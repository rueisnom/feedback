<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/684672">
    <body>
      <group id="684672">
        <trans-unit id="4e6c60b40db8e2958de1c62a00efabde299246e3" translate="yes" xml:space="preserve">
          <source>'big' object - with 1000 fields - you can perform test on your machine &lt;a href=&quot;https://jsbench.me/0pk7emfoy9/1&quot;&gt;HERE&lt;/a&gt;</source>
          <target state="translated">1000 개의 필드가있는 '큰'개체- &lt;a href=&quot;https://jsbench.me/0pk7emfoy9/1&quot;&gt;여기&lt;/a&gt; 에서 컴퓨터에서 테스트를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec950c295fbae882d685ccc9545dfed2b76e75ae" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://codepen.io/Hashbrown/pen/mEWadp&quot;&gt;DEMO&lt;/a&gt; working in Chrome and FF (I assume ES6 only)</source>
          <target state="translated">Chrome 및 FF에서 작동하는 &lt;a href=&quot;http://codepen.io/Hashbrown/pen/mEWadp&quot;&gt;DEMO&lt;/a&gt; (ES6 만 가정)</target>
        </trans-unit>
        <trans-unit id="474279ebe960067670817c8a1990ae8709a29b95" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_.forIn()&lt;/code&gt; iterates over &lt;em&gt;own and inherited&lt;/em&gt; enumerable properties of an object, while &lt;code&gt;_.forOwn()&lt;/code&gt; iterates only over &lt;em&gt;own&lt;/em&gt; properties of an object (basically checking against &lt;code&gt;hasOwnProperty&lt;/code&gt; function). For simple objects and object literals any of these methods will work fine.</source>
          <target state="translated">&lt;code&gt;_.forIn()&lt;/code&gt; 은 객체의 &lt;em&gt;고유하고 상속&lt;/em&gt; 가능한 열거 가능한 속성에 대해 반복되는 반면 &lt;code&gt;_.forOwn()&lt;/code&gt; 은 객체 &lt;em&gt;의 자체&lt;/em&gt; 속성에 대해서만 반복됩니다 (기본적으로 &lt;code&gt;hasOwnProperty&lt;/code&gt; 함수에 대해 검사). 간단한 객체와 객체 리터럴의 경우 이러한 방법 중 하나가 잘 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bd81e35af1823c9558691aedf06bde04281fb40c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Object.entries&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;Object.entries&lt;/code&gt;:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3dd5a193e7d69f45ee20d2f2016b15efdde5358d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Object.entries&lt;/code&gt;&lt;/strong&gt; [&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt;MDN&lt;/a&gt;, &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.entries&quot;&gt;spec&lt;/a&gt;] &amp;mdash; A function providing an array of the names &lt;em&gt;and&lt;/em&gt; values of an object's &lt;em&gt;own&lt;/em&gt;, &lt;em&gt;enumerable&lt;/em&gt; properties (each entry in the array is a &lt;code&gt;[name, value]&lt;/code&gt; array).</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Object.entries&lt;/code&gt; &lt;/strong&gt; [ &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt;MDN&lt;/a&gt; , &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.entries&quot;&gt;spec&lt;/a&gt; ] &amp;mdash; 객체 &lt;em&gt;자체&lt;/em&gt; 의 &lt;em&gt;열거 가능한&lt;/em&gt; 속성의 이름 &lt;em&gt;과&lt;/em&gt; 값 배열을 제공하는 함수입니다 (배열의 각 항목은 &lt;code&gt;[name, value]&lt;/code&gt; 배열입니다).</target>
        </trans-unit>
        <trans-unit id="ede21db207d84db7454d34051468010e74e5fcfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8a00e2a008aac31c6e4fc4fec09c0d8812aacc4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;&lt;/strong&gt; [&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames&quot;&gt;MDN&lt;/a&gt;, &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.getownpropertynames&quot;&gt;spec&lt;/a&gt;] &amp;mdash; A function providing an array of the names of an object's &lt;em&gt;own&lt;/em&gt; properties (even non-enumerable ones) whose names are strings.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt; &lt;/strong&gt; [ &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames&quot;&gt;MDN&lt;/a&gt; , &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.getownpropertynames&quot;&gt;spec&lt;/a&gt; ] &amp;mdash; 이름이 문자열 인 객체 &lt;em&gt;자체&lt;/em&gt; 속성 (열거 불가능한 속성)의 이름 배열을 제공하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="a5aec969b485f5159cd506af0dfcdf05706956c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a2b3837c88dfdd939e85634eaed657aebee7690f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;&lt;/strong&gt; [&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols&quot;&gt;MDN&lt;/a&gt;, &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols&quot;&gt;spec&lt;/a&gt;] &amp;mdash; A function providing an array of the names of an object's &lt;em&gt;own&lt;/em&gt; properties (even non-enumerable ones) whose names are Symbols.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt; &lt;/strong&gt; [ &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols&quot;&gt;MDN&lt;/a&gt; , &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols&quot;&gt;spec&lt;/a&gt; ] &amp;mdash; 이름이 Symbols 인 객체 &lt;em&gt;자체&lt;/em&gt; 속성의 이름 (열거 불가능한 속성)의 배열을 제공하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="1ebda5b16342bb06084a9bd4fd7be9e7eab81a71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Object.keys&lt;/code&gt;&lt;/strong&gt; [&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;MDN&lt;/a&gt;, &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.keys&quot;&gt;spec&lt;/a&gt;] &amp;mdash; A function providing an array of the names of an object's &lt;em&gt;own&lt;/em&gt;, &lt;em&gt;enumerable&lt;/em&gt; properties whose names are strings.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Object.keys&lt;/code&gt; &lt;/strong&gt; [ &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;MDN&lt;/a&gt; , &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.keys&quot;&gt;spec&lt;/a&gt; ] &amp;mdash; 이름이 문자열 인 객체 &lt;em&gt;자체&lt;/em&gt; 의 &lt;em&gt;열거 가능한&lt;/em&gt; 속성의 이름 배열을 제공하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="8b65922b96013e6bbea564cf2c7cb74b7bfe4dee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Object.keys&lt;/code&gt;&lt;/strong&gt;&lt;em&gt;(with a &lt;code&gt;for-of&lt;/code&gt; loop, but you can use any looping construct)&lt;/em&gt;:</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Object.keys&lt;/code&gt; &lt;/strong&gt; &lt;em&gt;( &lt;code&gt;for-of&lt;/code&gt; 루프가 있지만 루프 구성을 사용할 수 있음)&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="1754300f39456aee06698922c50acb14a9fe09f2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Object.values&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;Object.values&lt;/code&gt;:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dac8d73c86bc0d696fe7cea9ad377898c9d43b9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Object.values&lt;/code&gt;&lt;/strong&gt; [&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/values&quot;&gt;MDN&lt;/a&gt;, &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.values&quot;&gt;spec&lt;/a&gt;] &amp;mdash; A function providing an array of the &lt;em&gt;values&lt;/em&gt; of an object's &lt;em&gt;own&lt;/em&gt;, &lt;em&gt;enumerable&lt;/em&gt; properties.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Object.values&lt;/code&gt; &lt;/strong&gt; [ &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/values&quot;&gt;MDN&lt;/a&gt; , &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.values&quot;&gt;spec&lt;/a&gt; ] &amp;mdash; 객체의 &lt;em&gt;열거 가능한&lt;/em&gt; 속성 &lt;em&gt;값&lt;/em&gt; 의 배열을 제공하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="2da5969acc187f93fbeb365e2dccef6be6d0d7d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Reflect.ownKeys&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;Reflect.ownKeys&lt;/code&gt;:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3aab8dcea4dd592726faf4dc27e65e115ed78154" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;Reflect.ownKeys&lt;/code&gt;&lt;/strong&gt; [&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys&quot;&gt;MDN&lt;/a&gt;, &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-reflect.ownkeys&quot;&gt;spec&lt;/a&gt;] &amp;mdash; A function providing an array of the names of an object's &lt;em&gt;own&lt;/em&gt; properties (even non-enumerable ones), whether those names are strings or Symbols.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Reflect.ownKeys&lt;/code&gt; &lt;/strong&gt; [ &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys&quot;&gt;MDN&lt;/a&gt; , &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-reflect.ownkeys&quot;&gt;spec&lt;/a&gt; ] &amp;mdash; 객체의 속성 이름 (열거 가능하지 않은 속성)의 이름 배열이 문자열인지 기호인지를 나타내는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="0c83f91ec1f572afad87fb64a22dd5d2e7f873bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;for-in&lt;/code&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;code&gt;for-in&lt;/code&gt;:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be58acf7a12d4f8e428cd7ccb5c5c0d1a0e99dc8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;for-in&lt;/code&gt;&lt;/strong&gt; [&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;MDN&lt;/a&gt;, &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements&quot;&gt;spec&lt;/a&gt;] &amp;mdash; A loop structure that loops through the names of an object's &lt;em&gt;enumerable&lt;/em&gt; properties, including inherited ones, whose names are strings</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;for-in&lt;/code&gt; &lt;/strong&gt; [ &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;MDN&lt;/a&gt; , &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements&quot;&gt;spec&lt;/a&gt; ] &amp;mdash; 상속 된 속성을 비롯하여 객체의 &lt;em&gt;열거 가능한&lt;/em&gt; 속성의 이름을 문자열로 반복하는 루프 구조</target>
        </trans-unit>
        <trans-unit id="0ce88fb2e4b9a870187aeb2f4765051ba2131b1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;All properties&lt;/strong&gt;, including inherited non-enumerable ones:</source>
          <target state="translated">상속 불가능한 &lt;strong&gt;속성&lt;/strong&gt; 을 포함한 &lt;strong&gt;모든 속성&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea9f83ce98fb74a01138d2466873fea80b2ac7c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For those who don't like to shim, or mess with &lt;code&gt;prototype&lt;/code&gt; in general, feel free to make the function on window instead, calling it something like &lt;code&gt;getObjIterator()&lt;/code&gt; then;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;shim을 좋아하지 않거나 일반적으로 &lt;code&gt;prototype&lt;/code&gt; 을 엉망으로 만드는 사람들은 &lt;code&gt;getObjIterator()&lt;/code&gt; 와 같은 것을 호출하여 창에서 함수를 자유롭게 만들 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f29d8e49346eb8d4ca5b185798c9e93caa0374fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For-of with Object.keys() alternative:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Object.keys () 대안으로 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e6ba5897c67b5008b29e0f8adffc49356bf25e6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Here is the snippet:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;스 니펫은 다음과 같습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ec9e97aa9f9cb8b81f3d24df257f8e956e99de7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Lo-Dash&lt;/strong&gt; provides several methods for iterating over object properties. Basic &lt;a href=&quot;http://lodash.com/docs#forEach&quot;&gt;&lt;code&gt;_.forEach()&lt;/code&gt;&lt;/a&gt; (or it's alias &lt;code&gt;_.each()&lt;/code&gt;) is useful for looping through both objects and arrays, however (!) objects with &lt;code&gt;length&lt;/code&gt; property are treated like arrays, and to avoid this behavior it is suggested to use &lt;a href=&quot;http://lodash.com/docs#forIn&quot;&gt;&lt;code&gt;_.forIn()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://lodash.com/docs#forOwn&quot;&gt;&lt;code&gt;_.forOwn()&lt;/code&gt;&lt;/a&gt; methods (these also have &lt;code&gt;value&lt;/code&gt; argument coming first):</source>
          <target state="translated">&lt;strong&gt;Lo-Dash&lt;/strong&gt; 는 객체 속성을 반복하는 몇 가지 방법을 제공합니다. 기본 &lt;a href=&quot;http://lodash.com/docs#forEach&quot;&gt; &lt;code&gt;_.forEach()&lt;/code&gt; &lt;/a&gt; (또는 별명 &lt;code&gt;_.each()&lt;/code&gt; )는 객체와 배열을 반복하는 데 유용하지만 &lt;code&gt;length&lt;/code&gt; 속성을 가진 (!) 객체는 배열처럼 취급 되며이 동작을 피하려면 &lt;a href=&quot;http://lodash.com/docs#forIn&quot;&gt; &lt;code&gt;_.forIn()&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다. .forIn () 및 &lt;a href=&quot;http://lodash.com/docs#forOwn&quot;&gt; &lt;code&gt;_.forOwn()&lt;/code&gt; &lt;/a&gt; 메소드 ( &lt;code&gt;value&lt;/code&gt; 인수도 우선) :</target>
        </trans-unit>
        <trans-unit id="8a88d5e452dddbbc5bff670d7b08e484086a6743" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This method is not supported natively by Internet Explorer. You may consider using a Polyfill for older browsers.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 방법은 Internet Explorer에서 기본적으로 지원되지 않습니다. 구형 브라우저에는 Polyfill 사용을 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bcc2d79f81abc6bc319aa1e147e3a26bed87a03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPD:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPD:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ca69a725c1fda2284d76c860ae7bf0171359dc78" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using a &lt;code&gt;for-of&lt;/code&gt; on &lt;code&gt;Object.keys()&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;Object.keys()&lt;/code&gt; 에서 &lt;code&gt;for-of&lt;/code&gt; 사용&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="855d4dd01619da313af702cfb9f2ce2cf8e942d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using the new &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt;&lt;code&gt;Object.entries()&lt;/code&gt;&lt;/a&gt; method:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;새로운 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt; &lt;code&gt;Object.entries()&lt;/code&gt; &lt;/a&gt; 메소드 사용 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53790a84e8ab38f180b61a8110c686082d451b3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You can make ordinary object associations iterate! Behaving just like &lt;code&gt;Map&lt;/code&gt;s with direct use of the fancy &lt;code&gt;for...of&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;일반적인 객체 연결을 반복 할 수 있습니다!&lt;/strong&gt; &lt;strong&gt; &lt;code&gt;for...of&lt;/code&gt; 멋진 기능 을 직접 사용하여 &lt;code&gt;Map&lt;/code&gt; 과 같은 동작&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c7c568e20d9991ec9c2b339eef28dc0358005207" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;You can't just &lt;code&gt;for...of&lt;/code&gt; an &lt;code&gt;Object&lt;/code&gt; because it's not an iterator, and &lt;code&gt;for...index&lt;/code&gt; or &lt;code&gt;.forEach()&lt;/code&gt;ing the &lt;code&gt;Object.keys()&lt;/code&gt; is ugly/inefficient.&lt;br/&gt;
I'm glad most people are refraining from &lt;code&gt;for...in&lt;/code&gt; (with or without checking &lt;code&gt;.hasOwnProperty()&lt;/code&gt;) as that's also a bit messy, so other than my answer above, I'm here to say...&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt; &lt;code&gt;Object&lt;/code&gt; 는 반복자가 아니기 때문에 객체에 대해서만 할 수 없으며 &lt;code&gt;Object.keys()&lt;/code&gt; &lt;code&gt;for...index&lt;/code&gt; 또는 &lt;code&gt;.forEach()&lt;/code&gt; () 는 추악하고 비효율적입니다.&lt;/sub&gt; &lt;sub&gt;&lt;br/&gt;&lt;/sub&gt; &lt;sub&gt;나는 대부분의 사람들이 &lt;code&gt;.hasOwnProperty()&lt;/code&gt; 검사 여부에 관계없이) &lt;code&gt;for...in&lt;/code&gt; 자제하는 것이 기쁘다. 왜냐하면 위의 대답 외에는 약간 지저분하기 때문에 나는 여기에있다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2743df4fd6790c4b11ebcfecaa61faf6176c851f" translate="yes" xml:space="preserve">
          <source>After looking through all the answers in here, hasOwnProperty isn't required for my own usage because my json object is clean; there's really no sense in adding any additional javascript processing. This is all I'm using:</source>
          <target state="translated">여기에있는 모든 답변을 살펴본 후 내 json 객체가 깨끗하기 때문에 hasOwnProperty가 필요하지 않습니다. 추가 자바 스크립트 처리를 추가하는 것은 의미가 없습니다. 이것이 내가 사용하는 전부입니다.</target>
        </trans-unit>
        <trans-unit id="d23b6095239360e58d17c190e8570054390525cc" translate="yes" xml:space="preserve">
          <source>All information about how can you do an iterator and generator you can find at developer Mozilla page.</source>
          <target state="translated">반복자 및 생성기를 수행하는 방법에 대한 모든 정보는 개발자 Mozilla 페이지에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be3d1dffaaec51c8d5bac1fc878f97bc2de6ce72" translate="yes" xml:space="preserve">
          <source>Also, I know this is out of scope with this question but in 2011, ECMAScript 5.1 added the &lt;code&gt;forEach&lt;/code&gt; method for Arrays only which basically created a new improved way to loop through arrays while still leaving non iterable objects with the old verbose and confusing &lt;code&gt;for&lt;/code&gt; loop. But the odd part is that this new &lt;code&gt;forEach&lt;/code&gt; method does not support &lt;code&gt;break&lt;/code&gt; which led to all sorts of other problems.</source>
          <target state="translated">또한, 이것은이 질문의 범위를 벗어난 것을 알고 있지만 2011 년 ECMAScript 5.1은 배열에 &lt;code&gt;forEach&lt;/code&gt; 메소드 만 추가했습니다. . 그러나이 새로운 &lt;code&gt;forEach&lt;/code&gt; 방법은 모든 종류의 다른 문제를 야기하는 &lt;code&gt;break&lt;/code&gt; 을 지원하지 않는다는 것이 이상합니다.</target>
        </trans-unit>
        <trans-unit id="ddb599b84c5c70cad249ca23093fa251a6088148" translate="yes" xml:space="preserve">
          <source>Also, objects that comply with the iterable protocol can be used with the new ES2015 feature &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;spread&lt;/a&gt; operator thus we can read object property values as an array.</source>
          <target state="translated">또한 반복 가능한 프로토콜을 준수하는 객체를 새로운 ES2015 기능 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Spread_operator&quot;&gt;스프레드&lt;/a&gt; 연산자와 함께 사용할 수 있으므로 객체 속성 값을 배열로 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7169cd388b4e0ea06d66deafeab91e44ccebee64" translate="yes" xml:space="preserve">
          <source>And here are result for small objects on chrome</source>
          <target state="translated">그리고 여기 크롬의 작은 물체에 대한 결과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="26c29271527c52627e2a30548efdf0bbd9a1c238" translate="yes" xml:space="preserve">
          <source>As of 2015, we now have a better out of the box way to loop (and break) any object type (including Arrays and Strings). Here is what a loop in JavaScript will eventually look like when the recommendation becomes mainstream:</source>
          <target state="translated">2015 년 현재 모든 객체 유형 (배열 및 문자열 포함)을 루프 (및 중단)하는 방법이 개선되었습니다. 권장 사항이 주류가 될 때 JavaScript의 루프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b275d7374d2be31ecff1b4494870b6e516f02b51" translate="yes" xml:space="preserve">
          <source>At a glance here is what a JavaScript object loop look like before ECMA6:</source>
          <target state="translated">ECMA6 이전의 JavaScript 객체 루프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="49f65eee4a59f7212ca7868c00254253e471bfb3" translate="yes" xml:space="preserve">
          <source>Basically in 2011, there is not a real solid way to loop in JavaScript other than what many popular libraries (jQuery, Underscore, etc.) decided to re-implement.</source>
          <target state="translated">기본적으로 2011 년에는 많은 인기있는 라이브러리 (jQuery, Underscore 등)가 다시 구현하기로 결정한 것 이외의 JavaScript를 반복하는 확실한 방법이 없습니다.</target>
        </trans-unit>
        <trans-unit id="45a5f442b26367c7cb0baf8101619b75564033ea" translate="yes" xml:space="preserve">
          <source>Below snippets presents used solutions</source>
          <target state="translated">아래의 스 니펫은 사용 된 솔루션을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="3487c01cde5edf6b7390c08c1e99c3f7375241e6" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;Object.keys()&lt;/code&gt; and &lt;code&gt;Object.entries()&lt;/code&gt; iterate properties in the same order as a &lt;code&gt;for...in&lt;/code&gt; loop &lt;em&gt;but ignore the prototype chain&lt;/em&gt;. Only the object's own enumerable properties are iterated.</source>
          <target state="translated">&lt;code&gt;Object.keys()&lt;/code&gt; 및 &lt;code&gt;Object.entries()&lt;/code&gt; 는 &lt;code&gt;for...in&lt;/code&gt; 루프와 동일한 순서로 속성을 반복 &lt;em&gt;하지만 프로토 타입 체인은 무시합니다&lt;/em&gt; . 객체 자체의 열거 가능한 속성 만 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="1e0346498acc0470e9e83ec6c7e459d6ab78c307" translate="yes" xml:space="preserve">
          <source>Browser support you can see on &lt;a href=&quot;http://kangax.github.io/es5-compat-table/#Object.keys&quot;&gt;Kangax's compat table&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://kangax.github.io/es5-compat-table/#Object.keys&quot;&gt;Kangax의 compat 테이블에서&lt;/a&gt; 볼 수있는 브라우저 지원</target>
        </trans-unit>
        <trans-unit id="e7847daba29883c636ac7ac0fde37fec94bf0d76" translate="yes" xml:space="preserve">
          <source>But be very careful when using this kind of loop, because this will &lt;strong&gt;loop all the properties along the prototype chain&lt;/strong&gt;.</source>
          <target state="translated">그러나 이런 종류의 루프 &lt;strong&gt;를 사용할 때는 프로토 타입 체인을 따라 모든 속성을 반복&lt;/strong&gt; 하기 때문에 매우주의 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5d7cebc73a40081c8c8727aebf942e336258e8cb" translate="yes" xml:space="preserve">
          <source>But its important to know the capabilities you now have using es6!</source>
          <target state="translated">그러나 이제 es6을 사용하는 기능을 아는 것이 중요합니다!</target>
        </trans-unit>
        <trans-unit id="b536777ff175ae7f0dadd5ccfd9e78c00761a19e" translate="yes" xml:space="preserve">
          <source>Conclusions</source>
          <target state="translated">Conclusions</target>
        </trans-unit>
        <trans-unit id="432d4416f444775f0c61858bbd9701cb9bcf6474" translate="yes" xml:space="preserve">
          <source>Considering ES6 I'd like to add my own spoon of sugar and provide one more approach to iterate over object's properties.</source>
          <target state="translated">ES6을 고려하여 설탕 한 숟가락을 추가하고 객체의 속성을 반복하는 또 다른 접근법을 제공하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="bb0b024be65447537f1109f57128500da607b30c" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 adds &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">ECMAScript 6는 다음 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/a&gt; 추가합니다.</target>
        </trans-unit>
        <trans-unit id="aab6bac5701c96a921f7ef249212a3c6589127c4" translate="yes" xml:space="preserve">
          <source>ECMAScript 8 adds &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt;&lt;code&gt;Object.entries()&lt;/code&gt;&lt;/a&gt; which avoids having to look up each value in the original object:</source>
          <target state="translated">ECMAScript 8은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt; &lt;code&gt;Object.entries()&lt;/code&gt; &lt;/a&gt; 를 추가하여 원본 객체에서 각 값을 조회하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="f8e737a86e92eea815b3daf94f21793951fb689b" translate="yes" xml:space="preserve">
          <source>ES2017 will include &lt;code&gt;Object.entries&lt;/code&gt; which will make iterating over &lt;code&gt;[key, value]&lt;/code&gt; pairs in objects even more easier. It is now known that it will be a part of a standard according to the &lt;a href=&quot;https://github.com/tc39/proposal-object-values-entries&quot;&gt;ts39&lt;/a&gt; stage information.</source>
          <target state="translated">ES2017에는 &lt;code&gt;Object.entries&lt;/code&gt; 가 포함되어있어 객체의 &lt;code&gt;[key, value]&lt;/code&gt; 쌍을 더욱 쉽게 반복 할 수 있습니다. 이제 &lt;a href=&quot;https://github.com/tc39/proposal-object-values-entries&quot;&gt;ts39&lt;/a&gt; 스테이지 정보에 따라 표준의 일부가 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="cf8fd5dacacd6e6d99426d454618e6efc71eb3cf" translate="yes" xml:space="preserve">
          <source>Extend Implementations</source>
          <target state="translated">구현 확장</target>
        </trans-unit>
        <trans-unit id="9ad3df9ebcbaddf889827bce6d56caa2706bfaf9" translate="yes" xml:space="preserve">
          <source>For old browser you have &lt;a href=&quot;http://tokenposts.blogspot.com.au/2012/04/javascript-objectkeys-browser.html&quot;&gt;simple&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;full&lt;/a&gt; polyfill</source>
          <target state="translated">오래된 브라우저의 경우 &lt;a href=&quot;http://tokenposts.blogspot.com.au/2012/04/javascript-objectkeys-browser.html&quot;&gt;간단&lt;/a&gt; 하고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;완전한&lt;/a&gt; 폴리 필이 있습니다</target>
        </trans-unit>
        <trans-unit id="0bf13115eababbf2f614dc6364e0f23888e54c77" translate="yes" xml:space="preserve">
          <source>For those people who don't like the &quot;&lt;em&gt;for ... in&lt;/em&gt;&quot;-method:</source>
          <target state="translated">&quot;-방법에서&quot; &lt;em&gt;for ...&lt;/em&gt; 를 좋아하지 않는 사람들을 위해 :</target>
        </trans-unit>
        <trans-unit id="2268f901152e3f2d05e1c2ec2e3c22c82039761d" translate="yes" xml:space="preserve">
          <source>Generally all described methods have the same behaviour with any supplied objects. Besides using native &lt;code&gt;for..in&lt;/code&gt; loop will usually be &lt;em&gt;faster&lt;/em&gt; than any abstraction, such as &lt;code&gt;jQuery.each()&lt;/code&gt;, these methods are considerably easier to use, require less coding and provide better error handling.</source>
          <target state="translated">일반적으로 설명 된 모든 메소드는 제공된 오브젝트와 동일한 동작을 갖습니다. 네이티브 &lt;code&gt;for..in&lt;/code&gt; 루프를 사용하는 것은 일반적으로 &lt;code&gt;jQuery.each()&lt;/code&gt; 와 같은 추상화보다 &lt;em&gt;빠를&lt;/em&gt; 것입니다.이 메소드는 사용하기가 훨씬 쉽고 코딩이 덜 필요하며 더 나은 오류 처리 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3192335d6b047d6820b956a2f7d3d5ce3e4fb3bb" translate="yes" xml:space="preserve">
          <source>Here in 2018, your options for looping through an object's properties are (some examples follow the list):</source>
          <target state="translated">2018 년에는 객체의 속성을 반복하는 옵션이 있습니다 (일부 예제는 목록을 따릅니다).</target>
        </trans-unit>
        <trans-unit id="3600b23783a6ba3cad6df777ebfcbdec4cb1fb02" translate="yes" xml:space="preserve">
          <source>Here is another method to iterate through an object.</source>
          <target state="translated">다음은 객체를 반복하는 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d44521d61b9dbb64a50448918809bc483ebcd927" translate="yes" xml:space="preserve">
          <source>Hope It helped someone.</source>
          <target state="translated">희망 누군가를 도왔습니다.</target>
        </trans-unit>
        <trans-unit id="a70a77f4df60b00dbf4761fecee7e8eaf9d4703e" translate="yes" xml:space="preserve">
          <source>How do I loop through or enumerate a JavaScript object</source>
          <target state="translated">JavaScript 객체를 반복하거나 열거하는 방법</target>
        </trans-unit>
        <trans-unit id="4962635faad77468226beef9f94be30feb4bc4f4" translate="yes" xml:space="preserve">
          <source>I can modify the JavaScript object if necessary. My ultimate goal is to loop through some key value pairs and if possible I want to avoid using &lt;code&gt;eval&lt;/code&gt;.</source>
          <target state="translated">필요한 경우 JavaScript 객체를 수정할 수 있습니다. 내 궁극적 인 목표는 일부 키 값 쌍을 반복하는 것이며 가능한 경우 &lt;code&gt;eval&lt;/code&gt; 사용을 피하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="518b880018aedfc7045e2d34af28d36b3ffcb649" translate="yes" xml:space="preserve">
          <source>I have a JavaScript object like the following:</source>
          <target state="translated">다음과 같은 JavaScript 객체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aae5d3e79c225ee3d26350be843bb10799d7f06" translate="yes" xml:space="preserve">
          <source>I think it is time to update my answer to let it became even more fresher than it's now.</source>
          <target state="translated">나는 지금보다 더 신선 해지도록 내 대답을 업데이트해야 할 때라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="0a4080da4ca8055bce77c174c9c6711488472b3c" translate="yes" xml:space="preserve">
          <source>I would do this rather than checking &lt;code&gt;obj.hasOwnerProperty&lt;/code&gt; within every &lt;code&gt;for ... in&lt;/code&gt; loop.</source>
          <target state="translated">모든 &lt;code&gt;for ... in&lt;/code&gt; 루프 내에서 &lt;code&gt;obj.hasOwnerProperty&lt;/code&gt; 를 확인하는 대신이 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3854436e5e74dbacd9d3d55f9f6c2ddc431c9223" translate="yes" xml:space="preserve">
          <source>If anybody needs to loop through &lt;strong&gt;arrayObjects with condition&lt;/strong&gt;:</source>
          <target state="translated">누군가 &lt;strong&gt;조건이있는 arrayObject&lt;/strong&gt; 를 반복 해야하는 경우 :</target>
        </trans-unit>
        <trans-unit id="81b25a043bef98723984fe9cc8d2b96c70e6ec81" translate="yes" xml:space="preserve">
          <source>If you don't want to get conflicts with other forEach-Methods you can name it with your unique name.</source>
          <target state="translated">다른 forEach-Methods와 충돌하지 않으려면 고유 한 이름으로 이름을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d52c429155b878272be6a80be52e5d6ad0a333c" translate="yes" xml:space="preserve">
          <source>If you want &lt;strong&gt;all&lt;/strong&gt; of an object's properties, including non-enumerable inherited ones, you need to use a loop and &lt;code&gt;Object.getPrototypeOf&lt;/code&gt; [&lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf&quot;&gt;MDN&lt;/a&gt;, &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.getprototypeof&quot;&gt;spec&lt;/a&gt;] and use &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt;, &lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt;, or &lt;code&gt;Reflect.ownKeys&lt;/code&gt; on each object in the prototype chain (example at the bottom of this answer).</source>
          <target state="translated">열거 할 수없는 상속 된 속성을 포함하여 &lt;strong&gt;모든&lt;/strong&gt; 객체의 속성을 원할 경우 루프 및 &lt;code&gt;Object.getPrototypeOf&lt;/code&gt; [ &lt;a href=&quot;https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf&quot;&gt;MDN&lt;/a&gt; , &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-object.getprototypeof&quot;&gt;spec&lt;/a&gt; ]을 사용하고 &lt;code&gt;Object.getOwnPropertyNames&lt;/code&gt; , &lt;code&gt;Object.getOwnPropertySymbols&lt;/code&gt; 또는 &lt;code&gt;Reflect.ownKeys&lt;/code&gt; 를 사용해야 합니다. 프로토 타입 체인 (이 답변의 맨 아래에있는 예).</target>
        </trans-unit>
        <trans-unit id="e064bea268f729cfd8e9b622bb27d0d02946c767" translate="yes" xml:space="preserve">
          <source>If you want to iterate over &lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Enumerable_attribute&quot;&gt;non-enumerable properties&lt;/a&gt;&lt;/strong&gt; as well, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames&quot;&gt;&lt;code&gt;Object.getOwnPropertyNames(obj)&lt;/code&gt;&lt;/a&gt; to return an array of all properties (enumerable or not) found directly upon a given object.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty#Enumerable_attribute&quot;&gt;열거&lt;/a&gt;&lt;/strong&gt; 할 수 &lt;strong&gt;없는 속성&lt;/strong&gt; 에 대해서도 반복하려면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames&quot;&gt; &lt;code&gt;Object.getOwnPropertyNames(obj)&lt;/code&gt; &lt;/a&gt; 를 사용하여 지정된 객체에서 직접 찾은 모든 속성의 배열 (열거 가능 여부 ) 을 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f6358b4744c76d0b63e5ea4860e57dd30d61fc8" translate="yes" xml:space="preserve">
          <source>If you work with &lt;strong&gt;jQuery&lt;/strong&gt;, you may use &lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt;&lt;code&gt;jQuery.each()&lt;/code&gt;&lt;/a&gt; method. It can be used to seamlessly iterate over both objects and arrays:</source>
          <target state="translated">&lt;strong&gt;jQuery로&lt;/strong&gt; 작업하는 경우 &lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt; &lt;code&gt;jQuery.each()&lt;/code&gt; &lt;/a&gt; 메소드를 사용할 수 있습니다. 객체와 배열을 완벽하게 반복하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f897e5ce6ceaf2b1f2ce70c631d9cebac75e9cf" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Underscore.js&lt;/strong&gt; you can find method &lt;a href=&quot;http://underscorejs.org/#each&quot;&gt;&lt;code&gt;_.each()&lt;/code&gt;&lt;/a&gt;, which iterates over a list of elements, yielding each in turn to a supplied function (pay attention to the order of arguments in &lt;em&gt;iteratee&lt;/em&gt; function!):</source>
          <target state="translated">&lt;strong&gt;Underscore.js에서&lt;/strong&gt; &lt;a href=&quot;http://underscorejs.org/#each&quot;&gt; &lt;code&gt;_.each()&lt;/code&gt; &lt;/a&gt; 메소드를 찾을 수 있습니다.이 메소드는 요소 목록을 반복하여 제공된 함수를 차례로 생성합니다 ( &lt;em&gt;iteratee&lt;/em&gt; 함수의 인수 순서에주의하십시오!).</target>
        </trans-unit>
        <trans-unit id="2d20cf1ada379d6e39f32c37a72028e9238c013f" translate="yes" xml:space="preserve">
          <source>In ECMAScript 5 you have new approach in iteration fields of literal - &lt;code&gt;Object.keys&lt;/code&gt;</source>
          <target state="translated">ECMAScript 5에서는 리터럴 &lt;code&gt;Object.keys&lt;/code&gt; 의 반복 필드에 새로운 접근 방식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c7274ad3c87fa15ab98b9cce65eea76c9a19fd" translate="yes" xml:space="preserve">
          <source>In ES6 we have well-known symbols to expose some previously internal methods, you can use it to define how iterators work for this object:</source>
          <target state="translated">ES6에는 이전에 내부 메소드를 노출하는 잘 알려진 기호가 있으며,이 기호를 사용하여이 객체에서 반복자가 작동하는 방식을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e1fdbb2aaaf6c0ad99feef360af0adf0a7ed96a" translate="yes" xml:space="preserve">
          <source>In fact, with this shim, if you still wanted to take advantage of Map's other functionality (without shimming them all in) but still wanted to use the neat object notation, since objects are now iterable you can now just make a Map from it!</source>
          <target state="translated">사실,이 심으로, 당신이 여전히 맵의 다른 기능을 활용하고 싶었지만 (모두 숨기지 않고) 여전히 깔끔한 객체 표기법을 사용하고 싶었다면, 객체는 이제 반복 가능하기 때문에 이제 맵을 만들 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="439b07330c042796d437d89c30acfaa93b3e4fe9" translate="yes" xml:space="preserve">
          <source>In latest ES script, you can do something like this:</source>
          <target state="translated">최신 ES 스크립트에서는 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8f340ce3b448e2f38cbaf0946576afd1c5832b1" translate="yes" xml:space="preserve">
          <source>In my Firefox I have following results</source>
          <target state="translated">내 Firefox에서 다음과 같은 결과가 있습니다</target>
        </trans-unit>
        <trans-unit id="f91575a8eebebd143c3dcd78381f6c6cf67dd7be" translate="yes" xml:space="preserve">
          <source>It's interesting people in these answers have touched on both &lt;code&gt;Object.keys()&lt;/code&gt; and &lt;code&gt;for...of&lt;/code&gt; but never combined them:</source>
          <target state="translated">이 답변에서 사람들이 &lt;code&gt;Object.keys()&lt;/code&gt; 와 &lt;code&gt;for...of&lt;/code&gt; 만졌지만 결코 결합하지 않은 것은 흥미 롭습니다.</target>
        </trans-unit>
        <trans-unit id="6791e0260346d559f245d4a88a53a01351732e2d" translate="yes" xml:space="preserve">
          <source>Let's we have &lt;code&gt;book&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;book&lt;/code&gt; 객체를 보자.</target>
        </trans-unit>
        <trans-unit id="a707aa190f760150c8ff8256bff3171e748227a0" translate="yes" xml:space="preserve">
          <source>Like:</source>
          <target state="translated">Like:</target>
        </trans-unit>
        <trans-unit id="98e4701c0ce58626eabd986c3ab94ed192ef3071" translate="yes" xml:space="preserve">
          <source>Loops can be pretty interesting when using pure JavaScript. It seems that only ECMA6 (New 2015 JavaScript specification) got the loops under control. Unfortunately as I'm writing this, both Browsers and popular Integrated development environment (IDE) are still struggling to support completely the new bells and whistles.</source>
          <target state="translated">순수한 JavaScript를 사용할 때 루프는 꽤 흥미로울 수 있습니다. ECMA6 (New 2015 JavaScript 사양)만이 루프를 제어하고있는 것 같습니다. 불행히도이 글을 쓰는 동안 브라우저와 널리 사용되는 통합 개발 환경 (IDE)은 여전히 ​​새로운 종과 휘파람을 완벽하게 지원하기 위해 고심하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="13e7186984f9711a8852f884dfd2f7ae96b20b3f" translate="yes" xml:space="preserve">
          <source>MDN DOCS Object.values()</source>
          <target state="translated">MDN DOCS Object.values ​​()</target>
        </trans-unit>
        <trans-unit id="c33ee070c0554e63382502c3b891cc91bc88f40b" translate="yes" xml:space="preserve">
          <source>More information you can see on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;MDN&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;MDN에서&lt;/a&gt; 볼 수있는 추가 정보</target>
        </trans-unit>
        <trans-unit id="8ce2cf512eb2d280fcb6e6a8408306774abf7584" translate="yes" xml:space="preserve">
          <source>My choice is below as a faster solution in current versions of browsers (Chrome30, IE10, FF25)</source>
          <target state="translated">아래는 현재 버전의 브라우저 (Chrome30, IE10, FF25)에서 더 빠른 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="9283e1080a0ba71402309d9223ad40bc03462179" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;key&lt;/code&gt; will not take on the value of the property, it's just an index value.</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 는 속성 값을 가져 가지 않으며 인덱스 값일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="c478e37ee66a6eba87efd093d99010af9d03a121" translate="yes" xml:space="preserve">
          <source>Note that most browsers won't support the code above as of June 18th 2016. Even in Chrome you need to enable this special flag for it to work: &lt;code&gt;chrome://flags/#enable-javascript-harmony&lt;/code&gt;</source>
          <target state="translated">대부분의 브라우저는 2016 년 6 월 18 일 현재 위의 코드를 지원하지 않습니다. Chrome에서도 작동하려면이 특수 플래그를 활성화해야합니다. &lt;code&gt;chrome://flags/#enable-javascript-harmony&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="512c928855a3a4800967b483956e8c6009db237a" translate="yes" xml:space="preserve">
          <source>Note: you can do this over arrays, but you'll iterate over the &lt;code&gt;length&lt;/code&gt; and other properties, too.</source>
          <target state="translated">참고 : 배열을 통해이 작업을 수행 할 수 있지만 &lt;code&gt;length&lt;/code&gt; 및 기타 속성도 반복합니다.</target>
        </trans-unit>
        <trans-unit id="dc8ff6e94fd31b05b3bd0d0a7bbbe0463493bea0" translate="yes" xml:space="preserve">
          <source>Notice the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;code&gt;for-of&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;code&gt;for-in&lt;/code&gt;&lt;/a&gt;, if not used it will return undefined on named properties, and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;&lt;code&gt;Object.keys()&lt;/code&gt;&lt;/a&gt; ensures the use of only the object's own properties without the whole prototype-chain properties</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt; &lt;code&gt;for-in&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt; &lt;code&gt;for-of&lt;/code&gt; &lt;/a&gt; 를 사용하면 이름이 지정된 속성에서 undefined를 반환하고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt; &lt;code&gt;Object.keys()&lt;/code&gt; &lt;/a&gt; 는 전체 프로토 타입 체인 속성없이 객체 자체 속성 만 사용하도록합니다.</target>
        </trans-unit>
        <trans-unit id="a1c26ca5b91d4a51f8174e0bc4f8e68ec7cdcc94" translate="yes" xml:space="preserve">
          <source>Now I want to loop through all &lt;code&gt;p&lt;/code&gt; elements (&lt;code&gt;p1&lt;/code&gt;, &lt;code&gt;p2&lt;/code&gt;, &lt;code&gt;p3&lt;/code&gt;...) And get their keys and values. How can I do that?</source>
          <target state="translated">이제 모든 &lt;code&gt;p&lt;/code&gt; 요소 ( &lt;code&gt;p1&lt;/code&gt; , &lt;code&gt;p2&lt;/code&gt; , &lt;code&gt;p3&lt;/code&gt; ...)를 반복하고 키와 값을 가져옵니다. 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="7ea052b7cd7dd8fe0b68bae7e15db15d394b4554" translate="yes" xml:space="preserve">
          <source>Now you can just call it as an ordinary function, nothing else is affected</source>
          <target state="translated">이제 일반 함수로 호출하면 다른 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f8fe217f1f92ae27a4182945fcd57151d97a8b18" translate="yes" xml:space="preserve">
          <source>Now, you can simple call:</source>
          <target state="translated">이제 간단하게 전화를 걸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4911ec574e940846f79565123dd16e79b73fa664" translate="yes" xml:space="preserve">
          <source>Nowadays many well known JavaScript libraries provide their own methods for iterating over collections, i.e. over &lt;em&gt;arrays&lt;/em&gt;, &lt;em&gt;objects&lt;/em&gt;, and &lt;em&gt;array-like objects&lt;/em&gt;. These methods are convenient to use and are entirely compatible with any browser.</source>
          <target state="translated">오늘날 많은 잘 알려진 JavaScript 라이브러리는 컬렉션, 즉 &lt;em&gt;배열&lt;/em&gt; , &lt;em&gt;객체&lt;/em&gt; 및 &lt;em&gt;배열 유사 객체에&lt;/em&gt; 대해 반복하는 고유 한 메소드를 제공 &lt;em&gt;합니다&lt;/em&gt; . 이 방법은 사용하기 편리하며 모든 브라우저와 완전히 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="629350d753d476936775753f4a2c85036cbe029a" translate="yes" xml:space="preserve">
          <source>Object keys iteration</source>
          <target state="translated">객체 키 반복</target>
        </trans-unit>
        <trans-unit id="7e52410ffda30839d3fcb0ba5a2e71cf9dcfbcb1" translate="yes" xml:space="preserve">
          <source>Object properties can be &lt;em&gt;enumerable&lt;/em&gt; or &lt;em&gt;non-enumerable&lt;/em&gt;. Non-enumerable properties are left out of lots of property enumerations/arrays.</source>
          <target state="translated">객체 속성은 &lt;em&gt;열거 가능&lt;/em&gt; 하거나 &lt;em&gt;열거 불가능할&lt;/em&gt; 수 있습니다. 열거 할 수없는 속성은 많은 속성 열거 / 배열에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="22994f821def1dd2970557b55c917d3dfde9d7b8" translate="yes" xml:space="preserve">
          <source>Object properties can be &lt;em&gt;own&lt;/em&gt; (the property is on the object itself) or &lt;em&gt;inherited&lt;/em&gt; (not on the object itself, on one of its prototypes).</source>
          <target state="translated">객체 속성은 &lt;em&gt;소유&lt;/em&gt; (속성이 객체 자체에 있음) 또는 &lt;em&gt;상속&lt;/em&gt; (개체 자체가 아닌 프로토 타입 중 하나) 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be1c89ae8f0ef034137eab5e3b5a95b39860d1ac" translate="yes" xml:space="preserve">
          <source>Object.keys approach took 40.21101451665163 milliseconds.</source>
          <target state="translated">Object.keys 접근에는 40.21101451665163 밀리 초가 걸렸습니다.</target>
        </trans-unit>
        <trans-unit id="5686d9a694d8bcf58a2ec40ae647cbc33eb4e0e4" translate="yes" xml:space="preserve">
          <source>Object.keys(obj) : Array</source>
          <target state="translated">Object.keys (obj) : 배열</target>
        </trans-unit>
        <trans-unit id="9bd98e631eeca19ad778683f0b597ef60c3d91d2" translate="yes" xml:space="preserve">
          <source>Ok here is a code:</source>
          <target state="translated">여기 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="48821ddde845a8127856b5197412d3e9b98d849f" translate="yes" xml:space="preserve">
          <source>Only JavaScript code without dependencies:</source>
          <target state="translated">의존성이없는 JavaScript 코드 만 :</target>
        </trans-unit>
        <trans-unit id="1fc344e92e022043d22ed9f86b1ba91fec95875c" translate="yes" xml:space="preserve">
          <source>Or if you know the power of ES6 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;generators&lt;/a&gt;, so you certainly can make the code above much shorter.</source>
          <target state="translated">또는 ES6 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function*&quot;&gt;생성기&lt;/a&gt; 의 성능을 알고 있다면 코드를 훨씬 더 짧게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c5e92a1bdcfc9b09bb1412b1c5936ad6f1f5dbe" translate="yes" xml:space="preserve">
          <source>Or you can use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;destructuring&lt;/a&gt; assignment:</source>
          <target state="translated">또는 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;파괴&lt;/a&gt; 할당을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3cdf0ea02f23eab1dafc7dfa0f6225f546d3bb5" translate="yes" xml:space="preserve">
          <source>PS. on Chrome the difference even bigger &lt;a href=&quot;http://codepen.io/dsheiko/pen/JdrqXa&quot;&gt;http://codepen.io/dsheiko/pen/JdrqXa&lt;/a&gt;</source>
          <target state="translated">추신. 크롬에서 더 큰 차이 &lt;a href=&quot;http://codepen.io/dsheiko/pen/JdrqXa&quot;&gt;http://codepen.io/dsheiko/pen/JdrqXa&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9a7d963cb944872745e42eebdfeb267c1df5c1bf" translate="yes" xml:space="preserve">
          <source>PS2: In ES6 (EcmaScript 2015) you can iterate iterable object nicer:</source>
          <target state="translated">PS2 : ES6 (EcmaScript 2015)에서는 반복 가능한 객체를 더 잘 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="ad5f5605ae02a7ee104521831414d243db1ba749" translate="yes" xml:space="preserve">
          <source>Performance tests was performed for</source>
          <target state="translated">성능 테스트가 수행되었습니다</target>
        </trans-unit>
        <trans-unit id="d5f737ce74fd4e194d4acc8a93050d00e0d3a46c" translate="yes" xml:space="preserve">
          <source>Preface:</source>
          <target state="translated">Preface:</target>
        </trans-unit>
        <trans-unit id="e51f130523ffae59f445c83fb99c53b717a2112b" translate="yes" xml:space="preserve">
          <source>Property names can be strings or Symbols. Properties whose names are Symbols are left out of lots of property enumerations/arrays.</source>
          <target state="translated">속성 이름은 문자열 또는 기호 일 수 있습니다. 이름이 기호 인 속성은 많은 속성 열거 / 배열에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">코드 스 니펫 표시</target>
        </trans-unit>
        <trans-unit id="ccd8d63992692c4fb1b10a7b977cc306b7a354db" translate="yes" xml:space="preserve">
          <source>Since es2015 is getting more and more popular I am posting this answer which include usage of generator and iterator to smoothly iterate through &lt;code&gt;[key, value]&lt;/code&gt; pairs. As it is possible in other languages for instance Ruby.</source>
          <target state="translated">es2015가 점점 인기를 얻고 있기 때문에 &lt;code&gt;[key, value]&lt;/code&gt; 쌍을 원활하게 반복하기 위해 generator와 iterator의 사용법을 포함하는이 답변을 게시하고 있습니다. 다른 언어에서도 가능합니다 (예 : Ruby).</target>
        </trans-unit>
        <trans-unit id="7fd310e39b9c5384f400f2a00d5e814ddeb587d8" translate="yes" xml:space="preserve">
          <source>Since plain JS object isn't &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;iterable&lt;/a&gt; just out of box, we aren't able to use &lt;code&gt;for..of&lt;/code&gt; loop for iterating over its content. But no one can stop us &lt;strong&gt;to make it iterable&lt;/strong&gt;.</source>
          <target state="translated">평범한 JS 객체는 상자 밖에서 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Iteration_protocols&quot;&gt;반복&lt;/a&gt; 할 수 &lt;code&gt;for..of&lt;/code&gt; 내용을 반복하는 데 for..of 루프를 사용할 수 없습니다. 그러나 아무도 &lt;strong&gt;그것을 반복 가능하게 만들&lt;/strong&gt; 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="1426a0b62263371d020ccb96a30b630d270b2473" translate="yes" xml:space="preserve">
          <source>Since we've made it we can use it this way:</source>
          <target state="translated">우리가 만들었으므로 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dfdb00ae3e82ded6da686bffc206325c58d0800" translate="yes" xml:space="preserve">
          <source>So it gives the same list of keys as you intend by testing each object key with hasOwnProperty. You don't need that extra test operation than and &lt;code&gt;Object.keys( obj ).forEach(function( key ){})&lt;/code&gt; is supposed to be faster. Let's prove it:</source>
          <target state="translated">따라서 hasOwnProperty로 각 객체 키를 테스트하여 원하는 키 목록을 제공합니다. &lt;code&gt;Object.keys( obj ).forEach(function( key ){})&lt;/code&gt; 보다 추가 테스트 작업이 더 빠를 필요는 없습니다. 그것을 증명합시다 :</target>
        </trans-unit>
        <trans-unit id="4645d5a0a5468109c2f88c910e1e58294f6beb7c" translate="yes" xml:space="preserve">
          <source>So long as you include my shim below:</source>
          <target state="translated">아래에 심을 포함시키는 한 :</target>
        </trans-unit>
        <trans-unit id="5631c195805d78cb0d5be22d5f2c5a9ee8dc79d1" translate="yes" xml:space="preserve">
          <source>Sure, you can apply such behavior for all objects with making &lt;code&gt;Object&lt;/code&gt; iterable on &lt;code&gt;prototype&lt;/code&gt; level.</source>
          <target state="translated">물론 &lt;code&gt;prototype&lt;/code&gt; 수준에서 &lt;code&gt;Object&lt;/code&gt; 를 반복 가능하게하여 모든 객체에 이러한 동작을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9448e2a156ab791737a33c4161a27378a271d13f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Object.keys()&lt;/code&gt; method returns an array of a given object's own enumerable properties. Read more about it &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;Object.keys()&lt;/code&gt; 메소드는 주어진 객체 자체의 열거 가능한 속성의 배열을 반환합니다. 자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;여기를&lt;/a&gt; 참조 하십시오</target>
        </trans-unit>
        <trans-unit id="68bedeb904864bc6eac4936194bfc1432a121a4d" translate="yes" xml:space="preserve">
          <source>The question won't be complete if we don't mention about alternative methods for looping through objects.</source>
          <target state="translated">객체를 반복하는 대체 방법에 대해 언급하지 않으면 질문이 완료되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="707d8f25499ef81c0afd56a2467cd54972a9756d" translate="yes" xml:space="preserve">
          <source>There's no reason why that wouldn't work.</source>
          <target state="translated">그것이 효과가없는 이유는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a2aa295e2f8f8018137cbb4a177ff7f8b5f104f" translate="yes" xml:space="preserve">
          <source>Therefore, when using for-in loops, always make use of the &lt;code&gt;hasOwnProperty&lt;/code&gt; method to determine if the current property in iteration is really a property of the object you're checking on:</source>
          <target state="translated">따라서 for-in 루프를 사용할 때는 항상 &lt;code&gt;hasOwnProperty&lt;/code&gt; 메소드를 사용하여 반복의 현재 특성이 실제로 확인중인 오브젝트의 특성인지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="6573ff7791abb12235eaf772c627e522459492a8" translate="yes" xml:space="preserve">
          <source>Today 2020.03.06 I perform tests of chosen solutions on Chrome v80.0, Safari v13.0.5 and Firefox 73.0.1 on MacOs High Sierra v10.13.6</source>
          <target state="translated">오늘 2020.03.06 MacOs High Sierra v10.13.6에서 Chrome v80.0, Safari v13.0.5 및 Firefox 73.0.1에서 선택한 솔루션의 테스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b7fdbc9f9f0e814bb215987071150223e78ef8b9" translate="yes" xml:space="preserve">
          <source>Under ECMAScript 5, you can combine &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;&lt;code&gt;Object.keys()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;Array.prototype.forEach()&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">ECMAScript 5에서 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt; &lt;code&gt;Object.keys()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; &lt;/a&gt; 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fba73f56e7147c5069eb5bb50bfaa3827fd326bf" translate="yes" xml:space="preserve">
          <source>Until this becomes the new standard, the old method can still be used but there are also alternatives in popular libraries or even &lt;a href=&quot;https://github.com/nbouvrette/forEach&quot;&gt;lightweight alternatives&lt;/a&gt; for those who aren't using any of these libraries.</source>
          <target state="translated">이것이 새로운 표준이 될 때까지 기존 방법을 계속 사용할 수 있지만 인기있는 라이브러리의 &lt;a href=&quot;https://github.com/nbouvrette/forEach&quot;&gt;대안&lt;/a&gt; 이나 이러한 라이브러리를 사용하지 않는 사람들을위한 간단한 대안 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2223bf1aacb8d79e11777d0049d9e90a5b8f254" translate="yes" xml:space="preserve">
          <source>Welcome to the future.</source>
          <target state="translated">미래에 오신 것을 환영합니다.</target>
        </trans-unit>
        <trans-unit id="cc674edcf6e433a211df7e9e557f550332aec2a1" translate="yes" xml:space="preserve">
          <source>With all of them except &lt;code&gt;for-in&lt;/code&gt;, you'd use some kind of looping construct on the array (&lt;code&gt;for&lt;/code&gt;, &lt;code&gt;for-of&lt;/code&gt;, &lt;code&gt;forEach&lt;/code&gt;, etc.).</source>
          <target state="translated">&lt;code&gt;for-in&lt;/code&gt; 을 제외한 모든 것을 사용하면 배열에서 ( &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;for-of&lt;/code&gt; , &lt;code&gt;forEach&lt;/code&gt; 등) 일종의 반복 구성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1c0d75033729d34abf569f3b3ddaf6a1bdbed218" translate="yes" xml:space="preserve">
          <source>Without having to create a real Map object that doesn't have the nice syntactic sugar.</source>
          <target state="translated">좋은 구문 설탕이없는 실제 Map 객체를 만들 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="2afea76e635096801d93bc41fb6a5536f18c15fa" translate="yes" xml:space="preserve">
          <source>You can add a simple &lt;em&gt;forEach&lt;/em&gt; function to all objects, so you can automatically loop through any object:</source>
          <target state="translated">모든 객체에 간단한 &lt;em&gt;forEach&lt;/em&gt; 함수를 추가 할 수 있으므로 모든 객체를 자동으로 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8e306872c5b3d04ad61153a998ec79ee2e2e06f" translate="yes" xml:space="preserve">
          <source>You can also use Object.keys() and iterate over the object keys like below to get the value:</source>
          <target state="translated">Object.keys ()를 사용하여 아래와 같이 객체 키를 반복하여 값을 얻을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9df7817cd06171f45a723354756f26620f580de5" translate="yes" xml:space="preserve">
          <source>You can check out &lt;a href=&quot;http://www.es6fiddle.net/isksh68n/&quot;&gt;&lt;strong&gt;JSFiddle&lt;/strong&gt;&lt;/a&gt; with all code I've provided above.</source>
          <target state="translated">위에서 제공 한 모든 코드로 &lt;a href=&quot;http://www.es6fiddle.net/isksh68n/&quot;&gt;&lt;strong&gt;JSFiddle&lt;/strong&gt;&lt;/a&gt; 을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f092bb3d231117e16875d827dbcb4f592ee6ddd3" translate="yes" xml:space="preserve">
          <source>You can combine &lt;code&gt;for...of&lt;/code&gt;, destructuring, and &lt;code&gt;Object.entries&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;for...of&lt;/code&gt; , destructuring 및 &lt;code&gt;Object.entries&lt;/code&gt; 를 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5835361bd2e75d290192b51cf230550d40991036" translate="yes" xml:space="preserve">
          <source>You can compare performance of this approach with different implementations on &lt;a href=&quot;http://jsperf.com/&quot;&gt;jsperf.com&lt;/a&gt;:</source>
          <target state="translated">이 접근법의 성능을 &lt;a href=&quot;http://jsperf.com/&quot;&gt;jsperf.com의&lt;/a&gt; 다른 구현과 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07ea959fb6adebc978c0f011c09d6fbb38b48283" translate="yes" xml:space="preserve">
          <source>You can find more about usage on
&lt;a href=&quot;https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt;MDN&lt;/a&gt; page</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/pl/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt;MDN&lt;/a&gt; 페이지에서 사용법에 대한 자세한 내용을 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b39c85fe2996ce2b1cb62746063fa3f6b9c3aea2" translate="yes" xml:space="preserve">
          <source>You can just iterate over it like:</source>
          <target state="translated">다음과 같이 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2bacd14cdcb3c8381ec25749f21eb003ffda72a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;code&gt;for-in&lt;/code&gt;&lt;/a&gt; loop as shown by others. However, you also have to make sure that the key you get is an actual property of an object, and doesn't come from the prototype.</source>
          <target state="translated">다른 사람들이 보여주는 것처럼 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt; &lt;code&gt;for-in&lt;/code&gt; &lt;/a&gt; 루프를 사용할 수 있습니다. 그러나 얻는 키가 객체의 실제 속성이며 프로토 타입에서 가져 오지 않았는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="40252eae4706cceffc619189db0a17d754ce42ed" translate="yes" xml:space="preserve">
          <source>You have to use the &lt;strong&gt;for-in loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;for-in 루프&lt;/strong&gt; 를 사용해야합니다</target>
        </trans-unit>
        <trans-unit id="6730e3f19253e5d08b76d3651b7182a3df338152" translate="yes" xml:space="preserve">
          <source>and for keys ( allready answerd before me here )</source>
          <target state="translated">그리고 열쇠를 위해 (이미 나 앞에서 대답했다)</target>
        </trans-unit>
        <trans-unit id="7a947b3af5f007df2c90a38c8e173c0e9affdfa7" translate="yes" xml:space="preserve">
          <source>for...in/hasOwnProperty approach took 98.26163508463651 milliseconds.</source>
          <target state="translated">for ... in / hasOwnProperty 접근 방식에 98.26163508463651 밀리 초가 걸렸습니다.</target>
        </trans-unit>
        <trans-unit id="1dad84041e1f4a1ac2b61ea3b839a03f52f00ebd" translate="yes" xml:space="preserve">
          <source>it return the an array of the object values and it not extract values from Prototype!!</source>
          <target state="translated">객체 값의 배열을 반환하고 프로토 타입에서 값을 추출하지 않습니다 !!</target>
        </trans-unit>
        <trans-unit id="68be3091c9ded638c69cfcfde91d5f8203202b2c" translate="yes" xml:space="preserve">
          <source>object literal iteration</source>
          <target state="translated">객체 리터럴 반복</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="8972d45f7e8c1e4586030e6383fab869625b067e" translate="yes" xml:space="preserve">
          <source>performance comparison for all most popular cases in this question on &lt;code&gt;perfjs.info&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;perfjs.info&lt;/code&gt; 에서이 질문에 가장 인기있는 모든 경우의 성능 비교 :</target>
        </trans-unit>
        <trans-unit id="4e4ac781c74f3de12b85437e0ce21526690c5030" translate="yes" xml:space="preserve">
          <source>retrieves all string-valued keys of all enumerable own (non-inherited) properties.</source>
          <target state="translated">열거 가능한 모든 고유 한 (상속되지 않은) 속성의 모든 문자열 값 키를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="9d3fd172d54a8a1b0e808b84e2f2068fcff097b0" translate="yes" xml:space="preserve">
          <source>since ES06 you can get the values of an object as array with</source>
          <target state="translated">ES06부터 객체의 값을 배열로 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba86877b9e6415b124321f46f5e12940e8b3aa72" translate="yes" xml:space="preserve">
          <source>small object - with 3 fields - you can perform test on your machine &lt;a href=&quot;https://jsbench.me/wok7em87k8/1&quot;&gt;HERE&lt;/a&gt;</source>
          <target state="translated">3 개의 필드가있는 작은 물체- &lt;a href=&quot;https://jsbench.me/wok7em87k8/1&quot;&gt;여기&lt;/a&gt; 에서 기계를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b00365aaf30d8e7d329d80bbae34538a7af63af" translate="yes" xml:space="preserve">
          <source>solution C is slow for big objects and medium-slow for small objects</source>
          <target state="translated">솔루션 C는 큰 물체의 경우 느리고 작은 물체의 경우 중간 느립니다.</target>
        </trans-unit>
        <trans-unit id="5929799c0c51a9fbea02779e3db64be6923384d9" translate="yes" xml:space="preserve">
          <source>solutions based on &lt;code&gt;for-in&lt;/code&gt; (A,B) are fast (or fastest) for all browsers for big and small objects</source>
          <target state="translated">크고 작은 객체의 모든 브라우저에 대해 (A, B) &lt;code&gt;for-in&lt;/code&gt; (A, B) 기반 솔루션이 빠르거나 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ad6295bc425c88fcc6cc0617c8f1752b188249be" translate="yes" xml:space="preserve">
          <source>solutions based on explicit index &lt;code&gt;i&lt;/code&gt; (J,K) are quite fast on all browsers for small objects (for firefox also fast for big ojbects but medium fast on other browsers)</source>
          <target state="translated">명시 적 색인 &lt;code&gt;i&lt;/code&gt; (J, K) 기반 솔루션은 작은 객체의 모든 브라우저에서 매우 빠릅니다 (Firefox의 경우 큰 객체에서는 빠르지 만 다른 브라우저에서는 보통 빠름)</target>
        </trans-unit>
        <trans-unit id="b68a11032c4c5524a6d469ea8b3201d777a3c20e" translate="yes" xml:space="preserve">
          <source>solutions based on iterators (D,E) are slowest and not recommended</source>
          <target state="translated">반복자 (D, E) 기반 솔루션이 가장 느리고 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e650787270deb795dae97cbcb4d1880a0d37dc2" translate="yes" xml:space="preserve">
          <source>surprisingly &lt;code&gt;for-of&lt;/code&gt; (H) solution is fast on chrome for small and big objects</source>
          <target state="translated">놀랍게도 For &lt;code&gt;for-of&lt;/code&gt; (H) 솔루션은 크고 작은 물체를 위해 크롬에서 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="0f9f637f0ba1bb1c6606fd4a5d8bf3f034370d03" translate="yes" xml:space="preserve">
          <source>this will give the same result as using for...in es6 loop.</source>
          <target state="translated">이것은 for ... in es6 루프를 사용하는 것과 동일한 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d3bee068dc0d244e9d3ae4935d4bbc75483368a0" translate="yes" xml:space="preserve">
          <source>via &lt;strong&gt;prototype&lt;/strong&gt; with &lt;strong&gt;forEach()&lt;/strong&gt; which should skip the &lt;strong&gt;prototype chain&lt;/strong&gt; properties:</source>
          <target state="translated">&lt;strong&gt;프로토 타입 체인&lt;/strong&gt; 속성을 건너 뛰어야하는 &lt;strong&gt;forEach ()가&lt;/strong&gt; 있는 &lt;strong&gt;프로토 타입&lt;/strong&gt; 을 통해 :</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
