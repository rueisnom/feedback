<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/6841333">
    <body>
      <group id="6841333">
        <trans-unit id="bd1451938716cbc1c8094ba21225f6bd6718e890" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#Java_SE_6_.28December_11.2C_2006.29&quot;&gt;JDK 6&lt;/a&gt; two years ago, and in &lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#Java_SE_7_.28July_28.2C_2011.29&quot;&gt;JDK 7&lt;/a&gt; just recently in &lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#cite_note-131&quot;&gt;update 25&lt;/a&gt;.</source>
          <target state="translated">两年前的&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#Java_SE_6_.28December_11.2C_2006.29&quot;&gt;JDK 6&lt;/a&gt; ，以及最近在&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#cite_note-131&quot;&gt;更新25&lt;/a&gt;中的&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#Java_SE_7_.28July_28.2C_2011.29&quot;&gt;JDK 7&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe67aa701548fdd40c1b0265468a45f72b73f1df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; History has changed again...</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;历史再次改变了...</target>
        </trans-unit>
        <trans-unit id="0551d19941d120adfb039f0ae92f8a04f20e3128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; Stop press! History changes...</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;停止按！ 历史发生变化...</target>
        </trans-unit>
        <trans-unit id="bde921caecc04f466d2c822ea74545f52d552b7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; To answer a question around a transition at 1900... it looks like the Java timezone implementation treats &lt;em&gt;all&lt;/em&gt; time zones as simply being in their standard time for any instant before the start of 1900 UTC:</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;要回答有关1900年过渡的问题...似乎Java时区实现将&lt;em&gt;所有&lt;/em&gt;时区都视为在1900 UTC开始之前的任何时刻都处于其标准时间内：</target>
        </trans-unit>
        <trans-unit id="a97cec64d39b8eb010cdc08b8e103d0bb8477c86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's better to use UTC where time doesn't change unless if needed to use non-UTC time like in display.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最好在不改变时间的情况下使用UTC，除非需要使用非UTC时间（如在显示中）。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d54617ac5dccf99b7c02c39453136d7473a3a634" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java version:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Java版本：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad49472f83852737eae406aca91cdf31a2059cf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The output is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;输出为：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1902350e92496ff9e18c5813a36700a28a11fa42" translate="yes" xml:space="preserve">
          <source>Also, these two offsets are the same:</source>
          <target state="translated">另外,这两个偏移量是一样的。</target>
        </trans-unit>
        <trans-unit id="0c0cfe54c8369a97a25846fb4b86d04a36d5e3f0" translate="yes" xml:space="preserve">
          <source>And then see that the result is:</source>
          <target state="translated">然后看到的结果是。</target>
        </trans-unit>
        <trans-unit id="858ee0b7325db3da2f9d26de1bb98beb63ac41f3" translate="yes" xml:space="preserve">
          <source>Another way to approach this is to check whether there's a transition going on. We can do this like this:</source>
          <target state="translated">另一种方法是检查是否有过渡的情况发生。我们可以这样做。</target>
        </trans-unit>
        <trans-unit id="98e8bfb3f4d507059ac54e043de58cc5443b82ee" translate="yes" xml:space="preserve">
          <source>As explained by others, there's a time discontinuity there. There are two possible timezone offsets for &lt;code&gt;1927-12-31 23:54:08&lt;/code&gt; at &lt;code&gt;Asia/Shanghai&lt;/code&gt;, but only one offset for &lt;code&gt;1927-12-31 23:54:07&lt;/code&gt;. So, depending on which offset is used, there's either a one second difference or a 5 minutes and 53 seconds difference.</source>
          <target state="translated">正如其他人解释的那样，那里存在时间不连续性。 &lt;code&gt;Asia/Shanghai&lt;/code&gt; 对于 &lt;code&gt;1927-12-31 23:54:08&lt;/code&gt; 有两种可能的时区偏移，但是对于 &lt;code&gt;1927-12-31 23:54:07&lt;/code&gt; 只有一种偏移。 因此，根据使用的偏移量，可能会有一秒的差异或5分53秒的差异。</target>
        </trans-unit>
        <trans-unit id="4fc8c3099313e3b540718692a541892bd6628f60" translate="yes" xml:space="preserve">
          <source>As others said, it's a time change in 1927 in Shanghai.</source>
          <target state="translated">正如别人所说,1927年的上海,是一个时代的变化。</target>
        </trans-unit>
        <trans-unit id="92ab96205c8f86e70f3ccdccb518bf64a18fd635" translate="yes" xml:space="preserve">
          <source>But there is something different about these two time changes. The latter changes continuously and the former was just a change. It didn't change back or change again by the same amount.</source>
          <target state="translated">但这两个时间的变化,却又有不同的地方。后者是不断的变化,而前者只是一个变化。没有变回来,也没有变回去,也没有变回来,也没有再变回来。</target>
        </trans-unit>
        <trans-unit id="f514b433b60960e9cff044c9d2fa1237ffb4ac2d" translate="yes" xml:space="preserve">
          <source>But these two are different:</source>
          <target state="translated">但是,这两个是不一样的。</target>
        </trans-unit>
        <trans-unit id="e4d76851ab235c8fb1be42a6df2c235bb2b681eb" translate="yes" xml:space="preserve">
          <source>I hope this helps people handle this sort of issue once Java 8 becomes widely available, or to those using Java 7 who adopt the JSR 310 backport.</source>
          <target state="translated">我希望在Java 8普及之后,或者是对那些采用JSR 310后端的Java 7的人来说,希望这能帮助人们处理这类问题。</target>
        </trans-unit>
        <trans-unit id="a72d9ab2a0ed8923c9ba597f62e9bc18d91da876" translate="yes" xml:space="preserve">
          <source>I mean, come on, aren't global static variables an anti-OO pattern? Nothing else is those pervasive defaults given by some rudimentary environment variables.......</source>
          <target state="translated">我是说,拜托,全局静态变量不就是反OO的模式吗?别的不说,就是那些无孔不入的默认值由一些简陋的环境变量给出的...........。</target>
        </trans-unit>
        <trans-unit id="066199f064ebb3cc500e664941df954942936266" translate="yes" xml:space="preserve">
          <source>I only noticed this because I'm collecting questions like this in Noda Time, in the form of &lt;a href=&quot;https://github.com/nodatime/nodatime/blob/master/src/NodaTime.Demo/StackOverflowExamples.cs#L68&quot;&gt;unit tests&lt;/a&gt;... The test has now been changed, but it just goes to show - not even historical data is safe.</source>
          <target state="translated">我之所以注意到这一点，是因为我在Noda Time以&lt;a href=&quot;https://github.com/nodatime/nodatime/blob/master/src/NodaTime.Demo/StackOverflowExamples.cs#L68&quot;&gt;单元测试&lt;/a&gt;的形式收集了类似的问题&amp;hellip;&amp;hellip;测试现已更改，但这只是显示出来-甚至历史数据也不是安全的。</target>
        </trans-unit>
        <trans-unit id="56c48ba41119f7aa61b2ce2e8b785a8269989909" translate="yes" xml:space="preserve">
          <source>I'm sorry to say, but the time discontinuity has moved a bit in</source>
          <target state="translated">很抱歉,时间的不连续性有点移动了。</target>
        </trans-unit>
        <trans-unit id="8b3d29b36e59c1a8b6737ba1d904177462d786a8" translate="yes" xml:space="preserve">
          <source>IMHO the pervasive, &lt;em&gt;implicit&lt;/em&gt; localization in Java is its single largest design flaw. It may be intended for user interfaces, but frankly, who really uses Java for user interfaces today except for some IDEs where you can basically ignore localization because programmers aren't exactly the target audience for it. You can fix it (especially on Linux servers) by:</source>
          <target state="translated">恕我直言，Java中普遍存在的&lt;em&gt;隐式&lt;/em&gt;本地化是其最大的设计缺陷。 它可能是为用户界面设计的，但是坦率地说，今天的人真正将Java用于用户界面，除了一些IDE之外，您基本上可以忽略本地化，因为程序员并不完全是本地化的。 您可以通过以下方式修复（尤其是在Linux服务器上）：</target>
        </trans-unit>
        <trans-unit id="7fcc1a8a527402c0f0dfeebebf4baaaacb625564" translate="yes" xml:space="preserve">
          <source>If I change the dates to times 1 second later:</source>
          <target state="translated">如果我把日期改成了1秒后的时间。</target>
        </trans-unit>
        <trans-unit id="5111eaaf38d1db5ec766498848da9d88df7016f7" translate="yes" xml:space="preserve">
          <source>If I run the following program, which parses two date strings referencing times 1 second apart and compares them:</source>
          <target state="translated">如果我运行以下程序,解析两个相隔1秒的日期字符串,并对它们进行比较。</target>
        </trans-unit>
        <trans-unit id="02c748d4978e79c37d10ac4811023a81fbcf2f28" translate="yes" xml:space="preserve">
          <source>If you can not display a date or time in UTC, always indicate the time-zone.</source>
          <target state="translated">如果不能以UTC显示日期或时间,请务必注明时区。</target>
        </trans-unit>
        <trans-unit id="6306f0e3ad2baf3d4413643d7578c13d53158a95" translate="yes" xml:space="preserve">
          <source>If you can not require an input date/time in UTC, require an explicitly indicated time-zone.</source>
          <target state="translated">如果你不能要求输入的日期时间是UTC,那就要求明确指定一个时区。</target>
        </trans-unit>
        <trans-unit id="8087c7ec3c81c2fd292ffd2a9305534c6fc3d42a" translate="yes" xml:space="preserve">
          <source>If you converted to UTC, add each second, and convert to local time for display. You would go through 11:54:08 p.m. &lt;a href=&quot;http://en.wikipedia.org/wiki/Local_mean_time&quot;&gt;LMT&lt;/a&gt; - 11:59:59 p.m. LMT and then 11:54:08 p.m. &lt;a href=&quot;http://en.wikipedia.org/wiki/Central_Time_Zone_%28North_America%29&quot;&gt;CST&lt;/a&gt; - 11:59:59 p.m. CST.</source>
          <target state="translated">如果您转换为UTC，则每秒添加一次，然后转换为本地时间进行显示。 您将经历&lt;a href=&quot;http://en.wikipedia.org/wiki/Local_mean_time&quot;&gt;LMT的&lt;/a&gt; 11:54:08 pm-LMT的11:59:59 pm，然后经历&lt;a href=&quot;http://en.wikipedia.org/wiki/Central_Time_Zone_%28North_America%29&quot;&gt;CST的&lt;/a&gt; 11:54:08 pm- CST的 11:59:59 pm。</target>
        </trans-unit>
        <trans-unit id="103136494c4c14adc48cb8f8c7ddfd0b81928581" translate="yes" xml:space="preserve">
          <source>In TZDB 2014f, the time of the change has moved to 1900-12-31, and it's now a mere 343 second change (so the time between &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;t+1&lt;/code&gt; is 344 seconds, if you see what I mean).</source>
          <target state="translated">在TZDB 2014f中，更改时间已移至1900-12-31，现在仅更改了343秒（因此，如果您明白我的意思，那么 &lt;code&gt;t&lt;/code&gt; 和 &lt;code&gt;t+1&lt;/code&gt; 之间的时间为344秒）。</target>
        </trans-unit>
        <trans-unit id="5e37e1acca1e0cc2f4a1ebac231a5b1558c151d8" translate="yes" xml:space="preserve">
          <source>Instead of converting each date, you can use the following code:</source>
          <target state="translated">可以用下面的代码来代替每个日期的转换。</target>
        </trans-unit>
        <trans-unit id="b3b9e3534c00684dc4a2b06c0f3d5e8c5d38a7ab" translate="yes" xml:space="preserve">
          <source>It's a time zone change on December 31st in Shanghai.</source>
          <target state="translated">这是12月31日上海的时区变化。</target>
        </trans-unit>
        <trans-unit id="75441c0e99705d8e65e4033acbeb0010a83637ba" translate="yes" xml:space="preserve">
          <source>Just another episode in the often weird and wonderful world of time zones.</source>
          <target state="translated">只是在这个时区的世界里又发生了一幕。</target>
        </trans-unit>
        <trans-unit id="e65efb5fa854d52f51124f878d5b88742c1710d5" translate="yes" xml:space="preserve">
          <source>Lesson to learn: avoid non-UTC times at all costs, except maybe for display.</source>
          <target state="translated">教训:不惜一切代价避免非UTC时间,除非可能是为了展示,否则不惜一切代价。</target>
        </trans-unit>
        <trans-unit id="0049464ec04d018c3ecefbf1142ef34dcb8fd292" translate="yes" xml:space="preserve">
          <source>Note that the 2013a update of the timezone database moved this discontinuity a few seconds earlier, but the effect would still be observable.</source>
          <target state="translated">请注意,2013年a时区数据库的更新将这一不连续性提前了几秒,但仍然可以观察到效果。</target>
        </trans-unit>
        <trans-unit id="9137b60d69cf6be5d93720a3b111187bc27cb03e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.timeanddate.com/worldclock/clockchange.html?n=237&amp;amp;year=1927&quot;&gt;this page&lt;/a&gt; for details of 1927 in Shanghai. Basically at midnight at the end of 1927, the clocks went back 5 minutes and 52 seconds. So &quot;1927-12-31 23:54:08&quot; actually happened twice, and it looks like Java is parsing it as the &lt;em&gt;later&lt;/em&gt; possible instant for that local date/time - hence the difference.</source>
          <target state="translated">有关1927年上海的详细信息，请参&lt;a href=&quot;http://www.timeanddate.com/worldclock/clockchange.html?n=237&amp;amp;year=1927&quot;&gt;见此页&lt;/a&gt; 。 基本上在1927年底的午夜，时钟回到了5分52秒。 因此，&amp;ldquo; 1927-12-31 23:54:08&amp;rdquo;实际上发生了两次，看起来Java正在将其解析为该本地日期/时间的&lt;em&gt;稍后&lt;/em&gt;可能时刻，因此有所不同。</target>
        </trans-unit>
        <trans-unit id="9475c45ed435d1dcc8064230299ad9bbea971f1d" translate="yes" xml:space="preserve">
          <source>The code above produces no output on my Windows machine. So any time zone which has any offset other than its standard one at the start of 1900 will count that as a transition. TZDB itself has some data going back earlier than that, and doesn't rely on any idea of a &quot;fixed&quot; standard time (which is what &lt;code&gt;getRawOffset&lt;/code&gt; assumes to be a valid concept) so other libraries needn't introduce this artificial transition.</source>
          <target state="translated">上面的代码在Windows计算机上不产生任何输出。 因此，任何在1900年初具有除标准偏移量之外的偏移量的时区都将被视为过渡。 TZDB本身早有一些数据，并且不依赖任何&amp;ldquo;固定&amp;rdquo;标准时间的想法（ &lt;code&gt;getRawOffset&lt;/code&gt; 假定这是一个有效的概念），因此其他库不需要引入这种人为的转换。</target>
        </trans-unit>
        <trans-unit id="b7100a91b9d8b1cb54cb804d21e63e3627bdd121" translate="yes" xml:space="preserve">
          <source>The moral of this strangeness is:</source>
          <target state="translated">这种陌生感的寓意是:</target>
        </trans-unit>
        <trans-unit id="d63ca0e9fab08267556d100f286c945b2a64bc3d" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;java.time&lt;/code&gt; package on Java 8 let use see this more clearly, and provide tools to handle it. Given:</source>
          <target state="translated">Java 8上新的 &lt;code&gt;java.time&lt;/code&gt; 包使使用过程更加清晰，并提供了处理它的工具。 鉴于：</target>
        </trans-unit>
        <trans-unit id="19a3e89ca6ba713c3583ed6c4c15800b57fd093f" translate="yes" xml:space="preserve">
          <source>The original question would no longer demonstrate quite the same behaviour, if rebuilt with version 2013a of &lt;a href=&quot;https://github.com/nodatime/nodatime/blob/master/src/NodaTime.Demo/StackOverflowExamples.cs#L68&quot;&gt;TZDB&lt;/a&gt;. In 2013a, the result would be 358 seconds, with a transition time of 23:54:03 instead of 23:54:08.</source>
          <target state="translated">如果使用TZDB的&lt;a href=&quot;https://github.com/nodatime/nodatime/blob/master/src/NodaTime.Demo/StackOverflowExamples.cs#L68&quot;&gt;2013a&lt;/a&gt;版本进行重建，原始问题将不再表现出完全相同的行为。 在2013a中，结果为358秒，转换时间为23:54:03，而不是23:54:08。</target>
        </trans-unit>
        <trans-unit id="b217bce103afb1f4fb3afe8cf964a7f81122a266" translate="yes" xml:space="preserve">
          <source>The time can also mess up in other places like the US. The US has Daylight Saving Time. When the Daylight Saving Time starts the time goes forward 1 hour. But after a while the Daylight Saving Time ends, and it goes backward 1 hour back to the standard time zone. So sometimes when comparing times in the US the difference is about &lt;code&gt;3600&lt;/code&gt; seconds not 1 second.</source>
          <target state="translated">在美国等其他地方，时间也会混乱。 美国有夏令时。 夏令时开始时，时间向前1小时。 但是过了一会儿，夏令时结束，并且倒退了1小时回到标准时区。 因此有时在美国比较时间时，差异约为 &lt;code&gt;3600&lt;/code&gt; 秒而不是1秒。</target>
        </trans-unit>
        <trans-unit id="9ddd52667a83232bb1f4cef9b34b280a0bf54281" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;durationAtEarlierOffset&lt;/code&gt; will be one second, while &lt;code&gt;durationAtLaterOffset&lt;/code&gt; will be five minutes and 53 seconds.</source>
          <target state="translated">然后， &lt;code&gt;durationAtEarlierOffset&lt;/code&gt; 将为一秒钟，而 &lt;code&gt;durationAtLaterOffset&lt;/code&gt; 将为五分钟53秒。</target>
        </trans-unit>
        <trans-unit id="19db37336bb97e1cf9c14ba0a1883e72e3897316" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;ld4-ld3&lt;/code&gt; will be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">然后 &lt;code&gt;ld4-ld3&lt;/code&gt; 将为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4967ebc9aa4719471c06c3f53ba2a7bbe93eac0d" translate="yes" xml:space="preserve">
          <source>This is not particularly strange and has happened pretty much everywhere at one time or another as timezones were switched or changed due to political or administrative actions.</source>
          <target state="translated">这种情况并不是特别奇怪,而且由于政治或行政行为而被调换或改变的时间段,几乎到处都在发生。</target>
        </trans-unit>
        <trans-unit id="824c06d0b3b4e8849b79ccd53ac695c0c6307a4c" translate="yes" xml:space="preserve">
          <source>This slight shift of offsets, instead of the usual one-hour daylight savings (summer time) we are used to, obscures the problem a bit.</source>
          <target state="translated">这种轻微的偏移,而不是我们惯常的一小时白昼储蓄(夏季时间),稍微掩盖了问题。</target>
        </trans-unit>
        <trans-unit id="789fc42e0f431b1a07dca884b6ca5760ba615519" translate="yes" xml:space="preserve">
          <source>This way you will be able to walk through any periods where hours or minutes happen twice.</source>
          <target state="translated">这样一来,你就能在任何时间段里走过两次的时间段。</target>
        </trans-unit>
        <trans-unit id="b60de2541acc5faacd938ec0f0eba22688a97b01" translate="yes" xml:space="preserve">
          <source>To the &lt;a href=&quot;https://www.jcp.org/&quot;&gt;Java Community Process&lt;/a&gt; members I recommend:</source>
          <target state="translated">我向&lt;a href=&quot;https://www.jcp.org/&quot;&gt;Java Community Process&lt;/a&gt;成员推荐：</target>
        </trans-unit>
        <trans-unit id="6bd7890badd212524f07fa62eb450fca97ffbef9" translate="yes" xml:space="preserve">
          <source>Use dates and times in UTC wherever possible.</source>
          <target state="translated">尽可能使用UTC的日期和时间。</target>
        </trans-unit>
        <trans-unit id="c2ce6e9f01ab31c91c6ec268e87f5a3e7c9631a0" translate="yes" xml:space="preserve">
          <source>When incrementing time you should convert back to UTC and then add or subtract. Use the local time only for display.</source>
          <target state="translated">在递增时间时,您应该把时间换算成UTC,然后再加减。仅使用当地时间显示。</target>
        </trans-unit>
        <trans-unit id="e41c0f15f4012cc34cd7401c111b10939a9f0632" translate="yes" xml:space="preserve">
          <source>When it was &lt;code&gt;23:54:07&lt;/code&gt; in Shanghai, the local standard time, but after 5 minutes and 52 seconds, it turned to the next day at &lt;code&gt;00:00:00&lt;/code&gt;, and then local standard time changed back to &lt;code&gt;23:54:08&lt;/code&gt;. So, that's why the difference between the two times is 343 seconds not 1 second, as you would have expected.</source>
          <target state="translated">在上海，当地时间是当地标准时间 &lt;code&gt;23:54:07&lt;/code&gt; ，但经过5分52秒后，它转到第二天的 &lt;code&gt;00:00:00&lt;/code&gt; ，然后本地标准时间改回了 &lt;code&gt;23:54:08&lt;/code&gt; 。 因此，这就是为什么两次之间的差是343秒而不是1秒，这正是您所期望的。</target>
        </trans-unit>
        <trans-unit id="0c92b6b65def6ef6d62c2b2bf1cdc1784a43eefe" translate="yes" xml:space="preserve">
          <source>When local standard time was about to reach Sunday, 1. January 1928,
  00:00:00 clocks were turned backward 0:05:52 hours to Saturday, 31.
  December 1927, 23:54:08 local standard time instead</source>
          <target state="translated">1928年1月1日,00:00:00:00时,当地标准时间即将到达周日,1。1927年12月31日,当地标准时间23时54分08分</target>
        </trans-unit>
        <trans-unit id="73d4aa31d8c6b5023622dc30633d91c8e5f478f9" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;ld4-ld3&lt;/code&gt; not &lt;code&gt;1&lt;/code&gt; (as I would expect from the one-second difference in the times), but &lt;code&gt;353&lt;/code&gt;?</source>
          <target state="translated">为什么 &lt;code&gt;ld4-ld3&lt;/code&gt; 不是 &lt;code&gt;1&lt;/code&gt; （就像我从一秒的时间差中期望的那样），而是 &lt;code&gt;353&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="d2a71713da9e82099ccbad90518de1ca9e1bb60c" translate="yes" xml:space="preserve">
          <source>Why is subtracting these two times (in 1927) giving a strange result</source>
          <target state="translated">为什么减去这两次(1927年)会得到一个奇怪的结果?</target>
        </trans-unit>
        <trans-unit id="9fc9644ca504b8a7d6cc99d99594925a6e30ae17" translate="yes" xml:space="preserve">
          <source>You can check whether the transition is an overlap where there's more than one valid offset for that date/time or a gap where that date/time is not valid for that zone id - by using the &lt;code&gt;isOverlap()&lt;/code&gt; and &lt;code&gt;isGap()&lt;/code&gt; methods on &lt;code&gt;zot4&lt;/code&gt;.</source>
          <target state="translated">您可以通过在 &lt;code&gt;isOverlap()&lt;/code&gt; 使用isOverlap（）和 &lt;code&gt;isGap()&lt;/code&gt; 方法来检查过渡是否是重叠的（对于该日期/时间有多个有效偏移量）还是空白（对于该区域ID而言该日期/时间无效） 。</target>
        </trans-unit>
        <trans-unit id="46cca3c2b359b243aaf93432f10772e5e013b14e" translate="yes" xml:space="preserve">
          <source>You can see the same problem comparing &lt;code&gt;1927-12-31 23:59:59&lt;/code&gt; with &lt;code&gt;1928-01-01 00:00:00&lt;/code&gt;, though, in this case, it is the earlier offset that produces the longer divergence, and it is the earlier date that has two possible offsets.</source>
          <target state="translated">您可以看到将 &lt;code&gt;1927-12-31 23:59:59&lt;/code&gt; 与 &lt;code&gt;1928-01-01 00:00:00&lt;/code&gt; 进行比较的相同问题，但是，在这种情况下，是较早的偏移量导致了更长的发散度，而正是有两个可能的偏移量的较早日期。</target>
        </trans-unit>
        <trans-unit id="d0fc95a43660c9f95b3383aec1ea859ebd40f9a6" translate="yes" xml:space="preserve">
          <source>You've encountered a &lt;a href=&quot;http://timeanddate.com/worldclock/clockchange.html?n=237&amp;amp;year=1927&quot;&gt;local time discontinuity&lt;/a&gt;:</source>
          <target state="translated">您遇到了&lt;a href=&quot;http://timeanddate.com/worldclock/clockchange.html?n=237&amp;amp;year=1927&quot;&gt;当地时间不连续性&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="851c4419c76cc7437e9fc5b06b0d5a51f136d8c6" translate="yes" xml:space="preserve">
          <source>export LC_ALL=C TZ=UTC</source>
          <target state="translated">export LC_ALL=C TZ=UTC</target>
        </trans-unit>
        <trans-unit id="894fa40b06e8625588b6dbe8fd0fdc94e07482b6" translate="yes" xml:space="preserve">
          <source>make localized methods not the default, but require the user to explicitly request localization.</source>
          <target state="translated">使本地化方法不是默认的,而是要求用户明确要求本地化。</target>
        </trans-unit>
        <trans-unit id="e39b6549994f5fbdde97320628c30d6d2b245a1a" translate="yes" xml:space="preserve">
          <source>never use localized implementations unless absolutely necessary (ie for display only)</source>
          <target state="translated">绝不使用本地化的实现,除非万不得已(即仅用于显示)。</target>
        </trans-unit>
        <trans-unit id="6fd0469b691655f5c5d7e7cf3174ba1a2fc60148" translate="yes" xml:space="preserve">
          <source>set your system clock to UTC</source>
          <target state="translated">将系统时钟设置为UTC</target>
        </trans-unit>
        <trans-unit id="cf7886d28aed4eb23b330f782c10d18ca9ee1834" translate="yes" xml:space="preserve">
          <source>use UTF-8/UTC as the &lt;em&gt;FIXED&lt;/em&gt; default instead because that's simply the default today. There is no reason to do something else, except if you want to produce threads like this.</source>
          <target state="translated">请改用UTF-8 / UTC作为&lt;em&gt;FIXED&lt;/em&gt;默认值，因为这只是今天的默认值。 除了要生成这样的线程外，没有其他理由。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
