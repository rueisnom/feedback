<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/6841333">
    <body>
      <group id="6841333">
        <trans-unit id="bd1451938716cbc1c8094ba21225f6bd6718e890" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#Java_SE_6_.28December_11.2C_2006.29&quot;&gt;JDK 6&lt;/a&gt; two years ago, and in &lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#Java_SE_7_.28July_28.2C_2011.29&quot;&gt;JDK 7&lt;/a&gt; just recently in &lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#cite_note-131&quot;&gt;update 25&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#Java_SE_6_.28December_11.2C_2006.29&quot;&gt;JDK 6&lt;/a&gt; 2 년 전, &lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#Java_SE_7_.28July_28.2C_2011.29&quot;&gt;JDK 7&lt;/a&gt; 에서 최근 &lt;a href=&quot;https://en.wikipedia.org/wiki/Java_version_history#cite_note-131&quot;&gt;업데이트 25&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fe67aa701548fdd40c1b0265468a45f72b73f1df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; History has changed again...</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; 역사가 다시 변경되었습니다 ...</target>
        </trans-unit>
        <trans-unit id="0551d19941d120adfb039f0ae92f8a04f20e3128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; Stop press! History changes...</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; 보도 중지! 역사 변경 ...</target>
        </trans-unit>
        <trans-unit id="bde921caecc04f466d2c822ea74545f52d552b7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; To answer a question around a transition at 1900... it looks like the Java timezone implementation treats &lt;em&gt;all&lt;/em&gt; time zones as simply being in their standard time for any instant before the start of 1900 UTC:</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; 1900에서 전환에 관한 질문에 대답하기 위해 ... Java 시간대 구현은 &lt;em&gt;모든&lt;/em&gt; 시간대를 단순히 1900 UTC가 시작되기 전에 모든 표준 시간대로 처리하는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="a97cec64d39b8eb010cdc08b8e103d0bb8477c86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It's better to use UTC where time doesn't change unless if needed to use non-UTC time like in display.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UTC가 아닌 시간을 디스플레이와 같이 사용해야하는 경우가 아니라면 시간이 변경되지 않는 UTC를 사용하는 것이 좋습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d54617ac5dccf99b7c02c39453136d7473a3a634" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Java version:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;자바 버전 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ad49472f83852737eae406aca91cdf31a2059cf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The output is:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;출력은 다음과 같습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1902350e92496ff9e18c5813a36700a28a11fa42" translate="yes" xml:space="preserve">
          <source>Also, these two offsets are the same:</source>
          <target state="translated">또한이 두 오프셋은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0c0cfe54c8369a97a25846fb4b86d04a36d5e3f0" translate="yes" xml:space="preserve">
          <source>And then see that the result is:</source>
          <target state="translated">그리고 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="858ee0b7325db3da2f9d26de1bb98beb63ac41f3" translate="yes" xml:space="preserve">
          <source>Another way to approach this is to check whether there's a transition going on. We can do this like this:</source>
          <target state="translated">이에 접근하는 또 다른 방법은 전환이 진행 중인지 확인하는 것입니다. 우리는 이렇게 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="98e8bfb3f4d507059ac54e043de58cc5443b82ee" translate="yes" xml:space="preserve">
          <source>As explained by others, there's a time discontinuity there. There are two possible timezone offsets for &lt;code&gt;1927-12-31 23:54:08&lt;/code&gt; at &lt;code&gt;Asia/Shanghai&lt;/code&gt;, but only one offset for &lt;code&gt;1927-12-31 23:54:07&lt;/code&gt;. So, depending on which offset is used, there's either a one second difference or a 5 minutes and 53 seconds difference.</source>
          <target state="translated">다른 사람들이 설명했듯이 시간 불연속이 있습니다. &lt;code&gt;Asia/Shanghai&lt;/code&gt; 에서는 &lt;code&gt;1927-12-31 23:54:08&lt;/code&gt; 에 대해 두 개의 가능한 시간대 오프셋이 있지만 &lt;code&gt;1927-12-31 23:54:07&lt;/code&gt; 에 대해서는 하나의 오프셋 만 있습니다. 따라서 어떤 오프셋이 사용되는지에 따라 1 초 차이 또는 5 분 53 초 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fc8c3099313e3b540718692a541892bd6628f60" translate="yes" xml:space="preserve">
          <source>As others said, it's a time change in 1927 in Shanghai.</source>
          <target state="translated">다른 사람들이 말했듯이 1927 년 상하이에서 시간이 바뀌 었습니다.</target>
        </trans-unit>
        <trans-unit id="92ab96205c8f86e70f3ccdccb518bf64a18fd635" translate="yes" xml:space="preserve">
          <source>But there is something different about these two time changes. The latter changes continuously and the former was just a change. It didn't change back or change again by the same amount.</source>
          <target state="translated">그러나이 두 시간 변화에는 다른 점이 있습니다. 후자는 지속적으로 변화하고 전자는 단지 변화 일뿐입니다. 같은 양만큼 변경되거나 다시 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="f514b433b60960e9cff044c9d2fa1237ffb4ac2d" translate="yes" xml:space="preserve">
          <source>But these two are different:</source>
          <target state="translated">그러나이 두 가지는 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e4d76851ab235c8fb1be42a6df2c235bb2b681eb" translate="yes" xml:space="preserve">
          <source>I hope this helps people handle this sort of issue once Java 8 becomes widely available, or to those using Java 7 who adopt the JSR 310 backport.</source>
          <target state="translated">Java 8이 널리 사용 가능해 지거나 JSR 310 백 포트를 채택한 Java 7을 사용하는 사람들이 이런 종류의 문제를 처리하는 데 도움이되기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="a72d9ab2a0ed8923c9ba597f62e9bc18d91da876" translate="yes" xml:space="preserve">
          <source>I mean, come on, aren't global static variables an anti-OO pattern? Nothing else is those pervasive defaults given by some rudimentary environment variables.......</source>
          <target state="translated">전역 정적 변수가 anti-OO 패턴이 아닙니까? 다른 기본 환경 변수에 의해 제공되는 광범위한 기본값은 없습니다.</target>
        </trans-unit>
        <trans-unit id="066199f064ebb3cc500e664941df954942936266" translate="yes" xml:space="preserve">
          <source>I only noticed this because I'm collecting questions like this in Noda Time, in the form of &lt;a href=&quot;https://github.com/nodatime/nodatime/blob/master/src/NodaTime.Demo/StackOverflowExamples.cs#L68&quot;&gt;unit tests&lt;/a&gt;... The test has now been changed, but it just goes to show - not even historical data is safe.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/nodatime/nodatime/blob/master/src/NodaTime.Demo/StackOverflowExamples.cs#L68&quot;&gt;단위 테스트&lt;/a&gt; 형태로 Noda Time에서 이와 같은 질문을 수집하기 때문에이 사실을 알았습니다 ... 테스트가 이제 변경되었지만 표시됩니다. 이력 데이터조차도 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="56c48ba41119f7aa61b2ce2e8b785a8269989909" translate="yes" xml:space="preserve">
          <source>I'm sorry to say, but the time discontinuity has moved a bit in</source>
          <target state="translated">죄송 합니다만 시간 불연속이 약간 바뀌 었습니다.</target>
        </trans-unit>
        <trans-unit id="8b3d29b36e59c1a8b6737ba1d904177462d786a8" translate="yes" xml:space="preserve">
          <source>IMHO the pervasive, &lt;em&gt;implicit&lt;/em&gt; localization in Java is its single largest design flaw. It may be intended for user interfaces, but frankly, who really uses Java for user interfaces today except for some IDEs where you can basically ignore localization because programmers aren't exactly the target audience for it. You can fix it (especially on Linux servers) by:</source>
          <target state="translated">Java에서 널리 사용되는 &lt;em&gt;암시 적&lt;/em&gt; 현지화는 단일 설계상의 가장 큰 결함입니다. 사용자 인터페이스를위한 것일 수도 있지만, 솔직히 말해서 프로그래머가 타겟 대상이 아니기 때문에 기본적으로 현지화를 무시할 수있는 일부 IDE를 제외하고 오늘날 사용자 인터페이스에 Java를 실제로 사용하는 사용자는 있습니다. 다음과 같은 방법으로 (특히 Linux 서버에서) 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fcc1a8a527402c0f0dfeebebf4baaaacb625564" translate="yes" xml:space="preserve">
          <source>If I change the dates to times 1 second later:</source>
          <target state="translated">1 초 후에 날짜를 시간으로 변경하면 :</target>
        </trans-unit>
        <trans-unit id="5111eaaf38d1db5ec766498848da9d88df7016f7" translate="yes" xml:space="preserve">
          <source>If I run the following program, which parses two date strings referencing times 1 second apart and compares them:</source>
          <target state="translated">다음 프로그램을 실행하면 시간을 1 초 간격으로 참조하는 두 개의 날짜 문자열을 구문 분석하고 비교합니다.</target>
        </trans-unit>
        <trans-unit id="02c748d4978e79c37d10ac4811023a81fbcf2f28" translate="yes" xml:space="preserve">
          <source>If you can not display a date or time in UTC, always indicate the time-zone.</source>
          <target state="translated">날짜 나 시간을 UTC로 표시 할 수없는 경우 항상 시간대를 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="6306f0e3ad2baf3d4413643d7578c13d53158a95" translate="yes" xml:space="preserve">
          <source>If you can not require an input date/time in UTC, require an explicitly indicated time-zone.</source>
          <target state="translated">UTC로 입력 날짜 / 시간을 요구할 수없는 경우 명시 적으로 표시된 시간대를 요구하십시오.</target>
        </trans-unit>
        <trans-unit id="8087c7ec3c81c2fd292ffd2a9305534c6fc3d42a" translate="yes" xml:space="preserve">
          <source>If you converted to UTC, add each second, and convert to local time for display. You would go through 11:54:08 p.m. &lt;a href=&quot;http://en.wikipedia.org/wiki/Local_mean_time&quot;&gt;LMT&lt;/a&gt; - 11:59:59 p.m. LMT and then 11:54:08 p.m. &lt;a href=&quot;http://en.wikipedia.org/wiki/Central_Time_Zone_%28North_America%29&quot;&gt;CST&lt;/a&gt; - 11:59:59 p.m. CST.</source>
          <target state="translated">UTC로 변환 한 경우 1 초마다 추가하고 표시 할 현지 시간으로 변환하십시오. &lt;a href=&quot;http://en.wikipedia.org/wiki/Local_mean_time&quot;&gt;LMT&lt;/a&gt; 오후 11:54:08 (오후 LMT -11:59:59), LST 오후 11:54:08 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Central_Time_Zone_%28North_America%29&quot;&gt;CST&lt;/a&gt; -11:59:59) CST 를 거칩니다.</target>
        </trans-unit>
        <trans-unit id="103136494c4c14adc48cb8f8c7ddfd0b81928581" translate="yes" xml:space="preserve">
          <source>In TZDB 2014f, the time of the change has moved to 1900-12-31, and it's now a mere 343 second change (so the time between &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;t+1&lt;/code&gt; is 344 seconds, if you see what I mean).</source>
          <target state="translated">TZDB 2014f에서 변경 시간은 1900-12-31로 이동했으며 이제는 343 초에 불과합니다 (따라서 &lt;code&gt;t&lt;/code&gt; 와 &lt;code&gt;t+1&lt;/code&gt; 사이의 시간은 344 초입니다.</target>
        </trans-unit>
        <trans-unit id="5e37e1acca1e0cc2f4a1ebac231a5b1558c151d8" translate="yes" xml:space="preserve">
          <source>Instead of converting each date, you can use the following code:</source>
          <target state="translated">각 날짜를 변환하는 대신 다음 코드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3b9e3534c00684dc4a2b06c0f3d5e8c5d38a7ab" translate="yes" xml:space="preserve">
          <source>It's a time zone change on December 31st in Shanghai.</source>
          <target state="translated">12 월 31 일 상하이에서 시간대가 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="75441c0e99705d8e65e4033acbeb0010a83637ba" translate="yes" xml:space="preserve">
          <source>Just another episode in the often weird and wonderful world of time zones.</source>
          <target state="translated">종종 이상하고 멋진 시간대의 세계에서 또 다른 에피소드.</target>
        </trans-unit>
        <trans-unit id="e65efb5fa854d52f51124f878d5b88742c1710d5" translate="yes" xml:space="preserve">
          <source>Lesson to learn: avoid non-UTC times at all costs, except maybe for display.</source>
          <target state="translated">배우는 교훈 : 디스플레이를 제외하고 모든 비용으로 비 UTC 시간을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="0049464ec04d018c3ecefbf1142ef34dcb8fd292" translate="yes" xml:space="preserve">
          <source>Note that the 2013a update of the timezone database moved this discontinuity a few seconds earlier, but the effect would still be observable.</source>
          <target state="translated">시간대 데이터베이스의 2013a 업데이트는이 불연속을 몇 초 전에 옮겼지만 그 효과는 여전히 관찰 가능합니다.</target>
        </trans-unit>
        <trans-unit id="9137b60d69cf6be5d93720a3b111187bc27cb03e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://www.timeanddate.com/worldclock/clockchange.html?n=237&amp;amp;year=1927&quot;&gt;this page&lt;/a&gt; for details of 1927 in Shanghai. Basically at midnight at the end of 1927, the clocks went back 5 minutes and 52 seconds. So &quot;1927-12-31 23:54:08&quot; actually happened twice, and it looks like Java is parsing it as the &lt;em&gt;later&lt;/em&gt; possible instant for that local date/time - hence the difference.</source>
          <target state="translated">1927 년 상하이에 대한 자세한 내용은 &lt;a href=&quot;http://www.timeanddate.com/worldclock/clockchange.html?n=237&amp;amp;year=1927&quot;&gt;이 페이지&lt;/a&gt; 를 참조하십시오. 기본적으로 1927 년 말 자정에 시계는 5 분 52 초로 되돌아갔습니다. 따라서 &quot;1927-12-31 23:54:08&quot;은 실제로 두 번 발생했으며 Java가 현지 날짜 / 시간에 대해 &lt;em&gt;나중에&lt;/em&gt; 가능한 순간으로 구문 분석하는 것처럼 보이므로 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9475c45ed435d1dcc8064230299ad9bbea971f1d" translate="yes" xml:space="preserve">
          <source>The code above produces no output on my Windows machine. So any time zone which has any offset other than its standard one at the start of 1900 will count that as a transition. TZDB itself has some data going back earlier than that, and doesn't rely on any idea of a &quot;fixed&quot; standard time (which is what &lt;code&gt;getRawOffset&lt;/code&gt; assumes to be a valid concept) so other libraries needn't introduce this artificial transition.</source>
          <target state="translated">위의 코드는 Windows 컴퓨터에서 출력을 생성하지 않습니다. 따라서 1900 년 시작시 표준 시간대 이외의 오프셋이있는 시간대는 전환으로 간주합니다. TZDB 자체는 이전보다 약간의 데이터를 가지고 있으며 &quot;고정 된&quot;표준 시간 ( &lt;code&gt;getRawOffset&lt;/code&gt; 이 유효한 개념이라고 가정)에 대한 아이디어에 의존하지 않기 때문에 다른 라이브러리는이 인공적인 전환을 도입 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b7100a91b9d8b1cb54cb804d21e63e3627bdd121" translate="yes" xml:space="preserve">
          <source>The moral of this strangeness is:</source>
          <target state="translated">이 이상의 도덕은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d63ca0e9fab08267556d100f286c945b2a64bc3d" translate="yes" xml:space="preserve">
          <source>The new &lt;code&gt;java.time&lt;/code&gt; package on Java 8 let use see this more clearly, and provide tools to handle it. Given:</source>
          <target state="translated">Java 8의 새로운 &lt;code&gt;java.time&lt;/code&gt; 패키지는이를보다 명확하게 사용하고 처리 할 수있는 도구를 제공합니다. 주어진:</target>
        </trans-unit>
        <trans-unit id="19a3e89ca6ba713c3583ed6c4c15800b57fd093f" translate="yes" xml:space="preserve">
          <source>The original question would no longer demonstrate quite the same behaviour, if rebuilt with version 2013a of &lt;a href=&quot;https://github.com/nodatime/nodatime/blob/master/src/NodaTime.Demo/StackOverflowExamples.cs#L68&quot;&gt;TZDB&lt;/a&gt;. In 2013a, the result would be 358 seconds, with a transition time of 23:54:03 instead of 23:54:08.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/nodatime/nodatime/blob/master/src/NodaTime.Demo/StackOverflowExamples.cs#L68&quot;&gt;TZDB&lt;/a&gt; 버전 2013a로 다시 빌드하면 원래 질문은 더 이상 똑같은 동작을 나타내지 않습니다. 2013a에서 결과는 358 초이며 전환 시간은 23:54:08 대신 23:54:03입니다.</target>
        </trans-unit>
        <trans-unit id="b217bce103afb1f4fb3afe8cf964a7f81122a266" translate="yes" xml:space="preserve">
          <source>The time can also mess up in other places like the US. The US has Daylight Saving Time. When the Daylight Saving Time starts the time goes forward 1 hour. But after a while the Daylight Saving Time ends, and it goes backward 1 hour back to the standard time zone. So sometimes when comparing times in the US the difference is about &lt;code&gt;3600&lt;/code&gt; seconds not 1 second.</source>
          <target state="translated">미국과 같은 다른 곳에서도 시간이 엉망이 될 수 있습니다. 미국에는 일광 절약 시간 제가 있습니다. 일광 절약 시간 제가 시작되면 시간이 1 시간 앞으로 이동합니다. 그러나 잠시 후 일광 절약 시간 제가 종료되고 표준 시간대로 1 시간 뒤로 이동합니다. 따라서 미국에서 시간을 비교할 때 차이는 1 초가 아닌 약 &lt;code&gt;3600&lt;/code&gt; 초입니다.</target>
        </trans-unit>
        <trans-unit id="9ddd52667a83232bb1f4cef9b34b280a0bf54281" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;durationAtEarlierOffset&lt;/code&gt; will be one second, while &lt;code&gt;durationAtLaterOffset&lt;/code&gt; will be five minutes and 53 seconds.</source>
          <target state="translated">그러면 &lt;code&gt;durationAtEarlierOffset&lt;/code&gt; 은 1 초가되고 &lt;code&gt;durationAtLaterOffset&lt;/code&gt; 은 5 분 53 초가됩니다.</target>
        </trans-unit>
        <trans-unit id="19db37336bb97e1cf9c14ba0a1883e72e3897316" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;ld4-ld3&lt;/code&gt; will be &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">그러면 &lt;code&gt;ld4-ld3&lt;/code&gt; 은 &lt;code&gt;1&lt;/code&gt; 이 됩니다.</target>
        </trans-unit>
        <trans-unit id="4967ebc9aa4719471c06c3f53ba2a7bbe93eac0d" translate="yes" xml:space="preserve">
          <source>This is not particularly strange and has happened pretty much everywhere at one time or another as timezones were switched or changed due to political or administrative actions.</source>
          <target state="translated">이것은 특히 이상하지 않으며 정치 또는 행정적 조치로 시간대가 바뀌거나 바뀌면서 한 번에 거의 모든 곳에서 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="824c06d0b3b4e8849b79ccd53ac695c0c6307a4c" translate="yes" xml:space="preserve">
          <source>This slight shift of offsets, instead of the usual one-hour daylight savings (summer time) we are used to, obscures the problem a bit.</source>
          <target state="translated">우리가 익숙한 일반적인 1 시간 일광 절약 시간 (서머 타임) 대신이 약간의 오프셋 이동은 문제를 조금 모호하게합니다.</target>
        </trans-unit>
        <trans-unit id="789fc42e0f431b1a07dca884b6ca5760ba615519" translate="yes" xml:space="preserve">
          <source>This way you will be able to walk through any periods where hours or minutes happen twice.</source>
          <target state="translated">이렇게하면 몇 시간 또는 몇 분이 두 번 발생하는 기간을 걸을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b60de2541acc5faacd938ec0f0eba22688a97b01" translate="yes" xml:space="preserve">
          <source>To the &lt;a href=&quot;https://www.jcp.org/&quot;&gt;Java Community Process&lt;/a&gt; members I recommend:</source>
          <target state="translated">&lt;a href=&quot;https://www.jcp.org/&quot;&gt;Java Community Process&lt;/a&gt; 회원에게 다음을 권장합니다.</target>
        </trans-unit>
        <trans-unit id="6bd7890badd212524f07fa62eb450fca97ffbef9" translate="yes" xml:space="preserve">
          <source>Use dates and times in UTC wherever possible.</source>
          <target state="translated">가능하면 UTC로 날짜와 시간을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c2ce6e9f01ab31c91c6ec268e87f5a3e7c9631a0" translate="yes" xml:space="preserve">
          <source>When incrementing time you should convert back to UTC and then add or subtract. Use the local time only for display.</source>
          <target state="translated">시간이 증가하면 UTC로 다시 변환 한 다음 더하거나 빼야합니다. 현지 시간 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="e41c0f15f4012cc34cd7401c111b10939a9f0632" translate="yes" xml:space="preserve">
          <source>When it was &lt;code&gt;23:54:07&lt;/code&gt; in Shanghai, the local standard time, but after 5 minutes and 52 seconds, it turned to the next day at &lt;code&gt;00:00:00&lt;/code&gt;, and then local standard time changed back to &lt;code&gt;23:54:08&lt;/code&gt;. So, that's why the difference between the two times is 343 seconds not 1 second, as you would have expected.</source>
          <target state="translated">현지 &lt;code&gt;23:54:07&lt;/code&gt; 인 상하이에서 23:54:07 이었지만 5 분 52 초 후 다음 날 &lt;code&gt;00:00:00&lt;/code&gt; 으로 돌아간 후 현지 표준시가 &lt;code&gt;23:54:08&lt;/code&gt; 로 다시 변경되었습니다. . 그래서 두 시간 사이의 차이가 예상했던 것처럼 1 초가 아닌 343 초입니다.</target>
        </trans-unit>
        <trans-unit id="0c92b6b65def6ef6d62c2b2bf1cdc1784a43eefe" translate="yes" xml:space="preserve">
          <source>When local standard time was about to reach Sunday, 1. January 1928,
  00:00:00 clocks were turned backward 0:05:52 hours to Saturday, 31.
  December 1927, 23:54:08 local standard time instead</source>
          <target state="translated">현지 표준시가 1 월 1 일 일요일에 도달하려고했을 때 1928 년 1 월 1 일 00:00:00 시계가 0:05:52 시간에서 0:05:52 시간으로 되돌아갔습니다.</target>
        </trans-unit>
        <trans-unit id="73d4aa31d8c6b5023622dc30633d91c8e5f478f9" translate="yes" xml:space="preserve">
          <source>Why is &lt;code&gt;ld4-ld3&lt;/code&gt; not &lt;code&gt;1&lt;/code&gt; (as I would expect from the one-second difference in the times), but &lt;code&gt;353&lt;/code&gt;?</source>
          <target state="translated">왜 &lt;code&gt;ld4-ld3&lt;/code&gt; 이 &lt;code&gt;1&lt;/code&gt; 이 아닌 (시간의 1 초 차이에서 예상되는 것처럼) &lt;code&gt;353&lt;/code&gt; 입니까?</target>
        </trans-unit>
        <trans-unit id="d2a71713da9e82099ccbad90518de1ca9e1bb60c" translate="yes" xml:space="preserve">
          <source>Why is subtracting these two times (in 1927) giving a strange result</source>
          <target state="translated">왜 1927 년에이 두 번 빼는 것이 이상한 결과를 낳는가?</target>
        </trans-unit>
        <trans-unit id="9fc9644ca504b8a7d6cc99d99594925a6e30ae17" translate="yes" xml:space="preserve">
          <source>You can check whether the transition is an overlap where there's more than one valid offset for that date/time or a gap where that date/time is not valid for that zone id - by using the &lt;code&gt;isOverlap()&lt;/code&gt; and &lt;code&gt;isGap()&lt;/code&gt; methods on &lt;code&gt;zot4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;isOverlap()&lt;/code&gt; 에서 isOverlap () 및 &lt;code&gt;isGap()&lt;/code&gt; 메소드를 사용하여 전환이 해당 날짜 / 시간에 대해 둘 이상의 유효한 오프셋이있는 겹침인지 또는 해당 영역 ID에 대해 해당 날짜 / 시간이 유효하지 않은 갭 &lt;code&gt;zot4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46cca3c2b359b243aaf93432f10772e5e013b14e" translate="yes" xml:space="preserve">
          <source>You can see the same problem comparing &lt;code&gt;1927-12-31 23:59:59&lt;/code&gt; with &lt;code&gt;1928-01-01 00:00:00&lt;/code&gt;, though, in this case, it is the earlier offset that produces the longer divergence, and it is the earlier date that has two possible offsets.</source>
          <target state="translated">&lt;code&gt;1927-12-31 23:59:59&lt;/code&gt; 와 &lt;code&gt;1928-01-01 00:00:00&lt;/code&gt; 과 비교할 때 동일한 문제가 발생할 수 있지만이 경우 더 긴 분기를 생성하는 초기 오프셋이며 두 개의 가능한 오프셋이있는 이전 날짜.</target>
        </trans-unit>
        <trans-unit id="d0fc95a43660c9f95b3383aec1ea859ebd40f9a6" translate="yes" xml:space="preserve">
          <source>You've encountered a &lt;a href=&quot;http://timeanddate.com/worldclock/clockchange.html?n=237&amp;amp;year=1927&quot;&gt;local time discontinuity&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://timeanddate.com/worldclock/clockchange.html?n=237&amp;amp;year=1927&quot;&gt;현지 시간 불연속&lt;/a&gt; 이 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="851c4419c76cc7437e9fc5b06b0d5a51f136d8c6" translate="yes" xml:space="preserve">
          <source>export LC_ALL=C TZ=UTC</source>
          <target state="translated">수출 LC_ALL = C TZ = UTC</target>
        </trans-unit>
        <trans-unit id="894fa40b06e8625588b6dbe8fd0fdc94e07482b6" translate="yes" xml:space="preserve">
          <source>make localized methods not the default, but require the user to explicitly request localization.</source>
          <target state="translated">현지화 된 메소드를 기본값으로 설정하지 말고 사용자에게 명시 적으로 현지화를 요청해야합니다.</target>
        </trans-unit>
        <trans-unit id="e39b6549994f5fbdde97320628c30d6d2b245a1a" translate="yes" xml:space="preserve">
          <source>never use localized implementations unless absolutely necessary (ie for display only)</source>
          <target state="translated">반드시 필요한 경우가 아니면 현지화 된 구현을 사용하지 마십시오 (예 : 디스플레이 전용).</target>
        </trans-unit>
        <trans-unit id="6fd0469b691655f5c5d7e7cf3174ba1a2fc60148" translate="yes" xml:space="preserve">
          <source>set your system clock to UTC</source>
          <target state="translated">시스템 시계를 UTC로 설정</target>
        </trans-unit>
        <trans-unit id="cf7886d28aed4eb23b330f782c10d18ca9ee1834" translate="yes" xml:space="preserve">
          <source>use UTF-8/UTC as the &lt;em&gt;FIXED&lt;/em&gt; default instead because that's simply the default today. There is no reason to do something else, except if you want to produce threads like this.</source>
          <target state="translated">UTF-8 / UTC를 &lt;em&gt;FIXED&lt;/em&gt; 기본값으로 대신 사용하십시오. 이것이 오늘날의 기본값이기 때문입니다. 이와 같은 스레드를 생성하려는 경우를 제외하고는 다른 작업을 수행 할 이유가 없습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
