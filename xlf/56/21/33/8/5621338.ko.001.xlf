<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/5621338">
    <body>
      <group id="5621338">
        <trans-unit id="186ac159591784d588a50b2847718b6511545f93" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;JTable&lt;/code&gt; should be added into the &lt;code&gt;JScrollPane&lt;/code&gt; which actually should be added into the &lt;code&gt;JPanel&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;JTable&lt;/code&gt; 은 &lt;code&gt;JScrollPane&lt;/code&gt; 에 추가되어야하며 실제로 &lt;code&gt;JPanel&lt;/code&gt; 에 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="ae9c8831cf88e1b19fd5162142d9125984b84731" translate="yes" xml:space="preserve">
          <source>Also when designing your dialog, remember that you can and should &lt;strong&gt;nest your layouts&lt;/strong&gt;: one JPanel inside another JPanel (e.g. a GridLayout inside a BorderLayout). Please note: a 'good' dialog should &lt;strong&gt;resize properly&lt;/strong&gt;, so that if the user resizes your Frame, you want to automatically extend your information objects such as your table, and not show large areas of JPanel background. That's something you cannot achieve with a NullLayout.</source>
          <target state="translated">또한 대화 상자를 디자인 할 때 &lt;strong&gt;레이아웃을 중첩&lt;/strong&gt; 할 수 있고 &lt;strong&gt;중첩&lt;/strong&gt; 해야한다는 것을 기억 &lt;strong&gt;하십시오&lt;/strong&gt; : 하나의 JPanel을 다른 JPanel 안에 (예 : BorderLayout 안의 GridLayout). 참고 : '좋은'대화 상자의 &lt;strong&gt;크기가 올바르게 조정&lt;/strong&gt; 되어 사용자가 프레임의 크기를 &lt;strong&gt;조정할&lt;/strong&gt; 경우 테이블과 같은 정보 객체를 자동으로 확장하고 JPanel 배경의 넓은 영역을 표시하지 않으려 고합니다. NullLayout으로는 달성 할 수없는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a92c9956142c6600c1bcc3b4f219073b71d0f4cf" translate="yes" xml:space="preserve">
          <source>As I can remember, the &lt;strong&gt;null&lt;/strong&gt; layout means an absolute position so it will be pretty hard you to count the X point for your JTable left upper corner location. But if you just want to have all panel components one by one you can use FlowLayout() manager as</source>
          <target state="translated">내가 기억할 수 있듯이 &lt;strong&gt;null&lt;/strong&gt; 레이아웃은 절대 위치를 의미하므로 JTable 왼쪽 상단 위치의 X 포인트를 계산하기가 매우 어렵습니다. 그러나 모든 패널 구성 요소를 하나씩 원한다면 FlowLayout () 관리자를 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9239a43eb7f54cb5c66973ef22c669aff7ebc1b" translate="yes" xml:space="preserve">
          <source>But there are probably cases - somewhere in this big world - where a NullLayout is just the thing. So here's an example:</source>
          <target state="translated">그러나 NullLayout이 중요한 곳인 아마도이 큰 세상 어딘가에있을 것입니다. 여기 예가 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8e7d5edae0c2384f70bf06c5a50dbf230df9fb6d" translate="yes" xml:space="preserve">
          <source>Don't use a null layout.  Learn to use LayoutManagers:</source>
          <target state="translated">null 레이아웃을 사용하지 마십시오. LayoutManager 사용 방법을 배웁니다.</target>
        </trans-unit>
        <trans-unit id="5e7e0d57bcc0e19bb930769580534809f04b6a68" translate="yes" xml:space="preserve">
          <source>Enjoy, Boro.</source>
          <target state="translated">보로</target>
        </trans-unit>
        <trans-unit id="4181e04abb33d597c4c7a4cd8429f2155fc22133" translate="yes" xml:space="preserve">
          <source>First, you should seriously consider other Layout managers, for example the BorderLayoutManager (new JPanel(new BorderLayout())) is a good start.</source>
          <target state="translated">먼저 다른 레이아웃 관리자를 신중하게 고려해야합니다. 예를 들어 BorderLayoutManager (new JPanel (new BorderLayout ()))는 좋은 시작입니다.</target>
        </trans-unit>
        <trans-unit id="481bebe8a5d31e64b2f74a3439be89cd0506fe93" translate="yes" xml:space="preserve">
          <source>Good luck</source>
          <target state="translated">행운을 빕니다</target>
        </trans-unit>
        <trans-unit id="70376458c7e1d59978b45b6a33d1a41e52fb91db" translate="yes" xml:space="preserve">
          <source>Good luck.</source>
          <target state="translated">행운을 빕니다.</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">도움이 되었기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="d939797b5b318b3e280706024a5a6398dc1c8eb0" translate="yes" xml:space="preserve">
          <source>How to add JTable in JPanel with null layout</source>
          <target state="translated">null 레이아웃으로 JPanel에 JTable을 추가하는 방법</target>
        </trans-unit>
        <trans-unit id="a0be2819a4f92c435b2d4387a3acddc286308366" translate="yes" xml:space="preserve">
          <source>I want to add &lt;code&gt;JTable&lt;/code&gt; into &lt;code&gt;JPanel&lt;/code&gt; whose layout is &lt;code&gt;null&lt;/code&gt;.  &lt;code&gt;JPanel&lt;/code&gt; contains other components. I have to add &lt;code&gt;JTable&lt;/code&gt; at proper position.</source>
          <target state="translated">레이아웃이 &lt;code&gt;null&lt;/code&gt; 인 &lt;code&gt;JPanel&lt;/code&gt; 에 &lt;code&gt;JTable&lt;/code&gt; 을 추가하고 싶습니다. &lt;code&gt;JPanel&lt;/code&gt; 에는 다른 구성 요소가 포함되어 있습니다. 적절한 위치에 &lt;code&gt;JTable&lt;/code&gt; 을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="bc0f700004a07bf32b01639ddd937026f3b9a09c" translate="yes" xml:space="preserve">
          <source>If you are using null layout manager you always need to set the bounds of a component.
That is the problem in your case.</source>
          <target state="translated">null 레이아웃 관리자를 사용하는 경우 항상 구성 요소의 경계를 설정해야합니다. 그것이 귀하의 경우 문제입니다.</target>
        </trans-unit>
        <trans-unit id="9f1a1b1aea32f704fe7621b2e4d81111a1183339" translate="yes" xml:space="preserve">
          <source>If you don't care about the precision of components size you can use pure &lt;code&gt;BorderLayout&lt;/code&gt; and combine it with &lt;code&gt;FlowLayout&lt;/code&gt; and &lt;code&gt;GridLayout&lt;/code&gt;. if you need precision - use jgoodies &lt;code&gt;FormLayout&lt;/code&gt;.</source>
          <target state="translated">구성 요소 크기의 정밀도에 신경 쓰지 않으면 순수한 &lt;code&gt;BorderLayout&lt;/code&gt; 을 사용하고 &lt;code&gt;FlowLayout&lt;/code&gt; 및 &lt;code&gt;GridLayout&lt;/code&gt; 과 결합 할 수 있습니다. 정밀도가 필요한 경우 jgoodies &lt;code&gt;FormLayout&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9b28f9b80322abfaac3b91d01c97635d4a9e417d" translate="yes" xml:space="preserve">
          <source>If you really want that fine-grained control, maybe try GridBagLayout first before going mudding with the UI arrangement.</source>
          <target state="translated">세밀한 제어를 원한다면 UI 배열로 머딩하기 전에 GridBagLayout을 먼저 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="758b3dced983942719348a0df3eca9bb283e5a5e" translate="yes" xml:space="preserve">
          <source>LayoutManagers allow you to properly handle things window resizing or dynamic component counts.  They might seem intimidating at first, but they are worth the effort to learn.</source>
          <target state="translated">LayoutManager를 사용하면 사물 크기 조정 또는 동적 구성 요소 수를 올바르게 처리 할 수 ​​있습니다. 처음에는 위협적인 것처럼 보일지 모르지만 배우려고 노력할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="72e96856e48a92e52c2ca3be37508fa4bc1d77bd" translate="yes" xml:space="preserve">
          <source>Mac OS X Aqua PLAF</source>
          <target state="translated">맥 OS X 아쿠아 PLAF</target>
        </trans-unit>
        <trans-unit id="feec1ce0b3cb81919adc3e10ee50e10583ca00be" translate="yes" xml:space="preserve">
          <source>Nested/Combination Layout Example</source>
          <target state="translated">중첩 / 조합 레이아웃 예</target>
        </trans-unit>
        <trans-unit id="b5c4cc6ea8999cfde14ad7bce3ea25b154c4c3fa" translate="yes" xml:space="preserve">
          <source>NestedLayoutExample.java</source>
          <target state="translated">NestedLayoutExample.java</target>
        </trans-unit>
        <trans-unit id="add98ea6ccfd8daaf0d2caf73eac2515f5144a43" translate="yes" xml:space="preserve">
          <source>Nimbus PLAF</source>
          <target state="translated">님 버스 PLAF</target>
        </trans-unit>
        <trans-unit id="fc7ae457a2457685fa6d3a8839bad178bfd3a329" translate="yes" xml:space="preserve">
          <source>Notable aspects of the code are:</source>
          <target state="translated">코드의 주목할만한 측면은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57c0810bd4d1924ad3737eb78ecc93ebb64bcc61" translate="yes" xml:space="preserve">
          <source>One aspect of layouts that is &lt;em&gt;not&lt;/em&gt; covered well by the tutorial is that of nested layouts, putting one layout inside another to get complex effects.</source>
          <target state="translated">튜토리얼에서 다루지 &lt;em&gt;않은&lt;/em&gt; 레이아웃의 한 가지 측면은 중첩 된 레이아웃으로, 한 레이아웃을 다른 레이아웃 안에 넣어 복잡한 효과를 얻는 것입니다.</target>
        </trans-unit>
        <trans-unit id="14a2ac8deddc6b8a76d9f09213854697887e08ed" translate="yes" xml:space="preserve">
          <source>Other Screen Shots</source>
          <target state="translated">다른 스크린 샷</target>
        </trans-unit>
        <trans-unit id="86be0d816121adc9166299775d1f267ede0d6872" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FormLayout&lt;/code&gt; is really tricky one, but you can play a little with &lt;code&gt;WindowBuilder&lt;/code&gt; (which is embedded into Eclipse) and a look at the code it generates. It may look complicated but it is just an ignorance.</source>
          <target state="translated">&lt;code&gt;FormLayout&lt;/code&gt; 은 정말 까다로울 수 있지만 &lt;code&gt;WindowBuilder&lt;/code&gt; (Eclipse에 포함되어 있음)를 사용하여 생성하는 코드를 살펴볼 수 있습니다. 복잡해 보이지만 무지 일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="158e7fb747f4d4094fde9a27c514a80b6cd9a919" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;JPanel&lt;/code&gt; should have some layout manager.</source>
          <target state="translated">&lt;code&gt;JPanel&lt;/code&gt; 에는 레이아웃 관리자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="d789e2b4e332f79db6bbdd54ac18f260b0338a53" translate="yes" xml:space="preserve">
          <source>The GUI is expandable to the user's need.</source>
          <target state="translated">GUI는 사용자의 필요에 따라 확장 가능합니다.</target>
        </trans-unit>
        <trans-unit id="ddd6768ded446a3ca0c9b0f82e7c4487ed5ae596" translate="yes" xml:space="preserve">
          <source>The Java Tutorial has comprehensive information on using layout managers. See the &lt;a href=&quot;http://download.oracle.com/javase/tutorial/uiswing/layout/index.html&quot;&gt;Laying Out Components Within a Container&lt;/a&gt; lesson for further details.</source>
          <target state="translated">Java Tutorial에는 레이아웃 관리자 사용에 대한 포괄적 인 정보가 있습니다. 자세한 내용은 &lt;a href=&quot;http://download.oracle.com/javase/tutorial/uiswing/layout/index.html&quot;&gt;컨테이너 내에 구성 요소 배치&lt;/a&gt; 단원을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d8bbe9bd89921a2428636336ab61007d6c706648" translate="yes" xml:space="preserve">
          <source>The following code puts a variety of components into a frame to demonstrate how to use nested layouts.  All the layouts that are explicitly set are shown as a titled-border for the panel on which they are used.</source>
          <target state="translated">다음 코드는 중첩 된 레이아웃을 사용하는 방법을 보여주기 위해 다양한 구성 요소를 프레임에 넣습니다. 명시 적으로 설정된 모든 레이아웃은 사용되는 패널의 제목 테두리로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="c75a6c74a1702e5554553e1a18906f35677b872b" translate="yes" xml:space="preserve">
          <source>The image in the bottom of the split-pane is centered in the scroll-pane.</source>
          <target state="translated">분할 창의 아래쪽에있는 이미지는 스크롤 창의 중앙에 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb302983c1f5ab6c93eeaf15ff6df20660f3b0b2" translate="yes" xml:space="preserve">
          <source>The label instances on the left are dynamically added using the button.</source>
          <target state="translated">왼쪽의 라벨 인스턴스는 버튼을 사용하여 동적으로 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="53fe379088c8929dbbd54aeb2500a5fcece94d1a" translate="yes" xml:space="preserve">
          <source>There is a combo-box to change PLAF (Pluggable Look and Feel) at run-time.</source>
          <target state="translated">런타임에 PLAF (Pluggable Look and Feel)를 변경하는 콤보 상자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="93b98c29df31d41c91abf5b07dc797ca6bf1541f" translate="yes" xml:space="preserve">
          <source>Try this.</source>
          <target state="translated">이 시도.</target>
        </trans-unit>
        <trans-unit id="3e06b4083db08edfb0879ca18b569b3ad95fa007" translate="yes" xml:space="preserve">
          <source>Ubuntu GTK+ PLAF</source>
          <target state="translated">우분투 GTK + PLAF</target>
        </trans-unit>
        <trans-unit id="0a2dc889c093c1bf1c0ce5694b272d8b5e788120" translate="yes" xml:space="preserve">
          <source>When a component have a &quot;null&quot; layout, you have to manage the layout by yourself, that means you have to calculate the dimensions and locations for the children of the component to decide where they are drawn. Quite tedious unless it is absolutely necessary.</source>
          <target state="translated">구성 요소에 &quot;널&quot;레이아웃이있는 경우 레이아웃을 직접 관리해야합니다. 즉, 구성 요소의 하위 요소가 그려지는 위치를 결정하기 위해 구성 요소의 위치와 치수를 계산해야합니다. 꼭 필요한 경우가 아니면 상당히 지루합니다.</target>
        </trans-unit>
        <trans-unit id="8ccd5e726ed3c6c905bd1571c731170a95f7f606" translate="yes" xml:space="preserve">
          <source>Windows PLAF</source>
          <target state="translated">윈도우 PLAF</target>
        </trans-unit>
        <trans-unit id="b29d282824c64b25e86a2054f9bf4608961ffdc8" translate="yes" xml:space="preserve">
          <source>You can make use of the following code. To add JTable to JPanel.</source>
          <target state="translated">다음 코드를 사용할 수 있습니다. JPanel에 JTable을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="2f8bcfeeda4b0cd37a4304bbcb1bddf8f23af95b" translate="yes" xml:space="preserve">
          <source>You should do what everyone suggest here and go and use some layout manager believe they save time.
Go and check out the tutorial in @jzd's post.</source>
          <target state="translated">모두가 여기에서 제안하는 것을하고 가서 레이아웃 관리자가 시간을 절약한다고 믿는 것을 사용해야합니다. @jzd의 포스트에서 튜토리얼을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4a2a3b37056943abc0d43359518e7507f0f541b3" translate="yes" xml:space="preserve">
          <source>or if you need to fill the panel you should use GridLayout() as...</source>
          <target state="translated">또는 패널을 채워야하는 경우 GridLayout ()을 다음과 같이 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8fc4182cf0edf28554c39b7982f104e068391c5b" translate="yes" xml:space="preserve">
          <source>table model depends on your requirement</source>
          <target state="translated">테이블 모델은 요구 사항에 따라 다릅니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
