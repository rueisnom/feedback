<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2307283">
    <body>
      <group id="2307283">
        <trans-unit id="62c23e7ef4be86040d6c792d74b8103bb503c43a" translate="yes" xml:space="preserve">
          <source>&quot;Tends towards&quot; has the usual mathematical meaning from 'analysis': for example, that &quot;if you pick &lt;em&gt;any&lt;/em&gt; arbitrarily small non-zero constant &lt;code&gt;k&lt;/code&gt;, then I can find a corresponding value &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;((time/(a*log(n))) - 1)&lt;/code&gt; is less than &lt;code&gt;k&lt;/code&gt; for all values of &lt;code&gt;n&lt;/code&gt; greater than &lt;code&gt;X&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신이 선택하면 예를 들어, &quot;즉, '분석'에서 일반적인 수학적 의미가있다&quot;쪽으로 경향이있다 &quot; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어떤&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 임의의 작은 영이 아닌 상수의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;k&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 그때는 해당 값을 찾을 수 있습니다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 같은 그 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;((time/(a*log(n))) - 1)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 &lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 보다 큰 &lt;/font&gt; &lt;code&gt;n&lt;/code&gt; 의&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 모든 값에 대해 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;k&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 보다 작습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &quot;&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54e10c43522458d7384b566fb9db05322a518452" translate="yes" xml:space="preserve">
          <source>(you take the lg of each side, lg being the log base 2)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(당신은 각면의 lg를 가지고, lg는 로그베이스 2입니다)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="44c99847d54ae4d00b74068530a05dd1fef0dc04" translate="yes" xml:space="preserve">
          <source>*Remember that big-O notation, &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation#Formal_definition&quot;&gt;by definition&lt;/a&gt;, constants don't matter. Also by the &lt;a href=&quot;http://en.wikipedia.org/wiki/Change_of_base_formula_for_logs#Changing_the_base&quot;&gt;change of base rule&lt;/a&gt; for logarithms, the only difference between logarithms of different bases is a constant factor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;* &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation#Formal_definition&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정의에&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 따라 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;big-O 표기법 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 중요하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로그에 대한 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Change_of_base_formula_for_logs#Changing_the_base&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 규칙&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;변경에&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 따라 서로 다른 기본의 로그 간의 유일한 차이는 상수 요소입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48e253e5ab06e6976e35c9bdcea7e10b034cc3d4" translate="yes" xml:space="preserve">
          <source>... then this would be O(n squared) because, no matter what the values of the constants a, b, c, and non-zero d, the &lt;code&gt;d*n*n&lt;/code&gt; term would always dominate over the others for any sufficiently large value of n.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... 다음 상수 a, b, c 및 0이 아닌 d의 값에 관계없이 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;d*n*n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 항은 다른 것보다 충분히 우세 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하기 때문에 O (n 제곱)입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n의 큰 값&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a6b947aa846b5da9e63669d7e0ab43fa7149876" translate="yes" xml:space="preserve">
          <source>1. Physical System</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1. 물리 시스템&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2da5718e4456d8946ed7cc039bbf65bc4baf31dc" translate="yes" xml:space="preserve">
          <source>2. Programming Language</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2. 프로그래밍 언어&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c047d0c08b0f62ebc42d10b65de4db18f9b150e9" translate="yes" xml:space="preserve">
          <source>3 is the logarithm of 1,000, and 6 is the logarithm of 1,000,000 (base 10).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3은 1,000의 로그이고 6은 1,000,000의 로그 (기본 10)입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="864313c2df45c8ba64dccb8ec4055125eac5d1f5" translate="yes" xml:space="preserve">
          <source>3. coding Style</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3. 코딩 스타일&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f2e04afdb09df34f9f44473a7a1ccb50a406dc78" translate="yes" xml:space="preserve">
          <source>4. And much more ......</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;4. 그리고 훨씬 더 ......&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d563ed5a666051353255960e6c2817c3c0755862" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Linear Search&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;선형 검색&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b5fe40e00cd38153f7725ae75b9e9b6d20e78737" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The actual execution time is not a good measure for analysis.
&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제 실행 시간은 분석을위한 좋은 척도가 아닙니다. &lt;/font&gt;&lt;/font&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7302ce438edbf9d107087c0d00e63e527a7611c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log N)&lt;/code&gt; basically means time goes up linearly while the &lt;code&gt;n&lt;/code&gt; goes up exponentially. So if it takes &lt;code&gt;1&lt;/code&gt; second to compute &lt;code&gt;10&lt;/code&gt; elements, it will take &lt;code&gt;2&lt;/code&gt; seconds to compute &lt;code&gt;100&lt;/code&gt; elements, &lt;code&gt;3&lt;/code&gt; seconds to compute &lt;code&gt;1000&lt;/code&gt; elements, and so on.</source>
          <target state="translated">&lt;code&gt;O(log N)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 기본적으로 시간이 선형으로 증가하고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 기하 급수적 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;으로 증가 함을 의미 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 &lt;/font&gt; &lt;code&gt;10&lt;/code&gt; 개의&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 요소 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 계산 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하는 데 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 초가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;걸리면 &lt;/font&gt; &lt;code&gt;100&lt;/code&gt; 개의&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 요소 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 계산하는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데 &lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 초 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, &lt;/font&gt; &lt;code&gt;1000&lt;/code&gt; 개의&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 요소 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 계산하는 데 &lt;/font&gt; &lt;code&gt;3&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 초가 소요됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29521e79b284726f262e57f3d5e15142bdd210f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log n)&lt;/code&gt; refers to a function (or algorithm, or step in an algorithm) working in an amount of time proportional to the logarithm (usually base 2 in most cases, but not always, and in any event this is insignificant by big-O notation*) of the size of the input.</source>
          <target state="translated">&lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 대수에 비례하는 시간 (대개 대부분의 경우 기본 2이지만 항상 그런 것은 아님)으로 작동하는 함수 (또는 알고리즘 또는 알고리즘의 단계 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;)를&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의미하며, 어떤 경우에도 이것이 큰 의미는 없습니다. 입력 크기의 -O 표기 *)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a33e6cf6849c1bfd0bc219a80b69e82c56092cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log n)&lt;/code&gt; running times are very common in any sort of divide-and-conquer application, because you are (ideally) cutting the work in half every time. If in each of the division or conquer steps, you are doing constant time work (or work that is not constant-time, but with time growing more slowly than &lt;code&gt;O(log n)&lt;/code&gt;), then your entire function is &lt;code&gt;O(log n)&lt;/code&gt;. It's fairly common to have each step require linear time on the input instead; this will amount to a total time complexity of &lt;code&gt;O(n log n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 실행 시간은 모든 종류의 분할 및 정복 응용 프로그램에서 매우 일반적입니다. 매번 작업을 절반 씩 (이상적으로) 자르기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 분할 또는 정복 단계에서 일정 시간 작업 (또는 일정 시간이 아니지만 작업 시간이 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 보다 느리게 증가하는 작업)을 수행하는 경우 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전체 기능은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 단계마다 입력에 선형 시간이 필요한 것이 일반적입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 총 시간 복잡성에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해당합니다&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abb48e63c4d7db950366fd3b0dfe2e096b2f2c6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n^2)&lt;/code&gt; is obtained easily by nesting standard for loops.</source>
          <target state="translated">&lt;code&gt;O(n^2)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;표준 for 루프를 중첩하여 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n ^ 2)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 를 쉽게 얻을 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="664fced4730451fe1325328dbba584863529c241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log x to base b = y&lt;/code&gt; is the inverse of &lt;code&gt;b^y = x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;log x to base b = y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 &lt;/font&gt; &lt;code&gt;b^y = x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 역수입니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8966595017a7ad226eea24cdb7b873f35223518" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disclaimer: The rope-logarithm example was grabbed from the excellent &lt;a href=&quot;https://www.amazon.co.uk/Mathematicians-Delight-Dover-Books-Mathematics/dp/0486462404&quot;&gt;Mathematician's Delight book by W.Sawyer&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;면책 조항 : 로프 로그 예제는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.amazon.co.uk/Mathematicians-Delight-Dover-Books-Mathematics/dp/0486462404&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;W.Sawyer의&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 우수한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수학자 딜라이트 책에서 발췌 한 것&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="93b23fdcd6527df1dfdb4c0912b0fc04e2169d8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;n/(2^steps)=1 &amp;lt;=&amp;gt; n=2^steps &amp;lt;=&amp;gt; lg(n)=steps&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;n/(2^steps)=1 &amp;lt;=&amp;gt; n=2^steps &amp;lt;=&amp;gt; lg(n)=steps&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cecb08b9e2796a2712fcae78ab1e27ab18af4c8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 10&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 10&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="99059f5bd83e63ed1fa04489413c400ab49828dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 11&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 11&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c484f87bf2e7520bc9c13f2425548040f8ca656" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 12&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 12&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f792b9e20e7bd31191ec1ce96f2411274a40a430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 13&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 13&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87a6cf7b68bf7e84ece7cceaa6050ec935e54006" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 1 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc4f1ab0bbde20810982288d34df68bf23df808c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 2 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3580ba8f5fa81d2b6842006c382e678600fdf0eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 3 - This acts like &quot;log_2&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 3- &quot;log_2&quot;와 같은 역할&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50c2f6a991daf9f2251bac09adf66a8ed3c4e3c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 4 - This acts like &quot;log_3&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 4- &quot;log_3&quot;과 같은 기능&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ade3ccd18a1516ffea265742c9c4262ac85f74a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 5 - This acts like &quot;log_1.02&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 5- &quot;log_1.02&quot;와 같은 기능&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c2e9bc08ef7fff3d18351a20b3844a561de3e6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 6&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 6&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6042164656649616c8bd314b7001a62996f8c3e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 7&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 7&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3813a73f44ab79ffff5fc062e96df9c77be57f07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 8&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 8&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a43edf9ec98a0da521d4159e35c1204784fc256" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 9&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 9&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc851456bbf3606cfd07da8d669ac31d4a0e4865" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1) (in the average case):&lt;/strong&gt; Given the page that a person's name is on and their name, find the phone number.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (1) (평균적인 경우) :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사람의 이름이있는 페이지와 이름이 주어지면 전화 번호를 찾으십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="382f5486747667379a673e16fda00accedb3c67b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1) (in the worst case):&lt;/strong&gt; Given the page that a business's name is on and the business name, find the phone number.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (1) (최악의 경우) :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 업체 이름이있는 페이지와 업체 이름이 주어지면 전화 번호를 찾으십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db128fc404aa0da1b743b40724a8e30d03d62726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1) - Constant Time Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (1)-일정 시간 예 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dda1fa945adc6eb16b365bc6c67afd8d2bd88f75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log n):&lt;/strong&gt; Given a person's name, find the phone number by picking a random point about halfway through the part of the book you haven't searched yet, then checking to see whether the person's name is at that point. Then repeat the process about halfway through the part of the book where the person's name lies. (This is a binary search for a person's name.)</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n) :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사람의 이름이 주어지면 아직 검색하지 않은 책 부분의 중간 지점에서 임의의 지점을 선택한 다음 그 사람의 이름이 해당 지점에 있는지 확인하여 전화 번호를 찾습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음 그 사람의 이름이있는 책 부분의 절반 정도에 대해 과정을 반복하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(이것은 사람의 이름에 대한 이진 검색입니다.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="367cb7ed6ccc0a378006813f8be3af12e274a6c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log(n)) - Logarithmic Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log (n))-대수 예제 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="543a66101c585e2dc5a2e8d042e2d985b1274be7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n &amp;middot; n!):&lt;/strong&gt; We're ready to load the phonebooks onto the shipping dock. Unfortunately, the robot that was supposed to load the books has gone haywire: it's putting the books onto the truck in a random order! Even worse, it loads all the books onto the truck, then checks to see if they're in the right order, and if not, it unloads them and starts over. (This is the dreaded &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Bogosort&quot;&gt;bogo sort&lt;/a&gt;&lt;/strong&gt;.)</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n &amp;middot; n!) :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 전화 번호부를 배송 도크에로드 할 준비가되었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;불행하게도, 책을로드해야했던 로봇은 완전히 사라졌습니다 : 책을 무작위 순서로 트럭에 싣고 있습니다! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 나쁜 것은, 모든 서적을 트럭에 적재 한 다음, 올바른 순서인지 확인하고, 그렇지 않은 경우 적재를 해제하고 다시 시작하는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(이것은 두려운 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Bogosort&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보고 정렬&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1de65cc18d4f21d8e3a64ac738eb16027fb3867b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n log n):&lt;/strong&gt; There was a mix-up at the printer's office, and our phone book had all its pages inserted in a random order. Fix the ordering so that it's correct by looking at the first name on each page and then putting that page in the appropriate spot in a new, empty phone book.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n log n) :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 프린터 사무실에 혼동이 있었고 전화 번호부에 모든 페이지가 무작위로 삽입되었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 페이지의 이름을 확인한 다음 새 빈 전화 번호부의 해당 위치에 해당 페이지를 배치하여 순서가 올바른지 확인하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70127c240aa95e8b0ec96b3395f313034e9030aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n log n):&lt;/strong&gt; We want to personalize the phone book, so we're going to find each person or business's name in their designated copy, then circle their name in the book and write a short thank-you note for their patronage.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n log n) :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 전화 번호부를 개인화하고 싶기 때문에 지정된 사본에서 각 사람이나 회사 이름을 찾은 다음 책에서 이름을 동그라미로 표시하고 후원에 대한 짧은 감사의 글을 씁니다. .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b5606b21c0f2c96153c29e77b41f7fd85f0a0d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n) - Linear Time Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n)-선형 시간 예 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f43ccb38b5bf2cd670379ba3a1965f42b4771fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n):&lt;/strong&gt; Find all people whose phone numbers contain the digit &quot;5&quot;.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n) :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 전화 번호에 숫자 &quot;5&quot;가 포함 된 모든 사람을 찾습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75709c253759b933376bae3df6fbc5aea1471527" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n):&lt;/strong&gt; Given a phone number, find the person or business with that number.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n) :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 전화 번호가 주어지면 해당 번호의 사람이나 업체를 찾습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db4237adb37b8829a7cc9004385308260a533b0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n*log(n)) - nlog(n) Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n * log (n))-nlog (n) 예 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee37803266e306f1154c335eaba407e63fb9c491" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt; A mistake occurred at the office, and every entry in each of the phone books has an extra &quot;0&quot; at the end of the phone number. Take some white-out and remove each zero.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사무실에서 실수가 발생했으며 각 전화 번호부의 각 항목에는 전화 번호 끝에 &quot;0&quot;이 추가로 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;화이트 아웃을하고 각각의 0을 제거하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3a7fa1df845249458feef5121758e550acff4f5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n&lt;sup&gt;n&lt;/sup&gt;):&lt;/strong&gt; You fix the robot so that it's loading things correctly. The next day, one of your co-workers plays a prank on you and wires the loading dock robot to the automated printing systems. Every time the robot goes to load an original book, the factory printer makes a duplicate run of all the phonebooks! Fortunately, the robot's bug-detection systems are sophisticated enough that the robot doesn't try printing even more copies when it encounters a duplicate book for loading, but it still has to load every original and duplicate book that's been printed.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로봇이 올바르게 적재되도록 로봇을 고정시킵니다. 다음날 동료 중 한 명이 장난을 치고 로딩 독 로봇을 자동 인쇄 시스템에 연결합니다. 로봇이 원본 책을로드 할 때마다 팩토리 프린터는 모든 전화 번호부를 중복 실행합니다! 다행스럽게도, 로봇의 버그 감지 시스템은 중복 된 책이 적재 될 때 로봇이 더 많은 사본을 인쇄하려고 시도하지 않을 정도로 정교하지만 여전히 인쇄 된 모든 원본 및 복제 된 책을로드해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="baa3dcc6c7cb9768bae9c8737d449d37e482c784" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n^2) - n squared Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n ^ 2)-n 제곱 예 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c389c0632dce3cd1c5d250cbf01ee7bfb589c105" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n^3) - n cubed Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n ^ 3)-n 큐브 형 예 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1d7ddb9ca9305db3b69febe087986d85bdca4704" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Overview&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Overview&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec82ec2afdaeef73e3e33a4ff9e63ef02488d0d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Code Examples Of Various Big O Categories:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다양한 Big O 카테고리의 간단한 코드 예제 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="234aa035660484f0b043ef167e4eb0c4a6aff304" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what does O(log n) actually mean?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그렇다면 O (log n)은 실제로 무엇을 의미합니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e3286c2a6df794ce774454437c04c62779b831f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The logarithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대수&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72ef5689874ae61836de6559d76a3348730b20ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What about O(n log n)?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n log n)는 어떻습니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8505b2060537b9b8a16641d236c3c9169433e63f" translate="yes" xml:space="preserve">
          <source>A common algorithm with O(log n) time complexity is Binary Search whose recursive relation is T(n/2) + O(1) i.e. at every subsequent level of the tree you divide problem into half and do constant amount of additional work.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n) 시간 복잡성을 갖는 일반적인 알고리즘은 재귀 관계가 T (n / 2) + O (1) 인 이진 검색입니다. 즉, 트리의 모든 후속 레벨에서 문제를 반으로 나누고 일정한 양의 추가 작업을 수행합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e64150835103105f0ea6e31dc144d0c9f306ad8a" translate="yes" xml:space="preserve">
          <source>Actually, if you have a list of n elements, and create a binary tree from that list (like in the divide and conquer algorithm), you will keep dividing by 2 until you reach lists of size 1 (the leaves).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실제로 n 개의 요소 목록이 있고 해당 목록에서 이진 트리를 만들면 (분할 및 정복 알고리즘과 같이) 크기가 1 인 목록 (잎)에 도달 할 때까지 2로 계속 나눕니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="885a56ea0ae08ca84fb35233e67f695552695f1e" translate="yes" xml:space="preserve">
          <source>Algorithm 1 prints hello once and it doesn't depend on n, so it will always run in constant time, so it is &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 1은 hello를 한 번 인쇄하며 n에 의존하지 않으므로 항상 일정한 시간에 실행되므로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(1)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35be35b175c76af65d2827d2cf3dee1ef34934f1" translate="yes" xml:space="preserve">
          <source>Algorithm 2 prints hello 3 times, however it does not depend on an input size. Even as n grows, this algorithm will always only print hello 3 times. That being said 3, is a constant, so this algorithm is also &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 2는 hello를 3 번 ​​인쇄하지만 입력 크기에 의존하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n이 커지더라도이 알고리즘은 항상 hello를 3 번만 인쇄합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3이라고하는 것은 상수이므로이 알고리즘도 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(1)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="566ae46ca13a24c5b54b75fd8f752947062eed04" translate="yes" xml:space="preserve">
          <source>Algorithm 3 demonstrates an algorithm that runs in log_2(n). Notice the post operation of the for loop multiples the current value of i by 2, so &lt;code&gt;i&lt;/code&gt; goes from 1 to 2 to 4 to 8 to 16 to 32 ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 3은 log_2 (n)에서 실행되는 알고리즘을 보여줍니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래서, 루프 (2)에 의해 배수 I의 전류 값에 대한 포스트의 동작에 주목 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;i&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 32 16 8 4 2 1 간다 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="219cad7306c85bd667c5cb1b64143ac505019683" translate="yes" xml:space="preserve">
          <source>Algorithm 4 demonstrates log_3. Notice &lt;code&gt;i&lt;/code&gt; goes from 1 to 3 to 9 to 27...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 4는 log_3을 보여줍니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;주의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;i&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 27 9 3 1에서 이동 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a8454e3e9eaed77a0c84e7bcde53bb78684adbf" translate="yes" xml:space="preserve">
          <source>Algorithm 5 is important, as it helps show that as long as the number is greater than 1 and the result is repeatedly multiplied against itself, that you are looking at a logarithmic algorithm.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 5는 숫자가 1보다 크고 결과가 반복해서 자신에 대해 곱해지는 한, 로그 알고리즘을보고 있다는 것을 보여 주므로 중요합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="51aabda71f87b90773768c7a9973d25539b2adfd" translate="yes" xml:space="preserve">
          <source>Algorithm 9 is like algorithm 8, but each of the loops has allowed variations, which still result in the final result being &lt;code&gt;O(n*log(n))&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 9는 알고리즘 8과 유사하지만 각 루프마다 변형이 허용되므로 최종 결과는 여전히 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n*log(n))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17d79de1210f6f15a000af0169a5ef68b6ed4866" translate="yes" xml:space="preserve">
          <source>Algorithms (4th Edition)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 (제 4 판)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="546877fd41740873d1cfa8e4f36cf9b0df017323" translate="yes" xml:space="preserve">
          <source>Algorithms in the Divide and Conquer paradigm are of complexity O(logn). One example here, calculate your own power function,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Divide와 Conquer 패러다임의 알고리즘은 복잡하다 O (logn). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;한 가지 예를 들어, 자신의 전력 함수를 계산하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc69b8d895811f71046889c39e0d995b5f6f8de0" translate="yes" xml:space="preserve">
          <source>Although n is somewhere between 512 and 1023, only 10 iterations take place. This is because the step in the loop grows exponentially and thus takes only 10 iterations to reach the termination.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n이 512와 1023 사이에 있지만 10 회만 반복됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;루프의 단계가 기하 급수적으로 증가하므로 종료에 도달하는 데 10 회만 반복하기 때문입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="13fda95a4e29f31623e6b27919c9c2654912cdb6" translate="yes" xml:space="preserve">
          <source>Analyzing the running time of a program (example).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로그램의 실행 시간 분석 (예).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b430315d40268f6d421e3d42d2f41d05716445c7" translate="yes" xml:space="preserve">
          <source>Anatomy of a program&amp;rsquo;s statement execution frequencies.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;프로그램의 문장 실행 빈도 분석&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f024ce63ef78ef7b64b38e26fabafc1f314daaa6" translate="yes" xml:space="preserve">
          <source>And its not just search, whatever may be the work (increment, compare or any operation) its a function of input size.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 검색 (검색)뿐만 아니라 작업 (증가, 비교 또는 모든 작업)이 입력 크기의 기능 일 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3e0adb51e88db164baaa3fd268ad64b534eb5476" translate="yes" xml:space="preserve">
          <source>And so on.</source>
          <target state="translated">등등.</target>
        </trans-unit>
        <trans-unit id="7a8d4b0af6eedcdbdf7182951523d1cc82a773a9" translate="yes" xml:space="preserve">
          <source>And that's how you get O(log n) which is the amount of work that needs to be done on the above tree to reach a solution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 이것이 당신이 솔루션에 도달하기 위해 위의 트리에서 수행해야 할 작업량 인 O (log n)을 얻는 방법입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="430078eae25aa1035e9c5dded6c9d2dbbd85adf7" translate="yes" xml:space="preserve">
          <source>Another example is binary search, which has a running time of O(log&lt;sub&gt;2&lt;/sub&gt; n) because at every step you divide the search space by 2.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 예는 이진 검색으로, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 단계에서 검색 공간을 2로 나누기 때문에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실행 시간이 O (log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n)입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ea8b371babfbf6cdabc48efdcabde7886a45b20" translate="yes" xml:space="preserve">
          <source>Ant it seems that this notation was mostly have taken from mathematics.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개미이 표기법은 대부분 수학에서 가져온 것 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db52f24fa20a9333b6b58676f942da718a9e8a80" translate="yes" xml:space="preserve">
          <source>Applying this to your binary tree question so you have a good application: if you double the number of nodes in a binary tree, the height only increases by 1 (an additive amount).  If you double it again, it still only increased by 1.  (Obviously I'm assuming it stays balanced and such).  That way, instead of doubling your work when the problem size is multiplied, you're only doing very slightly more work. That's why O(log n) algorithms are awesome.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이진 트리 질문에 이것을 적용하면 좋은 응용 프로그램을 얻을 수 있습니다. 이진 트리의 노드 수를 두 배로 늘리면 높이는 1 (첨가량) 만 증가합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다시 두 배로 늘리면 여전히 1 증가했습니다 (분명히 균형을 유지한다고 가정합니다). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이렇게하면 문제의 크기를 곱할 때 작업을 두 배로 늘리는 대신 약간 더 많은 작업을 수행하게됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 O (log n) 알고리즘이 대단한 이유입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="32764ca168816d370c0095d83bb00526d97bc511" translate="yes" xml:space="preserve">
          <source>As I know from university the symbol was intoduced by German mathematician Landau (1877-1938)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 대학에서 알고 있듯이 독일 수학자 랜도 (1877-1938)에 의해 상징이 만들어졌습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0c50b5084a8768bf3848fba400f3d6b5a12bde9e" translate="yes" xml:space="preserve">
          <source>As the input size increases the work done(here the execution time) increases.(Hence proportionality)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입력 크기가 커질수록 완료된 작업 (여기서 실행 시간)이 증가합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="965b30064e173b5100a19b6d6ea70cf86fc6ba94" translate="yes" xml:space="preserve">
          <source>Assume we had instead a dataset with 32 elements. Continue the drawing above to find that we will now need 5 comparisons to find what we are searching for, as the tree has only grown one level deeper when we multiplied the amount of data. As a result, the complexity of the algorithm can be described as a logarithmic order.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대신 32 개의 요소가있는 데이터 세트가 있다고 가정합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터 양을 곱할 때 트리가 한 단계 깊게 성장했기 때문에 검색 대상을 찾기 위해 5 번의 비교가 필요하다는 것을 알기 위해 위의 그림을 계속하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결과적으로 알고리즘의 복잡성을 로그 순서로 설명 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1500b9ad9d3e53ed6762cb42f394ab0fc94c747c" translate="yes" xml:space="preserve">
          <source>Asymptotic complexity is the behavior of execution time of an algorithm while the time complexity is the actual execution time. But some people use these terms interchangeably.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;점근 적 복잡성은 알고리즘의 실행 시간의 동작이며 시간 복잡성은 실제 실행 시간입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 어떤 사람들은이 용어들을 서로 바꿔서 사용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b7364a52ea4e1ac22d7414be72af2283970927a4" translate="yes" xml:space="preserve">
          <source>At the first step, you divide by 2. You then have 2 lists (2^1), you divide each by 2, so you have 4 lists (2^2), you divide again, you have 8 lists (2^3)and so on until your list size is 1</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;첫 번째 단계에서는 2로 나눕니다. 그러면 2 개의 목록 (2 ^ 1)이 있고 각각 2로 나눕니다. 따라서 4 개의 목록 (2 ^ 2)이 있고 다시 나누면 8 개의 목록이 있습니다 (2 ^ 3). 목록 크기가 1이 될 때까지&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c089231c2cd527f03ef02173a14ef58e49378bb4" translate="yes" xml:space="preserve">
          <source>Because time complexity depends on various parameters viz.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시간 복잡도는 다양한 매개 변수 즉, z에 따라 달라집니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="79385006bae7e35860b6fe3468ec15323eadbe8e" translate="yes" xml:space="preserve">
          <source>Binary search is an example with complexity &lt;code&gt;O(log n)&lt;/code&gt;. Let's say that the nodes in the bottom level of the tree in figure 1 represents items in some sorted collection. Binary search is a divide-and-conquer algorithm, and the drawing shows how we will need (at most) 4 comparisons to find the record we are searching for in this 16 item dataset.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이진 검색은 복잡도 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그림 1에서 트리의 맨 아래 레벨에있는 노드는 정렬 된 콜렉션의 항목을 나타냅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이진 검색은 분할 및 정복 알고리즘이며,이 16 개의 항목 데이터 세트에서 검색중인 레코드를 찾기 위해 최대 4 개의 비교가 필요한 방법을 보여줍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be848c0e0760b865d37c7f1e1021bb006ee2006e" translate="yes" xml:space="preserve">
          <source>Binary tree is a case where a problem of size n is divided into sub-problem of size n/2 until we reach a problem of size 1:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이진 트리는 크기 n의 문제를 크기 1의 문제에 도달 할 때까지 크기 n / 2의 하위 문제로 나누는 경우입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3224959bcf8bf1a4e97341e888dd1713f7031354" translate="yes" xml:space="preserve">
          <source>But even in mathematical analysis sometimes this symbol was used in meaning &quot;C*g(n) &amp;gt; f(n) &amp;gt; 0&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 수학적 분석에서도이 기호는 &quot;C * g (n)&amp;gt; f (n)&amp;gt; 0&quot;을 의미하는 데 사용되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="028ac440b61f595ee3489b7aaf85ae807e104671" translate="yes" xml:space="preserve">
          <source>But what exactly is &lt;em&gt;O(log n)&lt;/em&gt;?  For example, what does it mean to say that the height of a complete binary tree is &lt;em&gt;O(log n)&lt;/em&gt;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 정확히 무엇 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 완전한 이진 트리의 높이가 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이라는 것은 무엇을 의미 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8956095c5174d4083eb653119d3665061530f125" translate="yes" xml:space="preserve">
          <source>But what exactly is O(log n)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 정확히 O (log n)는 무엇입니까&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f241aead868e87d092bade7cdb4f3dc39360f7f" translate="yes" xml:space="preserve">
          <source>But what exactly is O(log n)? For example, what does it mean to say that the height of a &amp;gt;complete binary tree is O(log n)?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 O (log n)는 정확히 무엇입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, 완전한 이진 트리의 높이가 O (log n) 인 것은 무엇을 의미합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="edc1bfb371b8739da6f6a8bfe6b528f1e14b4316" translate="yes" xml:space="preserve">
          <source>Divide and conquer algorithms usually have a &lt;code&gt;logn&lt;/code&gt; component to the running time. This comes from the repeated halving of the input.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;분할 및 정복 알고리즘에는 일반적으로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;실행 시간에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;logn&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 구성 요소가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 입력을 반으로 반감 한 결과입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="042a172d4487ee962ac155493b6704fe324ce14f" translate="yes" xml:space="preserve">
          <source>Edit: As noted, the log base doesn't matter, but when deriving the Big-O performance of an algorithm, the log factor will come from halving, hence why I think of it as base 2.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;편집 : 언급했듯이 로그베이스는 중요하지 않지만 알고리즘의 Big-O 성능을 도출 할 때 로그 팩터가 반으로 나옵니다. 따라서 왜베이스 2로 생각합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b51ffb5caa85a59fa5b79d9a86cc93f753c1d72" translate="yes" xml:space="preserve">
          <source>Every time we write an algorithm or code we try to analyze its asymptotic complexity.
It is different from its &lt;b&gt;time complexity&lt;/b&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘이나 코드를 작성할 때마다 점근 적 복잡성을 분석하려고합니다. &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시간 복잡성&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과는 다릅니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a32654a9db30d8a5838e3722ec97067271f1ac0" translate="yes" xml:space="preserve">
          <source>First I recommend you to read following book;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;먼저 다음 책을 읽는 것이 좋습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4389c042e3105fc444c640d496eb44c0535e3593" translate="yes" xml:space="preserve">
          <source>First, you'll want to have a general idea of Logarithm, which you can get from &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;https://en.wikipedia.org/wiki/Logarithm&lt;/a&gt; . Natural science use &lt;code&gt;e&lt;/code&gt; and the natural log. Engineering disciples will use log_10 (log base 10) and computer scientists will use log_2 (log base 2) a lot, since computers are binary based. Sometimes you'll see abbreviations of natural log as &lt;code&gt;ln()&lt;/code&gt;, engineers normally leave the _10 off and just use &lt;code&gt;log()&lt;/code&gt; and log_2 is abbreviated as &lt;code&gt;lg()&lt;/code&gt;. All of the types of logarithms grow in a similar fashion, that is why they share the same category of &lt;code&gt;log(n)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;먼저 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://en.wikipedia.org/wiki/Logarithm&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 얻을 수있는 Logarithm에 대한 일반적인 아이디어가 필요합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 자연 과학은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;e&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 자연 로그를 사용합니다. 엔지니어링 제자는 log_10 (log base 10)을 사용하고 컴퓨터 과학자는 log_2 (log base 2)를 많이 사용합니다. 컴퓨터는 이진 기반이기 때문입니다. 때로는 자연 로그의 약어가 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ln()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 되며 엔지니어는 일반적으로 _10을 끄고 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하고 log_2는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;lg()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 로 약어로 표시됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 모든 유형의 로그는 비슷한 방식으로 커지므로 동일한 카테고리의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 공유합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e17e10b891c653c285dea64d8f7a3373a1c19493" translate="yes" xml:space="preserve">
          <source>Following &lt;strong&gt;Big-O Complexity Chart&lt;/strong&gt; also taken from &lt;a href=&quot;http://bigocheatsheet.com/&quot;&gt;bigocheatsheet&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;a href=&quot;http://bigocheatsheet.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bigocheatsheet&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에서 가져온 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Big-O Complexity Chart&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 다음&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16d7a7b7bac663123d8b79b95559ac46d279282b" translate="yes" xml:space="preserve">
          <source>Following is an example of Linear Time Algorithm</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 선형 시간 알고리즘의 예입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1fef1582a836eacedbb1ab2d7e10888873cb5181" translate="yes" xml:space="preserve">
          <source>For example, the following function is &lt;em&gt;O(n)&lt;/em&gt; because the algorithm grows in proportion to its input &lt;em&gt;n&lt;/em&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘이 입력 &lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 비례하여 증가하므로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 함수는 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n)입니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4caaa120df8c8c3e1948ef5644142dc7327e7965" translate="yes" xml:space="preserve">
          <source>For the below examples, we're now at the printer's office. Phone books are waiting to be mailed to each resident or business, and there's a sticker on each phone book identifying where it should be mailed to. Every person or business gets one phone book.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래 예의 경우, 이제 프린터 사무실에 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전화 번호부는 각 거주자 또는 사업자에게 우편으로 발송되기를 기다리고 있으며, 각 전화 번호부에 우편 발송 위치를 나타내는 스티커가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 사람이나 사업체는 전화 번호부를 하나받습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="008f849741e4c42a77d0d3e85df29402d2062285" translate="yes" xml:space="preserve">
          <source>For the tree example, you can easily see that stepping down a level of nodes cuts down an exponential number of elements as you continue traversing. The popular example of looking through a name-sorted phone book is essentially equivalent to traversing down a binary search tree (middle page is the root element, and you can deduce at each step whether to go left or right).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;트리 예제의 경우, 계속해서 탐색 할 때 노드 수준을 낮추면 지수 요소 수가 줄어드는 것을 쉽게 알 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이름별로 정렬 된 전화 번호부를 살펴 보는 가장 일반적인 예는 기본적으로 이진 검색 트리를 탐색하는 것과 같습니다 (중간 페이지는 루트 요소이며 각 단계에서 왼쪽 또는 오른쪽으로 갈지 여부를 추론 할 수 있음).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8cbba489ca545bed31ce5284b0f861e16a08da2" translate="yes" xml:space="preserve">
          <source>Given n input elements, to search an element in the array you need &lt;b&gt;at most 'n' comparisons&lt;/b&gt;. In other words, no matter what programming language you use, what coding style you prefer, on what system you execute it. In the worst case scenario it requires only n comparisons.The execution time is linearly proportional to the input size.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n 개의 입력 요소가 주어지면 배열에서 요소를 검색하려면 &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최대 'n'비교&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 가 필요합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다시 말해서, 어떤 프로그래밍 언어를 사용하든, 어떤 코딩 스타일을 사용하든, 어떤 시스템을 실행하는지에 관계없이. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최악의 시나리오에서는 n 개의 비교 만 필요하며 실행 시간은 입력 크기에 비례합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b7e083bb0f5b4f68b701df168e90a1fcd7902c02" translate="yes" xml:space="preserve">
          <source>Here are the running times of some operations we might perform on the phone book, from fastest to slowest:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전화 번호부에서 수행 할 수있는 일부 작업의 실행 시간은 가장 빠르거나 느립니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a642dd551ca2983c44ce398efcbea81aaf769af0" translate="yes" xml:space="preserve">
          <source>Here is some functions and their expected complexities. Numbers are indicating &lt;strong&gt;statement execution frequencies&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 몇 가지 기능과 예상되는 복잡성입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;숫자는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;명령문 실행 빈도를&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 나타냅니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4544d6dc56eede04340e7b413a78c264800e6ff9" translate="yes" xml:space="preserve">
          <source>I am learning about Big O Notation running times and amortized times.  I understand the notion of &lt;em&gt;O(n)&lt;/em&gt; linear time, meaning that the size of the input affects the growth of the algorithm proportionally...and the same goes for, for example, quadratic time &lt;em&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/em&gt; etc..even algorithms, such as permutation generators, with &lt;em&gt;O(n!)&lt;/em&gt; times, that grow by factorials.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Big O Notation 실행 시간과 상각 시간에 대해 배우고 있습니다. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 선형 시간 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 개념을 이해합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 입력의 크기가 알고리즘의 성장에 비례 적으로 영향을 미치고 ... 예를 들어 2 차 시간 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 등에도 동일하게 적용됩니다. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(N (n!)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 시간의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;순열 생성기와 같이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;계승에 의해 증가합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1514ac946545245f0cd6c0c469469d9924c92dc8" translate="yes" xml:space="preserve">
          <source>I can add something interesting, that I read in book by Kormen and etc. a long time ago. Now, imagine a problem, where we have to find a solution in a problem space. This problem space should be finite.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Kormen 등이 오래 전에 읽은 흥미로운 내용을 추가 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 문제 공간에서 해결책을 찾아야하는 문제를 상상해보십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 문제 공간은 유한해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77898565c07238eac54505aaa70fda9acd97105d" translate="yes" xml:space="preserve">
          <source>I can give an example for a for loop and maybe once grasped the concept maybe it will be simpler to understand in different contexts.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 for 루프에 대한 예를 제시 할 수 있고, 개념을 이해 한 후에는 다른 상황에서 이해하는 것이 더 간단 할 것이다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f46c74600710cca3491ccc2d55014c941985acd4" translate="yes" xml:space="preserve">
          <source>I cannot understand how to identify a function with a log time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로그 시간으로 함수를 식별하는 방법을 이해할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b120641fbd4e22f22f1a41d9c1460d708b5abf16" translate="yes" xml:space="preserve">
          <source>I cannot understand how to identify a function with a logarithmic
  time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로그 시간으로 함수를 식별하는 방법을 이해할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fc60cfd1e6ecec87ecd174464fd863785193468" translate="yes" xml:space="preserve">
          <source>I do know (maybe not in great detail) what Logarithm is, in the sense that:  log&lt;sub&gt;10&lt;/sub&gt; 100 = 2, but I cannot understand how to identify a function with a logarithmic time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 100 = 2 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;라는 의미에서 Logarithm이 무엇인지 알고 있지만 (상세하게는 아님) Logithmic &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Time으로 함수를 식별하는 방법을 이해할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c4c380d7b586ba548b763e759bdb6e8a0e7d641" translate="yes" xml:space="preserve">
          <source>I should point out, that we are talking here about a relative fraction limit, not the absolute one. The binary search is a classical example. At each step we throw away 1/2 of the problem space. But binary search is not the only such example. Suppose, you proved somehow, that at each step you throw away at least 1/128 of problem space. That means, your program is still running at O(logN) time, although significantly slower than the binary search. This is a very good hint in analyzing of recursive algorithms. It often can be proved that at each step the recursion will not use several variants, and this leads to the cutoff of some fraction in problem space.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기서는 절대 분수가 아니라 상대 분수 한계에 대해 이야기하고 있음을 지적해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이진 검색은 전형적인 예입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 단계에서 문제 공간의 1/2을 버립니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 이진 검색 만이 그러한 예는 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어떻게 든 각 단계에서 최소한 1/128의 문제 공간을 버린다고 가정하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 바이너리 검색보다 훨씬 느리지 만 프로그램이 여전히 O (logN) 시간에 실행되고 있음을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 재귀 알고리즘 분석에 매우 유용한 힌트입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 단계에서 재귀가 여러 변형을 사용하지 않음을 종종 증명할 수 있으며, 이로 인해 문제 공간에서 일부 부분이 잘립니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5881b589c8d34329db8c8aaf3583f04e0a95d59a" translate="yes" xml:space="preserve">
          <source>I would rephrase this as 'height of a complete binary tree is log n'.  Figuring the height of a complete binary tree would be O(log n), if you were traversing down step by step.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 이것을 '완전한 이진 트리의 높이는 log n'으로 바꾸겠다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전체 이진 트리의 높이를 단계별로 탐색하는 경우 O (log n)가됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="34a2c69faab5e22f0819e07416c899e0ab5ea227" translate="yes" xml:space="preserve">
          <source>If an operation makes a series of constant time decisions each of which halves (reduces by a factor of 3, 4, 5..) the size of the input to be considered, the whole will take time proportional to log base 2 (base 3, base 4, base 5...) of the size N of the input, rather than being O(N).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작업이 고려할 입력의 크기를 반으로 (3, 4, 5로 줄임) 일련의 일정한 시간 결정을하는 경우 전체는 로그베이스 2 (베이스 3)에 비례하여 시간이 걸립니다. , base 4, base 5 ...)는 입력 크기 N의 O (N)가 아니라 크기 N입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29c301205bbde0676fa60de7fb664c0272520a41" translate="yes" xml:space="preserve">
          <source>If an operation performs constant time work on each digit or bit of an input, the whole operation will take time proportional to the number of digits or bits in the input, not the magnitude of the input; thus, O(log N) rather than O(N).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;연산이 입력의 각 자릿수 또는 비트에 대해 일정한 시간 작업을 수행하는 경우 전체 연산은 입력의 크기가 아니라 입력의 자릿수 또는 비트 수에 비례하여 시간이 걸립니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 O (N) 대신 O (log N)입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="40f1a35a514953f64f37c0530c0551a81f2c1d8c" translate="yes" xml:space="preserve">
          <source>If you are looking for a intuition based answer I would like to put up two interpretations for you.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직관 기반의 답변을 찾고 있다면 두 가지 해석을하고 싶습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e727fd9b51a54744bd70b04f39c112e181c73e04" translate="yes" xml:space="preserve">
          <source>If you had a function that takes:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;필요한 기능이있는 경우 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cae2fdb17e96f6926d298666e40f5aed0ba43750" translate="yes" xml:space="preserve">
          <source>If you have an M-ary tree of depth d and size n, then:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;깊이 d와 크기 n의 Mary 트리가있는 경우 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1d95e53c64e645e837222469b9cab7b8c1b9b2cb" translate="yes" xml:space="preserve">
          <source>If you increase the problem size by a multiplicative amount (i.e. multiply its size by 10), the work is only increased by an additive amount.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;문제 크기를 곱하기 양으로 늘리면 (즉, 크기에 10을 곱하면) 작업은 추가 량만큼만 증가합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8e7f99e5aec28c3c3af14e4b086ab56f08a3ece3" translate="yes" xml:space="preserve">
          <source>If you plot a logarithmic function on a graphical calculator or something similar, you'll see that it rises really slowly -- even more slowly than a linear function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래픽 계산기 또는 이와 유사한 것에 대수 함수를 플로팅하면 선형 함수보다 훨씬 느리게 상승 함을 알 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b135e7e3c1db73615122392851be7982fb0590b8" translate="yes" xml:space="preserve">
          <source>Imagine a very high hill with a very broad base as well. To reach the top of the hill there are two ways: one is a dedicated pathway going spirally around the hill reaching at the top, the other: small terrace like carvings cut out to provide a staircase. Now if the first way is reaching in linear time O(n), the second one is O(log n).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;매우 넓은 기초가있는 매우 높은 언덕을 상상해보십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;언덕 꼭대기에 도달하려면 두 가지 방법이 있습니다. 하나는 언덕을 따라 나선형으로 진행하는 전용 통로이고 다른 하나는 계단을 제공하기 위해 조각과 같은 작은 테라스입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 첫 번째 방법이 선형 시간 O (n)에 도달하면 두 번째 방법은 O (log n)입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e33e04b1dee3afdd640617efc039e44bde6caae" translate="yes" xml:space="preserve">
          <source>Imagine an algorithm, which accepts an integer, &lt;code&gt;n&lt;/code&gt; as input and completes in time proportional to &lt;code&gt;n&lt;/code&gt; then it is O(n) or theta(n) but if it runs in time proportion to the &lt;code&gt;number of digits or the number of bits in the binary representation on number&lt;/code&gt; then the algorithm runs in O(log n) or theta(log n) time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정수를 허용하는 알고리즘을 상상 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 시간 비례 입력 완료로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 O (N) 또는 세타 (N)는 다음하지만 시간 비율에서 실행되는 경우 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;number of digits or the number of bits in the binary representation on number&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 알고리즘이 O (log n) 또는 theta (log n) 시간으로 실행됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6d589872ee5e41297713f59c099e086e3b4052ff" translate="yes" xml:space="preserve">
          <source>Imagine we have a rope and we have tied it to a horse. If the rope is directly tied to the horse, the force the horse would need to pull away (say, from a man) is directly 1.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리가 밧줄을 가지고 있고 그것을 말에 묶었다고 상상해보십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;밧줄이 말에 직접 묶여 있다면 말이 잡아 당겨야 할 힘은 (즉, 사람에게서) 1입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6378d42546aa9afc7483f28bf7aebdf73c49b4cd" translate="yes" xml:space="preserve">
          <source>In information technology it means that:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정보 기술에서 이는 다음을 의미합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="98c3336af693827be0b1652e42621a919c618013" translate="yes" xml:space="preserve">
          <source>In lay terms, it means that the equation for time may have some other components: e.g. it may have some constant startup time;  but these other components pale towards insignificance for large values of n, and the a*log(n) is the dominating term for large n.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉, 시간 방정식에는 다른 구성 요소가있을 수 있습니다. 예를 들어 일정한 시작 시간이있을 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 이들 다른 성분들은 큰 n 값에 대해서는 무의미한 창백하고 a * log (n)은 큰 n에 대한 지배적 인 용어이다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="58f7c710de382403051e79844d41a906eeb779a2" translate="yes" xml:space="preserve">
          <source>In mathematical analysis it means that:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;수학적 분석에서 다음을 의미합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b3e3252b9357453f176dba5797bfb8ef7ee2628e" translate="yes" xml:space="preserve">
          <source>In our example above, our 'growth rate' is &lt;strong&gt;O(log n)&lt;/strong&gt;. For every additional loop, the force our rope can handle is 10 times more:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위의 예에서 '성장률'은 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 추가 루프마다 로프가 처리 할 수있는 힘이 10 배 이상 증가합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f65581e910638647521ce0d5776783cc36b7118" translate="yes" xml:space="preserve">
          <source>In the case of binary search, every iteration you throw away half of the input. It should be noted that in Big-O notation, log is log base 2.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이진 검색의 경우 반복 할 때마다 입력의 절반을 버립니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Big-O 표기법에서 log는 log base 2입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fb6b918ab69d9248208647f0c2b72d19f69ad0b5" translate="yes" xml:space="preserve">
          <source>In this article there is a quote:
&lt;a href=&quot;http://www.phil.uu.nl/datastructuren/09-10/knuth_big_omicron.pdf&quot;&gt;D.E. Knuth, &quot;BIG OMICRON AND BIG OMEGA AND BIG THETA&quot;, 1976&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 기사에는 다음과 같은 인용문이있다 : &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.phil.uu.nl/datastructuren/09-10/knuth_big_omicron.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DE Knuth, &quot;BIG OMICRON AND BIG OMEGA AND BIG THETA&quot;, 1976&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8670c63b3667b4287608c526872dfc9205befd56" translate="yes" xml:space="preserve">
          <source>Instead we take input size as the parameter because whatever the code is, the input is same.
&lt;b&gt;So the execution time is a function of input size.&lt;/b&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대신 코드가 무엇이든 입력이 동일하기 때문에 입력 크기를 매개 변수로 사용합니다. &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 실행 시간은 입력 크기의 함수입니다.&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0dc1da4c3f8d12c166ff2cd6e4311d6053faa4f2" translate="yes" xml:space="preserve">
          <source>It is like saying that logarithm is the inverse of exponential.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대수는 지수의 역수라고 말하는 것과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c4cf5d0abe643a3d91104db3051e74c625aac83a" translate="yes" xml:space="preserve">
          <source>It is the number of times you can cut a log of length n repeatedly into b equal parts before reaching a section of size 1.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;길이 1의 로그를 크기가 1 인 섹션에 도달하기 전에 b 등분으로 반복해서자를 수있는 횟수입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70b54711198b76e6fa5a133bb42b9709471571ba" translate="yes" xml:space="preserve">
          <source>It simply means that the time needed for this task grows with log(n) (example : 2s for n = 10, 4s for n = 100, ...). Read the Wikipedia articles on &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;Binary Search Algorithm&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O Notation&lt;/a&gt; for more precisions.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;단순히이 작업에 필요한 시간이 log (n)으로 증가 함을 의미합니다 (예 : n = 10의 경우 2 초, n = 100의 경우 4 초, ...). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자세한 정밀도 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이진 검색 알고리즘&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;큰 O 표기법에&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 대한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Wikipedia 기사를 읽으십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d446a1de595cefe01ba8d7b981f6598cef60e89a" translate="yes" xml:space="preserve">
          <source>Lastly very simple showcase there is shows how it is calculated;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막으로 매우 간단한 쇼케이스는 계산 방법을 보여줍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5365cefd34a28e9f6f10283dbf2204e550bd9877" translate="yes" xml:space="preserve">
          <source>Like algorithm 10, but with some variations.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 10과 유사하지만 약간의 변형이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="daf9ca7dff5ef97da12064b1422d4d6d308259b7" translate="yes" xml:space="preserve">
          <source>Like algorithm 12, but with some variations that still yield &lt;code&gt;O(n^3)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 12와 유사하지만 여전히 변형이 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n^3)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38289bf08745c473c76541ef8dc4bf419c9505a0" translate="yes" xml:space="preserve">
          <source>Logarithm is essentially the inverse of exponentiation.  So, if each 'step' of your function is eliminating a &lt;strong&gt;factor&lt;/strong&gt; of elements from the original item set, that is a logarithmic time algorithm.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대수는 본질적으로 지수의 역수입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;함수 각각 '단계'는 제거되고 경우에 따라서, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;계수&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 원본 항목 세트에서 요소를, 그 대수 시간 알고리즘이다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c37c28e3db4ab56ed0c7f37046862788fd45f644" translate="yes" xml:space="preserve">
          <source>Logarithmic running time (&lt;code&gt;O(log n)&lt;/code&gt;) essentially means that the running time grows in proportion to the &lt;em&gt;logarithm&lt;/em&gt; of the input size - as an example, if 10 items takes at most some amount of time &lt;code&gt;x&lt;/code&gt;, and 100 items takes at most, say, &lt;code&gt;2x&lt;/code&gt;, and 10,000 items takes at most &lt;code&gt;4x&lt;/code&gt;, then it's looking like an &lt;code&gt;O(log n)&lt;/code&gt; time complexity.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로그 실행 시간 ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )은 기본적으로 실행 시간이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입력 크기 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로그&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 에 비례하여 증가 함을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, 10 개의 항목이 최대 시간 ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )을 차지하고 100 개의 항목은 최대 즉, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 10,000 개의 항목이 최대 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;4x&lt;/code&gt; 를&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 차지 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 시간 복잡성 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;처럼 보입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0da223ebb05c072d02e7d7d009cc82db75960461" translate="yes" xml:space="preserve">
          <source>Many good answers have already been posted to this question, but I believe we really are missing an important one - namely, the illustrated answer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 질문에 대한 많은 좋은 답변이 이미 게시되어 있지만 중요한 답변, 즉 설명 된 답변이 실제로 누락되었다고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0b6718155769a3e78ed892aa3ac3ab7d62302796" translate="yes" xml:space="preserve">
          <source>Note that if the equation were, for example ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;방정식이 예를 들어 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0aa386acc93467ee2abde73845cd59703ce2baff" translate="yes" xml:space="preserve">
          <source>Notice that I have bolded 'at most'. Big-O notation always refers to the worse case. If you're lucky, you could guess the number in one attempt and so the best case is O(1), but that's another story.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;'최대한'굵게 표시했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Big-O 표기법은 항상 더 나쁜 경우를 나타냅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;운이 좋으면 한 번의 시도로 숫자를 추측 할 수 있으므로 가장 좋은 경우는 O (1)이지만 다른 이야기입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="896e616be26c906871b376ff0bcf07906cf168d2" translate="yes" xml:space="preserve">
          <source>Now if the rope is looped once, the horse will need to pull 10 times harder. If the human decides to make it really difficult for the horse, he may loop the rope again round a pole, increasing it's strength by an additional 10 times. A third loop will again increase the strength by a further 10 times.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;밧줄이 한 번 반복되면 말은 10 배 더 세게 당길 필요가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;만약 인간이 말을 정말로 어렵게하기로 결정한다면, 밧줄을 다시 기둥에 감아 강도를 추가로 10 배 증가시킬 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;세 번째 루프는 강도를 다시 10 배 더 증가시킵니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1d64633a7606b749454da054611ddab06ad82f5e" translate="yes" xml:space="preserve">
          <source>Now imagine the rope is looped round a pole. The horse to get away will now have to pull many times harder. The amount of times will depend on the roughness of the rope and the size of the pole, but let's assume it will multiply one's strength by 10 (when the rope makes a complete turn).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 밧줄이 기둥 둘레에 고리를 이루고 있다고 상상해보십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;도망 치는 말은 이제 여러 번 더 세게 잡아 당겨야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시간은 로프의 거칠기와 극의 크기에 따라 달라 지지만, 로프가 완전히 회전 할 때 자신의 힘에 10을 곱한다고 가정 해 봅시다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d4de53fc0c4c7ca626fe1b6e7ea8bfbf1e3b1a36" translate="yes" xml:space="preserve">
          <source>Now it took you 7 guesses to get this right. But what is the relationship here? What is the most amount of items that you can guess from each additional guess?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 이것을 올바르게하려면 7 가지 추측이 필요했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 여기서의 관계는 무엇입니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각각의 추가 추측으로 추측 할 수있는 가장 많은 항목은 무엇입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="02fb936ea47e751f434197c3c1e70189f2a9e94f" translate="yes" xml:space="preserve">
          <source>Now let's imagine you are trying to guess a number between 1-100.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 1-100 사이의 숫자를 추측하려고한다고 가정 해 봅시다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92c7d02b06664cf176d72b22469d6e2637331bf5" translate="yes" xml:space="preserve">
          <source>Now the example above did use base 10, but fortunately the base of the log is insignificant when we talk about big o notation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 위의 예는 10을 사용했지만 운 좋게도 큰 표기법에 대해 이야기 할 때 로그의 기본은 중요하지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d1132f0f0d5b4551a144f923806f22c8f231b52c" translate="yes" xml:space="preserve">
          <source>Now try to see it that way, if exponential grows very fast then logarithm grows (inversely) very slow.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 지수가 매우 빠르게 커지면 대수는 (반대 적으로) 매우 느리게 증가합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf7bf0faa69c8d99b94cd18c064970e2c8eb7a8e" translate="yes" xml:space="preserve">
          <source>Now, if you can prove, that at every iteration of your algorithm you cut off a fraction of this space, that is no less than some limit, this means that your algorithm is running in O(logN) time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 알고리즘을 반복 할 때마다이 공간의 일부, 즉 한계 값을 제한한다는 것을 증명할 수 있다면 이는 알고리즘이 O (logN) 시간에 실행되고 있음을 의미합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="225912e442e23ad1ffb556abadc76e236a543d7e" translate="yes" xml:space="preserve">
          <source>O(log n) is a bit misleading, more precisely it's O(log&lt;sub&gt;2&lt;/sub&gt; n), i.e. (logarithm with base 2).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)은 약간 오해의 소지가 있습니다.보다 정확하게는 O (log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n)입니다 (즉, 밑이 2 인 로그).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="741abfc15af347b4f12ce5826876662fcbfe5bae" translate="yes" xml:space="preserve">
          <source>Of course, a bigger phone book will still take you a longer time, but it won't grow as quickly as the proportional increase in the additional size.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;물론, 더 큰 전화 번호부는 여전히 더 오랜 시간이 걸리지 만, 추가 크기가 비례 적으로 증가하는 것만 큼 빠르게 커지는 것은 아닙니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c91777dabbef341bced10eccfce89a68f07e4082" translate="yes" xml:space="preserve">
          <source>Ok let's try and fully understand what a logarithm actually is.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 로그가 실제로 무엇인지 완전히 이해하려고 노력하겠습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60081c10f46ab24f55cbcac1d8baa12b740223fb" translate="yes" xml:space="preserve">
          <source>On the basis of the issues discussed here, I propose that members of
  SIGACT, and editors of computer science and mathematics journals,
  adopt notations as defined above, unless &lt;strong&gt;a better alternative can be
  found reasonably soon&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기서 논의 된 문제들에 기초하여, 나는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;더 나은 대안을 합리적으로 찾을 수&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 없다면, SIGACT 회원들과 컴퓨터 과학 및 수학 저널 편집자들은 위에 정의 된 표기법을 채택 할 것을 제안한다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f1b4ad273ca861456f8e996a15667043d1cefab0" translate="yes" xml:space="preserve">
          <source>Or actually, it doesn't quite mean that; more likely it means something like &quot;&lt;code&gt;time&lt;/code&gt; divided by &lt;code&gt;a*log(n)&lt;/code&gt; tends towards &lt;code&gt;1&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또는 실제로, 그런 의미는 아닙니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아마도 &quot; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;time&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;으로&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 나눈 값은 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1&lt;/code&gt; 을&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 향하는 경향 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;과 같은 것을 의미합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="172a790a2a8831c6bd8b4653399b564aa7c99f4b" translate="yes" xml:space="preserve">
          <source>Others have given good diagram examples, such as the tree diagrams. I did not see any simple code examples. So in addition to my explanation, I'll provide some algorithms with simple print statements to illustrate the complexity of different algorithm categories.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 사람들은 트리 다이어그램과 같은 좋은 다이어그램 예제를 제공했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단한 코드 예제는 보지 못했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 내 설명 외에도 다양한 알고리즘 범주의 복잡성을 설명하기 위해 간단한 인쇄 문이있는 일부 알고리즘을 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d226550a9f05c197e28559642c0c8048d4b533b4" translate="yes" xml:space="preserve">
          <source>Plotting &lt;code&gt;log(n)&lt;/code&gt; on a plain piece of paper, will result in a graph where the rise of the curve decelerates as &lt;code&gt;n&lt;/code&gt; increases:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반 용지에 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;플로팅 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; 이&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 증가함에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라 곡선의 상승이 감속되는 그래프가 생성됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fa164feedc89846fdd3de1a98b22842deeff5b6f" translate="yes" xml:space="preserve">
          <source>Searching for 4 yields 3 hits: 6, 3 then 4. And log2 12 = 3, which is a good apporximate to how many hits where needed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;4를 검색하면 3, 6, 3, 4가 표시됩니다. 그리고 log2 12 = 3은 필요한 위치에 몇 개의 적중이 있는지에 대한 좋은 결과입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1348a8daed3b64aac9ec3379db2da56a0a9a0029" translate="yes" xml:space="preserve">
          <source>See as the input size increased the work done is increased and it is independent of any machine.
And if you try to find out the value of units of work 
It's actually dependent onto those above specified parameters.It will change according to the systems and all.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입력 크기가 증가한 경우 작업이 증가하고 기계와 무관합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;작업 단위의 값을 찾으려면 실제로 위의 지정된 매개 변수에 따라 달라지며 시스템 및 모두에 따라 변경됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dab06999693f805ef1a862d7a609e81414475e38" translate="yes" xml:space="preserve">
          <source>Similarly, if there was a nested loop, the time would be O(n&lt;sup&gt;2&lt;/sup&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마찬가지로 중첩 루프가있는 경우 시간은 O (n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a89c7cdf5037c4260a4641bbc5992b3ebeecf1f" translate="yes" xml:space="preserve">
          <source>Simply put: At each step of your algorithm you can cut the work in half. (Asymptotically equivalent to third, fourth, ...)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단히 말해 : 알고리즘의 각 단계에서 작업을 반으로 줄일 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(증상 적으로 셋째, 넷째, ...과 동일)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="401e8032f76cd53b593529b22a8cb008c7dd6f7c" translate="yes" xml:space="preserve">
          <source>So when you say any algorithm is O(log n)
it means the execution time is log times the input size n.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 어떤 알고리즘이 O (log n)라고 말하면 실행 시간이 로그에 입력 크기 n을 곱한 것을 의미합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3fa29b366a6312d23b4d2519423f5db29d71f7d5" translate="yes" xml:space="preserve">
          <source>That gives you the equation :</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은 당신에게 방정식을 제공합니다 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5291dbaca6641002cae33e549bcd7025de975858" translate="yes" xml:space="preserve">
          <source>That means that in the loop the step grows exponentially. E.g.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 루프에서 단계가 기하 급수적으로 증가 함을 의미합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9216353681115945aaba6250fe5ae4d1014f5529" translate="yes" xml:space="preserve">
          <source>That's what bit O notation means: it means &quot;what is the order of dominant term for any sufficiently large n&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 비트 O 표기법의 의미입니다. &quot;충분히 큰 n에 대해 지배적 인 용어의 순서는 무엇입니까&quot;를 의미합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c239bafbc2dce1d2ee370782accc2cae132308f" translate="yes" xml:space="preserve">
          <source>The above give several straight forward examples, and variations to help demonstrate what subtle changes can be introduced that really don't change the analysis. Hopefully it gives you enough insight.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위의 몇 가지 간단한 예제와 분석을 변경하지 않는 미묘한 변경 사항을 소개하는 변형을 보여줍니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;잘만되면 그것은 당신에게 충분한 통찰력을 제공합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fda0956265302daf9fe6bdf8cd1b73b62ae63530" translate="yes" xml:space="preserve">
          <source>The best way I've always had to mentally visualize an algorithm that runs in O(log n) is as follows:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)에서 실행되는 알고리즘을 항상 정신적으로 시각화해야하는 가장 좋은 방법은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81f4a7349b2e61a08d286f542458555f1865b59a" translate="yes" xml:space="preserve">
          <source>The complete binary example is O(ln n) because the search looks like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;검색은 다음과 같으므로 전체 이진 예제는 O (ln n)입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d7c3202604045a8f0ca1c569409156d740cf38fe" translate="yes" xml:space="preserve">
          <source>The complexity in O-notation of this program is O(log(n)). Let's try to loop through it by hand (n being somewhere between 512 and 1023 (excluding 1024):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 프로그램의 O 표기법의 복잡성은 O (log (n))입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;직접 손으로 반복 해 봅시다 (n은 512와 1023 사이에 있습니다 (1024 제외)).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="23fb0bc54f9a22ea3778e044e18fe0f74b651fc4" translate="yes" xml:space="preserve">
          <source>The difference between O(n) and O(log(n)) is huge, similar to the difference between O(n) and O(a^n) (a being a constant).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n)과 O (log (n))의 차이는 O (n)과 O (a ^ n)의 차이와 유사합니다 (상수 임).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0077251502a2b3945f5070c00b578c932c22496e" translate="yes" xml:space="preserve">
          <source>The explanation below is using the case of a fully &lt;em&gt;balanced&lt;/em&gt; binary tree to help you understand how we get logarithmic time complexity.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래 설명은 완전 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;균형&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이진 트리 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 경우를 사용하여 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로그 시간 복잡성을 얻는 방법을 이해하는 데 도움이됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="979a113826a0c1e025cb59a3bc5b4dbfe4e82d94" translate="yes" xml:space="preserve">
          <source>The following drawing depicts a binary tree. Notice how each level contains double the number of nodes compared to the level above (hence &lt;em&gt;binary&lt;/em&gt;):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 그림은 이진 트리를 나타냅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 레벨에 위의 레벨에 비해 두 배의 노드 수가 어떻게 포함되는지 확인하십시오 (따라서 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;binary&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db2a24bbecedf8e012282630dd132fbb4ee8f292" translate="yes" xml:space="preserve">
          <source>The height of a balanced binary tree is O(log&lt;sub&gt;2&lt;/sub&gt; n), since every node has two (note the &quot;two&quot; as in log&lt;sub&gt;2&lt;/sub&gt; n) child nodes. So, a tree with n nodes has a height of log&lt;sub&gt;2&lt;/sub&gt; n.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;균형 잡힌 이진 트리의 높이는 O (log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n)입니다. 모든 노드에는 2 (로그 &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서와 같이 &quot;2&quot;참고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;) 자식 노드가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있기 때문입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 n 개의 노드가있는 트리의 높이는 log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f9f0b9b225087a04ae96fd13b7c4892a8920821" translate="yes" xml:space="preserve">
          <source>The logarithm of x (to the base of a) is the reverse function of a^x.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;x의 로그 (a의 밑)는 a ^ x의 역함수입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="748b4da565ee01d0e285c7ce2ee8782d05768ee1" translate="yes" xml:space="preserve">
          <source>The logarithmic function is the inverse of the exponential function. Put another way, if your input grows exponentially (rather than linearly, as you would normally consider it), your function grows linearly.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로그 함수는 지수 함수의 역수입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;달리 말하면, 입력이 일반적으로 생각하는 것처럼 선형이 아닌 기하 급수적으로 증가하면 함수가 선형으로 증가합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="217245fbd9703d38af322b5f4c84cf925e99d9dc" translate="yes" xml:space="preserve">
          <source>The most common attributes of logarithmic running-time function are that:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대수 실행 시간 함수의 가장 일반적인 속성은 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c6ff8c3cdb742922883fe572d4bd4535cbbcdabf" translate="yes" xml:space="preserve">
          <source>The running time complexity of binary search is an example of &lt;code&gt;O(log n)&lt;/code&gt;. This is because in binary search, you are always ignoring half of your input in each later step by dividing the array in half and only focusing on one half with each step. Each step is constant-time, because in binary search you only need to compare one element with your key in order to figure out what to do next irregardless of how big the array you are considering is at any point. So you do approximately log(n)/log(2) steps.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이진 검색의 실행 시간 복잡도는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 예입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. 바이너리 검색에서는 배열을 반으로 나누고 각 단계의 절반에만 초점을 두어 나중에 각 단계에서 입력의 절반을 무시하기 때문입니다. 각 단계는 일정한 시간입니다. 이진 검색에서는 고려중인 배열의 크기에 관계없이 다음에 수행 할 작업을 파악하기 위해 하나의 요소 만 키와 비교하면됩니다. 따라서 대략 log (n) / log (2) 단계를 수행하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="183ce247942b6cd9feda78873387089ea80dbff0" translate="yes" xml:space="preserve">
          <source>The running time complexity of merge sort is an example of &lt;code&gt;O(n log n)&lt;/code&gt;. This is because you are dividing the array in half with each step, resulting in a total of approximately log(n)/log(2) steps. However, in each step you need to perform merge operations on all elements (whether it's one merge operation on two sublists of n/2 elements, or two merge operations on four sublists of n/4 elements, is irrelevant because it adds to having to do this for n elements in each step). Thus, the total complexity is &lt;code&gt;O(n log n)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;병합 정렬의 실행 시간 복잡도는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 예입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이는 배열을 각 단계마다 반으로 나누기 때문에 총 대략 log (n) / log (2) 단계가 발생하기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 각 단계에서 모든 요소에 대해 병합 작업을 수행해야합니다 (n / 2 요소의 두 하위 목록에 대한 하나의 병합 작업 또는 n / 4 요소의 네 개의 하위 목록에 대한 두 개의 병합 작업은 관련이 없음). 각 단계에서 n 개의 요소에 대해이 작업을 수행하십시오.) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 총 복잡도는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="78d57ee8f42bffef4d8a9382ae1beeb55a66ed2c" translate="yes" xml:space="preserve">
          <source>Then it takes log&lt;sub&gt;2&lt;/sub&gt;(n) time. The &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt;, loosely speaking, means that the relationship only needs to be true for large n, and that constant factors and smaller terms can be ignored.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음 로그 &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (n) 시간이 걸립니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;큰 O 표기법은&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 느슨하게 관계는 큰 N에 대한 사실 필요가 수단을 말하고, 그 상수 요인과 작은 조건은 무시할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3f3dd6c155a570957f69b762d0742cb653f9ff27" translate="yes" xml:space="preserve">
          <source>These 2 cases will  take O(log n) time</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 두 경우는 O (log n) 시간이 걸립니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d0838d5f8965084f46ea02466a76e08056604c29" translate="yes" xml:space="preserve">
          <source>Think of this as a combination of &lt;code&gt;O(log(n))&lt;/code&gt; and &lt;code&gt;O(n)&lt;/code&gt;. The nesting of the for loops help us obtain the &lt;code&gt;O(n*log(n))&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것을 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log(n))&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 조합으로 생각하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;for 루프의 중첩은 &lt;/font&gt; &lt;code&gt;O(n*log(n))&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 얻는 데 도움이 &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c85c59919495767e1aa36e7cb8e1e1898fc42aff" translate="yes" xml:space="preserve">
          <source>This algorithm is simple, which prints hello n times.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 알고리즘은 간단하며 hello를 n 번 인쇄합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="275d42b938445e6155dc69cc23cb8dbbe4f2b94b" translate="yes" xml:space="preserve">
          <source>This algorithm shows a variation, where it will print hello n/2 times. n/2 = 1/2 * n. We ignore the 1/2 constant and see that this algorithm is O(n).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 알고리즘은 변형을 표시하여 hello n / 2 번 인쇄합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n / 2 = 1/2 * n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1/2 상수를 무시하고이 알고리즘이 O (n)임을 알 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef3f528f492ad5a3b79a1dcbea99bd7d9e170e6c" translate="yes" xml:space="preserve">
          <source>This is like algorithm 10, but with 3 loops instead of 2.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 알고리즘 10과 비슷하지만 2 대신 3 개의 루프가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4efa808ed1bb5af8e28061bc1c951efec7f558d1" translate="yes" xml:space="preserve">
          <source>This is why algorithms with a logarithmic time complexity are highly sought after: even for really big n (let's say n = 10^8, for example), they perform more than acceptably.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 로그 시간 복잡도를 가진 알고리즘을 찾는 이유입니다. 실제로 큰 n (예를 들어, n = 10 ^ 8이라고하더라도)은 수용 할 수있는 것 이상을 수행합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fb1c5cd15bd283875742af5791fe8a2b4e1a3c61" translate="yes" xml:space="preserve">
          <source>This is why, for example, looking up people in a phone book is O(log n). You don't need to check &lt;em&gt;every&lt;/em&gt; person in the phone book to find the right one; instead, you can simply divide-and-conquer by looking based on where their name is alphabetically, and in every section you only need to explore a subset of each section before you eventually find someone's phone number.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어, 전화 번호부에서 사람을 찾는 것이 O (log n) 인 이유입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전화 번호부의 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 사람 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;을 확인하지 않아도 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;올바른 사람을 찾을 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대신, 이름이 알파벳순으로 표시되어 구분하고 정복 할 수 있으며, 모든 섹션에서 누군가의 전화 번호를 찾기 전에 각 섹션의 하위 집합 만 탐색하면됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16784fa25d2d74ba6e12621a053bcbb284da4694" translate="yes" xml:space="preserve">
          <source>Today is 2016, but we use it still today.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;오늘은 2016 년이지만 오늘도 계속 사용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="20d2171208dac823f70a0fc05abd05f1bb1d23c5" translate="yes" xml:space="preserve">
          <source>Using the graph, we can see that if we use a binary search to guess a number between 1-100 it will take us &lt;strong&gt;at most&lt;/strong&gt; 7 attempts. If we had 128 numbers, we could also guess the number in 7 attemps but 129 numbers will takes us &lt;strong&gt;at most&lt;/strong&gt; 8 attempts (in relations to logarithms, here we would need 7 guesses for a 128 value range, 10 guesses for a 1024 value range. 7 is the logarithm of 128, 10 is the logarithm of 1024 (base 2)).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그래프를 사용하면 이진 검색을 사용하여 1-100 사이의 숫자를 추측하면 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최대&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 7 번의 시도 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 필요하다는 것을 알 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;만약 우리가 128 개의 숫자를 가지고 있다면, 우리는 7 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;번의 시도 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 숫자를 추측 할 수 있지만 129 개의 숫자는 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;최대&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 8 번의 시도를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;취할 것입니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(대수와 관련하여, 여기서는 128 개의 값 범위에 대한 7 개의 추측, 1024 개의 값에 대한 10 개의 추측이 필요합니다. 7은 128의 로그이고, 10은 1024의 로그 (기수 2)입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88eec511fbead7aa7ea065aa934d14f88f9f9b16" translate="yes" xml:space="preserve">
          <source>Walking a single path in the tree ~ O(d) = O(log n to base M)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나무에서 단일 경로를 걷는 ~ O (d) = O (log n to base M)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9b73a24be6f8b05f8c2985125f1eb8c601802768" translate="yes" xml:space="preserve">
          <source>We can expand the phone book example to compare other kinds of operations and &lt;em&gt;their&lt;/em&gt; running time. We will assume our phone book has &lt;em&gt;businesses&lt;/em&gt; (the &quot;Yellow Pages&quot;) which have unique names and &lt;em&gt;people&lt;/em&gt; (the &quot;White Pages&quot;) which may not have unique names. A phone number is assigned to at most one person or business. We will also assume that it takes constant time to flip to a specific page.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리는 작업의 다른 종류와 비교하는 전화 번호부 예를 확장 할 수 있습니다 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;자신의&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 실행 시간을. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전화 번호부에 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;고유 한 이름을 가진 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사업체&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ( &quot;노란색 페이지&quot;)와 고유 한 이름을 갖지 않는 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사람들&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ( &quot;백색 페이지&quot;)이 있다고 가정합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전화 번호는 최대 한 사람이나 회사에 할당됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 특정 페이지로 이동하는 데 일정한 시간이 걸린다고 가정합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf5c329d95290b50a23a52c623196a7055ce3a59" translate="yes" xml:space="preserve">
          <source>We can see that for each loop, the value increases by 10. The number of turns required to get any number is called the logarithm of the number i.e. we need 3 posts to multiple your strength by 1000 times, 6 posts to multiply your strength by 1,000,000.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 루프마다 값이 10 씩 증가 함을 알 수 있습니다. 어떤 숫자를 얻는 데 필요한 회전 수를 숫자의 로그라고합니다. 즉, 힘을 곱하기 위해 3 번의 게시물에 1000 번 곱하기 위해 6 번의 게시물이 필요합니다. 1,000,000&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="215d074be1f0a767e1033061b3e486085ff1e2f8" translate="yes" xml:space="preserve">
          <source>We can see that for every guess our data set is shrinking. A good rule of thumb to identify if an algorithm has a logarithmtic time is
  to see if the data set shrinks by a certain order after each iteration</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;모든 추측에 대해 데이터 세트가 축소되고 있음을 알 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘에 로그 시간이 있는지 식별하는 좋은 경험 법은 각 반복 후 데이터 세트가 특정 순서로 축소되는지 확인하는 것입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5c106784281fed81c6b6820aae1f0a6d9cbda0c5" translate="yes" xml:space="preserve">
          <source>What does O(log n) mean exactly</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)은 정확히 무엇을 의미합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="93c5eee1c00a2205d8b906b832bc3151f6cc1c21" translate="yes" xml:space="preserve">
          <source>What does it mean to say that the height of a complete binary tree is O(log n)?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;완전한 이진 트리의 높이가 O (log n)라는 것은 무엇을 의미합니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="44807ad43b2ea914e6e9301d20f34f969353dcde" translate="yes" xml:space="preserve">
          <source>What it means precisely is &quot;as &lt;code&gt;n&lt;/code&gt; tends towards &lt;code&gt;infinity&lt;/code&gt;, the &lt;code&gt;time&lt;/code&gt; tends towards &lt;code&gt;a*log(n)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a constant scaling factor&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;무엇 정확하게 의미하는 &quot;같다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; 은&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 향해 경향 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;infinity&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;time&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 으로 경향 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 일정한 스케일링 인자이다.&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d9d385e501f3c19dadeb1c4c3602e959a018409e" translate="yes" xml:space="preserve">
          <source>What's log&lt;sub&gt;b&lt;/sub&gt;(n)?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;로그 &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;b&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (n)는 무엇입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5ddb3aa95967c49aba70d9818c8d1d78fd583c6b" translate="yes" xml:space="preserve">
          <source>When you look at the code examples below, I recommend looking at O(1), then O(n), then O(n^2). After you are good with those, then look at the others. I've included clean examples as well as variations to demonstrate how subtle changes can still result in the same categorization.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래 코드 예제를 볼 때 O (1), O (n), O (n ^ 2)를 확인하는 것이 좋습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;당신이 그것들을 잘 알고 나면 다른 것들을보십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;미묘한 변경으로 인해 동일한 분류가 어떻게 이루어질 수 있는지 보여주는 변형뿐만 아니라 깨끗한 예도 포함 시켰습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="216423c2bafc59cfac2856f5284a31862176680e" translate="yes" xml:space="preserve">
          <source>You can easily identify if the algorithmic time is n log n. Look for an outer loop which iterates through a list (O(n)). Then look to see if there is an inner loop. If the inner loop is &lt;strong&gt;cutting/reducing&lt;/strong&gt; the data set on each iteration, that loop is (O(log n)), and so the overall algorithm is = &lt;strong&gt;O(n log n)&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;알고리즘 시간이 n log n인지 쉽게 식별 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;목록을 반복하는 외부 루프를 찾으십시오 (O (n)). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음 내부 루프가 있는지 확인하십시오. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내부 루프가 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;각 반복에서 데이터 세트를 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;절단 / 축소&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하는 경우 해당 루프는 (O (log n))이므로 전체 알고리즘은 = &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n log n)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1d5328a5b30597cfdbb5f64814aee6e0397a6702" translate="yes" xml:space="preserve">
          <source>You can think of O(1), O(n), O(logn), etc as classes or categories of growth. Some categories will take more time to do than others. These categories help give us a way of ordering the algorithm performance. Some grown faster as the input n grows. The following table demonstrates said growth numerically. In the table below think of log(n) as the ceiling of log_2.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (1), O (n), O (logn) 등을 클래스 또는 성장 범주로 생각할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일부 카테고리는 다른 카테고리보다 시간이 더 걸립니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 범주는 알고리즘 성능을 주문하는 방법을 제공합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일부는 입력 n이 증가함에 따라 더 빠르게 성장했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하기 표는 상기 성장을 수치 적으로 설명한다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;아래 표에서 log (n)을 log_2의 상한값으로 생각하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5c973715b1aaecc205af6056a3e8561731036021" translate="yes" xml:space="preserve">
          <source>You can think of O(log N) intuitively by saying the time is proportional to the number of digits in N.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시간이 N의 자릿수에 비례한다고 말하면 O (log N)을 직관적으로 생각할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be063b2f6f59fd659351560845cdcbd0fce725b1" translate="yes" xml:space="preserve">
          <source>You will eventually come across a linearithmic time &lt;strong&gt;O(n log(n))&lt;/strong&gt; algorithm. The rule of thumb above applies again, but this time the logarithmic function has to run n times e.g. reducing the size of a list &lt;strong&gt;n times&lt;/strong&gt;, which occurs in algorithms like a mergesort.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;결국 선형 선형 시간 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n log (n))&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 알고리즘을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;보게됩니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어림짐작 위에 다시 적용되지만 대수 함수를 갖는다 이번에 실행 n 번 예는리스트의 사이즈 감소 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n 번&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 머지 소트 등의 알고리즘에서 발생.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e633fb53f72a241fd99a62bdb2e5fec14d3b99f0" translate="yes" xml:space="preserve">
          <source>from &lt;a href=&quot;http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/&quot;&gt;http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.geeksforgeeks.org/write-ac-program-to-calculate-powxn/&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f561a474d88946ed4c679c84b7d0fa00aa1daefa" translate="yes" xml:space="preserve">
          <source>only one will need to be chosen.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하나만 선택하면됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="949b2d332a8532ba60eb0f9fdaaa648e4f5e90da" translate="yes" xml:space="preserve">
          <source>the choice of the next element on which to perform some action is one of several possibilities, and</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어떤 행동을 수행 할 다음 요소의 선택은 여러 가능성 중 하나이며,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="810680965d466ce9e27c217b0e6ef1c0fc7ac62f" translate="yes" xml:space="preserve">
          <source>the elements on which the action is performed are digits of n</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;조치가 수행되는 요소는 n의 숫자입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7c3255662cb9361125a26cad0c44f18afbdc1a9e" translate="yes" xml:space="preserve">
          <source>time(n) = a + b&lt;em&gt;log(n) + c&lt;/em&gt;n + d&lt;em&gt;n&lt;/em&gt;n</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시간 (n) = a + b &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;log (n) + c&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n + d &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3121a265ec660806dc7016bca8595689a539a80d" translate="yes" xml:space="preserve">
          <source>traversing the whole tree ~ O(M^d) = O(n)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전체 트리를 순회 ~ O (M ^ d) = O (n)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="601d76bcf9259b0951e3bbabeb31e37d99f1830f" translate="yes" xml:space="preserve">
          <source>​It is &lt;code&gt;O(log n)&lt;/code&gt; when we do divide and conquer type of algorithms e.g binary search. Another example is quick sort where each time we divide the array into two parts and each time it takes &lt;code&gt;O(N)&lt;/code&gt; time to find a pivot element. Hence it  &lt;code&gt;N O(log N)&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그것은이다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 우리는 알고리즘 예를 들어, 이진 검색의 분할 및 정복 유형을 수행 할 때. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또 다른 예는 배열을 두 부분으로 나누고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;피벗 요소를 찾는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(N)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 시간 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 걸리는 빠른 정렬 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N O(log N)&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
