<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/2307283">
    <body>
      <group id="2307283">
        <trans-unit id="62c23e7ef4be86040d6c792d74b8103bb503c43a" translate="yes" xml:space="preserve">
          <source>&quot;Tends towards&quot; has the usual mathematical meaning from 'analysis': for example, that &quot;if you pick &lt;em&gt;any&lt;/em&gt; arbitrarily small non-zero constant &lt;code&gt;k&lt;/code&gt;, then I can find a corresponding value &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;((time/(a*log(n))) - 1)&lt;/code&gt; is less than &lt;code&gt;k&lt;/code&gt; for all values of &lt;code&gt;n&lt;/code&gt; greater than &lt;code&gt;X&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;Стремится к&amp;raquo; имеет обычный математический смысл из &amp;laquo;анализа&amp;raquo;: например, что &amp;laquo;если вы выберете &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;любую&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; произвольно небольшую ненулевую константу &lt;/font&gt;&lt;/font&gt; &lt;code&gt;k&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , то я могу найти соответствующее значение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; такое, что &lt;/font&gt;&lt;/font&gt; &lt;code&gt;((time/(a*log(n))) - 1)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; меньше &lt;/font&gt;&lt;/font&gt; &lt;code&gt;k&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для всех значений &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; больше &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54e10c43522458d7384b566fb9db05322a518452" translate="yes" xml:space="preserve">
          <source>(you take the lg of each side, lg being the log base 2)</source>
          <target state="translated">(вы берете lg с каждой стороны,lg-основание бревна 2)</target>
        </trans-unit>
        <trans-unit id="44c99847d54ae4d00b74068530a05dd1fef0dc04" translate="yes" xml:space="preserve">
          <source>*Remember that big-O notation, &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation#Formal_definition&quot;&gt;by definition&lt;/a&gt;, constants don't matter. Also by the &lt;a href=&quot;http://en.wikipedia.org/wiki/Change_of_base_formula_for_logs#Changing_the_base&quot;&gt;change of base rule&lt;/a&gt; for logarithms, the only difference between logarithms of different bases is a constant factor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;* Помните, что обозначение big-O &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation#Formal_definition&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;по определению&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не имеет значения для констант. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, путем &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Change_of_base_formula_for_logs#Changing_the_base&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;изменения базового правила&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для логарифмов, единственная разница между логарифмами разных оснований является постоянным фактором.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48e253e5ab06e6976e35c9bdcea7e10b034cc3d4" translate="yes" xml:space="preserve">
          <source>... then this would be O(n squared) because, no matter what the values of the constants a, b, c, and non-zero d, the &lt;code&gt;d*n*n&lt;/code&gt; term would always dominate over the others for any sufficiently large value of n.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... тогда это будет O (n в квадрате), потому что, независимо от значений констант a, b, c и ненулевого d, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;член &lt;/font&gt;&lt;/font&gt; &lt;code&gt;d*n*n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; всегда будет доминировать над остальными при любом достаточно большое значение n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a6b947aa846b5da9e63669d7e0ab43fa7149876" translate="yes" xml:space="preserve">
          <source>1. Physical System</source>
          <target state="translated">1.Физическая система</target>
        </trans-unit>
        <trans-unit id="2da5718e4456d8946ed7cc039bbf65bc4baf31dc" translate="yes" xml:space="preserve">
          <source>2. Programming Language</source>
          <target state="translated">2.Язык программирования</target>
        </trans-unit>
        <trans-unit id="c047d0c08b0f62ebc42d10b65de4db18f9b150e9" translate="yes" xml:space="preserve">
          <source>3 is the logarithm of 1,000, and 6 is the logarithm of 1,000,000 (base 10).</source>
          <target state="translated">3-логарифм 1 000,а 6-логарифм 1 000 000 (базовый 10).</target>
        </trans-unit>
        <trans-unit id="864313c2df45c8ba64dccb8ec4055125eac5d1f5" translate="yes" xml:space="preserve">
          <source>3. coding Style</source>
          <target state="translated">3.Кодирование Стиль</target>
        </trans-unit>
        <trans-unit id="f2e04afdb09df34f9f44473a7a1ccb50a406dc78" translate="yes" xml:space="preserve">
          <source>4. And much more ......</source>
          <target state="translated">4.И гораздо больше...</target>
        </trans-unit>
        <trans-unit id="d563ed5a666051353255960e6c2817c3c0755862" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Linear Search&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Линейный поиск&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b5fe40e00cd38153f7725ae75b9e9b6d20e78737" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The actual execution time is not a good measure for analysis.
&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Фактическое время выполнения не является хорошей мерой для анализа. &lt;/font&gt;&lt;/font&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7302ce438edbf9d107087c0d00e63e527a7611c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log N)&lt;/code&gt; basically means time goes up linearly while the &lt;code&gt;n&lt;/code&gt; goes up exponentially. So if it takes &lt;code&gt;1&lt;/code&gt; second to compute &lt;code&gt;10&lt;/code&gt; elements, it will take &lt;code&gt;2&lt;/code&gt; seconds to compute &lt;code&gt;100&lt;/code&gt; elements, &lt;code&gt;3&lt;/code&gt; seconds to compute &lt;code&gt;1000&lt;/code&gt; elements, and so on.</source>
          <target state="translated">&lt;code&gt;O(log N)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; означает, что время линейно возрастает, а &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; экспоненциально возрастает. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Так что, &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;если он занимает &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; секунду , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;чтобы вычислить &lt;/font&gt;&lt;/font&gt; &lt;code&gt;10&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; элементов, это займет &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; секунды , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;чтобы вычислить &lt;/font&gt;&lt;/font&gt; &lt;code&gt;100&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; элементов, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;3&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; секунд , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;чтобы вычислить &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; элементов, и так далее.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29521e79b284726f262e57f3d5e15142bdd210f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log n)&lt;/code&gt; refers to a function (or algorithm, or step in an algorithm) working in an amount of time proportional to the logarithm (usually base 2 in most cases, but not always, and in any event this is insignificant by big-O notation*) of the size of the input.</source>
          <target state="translated">&lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; относится к функции (или алгоритму, или шагу в алгоритме), работающей в течение времени, пропорционального логарифму (обычно основание 2 в большинстве случаев, но не всегда, и в любом случае это незначительно для больших -O обозначение *) размера ввода.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a33e6cf6849c1bfd0bc219a80b69e82c56092cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log n)&lt;/code&gt; running times are very common in any sort of divide-and-conquer application, because you are (ideally) cutting the work in half every time. If in each of the division or conquer steps, you are doing constant time work (or work that is not constant-time, but with time growing more slowly than &lt;code&gt;O(log n)&lt;/code&gt;), then your entire function is &lt;code&gt;O(log n)&lt;/code&gt;. It's fairly common to have each step require linear time on the input instead; this will amount to a total time complexity of &lt;code&gt;O(n log n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Время выполнения &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; очень распространено в любом приложении типа &amp;laquo;разделяй и властвуй&amp;raquo;, потому что вы (в идеале) сокращаете работу пополам каждый раз. Если на каждом из этапов деления или завоевания вы выполняете работу с постоянным временем (или работу, которая не является постоянной, но со временем, растущим медленнее, чем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), тогда вся ваша функция - &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , Довольно часто каждый шаг требует линейного времени на входе; это составит общую сложность времени &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abb48e63c4d7db950366fd3b0dfe2e096b2f2c6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n^2)&lt;/code&gt; is obtained easily by nesting standard for loops.</source>
          <target state="translated">&lt;code&gt;O(n^2)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; легко получается путем вложения стандарта для циклов.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="664fced4730451fe1325328dbba584863529c241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log x to base b = y&lt;/code&gt; is the inverse of &lt;code&gt;b^y = x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;log x to base b = y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; является обратным к &lt;/font&gt;&lt;/font&gt; &lt;code&gt;b^y = x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8966595017a7ad226eea24cdb7b873f35223518" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disclaimer: The rope-logarithm example was grabbed from the excellent &lt;a href=&quot;https://www.amazon.co.uk/Mathematicians-Delight-Dover-Books-Mathematics/dp/0486462404&quot;&gt;Mathematician's Delight book by W.Sawyer&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Отказ от ответственности: Пример веревочного логарифма был взят из превосходной &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.amazon.co.uk/Mathematicians-Delight-Dover-Books-Mathematics/dp/0486462404&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;книги Математика &amp;laquo;Восхищение&amp;raquo; У. Сойера&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="93b23fdcd6527df1dfdb4c0912b0fc04e2169d8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;n/(2^steps)=1 &amp;lt;=&amp;gt; n=2^steps &amp;lt;=&amp;gt; lg(n)=steps&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;n/(2^steps)=1 &amp;lt;=&amp;gt; n=2^steps &amp;lt;=&amp;gt; lg(n)=steps&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cecb08b9e2796a2712fcae78ab1e27ab18af4c8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 10&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 10&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="99059f5bd83e63ed1fa04489413c400ab49828dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 11&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 11&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c484f87bf2e7520bc9c13f2425548040f8ca656" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 12&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 12&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f792b9e20e7bd31191ec1ce96f2411274a40a430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 13&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 13&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87a6cf7b68bf7e84ece7cceaa6050ec935e54006" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 1:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc4f1ab0bbde20810982288d34df68bf23df808c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 2:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3580ba8f5fa81d2b6842006c382e678600fdf0eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 3 - This acts like &quot;log_2&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 3 - действует как &amp;laquo;log_2&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50c2f6a991daf9f2251bac09adf66a8ed3c4e3c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 4 - This acts like &quot;log_3&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 4 - действует как &amp;laquo;log_3&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ade3ccd18a1516ffea265742c9c4262ac85f74a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 5 - This acts like &quot;log_1.02&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 5 - действует как &amp;laquo;log_1.02&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c2e9bc08ef7fff3d18351a20b3844a561de3e6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 6&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 6&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6042164656649616c8bd314b7001a62996f8c3e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 7&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 7&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3813a73f44ab79ffff5fc062e96df9c77be57f07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 8&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 8&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a43edf9ec98a0da521d4159e35c1204784fc256" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 9&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 9&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc851456bbf3606cfd07da8d669ac31d4a0e4865" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1) (in the average case):&lt;/strong&gt; Given the page that a person's name is on and their name, find the phone number.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (1) (в среднем случае):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; учитывая страницу с именем человека и его именем, найдите номер телефона.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="382f5486747667379a673e16fda00accedb3c67b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1) (in the worst case):&lt;/strong&gt; Given the page that a business's name is on and the business name, find the phone number.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (1) (в худшем случае):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; учитывая страницу с названием компании и названием компании, найдите номер телефона.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db128fc404aa0da1b743b40724a8e30d03d62726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1) - Constant Time Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (1) - Примеры с постоянным временем:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dda1fa945adc6eb16b365bc6c67afd8d2bd88f75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log n):&lt;/strong&gt; Given a person's name, find the phone number by picking a random point about halfway through the part of the book you haven't searched yet, then checking to see whether the person's name is at that point. Then repeat the process about halfway through the part of the book where the person's name lies. (This is a binary search for a person's name.)</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; по имени человека найдите номер телефона, выбрав случайную точку примерно на полпути в той части книги, которую вы еще не искали, а затем проверьте, находится ли имя человека в этой точке. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Затем повторите процесс примерно на полпути через часть книги, где находится имя человека. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Это двоичный поиск имени человека.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="367cb7ed6ccc0a378006813f8be3af12e274a6c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log(n)) - Logarithmic Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log (n)) - Логарифмические примеры:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="543a66101c585e2dc5a2e8d042e2d985b1274be7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n &amp;middot; n!):&lt;/strong&gt; We're ready to load the phonebooks onto the shipping dock. Unfortunately, the robot that was supposed to load the books has gone haywire: it's putting the books onto the truck in a random order! Even worse, it loads all the books onto the truck, then checks to see if they're in the right order, and if not, it unloads them and starts over. (This is the dreaded &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Bogosort&quot;&gt;bogo sort&lt;/a&gt;&lt;/strong&gt;.)</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n &amp;middot; n!):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Мы готовы загрузить телефонные книги в док-станцию. К сожалению, робот, который должен был загружать книги, стал бесполезным: он кладет книги на грузовик в случайном порядке! Хуже того, он загружает все книги в грузовик, затем проверяет, находятся ли они в правильном порядке, а если нет, то выгружает их и начинает заново. (Это ужасный &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Bogosort&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вид бого&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1de65cc18d4f21d8e3a64ac738eb16027fb3867b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n log n):&lt;/strong&gt; There was a mix-up at the printer's office, and our phone book had all its pages inserted in a random order. Fix the ordering so that it's correct by looking at the first name on each page and then putting that page in the appropriate spot in a new, empty phone book.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n log n):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в офисе принтера произошла путаница, и в нашей телефонной книге все страницы были вставлены в случайном порядке. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Исправьте порядок так, чтобы он был правильным: посмотрите на имя на каждой странице, а затем поместите эту страницу в соответствующее место в новой пустой телефонной книге.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70127c240aa95e8b0ec96b3395f313034e9030aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n log n):&lt;/strong&gt; We want to personalize the phone book, so we're going to find each person or business's name in their designated copy, then circle their name in the book and write a short thank-you note for their patronage.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n log n):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; мы хотим персонализировать телефонную книгу, поэтому мы собираемся найти имя каждого человека или компании в назначенной им копии, затем обвести их имя в книге и написать короткую благодарственную записку за их покровительство ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b5606b21c0f2c96153c29e77b41f7fd85f0a0d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n) - Linear Time Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n) - Примеры линейного времени:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f43ccb38b5bf2cd670379ba3a1965f42b4771fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n):&lt;/strong&gt; Find all people whose phone numbers contain the digit &quot;5&quot;.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Найти всех людей, номера телефонов которых содержат цифру &amp;laquo;5&amp;raquo;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75709c253759b933376bae3df6fbc5aea1471527" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n):&lt;/strong&gt; Given a phone number, find the person or business with that number.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n): По&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; номеру телефона найдите человека или компанию с этим номером.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db4237adb37b8829a7cc9004385308260a533b0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n*log(n)) - nlog(n) Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n * log (n)) - nlog (n) Примеры:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee37803266e306f1154c335eaba407e63fb9c491" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt; A mistake occurred at the office, and every entry in each of the phone books has an extra &quot;0&quot; at the end of the phone number. Take some white-out and remove each zero.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в офисе произошла ошибка, и каждая запись в каждой из телефонных книг имеет дополнительный &amp;laquo;0&amp;raquo; в конце номера телефона. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Возьмите немного белого и уберите каждый ноль.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3a7fa1df845249458feef5121758e550acff4f5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n&lt;sup&gt;n&lt;/sup&gt;):&lt;/strong&gt; You fix the robot so that it's loading things correctly. The next day, one of your co-workers plays a prank on you and wires the loading dock robot to the automated printing systems. Every time the robot goes to load an original book, the factory printer makes a duplicate run of all the phonebooks! Fortunately, the robot's bug-detection systems are sophisticated enough that the robot doesn't try printing even more copies when it encounters a duplicate book for loading, but it still has to load every original and duplicate book that's been printed.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Вы исправляете робота, чтобы он правильно загружал вещи. На следующий день один из ваших коллег подшучивает над вами и подключает робот-погрузчик к автоматизированным системам печати. Каждый раз, когда робот отправляется на загрузку оригинальной книги, заводской принтер дублирует все телефонные книги! К счастью, системы обнаружения ошибок робота настолько сложны, что робот не пытается печатать еще больше копий, когда для загрузки встречает дубликат книги, но ему все равно приходится загружать все напечатанные оригиналы и дубликаты книг.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="baa3dcc6c7cb9768bae9c8737d449d37e482c784" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n^2) - n squared Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n ^ 2) - n в квадрате Примеры:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c389c0632dce3cd1c5d250cbf01ee7bfb589c105" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n^3) - n cubed Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n ^ 3) - n куб. Примеры:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1d7ddb9ca9305db3b69febe087986d85bdca4704" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Overview&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Overview&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec82ec2afdaeef73e3e33a4ff9e63ef02488d0d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Code Examples Of Various Big O Categories:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Примеры простых кодов различных категорий Big O:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="234aa035660484f0b043ef167e4eb0c4a6aff304" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what does O(log n) actually mean?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Так что же на самом деле означает O (log n)?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e3286c2a6df794ce774454437c04c62779b831f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The logarithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Логарифм&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72ef5689874ae61836de6559d76a3348730b20ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What about O(n log n)?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что насчет O (n log n)?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8505b2060537b9b8a16641d236c3c9169433e63f" translate="yes" xml:space="preserve">
          <source>A common algorithm with O(log n) time complexity is Binary Search whose recursive relation is T(n/2) + O(1) i.e. at every subsequent level of the tree you divide problem into half and do constant amount of additional work.</source>
          <target state="translated">Общим алгоритмом с временной сложностью O(log n)является двоичный поиск,рекурсивное отношение которого T(n2)+O(1),т.е.на каждом последующем уровне дерева задача делится пополам и выполняется постоянный объем дополнительной работы.</target>
        </trans-unit>
        <trans-unit id="e64150835103105f0ea6e31dc144d0c9f306ad8a" translate="yes" xml:space="preserve">
          <source>Actually, if you have a list of n elements, and create a binary tree from that list (like in the divide and conquer algorithm), you will keep dividing by 2 until you reach lists of size 1 (the leaves).</source>
          <target state="translated">На самом деле,если у вас есть список из n элементов,и вы создаете двоичное дерево из этого списка (как в алгоритме &quot;разделяй и властвуй&quot;),вы будете продолжать делиться на 2,пока не достигнете списков размера 1 (листья).</target>
        </trans-unit>
        <trans-unit id="885a56ea0ae08ca84fb35233e67f695552695f1e" translate="yes" xml:space="preserve">
          <source>Algorithm 1 prints hello once and it doesn't depend on n, so it will always run in constant time, so it is &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 1 выводит привет один раз, и он не зависит от n, поэтому он всегда будет работать в постоянное время, поэтому он равен &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(1)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35be35b175c76af65d2827d2cf3dee1ef34934f1" translate="yes" xml:space="preserve">
          <source>Algorithm 2 prints hello 3 times, however it does not depend on an input size. Even as n grows, this algorithm will always only print hello 3 times. That being said 3, is a constant, so this algorithm is also &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 2 печатает привет 3 раза, однако это не зависит от размера ввода. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Даже при увеличении n этот алгоритм всегда будет печатать привет только 3 раза. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это, как говорится 3, является константой, поэтому этот алгоритм также &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(1)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="566ae46ca13a24c5b54b75fd8f752947062eed04" translate="yes" xml:space="preserve">
          <source>Algorithm 3 demonstrates an algorithm that runs in log_2(n). Notice the post operation of the for loop multiples the current value of i by 2, so &lt;code&gt;i&lt;/code&gt; goes from 1 to 2 to 4 to 8 to 16 to 32 ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 3 демонстрирует алгоритм, который работает в log_2 (n). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что операция post цикла for умножает текущее значение i на 2, поэтому значение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;i&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; увеличивается от 1 до 2, от 4 до 8, от 16 до 32 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="219cad7306c85bd667c5cb1b64143ac505019683" translate="yes" xml:space="preserve">
          <source>Algorithm 4 demonstrates log_3. Notice &lt;code&gt;i&lt;/code&gt; goes from 1 to 3 to 9 to 27...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 4 демонстрирует log_3. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;i&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; иду от 1 до 3 до 9 до 27 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a8454e3e9eaed77a0c84e7bcde53bb78684adbf" translate="yes" xml:space="preserve">
          <source>Algorithm 5 is important, as it helps show that as long as the number is greater than 1 and the result is repeatedly multiplied against itself, that you are looking at a logarithmic algorithm.</source>
          <target state="translated">Алгоритм 5 важен,так как помогает показать,что до тех пор,пока число больше 1 и результат многократно умножается на себя,вы смотрите на логарифмический алгоритм.</target>
        </trans-unit>
        <trans-unit id="51aabda71f87b90773768c7a9973d25539b2adfd" translate="yes" xml:space="preserve">
          <source>Algorithm 9 is like algorithm 8, but each of the loops has allowed variations, which still result in the final result being &lt;code&gt;O(n*log(n))&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритм 9 аналогичен алгоритму 8, но каждый из циклов допускает изменения, которые все же приводят к конечному результату, равному &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n*log(n))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17d79de1210f6f15a000af0169a5ef68b6ed4866" translate="yes" xml:space="preserve">
          <source>Algorithms (4th Edition)</source>
          <target state="translated">Алгоритмы (4-е издание)</target>
        </trans-unit>
        <trans-unit id="546877fd41740873d1cfa8e4f36cf9b0df017323" translate="yes" xml:space="preserve">
          <source>Algorithms in the Divide and Conquer paradigm are of complexity O(logn). One example here, calculate your own power function,</source>
          <target state="translated">Алгоритмы в парадигме &quot;Разделяй и властвуй&quot; имеют сложность O(logn).В качестве примера можно привести вычисление собственной силовой функции,</target>
        </trans-unit>
        <trans-unit id="bc69b8d895811f71046889c39e0d995b5f6f8de0" translate="yes" xml:space="preserve">
          <source>Although n is somewhere between 512 and 1023, only 10 iterations take place. This is because the step in the loop grows exponentially and thus takes only 10 iterations to reach the termination.</source>
          <target state="translated">Хотя n находится где-то между 512 и 1023,происходит всего 10 итераций.Это связано с тем,что шаг в цикле растет экспоненциально и для достижения завершения требуется всего 10 итераций.</target>
        </trans-unit>
        <trans-unit id="13fda95a4e29f31623e6b27919c9c2654912cdb6" translate="yes" xml:space="preserve">
          <source>Analyzing the running time of a program (example).</source>
          <target state="translated">Анализ времени работы программы (пример).</target>
        </trans-unit>
        <trans-unit id="b430315d40268f6d421e3d42d2f41d05716445c7" translate="yes" xml:space="preserve">
          <source>Anatomy of a program&amp;rsquo;s statement execution frequencies.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Анатомия частот выполнения операторов программы.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f024ce63ef78ef7b64b38e26fabafc1f314daaa6" translate="yes" xml:space="preserve">
          <source>And its not just search, whatever may be the work (increment, compare or any operation) its a function of input size.</source>
          <target state="translated">И это не просто поиск,какой бы ни была работа (инкремент,сравнение или любая другая операция),это функция входного размера.</target>
        </trans-unit>
        <trans-unit id="3e0adb51e88db164baaa3fd268ad64b534eb5476" translate="yes" xml:space="preserve">
          <source>And so on.</source>
          <target state="translated">И так далее.</target>
        </trans-unit>
        <trans-unit id="7a8d4b0af6eedcdbdf7182951523d1cc82a773a9" translate="yes" xml:space="preserve">
          <source>And that's how you get O(log n) which is the amount of work that needs to be done on the above tree to reach a solution.</source>
          <target state="translated">И вот так вы получаете O(log n),который представляет собой объем работы,который необходимо проделать на вышеуказанном дереве,чтобы достичь решения.</target>
        </trans-unit>
        <trans-unit id="430078eae25aa1035e9c5dded6c9d2dbbd85adf7" translate="yes" xml:space="preserve">
          <source>Another example is binary search, which has a running time of O(log&lt;sub&gt;2&lt;/sub&gt; n) because at every step you divide the search space by 2.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другой пример - бинарный поиск, который имеет время выполнения O (log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n), потому что на каждом шаге вы делите пространство поиска на 2.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ea8b371babfbf6cdabc48efdcabde7886a45b20" translate="yes" xml:space="preserve">
          <source>Ant it seems that this notation was mostly have taken from mathematics.</source>
          <target state="translated">Похоже,что эта запись в основном была взята из математики.</target>
        </trans-unit>
        <trans-unit id="db52f24fa20a9333b6b58676f942da718a9e8a80" translate="yes" xml:space="preserve">
          <source>Applying this to your binary tree question so you have a good application: if you double the number of nodes in a binary tree, the height only increases by 1 (an additive amount).  If you double it again, it still only increased by 1.  (Obviously I'm assuming it stays balanced and such).  That way, instead of doubling your work when the problem size is multiplied, you're only doing very slightly more work. That's why O(log n) algorithms are awesome.</source>
          <target state="translated">Применив это к вашему вопросу о двоичном дереве,вы получите хорошее приложение:если вы удвоите количество узлов в двоичном дереве,то высота увеличится только на 1 (добавочное количество).Если вы удвоите его еще раз,то высота все равно увеличится только на 1.(Очевидно,я предполагаю,что она останется сбалансированной и т.д.).Таким образом,вместо того,чтобы удваивать свою работу при умножении размера проблемы,вы делаете только очень немного больше работы.Вот почему алгоритмы O(log n)просто потрясающие.</target>
        </trans-unit>
        <trans-unit id="32764ca168816d370c0095d83bb00526d97bc511" translate="yes" xml:space="preserve">
          <source>As I know from university the symbol was intoduced by German mathematician Landau (1877-1938)</source>
          <target state="translated">Как я знаю из университета,символ был введен немецким математиком Ландау (1877-1938).</target>
        </trans-unit>
        <trans-unit id="0c50b5084a8768bf3848fba400f3d6b5a12bde9e" translate="yes" xml:space="preserve">
          <source>As the input size increases the work done(here the execution time) increases.(Hence proportionality)</source>
          <target state="translated">С увеличением размера входных данных увеличивается объем выполняемой работы (здесь время выполнения).(Следовательно,пропорциональность).</target>
        </trans-unit>
        <trans-unit id="965b30064e173b5100a19b6d6ea70cf86fc6ba94" translate="yes" xml:space="preserve">
          <source>Assume we had instead a dataset with 32 elements. Continue the drawing above to find that we will now need 5 comparisons to find what we are searching for, as the tree has only grown one level deeper when we multiplied the amount of data. As a result, the complexity of the algorithm can be described as a logarithmic order.</source>
          <target state="translated">Предположим,вместо этого у нас был набор данных с 32 элементами.Продолжайте рисунок выше,чтобы понять,что теперь нам понадобится 5 сравнений,чтобы найти то,что мы ищем,так как дерево выросло только на один уровень глубже,когда мы умножили количество данных.В результате сложность алгоритма можно описать как логарифмический порядок.</target>
        </trans-unit>
        <trans-unit id="1500b9ad9d3e53ed6762cb42f394ab0fc94c747c" translate="yes" xml:space="preserve">
          <source>Asymptotic complexity is the behavior of execution time of an algorithm while the time complexity is the actual execution time. But some people use these terms interchangeably.</source>
          <target state="translated">Асимптотическая сложность-это поведение времени исполнения алгоритма,в то время как временная сложность-это фактическое время исполнения.Но некоторые люди используют эти термины взаимозаменяемо.</target>
        </trans-unit>
        <trans-unit id="b7364a52ea4e1ac22d7414be72af2283970927a4" translate="yes" xml:space="preserve">
          <source>At the first step, you divide by 2. You then have 2 lists (2^1), you divide each by 2, so you have 4 lists (2^2), you divide again, you have 8 lists (2^3)and so on until your list size is 1</source>
          <target state="translated">На первом этапе вы делитесь на 2,затем у вас есть 2 списка (2^1),вы делите каждый на 2,так что у вас есть 4 списка (2^2),вы снова делитесь,у вас есть 8 списков (2^3)и так далее,пока размер вашего списка не станет 1.</target>
        </trans-unit>
        <trans-unit id="c089231c2cd527f03ef02173a14ef58e49378bb4" translate="yes" xml:space="preserve">
          <source>Because time complexity depends on various parameters viz.</source>
          <target state="translated">Потому что временная сложность зависит от различных параметров.</target>
        </trans-unit>
        <trans-unit id="79385006bae7e35860b6fe3468ec15323eadbe8e" translate="yes" xml:space="preserve">
          <source>Binary search is an example with complexity &lt;code&gt;O(log n)&lt;/code&gt;. Let's say that the nodes in the bottom level of the tree in figure 1 represents items in some sorted collection. Binary search is a divide-and-conquer algorithm, and the drawing shows how we will need (at most) 4 comparisons to find the record we are searching for in this 16 item dataset.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Двоичный поиск - пример со сложностью &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предположим, что узлы на нижнем уровне дерева на рисунке 1 представляют элементы в некоторой отсортированной коллекции. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Бинарный поиск - это алгоритм &amp;laquo;разделяй и властвуй&amp;raquo;, и на рисунке показано, как нам потребуется (не более) 4 сравнений, чтобы найти запись, которую мы ищем в этом наборе данных из 16 элементов.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be848c0e0760b865d37c7f1e1021bb006ee2006e" translate="yes" xml:space="preserve">
          <source>Binary tree is a case where a problem of size n is divided into sub-problem of size n/2 until we reach a problem of size 1:</source>
          <target state="translated">Двоичное дерево-это случай,когда задача размера n делится на подзадачу размера n2 до тех пор,пока мы не достигнем задачи размера 1:</target>
        </trans-unit>
        <trans-unit id="3224959bcf8bf1a4e97341e888dd1713f7031354" translate="yes" xml:space="preserve">
          <source>But even in mathematical analysis sometimes this symbol was used in meaning &quot;C*g(n) &amp;gt; f(n) &amp;gt; 0&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но даже в математическом анализе иногда этот символ использовался в значении &amp;laquo;C * g (n)&amp;gt; f (n)&amp;gt; 0&amp;raquo;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="028ac440b61f595ee3489b7aaf85ae807e104671" translate="yes" xml:space="preserve">
          <source>But what exactly is &lt;em&gt;O(log n)&lt;/em&gt;?  For example, what does it mean to say that the height of a complete binary tree is &lt;em&gt;O(log n)&lt;/em&gt;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но что именно &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, что значит сказать, что высота полного двоичного дерева равна &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8956095c5174d4083eb653119d3665061530f125" translate="yes" xml:space="preserve">
          <source>But what exactly is O(log n)</source>
          <target state="translated">Но что такое O(log n)</target>
        </trans-unit>
        <trans-unit id="0f241aead868e87d092bade7cdb4f3dc39360f7f" translate="yes" xml:space="preserve">
          <source>But what exactly is O(log n)? For example, what does it mean to say that the height of a &amp;gt;complete binary tree is O(log n)?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но что именно O (log n)? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, что значит сказать, что высота полного бинарного дерева равна O (log n)?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="edc1bfb371b8739da6f6a8bfe6b528f1e14b4316" translate="yes" xml:space="preserve">
          <source>Divide and conquer algorithms usually have a &lt;code&gt;logn&lt;/code&gt; component to the running time. This comes from the repeated halving of the input.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алгоритмы &amp;laquo;разделяй и властвуй&amp;raquo; обычно имеют &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;компонент &lt;/font&gt;&lt;/font&gt; &lt;code&gt;logn&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в систему во время выполнения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это происходит из-за многократного деления ввода на два.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="042a172d4487ee962ac155493b6704fe324ce14f" translate="yes" xml:space="preserve">
          <source>Edit: As noted, the log base doesn't matter, but when deriving the Big-O performance of an algorithm, the log factor will come from halving, hence why I think of it as base 2.</source>
          <target state="translated">Правка:Как уже отмечалось,лог-база не имеет значения,но при получении Big-O производительности алгоритма,лог-фактор будет происходить от сокращения вдвое,поэтому я считаю его базой 2.</target>
        </trans-unit>
        <trans-unit id="6b51ffb5caa85a59fa5b79d9a86cc93f753c1d72" translate="yes" xml:space="preserve">
          <source>Every time we write an algorithm or code we try to analyze its asymptotic complexity.
It is different from its &lt;b&gt;time complexity&lt;/b&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Каждый раз, когда мы пишем алгоритм или код, мы пытаемся проанализировать его асимптотическую сложность. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это отличается от своей &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;временной сложности&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a32654a9db30d8a5838e3722ec97067271f1ac0" translate="yes" xml:space="preserve">
          <source>First I recommend you to read following book;</source>
          <target state="translated">Сначала я рекомендую вам прочитать следующую книгу;</target>
        </trans-unit>
        <trans-unit id="4389c042e3105fc444c640d496eb44c0535e3593" translate="yes" xml:space="preserve">
          <source>First, you'll want to have a general idea of Logarithm, which you can get from &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;https://en.wikipedia.org/wiki/Logarithm&lt;/a&gt; . Natural science use &lt;code&gt;e&lt;/code&gt; and the natural log. Engineering disciples will use log_10 (log base 10) and computer scientists will use log_2 (log base 2) a lot, since computers are binary based. Sometimes you'll see abbreviations of natural log as &lt;code&gt;ln()&lt;/code&gt;, engineers normally leave the _10 off and just use &lt;code&gt;log()&lt;/code&gt; and log_2 is abbreviated as &lt;code&gt;lg()&lt;/code&gt;. All of the types of logarithms grow in a similar fashion, that is why they share the same category of &lt;code&gt;log(n)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Во-первых, вам нужно иметь общее представление о логарифме, которое вы можете получить по &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;адресу https://en.wikipedia.org/wiki/Logarithm&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Естествознание использует &lt;/font&gt;&lt;/font&gt; &lt;code&gt;e&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и натуральное бревно. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ученики-инженеры будут использовать log_10 (база 10 журналов), а ученые-программисты будут часто использовать log_2 (база 2 журналов), поскольку компьютеры работают на двоичном языке. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Иногда вы видите сокращения натурального журнала как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ln()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , инженеры обычно оставляют _10 выключенным и просто используют &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; а log_2 сокращается как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;lg()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Все типы логарифмов растут одинаковым образом, поэтому они разделяют одну и ту же категорию &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e17e10b891c653c285dea64d8f7a3373a1c19493" translate="yes" xml:space="preserve">
          <source>Following &lt;strong&gt;Big-O Complexity Chart&lt;/strong&gt; also taken from &lt;a href=&quot;http://bigocheatsheet.com/&quot;&gt;bigocheatsheet&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;После &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Big-O Сложность Chart&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; также взяты из &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bigocheatsheet.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bigocheatsheet&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16d7a7b7bac663123d8b79b95559ac46d279282b" translate="yes" xml:space="preserve">
          <source>Following is an example of Linear Time Algorithm</source>
          <target state="translated">Ниже приведен пример алгоритма линейного времени.</target>
        </trans-unit>
        <trans-unit id="1fef1582a836eacedbb1ab2d7e10888873cb5181" translate="yes" xml:space="preserve">
          <source>For example, the following function is &lt;em&gt;O(n)&lt;/em&gt; because the algorithm grows in proportion to its input &lt;em&gt;n&lt;/em&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, следующая функция - &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n),&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; потому что алгоритм растет пропорционально его входу &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4caaa120df8c8c3e1948ef5644142dc7327e7965" translate="yes" xml:space="preserve">
          <source>For the below examples, we're now at the printer's office. Phone books are waiting to be mailed to each resident or business, and there's a sticker on each phone book identifying where it should be mailed to. Every person or business gets one phone book.</source>
          <target state="translated">Для приведенных ниже примеров мы сейчас в офисе принтера.Телефонные книги ожидают отправки по почте каждому жителю или предприятию,и на каждой телефонной книге есть наклейка,указывающая,куда ее следует отправить по почте.Каждый человек или предприятие получает по одной телефонной книге.</target>
        </trans-unit>
        <trans-unit id="008f849741e4c42a77d0d3e85df29402d2062285" translate="yes" xml:space="preserve">
          <source>For the tree example, you can easily see that stepping down a level of nodes cuts down an exponential number of elements as you continue traversing. The popular example of looking through a name-sorted phone book is essentially equivalent to traversing down a binary search tree (middle page is the root element, and you can deduce at each step whether to go left or right).</source>
          <target state="translated">В примере дерева можно легко заметить,что понижение уровня узлов сокращает экспоненциальное количество элементов при продолжении движения по дереву.Популярный пример просмотра телефонной книги с сортировкой по именам,по сути,эквивалентен обходу по дереву двоичного поиска (средняя страница-это корневой элемент,и вы можете на каждом шагу определить,идти ли вправо или влево).</target>
        </trans-unit>
        <trans-unit id="f8cbba489ca545bed31ce5284b0f861e16a08da2" translate="yes" xml:space="preserve">
          <source>Given n input elements, to search an element in the array you need &lt;b&gt;at most 'n' comparisons&lt;/b&gt;. In other words, no matter what programming language you use, what coding style you prefer, on what system you execute it. In the worst case scenario it requires only n comparisons.The execution time is linearly proportional to the input size.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Учитывая n входных элементов, для поиска элемента в массиве нужно &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не более n сравнений&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другими словами, независимо от того, какой язык программирования вы используете, какой стиль кодирования вы предпочитаете, в какой системе вы его выполняете. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В худшем случае требуется только n сравнений. Время выполнения линейно пропорционально размеру ввода.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b7e083bb0f5b4f68b701df168e90a1fcd7902c02" translate="yes" xml:space="preserve">
          <source>Here are the running times of some operations we might perform on the phone book, from fastest to slowest:</source>
          <target state="translated">Вот время выполнения некоторых операций,которые мы можем выполнить в телефонной книге,от самых быстрых до самых медленных:</target>
        </trans-unit>
        <trans-unit id="a642dd551ca2983c44ce398efcbea81aaf769af0" translate="yes" xml:space="preserve">
          <source>Here is some functions and their expected complexities. Numbers are indicating &lt;strong&gt;statement execution frequencies&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот некоторые функции и их ожидаемые сложности. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Числа указывают &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;частоты выполнения операторов&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4544d6dc56eede04340e7b413a78c264800e6ff9" translate="yes" xml:space="preserve">
          <source>I am learning about Big O Notation running times and amortized times.  I understand the notion of &lt;em&gt;O(n)&lt;/em&gt; linear time, meaning that the size of the input affects the growth of the algorithm proportionally...and the same goes for, for example, quadratic time &lt;em&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/em&gt; etc..even algorithms, such as permutation generators, with &lt;em&gt;O(n!)&lt;/em&gt; times, that grow by factorials.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я узнаю о времени работы Big O Notation и времени амортизации. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я понимаю понятие &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; линейного времени, означающего, что размер входных данных влияет на рост алгоритма пропорционально ... и то же самое относится, например, к квадратичному времени &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) и т. Д.&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Даже к алгоритмам такие как генераторы перестановок, с &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n!)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; раз, которые растут на факториалах.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1514ac946545245f0cd6c0c469469d9924c92dc8" translate="yes" xml:space="preserve">
          <source>I can add something interesting, that I read in book by Kormen and etc. a long time ago. Now, imagine a problem, where we have to find a solution in a problem space. This problem space should be finite.</source>
          <target state="translated">Я могу добавить кое-что интересное,что я прочитала в книге Кормена и т.д.уже давно.Теперь представьте себе проблему,где мы должны найти решение в проблемном пространстве.Это проблемное пространство должно быть конечным.</target>
        </trans-unit>
        <trans-unit id="77898565c07238eac54505aaa70fda9acd97105d" translate="yes" xml:space="preserve">
          <source>I can give an example for a for loop and maybe once grasped the concept maybe it will be simpler to understand in different contexts.</source>
          <target state="translated">Я могу привести пример для петли,и,возможно,однажды усвоив концепцию,будет проще понять ее в разных контекстах.</target>
        </trans-unit>
        <trans-unit id="f46c74600710cca3491ccc2d55014c941985acd4" translate="yes" xml:space="preserve">
          <source>I cannot understand how to identify a function with a log time.</source>
          <target state="translated">Я не могу понять,как определить функцию по времени журнала.</target>
        </trans-unit>
        <trans-unit id="b120641fbd4e22f22f1a41d9c1460d708b5abf16" translate="yes" xml:space="preserve">
          <source>I cannot understand how to identify a function with a logarithmic
  time.</source>
          <target state="translated">Я не могу понять,как идентифицировать функцию с логарифмическим временем.</target>
        </trans-unit>
        <trans-unit id="2fc60cfd1e6ecec87ecd174464fd863785193468" translate="yes" xml:space="preserve">
          <source>I do know (maybe not in great detail) what Logarithm is, in the sense that:  log&lt;sub&gt;10&lt;/sub&gt; 100 = 2, but I cannot understand how to identify a function with a logarithmic time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я знаю (возможно, не очень подробно), что такое логарифм, в том смысле, что: log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 100 = 2, но я не могу понять, как идентифицировать функцию с логарифмическим временем.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c4c380d7b586ba548b763e759bdb6e8a0e7d641" translate="yes" xml:space="preserve">
          <source>I should point out, that we are talking here about a relative fraction limit, not the absolute one. The binary search is a classical example. At each step we throw away 1/2 of the problem space. But binary search is not the only such example. Suppose, you proved somehow, that at each step you throw away at least 1/128 of problem space. That means, your program is still running at O(logN) time, although significantly slower than the binary search. This is a very good hint in analyzing of recursive algorithms. It often can be proved that at each step the recursion will not use several variants, and this leads to the cutoff of some fraction in problem space.</source>
          <target state="translated">Должен заметить,что речь идет не об абсолютном,а об относительном пределе дроби.Двоичный поиск-классический пример.На каждом шаге мы выбрасываем 12 из проблемного пространства.Но двоичный поиск-не единственный такой пример.Предположим,вы как-то доказали,что на каждом шаге выбрасываете не менее 1128 проблемного пространства.Это значит,что Ваша программа все еще работает во время O(logN),хотя и значительно медленнее,чем бинарный поиск.Это очень хороший намек в анализе рекурсивных алгоритмов.Часто можно доказать,что на каждом шаге рекурсии не будет использоваться несколько вариантов,и это приводит к отсечению некоторой части проблемного пространства.</target>
        </trans-unit>
        <trans-unit id="5881b589c8d34329db8c8aaf3583f04e0a95d59a" translate="yes" xml:space="preserve">
          <source>I would rephrase this as 'height of a complete binary tree is log n'.  Figuring the height of a complete binary tree would be O(log n), if you were traversing down step by step.</source>
          <target state="translated">Я бы перефразировал это как &quot;высота полного двоичного дерева-это бревно n&quot;.Если бы вы шаг за шагом двигались вниз,то высота полного двоичного дерева была бы O(log n).</target>
        </trans-unit>
        <trans-unit id="34a2c69faab5e22f0819e07416c899e0ab5ea227" translate="yes" xml:space="preserve">
          <source>If an operation makes a series of constant time decisions each of which halves (reduces by a factor of 3, 4, 5..) the size of the input to be considered, the whole will take time proportional to log base 2 (base 3, base 4, base 5...) of the size N of the input, rather than being O(N).</source>
          <target state="translated">Если операция принимает ряд постоянных временных решений,каждое из которых вдвое уменьшает (уменьшает в 3,4,5...)размер рассматриваемого входа,то на это потребуется время,пропорциональное логовому базису 2 (базис 3,базис 4,базис 5...)размера N входа,а не O(N).</target>
        </trans-unit>
        <trans-unit id="29c301205bbde0676fa60de7fb664c0272520a41" translate="yes" xml:space="preserve">
          <source>If an operation performs constant time work on each digit or bit of an input, the whole operation will take time proportional to the number of digits or bits in the input, not the magnitude of the input; thus, O(log N) rather than O(N).</source>
          <target state="translated">Если операция выполняет постоянную временную работу над каждой цифрой или битом входа,то вся операция займет время,пропорциональное количеству цифр или битов на входе,а не амплитуде входа;таким образом,O(log N),а не O(N).</target>
        </trans-unit>
        <trans-unit id="40f1a35a514953f64f37c0530c0551a81f2c1d8c" translate="yes" xml:space="preserve">
          <source>If you are looking for a intuition based answer I would like to put up two interpretations for you.</source>
          <target state="translated">Если вы ищете ответ,основанный на интуиции,я хотел бы предложить вам две интерпретации.</target>
        </trans-unit>
        <trans-unit id="e727fd9b51a54744bd70b04f39c112e181c73e04" translate="yes" xml:space="preserve">
          <source>If you had a function that takes:</source>
          <target state="translated">Если бы у тебя была функция:</target>
        </trans-unit>
        <trans-unit id="cae2fdb17e96f6926d298666e40f5aed0ba43750" translate="yes" xml:space="preserve">
          <source>If you have an M-ary tree of depth d and size n, then:</source>
          <target state="translated">Если у вас есть М-образное дерево глубиной d и размером n,то..:</target>
        </trans-unit>
        <trans-unit id="1d95e53c64e645e837222469b9cab7b8c1b9b2cb" translate="yes" xml:space="preserve">
          <source>If you increase the problem size by a multiplicative amount (i.e. multiply its size by 10), the work is only increased by an additive amount.</source>
          <target state="translated">Если увеличить размер задачи на мультипликативную величину (т.е.умножить ее размер на 10),то работа увеличивается только на количество добавок.</target>
        </trans-unit>
        <trans-unit id="8e7f99e5aec28c3c3af14e4b086ab56f08a3ece3" translate="yes" xml:space="preserve">
          <source>If you plot a logarithmic function on a graphical calculator or something similar, you'll see that it rises really slowly -- even more slowly than a linear function.</source>
          <target state="translated">Если вы построите логарифмическую функцию на графическом калькуляторе или что-то подобное,вы увидите,что она поднимается очень медленно-даже медленнее,чем линейная функция.</target>
        </trans-unit>
        <trans-unit id="b135e7e3c1db73615122392851be7982fb0590b8" translate="yes" xml:space="preserve">
          <source>Imagine a very high hill with a very broad base as well. To reach the top of the hill there are two ways: one is a dedicated pathway going spirally around the hill reaching at the top, the other: small terrace like carvings cut out to provide a staircase. Now if the first way is reaching in linear time O(n), the second one is O(log n).</source>
          <target state="translated">Представьте себе очень высокий холм с очень широким основанием.Достичь вершины холма можно двумя способами:один-это специальная дорожка,проходящая по спирали вокруг холма,достигающая вершины,другой-небольшая терраса в виде резьбы,вырезанной для того,чтобы обеспечить лестницу.Теперь,если первый путь достигает в линейное время O(n),второй путь-O(log n).</target>
        </trans-unit>
        <trans-unit id="5e33e04b1dee3afdd640617efc039e44bde6caae" translate="yes" xml:space="preserve">
          <source>Imagine an algorithm, which accepts an integer, &lt;code&gt;n&lt;/code&gt; as input and completes in time proportional to &lt;code&gt;n&lt;/code&gt; then it is O(n) or theta(n) but if it runs in time proportion to the &lt;code&gt;number of digits or the number of bits in the binary representation on number&lt;/code&gt; then the algorithm runs in O(log n) or theta(log n) time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Представьте себе алгоритм, который принимает целое число, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; в&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; качестве входных данных, и завершает его во времени, пропорциональном &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; тогда это O (n) или theta (n), но если он выполняется во времени, пропорциональном &lt;/font&gt;&lt;/font&gt; &lt;code&gt;number of digits or the number of bits in the binary representation on number&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; после чего алгоритм выполняется за O (log n) или тета (log n) время.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6d589872ee5e41297713f59c099e086e3b4052ff" translate="yes" xml:space="preserve">
          <source>Imagine we have a rope and we have tied it to a horse. If the rope is directly tied to the horse, the force the horse would need to pull away (say, from a man) is directly 1.</source>
          <target state="translated">Представьте,что у нас есть веревка и мы привязали ее к лошади.Если веревка привязана непосредственно к лошади,то сила,которую лошадь должна была бы оттянуть (скажем,от человека),равна непосредственно 1.</target>
        </trans-unit>
        <trans-unit id="6378d42546aa9afc7483f28bf7aebdf73c49b4cd" translate="yes" xml:space="preserve">
          <source>In information technology it means that:</source>
          <target state="translated">В информационных технологиях это означает,что</target>
        </trans-unit>
        <trans-unit id="98c3336af693827be0b1652e42621a919c618013" translate="yes" xml:space="preserve">
          <source>In lay terms, it means that the equation for time may have some other components: e.g. it may have some constant startup time;  but these other components pale towards insignificance for large values of n, and the a*log(n) is the dominating term for large n.</source>
          <target state="translated">Говоря простым языком,это означает,что уравнение для времени может иметь некоторые другие компоненты:например,оно может иметь некоторое постоянное время запуска;но эти другие компоненты бледнеют к незначительному для больших значений n,а a*log(n)является доминирующим термином для больших n.</target>
        </trans-unit>
        <trans-unit id="58f7c710de382403051e79844d41a906eeb779a2" translate="yes" xml:space="preserve">
          <source>In mathematical analysis it means that:</source>
          <target state="translated">В математическом анализе это означает,что</target>
        </trans-unit>
        <trans-unit id="b3e3252b9357453f176dba5797bfb8ef7ee2628e" translate="yes" xml:space="preserve">
          <source>In our example above, our 'growth rate' is &lt;strong&gt;O(log n)&lt;/strong&gt;. For every additional loop, the force our rope can handle is 10 times more:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В нашем примере выше, наша &amp;laquo;скорость роста&amp;raquo; равна &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На каждую дополнительную петлю сила, которую может выдержать наша веревка, в 10 раз больше:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f65581e910638647521ce0d5776783cc36b7118" translate="yes" xml:space="preserve">
          <source>In the case of binary search, every iteration you throw away half of the input. It should be noted that in Big-O notation, log is log base 2.</source>
          <target state="translated">В случае двоичного поиска,каждую итерацию Вы выбрасываете половину входа.Следует отметить,что в нотации Big-O лог-это лог-база 2.</target>
        </trans-unit>
        <trans-unit id="fb6b918ab69d9248208647f0c2b72d19f69ad0b5" translate="yes" xml:space="preserve">
          <source>In this article there is a quote:
&lt;a href=&quot;http://www.phil.uu.nl/datastructuren/09-10/knuth_big_omicron.pdf&quot;&gt;D.E. Knuth, &quot;BIG OMICRON AND BIG OMEGA AND BIG THETA&quot;, 1976&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В этой статье есть цитата: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.phil.uu.nl/datastructuren/09-10/knuth_big_omicron.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DE Knuth, &amp;laquo;БОЛЬШОЕ ОМИКРОН И БОЛЬШАЯ ОМЕГА И БОЛЬШАЯ ТЕТА&amp;raquo;, 1976 г .&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8670c63b3667b4287608c526872dfc9205befd56" translate="yes" xml:space="preserve">
          <source>Instead we take input size as the parameter because whatever the code is, the input is same.
&lt;b&gt;So the execution time is a function of input size.&lt;/b&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вместо этого мы принимаем входной размер в качестве параметра, потому что, какой бы ни был код, входные данные одинаковы. &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, время выполнения зависит от размера ввода.&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0dc1da4c3f8d12c166ff2cd6e4311d6053faa4f2" translate="yes" xml:space="preserve">
          <source>It is like saying that logarithm is the inverse of exponential.</source>
          <target state="translated">Это все равно,что сказать,что логарифм-это обратный экспоненциальный.</target>
        </trans-unit>
        <trans-unit id="c4cf5d0abe643a3d91104db3051e74c625aac83a" translate="yes" xml:space="preserve">
          <source>It is the number of times you can cut a log of length n repeatedly into b equal parts before reaching a section of size 1.</source>
          <target state="translated">Это количество раз,которое можно нарезать бревно длиной n многократно на b равных частей до достижения отрезка 1-го размера.</target>
        </trans-unit>
        <trans-unit id="70b54711198b76e6fa5a133bb42b9709471571ba" translate="yes" xml:space="preserve">
          <source>It simply means that the time needed for this task grows with log(n) (example : 2s for n = 10, 4s for n = 100, ...). Read the Wikipedia articles on &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;Binary Search Algorithm&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O Notation&lt;/a&gt; for more precisions.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это просто означает, что время, необходимое для этой задачи, увеличивается с log (n) (пример: 2 с для n = 10, 4 с для n = 100, ...). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Прочитайте статьи Википедии об &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;алгоритме двоичного поиска&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Big O Notation&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для большей точности.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d446a1de595cefe01ba8d7b981f6598cef60e89a" translate="yes" xml:space="preserve">
          <source>Lastly very simple showcase there is shows how it is calculated;</source>
          <target state="translated">И,наконец,очень простая витрина показывает,как она рассчитывается;</target>
        </trans-unit>
        <trans-unit id="5365cefd34a28e9f6f10283dbf2204e550bd9877" translate="yes" xml:space="preserve">
          <source>Like algorithm 10, but with some variations.</source>
          <target state="translated">Как алгоритм 10,но с некоторыми вариациями.</target>
        </trans-unit>
        <trans-unit id="daf9ca7dff5ef97da12064b1422d4d6d308259b7" translate="yes" xml:space="preserve">
          <source>Like algorithm 12, but with some variations that still yield &lt;code&gt;O(n^3)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как и алгоритм 12, но с некоторыми вариациями, которые все еще дают &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n^3)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38289bf08745c473c76541ef8dc4bf419c9505a0" translate="yes" xml:space="preserve">
          <source>Logarithm is essentially the inverse of exponentiation.  So, if each 'step' of your function is eliminating a &lt;strong&gt;factor&lt;/strong&gt; of elements from the original item set, that is a logarithmic time algorithm.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Логарифм по сути является обратным возведению в степень. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Итак, если каждый &amp;laquo;шаг&amp;raquo; вашей функции исключает &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;фактор&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; элементов из исходного набора элементов, это алгоритм логарифмического времени.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c37c28e3db4ab56ed0c7f37046862788fd45f644" translate="yes" xml:space="preserve">
          <source>Logarithmic running time (&lt;code&gt;O(log n)&lt;/code&gt;) essentially means that the running time grows in proportion to the &lt;em&gt;logarithm&lt;/em&gt; of the input size - as an example, if 10 items takes at most some amount of time &lt;code&gt;x&lt;/code&gt;, and 100 items takes at most, say, &lt;code&gt;2x&lt;/code&gt;, and 10,000 items takes at most &lt;code&gt;4x&lt;/code&gt;, then it's looking like an &lt;code&gt;O(log n)&lt;/code&gt; time complexity.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Логарифмическое время выполнения ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) по существу означает, что время выполнения увеличивается пропорционально &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;логарифму&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; входного размера - например, если 10 элементов занимают самое большее некоторое количество времени &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , а 100 элементов занимают самое большее, скажем, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и 10000 элементов занимают не более &lt;/font&gt;&lt;/font&gt; &lt;code&gt;4x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , тогда это выглядит как &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сложность времени &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0da223ebb05c072d02e7d7d009cc82db75960461" translate="yes" xml:space="preserve">
          <source>Many good answers have already been posted to this question, but I believe we really are missing an important one - namely, the illustrated answer.</source>
          <target state="translated">На этот вопрос уже выложено много хороших ответов,но я считаю,что нам действительно не хватает одного важного,а именно иллюстрированного ответа.</target>
        </trans-unit>
        <trans-unit id="0b6718155769a3e78ed892aa3ac3ab7d62302796" translate="yes" xml:space="preserve">
          <source>Note that if the equation were, for example ...</source>
          <target state="translated">Обратите внимание,что если бы уравнение было,например,...</target>
        </trans-unit>
        <trans-unit id="0aa386acc93467ee2abde73845cd59703ce2baff" translate="yes" xml:space="preserve">
          <source>Notice that I have bolded 'at most'. Big-O notation always refers to the worse case. If you're lucky, you could guess the number in one attempt and so the best case is O(1), but that's another story.</source>
          <target state="translated">Заметьте,что я набрался смелости &quot;максимум&quot;.Большая нотация всегда относится к худшему.Если вам повезло,вы можете угадать число в одной попытке,так что лучший вариант-O(1),но это уже другая история.</target>
        </trans-unit>
        <trans-unit id="896e616be26c906871b376ff0bcf07906cf168d2" translate="yes" xml:space="preserve">
          <source>Now if the rope is looped once, the horse will need to pull 10 times harder. If the human decides to make it really difficult for the horse, he may loop the rope again round a pole, increasing it's strength by an additional 10 times. A third loop will again increase the strength by a further 10 times.</source>
          <target state="translated">Теперь,если веревку петлять один раз,лошади придется потянуть в 10 раз сильнее.Если человек решит усложнить лошади задачу,он может снова перетянуть веревку вокруг столба,увеличив ее прочность еще в 10 раз.Третья петля снова увеличит силу еще в 10 раз.</target>
        </trans-unit>
        <trans-unit id="1d64633a7606b749454da054611ddab06ad82f5e" translate="yes" xml:space="preserve">
          <source>Now imagine the rope is looped round a pole. The horse to get away will now have to pull many times harder. The amount of times will depend on the roughness of the rope and the size of the pole, but let's assume it will multiply one's strength by 10 (when the rope makes a complete turn).</source>
          <target state="translated">А теперь представьте,что веревка крутится вокруг столба.Лошади,чтобы уйти,теперь придется тянуть во много раз сильнее.Количество раз будет зависеть от шероховатости веревки и размера полюса,но допустим,что он умножит свою прочность на 10 (когда веревка сделает полный оборот).</target>
        </trans-unit>
        <trans-unit id="d4de53fc0c4c7ca626fe1b6e7ea8bfbf1e3b1a36" translate="yes" xml:space="preserve">
          <source>Now it took you 7 guesses to get this right. But what is the relationship here? What is the most amount of items that you can guess from each additional guess?</source>
          <target state="translated">Теперь тебе понадобилось 7 догадок,чтобы все исправить.Но какие здесь отношения? Какое количество предметов вы можете угадать из каждой дополнительной догадки?</target>
        </trans-unit>
        <trans-unit id="02fb936ea47e751f434197c3c1e70189f2a9e94f" translate="yes" xml:space="preserve">
          <source>Now let's imagine you are trying to guess a number between 1-100.</source>
          <target state="translated">Теперь давайте представим,что вы пытаетесь угадать число между 1-100.</target>
        </trans-unit>
        <trans-unit id="92c7d02b06664cf176d72b22469d6e2637331bf5" translate="yes" xml:space="preserve">
          <source>Now the example above did use base 10, but fortunately the base of the log is insignificant when we talk about big o notation.</source>
          <target state="translated">Теперь в примере выше использовалась база 10,но,к счастью,база лога незначительна,когда мы говорим о большой нотации.</target>
        </trans-unit>
        <trans-unit id="d1132f0f0d5b4551a144f923806f22c8f231b52c" translate="yes" xml:space="preserve">
          <source>Now try to see it that way, if exponential grows very fast then logarithm grows (inversely) very slow.</source>
          <target state="translated">Теперь попробуйте посмотреть на это так,если экспоненциальный рост очень быстрый,то логарифм растет (обратно)очень медленно.</target>
        </trans-unit>
        <trans-unit id="cf7bf0faa69c8d99b94cd18c064970e2c8eb7a8e" translate="yes" xml:space="preserve">
          <source>Now, if you can prove, that at every iteration of your algorithm you cut off a fraction of this space, that is no less than some limit, this means that your algorithm is running in O(logN) time.</source>
          <target state="translated">Теперь,если Вы можете доказать,что на каждой итерации Вашего алгоритма Вы отсекаете часть этого пространства,то есть не меньше некоторого лимита,это означает,что Ваш алгоритм работает во времени O(logN).</target>
        </trans-unit>
        <trans-unit id="225912e442e23ad1ffb556abadc76e236a543d7e" translate="yes" xml:space="preserve">
          <source>O(log n) is a bit misleading, more precisely it's O(log&lt;sub&gt;2&lt;/sub&gt; n), i.e. (logarithm with base 2).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n) немного вводит в заблуждение, точнее - O (log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n), т. Е. (Логарифм с основанием 2).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="741abfc15af347b4f12ce5826876662fcbfe5bae" translate="yes" xml:space="preserve">
          <source>Of course, a bigger phone book will still take you a longer time, but it won't grow as quickly as the proportional increase in the additional size.</source>
          <target state="translated">Конечно,большая телефонная книга все равно займет у вас больше времени,но она не будет расти так быстро,как пропорциональное увеличение дополнительного размера.</target>
        </trans-unit>
        <trans-unit id="c91777dabbef341bced10eccfce89a68f07e4082" translate="yes" xml:space="preserve">
          <source>Ok let's try and fully understand what a logarithm actually is.</source>
          <target state="translated">Хорошо,давайте попробуем полностью понять,что такое логарифм на самом деле.</target>
        </trans-unit>
        <trans-unit id="60081c10f46ab24f55cbcac1d8baa12b740223fb" translate="yes" xml:space="preserve">
          <source>On the basis of the issues discussed here, I propose that members of
  SIGACT, and editors of computer science and mathematics journals,
  adopt notations as defined above, unless &lt;strong&gt;a better alternative can be
  found reasonably soon&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Исходя из обсуждаемых здесь вопросов, я предлагаю членам SIGACT и редакторам журналов по информатике и математике принять обозначения, как определено выше, если только &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;лучшая альтернатива не будет найдена достаточно скоро&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f1b4ad273ca861456f8e996a15667043d1cefab0" translate="yes" xml:space="preserve">
          <source>Or actually, it doesn't quite mean that; more likely it means something like &quot;&lt;code&gt;time&lt;/code&gt; divided by &lt;code&gt;a*log(n)&lt;/code&gt; tends towards &lt;code&gt;1&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Или на самом деле, это не совсем так; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;более вероятно, что это означает что-то вроде &amp;laquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;time&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; деленное на &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; стремится к &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="172a790a2a8831c6bd8b4653399b564aa7c99f4b" translate="yes" xml:space="preserve">
          <source>Others have given good diagram examples, such as the tree diagrams. I did not see any simple code examples. So in addition to my explanation, I'll provide some algorithms with simple print statements to illustrate the complexity of different algorithm categories.</source>
          <target state="translated">Другие приводили хорошие примеры диаграмм,например,древовидные диаграммы.Простых примеров кода я не видел.Поэтому в дополнение к моим объяснениям,я приведу некоторые алгоритмы с простыми утверждениями печати,чтобы проиллюстрировать сложность различных категорий алгоритмов.</target>
        </trans-unit>
        <trans-unit id="d226550a9f05c197e28559642c0c8048d4b533b4" translate="yes" xml:space="preserve">
          <source>Plotting &lt;code&gt;log(n)&lt;/code&gt; on a plain piece of paper, will result in a graph where the rise of the curve decelerates as &lt;code&gt;n&lt;/code&gt; increases:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Построение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на обычном листе бумаги приведет к графику, на котором рост кривой замедляется с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;увеличением &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fa164feedc89846fdd3de1a98b22842deeff5b6f" translate="yes" xml:space="preserve">
          <source>Searching for 4 yields 3 hits: 6, 3 then 4. And log2 12 = 3, which is a good apporximate to how many hits where needed.</source>
          <target state="translated">Поиск 4-х дает 3-х попаданий:6,3 и 4.И log2 12=3,что хорошо аппроксимирует к тому,сколько попаданий где нужно.</target>
        </trans-unit>
        <trans-unit id="1348a8daed3b64aac9ec3379db2da56a0a9a0029" translate="yes" xml:space="preserve">
          <source>See as the input size increased the work done is increased and it is independent of any machine.
And if you try to find out the value of units of work 
It's actually dependent onto those above specified parameters.It will change according to the systems and all.</source>
          <target state="translated">Смотрите,так как размер ввода увеличивается,выполняемая работа увеличивается,и она не зависит от любой машины.И если вы попытаетесь выяснить значение единиц работы,на самом деле оно зависит от тех параметров,которые указаны выше.Оно будет меняться в зависимости от систем и всего остального.</target>
        </trans-unit>
        <trans-unit id="dab06999693f805ef1a862d7a609e81414475e38" translate="yes" xml:space="preserve">
          <source>Similarly, if there was a nested loop, the time would be O(n&lt;sup&gt;2&lt;/sup&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Точно так же, если бы был вложенный цикл, время было бы O (n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a89c7cdf5037c4260a4641bbc5992b3ebeecf1f" translate="yes" xml:space="preserve">
          <source>Simply put: At each step of your algorithm you can cut the work in half. (Asymptotically equivalent to third, fourth, ...)</source>
          <target state="translated">Проще говоря:на каждом шагу вашего алгоритма вы можете разрезать работу пополам.(Асимптотически эквивалентно третьему,четвертому,...).</target>
        </trans-unit>
        <trans-unit id="401e8032f76cd53b593529b22a8cb008c7dd6f7c" translate="yes" xml:space="preserve">
          <source>So when you say any algorithm is O(log n)
it means the execution time is log times the input size n.</source>
          <target state="translated">Таким образом,когда вы говорите,что любой алгоритм является O(log n),это означает,что время выполнения-это время лога,умноженное на входной размер n.</target>
        </trans-unit>
        <trans-unit id="3fa29b366a6312d23b4d2519423f5db29d71f7d5" translate="yes" xml:space="preserve">
          <source>That gives you the equation :</source>
          <target state="translated">Это дает вам уравнение:</target>
        </trans-unit>
        <trans-unit id="5291dbaca6641002cae33e549bcd7025de975858" translate="yes" xml:space="preserve">
          <source>That means that in the loop the step grows exponentially. E.g.</source>
          <target state="translated">Это означает,что в петле шаг растет экспоненциально.Например.</target>
        </trans-unit>
        <trans-unit id="9216353681115945aaba6250fe5ae4d1014f5529" translate="yes" xml:space="preserve">
          <source>That's what bit O notation means: it means &quot;what is the order of dominant term for any sufficiently large n&quot;.</source>
          <target state="translated">Вот что означает бит O:он означает &quot;какой порядок доминирующего термина для любого достаточно большого n&quot;.</target>
        </trans-unit>
        <trans-unit id="7c239bafbc2dce1d2ee370782accc2cae132308f" translate="yes" xml:space="preserve">
          <source>The above give several straight forward examples, and variations to help demonstrate what subtle changes can be introduced that really don't change the analysis. Hopefully it gives you enough insight.</source>
          <target state="translated">Выше приведено несколько прямых примеров и вариаций,которые помогают продемонстрировать,какие тонкие изменения могут быть введены,которые на самом деле не меняют анализа.Надеюсь,это даст вам достаточно информации.</target>
        </trans-unit>
        <trans-unit id="fda0956265302daf9fe6bdf8cd1b73b62ae63530" translate="yes" xml:space="preserve">
          <source>The best way I've always had to mentally visualize an algorithm that runs in O(log n) is as follows:</source>
          <target state="translated">Лучший способ мысленно визуализировать алгоритм,который работает в O(log n)-это следующее:</target>
        </trans-unit>
        <trans-unit id="81f4a7349b2e61a08d286f542458555f1865b59a" translate="yes" xml:space="preserve">
          <source>The complete binary example is O(ln n) because the search looks like this:</source>
          <target state="translated">Полный двоичный пример-O(ln n),потому что поиск выглядит так:</target>
        </trans-unit>
        <trans-unit id="d7c3202604045a8f0ca1c569409156d740cf38fe" translate="yes" xml:space="preserve">
          <source>The complexity in O-notation of this program is O(log(n)). Let's try to loop through it by hand (n being somewhere between 512 and 1023 (excluding 1024):</source>
          <target state="translated">Сложность в О-нотации этой программы-O(log(n)).Попробуем процитировать его вручную (n-где-то между 512 и 1023 (исключая 1024)):</target>
        </trans-unit>
        <trans-unit id="23fb0bc54f9a22ea3778e044e18fe0f74b651fc4" translate="yes" xml:space="preserve">
          <source>The difference between O(n) and O(log(n)) is huge, similar to the difference between O(n) and O(a^n) (a being a constant).</source>
          <target state="translated">Разница между O(n)и O(log(n))огромна,подобно разнице между O(n)и O(a^n)(a being a constant).</target>
        </trans-unit>
        <trans-unit id="0077251502a2b3945f5070c00b578c932c22496e" translate="yes" xml:space="preserve">
          <source>The explanation below is using the case of a fully &lt;em&gt;balanced&lt;/em&gt; binary tree to help you understand how we get logarithmic time complexity.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Приведенное ниже объяснение использует случай полностью &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сбалансированного&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; двоичного дерева, чтобы помочь вам понять, как мы получаем сложность логарифмического времени.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="979a113826a0c1e025cb59a3bc5b4dbfe4e82d94" translate="yes" xml:space="preserve">
          <source>The following drawing depicts a binary tree. Notice how each level contains double the number of nodes compared to the level above (hence &lt;em&gt;binary&lt;/em&gt;):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На следующем рисунке изображено двоичное дерево. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите внимание, что каждый уровень содержит удвоенное количество узлов по сравнению с уровнем выше (следовательно, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;двоичным&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db2a24bbecedf8e012282630dd132fbb4ee8f292" translate="yes" xml:space="preserve">
          <source>The height of a balanced binary tree is O(log&lt;sub&gt;2&lt;/sub&gt; n), since every node has two (note the &quot;two&quot; as in log&lt;sub&gt;2&lt;/sub&gt; n) child nodes. So, a tree with n nodes has a height of log&lt;sub&gt;2&lt;/sub&gt; n.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Высота сбалансированного двоичного дерева равна O (log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n), поскольку каждый узел имеет два (обратите внимание на &amp;laquo;два&amp;raquo;, как в log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n) дочерние узлы. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Итак, дерево с n узлами имеет высоту log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f9f0b9b225087a04ae96fd13b7c4892a8920821" translate="yes" xml:space="preserve">
          <source>The logarithm of x (to the base of a) is the reverse function of a^x.</source>
          <target state="translated">Логарифм x (к основанию a)является обратной функцией a^x.</target>
        </trans-unit>
        <trans-unit id="748b4da565ee01d0e285c7ce2ee8782d05768ee1" translate="yes" xml:space="preserve">
          <source>The logarithmic function is the inverse of the exponential function. Put another way, if your input grows exponentially (rather than linearly, as you would normally consider it), your function grows linearly.</source>
          <target state="translated">Логарифмическая функция является обратной по отношению к экспоненциальной функции.Другими словами,если Ваш вход растет экспоненциально (а не линейно,как Вы обычно считаете),то Ваша функция растет линейно.</target>
        </trans-unit>
        <trans-unit id="217245fbd9703d38af322b5f4c84cf925e99d9dc" translate="yes" xml:space="preserve">
          <source>The most common attributes of logarithmic running-time function are that:</source>
          <target state="translated">Наиболее распространенными атрибутами логарифмической функции времени выполнения являются следующие:</target>
        </trans-unit>
        <trans-unit id="c6ff8c3cdb742922883fe572d4bd4535cbbcdabf" translate="yes" xml:space="preserve">
          <source>The running time complexity of binary search is an example of &lt;code&gt;O(log n)&lt;/code&gt;. This is because in binary search, you are always ignoring half of your input in each later step by dividing the array in half and only focusing on one half with each step. Each step is constant-time, because in binary search you only need to compare one element with your key in order to figure out what to do next irregardless of how big the array you are considering is at any point. So you do approximately log(n)/log(2) steps.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Сложность времени выполнения бинарного поиска является примером &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Это связано с тем, что при бинарном поиске вы всегда игнорируете половину своего ввода на каждом последующем шаге, разделяя массив пополам и фокусируясь только на одной половине с каждым шагом. Каждый шаг является постоянным временем, потому что в бинарном поиске вам нужно только сравнить один элемент с вашим ключом, чтобы выяснить, что делать дальше, независимо от того, какой размер массива вы рассматриваете в любой момент. Таким образом, вы делаете примерно log (n) / log (2) шагов.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="183ce247942b6cd9feda78873387089ea80dbff0" translate="yes" xml:space="preserve">
          <source>The running time complexity of merge sort is an example of &lt;code&gt;O(n log n)&lt;/code&gt;. This is because you are dividing the array in half with each step, resulting in a total of approximately log(n)/log(2) steps. However, in each step you need to perform merge operations on all elements (whether it's one merge operation on two sublists of n/2 elements, or two merge operations on four sublists of n/4 elements, is irrelevant because it adds to having to do this for n elements in each step). Thus, the total complexity is &lt;code&gt;O(n log n)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Сложность времени выполнения сортировки слиянием является примером &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это потому, что вы делите массив пополам с каждым шагом, в результате чего получается примерно log (n) / log (2) шагов. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако на каждом шаге необходимо выполнять операции слияния для всех элементов (будь то одна операция слияния на двух подсписках из n / 2 элементов или две операции слияния на четырех подсписках из n / 4 элементов, не имеет значения, поскольку она добавляет к необходимости сделать это для п элементов в каждом шаге). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, общая сложность составляет &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="78d57ee8f42bffef4d8a9382ae1beeb55a66ed2c" translate="yes" xml:space="preserve">
          <source>Then it takes log&lt;sub&gt;2&lt;/sub&gt;(n) time. The &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt;, loosely speaking, means that the relationship only needs to be true for large n, and that constant factors and smaller terms can be ignored.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Тогда это займет log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (n) времени. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обозначение Большой О&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , грубо говоря, означает , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что отношения нужно только быть верно для больших п, и что постоянные множители и меньшие сроки могут быть проигнорированы.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3f3dd6c155a570957f69b762d0742cb653f9ff27" translate="yes" xml:space="preserve">
          <source>These 2 cases will  take O(log n) time</source>
          <target state="translated">Эти 2 случая займут время O(log n).</target>
        </trans-unit>
        <trans-unit id="d0838d5f8965084f46ea02466a76e08056604c29" translate="yes" xml:space="preserve">
          <source>Think of this as a combination of &lt;code&gt;O(log(n))&lt;/code&gt; and &lt;code&gt;O(n)&lt;/code&gt;. The nesting of the for loops help us obtain the &lt;code&gt;O(n*log(n))&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Думайте об этом как о комбинации &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log(n))&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вложенность циклов for помогает нам получить &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n*log(n))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c85c59919495767e1aa36e7cb8e1e1898fc42aff" translate="yes" xml:space="preserve">
          <source>This algorithm is simple, which prints hello n times.</source>
          <target state="translated">Этот алгоритм прост,который печатает привет n раз.</target>
        </trans-unit>
        <trans-unit id="275d42b938445e6155dc69cc23cb8dbbe4f2b94b" translate="yes" xml:space="preserve">
          <source>This algorithm shows a variation, where it will print hello n/2 times. n/2 = 1/2 * n. We ignore the 1/2 constant and see that this algorithm is O(n).</source>
          <target state="translated">Этот алгоритм показывает вариацию,где он будет печатать приветствие n2 раза.n2=12*n.Мы игнорируем 12-ю константу и видим,что этот алгоритм-O(n).</target>
        </trans-unit>
        <trans-unit id="ef3f528f492ad5a3b79a1dcbea99bd7d9e170e6c" translate="yes" xml:space="preserve">
          <source>This is like algorithm 10, but with 3 loops instead of 2.</source>
          <target state="translated">Это похоже на алгоритм 10,но с 3 циклами вместо 2.</target>
        </trans-unit>
        <trans-unit id="4efa808ed1bb5af8e28061bc1c951efec7f558d1" translate="yes" xml:space="preserve">
          <source>This is why algorithms with a logarithmic time complexity are highly sought after: even for really big n (let's say n = 10^8, for example), they perform more than acceptably.</source>
          <target state="translated">Поэтому алгоритмы со сложностью логарифмического времени очень востребованы:даже для действительно большого n (скажем,n=10^8)они работают более чем приемлемо.</target>
        </trans-unit>
        <trans-unit id="fb1c5cd15bd283875742af5791fe8a2b4e1a3c61" translate="yes" xml:space="preserve">
          <source>This is why, for example, looking up people in a phone book is O(log n). You don't need to check &lt;em&gt;every&lt;/em&gt; person in the phone book to find the right one; instead, you can simply divide-and-conquer by looking based on where their name is alphabetically, and in every section you only need to explore a subset of each section before you eventually find someone's phone number.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот почему, например, поиск людей в телефонной книге - это O (log n). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вам не нужно проверять &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;каждого&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; человека в телефонной книге, чтобы найти нужного; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;вместо этого вы можете просто разделить-и-завоевать, посмотрев на основе того, где их имена расположены в алфавитном порядке, и в каждом разделе вам нужно только изучить подмножество каждого раздела, прежде чем вы в конце концов найдете чей-либо номер телефона.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16784fa25d2d74ba6e12621a053bcbb284da4694" translate="yes" xml:space="preserve">
          <source>Today is 2016, but we use it still today.</source>
          <target state="translated">Сегодня 2016 год,но мы используем его и сегодня.</target>
        </trans-unit>
        <trans-unit id="20d2171208dac823f70a0fc05abd05f1bb1d23c5" translate="yes" xml:space="preserve">
          <source>Using the graph, we can see that if we use a binary search to guess a number between 1-100 it will take us &lt;strong&gt;at most&lt;/strong&gt; 7 attempts. If we had 128 numbers, we could also guess the number in 7 attemps but 129 numbers will takes us &lt;strong&gt;at most&lt;/strong&gt; 8 attempts (in relations to logarithms, here we would need 7 guesses for a 128 value range, 10 guesses for a 1024 value range. 7 is the logarithm of 128, 10 is the logarithm of 1024 (base 2)).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Используя график, мы можем видеть, что если мы используем бинарный поиск, чтобы угадать число от 1 до 100, нам потребуется &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не более&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 7 попыток. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если бы у нас было 128 чисел, мы могли бы также угадать число в 7 попытках, но 129 чисел потребует &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;максимум&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 8 попыток (в отношении логарифмов здесь нам понадобится 7 догадок для диапазона значений 128, 10 догадок для диапазона значений 1024). .7 - логарифм 128, 10 - логарифм 1024 (основание 2).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88eec511fbead7aa7ea065aa934d14f88f9f9b16" translate="yes" xml:space="preserve">
          <source>Walking a single path in the tree ~ O(d) = O(log n to base M)</source>
          <target state="translated">Проход по одному пути в дереве ~ O(d)=O(log n к базе M)</target>
        </trans-unit>
        <trans-unit id="9b73a24be6f8b05f8c2985125f1eb8c601802768" translate="yes" xml:space="preserve">
          <source>We can expand the phone book example to compare other kinds of operations and &lt;em&gt;their&lt;/em&gt; running time. We will assume our phone book has &lt;em&gt;businesses&lt;/em&gt; (the &quot;Yellow Pages&quot;) which have unique names and &lt;em&gt;people&lt;/em&gt; (the &quot;White Pages&quot;) which may not have unique names. A phone number is assigned to at most one person or business. We will also assume that it takes constant time to flip to a specific page.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мы можем расширить пример телефонной книги, чтобы сравнить другие виды операций и &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;их&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; время выполнения. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мы предполагаем, что в нашей телефонной книге есть &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;компании&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (&amp;laquo;Желтые страницы&amp;raquo;), которые имеют уникальные имена, и &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;люди&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (&amp;laquo;Белые страницы&amp;raquo;), которые могут не иметь уникальных имен. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Телефонный номер назначается максимум одному человеку или бизнесу. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мы также предполагаем, что для перехода на определенную страницу требуется постоянное время.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf5c329d95290b50a23a52c623196a7055ce3a59" translate="yes" xml:space="preserve">
          <source>We can see that for each loop, the value increases by 10. The number of turns required to get any number is called the logarithm of the number i.e. we need 3 posts to multiple your strength by 1000 times, 6 posts to multiply your strength by 1,000,000.</source>
          <target state="translated">Мы видим,что для каждого цикла значение увеличивается на 10.Количество оборотов,необходимое для получения любого числа,называется логарифмом числа,т.е.нам нужно 3 столба,чтобы умножить вашу силу в 1000 раз,6 столбов,чтобы умножить вашу силу на 1 000 000.</target>
        </trans-unit>
        <trans-unit id="215d074be1f0a767e1033061b3e486085ff1e2f8" translate="yes" xml:space="preserve">
          <source>We can see that for every guess our data set is shrinking. A good rule of thumb to identify if an algorithm has a logarithmtic time is
  to see if the data set shrinks by a certain order after each iteration</source>
          <target state="translated">Мы видим,что при каждом предположении наш набор данных сокращается.Хорошее эмпирическое правило,чтобы определить,имеет ли алгоритм логарифмическое время,состоит в том,чтобы посмотреть,уменьшается ли набор данных в определенном порядке после каждой итерации.</target>
        </trans-unit>
        <trans-unit id="5c106784281fed81c6b6820aae1f0a6d9cbda0c5" translate="yes" xml:space="preserve">
          <source>What does O(log n) mean exactly</source>
          <target state="translated">Что именно означает O(log n)</target>
        </trans-unit>
        <trans-unit id="93c5eee1c00a2205d8b906b832bc3151f6cc1c21" translate="yes" xml:space="preserve">
          <source>What does it mean to say that the height of a complete binary tree is O(log n)?</source>
          <target state="translated">Что значит,что высота полного двоичного дерева-O(log n)?</target>
        </trans-unit>
        <trans-unit id="44807ad43b2ea914e6e9301d20f34f969353dcde" translate="yes" xml:space="preserve">
          <source>What it means precisely is &quot;as &lt;code&gt;n&lt;/code&gt; tends towards &lt;code&gt;infinity&lt;/code&gt;, the &lt;code&gt;time&lt;/code&gt; tends towards &lt;code&gt;a*log(n)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a constant scaling factor&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это означает, что &amp;laquo;когда &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; стремится к &lt;/font&gt;&lt;/font&gt; &lt;code&gt;infinity&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;time&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; стремится к &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; где &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - постоянный коэффициент масштабирования&amp;raquo;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d9d385e501f3c19dadeb1c4c3602e959a018409e" translate="yes" xml:space="preserve">
          <source>What's log&lt;sub&gt;b&lt;/sub&gt;(n)?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что такое журнал &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;b&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (n)?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5ddb3aa95967c49aba70d9818c8d1d78fd583c6b" translate="yes" xml:space="preserve">
          <source>When you look at the code examples below, I recommend looking at O(1), then O(n), then O(n^2). After you are good with those, then look at the others. I've included clean examples as well as variations to demonstrate how subtle changes can still result in the same categorization.</source>
          <target state="translated">Когда вы смотрите на примеры кода ниже,я рекомендую посмотреть на O(1),затем O(n),затем O(n^2).После того,как вы хорошо справитесь с ними,посмотрите на другие.Я включил как чистые примеры,так и вариации,чтобы продемонстрировать,как едва уловимые изменения могут привести к той же категории.</target>
        </trans-unit>
        <trans-unit id="216423c2bafc59cfac2856f5284a31862176680e" translate="yes" xml:space="preserve">
          <source>You can easily identify if the algorithmic time is n log n. Look for an outer loop which iterates through a list (O(n)). Then look to see if there is an inner loop. If the inner loop is &lt;strong&gt;cutting/reducing&lt;/strong&gt; the data set on each iteration, that loop is (O(log n)), and so the overall algorithm is = &lt;strong&gt;O(n log n)&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете легко определить, если алгоритмическое время равно n log n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ищите внешний цикл, который перебирает список (O (n)). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Затем посмотрите, есть ли внутренний цикл. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если внутренний цикл &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;обрезает / уменьшает&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; набор данных на каждой итерации, этот цикл равен (O (log n)), и поэтому общий алгоритм равен = &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n log n)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1d5328a5b30597cfdbb5f64814aee6e0397a6702" translate="yes" xml:space="preserve">
          <source>You can think of O(1), O(n), O(logn), etc as classes or categories of growth. Some categories will take more time to do than others. These categories help give us a way of ordering the algorithm performance. Some grown faster as the input n grows. The following table demonstrates said growth numerically. In the table below think of log(n) as the ceiling of log_2.</source>
          <target state="translated">Вы можете думать об O(1),O(n),O(logn)и т.д.как о классах или категориях роста.Некоторые категории займут больше времени,чем другие.Эти категории помогают нам упорядочить работу алгоритма.Некоторые из них растут быстрее по мере роста входных n.В следующей таблице показан указанный рост в числовом выражении.В следующей таблице подумайте о log(n)как о потолке log_2.</target>
        </trans-unit>
        <trans-unit id="5c973715b1aaecc205af6056a3e8561731036021" translate="yes" xml:space="preserve">
          <source>You can think of O(log N) intuitively by saying the time is proportional to the number of digits in N.</source>
          <target state="translated">Вы можете интуитивно представить себе O(log N),сказав,что время пропорционально количеству цифр в N.</target>
        </trans-unit>
        <trans-unit id="be063b2f6f59fd659351560845cdcbd0fce725b1" translate="yes" xml:space="preserve">
          <source>You will eventually come across a linearithmic time &lt;strong&gt;O(n log(n))&lt;/strong&gt; algorithm. The rule of thumb above applies again, but this time the logarithmic function has to run n times e.g. reducing the size of a list &lt;strong&gt;n times&lt;/strong&gt;, which occurs in algorithms like a mergesort.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В конечном итоге вы столкнетесь с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;алгоритмом &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;линейного арифметического времени &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n log (n))&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эмпирическое правило выше применяется снова, но на этот раз логарифмическая функция должна запускаться n раз, например, уменьшать размер списка &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n раз&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что происходит в алгоритмах, таких как сортировка слиянием.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e633fb53f72a241fd99a62bdb2e5fec14d3b99f0" translate="yes" xml:space="preserve">
          <source>from &lt;a href=&quot;http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/&quot;&gt;http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;с &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.geeksforgeeks.org/write-ac-program-to-calculate-powxn/&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f561a474d88946ed4c679c84b7d0fa00aa1daefa" translate="yes" xml:space="preserve">
          <source>only one will need to be chosen.</source>
          <target state="translated">нужно будет выбрать только одного.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="949b2d332a8532ba60eb0f9fdaaa648e4f5e90da" translate="yes" xml:space="preserve">
          <source>the choice of the next element on which to perform some action is one of several possibilities, and</source>
          <target state="translated">выбор следующего элемента,на котором будет выполняться какое-либо действие,является одной из нескольких возможностей,и</target>
        </trans-unit>
        <trans-unit id="810680965d466ce9e27c217b0e6ef1c0fc7ac62f" translate="yes" xml:space="preserve">
          <source>the elements on which the action is performed are digits of n</source>
          <target state="translated">элементы,на которых выполняется действие,представляют собой цифры n</target>
        </trans-unit>
        <trans-unit id="7c3255662cb9361125a26cad0c44f18afbdc1a9e" translate="yes" xml:space="preserve">
          <source>time(n) = a + b&lt;em&gt;log(n) + c&lt;/em&gt;n + d&lt;em&gt;n&lt;/em&gt;n</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;время (n) = a + b &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;log (n) + c&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n + d &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3121a265ec660806dc7016bca8595689a539a80d" translate="yes" xml:space="preserve">
          <source>traversing the whole tree ~ O(M^d) = O(n)</source>
          <target state="translated">проходя через все дерево ~ O(M^d)=O(n)</target>
        </trans-unit>
        <trans-unit id="601d76bcf9259b0951e3bbabeb31e37d99f1830f" translate="yes" xml:space="preserve">
          <source>​It is &lt;code&gt;O(log n)&lt;/code&gt; when we do divide and conquer type of algorithms e.g binary search. Another example is quick sort where each time we divide the array into two parts and each time it takes &lt;code&gt;O(N)&lt;/code&gt; time to find a pivot element. Hence it  &lt;code&gt;N O(log N)&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; когда мы делим и побеждаем алгоритмы, например бинарный поиск. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другой пример - быстрая сортировка, где каждый раз, когда мы делим массив на две части, и каждый раз требуется &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(N)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; времени, чтобы найти элемент сводки. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Отсюда &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N O(log N)&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
