<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/2307283">
    <body>
      <group id="2307283">
        <trans-unit id="62c23e7ef4be86040d6c792d74b8103bb503c43a" translate="yes" xml:space="preserve">
          <source>&quot;Tends towards&quot; has the usual mathematical meaning from 'analysis': for example, that &quot;if you pick &lt;em&gt;any&lt;/em&gt; arbitrarily small non-zero constant &lt;code&gt;k&lt;/code&gt;, then I can find a corresponding value &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;((time/(a*log(n))) - 1)&lt;/code&gt; is less than &lt;code&gt;k&lt;/code&gt; for all values of &lt;code&gt;n&lt;/code&gt; greater than &lt;code&gt;X&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Tiende hacia&quot; tiene el significado matem&amp;aacute;tico habitual de 'an&amp;aacute;lisis': por ejemplo, que &quot;si elige &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cualquier&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; constante &lt;/font&gt;&lt;/font&gt; &lt;code&gt;k&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; arbitrariamente peque&amp;ntilde;a que no sea cero &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, entonces puedo encontrar un valor correspondiente &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tal que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;((time/(a*log(n))) - 1)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es menor que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;k&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para todos los valores de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; mayor que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54e10c43522458d7384b566fb9db05322a518452" translate="yes" xml:space="preserve">
          <source>(you take the lg of each side, lg being the log base 2)</source>
          <target state="translated">(tomas el lg de cada lado,siendo lg la base logarítmica 2)</target>
        </trans-unit>
        <trans-unit id="44c99847d54ae4d00b74068530a05dd1fef0dc04" translate="yes" xml:space="preserve">
          <source>*Remember that big-O notation, &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation#Formal_definition&quot;&gt;by definition&lt;/a&gt;, constants don't matter. Also by the &lt;a href=&quot;http://en.wikipedia.org/wiki/Change_of_base_formula_for_logs#Changing_the_base&quot;&gt;change of base rule&lt;/a&gt; for logarithms, the only difference between logarithms of different bases is a constant factor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;* Recuerde que la notaci&amp;oacute;n big-O, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation#Formal_definition&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;por definici&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , las constantes no importan. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n por el &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Change_of_base_formula_for_logs#Changing_the_base&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cambio de la regla de base&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para logaritmos, la &amp;uacute;nica diferencia entre logaritmos de diferentes bases es un factor constante.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48e253e5ab06e6976e35c9bdcea7e10b034cc3d4" translate="yes" xml:space="preserve">
          <source>... then this would be O(n squared) because, no matter what the values of the constants a, b, c, and non-zero d, the &lt;code&gt;d*n*n&lt;/code&gt; term would always dominate over the others for any sufficiently large value of n.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... entonces esto ser&amp;iacute;a O (n al cuadrado) porque, sin importar cu&amp;aacute;les sean los valores de las constantes a, b, c, y no cero d, el t&amp;eacute;rmino &lt;/font&gt;&lt;/font&gt; &lt;code&gt;d*n*n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; siempre dominar&amp;iacute;a sobre los dem&amp;aacute;s para cualquier gran valor de n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a6b947aa846b5da9e63669d7e0ab43fa7149876" translate="yes" xml:space="preserve">
          <source>1. Physical System</source>
          <target state="translated">1.Sistema físico</target>
        </trans-unit>
        <trans-unit id="2da5718e4456d8946ed7cc039bbf65bc4baf31dc" translate="yes" xml:space="preserve">
          <source>2. Programming Language</source>
          <target state="translated">2.2.Lenguaje de programación</target>
        </trans-unit>
        <trans-unit id="c047d0c08b0f62ebc42d10b65de4db18f9b150e9" translate="yes" xml:space="preserve">
          <source>3 is the logarithm of 1,000, and 6 is the logarithm of 1,000,000 (base 10).</source>
          <target state="translated">3 es el logaritmo de 1.000,y 6 es el logaritmo de 1.000.000 (base 10).</target>
        </trans-unit>
        <trans-unit id="864313c2df45c8ba64dccb8ec4055125eac5d1f5" translate="yes" xml:space="preserve">
          <source>3. coding Style</source>
          <target state="translated">3.Estilo de codificación</target>
        </trans-unit>
        <trans-unit id="f2e04afdb09df34f9f44473a7a1ccb50a406dc78" translate="yes" xml:space="preserve">
          <source>4. And much more ......</source>
          <target state="translated">4.Y mucho más...</target>
        </trans-unit>
        <trans-unit id="d563ed5a666051353255960e6c2817c3c0755862" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Linear Search&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B&amp;uacute;squeda lineal&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b5fe40e00cd38153f7725ae75b9e9b6d20e78737" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The actual execution time is not a good measure for analysis.
&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El tiempo de ejecuci&amp;oacute;n real no es una buena medida para el an&amp;aacute;lisis. &lt;/font&gt;&lt;/font&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7302ce438edbf9d107087c0d00e63e527a7611c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log N)&lt;/code&gt; basically means time goes up linearly while the &lt;code&gt;n&lt;/code&gt; goes up exponentially. So if it takes &lt;code&gt;1&lt;/code&gt; second to compute &lt;code&gt;10&lt;/code&gt; elements, it will take &lt;code&gt;2&lt;/code&gt; seconds to compute &lt;code&gt;100&lt;/code&gt; elements, &lt;code&gt;3&lt;/code&gt; seconds to compute &lt;code&gt;1000&lt;/code&gt; elements, and so on.</source>
          <target state="translated">&lt;code&gt;O(log N)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; b&amp;aacute;sicamente significa que el tiempo sube linealmente mientras que el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; sube exponencialmente. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, si toma &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; segundo calcular &lt;/font&gt;&lt;/font&gt; &lt;code&gt;10&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; elementos, tomar&amp;aacute; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; segundos calcular &lt;/font&gt;&lt;/font&gt; &lt;code&gt;100&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; elementos, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;3&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; segundos calcular &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; elementos, y as&amp;iacute; sucesivamente.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29521e79b284726f262e57f3d5e15142bdd210f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log n)&lt;/code&gt; refers to a function (or algorithm, or step in an algorithm) working in an amount of time proportional to the logarithm (usually base 2 in most cases, but not always, and in any event this is insignificant by big-O notation*) of the size of the input.</source>
          <target state="translated">&lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; refiere a una funci&amp;oacute;n (o algoritmo, o paso en un algoritmo) que trabaja en una cantidad de tiempo proporcional al logaritmo (generalmente base 2 en la mayor&amp;iacute;a de los casos, pero no siempre, y en cualquier caso esto es insignificante por grande -O notaci&amp;oacute;n *) del tama&amp;ntilde;o de la entrada.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a33e6cf6849c1bfd0bc219a80b69e82c56092cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log n)&lt;/code&gt; running times are very common in any sort of divide-and-conquer application, because you are (ideally) cutting the work in half every time. If in each of the division or conquer steps, you are doing constant time work (or work that is not constant-time, but with time growing more slowly than &lt;code&gt;O(log n)&lt;/code&gt;), then your entire function is &lt;code&gt;O(log n)&lt;/code&gt;. It's fairly common to have each step require linear time on the input instead; this will amount to a total time complexity of &lt;code&gt;O(n log n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tiempos de ejecuci&amp;oacute;n &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; son muy comunes en cualquier tipo de aplicaci&amp;oacute;n de divide y vencer&amp;aacute;s, porque (idealmente) est&amp;aacute;s reduciendo el trabajo a la mitad cada vez. Si en cada uno de los pasos de divisi&amp;oacute;n o conquista, est&amp;aacute; haciendo un trabajo de tiempo constante (o un trabajo que no es de tiempo constante, pero con el tiempo creciendo m&amp;aacute;s lentamente que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), entonces toda su funci&amp;oacute;n es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Es bastante com&amp;uacute;n que cada paso requiera tiempo lineal en la entrada; esto equivaldr&amp;aacute; a una complejidad de tiempo total de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abb48e63c4d7db950366fd3b0dfe2e096b2f2c6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n^2)&lt;/code&gt; is obtained easily by nesting standard for loops.</source>
          <target state="translated">&lt;code&gt;O(n^2)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se obtiene f&amp;aacute;cilmente anidando el est&amp;aacute;ndar para bucles.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="664fced4730451fe1325328dbba584863529c241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log x to base b = y&lt;/code&gt; is the inverse of &lt;code&gt;b^y = x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;log x to base b = y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es el inverso de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;b^y = x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f8966595017a7ad226eea24cdb7b873f35223518" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disclaimer: The rope-logarithm example was grabbed from the excellent &lt;a href=&quot;https://www.amazon.co.uk/Mathematicians-Delight-Dover-Books-Mathematics/dp/0486462404&quot;&gt;Mathematician's Delight book by W.Sawyer&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Descargo de responsabilidad: El ejemplo de logaritmo de cuerda fue tomado del excelente &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.amazon.co.uk/Mathematicians-Delight-Dover-Books-Mathematics/dp/0486462404&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;libro Mathematician's Delight de W.Sawyer&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="93b23fdcd6527df1dfdb4c0912b0fc04e2169d8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;n/(2^steps)=1 &amp;lt;=&amp;gt; n=2^steps &amp;lt;=&amp;gt; lg(n)=steps&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;n/(2^steps)=1 &amp;lt;=&amp;gt; n=2^steps &amp;lt;=&amp;gt; lg(n)=steps&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cecb08b9e2796a2712fcae78ab1e27ab18af4c8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 10&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo 10&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="99059f5bd83e63ed1fa04489413c400ab49828dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 11&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo 11&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c484f87bf2e7520bc9c13f2425548040f8ca656" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 12&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo 12&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f792b9e20e7bd31191ec1ce96f2411274a40a430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 13&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo 13&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87a6cf7b68bf7e84ece7cceaa6050ec935e54006" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo 1:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc4f1ab0bbde20810982288d34df68bf23df808c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo 2:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3580ba8f5fa81d2b6842006c382e678600fdf0eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 3 - This acts like &quot;log_2&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo 3: esto act&amp;uacute;a como &quot;log_2&quot;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50c2f6a991daf9f2251bac09adf66a8ed3c4e3c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 4 - This acts like &quot;log_3&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo 4: esto act&amp;uacute;a como &quot;log_3&quot;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ade3ccd18a1516ffea265742c9c4262ac85f74a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 5 - This acts like &quot;log_1.02&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo 5: esto act&amp;uacute;a como &quot;log_1.02&quot;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c2e9bc08ef7fff3d18351a20b3844a561de3e6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 6&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo 6&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6042164656649616c8bd314b7001a62996f8c3e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 7&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo 7&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3813a73f44ab79ffff5fc062e96df9c77be57f07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 8&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo 8&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a43edf9ec98a0da521d4159e35c1204784fc256" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 9&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo 9&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc851456bbf3606cfd07da8d669ac31d4a0e4865" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1) (in the average case):&lt;/strong&gt; Given the page that a person's name is on and their name, find the phone number.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (1) (en el caso promedio):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; dada la p&amp;aacute;gina en la que se encuentra el nombre de una persona y su nombre, busque el n&amp;uacute;mero de tel&amp;eacute;fono.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="382f5486747667379a673e16fda00accedb3c67b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1) (in the worst case):&lt;/strong&gt; Given the page that a business's name is on and the business name, find the phone number.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (1) (en el peor de los casos):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; dada la p&amp;aacute;gina en la que se encuentra el nombre de una empresa y el nombre de la empresa, busque el n&amp;uacute;mero de tel&amp;eacute;fono.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db128fc404aa0da1b743b40724a8e30d03d62726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1) - Constant Time Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (1) - Ejemplos de tiempo constante:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dda1fa945adc6eb16b365bc6c67afd8d2bd88f75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log n):&lt;/strong&gt; Given a person's name, find the phone number by picking a random point about halfway through the part of the book you haven't searched yet, then checking to see whether the person's name is at that point. Then repeat the process about halfway through the part of the book where the person's name lies. (This is a binary search for a person's name.)</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; dado el nombre de una persona, encuentre el n&amp;uacute;mero de tel&amp;eacute;fono seleccionando un punto aleatorio a la mitad de la parte del libro que a&amp;uacute;n no ha buscado, y luego verifique si el nombre de la persona est&amp;aacute; en ese punto. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Luego repita el proceso a la mitad de la parte del libro donde se encuentra el nombre de la persona. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Esta es una b&amp;uacute;squeda binaria del nombre de una persona).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="367cb7ed6ccc0a378006813f8be3af12e274a6c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log(n)) - Logarithmic Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log (n)) - Ejemplos logar&amp;iacute;tmicos:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="543a66101c585e2dc5a2e8d042e2d985b1274be7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n &amp;middot; n!):&lt;/strong&gt; We're ready to load the phonebooks onto the shipping dock. Unfortunately, the robot that was supposed to load the books has gone haywire: it's putting the books onto the truck in a random order! Even worse, it loads all the books onto the truck, then checks to see if they're in the right order, and if not, it unloads them and starts over. (This is the dreaded &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Bogosort&quot;&gt;bogo sort&lt;/a&gt;&lt;/strong&gt;.)</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n &amp;middot; n!):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Estamos listos para cargar las gu&amp;iacute;as telef&amp;oacute;nicas en el muelle de env&amp;iacute;o. Desafortunadamente, el robot que se supon&amp;iacute;a que deb&amp;iacute;a cargar los libros se volvi&amp;oacute; loco: &amp;iexcl;est&amp;aacute; poniendo los libros en el cami&amp;oacute;n en un orden aleatorio! Peor a&amp;uacute;n, carga todos los libros en el cami&amp;oacute;n, luego verifica si est&amp;aacute;n en el orden correcto, y si no, los descarga y comienza de nuevo. (Este es el temido &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Bogosort&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tipo bogo&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1de65cc18d4f21d8e3a64ac738eb16027fb3867b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n log n):&lt;/strong&gt; There was a mix-up at the printer's office, and our phone book had all its pages inserted in a random order. Fix the ordering so that it's correct by looking at the first name on each page and then putting that page in the appropriate spot in a new, empty phone book.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n log n):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Hubo una confusi&amp;oacute;n en la oficina de la impresora, y nuestra gu&amp;iacute;a telef&amp;oacute;nica ten&amp;iacute;a todas sus p&amp;aacute;ginas insertadas en un orden aleatorio. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Arregle el orden para que sea correcto mirando el primer nombre en cada p&amp;aacute;gina y luego colocando esa p&amp;aacute;gina en el lugar apropiado en una nueva gu&amp;iacute;a telef&amp;oacute;nica vac&amp;iacute;a.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70127c240aa95e8b0ec96b3395f313034e9030aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n log n):&lt;/strong&gt; We want to personalize the phone book, so we're going to find each person or business's name in their designated copy, then circle their name in the book and write a short thank-you note for their patronage.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n log n):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Queremos personalizar la gu&amp;iacute;a telef&amp;oacute;nica, por lo que vamos a encontrar el nombre de cada persona o empresa en su copia designada, luego encerrar en un c&amp;iacute;rculo su nombre en el libro y escribir una breve nota de agradecimiento por su patrocinio .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b5606b21c0f2c96153c29e77b41f7fd85f0a0d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n) - Linear Time Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n) - Ejemplos de tiempo lineal:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f43ccb38b5bf2cd670379ba3a1965f42b4771fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n):&lt;/strong&gt; Find all people whose phone numbers contain the digit &quot;5&quot;.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; busca todas las personas cuyos n&amp;uacute;meros de tel&amp;eacute;fono contienen el d&amp;iacute;gito &quot;5&quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75709c253759b933376bae3df6fbc5aea1471527" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n):&lt;/strong&gt; Given a phone number, find the person or business with that number.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; dado un n&amp;uacute;mero de tel&amp;eacute;fono, encuentre a la persona o empresa con ese n&amp;uacute;mero.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db4237adb37b8829a7cc9004385308260a533b0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n*log(n)) - nlog(n) Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n * log (n)) - nlog (n) Ejemplos:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee37803266e306f1154c335eaba407e63fb9c491" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt; A mistake occurred at the office, and every entry in each of the phone books has an extra &quot;0&quot; at the end of the phone number. Take some white-out and remove each zero.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ): se&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; produjo un error en la oficina y cada entrada en cada una de las gu&amp;iacute;as telef&amp;oacute;nicas tiene un &quot;0&quot; adicional al final del n&amp;uacute;mero de tel&amp;eacute;fono. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Toma un poco de blanqueamiento y elimina cada cero.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3a7fa1df845249458feef5121758e550acff4f5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n&lt;sup&gt;n&lt;/sup&gt;):&lt;/strong&gt; You fix the robot so that it's loading things correctly. The next day, one of your co-workers plays a prank on you and wires the loading dock robot to the automated printing systems. Every time the robot goes to load an original book, the factory printer makes a duplicate run of all the phonebooks! Fortunately, the robot's bug-detection systems are sophisticated enough that the robot doesn't try printing even more copies when it encounters a duplicate book for loading, but it still has to load every original and duplicate book that's been printed.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ):&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; arreglas el robot para que cargue las cosas correctamente. Al d&amp;iacute;a siguiente, uno de tus compa&amp;ntilde;eros de trabajo te hace una broma y conecta el robot del muelle de carga a los sistemas de impresi&amp;oacute;n automatizados. &amp;iexcl;Cada vez que el robot va a cargar un libro original, la impresora de f&amp;aacute;brica realiza una ejecuci&amp;oacute;n duplicada de todas las gu&amp;iacute;as telef&amp;oacute;nicas! Afortunadamente, los sistemas de detecci&amp;oacute;n de errores del robot son lo suficientemente sofisticados como para que el robot no intente imprimir a&amp;uacute;n m&amp;aacute;s copias cuando encuentra un libro duplicado para cargar, pero todav&amp;iacute;a tiene que cargar cada libro original y duplicado que se haya impreso.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="baa3dcc6c7cb9768bae9c8737d449d37e482c784" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n^2) - n squared Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n ^ 2) - n al cuadrado Ejemplos:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c389c0632dce3cd1c5d250cbf01ee7bfb589c105" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n^3) - n cubed Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n ^ 3) - n cubos Ejemplos:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1d7ddb9ca9305db3b69febe087986d85bdca4704" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Overview&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Overview&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec82ec2afdaeef73e3e33a4ff9e63ef02488d0d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Code Examples Of Various Big O Categories:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ejemplos de c&amp;oacute;digo simple de varias categor&amp;iacute;as Big O:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="234aa035660484f0b043ef167e4eb0c4a6aff304" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what does O(log n) actually mean?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, &amp;iquest;qu&amp;eacute; significa realmente O (log n)?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e3286c2a6df794ce774454437c04c62779b831f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The logarithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El logaritmo&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72ef5689874ae61836de6559d76a3348730b20ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What about O(n log n)?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Qu&amp;eacute; pasa con O (n log n)?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8505b2060537b9b8a16641d236c3c9169433e63f" translate="yes" xml:space="preserve">
          <source>A common algorithm with O(log n) time complexity is Binary Search whose recursive relation is T(n/2) + O(1) i.e. at every subsequent level of the tree you divide problem into half and do constant amount of additional work.</source>
          <target state="translated">Un algoritmo común con complejidad de tiempo O(log n)es la Búsqueda Binaria cuya relación recursiva es T(n2)+O(1),es decir,en cada nivel subsiguiente del árbol se divide el problema en la mitad y se hace una cantidad constante de trabajo adicional.</target>
        </trans-unit>
        <trans-unit id="e64150835103105f0ea6e31dc144d0c9f306ad8a" translate="yes" xml:space="preserve">
          <source>Actually, if you have a list of n elements, and create a binary tree from that list (like in the divide and conquer algorithm), you will keep dividing by 2 until you reach lists of size 1 (the leaves).</source>
          <target state="translated">En realidad,si tienes una lista de n elementos,y creas un árbol binario a partir de esa lista (como en el algoritmo de dividir y conquistar),seguirás dividiendo por 2 hasta llegar a listas de tamaño 1 (las hojas).</target>
        </trans-unit>
        <trans-unit id="885a56ea0ae08ca84fb35233e67f695552695f1e" translate="yes" xml:space="preserve">
          <source>Algorithm 1 prints hello once and it doesn't depend on n, so it will always run in constant time, so it is &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El algoritmo 1 imprime hola una vez y no depende de n, por lo que siempre se ejecutar&amp;aacute; en tiempo constante, por lo que es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(1)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35be35b175c76af65d2827d2cf3dee1ef34934f1" translate="yes" xml:space="preserve">
          <source>Algorithm 2 prints hello 3 times, however it does not depend on an input size. Even as n grows, this algorithm will always only print hello 3 times. That being said 3, is a constant, so this algorithm is also &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El algoritmo 2 imprime hola 3 veces, sin embargo, no depende de un tama&amp;ntilde;o de entrada. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Incluso cuando n crece, este algoritmo siempre imprimir&amp;aacute; hola 3 veces. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dicho esto 3, es una constante, por lo que este algoritmo tambi&amp;eacute;n es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(1)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="566ae46ca13a24c5b54b75fd8f752947062eed04" translate="yes" xml:space="preserve">
          <source>Algorithm 3 demonstrates an algorithm that runs in log_2(n). Notice the post operation of the for loop multiples the current value of i by 2, so &lt;code&gt;i&lt;/code&gt; goes from 1 to 2 to 4 to 8 to 16 to 32 ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El algoritmo 3 demuestra un algoritmo que se ejecuta en log_2 (n). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Note la operaci&amp;oacute;n de post de la para m&amp;uacute;ltiplos de bucle el valor actual de i por 2, por lo que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;i&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; va de 1 a 2 a 4 a 8 para 16 a 32 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="219cad7306c85bd667c5cb1b64143ac505019683" translate="yes" xml:space="preserve">
          <source>Algorithm 4 demonstrates log_3. Notice &lt;code&gt;i&lt;/code&gt; goes from 1 to 3 to 9 to 27...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El algoritmo 4 demuestra log_3. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Noto &lt;/font&gt;&lt;/font&gt; &lt;code&gt;i&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; va de 1 a 3 para 9 al 27 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a8454e3e9eaed77a0c84e7bcde53bb78684adbf" translate="yes" xml:space="preserve">
          <source>Algorithm 5 is important, as it helps show that as long as the number is greater than 1 and the result is repeatedly multiplied against itself, that you are looking at a logarithmic algorithm.</source>
          <target state="translated">El algoritmo 5 es importante,ya que ayuda a mostrar que mientras el número sea mayor que 1 y el resultado se multiplique repetidamente contra sí mismo,se está viendo un algoritmo logarítmico.</target>
        </trans-unit>
        <trans-unit id="51aabda71f87b90773768c7a9973d25539b2adfd" translate="yes" xml:space="preserve">
          <source>Algorithm 9 is like algorithm 8, but each of the loops has allowed variations, which still result in the final result being &lt;code&gt;O(n*log(n))&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El algoritmo 9 es como el algoritmo 8, pero cada uno de los bucles ha permitido variaciones, que a&amp;uacute;n dan como resultado que el resultado final sea &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n*log(n))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17d79de1210f6f15a000af0169a5ef68b6ed4866" translate="yes" xml:space="preserve">
          <source>Algorithms (4th Edition)</source>
          <target state="translated">Algoritmos (4ª edición)</target>
        </trans-unit>
        <trans-unit id="546877fd41740873d1cfa8e4f36cf9b0df017323" translate="yes" xml:space="preserve">
          <source>Algorithms in the Divide and Conquer paradigm are of complexity O(logn). One example here, calculate your own power function,</source>
          <target state="translated">Los algoritmos del paradigma de Dividir y Conquistar son de complejidad O(logn).Un ejemplo aquí,calcula tu propia función de potencia,</target>
        </trans-unit>
        <trans-unit id="bc69b8d895811f71046889c39e0d995b5f6f8de0" translate="yes" xml:space="preserve">
          <source>Although n is somewhere between 512 and 1023, only 10 iterations take place. This is because the step in the loop grows exponentially and thus takes only 10 iterations to reach the termination.</source>
          <target state="translated">Aunque n se encuentra entre 512 y 1023,sólo se producen 10 iteraciones.Esto se debe a que el paso en el bucle crece exponencialmente y por lo tanto sólo se necesitan 10 iteraciones para llegar a la terminación.</target>
        </trans-unit>
        <trans-unit id="13fda95a4e29f31623e6b27919c9c2654912cdb6" translate="yes" xml:space="preserve">
          <source>Analyzing the running time of a program (example).</source>
          <target state="translated">Analizando el tiempo de ejecución de un programa (ejemplo).</target>
        </trans-unit>
        <trans-unit id="b430315d40268f6d421e3d42d2f41d05716445c7" translate="yes" xml:space="preserve">
          <source>Anatomy of a program&amp;rsquo;s statement execution frequencies.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Anatom&amp;iacute;a de las frecuencias de ejecuci&amp;oacute;n de declaraciones de un programa.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f024ce63ef78ef7b64b38e26fabafc1f314daaa6" translate="yes" xml:space="preserve">
          <source>And its not just search, whatever may be the work (increment, compare or any operation) its a function of input size.</source>
          <target state="translated">Y no es sólo búsqueda,cualquiera que sea el trabajo (incrementar,comparar o cualquier operación)es una función del tamaño de la entrada.</target>
        </trans-unit>
        <trans-unit id="3e0adb51e88db164baaa3fd268ad64b534eb5476" translate="yes" xml:space="preserve">
          <source>And so on.</source>
          <target state="translated">Y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="7a8d4b0af6eedcdbdf7182951523d1cc82a773a9" translate="yes" xml:space="preserve">
          <source>And that's how you get O(log n) which is the amount of work that needs to be done on the above tree to reach a solution.</source>
          <target state="translated">Y así es como se obtiene O(log n)que es la cantidad de trabajo que hay que hacer en el árbol anterior para llegar a una solución.</target>
        </trans-unit>
        <trans-unit id="430078eae25aa1035e9c5dded6c9d2dbbd85adf7" translate="yes" xml:space="preserve">
          <source>Another example is binary search, which has a running time of O(log&lt;sub&gt;2&lt;/sub&gt; n) because at every step you divide the search space by 2.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otro ejemplo es la b&amp;uacute;squeda binaria, que tiene un tiempo de ejecuci&amp;oacute;n de O (log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n) porque en cada paso divide el espacio de b&amp;uacute;squeda por 2.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ea8b371babfbf6cdabc48efdcabde7886a45b20" translate="yes" xml:space="preserve">
          <source>Ant it seems that this notation was mostly have taken from mathematics.</source>
          <target state="translated">Y parece que esta notación fue tomada en su mayoría de las matemáticas.</target>
        </trans-unit>
        <trans-unit id="db52f24fa20a9333b6b58676f942da718a9e8a80" translate="yes" xml:space="preserve">
          <source>Applying this to your binary tree question so you have a good application: if you double the number of nodes in a binary tree, the height only increases by 1 (an additive amount).  If you double it again, it still only increased by 1.  (Obviously I'm assuming it stays balanced and such).  That way, instead of doubling your work when the problem size is multiplied, you're only doing very slightly more work. That's why O(log n) algorithms are awesome.</source>
          <target state="translated">Aplicando esto a su pregunta sobre el árbol binario para tener una buena aplicación:si duplica el número de nodos en un árbol binario,la altura sólo aumenta en 1 (una cantidad aditiva).Si lo duplicas de nuevo,aún así sólo aumenta en 1.(Obviamente estoy asumiendo que se mantiene equilibrado y tal).De esta manera,en lugar de duplicar tu trabajo cuando se multiplica el tamaño del problema,sólo estás haciendo un poco más de trabajo.Por eso los algoritmos O(log n)son increíbles.</target>
        </trans-unit>
        <trans-unit id="32764ca168816d370c0095d83bb00526d97bc511" translate="yes" xml:space="preserve">
          <source>As I know from university the symbol was intoduced by German mathematician Landau (1877-1938)</source>
          <target state="translated">Como sé por la universidad,el símbolo fue introducido por el matemático alemán Landau (1877-1938)</target>
        </trans-unit>
        <trans-unit id="0c50b5084a8768bf3848fba400f3d6b5a12bde9e" translate="yes" xml:space="preserve">
          <source>As the input size increases the work done(here the execution time) increases.(Hence proportionality)</source>
          <target state="translated">A medida que el tamaño de la entrada aumenta el trabajo realizado (aquí el tiempo de ejecución)aumenta.(De ahí la proporcionalidad)</target>
        </trans-unit>
        <trans-unit id="965b30064e173b5100a19b6d6ea70cf86fc6ba94" translate="yes" xml:space="preserve">
          <source>Assume we had instead a dataset with 32 elements. Continue the drawing above to find that we will now need 5 comparisons to find what we are searching for, as the tree has only grown one level deeper when we multiplied the amount of data. As a result, the complexity of the algorithm can be described as a logarithmic order.</source>
          <target state="translated">Supongamos que en su lugar tuviéramos un conjunto de datos con 32 elementos.Continúa el dibujo anterior para encontrar que ahora necesitaremos 5 comparaciones para encontrar lo que estamos buscando,ya que el árbol sólo ha crecido un nivel más cuando multiplicamos la cantidad de datos.Como resultado,la complejidad del algoritmo puede describirse como un orden logarítmico.</target>
        </trans-unit>
        <trans-unit id="1500b9ad9d3e53ed6762cb42f394ab0fc94c747c" translate="yes" xml:space="preserve">
          <source>Asymptotic complexity is the behavior of execution time of an algorithm while the time complexity is the actual execution time. But some people use these terms interchangeably.</source>
          <target state="translated">La complejidad asintótica es el comportamiento del tiempo de ejecución de un algoritmo mientras que la complejidad temporal es el tiempo de ejecución real.Pero algunas personas usan estos términos indistintamente.</target>
        </trans-unit>
        <trans-unit id="b7364a52ea4e1ac22d7414be72af2283970927a4" translate="yes" xml:space="preserve">
          <source>At the first step, you divide by 2. You then have 2 lists (2^1), you divide each by 2, so you have 4 lists (2^2), you divide again, you have 8 lists (2^3)and so on until your list size is 1</source>
          <target state="translated">En el primer paso,divides por 2.Luego tienes 2 listas (2^1),divides cada una por 2,así que tienes 4 listas (2^2),vuelves a dividir,tienes 8 listas (2^3)y así sucesivamente hasta que el tamaño de la lista es 1.</target>
        </trans-unit>
        <trans-unit id="c089231c2cd527f03ef02173a14ef58e49378bb4" translate="yes" xml:space="preserve">
          <source>Because time complexity depends on various parameters viz.</source>
          <target state="translated">Porque la complejidad del tiempo depende de varios parámetros,a saber</target>
        </trans-unit>
        <trans-unit id="79385006bae7e35860b6fe3468ec15323eadbe8e" translate="yes" xml:space="preserve">
          <source>Binary search is an example with complexity &lt;code&gt;O(log n)&lt;/code&gt;. Let's say that the nodes in the bottom level of the tree in figure 1 represents items in some sorted collection. Binary search is a divide-and-conquer algorithm, and the drawing shows how we will need (at most) 4 comparisons to find the record we are searching for in this 16 item dataset.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La b&amp;uacute;squeda binaria es un ejemplo con complejidad &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Digamos que los nodos en el nivel inferior del &amp;aacute;rbol en la figura 1 representan elementos en alguna colecci&amp;oacute;n ordenada. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La b&amp;uacute;squeda binaria es un algoritmo de divide y vencer&amp;aacute;s, y el dibujo muestra c&amp;oacute;mo necesitaremos (como m&amp;aacute;ximo) 4 comparaciones para encontrar el registro que estamos buscando en este conjunto de datos de 16 elementos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be848c0e0760b865d37c7f1e1021bb006ee2006e" translate="yes" xml:space="preserve">
          <source>Binary tree is a case where a problem of size n is divided into sub-problem of size n/2 until we reach a problem of size 1:</source>
          <target state="translated">El árbol binario es un caso en el que un problema de tamaño n se divide en un sub-problema de tamaño n2 hasta llegar a un problema de tamaño 1:</target>
        </trans-unit>
        <trans-unit id="3224959bcf8bf1a4e97341e888dd1713f7031354" translate="yes" xml:space="preserve">
          <source>But even in mathematical analysis sometimes this symbol was used in meaning &quot;C*g(n) &amp;gt; f(n) &amp;gt; 0&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero incluso en el an&amp;aacute;lisis matem&amp;aacute;tico a veces este s&amp;iacute;mbolo se us&amp;oacute; en el significado &quot;C * g (n)&amp;gt; f (n)&amp;gt; 0&quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="028ac440b61f595ee3489b7aaf85ae807e104671" translate="yes" xml:space="preserve">
          <source>But what exactly is &lt;em&gt;O(log n)&lt;/em&gt;?  For example, what does it mean to say that the height of a complete binary tree is &lt;em&gt;O(log n)&lt;/em&gt;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero, &amp;iquest;qu&amp;eacute; es exactamente &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo, &amp;iquest;qu&amp;eacute; significa decir que la altura de un &amp;aacute;rbol binario completo es &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8956095c5174d4083eb653119d3665061530f125" translate="yes" xml:space="preserve">
          <source>But what exactly is O(log n)</source>
          <target state="translated">Pero,¿qué es exactamente O(log n)</target>
        </trans-unit>
        <trans-unit id="0f241aead868e87d092bade7cdb4f3dc39360f7f" translate="yes" xml:space="preserve">
          <source>But what exactly is O(log n)? For example, what does it mean to say that the height of a &amp;gt;complete binary tree is O(log n)?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero, &amp;iquest;qu&amp;eacute; es exactamente O (log n)? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo, &amp;iquest;qu&amp;eacute; significa decir que la altura de un&amp;gt; &amp;aacute;rbol binario completo es O (log n)?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="edc1bfb371b8739da6f6a8bfe6b528f1e14b4316" translate="yes" xml:space="preserve">
          <source>Divide and conquer algorithms usually have a &lt;code&gt;logn&lt;/code&gt; component to the running time. This comes from the repeated halving of the input.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los algoritmos de divisi&amp;oacute;n y conquista generalmente tienen un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;componente &lt;/font&gt;&lt;/font&gt; &lt;code&gt;logn&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para el tiempo de ejecuci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto proviene de la reducci&amp;oacute;n a la mitad de la entrada.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="042a172d4487ee962ac155493b6704fe324ce14f" translate="yes" xml:space="preserve">
          <source>Edit: As noted, the log base doesn't matter, but when deriving the Big-O performance of an algorithm, the log factor will come from halving, hence why I think of it as base 2.</source>
          <target state="translated">Editar:Como se ha señalado,la base de registro no importa,pero al derivar el rendimiento Big-O de un algoritmo,el factor de registro vendrá de reducirse a la mitad,por lo que pienso en él como base 2.</target>
        </trans-unit>
        <trans-unit id="6b51ffb5caa85a59fa5b79d9a86cc93f753c1d72" translate="yes" xml:space="preserve">
          <source>Every time we write an algorithm or code we try to analyze its asymptotic complexity.
It is different from its &lt;b&gt;time complexity&lt;/b&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cada vez que escribimos un algoritmo o c&amp;oacute;digo intentamos analizar su complejidad asint&amp;oacute;tica. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es diferente de su &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;complejidad temporal&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a32654a9db30d8a5838e3722ec97067271f1ac0" translate="yes" xml:space="preserve">
          <source>First I recommend you to read following book;</source>
          <target state="translated">Primero le recomiendo que lea el siguiente libro;</target>
        </trans-unit>
        <trans-unit id="4389c042e3105fc444c640d496eb44c0535e3593" translate="yes" xml:space="preserve">
          <source>First, you'll want to have a general idea of Logarithm, which you can get from &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;https://en.wikipedia.org/wiki/Logarithm&lt;/a&gt; . Natural science use &lt;code&gt;e&lt;/code&gt; and the natural log. Engineering disciples will use log_10 (log base 10) and computer scientists will use log_2 (log base 2) a lot, since computers are binary based. Sometimes you'll see abbreviations of natural log as &lt;code&gt;ln()&lt;/code&gt;, engineers normally leave the _10 off and just use &lt;code&gt;log()&lt;/code&gt; and log_2 is abbreviated as &lt;code&gt;lg()&lt;/code&gt;. All of the types of logarithms grow in a similar fashion, that is why they share the same category of &lt;code&gt;log(n)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Primero, querr&amp;aacute; tener una idea general de Logarithm, que puede obtener de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://en.wikipedia.org/wiki/Logarithm&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El uso de la ciencia natural &lt;/font&gt;&lt;/font&gt; &lt;code&gt;e&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y el registro natural. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los disc&amp;iacute;pulos de ingenier&amp;iacute;a utilizar&amp;aacute;n log_10 (log base 10) y los inform&amp;aacute;ticos utilizar&amp;aacute;n log_2 (log base 2) mucho, ya que las computadoras est&amp;aacute;n basadas en binarios. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;A veces ver&amp;aacute; abreviaturas de log natural como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;ln()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , los ingenieros normalmente dejan el _10 apagado y solo usan &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y log_2 se abrevia como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;lg()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Todos los tipos de logaritmos crecen de manera similar, es por eso que comparten la misma categor&amp;iacute;a de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e17e10b891c653c285dea64d8f7a3373a1c19493" translate="yes" xml:space="preserve">
          <source>Following &lt;strong&gt;Big-O Complexity Chart&lt;/strong&gt; also taken from &lt;a href=&quot;http://bigocheatsheet.com/&quot;&gt;bigocheatsheet&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Siguiendo el &lt;/font&gt;&lt;a href=&quot;http://bigocheatsheet.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cuadro de &lt;/font&gt;&lt;/a&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;complejidad Big-O&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tambi&amp;eacute;n tomado de &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bigocheatsheet&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16d7a7b7bac663123d8b79b95559ac46d279282b" translate="yes" xml:space="preserve">
          <source>Following is an example of Linear Time Algorithm</source>
          <target state="translated">A continuación se muestra un ejemplo de Algoritmo de Tiempo Lineal</target>
        </trans-unit>
        <trans-unit id="1fef1582a836eacedbb1ab2d7e10888873cb5181" translate="yes" xml:space="preserve">
          <source>For example, the following function is &lt;em&gt;O(n)&lt;/em&gt; because the algorithm grows in proportion to its input &lt;em&gt;n&lt;/em&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo, la siguiente funci&amp;oacute;n es &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; porque el algoritmo crece en proporci&amp;oacute;n a su entrada &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4caaa120df8c8c3e1948ef5644142dc7327e7965" translate="yes" xml:space="preserve">
          <source>For the below examples, we're now at the printer's office. Phone books are waiting to be mailed to each resident or business, and there's a sticker on each phone book identifying where it should be mailed to. Every person or business gets one phone book.</source>
          <target state="translated">Para los siguientes ejemplos,estamos ahora en la oficina de la imprenta.Las guías telefónicas están esperando ser enviadas a cada residente o negocio,y hay una pegatina en cada guía telefónica identificando a dónde debe ser enviada.Cada persona o negocio recibe una guía telefónica.</target>
        </trans-unit>
        <trans-unit id="008f849741e4c42a77d0d3e85df29402d2062285" translate="yes" xml:space="preserve">
          <source>For the tree example, you can easily see that stepping down a level of nodes cuts down an exponential number of elements as you continue traversing. The popular example of looking through a name-sorted phone book is essentially equivalent to traversing down a binary search tree (middle page is the root element, and you can deduce at each step whether to go left or right).</source>
          <target state="translated">Para el ejemplo del árbol,se puede ver fácilmente que al bajar un nivel de nodos se reduce un número exponencial de elementos a medida que se continúa atravesando.El ejemplo popular de buscar en una guía telefónica clasificada por nombres equivale esencialmente a recorrer un árbol de búsqueda binaria (la página central es el elemento raíz,y en cada paso se puede deducir si se va a la izquierda o a la derecha).</target>
        </trans-unit>
        <trans-unit id="f8cbba489ca545bed31ce5284b0f861e16a08da2" translate="yes" xml:space="preserve">
          <source>Given n input elements, to search an element in the array you need &lt;b&gt;at most 'n' comparisons&lt;/b&gt;. In other words, no matter what programming language you use, what coding style you prefer, on what system you execute it. In the worst case scenario it requires only n comparisons.The execution time is linearly proportional to the input size.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dados n elementos de entrada, para buscar un elemento en la matriz que necesita &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a lo sumo 'n' comparaciones&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En otras palabras, no importa qu&amp;eacute; lenguaje de programaci&amp;oacute;n use, qu&amp;eacute; estilo de codificaci&amp;oacute;n prefiera, en qu&amp;eacute; sistema lo ejecute. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En el peor de los casos, solo requiere n comparaciones. El tiempo de ejecuci&amp;oacute;n es linealmente proporcional al tama&amp;ntilde;o de entrada.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b7e083bb0f5b4f68b701df168e90a1fcd7902c02" translate="yes" xml:space="preserve">
          <source>Here are the running times of some operations we might perform on the phone book, from fastest to slowest:</source>
          <target state="translated">Aquí están los tiempos de ejecución de algunas operaciones que podríamos realizar en la guía telefónica,de las más rápidas a las más lentas:</target>
        </trans-unit>
        <trans-unit id="a642dd551ca2983c44ce398efcbea81aaf769af0" translate="yes" xml:space="preserve">
          <source>Here is some functions and their expected complexities. Numbers are indicating &lt;strong&gt;statement execution frequencies&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; hay algunas funciones y sus complejidades esperadas. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los n&amp;uacute;meros indican &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;frecuencias de ejecuci&amp;oacute;n de sentencias&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4544d6dc56eede04340e7b413a78c264800e6ff9" translate="yes" xml:space="preserve">
          <source>I am learning about Big O Notation running times and amortized times.  I understand the notion of &lt;em&gt;O(n)&lt;/em&gt; linear time, meaning that the size of the input affects the growth of the algorithm proportionally...and the same goes for, for example, quadratic time &lt;em&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/em&gt; etc..even algorithms, such as permutation generators, with &lt;em&gt;O(n!)&lt;/em&gt; times, that grow by factorials.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Estoy aprendiendo sobre los tiempos de ejecuci&amp;oacute;n de Big O Notation y los tiempos amortizados. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entiendo la noci&amp;oacute;n de &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tiempo lineal &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , lo que significa que el tama&amp;ntilde;o de la entrada afecta el crecimiento del algoritmo proporcionalmente ... y lo mismo ocurre, por ejemplo, con el tiempo cuadr&amp;aacute;tico &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ),&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; etc. incluso algoritmos , como los generadores de permutaci&amp;oacute;n, con &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n!)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; veces, que crecen por factoriales.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1514ac946545245f0cd6c0c469469d9924c92dc8" translate="yes" xml:space="preserve">
          <source>I can add something interesting, that I read in book by Kormen and etc. a long time ago. Now, imagine a problem, where we have to find a solution in a problem space. This problem space should be finite.</source>
          <target state="translated">Puedo añadir algo interesante,que leí en un libro de Kormen y etc.hace mucho tiempo.Ahora,imagina un problema,donde tenemos que encontrar una solución en un espacio problemático.Este espacio problemático debería ser finito.</target>
        </trans-unit>
        <trans-unit id="77898565c07238eac54505aaa70fda9acd97105d" translate="yes" xml:space="preserve">
          <source>I can give an example for a for loop and maybe once grasped the concept maybe it will be simpler to understand in different contexts.</source>
          <target state="translated">Puedo dar un ejemplo para un bucle de for y tal vez una vez comprendido el concepto sea más sencillo de entender en diferentes contextos.</target>
        </trans-unit>
        <trans-unit id="f46c74600710cca3491ccc2d55014c941985acd4" translate="yes" xml:space="preserve">
          <source>I cannot understand how to identify a function with a log time.</source>
          <target state="translated">No puedo entender cómo identificar una función con un tiempo de registro.</target>
        </trans-unit>
        <trans-unit id="b120641fbd4e22f22f1a41d9c1460d708b5abf16" translate="yes" xml:space="preserve">
          <source>I cannot understand how to identify a function with a logarithmic
  time.</source>
          <target state="translated">No puedo entender cómo identificar una función con un tiempo logarítmico.</target>
        </trans-unit>
        <trans-unit id="2fc60cfd1e6ecec87ecd174464fd863785193468" translate="yes" xml:space="preserve">
          <source>I do know (maybe not in great detail) what Logarithm is, in the sense that:  log&lt;sub&gt;10&lt;/sub&gt; 100 = 2, but I cannot understand how to identify a function with a logarithmic time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;S&amp;eacute; (tal vez no con gran detalle) qu&amp;eacute; es el logaritmo, en el sentido de que: log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 100 = 2, pero no puedo entender c&amp;oacute;mo identificar una funci&amp;oacute;n con un tiempo logar&amp;iacute;tmico.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c4c380d7b586ba548b763e759bdb6e8a0e7d641" translate="yes" xml:space="preserve">
          <source>I should point out, that we are talking here about a relative fraction limit, not the absolute one. The binary search is a classical example. At each step we throw away 1/2 of the problem space. But binary search is not the only such example. Suppose, you proved somehow, that at each step you throw away at least 1/128 of problem space. That means, your program is still running at O(logN) time, although significantly slower than the binary search. This is a very good hint in analyzing of recursive algorithms. It often can be proved that at each step the recursion will not use several variants, and this leads to the cutoff of some fraction in problem space.</source>
          <target state="translated">Debo señalar que estamos hablando de un límite de fracción relativa,no de absoluta.La búsqueda binaria es un ejemplo clásico.En cada paso tiramos 12 del espacio del problema.Pero la búsqueda binaria no es el único ejemplo.Supongamos que,de alguna manera,probaste que a cada paso tiras al menos 1128 del espacio del problema.Eso significa que tu programa sigue funcionando en el tiempo O(logN),aunque significativamente más lento que la búsqueda binaria.Esta es una muy buena pista en el análisis de los algoritmos recursivos.A menudo se puede probar que en cada paso la recursividad no usará varias variantes,y esto lleva al corte de alguna fracción en el espacio de problemas.</target>
        </trans-unit>
        <trans-unit id="5881b589c8d34329db8c8aaf3583f04e0a95d59a" translate="yes" xml:space="preserve">
          <source>I would rephrase this as 'height of a complete binary tree is log n'.  Figuring the height of a complete binary tree would be O(log n), if you were traversing down step by step.</source>
          <target state="translated">Yo diría que &quot;la altura de un árbol binario completo es el tronco n&quot;.La altura de un árbol binario completo sería O(log n),si se recorre paso a paso hacia abajo.</target>
        </trans-unit>
        <trans-unit id="34a2c69faab5e22f0819e07416c899e0ab5ea227" translate="yes" xml:space="preserve">
          <source>If an operation makes a series of constant time decisions each of which halves (reduces by a factor of 3, 4, 5..) the size of the input to be considered, the whole will take time proportional to log base 2 (base 3, base 4, base 5...) of the size N of the input, rather than being O(N).</source>
          <target state="translated">Si una operación toma una serie de decisiones en tiempo constante,cada una de las cuales reduce por un factor de 3,4,5...el tamaño de la entrada a considerar,el conjunto tomará un tiempo proporcional a la base logarítmica 2 (base 3,base 4,base 5...)del tamaño N de la entrada,en lugar de ser O(N).</target>
        </trans-unit>
        <trans-unit id="29c301205bbde0676fa60de7fb664c0272520a41" translate="yes" xml:space="preserve">
          <source>If an operation performs constant time work on each digit or bit of an input, the whole operation will take time proportional to the number of digits or bits in the input, not the magnitude of the input; thus, O(log N) rather than O(N).</source>
          <target state="translated">Si una operación realiza un trabajo de tiempo constante en cada dígito o bit de una entrada,toda la operación tomará un tiempo proporcional al número de dígitos o bits de la entrada,no a la magnitud de la misma;así,O(log N)en lugar de O(N).</target>
        </trans-unit>
        <trans-unit id="40f1a35a514953f64f37c0530c0551a81f2c1d8c" translate="yes" xml:space="preserve">
          <source>If you are looking for a intuition based answer I would like to put up two interpretations for you.</source>
          <target state="translated">Si busca una respuesta basada en la intuición me gustaría poner dos interpretaciones para usted.</target>
        </trans-unit>
        <trans-unit id="e727fd9b51a54744bd70b04f39c112e181c73e04" translate="yes" xml:space="preserve">
          <source>If you had a function that takes:</source>
          <target state="translated">Si tuvieras una función que tomara:</target>
        </trans-unit>
        <trans-unit id="cae2fdb17e96f6926d298666e40f5aed0ba43750" translate="yes" xml:space="preserve">
          <source>If you have an M-ary tree of depth d and size n, then:</source>
          <target state="translated">Si tienes un árbol M-ary de profundidad d y tamaño n,entonces:</target>
        </trans-unit>
        <trans-unit id="1d95e53c64e645e837222469b9cab7b8c1b9b2cb" translate="yes" xml:space="preserve">
          <source>If you increase the problem size by a multiplicative amount (i.e. multiply its size by 10), the work is only increased by an additive amount.</source>
          <target state="translated">Si se aumenta el tamaño del problema por una cantidad multiplicadora (es decir,se multiplica su tamaño por 10),el trabajo sólo se aumenta por una cantidad aditiva.</target>
        </trans-unit>
        <trans-unit id="8e7f99e5aec28c3c3af14e4b086ab56f08a3ece3" translate="yes" xml:space="preserve">
          <source>If you plot a logarithmic function on a graphical calculator or something similar, you'll see that it rises really slowly -- even more slowly than a linear function.</source>
          <target state="translated">Si graficas una función logarítmica en una calculadora gráfica o algo similar,verás que se eleva muy lentamente,incluso más lentamente que una función lineal.</target>
        </trans-unit>
        <trans-unit id="b135e7e3c1db73615122392851be7982fb0590b8" translate="yes" xml:space="preserve">
          <source>Imagine a very high hill with a very broad base as well. To reach the top of the hill there are two ways: one is a dedicated pathway going spirally around the hill reaching at the top, the other: small terrace like carvings cut out to provide a staircase. Now if the first way is reaching in linear time O(n), the second one is O(log n).</source>
          <target state="translated">Imagina una colina muy alta con una base muy amplia también.Para llegar a la cima de la colina hay dos caminos:uno es un sendero dedicado que va en espiral alrededor de la colina y llega a la cima,el otro:una pequeña terraza como tallas recortadas para proporcionar una escalera.Ahora bien,si el primer camino llega en tiempo lineal O(n),el segundo es O(log n).</target>
        </trans-unit>
        <trans-unit id="5e33e04b1dee3afdd640617efc039e44bde6caae" translate="yes" xml:space="preserve">
          <source>Imagine an algorithm, which accepts an integer, &lt;code&gt;n&lt;/code&gt; as input and completes in time proportional to &lt;code&gt;n&lt;/code&gt; then it is O(n) or theta(n) but if it runs in time proportion to the &lt;code&gt;number of digits or the number of bits in the binary representation on number&lt;/code&gt; then the algorithm runs in O(log n) or theta(log n) time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Imagine un algoritmo, que acepta un n&amp;uacute;mero entero, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como entrada y se completa en tiempo proporcional a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; entonces es O (n) o theta (n) pero si se ejecuta en tiempo proporcional al &lt;/font&gt;&lt;/font&gt; &lt;code&gt;number of digits or the number of bits in the binary representation on number&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; luego el algoritmo se ejecuta en tiempo O (log n) o theta (log n).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6d589872ee5e41297713f59c099e086e3b4052ff" translate="yes" xml:space="preserve">
          <source>Imagine we have a rope and we have tied it to a horse. If the rope is directly tied to the horse, the force the horse would need to pull away (say, from a man) is directly 1.</source>
          <target state="translated">Imagina que tenemos una cuerda y la hemos atado a un caballo.Si la cuerda está atada directamente al caballo,la fuerza que el caballo necesitaría para alejarse (digamos,de un hombre)es directamente 1.</target>
        </trans-unit>
        <trans-unit id="6378d42546aa9afc7483f28bf7aebdf73c49b4cd" translate="yes" xml:space="preserve">
          <source>In information technology it means that:</source>
          <target state="translated">En la tecnología de la información significa que:</target>
        </trans-unit>
        <trans-unit id="98c3336af693827be0b1652e42621a919c618013" translate="yes" xml:space="preserve">
          <source>In lay terms, it means that the equation for time may have some other components: e.g. it may have some constant startup time;  but these other components pale towards insignificance for large values of n, and the a*log(n) is the dominating term for large n.</source>
          <target state="translated">En términos simples,significa que la ecuación del tiempo puede tener otros componentes:por ejemplo,puede tener un tiempo de arranque constante;pero estos otros componentes palidecen ante la insignificancia para los grandes valores de n,y el a*log(n)es el término dominante para el gran n.</target>
        </trans-unit>
        <trans-unit id="58f7c710de382403051e79844d41a906eeb779a2" translate="yes" xml:space="preserve">
          <source>In mathematical analysis it means that:</source>
          <target state="translated">En el análisis matemático significa que:</target>
        </trans-unit>
        <trans-unit id="b3e3252b9357453f176dba5797bfb8ef7ee2628e" translate="yes" xml:space="preserve">
          <source>In our example above, our 'growth rate' is &lt;strong&gt;O(log n)&lt;/strong&gt;. For every additional loop, the force our rope can handle is 10 times more:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En nuestro ejemplo anterior, nuestra 'tasa de crecimiento' es &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por cada lazo adicional, la fuerza que puede manejar nuestra cuerda es 10 veces m&amp;aacute;s:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f65581e910638647521ce0d5776783cc36b7118" translate="yes" xml:space="preserve">
          <source>In the case of binary search, every iteration you throw away half of the input. It should be noted that in Big-O notation, log is log base 2.</source>
          <target state="translated">En el caso de la búsqueda binaria,en cada iteración se tira la mitad de la entrada.Hay que tener en cuenta que en la notación Big-O,la bitácora es la base de bitácora 2.</target>
        </trans-unit>
        <trans-unit id="fb6b918ab69d9248208647f0c2b72d19f69ad0b5" translate="yes" xml:space="preserve">
          <source>In this article there is a quote:
&lt;a href=&quot;http://www.phil.uu.nl/datastructuren/09-10/knuth_big_omicron.pdf&quot;&gt;D.E. Knuth, &quot;BIG OMICRON AND BIG OMEGA AND BIG THETA&quot;, 1976&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En este art&amp;iacute;culo hay una cita: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.phil.uu.nl/datastructuren/09-10/knuth_big_omicron.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DE Knuth, &quot;BIG OMICRON Y BIG OMEGA Y BIG THETA&quot;, 1976&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8670c63b3667b4287608c526872dfc9205befd56" translate="yes" xml:space="preserve">
          <source>Instead we take input size as the parameter because whatever the code is, the input is same.
&lt;b&gt;So the execution time is a function of input size.&lt;/b&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En su lugar, tomamos el tama&amp;ntilde;o de entrada como par&amp;aacute;metro porque cualquiera que sea el c&amp;oacute;digo, la entrada es la misma. &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces el tiempo de ejecuci&amp;oacute;n es una funci&amp;oacute;n del tama&amp;ntilde;o de entrada.&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0dc1da4c3f8d12c166ff2cd6e4311d6053faa4f2" translate="yes" xml:space="preserve">
          <source>It is like saying that logarithm is the inverse of exponential.</source>
          <target state="translated">Es como decir que el logaritmo es lo inverso de lo exponencial.</target>
        </trans-unit>
        <trans-unit id="c4cf5d0abe643a3d91104db3051e74c625aac83a" translate="yes" xml:space="preserve">
          <source>It is the number of times you can cut a log of length n repeatedly into b equal parts before reaching a section of size 1.</source>
          <target state="translated">Es el número de veces que se puede cortar un tronco de longitud n repetidamente en b partes iguales antes de llegar a una sección de tamaño 1.</target>
        </trans-unit>
        <trans-unit id="70b54711198b76e6fa5a133bb42b9709471571ba" translate="yes" xml:space="preserve">
          <source>It simply means that the time needed for this task grows with log(n) (example : 2s for n = 10, 4s for n = 100, ...). Read the Wikipedia articles on &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;Binary Search Algorithm&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O Notation&lt;/a&gt; for more precisions.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Simplemente significa que el tiempo necesario para esta tarea aumenta con log (n) (ejemplo: 2s para n = 10, 4s para n = 100, ...). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lea los art&amp;iacute;culos de Wikipedia sobre &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algoritmo de b&amp;uacute;squeda binaria&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Big O Notation&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para obtener m&amp;aacute;s precisiones.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d446a1de595cefe01ba8d7b981f6598cef60e89a" translate="yes" xml:space="preserve">
          <source>Lastly very simple showcase there is shows how it is calculated;</source>
          <target state="translated">Por último,una muestra muy simple muestra cómo se calcula;</target>
        </trans-unit>
        <trans-unit id="5365cefd34a28e9f6f10283dbf2204e550bd9877" translate="yes" xml:space="preserve">
          <source>Like algorithm 10, but with some variations.</source>
          <target state="translated">Como el algoritmo 10,pero con algunas variaciones.</target>
        </trans-unit>
        <trans-unit id="daf9ca7dff5ef97da12064b1422d4d6d308259b7" translate="yes" xml:space="preserve">
          <source>Like algorithm 12, but with some variations that still yield &lt;code&gt;O(n^3)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Como el algoritmo 12, pero con algunas variaciones que a&amp;uacute;n producen &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n^3)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38289bf08745c473c76541ef8dc4bf419c9505a0" translate="yes" xml:space="preserve">
          <source>Logarithm is essentially the inverse of exponentiation.  So, if each 'step' of your function is eliminating a &lt;strong&gt;factor&lt;/strong&gt; of elements from the original item set, that is a logarithmic time algorithm.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El logaritmo es esencialmente el inverso de la exponenciaci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, si cada 'paso' de su funci&amp;oacute;n est&amp;aacute; eliminando un &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;factor&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de elementos del conjunto de elementos original, ese es un algoritmo de tiempo logar&amp;iacute;tmico.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c37c28e3db4ab56ed0c7f37046862788fd45f644" translate="yes" xml:space="preserve">
          <source>Logarithmic running time (&lt;code&gt;O(log n)&lt;/code&gt;) essentially means that the running time grows in proportion to the &lt;em&gt;logarithm&lt;/em&gt; of the input size - as an example, if 10 items takes at most some amount of time &lt;code&gt;x&lt;/code&gt;, and 100 items takes at most, say, &lt;code&gt;2x&lt;/code&gt;, and 10,000 items takes at most &lt;code&gt;4x&lt;/code&gt;, then it's looking like an &lt;code&gt;O(log n)&lt;/code&gt; time complexity.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El tiempo de ejecuci&amp;oacute;n logar&amp;iacute;tmico ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) esencialmente significa que el tiempo de ejecuci&amp;oacute;n crece en proporci&amp;oacute;n al &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;logaritmo&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; del tama&amp;ntilde;o de entrada; por ejemplo, si 10 elementos toman como m&amp;aacute;ximo una cantidad de tiempo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , y 100 elementos toman como m&amp;aacute;ximo, digamos, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;2x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , y 10,000 art&amp;iacute;culos toman como m&amp;aacute;ximo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;4x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , luego se ve como una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;complejidad de tiempo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0da223ebb05c072d02e7d7d009cc82db75960461" translate="yes" xml:space="preserve">
          <source>Many good answers have already been posted to this question, but I believe we really are missing an important one - namely, the illustrated answer.</source>
          <target state="translated">Ya se han publicado muchas buenas respuestas a esta pregunta,pero creo que nos falta una importante,a saber,la respuesta ilustrada.</target>
        </trans-unit>
        <trans-unit id="0b6718155769a3e78ed892aa3ac3ab7d62302796" translate="yes" xml:space="preserve">
          <source>Note that if the equation were, for example ...</source>
          <target state="translated">Observe que si la ecuación fuera,por ejemplo...</target>
        </trans-unit>
        <trans-unit id="0aa386acc93467ee2abde73845cd59703ce2baff" translate="yes" xml:space="preserve">
          <source>Notice that I have bolded 'at most'. Big-O notation always refers to the worse case. If you're lucky, you could guess the number in one attempt and so the best case is O(1), but that's another story.</source>
          <target state="translated">Fíjese que he puesto el &quot;como mucho&quot; en negrita.La notación Big-O siempre se refiere al peor de los casos.Si tienes suerte,podrías adivinar el número en un intento y así el mejor caso es O(1),pero esa es otra historia.</target>
        </trans-unit>
        <trans-unit id="896e616be26c906871b376ff0bcf07906cf168d2" translate="yes" xml:space="preserve">
          <source>Now if the rope is looped once, the horse will need to pull 10 times harder. If the human decides to make it really difficult for the horse, he may loop the rope again round a pole, increasing it's strength by an additional 10 times. A third loop will again increase the strength by a further 10 times.</source>
          <target state="translated">Ahora,si la cuerda se enlaza una vez,el caballo tendrá que tirar 10 veces más fuerte.Si el humano decide hacerlo realmente difícil para el caballo,puede enlazar la cuerda de nuevo alrededor de un poste,aumentando su fuerza en 10 veces más.Un tercer lazo volverá a aumentar la fuerza 10 veces más.</target>
        </trans-unit>
        <trans-unit id="1d64633a7606b749454da054611ddab06ad82f5e" translate="yes" xml:space="preserve">
          <source>Now imagine the rope is looped round a pole. The horse to get away will now have to pull many times harder. The amount of times will depend on the roughness of the rope and the size of the pole, but let's assume it will multiply one's strength by 10 (when the rope makes a complete turn).</source>
          <target state="translated">Ahora imagina que la cuerda está enrollada alrededor de un poste.El caballo para escapar tendrá que tirar muchas veces más fuerte.La cantidad de veces dependerá de la rugosidad de la cuerda y del tamaño del poste,pero supongamos que multiplicará su fuerza por 10 (cuando la cuerda haga un giro completo).</target>
        </trans-unit>
        <trans-unit id="d4de53fc0c4c7ca626fe1b6e7ea8bfbf1e3b1a36" translate="yes" xml:space="preserve">
          <source>Now it took you 7 guesses to get this right. But what is the relationship here? What is the most amount of items that you can guess from each additional guess?</source>
          <target state="translated">Ahora te tomó 7 intentos para hacer esto bien.¿Pero cuál es la relación aquí? ¿Cuál es la mayor cantidad de artículos que puedes adivinar de cada suposición adicional?</target>
        </trans-unit>
        <trans-unit id="02fb936ea47e751f434197c3c1e70189f2a9e94f" translate="yes" xml:space="preserve">
          <source>Now let's imagine you are trying to guess a number between 1-100.</source>
          <target state="translated">Ahora imaginemos que estás tratando de adivinar un número entre el 1 y el 100.</target>
        </trans-unit>
        <trans-unit id="92c7d02b06664cf176d72b22469d6e2637331bf5" translate="yes" xml:space="preserve">
          <source>Now the example above did use base 10, but fortunately the base of the log is insignificant when we talk about big o notation.</source>
          <target state="translated">El ejemplo anterior usó la base 10,pero afortunadamente la base del registro es insignificante cuando hablamos de una gran anotación.</target>
        </trans-unit>
        <trans-unit id="d1132f0f0d5b4551a144f923806f22c8f231b52c" translate="yes" xml:space="preserve">
          <source>Now try to see it that way, if exponential grows very fast then logarithm grows (inversely) very slow.</source>
          <target state="translated">Ahora trata de verlo de esa manera,si lo exponencial crece muy rápido entonces el logaritmo crece (inversamente)muy lentamente.</target>
        </trans-unit>
        <trans-unit id="cf7bf0faa69c8d99b94cd18c064970e2c8eb7a8e" translate="yes" xml:space="preserve">
          <source>Now, if you can prove, that at every iteration of your algorithm you cut off a fraction of this space, that is no less than some limit, this means that your algorithm is running in O(logN) time.</source>
          <target state="translated">Ahora,si puedes probar que en cada iteración de tu algoritmo cortaste una fracción de este espacio,que no es menos que algún límite,esto significa que tu algoritmo se está ejecutando en tiempo O(logN).</target>
        </trans-unit>
        <trans-unit id="225912e442e23ad1ffb556abadc76e236a543d7e" translate="yes" xml:space="preserve">
          <source>O(log n) is a bit misleading, more precisely it's O(log&lt;sub&gt;2&lt;/sub&gt; n), i.e. (logarithm with base 2).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (log n) es un poco enga&amp;ntilde;oso, m&amp;aacute;s precisamente es O (log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n), es decir (logaritmo con base 2).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="741abfc15af347b4f12ce5826876662fcbfe5bae" translate="yes" xml:space="preserve">
          <source>Of course, a bigger phone book will still take you a longer time, but it won't grow as quickly as the proportional increase in the additional size.</source>
          <target state="translated">Por supuesto,una guía telefónica más grande todavía le llevará más tiempo,pero no crecerá tan rápido como el aumento proporcional del tamaño adicional.</target>
        </trans-unit>
        <trans-unit id="c91777dabbef341bced10eccfce89a68f07e4082" translate="yes" xml:space="preserve">
          <source>Ok let's try and fully understand what a logarithm actually is.</source>
          <target state="translated">Ok,tratemos de entender completamente lo que un logaritmo es en realidad.</target>
        </trans-unit>
        <trans-unit id="60081c10f46ab24f55cbcac1d8baa12b740223fb" translate="yes" xml:space="preserve">
          <source>On the basis of the issues discussed here, I propose that members of
  SIGACT, and editors of computer science and mathematics journals,
  adopt notations as defined above, unless &lt;strong&gt;a better alternative can be
  found reasonably soon&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sobre la base de los temas discutidos aqu&amp;iacute;, propongo que los miembros de SIGACT y los editores de revistas de inform&amp;aacute;tica y matem&amp;aacute;tica adopten las anotaciones como se defini&amp;oacute; anteriormente, a menos que &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;se pueda encontrar una alternativa mejor razonablemente pronto&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f1b4ad273ca861456f8e996a15667043d1cefab0" translate="yes" xml:space="preserve">
          <source>Or actually, it doesn't quite mean that; more likely it means something like &quot;&lt;code&gt;time&lt;/code&gt; divided by &lt;code&gt;a*log(n)&lt;/code&gt; tends towards &lt;code&gt;1&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O en realidad, no significa eso en absoluto; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lo m&amp;aacute;s probable es que signifique algo as&amp;iacute; como &quot;el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;time&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; dividido entre &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tiende a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="172a790a2a8831c6bd8b4653399b564aa7c99f4b" translate="yes" xml:space="preserve">
          <source>Others have given good diagram examples, such as the tree diagrams. I did not see any simple code examples. So in addition to my explanation, I'll provide some algorithms with simple print statements to illustrate the complexity of different algorithm categories.</source>
          <target state="translated">Otros han dado buenos ejemplos de diagramas,como los diagramas de árboles.No he visto ningún ejemplo de código simple.Así que además de mi explicación,proporcionaré algunos algoritmos con simples declaraciones de impresión para ilustrar la complejidad de las diferentes categorías de algoritmos.</target>
        </trans-unit>
        <trans-unit id="d226550a9f05c197e28559642c0c8048d4b533b4" translate="yes" xml:space="preserve">
          <source>Plotting &lt;code&gt;log(n)&lt;/code&gt; on a plain piece of paper, will result in a graph where the rise of the curve decelerates as &lt;code&gt;n&lt;/code&gt; increases:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Al trazar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en una hoja de papel normal, se obtendr&amp;aacute; un gr&amp;aacute;fico donde el aumento de la curva se desacelera a medida que &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; aumenta:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fa164feedc89846fdd3de1a98b22842deeff5b6f" translate="yes" xml:space="preserve">
          <source>Searching for 4 yields 3 hits: 6, 3 then 4. And log2 12 = 3, which is a good apporximate to how many hits where needed.</source>
          <target state="translated">La búsqueda de 4 da 3 resultados:6,3 y luego 4.Y log2 12=3,que es un buen aproximado de cuántos aciertos se necesitan.</target>
        </trans-unit>
        <trans-unit id="1348a8daed3b64aac9ec3379db2da56a0a9a0029" translate="yes" xml:space="preserve">
          <source>See as the input size increased the work done is increased and it is independent of any machine.
And if you try to find out the value of units of work 
It's actually dependent onto those above specified parameters.It will change according to the systems and all.</source>
          <target state="translated">Como el tamaño de la entrada aumentó,el trabajo realizado se incrementa y es independiente de cualquier máquina.Y si tratas de averiguar el valor de las unidades de trabajo,en realidad depende de los parámetros arriba especificados.Cambiará según los sistemas y todo.</target>
        </trans-unit>
        <trans-unit id="dab06999693f805ef1a862d7a609e81414475e38" translate="yes" xml:space="preserve">
          <source>Similarly, if there was a nested loop, the time would be O(n&lt;sup&gt;2&lt;/sup&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Del mismo modo, si hubiera un bucle anidado, el tiempo ser&amp;iacute;a O (n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a89c7cdf5037c4260a4641bbc5992b3ebeecf1f" translate="yes" xml:space="preserve">
          <source>Simply put: At each step of your algorithm you can cut the work in half. (Asymptotically equivalent to third, fourth, ...)</source>
          <target state="translated">En pocas palabras:En cada paso de tu algoritmo puedes reducir el trabajo a la mitad.(Asintóticamente equivalente a tercero,cuarto,...)</target>
        </trans-unit>
        <trans-unit id="401e8032f76cd53b593529b22a8cb008c7dd6f7c" translate="yes" xml:space="preserve">
          <source>So when you say any algorithm is O(log n)
it means the execution time is log times the input size n.</source>
          <target state="translated">Así que cuando dices que cualquier algoritmo es O(log n)significa que el tiempo de ejecución es log veces el tamaño de entrada n.</target>
        </trans-unit>
        <trans-unit id="3fa29b366a6312d23b4d2519423f5db29d71f7d5" translate="yes" xml:space="preserve">
          <source>That gives you the equation :</source>
          <target state="translated">Eso te da la ecuación:</target>
        </trans-unit>
        <trans-unit id="5291dbaca6641002cae33e549bcd7025de975858" translate="yes" xml:space="preserve">
          <source>That means that in the loop the step grows exponentially. E.g.</source>
          <target state="translated">Eso significa que en el bucle el paso crece exponencialmente.Por ejemplo.</target>
        </trans-unit>
        <trans-unit id="9216353681115945aaba6250fe5ae4d1014f5529" translate="yes" xml:space="preserve">
          <source>That's what bit O notation means: it means &quot;what is the order of dominant term for any sufficiently large n&quot;.</source>
          <target state="translated">Eso es lo que significa la notación del bit O:significa &quot;cuál es el orden del término dominante para cualquier n suficientemente grande&quot;.</target>
        </trans-unit>
        <trans-unit id="7c239bafbc2dce1d2ee370782accc2cae132308f" translate="yes" xml:space="preserve">
          <source>The above give several straight forward examples, and variations to help demonstrate what subtle changes can be introduced that really don't change the analysis. Hopefully it gives you enough insight.</source>
          <target state="translated">Lo anterior da varios ejemplos directos y variaciones para ayudar a demostrar qué cambios sutiles pueden introducirse que realmente no cambian el análisis.Esperemos que te dé suficiente perspicacia.</target>
        </trans-unit>
        <trans-unit id="fda0956265302daf9fe6bdf8cd1b73b62ae63530" translate="yes" xml:space="preserve">
          <source>The best way I've always had to mentally visualize an algorithm that runs in O(log n) is as follows:</source>
          <target state="translated">La mejor manera que siempre he tenido de visualizar mentalmente un algoritmo que se ejecuta en O(log n)es la siguiente:</target>
        </trans-unit>
        <trans-unit id="81f4a7349b2e61a08d286f542458555f1865b59a" translate="yes" xml:space="preserve">
          <source>The complete binary example is O(ln n) because the search looks like this:</source>
          <target state="translated">El ejemplo binario completo es O(ln n)porque la búsqueda tiene este aspecto:</target>
        </trans-unit>
        <trans-unit id="d7c3202604045a8f0ca1c569409156d740cf38fe" translate="yes" xml:space="preserve">
          <source>The complexity in O-notation of this program is O(log(n)). Let's try to loop through it by hand (n being somewhere between 512 and 1023 (excluding 1024):</source>
          <target state="translated">La complejidad en la anotación O de este programa es O(log(n)).Intentemos hacer un bucle a través de él a mano (n estando entre 512 y 1023 (excluyendo 1024):</target>
        </trans-unit>
        <trans-unit id="23fb0bc54f9a22ea3778e044e18fe0f74b651fc4" translate="yes" xml:space="preserve">
          <source>The difference between O(n) and O(log(n)) is huge, similar to the difference between O(n) and O(a^n) (a being a constant).</source>
          <target state="translated">La diferencia entre O(n)y O(log(n))es enorme,similar a la diferencia entre O(n)y O(a^n)(un ser constante).</target>
        </trans-unit>
        <trans-unit id="0077251502a2b3945f5070c00b578c932c22496e" translate="yes" xml:space="preserve">
          <source>The explanation below is using the case of a fully &lt;em&gt;balanced&lt;/em&gt; binary tree to help you understand how we get logarithmic time complexity.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La explicaci&amp;oacute;n a continuaci&amp;oacute;n utiliza el caso de un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;aacute;rbol binario &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;completamente &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;equilibrado&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para ayudarlo a comprender c&amp;oacute;mo obtenemos la complejidad del tiempo logar&amp;iacute;tmico.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="979a113826a0c1e025cb59a3bc5b4dbfe4e82d94" translate="yes" xml:space="preserve">
          <source>The following drawing depicts a binary tree. Notice how each level contains double the number of nodes compared to the level above (hence &lt;em&gt;binary&lt;/em&gt;):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El siguiente dibujo representa un &amp;aacute;rbol binario. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Observe c&amp;oacute;mo cada nivel contiene el doble del n&amp;uacute;mero de nodos en comparaci&amp;oacute;n con el nivel anterior (por lo tanto, &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;binario&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ):&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db2a24bbecedf8e012282630dd132fbb4ee8f292" translate="yes" xml:space="preserve">
          <source>The height of a balanced binary tree is O(log&lt;sub&gt;2&lt;/sub&gt; n), since every node has two (note the &quot;two&quot; as in log&lt;sub&gt;2&lt;/sub&gt; n) child nodes. So, a tree with n nodes has a height of log&lt;sub&gt;2&lt;/sub&gt; n.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La altura de un &amp;aacute;rbol binario equilibrado es O (log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n), ya que cada nodo tiene dos (tenga en cuenta los &quot;dos&quot; como en log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n) nodos secundarios. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, un &amp;aacute;rbol con n nodos tiene una altura de log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f9f0b9b225087a04ae96fd13b7c4892a8920821" translate="yes" xml:space="preserve">
          <source>The logarithm of x (to the base of a) is the reverse function of a^x.</source>
          <target state="translated">El logaritmo de x (a la base de a)es la función inversa de a^x.</target>
        </trans-unit>
        <trans-unit id="748b4da565ee01d0e285c7ce2ee8782d05768ee1" translate="yes" xml:space="preserve">
          <source>The logarithmic function is the inverse of the exponential function. Put another way, if your input grows exponentially (rather than linearly, as you would normally consider it), your function grows linearly.</source>
          <target state="translated">La función logarítmica es la inversa de la función exponencial.Dicho de otro modo,si su entrada crece exponencialmente (en lugar de linealmente,como normalmente se consideraría),su función crece linealmente.</target>
        </trans-unit>
        <trans-unit id="217245fbd9703d38af322b5f4c84cf925e99d9dc" translate="yes" xml:space="preserve">
          <source>The most common attributes of logarithmic running-time function are that:</source>
          <target state="translated">Los atributos más comunes de la función de tiempo de ejecución logarítmica son que:</target>
        </trans-unit>
        <trans-unit id="c6ff8c3cdb742922883fe572d4bd4535cbbcdabf" translate="yes" xml:space="preserve">
          <source>The running time complexity of binary search is an example of &lt;code&gt;O(log n)&lt;/code&gt;. This is because in binary search, you are always ignoring half of your input in each later step by dividing the array in half and only focusing on one half with each step. Each step is constant-time, because in binary search you only need to compare one element with your key in order to figure out what to do next irregardless of how big the array you are considering is at any point. So you do approximately log(n)/log(2) steps.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La complejidad del tiempo de ejecuci&amp;oacute;n de la b&amp;uacute;squeda binaria es un ejemplo de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Esto se debe a que en la b&amp;uacute;squeda binaria, siempre ignora la mitad de su entrada en cada paso posterior al dividir la matriz por la mitad y solo se enfoca en la mitad con cada paso. Cada paso es de tiempo constante, porque en la b&amp;uacute;squeda binaria solo necesita comparar un elemento con su clave para descubrir qu&amp;eacute; hacer a continuaci&amp;oacute;n, independientemente de cu&amp;aacute;n grande sea la matriz que est&amp;aacute; considerando en cualquier momento. Entonces, realiza aproximadamente los pasos log (n) / log (2).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="183ce247942b6cd9feda78873387089ea80dbff0" translate="yes" xml:space="preserve">
          <source>The running time complexity of merge sort is an example of &lt;code&gt;O(n log n)&lt;/code&gt;. This is because you are dividing the array in half with each step, resulting in a total of approximately log(n)/log(2) steps. However, in each step you need to perform merge operations on all elements (whether it's one merge operation on two sublists of n/2 elements, or two merge operations on four sublists of n/4 elements, is irrelevant because it adds to having to do this for n elements in each step). Thus, the total complexity is &lt;code&gt;O(n log n)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La complejidad del tiempo de ejecuci&amp;oacute;n del tipo de fusi&amp;oacute;n es un ejemplo de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto se debe a que est&amp;aacute; dividiendo la matriz por la mitad con cada paso, lo que resulta en un total de aproximadamente log (n) / log (2) pasos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin embargo, en cada paso debe realizar operaciones de fusi&amp;oacute;n en todos los elementos (ya sea una operaci&amp;oacute;n de fusi&amp;oacute;n en dos sublistas de n / 2 elementos, o dos operaciones de fusi&amp;oacute;n en cuatro sublistas de n / 4 elementos, es irrelevante porque se suma a tener que haz esto para n elementos en cada paso). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, la complejidad total es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="78d57ee8f42bffef4d8a9382ae1beeb55a66ed2c" translate="yes" xml:space="preserve">
          <source>Then it takes log&lt;sub&gt;2&lt;/sub&gt;(n) time. The &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt;, loosely speaking, means that the relationship only needs to be true for large n, and that constant factors and smaller terms can be ignored.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Luego toma el tiempo log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (n). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;notaci&amp;oacute;n Big O&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , en t&amp;eacute;rminos generales, significa que la relaci&amp;oacute;n solo necesita ser verdadera para n grande, y que pueden ignorarse factores constantes y t&amp;eacute;rminos m&amp;aacute;s peque&amp;ntilde;os.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3f3dd6c155a570957f69b762d0742cb653f9ff27" translate="yes" xml:space="preserve">
          <source>These 2 cases will  take O(log n) time</source>
          <target state="translated">Estos 2 casos tomarán O(log n)tiempo</target>
        </trans-unit>
        <trans-unit id="d0838d5f8965084f46ea02466a76e08056604c29" translate="yes" xml:space="preserve">
          <source>Think of this as a combination of &lt;code&gt;O(log(n))&lt;/code&gt; and &lt;code&gt;O(n)&lt;/code&gt;. The nesting of the for loops help us obtain the &lt;code&gt;O(n*log(n))&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Piense en esto como una combinaci&amp;oacute;n de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log(n))&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La anidaci&amp;oacute;n de los bucles for nos ayuda a obtener el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n*log(n))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c85c59919495767e1aa36e7cb8e1e1898fc42aff" translate="yes" xml:space="preserve">
          <source>This algorithm is simple, which prints hello n times.</source>
          <target state="translated">Este algoritmo es simple,que imprime hola n veces.</target>
        </trans-unit>
        <trans-unit id="275d42b938445e6155dc69cc23cb8dbbe4f2b94b" translate="yes" xml:space="preserve">
          <source>This algorithm shows a variation, where it will print hello n/2 times. n/2 = 1/2 * n. We ignore the 1/2 constant and see that this algorithm is O(n).</source>
          <target state="translated">Este algoritmo muestra una variación,donde imprimirá hola n2 veces.n2=12*n.Ignoramos la constante 12 y vemos que este algoritmo es O(n).</target>
        </trans-unit>
        <trans-unit id="ef3f528f492ad5a3b79a1dcbea99bd7d9e170e6c" translate="yes" xml:space="preserve">
          <source>This is like algorithm 10, but with 3 loops instead of 2.</source>
          <target state="translated">Esto es como el algoritmo 10,pero con 3 bucles en lugar de 2.</target>
        </trans-unit>
        <trans-unit id="4efa808ed1bb5af8e28061bc1c951efec7f558d1" translate="yes" xml:space="preserve">
          <source>This is why algorithms with a logarithmic time complexity are highly sought after: even for really big n (let's say n = 10^8, for example), they perform more than acceptably.</source>
          <target state="translated">Por eso los algoritmos con una complejidad de tiempo logarítmico son muy buscados:incluso para n realmente grande (digamos n=10^8,por ejemplo),tienen un rendimiento más que aceptable.</target>
        </trans-unit>
        <trans-unit id="fb1c5cd15bd283875742af5791fe8a2b4e1a3c61" translate="yes" xml:space="preserve">
          <source>This is why, for example, looking up people in a phone book is O(log n). You don't need to check &lt;em&gt;every&lt;/em&gt; person in the phone book to find the right one; instead, you can simply divide-and-conquer by looking based on where their name is alphabetically, and in every section you only need to explore a subset of each section before you eventually find someone's phone number.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta es la raz&amp;oacute;n por la cual, por ejemplo, buscar personas en una gu&amp;iacute;a telef&amp;oacute;nica es O (log n). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No necesita verificar a &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cada&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; persona en la gu&amp;iacute;a telef&amp;oacute;nica para encontrar la correcta; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;en su lugar, simplemente puede dividir y conquistar buscando seg&amp;uacute;n el nombre alfab&amp;eacute;tico, y en cada secci&amp;oacute;n solo necesita explorar un subconjunto de cada secci&amp;oacute;n antes de encontrar el n&amp;uacute;mero de tel&amp;eacute;fono de alguien.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16784fa25d2d74ba6e12621a053bcbb284da4694" translate="yes" xml:space="preserve">
          <source>Today is 2016, but we use it still today.</source>
          <target state="translated">Hoy es 2016,pero lo usamos todavía hoy.</target>
        </trans-unit>
        <trans-unit id="20d2171208dac823f70a0fc05abd05f1bb1d23c5" translate="yes" xml:space="preserve">
          <source>Using the graph, we can see that if we use a binary search to guess a number between 1-100 it will take us &lt;strong&gt;at most&lt;/strong&gt; 7 attempts. If we had 128 numbers, we could also guess the number in 7 attemps but 129 numbers will takes us &lt;strong&gt;at most&lt;/strong&gt; 8 attempts (in relations to logarithms, here we would need 7 guesses for a 128 value range, 10 guesses for a 1024 value range. 7 is the logarithm of 128, 10 is the logarithm of 1024 (base 2)).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Usando el gr&amp;aacute;fico, podemos ver que si usamos una b&amp;uacute;squeda binaria para adivinar un n&amp;uacute;mero entre 1-100, nos llevar&amp;aacute; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;como m&amp;aacute;ximo&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 7 intentos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si tuvi&amp;eacute;ramos 128 n&amp;uacute;meros, tambi&amp;eacute;n podr&amp;iacute;amos adivinar el n&amp;uacute;mero en 7 intentos, pero 129 n&amp;uacute;meros nos llevar&amp;aacute;n &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a lo sumo&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 8 intentos (en relaci&amp;oacute;n con los logaritmos, aqu&amp;iacute; necesitar&amp;iacute;amos 7 conjeturas para un rango de valores de 128, 10 conjeturas para un rango de valores de 1024 .7 es el logaritmo de 128, 10 es el logaritmo de 1024 (base 2)).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88eec511fbead7aa7ea065aa934d14f88f9f9b16" translate="yes" xml:space="preserve">
          <source>Walking a single path in the tree ~ O(d) = O(log n to base M)</source>
          <target state="translated">Caminando un solo camino en el árbol ~ O(d)=O(log n a base M)</target>
        </trans-unit>
        <trans-unit id="9b73a24be6f8b05f8c2985125f1eb8c601802768" translate="yes" xml:space="preserve">
          <source>We can expand the phone book example to compare other kinds of operations and &lt;em&gt;their&lt;/em&gt; running time. We will assume our phone book has &lt;em&gt;businesses&lt;/em&gt; (the &quot;Yellow Pages&quot;) which have unique names and &lt;em&gt;people&lt;/em&gt; (the &quot;White Pages&quot;) which may not have unique names. A phone number is assigned to at most one person or business. We will also assume that it takes constant time to flip to a specific page.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Podemos ampliar el ejemplo de la gu&amp;iacute;a telef&amp;oacute;nica para comparar otros tipos de operaciones y &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;su&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tiempo de ejecuci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Asumiremos que nuestra gu&amp;iacute;a telef&amp;oacute;nica tiene &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;negocios&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (las &quot;P&amp;aacute;ginas amarillas&quot;) que tienen nombres &amp;uacute;nicos y &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;personas&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (las &quot;P&amp;aacute;ginas blancas&quot;) que pueden no tener nombres &amp;uacute;nicos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Se asigna un n&amp;uacute;mero de tel&amp;eacute;fono como m&amp;aacute;ximo a una persona o empresa. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n asumiremos que lleva tiempo constante pasar a una p&amp;aacute;gina espec&amp;iacute;fica.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf5c329d95290b50a23a52c623196a7055ce3a59" translate="yes" xml:space="preserve">
          <source>We can see that for each loop, the value increases by 10. The number of turns required to get any number is called the logarithm of the number i.e. we need 3 posts to multiple your strength by 1000 times, 6 posts to multiply your strength by 1,000,000.</source>
          <target state="translated">Podemos ver que para cada bucle,el valor aumenta en 10.El número de turnos necesarios para obtener cualquier número se llama el logaritmo del número,es decir,necesitamos 3 postes para multiplicar su fuerza por 1000 veces,6 postes para multiplicar su fuerza por 1.000.000.</target>
        </trans-unit>
        <trans-unit id="215d074be1f0a767e1033061b3e486085ff1e2f8" translate="yes" xml:space="preserve">
          <source>We can see that for every guess our data set is shrinking. A good rule of thumb to identify if an algorithm has a logarithmtic time is
  to see if the data set shrinks by a certain order after each iteration</source>
          <target state="translated">Podemos ver que por cada suposición nuestro conjunto de datos se está reduciendo.Una buena regla para identificar si un algoritmo tiene un tiempo logarítmico es ver si el conjunto de datos se encoge en un cierto orden después de cada iteración.</target>
        </trans-unit>
        <trans-unit id="5c106784281fed81c6b6820aae1f0a6d9cbda0c5" translate="yes" xml:space="preserve">
          <source>What does O(log n) mean exactly</source>
          <target state="translated">¿Qué significa O(log n)exactamente</target>
        </trans-unit>
        <trans-unit id="93c5eee1c00a2205d8b906b832bc3151f6cc1c21" translate="yes" xml:space="preserve">
          <source>What does it mean to say that the height of a complete binary tree is O(log n)?</source>
          <target state="translated">¿Qué significa decir que la altura de un árbol binario completo es O(log n)?</target>
        </trans-unit>
        <trans-unit id="44807ad43b2ea914e6e9301d20f34f969353dcde" translate="yes" xml:space="preserve">
          <source>What it means precisely is &quot;as &lt;code&gt;n&lt;/code&gt; tends towards &lt;code&gt;infinity&lt;/code&gt;, the &lt;code&gt;time&lt;/code&gt; tends towards &lt;code&gt;a*log(n)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a constant scaling factor&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Lo que significa precisamente es &quot;como &lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tiende hacia el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;infinity&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;time&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tiende hacia &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; donde &lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es un factor de escala constante&quot;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d9d385e501f3c19dadeb1c4c3602e959a018409e" translate="yes" xml:space="preserve">
          <source>What's log&lt;sub&gt;b&lt;/sub&gt;(n)?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Qu&amp;eacute; es el registro &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;b&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (n)?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5ddb3aa95967c49aba70d9818c8d1d78fd583c6b" translate="yes" xml:space="preserve">
          <source>When you look at the code examples below, I recommend looking at O(1), then O(n), then O(n^2). After you are good with those, then look at the others. I've included clean examples as well as variations to demonstrate how subtle changes can still result in the same categorization.</source>
          <target state="translated">Cuando se miran los ejemplos de código que se muestran a continuación,recomiendo mirar O(1),luego O(n),y luego O(n^2).Después de que seas bueno con esos,entonces mira los otros.He incluido ejemplos limpios así como variaciones para demostrar cómo los cambios sutiles pueden aún resultar en la misma categorización.</target>
        </trans-unit>
        <trans-unit id="216423c2bafc59cfac2856f5284a31862176680e" translate="yes" xml:space="preserve">
          <source>You can easily identify if the algorithmic time is n log n. Look for an outer loop which iterates through a list (O(n)). Then look to see if there is an inner loop. If the inner loop is &lt;strong&gt;cutting/reducing&lt;/strong&gt; the data set on each iteration, that loop is (O(log n)), and so the overall algorithm is = &lt;strong&gt;O(n log n)&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede identificar f&amp;aacute;cilmente si el tiempo algor&amp;iacute;tmico es n log n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Busque un bucle externo que recorra en iteraci&amp;oacute;n una lista (O (n)). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Luego mira para ver si hay un bucle interno. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si el bucle interno est&amp;aacute; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cortando / reduciendo&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; el conjunto de datos en cada iteraci&amp;oacute;n, ese bucle es (O (log n)), por lo que el algoritmo general es = &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n log n)&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1d5328a5b30597cfdbb5f64814aee6e0397a6702" translate="yes" xml:space="preserve">
          <source>You can think of O(1), O(n), O(logn), etc as classes or categories of growth. Some categories will take more time to do than others. These categories help give us a way of ordering the algorithm performance. Some grown faster as the input n grows. The following table demonstrates said growth numerically. In the table below think of log(n) as the ceiling of log_2.</source>
          <target state="translated">Puedes pensar en O(1),O(n),O(logn),etc.como clases o categorías de crecimiento.Algunas categorías tomarán más tiempo que otras.Estas categorías ayudan a darnos una forma de ordenar el rendimiento del algoritmo.Algunas crecieron más rápido a medida que la entrada n crece.La siguiente tabla demuestra dicho crecimiento numéricamente.En la tabla siguiente piensa en log(n)como el techo de log_2.</target>
        </trans-unit>
        <trans-unit id="5c973715b1aaecc205af6056a3e8561731036021" translate="yes" xml:space="preserve">
          <source>You can think of O(log N) intuitively by saying the time is proportional to the number of digits in N.</source>
          <target state="translated">Puedes pensar en O(log N)intuitivamente diciendo que el tiempo es proporcional al número de dígitos en N.</target>
        </trans-unit>
        <trans-unit id="be063b2f6f59fd659351560845cdcbd0fce725b1" translate="yes" xml:space="preserve">
          <source>You will eventually come across a linearithmic time &lt;strong&gt;O(n log(n))&lt;/strong&gt; algorithm. The rule of thumb above applies again, but this time the logarithmic function has to run n times e.g. reducing the size of a list &lt;strong&gt;n times&lt;/strong&gt;, which occurs in algorithms like a mergesort.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Eventualmente se encontrar&amp;aacute; con un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;algoritmo &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;lineal de tiempo &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O (n log (n))&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La regla general anterior se aplica nuevamente, pero esta vez la funci&amp;oacute;n logar&amp;iacute;tmica tiene que ejecutarse n veces, por ejemplo, reduciendo el tama&amp;ntilde;o de una lista &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n veces&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , lo que ocurre en algoritmos como un mergesort.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e633fb53f72a241fd99a62bdb2e5fec14d3b99f0" translate="yes" xml:space="preserve">
          <source>from &lt;a href=&quot;http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/&quot;&gt;http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;de &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.geeksforgeeks.org/write-ac-program-to-calculate-powxn/&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f561a474d88946ed4c679c84b7d0fa00aa1daefa" translate="yes" xml:space="preserve">
          <source>only one will need to be chosen.</source>
          <target state="translated">sólo uno tendrá que ser elegido.</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="949b2d332a8532ba60eb0f9fdaaa648e4f5e90da" translate="yes" xml:space="preserve">
          <source>the choice of the next element on which to perform some action is one of several possibilities, and</source>
          <target state="translated">la elección del siguiente elemento sobre el cual realizar alguna acción es una de varias posibilidades,y</target>
        </trans-unit>
        <trans-unit id="810680965d466ce9e27c217b0e6ef1c0fc7ac62f" translate="yes" xml:space="preserve">
          <source>the elements on which the action is performed are digits of n</source>
          <target state="translated">los elementos sobre los que se realiza la acción son dígitos de n</target>
        </trans-unit>
        <trans-unit id="7c3255662cb9361125a26cad0c44f18afbdc1a9e" translate="yes" xml:space="preserve">
          <source>time(n) = a + b&lt;em&gt;log(n) + c&lt;/em&gt;n + d&lt;em&gt;n&lt;/em&gt;n</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tiempo (n) = a + b &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;log (n) + c&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n + d &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3121a265ec660806dc7016bca8595689a539a80d" translate="yes" xml:space="preserve">
          <source>traversing the whole tree ~ O(M^d) = O(n)</source>
          <target state="translated">atravesando todo el árbol ~ O(M^d)=O(n)</target>
        </trans-unit>
        <trans-unit id="601d76bcf9259b0951e3bbabeb31e37d99f1830f" translate="yes" xml:space="preserve">
          <source>​It is &lt;code&gt;O(log n)&lt;/code&gt; when we do divide and conquer type of algorithms e.g binary search. Another example is quick sort where each time we divide the array into two parts and each time it takes &lt;code&gt;O(N)&lt;/code&gt; time to find a pivot element. Hence it  &lt;code&gt;N O(log N)&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cuando dividimos y conquistamos tipos de algoritmos, por ejemplo, b&amp;uacute;squeda binaria. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otro ejemplo es la ordenaci&amp;oacute;n r&amp;aacute;pida en la que cada vez que dividimos la matriz en dos partes y cada vez que lleva tiempo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(N)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; encontrar un elemento pivote. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N O(log N)&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
