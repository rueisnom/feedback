<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/2307283">
    <body>
      <group id="2307283">
        <trans-unit id="62c23e7ef4be86040d6c792d74b8103bb503c43a" translate="yes" xml:space="preserve">
          <source>&quot;Tends towards&quot; has the usual mathematical meaning from 'analysis': for example, that &quot;if you pick &lt;em&gt;any&lt;/em&gt; arbitrarily small non-zero constant &lt;code&gt;k&lt;/code&gt;, then I can find a corresponding value &lt;code&gt;X&lt;/code&gt; such that &lt;code&gt;((time/(a*log(n))) - 1)&lt;/code&gt; is less than &lt;code&gt;k&lt;/code&gt; for all values of &lt;code&gt;n&lt;/code&gt; greater than &lt;code&gt;X&lt;/code&gt;.&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;趋向&amp;rdquo;具有从&amp;ldquo;分析&amp;rdquo;通常的数学含义：例如，&amp;ldquo;如果你选择&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任何&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任意小的非零常数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;k&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，然后我能找到一个对应的值&lt;/font&gt;&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，使得&lt;/font&gt;&lt;/font&gt; &lt;code&gt;((time/(a*log(n))) - 1)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于所有&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大于&lt;/font&gt; &lt;code&gt;X&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;都小于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;k&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="54e10c43522458d7384b566fb9db05322a518452" translate="yes" xml:space="preserve">
          <source>(you take the lg of each side, lg being the log base 2)</source>
          <target state="translated">(你取每边的lg,lg为对数基数2)</target>
        </trans-unit>
        <trans-unit id="44c99847d54ae4d00b74068530a05dd1fef0dc04" translate="yes" xml:space="preserve">
          <source>*Remember that big-O notation, &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation#Formal_definition&quot;&gt;by definition&lt;/a&gt;, constants don't matter. Also by the &lt;a href=&quot;http://en.wikipedia.org/wiki/Change_of_base_formula_for_logs#Changing_the_base&quot;&gt;change of base rule&lt;/a&gt; for logarithms, the only difference between logarithms of different bases is a constant factor.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;*请记住，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation#Formal_definition&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;按照定义&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大O表示法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并不重要。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同样，通过&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Change_of_base_formula_for_logs#Changing_the_base&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;改变&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的基本规则&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，不同底数的对数之间的唯一区别就是一个常数因子。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="48e253e5ab06e6976e35c9bdcea7e10b034cc3d4" translate="yes" xml:space="preserve">
          <source>... then this would be O(n squared) because, no matter what the values of the constants a, b, c, and non-zero d, the &lt;code&gt;d*n*n&lt;/code&gt; term would always dominate over the others for any sufficiently large value of n.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;...这将是O（n平方），因为无论常数a，b，c和非零d的值是什么，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;d*n*n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;项将始终在其他项上占据主导地位n大值&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a6b947aa846b5da9e63669d7e0ab43fa7149876" translate="yes" xml:space="preserve">
          <source>1. Physical System</source>
          <target state="translated">1.物理系统</target>
        </trans-unit>
        <trans-unit id="2da5718e4456d8946ed7cc039bbf65bc4baf31dc" translate="yes" xml:space="preserve">
          <source>2. Programming Language</source>
          <target state="translated">2.编程语言</target>
        </trans-unit>
        <trans-unit id="c047d0c08b0f62ebc42d10b65de4db18f9b150e9" translate="yes" xml:space="preserve">
          <source>3 is the logarithm of 1,000, and 6 is the logarithm of 1,000,000 (base 10).</source>
          <target state="translated">3是1000的对数,6是100万的对数(基数10)。</target>
        </trans-unit>
        <trans-unit id="864313c2df45c8ba64dccb8ec4055125eac5d1f5" translate="yes" xml:space="preserve">
          <source>3. coding Style</source>
          <target state="translated">3.编码风格</target>
        </trans-unit>
        <trans-unit id="f2e04afdb09df34f9f44473a7a1ccb50a406dc78" translate="yes" xml:space="preserve">
          <source>4. And much more ......</source>
          <target state="translated">4.还有更多.......</target>
        </trans-unit>
        <trans-unit id="d563ed5a666051353255960e6c2817c3c0755862" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;Linear Search&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;线性搜寻&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="b5fe40e00cd38153f7725ae75b9e9b6d20e78737" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;The actual execution time is not a good measure for analysis.
&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际执行时间不是分析的好方法。 &lt;/font&gt;&lt;/font&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7302ce438edbf9d107087c0d00e63e527a7611c5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log N)&lt;/code&gt; basically means time goes up linearly while the &lt;code&gt;n&lt;/code&gt; goes up exponentially. So if it takes &lt;code&gt;1&lt;/code&gt; second to compute &lt;code&gt;10&lt;/code&gt; elements, it will take &lt;code&gt;2&lt;/code&gt; seconds to compute &lt;code&gt;100&lt;/code&gt; elements, &lt;code&gt;3&lt;/code&gt; seconds to compute &lt;code&gt;1000&lt;/code&gt; elements, and so on.</source>
          <target state="translated">&lt;code&gt;O(log N)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基本上意味着时间线性增长，而&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;呈指数增长。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，如果它需要&lt;/font&gt;&lt;/font&gt; &lt;code&gt;1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;秒到计算&lt;/font&gt;&lt;/font&gt; &lt;code&gt;10&lt;/code&gt; 层&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的元件，这将需要&lt;/font&gt;&lt;/font&gt; &lt;code&gt;2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;秒，以计算&lt;/font&gt;&lt;/font&gt; &lt;code&gt;100&lt;/code&gt; 层&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的元件，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;3&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;秒，以计算&lt;/font&gt;&lt;/font&gt; &lt;code&gt;1000&lt;/code&gt; 个&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;元素，依此类推。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29521e79b284726f262e57f3d5e15142bdd210f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log n)&lt;/code&gt; refers to a function (or algorithm, or step in an algorithm) working in an amount of time proportional to the logarithm (usually base 2 in most cases, but not always, and in any event this is insignificant by big-O notation*) of the size of the input.</source>
          <target state="translated">&lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是指一个函数（或算法，或算法中的步骤），其工作时间与对数成比例（通常在大多数情况下以2为底数，但并非总是如此），无论如何这在很大程度上并不重要输入大小的-O标记*）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a33e6cf6849c1bfd0bc219a80b69e82c56092cd8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(log n)&lt;/code&gt; running times are very common in any sort of divide-and-conquer application, because you are (ideally) cutting the work in half every time. If in each of the division or conquer steps, you are doing constant time work (or work that is not constant-time, but with time growing more slowly than &lt;code&gt;O(log n)&lt;/code&gt;), then your entire function is &lt;code&gt;O(log n)&lt;/code&gt;. It's fairly common to have each step require linear time on the input instead; this will amount to a total time complexity of &lt;code&gt;O(n log n)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运行时间在任何类型的分治应用程序中都很常见，因为您（每次都）理想地将工作量减半。如果在每个分割或征服步骤中您都在进行恒定时间工作（或不是固定时间的工作，但是时间增长的速度比&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;慢&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），那么您的整个函数就是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。通常，每个步骤都需要线性输入，而不是线性输入。这将导致总的时间复杂度为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abb48e63c4d7db950366fd3b0dfe2e096b2f2c6c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;O(n^2)&lt;/code&gt; is obtained easily by nesting standard for loops.</source>
          <target state="translated">&lt;code&gt;O(n^2)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过嵌套循环标准可以轻松获得&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n ^ 2）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="664fced4730451fe1325328dbba584863529c241" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;log x to base b = y&lt;/code&gt; is the inverse of &lt;code&gt;b^y = x&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;log x to base b = y&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt; &lt;code&gt;b^y = x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的倒数&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f8966595017a7ad226eea24cdb7b873f35223518" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Disclaimer: The rope-logarithm example was grabbed from the excellent &lt;a href=&quot;https://www.amazon.co.uk/Mathematicians-Delight-Dover-Books-Mathematics/dp/0486462404&quot;&gt;Mathematician's Delight book by W.Sawyer&lt;/a&gt;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;免责声明：绳对数示例是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.amazon.co.uk/Mathematicians-Delight-Dover-Books-Mathematics/dp/0486462404&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;W.Sawyer&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从出色的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数学家的Delight书中获得的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="93b23fdcd6527df1dfdb4c0912b0fc04e2169d8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;n/(2^steps)=1 &amp;lt;=&amp;gt; n=2^steps &amp;lt;=&amp;gt; lg(n)=steps&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;n/(2^steps)=1 &amp;lt;=&amp;gt; n=2^steps &amp;lt;=&amp;gt; lg(n)=steps&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cecb08b9e2796a2712fcae78ab1e27ab18af4c8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 10&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法10&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="99059f5bd83e63ed1fa04489413c400ab49828dc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 11&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法11&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c484f87bf2e7520bc9c13f2425548040f8ca656" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 12&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法12&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f792b9e20e7bd31191ec1ce96f2411274a40a430" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 13&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法13&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="87a6cf7b68bf7e84ece7cceaa6050ec935e54006" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法1：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc4f1ab0bbde20810982288d34df68bf23df808c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法2：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3580ba8f5fa81d2b6842006c382e678600fdf0eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 3 - This acts like &quot;log_2&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法3-类似于&amp;ldquo; log_2&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="50c2f6a991daf9f2251bac09adf66a8ed3c4e3c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 4 - This acts like &quot;log_3&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法4-类似于&amp;ldquo; log_3&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ade3ccd18a1516ffea265742c9c4262ac85f74a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 5 - This acts like &quot;log_1.02&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法5-行为类似于&amp;ldquo; log_1.02&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7c2e9bc08ef7fff3d18351a20b3844a561de3e6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 6&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法6&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6042164656649616c8bd314b7001a62996f8c3e0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 7&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法7&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3813a73f44ab79ffff5fc062e96df9c77be57f07" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 8&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法8&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a43edf9ec98a0da521d4159e35c1204784fc256" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Algorithm 9&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法9&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc851456bbf3606cfd07da8d669ac31d4a0e4865" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1) (in the average case):&lt;/strong&gt; Given the page that a person's name is on and their name, find the phone number.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（1）（在&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通常&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;情况下）：&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给定一个人的名字所在的页面及其名字，找到电话号码。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="382f5486747667379a673e16fda00accedb3c67b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1) (in the worst case):&lt;/strong&gt; Given the page that a business's name is on and the business name, find the phone number.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（1）（在最坏的情况下）：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给定一家企业名称所在的页面和该企业名称，找到电话号码。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db128fc404aa0da1b743b40724a8e30d03d62726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(1) - Constant Time Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（1）-恒定时间示例：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dda1fa945adc6eb16b365bc6c67afd8d2bd88f75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log n):&lt;/strong&gt; Given a person's name, find the phone number by picking a random point about halfway through the part of the book you haven't searched yet, then checking to see whether the person's name is at that point. Then repeat the process about halfway through the part of the book where the person's name lies. (This is a binary search for a person's name.)</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（log n）：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给定一个人的名字，通过在您尚未搜索的书本的一半左右随机选择一个点来找到电话号码，然后检查该人的名字是否在该点上。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后在此人名字所在的部分的一半左右重复该过程。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（这是对人名的二进制搜索。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="367cb7ed6ccc0a378006813f8be3af12e274a6c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(log(n)) - Logarithmic Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（log（n））-对数示例：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="543a66101c585e2dc5a2e8d042e2d985b1274be7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n &amp;middot; n!):&lt;/strong&gt; We're ready to load the phonebooks onto the shipping dock. Unfortunately, the robot that was supposed to load the books has gone haywire: it's putting the books onto the truck in a random order! Even worse, it loads all the books onto the truck, then checks to see if they're in the right order, and if not, it unloads them and starts over. (This is the dreaded &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Bogosort&quot;&gt;bogo sort&lt;/a&gt;&lt;/strong&gt;.)</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n&amp;middot;n！）：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们已经准备好将电话簿加载到货运码头上。不幸的是，原本应该用来装书的机器人已经走到了尽头：它将书随机地放到卡车上！更糟糕的是，它将所有书籍装到卡车上，然后检查它们的顺序是否正确，如果不正确，则将其卸下并重新开始。 （这是可怕的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Bogosort&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bogo排序&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1de65cc18d4f21d8e3a64ac738eb16027fb3867b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n log n):&lt;/strong&gt; There was a mix-up at the printer's office, and our phone book had all its pages inserted in a random order. Fix the ordering so that it's correct by looking at the first name on each page and then putting that page in the appropriate spot in a new, empty phone book.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n log n）：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;打印机办公室里有些混乱，我们的电话簿中所有页面的插入顺序都是随机的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过查看每个页面上的名字，然后将该页面放在新的空电话簿中的适当位置，可以更正顺序，使其正确无误。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="70127c240aa95e8b0ec96b3395f313034e9030aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n log n):&lt;/strong&gt; We want to personalize the phone book, so we're going to find each person or business's name in their designated copy, then circle their name in the book and write a short thank-you note for their patronage.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n log n）：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们想对电话簿进行个性化设置，因此我们将在其指定的副本中查找每个人或公司的名称，然后在电话簿中圈出他们的姓名，并为他们的惠顾写一封简短的感谢信。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b5606b21c0f2c96153c29e77b41f7fd85f0a0d1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n) - Linear Time Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n）-线性时间示例：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f43ccb38b5bf2cd670379ba3a1965f42b4771fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n):&lt;/strong&gt; Find all people whose phone numbers contain the digit &quot;5&quot;.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n）：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;查找所有电话号码包含数字&amp;ldquo; 5&amp;rdquo;的人。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="75709c253759b933376bae3df6fbc5aea1471527" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n):&lt;/strong&gt; Given a phone number, find the person or business with that number.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n）：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给定一个电话号码，找到具有该号码的人或公司。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db4237adb37b8829a7cc9004385308260a533b0f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n*log(n)) - nlog(n) Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n * log（n））-nlog（n）示例：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee37803266e306f1154c335eaba407e63fb9c491" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n&lt;sup&gt;2&lt;/sup&gt;):&lt;/strong&gt; A mistake occurred at the office, and every entry in each of the phone books has an extra &quot;0&quot; at the end of the phone number. Take some white-out and remove each zero.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在办公室发生错误，并且每个电话簿中的每个条目在电话号码的末尾都有一个额外的&amp;ldquo; 0&amp;rdquo;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行一些涂白并删除每个零。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3a7fa1df845249458feef5121758e550acff4f5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n&lt;sup&gt;n&lt;/sup&gt;):&lt;/strong&gt; You fix the robot so that it's loading things correctly. The next day, one of your co-workers plays a prank on you and wires the loading dock robot to the automated printing systems. Every time the robot goes to load an original book, the factory printer makes a duplicate run of all the phonebooks! Fortunately, the robot's bug-detection systems are sophisticated enough that the robot doesn't try printing even more copies when it encounters a duplicate book for loading, but it still has to load every original and duplicate book that's been printed.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;修复机器人，使其正确装载东西。第二天，您的一个同事在对您进行恶作剧，并将装卸台机器人连接到自动打印系统。每次机器人去装入原书时，工厂打印机都会重复运行所有电话簿！幸运的是，该机器人的错误检测系统足够复杂，以至于当机器人遇到一本重复的书本进行加载时，它不会尝试打印更多的副本，但仍然必须加载每本印刷的原始书本和重复本。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="baa3dcc6c7cb9768bae9c8737d449d37e482c784" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n^2) - n squared Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n ^ 2）-n平方的例子：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c389c0632dce3cd1c5d250cbf01ee7bfb589c105" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;O(n^3) - n cubed Examples:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n ^ 3）-n立方示例：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1d7ddb9ca9305db3b69febe087986d85bdca4704" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Overview&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Overview&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec82ec2afdaeef73e3e33a4ff9e63ef02488d0d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Code Examples Of Various Big O Categories:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;各种Big O类别的简单代码示例：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="234aa035660484f0b043ef167e4eb0c4a6aff304" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what does O(log n) actually mean?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那么O（log n）到底是什么意思？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dcd8fc71e05cf69f2f4aedf034ba98a76d6ae8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Summary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e3286c2a6df794ce774454437c04c62779b831f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The logarithm&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对数&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72ef5689874ae61836de6559d76a3348730b20ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What about O(n log n)?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n log n）呢？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8505b2060537b9b8a16641d236c3c9169433e63f" translate="yes" xml:space="preserve">
          <source>A common algorithm with O(log n) time complexity is Binary Search whose recursive relation is T(n/2) + O(1) i.e. at every subsequent level of the tree you divide problem into half and do constant amount of additional work.</source>
          <target state="translated">一个常用的时间复杂度为O(log n)的算法是二进制搜索,其递归关系为T(n2)+O(1),也就是说,在树的每一层,你把问题分成两半,并做恒定的额外工作。</target>
        </trans-unit>
        <trans-unit id="e64150835103105f0ea6e31dc144d0c9f306ad8a" translate="yes" xml:space="preserve">
          <source>Actually, if you have a list of n elements, and create a binary tree from that list (like in the divide and conquer algorithm), you will keep dividing by 2 until you reach lists of size 1 (the leaves).</source>
          <target state="translated">实际上,如果你有一个由n个元素组成的列表,并从这个列表中创建一个二进制树(就像在除法和征服算法中一样),你将不断地除以2,直到你到达大小为1的列表(叶子)。</target>
        </trans-unit>
        <trans-unit id="885a56ea0ae08ca84fb35233e67f695552695f1e" translate="yes" xml:space="preserve">
          <source>Algorithm 1 prints hello once and it doesn't depend on n, so it will always run in constant time, so it is &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法1打印一次hello，它不依赖于n，因此它将始终在恒定时间内运行，因此为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(1)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="35be35b175c76af65d2827d2cf3dee1ef34934f1" translate="yes" xml:space="preserve">
          <source>Algorithm 2 prints hello 3 times, however it does not depend on an input size. Even as n grows, this algorithm will always only print hello 3 times. That being said 3, is a constant, so this algorithm is also &lt;code&gt;O(1)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法2会打印3次hello，但是它并不取决于输入的大小。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即使n增大，该算法也始终只会打印hello 3次。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;就是说3是一个常数，因此该算法也是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(1)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="566ae46ca13a24c5b54b75fd8f752947062eed04" translate="yes" xml:space="preserve">
          <source>Algorithm 3 demonstrates an algorithm that runs in log_2(n). Notice the post operation of the for loop multiples the current value of i by 2, so &lt;code&gt;i&lt;/code&gt; goes from 1 to 2 to 4 to 8 to 16 to 32 ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法3演示了在log_2（n）中运行的算法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意for循环的后操作将i的当前值乘以2，因此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;i&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从1变为2到4到8到16到32 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="219cad7306c85bd667c5cb1b64143ac505019683" translate="yes" xml:space="preserve">
          <source>Algorithm 4 demonstrates log_3. Notice &lt;code&gt;i&lt;/code&gt; goes from 1 to 3 to 9 to 27...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法4演示了log_3。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意&lt;/font&gt;&lt;/font&gt; &lt;code&gt;i&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从1到3到9到27 ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a8454e3e9eaed77a0c84e7bcde53bb78684adbf" translate="yes" xml:space="preserve">
          <source>Algorithm 5 is important, as it helps show that as long as the number is greater than 1 and the result is repeatedly multiplied against itself, that you are looking at a logarithmic algorithm.</source>
          <target state="translated">算法5是很重要的,因为它有助于说明只要数大于1,并且结果与自身反复相乘,就说明你看的是对数算法。</target>
        </trans-unit>
        <trans-unit id="51aabda71f87b90773768c7a9973d25539b2adfd" translate="yes" xml:space="preserve">
          <source>Algorithm 9 is like algorithm 8, but each of the loops has allowed variations, which still result in the final result being &lt;code&gt;O(n*log(n))&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法9与算法8类似，但是每个循环都允许有变化，最终结果仍为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n*log(n))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="17d79de1210f6f15a000af0169a5ef68b6ed4866" translate="yes" xml:space="preserve">
          <source>Algorithms (4th Edition)</source>
          <target state="translated">算法(第四版)</target>
        </trans-unit>
        <trans-unit id="546877fd41740873d1cfa8e4f36cf9b0df017323" translate="yes" xml:space="preserve">
          <source>Algorithms in the Divide and Conquer paradigm are of complexity O(logn). One example here, calculate your own power function,</source>
          <target state="translated">除法与征服范式中的算法复杂度为O(logn)。这里举一个例子,计算自己的幂函数。</target>
        </trans-unit>
        <trans-unit id="bc69b8d895811f71046889c39e0d995b5f6f8de0" translate="yes" xml:space="preserve">
          <source>Although n is somewhere between 512 and 1023, only 10 iterations take place. This is because the step in the loop grows exponentially and thus takes only 10 iterations to reach the termination.</source>
          <target state="translated">虽然n介于512和1023之间,但只进行了10次迭代。这是因为循环中的步长呈指数级增长,因此只需要10次迭代就可以到达终点。</target>
        </trans-unit>
        <trans-unit id="13fda95a4e29f31623e6b27919c9c2654912cdb6" translate="yes" xml:space="preserve">
          <source>Analyzing the running time of a program (example).</source>
          <target state="translated">分析程序的运行时间(例)。</target>
        </trans-unit>
        <trans-unit id="b430315d40268f6d421e3d42d2f41d05716445c7" translate="yes" xml:space="preserve">
          <source>Anatomy of a program&amp;rsquo;s statement execution frequencies.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;程序语句执行频率的剖析。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f024ce63ef78ef7b64b38e26fabafc1f314daaa6" translate="yes" xml:space="preserve">
          <source>And its not just search, whatever may be the work (increment, compare or any operation) its a function of input size.</source>
          <target state="translated">而且它不只是搜索,不管是什么工作(增量、比较或任何操作),它都是一个输入大小的函数。</target>
        </trans-unit>
        <trans-unit id="3e0adb51e88db164baaa3fd268ad64b534eb5476" translate="yes" xml:space="preserve">
          <source>And so on.</source>
          <target state="translated">诸如此类。</target>
        </trans-unit>
        <trans-unit id="7a8d4b0af6eedcdbdf7182951523d1cc82a773a9" translate="yes" xml:space="preserve">
          <source>And that's how you get O(log n) which is the amount of work that needs to be done on the above tree to reach a solution.</source>
          <target state="translated">就这样,你就可以得到O(log n),也就是在上面的树上需要做多少工作才能达到一个解。</target>
        </trans-unit>
        <trans-unit id="430078eae25aa1035e9c5dded6c9d2dbbd85adf7" translate="yes" xml:space="preserve">
          <source>Another example is binary search, which has a running time of O(log&lt;sub&gt;2&lt;/sub&gt; n) because at every step you divide the search space by 2.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一个示例是二进制搜索，它的运行时间为O（log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n），因为在每一步您都将搜索空间除以2。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8ea8b371babfbf6cdabc48efdcabde7886a45b20" translate="yes" xml:space="preserve">
          <source>Ant it seems that this notation was mostly have taken from mathematics.</source>
          <target state="translated">蚂蚁看来,这种记号法大多是从数学中提取的。</target>
        </trans-unit>
        <trans-unit id="db52f24fa20a9333b6b58676f942da718a9e8a80" translate="yes" xml:space="preserve">
          <source>Applying this to your binary tree question so you have a good application: if you double the number of nodes in a binary tree, the height only increases by 1 (an additive amount).  If you double it again, it still only increased by 1.  (Obviously I'm assuming it stays balanced and such).  That way, instead of doubling your work when the problem size is multiplied, you're only doing very slightly more work. That's why O(log n) algorithms are awesome.</source>
          <target state="translated">把这个应用到你的二叉树问题上,这样你就有了一个很好的应用:如果你把二叉树中的节点数增加一倍,高度只增加1(一个加法量)。如果你再增加一倍,它仍然只增加了1(显然我是假设它保持平衡之类的)。这样一来,当问题的大小被乘以倍数时,你的工作量不是增加了一倍,而是只做了很小的工作量。这就是为什么O(log n)算法很厉害的原因。</target>
        </trans-unit>
        <trans-unit id="32764ca168816d370c0095d83bb00526d97bc511" translate="yes" xml:space="preserve">
          <source>As I know from university the symbol was intoduced by German mathematician Landau (1877-1938)</source>
          <target state="translated">我在大学时就知道,这个符号是由德国数学家兰道(1877-1938年)提出的。</target>
        </trans-unit>
        <trans-unit id="0c50b5084a8768bf3848fba400f3d6b5a12bde9e" translate="yes" xml:space="preserve">
          <source>As the input size increases the work done(here the execution time) increases.(Hence proportionality)</source>
          <target state="translated">随着输入大小的增加,所做的工作(这里指的是执行时间)也会增加(因此比例性)。</target>
        </trans-unit>
        <trans-unit id="965b30064e173b5100a19b6d6ea70cf86fc6ba94" translate="yes" xml:space="preserve">
          <source>Assume we had instead a dataset with 32 elements. Continue the drawing above to find that we will now need 5 comparisons to find what we are searching for, as the tree has only grown one level deeper when we multiplied the amount of data. As a result, the complexity of the algorithm can be described as a logarithmic order.</source>
          <target state="translated">假设我们有一个有32个元素的数据集。继续上面的画法,发现我们现在需要5次比较才能找到我们要找的东西,因为当我们将数据量乘以数据量时,树只增长了一层。因此,该算法的复杂度可以用对数顺序来描述。</target>
        </trans-unit>
        <trans-unit id="1500b9ad9d3e53ed6762cb42f394ab0fc94c747c" translate="yes" xml:space="preserve">
          <source>Asymptotic complexity is the behavior of execution time of an algorithm while the time complexity is the actual execution time. But some people use these terms interchangeably.</source>
          <target state="translated">拟态复杂度是指算法执行时间的行为,而时间复杂度是指算法的实际执行时间。但有些人把这两个词交替使用。</target>
        </trans-unit>
        <trans-unit id="b7364a52ea4e1ac22d7414be72af2283970927a4" translate="yes" xml:space="preserve">
          <source>At the first step, you divide by 2. You then have 2 lists (2^1), you divide each by 2, so you have 4 lists (2^2), you divide again, you have 8 lists (2^3)and so on until your list size is 1</source>
          <target state="translated">在第一步,你除以2,然后你有2个列表(2^1),你再除以2,你有4个列表(2^2),你再除,你有8个列表(2^3),以此类推,直到你的列表大小是1</target>
        </trans-unit>
        <trans-unit id="c089231c2cd527f03ef02173a14ef58e49378bb4" translate="yes" xml:space="preserve">
          <source>Because time complexity depends on various parameters viz.</source>
          <target state="translated">因为时间的复杂度取决于各种参数,即时间复杂度。</target>
        </trans-unit>
        <trans-unit id="79385006bae7e35860b6fe3468ec15323eadbe8e" translate="yes" xml:space="preserve">
          <source>Binary search is an example with complexity &lt;code&gt;O(log n)&lt;/code&gt;. Let's say that the nodes in the bottom level of the tree in figure 1 represents items in some sorted collection. Binary search is a divide-and-conquer algorithm, and the drawing shows how we will need (at most) 4 comparisons to find the record we are searching for in this 16 item dataset.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;二进制搜索是一个复杂度为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的示例&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设图1中树的最底层节点代表某种已排序集合中的项目。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;二进制搜索是一种分而治之的算法，该图显示了我们如何（最多）需要进行4次比较才能在这16个项目的数据集中找到要搜索的记录。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be848c0e0760b865d37c7f1e1021bb006ee2006e" translate="yes" xml:space="preserve">
          <source>Binary tree is a case where a problem of size n is divided into sub-problem of size n/2 until we reach a problem of size 1:</source>
          <target state="translated">二叉树是将一个大小为n的问题分成大小为n2的子问题,直到到达大小为1的问题。</target>
        </trans-unit>
        <trans-unit id="3224959bcf8bf1a4e97341e888dd1713f7031354" translate="yes" xml:space="preserve">
          <source>But even in mathematical analysis sometimes this symbol was used in meaning &quot;C*g(n) &amp;gt; f(n) &amp;gt; 0&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，即使在数学分析中，有时也会使用该符号表示&amp;ldquo; C * g（n）&amp;gt; f（n）&amp;gt; 0&amp;rdquo;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="028ac440b61f595ee3489b7aaf85ae807e104671" translate="yes" xml:space="preserve">
          <source>But what exactly is &lt;em&gt;O(log n)&lt;/em&gt;?  For example, what does it mean to say that the height of a complete binary tree is &lt;em&gt;O(log n)&lt;/em&gt;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（log n）&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到底是什么&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，说一个完整的二叉树的高度为&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（log n）是&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;什么意思？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8956095c5174d4083eb653119d3665061530f125" translate="yes" xml:space="preserve">
          <source>But what exactly is O(log n)</source>
          <target state="translated">但究竟什么是O(log n)</target>
        </trans-unit>
        <trans-unit id="0f241aead868e87d092bade7cdb4f3dc39360f7f" translate="yes" xml:space="preserve">
          <source>But what exactly is O(log n)? For example, what does it mean to say that the height of a &amp;gt;complete binary tree is O(log n)?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是O（log n）到底是什么？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，说&amp;gt;完整二叉树的高度为O（log n）是什么意思？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="edc1bfb371b8739da6f6a8bfe6b528f1e14b4316" translate="yes" xml:space="preserve">
          <source>Divide and conquer algorithms usually have a &lt;code&gt;logn&lt;/code&gt; component to the running time. This comes from the repeated halving of the input.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分而治之算法通常具有&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运行时间&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;logn&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组件。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这源于输入的重复减半。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="042a172d4487ee962ac155493b6704fe324ce14f" translate="yes" xml:space="preserve">
          <source>Edit: As noted, the log base doesn't matter, but when deriving the Big-O performance of an algorithm, the log factor will come from halving, hence why I think of it as base 2.</source>
          <target state="translated">编辑:如前所述,对数基数并不重要,但在推导出一个算法的Big-O性能时,对数系数将来自于减半,因此我认为是基数2。</target>
        </trans-unit>
        <trans-unit id="6b51ffb5caa85a59fa5b79d9a86cc93f753c1d72" translate="yes" xml:space="preserve">
          <source>Every time we write an algorithm or code we try to analyze its asymptotic complexity.
It is different from its &lt;b&gt;time complexity&lt;/b&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每次我们编写算法或代码时，我们都会尝试分析其渐近复杂性。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它不同于&lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时间复杂度&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7a32654a9db30d8a5838e3722ec97067271f1ac0" translate="yes" xml:space="preserve">
          <source>First I recommend you to read following book;</source>
          <target state="translated">首先,我推荐你看以下这本书。</target>
        </trans-unit>
        <trans-unit id="4389c042e3105fc444c640d496eb44c0535e3593" translate="yes" xml:space="preserve">
          <source>First, you'll want to have a general idea of Logarithm, which you can get from &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;https://en.wikipedia.org/wiki/Logarithm&lt;/a&gt; . Natural science use &lt;code&gt;e&lt;/code&gt; and the natural log. Engineering disciples will use log_10 (log base 10) and computer scientists will use log_2 (log base 2) a lot, since computers are binary based. Sometimes you'll see abbreviations of natural log as &lt;code&gt;ln()&lt;/code&gt;, engineers normally leave the _10 off and just use &lt;code&gt;log()&lt;/code&gt; and log_2 is abbreviated as &lt;code&gt;lg()&lt;/code&gt;. All of the types of logarithms grow in a similar fashion, that is why they share the same category of &lt;code&gt;log(n)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先，您需要了解对数的一般概念，您可以从&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://en.wikipedia.org/wiki/Logarithm&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;获得&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自然科学使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;e&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和自然对数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;工程弟子将使用log_10（对数为10），计算机科学家将大量使用log_2（对数为2），因为计算机是基于二进制的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有时，您会看到自然日志的缩写为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ln()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，工程师通常会关闭_10并仅使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;log()&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而log_2则缩写为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;lg()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有类型的对数以相似的方式增长，这就是为什么它们共享相同的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类别&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e17e10b891c653c285dea64d8f7a3373a1c19493" translate="yes" xml:space="preserve">
          <source>Following &lt;strong&gt;Big-O Complexity Chart&lt;/strong&gt; also taken from &lt;a href=&quot;http://bigocheatsheet.com/&quot;&gt;bigocheatsheet&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;big-O复杂度图表&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也来自&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bigocheatsheet.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bigocheatsheet&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="16d7a7b7bac663123d8b79b95559ac46d279282b" translate="yes" xml:space="preserve">
          <source>Following is an example of Linear Time Algorithm</source>
          <target state="translated">以下是线性时间算法的一个例子</target>
        </trans-unit>
        <trans-unit id="1fef1582a836eacedbb1ab2d7e10888873cb5181" translate="yes" xml:space="preserve">
          <source>For example, the following function is &lt;em&gt;O(n)&lt;/em&gt; because the algorithm grows in proportion to its input &lt;em&gt;n&lt;/em&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，以下函数为&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n），&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为该算法与输入&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;成正比增长&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4caaa120df8c8c3e1948ef5644142dc7327e7965" translate="yes" xml:space="preserve">
          <source>For the below examples, we're now at the printer's office. Phone books are waiting to be mailed to each resident or business, and there's a sticker on each phone book identifying where it should be mailed to. Every person or business gets one phone book.</source>
          <target state="translated">对于下面的例子,我们现在到了印刷厂的办公室。电话簿等着寄给每个居民或企业,每本电话簿上都有一个贴纸,标明应该寄到哪里。每个人或企业都会得到一本电话簿。</target>
        </trans-unit>
        <trans-unit id="008f849741e4c42a77d0d3e85df29402d2062285" translate="yes" xml:space="preserve">
          <source>For the tree example, you can easily see that stepping down a level of nodes cuts down an exponential number of elements as you continue traversing. The popular example of looking through a name-sorted phone book is essentially equivalent to traversing down a binary search tree (middle page is the root element, and you can deduce at each step whether to go left or right).</source>
          <target state="translated">对于树形的例子,你不难发现,往下踏下一级节点,在继续遍历的过程中会减少一个指数级的元素。通俗的例子是翻阅一个名字排序的电话簿,本质上相当于向下遍历一个二进制搜索树(中间页是根元素,每一步都可以推断出是向左还是向右)。</target>
        </trans-unit>
        <trans-unit id="f8cbba489ca545bed31ce5284b0f861e16a08da2" translate="yes" xml:space="preserve">
          <source>Given n input elements, to search an element in the array you need &lt;b&gt;at most 'n' comparisons&lt;/b&gt;. In other words, no matter what programming language you use, what coding style you prefer, on what system you execute it. In the worst case scenario it requires only n comparisons.The execution time is linearly proportional to the input size.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给定n个输入元素，要搜索数组中的一个元素，您&lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最多&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;需要&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;'n'比较&lt;/font&gt;&lt;/b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;换句话说，无论您使用哪种编程语言，更喜欢哪种编码风格，在哪种系统上执行它。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在最坏的情况下，它仅需要进行n次比较。执行时间与输入大小成线性比例关系。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b7e083bb0f5b4f68b701df168e90a1fcd7902c02" translate="yes" xml:space="preserve">
          <source>Here are the running times of some operations we might perform on the phone book, from fastest to slowest:</source>
          <target state="translated">以下是我们可能在电话本上进行的一些操作,从最快到最慢的运行时间。</target>
        </trans-unit>
        <trans-unit id="a642dd551ca2983c44ce398efcbea81aaf769af0" translate="yes" xml:space="preserve">
          <source>Here is some functions and their expected complexities. Numbers are indicating &lt;strong&gt;statement execution frequencies&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一些功能及其预期的复杂性。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数字表示&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语句执行的频率&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4544d6dc56eede04340e7b413a78c264800e6ff9" translate="yes" xml:space="preserve">
          <source>I am learning about Big O Notation running times and amortized times.  I understand the notion of &lt;em&gt;O(n)&lt;/em&gt; linear time, meaning that the size of the input affects the growth of the algorithm proportionally...and the same goes for, for example, quadratic time &lt;em&gt;O(n&lt;sup&gt;2&lt;/sup&gt;)&lt;/em&gt; etc..even algorithms, such as permutation generators, with &lt;em&gt;O(n!)&lt;/em&gt; times, that grow by factorials.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我正在了解Big O Notation运行时间和摊销时间。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我理解&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n）&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;线性时间&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的概念&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这意味着输入的大小会成比例地影响算法的增长...例如，二次时间&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）等&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也是如此。 ，例如乘数为&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n！）的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;排列生成器，并&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过阶乘增长。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1514ac946545245f0cd6c0c469469d9924c92dc8" translate="yes" xml:space="preserve">
          <source>I can add something interesting, that I read in book by Kormen and etc. a long time ago. Now, imagine a problem, where we have to find a solution in a problem space. This problem space should be finite.</source>
          <target state="translated">我可以补充一些有趣的东西,这是我很久之前在Kormen等人的书中看到的。现在,想象一个问题,我们必须在一个问题空间中找到一个解决方案。这个问题空间应该是有限的。</target>
        </trans-unit>
        <trans-unit id="77898565c07238eac54505aaa70fda9acd97105d" translate="yes" xml:space="preserve">
          <source>I can give an example for a for loop and maybe once grasped the concept maybe it will be simpler to understand in different contexts.</source>
          <target state="translated">我可以举一个for循环的例子,也许一旦掌握了这个概念,也许在不同的语境下理解起来会更简单。</target>
        </trans-unit>
        <trans-unit id="f46c74600710cca3491ccc2d55014c941985acd4" translate="yes" xml:space="preserve">
          <source>I cannot understand how to identify a function with a log time.</source>
          <target state="translated">我无法理解如何用日志时间来识别一个功能。</target>
        </trans-unit>
        <trans-unit id="b120641fbd4e22f22f1a41d9c1460d708b5abf16" translate="yes" xml:space="preserve">
          <source>I cannot understand how to identify a function with a logarithmic
  time.</source>
          <target state="translated">我无法理解如何用对数时间来识别一个函数。</target>
        </trans-unit>
        <trans-unit id="2fc60cfd1e6ecec87ecd174464fd863785193468" translate="yes" xml:space="preserve">
          <source>I do know (maybe not in great detail) what Logarithm is, in the sense that:  log&lt;sub&gt;10&lt;/sub&gt; 100 = 2, but I cannot understand how to identify a function with a logarithmic time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我确实知道（也许不是很详细）什么是对数，即：log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;10&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 100 = 2，但是我不明白如何用对数时间来识别一个函数。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c4c380d7b586ba548b763e759bdb6e8a0e7d641" translate="yes" xml:space="preserve">
          <source>I should point out, that we are talking here about a relative fraction limit, not the absolute one. The binary search is a classical example. At each step we throw away 1/2 of the problem space. But binary search is not the only such example. Suppose, you proved somehow, that at each step you throw away at least 1/128 of problem space. That means, your program is still running at O(logN) time, although significantly slower than the binary search. This is a very good hint in analyzing of recursive algorithms. It often can be proved that at each step the recursion will not use several variants, and this leads to the cutoff of some fraction in problem space.</source>
          <target state="translated">我应该指出,我们这里说的是相对的分数限制,而不是绝对的分数限制。二元搜索是一个经典的例子。在每一步我们都会丢掉12个问题空间。但二进制搜索并不是唯一的例子。假设,你以某种方式证明,在每一步中,你至少扔掉了1128个问题空间。这意味着,你的程序仍然以O(logN)时间运行,虽然比二进制搜索要慢很多。这在分析递归算法时,是一个很好的提示。往往可以证明,在每一步递归不会使用几个变体,这就会导致问题空间中的某一部分被切断。</target>
        </trans-unit>
        <trans-unit id="5881b589c8d34329db8c8aaf3583f04e0a95d59a" translate="yes" xml:space="preserve">
          <source>I would rephrase this as 'height of a complete binary tree is log n'.  Figuring the height of a complete binary tree would be O(log n), if you were traversing down step by step.</source>
          <target state="translated">我想把这句话改成 &quot;一个完整的二进制树的高度是对数n&quot;。如果你是一步一步地往下走,那么一个完整的二元树的高度是O(log n)。</target>
        </trans-unit>
        <trans-unit id="34a2c69faab5e22f0819e07416c899e0ab5ea227" translate="yes" xml:space="preserve">
          <source>If an operation makes a series of constant time decisions each of which halves (reduces by a factor of 3, 4, 5..) the size of the input to be considered, the whole will take time proportional to log base 2 (base 3, base 4, base 5...) of the size N of the input, rather than being O(N).</source>
          <target state="translated">如果一个操作做了一系列的恒定时间决策,每一个决策都是要考虑的输入的大小的一半(缩小3、4、5...的系数),那么整个操作所花费的时间将与输入的大小N的对数基2(基3、基4、基5...)成正比,而不是O(N)。</target>
        </trans-unit>
        <trans-unit id="29c301205bbde0676fa60de7fb664c0272520a41" translate="yes" xml:space="preserve">
          <source>If an operation performs constant time work on each digit or bit of an input, the whole operation will take time proportional to the number of digits or bits in the input, not the magnitude of the input; thus, O(log N) rather than O(N).</source>
          <target state="translated">如果一个操作对输入的每个数字或位执行恒定时间的工作,那么整个操作所需时间将与输入中的数字或位数成正比,而不是与输入的大小成正比;因此,O(log N)而不是O(N)。</target>
        </trans-unit>
        <trans-unit id="40f1a35a514953f64f37c0530c0551a81f2c1d8c" translate="yes" xml:space="preserve">
          <source>If you are looking for a intuition based answer I would like to put up two interpretations for you.</source>
          <target state="translated">如果你想找一个基于直觉的答案,我想为你提出两个解释。</target>
        </trans-unit>
        <trans-unit id="e727fd9b51a54744bd70b04f39c112e181c73e04" translate="yes" xml:space="preserve">
          <source>If you had a function that takes:</source>
          <target state="translated">如果你有一个功能,需要。</target>
        </trans-unit>
        <trans-unit id="cae2fdb17e96f6926d298666e40f5aed0ba43750" translate="yes" xml:space="preserve">
          <source>If you have an M-ary tree of depth d and size n, then:</source>
          <target state="translated">如果你有一棵深度为d且大小为n的M级树,那么:</target>
        </trans-unit>
        <trans-unit id="1d95e53c64e645e837222469b9cab7b8c1b9b2cb" translate="yes" xml:space="preserve">
          <source>If you increase the problem size by a multiplicative amount (i.e. multiply its size by 10), the work is only increased by an additive amount.</source>
          <target state="translated">如果你把问题的大小增加了一个倍数(即它的大小乘以10),那么工作只增加了一个加法量。</target>
        </trans-unit>
        <trans-unit id="8e7f99e5aec28c3c3af14e4b086ab56f08a3ece3" translate="yes" xml:space="preserve">
          <source>If you plot a logarithmic function on a graphical calculator or something similar, you'll see that it rises really slowly -- even more slowly than a linear function.</source>
          <target state="translated">如果你在图形计算器或类似的东西上绘制一个对数函数,你会发现它的上升速度非常慢--甚至比线性函数还要慢。</target>
        </trans-unit>
        <trans-unit id="b135e7e3c1db73615122392851be7982fb0590b8" translate="yes" xml:space="preserve">
          <source>Imagine a very high hill with a very broad base as well. To reach the top of the hill there are two ways: one is a dedicated pathway going spirally around the hill reaching at the top, the other: small terrace like carvings cut out to provide a staircase. Now if the first way is reaching in linear time O(n), the second one is O(log n).</source>
          <target state="translated">想象一下,这是一座很高的山丘,它的基座也很宽阔。要到达山顶有两条路:一条是专门的小路,绕着山体螺旋式地到达山顶,另一条是在山顶上凿出一个小平台,像雕刻一样的小台阶。现在,如果第一种方式是以线性时间O(n)到达,第二种方式是O(对数n)。</target>
        </trans-unit>
        <trans-unit id="5e33e04b1dee3afdd640617efc039e44bde6caae" translate="yes" xml:space="preserve">
          <source>Imagine an algorithm, which accepts an integer, &lt;code&gt;n&lt;/code&gt; as input and completes in time proportional to &lt;code&gt;n&lt;/code&gt; then it is O(n) or theta(n) but if it runs in time proportion to the &lt;code&gt;number of digits or the number of bits in the binary representation on number&lt;/code&gt; then the algorithm runs in O(log n) or theta(log n) time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;想象一下一种算法，该算法接受整数&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为输入，并且在时间上与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;成正比，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那么它是O（n）或theta（n），但是如果它在时间上与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;number of digits or the number of bits in the binary representation on number&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;成比例，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用数字表示二进制，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后算法在O（log n）或theta（log n）时间运行。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6d589872ee5e41297713f59c099e086e3b4052ff" translate="yes" xml:space="preserve">
          <source>Imagine we have a rope and we have tied it to a horse. If the rope is directly tied to the horse, the force the horse would need to pull away (say, from a man) is directly 1.</source>
          <target state="translated">设想一下,我们有一根绳子,我们把它绑在一匹马身上。如果绳子直接绑在马身上,那么马要拉开(比如说,从人身上拉开)所需要的力直接是1。</target>
        </trans-unit>
        <trans-unit id="6378d42546aa9afc7483f28bf7aebdf73c49b4cd" translate="yes" xml:space="preserve">
          <source>In information technology it means that:</source>
          <target state="translated">在信息技术方面,它意味着:</target>
        </trans-unit>
        <trans-unit id="98c3336af693827be0b1652e42621a919c618013" translate="yes" xml:space="preserve">
          <source>In lay terms, it means that the equation for time may have some other components: e.g. it may have some constant startup time;  but these other components pale towards insignificance for large values of n, and the a*log(n) is the dominating term for large n.</source>
          <target state="translated">通俗地讲,这意味着时间方程可能有一些其他成分:例如,它可能有一些恒定的启动时间;但这些其他成分对于n的大值来说就显得微不足道了,而a*log(n)是n大时的主导项。</target>
        </trans-unit>
        <trans-unit id="58f7c710de382403051e79844d41a906eeb779a2" translate="yes" xml:space="preserve">
          <source>In mathematical analysis it means that:</source>
          <target state="translated">在数学分析中,它的意思是()。</target>
        </trans-unit>
        <trans-unit id="b3e3252b9357453f176dba5797bfb8ef7ee2628e" translate="yes" xml:space="preserve">
          <source>In our example above, our 'growth rate' is &lt;strong&gt;O(log n)&lt;/strong&gt;. For every additional loop, the force our rope can handle is 10 times more:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在上面的示例中，我们的&amp;ldquo;增长率&amp;rdquo;为&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（log n）&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每增加一个环，我们的绳索可以承受的力就会增加十倍：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f65581e910638647521ce0d5776783cc36b7118" translate="yes" xml:space="preserve">
          <source>In the case of binary search, every iteration you throw away half of the input. It should be noted that in Big-O notation, log is log base 2.</source>
          <target state="translated">在二进制搜索的情况下,每迭代一次就丢掉一半的输入。需要注意的是,在Big-O记数法中,log是log基数2。</target>
        </trans-unit>
        <trans-unit id="fb6b918ab69d9248208647f0c2b72d19f69ad0b5" translate="yes" xml:space="preserve">
          <source>In this article there is a quote:
&lt;a href=&quot;http://www.phil.uu.nl/datastructuren/09-10/knuth_big_omicron.pdf&quot;&gt;D.E. Knuth, &quot;BIG OMICRON AND BIG OMEGA AND BIG THETA&quot;, 1976&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在本文中有一个引语： &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.phil.uu.nl/datastructuren/09-10/knuth_big_omicron.pdf&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DE Knuth，&amp;ldquo;大欧姆龙和大欧米茄和大THETA&amp;rdquo;，1976年&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8670c63b3667b4287608c526872dfc9205befd56" translate="yes" xml:space="preserve">
          <source>Instead we take input size as the parameter because whatever the code is, the input is same.
&lt;b&gt;So the execution time is a function of input size.&lt;/b&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相反，我们将输入大小作为参数，因为无论代码是什么，输入都是相同的。 &lt;/font&gt;&lt;/font&gt;&lt;b&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此执行时间是输入大小的函数。&lt;/font&gt;&lt;/font&gt;&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="0dc1da4c3f8d12c166ff2cd6e4311d6053faa4f2" translate="yes" xml:space="preserve">
          <source>It is like saying that logarithm is the inverse of exponential.</source>
          <target state="translated">这就像说对数是指数的倒数一样。</target>
        </trans-unit>
        <trans-unit id="c4cf5d0abe643a3d91104db3051e74c625aac83a" translate="yes" xml:space="preserve">
          <source>It is the number of times you can cut a log of length n repeatedly into b equal parts before reaching a section of size 1.</source>
          <target state="translated">它是指将一根长度为n的原木反复切成b等份的次数,然后再切成大小为1的一段。</target>
        </trans-unit>
        <trans-unit id="70b54711198b76e6fa5a133bb42b9709471571ba" translate="yes" xml:space="preserve">
          <source>It simply means that the time needed for this task grows with log(n) (example : 2s for n = 10, 4s for n = 100, ...). Read the Wikipedia articles on &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;Binary Search Algorithm&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O Notation&lt;/a&gt; for more precisions.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这仅表示此任务所需的时间随log（n）的增加而增加（例如：n = 10时为2s，n = 100时为4s，...）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;阅读Wikipedia上有关&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;二进制搜索算法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Big O表示法的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文章，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以获取更多精度。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d446a1de595cefe01ba8d7b981f6598cef60e89a" translate="yes" xml:space="preserve">
          <source>Lastly very simple showcase there is shows how it is calculated;</source>
          <target state="translated">最后是非常简单的展示,有显示它是如何计算的。</target>
        </trans-unit>
        <trans-unit id="5365cefd34a28e9f6f10283dbf2204e550bd9877" translate="yes" xml:space="preserve">
          <source>Like algorithm 10, but with some variations.</source>
          <target state="translated">就像算法10,但有一些变化。</target>
        </trans-unit>
        <trans-unit id="daf9ca7dff5ef97da12064b1422d4d6d308259b7" translate="yes" xml:space="preserve">
          <source>Like algorithm 12, but with some variations that still yield &lt;code&gt;O(n^3)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与算法12类似，但仍具有一些变化，仍会产生&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n^3)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38289bf08745c473c76541ef8dc4bf419c9505a0" translate="yes" xml:space="preserve">
          <source>Logarithm is essentially the inverse of exponentiation.  So, if each 'step' of your function is eliminating a &lt;strong&gt;factor&lt;/strong&gt; of elements from the original item set, that is a logarithmic time algorithm.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对数本质上是幂的倒数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，如果函数的每个&amp;ldquo;步骤&amp;rdquo;都&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从原始项目集中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;消除了一个&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因素因素&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，那就是对数时间算法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c37c28e3db4ab56ed0c7f37046862788fd45f644" translate="yes" xml:space="preserve">
          <source>Logarithmic running time (&lt;code&gt;O(log n)&lt;/code&gt;) essentially means that the running time grows in proportion to the &lt;em&gt;logarithm&lt;/em&gt; of the input size - as an example, if 10 items takes at most some amount of time &lt;code&gt;x&lt;/code&gt;, and 100 items takes at most, say, &lt;code&gt;2x&lt;/code&gt;, and 10,000 items takes at most &lt;code&gt;4x&lt;/code&gt;, then it's looking like an &lt;code&gt;O(log n)&lt;/code&gt; time complexity.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对数运行时间（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）本质上意味着运行时间&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与输入大小&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对数&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;成正比增长&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-例如，如果10个项目最多花费一定的时间&lt;/font&gt;&lt;/font&gt; &lt;code&gt;x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，而100个项目最多花费时间，例如，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;2x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和10,000个项目最多需要&lt;/font&gt;&lt;/font&gt; &lt;code&gt;4x&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，那么它看起来像&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时间复杂度。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0da223ebb05c072d02e7d7d009cc82db75960461" translate="yes" xml:space="preserve">
          <source>Many good answers have already been posted to this question, but I believe we really are missing an important one - namely, the illustrated answer.</source>
          <target state="translated">关于这个问题,已经有很多好的答案,但我相信我们真的缺少了一个重要的答案----即图文并茂的答案。</target>
        </trans-unit>
        <trans-unit id="0b6718155769a3e78ed892aa3ac3ab7d62302796" translate="yes" xml:space="preserve">
          <source>Note that if the equation were, for example ...</source>
          <target state="translated">请注意,如果方程是,例如...。</target>
        </trans-unit>
        <trans-unit id="0aa386acc93467ee2abde73845cd59703ce2baff" translate="yes" xml:space="preserve">
          <source>Notice that I have bolded 'at most'. Big-O notation always refers to the worse case. If you're lucky, you could guess the number in one attempt and so the best case is O(1), but that's another story.</source>
          <target state="translated">请注意,我把 &quot;最多 &quot;加粗了。Big-O的记号总是指的是最坏的情况。如果你运气好的话,你可以一次就猜到这个数字,所以最好的情况是O(1),但这是另一回事。</target>
        </trans-unit>
        <trans-unit id="896e616be26c906871b376ff0bcf07906cf168d2" translate="yes" xml:space="preserve">
          <source>Now if the rope is looped once, the horse will need to pull 10 times harder. If the human decides to make it really difficult for the horse, he may loop the rope again round a pole, increasing it's strength by an additional 10 times. A third loop will again increase the strength by a further 10 times.</source>
          <target state="translated">现在,如果绳子绕了一次,马就需要用10倍的力气去拉。如果人类决定要让马匹真的很难拉,他可以把绳子再绕一圈,再增加10倍的力量。第三次再绕一圈,强度会再增加10倍。</target>
        </trans-unit>
        <trans-unit id="1d64633a7606b749454da054611ddab06ad82f5e" translate="yes" xml:space="preserve">
          <source>Now imagine the rope is looped round a pole. The horse to get away will now have to pull many times harder. The amount of times will depend on the roughness of the rope and the size of the pole, but let's assume it will multiply one's strength by 10 (when the rope makes a complete turn).</source>
          <target state="translated">现在,想象一下,绳子绕着杆子转了一圈。马匹要想跑开,现在必须要用力拉多少倍。次数的多少取决于绳子的粗糙度和杆子的大小,但我们假设一个人的力气要乘以10(当绳子转完一圈后)。</target>
        </trans-unit>
        <trans-unit id="d4de53fc0c4c7ca626fe1b6e7ea8bfbf1e3b1a36" translate="yes" xml:space="preserve">
          <source>Now it took you 7 guesses to get this right. But what is the relationship here? What is the most amount of items that you can guess from each additional guess?</source>
          <target state="translated">现在,你花了7个猜测才猜对了。但是,这里的关系是什么?每多猜一次,你能猜到的东西最多是多少?</target>
        </trans-unit>
        <trans-unit id="02fb936ea47e751f434197c3c1e70189f2a9e94f" translate="yes" xml:space="preserve">
          <source>Now let's imagine you are trying to guess a number between 1-100.</source>
          <target state="translated">现在让我们想象一下,你正在尝试猜测一个1-100之间的数字。</target>
        </trans-unit>
        <trans-unit id="92c7d02b06664cf176d72b22469d6e2637331bf5" translate="yes" xml:space="preserve">
          <source>Now the example above did use base 10, but fortunately the base of the log is insignificant when we talk about big o notation.</source>
          <target state="translated">现在,上面的例子确实使用了基数10,但幸运的是,当我们谈论大O记号时,日志的基数并不重要。</target>
        </trans-unit>
        <trans-unit id="d1132f0f0d5b4551a144f923806f22c8f231b52c" translate="yes" xml:space="preserve">
          <source>Now try to see it that way, if exponential grows very fast then logarithm grows (inversely) very slow.</source>
          <target state="translated">现在试着这样看,如果指数增长得很快,那么对数增长(反之)很慢。</target>
        </trans-unit>
        <trans-unit id="cf7bf0faa69c8d99b94cd18c064970e2c8eb7a8e" translate="yes" xml:space="preserve">
          <source>Now, if you can prove, that at every iteration of your algorithm you cut off a fraction of this space, that is no less than some limit, this means that your algorithm is running in O(logN) time.</source>
          <target state="translated">现在,如果你能证明,在你的算法的每一次迭代中,你的算法都会切掉这个空间的一小部分,也就是不小于某个极限,这意味着你的算法是在O(logN)时间内运行的。</target>
        </trans-unit>
        <trans-unit id="225912e442e23ad1ffb556abadc76e236a543d7e" translate="yes" xml:space="preserve">
          <source>O(log n) is a bit misleading, more precisely it's O(log&lt;sub&gt;2&lt;/sub&gt; n), i.e. (logarithm with base 2).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（log n）有点误导，更确切地说是O（log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n），即（以2为底的对数）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="741abfc15af347b4f12ce5826876662fcbfe5bae" translate="yes" xml:space="preserve">
          <source>Of course, a bigger phone book will still take you a longer time, but it won't grow as quickly as the proportional increase in the additional size.</source>
          <target state="translated">当然,大一点的电话本还是会花较长的时间,但它的增长速度不会像按比例增加的额外规模那样快。</target>
        </trans-unit>
        <trans-unit id="c91777dabbef341bced10eccfce89a68f07e4082" translate="yes" xml:space="preserve">
          <source>Ok let's try and fully understand what a logarithm actually is.</source>
          <target state="translated">好吧,让我们来充分了解一下对数究竟是什么。</target>
        </trans-unit>
        <trans-unit id="60081c10f46ab24f55cbcac1d8baa12b740223fb" translate="yes" xml:space="preserve">
          <source>On the basis of the issues discussed here, I propose that members of
  SIGACT, and editors of computer science and mathematics journals,
  adopt notations as defined above, unless &lt;strong&gt;a better alternative can be
  found reasonably soon&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基于此处讨论的问题，我建议SIGACT的成员以及计算机科学和数学杂志的编辑采用上述定义的符号，除非&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以在合理的时间内找到更好的替代方法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f1b4ad273ca861456f8e996a15667043d1cefab0" translate="yes" xml:space="preserve">
          <source>Or actually, it doesn't quite mean that; more likely it means something like &quot;&lt;code&gt;time&lt;/code&gt; divided by &lt;code&gt;a*log(n)&lt;/code&gt; tends towards &lt;code&gt;1&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或实际上，这并不完全意味着。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它更可能表示&amp;ldquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;time&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;除以&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;趋于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;之类的东西。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="172a790a2a8831c6bd8b4653399b564aa7c99f4b" translate="yes" xml:space="preserve">
          <source>Others have given good diagram examples, such as the tree diagrams. I did not see any simple code examples. So in addition to my explanation, I'll provide some algorithms with simple print statements to illustrate the complexity of different algorithm categories.</source>
          <target state="translated">别人给出了很好的图例,比如树状图。但我没有看到简单的代码例子。所以除了我的讲解之外,我还会提供一些算法,用简单的打印语句来说明不同算法类别的复杂程度。</target>
        </trans-unit>
        <trans-unit id="d226550a9f05c197e28559642c0c8048d4b533b4" translate="yes" xml:space="preserve">
          <source>Plotting &lt;code&gt;log(n)&lt;/code&gt; on a plain piece of paper, will result in a graph where the rise of the curve decelerates as &lt;code&gt;n&lt;/code&gt; increases:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在一张普通纸上&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;绘制&lt;/font&gt;&lt;/font&gt; &lt;code&gt;log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;会得到一个图形，其中曲线的上升随着&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;增加而&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;减速&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fa164feedc89846fdd3de1a98b22842deeff5b6f" translate="yes" xml:space="preserve">
          <source>Searching for 4 yields 3 hits: 6, 3 then 4. And log2 12 = 3, which is a good apporximate to how many hits where needed.</source>
          <target state="translated">搜索4会产生3次点击率。6,3 然后是4.而log2 12=3,这是一个很好的近似值。</target>
        </trans-unit>
        <trans-unit id="1348a8daed3b64aac9ec3379db2da56a0a9a0029" translate="yes" xml:space="preserve">
          <source>See as the input size increased the work done is increased and it is independent of any machine.
And if you try to find out the value of units of work 
It's actually dependent onto those above specified parameters.It will change according to the systems and all.</source>
          <target state="translated">你看,随着输入量的增加,所做的工作量也会增加,这与任何机器无关。而如果你试图找出工作单位的值,实际上是取决于上述指定的参数。</target>
        </trans-unit>
        <trans-unit id="dab06999693f805ef1a862d7a609e81414475e38" translate="yes" xml:space="preserve">
          <source>Similarly, if there was a nested loop, the time would be O(n&lt;sup&gt;2&lt;/sup&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同样，如果存在嵌套循环，则时间将为O（n &lt;/font&gt;&lt;/font&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a89c7cdf5037c4260a4641bbc5992b3ebeecf1f" translate="yes" xml:space="preserve">
          <source>Simply put: At each step of your algorithm you can cut the work in half. (Asymptotically equivalent to third, fourth, ...)</source>
          <target state="translated">简单来说:在你的算法的每一步,你可以把工作减少一半。(Asymptotically equivalent to third,fourth,...)</target>
        </trans-unit>
        <trans-unit id="401e8032f76cd53b593529b22a8cb008c7dd6f7c" translate="yes" xml:space="preserve">
          <source>So when you say any algorithm is O(log n)
it means the execution time is log times the input size n.</source>
          <target state="translated">所以,当你说任何算法都是O(log n)的时候,就意味着执行时间是输入大小n的对数倍。</target>
        </trans-unit>
        <trans-unit id="3fa29b366a6312d23b4d2519423f5db29d71f7d5" translate="yes" xml:space="preserve">
          <source>That gives you the equation :</source>
          <target state="translated">这就给了你一个公式:</target>
        </trans-unit>
        <trans-unit id="5291dbaca6641002cae33e549bcd7025de975858" translate="yes" xml:space="preserve">
          <source>That means that in the loop the step grows exponentially. E.g.</source>
          <target state="translated">这意味着,在循环中,步长是成倍增长的。例如:</target>
        </trans-unit>
        <trans-unit id="9216353681115945aaba6250fe5ae4d1014f5529" translate="yes" xml:space="preserve">
          <source>That's what bit O notation means: it means &quot;what is the order of dominant term for any sufficiently large n&quot;.</source>
          <target state="translated">这就是位O记号的意思:它的意思是 &quot;对于任何足够大的n来说,显性项的顺序是什么&quot;。</target>
        </trans-unit>
        <trans-unit id="7c239bafbc2dce1d2ee370782accc2cae132308f" translate="yes" xml:space="preserve">
          <source>The above give several straight forward examples, and variations to help demonstrate what subtle changes can be introduced that really don't change the analysis. Hopefully it gives you enough insight.</source>
          <target state="translated">上面举了几个直截了当的例子,以及变化的例子,帮助说明有哪些微妙的变化可以引入真正不会改变分析的东西。希望它能给你足够的启示。</target>
        </trans-unit>
        <trans-unit id="fda0956265302daf9fe6bdf8cd1b73b62ae63530" translate="yes" xml:space="preserve">
          <source>The best way I've always had to mentally visualize an algorithm that runs in O(log n) is as follows:</source>
          <target state="translated">我一直以来对一个运行在O(log n)中的算法进行心理可视化的最佳方法如下。</target>
        </trans-unit>
        <trans-unit id="81f4a7349b2e61a08d286f542458555f1865b59a" translate="yes" xml:space="preserve">
          <source>The complete binary example is O(ln n) because the search looks like this:</source>
          <target state="translated">完整的二进制例子是O(ln n),因为搜索结果是这样的。</target>
        </trans-unit>
        <trans-unit id="d7c3202604045a8f0ca1c569409156d740cf38fe" translate="yes" xml:space="preserve">
          <source>The complexity in O-notation of this program is O(log(n)). Let's try to loop through it by hand (n being somewhere between 512 and 1023 (excluding 1024):</source>
          <target state="translated">这个程序的复杂度用O表示,其复杂度为O(log(n))。让我们试着用手循环一遍(n是在512到1023之间(不包括1024)。</target>
        </trans-unit>
        <trans-unit id="23fb0bc54f9a22ea3778e044e18fe0f74b651fc4" translate="yes" xml:space="preserve">
          <source>The difference between O(n) and O(log(n)) is huge, similar to the difference between O(n) and O(a^n) (a being a constant).</source>
          <target state="translated">O(n)和O(log(n))之间的差异很大,类似于O(n)和O(a^n)之间的差异(a为常数)。</target>
        </trans-unit>
        <trans-unit id="0077251502a2b3945f5070c00b578c932c22496e" translate="yes" xml:space="preserve">
          <source>The explanation below is using the case of a fully &lt;em&gt;balanced&lt;/em&gt; binary tree to help you understand how we get logarithmic time complexity.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;下面的解释使用的是完全&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;平衡的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;二叉树&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的情况，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以帮助您了解我们如何获得对数时间复杂度。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="979a113826a0c1e025cb59a3bc5b4dbfe4e82d94" translate="yes" xml:space="preserve">
          <source>The following drawing depicts a binary tree. Notice how each level contains double the number of nodes compared to the level above (hence &lt;em&gt;binary&lt;/em&gt;):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;下图描绘了一个二叉树。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，每个级别如何包含的节点数量是上述级别的两倍（因此，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;binary&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db2a24bbecedf8e012282630dd132fbb4ee8f292" translate="yes" xml:space="preserve">
          <source>The height of a balanced binary tree is O(log&lt;sub&gt;2&lt;/sub&gt; n), since every node has two (note the &quot;two&quot; as in log&lt;sub&gt;2&lt;/sub&gt; n) child nodes. So, a tree with n nodes has a height of log&lt;sub&gt;2&lt;/sub&gt; n.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;平衡二叉树的高度为O（log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n），因为每个节点都有两个（在log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意&amp;ldquo;两个&amp;rdquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）子节点。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，具有n个节点的树的高度为log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f9f0b9b225087a04ae96fd13b7c4892a8920821" translate="yes" xml:space="preserve">
          <source>The logarithm of x (to the base of a) is the reverse function of a^x.</source>
          <target state="translated">x的对数(以a为基数)是a^x的反函数。</target>
        </trans-unit>
        <trans-unit id="748b4da565ee01d0e285c7ce2ee8782d05768ee1" translate="yes" xml:space="preserve">
          <source>The logarithmic function is the inverse of the exponential function. Put another way, if your input grows exponentially (rather than linearly, as you would normally consider it), your function grows linearly.</source>
          <target state="translated">对数函数是指数函数的倒数。换句话说,如果你的输入是指数式增长(而不是像你通常认为的线性增长),你的函数是线性增长的。</target>
        </trans-unit>
        <trans-unit id="217245fbd9703d38af322b5f4c84cf925e99d9dc" translate="yes" xml:space="preserve">
          <source>The most common attributes of logarithmic running-time function are that:</source>
          <target state="translated">对数运行时函数最常见的属性是:。</target>
        </trans-unit>
        <trans-unit id="c6ff8c3cdb742922883fe572d4bd4535cbbcdabf" translate="yes" xml:space="preserve">
          <source>The running time complexity of binary search is an example of &lt;code&gt;O(log n)&lt;/code&gt;. This is because in binary search, you are always ignoring half of your input in each later step by dividing the array in half and only focusing on one half with each step. Each step is constant-time, because in binary search you only need to compare one element with your key in order to figure out what to do next irregardless of how big the array you are considering is at any point. So you do approximately log(n)/log(2) steps.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;二进制搜索的运行时间复杂度是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个示例&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。这是因为在二进制搜索中，您总是在后面的每一步中忽略输入的一半，方法是将数组分为两半，而每一步只关注一半。每个步骤都是固定时间的，因为在二进制搜索中，无论您考虑的数组有多大，您都只需将一个元素与您的键进行比较就可以确定下一步要做什么。因此，您大约执行log（n）/ log（2）步骤。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="183ce247942b6cd9feda78873387089ea80dbff0" translate="yes" xml:space="preserve">
          <source>The running time complexity of merge sort is an example of &lt;code&gt;O(n log n)&lt;/code&gt;. This is because you are dividing the array in half with each step, resulting in a total of approximately log(n)/log(2) steps. However, in each step you need to perform merge operations on all elements (whether it's one merge operation on two sublists of n/2 elements, or two merge operations on four sublists of n/4 elements, is irrelevant because it adds to having to do this for n elements in each step). Thus, the total complexity is &lt;code&gt;O(n log n)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;合并排序的运行时间复杂度是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n log n)&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个示例&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是因为您将每一步将数组分成两半，因此总共大约需要log（n）/ log（2）个步骤。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，在每个步骤中，您都需要对所有元素执行合并操作（无论是对n / 2个元素的两个子列表进行一次合并操作，还是对n / 4个元素的四个子列表进行两次合并操作都是无关紧要的，因为这增加了必须在每个步骤中对n个元素执行此操作）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，总复杂度为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="78d57ee8f42bffef4d8a9382ae1beeb55a66ed2c" translate="yes" xml:space="preserve">
          <source>Then it takes log&lt;sub&gt;2&lt;/sub&gt;(n) time. The &lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;Big O notation&lt;/a&gt;, loosely speaking, means that the relationship only needs to be true for large n, and that constant factors and smaller terms can be ignored.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，它需要log &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（n）时间。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Big_O_notation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大O符号&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，严格地讲，这意味着关系只需要进行大的n是真实的，而且持续性因素和更小的方面可以忽略不计。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3f3dd6c155a570957f69b762d0742cb653f9ff27" translate="yes" xml:space="preserve">
          <source>These 2 cases will  take O(log n) time</source>
          <target state="translated">这2种情况需要O(log n)时间</target>
        </trans-unit>
        <trans-unit id="d0838d5f8965084f46ea02466a76e08056604c29" translate="yes" xml:space="preserve">
          <source>Think of this as a combination of &lt;code&gt;O(log(n))&lt;/code&gt; and &lt;code&gt;O(n)&lt;/code&gt;. The nesting of the for loops help us obtain the &lt;code&gt;O(n*log(n))&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将其视为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log(n))&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n)&lt;/code&gt; 的组合&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;for循环的嵌套可帮助我们获得&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(n*log(n))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c85c59919495767e1aa36e7cb8e1e1898fc42aff" translate="yes" xml:space="preserve">
          <source>This algorithm is simple, which prints hello n times.</source>
          <target state="translated">这个算法很简单,可以打印hello n次。</target>
        </trans-unit>
        <trans-unit id="275d42b938445e6155dc69cc23cb8dbbe4f2b94b" translate="yes" xml:space="preserve">
          <source>This algorithm shows a variation, where it will print hello n/2 times. n/2 = 1/2 * n. We ignore the 1/2 constant and see that this algorithm is O(n).</source>
          <target state="translated">n2=12*n,我们忽略12个常数,可以看到这个算法是O(n)。</target>
        </trans-unit>
        <trans-unit id="ef3f528f492ad5a3b79a1dcbea99bd7d9e170e6c" translate="yes" xml:space="preserve">
          <source>This is like algorithm 10, but with 3 loops instead of 2.</source>
          <target state="translated">这就像算法10,但有3个循环,而不是2个循环。</target>
        </trans-unit>
        <trans-unit id="4efa808ed1bb5af8e28061bc1c951efec7f558d1" translate="yes" xml:space="preserve">
          <source>This is why algorithms with a logarithmic time complexity are highly sought after: even for really big n (let's say n = 10^8, for example), they perform more than acceptably.</source>
          <target state="translated">这就是为什么具有对数时间复杂度的算法受到追捧的原因:即使对于真正的大n(比如说n=10^8),它们的表现也是超出了人们的接受范围。</target>
        </trans-unit>
        <trans-unit id="fb1c5cd15bd283875742af5791fe8a2b4e1a3c61" translate="yes" xml:space="preserve">
          <source>This is why, for example, looking up people in a phone book is O(log n). You don't need to check &lt;em&gt;every&lt;/em&gt; person in the phone book to find the right one; instead, you can simply divide-and-conquer by looking based on where their name is alphabetically, and in every section you only need to explore a subset of each section before you eventually find someone's phone number.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，这就是为什么在电话簿中查找人为O（log n）的原因。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您无需检查&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;电话簿中的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每个&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;人都可以找到合适的人。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;取而代之的是，您可以根据名字的字母顺序在哪里进行分而治之，并且在每个部分中，只需找到每个部分的子集即可，最终找到某人的电话号码。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16784fa25d2d74ba6e12621a053bcbb284da4694" translate="yes" xml:space="preserve">
          <source>Today is 2016, but we use it still today.</source>
          <target state="translated">今天是2016年,但我们今天依然在用它。</target>
        </trans-unit>
        <trans-unit id="20d2171208dac823f70a0fc05abd05f1bb1d23c5" translate="yes" xml:space="preserve">
          <source>Using the graph, we can see that if we use a binary search to guess a number between 1-100 it will take us &lt;strong&gt;at most&lt;/strong&gt; 7 attempts. If we had 128 numbers, we could also guess the number in 7 attemps but 129 numbers will takes us &lt;strong&gt;at most&lt;/strong&gt; 8 attempts (in relations to logarithms, here we would need 7 guesses for a 128 value range, 10 guesses for a 1024 value range. 7 is the logarithm of 128, 10 is the logarithm of 1024 (base 2)).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用该图，我们可以看到，如果使用二进制搜索来猜测1-100之间的数字，则&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最多需要&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 7次尝试。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果我们有128个数字，我们还可以猜测7次&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尝试中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的数字，但是129个数字&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最多&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;需要我们&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 8次尝试（与对数相关，此处对于128个值范围，我们将需要7个猜测，对于1024个值范围，我们将需要10个猜测。7是128的对数，10是1024（以2为底）的对数。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88eec511fbead7aa7ea065aa934d14f88f9f9b16" translate="yes" xml:space="preserve">
          <source>Walking a single path in the tree ~ O(d) = O(log n to base M)</source>
          <target state="translated">在树上走一条路~O(d)=O(对数n到基数M)。</target>
        </trans-unit>
        <trans-unit id="9b73a24be6f8b05f8c2985125f1eb8c601802768" translate="yes" xml:space="preserve">
          <source>We can expand the phone book example to compare other kinds of operations and &lt;em&gt;their&lt;/em&gt; running time. We will assume our phone book has &lt;em&gt;businesses&lt;/em&gt; (the &quot;Yellow Pages&quot;) which have unique names and &lt;em&gt;people&lt;/em&gt; (the &quot;White Pages&quot;) which may not have unique names. A phone number is assigned to at most one person or business. We will also assume that it takes constant time to flip to a specific page.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们可以扩展电话簿示例，以比较其他类型的操作&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;及其&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运行时间。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们将假定电话簿中的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;公司&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&amp;ldquo;黄页&amp;rdquo;）具有唯一的名称，而&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;人&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&amp;ldquo;白页&amp;rdquo;）则可能没有唯一的名称。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个电话号码最多分配给一个人或一个公司。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们还将假设翻转到特定页面需要花费固定的时间。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bf5c329d95290b50a23a52c623196a7055ce3a59" translate="yes" xml:space="preserve">
          <source>We can see that for each loop, the value increases by 10. The number of turns required to get any number is called the logarithm of the number i.e. we need 3 posts to multiple your strength by 1000 times, 6 posts to multiply your strength by 1,000,000.</source>
          <target state="translated">我们可以看到,每循环一次,数值就增加10。得到任何一个数字所需要的循环次数叫做对数,也就是说,我们需要3个职位,才能将你的实力乘以1000倍,6个职位,才能将你的实力乘以1000,000,000,000。</target>
        </trans-unit>
        <trans-unit id="215d074be1f0a767e1033061b3e486085ff1e2f8" translate="yes" xml:space="preserve">
          <source>We can see that for every guess our data set is shrinking. A good rule of thumb to identify if an algorithm has a logarithmtic time is
  to see if the data set shrinks by a certain order after each iteration</source>
          <target state="translated">我们可以看到,每一次的猜测,我们的数据集都在缩小。鉴别一个算法是否有对数时间,一个很好的经验法则是看每次迭代后数据集是否以一定的顺序收缩</target>
        </trans-unit>
        <trans-unit id="5c106784281fed81c6b6820aae1f0a6d9cbda0c5" translate="yes" xml:space="preserve">
          <source>What does O(log n) mean exactly</source>
          <target state="translated">O(log n)到底是什么意思</target>
        </trans-unit>
        <trans-unit id="93c5eee1c00a2205d8b906b832bc3151f6cc1c21" translate="yes" xml:space="preserve">
          <source>What does it mean to say that the height of a complete binary tree is O(log n)?</source>
          <target state="translated">一个完整的二元树的高度是O(log n)是什么意思?</target>
        </trans-unit>
        <trans-unit id="44807ad43b2ea914e6e9301d20f34f969353dcde" translate="yes" xml:space="preserve">
          <source>What it means precisely is &quot;as &lt;code&gt;n&lt;/code&gt; tends towards &lt;code&gt;infinity&lt;/code&gt;, the &lt;code&gt;time&lt;/code&gt; tends towards &lt;code&gt;a*log(n)&lt;/code&gt; where &lt;code&gt;a&lt;/code&gt; is a constant scaling factor&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它的确切含义是&amp;ldquo;随着&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;趋于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;infinity&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;time&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;趋于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a*log(n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，其中&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个恒定的缩放因子&amp;rdquo;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d9d385e501f3c19dadeb1c4c3602e959a018409e" translate="yes" xml:space="preserve">
          <source>What's log&lt;sub&gt;b&lt;/sub&gt;(n)?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;日志&lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;b&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（n）是多少？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5ddb3aa95967c49aba70d9818c8d1d78fd583c6b" translate="yes" xml:space="preserve">
          <source>When you look at the code examples below, I recommend looking at O(1), then O(n), then O(n^2). After you are good with those, then look at the others. I've included clean examples as well as variations to demonstrate how subtle changes can still result in the same categorization.</source>
          <target state="translated">当你看下面的代码示例时,我建议你先看O(1),然后看O(n),再看O(n^2)。在你熟练掌握了这些之后,再看其他的例子。我把干净的例子和变化的例子都包括在内,以证明微妙的变化仍然可以导致相同的分类。</target>
        </trans-unit>
        <trans-unit id="216423c2bafc59cfac2856f5284a31862176680e" translate="yes" xml:space="preserve">
          <source>You can easily identify if the algorithmic time is n log n. Look for an outer loop which iterates through a list (O(n)). Then look to see if there is an inner loop. If the inner loop is &lt;strong&gt;cutting/reducing&lt;/strong&gt; the data set on each iteration, that loop is (O(log n)), and so the overall algorithm is = &lt;strong&gt;O(n log n)&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以轻松确定算法时间是否为n log n。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;寻找一个遍历列表（O（n））的外部循环。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后查看是否存在内部循环。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果内部循环&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在每次迭代中&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;削减/减少&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数据集，则该循环为（O（log n）），因此整个算法为= &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n log n）&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1d5328a5b30597cfdbb5f64814aee6e0397a6702" translate="yes" xml:space="preserve">
          <source>You can think of O(1), O(n), O(logn), etc as classes or categories of growth. Some categories will take more time to do than others. These categories help give us a way of ordering the algorithm performance. Some grown faster as the input n grows. The following table demonstrates said growth numerically. In the table below think of log(n) as the ceiling of log_2.</source>
          <target state="translated">你可以把O(1)、O(n)、O(logn)等看作是增长的类或类别。有些类别会比其他类别花更多的时间去做。这些类别有助于我们对算法的性能进行排序。有的随着输入n的增长而增长得更快。下面的表格用数字来演示说的增长。在下表中,可以把log(n)看作是log_2的上限。</target>
        </trans-unit>
        <trans-unit id="5c973715b1aaecc205af6056a3e8561731036021" translate="yes" xml:space="preserve">
          <source>You can think of O(log N) intuitively by saying the time is proportional to the number of digits in N.</source>
          <target state="translated">你可以直观地认为O(log N)的时间与N中的位数成正比。</target>
        </trans-unit>
        <trans-unit id="be063b2f6f59fd659351560845cdcbd0fce725b1" translate="yes" xml:space="preserve">
          <source>You will eventually come across a linearithmic time &lt;strong&gt;O(n log(n))&lt;/strong&gt; algorithm. The rule of thumb above applies again, but this time the logarithmic function has to run n times e.g. reducing the size of a list &lt;strong&gt;n times&lt;/strong&gt;, which occurs in algorithms like a mergesort.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您最终将遇到线性时间&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（n log（n））&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上面的经验法则再次适用，但是这次对数函数必须运行n次，例如将列表的大小减小&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n次&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这在像mergesort这样的算法中会发生。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e633fb53f72a241fd99a62bdb2e5fec14d3b99f0" translate="yes" xml:space="preserve">
          <source>from &lt;a href=&quot;http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/&quot;&gt;http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来自&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://www.geeksforgeeks.org/write-ac-program-to-calculate-powxn/&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f561a474d88946ed4c679c84b7d0fa00aa1daefa" translate="yes" xml:space="preserve">
          <source>only one will need to be chosen.</source>
          <target state="translated">只需要选择一个就可以了。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="949b2d332a8532ba60eb0f9fdaaa648e4f5e90da" translate="yes" xml:space="preserve">
          <source>the choice of the next element on which to perform some action is one of several possibilities, and</source>
          <target state="translated">选择下一个要执行某种行动的要素是几种可能性之一,并且</target>
        </trans-unit>
        <trans-unit id="810680965d466ce9e27c217b0e6ef1c0fc7ac62f" translate="yes" xml:space="preserve">
          <source>the elements on which the action is performed are digits of n</source>
          <target state="translated">被执行动作的元素是n的数字。</target>
        </trans-unit>
        <trans-unit id="7c3255662cb9361125a26cad0c44f18afbdc1a9e" translate="yes" xml:space="preserve">
          <source>time(n) = a + b&lt;em&gt;log(n) + c&lt;/em&gt;n + d&lt;em&gt;n&lt;/em&gt;n</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;time（n）= a + b &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;log（n）+ c&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n + d &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; n&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3121a265ec660806dc7016bca8595689a539a80d" translate="yes" xml:space="preserve">
          <source>traversing the whole tree ~ O(M^d) = O(n)</source>
          <target state="translated">遍历整棵树 ~ O(M^d)=O(n)</target>
        </trans-unit>
        <trans-unit id="601d76bcf9259b0951e3bbabeb31e37d99f1830f" translate="yes" xml:space="preserve">
          <source>​It is &lt;code&gt;O(log n)&lt;/code&gt; when we do divide and conquer type of algorithms e.g binary search. Another example is quick sort where each time we divide the array into two parts and each time it takes &lt;code&gt;O(N)&lt;/code&gt; time to find a pivot element. Hence it  &lt;code&gt;N O(log N)&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;``当我们进行分治的算法（例如二进制搜索&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(log n)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;O（log n）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一个例子是快速排序，其中每次我们将数组分为两部分，并且每次花费&lt;/font&gt;&lt;/font&gt; &lt;code&gt;O(N)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时间来查找枢轴元素。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，它 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N O(log N)&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
