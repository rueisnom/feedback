<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/23667086">
    <body>
      <group id="23667086">
        <trans-unit id="87e7945a2a6acfe9e9ac15c56656043a7d3eaa7b" translate="yes" xml:space="preserve">
          <source>... as before, note that we've been able to remove the global variables (in this case &lt;code&gt;width&lt;/code&gt;).</source>
          <target state="translated">... как и прежде, обратите внимание, что мы смогли удалить глобальные переменные (в данном случае &lt;code&gt;width&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="483231bd8f34a26d5113dd22f8c5212933edbb64" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/maxogden/art-of-node#callbacks&quot;&gt;The Art of Node - Callbacks&lt;/a&gt; explains asynchronous code and callbacks very well with vanilla JS examples and Node.js code as well.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/maxogden/art-of-node#callbacks&quot;&gt;Искусство Node - Callbacks&lt;/a&gt; очень хорошо объясняет асинхронный код и обратные вызовы с помощью ванильных примеров JS и кода Node.js.</target>
        </trans-unit>
        <trans-unit id="18b6513dab89c1fe133131a6fb64518a7ba93ed0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/10058879/1331430&quot;&gt;@Matt Esch's answer to &quot;Get data from fs.readFile&quot;&lt;/a&gt; also explains asynchronicity extremely well in a simple manner.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/10058879/1331430&quot;&gt;Ответ @Matt Esch &amp;laquo;Получить данные из fs.readFile&amp;raquo;&lt;/a&gt; также очень просто объясняет асинхронность.</target>
        </trans-unit>
        <trans-unit id="cadc61baae72a97d1e69933c6cfd90e943dc7402" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/14220323/1331430&quot;&gt;@Felix Kling's answer to &quot;How do I return the response from an asynchronous call?&quot;&lt;/a&gt;. See his excellent answer explaining synchronous and asynchronous flows, as well as the &quot;Restructure code&quot; section.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/14220323/1331430&quot;&gt;@ Ответ Феликса Клинга на &amp;laquo;Как вернуть ответ от асинхронного вызова?&amp;raquo;&lt;/a&gt; , Смотрите его превосходный ответ, объясняющий синхронные и асинхронные потоки, а также раздел &amp;laquo;Реструктуризация кода&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="34372c0e6cc14dd9b3b03232668d7110ae7f8856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;img.onload&lt;/code&gt; may be called &lt;em&gt;sometime in the future&lt;/em&gt;, when (and if) the image has successfully loaded.</source>
          <target state="translated">&lt;code&gt;img.onload&lt;/code&gt; может быть вызван &lt;em&gt;когда-нибудь в будущем&lt;/em&gt; , когда (и если) изображение будет успешно загружено.</target>
        </trans-unit>
        <trans-unit id="68a8ea4de6a6afdbe9657f4ae00dcc062708d45f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setTimeout&lt;/code&gt; may be called &lt;em&gt;sometime in the future&lt;/em&gt;, after the delay has expired and the timeout hasn't been canceled by &lt;code&gt;clearTimeout&lt;/code&gt;. Note: even when using &lt;code&gt;0&lt;/code&gt; as delay, all browsers have a minimum timeout delay cap (specified to be 4ms in the HTML5 spec).</source>
          <target state="translated">&lt;code&gt;setTimeout&lt;/code&gt; может быть вызван &lt;em&gt;когда-нибудь в будущем&lt;/em&gt; , после того, как задержка истечет и время ожидания не будет отменено &lt;code&gt;clearTimeout&lt;/code&gt; . Примечание: даже при использовании &lt;code&gt;0&lt;/code&gt; в качестве задержки все браузеры имеют минимальный предел задержки по времени (указанный в спецификации HTML5 равным 4 мс).</target>
        </trans-unit>
        <trans-unit id="0bfccf94f3ad9d7adee477872ae30a98032c0523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; gets logged in this case because &lt;code&gt;getMessage&lt;/code&gt; returns before the &lt;code&gt;setTimeout&lt;/code&gt; callback is called and updates &lt;code&gt;outerScopeVar&lt;/code&gt;.</source>
          <target state="translated">в этом случае регистрируется &lt;code&gt;undefined&lt;/code&gt; , потому что &lt;code&gt;getMessage&lt;/code&gt; возвращается до вызова обратного вызова &lt;code&gt;setTimeout&lt;/code&gt; и обновляет &lt;code&gt;outerScopeVar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed49b1097a751bc8dfb2f4fa8d5282592dce48f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Fabr&amp;iacute;cio's answer is spot on; but I wanted to complement his answer with something less technical, which focusses on an analogy to help explain the concept of asynchronicity&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Ответ Фабрисио точен;&lt;/em&gt; &lt;em&gt;но я хотел дополнить его ответ чем-то менее техническим, сосредоточенным на аналогии, чтобы помочь объяснить концепцию асинхронности&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d22e77c39b64987867f31bc641a2c7fd0c1f2f91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="289bea1f35eed1af7b8112d0f8c61f705d425958" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2778e9f54b08b0eccef6e1f5fe205c622cd3d03c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b0452ea54bfa19c34b31eea62b1df9bde0570907" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f20ea25a1c1f93d46c8a492286f9cf8254aea33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b346ab96e2b29b13b999bfffc88ff3a8086c76c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/primers/promises&quot;&gt;Promises&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/primers/promises&quot;&gt;Promises&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5a5d71dbf9e42228d1baf6d36e54cd389b38eea8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bob&lt;/strong&gt;: Sure thing, but it'll take me around 30 minutes?</source>
          <target state="translated">&lt;strong&gt;Боб&lt;/strong&gt; : Конечно, но это займет у меня около 30 минут?</target>
        </trans-unit>
        <trans-unit id="7fdddf9c3bee50f48d61f290501ea4e7b84eca27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Callbacks&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Callbacks&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3733084af55c2ff08a2c0a4af4d4f8d7dafdd1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: Hi Bob, I need to know how we &lt;em&gt;foo&lt;/em&gt;'d the &lt;em&gt;bar&lt;/em&gt;'d last week. Jim want's a report on it, and you're the only one who knows the details about it.</source>
          <target state="translated">&lt;strong&gt;Я&lt;/strong&gt; : Привет, Боб, мне нужно знать, как мы &lt;em&gt;побывали&lt;/em&gt; в &lt;em&gt;баре&lt;/em&gt; на прошлой неделе. Джим хочет сообщить об этом, и вы единственный, кто знает подробности об этом.</target>
        </trans-unit>
        <trans-unit id="713f53e40c4562b4ab9eba6d6198debc536e516b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: Hi Bob, I need to know how we &lt;em&gt;foo&lt;/em&gt;'d the &lt;em&gt;bar&lt;/em&gt;'d last week. Jim wants a report on it, and you're the only one who knows the details about it.</source>
          <target state="translated">&lt;strong&gt;Я&lt;/strong&gt; : Привет, Боб, мне нужно знать, как мы &lt;em&gt;побывали&lt;/em&gt; в &lt;em&gt;баре&lt;/em&gt; на прошлой неделе. Джим хочет сообщить об этом, и вы единственный, кто знает подробности об этом.</target>
        </trans-unit>
        <trans-unit id="696d9e23b68465a334ff08838685b593defebdc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: That's great Bob. Give me a ring back when you've got the information!</source>
          <target state="translated">&lt;strong&gt;Я&lt;/strong&gt; : Это здорово, Боб. Позвони мне, когда получишь информацию!</target>
        </trans-unit>
        <trans-unit id="31595be6d48c2097c06c53e9214cf88db6632a77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: That's great Bob. I'll wait.</source>
          <target state="translated">&lt;strong&gt;Я&lt;/strong&gt; : Это здорово, Боб. Я буду ждать.</target>
        </trans-unit>
        <trans-unit id="c2fd0d38b0ab8484e639564a171161035b2a7b4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I'm using &lt;code&gt;setTimeout&lt;/code&gt; with a random delay as a generic asynchronous function, the same example applies to Ajax, &lt;code&gt;readFile&lt;/code&gt;, &lt;code&gt;onload&lt;/code&gt; and any other asynchronous flow.</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; я использую &lt;code&gt;setTimeout&lt;/code&gt; со случайной задержкой в ​​качестве универсальной асинхронной функции, этот же пример применяется к Ajax, &lt;code&gt;readFile&lt;/code&gt; , &lt;code&gt;onload&lt;/code&gt; и любому другому асинхронному потоку.</target>
        </trans-unit>
        <trans-unit id="5e39b2acd2b8bf115a6c7845f5b4a885b1f2ab18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I've marked this answer as Community Wiki, hence anyone with at least 100 reputations can edit and improve it! Please feel free to improve this answer, or submit a completely new answer if you'd like as well.</source>
          <target state="translated">&lt;strong&gt;Примечание:&lt;/strong&gt; я пометил этот ответ как вики сообщества, поэтому любой, имеющий не менее 100 репутаций, может редактировать и улучшать его! Пожалуйста, не стесняйтесь улучшать этот ответ или отправьте совершенно новый ответ, если хотите.</target>
        </trans-unit>
        <trans-unit id="01a61e555cd8030fb7253b04500742128a3d6699" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is a canonical question for &lt;em&gt;JavaScript asynchronicity&lt;/em&gt;. Feel free to improve this question and add more simplified examples which the community can identify with.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Это канонический вопрос для &lt;em&gt;асинхронности JavaScript&lt;/em&gt; . Не стесняйтесь улучшать этот вопрос и добавлять более упрощенные примеры, с которыми сообщество может идентифицировать.</target>
        </trans-unit>
        <trans-unit id="8fe8260d2797d89dec2d4d73b3d6171752b44d37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;async/await&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;async/await&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a0135ab690b1a17b0530e20999de06043814128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery &lt;a href=&quot;http://api.jquery.com/category/deferred-object/&quot;&gt;Deferreds&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery &lt;a href=&quot;http://api.jquery.com/category/deferred-object/&quot;&gt;Deferreds&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dbe2dc81e7b8f642b5949e87b7c1af8324d0995c" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;* Technically you can use &lt;code&gt;eval()&lt;/code&gt; as well, but &lt;a href=&quot;https://stackoverflow.com/questions/86513/why-is-using-the-javascript-eval-function-a-bad-idea&quot;&gt;&lt;code&gt;eval()&lt;/code&gt; is evil&lt;/a&gt; for this purpose&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;* Технически вы также можете использовать &lt;code&gt;eval()&lt;/code&gt; , но &lt;a href=&quot;https://stackoverflow.com/questions/86513/why-is-using-the-javascript-eval-function-a-bad-idea&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; является злом&lt;/a&gt; для этой цели&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="193eae364dc628fc092cd8ef11b86139f36c9a36" translate="yes" xml:space="preserve">
          <source>@Benjamin Gruenbaum has also put a lot of effort explaining asynchronicity in the same thread.</source>
          <target state="translated">@Benjamin Gruenbaum также приложил много усилий,объясняя асинхроничность в одной нити.</target>
        </trans-unit>
        <trans-unit id="2616531e447d36623971529ada2669d82436aed6" translate="yes" xml:space="preserve">
          <source>All ajax calls (including the &lt;code&gt;$.get&lt;/code&gt; or &lt;code&gt;$.post&lt;/code&gt; or &lt;code&gt;$.ajax&lt;/code&gt;) are asynchronous.</source>
          <target state="translated">Все вызовы ajax (включая &lt;code&gt;$.get&lt;/code&gt; или &lt;code&gt;$.post&lt;/code&gt; или &lt;code&gt;$.ajax&lt;/code&gt; ) являются асинхронными.</target>
        </trans-unit>
        <trans-unit id="2a0a37ac5b8e47801b9f45a88a68c9a89cad5b91" translate="yes" xml:space="preserve">
          <source>All the code that depends on the asynchronous calls, is moved inside the asynchronous block, or by waiting on the asynchronous calls.</source>
          <target state="translated">Весь код,который зависит от асинхронных вызовов,перемещается внутри асинхронного блока,или путем ожидания асинхронных вызовов.</target>
        </trans-unit>
        <trans-unit id="1fb9670113b1c96e286f81efab4da12bc3d0e7ca" translate="yes" xml:space="preserve">
          <source>Although there are ways to keep the &lt;a href=&quot;http://callbackhell.com/&quot;&gt;callback hell&lt;/a&gt; at bay with vanilla JS, promises are growing in popularity and are currently being standardized in ES6 (see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise - MDN&lt;/a&gt;).</source>
          <target state="translated">Несмотря на то, что с помощью vanilla JS существуют способы, позволяющие не допускать &lt;a href=&quot;http://callbackhell.com/&quot;&gt;обратного вызова&lt;/a&gt; , все более популярными становятся обещания, которые в настоящее время стандартизируются в ES6 (см. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise - MDN&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3351fcf6c12d50fc0ac88805069aea142f975b54" translate="yes" xml:space="preserve">
          <source>An Analogy...</source>
          <target state="translated">Аналогия...</target>
        </trans-unit>
        <trans-unit id="5ab84d7fcdf6fb1318fe079454de14bc2e9d8e11" translate="yes" xml:space="preserve">
          <source>And I sat there and waited. And waited. And waited. For 40 minutes. Doing nothing but waiting. Eventually, Bob gave me the information, we hung up, and I completed my report. But I'd lost 40 minutes of productivity.</source>
          <target state="translated">И я сидел и ждал.И ждал.И ждал.40 минут.Не делая ничего,кроме как ждать.В конце концов,Боб дал мне информацию,мы повесили трубку,и я закончил свой отчет.Но я потерял 40 минут продуктивности.</target>
        </trans-unit>
        <trans-unit id="fda44874bfa419ff03d6f65b066d614159b645b1" translate="yes" xml:space="preserve">
          <source>Asynchronous execution is pushed out of the synchronous flow. That is, the asynchronous code will &lt;strong&gt;never&lt;/strong&gt; execute while the synchronous code stack is executing. This is the meaning of JavaScript being single-threaded.</source>
          <target state="translated">Асинхронное выполнение выталкивается из синхронного потока. То есть асинхронный код &lt;strong&gt;никогда не&lt;/strong&gt; будет выполняться во время выполнения стека синхронного кода. Это означает, что JavaScript является однопоточным.</target>
        </trans-unit>
        <trans-unit id="3eaa02daa9e2fa7476ef359c4e92ddb36ff3ccfa" translate="yes" xml:space="preserve">
          <source>Asynchronous functions be like...</source>
          <target state="translated">Асинхронные функции-это как...</target>
        </trans-unit>
        <trans-unit id="43f59b64684b4ec6e77bc10459d2c89df596e351" translate="yes" xml:space="preserve">
          <source>At this point, I hung up the phone. Since I needed information from Bob to complete my report, I left the report and went for a coffee instead, then I caught up on some email. 40 minutes later (Bob is slow), Bob called back and gave me the information I needed. At this point, I resumed my work with my report, as I had all the information I needed.</source>
          <target state="translated">В этот момент я повесил трубку.Так как мне нужна была информация от Боба,чтобы закончить отчет,я оставил отчет и вместо этого пошел выпить кофе,а потом наткнулся на какую-то электронную почту.Через 40 минут (Боб медленный)Боб перезвонил и дал мне нужную информацию.На этом этапе я возобновил работу с отчетом,так как у меня была вся необходимая информация.</target>
        </trans-unit>
        <trans-unit id="b103b8d3480de02206ccf798fcaa01817ae2396c" translate="yes" xml:space="preserve">
          <source>Code snippet of the above example:</source>
          <target state="translated">Кодовый фрагмент вышеприведенного примера:</target>
        </trans-unit>
        <trans-unit id="d268a2e26266d8a732fbf03fc545f77a1511cad7" translate="yes" xml:space="preserve">
          <source>Considering your example</source>
          <target state="translated">Рассматривая ваш пример</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="4161388d0bc1d4981fe7e703476edf485adb1e23" translate="yes" xml:space="preserve">
          <source>Forewords</source>
          <target state="translated">Forewords</target>
        </trans-unit>
        <trans-unit id="9ff1e84bc1df7325df3d395b27e23dde1e64014a" translate="yes" xml:space="preserve">
          <source>Given the following examples, why is &lt;code&gt;outerScopeVar&lt;/code&gt; undefined in all cases?</source>
          <target state="translated">Учитывая следующие примеры, почему &lt;code&gt;outerScopeVar&lt;/code&gt; не определен во всех случаях?</target>
        </trans-unit>
        <trans-unit id="90acfeac32c622ee5ef1932cf600a7a4910a15ba" translate="yes" xml:space="preserve">
          <source>Here the timeout event plays the role, which will invoke the handler after the specified time. Here it is &lt;code&gt;0&lt;/code&gt;, but still it registers an asynchronous event it will be added to the last position of the &lt;code&gt;Event Queue&lt;/code&gt; for execution, which makes the guaranteed delay.</source>
          <target state="translated">Здесь роль тайм-аута играет роль, которая вызовет обработчик по истечении указанного времени. Здесь оно равно &lt;code&gt;0&lt;/code&gt; , но все же оно регистрирует асинхронное событие, которое будет добавлено к последней позиции &lt;code&gt;Event Queue&lt;/code&gt; для выполнения, что обеспечивает гарантированную задержку.</target>
        </trans-unit>
        <trans-unit id="c0ccb8fb1c710d25514aa41de1cf403d4866d1fc" translate="yes" xml:space="preserve">
          <source>Here we register an eventlistner which will be executed upon that particular event.Here loading of image.Then the current execution continuous with next lines &lt;code&gt;img.src = 'lolcat.png';&lt;/code&gt; and &lt;code&gt;alert(outerScopeVar);&lt;/code&gt; meanwhile the event may not occur. i.e, funtion &lt;code&gt;img.onload&lt;/code&gt; wait for the referred image to load, asynchrously. This will happen all the folowing example- the event may differ.</source>
          <target state="translated">Здесь мы регистрируем список событий, который будет выполняться при этом конкретном событии. Здесь происходит загрузка изображения. Затем текущее выполнение продолжается со следующими строками &lt;code&gt;img.src = 'lolcat.png';&lt;/code&gt; и &lt;code&gt;alert(outerScopeVar);&lt;/code&gt; Между тем событие может не произойти. т.е. функция &lt;code&gt;img.onload&lt;/code&gt; ожидает асинхронной загрузки указанного изображения. Это произойдет во всех следующих примерах - событие может отличаться.</target>
        </trans-unit>
        <trans-unit id="9513c4fd164bc6e4b493627615a49084822fe3c0" translate="yes" xml:space="preserve">
          <source>Here's a more concise answer for people that are looking for a quick reference as well as some examples using promises and async/await.</source>
          <target state="translated">Вот более лаконичный ответ для людей,которые ищут краткое руководство,а также несколько примеров использования обещаний и асинкаваит.</target>
        </trans-unit>
        <trans-unit id="b6008160b60a5356b4ee831a5e643f9f9bec0f29" translate="yes" xml:space="preserve">
          <source>How do I keep my caller waiting?</source>
          <target state="translated">Как заставить моего звонящего ждать?</target>
        </trans-unit>
        <trans-unit id="5376e14e843406f61ac87403197fd8d1d7434c5e" translate="yes" xml:space="preserve">
          <source>However, we now know that the &lt;code&gt;return outerScopeVar&lt;/code&gt; happens immediately; before the &lt;code&gt;onload&lt;/code&gt; callback function has updated the variable. This leads to &lt;code&gt;getWidthOfImage()&lt;/code&gt; returning &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;undefined&lt;/code&gt; being alerted.</source>
          <target state="translated">Однако теперь мы знаем, что &lt;code&gt;return outerScopeVar&lt;/code&gt; происходит немедленно; до того, как функция обратного вызова &lt;code&gt;onload&lt;/code&gt; обновила переменную. Это приводит к тому, что &lt;code&gt;getWidthOfImage()&lt;/code&gt; возвращает &lt;code&gt;undefined&lt;/code&gt; и &lt;code&gt;undefined&lt;/code&gt; получении предупреждения.</target>
        </trans-unit>
        <trans-unit id="e6239a14687cbf4f9e4e299f4f10e3f1d0d8290b" translate="yes" xml:space="preserve">
          <source>I want to turn this question into a canonical topic to answer asynchronicity issues which are unrelated to Ajax (there is &lt;a href=&quot;https://stackoverflow.com/q/14220321/1331430&quot;&gt;How to return the response from an AJAX call?&lt;/a&gt; for that), hence this topic needs your help to be as good and helpful as possible!</source>
          <target state="translated">Я хочу превратить этот вопрос в каноническую тему, чтобы ответить на вопросы асинхронности, которые не связаны с Ajax (для этого есть &lt;a href=&quot;https://stackoverflow.com/q/14220321/1331430&quot;&gt;ответ Как&lt;/a&gt; ответить на вызов AJAX? ), Поэтому эта тема нуждается в вашей помощи, чтобы быть как можно более полезной и полезной !</target>
        </trans-unit>
        <trans-unit id="c6867acba73dcc3d63f6f6a677d4a3c0f03b6e0a" translate="yes" xml:space="preserve">
          <source>If your JavaScript environment includes support for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; (like Node.js 7.6+), then you can use promises synchronously within &lt;code&gt;async&lt;/code&gt; functions:</source>
          <target state="translated">Если ваша среда JavaScript включает поддержку &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; (например, Node.js 7.6+), то вы можете синхронно использовать обещания в &lt;code&gt;async&lt;/code&gt; функциях:</target>
        </trans-unit>
        <trans-unit id="cbe7623af9f69417f8c30820f0ea3f8da88b935e" translate="yes" xml:space="preserve">
          <source>Imagine if the conversation had gone like this instead;</source>
          <target state="translated">Представь себе,если бы разговор прошел так,как сейчас;</target>
        </trans-unit>
        <trans-unit id="d94c2a88c0873ea1bc503304b1c42af08fccd5f4" translate="yes" xml:space="preserve">
          <source>Implementing your own callback logic</source>
          <target state="translated">Реализация собственной логики обратного вызова</target>
        </trans-unit>
        <trans-unit id="19eaef30713ec40985dd7ae805fde594db8f511d" translate="yes" xml:space="preserve">
          <source>In all cases, we have a callback which may run &lt;em&gt;sometime in the future&lt;/em&gt;. This &quot;sometime in the future&quot; is what we refer to as &lt;strong&gt;asynchronous flow&lt;/strong&gt;.</source>
          <target state="translated">Во всех случаях у нас есть обратный вызов, который может быть запущен &lt;em&gt;когда-нибудь в будущем&lt;/em&gt; . Это &amp;laquo;когда-нибудь в будущем&amp;raquo; мы называем &lt;strong&gt;асинхронным потоком&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="135bd88cbd59b18dc1f9b7be855f8e4fa92e1f0e" translate="yes" xml:space="preserve">
          <source>In all these scenarios &lt;code&gt;outerScopeVar&lt;/code&gt; is modified or assigned a value &lt;strong&gt;asynchronously&lt;/strong&gt; or &lt;strong&gt;happening in a later time(waiting or listening for some event to occur),for which the current execution will not wait&lt;/strong&gt;.So all these cases current execution flow results in &lt;code&gt;outerScopeVar = undefined&lt;/code&gt;</source>
          <target state="translated">Во всех этих сценариях &lt;code&gt;outerScopeVar&lt;/code&gt; изменяется или присваивается значение &lt;strong&gt;асинхронно&lt;/strong&gt; или &lt;strong&gt;происходит в более позднее время (ожидание или прослушивание какого-либо события), для которого текущее выполнение не будет ждать. Так&lt;/strong&gt; что во всех этих случаях текущий поток выполнения приводит к &lt;code&gt;outerScopeVar = undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dfc2217afad206d82ab1c489045154e363b8cd2a" translate="yes" xml:space="preserve">
          <source>In order to fix our code, all we have to do is move the &lt;code&gt;alert(outerScopeVar)&lt;/code&gt; code &lt;em&gt;into&lt;/em&gt; the callback function. As a consequence of this, we no longer need the &lt;code&gt;outerScopeVar&lt;/code&gt; variable declared as a global variable.</source>
          <target state="translated">Чтобы исправить наш код, все, что нам нужно сделать, это переместить код &lt;code&gt;alert(outerScopeVar)&lt;/code&gt; &lt;em&gt;в&lt;/em&gt; функцию обратного вызова. Как следствие этого нам больше не нужна переменная &lt;code&gt;outerScopeVar&lt;/code&gt; объявленная как глобальная переменная.</target>
        </trans-unit>
        <trans-unit id="219fa966e4403c99f93745961a66347fdd6ee889" translate="yes" xml:space="preserve">
          <source>In real life scenario, the code becomes,</source>
          <target state="translated">В реальной жизни код становится,</target>
        </trans-unit>
        <trans-unit id="729a2882bffa8796d64097b884d3520508f6cc3c" translate="yes" xml:space="preserve">
          <source>In short, the callback functions are created synchronously but executed asynchronously. You just can't rely on the execution of an asynchronous function until you know it has executed, and how to do that?</source>
          <target state="translated">Короче говоря,функции обратного вызова создаются синхронно,но выполняются асинхронно.Вы просто не можете полагаться на выполнение асинхронной функции,пока не узнаете,что она выполнена,и как это сделать?</target>
        </trans-unit>
        <trans-unit id="c30a8d270de5576c077f0fa84b762b1e781bf74b" translate="yes" xml:space="preserve">
          <source>In the code above, we're asking JavaScript to load &lt;code&gt;lolcat.png&lt;/code&gt;, which is a &lt;em&gt;sloooow&lt;/em&gt; operation. The callback function will be executed once this slow operation has done, but in the meantime, JavaScript will keep processing the next lines of code; i.e. &lt;code&gt;alert(outerScopeVar)&lt;/code&gt;.</source>
          <target state="translated">В приведенном выше коде мы просим JavaScript загрузить &lt;code&gt;lolcat.png&lt;/code&gt; , который представляет собой операцию &lt;em&gt;sloooow&lt;/em&gt; . Функция обратного вызова будет выполнена после выполнения этой медленной операции, но в то же время JavaScript продолжит обрабатывать следующие строки кода; т.е. &lt;code&gt;alert(outerScopeVar)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41d2083ae42e2602204895d28ef21aeaac582cb0" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;return&lt;/code&gt;ing a value from an asynchronous callback, you will have to make use of the callback pattern, or... Promises.</source>
          <target state="translated">Вместо того, чтобы &lt;code&gt;return&lt;/code&gt; значение из асинхронного обратного вызова, вам придется использовать шаблон обратного вызова или ... Обещания.</target>
        </trans-unit>
        <trans-unit id="0cc7a9dd54f8bbb52fefe95aa868d2fb8e4076e2" translate="yes" xml:space="preserve">
          <source>It depends on the case. Let's try to trace some common behavior again:</source>
          <target state="translated">Это зависит от случая.Давайте попробуем еще раз проследить какое-нибудь обычное поведение:</target>
        </trans-unit>
        <trans-unit id="fb2ea5baac3ad36c938aef8df244432e62524de2" translate="yes" xml:space="preserve">
          <source>It is simple, really. The logic that depends on the asynchronous function execution should be started/called from inside this asynchronous function. For example, moving the &lt;code&gt;alert&lt;/code&gt;s and &lt;code&gt;console.log&lt;/code&gt;s too inside the callback function would output the expected result, because the result is available at that point.</source>
          <target state="translated">Это действительно просто. Логика, которая зависит от выполнения асинхронной функции, должна запускаться / вызываться изнутри этой асинхронной функции. Например, перемещение &lt;code&gt;alert&lt;/code&gt; s и &lt;code&gt;console.log&lt;/code&gt; s внутри функции обратного вызова приведет к получению ожидаемого результата, поскольку результат доступен в этой точке.</target>
        </trans-unit>
        <trans-unit id="f833c4bc8e7973b5c0788881a871357c0b979a45" translate="yes" xml:space="preserve">
          <source>JavaScript Promises - HTML5 Rocks</source>
          <target state="translated">JavaScript Promises-HTML5 Rocks</target>
        </trans-unit>
        <trans-unit id="7e1a19f21ecf74a20fd1fc528e7a374bc5f9c8d9" translate="yes" xml:space="preserve">
          <source>Let's discuss each examples(I marked the portion which is called asynchronously or delayed for some events to occur):</source>
          <target state="translated">Рассмотрим каждый пример (я отметил ту часть,которая называется асинхронно или задерживается,чтобы произошли какие-то события):</target>
        </trans-unit>
        <trans-unit id="638c1153b14aa1b9d097c6dcdd2c2f61b8c583bf" translate="yes" xml:space="preserve">
          <source>Let's tackle it implementing a callback system of our own. First off, we get rid of that ugly &lt;code&gt;outerScopeVar&lt;/code&gt; which is completely useless in this case. Then we add a parameter which accepts a function argument, our callback. When the asynchronous operation finishes, we call this callback passing the result. The implementation (please read the comments in order):</source>
          <target state="translated">Давайте рассмотрим реализацию собственной системы обратного вызова. Прежде всего, мы избавляемся от того уродливого &lt;code&gt;outerScopeVar&lt;/code&gt; который в этом случае совершенно бесполезен. Затем мы добавляем параметр, который принимает аргумент функции, наш обратный вызов. Когда асинхронная операция заканчивается, мы вызываем этот обратный вызов, передавая результат. Реализация (пожалуйста, прочитайте комментарии по порядку):</target>
        </trans-unit>
        <trans-unit id="487666eb364c70eb737ac6495aa0ccd4f8d13ba0" translate="yes" xml:space="preserve">
          <source>Let's trace the common behavior first. In all examples, the &lt;code&gt;outerScopeVar&lt;/code&gt; is modified inside of a &lt;em&gt;function&lt;/em&gt;. That function is clearly not executed immediately, it is being assigned or passed as an argument. That is what we call a &lt;strong&gt;&lt;em&gt;callback&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">Давайте сначала проследим общее поведение. Во всех примерах &lt;code&gt;outerScopeVar&lt;/code&gt; изменяется внутри &lt;em&gt;функции&lt;/em&gt; . Эта функция явно не выполняется сразу, она присваивается или передается в качестве аргумента. Это то, что мы называем &lt;strong&gt;&lt;em&gt;обратным вызовом&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7adf46b8af10f9ffba635ac39fa32e59eedd72ea" translate="yes" xml:space="preserve">
          <source>Lets say that the post request takes 10 seconds to complete, the value of &lt;code&gt;outerScopeVar&lt;/code&gt; will only be set after those 10 seconds.</source>
          <target state="translated">Допустим, что пост-запрос занимает 10 секунд, значение &lt;code&gt;outerScopeVar&lt;/code&gt; будет установлено только после этих 10 секунд.</target>
        </trans-unit>
        <trans-unit id="2cd4cb675addf1e7a7a8765c722dcd18f39a2b27" translate="yes" xml:space="preserve">
          <source>More reading material about JavaScript asynchronicity</source>
          <target state="translated">Дополнительный материал для чтения об асинхронизме JavaScript</target>
        </trans-unit>
        <trans-unit id="36f8fb94265b7a738324676d4ddedf0f7f8be952" translate="yes" xml:space="preserve">
          <source>More specifically, when the JS engine is idle -- not executing a stack of (a)synchronous code -- it will poll for events that may have triggered asynchronous callbacks (e.g. expired timeout, received network response) and execute them one after another. This is regarded as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop&quot;&gt;Event Loop&lt;/a&gt;.</source>
          <target state="translated">Более конкретно, когда механизм JS находится в режиме ожидания, не выполняя стек (a) синхронного кода, он будет запрашивать события, которые могли вызвать асинхронные обратные вызовы (например, истекло время ожидания, полученный сетевой ответ), и выполнять их один за другим. Это рассматривается как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop&quot;&gt;Event Loop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="027fcce6dca0e5452f5c3ae77d3776d83b9cb117" translate="yes" xml:space="preserve">
          <source>Most often in real use cases, the DOM API and most libraries already provide the callback functionality (the &lt;code&gt;helloCatAsync&lt;/code&gt; implementation in this demonstrative example). You only need to pass the callback function and understand that it will execute out of the synchronous flow, and restructure your code to accommodate for that.</source>
          <target state="translated">Чаще всего в реальных случаях использования DOM API и большинство библиотек уже предоставляют функциональность обратного вызова (реализация &lt;code&gt;helloCatAsync&lt;/code&gt; в этом демонстрационном примере). Вам нужно только передать функцию обратного вызова и понять, что она будет выполняться вне синхронного потока, и реструктурировать свой код, чтобы приспособиться к этому.</target>
        </trans-unit>
        <trans-unit id="0dcfbb375ba4904c46d6dce14e7309a4eb9988dc" translate="yes" xml:space="preserve">
          <source>Node can be consider as a king of asynchronous coding.Here the marked function is registered as a callback handler which will be executed after reading the specified file.</source>
          <target state="translated">Узел можно рассматривать как король асинхронного кодирования,здесь помеченная функция регистрируется как обработчик обратного вызова,который будет выполнен после прочтения указанного файла.</target>
        </trans-unit>
        <trans-unit id="b216c6131cd7d019cbd3e050a3a8d93e5b049385" translate="yes" xml:space="preserve">
          <source>Node.js's &lt;code&gt;fs.readFile&lt;/code&gt; may be called &lt;em&gt;sometime in the future&lt;/em&gt;, when the file has been read successfully or thrown an error.</source>
          <target state="translated">&lt;code&gt;fs.readFile&lt;/code&gt; Node.js может быть вызван &lt;em&gt;в будущем&lt;/em&gt; , когда файл будет успешно прочитан или возникла ошибка.</target>
        </trans-unit>
        <trans-unit id="edba6c23726045806eaa1d7bc5d696075358f973" translate="yes" xml:space="preserve">
          <source>Now the question is, when is that callback called?</source>
          <target state="translated">Теперь вопрос в том,когда звонят по обратному вызову?</target>
        </trans-unit>
        <trans-unit id="6cdece044e170983c1f5cab467ce941e2ddd0dde" translate="yes" xml:space="preserve">
          <source>Now when you execute this, you would get an alert on line 3. Now wait for some time until you are sure the post request has returned some value. Then when you click OK, on the alert box, next alert would print the expected value, because you waited for it.</source>
          <target state="translated">Теперь,когда вы выполните это,вы получите предупреждение на третьей линии.Теперь подождите некоторое время,пока не убедитесь,что почтовый запрос вернул некоторое значение.Затем,когда вы нажмете OK в поле alert (предупреждение),следующее предупреждение распечатает ожидаемое значение,потому что вы ждали его.</target>
        </trans-unit>
        <trans-unit id="8f7e7c308a72af2805417b772be3373d55f7aa67" translate="yes" xml:space="preserve">
          <source>Obvious promise (something will be done in future) is asynchronous. see &lt;a href=&quot;https://stackoverflow.com/questions/6801283/what-are-the-differences-between-deferred-promise-and-future-in-javascript&quot;&gt;What are the differences between Deferred, Promise and Future in JavaScript?&lt;/a&gt;</source>
          <target state="translated">Очевидное обещание (что-то будет сделано в будущем) является асинхронным. см. В &lt;a href=&quot;https://stackoverflow.com/questions/6801283/what-are-the-differences-between-deferred-promise-and-future-in-javascript&quot;&gt;чем разница между отложенным, обещанием и будущим в JavaScript?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="acfa95439c5b3dfbc3f590cb3d6cbc5140d0725d" translate="yes" xml:space="preserve">
          <source>Often you need to do more things with the result from an asynchronous function or do different things with the result depending on where the asynchronous function has been called. Let's tackle a bit more complex example:</source>
          <target state="translated">Часто нужно делать больше вещей с результатом от асинхронной функции или делать различные вещи с результатом в зависимости от того,где была вызвана асинхронная функция.Рассмотрим более сложный пример:</target>
        </trans-unit>
        <trans-unit id="69aae8a529faeef3bf34a8f29a9aeb27faa6c60a" translate="yes" xml:space="preserve">
          <source>One word answer: &lt;strong&gt;asynchronicity&lt;/strong&gt;.</source>
          <target state="translated">Одним словом ответ: &lt;strong&gt;асинхронность&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b1d472e424c03ff52490d1edc8a0e23f95babb92" translate="yes" xml:space="preserve">
          <source>Promises</source>
          <target state="translated">Promises</target>
        </trans-unit>
        <trans-unit id="6d9d164125b7cac2630c27b4a009417447162bf7" translate="yes" xml:space="preserve">
          <source>Promises (a.k.a. Futures) provide a more linear, and thus pleasant, reading of the asynchronous code, but explaining their entire functionality is out of the scope of this question. Instead, I'll leave these excellent resources for the interested:</source>
          <target state="translated">Обещания (так же известные как Futures)обеспечивают более линейное,а значит и приятное чтение асинхронного кода,но объяснение всей их функциональности выходит за рамки этого вопроса.Вместо этого я оставлю эти отличные ресурсы для заинтересованных лиц:</target>
        </trans-unit>
        <trans-unit id="cb68ff088476aec4be87b92843cdbef82052867f" translate="yes" xml:space="preserve">
          <source>Promises provide an alternative which is more flexible than callbacks because they can be naturally combined to coordinate multiple async operations. A &lt;a href=&quot;https://promisesaplus.com/&quot;&gt;Promises/A+&lt;/a&gt; standard implementation is natively provided in node.js (0.12+) and many current browsers, but is also implemented in libraries like &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;Bluebird&lt;/a&gt; and &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt;.</source>
          <target state="translated">Обещания предоставляют альтернативу, которая является более гибкой, чем обратные вызовы, поскольку их можно естественным образом объединить для координации нескольких асинхронных операций. Стандартная реализация &lt;a href=&quot;https://promisesaplus.com/&quot;&gt;Promises / A +&lt;/a&gt; изначально предоставляется в node.js (0.12+) и многих современных браузерах, но также реализована в библиотеках, таких как &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;Bluebird&lt;/a&gt; и &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d7c2ad2dddc44dedd1e96fb0db1f59589562e3c" translate="yes" xml:space="preserve">
          <source>Rather than &lt;em&gt;waiting&lt;/em&gt; for these slow operations to complete, JavaScript lets you register a callback function which will be executed when the slow operation has completed. In the meantime, however, JavaScript will continue to execute other code. The fact that JavaScript executes &lt;em&gt;other code&lt;/em&gt; whilst waiting for the slow operation to complete makes the behavior&lt;strong&gt;asynchronous&lt;/strong&gt;. Had JavaScript waited around for the operation to complete before executing any other code, this would have been &lt;strong&gt;synchronous&lt;/strong&gt; behavior.</source>
          <target state="translated">Вместо &lt;em&gt;ожидания&lt;/em&gt; завершения этих медленных операций JavaScript позволяет зарегистрировать функцию обратного вызова, которая будет выполнена после завершения медленной операции. Тем временем, однако, JavaScript продолжит выполнять другой код. Тот факт, что JavaScript выполняет &lt;em&gt;другой код&lt;/em&gt; , ожидая завершения медленной операции, делает поведение &lt;strong&gt;асинхронным&lt;/strong&gt; . Если бы JavaScript ожидал завершения операции перед выполнением любого другого кода, это было бы &lt;strong&gt;синхронным&lt;/strong&gt; поведением.</target>
        </trans-unit>
        <trans-unit id="8f3fc1e296aaa81836928351f23624856a1de71b" translate="yes" xml:space="preserve">
          <source>Start with the naive approach (that doesn't work) for a function that calls an asynchronous method (in this case &lt;code&gt;setTimeout&lt;/code&gt;) and returns a message:</source>
          <target state="translated">Начните с наивного подхода (который не работает) для функции, которая вызывает асинхронный метод (в данном случае &lt;code&gt;setTimeout&lt;/code&gt; ) и возвращает сообщение:</target>
        </trans-unit>
        <trans-unit id="fb0e4798cb170cfc40f0368e44f763affdfd54e9" translate="yes" xml:space="preserve">
          <source>That is, the asynchronous code highlighted in the hand-drawn red shapes may execute only after all the remaining synchronous code in their respective code blocks have executed:</source>
          <target state="translated">То есть,асинхронный код,выделенный красным цветом нарисованным вручную,может быть выполнен только после того,как будут выполнены все остальные синхронные коды в соответствующих блоках кода:</target>
        </trans-unit>
        <trans-unit id="0a9be42f4d2ec4950f69e0eb67c25bd4ebaa41c0" translate="yes" xml:space="preserve">
          <source>The answer to the question at hand</source>
          <target state="translated">Ответ на рассматриваемый вопрос</target>
        </trans-unit>
        <trans-unit id="0f58e0d8b311cbdc96d07934de3ac62c55d87691" translate="yes" xml:space="preserve">
          <source>The change here is that &lt;code&gt;getMessage&lt;/code&gt; accepts a &lt;code&gt;callback&lt;/code&gt; parameter that will be called to deliver the results back to the calling code once available.</source>
          <target state="translated">Изменение здесь в том, что &lt;code&gt;getMessage&lt;/code&gt; принимает параметр &lt;code&gt;callback&lt;/code&gt; который будет вызываться для доставки результатов обратно в вызывающий код, когда он станет доступен.</target>
        </trans-unit>
        <trans-unit id="dfbc4999399aec4a2d69483e59a7728ba63f4f53" translate="yes" xml:space="preserve">
          <source>The code execution starts from line 1, declares the variable and triggers and asynchronous call on line 2, (i.e., the post request) and it continues its execution from line 3, without waiting for the post request to complete its execution.</source>
          <target state="translated">Выполнение кода начинается со строки 1,объявляет переменную и запускает и асинхронный вызов на строке 2 (т.е.почтовый запрос)и продолжает выполнение из строки 3,не дожидаясь завершения выполнения почтового запроса.</target>
        </trans-unit>
        <trans-unit id="9d15198b66c44aa363b53458036280b399cb3f48" translate="yes" xml:space="preserve">
          <source>The other answers are excellent and I just want to provide a straight forward answer to this. Just limiting to jQuery asynchronous calls</source>
          <target state="translated">Остальные ответы превосходны,и я просто хочу дать прямой ответ на этот вопрос.Просто ограничусь асинхронными звонками jQuery.</target>
        </trans-unit>
        <trans-unit id="d52589835b03cdf8d7ac3617f883151bd0f44bc6" translate="yes" xml:space="preserve">
          <source>The two main ways to solve it are using &lt;strong&gt;callbacks&lt;/strong&gt; and &lt;strong&gt;promises&lt;/strong&gt;:</source>
          <target state="translated">Два основных способа решить эту проблему - использовать &lt;strong&gt;обратные вызовы&lt;/strong&gt; и &lt;strong&gt;обещания&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4f5b392d075945718f406191e510986ae67301e9" translate="yes" xml:space="preserve">
          <source>Therefore, in all of our examples, the &lt;code&gt;function() { /* Do something */ }&lt;/code&gt; is the callback; to fix &lt;strong&gt;all&lt;/strong&gt; the examples, all we have to do is move the code which needs the response of the operation into there!</source>
          <target state="translated">Поэтому во всех наших примерах &lt;code&gt;function() { /* Do something */ }&lt;/code&gt; является обратным вызовом; чтобы исправить &lt;strong&gt;все&lt;/strong&gt; примеры, все, что нам нужно сделать, это переместить туда код, который нуждается в ответе операции!</target>
        </trans-unit>
        <trans-unit id="91fe005c7b9a8de24f4645e8f363dbc2e0529353" translate="yes" xml:space="preserve">
          <source>This example clearly suffers from the same issue as the other examples, it is not waiting until the asynchronous function executes.</source>
          <target state="translated">Этот пример явно страдает от той же проблемы,что и другие примеры,он не ждет,пока асинхронная функция выполнится.</target>
        </trans-unit>
        <trans-unit id="ffac965ab18c7d09429e1769cd6077e8cb88d4ef" translate="yes" xml:space="preserve">
          <source>This is asynchronous vs. synchronous behavior</source>
          <target state="translated">Это асинхронное поведение против синхронного.</target>
        </trans-unit>
        <trans-unit id="4a9f0c688c7a4ad3c6e910681cbfa516c1908817" translate="yes" xml:space="preserve">
          <source>This is exactly what is happening in all the examples in our question. Loading an image, loading a file off disk, and requesting a page via AJAX are all slow operations (in the context of modern computing).</source>
          <target state="translated">Это именно то,что происходит во всех примерах нашего вопроса.Загрузка образа,загрузка файла с диска и запрос страницы через AJAX-все это медленные операции (в контексте современных вычислений).</target>
        </trans-unit>
        <trans-unit id="f707894961ab83a7c6e333b28e7f9931e3824aa4" translate="yes" xml:space="preserve">
          <source>This is why we see the alert showing &lt;code&gt;undefined&lt;/code&gt;; since the &lt;code&gt;alert()&lt;/code&gt; is processed immediately, rather than after the image has been loaded.</source>
          <target state="translated">Вот почему мы видим предупреждение, показывающее &lt;code&gt;undefined&lt;/code&gt; ; так как &lt;code&gt;alert()&lt;/code&gt; обрабатывается сразу, а не после загрузки изображения.</target>
        </trans-unit>
        <trans-unit id="f2e10d930e731050a7b6c7e2eaf695b3876a9b2e" translate="yes" xml:space="preserve">
          <source>This time ajax callback.</source>
          <target state="translated">На этот раз Аякс перезвонил.</target>
        </trans-unit>
        <trans-unit id="42b9aece256629e1f3ae7fd0b418fdce8ba1bf5d" translate="yes" xml:space="preserve">
          <source>This topic has been iterated at least a couple of thousands of times, here, in Stack Overflow. Hence, first off I'd like to point out some extremely useful resources:</source>
          <target state="translated">Эта тема была итерациирована как минимум пару тысяч раз,здесь,в Stack Overflow.Поэтому,во-первых,я хотел бы обратить внимание на некоторые чрезвычайно полезные ресурсы:</target>
        </trans-unit>
        <trans-unit id="b45bcc49f561af62860de0ba678026a934aa6d4c" translate="yes" xml:space="preserve">
          <source>To fix this, we need to allow the function calling &lt;code&gt;getWidthOfImage()&lt;/code&gt; to register a callback, then move the alert'ing of the width to be within that callback;</source>
          <target state="translated">Чтобы это исправить, нам нужно разрешить функции, вызывающей &lt;code&gt;getWidthOfImage()&lt;/code&gt; зарегистрировать обратный вызов, а затем переместить оповещение ширины в этот обратный вызов;</target>
        </trans-unit>
        <trans-unit id="efd3968d8235a10f87b53e88a27d4485fcc5fe25" translate="yes" xml:space="preserve">
          <source>To state the obvious, the cup represents &lt;code&gt;outerScopeVar&lt;/code&gt;.</source>
          <target state="translated">Чтобы утверждать очевидное, чашка представляет &lt;code&gt;outerScopeVar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4db799b398211e889d65554156059060d81f356d" translate="yes" xml:space="preserve">
          <source>To try out,</source>
          <target state="translated">Чтобы попробовать,</target>
        </trans-unit>
        <trans-unit id="90422ad2e2bbc1c8f4a48927d8b73dd5160a2e66" translate="yes" xml:space="preserve">
          <source>Why does it output &lt;code&gt;undefined&lt;/code&gt; in all of these examples? I don't want workarounds, I want to know &lt;strong&gt;why&lt;/strong&gt; this is happening.</source>
          <target state="translated">Почему он выводит &lt;code&gt;undefined&lt;/code&gt; во всех этих примерах? Я не хочу обходных путей, я хочу знать, &lt;strong&gt;почему&lt;/strong&gt; это происходит.</target>
        </trans-unit>
        <trans-unit id="c4936bc542e6ff5a21b7420fda279b793c156e24" translate="yes" xml:space="preserve">
          <source>Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference</source>
          <target state="translated">Почему моя переменная не изменяется после того,как я модифицирую ее внутри функции?-Асинхронная ссылка на код</target>
        </trans-unit>
        <trans-unit id="30c09e36d32f8aa50d9fd572ae75dfa8792e72cd" translate="yes" xml:space="preserve">
          <source>Yesterday, the work I was doing required some information from a colleague. I rang him up; here's how the conversation went:</source>
          <target state="translated">Вчера работа,которую я выполнял,требовала кое-какой информации от коллеги.Я позвонил ему,вот как прошел разговор:</target>
        </trans-unit>
        <trans-unit id="f1ced2ce1f9304e9a0ba78b790d5a22ededef908" translate="yes" xml:space="preserve">
          <source>You might currently have some code similar to this;</source>
          <target state="translated">В настоящее время у вас может быть какой-нибудь код,похожий на этот;</target>
        </trans-unit>
        <trans-unit id="f7b14f844f491cec253dffd6a2877e87891e6a62" translate="yes" xml:space="preserve">
          <source>You will also notice that due to the asynchronous nature, it is impossible to &lt;code&gt;return&lt;/code&gt; a value from an asynchronous flow back to the synchronous flow where the callback was defined, as the asynchronous callbacks are executed long after the synchronous code has already finished executing.</source>
          <target state="translated">Вы также заметите, что из-за асинхронного характера невозможно &lt;code&gt;return&lt;/code&gt; значение из асинхронного потока обратно в синхронный поток, где был определен обратный вызов, так как асинхронные обратные вызовы выполняются задолго после того, как синхронный код уже завершен.</target>
        </trans-unit>
        <trans-unit id="17990bb6c33a853fa89124957ec7cb0f2f107251" translate="yes" xml:space="preserve">
          <source>You'll &lt;strong&gt;&lt;em&gt;always&lt;/em&gt;&lt;/strong&gt; see a callback is specified as a function, because that's the only* way in JavaScript to define some code, but not execute it until later.</source>
          <target state="translated">Вы &lt;strong&gt;&lt;em&gt;всегда&lt;/em&gt;&lt;/strong&gt; увидите, что обратный вызов указан как функция, потому что это единственный * способ в JavaScript определить некоторый код, но не выполнять его до тех пор, пока он не будет выполнен позже.</target>
        </trans-unit>
        <trans-unit id="1a36ade9be4ed848a5cd8b84079e9715d403ca94" translate="yes" xml:space="preserve">
          <source>You're Missing the Point of Promises - domenic.me</source>
          <target state="translated">Ты пропускаешь &quot;Точку Обещаний&quot;-доминиканец.Я.</target>
        </trans-unit>
        <trans-unit id="ff168847efe383bab3ac7dd4c396db86055ad902" translate="yes" xml:space="preserve">
          <source>jQuery &lt;code&gt;$.post&lt;/code&gt;'s callback may be called &lt;em&gt;sometime in the future&lt;/em&gt;, when (and if) the Ajax request has been completed successfully.</source>
          <target state="translated">Обратный вызов jQuery &lt;code&gt;$.post&lt;/code&gt; может быть вызван &lt;em&gt;когда-нибудь в будущем&lt;/em&gt; , когда (и если) Ajax-запрос будет успешно выполнен.</target>
        </trans-unit>
        <trans-unit id="3506140f1030ab84b377ab6155325a3641104402" translate="yes" xml:space="preserve">
          <source>jQuery provides functionality that's similar to promises with its Deferreds.</source>
          <target state="translated">jQuery предоставляет функциональность,аналогичную обещаниям с Deferreds.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
