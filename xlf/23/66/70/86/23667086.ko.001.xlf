<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/23667086">
    <body>
      <group id="23667086">
        <trans-unit id="87e7945a2a6acfe9e9ac15c56656043a7d3eaa7b" translate="yes" xml:space="preserve">
          <source>... as before, note that we've been able to remove the global variables (in this case &lt;code&gt;width&lt;/code&gt;).</source>
          <target state="translated">... 전과 같이 전역 변수 (이 경우 &lt;code&gt;width&lt;/code&gt; )를 제거 할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="483231bd8f34a26d5113dd22f8c5212933edbb64" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/maxogden/art-of-node#callbacks&quot;&gt;The Art of Node - Callbacks&lt;/a&gt; explains asynchronous code and callbacks very well with vanilla JS examples and Node.js code as well.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/maxogden/art-of-node#callbacks&quot;&gt;Art of Node-Callbacks&lt;/a&gt; 는 바닐라 JS 예제와 Node.js 코드로 비동기 코드와 콜백에 대해 잘 설명합니다.</target>
        </trans-unit>
        <trans-unit id="18b6513dab89c1fe133131a6fb64518a7ba93ed0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/10058879/1331430&quot;&gt;@Matt Esch's answer to &quot;Get data from fs.readFile&quot;&lt;/a&gt; also explains asynchronicity extremely well in a simple manner.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/10058879/1331430&quot;&gt;&quot;fs.readFile에서 데이터 가져 오기&quot;에 대한 @Matt Esch의 답변&lt;/a&gt; 은 간단한 방식으로 비동기 성이 매우 잘 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cadc61baae72a97d1e69933c6cfd90e943dc7402" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/14220323/1331430&quot;&gt;@Felix Kling's answer to &quot;How do I return the response from an asynchronous call?&quot;&lt;/a&gt;. See his excellent answer explaining synchronous and asynchronous flows, as well as the &quot;Restructure code&quot; section.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/14220323/1331430&quot;&gt;&quot;비동기 호출에서 응답을 어떻게 반환합니까?&quot;에 대한 @Felix Kling의 답변&lt;/a&gt; . &quot;구조 코드&quot;섹션뿐만 아니라 동기식 및 비동기식 흐름을 설명하는 뛰어난 답변을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="34372c0e6cc14dd9b3b03232668d7110ae7f8856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;img.onload&lt;/code&gt; may be called &lt;em&gt;sometime in the future&lt;/em&gt;, when (and if) the image has successfully loaded.</source>
          <target state="translated">이미지가 성공적으로로드되면 &lt;em&gt;나중에&lt;/em&gt; &lt;code&gt;img.onload&lt;/code&gt; 가 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="68a8ea4de6a6afdbe9657f4ae00dcc062708d45f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setTimeout&lt;/code&gt; may be called &lt;em&gt;sometime in the future&lt;/em&gt;, after the delay has expired and the timeout hasn't been canceled by &lt;code&gt;clearTimeout&lt;/code&gt;. Note: even when using &lt;code&gt;0&lt;/code&gt; as delay, all browsers have a minimum timeout delay cap (specified to be 4ms in the HTML5 spec).</source>
          <target state="translated">&lt;code&gt;setTimeout&lt;/code&gt; 은 지연이 만료되고 &lt;code&gt;clearTimeout&lt;/code&gt; 에 의해 시간 초과가 취소되지 않은 이후에 &lt;em&gt;언젠가&lt;/em&gt; 호출 될 수 있습니다. 참고 : &lt;code&gt;0&lt;/code&gt; 을 지연으로 사용하더라도 모든 브라우저에는 최소 시간 초과 지연 제한이 있습니다 (HTML5 사양에서 4ms로 지정됨).</target>
        </trans-unit>
        <trans-unit id="0bfccf94f3ad9d7adee477872ae30a98032c0523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; gets logged in this case because &lt;code&gt;getMessage&lt;/code&gt; returns before the &lt;code&gt;setTimeout&lt;/code&gt; callback is called and updates &lt;code&gt;outerScopeVar&lt;/code&gt;.</source>
          <target state="translated">이 경우, &lt;code&gt;setTimeout&lt;/code&gt; 콜백이 호출되기 전에 &lt;code&gt;getMessage&lt;/code&gt; 가 반환되고 &lt;code&gt;outerScopeVar&lt;/code&gt; 가 업데이트되기 때문에 &lt;code&gt;undefined&lt;/code&gt; 가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="ed49b1097a751bc8dfb2f4fa8d5282592dce48f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Fabr&amp;iacute;cio's answer is spot on; but I wanted to complement his answer with something less technical, which focusses on an analogy to help explain the concept of asynchronicity&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Fabr&amp;iacute;cio의 대답은 바로 그 자리에 있습니다.&lt;/em&gt; &lt;em&gt;그러나 나는 그의 대답을 덜 기술적 인 것으로 보완하고 싶었다. 이것은 비 동시성의 개념을 설명하기 위해 유추에 초점을 둔다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d22e77c39b64987867f31bc641a2c7fd0c1f2f91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="289bea1f35eed1af7b8112d0f8c61f705d425958" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2778e9f54b08b0eccef6e1f5fe205c622cd3d03c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b0452ea54bfa19c34b31eea62b1df9bde0570907" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f20ea25a1c1f93d46c8a492286f9cf8254aea33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b346ab96e2b29b13b999bfffc88ff3a8086c76c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/primers/promises&quot;&gt;Promises&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/primers/promises&quot;&gt;Promises&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5a5d71dbf9e42228d1baf6d36e54cd389b38eea8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bob&lt;/strong&gt;: Sure thing, but it'll take me around 30 minutes?</source>
          <target state="translated">&lt;strong&gt;Bob&lt;/strong&gt; : 물론이지만 30 분 정도 걸릴까요?</target>
        </trans-unit>
        <trans-unit id="7fdddf9c3bee50f48d61f290501ea4e7b84eca27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Callbacks&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Callbacks&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3733084af55c2ff08a2c0a4af4d4f8d7dafdd1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: Hi Bob, I need to know how we &lt;em&gt;foo&lt;/em&gt;'d the &lt;em&gt;bar&lt;/em&gt;'d last week. Jim want's a report on it, and you're the only one who knows the details about it.</source>
          <target state="translated">&lt;strong&gt;나&lt;/strong&gt; : 안녕 밥, 나는 우리가 지난주에 &lt;em&gt;바를&lt;/em&gt; 어떻게했는지 알 필요가있다. Jim은 이에 대한 보고서를 원하며 귀하는 이에 대한 세부 사항을 아는 유일한 사람입니다.</target>
        </trans-unit>
        <trans-unit id="713f53e40c4562b4ab9eba6d6198debc536e516b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: Hi Bob, I need to know how we &lt;em&gt;foo&lt;/em&gt;'d the &lt;em&gt;bar&lt;/em&gt;'d last week. Jim wants a report on it, and you're the only one who knows the details about it.</source>
          <target state="translated">&lt;strong&gt;나&lt;/strong&gt; : 안녕 밥, 나는 우리가 지난주에 &lt;em&gt;바를&lt;/em&gt; 어떻게했는지 알 필요가있다. Jim은 이에 대한 보고서를 원하며 귀하는 이에 대한 세부 사항을 아는 유일한 사람입니다.</target>
        </trans-unit>
        <trans-unit id="696d9e23b68465a334ff08838685b593defebdc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: That's great Bob. Give me a ring back when you've got the information!</source>
          <target state="translated">&lt;strong&gt;나&lt;/strong&gt; : 잘 했어. 정보를 받으면 다시 연락주세요!</target>
        </trans-unit>
        <trans-unit id="31595be6d48c2097c06c53e9214cf88db6632a77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: That's great Bob. I'll wait.</source>
          <target state="translated">&lt;strong&gt;나&lt;/strong&gt; : 잘 했어. 기다릴게.</target>
        </trans-unit>
        <trans-unit id="c2fd0d38b0ab8484e639564a171161035b2a7b4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I'm using &lt;code&gt;setTimeout&lt;/code&gt; with a random delay as a generic asynchronous function, the same example applies to Ajax, &lt;code&gt;readFile&lt;/code&gt;, &lt;code&gt;onload&lt;/code&gt; and any other asynchronous flow.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 일반적인 비동기 함수로 임의 지연으로 &lt;code&gt;setTimeout&lt;/code&gt; 을 사용하고 있으며 동일한 예제가 Ajax, &lt;code&gt;readFile&lt;/code&gt; , &lt;code&gt;onload&lt;/code&gt; 및 기타 비동기 흐름에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="5e39b2acd2b8bf115a6c7845f5b4a885b1f2ab18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I've marked this answer as Community Wiki, hence anyone with at least 100 reputations can edit and improve it! Please feel free to improve this answer, or submit a completely new answer if you'd like as well.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이 답변을 Community Wiki로 표시 했으므로 평판이 100 이상인 사람은 누구나 편집하고 개선 할 수 있습니다! 이 답변을 개선하거나 원하는 경우 완전히 새로운 답변을 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="01a61e555cd8030fb7253b04500742128a3d6699" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is a canonical question for &lt;em&gt;JavaScript asynchronicity&lt;/em&gt;. Feel free to improve this question and add more simplified examples which the community can identify with.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이것은 &lt;em&gt;JavaScript 비동기&lt;/em&gt; 성에 대한 표준 질문입니다. 이 질문을 자유롭게 개선하고 커뮤니티가 식별 할 수있는 더 간단한 예를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="8fe8260d2797d89dec2d4d73b3d6171752b44d37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;async/await&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;async/await&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a0135ab690b1a17b0530e20999de06043814128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery &lt;a href=&quot;http://api.jquery.com/category/deferred-object/&quot;&gt;Deferreds&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery &lt;a href=&quot;http://api.jquery.com/category/deferred-object/&quot;&gt;연기&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dbe2dc81e7b8f642b5949e87b7c1af8324d0995c" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;* Technically you can use &lt;code&gt;eval()&lt;/code&gt; as well, but &lt;a href=&quot;https://stackoverflow.com/questions/86513/why-is-using-the-javascript-eval-function-a-bad-idea&quot;&gt;&lt;code&gt;eval()&lt;/code&gt; is evil&lt;/a&gt; for this purpose&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;* 기술적으로 &lt;code&gt;eval()&lt;/code&gt; 을 사용할 수 있지만 &lt;a href=&quot;https://stackoverflow.com/questions/86513/why-is-using-the-javascript-eval-function-a-bad-idea&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; &lt;/a&gt; 은이 목적에 적합하지 않습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="193eae364dc628fc092cd8ef11b86139f36c9a36" translate="yes" xml:space="preserve">
          <source>@Benjamin Gruenbaum has also put a lot of effort explaining asynchronicity in the same thread.</source>
          <target state="translated">@Benjamin Gruenbaum도 같은 스레드에서 비동기 성을 설명하기 위해 많은 노력을 기울였습니다.</target>
        </trans-unit>
        <trans-unit id="2616531e447d36623971529ada2669d82436aed6" translate="yes" xml:space="preserve">
          <source>All ajax calls (including the &lt;code&gt;$.get&lt;/code&gt; or &lt;code&gt;$.post&lt;/code&gt; or &lt;code&gt;$.ajax&lt;/code&gt;) are asynchronous.</source>
          <target state="translated">모든 ajax 호출 ( &lt;code&gt;$.get&lt;/code&gt; 또는 &lt;code&gt;$.post&lt;/code&gt; 또는 &lt;code&gt;$.ajax&lt;/code&gt; )은 비동기식입니다.</target>
        </trans-unit>
        <trans-unit id="2a0a37ac5b8e47801b9f45a88a68c9a89cad5b91" translate="yes" xml:space="preserve">
          <source>All the code that depends on the asynchronous calls, is moved inside the asynchronous block, or by waiting on the asynchronous calls.</source>
          <target state="translated">비동기 호출에 의존하는 모든 코드는 비동기 블록 내로 이동하거나 비동기 호출을 대기하여 이동합니다.</target>
        </trans-unit>
        <trans-unit id="1fb9670113b1c96e286f81efab4da12bc3d0e7ca" translate="yes" xml:space="preserve">
          <source>Although there are ways to keep the &lt;a href=&quot;http://callbackhell.com/&quot;&gt;callback hell&lt;/a&gt; at bay with vanilla JS, promises are growing in popularity and are currently being standardized in ES6 (see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise - MDN&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;http://callbackhell.com/&quot;&gt;콜백 지옥&lt;/a&gt; 을 바닐라 JS와 함께 유지하는 방법이 있지만 약속은 점점 커지고 있으며 현재 ES6에서 표준화되고 있습니다 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise-MDN&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="3351fcf6c12d50fc0ac88805069aea142f975b54" translate="yes" xml:space="preserve">
          <source>An Analogy...</source>
          <target state="translated">비유 ...</target>
        </trans-unit>
        <trans-unit id="5ab84d7fcdf6fb1318fe079454de14bc2e9d8e11" translate="yes" xml:space="preserve">
          <source>And I sat there and waited. And waited. And waited. For 40 minutes. Doing nothing but waiting. Eventually, Bob gave me the information, we hung up, and I completed my report. But I'd lost 40 minutes of productivity.</source>
          <target state="translated">그리고 나는 거기에 앉아 기다렸다. 그리고 기다렸다. 그리고 기다렸다. 40 분 동안. 기다리는 것 외에는 아무것도하지 않습니다. 결국 밥은 나에게 정보를 주었고, 우리는 끊었고 보고서를 완성했다. 그러나 나는 40 분의 생산성을 잃었습니다.</target>
        </trans-unit>
        <trans-unit id="fda44874bfa419ff03d6f65b066d614159b645b1" translate="yes" xml:space="preserve">
          <source>Asynchronous execution is pushed out of the synchronous flow. That is, the asynchronous code will &lt;strong&gt;never&lt;/strong&gt; execute while the synchronous code stack is executing. This is the meaning of JavaScript being single-threaded.</source>
          <target state="translated">비동기식 실행이 동기식 흐름에서 빠져 나옵니다. 즉, 비동기 코드 스택이 실행되는 동안 비동기 코드는 실행 &lt;strong&gt;되지 않습니다&lt;/strong&gt; . 이것이 자바 스크립트가 단일 스레드라는 의미입니다.</target>
        </trans-unit>
        <trans-unit id="3eaa02daa9e2fa7476ef359c4e92ddb36ff3ccfa" translate="yes" xml:space="preserve">
          <source>Asynchronous functions be like...</source>
          <target state="translated">비동기 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43f59b64684b4ec6e77bc10459d2c89df596e351" translate="yes" xml:space="preserve">
          <source>At this point, I hung up the phone. Since I needed information from Bob to complete my report, I left the report and went for a coffee instead, then I caught up on some email. 40 minutes later (Bob is slow), Bob called back and gave me the information I needed. At this point, I resumed my work with my report, as I had all the information I needed.</source>
          <target state="translated">이 시점에서 나는 전화를 끊었다. 보고서를 완성하기 위해 Bob의 정보가 필요했기 때문에 보고서를 남기고 커피를 마시 러 갔다가 이메일을 받았습니다. 40 분 후 (밥이 느리다) 밥이 전화를 걸어 필요한 정보를 주었다. 이 시점에서 필요한 모든 정보를 얻었으므로 보고서 작업을 다시 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="b103b8d3480de02206ccf798fcaa01817ae2396c" translate="yes" xml:space="preserve">
          <source>Code snippet of the above example:</source>
          <target state="translated">위 예제의 코드 스 니펫 :</target>
        </trans-unit>
        <trans-unit id="d268a2e26266d8a732fbf03fc545f77a1511cad7" translate="yes" xml:space="preserve">
          <source>Considering your example</source>
          <target state="translated">당신의 모범을 고려</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="4161388d0bc1d4981fe7e703476edf485adb1e23" translate="yes" xml:space="preserve">
          <source>Forewords</source>
          <target state="translated">Forewords</target>
        </trans-unit>
        <trans-unit id="9ff1e84bc1df7325df3d395b27e23dde1e64014a" translate="yes" xml:space="preserve">
          <source>Given the following examples, why is &lt;code&gt;outerScopeVar&lt;/code&gt; undefined in all cases?</source>
          <target state="translated">다음 예제를 보면 왜 모든 경우에 &lt;code&gt;outerScopeVar&lt;/code&gt; 가 정의되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="90acfeac32c622ee5ef1932cf600a7a4910a15ba" translate="yes" xml:space="preserve">
          <source>Here the timeout event plays the role, which will invoke the handler after the specified time. Here it is &lt;code&gt;0&lt;/code&gt;, but still it registers an asynchronous event it will be added to the last position of the &lt;code&gt;Event Queue&lt;/code&gt; for execution, which makes the guaranteed delay.</source>
          <target state="translated">여기서 타임 아웃 이벤트가 역할을 수행하며 지정된 시간 이후에 핸들러를 호출합니다. 여기서 &lt;code&gt;0&lt;/code&gt; 이지만 여전히 비동기 이벤트를 등록하여 실행을 위해 &lt;code&gt;Event Queue&lt;/code&gt; 의 마지막 위치에 추가되어 지연을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="c0ccb8fb1c710d25514aa41de1cf403d4866d1fc" translate="yes" xml:space="preserve">
          <source>Here we register an eventlistner which will be executed upon that particular event.Here loading of image.Then the current execution continuous with next lines &lt;code&gt;img.src = 'lolcat.png';&lt;/code&gt; and &lt;code&gt;alert(outerScopeVar);&lt;/code&gt; meanwhile the event may not occur. i.e, funtion &lt;code&gt;img.onload&lt;/code&gt; wait for the referred image to load, asynchrously. This will happen all the folowing example- the event may differ.</source>
          <target state="translated">여기에 특정 이벤트에 대해 실행될 이벤트 목록을 등록합니다. 여기에 이미지를로드합니다. 다음 행과 함께 현재 실행 &lt;code&gt;img.src = 'lolcat.png';&lt;/code&gt; 및 &lt;code&gt;alert(outerScopeVar);&lt;/code&gt; 한편 이벤트가 발생하지 않을 수 있습니다. 즉, funtion &lt;code&gt;img.onload&lt;/code&gt; 는 참조 된 이미지가 비동기 적으로로드 될 때까지 기다립니다. 이것은 다음의 모든 예에서 발생하며 사건이 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9513c4fd164bc6e4b493627615a49084822fe3c0" translate="yes" xml:space="preserve">
          <source>Here's a more concise answer for people that are looking for a quick reference as well as some examples using promises and async/await.</source>
          <target state="translated">다음은 약속 및 async / await를 사용하는 몇 가지 예뿐만 아니라 빠른 참조를 원하는 사람들에게 더 간결한 답변입니다.</target>
        </trans-unit>
        <trans-unit id="b6008160b60a5356b4ee831a5e643f9f9bec0f29" translate="yes" xml:space="preserve">
          <source>How do I keep my caller waiting?</source>
          <target state="translated">발신자를 대기 상태로 유지하려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="5376e14e843406f61ac87403197fd8d1d7434c5e" translate="yes" xml:space="preserve">
          <source>However, we now know that the &lt;code&gt;return outerScopeVar&lt;/code&gt; happens immediately; before the &lt;code&gt;onload&lt;/code&gt; callback function has updated the variable. This leads to &lt;code&gt;getWidthOfImage()&lt;/code&gt; returning &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;undefined&lt;/code&gt; being alerted.</source>
          <target state="translated">그러나 이제 &lt;code&gt;return outerScopeVar&lt;/code&gt; 즉시 발생한다는 것을 알고 있습니다. &lt;code&gt;onload&lt;/code&gt; 콜백 함수가 변수를 업데이트하기 전에. 이로 인해 &lt;code&gt;getWidthOfImage()&lt;/code&gt; &lt;code&gt;undefined&lt;/code&gt; 를 반환하고 &lt;code&gt;undefined&lt;/code&gt; 가 경고됩니다.</target>
        </trans-unit>
        <trans-unit id="e6239a14687cbf4f9e4e299f4f10e3f1d0d8290b" translate="yes" xml:space="preserve">
          <source>I want to turn this question into a canonical topic to answer asynchronicity issues which are unrelated to Ajax (there is &lt;a href=&quot;https://stackoverflow.com/q/14220321/1331430&quot;&gt;How to return the response from an AJAX call?&lt;/a&gt; for that), hence this topic needs your help to be as good and helpful as possible!</source>
          <target state="translated">이 질문을 Ajax와 관련이없는 비 동시성 문제에 답변하기 위해 정식 주제로 바꾸고 싶습니다 ( &lt;a href=&quot;https://stackoverflow.com/q/14220321/1331430&quot;&gt;AJAX 호출에서 응답을 반환하는 방법&lt;/a&gt; 은 무엇입니까? ) !</target>
        </trans-unit>
        <trans-unit id="c6867acba73dcc3d63f6f6a677d4a3c0f03b6e0a" translate="yes" xml:space="preserve">
          <source>If your JavaScript environment includes support for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; (like Node.js 7.6+), then you can use promises synchronously within &lt;code&gt;async&lt;/code&gt; functions:</source>
          <target state="translated">JavaScript 환경에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; 지원 (예 : Node.js 7.6+)이있는 경우 &lt;code&gt;async&lt;/code&gt; 함수 내에서 약속을 동 기적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbe7623af9f69417f8c30820f0ea3f8da88b935e" translate="yes" xml:space="preserve">
          <source>Imagine if the conversation had gone like this instead;</source>
          <target state="translated">대화가 대신 이런 식으로 진행되었다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="d94c2a88c0873ea1bc503304b1c42af08fccd5f4" translate="yes" xml:space="preserve">
          <source>Implementing your own callback logic</source>
          <target state="translated">자신의 콜백 로직 구현</target>
        </trans-unit>
        <trans-unit id="19eaef30713ec40985dd7ae805fde594db8f511d" translate="yes" xml:space="preserve">
          <source>In all cases, we have a callback which may run &lt;em&gt;sometime in the future&lt;/em&gt;. This &quot;sometime in the future&quot; is what we refer to as &lt;strong&gt;asynchronous flow&lt;/strong&gt;.</source>
          <target state="translated">모든 경우에 &lt;em&gt;향후&lt;/em&gt; 콜백이 발생할 수 &lt;em&gt;있습니다&lt;/em&gt; . 이 &quot;언젠가&quot;는 우리가 &lt;strong&gt;비동기식 흐름&lt;/strong&gt; 이라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="135bd88cbd59b18dc1f9b7be855f8e4fa92e1f0e" translate="yes" xml:space="preserve">
          <source>In all these scenarios &lt;code&gt;outerScopeVar&lt;/code&gt; is modified or assigned a value &lt;strong&gt;asynchronously&lt;/strong&gt; or &lt;strong&gt;happening in a later time(waiting or listening for some event to occur),for which the current execution will not wait&lt;/strong&gt;.So all these cases current execution flow results in &lt;code&gt;outerScopeVar = undefined&lt;/code&gt;</source>
          <target state="translated">이러한 모든 시나리오에서 &lt;code&gt;outerScopeVar&lt;/code&gt; 는 &lt;strong&gt;현재 실행이 대기하지 않는&lt;/strong&gt; &lt;strong&gt;비동기식&lt;/strong&gt; 또는 &lt;strong&gt;나중에 발생&lt;/strong&gt; 하는 값 &lt;strong&gt;(일부 이벤트가 발생하거나 대기 중)&lt;/strong&gt; 으로 값이 수정되거나 할당 &lt;strong&gt;되므로&lt;/strong&gt; 이러한 모든 경우에 현재 실행 흐름은 &lt;code&gt;outerScopeVar = undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dfc2217afad206d82ab1c489045154e363b8cd2a" translate="yes" xml:space="preserve">
          <source>In order to fix our code, all we have to do is move the &lt;code&gt;alert(outerScopeVar)&lt;/code&gt; code &lt;em&gt;into&lt;/em&gt; the callback function. As a consequence of this, we no longer need the &lt;code&gt;outerScopeVar&lt;/code&gt; variable declared as a global variable.</source>
          <target state="translated">코드를 수정하려면 &lt;code&gt;alert(outerScopeVar)&lt;/code&gt; 코드 &lt;em&gt;를&lt;/em&gt; 콜백 함수 &lt;em&gt;로&lt;/em&gt; 옮기면 됩니다. 결과적으로 더 이상 전역 변수로 선언 된 &lt;code&gt;outerScopeVar&lt;/code&gt; 변수가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="219fa966e4403c99f93745961a66347fdd6ee889" translate="yes" xml:space="preserve">
          <source>In real life scenario, the code becomes,</source>
          <target state="translated">실제 시나리오에서 코드는</target>
        </trans-unit>
        <trans-unit id="729a2882bffa8796d64097b884d3520508f6cc3c" translate="yes" xml:space="preserve">
          <source>In short, the callback functions are created synchronously but executed asynchronously. You just can't rely on the execution of an asynchronous function until you know it has executed, and how to do that?</source>
          <target state="translated">요컨대, 콜백 함수는 동 기적으로 생성되지만 비동기 적으로 실행됩니다. 비동기 함수가 실행되었다는 것을 알기 전까지는 비동기 함수의 실행에 의존 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c30a8d270de5576c077f0fa84b762b1e781bf74b" translate="yes" xml:space="preserve">
          <source>In the code above, we're asking JavaScript to load &lt;code&gt;lolcat.png&lt;/code&gt;, which is a &lt;em&gt;sloooow&lt;/em&gt; operation. The callback function will be executed once this slow operation has done, but in the meantime, JavaScript will keep processing the next lines of code; i.e. &lt;code&gt;alert(outerScopeVar)&lt;/code&gt;.</source>
          <target state="translated">위의 코드에서 우리는 &lt;em&gt;sloooow&lt;/em&gt; 작업 인 &lt;code&gt;lolcat.png&lt;/code&gt; 를로드 하도록 JavaScript를 요청하고 있습니다. 이 느린 작업이 완료되면 콜백 함수가 실행되지만 그 동안 JavaScript는 다음 코드 줄을 계속 처리합니다. 즉, &lt;code&gt;alert(outerScopeVar)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="41d2083ae42e2602204895d28ef21aeaac582cb0" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;return&lt;/code&gt;ing a value from an asynchronous callback, you will have to make use of the callback pattern, or... Promises.</source>
          <target state="translated">비동기 콜백에서 값을 &lt;code&gt;return&lt;/code&gt; 하는 대신 콜백 패턴을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0cc7a9dd54f8bbb52fefe95aa868d2fb8e4076e2" translate="yes" xml:space="preserve">
          <source>It depends on the case. Let's try to trace some common behavior again:</source>
          <target state="translated">경우에 따라 다릅니다. 몇 가지 일반적인 동작을 다시 추적 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="fb2ea5baac3ad36c938aef8df244432e62524de2" translate="yes" xml:space="preserve">
          <source>It is simple, really. The logic that depends on the asynchronous function execution should be started/called from inside this asynchronous function. For example, moving the &lt;code&gt;alert&lt;/code&gt;s and &lt;code&gt;console.log&lt;/code&gt;s too inside the callback function would output the expected result, because the result is available at that point.</source>
          <target state="translated">정말 간단합니다. 비동기 함수 실행에 의존하는 논리는이 비동기 함수 내부에서 시작 / 호출되어야합니다. 예를 들어 콜백 함수 내에서 &lt;code&gt;console.log&lt;/code&gt; 및 console.log를 너무 이동하면 결과가 해당 시점에 사용 가능하므로 예상 결과가 출력됩니다.</target>
        </trans-unit>
        <trans-unit id="f833c4bc8e7973b5c0788881a871357c0b979a45" translate="yes" xml:space="preserve">
          <source>JavaScript Promises - HTML5 Rocks</source>
          <target state="translated">JavaScript 약속-HTML5 락</target>
        </trans-unit>
        <trans-unit id="7e1a19f21ecf74a20fd1fc528e7a374bc5f9c8d9" translate="yes" xml:space="preserve">
          <source>Let's discuss each examples(I marked the portion which is called asynchronously or delayed for some events to occur):</source>
          <target state="translated">각 예제에 대해 논의 해 봅시다 (일부 이벤트가 발생하기 위해 비동기 또는 지연이라고하는 부분을 표시했습니다).</target>
        </trans-unit>
        <trans-unit id="638c1153b14aa1b9d097c6dcdd2c2f61b8c583bf" translate="yes" xml:space="preserve">
          <source>Let's tackle it implementing a callback system of our own. First off, we get rid of that ugly &lt;code&gt;outerScopeVar&lt;/code&gt; which is completely useless in this case. Then we add a parameter which accepts a function argument, our callback. When the asynchronous operation finishes, we call this callback passing the result. The implementation (please read the comments in order):</source>
          <target state="translated">우리 자신의 콜백 시스템을 구현하는 방법을 다루겠습니다. &lt;code&gt;outerScopeVar&lt;/code&gt; 경우 완전히 쓸모없는 추한 outerScopeVar 를 제거합니다. 그런 다음 함수 인수 인 콜백을 허용하는 매개 변수를 추가합니다. 비동기 작업이 완료되면이 콜백을 호출하여 결과를 전달합니다. 구현 (주석을 순서대로 읽으십시오) :</target>
        </trans-unit>
        <trans-unit id="487666eb364c70eb737ac6495aa0ccd4f8d13ba0" translate="yes" xml:space="preserve">
          <source>Let's trace the common behavior first. In all examples, the &lt;code&gt;outerScopeVar&lt;/code&gt; is modified inside of a &lt;em&gt;function&lt;/em&gt;. That function is clearly not executed immediately, it is being assigned or passed as an argument. That is what we call a &lt;strong&gt;&lt;em&gt;callback&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">먼저 일반적인 동작을 추적 해 봅시다. 모든 예에서 &lt;code&gt;outerScopeVar&lt;/code&gt; 는 &lt;em&gt;함수&lt;/em&gt; 안에서 수정 &lt;em&gt;됩니다&lt;/em&gt; . 이 기능은 즉시 실행되지 않으며 인수로 지정되거나 전달됩니다. 이것이 우리가 &lt;strong&gt;&lt;em&gt;콜백&lt;/em&gt;&lt;/strong&gt; 이라고 부르는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7adf46b8af10f9ffba635ac39fa32e59eedd72ea" translate="yes" xml:space="preserve">
          <source>Lets say that the post request takes 10 seconds to complete, the value of &lt;code&gt;outerScopeVar&lt;/code&gt; will only be set after those 10 seconds.</source>
          <target state="translated">게시 요청을 완료하는 데 10 초가 걸리고 &lt;code&gt;outerScopeVar&lt;/code&gt; 의 값은 10 초 후에 만 ​​설정됩니다.</target>
        </trans-unit>
        <trans-unit id="2cd4cb675addf1e7a7a8765c722dcd18f39a2b27" translate="yes" xml:space="preserve">
          <source>More reading material about JavaScript asynchronicity</source>
          <target state="translated">JavaScript 비동기성에 대한 추가 자료</target>
        </trans-unit>
        <trans-unit id="36f8fb94265b7a738324676d4ddedf0f7f8be952" translate="yes" xml:space="preserve">
          <source>More specifically, when the JS engine is idle -- not executing a stack of (a)synchronous code -- it will poll for events that may have triggered asynchronous callbacks (e.g. expired timeout, received network response) and execute them one after another. This is regarded as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop&quot;&gt;Event Loop&lt;/a&gt;.</source>
          <target state="translated">보다 구체적으로, (a) 동기 코드 스택을 실행하지 않고 JS 엔진이 유휴 상태 인 경우 비동기 콜백 (예 : 만료 된 시간 초과, 수신 된 네트워크 응답)을 트리거 한 이벤트를 폴링하고 차례로 실행합니다. 이를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop&quot;&gt;이벤트 루프&lt;/a&gt; 로 간주 합니다 .</target>
        </trans-unit>
        <trans-unit id="027fcce6dca0e5452f5c3ae77d3776d83b9cb117" translate="yes" xml:space="preserve">
          <source>Most often in real use cases, the DOM API and most libraries already provide the callback functionality (the &lt;code&gt;helloCatAsync&lt;/code&gt; implementation in this demonstrative example). You only need to pass the callback function and understand that it will execute out of the synchronous flow, and restructure your code to accommodate for that.</source>
          <target state="translated">실제 사용 사례에서 DOM API 및 대부분의 라이브러리는 이미 콜백 기능 (이 예제에서는 &lt;code&gt;helloCatAsync&lt;/code&gt; 구현)을 제공합니다. 콜백 함수를 전달하고 동기 흐름에서 실행될 것임을 이해하고이를 수용하도록 코드를 재구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="0dcfbb375ba4904c46d6dce14e7309a4eb9988dc" translate="yes" xml:space="preserve">
          <source>Node can be consider as a king of asynchronous coding.Here the marked function is registered as a callback handler which will be executed after reading the specified file.</source>
          <target state="translated">노드는 비동기 코딩의 왕으로 간주 될 수 있습니다. 여기서 표시된 함수는 지정된 파일을 읽은 후 실행될 콜백 핸들러로 등록됩니다.</target>
        </trans-unit>
        <trans-unit id="b216c6131cd7d019cbd3e050a3a8d93e5b049385" translate="yes" xml:space="preserve">
          <source>Node.js's &lt;code&gt;fs.readFile&lt;/code&gt; may be called &lt;em&gt;sometime in the future&lt;/em&gt;, when the file has been read successfully or thrown an error.</source>
          <target state="translated">Node.js의 &lt;code&gt;fs.readFile&lt;/code&gt; 은 파일이 성공적으로 읽히거나 오류가 발생했을 때 &lt;em&gt;나중에&lt;/em&gt; 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edba6c23726045806eaa1d7bc5d696075358f973" translate="yes" xml:space="preserve">
          <source>Now the question is, when is that callback called?</source>
          <target state="translated">이제 문제는 언제 콜백이 호출됩니까?</target>
        </trans-unit>
        <trans-unit id="6cdece044e170983c1f5cab467ce941e2ddd0dde" translate="yes" xml:space="preserve">
          <source>Now when you execute this, you would get an alert on line 3. Now wait for some time until you are sure the post request has returned some value. Then when you click OK, on the alert box, next alert would print the expected value, because you waited for it.</source>
          <target state="translated">이제 이것을 실행하면 라인 3에 경고가 표시됩니다. 이제 포스트 요청이 어떤 값을 리턴 할 때까지 잠시 기다리십시오. 그런 다음 확인을 클릭하면 경고 상자에서 기다렸다가 다음 경고에 예상 값이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="8f7e7c308a72af2805417b772be3373d55f7aa67" translate="yes" xml:space="preserve">
          <source>Obvious promise (something will be done in future) is asynchronous. see &lt;a href=&quot;https://stackoverflow.com/questions/6801283/what-are-the-differences-between-deferred-promise-and-future-in-javascript&quot;&gt;What are the differences between Deferred, Promise and Future in JavaScript?&lt;/a&gt;</source>
          <target state="translated">명백한 약속 (무언가 미래에 이루어질 것)은 비동기 적입니다. &lt;a href=&quot;https://stackoverflow.com/questions/6801283/what-are-the-differences-between-deferred-promise-and-future-in-javascript&quot;&gt;JavaScript에서 Deferred, Promise 및 Future의 차이점&lt;/a&gt; 은 무엇입니까?를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="acfa95439c5b3dfbc3f590cb3d6cbc5140d0725d" translate="yes" xml:space="preserve">
          <source>Often you need to do more things with the result from an asynchronous function or do different things with the result depending on where the asynchronous function has been called. Let's tackle a bit more complex example:</source>
          <target state="translated">비동기 함수의 결과로 더 많은 작업을 수행하거나 비동기 함수가 호출 된 위치에 따라 결과로 다른 작업을 수행해야하는 경우가 종종 있습니다. 좀 더 복잡한 예를 다루겠습니다.</target>
        </trans-unit>
        <trans-unit id="69aae8a529faeef3bf34a8f29a9aeb27faa6c60a" translate="yes" xml:space="preserve">
          <source>One word answer: &lt;strong&gt;asynchronicity&lt;/strong&gt;.</source>
          <target state="translated">한마디로 대답 : &lt;strong&gt;비동기 성&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b1d472e424c03ff52490d1edc8a0e23f95babb92" translate="yes" xml:space="preserve">
          <source>Promises</source>
          <target state="translated">Promises</target>
        </trans-unit>
        <trans-unit id="6d9d164125b7cac2630c27b4a009417447162bf7" translate="yes" xml:space="preserve">
          <source>Promises (a.k.a. Futures) provide a more linear, and thus pleasant, reading of the asynchronous code, but explaining their entire functionality is out of the scope of this question. Instead, I'll leave these excellent resources for the interested:</source>
          <target state="translated">약속 (일명 Futures)은 비동기 코드를보다 선형적이고 유쾌하게 읽을 수있게하지만 전체 기능을 설명하는 것은이 질문의 범위를 벗어납니다. 대신, 나는 다음과 같은 훌륭한 자료를 관심의 대상으로 남길 것이다.</target>
        </trans-unit>
        <trans-unit id="cb68ff088476aec4be87b92843cdbef82052867f" translate="yes" xml:space="preserve">
          <source>Promises provide an alternative which is more flexible than callbacks because they can be naturally combined to coordinate multiple async operations. A &lt;a href=&quot;https://promisesaplus.com/&quot;&gt;Promises/A+&lt;/a&gt; standard implementation is natively provided in node.js (0.12+) and many current browsers, but is also implemented in libraries like &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;Bluebird&lt;/a&gt; and &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt;.</source>
          <target state="translated">약속은 여러 비동기 작업을 조정하기 위해 자연스럽게 결합 될 수 있기 때문에 콜백보다 유연한 대안을 제공합니다. &lt;a href=&quot;https://promisesaplus.com/&quot;&gt;Promises / A +&lt;/a&gt; 표준 구현은 기본적으로 node.js (0.12+) 및 많은 최신 브라우저에서 제공되지만 &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;Bluebird&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt; 와 같은 라이브러리에서도 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="9d7c2ad2dddc44dedd1e96fb0db1f59589562e3c" translate="yes" xml:space="preserve">
          <source>Rather than &lt;em&gt;waiting&lt;/em&gt; for these slow operations to complete, JavaScript lets you register a callback function which will be executed when the slow operation has completed. In the meantime, however, JavaScript will continue to execute other code. The fact that JavaScript executes &lt;em&gt;other code&lt;/em&gt; whilst waiting for the slow operation to complete makes the behavior&lt;strong&gt;asynchronous&lt;/strong&gt;. Had JavaScript waited around for the operation to complete before executing any other code, this would have been &lt;strong&gt;synchronous&lt;/strong&gt; behavior.</source>
          <target state="translated">JavaScript는 이러한 느린 작업이 완료 &lt;em&gt;되기를 기다리지&lt;/em&gt; 않고 느린 작업이 완료 될 때 실행될 콜백 함수를 등록 할 수 있도록합니다. 그러나 그 동안 JavaScript는 다른 코드를 계속 실행합니다. 느린 작업이 완료되기를 기다리는 동안 JavaScript가 &lt;em&gt;다른 코드&lt;/em&gt; 를 실행한다는 사실은 동작을 &lt;strong&gt;비동기 적으로&lt;/strong&gt; 만듭니다. JavaScript가 다른 코드를 실행하기 전에 작업이 완료 될 때까지 기다렸다면 이는 &lt;strong&gt;동기&lt;/strong&gt; 동작 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="8f3fc1e296aaa81836928351f23624856a1de71b" translate="yes" xml:space="preserve">
          <source>Start with the naive approach (that doesn't work) for a function that calls an asynchronous method (in this case &lt;code&gt;setTimeout&lt;/code&gt;) and returns a message:</source>
          <target state="translated">비동기 메소드 (이 경우 &lt;code&gt;setTimeout&lt;/code&gt; )를 호출하고 메시지를 리턴하는 함수에 대해 순진한 접근 (작동하지 않음)으로 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="fb0e4798cb170cfc40f0368e44f763affdfd54e9" translate="yes" xml:space="preserve">
          <source>That is, the asynchronous code highlighted in the hand-drawn red shapes may execute only after all the remaining synchronous code in their respective code blocks have executed:</source>
          <target state="translated">즉, 손으로 그린 ​​빨간색 모양으로 강조 표시된 비동기 코드는 해당 코드 블록의 나머지 모든 동기 코드가 실행 된 후에 만 ​​실행될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a9be42f4d2ec4950f69e0eb67c25bd4ebaa41c0" translate="yes" xml:space="preserve">
          <source>The answer to the question at hand</source>
          <target state="translated">당면한 질문에 대한 답</target>
        </trans-unit>
        <trans-unit id="0f58e0d8b311cbdc96d07934de3ac62c55d87691" translate="yes" xml:space="preserve">
          <source>The change here is that &lt;code&gt;getMessage&lt;/code&gt; accepts a &lt;code&gt;callback&lt;/code&gt; parameter that will be called to deliver the results back to the calling code once available.</source>
          <target state="translated">여기서 변경된 사항은 &lt;code&gt;getMessage&lt;/code&gt; 가 &lt;code&gt;callback&lt;/code&gt; 매개 변수를 수락하여 사용 가능한 호출 코드로 결과를 다시 전달하도록 호출한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dfbc4999399aec4a2d69483e59a7728ba63f4f53" translate="yes" xml:space="preserve">
          <source>The code execution starts from line 1, declares the variable and triggers and asynchronous call on line 2, (i.e., the post request) and it continues its execution from line 3, without waiting for the post request to complete its execution.</source>
          <target state="translated">코드 실행은 라인 1에서 시작하여 변수를 선언하고 라인 2에서 트리거 및 비동기 호출 (즉, 사후 요청)을 실행하며 사후 요청이 실행을 완료 할 때까지 기다리지 않고 라인 3에서 실행을 계속합니다.</target>
        </trans-unit>
        <trans-unit id="9d15198b66c44aa363b53458036280b399cb3f48" translate="yes" xml:space="preserve">
          <source>The other answers are excellent and I just want to provide a straight forward answer to this. Just limiting to jQuery asynchronous calls</source>
          <target state="translated">다른 답변은 훌륭하며 이에 대한 간단한 답변을 제공하고자합니다. jQuery 비동기 호출로만 제한</target>
        </trans-unit>
        <trans-unit id="d52589835b03cdf8d7ac3617f883151bd0f44bc6" translate="yes" xml:space="preserve">
          <source>The two main ways to solve it are using &lt;strong&gt;callbacks&lt;/strong&gt; and &lt;strong&gt;promises&lt;/strong&gt;:</source>
          <target state="translated">이를 해결하는 두 가지 주요 방법은 &lt;strong&gt;콜백&lt;/strong&gt; 과 &lt;strong&gt;약속을 사용하는 것입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4f5b392d075945718f406191e510986ae67301e9" translate="yes" xml:space="preserve">
          <source>Therefore, in all of our examples, the &lt;code&gt;function() { /* Do something */ }&lt;/code&gt; is the callback; to fix &lt;strong&gt;all&lt;/strong&gt; the examples, all we have to do is move the code which needs the response of the operation into there!</source>
          <target state="translated">따라서 모든 예제에서 &lt;code&gt;function() { /* Do something */ }&lt;/code&gt; 는 콜백입니다. &lt;strong&gt;모든&lt;/strong&gt; 예제를 수정하려면 작업의 응답이 필요한 코드를 여기로 옮기면됩니다!</target>
        </trans-unit>
        <trans-unit id="91fe005c7b9a8de24f4645e8f363dbc2e0529353" translate="yes" xml:space="preserve">
          <source>This example clearly suffers from the same issue as the other examples, it is not waiting until the asynchronous function executes.</source>
          <target state="translated">이 예제는 다른 예제와 동일한 문제를 겪고 있으며 비동기 함수가 실행될 때까지 기다리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ffac965ab18c7d09429e1769cd6077e8cb88d4ef" translate="yes" xml:space="preserve">
          <source>This is asynchronous vs. synchronous behavior</source>
          <target state="translated">이것은 비동기 대 동기 동작입니다.</target>
        </trans-unit>
        <trans-unit id="4a9f0c688c7a4ad3c6e910681cbfa516c1908817" translate="yes" xml:space="preserve">
          <source>This is exactly what is happening in all the examples in our question. Loading an image, loading a file off disk, and requesting a page via AJAX are all slow operations (in the context of modern computing).</source>
          <target state="translated">이것이 바로 우리 질문의 모든 예에서 일어나는 일입니다. 이미지를로드하고 디스크에서 파일을로드하고 AJAX를 통해 페이지를 요청하는 작업은 모두 느리게 수행됩니다 (현대 컴퓨팅의 맥락에서).</target>
        </trans-unit>
        <trans-unit id="f707894961ab83a7c6e333b28e7f9931e3824aa4" translate="yes" xml:space="preserve">
          <source>This is why we see the alert showing &lt;code&gt;undefined&lt;/code&gt;; since the &lt;code&gt;alert()&lt;/code&gt; is processed immediately, rather than after the image has been loaded.</source>
          <target state="translated">이것이 경고가 &lt;code&gt;undefined&lt;/code&gt; 것을 보여주는 이유입니다. 이미지가로드 된 후가 아니라 &lt;code&gt;alert()&lt;/code&gt; 이 즉시 처리되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="f2e10d930e731050a7b6c7e2eaf695b3876a9b2e" translate="yes" xml:space="preserve">
          <source>This time ajax callback.</source>
          <target state="translated">이번에는 아약스 콜백입니다.</target>
        </trans-unit>
        <trans-unit id="42b9aece256629e1f3ae7fd0b418fdce8ba1bf5d" translate="yes" xml:space="preserve">
          <source>This topic has been iterated at least a couple of thousands of times, here, in Stack Overflow. Hence, first off I'd like to point out some extremely useful resources:</source>
          <target state="translated">이 항목은 여기에서 스택 오버플로에서 적어도 수천 번 반복되었습니다. 따라서 먼저 매우 유용한 리소스를 지적하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="b45bcc49f561af62860de0ba678026a934aa6d4c" translate="yes" xml:space="preserve">
          <source>To fix this, we need to allow the function calling &lt;code&gt;getWidthOfImage()&lt;/code&gt; to register a callback, then move the alert'ing of the width to be within that callback;</source>
          <target state="translated">이 문제를 해결하려면 &lt;code&gt;getWidthOfImage()&lt;/code&gt; 를 호출하는 함수가 콜백을 등록한 다음 해당 콜백 내에 있도록 너비의 경고를 이동해야합니다.</target>
        </trans-unit>
        <trans-unit id="efd3968d8235a10f87b53e88a27d4485fcc5fe25" translate="yes" xml:space="preserve">
          <source>To state the obvious, the cup represents &lt;code&gt;outerScopeVar&lt;/code&gt;.</source>
          <target state="translated">명백하게 &lt;code&gt;outerScopeVar&lt;/code&gt; 컵은 outerScopeVar를 나타 냅니다 .</target>
        </trans-unit>
        <trans-unit id="4db799b398211e889d65554156059060d81f356d" translate="yes" xml:space="preserve">
          <source>To try out,</source>
          <target state="translated">시험해보기 위해</target>
        </trans-unit>
        <trans-unit id="90422ad2e2bbc1c8f4a48927d8b73dd5160a2e66" translate="yes" xml:space="preserve">
          <source>Why does it output &lt;code&gt;undefined&lt;/code&gt; in all of these examples? I don't want workarounds, I want to know &lt;strong&gt;why&lt;/strong&gt; this is happening.</source>
          <target state="translated">이 모든 예제에서 &lt;code&gt;undefined&lt;/code&gt; 가 출력되는 이유는 무엇입니까? 해결 방법을 원하지 않습니다. &lt;strong&gt;왜&lt;/strong&gt; 이런 일이 발생 &lt;strong&gt;하는지&lt;/strong&gt; 알고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="c4936bc542e6ff5a21b7420fda279b793c156e24" translate="yes" xml:space="preserve">
          <source>Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference</source>
          <target state="translated">함수 내에서 변수를 수정 한 후 왜 변수가 변경되지 않습니까? -비동기 코드 참조</target>
        </trans-unit>
        <trans-unit id="30c09e36d32f8aa50d9fd572ae75dfa8792e72cd" translate="yes" xml:space="preserve">
          <source>Yesterday, the work I was doing required some information from a colleague. I rang him up; here's how the conversation went:</source>
          <target state="translated">어제, 내가하고있는 일에는 동료의 정보가 필요했습니다. 나는 그를 울렸다. 대화 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1ced2ce1f9304e9a0ba78b790d5a22ededef908" translate="yes" xml:space="preserve">
          <source>You might currently have some code similar to this;</source>
          <target state="translated">현재 이와 비슷한 코드가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7b14f844f491cec253dffd6a2877e87891e6a62" translate="yes" xml:space="preserve">
          <source>You will also notice that due to the asynchronous nature, it is impossible to &lt;code&gt;return&lt;/code&gt; a value from an asynchronous flow back to the synchronous flow where the callback was defined, as the asynchronous callbacks are executed long after the synchronous code has already finished executing.</source>
          <target state="translated">비동기 특성으로 인해 비동기 코드가 이미 실행 완료된 후에도 비동기 콜백이 실행되므로 비동기 플로우에서 콜백이 정의 된 동기 플로우로 값을 &lt;code&gt;return&lt;/code&gt; 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="17990bb6c33a853fa89124957ec7cb0f2f107251" translate="yes" xml:space="preserve">
          <source>You'll &lt;strong&gt;&lt;em&gt;always&lt;/em&gt;&lt;/strong&gt; see a callback is specified as a function, because that's the only* way in JavaScript to define some code, but not execute it until later.</source>
          <target state="translated">콜백은 함수로 지정되어 있습니다. JavaScript에서는 코드를 정의 할 수있는 유일한 방법이기 때문에 나중에 코드를 실행하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="1a36ade9be4ed848a5cd8b84079e9715d403ca94" translate="yes" xml:space="preserve">
          <source>You're Missing the Point of Promises - domenic.me</source>
          <target state="translated">약속의 요점을 놓치다-domenic.me</target>
        </trans-unit>
        <trans-unit id="ff168847efe383bab3ac7dd4c396db86055ad902" translate="yes" xml:space="preserve">
          <source>jQuery &lt;code&gt;$.post&lt;/code&gt;'s callback may be called &lt;em&gt;sometime in the future&lt;/em&gt;, when (and if) the Ajax request has been completed successfully.</source>
          <target state="translated">jQuery &lt;code&gt;$.post&lt;/code&gt; 의 콜백은 &lt;em&gt;나중에&lt;/em&gt; Ajax 요청이 성공적으로 완료되었을 때 호출 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3506140f1030ab84b377ab6155325a3641104402" translate="yes" xml:space="preserve">
          <source>jQuery provides functionality that's similar to promises with its Deferreds.</source>
          <target state="translated">jQuery는 지연된 약속과 유사한 기능을 제공합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
