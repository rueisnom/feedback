<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/23667086">
    <body>
      <group id="23667086">
        <trans-unit id="87e7945a2a6acfe9e9ac15c56656043a7d3eaa7b" translate="yes" xml:space="preserve">
          <source>... as before, note that we've been able to remove the global variables (in this case &lt;code&gt;width&lt;/code&gt;).</source>
          <target state="translated">... como antes, tenga en cuenta que hemos podido eliminar las variables globales (en este caso, el &lt;code&gt;width&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="483231bd8f34a26d5113dd22f8c5212933edbb64" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/maxogden/art-of-node#callbacks&quot;&gt;The Art of Node - Callbacks&lt;/a&gt; explains asynchronous code and callbacks very well with vanilla JS examples and Node.js code as well.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/maxogden/art-of-node#callbacks&quot;&gt;The Art of Node - Callbacks&lt;/a&gt; explica muy bien el c&amp;oacute;digo as&amp;iacute;ncrono y las devoluciones de llamada con ejemplos de Vanilla JS y el c&amp;oacute;digo Node.js tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="18b6513dab89c1fe133131a6fb64518a7ba93ed0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/10058879/1331430&quot;&gt;@Matt Esch's answer to &quot;Get data from fs.readFile&quot;&lt;/a&gt; also explains asynchronicity extremely well in a simple manner.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/10058879/1331430&quot;&gt;La respuesta de @Matt Esch a &quot;Obtener datos de fs.readFile&quot;&lt;/a&gt; tambi&amp;eacute;n explica la asincron&amp;iacute;a extremadamente bien de una manera simple.</target>
        </trans-unit>
        <trans-unit id="cadc61baae72a97d1e69933c6cfd90e943dc7402" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/14220323/1331430&quot;&gt;@Felix Kling's answer to &quot;How do I return the response from an asynchronous call?&quot;&lt;/a&gt;. See his excellent answer explaining synchronous and asynchronous flows, as well as the &quot;Restructure code&quot; section.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/14220323/1331430&quot;&gt;La respuesta de @Felix Kling a &quot;&amp;iquest;C&amp;oacute;mo devuelvo la respuesta de una llamada asincr&amp;oacute;nica?&quot;&lt;/a&gt; . Vea su excelente respuesta explicando flujos sincr&amp;oacute;nicos y asincr&amp;oacute;nicos, as&amp;iacute; como la secci&amp;oacute;n &quot;C&amp;oacute;digo de reestructuraci&amp;oacute;n&quot;.</target>
        </trans-unit>
        <trans-unit id="34372c0e6cc14dd9b3b03232668d7110ae7f8856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;img.onload&lt;/code&gt; may be called &lt;em&gt;sometime in the future&lt;/em&gt;, when (and if) the image has successfully loaded.</source>
          <target state="translated">&lt;code&gt;img.onload&lt;/code&gt; puede llamar a img.onload &lt;em&gt;en alg&amp;uacute;n momento en el futuro&lt;/em&gt; , cuando (y si) la imagen se haya cargado correctamente.</target>
        </trans-unit>
        <trans-unit id="68a8ea4de6a6afdbe9657f4ae00dcc062708d45f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setTimeout&lt;/code&gt; may be called &lt;em&gt;sometime in the future&lt;/em&gt;, after the delay has expired and the timeout hasn't been canceled by &lt;code&gt;clearTimeout&lt;/code&gt;. Note: even when using &lt;code&gt;0&lt;/code&gt; as delay, all browsers have a minimum timeout delay cap (specified to be 4ms in the HTML5 spec).</source>
          <target state="translated">&lt;code&gt;setTimeout&lt;/code&gt; puede llamar a setTimeout &lt;em&gt;en alg&amp;uacute;n momento en el futuro&lt;/em&gt; , despu&amp;eacute;s de que la demora haya expirado y &lt;code&gt;clearTimeout&lt;/code&gt; no haya cancelado el tiempo de espera . Nota: incluso cuando se usa &lt;code&gt;0&lt;/code&gt; como retraso, todos los navegadores tienen un l&amp;iacute;mite de tiempo de espera m&amp;iacute;nimo (especificado en 4 ms en la especificaci&amp;oacute;n HTML5).</target>
        </trans-unit>
        <trans-unit id="0bfccf94f3ad9d7adee477872ae30a98032c0523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; gets logged in this case because &lt;code&gt;getMessage&lt;/code&gt; returns before the &lt;code&gt;setTimeout&lt;/code&gt; callback is called and updates &lt;code&gt;outerScopeVar&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; se registra en este caso porque &lt;code&gt;getMessage&lt;/code&gt; regresa antes de que se &lt;code&gt;setTimeout&lt;/code&gt; devoluci&amp;oacute;n de llamada &lt;code&gt;outerScopeVar&lt;/code&gt; y se actualiza externalScopeVar .</target>
        </trans-unit>
        <trans-unit id="ed49b1097a751bc8dfb2f4fa8d5282592dce48f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Fabr&amp;iacute;cio's answer is spot on; but I wanted to complement his answer with something less technical, which focusses on an analogy to help explain the concept of asynchronicity&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;La respuesta de Fabricio es acertada;&lt;/em&gt; &lt;em&gt;pero quer&amp;iacute;a complementar su respuesta con algo menos t&amp;eacute;cnico, que se centra en una analog&amp;iacute;a para ayudar a explicar el concepto de asincron&amp;iacute;a&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="d22e77c39b64987867f31bc641a2c7fd0c1f2f91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="289bea1f35eed1af7b8112d0f8c61f705d425958" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2778e9f54b08b0eccef6e1f5fe205c622cd3d03c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b0452ea54bfa19c34b31eea62b1df9bde0570907" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f20ea25a1c1f93d46c8a492286f9cf8254aea33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b346ab96e2b29b13b999bfffc88ff3a8086c76c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/primers/promises&quot;&gt;Promises&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/primers/promises&quot;&gt;Promises&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5a5d71dbf9e42228d1baf6d36e54cd389b38eea8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bob&lt;/strong&gt;: Sure thing, but it'll take me around 30 minutes?</source>
          <target state="translated">&lt;strong&gt;Bob&lt;/strong&gt; : Claro, pero &amp;iquest;me llevar&amp;aacute; unos 30 minutos?</target>
        </trans-unit>
        <trans-unit id="7fdddf9c3bee50f48d61f290501ea4e7b84eca27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Callbacks&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Callbacks&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3733084af55c2ff08a2c0a4af4d4f8d7dafdd1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: Hi Bob, I need to know how we &lt;em&gt;foo&lt;/em&gt;'d the &lt;em&gt;bar&lt;/em&gt;'d last week. Jim want's a report on it, and you're the only one who knows the details about it.</source>
          <target state="translated">&lt;strong&gt;Yo&lt;/strong&gt; : Hola Bob, necesito saber c&amp;oacute;mo &lt;em&gt;enga&amp;ntilde;amos&lt;/em&gt; al &lt;em&gt;bar&lt;/em&gt; la semana pasada. Jim quiere un informe al respecto, y t&amp;uacute; eres el &amp;uacute;nico que conoce los detalles al respecto.</target>
        </trans-unit>
        <trans-unit id="713f53e40c4562b4ab9eba6d6198debc536e516b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: Hi Bob, I need to know how we &lt;em&gt;foo&lt;/em&gt;'d the &lt;em&gt;bar&lt;/em&gt;'d last week. Jim wants a report on it, and you're the only one who knows the details about it.</source>
          <target state="translated">&lt;strong&gt;Yo&lt;/strong&gt; : Hola Bob, necesito saber c&amp;oacute;mo &lt;em&gt;enga&amp;ntilde;amos&lt;/em&gt; al &lt;em&gt;bar&lt;/em&gt; la semana pasada. Jim quiere un informe al respecto, y t&amp;uacute; eres el &amp;uacute;nico que conoce los detalles al respecto.</target>
        </trans-unit>
        <trans-unit id="696d9e23b68465a334ff08838685b593defebdc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: That's great Bob. Give me a ring back when you've got the information!</source>
          <target state="translated">&lt;strong&gt;Yo&lt;/strong&gt; : Eso es genial Bob. &amp;iexcl;Ll&amp;aacute;mame cuando tengas la informaci&amp;oacute;n!</target>
        </trans-unit>
        <trans-unit id="31595be6d48c2097c06c53e9214cf88db6632a77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: That's great Bob. I'll wait.</source>
          <target state="translated">&lt;strong&gt;Yo&lt;/strong&gt; : Eso es genial Bob. Esperar&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="c2fd0d38b0ab8484e639564a171161035b2a7b4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I'm using &lt;code&gt;setTimeout&lt;/code&gt; with a random delay as a generic asynchronous function, the same example applies to Ajax, &lt;code&gt;readFile&lt;/code&gt;, &lt;code&gt;onload&lt;/code&gt; and any other asynchronous flow.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; estoy usando &lt;code&gt;setTimeout&lt;/code&gt; con un retraso aleatorio como una funci&amp;oacute;n asincr&amp;oacute;nica gen&amp;eacute;rica, el mismo ejemplo se aplica a Ajax, &lt;code&gt;readFile&lt;/code&gt; , &lt;code&gt;onload&lt;/code&gt; y cualquier otro flujo asincr&amp;oacute;nico.</target>
        </trans-unit>
        <trans-unit id="5e39b2acd2b8bf115a6c7845f5b4a885b1f2ab18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I've marked this answer as Community Wiki, hence anyone with at least 100 reputations can edit and improve it! Please feel free to improve this answer, or submit a completely new answer if you'd like as well.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; He marcado esta respuesta como Wiki de la comunidad, por lo tanto, &amp;iexcl;cualquiera con al menos 100 reputaciones puede editarla y mejorarla! Por favor, si&amp;eacute;ntase libre de mejorar esta respuesta, o env&amp;iacute;e una respuesta completamente nueva si as&amp;iacute; lo desea.</target>
        </trans-unit>
        <trans-unit id="01a61e555cd8030fb7253b04500742128a3d6699" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is a canonical question for &lt;em&gt;JavaScript asynchronicity&lt;/em&gt;. Feel free to improve this question and add more simplified examples which the community can identify with.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Esta es una pregunta can&amp;oacute;nica para la &lt;em&gt;asincron&amp;iacute;a de JavaScript&lt;/em&gt; . Si&amp;eacute;ntase libre de mejorar esta pregunta y agregar ejemplos m&amp;aacute;s simplificados con los que la comunidad pueda identificarse.</target>
        </trans-unit>
        <trans-unit id="8fe8260d2797d89dec2d4d73b3d6171752b44d37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;async/await&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;async/await&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a0135ab690b1a17b0530e20999de06043814128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery &lt;a href=&quot;http://api.jquery.com/category/deferred-object/&quot;&gt;Deferreds&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery &lt;a href=&quot;http://api.jquery.com/category/deferred-object/&quot;&gt;diferidos&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dbe2dc81e7b8f642b5949e87b7c1af8324d0995c" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;* Technically you can use &lt;code&gt;eval()&lt;/code&gt; as well, but &lt;a href=&quot;https://stackoverflow.com/questions/86513/why-is-using-the-javascript-eval-function-a-bad-idea&quot;&gt;&lt;code&gt;eval()&lt;/code&gt; is evil&lt;/a&gt; for this purpose&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;* T&amp;eacute;cnicamente tambi&amp;eacute;n puedes usar &lt;code&gt;eval()&lt;/code&gt; , pero &lt;a href=&quot;https://stackoverflow.com/questions/86513/why-is-using-the-javascript-eval-function-a-bad-idea&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; es malo&lt;/a&gt; para este prop&amp;oacute;sito&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="193eae364dc628fc092cd8ef11b86139f36c9a36" translate="yes" xml:space="preserve">
          <source>@Benjamin Gruenbaum has also put a lot of effort explaining asynchronicity in the same thread.</source>
          <target state="translated">@Benjamin Gruenbaum también ha puesto mucho esfuerzo en explicar la asincronía en el mismo hilo.</target>
        </trans-unit>
        <trans-unit id="2616531e447d36623971529ada2669d82436aed6" translate="yes" xml:space="preserve">
          <source>All ajax calls (including the &lt;code&gt;$.get&lt;/code&gt; or &lt;code&gt;$.post&lt;/code&gt; or &lt;code&gt;$.ajax&lt;/code&gt;) are asynchronous.</source>
          <target state="translated">Todas las llamadas ajax (incluyendo &lt;code&gt;$.get&lt;/code&gt; o &lt;code&gt;$.post&lt;/code&gt; o &lt;code&gt;$.ajax&lt;/code&gt; ) son as&amp;iacute;ncronas.</target>
        </trans-unit>
        <trans-unit id="2a0a37ac5b8e47801b9f45a88a68c9a89cad5b91" translate="yes" xml:space="preserve">
          <source>All the code that depends on the asynchronous calls, is moved inside the asynchronous block, or by waiting on the asynchronous calls.</source>
          <target state="translated">Todo el código que depende de las llamadas asíncronas,se mueve dentro del bloque asíncrono,o esperando las llamadas asíncronas.</target>
        </trans-unit>
        <trans-unit id="1fb9670113b1c96e286f81efab4da12bc3d0e7ca" translate="yes" xml:space="preserve">
          <source>Although there are ways to keep the &lt;a href=&quot;http://callbackhell.com/&quot;&gt;callback hell&lt;/a&gt; at bay with vanilla JS, promises are growing in popularity and are currently being standardized in ES6 (see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise - MDN&lt;/a&gt;).</source>
          <target state="translated">Aunque hay formas de mantener a raya el &lt;a href=&quot;http://callbackhell.com/&quot;&gt;infierno de devoluci&amp;oacute;n de llamadas&lt;/a&gt; con vanilla JS, las promesas est&amp;aacute;n creciendo en popularidad y actualmente se est&amp;aacute;n estandarizando en ES6 (ver &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promesa - MDN&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3351fcf6c12d50fc0ac88805069aea142f975b54" translate="yes" xml:space="preserve">
          <source>An Analogy...</source>
          <target state="translated">Una analogía...</target>
        </trans-unit>
        <trans-unit id="5ab84d7fcdf6fb1318fe079454de14bc2e9d8e11" translate="yes" xml:space="preserve">
          <source>And I sat there and waited. And waited. And waited. For 40 minutes. Doing nothing but waiting. Eventually, Bob gave me the information, we hung up, and I completed my report. But I'd lost 40 minutes of productivity.</source>
          <target state="translated">Y me senté allí y esperé.Y esperé.Y esperé.Durante 40 minutos.Sin hacer nada más que esperar.Finalmente,Bob me dio la información,colgamos y completé mi informe.Pero había perdido 40 minutos de productividad.</target>
        </trans-unit>
        <trans-unit id="fda44874bfa419ff03d6f65b066d614159b645b1" translate="yes" xml:space="preserve">
          <source>Asynchronous execution is pushed out of the synchronous flow. That is, the asynchronous code will &lt;strong&gt;never&lt;/strong&gt; execute while the synchronous code stack is executing. This is the meaning of JavaScript being single-threaded.</source>
          <target state="translated">La ejecuci&amp;oacute;n asincr&amp;oacute;nica se elimina del flujo sincr&amp;oacute;nico. Es decir, el c&amp;oacute;digo asincr&amp;oacute;nico &lt;strong&gt;nunca se&lt;/strong&gt; ejecutar&amp;aacute; mientras se ejecuta la pila de c&amp;oacute;digo s&amp;iacute;ncrono. Este es el significado de JavaScript con un solo subproceso.</target>
        </trans-unit>
        <trans-unit id="3eaa02daa9e2fa7476ef359c4e92ddb36ff3ccfa" translate="yes" xml:space="preserve">
          <source>Asynchronous functions be like...</source>
          <target state="translated">Las funciones asíncronas son como...</target>
        </trans-unit>
        <trans-unit id="43f59b64684b4ec6e77bc10459d2c89df596e351" translate="yes" xml:space="preserve">
          <source>At this point, I hung up the phone. Since I needed information from Bob to complete my report, I left the report and went for a coffee instead, then I caught up on some email. 40 minutes later (Bob is slow), Bob called back and gave me the information I needed. At this point, I resumed my work with my report, as I had all the information I needed.</source>
          <target state="translated">En este punto,colgué el teléfono.Como necesitaba información de Bob para completar mi informe,dejé el informe y me fui a tomar un café en su lugar,luego me puse al día con un correo electrónico.40 minutos más tarde (Bob es lento),Bob me llamó y me dio la información que necesitaba.En ese momento,reanudé mi trabajo con mi informe,ya que tenía toda la información que necesitaba.</target>
        </trans-unit>
        <trans-unit id="b103b8d3480de02206ccf798fcaa01817ae2396c" translate="yes" xml:space="preserve">
          <source>Code snippet of the above example:</source>
          <target state="translated">Fragmento de código del ejemplo anterior:</target>
        </trans-unit>
        <trans-unit id="d268a2e26266d8a732fbf03fc545f77a1511cad7" translate="yes" xml:space="preserve">
          <source>Considering your example</source>
          <target state="translated">Considerando su ejemplo</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="4161388d0bc1d4981fe7e703476edf485adb1e23" translate="yes" xml:space="preserve">
          <source>Forewords</source>
          <target state="translated">Forewords</target>
        </trans-unit>
        <trans-unit id="9ff1e84bc1df7325df3d395b27e23dde1e64014a" translate="yes" xml:space="preserve">
          <source>Given the following examples, why is &lt;code&gt;outerScopeVar&lt;/code&gt; undefined in all cases?</source>
          <target state="translated">Dados los siguientes ejemplos, &amp;iquest;por qu&amp;eacute; &lt;code&gt;outerScopeVar&lt;/code&gt; no est&amp;aacute; definido en todos los casos?</target>
        </trans-unit>
        <trans-unit id="90acfeac32c622ee5ef1932cf600a7a4910a15ba" translate="yes" xml:space="preserve">
          <source>Here the timeout event plays the role, which will invoke the handler after the specified time. Here it is &lt;code&gt;0&lt;/code&gt;, but still it registers an asynchronous event it will be added to the last position of the &lt;code&gt;Event Queue&lt;/code&gt; for execution, which makes the guaranteed delay.</source>
          <target state="translated">Aqu&amp;iacute; el evento de tiempo de espera juega el papel, que invocar&amp;aacute; al controlador despu&amp;eacute;s del tiempo especificado. Aqu&amp;iacute; es &lt;code&gt;0&lt;/code&gt; , pero a&amp;uacute;n as&amp;iacute; registra un evento asincr&amp;oacute;nico que se agregar&amp;aacute; a la &amp;uacute;ltima posici&amp;oacute;n de la &lt;code&gt;Event Queue&lt;/code&gt; para su ejecuci&amp;oacute;n, lo que hace que el retraso est&amp;eacute; garantizado.</target>
        </trans-unit>
        <trans-unit id="c0ccb8fb1c710d25514aa41de1cf403d4866d1fc" translate="yes" xml:space="preserve">
          <source>Here we register an eventlistner which will be executed upon that particular event.Here loading of image.Then the current execution continuous with next lines &lt;code&gt;img.src = 'lolcat.png';&lt;/code&gt; and &lt;code&gt;alert(outerScopeVar);&lt;/code&gt; meanwhile the event may not occur. i.e, funtion &lt;code&gt;img.onload&lt;/code&gt; wait for the referred image to load, asynchrously. This will happen all the folowing example- the event may differ.</source>
          <target state="translated">Aqu&amp;iacute; registramos un eventlistner que se ejecutar&amp;aacute; en ese evento en particular. Aqu&amp;iacute; se carga la imagen. Luego, la ejecuci&amp;oacute;n actual contin&amp;uacute;a con las siguientes l&amp;iacute;neas &lt;code&gt;img.src = 'lolcat.png';&lt;/code&gt; y &lt;code&gt;alert(outerScopeVar);&lt;/code&gt; mientras tanto el evento puede no ocurrir. es decir, la funci&amp;oacute;n &lt;code&gt;img.onload&lt;/code&gt; espera a que la imagen referida se cargue, as&amp;iacute;ncronamente. Esto suceder&amp;aacute; todo el siguiente ejemplo: el evento puede diferir.</target>
        </trans-unit>
        <trans-unit id="9513c4fd164bc6e4b493627615a49084822fe3c0" translate="yes" xml:space="preserve">
          <source>Here's a more concise answer for people that are looking for a quick reference as well as some examples using promises and async/await.</source>
          <target state="translated">Aquí hay una respuesta más concisa para las personas que buscan una referencia rápida,así como algunos ejemplos utilizando promesas y asincawait.</target>
        </trans-unit>
        <trans-unit id="b6008160b60a5356b4ee831a5e643f9f9bec0f29" translate="yes" xml:space="preserve">
          <source>How do I keep my caller waiting?</source>
          <target state="translated">¿Cómo hago esperar a la persona que me llama?</target>
        </trans-unit>
        <trans-unit id="5376e14e843406f61ac87403197fd8d1d7434c5e" translate="yes" xml:space="preserve">
          <source>However, we now know that the &lt;code&gt;return outerScopeVar&lt;/code&gt; happens immediately; before the &lt;code&gt;onload&lt;/code&gt; callback function has updated the variable. This leads to &lt;code&gt;getWidthOfImage()&lt;/code&gt; returning &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;undefined&lt;/code&gt; being alerted.</source>
          <target state="translated">Sin embargo, ahora sabemos que el &lt;code&gt;return outerScopeVar&lt;/code&gt; ocurre inmediatamente; antes de que la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada de &lt;code&gt;onload&lt;/code&gt; haya actualizado la variable. Esto lleva a que &lt;code&gt;getWidthOfImage()&lt;/code&gt; regrese &lt;code&gt;undefined&lt;/code&gt; , y que &lt;code&gt;undefined&lt;/code&gt; sea ​​alertado.</target>
        </trans-unit>
        <trans-unit id="e6239a14687cbf4f9e4e299f4f10e3f1d0d8290b" translate="yes" xml:space="preserve">
          <source>I want to turn this question into a canonical topic to answer asynchronicity issues which are unrelated to Ajax (there is &lt;a href=&quot;https://stackoverflow.com/q/14220321/1331430&quot;&gt;How to return the response from an AJAX call?&lt;/a&gt; for that), hence this topic needs your help to be as good and helpful as possible!</source>
          <target state="translated">Quiero convertir esta pregunta en un tema can&amp;oacute;nico para responder a problemas de asincron&amp;iacute;a que no est&amp;aacute;n relacionados con Ajax (hay &lt;a href=&quot;https://stackoverflow.com/q/14220321/1331430&quot;&gt;&amp;iquest;C&amp;oacute;mo devolver la respuesta de una llamada AJAX?&lt;/a&gt; Para eso), por lo tanto, este tema necesita su ayuda para ser lo m&amp;aacute;s bueno y &amp;uacute;til posible !</target>
        </trans-unit>
        <trans-unit id="c6867acba73dcc3d63f6f6a677d4a3c0f03b6e0a" translate="yes" xml:space="preserve">
          <source>If your JavaScript environment includes support for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; (like Node.js 7.6+), then you can use promises synchronously within &lt;code&gt;async&lt;/code&gt; functions:</source>
          <target state="translated">Si su entorno de JavaScript incluye soporte para &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; &lt;/a&gt; (como Node.js 7.6+), entonces puede usar promesas sincr&amp;oacute;nicamente dentro de las funciones &lt;code&gt;async&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cbe7623af9f69417f8c30820f0ea3f8da88b935e" translate="yes" xml:space="preserve">
          <source>Imagine if the conversation had gone like this instead;</source>
          <target state="translated">Imagina si la conversación hubiera sido así;</target>
        </trans-unit>
        <trans-unit id="d94c2a88c0873ea1bc503304b1c42af08fccd5f4" translate="yes" xml:space="preserve">
          <source>Implementing your own callback logic</source>
          <target state="translated">Implementar su propia lógica de devolución de llamada</target>
        </trans-unit>
        <trans-unit id="19eaef30713ec40985dd7ae805fde594db8f511d" translate="yes" xml:space="preserve">
          <source>In all cases, we have a callback which may run &lt;em&gt;sometime in the future&lt;/em&gt;. This &quot;sometime in the future&quot; is what we refer to as &lt;strong&gt;asynchronous flow&lt;/strong&gt;.</source>
          <target state="translated">En todos los casos, tenemos una devoluci&amp;oacute;n de llamada que puede ejecutarse &lt;em&gt;en alg&amp;uacute;n momento en el futuro&lt;/em&gt; . Este &quot;en alg&amp;uacute;n momento en el futuro&quot; es lo que llamamos &lt;strong&gt;flujo as&amp;iacute;ncrono&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="135bd88cbd59b18dc1f9b7be855f8e4fa92e1f0e" translate="yes" xml:space="preserve">
          <source>In all these scenarios &lt;code&gt;outerScopeVar&lt;/code&gt; is modified or assigned a value &lt;strong&gt;asynchronously&lt;/strong&gt; or &lt;strong&gt;happening in a later time(waiting or listening for some event to occur),for which the current execution will not wait&lt;/strong&gt;.So all these cases current execution flow results in &lt;code&gt;outerScopeVar = undefined&lt;/code&gt;</source>
          <target state="translated">En todos estos escenarios, &lt;code&gt;outerScopeVar&lt;/code&gt; se modifica o se le asigna un valor de &lt;strong&gt;forma asincr&amp;oacute;nica&lt;/strong&gt; o &lt;strong&gt;sucede en un momento posterior (esperando o escuchando que ocurra alg&amp;uacute;n evento), por lo que la ejecuci&amp;oacute;n actual no esperar&amp;aacute;&lt;/strong&gt; . Por lo tanto, todos estos casos el flujo de ejecuci&amp;oacute;n actual da como resultado &lt;code&gt;outerScopeVar = undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dfc2217afad206d82ab1c489045154e363b8cd2a" translate="yes" xml:space="preserve">
          <source>In order to fix our code, all we have to do is move the &lt;code&gt;alert(outerScopeVar)&lt;/code&gt; code &lt;em&gt;into&lt;/em&gt; the callback function. As a consequence of this, we no longer need the &lt;code&gt;outerScopeVar&lt;/code&gt; variable declared as a global variable.</source>
          <target state="translated">Para arreglar nuestro c&amp;oacute;digo, todo lo que tenemos que hacer es mover el c&amp;oacute;digo de &lt;code&gt;alert(outerScopeVar)&lt;/code&gt; &lt;em&gt;a&lt;/em&gt; la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada. Como consecuencia de esto, ya no necesitamos la variable &lt;code&gt;outerScopeVar&lt;/code&gt; declarada como una variable global.</target>
        </trans-unit>
        <trans-unit id="219fa966e4403c99f93745961a66347fdd6ee889" translate="yes" xml:space="preserve">
          <source>In real life scenario, the code becomes,</source>
          <target state="translated">En el escenario de la vida real,el código se convierte,</target>
        </trans-unit>
        <trans-unit id="729a2882bffa8796d64097b884d3520508f6cc3c" translate="yes" xml:space="preserve">
          <source>In short, the callback functions are created synchronously but executed asynchronously. You just can't rely on the execution of an asynchronous function until you know it has executed, and how to do that?</source>
          <target state="translated">En resumen,las funciones de devolución de llamada se crean sincrónicamente pero se ejecutan asincrónicamente.No puedes confiar en la ejecución de una función asíncrona hasta que sepas que se ha ejecutado,¿y cómo hacerlo?</target>
        </trans-unit>
        <trans-unit id="c30a8d270de5576c077f0fa84b762b1e781bf74b" translate="yes" xml:space="preserve">
          <source>In the code above, we're asking JavaScript to load &lt;code&gt;lolcat.png&lt;/code&gt;, which is a &lt;em&gt;sloooow&lt;/em&gt; operation. The callback function will be executed once this slow operation has done, but in the meantime, JavaScript will keep processing the next lines of code; i.e. &lt;code&gt;alert(outerScopeVar)&lt;/code&gt;.</source>
          <target state="translated">En el c&amp;oacute;digo anterior, le pedimos a JavaScript que cargue &lt;code&gt;lolcat.png&lt;/code&gt; , que es una operaci&amp;oacute;n &lt;em&gt;lenta&lt;/em&gt; . La funci&amp;oacute;n de devoluci&amp;oacute;n de llamada se ejecutar&amp;aacute; una vez que esta operaci&amp;oacute;n lenta haya terminado, pero mientras tanto, JavaScript seguir&amp;aacute; procesando las siguientes l&amp;iacute;neas de c&amp;oacute;digo; es decir, &lt;code&gt;alert(outerScopeVar)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41d2083ae42e2602204895d28ef21aeaac582cb0" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;return&lt;/code&gt;ing a value from an asynchronous callback, you will have to make use of the callback pattern, or... Promises.</source>
          <target state="translated">En lugar de &lt;code&gt;return&lt;/code&gt; un valor de una devoluci&amp;oacute;n de llamada asincr&amp;oacute;nica, deber&amp;aacute; utilizar el patr&amp;oacute;n de devoluci&amp;oacute;n de llamada o ... Promesas.</target>
        </trans-unit>
        <trans-unit id="0cc7a9dd54f8bbb52fefe95aa868d2fb8e4076e2" translate="yes" xml:space="preserve">
          <source>It depends on the case. Let's try to trace some common behavior again:</source>
          <target state="translated">Depende del caso.Intentemos rastrear algún comportamiento común de nuevo:</target>
        </trans-unit>
        <trans-unit id="fb2ea5baac3ad36c938aef8df244432e62524de2" translate="yes" xml:space="preserve">
          <source>It is simple, really. The logic that depends on the asynchronous function execution should be started/called from inside this asynchronous function. For example, moving the &lt;code&gt;alert&lt;/code&gt;s and &lt;code&gt;console.log&lt;/code&gt;s too inside the callback function would output the expected result, because the result is available at that point.</source>
          <target state="translated">Es simple, de verdad. La l&amp;oacute;gica que depende de la ejecuci&amp;oacute;n de la funci&amp;oacute;n asincr&amp;oacute;nica debe iniciarse / invocarse desde esta funci&amp;oacute;n asincr&amp;oacute;nica. Por ejemplo, mover las &lt;code&gt;alert&lt;/code&gt; as sy &lt;code&gt;console.log&lt;/code&gt; s tambi&amp;eacute;n dentro de la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada generar&amp;iacute;a el resultado esperado, porque el resultado est&amp;aacute; disponible en ese punto.</target>
        </trans-unit>
        <trans-unit id="f833c4bc8e7973b5c0788881a871357c0b979a45" translate="yes" xml:space="preserve">
          <source>JavaScript Promises - HTML5 Rocks</source>
          <target state="translated">Promesas de JavaScript-HTML5 Rocas</target>
        </trans-unit>
        <trans-unit id="7e1a19f21ecf74a20fd1fc528e7a374bc5f9c8d9" translate="yes" xml:space="preserve">
          <source>Let's discuss each examples(I marked the portion which is called asynchronously or delayed for some events to occur):</source>
          <target state="translated">Veamos cada ejemplo (marqué la parte que se llama asincrónica o retrasada para que ocurran algunos eventos):</target>
        </trans-unit>
        <trans-unit id="638c1153b14aa1b9d097c6dcdd2c2f61b8c583bf" translate="yes" xml:space="preserve">
          <source>Let's tackle it implementing a callback system of our own. First off, we get rid of that ugly &lt;code&gt;outerScopeVar&lt;/code&gt; which is completely useless in this case. Then we add a parameter which accepts a function argument, our callback. When the asynchronous operation finishes, we call this callback passing the result. The implementation (please read the comments in order):</source>
          <target state="translated">Vamos a abordarlo implementando un sistema de devoluci&amp;oacute;n de llamada propio. En primer lugar, nos deshacemos de ese feo &lt;code&gt;outerScopeVar&lt;/code&gt; que es completamente in&amp;uacute;til en este caso. Luego agregamos un par&amp;aacute;metro que acepta un argumento de funci&amp;oacute;n, nuestra devoluci&amp;oacute;n de llamada. Cuando finaliza la operaci&amp;oacute;n asincr&amp;oacute;nica, llamamos a esta devoluci&amp;oacute;n de llamada pasando el resultado. La implementaci&amp;oacute;n (lea los comentarios en orden):</target>
        </trans-unit>
        <trans-unit id="487666eb364c70eb737ac6495aa0ccd4f8d13ba0" translate="yes" xml:space="preserve">
          <source>Let's trace the common behavior first. In all examples, the &lt;code&gt;outerScopeVar&lt;/code&gt; is modified inside of a &lt;em&gt;function&lt;/em&gt;. That function is clearly not executed immediately, it is being assigned or passed as an argument. That is what we call a &lt;strong&gt;&lt;em&gt;callback&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">Tracemos el comportamiento com&amp;uacute;n primero. En todos los ejemplos, la &lt;code&gt;outerScopeVar&lt;/code&gt; se modifica dentro de una &lt;em&gt;funci&amp;oacute;n&lt;/em&gt; . Es evidente que esa funci&amp;oacute;n no se ejecuta de inmediato, se est&amp;aacute; asignando o pasando como argumento. Eso es lo que llamamos una &lt;strong&gt;&lt;em&gt;devoluci&amp;oacute;n de llamada&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="7adf46b8af10f9ffba635ac39fa32e59eedd72ea" translate="yes" xml:space="preserve">
          <source>Lets say that the post request takes 10 seconds to complete, the value of &lt;code&gt;outerScopeVar&lt;/code&gt; will only be set after those 10 seconds.</source>
          <target state="translated">Digamos que la solicitud de publicaci&amp;oacute;n tarda 10 segundos en completarse, el valor de &lt;code&gt;outerScopeVar&lt;/code&gt; solo se establecer&amp;aacute; despu&amp;eacute;s de esos 10 segundos.</target>
        </trans-unit>
        <trans-unit id="2cd4cb675addf1e7a7a8765c722dcd18f39a2b27" translate="yes" xml:space="preserve">
          <source>More reading material about JavaScript asynchronicity</source>
          <target state="translated">Más material de lectura sobre la asincronía de JavaScript</target>
        </trans-unit>
        <trans-unit id="36f8fb94265b7a738324676d4ddedf0f7f8be952" translate="yes" xml:space="preserve">
          <source>More specifically, when the JS engine is idle -- not executing a stack of (a)synchronous code -- it will poll for events that may have triggered asynchronous callbacks (e.g. expired timeout, received network response) and execute them one after another. This is regarded as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop&quot;&gt;Event Loop&lt;/a&gt;.</source>
          <target state="translated">M&amp;aacute;s espec&amp;iacute;ficamente, cuando el motor JS est&amp;aacute; inactivo, sin ejecutar una pila de (a) c&amp;oacute;digo s&amp;iacute;ncrono, sondear&amp;aacute; los eventos que pueden haber desencadenado devoluciones de llamada asincr&amp;oacute;nicas (por ejemplo, tiempo de espera expirado, respuesta de red recibida) y las ejecutar&amp;aacute; una tras otra. Esto se considera como &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop&quot;&gt;Event Loop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="027fcce6dca0e5452f5c3ae77d3776d83b9cb117" translate="yes" xml:space="preserve">
          <source>Most often in real use cases, the DOM API and most libraries already provide the callback functionality (the &lt;code&gt;helloCatAsync&lt;/code&gt; implementation in this demonstrative example). You only need to pass the callback function and understand that it will execute out of the synchronous flow, and restructure your code to accommodate for that.</source>
          <target state="translated">Con mayor frecuencia en casos de uso real, la API DOM y la mayor&amp;iacute;a de las bibliotecas ya proporcionan la funcionalidad de devoluci&amp;oacute;n de llamada (la implementaci&amp;oacute;n de &lt;code&gt;helloCatAsync&lt;/code&gt; en este ejemplo demostrativo). Solo necesita pasar la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada y comprender que se ejecutar&amp;aacute; fuera del flujo sincr&amp;oacute;nico, y reestructurar su c&amp;oacute;digo para acomodarlo.</target>
        </trans-unit>
        <trans-unit id="0dcfbb375ba4904c46d6dce14e7309a4eb9988dc" translate="yes" xml:space="preserve">
          <source>Node can be consider as a king of asynchronous coding.Here the marked function is registered as a callback handler which will be executed after reading the specified file.</source>
          <target state="translated">El nodo puede considerarse como un rey de la codificación asíncrona.Aquí la función marcada se registra como un manejador de devolución de llamada que se ejecutará después de leer el archivo especificado.</target>
        </trans-unit>
        <trans-unit id="b216c6131cd7d019cbd3e050a3a8d93e5b049385" translate="yes" xml:space="preserve">
          <source>Node.js's &lt;code&gt;fs.readFile&lt;/code&gt; may be called &lt;em&gt;sometime in the future&lt;/em&gt;, when the file has been read successfully or thrown an error.</source>
          <target state="translated">&lt;code&gt;fs.readFile&lt;/code&gt; puede llamar a fs.readFile de Node.js en alg&amp;uacute;n &lt;em&gt;momento en el futuro&lt;/em&gt; , cuando el archivo se haya le&amp;iacute;do correctamente o se haya producido un error.</target>
        </trans-unit>
        <trans-unit id="edba6c23726045806eaa1d7bc5d696075358f973" translate="yes" xml:space="preserve">
          <source>Now the question is, when is that callback called?</source>
          <target state="translated">Ahora la pregunta es,¿cuándo se llama esa llamada?</target>
        </trans-unit>
        <trans-unit id="6cdece044e170983c1f5cab467ce941e2ddd0dde" translate="yes" xml:space="preserve">
          <source>Now when you execute this, you would get an alert on line 3. Now wait for some time until you are sure the post request has returned some value. Then when you click OK, on the alert box, next alert would print the expected value, because you waited for it.</source>
          <target state="translated">Ahora,cuando ejecuten esto,recibirán una alerta en la línea 3.Ahora espera un poco de tiempo hasta que estés seguro de que la solicitud de correo ha devuelto algún valor.Entonces cuando hagas clic en OK,en la casilla de alerta,la siguiente alerta imprimirá el valor esperado,porque lo esperaste.</target>
        </trans-unit>
        <trans-unit id="8f7e7c308a72af2805417b772be3373d55f7aa67" translate="yes" xml:space="preserve">
          <source>Obvious promise (something will be done in future) is asynchronous. see &lt;a href=&quot;https://stackoverflow.com/questions/6801283/what-are-the-differences-between-deferred-promise-and-future-in-javascript&quot;&gt;What are the differences between Deferred, Promise and Future in JavaScript?&lt;/a&gt;</source>
          <target state="translated">La promesa obvia (se har&amp;aacute; algo en el futuro) es as&amp;iacute;ncrona. ver &lt;a href=&quot;https://stackoverflow.com/questions/6801283/what-are-the-differences-between-deferred-promise-and-future-in-javascript&quot;&gt;&amp;iquest;Cu&amp;aacute;les son las diferencias entre diferido, promesa y futuro en JavaScript?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="acfa95439c5b3dfbc3f590cb3d6cbc5140d0725d" translate="yes" xml:space="preserve">
          <source>Often you need to do more things with the result from an asynchronous function or do different things with the result depending on where the asynchronous function has been called. Let's tackle a bit more complex example:</source>
          <target state="translated">A menudo es necesario hacer más cosas con el resultado de una función asíncrona o hacer cosas diferentes con el resultado dependiendo de dónde se ha llamado la función asíncrona.Vamos a abordar un ejemplo un poco más complejo:</target>
        </trans-unit>
        <trans-unit id="69aae8a529faeef3bf34a8f29a9aeb27faa6c60a" translate="yes" xml:space="preserve">
          <source>One word answer: &lt;strong&gt;asynchronicity&lt;/strong&gt;.</source>
          <target state="translated">Respuesta de una palabra: &lt;strong&gt;asincron&amp;iacute;a&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b1d472e424c03ff52490d1edc8a0e23f95babb92" translate="yes" xml:space="preserve">
          <source>Promises</source>
          <target state="translated">Promises</target>
        </trans-unit>
        <trans-unit id="6d9d164125b7cac2630c27b4a009417447162bf7" translate="yes" xml:space="preserve">
          <source>Promises (a.k.a. Futures) provide a more linear, and thus pleasant, reading of the asynchronous code, but explaining their entire functionality is out of the scope of this question. Instead, I'll leave these excellent resources for the interested:</source>
          <target state="translated">Las promesas (también conocidas como futuros)proporcionan una lectura más lineal,y por lo tanto agradable,del código asíncrono,pero explicar toda su funcionalidad está fuera del alcance de esta cuestión.En su lugar,dejaré estos excelentes recursos para los interesados:</target>
        </trans-unit>
        <trans-unit id="cb68ff088476aec4be87b92843cdbef82052867f" translate="yes" xml:space="preserve">
          <source>Promises provide an alternative which is more flexible than callbacks because they can be naturally combined to coordinate multiple async operations. A &lt;a href=&quot;https://promisesaplus.com/&quot;&gt;Promises/A+&lt;/a&gt; standard implementation is natively provided in node.js (0.12+) and many current browsers, but is also implemented in libraries like &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;Bluebird&lt;/a&gt; and &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt;.</source>
          <target state="translated">Las promesas proporcionan una alternativa que es m&amp;aacute;s flexible que las devoluciones de llamada porque se pueden combinar de forma natural para coordinar m&amp;uacute;ltiples operaciones as&amp;iacute;ncronas. Una implementaci&amp;oacute;n est&amp;aacute;ndar de &lt;a href=&quot;https://promisesaplus.com/&quot;&gt;Promises / A +&lt;/a&gt; se proporciona de forma nativa en node.js (0.12+) y muchos navegadores actuales, pero tambi&amp;eacute;n se implementa en bibliotecas como &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;Bluebird&lt;/a&gt; y &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d7c2ad2dddc44dedd1e96fb0db1f59589562e3c" translate="yes" xml:space="preserve">
          <source>Rather than &lt;em&gt;waiting&lt;/em&gt; for these slow operations to complete, JavaScript lets you register a callback function which will be executed when the slow operation has completed. In the meantime, however, JavaScript will continue to execute other code. The fact that JavaScript executes &lt;em&gt;other code&lt;/em&gt; whilst waiting for the slow operation to complete makes the behavior&lt;strong&gt;asynchronous&lt;/strong&gt;. Had JavaScript waited around for the operation to complete before executing any other code, this would have been &lt;strong&gt;synchronous&lt;/strong&gt; behavior.</source>
          <target state="translated">En lugar de &lt;em&gt;esperar&lt;/em&gt; a que se completen estas operaciones lentas, JavaScript le permite registrar una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada que se ejecutar&amp;aacute; cuando se complete la operaci&amp;oacute;n lenta. Mientras tanto, sin embargo, JavaScript continuar&amp;aacute; ejecutando otro c&amp;oacute;digo. El hecho de que JavaScript ejecute &lt;em&gt;otro c&amp;oacute;digo&lt;/em&gt; mientras espera que se complete la operaci&amp;oacute;n lenta hace que el comportamiento sea &lt;strong&gt;as&amp;iacute;ncrono&lt;/strong&gt; . Si JavaScript hubiera esperado a que se completara la operaci&amp;oacute;n antes de ejecutar cualquier otro c&amp;oacute;digo, este habr&amp;iacute;a sido &lt;strong&gt;un&lt;/strong&gt; comportamiento &lt;strong&gt;sincr&amp;oacute;nico&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8f3fc1e296aaa81836928351f23624856a1de71b" translate="yes" xml:space="preserve">
          <source>Start with the naive approach (that doesn't work) for a function that calls an asynchronous method (in this case &lt;code&gt;setTimeout&lt;/code&gt;) and returns a message:</source>
          <target state="translated">Comience con el enfoque ingenuo (que no funciona) para una funci&amp;oacute;n que llama a un m&amp;eacute;todo asincr&amp;oacute;nico (en este caso, &lt;code&gt;setTimeout&lt;/code&gt; ) y devuelve un mensaje:</target>
        </trans-unit>
        <trans-unit id="fb0e4798cb170cfc40f0368e44f763affdfd54e9" translate="yes" xml:space="preserve">
          <source>That is, the asynchronous code highlighted in the hand-drawn red shapes may execute only after all the remaining synchronous code in their respective code blocks have executed:</source>
          <target state="translated">Es decir,el código asíncrono resaltado en las formas rojas dibujadas a mano sólo puede ejecutarse después de que se haya ejecutado todo el código síncrono restante en sus respectivos bloques de código:</target>
        </trans-unit>
        <trans-unit id="0a9be42f4d2ec4950f69e0eb67c25bd4ebaa41c0" translate="yes" xml:space="preserve">
          <source>The answer to the question at hand</source>
          <target state="translated">La respuesta a la pregunta en cuestión</target>
        </trans-unit>
        <trans-unit id="0f58e0d8b311cbdc96d07934de3ac62c55d87691" translate="yes" xml:space="preserve">
          <source>The change here is that &lt;code&gt;getMessage&lt;/code&gt; accepts a &lt;code&gt;callback&lt;/code&gt; parameter that will be called to deliver the results back to the calling code once available.</source>
          <target state="translated">El cambio aqu&amp;iacute; es que &lt;code&gt;getMessage&lt;/code&gt; acepta un par&amp;aacute;metro de &lt;code&gt;callback&lt;/code&gt; que se llamar&amp;aacute; para devolver los resultados al c&amp;oacute;digo de llamada una vez que est&amp;eacute; disponible.</target>
        </trans-unit>
        <trans-unit id="dfbc4999399aec4a2d69483e59a7728ba63f4f53" translate="yes" xml:space="preserve">
          <source>The code execution starts from line 1, declares the variable and triggers and asynchronous call on line 2, (i.e., the post request) and it continues its execution from line 3, without waiting for the post request to complete its execution.</source>
          <target state="translated">La ejecución del código comienza en la línea 1,declara la variable y activa la llamada asíncrona en la línea 2,(es decir,la solicitud de correo)y continúa su ejecución desde la línea 3,sin esperar a que la solicitud de correo complete su ejecución.</target>
        </trans-unit>
        <trans-unit id="9d15198b66c44aa363b53458036280b399cb3f48" translate="yes" xml:space="preserve">
          <source>The other answers are excellent and I just want to provide a straight forward answer to this. Just limiting to jQuery asynchronous calls</source>
          <target state="translated">Las otras respuestas son excelentes y sólo quiero dar una respuesta directa a esto.Limitándome a las llamadas asincrónicas de jQuery</target>
        </trans-unit>
        <trans-unit id="d52589835b03cdf8d7ac3617f883151bd0f44bc6" translate="yes" xml:space="preserve">
          <source>The two main ways to solve it are using &lt;strong&gt;callbacks&lt;/strong&gt; and &lt;strong&gt;promises&lt;/strong&gt;:</source>
          <target state="translated">Las dos formas principales de resolverlo son mediante &lt;strong&gt;devoluciones de llamada&lt;/strong&gt; y &lt;strong&gt;promesas&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="4f5b392d075945718f406191e510986ae67301e9" translate="yes" xml:space="preserve">
          <source>Therefore, in all of our examples, the &lt;code&gt;function() { /* Do something */ }&lt;/code&gt; is the callback; to fix &lt;strong&gt;all&lt;/strong&gt; the examples, all we have to do is move the code which needs the response of the operation into there!</source>
          <target state="translated">Por lo tanto, en todos nuestros ejemplos, la &lt;code&gt;function() { /* Do something */ }&lt;/code&gt; es la devoluci&amp;oacute;n de llamada; Para arreglar &lt;strong&gt;todos&lt;/strong&gt; los ejemplos, todo lo que tenemos que hacer es mover el c&amp;oacute;digo que necesita la respuesta de la operaci&amp;oacute;n all&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="91fe005c7b9a8de24f4645e8f363dbc2e0529353" translate="yes" xml:space="preserve">
          <source>This example clearly suffers from the same issue as the other examples, it is not waiting until the asynchronous function executes.</source>
          <target state="translated">Este ejemplo sufre claramente de la misma cuestión que los otros ejemplos,no espera a que se ejecute la función asíncrona.</target>
        </trans-unit>
        <trans-unit id="ffac965ab18c7d09429e1769cd6077e8cb88d4ef" translate="yes" xml:space="preserve">
          <source>This is asynchronous vs. synchronous behavior</source>
          <target state="translated">Este es un comportamiento asíncrono contra síncrono</target>
        </trans-unit>
        <trans-unit id="4a9f0c688c7a4ad3c6e910681cbfa516c1908817" translate="yes" xml:space="preserve">
          <source>This is exactly what is happening in all the examples in our question. Loading an image, loading a file off disk, and requesting a page via AJAX are all slow operations (in the context of modern computing).</source>
          <target state="translated">Esto es exactamente lo que está sucediendo en todos los ejemplos de nuestra pregunta.Cargar una imagen,cargar un archivo fuera del disco y solicitar una página a través de AJAX son operaciones lentas (en el contexto de la informática moderna).</target>
        </trans-unit>
        <trans-unit id="f707894961ab83a7c6e333b28e7f9931e3824aa4" translate="yes" xml:space="preserve">
          <source>This is why we see the alert showing &lt;code&gt;undefined&lt;/code&gt;; since the &lt;code&gt;alert()&lt;/code&gt; is processed immediately, rather than after the image has been loaded.</source>
          <target state="translated">Por eso vemos que la alerta se muestra &lt;code&gt;undefined&lt;/code&gt; ; ya que la &lt;code&gt;alert()&lt;/code&gt; se procesa inmediatamente, en lugar de despu&amp;eacute;s de que se haya cargado la imagen.</target>
        </trans-unit>
        <trans-unit id="f2e10d930e731050a7b6c7e2eaf695b3876a9b2e" translate="yes" xml:space="preserve">
          <source>This time ajax callback.</source>
          <target state="translated">Esta vez,Ajax me ha devuelto la llamada.</target>
        </trans-unit>
        <trans-unit id="42b9aece256629e1f3ae7fd0b418fdce8ba1bf5d" translate="yes" xml:space="preserve">
          <source>This topic has been iterated at least a couple of thousands of times, here, in Stack Overflow. Hence, first off I'd like to point out some extremely useful resources:</source>
          <target state="translated">Este tema ha sido repetido al menos un par de miles de veces,aquí,en Stack Overflow.Por lo tanto,en primer lugar me gustaría señalar algunos recursos extremadamente útiles:</target>
        </trans-unit>
        <trans-unit id="b45bcc49f561af62860de0ba678026a934aa6d4c" translate="yes" xml:space="preserve">
          <source>To fix this, we need to allow the function calling &lt;code&gt;getWidthOfImage()&lt;/code&gt; to register a callback, then move the alert'ing of the width to be within that callback;</source>
          <target state="translated">Para solucionar esto, debemos permitir que la funci&amp;oacute;n que llama a &lt;code&gt;getWidthOfImage()&lt;/code&gt; registre una devoluci&amp;oacute;n de llamada, luego mueva la alerta del ancho para que est&amp;eacute; dentro de esa devoluci&amp;oacute;n de llamada;</target>
        </trans-unit>
        <trans-unit id="efd3968d8235a10f87b53e88a27d4485fcc5fe25" translate="yes" xml:space="preserve">
          <source>To state the obvious, the cup represents &lt;code&gt;outerScopeVar&lt;/code&gt;.</source>
          <target state="translated">Para decir lo obvio, la copa representa &lt;code&gt;outerScopeVar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4db799b398211e889d65554156059060d81f356d" translate="yes" xml:space="preserve">
          <source>To try out,</source>
          <target state="translated">Para probar,</target>
        </trans-unit>
        <trans-unit id="90422ad2e2bbc1c8f4a48927d8b73dd5160a2e66" translate="yes" xml:space="preserve">
          <source>Why does it output &lt;code&gt;undefined&lt;/code&gt; in all of these examples? I don't want workarounds, I want to know &lt;strong&gt;why&lt;/strong&gt; this is happening.</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; sale &lt;code&gt;undefined&lt;/code&gt; en todos estos ejemplos? No quiero soluciones, quiero saber &lt;strong&gt;por qu&amp;eacute;&lt;/strong&gt; sucede esto.</target>
        </trans-unit>
        <trans-unit id="c4936bc542e6ff5a21b7420fda279b793c156e24" translate="yes" xml:space="preserve">
          <source>Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference</source>
          <target state="translated">¿Por qué mi variable no se altera después de que la modifique dentro de una función?-Referencia del código asíncrono</target>
        </trans-unit>
        <trans-unit id="30c09e36d32f8aa50d9fd572ae75dfa8792e72cd" translate="yes" xml:space="preserve">
          <source>Yesterday, the work I was doing required some information from a colleague. I rang him up; here's how the conversation went:</source>
          <target state="translated">Ayer,el trabajo que estaba haciendo requería alguna información de un colega.Le llamé;así es como fue la conversación:</target>
        </trans-unit>
        <trans-unit id="f1ced2ce1f9304e9a0ba78b790d5a22ededef908" translate="yes" xml:space="preserve">
          <source>You might currently have some code similar to this;</source>
          <target state="translated">Puede que actualmente tengas un código similar a este;</target>
        </trans-unit>
        <trans-unit id="f7b14f844f491cec253dffd6a2877e87891e6a62" translate="yes" xml:space="preserve">
          <source>You will also notice that due to the asynchronous nature, it is impossible to &lt;code&gt;return&lt;/code&gt; a value from an asynchronous flow back to the synchronous flow where the callback was defined, as the asynchronous callbacks are executed long after the synchronous code has already finished executing.</source>
          <target state="translated">Tambi&amp;eacute;n notar&amp;aacute; que debido a la naturaleza asincr&amp;oacute;nica, es imposible &lt;code&gt;return&lt;/code&gt; un valor de un flujo asincr&amp;oacute;nico al flujo sincr&amp;oacute;nico donde se defini&amp;oacute; la devoluci&amp;oacute;n de llamada, ya que las devoluciones de llamada asincr&amp;oacute;nicas se ejecutan mucho despu&amp;eacute;s de que el c&amp;oacute;digo sincr&amp;oacute;nico ya haya terminado de ejecutarse.</target>
        </trans-unit>
        <trans-unit id="17990bb6c33a853fa89124957ec7cb0f2f107251" translate="yes" xml:space="preserve">
          <source>You'll &lt;strong&gt;&lt;em&gt;always&lt;/em&gt;&lt;/strong&gt; see a callback is specified as a function, because that's the only* way in JavaScript to define some code, but not execute it until later.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Siempre&lt;/em&gt;&lt;/strong&gt; ver&amp;aacute; que una devoluci&amp;oacute;n de llamada se especifica como una funci&amp;oacute;n, porque esa es la &amp;uacute;nica forma * en JavaScript de definir alg&amp;uacute;n c&amp;oacute;digo, pero no ejecutarlo hasta m&amp;aacute;s tarde.</target>
        </trans-unit>
        <trans-unit id="1a36ade9be4ed848a5cd8b84079e9715d403ca94" translate="yes" xml:space="preserve">
          <source>You're Missing the Point of Promises - domenic.me</source>
          <target state="translated">Estás perdiendo el punto de las promesas-domenic.me</target>
        </trans-unit>
        <trans-unit id="ff168847efe383bab3ac7dd4c396db86055ad902" translate="yes" xml:space="preserve">
          <source>jQuery &lt;code&gt;$.post&lt;/code&gt;'s callback may be called &lt;em&gt;sometime in the future&lt;/em&gt;, when (and if) the Ajax request has been completed successfully.</source>
          <target state="translated">La devoluci&amp;oacute;n de llamada de jQuery &lt;code&gt;$.post&lt;/code&gt; se puede llamar &lt;em&gt;en alg&amp;uacute;n momento en el futuro&lt;/em&gt; , cuando (y si) la solicitud de Ajax se haya completado con &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="3506140f1030ab84b377ab6155325a3641104402" translate="yes" xml:space="preserve">
          <source>jQuery provides functionality that's similar to promises with its Deferreds.</source>
          <target state="translated">jQuery proporciona una funcionalidad similar a la de las promesas con sus Deferreds.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
