<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/23667086">
    <body>
      <group id="23667086">
        <trans-unit id="87e7945a2a6acfe9e9ac15c56656043a7d3eaa7b" translate="yes" xml:space="preserve">
          <source>... as before, note that we've been able to remove the global variables (in this case &lt;code&gt;width&lt;/code&gt;).</source>
          <target state="translated">...前と同じように、グローバル変数（この場合は &lt;code&gt;width&lt;/code&gt; ）を削除できることに注意してください。</target>
        </trans-unit>
        <trans-unit id="483231bd8f34a26d5113dd22f8c5212933edbb64" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/maxogden/art-of-node#callbacks&quot;&gt;The Art of Node - Callbacks&lt;/a&gt; explains asynchronous code and callbacks very well with vanilla JS examples and Node.js code as well.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/maxogden/art-of-node#callbacks&quot;&gt;Art of Node-Callbacks&lt;/a&gt;では、非同期コードとコールバックについて、バニラJSの例とNode.jsコードを使用して非常によく説明しています。</target>
        </trans-unit>
        <trans-unit id="18b6513dab89c1fe133131a6fb64518a7ba93ed0" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/10058879/1331430&quot;&gt;@Matt Esch's answer to &quot;Get data from fs.readFile&quot;&lt;/a&gt; also explains asynchronicity extremely well in a simple manner.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/10058879/1331430&quot;&gt;@ fatt.readFileからデータを取得するための@Matt Eschの回答&lt;/a&gt;も、非同期性を非常に簡単に説明しています。</target>
        </trans-unit>
        <trans-unit id="cadc61baae72a97d1e69933c6cfd90e943dc7402" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/14220323/1331430&quot;&gt;@Felix Kling's answer to &quot;How do I return the response from an asynchronous call?&quot;&lt;/a&gt;. See his excellent answer explaining synchronous and asynchronous flows, as well as the &quot;Restructure code&quot; section.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/14220323/1331430&quot;&gt;「非同期呼び出しから応答を返すにはどうすればよいですか？」に対する@Felix Klingの回答&lt;/a&gt; 。 同期フローと非同期フローを説明する彼の優れた回答と、「コードの再構築」セクションをご覧ください。</target>
        </trans-unit>
        <trans-unit id="34372c0e6cc14dd9b3b03232668d7110ae7f8856" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;img.onload&lt;/code&gt; may be called &lt;em&gt;sometime in the future&lt;/em&gt;, when (and if) the image has successfully loaded.</source>
          <target state="translated">&lt;code&gt;img.onload&lt;/code&gt; は、画像が正常にロードされたとき（およびその場合）に&lt;em&gt;いつか&lt;/em&gt;呼び出さ&lt;em&gt;れる&lt;/em&gt;可能性があります。</target>
        </trans-unit>
        <trans-unit id="68a8ea4de6a6afdbe9657f4ae00dcc062708d45f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;setTimeout&lt;/code&gt; may be called &lt;em&gt;sometime in the future&lt;/em&gt;, after the delay has expired and the timeout hasn't been canceled by &lt;code&gt;clearTimeout&lt;/code&gt;. Note: even when using &lt;code&gt;0&lt;/code&gt; as delay, all browsers have a minimum timeout delay cap (specified to be 4ms in the HTML5 spec).</source>
          <target state="translated">&lt;code&gt;setTimeout&lt;/code&gt; は、遅延が終了し、タイムアウトが &lt;code&gt;clearTimeout&lt;/code&gt; によってキャンセルされなかった後&lt;em&gt;、いつか&lt;/em&gt;呼び出さ&lt;em&gt;れる&lt;/em&gt;可能性が&lt;em&gt;あり&lt;/em&gt; ます 。 注： &lt;code&gt;0&lt;/code&gt; を遅延として使用する場合でも、すべてのブラウザーには最小タイムアウト遅延キャップがあります（HTML5仕様で4msと指定されています）。</target>
        </trans-unit>
        <trans-unit id="0bfccf94f3ad9d7adee477872ae30a98032c0523" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;undefined&lt;/code&gt; gets logged in this case because &lt;code&gt;getMessage&lt;/code&gt; returns before the &lt;code&gt;setTimeout&lt;/code&gt; callback is called and updates &lt;code&gt;outerScopeVar&lt;/code&gt;.</source>
          <target state="translated">この場合、 &lt;code&gt;setTimeout&lt;/code&gt; コールバックが呼び出されて &lt;code&gt;outerScopeVar&lt;/code&gt; を更新する前に &lt;code&gt;getMessage&lt;/code&gt; が返されるため、 &lt;code&gt;undefined&lt;/code&gt; がログに記録されます。</target>
        </trans-unit>
        <trans-unit id="ed49b1097a751bc8dfb2f4fa8d5282592dce48f1" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Fabr&amp;iacute;cio's answer is spot on; but I wanted to complement his answer with something less technical, which focusses on an analogy to help explain the concept of asynchronicity&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;ファブリシオの答えはその場にあります。&lt;/em&gt; &lt;em&gt;しかし私は、非同期性の概念を説明するのに役立つアナロジーに焦点を当てた、あまり技術的でないもので彼の答えを補足したいと思いました&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="d22e77c39b64987867f31bc641a2c7fd0c1f2f91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="289bea1f35eed1af7b8112d0f8c61f705d425958" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2778e9f54b08b0eccef6e1f5fe205c622cd3d03c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b0452ea54bfa19c34b31eea62b1df9bde0570907" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;4.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;4.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9f20ea25a1c1f93d46c8a492286f9cf8254aea33" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;5.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;5.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2b346ab96e2b29b13b999bfffc88ff3a8086c76c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/primers/promises&quot;&gt;Promises&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/primers/promises&quot;&gt;Promises&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5a5d71dbf9e42228d1baf6d36e54cd389b38eea8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bob&lt;/strong&gt;: Sure thing, but it'll take me around 30 minutes?</source>
          <target state="translated">&lt;strong&gt;Bob&lt;/strong&gt; ：もちろん。でも30分くらいかかる？</target>
        </trans-unit>
        <trans-unit id="7fdddf9c3bee50f48d61f290501ea4e7b84eca27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Callbacks&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Callbacks&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3733084af55c2ff08a2c0a4af4d4f8d7dafdd1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: Hi Bob, I need to know how we &lt;em&gt;foo&lt;/em&gt;'d the &lt;em&gt;bar&lt;/em&gt;'d last week. Jim want's a report on it, and you're the only one who knows the details about it.</source>
          <target state="translated">&lt;strong&gt;私&lt;/strong&gt; ：こんにちは、ボブ。先週、私たちがどのように&lt;em&gt;fooをした&lt;/em&gt;かを知る必要があります。 ジムはそれについての報告を望んでおり、それについての詳細を知っているのはあなただけです。</target>
        </trans-unit>
        <trans-unit id="713f53e40c4562b4ab9eba6d6198debc536e516b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: Hi Bob, I need to know how we &lt;em&gt;foo&lt;/em&gt;'d the &lt;em&gt;bar&lt;/em&gt;'d last week. Jim wants a report on it, and you're the only one who knows the details about it.</source>
          <target state="translated">&lt;strong&gt;私&lt;/strong&gt; ：こんにちは、ボブ。先週、私たちがどのように&lt;em&gt;fooをした&lt;/em&gt;かを知る必要があります。 ジムはそれについてのレポートを望んでいます、そしてあなたはそれについての詳細を知っている唯一の人です。</target>
        </trans-unit>
        <trans-unit id="696d9e23b68465a334ff08838685b593defebdc0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: That's great Bob. Give me a ring back when you've got the information!</source>
          <target state="translated">&lt;strong&gt;私&lt;/strong&gt; ：それは素晴らしいボブです。 情報を入手したら、リングを返してください。</target>
        </trans-unit>
        <trans-unit id="31595be6d48c2097c06c53e9214cf88db6632a77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Me&lt;/strong&gt;: That's great Bob. I'll wait.</source>
          <target state="translated">&lt;strong&gt;私&lt;/strong&gt; ：それは素晴らしいボブです。 待ちます。</target>
        </trans-unit>
        <trans-unit id="c2fd0d38b0ab8484e639564a171161035b2a7b4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I'm using &lt;code&gt;setTimeout&lt;/code&gt; with a random delay as a generic asynchronous function, the same example applies to Ajax, &lt;code&gt;readFile&lt;/code&gt;, &lt;code&gt;onload&lt;/code&gt; and any other asynchronous flow.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;ランダムな遅延のある &lt;code&gt;setTimeout&lt;/code&gt; を一般的な非同期関数として使用しています。同じ例がAjax、 &lt;code&gt;readFile&lt;/code&gt; 、 &lt;code&gt;onload&lt;/code&gt; およびその他の非同期フローに適用されます。</target>
        </trans-unit>
        <trans-unit id="5e39b2acd2b8bf115a6c7845f5b4a885b1f2ab18" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; I've marked this answer as Community Wiki, hence anyone with at least 100 reputations can edit and improve it! Please feel free to improve this answer, or submit a completely new answer if you'd like as well.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;私はこの回答をコミュニティWikiとしてマークしました。そのため、100以上の評判がある人なら誰でも編集して改善できます！ この回答を自由に改善してください。必要に応じて、まったく新しい回答を送信してください。</target>
        </trans-unit>
        <trans-unit id="01a61e555cd8030fb7253b04500742128a3d6699" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; This is a canonical question for &lt;em&gt;JavaScript asynchronicity&lt;/em&gt;. Feel free to improve this question and add more simplified examples which the community can identify with.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;これは、 &lt;em&gt;JavaScriptの非同期性&lt;/em&gt;に関する標準的な質問です。 この質問を自由に改善し、コミュニティが特定できるより簡単な例を追加してください。</target>
        </trans-unit>
        <trans-unit id="8fe8260d2797d89dec2d4d73b3d6171752b44d37" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;async/await&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;async/await&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a0135ab690b1a17b0530e20999de06043814128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery &lt;a href=&quot;http://api.jquery.com/category/deferred-object/&quot;&gt;Deferreds&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery &lt;a href=&quot;http://api.jquery.com/category/deferred-object/&quot;&gt;Deferreds&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dbe2dc81e7b8f642b5949e87b7c1af8324d0995c" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;* Technically you can use &lt;code&gt;eval()&lt;/code&gt; as well, but &lt;a href=&quot;https://stackoverflow.com/questions/86513/why-is-using-the-javascript-eval-function-a-bad-idea&quot;&gt;&lt;code&gt;eval()&lt;/code&gt; is evil&lt;/a&gt; for this purpose&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;*技術的には &lt;code&gt;eval()&lt;/code&gt; も使用できますが、 &lt;a href=&quot;https://stackoverflow.com/questions/86513/why-is-using-the-javascript-eval-function-a-bad-idea&quot;&gt; &lt;code&gt;eval()&lt;/code&gt; は&lt;/a&gt;この目的には適していません&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="193eae364dc628fc092cd8ef11b86139f36c9a36" translate="yes" xml:space="preserve">
          <source>@Benjamin Gruenbaum has also put a lot of effort explaining asynchronicity in the same thread.</source>
          <target state="translated">@Benjamin Gruenbaumさんも同じスレッドで非同期性の説明に力を入れています。</target>
        </trans-unit>
        <trans-unit id="2616531e447d36623971529ada2669d82436aed6" translate="yes" xml:space="preserve">
          <source>All ajax calls (including the &lt;code&gt;$.get&lt;/code&gt; or &lt;code&gt;$.post&lt;/code&gt; or &lt;code&gt;$.ajax&lt;/code&gt;) are asynchronous.</source>
          <target state="translated">すべてのajax呼び出し（ &lt;code&gt;$.get&lt;/code&gt; または &lt;code&gt;$.post&lt;/code&gt; または &lt;code&gt;$.ajax&lt;/code&gt; ）は非同期です。</target>
        </trans-unit>
        <trans-unit id="2a0a37ac5b8e47801b9f45a88a68c9a89cad5b91" translate="yes" xml:space="preserve">
          <source>All the code that depends on the asynchronous calls, is moved inside the asynchronous block, or by waiting on the asynchronous calls.</source>
          <target state="translated">非同期呼び出しに依存するすべてのコードは、非同期ブロック内に移動されるか、非同期呼び出しを待つことで移動されます。</target>
        </trans-unit>
        <trans-unit id="1fb9670113b1c96e286f81efab4da12bc3d0e7ca" translate="yes" xml:space="preserve">
          <source>Although there are ways to keep the &lt;a href=&quot;http://callbackhell.com/&quot;&gt;callback hell&lt;/a&gt; at bay with vanilla JS, promises are growing in popularity and are currently being standardized in ES6 (see &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;Promise - MDN&lt;/a&gt;).</source>
          <target state="translated">バニラJSを使用して&lt;a href=&quot;http://callbackhell.com/&quot;&gt;コールバックの問題&lt;/a&gt;を解決する方法はいくつかありますが、プロミスは人気が高まり、現在ES6で標準化されています（ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise&quot;&gt;プロミス&lt;/a&gt; -MDNを参照）。</target>
        </trans-unit>
        <trans-unit id="3351fcf6c12d50fc0ac88805069aea142f975b54" translate="yes" xml:space="preserve">
          <source>An Analogy...</source>
          <target state="translated">例え話だが...</target>
        </trans-unit>
        <trans-unit id="5ab84d7fcdf6fb1318fe079454de14bc2e9d8e11" translate="yes" xml:space="preserve">
          <source>And I sat there and waited. And waited. And waited. For 40 minutes. Doing nothing but waiting. Eventually, Bob gave me the information, we hung up, and I completed my report. But I'd lost 40 minutes of productivity.</source>
          <target state="translated">私はそこに座って待っていた そして待った。そして待った。40分間 何もしないで待っていた 結局、ボブが情報を教えてくれて、電話を切って、私はレポートを完成させました。しかし、私は40分間の生産性を失った。</target>
        </trans-unit>
        <trans-unit id="fda44874bfa419ff03d6f65b066d614159b645b1" translate="yes" xml:space="preserve">
          <source>Asynchronous execution is pushed out of the synchronous flow. That is, the asynchronous code will &lt;strong&gt;never&lt;/strong&gt; execute while the synchronous code stack is executing. This is the meaning of JavaScript being single-threaded.</source>
          <target state="translated">非同期実行は、同期フローから押し出されます。 つまり、同期コードスタックの実行中に非同期コードが実行される&lt;strong&gt;こと&lt;/strong&gt;はあり&lt;strong&gt;ません&lt;/strong&gt; 。 これは、JavaScriptがシングルスレッドであることの意味です。</target>
        </trans-unit>
        <trans-unit id="3eaa02daa9e2fa7476ef359c4e92ddb36ff3ccfa" translate="yes" xml:space="preserve">
          <source>Asynchronous functions be like...</source>
          <target state="translated">非同期関数は...</target>
        </trans-unit>
        <trans-unit id="43f59b64684b4ec6e77bc10459d2c89df596e351" translate="yes" xml:space="preserve">
          <source>At this point, I hung up the phone. Since I needed information from Bob to complete my report, I left the report and went for a coffee instead, then I caught up on some email. 40 minutes later (Bob is slow), Bob called back and gave me the information I needed. At this point, I resumed my work with my report, as I had all the information I needed.</source>
          <target state="translated">この時点で、私は電話を切りました。私のレポートを完成させるためにボブからの情報が必要だったので、私はレポートを残し、代わりにコーヒーを飲みに行き、その後、いくつかのメールに追いつきました。40分後(ボブは遅い)、ボブから電話がかかってきて、私が必要としている情報を教えてくれました。この時点で、私は必要な情報をすべて持っていたので、レポートの仕事を再開しました。</target>
        </trans-unit>
        <trans-unit id="b103b8d3480de02206ccf798fcaa01817ae2396c" translate="yes" xml:space="preserve">
          <source>Code snippet of the above example:</source>
          <target state="translated">上記の例のコードスニペット。</target>
        </trans-unit>
        <trans-unit id="d268a2e26266d8a732fbf03fc545f77a1511cad7" translate="yes" xml:space="preserve">
          <source>Considering your example</source>
          <target state="translated">あなたの例を考えると</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="4161388d0bc1d4981fe7e703476edf485adb1e23" translate="yes" xml:space="preserve">
          <source>Forewords</source>
          <target state="translated">Forewords</target>
        </trans-unit>
        <trans-unit id="9ff1e84bc1df7325df3d395b27e23dde1e64014a" translate="yes" xml:space="preserve">
          <source>Given the following examples, why is &lt;code&gt;outerScopeVar&lt;/code&gt; undefined in all cases?</source>
          <target state="translated">次の例の場合、 &lt;code&gt;outerScopeVar&lt;/code&gt; がすべての場合に未定義になるのはなぜですか？</target>
        </trans-unit>
        <trans-unit id="90acfeac32c622ee5ef1932cf600a7a4910a15ba" translate="yes" xml:space="preserve">
          <source>Here the timeout event plays the role, which will invoke the handler after the specified time. Here it is &lt;code&gt;0&lt;/code&gt;, but still it registers an asynchronous event it will be added to the last position of the &lt;code&gt;Event Queue&lt;/code&gt; for execution, which makes the guaranteed delay.</source>
          <target state="translated">ここでは、タイムアウトイベントが役割を果たし、指定された時間の後にハンドラーを呼び出します。 ここでは &lt;code&gt;0&lt;/code&gt; ですが、非同期イベントを登録しますが、 &lt;code&gt;Event Queue&lt;/code&gt; 最後の位置に追加されて実行されるため、遅延が保証されます。</target>
        </trans-unit>
        <trans-unit id="c0ccb8fb1c710d25514aa41de1cf403d4866d1fc" translate="yes" xml:space="preserve">
          <source>Here we register an eventlistner which will be executed upon that particular event.Here loading of image.Then the current execution continuous with next lines &lt;code&gt;img.src = 'lolcat.png';&lt;/code&gt; and &lt;code&gt;alert(outerScopeVar);&lt;/code&gt; meanwhile the event may not occur. i.e, funtion &lt;code&gt;img.onload&lt;/code&gt; wait for the referred image to load, asynchrously. This will happen all the folowing example- the event may differ.</source>
          <target state="translated">ここで、その特定のイベントで実行されるeventlistnerを登録します。ここで画像をロードします。次に、現在の実行が次の行に &lt;code&gt;img.src = 'lolcat.png';&lt;/code&gt; および &lt;code&gt;alert(outerScopeVar);&lt;/code&gt; その間、イベントは発生しない可能性があります。 つまり、 &lt;code&gt;img.onload&lt;/code&gt; は、参照された画像が非同期にロードされるのを待ちます。 これは、以下のすべての例で発生します。イベントは異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="9513c4fd164bc6e4b493627615a49084822fe3c0" translate="yes" xml:space="preserve">
          <source>Here's a more concise answer for people that are looking for a quick reference as well as some examples using promises and async/await.</source>
          <target state="translated">ここでは、プロミスやasyncawaitを使用した例と同様に、簡単なリファレンスを探している人のために、より簡潔に回答しています。</target>
        </trans-unit>
        <trans-unit id="b6008160b60a5356b4ee831a5e643f9f9bec0f29" translate="yes" xml:space="preserve">
          <source>How do I keep my caller waiting?</source>
          <target state="translated">発信者を待たせるにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="5376e14e843406f61ac87403197fd8d1d7434c5e" translate="yes" xml:space="preserve">
          <source>However, we now know that the &lt;code&gt;return outerScopeVar&lt;/code&gt; happens immediately; before the &lt;code&gt;onload&lt;/code&gt; callback function has updated the variable. This leads to &lt;code&gt;getWidthOfImage()&lt;/code&gt; returning &lt;code&gt;undefined&lt;/code&gt;, and &lt;code&gt;undefined&lt;/code&gt; being alerted.</source>
          <target state="translated">ただし、 &lt;code&gt;return outerScopeVar&lt;/code&gt; がすぐに返されることがわかっています。 &lt;code&gt;onload&lt;/code&gt; コールバック関数が変数を更新する前。 これにより、 &lt;code&gt;getWidthOfImage()&lt;/code&gt; が &lt;code&gt;undefined&lt;/code&gt; を返し、 &lt;code&gt;undefined&lt;/code&gt; がアラートされます。</target>
        </trans-unit>
        <trans-unit id="e6239a14687cbf4f9e4e299f4f10e3f1d0d8290b" translate="yes" xml:space="preserve">
          <source>I want to turn this question into a canonical topic to answer asynchronicity issues which are unrelated to Ajax (there is &lt;a href=&quot;https://stackoverflow.com/q/14220321/1331430&quot;&gt;How to return the response from an AJAX call?&lt;/a&gt; for that), hence this topic needs your help to be as good and helpful as possible!</source>
          <target state="translated">この質問を正規トピックに変えて、Ajaxとは無関係の非同期性の問題に答えたいのです（そのために&lt;a href=&quot;https://stackoverflow.com/q/14220321/1331430&quot;&gt;AJAX呼び出しからの応答を返す方法&lt;/a&gt;はありますか？ ）。したがって、このトピックは、できる限り役立ち、役立つようにあなたの助けを必要とします！</target>
        </trans-unit>
        <trans-unit id="c6867acba73dcc3d63f6f6a677d4a3c0f03b6e0a" translate="yes" xml:space="preserve">
          <source>If your JavaScript environment includes support for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt;&lt;code&gt;async&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt;&lt;code&gt;await&lt;/code&gt;&lt;/a&gt; (like Node.js 7.6+), then you can use promises synchronously within &lt;code&gt;async&lt;/code&gt; functions:</source>
          <target state="translated">JavaScript環境に&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function&quot;&gt; &lt;code&gt;async&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await&quot;&gt; &lt;code&gt;await&lt;/code&gt; の&lt;/a&gt;サポートが含まれている場合（Node.js 7.6以降など）、 &lt;code&gt;async&lt;/code&gt; 関数内でプロミスを同期的に使用できます。</target>
        </trans-unit>
        <trans-unit id="cbe7623af9f69417f8c30820f0ea3f8da88b935e" translate="yes" xml:space="preserve">
          <source>Imagine if the conversation had gone like this instead;</source>
          <target state="translated">もし会話がこうなっていたらと想像してみてください。</target>
        </trans-unit>
        <trans-unit id="d94c2a88c0873ea1bc503304b1c42af08fccd5f4" translate="yes" xml:space="preserve">
          <source>Implementing your own callback logic</source>
          <target state="translated">独自のコールバックロジックの実装</target>
        </trans-unit>
        <trans-unit id="19eaef30713ec40985dd7ae805fde594db8f511d" translate="yes" xml:space="preserve">
          <source>In all cases, we have a callback which may run &lt;em&gt;sometime in the future&lt;/em&gt;. This &quot;sometime in the future&quot; is what we refer to as &lt;strong&gt;asynchronous flow&lt;/strong&gt;.</source>
          <target state="translated">すべての場合において、コールバックがあり&lt;em&gt;、いつか&lt;/em&gt;実行さ&lt;em&gt;れる&lt;/em&gt;可能性が&lt;em&gt;あります&lt;/em&gt; 。 この「将来のある時点」は、 &lt;strong&gt;非同期フローと&lt;/strong&gt;呼ばれるものです。</target>
        </trans-unit>
        <trans-unit id="135bd88cbd59b18dc1f9b7be855f8e4fa92e1f0e" translate="yes" xml:space="preserve">
          <source>In all these scenarios &lt;code&gt;outerScopeVar&lt;/code&gt; is modified or assigned a value &lt;strong&gt;asynchronously&lt;/strong&gt; or &lt;strong&gt;happening in a later time(waiting or listening for some event to occur),for which the current execution will not wait&lt;/strong&gt;.So all these cases current execution flow results in &lt;code&gt;outerScopeVar = undefined&lt;/code&gt;</source>
          <target state="translated">これらのすべてのシナリオで、 &lt;code&gt;outerScopeVar&lt;/code&gt; は変更されるか、値が&lt;strong&gt;非同期に&lt;/strong&gt;割り当てられるか&lt;strong&gt;、後で発生し（何らかのイベントの発生を待機または待機）、現在の実行は待機しません。&lt;/strong&gt;したがって、これらのすべてのケースで、現在の実行フローは &lt;code&gt;outerScopeVar = undefined&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dfc2217afad206d82ab1c489045154e363b8cd2a" translate="yes" xml:space="preserve">
          <source>In order to fix our code, all we have to do is move the &lt;code&gt;alert(outerScopeVar)&lt;/code&gt; code &lt;em&gt;into&lt;/em&gt; the callback function. As a consequence of this, we no longer need the &lt;code&gt;outerScopeVar&lt;/code&gt; variable declared as a global variable.</source>
          <target state="translated">コードを修正するには、 &lt;code&gt;alert(outerScopeVar)&lt;/code&gt; コード&lt;em&gt;を&lt;/em&gt;コールバック関数に移動するだけです。 これにより、 &lt;code&gt;outerScopeVar&lt;/code&gt; 変数をグローバル変数として宣言する必要がなくなりました。</target>
        </trans-unit>
        <trans-unit id="219fa966e4403c99f93745961a66347fdd6ee889" translate="yes" xml:space="preserve">
          <source>In real life scenario, the code becomes,</source>
          <target state="translated">現実のシナリオでは、コードはなります。</target>
        </trans-unit>
        <trans-unit id="729a2882bffa8796d64097b884d3520508f6cc3c" translate="yes" xml:space="preserve">
          <source>In short, the callback functions are created synchronously but executed asynchronously. You just can't rely on the execution of an asynchronous function until you know it has executed, and how to do that?</source>
          <target state="translated">要するに、コールバック関数は同期的に生成されますが、非同期的に実行されます。非同期関数が実行されたことを知るまでは、非同期関数の実行に頼ることはできませんが、どうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="c30a8d270de5576c077f0fa84b762b1e781bf74b" translate="yes" xml:space="preserve">
          <source>In the code above, we're asking JavaScript to load &lt;code&gt;lolcat.png&lt;/code&gt;, which is a &lt;em&gt;sloooow&lt;/em&gt; operation. The callback function will be executed once this slow operation has done, but in the meantime, JavaScript will keep processing the next lines of code; i.e. &lt;code&gt;alert(outerScopeVar)&lt;/code&gt;.</source>
          <target state="translated">上記のコードでは、JavaScriptに&lt;em&gt;sloooow&lt;/em&gt;操作である&lt;em&gt;lolcat.png&lt;/em&gt;をロードするように要求しています。 この遅い操作が完了すると、コールバック関数が実行されますが、その間、JavaScriptは次のコード行を処理し続けます。 つまり、 &lt;code&gt;alert(outerScopeVar)&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="41d2083ae42e2602204895d28ef21aeaac582cb0" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;return&lt;/code&gt;ing a value from an asynchronous callback, you will have to make use of the callback pattern, or... Promises.</source>
          <target state="translated">非同期コールバックから値を &lt;code&gt;return&lt;/code&gt; 代わりに、コールバックパターンを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="0cc7a9dd54f8bbb52fefe95aa868d2fb8e4076e2" translate="yes" xml:space="preserve">
          <source>It depends on the case. Let's try to trace some common behavior again:</source>
          <target state="translated">場合によります。もう一度、よくある動作をなぞってみましょう。</target>
        </trans-unit>
        <trans-unit id="fb2ea5baac3ad36c938aef8df244432e62524de2" translate="yes" xml:space="preserve">
          <source>It is simple, really. The logic that depends on the asynchronous function execution should be started/called from inside this asynchronous function. For example, moving the &lt;code&gt;alert&lt;/code&gt;s and &lt;code&gt;console.log&lt;/code&gt;s too inside the callback function would output the expected result, because the result is available at that point.</source>
          <target state="translated">本当に簡単です。 非同期関数の実行に依存するロジックは、この非同期関数内から開始/呼び出される必要があります。 たとえば、 &lt;code&gt;alert&lt;/code&gt; sと &lt;code&gt;console.log&lt;/code&gt; sをコールバック関数内で移動しすぎると、予期した結果が出力されます。これは、その時点で結果が利用できるためです。</target>
        </trans-unit>
        <trans-unit id="f833c4bc8e7973b5c0788881a871357c0b979a45" translate="yes" xml:space="preserve">
          <source>JavaScript Promises - HTML5 Rocks</source>
          <target state="translated">JavaScript の約束-HTML5 Rocks</target>
        </trans-unit>
        <trans-unit id="7e1a19f21ecf74a20fd1fc528e7a374bc5f9c8d9" translate="yes" xml:space="preserve">
          <source>Let's discuss each examples(I marked the portion which is called asynchronously or delayed for some events to occur):</source>
          <target state="translated">それぞれの例を見てみましょう(非同期と呼ばれる部分やイベントの発生が遅れている部分に印をつけました)。</target>
        </trans-unit>
        <trans-unit id="638c1153b14aa1b9d097c6dcdd2c2f61b8c583bf" translate="yes" xml:space="preserve">
          <source>Let's tackle it implementing a callback system of our own. First off, we get rid of that ugly &lt;code&gt;outerScopeVar&lt;/code&gt; which is completely useless in this case. Then we add a parameter which accepts a function argument, our callback. When the asynchronous operation finishes, we call this callback passing the result. The implementation (please read the comments in order):</source>
          <target state="translated">独自のコールバックシステムの実装に取り​​組みましょう。 まず、この場合はまったく役に立たない醜い &lt;code&gt;outerScopeVar&lt;/code&gt; を削除します。 次に、関数の引数を受け入れるパラメーター（コールバック）を追加します。 非同期操作が終了したら、このコールバックを呼び出して結果を渡します。 実装（コメントを順番に読んでください）：</target>
        </trans-unit>
        <trans-unit id="487666eb364c70eb737ac6495aa0ccd4f8d13ba0" translate="yes" xml:space="preserve">
          <source>Let's trace the common behavior first. In all examples, the &lt;code&gt;outerScopeVar&lt;/code&gt; is modified inside of a &lt;em&gt;function&lt;/em&gt;. That function is clearly not executed immediately, it is being assigned or passed as an argument. That is what we call a &lt;strong&gt;&lt;em&gt;callback&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">最初に一般的な動作をトレースしましょう。 すべての例で、 &lt;code&gt;outerScopeVar&lt;/code&gt; は&lt;em&gt;関数&lt;/em&gt;内で変更され&lt;em&gt;ます&lt;/em&gt; 。 その関数は明らかにすぐには実行されず、引数として割り当てまたは渡されます。 これが&lt;strong&gt;&lt;em&gt;コールバック&lt;/em&gt;&lt;/strong&gt;と呼ばれるものです。</target>
        </trans-unit>
        <trans-unit id="7adf46b8af10f9ffba635ac39fa32e59eedd72ea" translate="yes" xml:space="preserve">
          <source>Lets say that the post request takes 10 seconds to complete, the value of &lt;code&gt;outerScopeVar&lt;/code&gt; will only be set after those 10 seconds.</source>
          <target state="translated">postリクエストの完了に10秒かかるとすると、 &lt;code&gt;outerScopeVar&lt;/code&gt; の値はそれらの10秒後にのみ設定されます。</target>
        </trans-unit>
        <trans-unit id="2cd4cb675addf1e7a7a8765c722dcd18f39a2b27" translate="yes" xml:space="preserve">
          <source>More reading material about JavaScript asynchronicity</source>
          <target state="translated">JavaScriptの非同期性に関するその他の読み物</target>
        </trans-unit>
        <trans-unit id="36f8fb94265b7a738324676d4ddedf0f7f8be952" translate="yes" xml:space="preserve">
          <source>More specifically, when the JS engine is idle -- not executing a stack of (a)synchronous code -- it will poll for events that may have triggered asynchronous callbacks (e.g. expired timeout, received network response) and execute them one after another. This is regarded as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop&quot;&gt;Event Loop&lt;/a&gt;.</source>
          <target state="translated">より具体的には、JSエンジンがアイドル状態のとき-（a）同期コードのスタックを実行していないとき-非同期コールバックをトリガーした可能性のあるイベント（タイムアウトのタイムアウト、受信したネットワーク応答など）をポーリングし、次々に実行します。 これは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/EventLoop&quot;&gt;イベントループ&lt;/a&gt;と見なされます 。</target>
        </trans-unit>
        <trans-unit id="027fcce6dca0e5452f5c3ae77d3776d83b9cb117" translate="yes" xml:space="preserve">
          <source>Most often in real use cases, the DOM API and most libraries already provide the callback functionality (the &lt;code&gt;helloCatAsync&lt;/code&gt; implementation in this demonstrative example). You only need to pass the callback function and understand that it will execute out of the synchronous flow, and restructure your code to accommodate for that.</source>
          <target state="translated">ほとんどの場合、実際の使用例では、DOM APIとほとんどのライブラリーがコールバック機能（このデモ例では &lt;code&gt;helloCatAsync&lt;/code&gt; 実装）をすでに提供しています。 コールバック関数を渡して、それが同期フローから実行されることを理解し、それに対応するようにコードを再構成するだけです。</target>
        </trans-unit>
        <trans-unit id="0dcfbb375ba4904c46d6dce14e7309a4eb9988dc" translate="yes" xml:space="preserve">
          <source>Node can be consider as a king of asynchronous coding.Here the marked function is registered as a callback handler which will be executed after reading the specified file.</source>
          <target state="translated">ここでは、マークされた関数をコールバックハンドラとして登録し、指定されたファイルを読み込んだ後に実行されるようにしています。</target>
        </trans-unit>
        <trans-unit id="b216c6131cd7d019cbd3e050a3a8d93e5b049385" translate="yes" xml:space="preserve">
          <source>Node.js's &lt;code&gt;fs.readFile&lt;/code&gt; may be called &lt;em&gt;sometime in the future&lt;/em&gt;, when the file has been read successfully or thrown an error.</source>
          <target state="translated">Node.jsの &lt;code&gt;fs.readFile&lt;/code&gt; は、ファイルが正常に読み取られたとき、またはエラーがスローされたとき&lt;em&gt;に、将来&lt;/em&gt;呼び出さ&lt;em&gt;れる&lt;/em&gt;可能性があります。</target>
        </trans-unit>
        <trans-unit id="edba6c23726045806eaa1d7bc5d696075358f973" translate="yes" xml:space="preserve">
          <source>Now the question is, when is that callback called?</source>
          <target state="translated">さて、問題は、そのコールバックがいつ呼ばれるかです。</target>
        </trans-unit>
        <trans-unit id="6cdece044e170983c1f5cab467ce941e2ddd0dde" translate="yes" xml:space="preserve">
          <source>Now when you execute this, you would get an alert on line 3. Now wait for some time until you are sure the post request has returned some value. Then when you click OK, on the alert box, next alert would print the expected value, because you waited for it.</source>
          <target state="translated">これを実行すると、3行目にアラートが表示されます。ここで、投稿リクエストが何らかの値を返したことを確認するまでしばらく待ってください。そして、OKをクリックすると、アラートボックスで、次のアラートは、あなたがそれを待っていたので、期待される値を表示します。</target>
        </trans-unit>
        <trans-unit id="8f7e7c308a72af2805417b772be3373d55f7aa67" translate="yes" xml:space="preserve">
          <source>Obvious promise (something will be done in future) is asynchronous. see &lt;a href=&quot;https://stackoverflow.com/questions/6801283/what-are-the-differences-between-deferred-promise-and-future-in-javascript&quot;&gt;What are the differences between Deferred, Promise and Future in JavaScript?&lt;/a&gt;</source>
          <target state="translated">明白な約束（何かが将来行われる）は非同期です。 &lt;a href=&quot;https://stackoverflow.com/questions/6801283/what-are-the-differences-between-deferred-promise-and-future-in-javascript&quot;&gt;JavaScriptの据え置き、約束、未来の違い&lt;/a&gt;は何ですか？</target>
        </trans-unit>
        <trans-unit id="acfa95439c5b3dfbc3f590cb3d6cbc5140d0725d" translate="yes" xml:space="preserve">
          <source>Often you need to do more things with the result from an asynchronous function or do different things with the result depending on where the asynchronous function has been called. Let's tackle a bit more complex example:</source>
          <target state="translated">非同期関数の結果をより多くのことをしなければならなかったり、非同期関数が呼び出された場所に応じて異なることをしなければならなかったりすることがよくあります。もう少し複雑な例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="69aae8a529faeef3bf34a8f29a9aeb27faa6c60a" translate="yes" xml:space="preserve">
          <source>One word answer: &lt;strong&gt;asynchronicity&lt;/strong&gt;.</source>
          <target state="translated">一言で言えば、 &lt;strong&gt;非同期性&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="b1d472e424c03ff52490d1edc8a0e23f95babb92" translate="yes" xml:space="preserve">
          <source>Promises</source>
          <target state="translated">Promises</target>
        </trans-unit>
        <trans-unit id="6d9d164125b7cac2630c27b4a009417447162bf7" translate="yes" xml:space="preserve">
          <source>Promises (a.k.a. Futures) provide a more linear, and thus pleasant, reading of the asynchronous code, but explaining their entire functionality is out of the scope of this question. Instead, I'll leave these excellent resources for the interested:</source>
          <target state="translated">プロミス(別名フューチャー)は、非同期コードをより直線的に読むことができるので楽しいですが、その機能全体を説明するのはこの質問の範囲外です。その代わりに、興味のある方のためにこれらの優れたリソースを残しておきます。</target>
        </trans-unit>
        <trans-unit id="cb68ff088476aec4be87b92843cdbef82052867f" translate="yes" xml:space="preserve">
          <source>Promises provide an alternative which is more flexible than callbacks because they can be naturally combined to coordinate multiple async operations. A &lt;a href=&quot;https://promisesaplus.com/&quot;&gt;Promises/A+&lt;/a&gt; standard implementation is natively provided in node.js (0.12+) and many current browsers, but is also implemented in libraries like &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;Bluebird&lt;/a&gt; and &lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt;.</source>
          <target state="translated">プロミスは、複数の非同期操作を調整するために自然に組み合わせることができるため、コールバックよりも柔軟な代替手段を提供します。 &lt;a href=&quot;https://promisesaplus.com/&quot;&gt;Promises / A +&lt;/a&gt;標準実装は、node.js（0.12+）および多くの現在のブラウザーでネイティブに提供されていますが、 &lt;a href=&quot;https://github.com/petkaantonov/bluebird&quot;&gt;Bluebird&lt;/a&gt;や&lt;a href=&quot;https://github.com/kriskowal/q&quot;&gt;Q&lt;/a&gt;などのライブラリーにも実装されています。</target>
        </trans-unit>
        <trans-unit id="9d7c2ad2dddc44dedd1e96fb0db1f59589562e3c" translate="yes" xml:space="preserve">
          <source>Rather than &lt;em&gt;waiting&lt;/em&gt; for these slow operations to complete, JavaScript lets you register a callback function which will be executed when the slow operation has completed. In the meantime, however, JavaScript will continue to execute other code. The fact that JavaScript executes &lt;em&gt;other code&lt;/em&gt; whilst waiting for the slow operation to complete makes the behavior&lt;strong&gt;asynchronous&lt;/strong&gt;. Had JavaScript waited around for the operation to complete before executing any other code, this would have been &lt;strong&gt;synchronous&lt;/strong&gt; behavior.</source>
          <target state="translated">JavaScriptでは、これらの遅い操作が完了するのを&lt;em&gt;待つの&lt;/em&gt;ではなく、遅い操作が完了したときに実行されるコールバック関数を登録できます。 その間、JavaScriptは引き続き他のコードを実行します。 遅い操作が完了するのを待つ間、JavaScriptが&lt;em&gt;他のコード&lt;/em&gt;を実行するという事実は、動作を&lt;strong&gt;非同期にします&lt;/strong&gt; 。 JavaScriptが他のコードを実行する前に操作が完了するのを待っていた場合、これは&lt;strong&gt;同期&lt;/strong&gt;的な動作でした。</target>
        </trans-unit>
        <trans-unit id="8f3fc1e296aaa81836928351f23624856a1de71b" translate="yes" xml:space="preserve">
          <source>Start with the naive approach (that doesn't work) for a function that calls an asynchronous method (in this case &lt;code&gt;setTimeout&lt;/code&gt;) and returns a message:</source>
          <target state="translated">非同期メソッド（この場合は &lt;code&gt;setTimeout&lt;/code&gt; ）を呼び出してメッセージを返す関数の単純なアプローチ（機能しない）から始めます。</target>
        </trans-unit>
        <trans-unit id="fb0e4798cb170cfc40f0368e44f763affdfd54e9" translate="yes" xml:space="preserve">
          <source>That is, the asynchronous code highlighted in the hand-drawn red shapes may execute only after all the remaining synchronous code in their respective code blocks have executed:</source>
          <target state="translated">つまり、手書きの赤い図形で強調表示された非同期コードは、それぞれのコードブロック内の残りの同期コードがすべて実行された後にのみ実行することができます。</target>
        </trans-unit>
        <trans-unit id="0a9be42f4d2ec4950f69e0eb67c25bd4ebaa41c0" translate="yes" xml:space="preserve">
          <source>The answer to the question at hand</source>
          <target state="translated">手元にある質問の答え</target>
        </trans-unit>
        <trans-unit id="0f58e0d8b311cbdc96d07934de3ac62c55d87691" translate="yes" xml:space="preserve">
          <source>The change here is that &lt;code&gt;getMessage&lt;/code&gt; accepts a &lt;code&gt;callback&lt;/code&gt; parameter that will be called to deliver the results back to the calling code once available.</source>
          <target state="translated">ここでの変更点は、 &lt;code&gt;getMessage&lt;/code&gt; が &lt;code&gt;callback&lt;/code&gt; パラメータを受け入れることです。 コールバックパラメータは、使用可能になったときに結果を呼び出しコードに返すために呼び出されます。</target>
        </trans-unit>
        <trans-unit id="dfbc4999399aec4a2d69483e59a7728ba63f4f53" translate="yes" xml:space="preserve">
          <source>The code execution starts from line 1, declares the variable and triggers and asynchronous call on line 2, (i.e., the post request) and it continues its execution from line 3, without waiting for the post request to complete its execution.</source>
          <target state="translated">コードの実行は1行目から始まり、2行目で変数を宣言してトリガーと非同期呼び出し(つまりポストリクエスト)を行い、3行目からはポストリクエストの実行完了を待たずに実行を続けます。</target>
        </trans-unit>
        <trans-unit id="9d15198b66c44aa363b53458036280b399cb3f48" translate="yes" xml:space="preserve">
          <source>The other answers are excellent and I just want to provide a straight forward answer to this. Just limiting to jQuery asynchronous calls</source>
          <target state="translated">他の回答は素晴らしいので、私はただただ素直に答えを出したいと思っています。jQueryの非同期呼び出しに限定するだけで</target>
        </trans-unit>
        <trans-unit id="d52589835b03cdf8d7ac3617f883151bd0f44bc6" translate="yes" xml:space="preserve">
          <source>The two main ways to solve it are using &lt;strong&gt;callbacks&lt;/strong&gt; and &lt;strong&gt;promises&lt;/strong&gt;:</source>
          <target state="translated">それを解決する2つの主な方法は、 &lt;strong&gt;コールバック&lt;/strong&gt;と&lt;strong&gt;promise&lt;/strong&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="4f5b392d075945718f406191e510986ae67301e9" translate="yes" xml:space="preserve">
          <source>Therefore, in all of our examples, the &lt;code&gt;function() { /* Do something */ }&lt;/code&gt; is the callback; to fix &lt;strong&gt;all&lt;/strong&gt; the examples, all we have to do is move the code which needs the response of the operation into there!</source>
          <target state="translated">したがって、すべての例で、 &lt;code&gt;function() { /* Do something */ }&lt;/code&gt; がコールバックです。 &lt;strong&gt;すべて&lt;/strong&gt;の例を修正するには、操作の応答を必要とするコードをそこに移動するだけです！</target>
        </trans-unit>
        <trans-unit id="91fe005c7b9a8de24f4645e8f363dbc2e0529353" translate="yes" xml:space="preserve">
          <source>This example clearly suffers from the same issue as the other examples, it is not waiting until the asynchronous function executes.</source>
          <target state="translated">この例は明らかに他の例と同じ問題を抱えており、非同期関数が実行されるまで待っていません。</target>
        </trans-unit>
        <trans-unit id="ffac965ab18c7d09429e1769cd6077e8cb88d4ef" translate="yes" xml:space="preserve">
          <source>This is asynchronous vs. synchronous behavior</source>
          <target state="translated">これは、非同期対同期の動作です。</target>
        </trans-unit>
        <trans-unit id="4a9f0c688c7a4ad3c6e910681cbfa516c1908817" translate="yes" xml:space="preserve">
          <source>This is exactly what is happening in all the examples in our question. Loading an image, loading a file off disk, and requesting a page via AJAX are all slow operations (in the context of modern computing).</source>
          <target state="translated">これはまさに私たちの質問のすべての例で起こっていることです。画像をロードすること、ディスクからファイルをロードすること、AJAX経由でページをリクエストすることは、(現代のコンピューティングのコンテキストでは)すべて遅い操作です。</target>
        </trans-unit>
        <trans-unit id="f707894961ab83a7c6e333b28e7f9931e3824aa4" translate="yes" xml:space="preserve">
          <source>This is why we see the alert showing &lt;code&gt;undefined&lt;/code&gt;; since the &lt;code&gt;alert()&lt;/code&gt; is processed immediately, rather than after the image has been loaded.</source>
          <target state="translated">これが、 &lt;code&gt;undefined&lt;/code&gt; を示すアラートが表示される理由です。 画像が読み込まれた後ではなく、 &lt;code&gt;alert()&lt;/code&gt; がすぐに処理されるためです。</target>
        </trans-unit>
        <trans-unit id="f2e10d930e731050a7b6c7e2eaf695b3876a9b2e" translate="yes" xml:space="preserve">
          <source>This time ajax callback.</source>
          <target state="translated">今回はajaxコールバックです。</target>
        </trans-unit>
        <trans-unit id="42b9aece256629e1f3ae7fd0b418fdce8ba1bf5d" translate="yes" xml:space="preserve">
          <source>This topic has been iterated at least a couple of thousands of times, here, in Stack Overflow. Hence, first off I'd like to point out some extremely useful resources:</source>
          <target state="translated">このトピックは、Stack Overflowで少なくとも数千回は繰り返してきました。そこで、まず最初に非常に有用なリソースをいくつか挙げておきます。</target>
        </trans-unit>
        <trans-unit id="b45bcc49f561af62860de0ba678026a934aa6d4c" translate="yes" xml:space="preserve">
          <source>To fix this, we need to allow the function calling &lt;code&gt;getWidthOfImage()&lt;/code&gt; to register a callback, then move the alert'ing of the width to be within that callback;</source>
          <target state="translated">これを修正するには、 &lt;code&gt;getWidthOfImage()&lt;/code&gt; を呼び出す関数がコールバックを登録できるようにする必要があります。次に、幅のアラートをそのコールバック内に移動します。</target>
        </trans-unit>
        <trans-unit id="efd3968d8235a10f87b53e88a27d4485fcc5fe25" translate="yes" xml:space="preserve">
          <source>To state the obvious, the cup represents &lt;code&gt;outerScopeVar&lt;/code&gt;.</source>
          <target state="translated">明白に述べると、カップは &lt;code&gt;outerScopeVar&lt;/code&gt; を表します 。</target>
        </trans-unit>
        <trans-unit id="4db799b398211e889d65554156059060d81f356d" translate="yes" xml:space="preserve">
          <source>To try out,</source>
          <target state="translated">試してみること。</target>
        </trans-unit>
        <trans-unit id="90422ad2e2bbc1c8f4a48927d8b73dd5160a2e66" translate="yes" xml:space="preserve">
          <source>Why does it output &lt;code&gt;undefined&lt;/code&gt; in all of these examples? I don't want workarounds, I want to know &lt;strong&gt;why&lt;/strong&gt; this is happening.</source>
          <target state="translated">これらすべての例で &lt;code&gt;undefined&lt;/code&gt; が出力されるのはなぜですか？ 回避策は必要ありません。 &lt;strong&gt;なぜ&lt;/strong&gt;これが起こっているの&lt;strong&gt;か&lt;/strong&gt;知りたいのですが。</target>
        </trans-unit>
        <trans-unit id="c4936bc542e6ff5a21b7420fda279b793c156e24" translate="yes" xml:space="preserve">
          <source>Why is my variable unaltered after I modify it inside of a function? - Asynchronous code reference</source>
          <target state="translated">関数の中で変数を変更した後、変数が変更されないのはなぜですか?-非同期コード参照</target>
        </trans-unit>
        <trans-unit id="30c09e36d32f8aa50d9fd572ae75dfa8792e72cd" translate="yes" xml:space="preserve">
          <source>Yesterday, the work I was doing required some information from a colleague. I rang him up; here's how the conversation went:</source>
          <target state="translated">昨日、私がやっていた仕事で、同僚から情報が必要になりました。彼に電話してみたんですが、その時の会話はこうでした。</target>
        </trans-unit>
        <trans-unit id="f1ced2ce1f9304e9a0ba78b790d5a22ededef908" translate="yes" xml:space="preserve">
          <source>You might currently have some code similar to this;</source>
          <target state="translated">現在、これに似たようなコードを持っているかもしれません。</target>
        </trans-unit>
        <trans-unit id="f7b14f844f491cec253dffd6a2877e87891e6a62" translate="yes" xml:space="preserve">
          <source>You will also notice that due to the asynchronous nature, it is impossible to &lt;code&gt;return&lt;/code&gt; a value from an asynchronous flow back to the synchronous flow where the callback was defined, as the asynchronous callbacks are executed long after the synchronous code has already finished executing.</source>
          <target state="translated">また、非同期の性質により、非同期コードからのコールバックが定義されている同期フローに値を &lt;code&gt;return&lt;/code&gt; ことはできません。非同期コードは、同期コードの実行が完了してからかなり後に実行されるためです。</target>
        </trans-unit>
        <trans-unit id="17990bb6c33a853fa89124957ec7cb0f2f107251" translate="yes" xml:space="preserve">
          <source>You'll &lt;strong&gt;&lt;em&gt;always&lt;/em&gt;&lt;/strong&gt; see a callback is specified as a function, because that's the only* way in JavaScript to define some code, but not execute it until later.</source>
          <target state="translated">コールバックが関数として指定されていることが&lt;strong&gt;&lt;em&gt;常に&lt;/em&gt;&lt;/strong&gt;わかります。これは、JavaScriptでコードを定義する唯一の*方法ですが、後で実行するためです。</target>
        </trans-unit>
        <trans-unit id="1a36ade9be4ed848a5cd8b84079e9715d403ca94" translate="yes" xml:space="preserve">
          <source>You're Missing the Point of Promises - domenic.me</source>
          <target state="translated">あなたは約束のポイントを逃している-domenic.me</target>
        </trans-unit>
        <trans-unit id="ff168847efe383bab3ac7dd4c396db86055ad902" translate="yes" xml:space="preserve">
          <source>jQuery &lt;code&gt;$.post&lt;/code&gt;'s callback may be called &lt;em&gt;sometime in the future&lt;/em&gt;, when (and if) the Ajax request has been completed successfully.</source>
          <target state="translated">jQuery &lt;code&gt;$.post&lt;/code&gt; のコールバックは、Ajaxリクエストが正常に完了した場合（および場合）、 &lt;em&gt;将来いつか&lt;/em&gt;呼び出さ&lt;em&gt;れる&lt;/em&gt;可能性があります。</target>
        </trans-unit>
        <trans-unit id="3506140f1030ab84b377ab6155325a3641104402" translate="yes" xml:space="preserve">
          <source>jQuery provides functionality that's similar to promises with its Deferreds.</source>
          <target state="translated">jQueryはDeferredsでプロミスに近い機能を提供しています。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
