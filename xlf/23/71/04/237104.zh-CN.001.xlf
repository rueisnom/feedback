<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/237104">
    <body>
      <group id="237104">
        <trans-unit id="fa1fddf27a8bbd3e6a51595070fec2ffdda0cba8" translate="yes" xml:space="preserve">
          <source>$.inArray works fine for determining whether a &lt;em&gt;scalar&lt;/em&gt; value exists in an array of scalars...</source>
          <target state="translated">$ .inArray可以很好地确定&lt;em&gt;标量&lt;/em&gt;数组中是否存在&lt;em&gt;标&lt;/em&gt;量值...</target>
        </trans-unit>
        <trans-unit id="e979338f8a2f2e59abc9249af3190ebc03ad8b13" translate="yes" xml:space="preserve">
          <source>(Unfortunately, while you can create an Array.prototype.contains to &quot;freeze&quot; an array and store a hashtable in this._cache in two lines, this would give wrong results if you chose to edit your array later. JavaScript has insufficient hooks to let you keep this state, unlike Python for example.)</source>
          <target state="translated">(不幸的是,虽然你可以创建一个Array.prototype.contains来 &quot;冻结 &quot;一个数组并在this._cache中存储一个hashtable,但如果你以后选择编辑数组,这将会给出错误的结果。JavaScript没有足够的钩子来让你保持这种状态,不像Python那样。)</target>
        </trans-unit>
        <trans-unit id="666a1d7cd2502c4f03da17df37ee0d8e05fc9ce7" translate="yes" xml:space="preserve">
          <source>* As jamess pointed out in the comment, at the time of this answer, September 2018, &lt;code&gt;Array.prototype.some()&lt;/code&gt; is fully supported: &lt;a href=&quot;http://kangax.github.io/compat-table/es5/#test-Array_methods_Array.prototype.some_a_href=_https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some_title=_MDN_documentation_img_src=_../mdn.png_alt=_MDN_(Mozilla_Development_Network)_logo_width=_15_height=_13_/_/a_nbsp;&quot;&gt;caniuse.com support table&lt;/a&gt;</source>
          <target state="translated">*正如詹姆士（Jamess）在评论中指出的那样，在此答案发布时（2018年9月 &lt;code&gt;Array.prototype.some()&lt;/code&gt; ，完全支持Array.prototype.some（） ： &lt;a href=&quot;http://kangax.github.io/compat-table/es5/#test-Array_methods_Array.prototype.some_a_href=_https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some_title=_MDN_documentation_img_src=_../mdn.png_alt=_MDN_(Mozilla_Development_Network)_logo_width=_15_height=_13_/_/a_nbsp;&quot;&gt;caniuse.com支持表&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ff01b541f233e095936ed95fd600d53d0d50e8cd" translate="yes" xml:space="preserve">
          <source>... but the question clearly asks for an efficient way to determine if an &lt;em&gt;object&lt;/em&gt; is contained in an array.</source>
          <target state="translated">...但是这个问题显然要求一种有效的方法来确定&lt;em&gt;对象&lt;/em&gt;是否包含在数组中。</target>
        </trans-unit>
        <trans-unit id="82ba87f801a9d4855c22108ef67433ef0a8af8b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;Array.prototype.some()&lt;/a&gt; was added to the ECMA-262 standard in the 5th edition</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;Array.prototype.some（）&lt;/a&gt;已在第5版中添加到ECMA-262标准中</target>
        </trans-unit>
        <trans-unit id="b1af03410872d22aa090478ca85044102ca7e787" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/indexOf&quot;&gt;&lt;code&gt;indexOf&lt;/code&gt;&lt;/a&gt; maybe, but it's a &quot;JavaScript extension to the ECMA-262 standard; as such it may not be present in other implementations of the standard.&quot;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/indexOf&quot;&gt; &lt;code&gt;indexOf&lt;/code&gt; &lt;/a&gt;可能是，但是它是&amp;ldquo; ECMA-262标准的JavaScript扩展；因此，该标准的其他实现中可能不存在它&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="bffcb9f337378974e8b34966a149dbbb68e52188" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array.indexOf&lt;/code&gt; and &lt;code&gt;Array.includes&lt;/code&gt; (as well as most of the answers here) only compare by reference and not by value.</source>
          <target state="translated">&lt;code&gt;Array.indexOf&lt;/code&gt; 和 &lt;code&gt;Array.includes&lt;/code&gt; （以及此处的大多数答案）仅按引用而不是按值进行比较。</target>
        </trans-unit>
        <trans-unit id="0c67478f11e2e78d248d12730af40590e49d8d53" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Requirements:&lt;/em&gt; Recommend most concise and efficient way to find out if a JavaScript array contains an object.</source>
          <target state="translated">&lt;em&gt;要求：&lt;/em&gt;推荐一种最简洁，最有效的方法来找出JavaScript数组是否包含对象。</target>
        </trans-unit>
        <trans-unit id="3328e402eaab9fa9ffa2904507ac1e15deedaa9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A hopefully faster bidirectional &lt;code&gt;indexOf&lt;/code&gt; / &lt;code&gt;lastIndexOf&lt;/code&gt; alternative&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;希望更快的双向 &lt;code&gt;indexOf&lt;/code&gt; / &lt;code&gt;lastIndexOf&lt;/code&gt; 替代&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8d78a67732f4c0a40bd987aec69c5f5c06ced172" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Accepted Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;接受的答案：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dca58c8f007a19a8c485db3191ee67d50e382e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array big - 1.000.000 elements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;大数组-1.000.000元素&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bcb9db629c9a0558ab47a317e2d8b485d0969128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array small - 10 elements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;小数组-10个元素&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2550bdae36c113e4a47d24b4ea74558c357b9dd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bidirectional indexOf/lastIndexOf&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;双向indexOf / lastIndexOf&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dca676a8af0cab5dcd796ab1ed5917f8c1ae0c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;My recommendation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;我的建议：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="da2dcdbcfc4b0fe47450de9fb9a98320068c3e91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update from 2019: This answer is from 2008 (11 years old!) and is not relevant for modern JS usage. The promised performance improvement was based on a benchmark done in browsers of that time. It might not be relevant to modern JS execution contexts. If you need an easy solution, look for other answers. If you need the best performance, benchmark for yourself in the relevant execution environments.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;从2019年开始更新：这个答案来自2008年（11岁！），与现代JS使用无关。&lt;/strong&gt; &lt;strong&gt;承诺的性能改进基于当时在浏览器中完成的基准测试。&lt;/strong&gt; &lt;strong&gt;它可能与现代JS执行上下文无关。&lt;/strong&gt; &lt;strong&gt;如果您需要简单的解决方案，请寻找其他答案。&lt;/strong&gt; &lt;strong&gt;如果您需要最佳性能，请在相关执行环境中为自己设定基准。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3dd7f728110b6212e76f1f99084dfc27e75be15a" translate="yes" xml:space="preserve">
          <source>A performant way has already been found, looking at the top answers. From those I chose the &lt;code&gt;contains&lt;/code&gt; function posted by @Damir Zekic which should be the fastest one. But it also states that the benchmarks are from 2008 and so are outdated.</source>
          <target state="translated">已经找到了一种表现最佳的方法，寻找最重要的答案。 从这些中，我选择了@Damir Zekic发布的 &lt;code&gt;contains&lt;/code&gt; 函数，它应该是最快的。 但是它也指出基准是从2008年开始的，因此已经过时了。</target>
        </trans-unit>
        <trans-unit id="3fea7bc0c9c385deaf9e732da8ef43205ce4079c" translate="yes" xml:space="preserve">
          <source>AFAICS &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/k4h76zbx%5C%28VS.85%5C%29.aspx&quot;&gt;Microsoft does &lt;em&gt;not&lt;/em&gt; offer some kind of alternative&lt;/a&gt; to this, but you can add similar functionality to arrays in Internet Explorer (and other browsers that don't support &lt;code&gt;indexOf&lt;/code&gt;) if you want to, as a &lt;a href=&quot;http://google.com/search?q=indexof%20internet%20explorer&quot;&gt;quick Google search reveals&lt;/a&gt; (for example, &lt;a href=&quot;http://soledadpenades.com/2007/05/17/arrayindexof-in-internet-explorer/&quot;&gt;this one&lt;/a&gt;).</source>
          <target state="translated">AFAICS &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/k4h76zbx%5C%28VS.85%5C%29.aspx&quot;&gt;Microsoft并&lt;em&gt;没有&lt;/em&gt;提供其他替代方法&lt;/a&gt; ，但是您可以根据需要在Internet Explorer（以及其他不支持 &lt;code&gt;indexOf&lt;/code&gt; 的其他浏览器）中向阵列添加类似的功能，例如&lt;a href=&quot;http://google.com/search?q=indexof%20internet%20explorer&quot;&gt;Google快速搜索所揭示的&lt;/a&gt; （例如， &lt;a href=&quot;http://soledadpenades.com/2007/05/17/arrayindexof-in-internet-explorer/&quot;&gt;一&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2e1a21db865a12dc215cd0757653828363ce0b37" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;http://github.com/sstephenson/prototype/blob/f405b2c510e09b55d08c926a9e1a5c2e2d0a1834/src/lang/array.js#L364-365&quot;&gt;here&lt;/a&gt; for how they hook it up.</source>
          <target state="translated">另请参阅&lt;a href=&quot;http://github.com/sstephenson/prototype/blob/f405b2c510e09b55d08c926a9e1a5c2e2d0a1834/src/lang/array.js#L364-365&quot;&gt;此处&lt;/a&gt; ，了解他们如何进行连接。</target>
        </trans-unit>
        <trans-unit id="ef2cd47054f7c2e7287dcdcf3389cdb38c008c53" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;indexOf&lt;/code&gt;, &lt;code&gt;includes&lt;/code&gt; does not skip missing indices:</source>
          <target state="translated">也不同于 &lt;code&gt;indexOf&lt;/code&gt; ， &lt;code&gt;includes&lt;/code&gt; 不会跳过丢失的索引：</target>
        </trans-unit>
        <trans-unit id="fe1263bbb735fe48bd1e929be3a7542be2dfbbe3" translate="yes" xml:space="preserve">
          <source>Also, it fits nicely in an &lt;code&gt;if&lt;/code&gt; statement since it returns a boolean:</source>
          <target state="translated">此外，由于它返回布尔值，因此它非常适合 &lt;code&gt;if&lt;/code&gt; 语句：</target>
        </trans-unit>
        <trans-unit id="fd49cf48d65e8591372b9ab2e58ef2862979ec3c" translate="yes" xml:space="preserve">
          <source>And here is the &lt;code&gt;while&lt;/code&gt; variant:</source>
          <target state="translated">这是 &lt;code&gt;while&lt;/code&gt; 变体：</target>
        </trans-unit>
        <trans-unit id="e9e912c3f4aaddf36a551e9a19f1b31785ce824c" translate="yes" xml:space="preserve">
          <source>And now you can simply use the following:</source>
          <target state="translated">而现在,你只需使用下面的方法就可以了。</target>
        </trans-unit>
        <trans-unit id="28746dfd1b61ed6d0a8ada4c2b2b65c189a03dc0" translate="yes" xml:space="preserve">
          <source>Array.prototype.&lt;strong&gt;find&lt;/strong&gt; -&amp;gt; (takes callback, returns first &lt;strong&gt;value/object&lt;/strong&gt; that returns true in CB).</source>
          <target state="translated">Array.prototype。 &lt;strong&gt;find&lt;/strong&gt; -&amp;gt;（进行回调，返回在CB中返回true的第一个&lt;strong&gt;值/对象&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="2a2ae4f8c0c85f5dda2d7c7b158b42785c2c9b38" translate="yes" xml:space="preserve">
          <source>Array.prototype.&lt;strong&gt;findIndex&lt;/strong&gt; -&amp;gt; (takes callback, returns &lt;strong&gt;index&lt;/strong&gt; of first value/object that returns true in CB).</source>
          <target state="translated">Array.prototype。 &lt;strong&gt;findIndex&lt;/strong&gt; -&amp;gt;（进行回调，返回在CB中返回true的第一个值/对象的&lt;strong&gt;索引&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="13774ea8043b54624cbe8f2322d27cbd49c3f695" translate="yes" xml:space="preserve">
          <source>Array.prototype.&lt;strong&gt;includes&lt;/strong&gt; -&amp;gt; (returns &lt;strong&gt;true&lt;/strong&gt; or &lt;strong&gt;false&lt;/strong&gt;)</source>
          <target state="translated">Array.prototype。 &lt;strong&gt;包括&lt;/strong&gt; -&amp;gt;（返回&lt;strong&gt;true&lt;/strong&gt;或&lt;strong&gt;false&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="159144824cccf4c9146f260d2d0aec916594f068" translate="yes" xml:space="preserve">
          <source>Array.prototype.&lt;strong&gt;indexOf&lt;/strong&gt; -&amp;gt; (returns &lt;strong&gt;index or -1&lt;/strong&gt;) is generally used for finding index of element in array.
This can also be used for searching object but only works if you are passing reference to same object.</source>
          <target state="translated">Array.prototype。 &lt;strong&gt;indexOf&lt;/strong&gt; -&amp;gt;（返回&lt;strong&gt;索引或-1&lt;/strong&gt; ）通常用于查找数组中元素的索引。 这也可以用于搜索对象，但是仅当您将引用传递给同一对象时才有效。</target>
        </trans-unit>
        <trans-unit id="ee6d18b2067d77f05479b33415bea0665938366f" translate="yes" xml:space="preserve">
          <source>As custom Array method (pre ES2016)</source>
          <target state="translated">作为自定义阵列方法(ES2016之前)</target>
        </trans-unit>
        <trans-unit id="820471fc96bdf044cac7a71fa7e5925072bd7715" translate="yes" xml:space="preserve">
          <source>As others have said, the iteration through the array is probably the best way, but it &lt;a href=&quot;http://blogs.oracle.com/greimer/entry/best_way_to_code_a&quot;&gt;has been proven&lt;/a&gt; that a decreasing &lt;code&gt;while&lt;/code&gt; loop is the fastest way to iterate in JavaScript. So you may want to rewrite your code as follows:</source>
          <target state="translated">就像其他人所说的那样，遍历数组可能是最好的方法，但是&lt;a href=&quot;http://blogs.oracle.com/greimer/entry/best_way_to_code_a&quot;&gt;事实证明&lt;/a&gt; ，减少 &lt;code&gt;while&lt;/code&gt; 循环是在JavaScript中进行迭代的最快方法。 因此，您可能希望按如下所示重写代码：</target>
        </trans-unit>
        <trans-unit id="a183a9029e6053aa206bd8f78fb63e1bcdddaac1" translate="yes" xml:space="preserve">
          <source>As test I created an array with 100k entries.</source>
          <target state="translated">作为测试,我创建了一个有100k条目的数组。</target>
        </trans-unit>
        <trans-unit id="9d7e7c087b4bd3ac73364918b2ee9cb9c1799676" translate="yes" xml:space="preserve">
          <source>Below are three ways of checking whether there is a &lt;code&gt;3&lt;/code&gt; in there. All of them return either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">以下是检查其中是否存在 &lt;code&gt;3&lt;/code&gt; 的三种方法。 它们全部返回 &lt;code&gt;true&lt;/code&gt; 或 &lt;code&gt;false&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4d963cfab70d8c850b1221649bcc7b4d96d558d3" translate="yes" xml:space="preserve">
          <source>Bonus</source>
          <target state="translated">Bonus</target>
        </trans-unit>
        <trans-unit id="00d426145cd70803b163fe1889541e0436672a9b" translate="yes" xml:space="preserve">
          <source>Currently it's still a draft but can be &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Polyfill&quot;&gt;polyfilled&lt;/a&gt; to make it work on all browsers.</source>
          <target state="translated">目前，它仍然是草稿，但可以对其进行多&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Polyfill&quot;&gt;填充&lt;/a&gt;以使其在所有浏览器上均可使用。</target>
        </trans-unit>
        <trans-unit id="e52c854d5631eec7468ba4727b4c77eb745f2965" translate="yes" xml:space="preserve">
          <source>Demo</source>
          <target state="translated">Demo</target>
        </trans-unit>
        <trans-unit id="83d36288b5c8873730d74ec2bee7f0a6e4883b2f" translate="yes" xml:space="preserve">
          <source>Demo:</source>
          <target state="translated">Demo:</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="b75e71a9c0a73c636523fc12a59e51c67115ee2c" translate="yes" xml:space="preserve">
          <source>Dojo Toolkit: &lt;a href=&quot;http://dojotoolkit.org/reference-guide/dojo/indexOf.html&quot;&gt;&lt;code&gt;dojo.indexOf(array, value, [fromIndex, findLast])&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Dojo工具包： &lt;a href=&quot;http://dojotoolkit.org/reference-guide/dojo/indexOf.html&quot;&gt; &lt;code&gt;dojo.indexOf(array, value, [fromIndex, findLast])&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7eb5e66ccf7ff4b0c3e12f9b838e3c060dbe7ab" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 has an elegant proposal on find.</source>
          <target state="translated">ECMAScript 6有一个关于查找的优雅建议。</target>
        </trans-unit>
        <trans-unit id="b288b702748358f62fc1dabe0b0e9ae73618544c" translate="yes" xml:space="preserve">
          <source>ECMAScript 7 introduces &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes&quot;&gt;&lt;code&gt;Array.prototype.includes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ECMAScript 7引入了&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes&quot;&gt; &lt;code&gt;Array.prototype.includes&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="ac15517e284529ed9d77b5e4ab5790a55e8af0bf" translate="yes" xml:space="preserve">
          <source>Ext: &lt;a href=&quot;http://docs.sencha.com/extjs/4.0.0/#/api/Ext.Array-method-contains&quot;&gt;&lt;code&gt;Ext.Array.contains(array, value)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Ext： &lt;a href=&quot;http://docs.sencha.com/extjs/4.0.0/#/api/Ext.Array-method-contains&quot;&gt; &lt;code&gt;Ext.Array.contains(array, value)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb68107e5febdf35eea1d01bad4984345866f1fd" translate="yes" xml:space="preserve">
          <source>Extending the JavaScript &lt;code&gt;Array&lt;/code&gt; object is a really bad idea because you introduce new properties (your custom methods) into &lt;code&gt;for-in&lt;/code&gt; loops which can break existing scripts. A few years ago the authors of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework&quot;&gt;Prototype&lt;/a&gt; library had to re-engineer their library implementation to remove just this kind of thing.</source>
          <target state="translated">扩展JavaScript &lt;code&gt;Array&lt;/code&gt; 对象是一个非常糟糕的主意，因为您在 &lt;code&gt;for-in&lt;/code&gt; 循环中引入了新属性（您的自定义方法） ，这可能会破坏现有脚本。 几年前， &lt;a href=&quot;http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework&quot;&gt;原型&lt;/a&gt;库的作者不得不重新设计其库实现，以删除此类内容。</target>
        </trans-unit>
        <trans-unit id="f5ec22899f4427f21921edbbd5e8fb8dcb009ec9" translate="yes" xml:space="preserve">
          <source>Here is a complex example doing three checks per iteration, but this is only possible with a longer calculation which causes the slowdown of the code.</source>
          <target state="translated">这里是一个复杂的例子,每次迭代做三次检查,但这只有在计算时间较长的情况下才会导致代码速度变慢。</target>
        </trans-unit>
        <trans-unit id="32a46c0daf7a31dffc5357242054af1019b73d24" translate="yes" xml:space="preserve">
          <source>Here is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt;MDN documentation&lt;/a&gt; on that.</source>
          <target state="translated">这是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt;MDN文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f73591287f9a256c22a935074fa54f1b4edc5742" translate="yes" xml:space="preserve">
          <source>Here's a &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&quot;&gt;JavaScript 1.6 compatible&lt;/a&gt; implementation of &lt;code&gt;Array.indexOf&lt;/code&gt;:</source>
          <target state="translated">这是 &lt;code&gt;Array.indexOf&lt;/code&gt; 的&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&quot;&gt;JavaScript 1.6兼容&lt;/a&gt;实现：</target>
        </trans-unit>
        <trans-unit id="73ddb6b3efa49acc39d3b80f97da9706b3ea2e7a" translate="yes" xml:space="preserve">
          <source>Here's how &lt;a href=&quot;http://github.com/sstephenson/prototype/blob/f405b2c510e09b55d08c926a9e1a5c2e2d0a1834/src/lang/array.js#L286-302&quot;&gt;Prototype does it&lt;/a&gt;:</source>
          <target state="translated">这是&lt;a href=&quot;http://github.com/sstephenson/prototype/blob/f405b2c510e09b55d08c926a9e1a5c2e2d0a1834/src/lang/array.js#L286-302&quot;&gt;Prototype的工作方式&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="20ae8e0c00b1fa1a1071d47bdb057532c38b84b1" translate="yes" xml:space="preserve">
          <source>How do I check if an array includes a value in JavaScript</source>
          <target state="translated">如何检查JavaScript中的数组是否包含一个值?</target>
        </trans-unit>
        <trans-unit id="2494e96cd66323400e7154384c7f185dc839ebd1" translate="yes" xml:space="preserve">
          <source>How is this possible?</source>
          <target state="translated">这怎么可能呢?</target>
        </trans-unit>
        <trans-unit id="c99fe5750c3181f3859af356a418988a87310708" translate="yes" xml:space="preserve">
          <source>I also prefer &lt;code&gt;while&lt;/code&gt; over &lt;code&gt;for&lt;/code&gt;, but for not a specific reason I ended writing the function with a for loop. It could be also done with a &lt;code&gt;while --&lt;/code&gt;.</source>
          <target state="translated">我也更喜欢 &lt;code&gt;for&lt;/code&gt; ，但出于特定原因，我结束了使用for循环编写函数的工作。 也可以用 &lt;code&gt;while --&lt;/code&gt; 来完成- 。</target>
        </trans-unit>
        <trans-unit id="4e7f926e0198c33afed235e77fff45b62d69efaf" translate="yes" xml:space="preserve">
          <source>I also run test for big array when searched element was on position 66% of array length, and solutions based on &lt;code&gt;for&lt;/code&gt; (C,D,E) gives similar results (~630 ops/sec - but the E on safari and firefox was 10-20% slower than C and D)</source>
          <target state="translated">当搜索到的元素位于数组长度的66％的位置时，我也对大型数组进行了测试，基于（C，D，E）的解决方案给出了相似的结果（〜630 ops / sec-但是Safari和Firefox中的E为10比C和D慢-20％）</target>
        </trans-unit>
        <trans-unit id="84464b4ca7dfa8c6d4801774a3135af233b2ebac" translate="yes" xml:space="preserve">
          <source>I hope you also find this interesting and test the performance.</source>
          <target state="translated">希望大家也觉得有趣,测试一下性能。</target>
        </trans-unit>
        <trans-unit id="9dcc9d0305378204bf3ede8b2618fed0eb90649c" translate="yes" xml:space="preserve">
          <source>I perform 2 tests cases: for array with 10 elements, and array with 1 milion elements. In both cases we put searched element in the array middle.</source>
          <target state="translated">我执行了2个测试案例:10个元素的数组和1个元素的数组。在这两种情况下,我们把搜索的元素放在数组中间。</target>
        </trans-unit>
        <trans-unit id="0b8a1c5b70eefb3d48daa75b54a499297c28805a" translate="yes" xml:space="preserve">
          <source>I think that the simple calculation to get the reflected index in an array is so simple that it's two times faster than doing an actual loop iteration.</source>
          <target state="translated">我认为,获取数组中的反射索引的计算很简单,比实际做一个循环迭代要快2倍。</target>
        </trans-unit>
        <trans-unit id="c9fe622e69b560ae352d96f8ff0fcf61e9c7bed2" translate="yes" xml:space="preserve">
          <source>I use the following:</source>
          <target state="translated">我用的是:</target>
        </trans-unit>
        <trans-unit id="28e4ffc52f1e8141f4b7d43d5c75f149bcd5dfc8" translate="yes" xml:space="preserve">
          <source>I was curious if the iteration was much slower if I check both sides of the array while doing it. Apparently no, and so this function is around two times faster than the top voted ones. Obviously it's also faster than the native one. This in a real world environment, where you never know if the value you are searching is at the beginning or at the end of the array.</source>
          <target state="translated">我很好奇,如果我在做这个功能的时候检查数组的两边,迭代的速度会不会慢很多?显然不是,所以这个函数比顶投的快2倍左右。显然,它也比原生的快。这在现实环境中,你永远不知道你要搜索的值是在数组的开头还是在数组的结尾。</target>
        </trans-unit>
        <trans-unit id="b9f22fd83bdf3e491fb6e80ec269fbb800d6ee83" translate="yes" xml:space="preserve">
          <source>IE6+ solution:</source>
          <target state="translated">IE6+解决方案。</target>
        </trans-unit>
        <trans-unit id="e2c5590817181cc7e7c8909b5f1ca3dd5150eaf6" translate="yes" xml:space="preserve">
          <source>If you are checking repeatedly for existence of an object in an array you should maybe look into</source>
          <target state="translated">如果你要反复检查数组中的对象是否存在,你也许应该研究一下</target>
        </trans-unit>
        <trans-unit id="625b41de336989cef496844e1118db8209392193" translate="yes" xml:space="preserve">
          <source>If you are using JavaScript 1.6 or later (Firefox 1.5 or later) you can use &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&quot;&gt;Array.indexOf&lt;/a&gt;.  Otherwise, I think you are going to end up with something similar to your original code.</source>
          <target state="translated">如果您使用的是JavaScript 1.6或更高版本（Firefox 1.5或更高版本），则可以使用&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&quot;&gt;Array.indexOf&lt;/a&gt; 。 否则，我认为您最终将得到与原始代码相似的东西。</target>
        </trans-unit>
        <trans-unit id="3ee6e017af8f89d3d12e3d78389bb4add3cf2317" translate="yes" xml:space="preserve">
          <source>If you don't need to worry about compatibility with other JavaScript running on your page, go for it, otherwise, I'd recommend the more awkward, but safer free-standing function solution.</source>
          <target state="translated">如果你不需要担心与你的页面上运行的其他JavaScript的兼容性,那就去做吧,否则,我推荐更笨拙,但更安全的独立功能解决方案。</target>
        </trans-unit>
        <trans-unit id="2daaa05340a4a5fbf45632f41108223c525f42cf" translate="yes" xml:space="preserve">
          <source>If you're having array of objects like below,</source>
          <target state="translated">如果你有像下面这样的对象数组。</target>
        </trans-unit>
        <trans-unit id="d2da7e5fc690c05c7dd880dab7d51eecaf495e88" translate="yes" xml:space="preserve">
          <source>In order to handle both scalars and objects, you could do this:</source>
          <target state="translated">为了同时处理标量和对象,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="fbb0ba0cb144ea9ec30e8a02f59189cac1e0fd83" translate="yes" xml:space="preserve">
          <source>Is there a better and more concise way to accomplish this?</source>
          <target state="translated">有没有更好、更简洁的方法来完成?</target>
        </trans-unit>
        <trans-unit id="96524039763060c62193d4b3f2e8e0aeb1a9c048" translate="yes" xml:space="preserve">
          <source>It also accepts an optional second argument &lt;code&gt;fromIndex&lt;/code&gt;:</source>
          <target state="translated">它还接受一个可选的第二个参数 &lt;code&gt;fromIndex&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7957cdd685e55b0659e0f881b1501d7538cec20a" translate="yes" xml:space="preserve">
          <source>It can be used like this:</source>
          <target state="translated">它可以这样使用。</target>
        </trans-unit>
        <trans-unit id="dec9bd251fe067dfc0548c5c6f8d543981f5dc35" translate="yes" xml:space="preserve">
          <source>It's concise, accurate and has great cross platform support.</source>
          <target state="translated">它简洁、准确,并且有很好的跨平台支持。</target>
        </trans-unit>
        <trans-unit id="d7b1386bed9cbbf81dba8983bdb2c019db7c6ebc" translate="yes" xml:space="preserve">
          <source>It's long time that I was thinking of way to replace the slow indexOf/lastIndexOf functions.</source>
          <target state="translated">很久以来,我一直在想用什么方法来代替慢的indexOflastIndexOf函数。</target>
        </trans-unit>
        <trans-unit id="25b2e1835d0c0287f224776b63a40c7d557a0824" translate="yes" xml:space="preserve">
          <source>Keeping the array sorted at all times by doing &lt;a href=&quot;http://en.wikipedia.org/wiki/Insertion_sort&quot;&gt;insertion sort&lt;/a&gt; in your array (put new objects in on the right place)</source>
          <target state="translated">通过在数组中进行&lt;a href=&quot;http://en.wikipedia.org/wiki/Insertion_sort&quot;&gt;插入排序&lt;/a&gt; （始终将新对象放在正确的位置）来始终保持数组的排序</target>
        </trans-unit>
        <trans-unit id="fc09e2e02a3b9b59afbbd4c12fd5ae7cc7d86edf" translate="yes" xml:space="preserve">
          <source>Let's say we have array of Objects arrObj and we want to search obj in it.</source>
          <target state="translated">假设我们有一个数组对象 arrObj,我们想在其中搜索obj。</target>
        </trans-unit>
        <trans-unit id="5dcdd6376733383c88fb8505f672ce2c465e3ee7" translate="yes" xml:space="preserve">
          <source>Let's say you've defined an array like so:</source>
          <target state="translated">假设你定义了一个像这样的数组。</target>
        </trans-unit>
        <trans-unit id="1133d8a8268183b654cc15e962adec1905def045" translate="yes" xml:space="preserve">
          <source>Lodash: &lt;a href=&quot;https://lodash.com/docs#includes&quot;&gt;&lt;code&gt;_.includes(array, value, [from])&lt;/code&gt;&lt;/a&gt; (is &lt;code&gt;_.contains&lt;/code&gt; prior 4.0.0)</source>
          <target state="translated">Lodash： &lt;a href=&quot;https://lodash.com/docs#includes&quot;&gt; &lt;code&gt;_.includes(array, value, [from])&lt;/code&gt; &lt;/a&gt; （是 &lt;code&gt;_.contains&lt;/code&gt; 4.0.0之前的版本）</target>
        </trans-unit>
        <trans-unit id="15ad60cdf54e6bc76cdd4462ba0c40f97badfa2d" translate="yes" xml:space="preserve">
          <source>MS Ajax: &lt;a href=&quot;http://www.asp.net/ajaxlibrary/Reference.Array-indexOf-Function.ashx&quot;&gt;&lt;code&gt;array.indexOf(value)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">MS Ajax： &lt;a href=&quot;http://www.asp.net/ajaxlibrary/Reference.Array-indexOf-Function.ashx&quot;&gt; &lt;code&gt;array.indexOf(value)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="84984b49ae654a77558f7a39ed56f68055a47884" translate="yes" xml:space="preserve">
          <source>Make updating objects as remove+sorted insert operation and</source>
          <target state="translated">将更新对象作为删除+排序插入操作和</target>
        </trans-unit>
        <trans-unit id="13f96a3206465a40fdd57b0c45a1c47a96492ce3" translate="yes" xml:space="preserve">
          <source>Many frameworks also offer similar methods:</source>
          <target state="translated">许多框架也提供了类似的方法。</target>
        </trans-unit>
        <trans-unit id="34b498db5861179f4d01de30ad382c1c99d173a6" translate="yes" xml:space="preserve">
          <source>MochiKit: &lt;a href=&quot;http://mochi.github.io/mochikit/doc/html/MochiKit/Base.html#fn-findvalue&quot;&gt;&lt;code&gt;findValue(array, value)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://mochi.github.io/mochikit/doc/html/MochiKit/Base.html#fn-findvalue&quot;&gt; &lt;code&gt;findValue(array, value)&lt;/code&gt; &lt;/a&gt; ： findValue（数组，值）</target>
        </trans-unit>
        <trans-unit id="11bd5cb3c081453f6118ff4b291498d2d7511e0d" translate="yes" xml:space="preserve">
          <source>Modern browsers have &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Browser_compatibility&quot;&gt;&lt;code&gt;Array#includes&lt;/code&gt;&lt;/a&gt;, which does &lt;em&gt;exactly&lt;/em&gt; that and &lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-Array.prototype.includes&quot;&gt;is widely supported&lt;/a&gt; by everyone except IE:</source>
          <target state="translated">现代浏览器具有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Browser_compatibility&quot;&gt; &lt;code&gt;Array#includes&lt;/code&gt; &lt;/a&gt; ，它可以做到这一点，并且除IE之外，每个人都&lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-Array.prototype.includes&quot;&gt;广泛支持&lt;/a&gt;它：</target>
        </trans-unit>
        <trans-unit id="ac5f3f86aeba412f6c7300de9ded324b814b2be2" translate="yes" xml:space="preserve">
          <source>MooTools: &lt;a href=&quot;https://mootools.net/core/docs/1.6.0/Types/Array#Array:indexOf&quot;&gt;&lt;code&gt;array.indexOf(value)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">MooTools： &lt;a href=&quot;https://mootools.net/core/docs/1.6.0/Types/Array#Array:indexOf&quot;&gt; &lt;code&gt;array.indexOf(value)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f9f5580daea7b8f13b0defea3a5dc9f8652aa84" translate="yes" xml:space="preserve">
          <source>Native Array method (since ES2016) (&lt;a href=&quot;https://caniuse.com/#feat=array-includes&quot;&gt;compatibility table&lt;/a&gt;)</source>
          <target state="translated">本机数组方法（自ES2016起）（ &lt;a href=&quot;https://caniuse.com/#feat=array-includes&quot;&gt;兼容性表&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="697f83c56e4af8a3d870ae1c1d3850dac14005f4" translate="yes" xml:space="preserve">
          <source>Non-optimized ES6 one-liner:</source>
          <target state="translated">非优化的ES6单行本。</target>
        </trans-unit>
        <trans-unit id="cf369e9f80a3aee5118b14ec07f5711bfcb6fc0f" translate="yes" xml:space="preserve">
          <source>Note:
Comparing objects by value will work better if the keys are in the same order, so to be safe you might sort the keys first with a package like this one: &lt;a href=&quot;https://www.npmjs.com/package/sort-keys&quot;&gt;https://www.npmjs.com/package/sort-keys&lt;/a&gt;</source>
          <target state="translated">注意：如果键的顺序相同，则按值比较对象会更好，因此，为了安全起见，您可以首先使用以下程序包对键进行排序： &lt;a href=&quot;https://www.npmjs.com/package/sort-keys&quot;&gt;https&lt;/a&gt; : //www.npmjs.com/package/sort-keys</target>
        </trans-unit>
        <trans-unit id="11415b96e3d11a9e4bc779554b10a502ba013727" translate="yes" xml:space="preserve">
          <source>Note: As you can see I slightly modified the &lt;code&gt;contains&lt;/code&gt; function to reflect the indexOf &amp;amp; lastIndexOf output (so basically &lt;code&gt;true&lt;/code&gt; with the &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; with &lt;code&gt;-1&lt;/code&gt;). That shouldn't harm it.</source>
          <target state="translated">注意：如您所见，我稍微修改了 &lt;code&gt;contains&lt;/code&gt; 函数以反映indexOf＆lastIndexOf输出（因此，对于 &lt;code&gt;index&lt;/code&gt; 基本上为 &lt;code&gt;true&lt;/code&gt; ，对于 &lt;code&gt;-1&lt;/code&gt; 基本上为 &lt;code&gt;false&lt;/code&gt; ）。 那不应该伤害它。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="f625fa0058ddfcc2adcd5b53ac3bb76651142210" translate="yes" xml:space="preserve">
          <source>Notice that some frameworks implement this as a function, while others add the function to the array prototype.</source>
          <target state="translated">注意,有些框架将其作为一个函数实现,而有些框架则将该函数添加到数组原型中。</target>
        </trans-unit>
        <trans-unit id="40a0fca5b4ff80b27dceac44499b495cb11b44ad" translate="yes" xml:space="preserve">
          <source>OK, you can just &lt;strong&gt;optimise your&lt;/strong&gt; code to get the result!</source>
          <target state="translated">好的，您只需&lt;strong&gt;优化&lt;/strong&gt;代码即可获得结果！</target>
        </trans-unit>
        <trans-unit id="c6004473778dc819accd15d1a64aa218f11402d1" translate="yes" xml:space="preserve">
          <source>Of course, you may as well extend Array prototype:</source>
          <target state="translated">当然,你也可以扩展Array原型。</target>
        </trans-unit>
        <trans-unit id="f479744c024205bcadceb234c72adf9ccab6115d" translate="yes" xml:space="preserve">
          <source>One can use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt; that has the method &quot;has()&quot;:</source>
          <target state="translated">可以使用具有方法&amp;ldquo; has（）&amp;rdquo;的&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="825581b147d158d0a4fcbad34b8422e021ee90b1" translate="yes" xml:space="preserve">
          <source>One-liner:</source>
          <target state="translated">One-liner:</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="68c145e8a882446ce410a8fffbfe92a5b1901acc" translate="yes" xml:space="preserve">
          <source>Performance test</source>
          <target state="translated">性能测试</target>
        </trans-unit>
        <trans-unit id="14af93ac2aa339aa659d1348d1120c589b66f432" translate="yes" xml:space="preserve">
          <source>Prototype: &lt;a href=&quot;http://api.prototypejs.org/language/Array/prototype/indexOf/&quot;&gt;&lt;code&gt;array.indexOf(value)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">原型： &lt;a href=&quot;http://api.prototypejs.org/language/Array/prototype/indexOf/&quot;&gt; &lt;code&gt;array.indexOf(value)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7effb1c9ae5bdca656da5f4d5ba15d3df67f272" translate="yes" xml:space="preserve">
          <source>Ramda: &lt;a href=&quot;https://ramdajs.com/docs/#includes&quot;&gt;&lt;code&gt;R.includes(value, array)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://ramdajs.com/docs/#includes&quot;&gt; &lt;code&gt;R.includes(value, array)&lt;/code&gt; &lt;/a&gt; ： R.includes（值，数组）</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="e8323adb0162f1ecb663442b5fcc7ca8dcc10b18" translate="yes" xml:space="preserve">
          <source>Returns array index if found, or -1 if not found</source>
          <target state="translated">如果找到,则返回数组索引,如果没有找到,则返回-1。</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">显示代码片段</target>
        </trans-unit>
        <trans-unit id="cde8d71a70567d48dd01952e68d8fa1e0ed18bca" translate="yes" xml:space="preserve">
          <source>Simple function</source>
          <target state="translated">简单的功能</target>
        </trans-unit>
        <trans-unit id="0e9d5dfd8c62d9bd7b04e68e33d6289e0216ca1f" translate="yes" xml:space="preserve">
          <source>Simple solution for this requirement is using &lt;code&gt;find()&lt;/code&gt;</source>
          <target state="translated">满足此要求的简单解决方案是使用 &lt;code&gt;find()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cba0b4c636764d40e59c45dfcbeaff8fd15c2f2f" translate="yes" xml:space="preserve">
          <source>Since find and findIndex takes a callback, we can be fetch any object(even if we don't have the reference) from array by creatively setting the true condition.</source>
          <target state="translated">由于find和findIndex需要回调,所以我们可以通过创造性地设置true条件,从数组中提取任何对象(即使没有引用)。</target>
        </trans-unit>
        <trans-unit id="e8120e70e781059a2250649e3a26d1ef79737908" translate="yes" xml:space="preserve">
          <source>Solution that works in all modern browsers:</source>
          <target state="translated">可在所有现代浏览器中工作的解决方案。</target>
        </trans-unit>
        <trans-unit id="c76563a98a925864b596ec5d5c1c427850c1e563" translate="yes" xml:space="preserve">
          <source>Surprised that this question still doesn't have latest syntax added, adding my 2 cents.</source>
          <target state="translated">没想到这个问题还是没有添加最新的语法,补充我的2分钱。</target>
        </trans-unit>
        <trans-unit id="e32c19490d0541d3cf19e6edf0e601f2c55e35c0" translate="yes" xml:space="preserve">
          <source>The accepted answer does not even meet the requirements.</source>
          <target state="translated">接受的答案根本不符合要求。</target>
        </trans-unit>
        <trans-unit id="6e76714ac550731d4df9f2f4c7278a064a84b068" translate="yes" xml:space="preserve">
          <source>The array prototype variant</source>
          <target state="translated">阵列原型变体</target>
        </trans-unit>
        <trans-unit id="fbe496135ed624dc79a7b415841f95f2535966fe" translate="yes" xml:space="preserve">
          <source>The find functionality works like this.</source>
          <target state="translated">查找功能的工作原理是这样的。</target>
        </trans-unit>
        <trans-unit id="abb94027a4ec61a730cdc8afd975bf908ce25a48" translate="yes" xml:space="preserve">
          <source>The find method executes the callback function once for each element
  present in the array until it finds one where callback returns a true
  value. If such an element is found, find immediately returns the value
  of that element. Otherwise, find returns undefined. callback is
  invoked only for indexes of the array which have assigned values; it
  is not invoked for indexes which have been deleted or which have never
  been assigned values.</source>
          <target state="translated">find方法对数组中的每个元素执行一次回调函数,直到找到一个元素,并返回一个真值。如果找到了这样一个元素,find立即返回该元素的值。回调函数只对数组中已经赋值的索引调用;对于已经被删除或从未被赋值的索引不会被调用。</target>
        </trans-unit>
        <trans-unit id="5b756913fa20f5856e97197d8d0fda4fbf36c558" translate="yes" xml:space="preserve">
          <source>The function can also be easily modified to return true or false or even the object, string or whatever it is.</source>
          <target state="translated">该函数也可以很容易地修改为返回true或false,甚至是返回对象、字符串或其他什么东西。</target>
        </trans-unit>
        <trans-unit id="42cafc36913e43d0dc7e04557d3be49392edb70e" translate="yes" xml:space="preserve">
          <source>The nice thing about it is that the iteration is aborted once the element is found so unnecessary iteration cycles are spared.</source>
          <target state="translated">它的好处是,一旦发现元素,就会中止迭代,因此省去了不必要的迭代周期。</target>
        </trans-unit>
        <trans-unit id="c57bb5822f56318aa1093c9fd0bde5d8e450f3af" translate="yes" xml:space="preserve">
          <source>The top answers assume primitive types but if you want to find out if an array contains an &lt;strong&gt;object&lt;/strong&gt; with some trait, &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;Array.prototype.some()&lt;/a&gt; is a very elegant solution:</source>
          <target state="translated">最佳答案采用原始类型，但是如果要确定数组是否包含具有某些特征的&lt;strong&gt;对象&lt;/strong&gt; ，则&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;Array.prototype.some（）&lt;/a&gt;是一个非常优雅的解决方案：</target>
        </trans-unit>
        <trans-unit id="8745427232de5b90792b54c573542edc52081778" translate="yes" xml:space="preserve">
          <source>Then you can check whether the object with your value is already present or not</source>
          <target state="translated">然后,你可以检查带有你的值的对象是否已经存在。</target>
        </trans-unit>
        <trans-unit id="5e5170b7a4ad0e560f4e4f174f48e9a7abcbf1da" translate="yes" xml:space="preserve">
          <source>Then you can find the index of that object in the array and replace the object using below code.</source>
          <target state="translated">然后你可以在数组中找到该对象的索引,然后用下面的代码替换该对象。</target>
        </trans-unit>
        <trans-unit id="c9fd6f4ab61b50813778042886300ccd0e83bc2c" translate="yes" xml:space="preserve">
          <source>There are many ways to do this which are cleaner and better, but I just wanted to get your pattern and apply to that using &lt;code&gt;JSON.stringify&lt;/code&gt;, just simply do something like this in your case:</source>
          <target state="translated">有很多方法可以做到这一点越来越好，但我只想获取您的模式并使用 &lt;code&gt;JSON.stringify&lt;/code&gt; 应用于它，只需在您的情况下做类似的事情即可：</target>
        </trans-unit>
        <trans-unit id="cc16540816c436314b02d39733fbde781a2be92d" translate="yes" xml:space="preserve">
          <source>Thinking out of the box for a second, if you are making this call many many times, it is vastly more efficient to use &lt;strike&gt;an associative array&lt;/strike&gt; a Map to do lookups using a hash function.</source>
          <target state="translated">开箱即用地思考一下，如果您多次进行此调用，则使用&lt;strike&gt;关联数组&lt;/strike&gt; Map来使用哈希函数进行查找要高效得多。</target>
        </trans-unit>
        <trans-unit id="c90ebff9b8cace224a8ac140604be3b76e23637d" translate="yes" xml:space="preserve">
          <source>This is the only way I know to do it:</source>
          <target state="translated">这是我所知道的唯一方法。</target>
        </trans-unit>
        <trans-unit id="9fec1e19841ff4041bd895c4395ba1d97e9718e9" translate="yes" xml:space="preserve">
          <source>This is very closely related to Stack Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/143847/best-way-to-find-an-item-in-a-javascript-array&quot;&gt;Best way to find an item in a JavaScript Array?&lt;/a&gt;&lt;/em&gt; which addresses finding objects in an array using &lt;code&gt;indexOf&lt;/code&gt;.</source>
          <target state="translated">这与Stack Overflow问题密切相关。 &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/143847/best-way-to-find-an-item-in-a-javascript-array&quot;&gt;在JavaScript数组中查找项目的最佳方法？&lt;/a&gt;&lt;/em&gt; 它解决了使用 &lt;code&gt;indexOf&lt;/code&gt; 在数组中查找对象的问题。</target>
        </trans-unit>
        <trans-unit id="2b20c684ba339a0aa8fa186e3bd452c5a2f3f3d9" translate="yes" xml:space="preserve">
          <source>Three queries: at the beginning, in the middle &amp;amp; at the end of the array.</source>
          <target state="translated">三个查询：数组的开头，中间和结尾。</target>
        </trans-unit>
        <trans-unit id="5e26c8bf03eec1969b324604b86cbc899b237577" translate="yes" xml:space="preserve">
          <source>To know exactly what the &lt;code&gt;tilde&lt;/code&gt;&lt;code&gt;~&lt;/code&gt; do at this point, refer to this question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/12299665/what-does-a-tilde-do-when-it-precedes-an-expression&quot;&gt;What does a tilde do when it precedes an expression?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">要确切了解此时的 &lt;code&gt;tilde&lt;/code&gt; &lt;code&gt;~&lt;/code&gt; ，请参考以下问题&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/12299665/what-does-a-tilde-do-when-it-precedes-an-expression&quot;&gt;：波浪号在表达式之前会做什么？&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="48cd98f9836826608a5509761b5545dff093468c" translate="yes" xml:space="preserve">
          <source>Today 2020.01.07 I perform tests on MacOs HighSierra 10.13.6 on Chrome v78.0.0, Safari v13.0.4 and Firefox v71.0.0 for 15 chosen solutions. Conclusions</source>
          <target state="translated">今天2020.01.07我在MacOs HighSierra 10.13.6上对Chrome v78.0.0.0、Safari v13.0.4和Firefox v71.0.0.0等15种选择的解决方案进行测试。结论是</target>
        </trans-unit>
        <trans-unit id="49294c55abc80cbff078b924b2c630ec220213bf" translate="yes" xml:space="preserve">
          <source>Underscore.js: &lt;a href=&quot;http://underscorejs.org/#contains&quot;&gt;&lt;code&gt;_.contains(array, value)&lt;/code&gt;&lt;/a&gt; (also aliased as &lt;code&gt;_.include&lt;/code&gt; and &lt;code&gt;_.includes&lt;/code&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://underscorejs.org/#contains&quot;&gt; &lt;code&gt;_.contains(array, value)&lt;/code&gt; &lt;/a&gt; ： _.contains（array，value） （也别名为 &lt;code&gt;_.include&lt;/code&gt; 和 &lt;code&gt;_.includes&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f3d059b896de2ed3d87cd30f8be35c02ffb5fc69" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;indexOf&lt;/code&gt;, which uses &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison&quot;&gt;Strict Equality Comparison&lt;/a&gt;, &lt;code&gt;includes&lt;/code&gt; compares using &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero&quot;&gt;SameValueZero&lt;/a&gt; equality algorithm. That means that you can detect if an array includes a &lt;code&gt;NaN&lt;/code&gt;:</source>
          <target state="translated">与使用&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison&quot;&gt;严格相等比较的&lt;/a&gt; &lt;code&gt;indexOf&lt;/code&gt; 不同，它 &lt;code&gt;includes&lt;/code&gt; 使用&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero&quot;&gt;SameValueZero&lt;/a&gt;相等算法的比较。 这意味着您可以检测数组是否包含 &lt;code&gt;NaN&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="28771587e0631fb484f44d7bb44cf48c63b7758f" translate="yes" xml:space="preserve">
          <source>Updated the &lt;code&gt;contains&lt;/code&gt; function with a perf optimization. Thanks &lt;a href=&quot;https://stackoverflow.com/users/1397160/itinance&quot;&gt;itinance&lt;/a&gt; for pointing it out.</source>
          <target state="translated">通过性能优化更新了 &lt;code&gt;contains&lt;/code&gt; 函数。 感谢&lt;a href=&quot;https://stackoverflow.com/users/1397160/itinance&quot;&gt;itinance&lt;/a&gt;指出。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="f0228254bb4ff82bb180b380d25a7ac8da7e9b8c" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;binary search&lt;/a&gt; lookup in your &lt;code&gt;contains(a, obj)&lt;/code&gt;.</source>
          <target state="translated">在 &lt;code&gt;contains(a, obj)&lt;/code&gt; 使用&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;二进制搜索&lt;/a&gt;查找。</target>
        </trans-unit>
        <trans-unit id="7db1625c0ecb79fc25336042f3620583672ba039" translate="yes" xml:space="preserve">
          <source>Use lodash's &lt;a href=&quot;https://lodash.com/docs#some&quot;&gt;some&lt;/a&gt; function.</source>
          <target state="translated">使用lodash的&lt;a href=&quot;https://lodash.com/docs#some&quot;&gt;一些&lt;/a&gt;功能。</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="99d49a545e16e15fde40c6d01e8df0374271fbf3" translate="yes" xml:space="preserve">
          <source>We use this snippet (works with objects, arrays, strings):</source>
          <target state="translated">我们使用这个片段(可用于对象、数组、字符串)。</target>
        </trans-unit>
        <trans-unit id="e5a8bfa78b6cc841ae306aa109c2288f80d1bcad" translate="yes" xml:space="preserve">
          <source>What is the most concise and efficient way to find out if a JavaScript array contains a value?</source>
          <target state="translated">找出一个JavaScript数组是否包含一个值,最简洁有效的方法是什么?</target>
        </trans-unit>
        <trans-unit id="8703cf29cfa5ac185fce8c1dec2a01c5c3eb839d" translate="yes" xml:space="preserve">
          <source>When you know you just pushed an array with a value, using lastIndexOf remains probably the best solution, but if you have to travel through big arrays and the result could be everywhere, this could be a solid solution to make things faster.</source>
          <target state="translated">当你知道你只是推送一个数组的值时,使用lastIndexOf可能仍然是最好的解决方案,但如果你必须在大数组中穿行,而且结果可能到处都是,这可能是一个坚实的解决方案,可以让事情变得更快。</target>
        </trans-unit>
        <trans-unit id="f11390c7b08f5438453c92d12de28409182c4947" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;array.indexOf(x)!=-1&lt;/code&gt; is the most concise way to do this (and has been supported by non-Internet&amp;nbsp;Explorer browsers for over decade...), it is not O(1), but rather O(N), which is terrible. If your array will not be changing, you can convert your array to a hashtable, then do &lt;code&gt;table[x]!==undefined&lt;/code&gt; or &lt;code&gt;===undefined&lt;/code&gt;:</source>
          <target state="translated">虽然 &lt;code&gt;array.indexOf(x)!=-1&lt;/code&gt; 是执行此操作的最简洁方法（并且已由非Internet Explorer浏览器支持了十多年...），但它不是O（1），而是O（ N），这很糟糕。 如果您的数组不会改变，则可以将其转换为哈希表，然后执行 &lt;code&gt;table[x]!==undefined&lt;/code&gt; 或 &lt;code&gt;===undefined&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b01c71c2892eac27aa9d47b7b2460c3ca6b6002f" translate="yes" xml:space="preserve">
          <source>While the new method &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes&quot;&gt;includes&lt;/a&gt; is very nice, the support is basically zero for now.</source>
          <target state="translated">虽然新方法&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes&quot;&gt;包括&lt;/a&gt;非常好，但目前支持基本上为零。</target>
        </trans-unit>
        <trans-unit id="66a9a0ebce37ca21a36fa25294dd0f724d8af682" translate="yes" xml:space="preserve">
          <source>Why to use &lt;code&gt;JSON.stringify&lt;/code&gt;?</source>
          <target state="translated">为什么要使用 &lt;code&gt;JSON.stringify&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="710e9393126b52a4f0c439a6f12859ff0112353e" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt;&lt;code&gt;Array#indexOf&lt;/code&gt;&lt;/a&gt;, which is less direct, but doesn't require polyfills for outdated browsers.</source>
          <target state="translated">您还可以使用&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt; &lt;code&gt;Array#indexOf&lt;/code&gt; &lt;/a&gt; ，它不太直接，但对于过时的浏览器不需要polyfill。</target>
        </trans-unit>
        <trans-unit id="5d307aa6a64cce35bbe21c4e01d8d6639b51bbad" translate="yes" xml:space="preserve">
          <source>You can perform tests in your machine &lt;a href=&quot;https://jsperf.com/array-big-exist-element/1&quot;&gt;HERE&lt;/a&gt;</source>
          <target state="translated">您可以在机器上执行测试</target>
        </trans-unit>
        <trans-unit id="c452231ce645912ee34b17df9db70ba167c4c874" translate="yes" xml:space="preserve">
          <source>You can perform tests in your machine &lt;a href=&quot;https://jsperf.com/array-exist-element/1&quot;&gt;HERE&lt;/a&gt;</source>
          <target state="translated">您可以在机器上执行测试</target>
        </trans-unit>
        <trans-unit id="4cffa6d9408268dd04c67fe0e590fb87b7066b9c" translate="yes" xml:space="preserve">
          <source>You can use this in ECMAScript 5 and below by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find#Polyfill&quot;&gt;defining the function&lt;/a&gt;.</source>
          <target state="translated">您可以通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find#Polyfill&quot;&gt;定义功能&lt;/a&gt;在ECMAScript 5及更低版本中使用此功能 。</target>
        </trans-unit>
        <trans-unit id="8a8b0fcd60b778db319e070da9ab5bd99a70551d" translate="yes" xml:space="preserve">
          <source>hope this will help anyone.</source>
          <target state="translated">希望这能帮助到大家。</target>
        </trans-unit>
        <trans-unit id="f4b7e9b9241515996b32e009d8f7fee6dcf4fc80" translate="yes" xml:space="preserve">
          <source>if data is null then no admin, else it will return the existing object like below.</source>
          <target state="translated">如果data为null,则没有管理,否则将返回现有对象,如下图所示。</target>
        </trans-unit>
        <trans-unit id="12c167eda8182142022b2a92450f25c79b0bcb8b" translate="yes" xml:space="preserve">
          <source>jQuery: &lt;a href=&quot;http://api.jquery.com/jquery.inarray/&quot;&gt;&lt;code&gt;$.inArray(value, array, [fromIndex])&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">jQuery： &lt;a href=&quot;http://api.jquery.com/jquery.inarray/&quot;&gt; &lt;code&gt;$.inArray(value, array, [fromIndex])&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6101b8b106bb34aa75ee0814071b80c3bd5855d4" translate="yes" xml:space="preserve">
          <source>solutions based on &lt;code&gt;JSON&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and surprisingly &lt;code&gt;find&lt;/code&gt; (K,N,O) are slowest on all browsers</source>
          <target state="translated">在所有浏览器中，基于 &lt;code&gt;JSON&lt;/code&gt; ， &lt;code&gt;Set&lt;/code&gt; 和令人惊讶地 &lt;code&gt;find&lt;/code&gt; （K，N，O）的解决方案最慢</target>
        </trans-unit>
        <trans-unit id="a11a1beae753e81ce95402eff46f26a927ec2374" translate="yes" xml:space="preserve">
          <source>the es6 &lt;code&gt;includes&lt;/code&gt; (F) is fast only on chrome</source>
          <target state="translated">es6 &lt;code&gt;includes&lt;/code&gt; （F）仅在chrome上快速</target>
        </trans-unit>
        <trans-unit id="7ec7950d04195293692d83e333f6cef03db4144a" translate="yes" xml:space="preserve">
          <source>the solutions based on &lt;code&gt;for&lt;/code&gt; (C,D) and &lt;code&gt;indexOf&lt;/code&gt; (G,H) are quite-fast on all browsers on small and big arrays so probably they are best choice for efficient solution</source>
          <target state="translated">基于（C，D）和 &lt;code&gt;indexOf&lt;/code&gt; （G，H）的解决方案在大小数组上的所有浏览器上都非常快，因此它们可能是高效解决方案的最佳选择</target>
        </trans-unit>
        <trans-unit id="289945786f0df06cde96642e167bcc38037aa002" translate="yes" xml:space="preserve">
          <source>the solutions where index decrease during loop, (B) is slower probably because the way of &lt;a href=&quot;https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus&quot;&gt;CPU cache works&lt;/a&gt;.</source>
          <target state="translated">循环期间索引减少的解决方案（B）较慢，可能是因为&lt;a href=&quot;https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus&quot;&gt;CPU缓存的工作方式&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="798bc4d228938e571a6eb1d95ec4af0226cad052" translate="yes" xml:space="preserve">
          <source>you will get value like below</source>
          <target state="translated">你会得到如下值</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
