<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/237104">
    <body>
      <group id="237104">
        <trans-unit id="fa1fddf27a8bbd3e6a51595070fec2ffdda0cba8" translate="yes" xml:space="preserve">
          <source>$.inArray works fine for determining whether a &lt;em&gt;scalar&lt;/em&gt; value exists in an array of scalars...</source>
          <target state="translated">$ .inArrayは、 &lt;em&gt;スカラー&lt;/em&gt;の配列にスカラー値が存在するかどうかを判断するためにうまく機能します...</target>
        </trans-unit>
        <trans-unit id="e979338f8a2f2e59abc9249af3190ebc03ad8b13" translate="yes" xml:space="preserve">
          <source>(Unfortunately, while you can create an Array.prototype.contains to &quot;freeze&quot; an array and store a hashtable in this._cache in two lines, this would give wrong results if you chose to edit your array later. JavaScript has insufficient hooks to let you keep this state, unlike Python for example.)</source>
          <target state="translated">(残念ながら、Array.prototype.contains を作成して配列を「凍結」し、ハッシュテーブルを this._cache に 2 行で格納することができますが、後で配列を編集することを選択した場合、これは間違った結果を与えることになります。JavaScriptには、Pythonなどとは異なり、この状態を保持するためのフックが十分にありません。)</target>
        </trans-unit>
        <trans-unit id="666a1d7cd2502c4f03da17df37ee0d8e05fc9ce7" translate="yes" xml:space="preserve">
          <source>* As jamess pointed out in the comment, at the time of this answer, September 2018, &lt;code&gt;Array.prototype.some()&lt;/code&gt; is fully supported: &lt;a href=&quot;http://kangax.github.io/compat-table/es5/#test-Array_methods_Array.prototype.some_a_href=_https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some_title=_MDN_documentation_img_src=_../mdn.png_alt=_MDN_(Mozilla_Development_Network)_logo_width=_15_height=_13_/_/a_nbsp;&quot;&gt;caniuse.com support table&lt;/a&gt;</source>
          <target state="translated">* jamessがコメントで指摘したように、この回答の &lt;code&gt;Array.prototype.some()&lt;/code&gt; 2018年9月）では、 Array.prototype.some（）が完全にサポートされています&lt;a href=&quot;http://kangax.github.io/compat-table/es5/#test-Array_methods_Array.prototype.some_a_href=_https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some_title=_MDN_documentation_img_src=_../mdn.png_alt=_MDN_(Mozilla_Development_Network)_logo_width=_15_height=_13_/_/a_nbsp;&quot;&gt;。caniuse.comサポートテーブル&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ff01b541f233e095936ed95fd600d53d0d50e8cd" translate="yes" xml:space="preserve">
          <source>... but the question clearly asks for an efficient way to determine if an &lt;em&gt;object&lt;/em&gt; is contained in an array.</source>
          <target state="translated">...しかし、質問には、 &lt;em&gt;オブジェクト&lt;/em&gt;が配列に含まれているかどうかを判断する効率的な方法が明らかに求められ&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="82ba87f801a9d4855c22108ef67433ef0a8af8b2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;Array.prototype.some()&lt;/a&gt; was added to the ECMA-262 standard in the 5th edition</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;Array.prototype.some（）&lt;/a&gt;は、第5版でECMA-262標準に追加されました</target>
        </trans-unit>
        <trans-unit id="b1af03410872d22aa090478ca85044102ca7e787" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/indexOf&quot;&gt;&lt;code&gt;indexOf&lt;/code&gt;&lt;/a&gt; maybe, but it's a &quot;JavaScript extension to the ECMA-262 standard; as such it may not be present in other implementations of the standard.&quot;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/indexOf&quot;&gt; &lt;code&gt;indexOf&lt;/code&gt; &lt;/a&gt;かもしれませんが、これは「ECMA-262標準へのJavaScript拡張です。そのため、標準の他の実装には存在しない可能性があります」。</target>
        </trans-unit>
        <trans-unit id="bffcb9f337378974e8b34966a149dbbb68e52188" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array.indexOf&lt;/code&gt; and &lt;code&gt;Array.includes&lt;/code&gt; (as well as most of the answers here) only compare by reference and not by value.</source>
          <target state="translated">&lt;code&gt;Array.indexOf&lt;/code&gt; と &lt;code&gt;Array.includes&lt;/code&gt; （およびここでのほとんどの回答）は、値ではなく参照でのみ比較します。</target>
        </trans-unit>
        <trans-unit id="0c67478f11e2e78d248d12730af40590e49d8d53" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Requirements:&lt;/em&gt; Recommend most concise and efficient way to find out if a JavaScript array contains an object.</source>
          <target state="translated">&lt;em&gt;要件：&lt;/em&gt; JavaScript配列にオブジェクトが含まれているかどうかを確認する最も簡潔で効率的な方法をお勧めします。</target>
        </trans-unit>
        <trans-unit id="3328e402eaab9fa9ffa2904507ac1e15deedaa9a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A hopefully faster bidirectional &lt;code&gt;indexOf&lt;/code&gt; / &lt;code&gt;lastIndexOf&lt;/code&gt; alternative&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;うまくいけば、より高速な双方向 &lt;code&gt;indexOf&lt;/code&gt; / &lt;code&gt;lastIndexOf&lt;/code&gt; 代替&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8d78a67732f4c0a40bd987aec69c5f5c06ced172" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Accepted Answer:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;受け入れられた答え：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dca58c8f007a19a8c485db3191ee67d50e382e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array big - 1.000.000 elements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;大きな配列-1.000.000要素&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bcb9db629c9a0558ab47a317e2d8b485d0969128" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Array small - 10 elements&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;小配列-10要素&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2550bdae36c113e4a47d24b4ea74558c357b9dd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Bidirectional indexOf/lastIndexOf&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;双方向のindexOf / lastIndexOf&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dca676a8af0cab5dcd796ab1ed5917f8c1ae0c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;My recommendation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;私の推薦：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="da2dcdbcfc4b0fe47450de9fb9a98320068c3e91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update from 2019: This answer is from 2008 (11 years old!) and is not relevant for modern JS usage. The promised performance improvement was based on a benchmark done in browsers of that time. It might not be relevant to modern JS execution contexts. If you need an easy solution, look for other answers. If you need the best performance, benchmark for yourself in the relevant execution environments.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2019からの更新：この回答は2008（11歳！）からのものであり、最新のJSの使用には関係ありません。&lt;/strong&gt; &lt;strong&gt;約束されたパフォーマンスの改善は、当時のブラウザで行われたベンチマークに基づいていました。&lt;/strong&gt; &lt;strong&gt;最近のJS実行コンテキストには関係ないかもしれません。&lt;/strong&gt; &lt;strong&gt;簡単な解決策が必要な場合は、他の答えを探してください。&lt;/strong&gt; &lt;strong&gt;最高のパフォーマンスが必要な場合は、関連する実行環境でベンチマークを行ってください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3dd7f728110b6212e76f1f99084dfc27e75be15a" translate="yes" xml:space="preserve">
          <source>A performant way has already been found, looking at the top answers. From those I chose the &lt;code&gt;contains&lt;/code&gt; function posted by @Damir Zekic which should be the fastest one. But it also states that the benchmarks are from 2008 and so are outdated.</source>
          <target state="translated">上位の回答を見て、パフォーマンスの高い方法がすでに見つかりました。 それらの中から、@ Damir Zekicが投稿した &lt;code&gt;contains&lt;/code&gt; 関数を選択しました。これは最速の関数です。 しかし、それはまた、ベンチマークが2008年からのものであり、時代遅れであることも述べています。</target>
        </trans-unit>
        <trans-unit id="3fea7bc0c9c385deaf9e732da8ef43205ce4079c" translate="yes" xml:space="preserve">
          <source>AFAICS &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/k4h76zbx%5C%28VS.85%5C%29.aspx&quot;&gt;Microsoft does &lt;em&gt;not&lt;/em&gt; offer some kind of alternative&lt;/a&gt; to this, but you can add similar functionality to arrays in Internet Explorer (and other browsers that don't support &lt;code&gt;indexOf&lt;/code&gt;) if you want to, as a &lt;a href=&quot;http://google.com/search?q=indexof%20internet%20explorer&quot;&gt;quick Google search reveals&lt;/a&gt; (for example, &lt;a href=&quot;http://soledadpenades.com/2007/05/17/arrayindexof-in-internet-explorer/&quot;&gt;this one&lt;/a&gt;).</source>
          <target state="translated">AFAICS &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/k4h76zbx%5C%28VS.85%5C%29.aspx&quot;&gt;Microsoftは&lt;/a&gt;これに対する何らかの代替手段を提供していませ&lt;em&gt;ん&lt;/em&gt;が、必要に応じて、 &lt;a href=&quot;http://google.com/search?q=indexof%20internet%20explorer&quot;&gt;Google&lt;/a&gt;のクイック検索で明らかになるように （たとえば、 &lt;a href=&quot;http://soledadpenades.com/2007/05/17/arrayindexof-in-internet-explorer/&quot;&gt;これの&lt;/a&gt;ように、Internet Explorer（および &lt;code&gt;indexOf&lt;/code&gt; をサポートしない他のブラウザー）の配列に同様の機能を追加できます（ これは1つ ）。</target>
        </trans-unit>
        <trans-unit id="2e1a21db865a12dc215cd0757653828363ce0b37" translate="yes" xml:space="preserve">
          <source>Also see &lt;a href=&quot;http://github.com/sstephenson/prototype/blob/f405b2c510e09b55d08c926a9e1a5c2e2d0a1834/src/lang/array.js#L364-365&quot;&gt;here&lt;/a&gt; for how they hook it up.</source>
          <target state="translated">それらがどのように接続するかについては、 &lt;a href=&quot;http://github.com/sstephenson/prototype/blob/f405b2c510e09b55d08c926a9e1a5c2e2d0a1834/src/lang/array.js#L364-365&quot;&gt;こちら&lt;/a&gt;も参照してください。</target>
        </trans-unit>
        <trans-unit id="ef2cd47054f7c2e7287dcdcf3389cdb38c008c53" translate="yes" xml:space="preserve">
          <source>Also unlike &lt;code&gt;indexOf&lt;/code&gt;, &lt;code&gt;includes&lt;/code&gt; does not skip missing indices:</source>
          <target state="translated">また、 &lt;code&gt;indexOf&lt;/code&gt; と &lt;code&gt;includes&lt;/code&gt; 異なり、 includesは欠落しているインデックスをスキップしません。</target>
        </trans-unit>
        <trans-unit id="fe1263bbb735fe48bd1e929be3a7542be2dfbbe3" translate="yes" xml:space="preserve">
          <source>Also, it fits nicely in an &lt;code&gt;if&lt;/code&gt; statement since it returns a boolean:</source>
          <target state="translated">また、ブール値を返すため、 &lt;code&gt;if&lt;/code&gt; ステートメントにうまく適合します。</target>
        </trans-unit>
        <trans-unit id="fd49cf48d65e8591372b9ab2e58ef2862979ec3c" translate="yes" xml:space="preserve">
          <source>And here is the &lt;code&gt;while&lt;/code&gt; variant:</source>
          <target state="translated">そして、 &lt;code&gt;while&lt;/code&gt; バリアントは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="e9e912c3f4aaddf36a551e9a19f1b31785ce824c" translate="yes" xml:space="preserve">
          <source>And now you can simply use the following:</source>
          <target state="translated">そして、これで簡単に以下のようになりました。</target>
        </trans-unit>
        <trans-unit id="28746dfd1b61ed6d0a8ada4c2b2b65c189a03dc0" translate="yes" xml:space="preserve">
          <source>Array.prototype.&lt;strong&gt;find&lt;/strong&gt; -&amp;gt; (takes callback, returns first &lt;strong&gt;value/object&lt;/strong&gt; that returns true in CB).</source>
          <target state="translated">Array.prototype。 &lt;strong&gt;find&lt;/strong&gt; -&amp;gt;（コールバックを受け取り、CBでtrueを返す最初の&lt;strong&gt;値/オブジェクト&lt;/strong&gt;を返します）。</target>
        </trans-unit>
        <trans-unit id="2a2ae4f8c0c85f5dda2d7c7b158b42785c2c9b38" translate="yes" xml:space="preserve">
          <source>Array.prototype.&lt;strong&gt;findIndex&lt;/strong&gt; -&amp;gt; (takes callback, returns &lt;strong&gt;index&lt;/strong&gt; of first value/object that returns true in CB).</source>
          <target state="translated">Array.prototype。 &lt;strong&gt;findIndex&lt;/strong&gt; -&amp;gt;（コールバックを受け取り、CBでtrueを返す最初の値/オブジェクトの&lt;strong&gt;インデックス&lt;/strong&gt;を返します）。</target>
        </trans-unit>
        <trans-unit id="13774ea8043b54624cbe8f2322d27cbd49c3f695" translate="yes" xml:space="preserve">
          <source>Array.prototype.&lt;strong&gt;includes&lt;/strong&gt; -&amp;gt; (returns &lt;strong&gt;true&lt;/strong&gt; or &lt;strong&gt;false&lt;/strong&gt;)</source>
          <target state="translated">Array.prototype。 &lt;strong&gt;含む&lt;/strong&gt; -&amp;gt;（ &lt;strong&gt;true&lt;/strong&gt;または&lt;strong&gt;falseを&lt;/strong&gt;返し&lt;strong&gt;ます&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="159144824cccf4c9146f260d2d0aec916594f068" translate="yes" xml:space="preserve">
          <source>Array.prototype.&lt;strong&gt;indexOf&lt;/strong&gt; -&amp;gt; (returns &lt;strong&gt;index or -1&lt;/strong&gt;) is generally used for finding index of element in array.
This can also be used for searching object but only works if you are passing reference to same object.</source>
          <target state="translated">Array.prototype。 &lt;strong&gt;indexOf&lt;/strong&gt; -&amp;gt;（ &lt;strong&gt;indexまたは-1を&lt;/strong&gt;返す）は通常、配列内の要素のインデックスを見つけるために使用されます。 これはオブジェクトの検索にも使用できますが、同じオブジェクトへの参照を渡す場合にのみ機能します。</target>
        </trans-unit>
        <trans-unit id="ee6d18b2067d77f05479b33415bea0665938366f" translate="yes" xml:space="preserve">
          <source>As custom Array method (pre ES2016)</source>
          <target state="translated">カスタム配列法として(ES2016以前</target>
        </trans-unit>
        <trans-unit id="820471fc96bdf044cac7a71fa7e5925072bd7715" translate="yes" xml:space="preserve">
          <source>As others have said, the iteration through the array is probably the best way, but it &lt;a href=&quot;http://blogs.oracle.com/greimer/entry/best_way_to_code_a&quot;&gt;has been proven&lt;/a&gt; that a decreasing &lt;code&gt;while&lt;/code&gt; loop is the fastest way to iterate in JavaScript. So you may want to rewrite your code as follows:</source>
          <target state="translated">他の人が言ったように、配列の反復はおそらく最良の方法ですが、 &lt;code&gt;while&lt;/code&gt; ループを減らすことがJavaScriptで反復する最も速い方法で&lt;a href=&quot;http://blogs.oracle.com/greimer/entry/best_way_to_code_a&quot;&gt;ある&lt;/a&gt;ことが証明されています。 したがって、次のようにコードを書き直すことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="a183a9029e6053aa206bd8f78fb63e1bcdddaac1" translate="yes" xml:space="preserve">
          <source>As test I created an array with 100k entries.</source>
          <target state="translated">テストとして、私は100kのエントリを持つ配列を作成しました。</target>
        </trans-unit>
        <trans-unit id="9d7e7c087b4bd3ac73364918b2ee9cb9c1799676" translate="yes" xml:space="preserve">
          <source>Below are three ways of checking whether there is a &lt;code&gt;3&lt;/code&gt; in there. All of them return either &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">以下に3があるかどうかを確認する3つの方法を示します。 それらはすべて &lt;code&gt;true&lt;/code&gt; または &lt;code&gt;false&lt;/code&gt; を返します。</target>
        </trans-unit>
        <trans-unit id="4d963cfab70d8c850b1221649bcc7b4d96d558d3" translate="yes" xml:space="preserve">
          <source>Bonus</source>
          <target state="translated">Bonus</target>
        </trans-unit>
        <trans-unit id="00d426145cd70803b163fe1889541e0436672a9b" translate="yes" xml:space="preserve">
          <source>Currently it's still a draft but can be &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Polyfill&quot;&gt;polyfilled&lt;/a&gt; to make it work on all browsers.</source>
          <target state="translated">現在はまだドラフトですが、すべてのブラウザで機能するように&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Polyfill&quot;&gt;ポリフィル&lt;/a&gt;することができます。</target>
        </trans-unit>
        <trans-unit id="e52c854d5631eec7468ba4727b4c77eb745f2965" translate="yes" xml:space="preserve">
          <source>Demo</source>
          <target state="translated">Demo</target>
        </trans-unit>
        <trans-unit id="83d36288b5c8873730d74ec2bee7f0a6e4883b2f" translate="yes" xml:space="preserve">
          <source>Demo:</source>
          <target state="translated">Demo:</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="b75e71a9c0a73c636523fc12a59e51c67115ee2c" translate="yes" xml:space="preserve">
          <source>Dojo Toolkit: &lt;a href=&quot;http://dojotoolkit.org/reference-guide/dojo/indexOf.html&quot;&gt;&lt;code&gt;dojo.indexOf(array, value, [fromIndex, findLast])&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Dojoツールキット： &lt;a href=&quot;http://dojotoolkit.org/reference-guide/dojo/indexOf.html&quot;&gt; &lt;code&gt;dojo.indexOf(array, value, [fromIndex, findLast])&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7eb5e66ccf7ff4b0c3e12f9b838e3c060dbe7ab" translate="yes" xml:space="preserve">
          <source>ECMAScript 6 has an elegant proposal on find.</source>
          <target state="translated">ECMAScript 6は、findにエレガントな提案をしています。</target>
        </trans-unit>
        <trans-unit id="b288b702748358f62fc1dabe0b0e9ae73618544c" translate="yes" xml:space="preserve">
          <source>ECMAScript 7 introduces &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes&quot;&gt;&lt;code&gt;Array.prototype.includes&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ECMAScript 7は&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes&quot;&gt; &lt;code&gt;Array.prototype.includes&lt;/code&gt; を&lt;/a&gt;導入しています 。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="ac15517e284529ed9d77b5e4ab5790a55e8af0bf" translate="yes" xml:space="preserve">
          <source>Ext: &lt;a href=&quot;http://docs.sencha.com/extjs/4.0.0/#/api/Ext.Array-method-contains&quot;&gt;&lt;code&gt;Ext.Array.contains(array, value)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Ext： &lt;a href=&quot;http://docs.sencha.com/extjs/4.0.0/#/api/Ext.Array-method-contains&quot;&gt; &lt;code&gt;Ext.Array.contains(array, value)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eb68107e5febdf35eea1d01bad4984345866f1fd" translate="yes" xml:space="preserve">
          <source>Extending the JavaScript &lt;code&gt;Array&lt;/code&gt; object is a really bad idea because you introduce new properties (your custom methods) into &lt;code&gt;for-in&lt;/code&gt; loops which can break existing scripts. A few years ago the authors of the &lt;a href=&quot;http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework&quot;&gt;Prototype&lt;/a&gt; library had to re-engineer their library implementation to remove just this kind of thing.</source>
          <target state="translated">JavaScriptの &lt;code&gt;Array&lt;/code&gt; オブジェクトを拡張することは、既存のスクリプトを破壊する可能性のある &lt;code&gt;for-in&lt;/code&gt; ループに新しいプロパティ（カスタムメソッド）を導入するため、非常に悪い考えです。 数年前、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Prototype_JavaScript_Framework&quot;&gt;Prototype&lt;/a&gt;ライブラリの作成者は、この種のものだけを削除するために、ライブラリ実装を再設計する必要がありました。</target>
        </trans-unit>
        <trans-unit id="f5ec22899f4427f21921edbbd5e8fb8dcb009ec9" translate="yes" xml:space="preserve">
          <source>Here is a complex example doing three checks per iteration, but this is only possible with a longer calculation which causes the slowdown of the code.</source>
          <target state="translated">ここでは、反復ごとに3つのチェックを行う複雑な例を示していますが、これは計算が長くなってコードの速度が低下する場合にのみ可能です。</target>
        </trans-unit>
        <trans-unit id="32a46c0daf7a31dffc5357242054af1019b73d24" translate="yes" xml:space="preserve">
          <source>Here is the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt;MDN documentation&lt;/a&gt; on that.</source>
          <target state="translated">これに関する&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt;MDNのドキュメント&lt;/a&gt;は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="f73591287f9a256c22a935074fa54f1b4edc5742" translate="yes" xml:space="preserve">
          <source>Here's a &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&quot;&gt;JavaScript 1.6 compatible&lt;/a&gt; implementation of &lt;code&gt;Array.indexOf&lt;/code&gt;:</source>
          <target state="translated">以下は、 &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&quot;&gt;JavaScript 1.6互換&lt;/a&gt;の &lt;code&gt;Array.indexOf&lt;/code&gt; の実装です。</target>
        </trans-unit>
        <trans-unit id="73ddb6b3efa49acc39d3b80f97da9706b3ea2e7a" translate="yes" xml:space="preserve">
          <source>Here's how &lt;a href=&quot;http://github.com/sstephenson/prototype/blob/f405b2c510e09b55d08c926a9e1a5c2e2d0a1834/src/lang/array.js#L286-302&quot;&gt;Prototype does it&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://github.com/sstephenson/prototype/blob/f405b2c510e09b55d08c926a9e1a5c2e2d0a1834/src/lang/array.js#L286-302&quot;&gt;Prototypeがこれを行う&lt;/a&gt;方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="20ae8e0c00b1fa1a1071d47bdb057532c38b84b1" translate="yes" xml:space="preserve">
          <source>How do I check if an array includes a value in JavaScript</source>
          <target state="translated">JavaScriptで配列に値が含まれているかどうかを確認する方法</target>
        </trans-unit>
        <trans-unit id="2494e96cd66323400e7154384c7f185dc839ebd1" translate="yes" xml:space="preserve">
          <source>How is this possible?</source>
          <target state="translated">これはどうやって可能なのでしょうか?</target>
        </trans-unit>
        <trans-unit id="c99fe5750c3181f3859af356a418988a87310708" translate="yes" xml:space="preserve">
          <source>I also prefer &lt;code&gt;while&lt;/code&gt; over &lt;code&gt;for&lt;/code&gt;, but for not a specific reason I ended writing the function with a for loop. It could be also done with a &lt;code&gt;while --&lt;/code&gt;.</source>
          <target state="translated">私は &lt;code&gt;for&lt;/code&gt; &lt;code&gt;while&lt;/code&gt; している 間も好みますが、特定の理由ではなく、forループを使用して関数の記述を終了しました。 それは &lt;code&gt;while --&lt;/code&gt; でも可能でした- 。</target>
        </trans-unit>
        <trans-unit id="4e7f926e0198c33afed235e77fff45b62d69efaf" translate="yes" xml:space="preserve">
          <source>I also run test for big array when searched element was on position 66% of array length, and solutions based on &lt;code&gt;for&lt;/code&gt; (C,D,E) gives similar results (~630 ops/sec - but the E on safari and firefox was 10-20% slower than C and D)</source>
          <target state="translated">また、検索された要素が配列の長さの66％の位置にあるときに大きな配列のテストを実行し &lt;code&gt;for&lt;/code&gt; （C、D、E）に基づくソリューションでは同様の結果が得られます（〜630 ops /秒-サファリとファイアフォックスのEは10でした） CおよびDより-20％遅い）</target>
        </trans-unit>
        <trans-unit id="84464b4ca7dfa8c6d4801774a3135af233b2ebac" translate="yes" xml:space="preserve">
          <source>I hope you also find this interesting and test the performance.</source>
          <target state="translated">皆さんにも興味を持っていただき、性能を試していただければと思います。</target>
        </trans-unit>
        <trans-unit id="9dcc9d0305378204bf3ede8b2618fed0eb90649c" translate="yes" xml:space="preserve">
          <source>I perform 2 tests cases: for array with 10 elements, and array with 1 milion elements. In both cases we put searched element in the array middle.</source>
          <target state="translated">10個の要素を持つ配列と100万個の要素を持つ配列の2つのテストを行いました。どちらの場合も,検索した要素を配列の中央に配置しています.</target>
        </trans-unit>
        <trans-unit id="0b8a1c5b70eefb3d48daa75b54a499297c28805a" translate="yes" xml:space="preserve">
          <source>I think that the simple calculation to get the reflected index in an array is so simple that it's two times faster than doing an actual loop iteration.</source>
          <target state="translated">配列に反映されたインデックスを取得する単純な計算は、実際にループの繰り返しをするよりも2倍くらい速いと思います。</target>
        </trans-unit>
        <trans-unit id="c9fe622e69b560ae352d96f8ff0fcf61e9c7bed2" translate="yes" xml:space="preserve">
          <source>I use the following:</source>
          <target state="translated">私は以下のように使っています。</target>
        </trans-unit>
        <trans-unit id="28e4ffc52f1e8141f4b7d43d5c75f149bcd5dfc8" translate="yes" xml:space="preserve">
          <source>I was curious if the iteration was much slower if I check both sides of the array while doing it. Apparently no, and so this function is around two times faster than the top voted ones. Obviously it's also faster than the native one. This in a real world environment, where you never know if the value you are searching is at the beginning or at the end of the array.</source>
          <target state="translated">気になっていたのは、配列の両側をチェックしながらやっていると、繰り返しの処理がかなり遅くなること。どうやらそうではなくて、だからこの関数は上位に投票されたものよりも2倍くらい速くなっています。明らかにネイティブのものよりも速いです。これは、検索している値が配列の先頭にあるのか末尾にあるのかわからない現実の環境での話です。</target>
        </trans-unit>
        <trans-unit id="b9f22fd83bdf3e491fb6e80ec269fbb800d6ee83" translate="yes" xml:space="preserve">
          <source>IE6+ solution:</source>
          <target state="translated">IE6+のソリューション。</target>
        </trans-unit>
        <trans-unit id="e2c5590817181cc7e7c8909b5f1ca3dd5150eaf6" translate="yes" xml:space="preserve">
          <source>If you are checking repeatedly for existence of an object in an array you should maybe look into</source>
          <target state="translated">配列の中にオブジェクトが存在するかどうかを繰り返しチェックしているのであれば</target>
        </trans-unit>
        <trans-unit id="625b41de336989cef496844e1118db8209392193" translate="yes" xml:space="preserve">
          <source>If you are using JavaScript 1.6 or later (Firefox 1.5 or later) you can use &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&quot;&gt;Array.indexOf&lt;/a&gt;.  Otherwise, I think you are going to end up with something similar to your original code.</source>
          <target state="translated">JavaScript 1.6以降（Firefox 1.5以降）を使用している場合は、 &lt;a href=&quot;https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf&quot;&gt;Array.indexOf&lt;/a&gt;を使用できます。 そうでなければ、あなたはあなたの元のコードに似たものになってしまうと思います。</target>
        </trans-unit>
        <trans-unit id="3ee6e017af8f89d3d12e3d78389bb4add3cf2317" translate="yes" xml:space="preserve">
          <source>If you don't need to worry about compatibility with other JavaScript running on your page, go for it, otherwise, I'd recommend the more awkward, but safer free-standing function solution.</source>
          <target state="translated">もしあなたのページで実行されている他の JavaScript との互換性を心配する必要がないのであれば、そうすることをお勧めしますが、そうでなければ、より厄介ではありますが、より安全な自立型の機能ソリューションをお勧めします。</target>
        </trans-unit>
        <trans-unit id="2daaa05340a4a5fbf45632f41108223c525f42cf" translate="yes" xml:space="preserve">
          <source>If you're having array of objects like below,</source>
          <target state="translated">以下のようなオブジェクトの配列を持っている場合。</target>
        </trans-unit>
        <trans-unit id="d2da7e5fc690c05c7dd880dab7d51eecaf495e88" translate="yes" xml:space="preserve">
          <source>In order to handle both scalars and objects, you could do this:</source>
          <target state="translated">スカラーとオブジェクトの両方を扱うためには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="fbb0ba0cb144ea9ec30e8a02f59189cac1e0fd83" translate="yes" xml:space="preserve">
          <source>Is there a better and more concise way to accomplish this?</source>
          <target state="translated">もっと簡潔で良い方法はないのでしょうか?</target>
        </trans-unit>
        <trans-unit id="96524039763060c62193d4b3f2e8e0aeb1a9c048" translate="yes" xml:space="preserve">
          <source>It also accepts an optional second argument &lt;code&gt;fromIndex&lt;/code&gt;:</source>
          <target state="translated">また、オプションの2番目の引数 &lt;code&gt;fromIndex&lt;/code&gt; も受け入れます。</target>
        </trans-unit>
        <trans-unit id="7957cdd685e55b0659e0f881b1501d7538cec20a" translate="yes" xml:space="preserve">
          <source>It can be used like this:</source>
          <target state="translated">こんな感じで使えます。</target>
        </trans-unit>
        <trans-unit id="dec9bd251fe067dfc0548c5c6f8d543981f5dc35" translate="yes" xml:space="preserve">
          <source>It's concise, accurate and has great cross platform support.</source>
          <target state="translated">簡潔で正確で、クロスプラットフォームにも対応しています。</target>
        </trans-unit>
        <trans-unit id="d7b1386bed9cbbf81dba8983bdb2c019db7c6ebc" translate="yes" xml:space="preserve">
          <source>It's long time that I was thinking of way to replace the slow indexOf/lastIndexOf functions.</source>
          <target state="translated">遅いindexOflastIndexOf関数を置き換える方法を考えていたのは久しぶりです。</target>
        </trans-unit>
        <trans-unit id="25b2e1835d0c0287f224776b63a40c7d557a0824" translate="yes" xml:space="preserve">
          <source>Keeping the array sorted at all times by doing &lt;a href=&quot;http://en.wikipedia.org/wiki/Insertion_sort&quot;&gt;insertion sort&lt;/a&gt; in your array (put new objects in on the right place)</source>
          <target state="translated">配列で&lt;a href=&quot;http://en.wikipedia.org/wiki/Insertion_sort&quot;&gt;挿入ソート&lt;/a&gt;を実行して、常に配列をソートしたままにします（新しいオブジェクトを適切な場所に配置します）</target>
        </trans-unit>
        <trans-unit id="fc09e2e02a3b9b59afbbd4c12fd5ae7cc7d86edf" translate="yes" xml:space="preserve">
          <source>Let's say we have array of Objects arrObj and we want to search obj in it.</source>
          <target state="translated">オブジェクト arrObj の配列を持っていて、その中から obj を検索したいとします。</target>
        </trans-unit>
        <trans-unit id="5dcdd6376733383c88fb8505f672ce2c465e3ee7" translate="yes" xml:space="preserve">
          <source>Let's say you've defined an array like so:</source>
          <target state="translated">このような配列を定義したとしましょう。</target>
        </trans-unit>
        <trans-unit id="1133d8a8268183b654cc15e962adec1905def045" translate="yes" xml:space="preserve">
          <source>Lodash: &lt;a href=&quot;https://lodash.com/docs#includes&quot;&gt;&lt;code&gt;_.includes(array, value, [from])&lt;/code&gt;&lt;/a&gt; (is &lt;code&gt;_.contains&lt;/code&gt; prior 4.0.0)</source>
          <target state="translated">Lodash：_. &lt;a href=&quot;https://lodash.com/docs#includes&quot;&gt; &lt;code&gt;_.includes(array, value, [from])&lt;/code&gt; &lt;/a&gt; （ &lt;code&gt;_.contains&lt;/code&gt; before 4.0.0）</target>
        </trans-unit>
        <trans-unit id="15ad60cdf54e6bc76cdd4462ba0c40f97badfa2d" translate="yes" xml:space="preserve">
          <source>MS Ajax: &lt;a href=&quot;http://www.asp.net/ajaxlibrary/Reference.Array-indexOf-Function.ashx&quot;&gt;&lt;code&gt;array.indexOf(value)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">MS Ajax： &lt;a href=&quot;http://www.asp.net/ajaxlibrary/Reference.Array-indexOf-Function.ashx&quot;&gt; &lt;code&gt;array.indexOf(value)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="84984b49ae654a77558f7a39ed56f68055a47884" translate="yes" xml:space="preserve">
          <source>Make updating objects as remove+sorted insert operation and</source>
          <target state="translated">オブジェクトの更新をremove+ソートされた挿入操作と</target>
        </trans-unit>
        <trans-unit id="13f96a3206465a40fdd57b0c45a1c47a96492ce3" translate="yes" xml:space="preserve">
          <source>Many frameworks also offer similar methods:</source>
          <target state="translated">多くのフレームワークも同様の方法を提供しています。</target>
        </trans-unit>
        <trans-unit id="34b498db5861179f4d01de30ad382c1c99d173a6" translate="yes" xml:space="preserve">
          <source>MochiKit: &lt;a href=&quot;http://mochi.github.io/mochikit/doc/html/MochiKit/Base.html#fn-findvalue&quot;&gt;&lt;code&gt;findValue(array, value)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">MochiKit： &lt;a href=&quot;http://mochi.github.io/mochikit/doc/html/MochiKit/Base.html#fn-findvalue&quot;&gt; &lt;code&gt;findValue(array, value)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="11bd5cb3c081453f6118ff4b291498d2d7511e0d" translate="yes" xml:space="preserve">
          <source>Modern browsers have &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Browser_compatibility&quot;&gt;&lt;code&gt;Array#includes&lt;/code&gt;&lt;/a&gt;, which does &lt;em&gt;exactly&lt;/em&gt; that and &lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-Array.prototype.includes&quot;&gt;is widely supported&lt;/a&gt; by everyone except IE:</source>
          <target state="translated">最新のブラウザには&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes#Browser_compatibility&quot;&gt; &lt;code&gt;Array#includes&lt;/code&gt; があり&lt;/a&gt; 、これは&lt;em&gt;まさに&lt;/em&gt;それを行い、IEを除くすべての人によって&lt;a href=&quot;https://kangax.github.io/compat-table/es2016plus/#test-Array.prototype.includes&quot;&gt;広くサポート&lt;/a&gt;されています。</target>
        </trans-unit>
        <trans-unit id="ac5f3f86aeba412f6c7300de9ded324b814b2be2" translate="yes" xml:space="preserve">
          <source>MooTools: &lt;a href=&quot;https://mootools.net/core/docs/1.6.0/Types/Array#Array:indexOf&quot;&gt;&lt;code&gt;array.indexOf(value)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">MooTools： &lt;a href=&quot;https://mootools.net/core/docs/1.6.0/Types/Array#Array:indexOf&quot;&gt; &lt;code&gt;array.indexOf(value)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1f9f5580daea7b8f13b0defea3a5dc9f8652aa84" translate="yes" xml:space="preserve">
          <source>Native Array method (since ES2016) (&lt;a href=&quot;https://caniuse.com/#feat=array-includes&quot;&gt;compatibility table&lt;/a&gt;)</source>
          <target state="translated">ネイティブ配列メソッド（ES2016以降）（ &lt;a href=&quot;https://caniuse.com/#feat=array-includes&quot;&gt;互換性テーブル&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="697f83c56e4af8a3d870ae1c1d3850dac14005f4" translate="yes" xml:space="preserve">
          <source>Non-optimized ES6 one-liner:</source>
          <target state="translated">最適化されていないES6のワンライナー。</target>
        </trans-unit>
        <trans-unit id="cf369e9f80a3aee5118b14ec07f5711bfcb6fc0f" translate="yes" xml:space="preserve">
          <source>Note:
Comparing objects by value will work better if the keys are in the same order, so to be safe you might sort the keys first with a package like this one: &lt;a href=&quot;https://www.npmjs.com/package/sort-keys&quot;&gt;https://www.npmjs.com/package/sort-keys&lt;/a&gt;</source>
          <target state="translated">注：キーが同じ順序である場合、値によるオブジェクトの比較はより適切に機能するため、安全のために、次のようなパッケージで最初にキーをソートすることができます： &lt;a href=&quot;https://www.npmjs.com/package/sort-keys&quot;&gt;https&lt;/a&gt; : //www.npmjs.com/package/sort-keys</target>
        </trans-unit>
        <trans-unit id="11415b96e3d11a9e4bc779554b10a502ba013727" translate="yes" xml:space="preserve">
          <source>Note: As you can see I slightly modified the &lt;code&gt;contains&lt;/code&gt; function to reflect the indexOf &amp;amp; lastIndexOf output (so basically &lt;code&gt;true&lt;/code&gt; with the &lt;code&gt;index&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; with &lt;code&gt;-1&lt;/code&gt;). That shouldn't harm it.</source>
          <target state="translated">注：ご覧のとおり、indexOfおよびlastIndexOfの出力を反映するように &lt;code&gt;contains&lt;/code&gt; 関数を少し変更しました（したがって、基本的には &lt;code&gt;index&lt;/code&gt; では &lt;code&gt;true&lt;/code&gt; になり、 &lt;code&gt;-1&lt;/code&gt; では &lt;code&gt;false&lt;/code&gt; になります ）。 それはそれを害するべきではありません。</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="f625fa0058ddfcc2adcd5b53ac3bb76651142210" translate="yes" xml:space="preserve">
          <source>Notice that some frameworks implement this as a function, while others add the function to the array prototype.</source>
          <target state="translated">これを関数として実装しているフレームワークもあれば、配列のプロトタイプに関数を追加しているフレームワークもあることに注目してください。</target>
        </trans-unit>
        <trans-unit id="40a0fca5b4ff80b27dceac44499b495cb11b44ad" translate="yes" xml:space="preserve">
          <source>OK, you can just &lt;strong&gt;optimise your&lt;/strong&gt; code to get the result!</source>
          <target state="translated">OK、コードを&lt;strong&gt;最適化して&lt;/strong&gt;結果を得ることができ&lt;strong&gt;ます&lt;/strong&gt; ！</target>
        </trans-unit>
        <trans-unit id="c6004473778dc819accd15d1a64aa218f11402d1" translate="yes" xml:space="preserve">
          <source>Of course, you may as well extend Array prototype:</source>
          <target state="translated">もちろん、Arrayのプロトタイプを拡張しても構いません。</target>
        </trans-unit>
        <trans-unit id="f479744c024205bcadceb234c72adf9ccab6115d" translate="yes" xml:space="preserve">
          <source>One can use &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt; that has the method &quot;has()&quot;:</source>
          <target state="translated">「has（）」メソッドを持つ&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Set&quot;&gt;Set&lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="825581b147d158d0a4fcbad34b8422e021ee90b1" translate="yes" xml:space="preserve">
          <source>One-liner:</source>
          <target state="translated">One-liner:</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="68c145e8a882446ce410a8fffbfe92a5b1901acc" translate="yes" xml:space="preserve">
          <source>Performance test</source>
          <target state="translated">性能試験</target>
        </trans-unit>
        <trans-unit id="14af93ac2aa339aa659d1348d1120c589b66f432" translate="yes" xml:space="preserve">
          <source>Prototype: &lt;a href=&quot;http://api.prototypejs.org/language/Array/prototype/indexOf/&quot;&gt;&lt;code&gt;array.indexOf(value)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">プロトタイプ： &lt;a href=&quot;http://api.prototypejs.org/language/Array/prototype/indexOf/&quot;&gt; &lt;code&gt;array.indexOf(value)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b7effb1c9ae5bdca656da5f4d5ba15d3df67f272" translate="yes" xml:space="preserve">
          <source>Ramda: &lt;a href=&quot;https://ramdajs.com/docs/#includes&quot;&gt;&lt;code&gt;R.includes(value, array)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://ramdajs.com/docs/#includes&quot;&gt; &lt;code&gt;R.includes(value, array)&lt;/code&gt; &lt;/a&gt; ： R.includes（value、array）</target>
        </trans-unit>
        <trans-unit id="612e12d29278b5519294bc25cdaddffec6d0f1c6" translate="yes" xml:space="preserve">
          <source>Results</source>
          <target state="translated">Results</target>
        </trans-unit>
        <trans-unit id="e8323adb0162f1ecb663442b5fcc7ca8dcc10b18" translate="yes" xml:space="preserve">
          <source>Returns array index if found, or -1 if not found</source>
          <target state="translated">見つかった場合は配列のインデックスを、見つからなかった場合は -1 を返します。</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">コードスニペットを表示</target>
        </trans-unit>
        <trans-unit id="cde8d71a70567d48dd01952e68d8fa1e0ed18bca" translate="yes" xml:space="preserve">
          <source>Simple function</source>
          <target state="translated">シンプルな機能</target>
        </trans-unit>
        <trans-unit id="0e9d5dfd8c62d9bd7b04e68e33d6289e0216ca1f" translate="yes" xml:space="preserve">
          <source>Simple solution for this requirement is using &lt;code&gt;find()&lt;/code&gt;</source>
          <target state="translated">この要件の簡単な解決策は、 &lt;code&gt;find()&lt;/code&gt; を使用することです</target>
        </trans-unit>
        <trans-unit id="cba0b4c636764d40e59c45dfcbeaff8fd15c2f2f" translate="yes" xml:space="preserve">
          <source>Since find and findIndex takes a callback, we can be fetch any object(even if we don't have the reference) from array by creatively setting the true condition.</source>
          <target state="translated">findやfindIndexはコールバックを取るので、真の条件を設定することで配列から任意のオブジェクト(参照がなくても)を取り出すことができます。</target>
        </trans-unit>
        <trans-unit id="e8120e70e781059a2250649e3a26d1ef79737908" translate="yes" xml:space="preserve">
          <source>Solution that works in all modern browsers:</source>
          <target state="translated">すべての最新ブラウザで動作するソリューション。</target>
        </trans-unit>
        <trans-unit id="c76563a98a925864b596ec5d5c1c427850c1e563" translate="yes" xml:space="preserve">
          <source>Surprised that this question still doesn't have latest syntax added, adding my 2 cents.</source>
          <target state="translated">この質問にはまだ最新の構文が追加されていないことに驚き、私の2セントを追加しました。</target>
        </trans-unit>
        <trans-unit id="e32c19490d0541d3cf19e6edf0e601f2c55e35c0" translate="yes" xml:space="preserve">
          <source>The accepted answer does not even meet the requirements.</source>
          <target state="translated">認められた答えは、条件を満たしていない。</target>
        </trans-unit>
        <trans-unit id="6e76714ac550731d4df9f2f4c7278a064a84b068" translate="yes" xml:space="preserve">
          <source>The array prototype variant</source>
          <target state="translated">配列プロトタイプのバリアント</target>
        </trans-unit>
        <trans-unit id="fbe496135ed624dc79a7b415841f95f2535966fe" translate="yes" xml:space="preserve">
          <source>The find functionality works like this.</source>
          <target state="translated">検索機能はこのように動作します。</target>
        </trans-unit>
        <trans-unit id="abb94027a4ec61a730cdc8afd975bf908ce25a48" translate="yes" xml:space="preserve">
          <source>The find method executes the callback function once for each element
  present in the array until it finds one where callback returns a true
  value. If such an element is found, find immediately returns the value
  of that element. Otherwise, find returns undefined. callback is
  invoked only for indexes of the array which have assigned values; it
  is not invoked for indexes which have been deleted or which have never
  been assigned values.</source>
          <target state="translated">find メソッドは、配列内に存在する各要素に対してコールバック関数を一度だけ実行し、 callback が真の値を返す要素を見つけるまで実行します。そのような要素が見つかった場合、find は直ちにその要素の値を返します。callback は、値が代入された配列のインデックスに対してのみ呼び出され、削除されたインデックスや値が代入されたことのないインデックスに対しては呼び出されません。</target>
        </trans-unit>
        <trans-unit id="5b756913fa20f5856e97197d8d0fda4fbf36c558" translate="yes" xml:space="preserve">
          <source>The function can also be easily modified to return true or false or even the object, string or whatever it is.</source>
          <target state="translated">この関数は、真か偽か、あるいはオブジェクト、文字列、あるいはそれが何であれ、それを返すように簡単に変更することもできます。</target>
        </trans-unit>
        <trans-unit id="42cafc36913e43d0dc7e04557d3be49392edb70e" translate="yes" xml:space="preserve">
          <source>The nice thing about it is that the iteration is aborted once the element is found so unnecessary iteration cycles are spared.</source>
          <target state="translated">これの良いところは、要素が見つかると反復処理が中止されるので、不要な反復処理のサイクルが省けることです。</target>
        </trans-unit>
        <trans-unit id="c57bb5822f56318aa1093c9fd0bde5d8e450f3af" translate="yes" xml:space="preserve">
          <source>The top answers assume primitive types but if you want to find out if an array contains an &lt;strong&gt;object&lt;/strong&gt; with some trait, &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;Array.prototype.some()&lt;/a&gt; is a very elegant solution:</source>
          <target state="translated">上位の回答はプリミティブ型を想定していますが、配列にある特性を持つ&lt;strong&gt;オブジェクト&lt;/strong&gt;が含まれているかどうかを確認する場合、 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;Array.prototype.some（）&lt;/a&gt;は非常にエレガントなソリューションです。</target>
        </trans-unit>
        <trans-unit id="8745427232de5b90792b54c573542edc52081778" translate="yes" xml:space="preserve">
          <source>Then you can check whether the object with your value is already present or not</source>
          <target state="translated">そして、あなたの値を持つオブジェクトが既に存在するかどうかを確認することができます。</target>
        </trans-unit>
        <trans-unit id="5e5170b7a4ad0e560f4e4f174f48e9a7abcbf1da" translate="yes" xml:space="preserve">
          <source>Then you can find the index of that object in the array and replace the object using below code.</source>
          <target state="translated">そして、そのオブジェクトのインデックスを配列の中から見つけ、以下のコードを使ってオブジェクトを置換します。</target>
        </trans-unit>
        <trans-unit id="c9fd6f4ab61b50813778042886300ccd0e83bc2c" translate="yes" xml:space="preserve">
          <source>There are many ways to do this which are cleaner and better, but I just wanted to get your pattern and apply to that using &lt;code&gt;JSON.stringify&lt;/code&gt;, just simply do something like this in your case:</source>
          <target state="translated">これを行うには、よりクリーンで優れた多くの方法がありますが、私はあなたのパターンを取得し、 &lt;code&gt;JSON.stringify&lt;/code&gt; を使用してそれに適用したかったので、単にあなたのケースで次のようなことをしてください：</target>
        </trans-unit>
        <trans-unit id="cc16540816c436314b02d39733fbde781a2be92d" translate="yes" xml:space="preserve">
          <source>Thinking out of the box for a second, if you are making this call many many times, it is vastly more efficient to use &lt;strike&gt;an associative array&lt;/strike&gt; a Map to do lookups using a hash function.</source>
          <target state="translated">ちょっと考えてみると、この呼び出しを何度も行う場合は&lt;strike&gt;、連想配列&lt;/strike&gt; Mapを使用してハッシュ関数を使用してルックアップを行う方がはるかに効率的です。</target>
        </trans-unit>
        <trans-unit id="c90ebff9b8cace224a8ac140604be3b76e23637d" translate="yes" xml:space="preserve">
          <source>This is the only way I know to do it:</source>
          <target state="translated">これが唯一の方法だと思っています。</target>
        </trans-unit>
        <trans-unit id="9fec1e19841ff4041bd895c4395ba1d97e9718e9" translate="yes" xml:space="preserve">
          <source>This is very closely related to Stack Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/143847/best-way-to-find-an-item-in-a-javascript-array&quot;&gt;Best way to find an item in a JavaScript Array?&lt;/a&gt;&lt;/em&gt; which addresses finding objects in an array using &lt;code&gt;indexOf&lt;/code&gt;.</source>
          <target state="translated">これは、スタックオーバーフローの質問と非常に密接に関連し&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/143847/best-way-to-find-an-item-in-a-javascript-array&quot;&gt;ています。JavaScript配列でアイテムを検索する最良の方法は何ですか？&lt;/a&gt;&lt;/em&gt; これは、 &lt;code&gt;indexOf&lt;/code&gt; を使用して配列内のオブジェクトを見つけることを扱います。</target>
        </trans-unit>
        <trans-unit id="2b20c684ba339a0aa8fa186e3bd452c5a2f3f3d9" translate="yes" xml:space="preserve">
          <source>Three queries: at the beginning, in the middle &amp;amp; at the end of the array.</source>
          <target state="translated">3つのクエリ：配列の最初、中央、最後。</target>
        </trans-unit>
        <trans-unit id="5e26c8bf03eec1969b324604b86cbc899b237577" translate="yes" xml:space="preserve">
          <source>To know exactly what the &lt;code&gt;tilde&lt;/code&gt;&lt;code&gt;~&lt;/code&gt; do at this point, refer to this question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/12299665/what-does-a-tilde-do-when-it-precedes-an-expression&quot;&gt;What does a tilde do when it precedes an expression?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;tilde&lt;/code&gt; &lt;code&gt;~&lt;/code&gt; がこの時点で何をするかを正確に知るには、この質問を参照してください。 &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/12299665/what-does-a-tilde-do-when-it-precedes-an-expression&quot;&gt;チルドが式の前にあるとき、チルドは何をしますか？&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="48cd98f9836826608a5509761b5545dff093468c" translate="yes" xml:space="preserve">
          <source>Today 2020.01.07 I perform tests on MacOs HighSierra 10.13.6 on Chrome v78.0.0, Safari v13.0.4 and Firefox v71.0.0 for 15 chosen solutions. Conclusions</source>
          <target state="translated">本日2020.01.07 MacOs HighSierra 10.13.6でChrome v78.0.0.0、Safari v13.0.4、Firefox v71.0.0の15のソリューションをテストしてみました。結論</target>
        </trans-unit>
        <trans-unit id="49294c55abc80cbff078b924b2c630ec220213bf" translate="yes" xml:space="preserve">
          <source>Underscore.js: &lt;a href=&quot;http://underscorejs.org/#contains&quot;&gt;&lt;code&gt;_.contains(array, value)&lt;/code&gt;&lt;/a&gt; (also aliased as &lt;code&gt;_.include&lt;/code&gt; and &lt;code&gt;_.includes&lt;/code&gt;)</source>
          <target state="translated">Underscore.js： &lt;a href=&quot;http://underscorejs.org/#contains&quot;&gt; &lt;code&gt;_.contains(array, value)&lt;/code&gt; &lt;/a&gt; . contains（array、value） （別名 &lt;code&gt;_.include&lt;/code&gt; および &lt;code&gt;_.includes&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="f3d059b896de2ed3d87cd30f8be35c02ffb5fc69" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;indexOf&lt;/code&gt;, which uses &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison&quot;&gt;Strict Equality Comparison&lt;/a&gt;, &lt;code&gt;includes&lt;/code&gt; compares using &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero&quot;&gt;SameValueZero&lt;/a&gt; equality algorithm. That means that you can detect if an array includes a &lt;code&gt;NaN&lt;/code&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-strict-equality-comparison&quot;&gt;Strict Equality Comparison&lt;/a&gt;を使用する &lt;code&gt;indexOf&lt;/code&gt; とは異なり、 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-samevaluezero&quot;&gt;SameValueZero&lt;/a&gt;等式アルゴリズムを使用した比較が &lt;code&gt;includes&lt;/code&gt; ます。 つまり、配列に &lt;code&gt;NaN&lt;/code&gt; が含まれているかどうかを検出できます。</target>
        </trans-unit>
        <trans-unit id="28771587e0631fb484f44d7bb44cf48c63b7758f" translate="yes" xml:space="preserve">
          <source>Updated the &lt;code&gt;contains&lt;/code&gt; function with a perf optimization. Thanks &lt;a href=&quot;https://stackoverflow.com/users/1397160/itinance&quot;&gt;itinance&lt;/a&gt; for pointing it out.</source>
          <target state="translated">&lt;code&gt;contains&lt;/code&gt; 関数をperf最適化で更新しました。 指摘してくれてありがとう。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="f0228254bb4ff82bb180b380d25a7ac8da7e9b8c" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;binary search&lt;/a&gt; lookup in your &lt;code&gt;contains(a, obj)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;contains(a, obj)&lt;/code&gt; で&lt;a href=&quot;http://en.wikipedia.org/wiki/Binary_search_algorithm&quot;&gt;バイナリ検索&lt;/a&gt;ルックアップを使用します。</target>
        </trans-unit>
        <trans-unit id="7db1625c0ecb79fc25336042f3620583672ba039" translate="yes" xml:space="preserve">
          <source>Use lodash's &lt;a href=&quot;https://lodash.com/docs#some&quot;&gt;some&lt;/a&gt; function.</source>
          <target state="translated">lodashの&lt;a href=&quot;https://lodash.com/docs#some&quot;&gt;some&lt;/a&gt;関数を使用します。</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="99d49a545e16e15fde40c6d01e8df0374271fbf3" translate="yes" xml:space="preserve">
          <source>We use this snippet (works with objects, arrays, strings):</source>
          <target state="translated">このスニペットを使用しています(オブジェクト、配列、文字列で動作します)。</target>
        </trans-unit>
        <trans-unit id="e5a8bfa78b6cc841ae306aa109c2288f80d1bcad" translate="yes" xml:space="preserve">
          <source>What is the most concise and efficient way to find out if a JavaScript array contains a value?</source>
          <target state="translated">JavaScriptの配列に値が含まれているかどうかを調べる最も簡潔で効率的な方法は何ですか?</target>
        </trans-unit>
        <trans-unit id="8703cf29cfa5ac185fce8c1dec2a01c5c3eb839d" translate="yes" xml:space="preserve">
          <source>When you know you just pushed an array with a value, using lastIndexOf remains probably the best solution, but if you have to travel through big arrays and the result could be everywhere, this could be a solid solution to make things faster.</source>
          <target state="translated">配列を値で押しただけだとわかっている場合は、lastIndexOf を使うのが最良の解決策でしょう。しかし、大きな配列を移動しなければならず、結果がどこにでもありそうな場合は、これが高速化のための確かな解決策になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="f11390c7b08f5438453c92d12de28409182c4947" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;array.indexOf(x)!=-1&lt;/code&gt; is the most concise way to do this (and has been supported by non-Internet&amp;nbsp;Explorer browsers for over decade...), it is not O(1), but rather O(N), which is terrible. If your array will not be changing, you can convert your array to a hashtable, then do &lt;code&gt;table[x]!==undefined&lt;/code&gt; or &lt;code&gt;===undefined&lt;/code&gt;:</source>
          <target state="translated">これを行うには、 &lt;code&gt;array.indexOf(x)!=-1&lt;/code&gt; が最も簡潔な方法ですが（Internet Explorer以外のブラウザでも10年以上サポートされています...）、O（1）ではなく、O（ N）、それはひどいです。 配列が変更されない場合は、配列をハッシュテーブルに変換してから、 &lt;code&gt;table[x]!==undefined&lt;/code&gt; または &lt;code&gt;===undefined&lt;/code&gt; を実行できます 。</target>
        </trans-unit>
        <trans-unit id="b01c71c2892eac27aa9d47b7b2460c3ca6b6002f" translate="yes" xml:space="preserve">
          <source>While the new method &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes&quot;&gt;includes&lt;/a&gt; is very nice, the support is basically zero for now.</source>
          <target state="translated">新しいメソッド&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes&quot;&gt;include&lt;/a&gt;は非常に優れていますが、現時点ではサポートは基本的にゼロです。</target>
        </trans-unit>
        <trans-unit id="66a9a0ebce37ca21a36fa25294dd0f724d8af682" translate="yes" xml:space="preserve">
          <source>Why to use &lt;code&gt;JSON.stringify&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;JSON.stringify&lt;/code&gt; を使用する理由</target>
        </trans-unit>
        <trans-unit id="710e9393126b52a4f0c439a6f12859ff0112353e" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt;&lt;code&gt;Array#indexOf&lt;/code&gt;&lt;/a&gt;, which is less direct, but doesn't require polyfills for outdated browsers.</source>
          <target state="translated">直接性は低いですが、古いブラウザではポリフィルを必要としない&lt;a href=&quot;https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt; &lt;code&gt;Array#indexOf&lt;/code&gt; を&lt;/a&gt;使用することもできます。</target>
        </trans-unit>
        <trans-unit id="5d307aa6a64cce35bbe21c4e01d8d6639b51bbad" translate="yes" xml:space="preserve">
          <source>You can perform tests in your machine &lt;a href=&quot;https://jsperf.com/array-big-exist-element/1&quot;&gt;HERE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://jsperf.com/array-big-exist-element/1&quot;&gt;ここで&lt;/a&gt;マシンでテストを実行できます</target>
        </trans-unit>
        <trans-unit id="c452231ce645912ee34b17df9db70ba167c4c874" translate="yes" xml:space="preserve">
          <source>You can perform tests in your machine &lt;a href=&quot;https://jsperf.com/array-exist-element/1&quot;&gt;HERE&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://jsperf.com/array-exist-element/1&quot;&gt;ここで&lt;/a&gt;マシンでテストを実行できます</target>
        </trans-unit>
        <trans-unit id="4cffa6d9408268dd04c67fe0e590fb87b7066b9c" translate="yes" xml:space="preserve">
          <source>You can use this in ECMAScript 5 and below by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find#Polyfill&quot;&gt;defining the function&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find#Polyfill&quot;&gt;関数を定義すること&lt;/a&gt;により、ECMAScript 5以下でこれを使用できます。</target>
        </trans-unit>
        <trans-unit id="8a8b0fcd60b778db319e070da9ab5bd99a70551d" translate="yes" xml:space="preserve">
          <source>hope this will help anyone.</source>
          <target state="translated">これが誰かの助けになることを願っています。</target>
        </trans-unit>
        <trans-unit id="f4b7e9b9241515996b32e009d8f7fee6dcf4fc80" translate="yes" xml:space="preserve">
          <source>if data is null then no admin, else it will return the existing object like below.</source>
          <target state="translated">dataがnullの場合はadminではなく、以下のように既存のオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="12c167eda8182142022b2a92450f25c79b0bcb8b" translate="yes" xml:space="preserve">
          <source>jQuery: &lt;a href=&quot;http://api.jquery.com/jquery.inarray/&quot;&gt;&lt;code&gt;$.inArray(value, array, [fromIndex])&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">jQuery： &lt;a href=&quot;http://api.jquery.com/jquery.inarray/&quot;&gt; &lt;code&gt;$.inArray(value, array, [fromIndex])&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6101b8b106bb34aa75ee0814071b80c3bd5855d4" translate="yes" xml:space="preserve">
          <source>solutions based on &lt;code&gt;JSON&lt;/code&gt;, &lt;code&gt;Set&lt;/code&gt; and surprisingly &lt;code&gt;find&lt;/code&gt; (K,N,O) are slowest on all browsers</source>
          <target state="translated">&lt;code&gt;JSON&lt;/code&gt; 、 &lt;code&gt;Set&lt;/code&gt; 、意外な &lt;code&gt;find&lt;/code&gt; （K、N、O）に基づくソリューションは、すべてのブラウザーで最も遅い</target>
        </trans-unit>
        <trans-unit id="a11a1beae753e81ce95402eff46f26a927ec2374" translate="yes" xml:space="preserve">
          <source>the es6 &lt;code&gt;includes&lt;/code&gt; (F) is fast only on chrome</source>
          <target state="translated">es6 &lt;code&gt;includes&lt;/code&gt; （F）はChromeでのみ高速です</target>
        </trans-unit>
        <trans-unit id="7ec7950d04195293692d83e333f6cef03db4144a" translate="yes" xml:space="preserve">
          <source>the solutions based on &lt;code&gt;for&lt;/code&gt; (C,D) and &lt;code&gt;indexOf&lt;/code&gt; (G,H) are quite-fast on all browsers on small and big arrays so probably they are best choice for efficient solution</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; （C、D）と &lt;code&gt;indexOf&lt;/code&gt; （G、H）に基づくソリューションは、すべてのブラウザーで小さなアレイと大きなアレイに非常に高速であるため、おそらく効率的なソリューションに最適です</target>
        </trans-unit>
        <trans-unit id="289945786f0df06cde96642e167bcc38037aa002" translate="yes" xml:space="preserve">
          <source>the solutions where index decrease during loop, (B) is slower probably because the way of &lt;a href=&quot;https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus&quot;&gt;CPU cache works&lt;/a&gt;.</source>
          <target state="translated">ループ中にインデックスが減少するソリューション（B）は、 &lt;a href=&quot;https://stackoverflow.com/questions/1950878/c-for-loop-indexing-is-forward-indexing-faster-in-new-cpus&quot;&gt;CPUキャッシュが機能する&lt;/a&gt;ためか、おそらく遅くなります。</target>
        </trans-unit>
        <trans-unit id="798bc4d228938e571a6eb1d95ec4af0226cad052" translate="yes" xml:space="preserve">
          <source>you will get value like below</source>
          <target state="translated">以下のような値が得られます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
