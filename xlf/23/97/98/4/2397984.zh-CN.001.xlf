<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/2397984">
    <body>
      <group id="2397984">
        <trans-unit id="a8642ac09b8508587e68f1734255bd9f149b636b" translate="yes" xml:space="preserve">
          <source>2
  EXAMPLE An example of unspecified
  behavior is the order in which the
  arguments to a function are evaluated.</source>
          <target state="translated">2 例子 未指定行为的一个例子是对一个函数的参数进行评价的顺序。</target>
        </trans-unit>
        <trans-unit id="2503f99863d13d5ddf37f8e7ca0aa5dc129bfad7" translate="yes" xml:space="preserve">
          <source>2
  NOTE Possible undefined behavior
  ranges from ignoring the situation
  completely with unpredictable results,
  to behaving during translation or
  program execution in a documented
  manner characteristic of the
  environment (with or without the
  issuance of a diagnostic message), to
  terminating a translation or execution
  (with the issuance of a diagnostic
  message).</source>
          <target state="translated">2 注意 可能的未定义行为包括:完全忽略情况,结果不可预知,在翻译或程序执行过程中以环境特征的记录方式(有或没有发出诊断信息),以及终止翻译或执行(发出诊断信息)。</target>
        </trans-unit>
        <trans-unit id="569b518442a5c00e3f5f269306db32d537693a40" translate="yes" xml:space="preserve">
          <source>2 EXAMPLE An example of
  implementation-defined behavior is the
  propagation of the high-order bit when
  a signed integer is shifted right.</source>
          <target state="translated">2 例子 一个实现定义行为的例子是当有符号整数向右移位时,高阶位的传播。</target>
        </trans-unit>
        <trans-unit id="55e2cabac9083f31e037fb27d178b197629146d2" translate="yes" xml:space="preserve">
          <source>3 EXAMPLE An example of
  undefined behavior is the behavior on
  integer overflow.</source>
          <target state="translated">3 EXAMPLE 未定义行为的一个例子是在整数溢出上的行为。</target>
        </trans-unit>
        <trans-unit id="b59dcbb47c1299641d663023ee7e761885c46dec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.devx.com/tips/Tip/12684&quot;&gt;Undefined Behavior vs. Unspecified Behavior&lt;/a&gt; has a short description of it.</source>
          <target state="translated">&lt;a href=&quot;http://www.devx.com/tips/Tip/12684&quot;&gt;未定义行为与未指定行为&lt;/a&gt;对此进行了简短描述。</target>
        </trans-unit>
        <trans-unit id="ee0b8c6197fe6b3a5f488da9fd25ff2ee8c6dec7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Implementation-defined&lt;/em&gt; behavior gives an implementor the freedom to choose the appropriate approach, but requires that this choice be explained to the user.  Behaviors designated as implementation-defined are generally those in which a user could make meaningful coding decisions based on the implementation definition.  Implementors should bear in mind this criterion when deciding how extensive an implementation definition ought to be.  As with unspecified behavior, simply failing to translate the source containing the implementation-defined behavior is not an adequate response.</source>
          <target state="translated">&lt;em&gt;实施定义的&lt;/em&gt;行为使实施者可以自由选择适当的方法，但是需要向用户说明这一选择。 指定为实现定义的行为通常是指用户可以根据实现定义做出有意义的编码决策的行为。 在确定实施定义应有多广泛时，实施者应牢记此标准。 与未指定的行为一样，仅对包含实现定义的行为的源进行翻译失败也就不足为奇了。</target>
        </trans-unit>
        <trans-unit id="8599642070272d1f3aa7633ea08cf86c0b0f359d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Undefined behavior&lt;/em&gt; gives the implementor license not to catch certain program errors that are difficult to diagnose.  It also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior.</source>
          <target state="translated">&lt;em&gt;未定义的行为&lt;/em&gt;使实施者可以不捕获某些难以诊断的程序错误。 它还确定了可能的符合语言扩展的领域：实现者可以通过提供正式未定义行为的定义来扩展语言。</target>
        </trans-unit>
        <trans-unit id="7ee702ce983e09f9c8a606b57e09c396752f1074" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Unspecified behavior&lt;/em&gt; gives the implementor some latitude in translating programs.  This latitude does not extend as far as failing to translate the program.</source>
          <target state="translated">&lt;em&gt;未指定的行为&lt;/em&gt;使实施者可以自由翻译程序。 这种范围不会扩展到无法翻译程序的程度。</target>
        </trans-unit>
        <trans-unit id="cad8f14462d2da2f559db18ca6a3eab49739a99c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.1&lt;/strong&gt; 1 &lt;strong&gt;implementation-defined behavior&lt;/strong&gt; unspecified behavior where
  each implementation documents how the
  choice is made</source>
          <target state="translated">&lt;strong&gt;3.4.1&lt;/strong&gt; 1个&lt;strong&gt;实施定义的行为&lt;/strong&gt;未指定的行为，其中每个实施记录了选择的方式</target>
        </trans-unit>
        <trans-unit id="9de03b72d558df568e7926b9e71adf72c5a06b64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.3&lt;/strong&gt; 1 &lt;strong&gt;undefined behavior&lt;/strong&gt; behavior, upon use of a nonportable or erroneous
  program construct or of erroneous
  data, for which this International
  Standard imposes no requirements</source>
          <target state="translated">&lt;strong&gt;3.4.3&lt;/strong&gt; 1 &lt;strong&gt;未定义行为的&lt;/strong&gt;行为，使用非便携式或错误的程序构造或错误的数据，而本国际标准对此不施加任何要求</target>
        </trans-unit>
        <trans-unit id="3dd4f6dcab8bfd6801d918b5e9fcc7e33a661ccd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.4&lt;/strong&gt; 1 &lt;strong&gt;unspecified behavior&lt;/strong&gt; use of an unspecified value, or other behavior
  where this International Standard
  provides two or more possibilities and
  imposes no further requirements on
  which is chosen in any instance</source>
          <target state="translated">&lt;strong&gt;3.4.4&lt;/strong&gt; 1 &lt;strong&gt;未指明的行为&lt;/strong&gt;使用未指明的值，或在本国际标准提供两种或两种以上可能性且在任何情况下均不对其施加任何其他要求的情况下的其他行为</target>
        </trans-unit>
        <trans-unit id="aeac9f01453e8d88294f9e02230d16dc104b3874" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Undefined behavior&lt;/em&gt;&lt;/strong&gt; is one of those aspects of the C and C++ language that can be surprising to programmers coming from other languages (other languages try to hide it better). Basically,  it is possible to write C++ programs that do not behave in a predictable way, even though many C++ compilers will not report any errors in the program!</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;未定义的行为&lt;/em&gt;&lt;/strong&gt;是C和C ++语言的那些方面之一，对于其他语言的程序员来说，这可能是令人惊讶的（其他语言试图更好地隐藏它）。 基本上，即使许多C ++编译器不会报告程序中的任何错误，也可以编写行为无法预测的C ++程序！</target>
        </trans-unit>
        <trans-unit id="89cfb28e2a87f840b0837be96911f5555ef4bc80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;implementation-defined behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;实现定义的行为&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8afce23c6edac06facd82113e916bc887c72ee2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;未定义的行为&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1fbaed2b0330ce88dda9bc280a73badcca5396a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;未指明的行为&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0f50639979e1e6edba80094faabb497356f2481a" translate="yes" xml:space="preserve">
          <source>@eSKay I think your question is worth editing the answer to clarify more :)</source>
          <target state="translated">@eSKay 我认为你的问题值得编辑答案,以澄清更多的问题 :)</target>
        </trans-unit>
        <trans-unit id="4408e31b9c4b1008a8002431961b6a435f55e8db" translate="yes" xml:space="preserve">
          <source>Anything might happen,take care of it.</source>
          <target state="translated">任何事情都有可能发生,你要小心谨慎。</target>
        </trans-unit>
        <trans-unit id="1e67c5c154cd7cab955ab3f3ec82e33acc7125e0" translate="yes" xml:space="preserve">
          <source>C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen ( &lt;strong&gt;bot not necessary described&lt;/strong&gt;) by particular implementation (version of library). So in the case when no description has been provided it can be difficult to the user to know exactly how will program behave.</source>
          <target state="translated">C ++ Standard并未在某些构造上强加特定的行为，而是说&lt;strong&gt;必须&lt;/strong&gt;通过特定的实现（库的版本）选择特定的，定义明确的行为（ &lt;strong&gt;无需描述bot&lt;/strong&gt; ）。 因此，在没有提供任何描述的情况下，用户可能很难确切知道程序的行为方式。</target>
        </trans-unit>
        <trans-unit id="5455973a5b63faf093a2386058a1346a183e359c" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.10
&lt;strong&gt;implementation-defined behavior&lt;/strong&gt;</source>
          <target state="translated">C ++标准n3337&amp;sect;1.3.10 &lt;strong&gt;实现定义的行为&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83ac5b84b2b1cf0f027707ad4321c678feaebc59" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.24
&lt;strong&gt;undefined behavior&lt;/strong&gt;</source>
          <target state="translated">C ++标准n3337&amp;sect;1.3.24 &lt;strong&gt;未定义行为&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5d9a1e3f8a889e8dab1de5162f84879e8d623bd" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.25
&lt;strong&gt;unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">C ++标准n3337&amp;sect;1.3.25 &lt;strong&gt;未指定行为&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c147dafffa7c09aef6daa958cd748ef62ee63c1" translate="yes" xml:space="preserve">
          <source>Certain aspects and operations of the abstract machine are described in this International Standard as &lt;strong&gt;implementation-defined&lt;/strong&gt; (for example, &lt;code&gt;sizeof(int)&lt;/code&gt;). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these respects.</source>
          <target state="translated">在本国际标准中，抽象机的某些方面和操作被描述为&lt;strong&gt;实现定义的&lt;/strong&gt; （例如， &lt;code&gt;sizeof(int)&lt;/code&gt; ）。 这些构成了抽象机的参数。 每个实现都应包括描述这些方面的特性和行为的文档。</target>
        </trans-unit>
        <trans-unit id="99647a312493a7bc6d385f15f565cff68383c1e9" translate="yes" xml:space="preserve">
          <source>Certain other aspects and operations of the abstract machine are described in this International Standard as &lt;strong&gt;unspecified&lt;/strong&gt; (for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine.</source>
          <target state="translated">抽象机的某些其他方面和操作在本国际标准中描述为&lt;strong&gt;未指定&lt;/strong&gt; （例如，对函数自变量的求值顺序）。 在可能的情况下，本国际标准定义了一组允许的行为。 这些定义了抽象机的不确定性方面。</target>
        </trans-unit>
        <trans-unit id="877fa79cfe0bb2180cea26e2a5734c4880504fb2" translate="yes" xml:space="preserve">
          <source>Certain other operations are described in this International Standard as &lt;strong&gt;undefined&lt;/strong&gt; (for example, the  effect of dereferencing the null pointer). [ &lt;em&gt;Note&lt;/em&gt;: &lt;strong&gt;this International Standard imposes no requirements on the behavior of programs that contain undefined behavior.&lt;/strong&gt; &amp;mdash;&lt;em&gt;end note&lt;/em&gt; ]</source>
          <target state="translated">在本国际标准中，某些其他操作被描述为&lt;strong&gt;未定义&lt;/strong&gt; （例如，取消引用空指针的效果）。 [ &lt;em&gt;注意&lt;/em&gt; ： &lt;strong&gt;本国际标准对包含未定义行为的程序的行为没有任何要求。&lt;/strong&gt; &amp;mdash; &lt;em&gt;尾注&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0839b8c0f93bc7215bae8e654ced5403f6f34f98" translate="yes" xml:space="preserve">
          <source>For example, given the following code:</source>
          <target state="translated">例如,鉴于以下代码:</target>
        </trans-unit>
        <trans-unit id="910feb56caa0b4f4562dfa21c599f9c4fce3aea8" translate="yes" xml:space="preserve">
          <source>From the official C Rationale Document</source>
          <target state="translated">摘自官方的C类理由文件</target>
        </trans-unit>
        <trans-unit id="a2257744a12c541b56be26d9e4b425a8900f06cc" translate="yes" xml:space="preserve">
          <source>Historically, both Implementation-Defined Behavior and Undefined Behavior represented situations in which the authors of the Standard expected that people writing quality implementations would use judgment to decide what behavioral guarantees, if any, would be useful for programs in the intended application field running on the intended targets.  The needs of high-end number-crunching code are quite different from those of low-level systems code, and both UB and IDB give compiler writers flexibility to meet those different needs.  Neither category mandates that implementations behave in a way that's useful for any particular purpose, or even for any purpose whatsoever.  Quality implementations that claim to be suitable for a particular purpose, however, should behave in a manner befitting such purpose &lt;em&gt;whether the Standard requires it or not&lt;/em&gt;.</source>
          <target state="translated">从历史上看，实现定义的行为和未定义的行为都代表了这样的情况，在该情况下，标准的作者期望编写高质量实现的人们将使用判断来决定哪些行为保证（如果有的话）对于在运行于目标应用程序领域的程序有用预定目标。 高端数字运算代码的需求与低层系统代码的需求完全不同，并且UB和IDB都为编译器编写者提供了满足这些不同需求的灵活性。 这两个类别都不要求实现的行为对于任何特定目的甚至任何目的都无用。 但是， &lt;em&gt;无论标准是否要求&lt;/em&gt; ，声称适合特定目的的质量实现都应以适合该目的的方式运行。</target>
        </trans-unit>
        <trans-unit id="2540f81c26e6466020aee474b4a78829aae36435" translate="yes" xml:space="preserve">
          <source>I can hear people screaming &quot;But wait, I can compile this no problem and get the output &lt;code&gt;yellow&lt;/code&gt;&quot; or &quot;What do you mean undefined, string literals are stored in read-only memory, so the first assignment attempt results in a core dump&quot;. This is exactly the problem with undefined behavior. Basically, the standard allows anything to happen once you invoke undefined behavior (even nasal demons). If there is a &quot;correct&quot; behavior according to your mental model of the language, that model is simply wrong; The C++ standard has the only vote, period.</source>
          <target state="translated">我听到有人在喊&amp;ldquo;但是，我可以编译这个问题，并把输出显示为 &lt;code&gt;yellow&lt;/code&gt; &amp;rdquo;或&amp;ldquo;您的意思是未定义的，字符串文字存储在只读存储器中，因此第一次分配尝试会导致核心转储&amp;rdquo; 。 这正是未定义行为的问题。 基本上，一旦您调用未定义的行为（甚至是鼻恶魔），该标准将允许发生任何事情。 如果根据您的语言思维模式有&amp;ldquo;正确&amp;rdquo;的行为，则该模式完全是错误的。 C ++标准具有唯一的投票期限。</target>
        </trans-unit>
        <trans-unit id="d3cbfc77c16c8f8fe13215121e443b68e0af440a" translate="yes" xml:space="preserve">
          <source>IMO far too many &quot;things&quot; are left
  undefined, unspecified,
  implementation-defined, etc. However,
  that's easy to say and even to give
  examples of, but hard to fix. It
  should also be noted that it is not
  all that difficult to avoid most of
  the problems and produce portable
  code.</source>
          <target state="translated">IMO太多的 &quot;东西 &quot;都是未定义、未指定、未定义、未实现等。然而,这一点说起来容易,甚至可以举例说明,但很难解决。还需要注意的是,要避免大部分的问题,制作出可移植的代码,其实并不难。</target>
        </trans-unit>
        <trans-unit id="a291455822dc1c54fd3c820d50b04b5689f1956b" translate="yes" xml:space="preserve">
          <source>Implementation defined-</source>
          <target state="translated">定义的执行情况-</target>
        </trans-unit>
        <trans-unit id="f0d8b740f7f9ff893a0572fcc79dd50d8329925f" translate="yes" xml:space="preserve">
          <source>Implementors wish,should be well documented,standard gives choices but sure to compile</source>
          <target state="translated">实施者的愿望,应该有很好的文档化,标准给出了选择,但肯定是要编译的</target>
        </trans-unit>
        <trans-unit id="fd18bf07df2a483e12d5b771dc0b3af5d3a88ea6" translate="yes" xml:space="preserve">
          <source>It is claimed that the difference
  between what can be produced giving
  the compiler this freedom and
  requiring &quot;ordinary left-to-right
  evaluation&quot; can be significant. I'm
  unconvinced, but with innumerable
  compilers &quot;out there&quot; taking advantage
  of the freedom and some people
  passionately defending that freedom, a
  change would be difficult and could
  take decades to penetrate to the
  distant corners of the C and C++
  worlds. I am disappointed that not all
  compilers warn against code such as
  ++i+i++. Similarly, the order of evaluation of arguments is
  unspecified.</source>
          <target state="translated">有人声称,给予编译器这种自由和要求 &quot;普通的从左到右的评价 &quot;之间的差别可能很大。我不以为然,但随着无数的编译器 &quot;在外面 &quot;利用这种自由,以及一些人热情地维护这种自由,这种改变是很困难的,可能需要几十年的时间才能渗透到C和C++世界的遥远角落。令我失望的是,并不是所有的编译器都会对++i+i++这样的代码发出警告。同样,对参数的评价顺序也没有明确规定。</target>
        </trans-unit>
        <trans-unit id="fdf5bfd499acd8a1d289a719f15515471ac74fca" translate="yes" xml:space="preserve">
          <source>Let's look at a classic example:</source>
          <target state="translated">我们来看看一个经典的例子。</target>
        </trans-unit>
        <trans-unit id="70c706a5f40b3cd3a5d8a17c0d0b0ab9a0ca06a5" translate="yes" xml:space="preserve">
          <source>Maybe easy wording could be easier for understanding than the rigorous definition of the standards.</source>
          <target state="translated">也许简单的措辞可能比标准的严格定义更容易理解。</target>
        </trans-unit>
        <trans-unit id="3a745746f33c45b300b6511a474f5f3daaf2664a" translate="yes" xml:space="preserve">
          <source>Other examples of undefined behavior include accessing an array beyond its bounds, &lt;a href=&quot;https://stackoverflow.com/q/2894891&quot;&gt;dereferencing the null pointer&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/q/6441218&quot;&gt;accessing objects after their lifetime ended&lt;/a&gt; or writing &lt;a href=&quot;https://stackoverflow.com/q/949433&quot;&gt;allegedly clever expressions&lt;/a&gt; like &lt;code&gt;i++ + ++i&lt;/code&gt;.</source>
          <target state="translated">未定义行为的其他示例包括访问数组之外​​的数组， &lt;a href=&quot;https://stackoverflow.com/q/2894891&quot;&gt;取消引用空指针&lt;/a&gt; ，在&lt;a href=&quot;https://stackoverflow.com/q/6441218&quot;&gt;对象生命周期结束后访问对象&lt;/a&gt;或编写&lt;a href=&quot;https://stackoverflow.com/q/949433&quot;&gt;据称聪明的表达式（&lt;/a&gt;例如 &lt;code&gt;i++ + ++i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="319b32ef19056d6a4cc43f23a6017acb86983769" translate="yes" xml:space="preserve">
          <source>Permissible undefined behavior ranges from &lt;strong&gt;ignoring the situation completely with unpredictable results&lt;/strong&gt;, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</source>
          <target state="translated">允许的不确定行为的范围从&lt;strong&gt;完全忽略具有不可预测结果的情况&lt;/strong&gt;到在翻译或程序执行过程中以环境特征的书面方式记录的行为（带有或不带有诊断消息）到终止翻译或执行（带有发布）诊断消息）。</target>
        </trans-unit>
        <trans-unit id="f4c7eb67efae2426128053994ca5a87e8f8fc518" translate="yes" xml:space="preserve">
          <source>Same as implementation-defined but not documented</source>
          <target state="translated">与实现定义但未记录在案相同</target>
        </trans-unit>
        <trans-unit id="bfdc4a7a8214fa75e47089f0c3154e682f509bac" translate="yes" xml:space="preserve">
          <source>Section 1.9 of the C++ standard also mentions undefined behavior's two less dangerous brothers, &lt;strong&gt;unspecified behavior&lt;/strong&gt; and &lt;strong&gt;implementation-defined behavior&lt;/strong&gt;:</source>
          <target state="translated">C ++标准的1.9节还提到了未定义行为的两个不太危险的兄弟，即&lt;strong&gt;未指定行为&lt;/strong&gt;和&lt;strong&gt;实现定义的行为&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="34669cae5d82e706134e0fee4b3402d81d5ed84b" translate="yes" xml:space="preserve">
          <source>Sometimes C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen and &lt;strong&gt;described&lt;/strong&gt; by particular implementation (version of library). So user can still know exactly how will program behave even though Standard doesn't describe this.</source>
          <target state="translated">有时，C ++ Standard并未在某些构造上强加特定的行为，而是说必须通过特定的实现（库的版本）选择并&lt;strong&gt;描述&lt;/strong&gt;特定的，定义明确的行为。 因此，即使Standard并未对此进行描述，用户仍可以确切知道程序的行为方式。</target>
        </trans-unit>
        <trans-unit id="8adb8ad36deb332dc2e827438bafa13e25c65398" translate="yes" xml:space="preserve">
          <source>Specifically, section 1.3.24 states:</source>
          <target state="translated">具体而言,1.3.24节规定:</target>
        </trans-unit>
        <trans-unit id="db0c3d454e250e7c9214ed030c2b4fe7f4dd68e8" translate="yes" xml:space="preserve">
          <source>The difference between implementation-defined and unspecified, is that the compiler is supposed to pick a behavior in the first case but it doesn't have to in the second case. For example, an implementation must have one and only one definition of &lt;code&gt;sizeof(int)&lt;/code&gt;. So, it can't say that &lt;code&gt;sizeof(int)&lt;/code&gt; is 4 for some portion of the program and 8 for others. Unlike unspecified behavior, where the compiler can say OK I am gonna evaluate these arguments left-to-right and the next function's arguments are evaluated right-to-left. It can happen in the same program, that's why it is called &lt;strong&gt;&lt;em&gt;unspecified&lt;/em&gt;&lt;/strong&gt;. In fact, C++ could have been made easier if some of the unspecified behaviors were specified. Take a look here at &lt;a href=&quot;http://www2.research.att.com/~bs/bs_faq2.html#undefined&quot;&gt;Dr. Stroustrup's answer for that&lt;/a&gt;:</source>
          <target state="translated">实现定义的和未指定的之间的区别在于，编译器应该在第一种情况下选择一种行为，但在第二种情况下则不必选择行为。 例如，一个实现必须具有一个且只有一个 &lt;code&gt;sizeof(int)&lt;/code&gt; 定义。 因此，不能说 &lt;code&gt;sizeof(int)&lt;/code&gt; 对于程序的某些部分为4，对于其他部分为8。 与未指定的行为不同，在编译器可以说&amp;ldquo;确定&amp;rdquo;的情况下，我将从左到右评估这些参数，而从下到右评估下一个函数的参数。 它可以在同一程序中发生，因此被称为&lt;strong&gt;&lt;em&gt;unspecified&lt;/em&gt;&lt;/strong&gt; 。 实际上，如果指定了一些未指定的行为，C ++可能会变得更容易。 在这里查看&lt;a href=&quot;http://www2.research.att.com/~bs/bs_faq2.html#undefined&quot;&gt;Stroustrup博士的回答&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="13d01a83f882b45a7b8274361567d50862b09497" translate="yes" xml:space="preserve">
          <source>The effect of attempting to modify a string literal is undefined.</source>
          <target state="translated">试图修改字符串字段的效果是未定义的。</target>
        </trans-unit>
        <trans-unit id="8d8507b91d1b68503fc0556c8b0fc10ce87230ca" translate="yes" xml:space="preserve">
          <source>The language doesn't specify the evaluation, left to right or right to left! So an unspecified behavior may or mayn't result in an undefined behavior, but certainly your program should not produce an unspecified behavior.</source>
          <target state="translated">语言中没有指定评价,从左到右或者从右到左! 所以,一个未指定的行为可能会导致一个未定义的行为,也可能不会导致一个未定义的行为,但当然你的程序不应该产生一个未指定的行为。</target>
        </trans-unit>
        <trans-unit id="03592da1d7f63ec108b81c8b1804b6691b9b3d0d" translate="yes" xml:space="preserve">
          <source>The language says that we have data-types. The compiler vendors specify what sizes shall they use, and provide a documentation of what they did.</source>
          <target state="translated">语言上说,我们有数据类型。编译器厂商要说明他们应该使用什么尺寸,并提供他们所做的文件。</target>
        </trans-unit>
        <trans-unit id="3fc47a5be1124c057ad6f2eacce91011ff65e6a4" translate="yes" xml:space="preserve">
          <source>The only difference between Implementation-Defined Behavior and Undefined Behavior is that the former requires that implementations define and document a consistent behavior &lt;em&gt;even in cases where nothing the implementation could possibly do would be useful&lt;/em&gt;.  The dividing line between them is not whether it would generally be useful for implementations to define behaviors (compiler writers should define useful behaviors when practical whether the Standard requires them to or not) but &lt;em&gt;whether there might be implementations where defining a behavior would be simultaneously costly and useless&lt;/em&gt;.  A judgment that such implementations might exist does not in any way, shape, or form, imply any judgment about the usefulness of supporting a defined behavior on other platforms.</source>
          <target state="translated">实现定义行为与未定义行为之间的唯一区别是，前者要求实现定义并记录一致的行为， &lt;em&gt;即使在实现可能无法做的情况下也是如此&lt;/em&gt; 。 它们之间的分界线不是通常是否对实现定义行为有用（无论标准是否要求编译器编写者应在实际可行时定义有用的行为），而是&lt;em&gt;是否可能存在定义行为同时代价高昂的实现而且没用&lt;/em&gt; 。 判断此类实现可能存在的判断，绝不以任何方式，形式或形式暗示对支持其他平台上定义的行为的有用性的任何判断。</target>
        </trans-unit>
        <trans-unit id="8e6faa7e4973d1b2d9160e16d12bcd7f321dc76f" translate="yes" xml:space="preserve">
          <source>The preferred philosophy among some of today's compiler writers, however, would suggest that because &lt;code&gt;v&lt;/code&gt; can only be negative if the program is going to engage in Undefined Behavior, there's no reason to have the program clip the negative range of &lt;code&gt;v&lt;/code&gt;.  Even though left-shifting of negative values used to be supported on every single compiler of significance, and a large amount of existing code relies upon that behavior, modern philosophy would interpret the fact that the Standard says that left-shifting negative values is UB as implying that compiler writers should feel free to ignore that.</source>
          <target state="translated">但是，在当今的一些编译器作者中，首选的哲学认为，由于 &lt;code&gt;v&lt;/code&gt; 仅在程序要进行未定义行为的情况下才可以为负，因此没有理由让程序限制 &lt;code&gt;v&lt;/code&gt; 的负范围。 即使以前每个有意义的编译器都支持负值的左移，并且大量现有代码都依赖于该行为，但是现代哲学仍会解释以下事实：标准将左移负值表示为UB暗示编译器作者应该随意忽略它。</target>
        </trans-unit>
        <trans-unit id="9d036d9e98b9050d932b30c3ad251a8f116fe3fa" translate="yes" xml:space="preserve">
          <source>The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine.</source>
          <target state="translated">本国际标准中的语义描述定义了一个参数化的非确定性抽象机。</target>
        </trans-unit>
        <trans-unit id="19030c219a55b7d14c74fef4b37a31512d06bca0" translate="yes" xml:space="preserve">
          <source>The terms &lt;em&gt;unspecified&lt;/em&gt; behavior, &lt;em&gt;undefined&lt;/em&gt; behavior, and &lt;em&gt;implementation-defined&lt;/em&gt; behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe.  The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard.  Appendix F to the Standard catalogs those behaviors which fall into one of these three categories.</source>
          <target state="translated">术语&lt;em&gt;未指定&lt;/em&gt;行为， &lt;em&gt;未定义&lt;/em&gt;行为和&lt;em&gt;实现定义的&lt;/em&gt;行为用于对编写程序的结果进行分类，这些程序的属性标准不能或不能完全描述。 采用这种分类的目的是允许实现中的某种变化，这使得实现的质量成为市场上的积极力量，并允许某些流行的扩展，而不会消除对本标准一致性的要求。 该标准的附录F列出了属于这三种类别之一的那些行为。</target>
        </trans-unit>
        <trans-unit id="7dab400ceb2afc2f8c18d46d1d68aff6ae94bb2c" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;p&lt;/code&gt; points to the string literal &lt;code&gt;&quot;hello!\n&quot;&lt;/code&gt;, and the two assignments below try to modify that string literal. What does this program do? According to section 2.14.5 paragraph 11 of the C++ standard, it invokes &lt;em&gt;undefined behavior&lt;/em&gt;:</source>
          <target state="translated">变量 &lt;code&gt;p&lt;/code&gt; 指向字符串文字 &lt;code&gt;&quot;hello!\n&quot;&lt;/code&gt; ，下面的两个赋值试图修改该字符串文字。 这个程序做什么？ 根据C ++标准第2.14.5节第11段，它调用&lt;em&gt;未定义的行为&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="b7cebcf19e1557782154ebbd8c8c7d81807ec461" translate="yes" xml:space="preserve">
          <source>Their final summary:</source>
          <target state="translated">他们最后的总结:</target>
        </trans-unit>
        <trans-unit id="c9484df72a4301a0e58a21f280b9f6ef65c82d56" translate="yes" xml:space="preserve">
          <source>To sum up, unspecified behavior is usually something you shouldn't
  worry about, unless your software is required to be portable.
  Conversely, undefined behavior is always undesirable and should never
  occur.</source>
          <target state="translated">总结一下,未定义的行为通常是你不应该担心的,除非你的软件被要求具有可移植性。相反,未定义的行为总是不可取的,不应该出现。</target>
        </trans-unit>
        <trans-unit id="5f0d39b8bae2a64f0cad3be5b95af63211bb7407" translate="yes" xml:space="preserve">
          <source>Undefined, unspecified and implementation-defined behavior</source>
          <target state="translated">未定义、未指定和执行定义的行为</target>
        </trans-unit>
        <trans-unit id="588daf6c4c6ee3a04c3826fd5936ab1a8d2ab32c" translate="yes" xml:space="preserve">
          <source>Undefined-</source>
          <target state="translated">Undefined-</target>
        </trans-unit>
        <trans-unit id="96b97090ac320fedc26b22d09f94f06081349d26" translate="yes" xml:space="preserve">
          <source>Unfortunately, since the mid 1990s compiler writers have started to interpret the lack of behavioral mandates as an judgment that behavioral guarantees aren't worth the cost even in application fields where they're vital, and even on systems where they cost practically nothing.  Instead of treating UB as an invitation to exercise reasonable judgment, compiler writers have started treating it as an excuse &lt;em&gt;not&lt;/em&gt; to do so.</source>
          <target state="translated">不幸的是，自1990年代中期以来，编译器作者就开始将缺乏行为授权解释为一种判断，即即使在至关重要的应用领域，甚至在几乎不花费任何费用的系统上，行为保证也不值得付出代价。 编译器作者没有将UB视为进行合理判断的邀请，而是开始以不这样做为由。</target>
        </trans-unit>
        <trans-unit id="030d71a8247686614320a9edf9e2d1ccd4e8d22b" translate="yes" xml:space="preserve">
          <source>Unspecified -</source>
          <target state="translated">不详 ----</target>
        </trans-unit>
        <trans-unit id="a7708e91a446b4023bb1b77f84bcfd74a92520ac" translate="yes" xml:space="preserve">
          <source>Well, this is basically a straight copy-paste from the standard</source>
          <target state="translated">好吧,这基本上是直接从标准的</target>
        </trans-unit>
        <trans-unit id="87ad9d2884c3adbac2b3aade98d1e68308202232" translate="yes" xml:space="preserve">
          <source>What can you do to avoid running into undefined behavior? Basically, you have to read &lt;a href=&quot;https://stackoverflow.com/questions/388242/&quot;&gt;good C++ books&lt;/a&gt; by authors who know what they're talking about. Screw internet tutorials. Screw bullschildt.</source>
          <target state="translated">您如何避免出现未定义的行为？ 基本上，您必须阅读知道他们在说什么的作者的&lt;a href=&quot;https://stackoverflow.com/questions/388242/&quot;&gt;优秀C ++书籍&lt;/a&gt; 。 螺丝互联网教程。 螺丝废话。</target>
        </trans-unit>
        <trans-unit id="08b722f8a37c3500626a622dbbf668cdcb065041" translate="yes" xml:space="preserve">
          <source>What is undefined behavior in C and C++?  What about unspecified behavior and implementation-defined behavior?  What is the difference between them?</source>
          <target state="translated">什么是C和C++中的未定义行为?未定义行为和实现定义行为是什么?它们之间有什么区别?</target>
        </trans-unit>
        <trans-unit id="d0694b1543421d75294f9e15d7ae60bbe8c4dfec" translate="yes" xml:space="preserve">
          <source>When the program encounters construct that is not defined according to C++ Standard it is allowed to do whatever it wants to do ( maybe send an email to me or maybe send an email to you or maybe ignore the code completely).</source>
          <target state="translated">当程序遇到没有按照C++标准定义的构造时,它可以做任何它想做的事情(也许给我发个邮件,也许给你发个邮件,也许完全无视代码)。</target>
        </trans-unit>
        <trans-unit id="77c0292370d7dde2bb9273762fc4aa0ed7281573" translate="yes" xml:space="preserve">
          <source>Which function of these two is executed first?</source>
          <target state="translated">这两者中的哪个功能是先执行的?</target>
        </trans-unit>
        <trans-unit id="36ed259ac8c492d01bbcc825c13c77a68f563188" translate="yes" xml:space="preserve">
          <source>You are doing something wrong. For example, you have a very large value in an &lt;code&gt;int&lt;/code&gt; that doesn't fit in &lt;code&gt;char&lt;/code&gt;. How do you put that value in &lt;code&gt;char&lt;/code&gt;? actually there is no way! Anything could happen, but the most sensible thing would be to take the first byte of that int and put it in &lt;code&gt;char&lt;/code&gt;. It is just wrong to do that to assign the first byte, but thats what happens under the hood.</source>
          <target state="translated">您做错了。 例如，您在不适合 &lt;code&gt;char&lt;/code&gt; 的 &lt;code&gt;int&lt;/code&gt; 中具有非常大的值。 您如何将这个值放入 &lt;code&gt;char&lt;/code&gt; 中 ？ 其实没有办法！ 可能发生任何事情，但是最明智的做法是将int的第一个字节放在 &lt;code&gt;char&lt;/code&gt; 中 。 分配第一个字节是错误的，但这就是幕后的事情。</target>
        </trans-unit>
        <trans-unit id="f107d231dbf1b031ddde5ed61218906955140fa4" translate="yes" xml:space="preserve">
          <source>a two's-complement implementation would not have to expend any effort
whatsoever to treat the expression &lt;code&gt;v &amp;lt;&amp;lt; pow&lt;/code&gt; as a two's-complement shift
without regard for whether &lt;code&gt;v&lt;/code&gt; was positive or negative.</source>
          <target state="translated">二进制补码实现无需考虑将 &lt;code&gt;v &amp;lt;&amp;lt; pow&lt;/code&gt; 视为二进制补码移位，而无需考虑 &lt;code&gt;v&lt;/code&gt; 是正数还是负数。</target>
        </trans-unit>
        <trans-unit id="b45f1d608a58c018e47110174b4665c9870aed4d" translate="yes" xml:space="preserve">
          <source>behavior for which this International Standard imposes no requirements
  [ Note: Undefined behavior may be expected when this International
  Standard omits any explicit definition of behavior or when a program
  uses an erroneous construct or erroneous data. Permissible undefined
  behavior ranges from ignoring the situation completely with
  unpredictable results, to behaving during translation or program
  execution in a documented manner characteristic of the environment
  (with or without the issuance of a diagnostic message), to terminating
  a translation or execution (with the issuance of a diagnostic
  message). Many erroneous program constructs do not engender undefined
  behavior; they are required to be diagnosed. &amp;mdash; end note ]</source>
          <target state="translated">本国际标准不对其施加任何要求的行为[注：当本国际标准省略行为的任何明确定义或程序使用错误的构造或错误的数据时，可能会出现未定义的行为。 允许的不确定行为的范围从完全忽略具有无法预测结果的情况到在翻译或程序执行过程中以环境特征的书面方式记录的行为（带有或不带有诊断消息）到终止翻译或执行（带有发布）诊断消息）。 许多错误的程序构造不会引起未定义的行为。 他们需要被诊断。 &amp;mdash;尾注]</target>
        </trans-unit>
        <trans-unit id="9724be63aed3070bfa520e88b4fcb6e7eaf4caeb" translate="yes" xml:space="preserve">
          <source>behavior, for a well-formed program construct and correct data, that
  depends on the implementation [ Note: The implementation is not
  required to document which behavior occurs. The range of possible
  behaviors is usually delineated by this International Standard. &amp;mdash; end
  note ]</source>
          <target state="translated">行为，对于格式正确的程序构造和正确数据，取决于实现[注：不需要实现来记录发生哪种行为。 可能的行为范围通常由该国际标准来描述。 &amp;mdash;尾注]</target>
        </trans-unit>
        <trans-unit id="979dc22a1216b408e243d86c25ba9776652b3efb" translate="yes" xml:space="preserve">
          <source>behavior, for a well-formed program construct and correct data, that
  depends on the implementation and that each implementation documents</source>
          <target state="translated">行为,对于一个良好的程序构造和正确的数据来说,这取决于实现,并且每个实现的文件</target>
        </trans-unit>
        <trans-unit id="2f6826c50a9aeeefffb662cd6899c5ec00cf5c96" translate="yes" xml:space="preserve">
          <source>for &lt;code&gt;fun(fun1(), fun2());&lt;/code&gt; isn't the
  behaviour &quot;implementation defined&quot;?
  The compiler has to choose one or the
  other course, after all?</source>
          <target state="translated">对于 &lt;code&gt;fun(fun1(), fun2());&lt;/code&gt; 行为不是&amp;ldquo;实现定义的&amp;rdquo;吗？ 毕竟，编译器必须选择一个或另一个过程？</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
