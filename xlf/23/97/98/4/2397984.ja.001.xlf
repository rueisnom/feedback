<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/2397984">
    <body>
      <group id="2397984">
        <trans-unit id="a8642ac09b8508587e68f1734255bd9f149b636b" translate="yes" xml:space="preserve">
          <source>2
  EXAMPLE An example of unspecified
  behavior is the order in which the
  arguments to a function are evaluated.</source>
          <target state="translated">2 EXAMPLE 不特定の動作の例として、関数の引数が評価される順序があります。</target>
        </trans-unit>
        <trans-unit id="2503f99863d13d5ddf37f8e7ca0aa5dc129bfad7" translate="yes" xml:space="preserve">
          <source>2
  NOTE Possible undefined behavior
  ranges from ignoring the situation
  completely with unpredictable results,
  to behaving during translation or
  program execution in a documented
  manner characteristic of the
  environment (with or without the
  issuance of a diagnostic message), to
  terminating a translation or execution
  (with the issuance of a diagnostic
  message).</source>
          <target state="translated">2 注 定義されていない動作の可能性は、予測不可能な結果を伴う状況を完全に無視することから、環境に特徴的な文書化された方法で翻訳またはプログラム実行中に動作すること(診断メッセージの発行の有無にかかわらず)、翻訳または実行を終了すること(診断メッセージの発行の有無にかかわらず)まで、多岐にわたります。</target>
        </trans-unit>
        <trans-unit id="569b518442a5c00e3f5f269306db32d537693a40" translate="yes" xml:space="preserve">
          <source>2 EXAMPLE An example of
  implementation-defined behavior is the
  propagation of the high-order bit when
  a signed integer is shifted right.</source>
          <target state="translated">2 EXAMPLE 実装定義の動作の例として、符号付き整数を右にシフトしたときの高次ビットの伝搬があります。</target>
        </trans-unit>
        <trans-unit id="55e2cabac9083f31e037fb27d178b197629146d2" translate="yes" xml:space="preserve">
          <source>3 EXAMPLE An example of
  undefined behavior is the behavior on
  integer overflow.</source>
          <target state="translated">3 EXAMPLE 未定義の動作の例として、整数オーバーフロー時の動作があります。</target>
        </trans-unit>
        <trans-unit id="b59dcbb47c1299641d663023ee7e761885c46dec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.devx.com/tips/Tip/12684&quot;&gt;Undefined Behavior vs. Unspecified Behavior&lt;/a&gt; has a short description of it.</source>
          <target state="translated">&lt;a href=&quot;http://www.devx.com/tips/Tip/12684&quot;&gt;未定義の動作と未指定の動作&lt;/a&gt;の簡単な説明があります。</target>
        </trans-unit>
        <trans-unit id="ee0b8c6197fe6b3a5f488da9fd25ff2ee8c6dec7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Implementation-defined&lt;/em&gt; behavior gives an implementor the freedom to choose the appropriate approach, but requires that this choice be explained to the user.  Behaviors designated as implementation-defined are generally those in which a user could make meaningful coding decisions based on the implementation definition.  Implementors should bear in mind this criterion when deciding how extensive an implementation definition ought to be.  As with unspecified behavior, simply failing to translate the source containing the implementation-defined behavior is not an adequate response.</source>
          <target state="translated">&lt;em&gt;実装定義の&lt;/em&gt;動作により、実装者は適切なアプローチを自由に選択できますが、この選択をユーザーに説明する必要があります。 実装定義として指定された動作は、通常、ユーザーが実装定義に基づいて有意義なコーディングを決定できる動作です。 実装者は、実装定義をどの程度拡張する必要があるかを決定するときに、この基準に留意する必要があります。 不特定の動作と同様に、実装で定義された動作を含むソースの翻訳に失敗しただけでは、適切な応答にはなりません。</target>
        </trans-unit>
        <trans-unit id="8599642070272d1f3aa7633ea08cf86c0b0f359d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Undefined behavior&lt;/em&gt; gives the implementor license not to catch certain program errors that are difficult to diagnose.  It also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior.</source>
          <target state="translated">&lt;em&gt;未定義の動作&lt;/em&gt;は、診断が困難な特定のプログラムエラーを検出しないように実装者にライセンスを与えます。 また、準拠する可能性のある言語拡張の領域も識別します。実装者は、公式に定義されていない動作の定義を提供することにより、言語を拡張できます。</target>
        </trans-unit>
        <trans-unit id="7ee702ce983e09f9c8a606b57e09c396752f1074" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Unspecified behavior&lt;/em&gt; gives the implementor some latitude in translating programs.  This latitude does not extend as far as failing to translate the program.</source>
          <target state="translated">&lt;em&gt;不特定の動作&lt;/em&gt;は、プログラムを翻訳する際に実装者にある程度の自由度を与えます。 この寛容度は、プログラムの翻訳に失敗した場合には及びません。</target>
        </trans-unit>
        <trans-unit id="cad8f14462d2da2f559db18ca6a3eab49739a99c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.1&lt;/strong&gt; 1 &lt;strong&gt;implementation-defined behavior&lt;/strong&gt; unspecified behavior where
  each implementation documents how the
  choice is made</source>
          <target state="translated">&lt;strong&gt;3.4.1&lt;/strong&gt; 1 &lt;strong&gt;実装で定義された動作の&lt;/strong&gt;不特定の動作。各実装では、選択方法が文書化されています。</target>
        </trans-unit>
        <trans-unit id="9de03b72d558df568e7926b9e71adf72c5a06b64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.3&lt;/strong&gt; 1 &lt;strong&gt;undefined behavior&lt;/strong&gt; behavior, upon use of a nonportable or erroneous
  program construct or of erroneous
  data, for which this International
  Standard imposes no requirements</source>
          <target state="translated">&lt;strong&gt;3.4.3&lt;/strong&gt; 1この国際標準が要件を課さない、移植不能またはエラーのあるプログラム構造またはエラーのあるデータの使用時の&lt;strong&gt;未定義の動作&lt;/strong&gt;動作</target>
        </trans-unit>
        <trans-unit id="3dd4f6dcab8bfd6801d918b5e9fcc7e33a661ccd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.4&lt;/strong&gt; 1 &lt;strong&gt;unspecified behavior&lt;/strong&gt; use of an unspecified value, or other behavior
  where this International Standard
  provides two or more possibilities and
  imposes no further requirements on
  which is chosen in any instance</source>
          <target state="translated">&lt;strong&gt;3.4.4&lt;/strong&gt; 1 &lt;strong&gt;不特定の動作&lt;/strong&gt;不特定の値の使用、またはこの国際規格が2つ以上の可能性を提供し、どのインスタンスでも選択されるものにそれ以上の要件を課さないその他の動作</target>
        </trans-unit>
        <trans-unit id="aeac9f01453e8d88294f9e02230d16dc104b3874" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Undefined behavior&lt;/em&gt;&lt;/strong&gt; is one of those aspects of the C and C++ language that can be surprising to programmers coming from other languages (other languages try to hide it better). Basically,  it is possible to write C++ programs that do not behave in a predictable way, even though many C++ compilers will not report any errors in the program!</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;未定義の動作&lt;/em&gt;&lt;/strong&gt;は、CおよびC ++言語の側面の1つであり、他の言語から来たプログラマーにとっては驚くべきことです（他の言語はそれをよりうまく隠そうとします）。 基本的に、多くのC ++コンパイラーがプログラムのエラーを報告しない場合でも、予測可能な動作をしないC ++プログラムを作成することは可能です。</target>
        </trans-unit>
        <trans-unit id="89cfb28e2a87f840b0837be96911f5555ef4bc80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;implementation-defined behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;実装定義の動作&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8afce23c6edac06facd82113e916bc887c72ee2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;未定義の動作&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1fbaed2b0330ce88dda9bc280a73badcca5396a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;不特定の行動&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0f50639979e1e6edba80094faabb497356f2481a" translate="yes" xml:space="preserve">
          <source>@eSKay I think your question is worth editing the answer to clarify more :)</source>
          <target state="translated">@eSKay 私はあなたの質問は、より明確にするために答えを編集する価値があると思います :)</target>
        </trans-unit>
        <trans-unit id="4408e31b9c4b1008a8002431961b6a435f55e8db" translate="yes" xml:space="preserve">
          <source>Anything might happen,take care of it.</source>
          <target state="translated">何か起こるかもしれないから、気をつけてね</target>
        </trans-unit>
        <trans-unit id="1e67c5c154cd7cab955ab3f3ec82e33acc7125e0" translate="yes" xml:space="preserve">
          <source>C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen ( &lt;strong&gt;bot not necessary described&lt;/strong&gt;) by particular implementation (version of library). So in the case when no description has been provided it can be difficult to the user to know exactly how will program behave.</source>
          <target state="translated">C ++標準では、特定の動作を一部の構成に課すことはありませんが、代わりに、特定の明確に定義された動作を特定の実装（ライブラリのバージョン）によって選択&lt;strong&gt;する必要がある&lt;/strong&gt; （ &lt;strong&gt;ボットは説明不要&lt;/strong&gt; ）と&lt;strong&gt;述べてい&lt;/strong&gt;ます。 したがって、説明が提供されていない場合、プログラムがどのように動作するかをユーザーが正確に知るのは難しい場合があります。</target>
        </trans-unit>
        <trans-unit id="5455973a5b63faf093a2386058a1346a183e359c" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.10
&lt;strong&gt;implementation-defined behavior&lt;/strong&gt;</source>
          <target state="translated">C ++標準n3337&amp;sect;1.3.10 &lt;strong&gt;実装定義の動作&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83ac5b84b2b1cf0f027707ad4321c678feaebc59" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.24
&lt;strong&gt;undefined behavior&lt;/strong&gt;</source>
          <target state="translated">C ++標準n3337&amp;sect;1.3.24 &lt;strong&gt;未定義の動作&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5d9a1e3f8a889e8dab1de5162f84879e8d623bd" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.25
&lt;strong&gt;unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">C ++標準n3337&amp;sect;1.3.25 &lt;strong&gt;不特定の動作&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c147dafffa7c09aef6daa958cd748ef62ee63c1" translate="yes" xml:space="preserve">
          <source>Certain aspects and operations of the abstract machine are described in this International Standard as &lt;strong&gt;implementation-defined&lt;/strong&gt; (for example, &lt;code&gt;sizeof(int)&lt;/code&gt;). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these respects.</source>
          <target state="translated">抽象マシンの特定の側面と操作は、この国際標準で&lt;strong&gt;実装定義&lt;/strong&gt; （ &lt;code&gt;sizeof(int)&lt;/code&gt; など ）として記述されています。 これらは、抽象マシンのパラメーターを構成します。 各実装には、これらの点での特性と動作を説明するドキュメントが含まれます。</target>
        </trans-unit>
        <trans-unit id="99647a312493a7bc6d385f15f565cff68383c1e9" translate="yes" xml:space="preserve">
          <source>Certain other aspects and operations of the abstract machine are described in this International Standard as &lt;strong&gt;unspecified&lt;/strong&gt; (for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine.</source>
          <target state="translated">抽象マシンの他の特定の側面と操作は、この国際標準では&lt;strong&gt;未指定&lt;/strong&gt;として記述されています（たとえば、関数への引数の評価順序）。 可能な場合、この国際標準は一連の許容可能な動作を定義します。 これらは、抽象マシンの非決定的な側面を定義します。</target>
        </trans-unit>
        <trans-unit id="877fa79cfe0bb2180cea26e2a5734c4880504fb2" translate="yes" xml:space="preserve">
          <source>Certain other operations are described in this International Standard as &lt;strong&gt;undefined&lt;/strong&gt; (for example, the  effect of dereferencing the null pointer). [ &lt;em&gt;Note&lt;/em&gt;: &lt;strong&gt;this International Standard imposes no requirements on the behavior of programs that contain undefined behavior.&lt;/strong&gt; &amp;mdash;&lt;em&gt;end note&lt;/em&gt; ]</source>
          <target state="translated">他の特定の操作は、この国際標準では&lt;strong&gt;未定義&lt;/strong&gt;として記述されて&lt;strong&gt;います&lt;/strong&gt; （たとえば、nullポインターの逆参照の影響）。 [ &lt;em&gt;注&lt;/em&gt; ： &lt;strong&gt;この国際規格は、未定義の動作を含むプログラムの動作に要件を課していません。&lt;/strong&gt; &amp;mdash; &lt;em&gt;エンドノート&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0839b8c0f93bc7215bae8e654ced5403f6f34f98" translate="yes" xml:space="preserve">
          <source>For example, given the following code:</source>
          <target state="translated">例えば、次のようなコードがあるとします。</target>
        </trans-unit>
        <trans-unit id="910feb56caa0b4f4562dfa21c599f9c4fce3aea8" translate="yes" xml:space="preserve">
          <source>From the official C Rationale Document</source>
          <target state="translated">Cの公式根拠資料より</target>
        </trans-unit>
        <trans-unit id="a2257744a12c541b56be26d9e4b425a8900f06cc" translate="yes" xml:space="preserve">
          <source>Historically, both Implementation-Defined Behavior and Undefined Behavior represented situations in which the authors of the Standard expected that people writing quality implementations would use judgment to decide what behavioral guarantees, if any, would be useful for programs in the intended application field running on the intended targets.  The needs of high-end number-crunching code are quite different from those of low-level systems code, and both UB and IDB give compiler writers flexibility to meet those different needs.  Neither category mandates that implementations behave in a way that's useful for any particular purpose, or even for any purpose whatsoever.  Quality implementations that claim to be suitable for a particular purpose, however, should behave in a manner befitting such purpose &lt;em&gt;whether the Standard requires it or not&lt;/em&gt;.</source>
          <target state="translated">歴史的に、実装定義の動作と未定義の動作はどちらも、標準の作成者が品質の実装を作成する人々が判断を使用して、動作保証が存在する場合は、その上で実行される目的のアプリケーションフィールドのプログラムに役立つと判断する状況を表しています。意図されたターゲット。 ハイエンドの数値処理コードのニーズは、低レベルのシステムコードのニーズとはかなり異なります。UBとIDBの両方が、それらの異なるニーズを満たす柔軟性をコンパイラー作成者に提供します。 どちらのカテゴリも、実装が特定の目的に役立つ方法で、またはどのような目的でも役立つように動作することを義務付けていません。 ただし、特定の目的に適していると主張する品質の実装は&lt;em&gt;、規格が要求するかどうかにかかわらず、&lt;/em&gt;そのような目的に適した方法で動作する&lt;em&gt;必要があり&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="2540f81c26e6466020aee474b4a78829aae36435" translate="yes" xml:space="preserve">
          <source>I can hear people screaming &quot;But wait, I can compile this no problem and get the output &lt;code&gt;yellow&lt;/code&gt;&quot; or &quot;What do you mean undefined, string literals are stored in read-only memory, so the first assignment attempt results in a core dump&quot;. This is exactly the problem with undefined behavior. Basically, the standard allows anything to happen once you invoke undefined behavior (even nasal demons). If there is a &quot;correct&quot; behavior according to your mental model of the language, that model is simply wrong; The C++ standard has the only vote, period.</source>
          <target state="translated">「でも待って、これで問題なくコンパイルして出力を &lt;code&gt;yellow&lt;/code&gt; にできます」または「未定義の文字列リテラルが読み取り専用メモリに保存されているため、最初の割り当てを試行するとコアダンプが発生します」という叫び声が聞こえる。 これは、未定義の動作の問題です。 基本的に、標準では、未定義の動作（たとえ鼻の悪魔であっても）を呼び出すと、何でも起こることを許可します。 言語のメンタルモデルに従って「正しい」動作がある場合、そのモデルは単に間違っています。 C ++標準には唯一の投票期間があります。</target>
        </trans-unit>
        <trans-unit id="d3cbfc77c16c8f8fe13215121e443b68e0af440a" translate="yes" xml:space="preserve">
          <source>IMO far too many &quot;things&quot; are left
  undefined, unspecified,
  implementation-defined, etc. However,
  that's easy to say and even to give
  examples of, but hard to fix. It
  should also be noted that it is not
  all that difficult to avoid most of
  the problems and produce portable
  code.</source>
          <target state="translated">IMOでは、あまりにも多くの「もの」が未定義のままにされていたり、特定されていなかったり、実装が定義されていなかったりします。しかし、それは言うのは簡単で、例を挙げるのは簡単ですが、修正するのは困難です。また、ほとんどの問題を回避して移植性の高いコードを作成することは、それほど難しいことではないことにも注意が必要です。</target>
        </trans-unit>
        <trans-unit id="a291455822dc1c54fd3c820d50b04b5689f1956b" translate="yes" xml:space="preserve">
          <source>Implementation defined-</source>
          <target state="translated">実装が定義されています。</target>
        </trans-unit>
        <trans-unit id="f0d8b740f7f9ff893a0572fcc79dd50d8329925f" translate="yes" xml:space="preserve">
          <source>Implementors wish,should be well documented,standard gives choices but sure to compile</source>
          <target state="translated">実装者の希望、よく文書化されるべきである、標準は選択肢を与えるが、コンパイルすることを確認してください。</target>
        </trans-unit>
        <trans-unit id="fd18bf07df2a483e12d5b771dc0b3af5d3a88ea6" translate="yes" xml:space="preserve">
          <source>It is claimed that the difference
  between what can be produced giving
  the compiler this freedom and
  requiring &quot;ordinary left-to-right
  evaluation&quot; can be significant. I'm
  unconvinced, but with innumerable
  compilers &quot;out there&quot; taking advantage
  of the freedom and some people
  passionately defending that freedom, a
  change would be difficult and could
  take decades to penetrate to the
  distant corners of the C and C++
  worlds. I am disappointed that not all
  compilers warn against code such as
  ++i+i++. Similarly, the order of evaluation of arguments is
  unspecified.</source>
          <target state="translated">コンパイラにこの自由を与えた場合と、「通常の左から右への評価」を必要とする場合との間には大きな違いがあると主張されています。私は納得していませんが、無数のコンパイラがこの自由を利用していて、その自由を熱烈に擁護している人たちがいる中で、変更を加えるのは難しく、CやC++の世界の遠い隅々まで浸透するのに何十年もかかるかもしれません。私は、すべてのコンパイラが++i+i++のようなコードに対して警告を出しているわけではないことにがっかりしています。同様に、引数の評価の順序が不明確である。</target>
        </trans-unit>
        <trans-unit id="fdf5bfd499acd8a1d289a719f15515471ac74fca" translate="yes" xml:space="preserve">
          <source>Let's look at a classic example:</source>
          <target state="translated">古典的な例を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="70c706a5f40b3cd3a5d8a17c0d0b0ab9a0ca06a5" translate="yes" xml:space="preserve">
          <source>Maybe easy wording could be easier for understanding than the rigorous definition of the standards.</source>
          <target state="translated">厳格な基準の定義よりも、簡単な言葉遣いの方が理解しやすいのかもしれませんね。</target>
        </trans-unit>
        <trans-unit id="3a745746f33c45b300b6511a474f5f3daaf2664a" translate="yes" xml:space="preserve">
          <source>Other examples of undefined behavior include accessing an array beyond its bounds, &lt;a href=&quot;https://stackoverflow.com/q/2894891&quot;&gt;dereferencing the null pointer&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/q/6441218&quot;&gt;accessing objects after their lifetime ended&lt;/a&gt; or writing &lt;a href=&quot;https://stackoverflow.com/q/949433&quot;&gt;allegedly clever expressions&lt;/a&gt; like &lt;code&gt;i++ + ++i&lt;/code&gt;.</source>
          <target state="translated">未定義の動作の他の例としては、境界を超えた配列へのアクセス&lt;a href=&quot;https://stackoverflow.com/q/2894891&quot;&gt;、nullポインターの逆参照、&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/q/6441218&quot;&gt;存続期間が終了した後のオブジェクトへのアクセス&lt;/a&gt; 、または &lt;code&gt;i++ + ++i&lt;/code&gt; などの&lt;a href=&quot;https://stackoverflow.com/q/949433&quot;&gt;巧妙な式の&lt;/a&gt;書き込みがあります。</target>
        </trans-unit>
        <trans-unit id="319b32ef19056d6a4cc43f23a6017acb86983769" translate="yes" xml:space="preserve">
          <source>Permissible undefined behavior ranges from &lt;strong&gt;ignoring the situation completely with unpredictable results&lt;/strong&gt;, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</source>
          <target state="translated">許容される未定義の動作は、 &lt;strong&gt;予測できない結果&lt;/strong&gt;で&lt;strong&gt;完全に状況&lt;/strong&gt;を&lt;strong&gt;無視すること&lt;/strong&gt;から、環境に特徴的な文書化された方法（診断メッセージの発行の有無にかかわらず）での変換またはプログラムの実行中の動作、変換または実行の終了（発行による）までの範囲です。診断メッセージの）。</target>
        </trans-unit>
        <trans-unit id="f4c7eb67efae2426128053994ca5a87e8f8fc518" translate="yes" xml:space="preserve">
          <source>Same as implementation-defined but not documented</source>
          <target state="translated">実装で定義されているが文書化されていないのと同じ</target>
        </trans-unit>
        <trans-unit id="bfdc4a7a8214fa75e47089f0c3154e682f509bac" translate="yes" xml:space="preserve">
          <source>Section 1.9 of the C++ standard also mentions undefined behavior's two less dangerous brothers, &lt;strong&gt;unspecified behavior&lt;/strong&gt; and &lt;strong&gt;implementation-defined behavior&lt;/strong&gt;:</source>
          <target state="translated">C ++標準のセクション1.9では、未定義の動作の2つの危険性の少ない兄弟、 &lt;strong&gt;未指定の動作&lt;/strong&gt;と&lt;strong&gt;実装定義の動作&lt;/strong&gt;についても触れています。</target>
        </trans-unit>
        <trans-unit id="34669cae5d82e706134e0fee4b3402d81d5ed84b" translate="yes" xml:space="preserve">
          <source>Sometimes C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen and &lt;strong&gt;described&lt;/strong&gt; by particular implementation (version of library). So user can still know exactly how will program behave even though Standard doesn't describe this.</source>
          <target state="translated">C ++標準では、一部の構成に特定の動作を課さない場合がありますが、代わりに、特定の明確に定義された動作を特定の実装（ライブラリのバージョン）で選択して&lt;strong&gt;記述&lt;/strong&gt;する必要があると&lt;strong&gt;述べ&lt;/strong&gt;ています。 したがって、Standardがこれを記述していなくても、ユーザーはプログラムがどのように動作するかを正確に知ることができます。</target>
        </trans-unit>
        <trans-unit id="8adb8ad36deb332dc2e827438bafa13e25c65398" translate="yes" xml:space="preserve">
          <source>Specifically, section 1.3.24 states:</source>
          <target state="translated">具体的には、1.3.24項に記載されています。</target>
        </trans-unit>
        <trans-unit id="db0c3d454e250e7c9214ed030c2b4fe7f4dd68e8" translate="yes" xml:space="preserve">
          <source>The difference between implementation-defined and unspecified, is that the compiler is supposed to pick a behavior in the first case but it doesn't have to in the second case. For example, an implementation must have one and only one definition of &lt;code&gt;sizeof(int)&lt;/code&gt;. So, it can't say that &lt;code&gt;sizeof(int)&lt;/code&gt; is 4 for some portion of the program and 8 for others. Unlike unspecified behavior, where the compiler can say OK I am gonna evaluate these arguments left-to-right and the next function's arguments are evaluated right-to-left. It can happen in the same program, that's why it is called &lt;strong&gt;&lt;em&gt;unspecified&lt;/em&gt;&lt;/strong&gt;. In fact, C++ could have been made easier if some of the unspecified behaviors were specified. Take a look here at &lt;a href=&quot;http://www2.research.att.com/~bs/bs_faq2.html#undefined&quot;&gt;Dr. Stroustrup's answer for that&lt;/a&gt;:</source>
          <target state="translated">実装定義と未指定の違いは、コンパイラは最初のケースでは動作を選択することになっているが、2番目のケースでは動作を選択する必要がないことです。 たとえば、実装には &lt;code&gt;sizeof(int)&lt;/code&gt; の定義が1つだけ必要です。 したがって、 &lt;code&gt;sizeof(int)&lt;/code&gt; がプログラムのある部分では4、他の部分では8であるとは言えません。 コンパイラがOKと言うことができる未指定の動作とは異なり、私はこれらの引数を左から右に評価し、次の関数の引数は右から左に評価されます。 同じプログラムで発生する可能性があるため、 &lt;strong&gt;&lt;em&gt;unspecified&lt;/em&gt;&lt;/strong&gt;と呼ばれています。 実際、未指定の動作の一部が指定されていれば、C ++はより簡単になったかもしれません。 &lt;a href=&quot;http://www2.research.att.com/~bs/bs_faq2.html#undefined&quot;&gt;Stroustrup博士の回答をご覧ください&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="13d01a83f882b45a7b8274361567d50862b09497" translate="yes" xml:space="preserve">
          <source>The effect of attempting to modify a string literal is undefined.</source>
          <target state="translated">文字列リテラルを変更しようとした場合の効果は定義されていません。</target>
        </trans-unit>
        <trans-unit id="8d8507b91d1b68503fc0556c8b0fc10ce87230ca" translate="yes" xml:space="preserve">
          <source>The language doesn't specify the evaluation, left to right or right to left! So an unspecified behavior may or mayn't result in an undefined behavior, but certainly your program should not produce an unspecified behavior.</source>
          <target state="translated">言語は評価を左から右へ、または右から左へと指定していません! そのため、指定されていない動作が未定義の動作になるかもしれませんし、ならないかもしれませんが、確かにあなたのプログラムは指定されていない動作を生成するべきではありません。</target>
        </trans-unit>
        <trans-unit id="03592da1d7f63ec108b81c8b1804b6691b9b3d0d" translate="yes" xml:space="preserve">
          <source>The language says that we have data-types. The compiler vendors specify what sizes shall they use, and provide a documentation of what they did.</source>
          <target state="translated">言語にはデータ型があると書かれています。コンパイラベンダは、どのサイズを使用するかを指定し、それを文書化しています。</target>
        </trans-unit>
        <trans-unit id="3fc47a5be1124c057ad6f2eacce91011ff65e6a4" translate="yes" xml:space="preserve">
          <source>The only difference between Implementation-Defined Behavior and Undefined Behavior is that the former requires that implementations define and document a consistent behavior &lt;em&gt;even in cases where nothing the implementation could possibly do would be useful&lt;/em&gt;.  The dividing line between them is not whether it would generally be useful for implementations to define behaviors (compiler writers should define useful behaviors when practical whether the Standard requires them to or not) but &lt;em&gt;whether there might be implementations where defining a behavior would be simultaneously costly and useless&lt;/em&gt;.  A judgment that such implementations might exist does not in any way, shape, or form, imply any judgment about the usefulness of supporting a defined behavior on other platforms.</source>
          <target state="translated">実装で定義された動作と未定義の動作の唯一の違いは、前者は実装&lt;em&gt;が何も役に立たない可能性がある場合でも、実装で&lt;/em&gt;一貫した動作を定義して文書化する&lt;em&gt;必要があることです&lt;/em&gt; 。 それらの間の境界線は、振る舞いを定義することは実装にとって一般的に有用であるかどうか（コンパイラー作成者は、標準が要求するかどうかにかかわらず、実用的なときに有用な振る舞いを定義する必要があります）ではなく&lt;em&gt;、振る舞いを定義すると同時にコストがかかる実装&lt;/em&gt;がある&lt;em&gt;かどうかですそして役に立たない&lt;/em&gt; 。 そのような実装が存在する可能性があるという判断は、いかなる形でも、形や形ではなく、他のプラットフォームで定義された動作をサポートすることの有用性に関する判断を意味します。</target>
        </trans-unit>
        <trans-unit id="8e6faa7e4973d1b2d9160e16d12bcd7f321dc76f" translate="yes" xml:space="preserve">
          <source>The preferred philosophy among some of today's compiler writers, however, would suggest that because &lt;code&gt;v&lt;/code&gt; can only be negative if the program is going to engage in Undefined Behavior, there's no reason to have the program clip the negative range of &lt;code&gt;v&lt;/code&gt;.  Even though left-shifting of negative values used to be supported on every single compiler of significance, and a large amount of existing code relies upon that behavior, modern philosophy would interpret the fact that the Standard says that left-shifting negative values is UB as implying that compiler writers should feel free to ignore that.</source>
          <target state="translated">ただし、今日のコンパイラライターの一部が好む哲学は、プログラムが未定義の動作に関与する場合にのみ &lt;code&gt;v&lt;/code&gt; が負になる可能性があるため、プログラムに &lt;code&gt;v&lt;/code&gt; の負の範囲をクリップさせる理由はないことを示唆しています。 負の値の左シフトは、すべての重要なコンパイラでサポートされていましたが、既存のコードの多くはその動作に依存していますが、現代の哲学では、左シフトの負の値はUBであると標準が言っているという事実を解釈します。コンパイラの作成者はそれを自由に無視できることを意味します。</target>
        </trans-unit>
        <trans-unit id="9d036d9e98b9050d932b30c3ad251a8f116fe3fa" translate="yes" xml:space="preserve">
          <source>The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine.</source>
          <target state="translated">この国際標準規格の意味的記述は、パラメータ化された非決定論的抽象機械を定義する。</target>
        </trans-unit>
        <trans-unit id="19030c219a55b7d14c74fef4b37a31512d06bca0" translate="yes" xml:space="preserve">
          <source>The terms &lt;em&gt;unspecified&lt;/em&gt; behavior, &lt;em&gt;undefined&lt;/em&gt; behavior, and &lt;em&gt;implementation-defined&lt;/em&gt; behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe.  The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard.  Appendix F to the Standard catalogs those behaviors which fall into one of these three categories.</source>
          <target state="translated">「 &lt;em&gt;不特定の&lt;/em&gt;動作」、「 &lt;em&gt;未定義の&lt;/em&gt;動作」、および「 &lt;em&gt;実装&lt;/em&gt; &lt;em&gt;定義の&lt;/em&gt;動作」という用語は、規格が完全に記述していない、または記述できないプロパティを持つプログラムを記述した結果を分類するために使用されます。 この分類を採用する目的は、実装への特定の多様性を可能にすることであり、実装の品質を市場で積極的に発揮できるようにするとともに、標準への準拠のキャッシュを削除することなく、特定の一般的な拡張を許可することです。 標準の付録Fは、これらの3つのカテゴリのいずれかに該当する動作をカタログ化しています。</target>
        </trans-unit>
        <trans-unit id="7dab400ceb2afc2f8c18d46d1d68aff6ae94bb2c" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;p&lt;/code&gt; points to the string literal &lt;code&gt;&quot;hello!\n&quot;&lt;/code&gt;, and the two assignments below try to modify that string literal. What does this program do? According to section 2.14.5 paragraph 11 of the C++ standard, it invokes &lt;em&gt;undefined behavior&lt;/em&gt;:</source>
          <target state="translated">変数 &lt;code&gt;p&lt;/code&gt; は文字列リテラル &lt;code&gt;&quot;hello!\n&quot;&lt;/code&gt; 指し、以下の2つの割り当てはその文字列リテラルを変更しようとします。 このプログラムは何をしますか？ C ++標準のセクション2.14.5パラグラフ11によれば、 &lt;em&gt;未定義の動作を&lt;/em&gt;呼び出します。</target>
        </trans-unit>
        <trans-unit id="b7cebcf19e1557782154ebbd8c8c7d81807ec461" translate="yes" xml:space="preserve">
          <source>Their final summary:</source>
          <target state="translated">彼らの最終的なまとめ。</target>
        </trans-unit>
        <trans-unit id="c9484df72a4301a0e58a21f280b9f6ef65c82d56" translate="yes" xml:space="preserve">
          <source>To sum up, unspecified behavior is usually something you shouldn't
  worry about, unless your software is required to be portable.
  Conversely, undefined behavior is always undesirable and should never
  occur.</source>
          <target state="translated">要約すると、ソフトウェアの移植性が要求されない限り、未定義の動作は通常、心配するべきものではありません。逆に、未定義の動作は常に望ましくないものであり、決して起こるべきではありません。</target>
        </trans-unit>
        <trans-unit id="5f0d39b8bae2a64f0cad3be5b95af63211bb7407" translate="yes" xml:space="preserve">
          <source>Undefined, unspecified and implementation-defined behavior</source>
          <target state="translated">未定義、未指定、実装定義の動作</target>
        </trans-unit>
        <trans-unit id="588daf6c4c6ee3a04c3826fd5936ab1a8d2ab32c" translate="yes" xml:space="preserve">
          <source>Undefined-</source>
          <target state="translated">Undefined-</target>
        </trans-unit>
        <trans-unit id="96b97090ac320fedc26b22d09f94f06081349d26" translate="yes" xml:space="preserve">
          <source>Unfortunately, since the mid 1990s compiler writers have started to interpret the lack of behavioral mandates as an judgment that behavioral guarantees aren't worth the cost even in application fields where they're vital, and even on systems where they cost practically nothing.  Instead of treating UB as an invitation to exercise reasonable judgment, compiler writers have started treating it as an excuse &lt;em&gt;not&lt;/em&gt; to do so.</source>
          <target state="translated">残念なことに、1990年代半ば以降、コンパイラの作成者は、動作要件の欠如を、動作保証が重要であるアプリケーション分野でも、実質的にコストがかからないシステムでも、コストに見合わないとの判断として解釈し始めました。 UBを合理的な判断を行うための招待状として扱う代わりに、コンパイラー作成者は、UBをそうし&lt;em&gt;ない&lt;/em&gt;言い訳として扱い始めました。</target>
        </trans-unit>
        <trans-unit id="030d71a8247686614320a9edf9e2d1ccd4e8d22b" translate="yes" xml:space="preserve">
          <source>Unspecified -</source>
          <target state="translated">不特定</target>
        </trans-unit>
        <trans-unit id="a7708e91a446b4023bb1b77f84bcfd74a92520ac" translate="yes" xml:space="preserve">
          <source>Well, this is basically a straight copy-paste from the standard</source>
          <target state="translated">まあ、これは基本的には標準の</target>
        </trans-unit>
        <trans-unit id="87ad9d2884c3adbac2b3aade98d1e68308202232" translate="yes" xml:space="preserve">
          <source>What can you do to avoid running into undefined behavior? Basically, you have to read &lt;a href=&quot;https://stackoverflow.com/questions/388242/&quot;&gt;good C++ books&lt;/a&gt; by authors who know what they're talking about. Screw internet tutorials. Screw bullschildt.</source>
          <target state="translated">未定義の動作に遭遇しないようにするにはどうすればよいですか？ 基本的に、あなたは彼らが何について話しているかを知っている作家による&lt;a href=&quot;https://stackoverflow.com/questions/388242/&quot;&gt;良いC ++の本&lt;/a&gt;を読む必要があります。 インターネットのチュートリアルをねじ込みます。 ネジのブルシルト。</target>
        </trans-unit>
        <trans-unit id="08b722f8a37c3500626a622dbbf668cdcb065041" translate="yes" xml:space="preserve">
          <source>What is undefined behavior in C and C++?  What about unspecified behavior and implementation-defined behavior?  What is the difference between them?</source>
          <target state="translated">CやC++での未定義動作とは?未定義動作と実装定義動作とは?両者の違いは何ですか?</target>
        </trans-unit>
        <trans-unit id="d0694b1543421d75294f9e15d7ae60bbe8c4dfec" translate="yes" xml:space="preserve">
          <source>When the program encounters construct that is not defined according to C++ Standard it is allowed to do whatever it wants to do ( maybe send an email to me or maybe send an email to you or maybe ignore the code completely).</source>
          <target state="translated">C++標準では定義されていない構造体に遭遇した場合、プログラムは何をしてもいいことになっています(私にメールを送ってもいいし、あなたにメールを送ってもいいし、コードを完全に無視してもいい)。</target>
        </trans-unit>
        <trans-unit id="77c0292370d7dde2bb9273762fc4aa0ed7281573" translate="yes" xml:space="preserve">
          <source>Which function of these two is executed first?</source>
          <target state="translated">この2つのうち、どちらの関数が先に実行されるか?</target>
        </trans-unit>
        <trans-unit id="36ed259ac8c492d01bbcc825c13c77a68f563188" translate="yes" xml:space="preserve">
          <source>You are doing something wrong. For example, you have a very large value in an &lt;code&gt;int&lt;/code&gt; that doesn't fit in &lt;code&gt;char&lt;/code&gt;. How do you put that value in &lt;code&gt;char&lt;/code&gt;? actually there is no way! Anything could happen, but the most sensible thing would be to take the first byte of that int and put it in &lt;code&gt;char&lt;/code&gt;. It is just wrong to do that to assign the first byte, but thats what happens under the hood.</source>
          <target state="translated">あなたは何か間違ったことをしています。 たとえば、 &lt;code&gt;char&lt;/code&gt; に収まらない &lt;code&gt;int&lt;/code&gt; に非常に大きな値があるとします。 どのようにその値を &lt;code&gt;char&lt;/code&gt; に入れますか？ 実際には方法はありません！ 何かが起こる可能性がありますが、最も賢明なことは、そのintの最初のバイトを取得して &lt;code&gt;char&lt;/code&gt; に入れることです。 最初のバイトを割り当てるためにそれを行うのは間違っていますが、それは内部で起こることです。</target>
        </trans-unit>
        <trans-unit id="f107d231dbf1b031ddde5ed61218906955140fa4" translate="yes" xml:space="preserve">
          <source>a two's-complement implementation would not have to expend any effort
whatsoever to treat the expression &lt;code&gt;v &amp;lt;&amp;lt; pow&lt;/code&gt; as a two's-complement shift
without regard for whether &lt;code&gt;v&lt;/code&gt; was positive or negative.</source>
          <target state="translated">2の補数の実装では、 &lt;code&gt;v&lt;/code&gt; が正であるか負であるかに関係なく、式 &lt;code&gt;v &amp;lt;&amp;lt; pow&lt;/code&gt; を2の補数シフトとして扱うために労力を費やす必要はありません。</target>
        </trans-unit>
        <trans-unit id="b45f1d608a58c018e47110174b4665c9870aed4d" translate="yes" xml:space="preserve">
          <source>behavior for which this International Standard imposes no requirements
  [ Note: Undefined behavior may be expected when this International
  Standard omits any explicit definition of behavior or when a program
  uses an erroneous construct or erroneous data. Permissible undefined
  behavior ranges from ignoring the situation completely with
  unpredictable results, to behaving during translation or program
  execution in a documented manner characteristic of the environment
  (with or without the issuance of a diagnostic message), to terminating
  a translation or execution (with the issuance of a diagnostic
  message). Many erroneous program constructs do not engender undefined
  behavior; they are required to be diagnosed. &amp;mdash; end note ]</source>
          <target state="translated">この国際標準が要件を課さない動作[注：この国際標準が動作の明示的な定義を省略した場合、またはプログラムが誤った構成体または誤ったデータを使用した場合、未定義の動作が予期される可能性があります。 許容される未定義の動作は、予測できない結果で完全に状況を無視することから、環境に特徴的な文書化された方法で（診断メッセージの発行の有無にかかわらず）変換またはプログラムの実行中に動作すること、変換または実行を終了すること（発行を伴う）までさまざまです。診断メッセージの）。 エラーのあるプログラム構造の多くは、未定義の動作を引き起こしません。 診断する必要があります。 &amp;mdash;エンドノート]</target>
        </trans-unit>
        <trans-unit id="9724be63aed3070bfa520e88b4fcb6e7eaf4caeb" translate="yes" xml:space="preserve">
          <source>behavior, for a well-formed program construct and correct data, that
  depends on the implementation [ Note: The implementation is not
  required to document which behavior occurs. The range of possible
  behaviors is usually delineated by this International Standard. &amp;mdash; end
  note ]</source>
          <target state="translated">動作に依存する、整形式プログラム構造と正しいデータの動作[注：実装は、どの動作が発生するかを文書化する必要はありません。 通常、考えられる動作の範囲は、この国際標準で規定されています。 &amp;mdash;エンドノート]</target>
        </trans-unit>
        <trans-unit id="979dc22a1216b408e243d86c25ba9776652b3efb" translate="yes" xml:space="preserve">
          <source>behavior, for a well-formed program construct and correct data, that
  depends on the implementation and that each implementation documents</source>
          <target state="translated">実装に依存し、各実装が文書化する、よくできたプログラム構成と正しいデータのための振る舞い</target>
        </trans-unit>
        <trans-unit id="2f6826c50a9aeeefffb662cd6899c5ec00cf5c96" translate="yes" xml:space="preserve">
          <source>for &lt;code&gt;fun(fun1(), fun2());&lt;/code&gt; isn't the
  behaviour &quot;implementation defined&quot;?
  The compiler has to choose one or the
  other course, after all?</source>
          <target state="translated">for &lt;code&gt;fun(fun1(), fun2());&lt;/code&gt; 動作は「実装定義」ではないのですか 結局のところ、コンパイラはどちらか一方のコースを選択する必要がありますか？</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
