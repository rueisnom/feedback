<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/2397984">
    <body>
      <group id="2397984">
        <trans-unit id="a8642ac09b8508587e68f1734255bd9f149b636b" translate="yes" xml:space="preserve">
          <source>2
  EXAMPLE An example of unspecified
  behavior is the order in which the
  arguments to a function are evaluated.</source>
          <target state="translated">2 EJEMPLO Un ejemplo de comportamiento no especificado es el orden en que se evalúan los argumentos de una función.</target>
        </trans-unit>
        <trans-unit id="2503f99863d13d5ddf37f8e7ca0aa5dc129bfad7" translate="yes" xml:space="preserve">
          <source>2
  NOTE Possible undefined behavior
  ranges from ignoring the situation
  completely with unpredictable results,
  to behaving during translation or
  program execution in a documented
  manner characteristic of the
  environment (with or without the
  issuance of a diagnostic message), to
  terminating a translation or execution
  (with the issuance of a diagnostic
  message).</source>
          <target state="translated">2 NOTA El posible comportamiento indefinido va desde ignorar completamente la situación con resultados impredecibles,hasta comportarse durante la traducción o la ejecución del programa de manera documentada y característica del entorno (con o sin la emisión de un mensaje de diagnóstico).</target>
        </trans-unit>
        <trans-unit id="569b518442a5c00e3f5f269306db32d537693a40" translate="yes" xml:space="preserve">
          <source>2 EXAMPLE An example of
  implementation-defined behavior is the
  propagation of the high-order bit when
  a signed integer is shifted right.</source>
          <target state="translated">2 EJEMPLO Un ejemplo de comportamiento definido por la implementación es la propagación del bit de alto orden cuando un entero con signo se desplaza a la derecha.</target>
        </trans-unit>
        <trans-unit id="55e2cabac9083f31e037fb27d178b197629146d2" translate="yes" xml:space="preserve">
          <source>3 EXAMPLE An example of
  undefined behavior is the behavior on
  integer overflow.</source>
          <target state="translated">3 EJEMPLO Un ejemplo de comportamiento indefinido es el comportamiento en el desbordamiento de números enteros.</target>
        </trans-unit>
        <trans-unit id="b59dcbb47c1299641d663023ee7e761885c46dec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.devx.com/tips/Tip/12684&quot;&gt;Undefined Behavior vs. Unspecified Behavior&lt;/a&gt; has a short description of it.</source>
          <target state="translated">&lt;a href=&quot;http://www.devx.com/tips/Tip/12684&quot;&gt;Comportamiento indefinido vs. Comportamiento no especificado&lt;/a&gt; tiene una breve descripci&amp;oacute;n del mismo.</target>
        </trans-unit>
        <trans-unit id="ee0b8c6197fe6b3a5f488da9fd25ff2ee8c6dec7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Implementation-defined&lt;/em&gt; behavior gives an implementor the freedom to choose the appropriate approach, but requires that this choice be explained to the user.  Behaviors designated as implementation-defined are generally those in which a user could make meaningful coding decisions based on the implementation definition.  Implementors should bear in mind this criterion when deciding how extensive an implementation definition ought to be.  As with unspecified behavior, simply failing to translate the source containing the implementation-defined behavior is not an adequate response.</source>
          <target state="translated">&lt;em&gt;El&lt;/em&gt; comportamiento &lt;em&gt;definido por&lt;/em&gt; la implementaci&amp;oacute;n le da al implementador la libertad de elegir el enfoque apropiado, pero requiere que se explique esta opci&amp;oacute;n al usuario. Los comportamientos designados como definidos por la implementaci&amp;oacute;n son generalmente aquellos en los que un usuario podr&amp;iacute;a tomar decisiones de codificaci&amp;oacute;n significativas basadas en la definici&amp;oacute;n de implementaci&amp;oacute;n. Los implementadores deben tener en cuenta este criterio al decidir qu&amp;eacute; tan extensa debe ser una definici&amp;oacute;n de implementaci&amp;oacute;n. Al igual que con el comportamiento no especificado, simplemente no traducir la fuente que contiene el comportamiento definido por la implementaci&amp;oacute;n no es una respuesta adecuada.</target>
        </trans-unit>
        <trans-unit id="8599642070272d1f3aa7633ea08cf86c0b0f359d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Undefined behavior&lt;/em&gt; gives the implementor license not to catch certain program errors that are difficult to diagnose.  It also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior.</source>
          <target state="translated">&lt;em&gt;El comportamiento indefinido&lt;/em&gt; otorga al implementador la licencia para no detectar ciertos errores del programa que son dif&amp;iacute;ciles de diagnosticar. Tambi&amp;eacute;n identifica &amp;aacute;reas de posible extensi&amp;oacute;n de lenguaje conforme: el implementador puede aumentar el lenguaje al proporcionar una definici&amp;oacute;n del comportamiento oficialmente indefinido.</target>
        </trans-unit>
        <trans-unit id="7ee702ce983e09f9c8a606b57e09c396752f1074" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Unspecified behavior&lt;/em&gt; gives the implementor some latitude in translating programs.  This latitude does not extend as far as failing to translate the program.</source>
          <target state="translated">&lt;em&gt;El comportamiento no especificado&lt;/em&gt; le da al implementador cierta libertad para traducir programas. Esta latitud no se extiende hasta no poder traducir el programa.</target>
        </trans-unit>
        <trans-unit id="cad8f14462d2da2f559db18ca6a3eab49739a99c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.1&lt;/strong&gt; 1 &lt;strong&gt;implementation-defined behavior&lt;/strong&gt; unspecified behavior where
  each implementation documents how the
  choice is made</source>
          <target state="translated">&lt;strong&gt;3.4.1&lt;/strong&gt; 1 &lt;strong&gt;comportamiento definido por la implementaci&amp;oacute;n comportamiento&lt;/strong&gt; no especificado donde cada implementaci&amp;oacute;n documenta c&amp;oacute;mo se hace la elecci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="9de03b72d558df568e7926b9e71adf72c5a06b64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.3&lt;/strong&gt; 1 &lt;strong&gt;undefined behavior&lt;/strong&gt; behavior, upon use of a nonportable or erroneous
  program construct or of erroneous
  data, for which this International
  Standard imposes no requirements</source>
          <target state="translated">&lt;strong&gt;3.4.3&lt;/strong&gt; 1 &lt;strong&gt;comportamiento de&lt;/strong&gt; comportamiento &lt;strong&gt;indefinido&lt;/strong&gt; , al usar una construcci&amp;oacute;n de programa no portable o err&amp;oacute;nea o de datos err&amp;oacute;neos, para los cuales esta Norma Internacional no impone requisitos</target>
        </trans-unit>
        <trans-unit id="3dd4f6dcab8bfd6801d918b5e9fcc7e33a661ccd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.4&lt;/strong&gt; 1 &lt;strong&gt;unspecified behavior&lt;/strong&gt; use of an unspecified value, or other behavior
  where this International Standard
  provides two or more possibilities and
  imposes no further requirements on
  which is chosen in any instance</source>
          <target state="translated">&lt;strong&gt;3.4.4&lt;/strong&gt; 1 &lt;strong&gt;comportamiento no especificado&lt;/strong&gt; uso de un valor no especificado u otro comportamiento donde esta Norma Internacional ofrece dos o m&amp;aacute;s posibilidades y no impone requisitos adicionales sobre los cuales se elige en ning&amp;uacute;n caso</target>
        </trans-unit>
        <trans-unit id="aeac9f01453e8d88294f9e02230d16dc104b3874" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Undefined behavior&lt;/em&gt;&lt;/strong&gt; is one of those aspects of the C and C++ language that can be surprising to programmers coming from other languages (other languages try to hide it better). Basically,  it is possible to write C++ programs that do not behave in a predictable way, even though many C++ compilers will not report any errors in the program!</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;El comportamiento indefinido&lt;/em&gt;&lt;/strong&gt; es uno de esos aspectos del lenguaje C y C ++ que puede sorprender a los programadores que vienen de otros lenguajes (otros lenguajes intentan ocultarlo mejor). B&amp;aacute;sicamente, es posible escribir programas de C ++ que no se comporten de una manera predecible, &amp;iexcl;aunque muchos compiladores de C ++ no informar&amp;aacute;n ning&amp;uacute;n error en el programa!</target>
        </trans-unit>
        <trans-unit id="89cfb28e2a87f840b0837be96911f5555ef4bc80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;implementation-defined behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;comportamiento definido por la implementaci&amp;oacute;n&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8afce23c6edac06facd82113e916bc887c72ee2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;comportamiento indefinido&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1fbaed2b0330ce88dda9bc280a73badcca5396a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;comportamiento no especificado&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0f50639979e1e6edba80094faabb497356f2481a" translate="yes" xml:space="preserve">
          <source>@eSKay I think your question is worth editing the answer to clarify more :)</source>
          <target state="translated">@eSKay creo que vale la pena editar la respuesta para aclarar más :)</target>
        </trans-unit>
        <trans-unit id="4408e31b9c4b1008a8002431961b6a435f55e8db" translate="yes" xml:space="preserve">
          <source>Anything might happen,take care of it.</source>
          <target state="translated">Cualquier cosa que pueda pasar,ocúpate de ello.</target>
        </trans-unit>
        <trans-unit id="1e67c5c154cd7cab955ab3f3ec82e33acc7125e0" translate="yes" xml:space="preserve">
          <source>C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen ( &lt;strong&gt;bot not necessary described&lt;/strong&gt;) by particular implementation (version of library). So in the case when no description has been provided it can be difficult to the user to know exactly how will program behave.</source>
          <target state="translated">C ++ Standard no impone un comportamiento particular en algunas construcciones, sino que dice que se debe elegir un comportamiento particular bien definido ( &lt;strong&gt;no se describe necesariamente el bot&lt;/strong&gt; ) mediante una implementaci&amp;oacute;n particular (versi&amp;oacute;n de la biblioteca). Entonces, en el caso de que no se haya proporcionado una descripci&amp;oacute;n, puede ser dif&amp;iacute;cil para el usuario saber exactamente c&amp;oacute;mo se comportar&amp;aacute; el programa.</target>
        </trans-unit>
        <trans-unit id="5455973a5b63faf093a2386058a1346a183e359c" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.10
&lt;strong&gt;implementation-defined behavior&lt;/strong&gt;</source>
          <target state="translated">C ++ est&amp;aacute;ndar n3337 &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.10 &lt;strong&gt;comportamiento definido por la implementaci&amp;oacute;n&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83ac5b84b2b1cf0f027707ad4321c678feaebc59" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.24
&lt;strong&gt;undefined behavior&lt;/strong&gt;</source>
          <target state="translated">C ++ est&amp;aacute;ndar n3337 &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.24 &lt;strong&gt;comportamiento indefinido&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5d9a1e3f8a889e8dab1de5162f84879e8d623bd" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.25
&lt;strong&gt;unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">C ++ est&amp;aacute;ndar n3337 &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.25 &lt;strong&gt;comportamiento no especificado&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c147dafffa7c09aef6daa958cd748ef62ee63c1" translate="yes" xml:space="preserve">
          <source>Certain aspects and operations of the abstract machine are described in this International Standard as &lt;strong&gt;implementation-defined&lt;/strong&gt; (for example, &lt;code&gt;sizeof(int)&lt;/code&gt;). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these respects.</source>
          <target state="translated">Ciertos aspectos y operaciones de la m&amp;aacute;quina abstracta se describen en esta Norma Internacional como &lt;strong&gt;definidos&lt;/strong&gt; por la &lt;strong&gt;implementaci&amp;oacute;n&lt;/strong&gt; (por ejemplo, &lt;code&gt;sizeof(int)&lt;/code&gt; ). Estos constituyen los par&amp;aacute;metros de la m&amp;aacute;quina abstracta. Cada implementaci&amp;oacute;n debe incluir documentaci&amp;oacute;n que describa sus caracter&amp;iacute;sticas y comportamiento en estos aspectos.</target>
        </trans-unit>
        <trans-unit id="99647a312493a7bc6d385f15f565cff68383c1e9" translate="yes" xml:space="preserve">
          <source>Certain other aspects and operations of the abstract machine are described in this International Standard as &lt;strong&gt;unspecified&lt;/strong&gt; (for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine.</source>
          <target state="translated">Ciertos otros aspectos y operaciones de la m&amp;aacute;quina abstracta se describen en esta Norma Internacional como &lt;strong&gt;no especificados&lt;/strong&gt; (por ejemplo, el orden de evaluaci&amp;oacute;n de los argumentos de una funci&amp;oacute;n). Siempre que sea posible, esta Norma Internacional define un conjunto de comportamientos permitidos. Estos definen los aspectos no deterministas de la m&amp;aacute;quina abstracta.</target>
        </trans-unit>
        <trans-unit id="877fa79cfe0bb2180cea26e2a5734c4880504fb2" translate="yes" xml:space="preserve">
          <source>Certain other operations are described in this International Standard as &lt;strong&gt;undefined&lt;/strong&gt; (for example, the  effect of dereferencing the null pointer). [ &lt;em&gt;Note&lt;/em&gt;: &lt;strong&gt;this International Standard imposes no requirements on the behavior of programs that contain undefined behavior.&lt;/strong&gt; &amp;mdash;&lt;em&gt;end note&lt;/em&gt; ]</source>
          <target state="translated">Algunas otras operaciones se describen en esta Norma Internacional como &lt;strong&gt;indefinidas&lt;/strong&gt; (por ejemplo, el efecto de desreferenciar el puntero nulo). [ &lt;em&gt;Nota&lt;/em&gt; : &lt;strong&gt;esta Norma Internacional no impone requisitos sobre el comportamiento de los programas que contienen un comportamiento indefinido.&lt;/strong&gt; - &lt;em&gt;nota final&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0839b8c0f93bc7215bae8e654ced5403f6f34f98" translate="yes" xml:space="preserve">
          <source>For example, given the following code:</source>
          <target state="translated">Por ejemplo,dado el siguiente código:</target>
        </trans-unit>
        <trans-unit id="910feb56caa0b4f4562dfa21c599f9c4fce3aea8" translate="yes" xml:space="preserve">
          <source>From the official C Rationale Document</source>
          <target state="translated">Del documento oficial de justificación C</target>
        </trans-unit>
        <trans-unit id="a2257744a12c541b56be26d9e4b425a8900f06cc" translate="yes" xml:space="preserve">
          <source>Historically, both Implementation-Defined Behavior and Undefined Behavior represented situations in which the authors of the Standard expected that people writing quality implementations would use judgment to decide what behavioral guarantees, if any, would be useful for programs in the intended application field running on the intended targets.  The needs of high-end number-crunching code are quite different from those of low-level systems code, and both UB and IDB give compiler writers flexibility to meet those different needs.  Neither category mandates that implementations behave in a way that's useful for any particular purpose, or even for any purpose whatsoever.  Quality implementations that claim to be suitable for a particular purpose, however, should behave in a manner befitting such purpose &lt;em&gt;whether the Standard requires it or not&lt;/em&gt;.</source>
          <target state="translated">Hist&amp;oacute;ricamente, tanto el Comportamiento definido por la implementaci&amp;oacute;n como el Comportamiento indefinido representaban situaciones en las que los autores de la Norma esperaban que las personas que escriben implementaciones de calidad usar&amp;iacute;an el juicio para decidir qu&amp;eacute; garant&amp;iacute;as de comportamiento, si las hubiera, ser&amp;iacute;an &amp;uacute;tiles para los programas en el campo de aplicaci&amp;oacute;n previsto que se ejecuta en el objetivos previstos. Las necesidades del c&amp;oacute;digo de procesamiento de n&amp;uacute;meros de gama alta son bastante diferentes de las del c&amp;oacute;digo de sistemas de bajo nivel, y tanto UB como IDB brindan flexibilidad a los escritores de compiladores para satisfacer esas diferentes necesidades. Ninguna de las categor&amp;iacute;as exige que las implementaciones se comporten de una manera que sea &amp;uacute;til para un prop&amp;oacute;sito en particular, o incluso para cualquier prop&amp;oacute;sito. Sin embargo, las implementaciones de calidad que afirman ser adecuadas para un prop&amp;oacute;sito particular, deben comportarse de una manera adecuada a tal prop&amp;oacute;sito, &lt;em&gt;ya sea que el Est&amp;aacute;ndar lo requiera o no&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2540f81c26e6466020aee474b4a78829aae36435" translate="yes" xml:space="preserve">
          <source>I can hear people screaming &quot;But wait, I can compile this no problem and get the output &lt;code&gt;yellow&lt;/code&gt;&quot; or &quot;What do you mean undefined, string literals are stored in read-only memory, so the first assignment attempt results in a core dump&quot;. This is exactly the problem with undefined behavior. Basically, the standard allows anything to happen once you invoke undefined behavior (even nasal demons). If there is a &quot;correct&quot; behavior according to your mental model of the language, that model is simply wrong; The C++ standard has the only vote, period.</source>
          <target state="translated">Puedo escuchar a la gente gritar &quot;Pero espera, puedo compilar esto sin problemas y obtener la salida &lt;code&gt;yellow&lt;/code&gt; &quot; o &quot;&amp;iquest;Qu&amp;eacute; quieres decir con indefinido, los literales de cadena se almacenan en la memoria de solo lectura, por lo que el primer intento de asignaci&amp;oacute;n resulta en un volcado del n&amp;uacute;cleo&quot; . Este es exactamente el problema con el comportamiento indefinido. B&amp;aacute;sicamente, el est&amp;aacute;ndar permite que cualquier cosa suceda una vez que invocas un comportamiento indefinido (incluso demonios nasales). Si hay un comportamiento &quot;correcto&quot; de acuerdo con su modelo mental del lenguaje, ese modelo simplemente est&amp;aacute; equivocado; El est&amp;aacute;ndar C ++ tiene el &amp;uacute;nico voto, punto.</target>
        </trans-unit>
        <trans-unit id="d3cbfc77c16c8f8fe13215121e443b68e0af440a" translate="yes" xml:space="preserve">
          <source>IMO far too many &quot;things&quot; are left
  undefined, unspecified,
  implementation-defined, etc. However,
  that's easy to say and even to give
  examples of, but hard to fix. It
  should also be noted that it is not
  all that difficult to avoid most of
  the problems and produce portable
  code.</source>
          <target state="translated">La OMI deja demasiadas &quot;cosas&quot; sin definir,sin especificar,sin definir la aplicación,etc.Sin embargo,eso es fácil de decir e incluso de dar ejemplos,pero difícil de arreglar.También hay que señalar que no es tan difícil evitar la mayoría de los problemas y producir código portátil.</target>
        </trans-unit>
        <trans-unit id="a291455822dc1c54fd3c820d50b04b5689f1956b" translate="yes" xml:space="preserve">
          <source>Implementation defined-</source>
          <target state="translated">La implementación definida...</target>
        </trans-unit>
        <trans-unit id="f0d8b740f7f9ff893a0572fcc79dd50d8329925f" translate="yes" xml:space="preserve">
          <source>Implementors wish,should be well documented,standard gives choices but sure to compile</source>
          <target state="translated">Los implementadores desean,deben estar bien documentados,el estándar da opciones pero seguro de compilar</target>
        </trans-unit>
        <trans-unit id="fd18bf07df2a483e12d5b771dc0b3af5d3a88ea6" translate="yes" xml:space="preserve">
          <source>It is claimed that the difference
  between what can be produced giving
  the compiler this freedom and
  requiring &quot;ordinary left-to-right
  evaluation&quot; can be significant. I'm
  unconvinced, but with innumerable
  compilers &quot;out there&quot; taking advantage
  of the freedom and some people
  passionately defending that freedom, a
  change would be difficult and could
  take decades to penetrate to the
  distant corners of the C and C++
  worlds. I am disappointed that not all
  compilers warn against code such as
  ++i+i++. Similarly, the order of evaluation of arguments is
  unspecified.</source>
          <target state="translated">Se afirma que la diferencia entre lo que se puede producir dando al compilador esta libertad y requiriendo una &quot;evaluación ordinaria de izquierda a derecha&quot; puede ser significativa.No estoy convencido,pero con innumerables compiladores &quot;ahí fuera&quot; aprovechando la libertad y algunas personas defendiendo apasionadamente esa libertad,un cambio sería difícil y podría tardar décadas en penetrar en los lejanos rincones del mundo del C y del C++.Me decepciona que no todos los compiladores adviertan sobre código como ++i+i++.Del mismo modo,el orden de evaluación de los argumentos no está especificado.</target>
        </trans-unit>
        <trans-unit id="fdf5bfd499acd8a1d289a719f15515471ac74fca" translate="yes" xml:space="preserve">
          <source>Let's look at a classic example:</source>
          <target state="translated">Veamos un ejemplo clásico:</target>
        </trans-unit>
        <trans-unit id="70c706a5f40b3cd3a5d8a17c0d0b0ab9a0ca06a5" translate="yes" xml:space="preserve">
          <source>Maybe easy wording could be easier for understanding than the rigorous definition of the standards.</source>
          <target state="translated">Tal vez una redacción fácil podría ser más fácil de entender que la definición rigurosa de las normas.</target>
        </trans-unit>
        <trans-unit id="3a745746f33c45b300b6511a474f5f3daaf2664a" translate="yes" xml:space="preserve">
          <source>Other examples of undefined behavior include accessing an array beyond its bounds, &lt;a href=&quot;https://stackoverflow.com/q/2894891&quot;&gt;dereferencing the null pointer&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/q/6441218&quot;&gt;accessing objects after their lifetime ended&lt;/a&gt; or writing &lt;a href=&quot;https://stackoverflow.com/q/949433&quot;&gt;allegedly clever expressions&lt;/a&gt; like &lt;code&gt;i++ + ++i&lt;/code&gt;.</source>
          <target state="translated">Otros ejemplos de comportamiento indefinido incluyen acceder a una matriz m&amp;aacute;s all&amp;aacute; de sus l&amp;iacute;mites, &lt;a href=&quot;https://stackoverflow.com/q/2894891&quot;&gt;desreferenciar el puntero nulo&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/q/6441218&quot;&gt;acceder a objetos despu&amp;eacute;s de que finaliz&amp;oacute; su vida &amp;uacute;til&lt;/a&gt; o escribir &lt;a href=&quot;https://stackoverflow.com/q/949433&quot;&gt;expresiones supuestamente inteligentes&lt;/a&gt; como &lt;code&gt;i++ + ++i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="319b32ef19056d6a4cc43f23a6017acb86983769" translate="yes" xml:space="preserve">
          <source>Permissible undefined behavior ranges from &lt;strong&gt;ignoring the situation completely with unpredictable results&lt;/strong&gt;, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</source>
          <target state="translated">El comportamiento indefinido permitido var&amp;iacute;a desde &lt;strong&gt;ignorar la situaci&amp;oacute;n por completo con resultados impredecibles&lt;/strong&gt; , hasta comportarse durante la traducci&amp;oacute;n o la ejecuci&amp;oacute;n del programa de una manera documentada caracter&amp;iacute;stica del entorno (con o sin la emisi&amp;oacute;n de un mensaje de diagn&amp;oacute;stico), hasta finalizar una traducci&amp;oacute;n o ejecuci&amp;oacute;n (con la emisi&amp;oacute;n de un mensaje de diagn&amp;oacute;stico).</target>
        </trans-unit>
        <trans-unit id="f4c7eb67efae2426128053994ca5a87e8f8fc518" translate="yes" xml:space="preserve">
          <source>Same as implementation-defined but not documented</source>
          <target state="translated">Igual que la aplicación-definida pero no documentada</target>
        </trans-unit>
        <trans-unit id="bfdc4a7a8214fa75e47089f0c3154e682f509bac" translate="yes" xml:space="preserve">
          <source>Section 1.9 of the C++ standard also mentions undefined behavior's two less dangerous brothers, &lt;strong&gt;unspecified behavior&lt;/strong&gt; and &lt;strong&gt;implementation-defined behavior&lt;/strong&gt;:</source>
          <target state="translated">La secci&amp;oacute;n 1.9 del est&amp;aacute;ndar C ++ tambi&amp;eacute;n menciona los dos hermanos menos peligrosos del comportamiento indefinido, el &lt;strong&gt;comportamiento no especificado&lt;/strong&gt; y el &lt;strong&gt;comportamiento definido por la implementaci&amp;oacute;n&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="34669cae5d82e706134e0fee4b3402d81d5ed84b" translate="yes" xml:space="preserve">
          <source>Sometimes C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen and &lt;strong&gt;described&lt;/strong&gt; by particular implementation (version of library). So user can still know exactly how will program behave even though Standard doesn't describe this.</source>
          <target state="translated">A veces, C ++ Standard no impone un comportamiento particular en algunas construcciones, sino que dice que un comportamiento particular y bien definido debe ser elegido y &lt;strong&gt;descrito&lt;/strong&gt; por una implementaci&amp;oacute;n particular (versi&amp;oacute;n de la biblioteca). Por lo tanto, el usuario puede saber exactamente c&amp;oacute;mo se comportar&amp;aacute; el programa, aunque Standard no lo describa.</target>
        </trans-unit>
        <trans-unit id="8adb8ad36deb332dc2e827438bafa13e25c65398" translate="yes" xml:space="preserve">
          <source>Specifically, section 1.3.24 states:</source>
          <target state="translated">Específicamente,la sección 1.3.24 dice:</target>
        </trans-unit>
        <trans-unit id="db0c3d454e250e7c9214ed030c2b4fe7f4dd68e8" translate="yes" xml:space="preserve">
          <source>The difference between implementation-defined and unspecified, is that the compiler is supposed to pick a behavior in the first case but it doesn't have to in the second case. For example, an implementation must have one and only one definition of &lt;code&gt;sizeof(int)&lt;/code&gt;. So, it can't say that &lt;code&gt;sizeof(int)&lt;/code&gt; is 4 for some portion of the program and 8 for others. Unlike unspecified behavior, where the compiler can say OK I am gonna evaluate these arguments left-to-right and the next function's arguments are evaluated right-to-left. It can happen in the same program, that's why it is called &lt;strong&gt;&lt;em&gt;unspecified&lt;/em&gt;&lt;/strong&gt;. In fact, C++ could have been made easier if some of the unspecified behaviors were specified. Take a look here at &lt;a href=&quot;http://www2.research.att.com/~bs/bs_faq2.html#undefined&quot;&gt;Dr. Stroustrup's answer for that&lt;/a&gt;:</source>
          <target state="translated">La diferencia entre implementaci&amp;oacute;n definida y no especificada es que el compilador debe elegir un comportamiento en el primer caso, pero no tiene que hacerlo en el segundo caso. Por ejemplo, una implementaci&amp;oacute;n debe tener una y solo una definici&amp;oacute;n de &lt;code&gt;sizeof(int)&lt;/code&gt; . Por lo tanto, no puede decir que &lt;code&gt;sizeof(int)&lt;/code&gt; es 4 para una parte del programa y 8 para otras. A diferencia del comportamiento no especificado, donde el compilador puede decir OK, evaluar&amp;eacute; estos argumentos de izquierda a derecha y los argumentos de la siguiente funci&amp;oacute;n se evaluar&amp;aacute;n de derecha a izquierda. Puede suceder en el mismo programa, por eso se llama &lt;strong&gt;&lt;em&gt;no especificado&lt;/em&gt;&lt;/strong&gt; . De hecho, C ++ podr&amp;iacute;a haberse hecho m&amp;aacute;s f&amp;aacute;cil si se especificaran algunos de los comportamientos no especificados. Eche un vistazo aqu&amp;iacute; a &lt;a href=&quot;http://www2.research.att.com/~bs/bs_faq2.html#undefined&quot;&gt;la respuesta del Dr. Stroustrup para eso&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="13d01a83f882b45a7b8274361567d50862b09497" translate="yes" xml:space="preserve">
          <source>The effect of attempting to modify a string literal is undefined.</source>
          <target state="translated">El efecto de intentar modificar un literal de la cadena no está definido.</target>
        </trans-unit>
        <trans-unit id="8d8507b91d1b68503fc0556c8b0fc10ce87230ca" translate="yes" xml:space="preserve">
          <source>The language doesn't specify the evaluation, left to right or right to left! So an unspecified behavior may or mayn't result in an undefined behavior, but certainly your program should not produce an unspecified behavior.</source>
          <target state="translated">El lenguaje no especifica la evaluación,¡de izquierda a derecha o de derecha a izquierda! Por lo tanto,un comportamiento no especificado puede o no resultar en un comportamiento no definido,pero ciertamente su programa no debe producir un comportamiento no especificado.</target>
        </trans-unit>
        <trans-unit id="03592da1d7f63ec108b81c8b1804b6691b9b3d0d" translate="yes" xml:space="preserve">
          <source>The language says that we have data-types. The compiler vendors specify what sizes shall they use, and provide a documentation of what they did.</source>
          <target state="translated">El lenguaje dice que tenemos tipos de datos.Los proveedores de compiladores especifican qué tamaños deben usar,y proporcionan una documentación de lo que hicieron.</target>
        </trans-unit>
        <trans-unit id="3fc47a5be1124c057ad6f2eacce91011ff65e6a4" translate="yes" xml:space="preserve">
          <source>The only difference between Implementation-Defined Behavior and Undefined Behavior is that the former requires that implementations define and document a consistent behavior &lt;em&gt;even in cases where nothing the implementation could possibly do would be useful&lt;/em&gt;.  The dividing line between them is not whether it would generally be useful for implementations to define behaviors (compiler writers should define useful behaviors when practical whether the Standard requires them to or not) but &lt;em&gt;whether there might be implementations where defining a behavior would be simultaneously costly and useless&lt;/em&gt;.  A judgment that such implementations might exist does not in any way, shape, or form, imply any judgment about the usefulness of supporting a defined behavior on other platforms.</source>
          <target state="translated">La &amp;uacute;nica diferencia entre el Comportamiento definido por la implementaci&amp;oacute;n y el Comportamiento indefinido es que el primero requiere que las implementaciones definan y documenten un comportamiento consistente &lt;em&gt;incluso en los casos en que nada de lo que la implementaci&amp;oacute;n podr&amp;iacute;a hacer ser&amp;iacute;a &amp;uacute;til&lt;/em&gt; . La l&amp;iacute;nea divisoria entre ellos no es si en general ser&amp;iacute;a &amp;uacute;til que las implementaciones definieran comportamientos (los escritores de compiladores deber&amp;iacute;an definir comportamientos &amp;uacute;tiles cuando sea pr&amp;aacute;ctico si el Est&amp;aacute;ndar lo requiere o no) sino &lt;em&gt;si podr&amp;iacute;a haber implementaciones en las que definir un comportamiento ser&amp;iacute;a simult&amp;aacute;neamente costoso e in&amp;uacute;til&lt;/em&gt; El juicio de que tales implementaciones pueden existir no implica, de ninguna manera o forma, ning&amp;uacute;n juicio sobre la utilidad de soportar un comportamiento definido en otras plataformas.</target>
        </trans-unit>
        <trans-unit id="8e6faa7e4973d1b2d9160e16d12bcd7f321dc76f" translate="yes" xml:space="preserve">
          <source>The preferred philosophy among some of today's compiler writers, however, would suggest that because &lt;code&gt;v&lt;/code&gt; can only be negative if the program is going to engage in Undefined Behavior, there's no reason to have the program clip the negative range of &lt;code&gt;v&lt;/code&gt;.  Even though left-shifting of negative values used to be supported on every single compiler of significance, and a large amount of existing code relies upon that behavior, modern philosophy would interpret the fact that the Standard says that left-shifting negative values is UB as implying that compiler writers should feel free to ignore that.</source>
          <target state="translated">La filosof&amp;iacute;a preferida entre algunos de los escritores de compiladores de hoy, sin embargo, sugerir&amp;iacute;a que debido a que &lt;code&gt;v&lt;/code&gt; solo puede ser negativo si el programa va a participar en Comportamiento indefinido, no hay raz&amp;oacute;n para que el programa recorte el rango negativo de &lt;code&gt;v&lt;/code&gt; . Aunque el desplazamiento hacia la izquierda de los valores negativos sol&amp;iacute;a ser compatible con cada compilador significativo, y una gran cantidad de c&amp;oacute;digo existente depende de ese comportamiento, la filosof&amp;iacute;a moderna interpretar&amp;iacute;a el hecho de que el Est&amp;aacute;ndar dice que los valores negativos hacia la izquierda son UB como lo que implica que los escritores de compiladores deben sentirse libres de ignorar eso.</target>
        </trans-unit>
        <trans-unit id="9d036d9e98b9050d932b30c3ad251a8f116fe3fa" translate="yes" xml:space="preserve">
          <source>The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine.</source>
          <target state="translated">Las descripciones semánticas de esta Norma Internacional definen una máquina abstracta no determinista parametrizada.</target>
        </trans-unit>
        <trans-unit id="19030c219a55b7d14c74fef4b37a31512d06bca0" translate="yes" xml:space="preserve">
          <source>The terms &lt;em&gt;unspecified&lt;/em&gt; behavior, &lt;em&gt;undefined&lt;/em&gt; behavior, and &lt;em&gt;implementation-defined&lt;/em&gt; behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe.  The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard.  Appendix F to the Standard catalogs those behaviors which fall into one of these three categories.</source>
          <target state="translated">Los t&amp;eacute;rminos comportamiento &lt;em&gt;no especificado&lt;/em&gt; , comportamiento &lt;em&gt;indefinido&lt;/em&gt; y comportamiento &lt;em&gt;definido por la implementaci&amp;oacute;n&lt;/em&gt; se utilizan para clasificar el resultado de escribir programas cuyas propiedades el Est&amp;aacute;ndar no describe o no puede describir por completo. El objetivo de adoptar esta categorizaci&amp;oacute;n es permitir una cierta variedad de implementaciones que permita que la calidad de implementaci&amp;oacute;n sea una fuerza activa en el mercado, as&amp;iacute; como permitir ciertas extensiones populares, sin eliminar el prestigio de conformidad con el Est&amp;aacute;ndar. El Ap&amp;eacute;ndice F de la Norma cataloga aquellos comportamientos que se incluyen en una de estas tres categor&amp;iacute;as.</target>
        </trans-unit>
        <trans-unit id="7dab400ceb2afc2f8c18d46d1d68aff6ae94bb2c" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;p&lt;/code&gt; points to the string literal &lt;code&gt;&quot;hello!\n&quot;&lt;/code&gt;, and the two assignments below try to modify that string literal. What does this program do? According to section 2.14.5 paragraph 11 of the C++ standard, it invokes &lt;em&gt;undefined behavior&lt;/em&gt;:</source>
          <target state="translated">La variable &lt;code&gt;p&lt;/code&gt; apunta al literal de cadena &lt;code&gt;&quot;hello!\n&quot;&lt;/code&gt; , y las dos asignaciones a continuaci&amp;oacute;n intentan modificar ese literal de cadena. &amp;iquest;Qu&amp;eacute; hace este programa? De acuerdo con la secci&amp;oacute;n 2.14.5, p&amp;aacute;rrafo 11 del est&amp;aacute;ndar C ++, invoca &lt;em&gt;un comportamiento indefinido&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="b7cebcf19e1557782154ebbd8c8c7d81807ec461" translate="yes" xml:space="preserve">
          <source>Their final summary:</source>
          <target state="translated">Su resumen final:</target>
        </trans-unit>
        <trans-unit id="c9484df72a4301a0e58a21f280b9f6ef65c82d56" translate="yes" xml:space="preserve">
          <source>To sum up, unspecified behavior is usually something you shouldn't
  worry about, unless your software is required to be portable.
  Conversely, undefined behavior is always undesirable and should never
  occur.</source>
          <target state="translated">En resumen,el comportamiento no especificado es algo de lo que no debe preocuparse,a menos que se requiera que su software sea portátil.Por el contrario,el comportamiento no definido siempre es indeseable y nunca debería ocurrir.</target>
        </trans-unit>
        <trans-unit id="5f0d39b8bae2a64f0cad3be5b95af63211bb7407" translate="yes" xml:space="preserve">
          <source>Undefined, unspecified and implementation-defined behavior</source>
          <target state="translated">Comportamiento indefinido,no especificado y definido por la aplicación</target>
        </trans-unit>
        <trans-unit id="588daf6c4c6ee3a04c3826fd5936ab1a8d2ab32c" translate="yes" xml:space="preserve">
          <source>Undefined-</source>
          <target state="translated">Undefined-</target>
        </trans-unit>
        <trans-unit id="96b97090ac320fedc26b22d09f94f06081349d26" translate="yes" xml:space="preserve">
          <source>Unfortunately, since the mid 1990s compiler writers have started to interpret the lack of behavioral mandates as an judgment that behavioral guarantees aren't worth the cost even in application fields where they're vital, and even on systems where they cost practically nothing.  Instead of treating UB as an invitation to exercise reasonable judgment, compiler writers have started treating it as an excuse &lt;em&gt;not&lt;/em&gt; to do so.</source>
          <target state="translated">Desafortunadamente, desde mediados de la d&amp;eacute;cada de 1990, los escritores de compiladores han comenzado a interpretar la falta de mandatos de comportamiento como un juicio de que las garant&amp;iacute;as de comportamiento no valen la pena, incluso en los campos de aplicaci&amp;oacute;n donde son vitales, e incluso en sistemas donde no cuestan pr&amp;aacute;cticamente nada. En lugar de tratar a UB como una invitaci&amp;oacute;n para ejercer un juicio razonable, los escritores del compilador han comenzado a tratarlo como una excusa para &lt;em&gt;no&lt;/em&gt; hacerlo.</target>
        </trans-unit>
        <trans-unit id="030d71a8247686614320a9edf9e2d1ccd4e8d22b" translate="yes" xml:space="preserve">
          <source>Unspecified -</source>
          <target state="translated">Sin especificar...</target>
        </trans-unit>
        <trans-unit id="a7708e91a446b4023bb1b77f84bcfd74a92520ac" translate="yes" xml:space="preserve">
          <source>Well, this is basically a straight copy-paste from the standard</source>
          <target state="translated">Bueno,esto es básicamente un copiar-pegar directo del estándar</target>
        </trans-unit>
        <trans-unit id="87ad9d2884c3adbac2b3aade98d1e68308202232" translate="yes" xml:space="preserve">
          <source>What can you do to avoid running into undefined behavior? Basically, you have to read &lt;a href=&quot;https://stackoverflow.com/questions/388242/&quot;&gt;good C++ books&lt;/a&gt; by authors who know what they're talking about. Screw internet tutorials. Screw bullschildt.</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; puede hacer para evitar tener un comportamiento indefinido? B&amp;aacute;sicamente, tienes que leer &lt;a href=&quot;https://stackoverflow.com/questions/388242/&quot;&gt;buenos libros de C ++&lt;/a&gt; de autores que saben de lo que est&amp;aacute;n hablando. Tornillo tutoriales de internet. Tornillo bullschildt.</target>
        </trans-unit>
        <trans-unit id="08b722f8a37c3500626a622dbbf668cdcb065041" translate="yes" xml:space="preserve">
          <source>What is undefined behavior in C and C++?  What about unspecified behavior and implementation-defined behavior?  What is the difference between them?</source>
          <target state="translated">¿Qué es el comportamiento indefinido en C y C++? ¿Qué pasa con el comportamiento no especificado y el comportamiento definido por la implementación? ¿Cuál es la diferencia entre ellos?</target>
        </trans-unit>
        <trans-unit id="d0694b1543421d75294f9e15d7ae60bbe8c4dfec" translate="yes" xml:space="preserve">
          <source>When the program encounters construct that is not defined according to C++ Standard it is allowed to do whatever it wants to do ( maybe send an email to me or maybe send an email to you or maybe ignore the code completely).</source>
          <target state="translated">Cuando el programa se encuentra con una construcción que no está definida según el estándar C++,se le permite hacer lo que quiera (tal vez enviarme un correo electrónico a mí o tal vez enviarte un correo electrónico a ti o tal vez ignorar el código por completo).</target>
        </trans-unit>
        <trans-unit id="77c0292370d7dde2bb9273762fc4aa0ed7281573" translate="yes" xml:space="preserve">
          <source>Which function of these two is executed first?</source>
          <target state="translated">¿Qué función de estas dos se ejecuta primero?</target>
        </trans-unit>
        <trans-unit id="36ed259ac8c492d01bbcc825c13c77a68f563188" translate="yes" xml:space="preserve">
          <source>You are doing something wrong. For example, you have a very large value in an &lt;code&gt;int&lt;/code&gt; that doesn't fit in &lt;code&gt;char&lt;/code&gt;. How do you put that value in &lt;code&gt;char&lt;/code&gt;? actually there is no way! Anything could happen, but the most sensible thing would be to take the first byte of that int and put it in &lt;code&gt;char&lt;/code&gt;. It is just wrong to do that to assign the first byte, but thats what happens under the hood.</source>
          <target state="translated">Estas haciendo algo mal. Por ejemplo, tiene un valor muy grande en un &lt;code&gt;int&lt;/code&gt; que no cabe en &lt;code&gt;char&lt;/code&gt; . &amp;iquest;C&amp;oacute;mo pones ese valor en &lt;code&gt;char&lt;/code&gt; ? en realidad no hay manera! Podr&amp;iacute;a pasar cualquier cosa, pero lo m&amp;aacute;s sensato ser&amp;iacute;a tomar el primer byte de ese int y ponerlo en &lt;code&gt;char&lt;/code&gt; . Es simplemente incorrecto hacer eso para asignar el primer byte, pero eso es lo que sucede debajo del cap&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="f107d231dbf1b031ddde5ed61218906955140fa4" translate="yes" xml:space="preserve">
          <source>a two's-complement implementation would not have to expend any effort
whatsoever to treat the expression &lt;code&gt;v &amp;lt;&amp;lt; pow&lt;/code&gt; as a two's-complement shift
without regard for whether &lt;code&gt;v&lt;/code&gt; was positive or negative.</source>
          <target state="translated">una implementaci&amp;oacute;n de complemento a dos no tendr&amp;iacute;a que hacer ning&amp;uacute;n esfuerzo para tratar la expresi&amp;oacute;n &lt;code&gt;v &amp;lt;&amp;lt; pow&lt;/code&gt; como un cambio de complemento a dos sin tener en cuenta si &lt;code&gt;v&lt;/code&gt; fue positivo o negativo.</target>
        </trans-unit>
        <trans-unit id="b45f1d608a58c018e47110174b4665c9870aed4d" translate="yes" xml:space="preserve">
          <source>behavior for which this International Standard imposes no requirements
  [ Note: Undefined behavior may be expected when this International
  Standard omits any explicit definition of behavior or when a program
  uses an erroneous construct or erroneous data. Permissible undefined
  behavior ranges from ignoring the situation completely with
  unpredictable results, to behaving during translation or program
  execution in a documented manner characteristic of the environment
  (with or without the issuance of a diagnostic message), to terminating
  a translation or execution (with the issuance of a diagnostic
  message). Many erroneous program constructs do not engender undefined
  behavior; they are required to be diagnosed. &amp;mdash; end note ]</source>
          <target state="translated">comportamiento para el cual esta Norma Internacional no impone requisitos [Nota: Se puede esperar un comportamiento indefinido cuando esta Norma Internacional omite cualquier definici&amp;oacute;n expl&amp;iacute;cita de comportamiento o cuando un programa utiliza una construcci&amp;oacute;n err&amp;oacute;nea o datos err&amp;oacute;neos. El comportamiento indefinido permitido var&amp;iacute;a desde ignorar la situaci&amp;oacute;n por completo con resultados impredecibles, hasta comportarse durante la traducci&amp;oacute;n o la ejecuci&amp;oacute;n del programa de una manera documentada caracter&amp;iacute;stica del entorno (con o sin la emisi&amp;oacute;n de un mensaje de diagn&amp;oacute;stico), hasta finalizar una traducci&amp;oacute;n o ejecuci&amp;oacute;n (con la emisi&amp;oacute;n de un mensaje de diagn&amp;oacute;stico). Muchas construcciones de programa err&amp;oacute;neas no generan un comportamiento indefinido; est&amp;aacute;n obligados a ser diagnosticados. - nota final]</target>
        </trans-unit>
        <trans-unit id="9724be63aed3070bfa520e88b4fcb6e7eaf4caeb" translate="yes" xml:space="preserve">
          <source>behavior, for a well-formed program construct and correct data, that
  depends on the implementation [ Note: The implementation is not
  required to document which behavior occurs. The range of possible
  behaviors is usually delineated by this International Standard. &amp;mdash; end
  note ]</source>
          <target state="translated">comportamiento, para una construcci&amp;oacute;n de programa bien formada y datos correctos, que depende de la implementaci&amp;oacute;n [Nota: La implementaci&amp;oacute;n no es necesaria para documentar qu&amp;eacute; comportamiento ocurre. El rango de posibles comportamientos generalmente est&amp;aacute; delineado por esta Norma Internacional. - nota final]</target>
        </trans-unit>
        <trans-unit id="979dc22a1216b408e243d86c25ba9776652b3efb" translate="yes" xml:space="preserve">
          <source>behavior, for a well-formed program construct and correct data, that
  depends on the implementation and that each implementation documents</source>
          <target state="translated">comportamiento,para una construcción de programa bien formada y datos correctos,que depende de la implementación y que cada implementación documenta</target>
        </trans-unit>
        <trans-unit id="2f6826c50a9aeeefffb662cd6899c5ec00cf5c96" translate="yes" xml:space="preserve">
          <source>for &lt;code&gt;fun(fun1(), fun2());&lt;/code&gt; isn't the
  behaviour &quot;implementation defined&quot;?
  The compiler has to choose one or the
  other course, after all?</source>
          <target state="translated">por &lt;code&gt;fun(fun1(), fun2());&lt;/code&gt; &amp;iquest;No es el comportamiento &quot;implementaci&amp;oacute;n definida&quot;? &amp;iquest;El compilador tiene que elegir uno u otro curso, despu&amp;eacute;s de todo?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
