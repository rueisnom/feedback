<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/2397984">
    <body>
      <group id="2397984">
        <trans-unit id="a8642ac09b8508587e68f1734255bd9f149b636b" translate="yes" xml:space="preserve">
          <source>2
  EXAMPLE An example of unspecified
  behavior is the order in which the
  arguments to a function are evaluated.</source>
          <target state="translated">Пример неуказанного поведения-порядок вычисления аргументов к функции.</target>
        </trans-unit>
        <trans-unit id="2503f99863d13d5ddf37f8e7ca0aa5dc129bfad7" translate="yes" xml:space="preserve">
          <source>2
  NOTE Possible undefined behavior
  ranges from ignoring the situation
  completely with unpredictable results,
  to behaving during translation or
  program execution in a documented
  manner characteristic of the
  environment (with or without the
  issuance of a diagnostic message), to
  terminating a translation or execution
  (with the issuance of a diagnostic
  message).</source>
          <target state="translated">2 ЗАМЕЧАНИЕ Возможное неопределённое поведение варьируется от полного игнорирования ситуации с непредсказуемыми результатами,до поведения во время трансляции или выполнения программы в документированной форме,характерной для данной среды (с выдачей или без выдачи диагностического сообщения),до прекращения трансляции или выполнения (с выдачей диагностического сообщения).</target>
        </trans-unit>
        <trans-unit id="569b518442a5c00e3f5f269306db32d537693a40" translate="yes" xml:space="preserve">
          <source>2 EXAMPLE An example of
  implementation-defined behavior is the
  propagation of the high-order bit when
  a signed integer is shifted right.</source>
          <target state="translated">2 ПРИМЕР 2 Пример реализованно-определенного поведения-распространение старшинного бита при сдвиге знакового целого вправо.</target>
        </trans-unit>
        <trans-unit id="55e2cabac9083f31e037fb27d178b197629146d2" translate="yes" xml:space="preserve">
          <source>3 EXAMPLE An example of
  undefined behavior is the behavior on
  integer overflow.</source>
          <target state="translated">3 ЭКЗЕМПЛЯ Примером неопределенного поведения является поведение при целочисленном переполнении.</target>
        </trans-unit>
        <trans-unit id="b59dcbb47c1299641d663023ee7e761885c46dec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.devx.com/tips/Tip/12684&quot;&gt;Undefined Behavior vs. Unspecified Behavior&lt;/a&gt; has a short description of it.</source>
          <target state="translated">&lt;a href=&quot;http://www.devx.com/tips/Tip/12684&quot;&gt;Неопределенное поведение против неуказанного поведения&lt;/a&gt; имеет краткое описание этого.</target>
        </trans-unit>
        <trans-unit id="ee0b8c6197fe6b3a5f488da9fd25ff2ee8c6dec7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Implementation-defined&lt;/em&gt; behavior gives an implementor the freedom to choose the appropriate approach, but requires that this choice be explained to the user.  Behaviors designated as implementation-defined are generally those in which a user could make meaningful coding decisions based on the implementation definition.  Implementors should bear in mind this criterion when deciding how extensive an implementation definition ought to be.  As with unspecified behavior, simply failing to translate the source containing the implementation-defined behavior is not an adequate response.</source>
          <target state="translated">Поведение, &lt;em&gt;определяемое&lt;/em&gt; реализацией, дает разработчику свободу выбора подходящего подхода, но требует, чтобы этот выбор был объяснен пользователю. Поведения, обозначенные как определенные реализацией, - это, как правило, те, в которых пользователь может принимать значимые решения по кодированию на основе определения реализации. Разработчики должны учитывать этот критерий при принятии решения о том, насколько обширным должно быть определение реализации. Как и в случае с неопределенным поведением, простой отказ от перевода источника, содержащего определяемое реализацией поведение, не является адекватным ответом.</target>
        </trans-unit>
        <trans-unit id="8599642070272d1f3aa7633ea08cf86c0b0f359d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Undefined behavior&lt;/em&gt; gives the implementor license not to catch certain program errors that are difficult to diagnose.  It also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior.</source>
          <target state="translated">&lt;em&gt;Неопределенное поведение&lt;/em&gt; дает разработчику лицензию на то, чтобы не фиксировать определенные программные ошибки, которые трудно диагностировать. Он также определяет области возможного соответствующего расширения языка: разработчик может расширить язык, предоставив определение официально неопределенного поведения.</target>
        </trans-unit>
        <trans-unit id="7ee702ce983e09f9c8a606b57e09c396752f1074" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Unspecified behavior&lt;/em&gt; gives the implementor some latitude in translating programs.  This latitude does not extend as far as failing to translate the program.</source>
          <target state="translated">&lt;em&gt;Неуказанное поведение&lt;/em&gt; дает разработчику некоторую свободу в переводе программ. Эта широта не распространяется на то, что не удалось перевести программу.</target>
        </trans-unit>
        <trans-unit id="cad8f14462d2da2f559db18ca6a3eab49739a99c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.1&lt;/strong&gt; 1 &lt;strong&gt;implementation-defined behavior&lt;/strong&gt; unspecified behavior where
  each implementation documents how the
  choice is made</source>
          <target state="translated">&lt;strong&gt;3.4.1&lt;/strong&gt; 1 &lt;strong&gt;поведение, определяемое реализацией,&lt;/strong&gt; неопределенное поведение, где каждая реализация документирует, как сделан выбор</target>
        </trans-unit>
        <trans-unit id="9de03b72d558df568e7926b9e71adf72c5a06b64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.3&lt;/strong&gt; 1 &lt;strong&gt;undefined behavior&lt;/strong&gt; behavior, upon use of a nonportable or erroneous
  program construct or of erroneous
  data, for which this International
  Standard imposes no requirements</source>
          <target state="translated">&lt;strong&gt;3.4.3&lt;/strong&gt; 1 &lt;strong&gt;неопределенное поведение&lt;/strong&gt; при использовании непереносимой или ошибочной программной конструкции или ошибочных данных, для которых настоящий международный стандарт не предъявляет никаких требований</target>
        </trans-unit>
        <trans-unit id="3dd4f6dcab8bfd6801d918b5e9fcc7e33a661ccd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.4&lt;/strong&gt; 1 &lt;strong&gt;unspecified behavior&lt;/strong&gt; use of an unspecified value, or other behavior
  where this International Standard
  provides two or more possibilities and
  imposes no further requirements on
  which is chosen in any instance</source>
          <target state="translated">&lt;strong&gt;3.4.4&lt;/strong&gt; 1 &lt;strong&gt;неуказанное поведение&lt;/strong&gt; использование неуказанного значения или другое поведение, когда этот международный стандарт предоставляет две или более возможности и не предъявляет никаких дополнительных требований, которые выбираются в любом случае</target>
        </trans-unit>
        <trans-unit id="aeac9f01453e8d88294f9e02230d16dc104b3874" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Undefined behavior&lt;/em&gt;&lt;/strong&gt; is one of those aspects of the C and C++ language that can be surprising to programmers coming from other languages (other languages try to hide it better). Basically,  it is possible to write C++ programs that do not behave in a predictable way, even though many C++ compilers will not report any errors in the program!</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Неопределенное поведение&lt;/em&gt;&lt;/strong&gt; - один из тех аспектов языка C и C ++, который может удивить программистов, пришедших из других языков (другие языки пытаются скрыть это лучше). По сути, можно писать программы на C ++, которые не ведут себя предсказуемо, хотя многие компиляторы C ++ не будут сообщать о каких-либо ошибках в программе!</target>
        </trans-unit>
        <trans-unit id="89cfb28e2a87f840b0837be96911f5555ef4bc80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;implementation-defined behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;поведение, определяемое реализацией&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8afce23c6edac06facd82113e916bc887c72ee2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;неопределенное поведение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1fbaed2b0330ce88dda9bc280a73badcca5396a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;неуточненное поведение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0f50639979e1e6edba80094faabb497356f2481a" translate="yes" xml:space="preserve">
          <source>@eSKay I think your question is worth editing the answer to clarify more :)</source>
          <target state="translated">@eSKay Я думаю,что ваш вопрос стоит отредактировать ответ,чтобы прояснить больше :)</target>
        </trans-unit>
        <trans-unit id="4408e31b9c4b1008a8002431961b6a435f55e8db" translate="yes" xml:space="preserve">
          <source>Anything might happen,take care of it.</source>
          <target state="translated">Если что-то случится,позаботься об этом.</target>
        </trans-unit>
        <trans-unit id="1e67c5c154cd7cab955ab3f3ec82e33acc7125e0" translate="yes" xml:space="preserve">
          <source>C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen ( &lt;strong&gt;bot not necessary described&lt;/strong&gt;) by particular implementation (version of library). So in the case when no description has been provided it can be difficult to the user to know exactly how will program behave.</source>
          <target state="translated">Стандарт C ++ не навязывает определенное поведение некоторым конструкциям, но вместо этого говорит, что конкретное, четко определенное поведение должно быть выбрано ( &lt;strong&gt;бот не описан&lt;/strong&gt; ) в конкретной реализации (версия библиотеки). Таким образом, в случае, когда описание не было предоставлено, пользователю может быть трудно точно знать, как будет вести себя программа.</target>
        </trans-unit>
        <trans-unit id="5455973a5b63faf093a2386058a1346a183e359c" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.10
&lt;strong&gt;implementation-defined behavior&lt;/strong&gt;</source>
          <target state="translated">Стандарт C ++ n3337 &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.10 &lt;strong&gt;Поведение, определяемое реализацией&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83ac5b84b2b1cf0f027707ad4321c678feaebc59" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.24
&lt;strong&gt;undefined behavior&lt;/strong&gt;</source>
          <target state="translated">Стандарт C ++ n3337 &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.24 &lt;strong&gt;неопределенное поведение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5d9a1e3f8a889e8dab1de5162f84879e8d623bd" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.25
&lt;strong&gt;unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">Стандарт C ++ n3337 &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.25 &lt;strong&gt;неопределенное поведение&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c147dafffa7c09aef6daa958cd748ef62ee63c1" translate="yes" xml:space="preserve">
          <source>Certain aspects and operations of the abstract machine are described in this International Standard as &lt;strong&gt;implementation-defined&lt;/strong&gt; (for example, &lt;code&gt;sizeof(int)&lt;/code&gt;). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these respects.</source>
          <target state="translated">Некоторые аспекты и операции абстрактной машины описаны в этом международном стандарте как &lt;strong&gt;определяемые реализацией&lt;/strong&gt; (например, &lt;code&gt;sizeof(int)&lt;/code&gt; ). Они составляют параметры абстрактной машины. Каждая реализация должна включать документацию, описывающую ее характеристики и поведение в этих отношениях.</target>
        </trans-unit>
        <trans-unit id="99647a312493a7bc6d385f15f565cff68383c1e9" translate="yes" xml:space="preserve">
          <source>Certain other aspects and operations of the abstract machine are described in this International Standard as &lt;strong&gt;unspecified&lt;/strong&gt; (for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine.</source>
          <target state="translated">Некоторые другие аспекты и операции абстрактной машины описаны в этом международном стандарте как &lt;strong&gt;неопределенные&lt;/strong&gt; (например, порядок вычисления аргументов функции). Там, где это возможно, этот международный стандарт определяет набор допустимого поведения. Они определяют недетерминированные аспекты абстрактной машины.</target>
        </trans-unit>
        <trans-unit id="877fa79cfe0bb2180cea26e2a5734c4880504fb2" translate="yes" xml:space="preserve">
          <source>Certain other operations are described in this International Standard as &lt;strong&gt;undefined&lt;/strong&gt; (for example, the  effect of dereferencing the null pointer). [ &lt;em&gt;Note&lt;/em&gt;: &lt;strong&gt;this International Standard imposes no requirements on the behavior of programs that contain undefined behavior.&lt;/strong&gt; &amp;mdash;&lt;em&gt;end note&lt;/em&gt; ]</source>
          <target state="translated">Некоторые другие операции описаны в этом международном стандарте как &lt;strong&gt;неопределенные&lt;/strong&gt; (например, эффект разыменования нулевого указателя). [ &lt;em&gt;Примечание&lt;/em&gt; : &lt;strong&gt;этот международный стандарт не предъявляет никаких требований к поведению программ, которые содержат неопределенное поведение.&lt;/strong&gt; - &lt;em&gt;конец примечания&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0839b8c0f93bc7215bae8e654ced5403f6f34f98" translate="yes" xml:space="preserve">
          <source>For example, given the following code:</source>
          <target state="translated">Например,учитывая следующий код:</target>
        </trans-unit>
        <trans-unit id="910feb56caa0b4f4562dfa21c599f9c4fce3aea8" translate="yes" xml:space="preserve">
          <source>From the official C Rationale Document</source>
          <target state="translated">Из официального Обоснования C</target>
        </trans-unit>
        <trans-unit id="a2257744a12c541b56be26d9e4b425a8900f06cc" translate="yes" xml:space="preserve">
          <source>Historically, both Implementation-Defined Behavior and Undefined Behavior represented situations in which the authors of the Standard expected that people writing quality implementations would use judgment to decide what behavioral guarantees, if any, would be useful for programs in the intended application field running on the intended targets.  The needs of high-end number-crunching code are quite different from those of low-level systems code, and both UB and IDB give compiler writers flexibility to meet those different needs.  Neither category mandates that implementations behave in a way that's useful for any particular purpose, or even for any purpose whatsoever.  Quality implementations that claim to be suitable for a particular purpose, however, should behave in a manner befitting such purpose &lt;em&gt;whether the Standard requires it or not&lt;/em&gt;.</source>
          <target state="translated">Исторически сложилось так, что определяемое реализацией поведение и неопределенное поведение представляли ситуации, в которых авторы стандарта ожидали, что люди, пишущие качественные реализации, будут использовать суждение, чтобы решить, какие поведенческие гарантии, если таковые имеются, будут полезны для программ в области предполагаемого приложения, работающей на предполагаемые цели. Потребности высокоуровневого кода обработки чисел сильно отличаются от потребностей низкоуровневого системного кода, и как UB, так и IDB предоставляют разработчикам компиляторов гибкость для удовлетворения этих различных потребностей. Ни одна из категорий не требует, чтобы реализации вели себя так, как это полезно для какой-либо конкретной цели или даже для какой-либо цели. Однако качественные реализации, которые претендуют на то, что они подходят для конкретной цели, должны вести себя так, как нужно для этой цели, &lt;em&gt;независимо от того, требует это Стандарт или нет&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2540f81c26e6466020aee474b4a78829aae36435" translate="yes" xml:space="preserve">
          <source>I can hear people screaming &quot;But wait, I can compile this no problem and get the output &lt;code&gt;yellow&lt;/code&gt;&quot; or &quot;What do you mean undefined, string literals are stored in read-only memory, so the first assignment attempt results in a core dump&quot;. This is exactly the problem with undefined behavior. Basically, the standard allows anything to happen once you invoke undefined behavior (even nasal demons). If there is a &quot;correct&quot; behavior according to your mental model of the language, that model is simply wrong; The C++ standard has the only vote, period.</source>
          <target state="translated">Я слышу, как люди кричат: &amp;laquo;Но подождите, я могу без проблем скомпилировать и получить вывод &lt;code&gt;yellow&lt;/code&gt; &amp;raquo; или &amp;laquo;Что вы подразумеваете под неопределенным, строковые литералы хранятся в постоянной памяти, поэтому первая попытка назначения приводит к дампу ядра&amp;raquo; , Это как раз проблема с неопределенным поведением. По сути, стандарт позволяет всему происходить, когда вы вызываете неопределенное поведение (даже носовые демоны). Если есть &amp;laquo;правильное&amp;raquo; поведение в соответствии с вашей ментальной моделью языка, эта модель просто неверна; Стандарт C ++ имеет единственный голос, точка.</target>
        </trans-unit>
        <trans-unit id="d3cbfc77c16c8f8fe13215121e443b68e0af440a" translate="yes" xml:space="preserve">
          <source>IMO far too many &quot;things&quot; are left
  undefined, unspecified,
  implementation-defined, etc. However,
  that's easy to say and even to give
  examples of, but hard to fix. It
  should also be noted that it is not
  all that difficult to avoid most of
  the problems and produce portable
  code.</source>
          <target state="translated">Слишком много &quot;вещей&quot; в IMO остаются неопределенными,неуказанными,определяемыми реализацией и т.д.Однако,это легко сказать и даже привести примеры,но трудно исправить.Следует также отметить,что не так уж и сложно избежать большинства проблем и производить переносимый код.</target>
        </trans-unit>
        <trans-unit id="a291455822dc1c54fd3c820d50b04b5689f1956b" translate="yes" xml:space="preserve">
          <source>Implementation defined-</source>
          <target state="translated">Реализация определена...</target>
        </trans-unit>
        <trans-unit id="f0d8b740f7f9ff893a0572fcc79dd50d8329925f" translate="yes" xml:space="preserve">
          <source>Implementors wish,should be well documented,standard gives choices but sure to compile</source>
          <target state="translated">Исполнители желают,должны быть хорошо задокументированы,стандарт дает выбор,но обязательно собрать</target>
        </trans-unit>
        <trans-unit id="fd18bf07df2a483e12d5b771dc0b3af5d3a88ea6" translate="yes" xml:space="preserve">
          <source>It is claimed that the difference
  between what can be produced giving
  the compiler this freedom and
  requiring &quot;ordinary left-to-right
  evaluation&quot; can be significant. I'm
  unconvinced, but with innumerable
  compilers &quot;out there&quot; taking advantage
  of the freedom and some people
  passionately defending that freedom, a
  change would be difficult and could
  take decades to penetrate to the
  distant corners of the C and C++
  worlds. I am disappointed that not all
  compilers warn against code such as
  ++i+i++. Similarly, the order of evaluation of arguments is
  unspecified.</source>
          <target state="translated">Утверждается,что разница между тем,что может быть произведено,давая компилятору эту свободу,и требованием &quot;обычной оценки слева направо&quot; может быть значительной.Я не уверен,но с бесчисленным множеством компиляторов,которые &quot;там&quot; пользуются этой свободой,и с некоторыми людьми,страстно защищающими эту свободу,изменение было бы трудным и могло бы занять десятилетия,чтобы проникнуть в далекие уголки миров Си и Си++.Я разочарован тем,что не все компиляторы предостерегают от такого кода,как ++i+i++.Точно так же не указан порядок оценки аргументов.</target>
        </trans-unit>
        <trans-unit id="fdf5bfd499acd8a1d289a719f15515471ac74fca" translate="yes" xml:space="preserve">
          <source>Let's look at a classic example:</source>
          <target state="translated">Давайте посмотрим на классический пример:</target>
        </trans-unit>
        <trans-unit id="70c706a5f40b3cd3a5d8a17c0d0b0ab9a0ca06a5" translate="yes" xml:space="preserve">
          <source>Maybe easy wording could be easier for understanding than the rigorous definition of the standards.</source>
          <target state="translated">Возможно,легкие формулировки могут быть проще для понимания,чем строгое определение стандартов.</target>
        </trans-unit>
        <trans-unit id="3a745746f33c45b300b6511a474f5f3daaf2664a" translate="yes" xml:space="preserve">
          <source>Other examples of undefined behavior include accessing an array beyond its bounds, &lt;a href=&quot;https://stackoverflow.com/q/2894891&quot;&gt;dereferencing the null pointer&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/q/6441218&quot;&gt;accessing objects after their lifetime ended&lt;/a&gt; or writing &lt;a href=&quot;https://stackoverflow.com/q/949433&quot;&gt;allegedly clever expressions&lt;/a&gt; like &lt;code&gt;i++ + ++i&lt;/code&gt;.</source>
          <target state="translated">Другие примеры неопределенного поведения включают доступ к массиву за его пределами, &lt;a href=&quot;https://stackoverflow.com/q/2894891&quot;&gt;разыменование нулевого указателя&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/q/6441218&quot;&gt;доступ к объектам после истечения срока их жизни&lt;/a&gt; или запись &lt;a href=&quot;https://stackoverflow.com/q/949433&quot;&gt;предположительно умных выражений,&lt;/a&gt; таких как &lt;code&gt;i++ + ++i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="319b32ef19056d6a4cc43f23a6017acb86983769" translate="yes" xml:space="preserve">
          <source>Permissible undefined behavior ranges from &lt;strong&gt;ignoring the situation completely with unpredictable results&lt;/strong&gt;, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</source>
          <target state="translated">Допустимое неопределенное поведение варьируется от &lt;strong&gt;полного игнорирования ситуации с непредсказуемыми результатами&lt;/strong&gt; до поведения во время перевода или выполнения программы документированным образом, характерным для среды (с выдачей или без выдачи диагностического сообщения), до прекращения перевода или выполнения (с выдачей диагностического сообщения).</target>
        </trans-unit>
        <trans-unit id="f4c7eb67efae2426128053994ca5a87e8f8fc518" translate="yes" xml:space="preserve">
          <source>Same as implementation-defined but not documented</source>
          <target state="translated">То же,что и при реализации,но не документировано</target>
        </trans-unit>
        <trans-unit id="bfdc4a7a8214fa75e47089f0c3154e682f509bac" translate="yes" xml:space="preserve">
          <source>Section 1.9 of the C++ standard also mentions undefined behavior's two less dangerous brothers, &lt;strong&gt;unspecified behavior&lt;/strong&gt; and &lt;strong&gt;implementation-defined behavior&lt;/strong&gt;:</source>
          <target state="translated">В разделе 1.9 стандарта C ++ также упоминаются два менее опасных брата &lt;strong&gt;неопределенного поведения: неопределенное поведение&lt;/strong&gt; и &lt;strong&gt;поведение, определяемое реализацией&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="34669cae5d82e706134e0fee4b3402d81d5ed84b" translate="yes" xml:space="preserve">
          <source>Sometimes C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen and &lt;strong&gt;described&lt;/strong&gt; by particular implementation (version of library). So user can still know exactly how will program behave even though Standard doesn't describe this.</source>
          <target state="translated">Иногда C ++ Standard не навязывает определенное поведение некоторым конструкциям, а вместо этого говорит, что конкретное, четко определенное поведение должно быть выбрано и &lt;strong&gt;описано&lt;/strong&gt; конкретной реализацией (версией библиотеки). Таким образом, пользователь все еще может точно знать, как будет вести себя программа, хотя Standard не описывает этого.</target>
        </trans-unit>
        <trans-unit id="8adb8ad36deb332dc2e827438bafa13e25c65398" translate="yes" xml:space="preserve">
          <source>Specifically, section 1.3.24 states:</source>
          <target state="translated">В частности,в разделе 1.3.24 указано:</target>
        </trans-unit>
        <trans-unit id="db0c3d454e250e7c9214ed030c2b4fe7f4dd68e8" translate="yes" xml:space="preserve">
          <source>The difference between implementation-defined and unspecified, is that the compiler is supposed to pick a behavior in the first case but it doesn't have to in the second case. For example, an implementation must have one and only one definition of &lt;code&gt;sizeof(int)&lt;/code&gt;. So, it can't say that &lt;code&gt;sizeof(int)&lt;/code&gt; is 4 for some portion of the program and 8 for others. Unlike unspecified behavior, where the compiler can say OK I am gonna evaluate these arguments left-to-right and the next function's arguments are evaluated right-to-left. It can happen in the same program, that's why it is called &lt;strong&gt;&lt;em&gt;unspecified&lt;/em&gt;&lt;/strong&gt;. In fact, C++ could have been made easier if some of the unspecified behaviors were specified. Take a look here at &lt;a href=&quot;http://www2.research.att.com/~bs/bs_faq2.html#undefined&quot;&gt;Dr. Stroustrup's answer for that&lt;/a&gt;:</source>
          <target state="translated">Различие между реализацией, определенной и неуказанной, состоит в том, что компилятор должен выбирать поведение в первом случае, но это не обязательно во втором случае. Например, реализация должна иметь одно и только одно определение &lt;code&gt;sizeof(int)&lt;/code&gt; . Таким образом, нельзя сказать, что &lt;code&gt;sizeof(int)&lt;/code&gt; равен 4 для некоторой части программы и 8 для других. В отличие от неопределенного поведения, когда компилятор может сказать &amp;laquo;ОК&amp;raquo;, я собираюсь оценить эти аргументы слева направо, а аргументы следующей функции - справа налево. Это может происходить в одной и той же программе, поэтому она называется &lt;strong&gt;&lt;em&gt;неопределенной&lt;/em&gt;&lt;/strong&gt; . На самом деле, C ++ можно было бы сделать проще, если бы были указаны некоторые неуказанные поведения. Посмотрите здесь на &lt;a href=&quot;http://www2.research.att.com/~bs/bs_faq2.html#undefined&quot;&gt;ответ доктора Страуструпа для этого&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="13d01a83f882b45a7b8274361567d50862b09497" translate="yes" xml:space="preserve">
          <source>The effect of attempting to modify a string literal is undefined.</source>
          <target state="translated">Эффект от попытки модификации строкового литерала не определен.</target>
        </trans-unit>
        <trans-unit id="8d8507b91d1b68503fc0556c8b0fc10ce87230ca" translate="yes" xml:space="preserve">
          <source>The language doesn't specify the evaluation, left to right or right to left! So an unspecified behavior may or mayn't result in an undefined behavior, but certainly your program should not produce an unspecified behavior.</source>
          <target state="translated">Язык не указывает оценку,слева направо или справа налево! Таким образом,неуточненное поведение может привести или не привести к неопределенному поведению,но,конечно,ваша программа не должна производить неуточненное поведение.</target>
        </trans-unit>
        <trans-unit id="03592da1d7f63ec108b81c8b1804b6691b9b3d0d" translate="yes" xml:space="preserve">
          <source>The language says that we have data-types. The compiler vendors specify what sizes shall they use, and provide a documentation of what they did.</source>
          <target state="translated">Язык говорит,что у нас есть типы данных.Поставщики компиляторов указывают,какие размеры они должны использовать,и предоставляют документацию о том,что они сделали.</target>
        </trans-unit>
        <trans-unit id="3fc47a5be1124c057ad6f2eacce91011ff65e6a4" translate="yes" xml:space="preserve">
          <source>The only difference between Implementation-Defined Behavior and Undefined Behavior is that the former requires that implementations define and document a consistent behavior &lt;em&gt;even in cases where nothing the implementation could possibly do would be useful&lt;/em&gt;.  The dividing line between them is not whether it would generally be useful for implementations to define behaviors (compiler writers should define useful behaviors when practical whether the Standard requires them to or not) but &lt;em&gt;whether there might be implementations where defining a behavior would be simultaneously costly and useless&lt;/em&gt;.  A judgment that such implementations might exist does not in any way, shape, or form, imply any judgment about the usefulness of supporting a defined behavior on other platforms.</source>
          <target state="translated">Единственное различие между поведением, определяемым реализацией, и неопределенным поведением заключается в том, что первое требует, чтобы реализации определяли и документировали согласованное поведение &lt;em&gt;даже в тех случаях, когда ничего, что реализация могла бы сделать, не было бы полезно&lt;/em&gt; . Разграничительная черта между ними заключается не в том, было бы полезно для реализаций вообще определять поведение (авторы компилятора должны определять полезные поведения, когда это целесообразно, требует ли Стандарт их или нет), но &lt;em&gt;могут ли быть реализации, где определение поведения будет одновременно дорогостоящим и бесполезно&lt;/em&gt; . Суждение о том, что такие реализации могут существовать, никоим образом не формирует и не формирует какого-либо суждения о полезности поддержки определенного поведения на других платформах.</target>
        </trans-unit>
        <trans-unit id="8e6faa7e4973d1b2d9160e16d12bcd7f321dc76f" translate="yes" xml:space="preserve">
          <source>The preferred philosophy among some of today's compiler writers, however, would suggest that because &lt;code&gt;v&lt;/code&gt; can only be negative if the program is going to engage in Undefined Behavior, there's no reason to have the program clip the negative range of &lt;code&gt;v&lt;/code&gt;.  Even though left-shifting of negative values used to be supported on every single compiler of significance, and a large amount of existing code relies upon that behavior, modern philosophy would interpret the fact that the Standard says that left-shifting negative values is UB as implying that compiler writers should feel free to ignore that.</source>
          <target state="translated">Однако предпочитаемая философия некоторых современных авторов компиляторов предполагает, что, поскольку &lt;code&gt;v&lt;/code&gt; может быть отрицательным только в том случае, если программа будет использовать неопределенное поведение, нет никаких причин, чтобы программа обрезала отрицательный диапазон &lt;code&gt;v&lt;/code&gt; . Несмотря на то, что смещение влево отрицательных значений поддерживалось каждым значимым компилятором, и большое количество существующего кода основывается на таком поведении, современная философия интерпретирует тот факт, что Стандарт говорит, что отрицательные значения, сдвигаемые влево, представляют собой UB как подразумевая, что авторы компилятора должны свободно игнорировать это.</target>
        </trans-unit>
        <trans-unit id="9d036d9e98b9050d932b30c3ad251a8f116fe3fa" translate="yes" xml:space="preserve">
          <source>The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine.</source>
          <target state="translated">Сематические описания в настоящем Международном стандарте определяют параметризованную недетерминистическую абстрактную машину.</target>
        </trans-unit>
        <trans-unit id="19030c219a55b7d14c74fef4b37a31512d06bca0" translate="yes" xml:space="preserve">
          <source>The terms &lt;em&gt;unspecified&lt;/em&gt; behavior, &lt;em&gt;undefined&lt;/em&gt; behavior, and &lt;em&gt;implementation-defined&lt;/em&gt; behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe.  The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard.  Appendix F to the Standard catalogs those behaviors which fall into one of these three categories.</source>
          <target state="translated">Термины &lt;em&gt;неопределенное&lt;/em&gt; поведение, &lt;em&gt;неопределенное&lt;/em&gt; поведение и поведение, &lt;em&gt;определяемое реализацией&lt;/em&gt; , используются для классификации результатов написания программ, свойства которых Стандарт не описывает или не может полностью описать. Цель принятия этой категоризации состоит в том, чтобы обеспечить определенное разнообразие среди реализаций, которое позволяет качеству реализации быть активной силой на рынке, а также разрешить некоторые популярные расширения, не удаляя кэш соответствия стандарта. В Приложении F к Стандарту перечислены те виды поведения, которые подпадают под одну из этих трех категорий.</target>
        </trans-unit>
        <trans-unit id="7dab400ceb2afc2f8c18d46d1d68aff6ae94bb2c" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;p&lt;/code&gt; points to the string literal &lt;code&gt;&quot;hello!\n&quot;&lt;/code&gt;, and the two assignments below try to modify that string literal. What does this program do? According to section 2.14.5 paragraph 11 of the C++ standard, it invokes &lt;em&gt;undefined behavior&lt;/em&gt;:</source>
          <target state="translated">Переменная &lt;code&gt;p&lt;/code&gt; указывает на строковый литерал &lt;code&gt;&quot;hello!\n&quot;&lt;/code&gt; , и два приведенных ниже назначения пытаются изменить этот строковый литерал. Что делает эта программа? Согласно пункту 11 раздела 2.14.5 стандарта C ++, он вызывает &lt;em&gt;неопределенное поведение&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="b7cebcf19e1557782154ebbd8c8c7d81807ec461" translate="yes" xml:space="preserve">
          <source>Their final summary:</source>
          <target state="translated">Их окончательное резюме:</target>
        </trans-unit>
        <trans-unit id="c9484df72a4301a0e58a21f280b9f6ef65c82d56" translate="yes" xml:space="preserve">
          <source>To sum up, unspecified behavior is usually something you shouldn't
  worry about, unless your software is required to be portable.
  Conversely, undefined behavior is always undesirable and should never
  occur.</source>
          <target state="translated">Подводя итог,неуточненное поведение-это обычно то,о чем вам не следует беспокоиться,если только ваша программа не должна быть переносимой.И наоборот,неопределенное поведение всегда нежелательно и никогда не должно возникать.</target>
        </trans-unit>
        <trans-unit id="5f0d39b8bae2a64f0cad3be5b95af63211bb7407" translate="yes" xml:space="preserve">
          <source>Undefined, unspecified and implementation-defined behavior</source>
          <target state="translated">Неопределенное,неуточненное и реализованно-определенное поведение</target>
        </trans-unit>
        <trans-unit id="588daf6c4c6ee3a04c3826fd5936ab1a8d2ab32c" translate="yes" xml:space="preserve">
          <source>Undefined-</source>
          <target state="translated">Undefined-</target>
        </trans-unit>
        <trans-unit id="96b97090ac320fedc26b22d09f94f06081349d26" translate="yes" xml:space="preserve">
          <source>Unfortunately, since the mid 1990s compiler writers have started to interpret the lack of behavioral mandates as an judgment that behavioral guarantees aren't worth the cost even in application fields where they're vital, and even on systems where they cost practically nothing.  Instead of treating UB as an invitation to exercise reasonable judgment, compiler writers have started treating it as an excuse &lt;em&gt;not&lt;/em&gt; to do so.</source>
          <target state="translated">К сожалению, с середины 1990-х годов авторы компиляторов начали интерпретировать отсутствие поведенческих мандатов как суждение о том, что поведенческие гарантии не стоят затрат даже в тех областях приложения, где они необходимы, и даже в системах, где они практически ничего не стоят. Вместо того, чтобы рассматривать UB как приглашение проявить разумное суждение, авторы компиляторов начали рассматривать его как оправдание &lt;em&gt;не&lt;/em&gt; делать этого.</target>
        </trans-unit>
        <trans-unit id="030d71a8247686614320a9edf9e2d1ccd4e8d22b" translate="yes" xml:space="preserve">
          <source>Unspecified -</source>
          <target state="translated">неопределённый -</target>
        </trans-unit>
        <trans-unit id="a7708e91a446b4023bb1b77f84bcfd74a92520ac" translate="yes" xml:space="preserve">
          <source>Well, this is basically a straight copy-paste from the standard</source>
          <target state="translated">Ну,это,по сути,прямая копировальная паста от стандарта.</target>
        </trans-unit>
        <trans-unit id="87ad9d2884c3adbac2b3aade98d1e68308202232" translate="yes" xml:space="preserve">
          <source>What can you do to avoid running into undefined behavior? Basically, you have to read &lt;a href=&quot;https://stackoverflow.com/questions/388242/&quot;&gt;good C++ books&lt;/a&gt; by authors who know what they're talking about. Screw internet tutorials. Screw bullschildt.</source>
          <target state="translated">Что вы можете сделать, чтобы избежать неожиданного поведения? По сути, вы должны читать &lt;a href=&quot;https://stackoverflow.com/questions/388242/&quot;&gt;хорошие книги&lt;/a&gt; по С ++ от авторов, которые знают, о чем они говорят. Винт интернет-учебники. Винт Буллшильдт.</target>
        </trans-unit>
        <trans-unit id="08b722f8a37c3500626a622dbbf668cdcb065041" translate="yes" xml:space="preserve">
          <source>What is undefined behavior in C and C++?  What about unspecified behavior and implementation-defined behavior?  What is the difference between them?</source>
          <target state="translated">Что такое неопределенное поведение в C и C++? Что такое неопределенное поведение и реализованно-определенное поведение? В чем разница между ними?</target>
        </trans-unit>
        <trans-unit id="d0694b1543421d75294f9e15d7ae60bbe8c4dfec" translate="yes" xml:space="preserve">
          <source>When the program encounters construct that is not defined according to C++ Standard it is allowed to do whatever it wants to do ( maybe send an email to me or maybe send an email to you or maybe ignore the code completely).</source>
          <target state="translated">Когда программа сталкивается с конструкцией,которая не определена в соответствии со Стандартом C++,ей разрешается делать все,что она захочет (может быть,послать мне письмо или,может быть,послать вам письмо,или,может быть,полностью игнорировать код).</target>
        </trans-unit>
        <trans-unit id="77c0292370d7dde2bb9273762fc4aa0ed7281573" translate="yes" xml:space="preserve">
          <source>Which function of these two is executed first?</source>
          <target state="translated">Какая из этих двух функций выполняется первой?</target>
        </trans-unit>
        <trans-unit id="36ed259ac8c492d01bbcc825c13c77a68f563188" translate="yes" xml:space="preserve">
          <source>You are doing something wrong. For example, you have a very large value in an &lt;code&gt;int&lt;/code&gt; that doesn't fit in &lt;code&gt;char&lt;/code&gt;. How do you put that value in &lt;code&gt;char&lt;/code&gt;? actually there is no way! Anything could happen, but the most sensible thing would be to take the first byte of that int and put it in &lt;code&gt;char&lt;/code&gt;. It is just wrong to do that to assign the first byte, but thats what happens under the hood.</source>
          <target state="translated">Вы делаете что-то не так. Например, у вас есть очень большое значение в &lt;code&gt;int&lt;/code&gt; , которое не помещается в &lt;code&gt;char&lt;/code&gt; . Как вы можете положить это значение в &lt;code&gt;char&lt;/code&gt; ? на самом деле нет пути! Может произойти все что угодно, но самым разумным будет взять первый байт этого целого и поместить его в &lt;code&gt;char&lt;/code&gt; . Это просто неправильно делать это, чтобы назначить первый байт, но это то, что происходит под капотом.</target>
        </trans-unit>
        <trans-unit id="f107d231dbf1b031ddde5ed61218906955140fa4" translate="yes" xml:space="preserve">
          <source>a two's-complement implementation would not have to expend any effort
whatsoever to treat the expression &lt;code&gt;v &amp;lt;&amp;lt; pow&lt;/code&gt; as a two's-complement shift
without regard for whether &lt;code&gt;v&lt;/code&gt; was positive or negative.</source>
          <target state="translated">реализация двойного дополнения не должна была бы затрачивать никаких усилий для того, чтобы рассматривать выражение &lt;code&gt;v &amp;lt;&amp;lt; pow&lt;/code&gt; как сдвиг двойного дополнения, независимо от того, было ли &lt;code&gt;v&lt;/code&gt; положительным или отрицательным.</target>
        </trans-unit>
        <trans-unit id="b45f1d608a58c018e47110174b4665c9870aed4d" translate="yes" xml:space="preserve">
          <source>behavior for which this International Standard imposes no requirements
  [ Note: Undefined behavior may be expected when this International
  Standard omits any explicit definition of behavior or when a program
  uses an erroneous construct or erroneous data. Permissible undefined
  behavior ranges from ignoring the situation completely with
  unpredictable results, to behaving during translation or program
  execution in a documented manner characteristic of the environment
  (with or without the issuance of a diagnostic message), to terminating
  a translation or execution (with the issuance of a diagnostic
  message). Many erroneous program constructs do not engender undefined
  behavior; they are required to be diagnosed. &amp;mdash; end note ]</source>
          <target state="translated">к поведению, для которого настоящий международный стандарт не предъявляет никаких требований [Примечание. Неопределенное поведение может ожидаться, когда в этом международном стандарте отсутствует какое-либо явное определение поведения или когда программа использует ошибочную конструкцию или ошибочные данные. Допустимое неопределенное поведение варьируется от полного игнорирования ситуации с непредсказуемыми результатами до поведения во время перевода или выполнения программы документированным образом, характерным для среды (с выдачей или без выдачи диагностического сообщения), до прекращения перевода или выполнения (с выдачей диагностического сообщения). Многие ошибочные программные конструкции не порождают неопределенного поведения; они должны быть диагностированы. - конец примечания]</target>
        </trans-unit>
        <trans-unit id="9724be63aed3070bfa520e88b4fcb6e7eaf4caeb" translate="yes" xml:space="preserve">
          <source>behavior, for a well-formed program construct and correct data, that
  depends on the implementation [ Note: The implementation is not
  required to document which behavior occurs. The range of possible
  behaviors is usually delineated by this International Standard. &amp;mdash; end
  note ]</source>
          <target state="translated">поведение для правильно сформированной программы и правильных данных, которые зависят от реализации [Примечание: реализация не обязана документировать, какое поведение имеет место. Диапазон возможных вариантов поведения обычно определяется этим международным стандартом. - конец примечания]</target>
        </trans-unit>
        <trans-unit id="979dc22a1216b408e243d86c25ba9776652b3efb" translate="yes" xml:space="preserve">
          <source>behavior, for a well-formed program construct and correct data, that
  depends on the implementation and that each implementation documents</source>
          <target state="translated">поведение,для хорошо сформированной конструкции программы и корректных данных,что зависит от реализации и от того,что каждый из документов по реализации</target>
        </trans-unit>
        <trans-unit id="2f6826c50a9aeeefffb662cd6899c5ec00cf5c96" translate="yes" xml:space="preserve">
          <source>for &lt;code&gt;fun(fun1(), fun2());&lt;/code&gt; isn't the
  behaviour &quot;implementation defined&quot;?
  The compiler has to choose one or the
  other course, after all?</source>
          <target state="translated">для &lt;code&gt;fun(fun1(), fun2());&lt;/code&gt; разве поведение &quot;реализация не определена&quot;? Компилятор должен выбрать один или другой курс, в конце концов?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
