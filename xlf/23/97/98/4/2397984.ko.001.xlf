<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2397984">
    <body>
      <group id="2397984">
        <trans-unit id="a8642ac09b8508587e68f1734255bd9f149b636b" translate="yes" xml:space="preserve">
          <source>2
  EXAMPLE An example of unspecified
  behavior is the order in which the
  arguments to a function are evaluated.</source>
          <target state="translated">2 예 지정되지 않은 동작의 예는 함수의 인수가 평가되는 순서입니다.</target>
        </trans-unit>
        <trans-unit id="2503f99863d13d5ddf37f8e7ca0aa5dc129bfad7" translate="yes" xml:space="preserve">
          <source>2
  NOTE Possible undefined behavior
  ranges from ignoring the situation
  completely with unpredictable results,
  to behaving during translation or
  program execution in a documented
  manner characteristic of the
  environment (with or without the
  issuance of a diagnostic message), to
  terminating a translation or execution
  (with the issuance of a diagnostic
  message).</source>
          <target state="translated">2 참고 가능한 정의되지 않은 행동은 예측할 수없는 결과로 상황을 완전히 무시하는 것부터, 환경의 특성화 된 문서화 된 방식으로 (진단 메시지 발행 여부에 관계없이) 번역 또는 프로그램 실행 중 행동, 번역 또는 실행 종료 진단 메시지 발행).</target>
        </trans-unit>
        <trans-unit id="569b518442a5c00e3f5f269306db32d537693a40" translate="yes" xml:space="preserve">
          <source>2 EXAMPLE An example of
  implementation-defined behavior is the
  propagation of the high-order bit when
  a signed integer is shifted right.</source>
          <target state="translated">2 예 구현 정의 된 동작의 예는 부호있는 정수가 오른쪽으로 이동 될 때 상위 비트의 전파입니다.</target>
        </trans-unit>
        <trans-unit id="55e2cabac9083f31e037fb27d178b197629146d2" translate="yes" xml:space="preserve">
          <source>3 EXAMPLE An example of
  undefined behavior is the behavior on
  integer overflow.</source>
          <target state="translated">3 예 정의되지 않은 동작의 예는 정수 오버플로에서의 동작입니다.</target>
        </trans-unit>
        <trans-unit id="b59dcbb47c1299641d663023ee7e761885c46dec" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.devx.com/tips/Tip/12684&quot;&gt;Undefined Behavior vs. Unspecified Behavior&lt;/a&gt; has a short description of it.</source>
          <target state="translated">&lt;a href=&quot;http://www.devx.com/tips/Tip/12684&quot;&gt;정의되지 않은 동작과 지정되지 않은 동작&lt;/a&gt; 에 대한 간단한 설명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee0b8c6197fe6b3a5f488da9fd25ff2ee8c6dec7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Implementation-defined&lt;/em&gt; behavior gives an implementor the freedom to choose the appropriate approach, but requires that this choice be explained to the user.  Behaviors designated as implementation-defined are generally those in which a user could make meaningful coding decisions based on the implementation definition.  Implementors should bear in mind this criterion when deciding how extensive an implementation definition ought to be.  As with unspecified behavior, simply failing to translate the source containing the implementation-defined behavior is not an adequate response.</source>
          <target state="translated">&lt;em&gt;구현 정의&lt;/em&gt; 동작은 &lt;em&gt;구현 자&lt;/em&gt; 에게 적절한 접근 방식을 선택할 수있는 자유를 제공하지만이 선택은 사용자에게 설명해야합니다. 구현 정의로 지정된 동작은 일반적으로 사용자가 구현 정의를 기반으로 의미있는 코딩 결정을 내릴 수있는 동작입니다. 구현자는 구현 정의의 범위를 결정할 때이 기준을 명심해야합니다. 지정되지 않은 동작과 마찬가지로 구현 정의 동작을 포함하는 소스를 변환하지 못하는 것만으로는 적절하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8599642070272d1f3aa7633ea08cf86c0b0f359d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Undefined behavior&lt;/em&gt; gives the implementor license not to catch certain program errors that are difficult to diagnose.  It also identifies areas of possible conforming language extension: the implementor may augment the language by providing a definition of the officially undefined behavior.</source>
          <target state="translated">&lt;em&gt;정의되지 않은 동작&lt;/em&gt; 은 구현 자에게 진단하기 어려운 특정 프로그램 오류를 포착하지 못하도록 라이센스를 부여합니다. 또한 가능한 언어 확장이 가능한 영역을 식별합니다. 구현자는 공식적으로 정의되지 않은 동작의 정의를 제공하여 언어를 보강 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ee702ce983e09f9c8a606b57e09c396752f1074" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Unspecified behavior&lt;/em&gt; gives the implementor some latitude in translating programs.  This latitude does not extend as far as failing to translate the program.</source>
          <target state="translated">&lt;em&gt;지정되지 않은 동작&lt;/em&gt; 은 구현 자에게 프로그램을 번역 할 때 위도를 제공합니다. 이 위도는 프로그램을 번역하지 못하는 한 확장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cad8f14462d2da2f559db18ca6a3eab49739a99c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.1&lt;/strong&gt; 1 &lt;strong&gt;implementation-defined behavior&lt;/strong&gt; unspecified behavior where
  each implementation documents how the
  choice is made</source>
          <target state="translated">&lt;strong&gt;3.4.1&lt;/strong&gt; 1 &lt;strong&gt;구현-정의 된 행동&lt;/strong&gt; 지정되지 않은 행동 &lt;strong&gt;-&lt;/strong&gt; 각 구현이 선택 방법을 문서화 함</target>
        </trans-unit>
        <trans-unit id="9de03b72d558df568e7926b9e71adf72c5a06b64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.3&lt;/strong&gt; 1 &lt;strong&gt;undefined behavior&lt;/strong&gt; behavior, upon use of a nonportable or erroneous
  program construct or of erroneous
  data, for which this International
  Standard imposes no requirements</source>
          <target state="translated">&lt;strong&gt;3.4.3&lt;/strong&gt; 1 비 이동식 또는 잘못된 프로그램 구성 또는 잘못된 데이터 사용시 &lt;strong&gt;정의되지 않은 행동&lt;/strong&gt; 거동</target>
        </trans-unit>
        <trans-unit id="3dd4f6dcab8bfd6801d918b5e9fcc7e33a661ccd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3.4.4&lt;/strong&gt; 1 &lt;strong&gt;unspecified behavior&lt;/strong&gt; use of an unspecified value, or other behavior
  where this International Standard
  provides two or more possibilities and
  imposes no further requirements on
  which is chosen in any instance</source>
          <target state="translated">&lt;strong&gt;3.4.4&lt;/strong&gt; 1 &lt;strong&gt;불특정 행동&lt;/strong&gt; 불특정 가치의 사용, 또는이 표준이 두 가지 이상의 가능성을 제공하고 어떠한 경우에도 선택되는 추가 요건을 부과하지 않는 기타 행동</target>
        </trans-unit>
        <trans-unit id="aeac9f01453e8d88294f9e02230d16dc104b3874" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Undefined behavior&lt;/em&gt;&lt;/strong&gt; is one of those aspects of the C and C++ language that can be surprising to programmers coming from other languages (other languages try to hide it better). Basically,  it is possible to write C++ programs that do not behave in a predictable way, even though many C++ compilers will not report any errors in the program!</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;정의되지 않은 동작&lt;/em&gt;&lt;/strong&gt; 은 다른 언어에서 온 프로그래머들에게 놀라운 C 및 C ++ 언어 측면 중 하나입니다 (다른 언어에서는 더 잘 숨기려고합니다). 기본적으로 많은 C ++ 컴파일러가 프로그램의 오류를보고하지 않더라도 예측 가능한 방식으로 동작하지 않는 C ++ 프로그램을 작성할 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="89cfb28e2a87f840b0837be96911f5555ef4bc80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;implementation-defined behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;구현 정의 동작&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8afce23c6edac06facd82113e916bc887c72ee2c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undefined behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;정의되지 않은 행동&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1fbaed2b0330ce88dda9bc280a73badcca5396a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;불특정 행동&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0f50639979e1e6edba80094faabb497356f2481a" translate="yes" xml:space="preserve">
          <source>@eSKay I think your question is worth editing the answer to clarify more :)</source>
          <target state="translated">@ eSKay 나는 귀하의 질문이 더 명확하게 답변을 편집 할 가치가 있다고 생각합니다 :)</target>
        </trans-unit>
        <trans-unit id="4408e31b9c4b1008a8002431961b6a435f55e8db" translate="yes" xml:space="preserve">
          <source>Anything might happen,take care of it.</source>
          <target state="translated">어떤 일이든 일어날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e67c5c154cd7cab955ab3f3ec82e33acc7125e0" translate="yes" xml:space="preserve">
          <source>C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen ( &lt;strong&gt;bot not necessary described&lt;/strong&gt;) by particular implementation (version of library). So in the case when no description has been provided it can be difficult to the user to know exactly how will program behave.</source>
          <target state="translated">C ++ 표준은 일부 구문에 특정 동작을 부과하지 않지만 대신 특정 구현 (라이브러리 버전)에 의해 잘 정의 된 특정 동작을 선택해야한다고 말합니다 ( &lt;strong&gt;봇은 필요하지 않음&lt;/strong&gt; ). 따라서 설명이 제공되지 않은 경우 사용자는 프로그램의 작동 방식을 정확히 이해하기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5455973a5b63faf093a2386058a1346a183e359c" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.10
&lt;strong&gt;implementation-defined behavior&lt;/strong&gt;</source>
          <target state="translated">C ++ 표준 n3337 &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.10 &lt;strong&gt;구현 정의 동작&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83ac5b84b2b1cf0f027707ad4321c678feaebc59" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.24
&lt;strong&gt;undefined behavior&lt;/strong&gt;</source>
          <target state="translated">C ++ 표준 n3337 &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.24 &lt;strong&gt;정의되지 않은 동작&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f5d9a1e3f8a889e8dab1de5162f84879e8d623bd" translate="yes" xml:space="preserve">
          <source>C++ standard n3337  &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.25
&lt;strong&gt;unspecified behavior&lt;/strong&gt;</source>
          <target state="translated">C ++ 표준 n3337 &lt;strong&gt;&amp;sect;&lt;/strong&gt; 1.3.25 &lt;strong&gt;지정되지 않은 동작&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c147dafffa7c09aef6daa958cd748ef62ee63c1" translate="yes" xml:space="preserve">
          <source>Certain aspects and operations of the abstract machine are described in this International Standard as &lt;strong&gt;implementation-defined&lt;/strong&gt; (for example, &lt;code&gt;sizeof(int)&lt;/code&gt;). These constitute the parameters of the abstract machine. Each implementation shall include documentation describing its characteristics and behavior in these respects.</source>
          <target state="translated">추상 기계의 특정 측면과 작동은이 국제 표준에서 &lt;strong&gt;구현 정의&lt;/strong&gt; (예 : &lt;code&gt;sizeof(int)&lt;/code&gt; )로 설명됩니다. 이것들은 추상 기계의 매개 변수를 구성합니다. 각 구현에는 이러한 점에서 특성과 동작을 설명하는 문서가 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="99647a312493a7bc6d385f15f565cff68383c1e9" translate="yes" xml:space="preserve">
          <source>Certain other aspects and operations of the abstract machine are described in this International Standard as &lt;strong&gt;unspecified&lt;/strong&gt; (for example, order of evaluation of arguments to a function). Where possible, this International Standard defines a set of allowable behaviors. These define the nondeterministic aspects of the abstract machine.</source>
          <target state="translated">추상 기계의 어떤 다른 측면들 및 동작들은이 국제 표준에서 &lt;strong&gt;지정되지 않은&lt;/strong&gt; 것으로 기술 &lt;strong&gt;되어있다&lt;/strong&gt; (예를 들어, 함수에 대한 인수의 평가 순서). 가능한 경우이 국제 표준은 허용 가능한 동작 집합을 정의합니다. 이것들은 추상 기계의 비 결정적 측면을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="877fa79cfe0bb2180cea26e2a5734c4880504fb2" translate="yes" xml:space="preserve">
          <source>Certain other operations are described in this International Standard as &lt;strong&gt;undefined&lt;/strong&gt; (for example, the  effect of dereferencing the null pointer). [ &lt;em&gt;Note&lt;/em&gt;: &lt;strong&gt;this International Standard imposes no requirements on the behavior of programs that contain undefined behavior.&lt;/strong&gt; &amp;mdash;&lt;em&gt;end note&lt;/em&gt; ]</source>
          <target state="translated">다른 국제 오퍼레이션은이 국제 표준에서 &lt;strong&gt;정의되지 않은&lt;/strong&gt; 것으로 설명되어 있습니다 (예 : 널 포인터 역 참조의 영향). [ &lt;em&gt;참고&lt;/em&gt; : &lt;strong&gt;이 국제 표준은 정의되지 않은 동작을 포함하는 프로그램의 동작에 대한 요구 사항을 부과하지 않습니다.&lt;/strong&gt; &amp;mdash; &lt;em&gt;끝 참고&lt;/em&gt; ]</target>
        </trans-unit>
        <trans-unit id="0839b8c0f93bc7215bae8e654ced5403f6f34f98" translate="yes" xml:space="preserve">
          <source>For example, given the following code:</source>
          <target state="translated">예를 들어 다음 코드가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="910feb56caa0b4f4562dfa21c599f9c4fce3aea8" translate="yes" xml:space="preserve">
          <source>From the official C Rationale Document</source>
          <target state="translated">공식 C 근거 문서에서</target>
        </trans-unit>
        <trans-unit id="a2257744a12c541b56be26d9e4b425a8900f06cc" translate="yes" xml:space="preserve">
          <source>Historically, both Implementation-Defined Behavior and Undefined Behavior represented situations in which the authors of the Standard expected that people writing quality implementations would use judgment to decide what behavioral guarantees, if any, would be useful for programs in the intended application field running on the intended targets.  The needs of high-end number-crunching code are quite different from those of low-level systems code, and both UB and IDB give compiler writers flexibility to meet those different needs.  Neither category mandates that implementations behave in a way that's useful for any particular purpose, or even for any purpose whatsoever.  Quality implementations that claim to be suitable for a particular purpose, however, should behave in a manner befitting such purpose &lt;em&gt;whether the Standard requires it or not&lt;/em&gt;.</source>
          <target state="translated">역사적으로, 구현 정의 행동과 정의되지 않은 행동은 표준 구현 자들이 품질 구현을 작성하는 사람들이 판단을 사용하여 행동 보장이있을 경우 어떤 행동 보장이 응용 프로그램에서 실행되는 의도 된 응용 분야의 프로그램에 도움이 될지를 결정할 것으로 예상하는 상황을 나타 냈습니다. 의도 된 목표. 하이 엔드 숫자 처리 코드의 요구는 저수준 시스템 코드의 요구와는 상당히 다르며 UB와 IDB는 컴파일러 작성자에게 다양한 요구를 충족시킬 수있는 유연성을 제공합니다. 범주는 구현이 특정 목적이나 어떤 목적에도 유용한 방식으로 작동하도록 요구하지 않습니다. 그러나 특정 목적에 적합하다고 주장하는 품질 구현 &lt;em&gt;은 표준이 요구하든 아니든&lt;/em&gt; 그러한 목적에 적합한 방식으로 행동해야한다.</target>
        </trans-unit>
        <trans-unit id="2540f81c26e6466020aee474b4a78829aae36435" translate="yes" xml:space="preserve">
          <source>I can hear people screaming &quot;But wait, I can compile this no problem and get the output &lt;code&gt;yellow&lt;/code&gt;&quot; or &quot;What do you mean undefined, string literals are stored in read-only memory, so the first assignment attempt results in a core dump&quot;. This is exactly the problem with undefined behavior. Basically, the standard allows anything to happen once you invoke undefined behavior (even nasal demons). If there is a &quot;correct&quot; behavior according to your mental model of the language, that model is simply wrong; The C++ standard has the only vote, period.</source>
          <target state="translated">사람들이 비명을 지르는 것을들을 수 있습니다. &quot;잠깐만 요,이 문제를 컴파일하지 않고 출력을 &lt;code&gt;yellow&lt;/code&gt; 표시 할 수 있습니다.&quot; . 이것은 정의되지 않은 동작의 문제입니다. 기본적으로이 표준은 정의되지 않은 동작 (비강 악마까지도)을 호출하면 어떤 일이든 발생할 수 있습니다. 언어의 당신의 정신 모델에 따라 &quot;올바른&quot;행동이 있다면, 그 모델은 단순히 잘못된 것입니다; C ++ 표준에는 유일한 투표 기간이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3cbfc77c16c8f8fe13215121e443b68e0af440a" translate="yes" xml:space="preserve">
          <source>IMO far too many &quot;things&quot; are left
  undefined, unspecified,
  implementation-defined, etc. However,
  that's easy to say and even to give
  examples of, but hard to fix. It
  should also be noted that it is not
  all that difficult to avoid most of
  the problems and produce portable
  code.</source>
          <target state="translated">IMO가 너무 많은 &quot;사물&quot;은 정의되지 않은, 지정되지 않은, 구현 정의 된 등으로 남아 있습니다. 그러나 그것은 말하기 쉽고 예를 제시하기는 어렵지만 수정하기는 어렵습니다. 또한 대부분의 문제를 피하고 이식 가능한 코드를 생성하는 것이 어려운 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a291455822dc1c54fd3c820d50b04b5689f1956b" translate="yes" xml:space="preserve">
          <source>Implementation defined-</source>
          <target state="translated">구현 정의</target>
        </trans-unit>
        <trans-unit id="f0d8b740f7f9ff893a0572fcc79dd50d8329925f" translate="yes" xml:space="preserve">
          <source>Implementors wish,should be well documented,standard gives choices but sure to compile</source>
          <target state="translated">구현자는 원하는 문서를 잘 작성해야하며 표준은 선택을 제공하지만 반드시 컴파일해야합니다.</target>
        </trans-unit>
        <trans-unit id="fd18bf07df2a483e12d5b771dc0b3af5d3a88ea6" translate="yes" xml:space="preserve">
          <source>It is claimed that the difference
  between what can be produced giving
  the compiler this freedom and
  requiring &quot;ordinary left-to-right
  evaluation&quot; can be significant. I'm
  unconvinced, but with innumerable
  compilers &quot;out there&quot; taking advantage
  of the freedom and some people
  passionately defending that freedom, a
  change would be difficult and could
  take decades to penetrate to the
  distant corners of the C and C++
  worlds. I am disappointed that not all
  compilers warn against code such as
  ++i+i++. Similarly, the order of evaluation of arguments is
  unspecified.</source>
          <target state="translated">컴파일러에게 이러한 자유를 제공하고 &quot;일반적인 왼쪽에서 오른쪽 평가&quot;를 요구하는 것의 차이는 중요 할 수 있다고 주장됩니다. 나는 확신 할 수 없지만 자유를 활용하는 무수한 컴파일러가 있고 자유를 열정적으로 지키는 일부 사람들이 있다면 변화가 어려울 수 있으며 C와 C ++ 세계의 먼 구석에 침투하는 데 수십 년이 걸릴 수 있습니다. 모든 컴파일러가 ++ i + i ++와 같은 코드에 대해 경고하는 것은 아닙니다. 마찬가지로, 인수 평가 순서는 지정되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdf5bfd499acd8a1d289a719f15515471ac74fca" translate="yes" xml:space="preserve">
          <source>Let's look at a classic example:</source>
          <target state="translated">고전적인 예를 보자.</target>
        </trans-unit>
        <trans-unit id="70c706a5f40b3cd3a5d8a17c0d0b0ab9a0ca06a5" translate="yes" xml:space="preserve">
          <source>Maybe easy wording could be easier for understanding than the rigorous definition of the standards.</source>
          <target state="translated">표준에 대한 엄격한 정의보다 이해하기 쉬운 표현이 더 쉬울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a745746f33c45b300b6511a474f5f3daaf2664a" translate="yes" xml:space="preserve">
          <source>Other examples of undefined behavior include accessing an array beyond its bounds, &lt;a href=&quot;https://stackoverflow.com/q/2894891&quot;&gt;dereferencing the null pointer&lt;/a&gt;, &lt;a href=&quot;https://stackoverflow.com/q/6441218&quot;&gt;accessing objects after their lifetime ended&lt;/a&gt; or writing &lt;a href=&quot;https://stackoverflow.com/q/949433&quot;&gt;allegedly clever expressions&lt;/a&gt; like &lt;code&gt;i++ + ++i&lt;/code&gt;.</source>
          <target state="translated">정의되지 않은 동작의 다른 예로는 경계를 넘어 배열에 액세스하고 &lt;a href=&quot;https://stackoverflow.com/q/2894891&quot;&gt;, 널 포인터를 역 참조하거나&lt;/a&gt; , &lt;a href=&quot;https://stackoverflow.com/q/6441218&quot;&gt;수명이 끝난 후에 오브젝트&lt;/a&gt; 에 액세스 하거나 &lt;code&gt;i++ + ++i&lt;/code&gt; 와 같은 &lt;a href=&quot;https://stackoverflow.com/q/949433&quot;&gt;영리한 표현식을&lt;/a&gt; 작성하는 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="319b32ef19056d6a4cc43f23a6017acb86983769" translate="yes" xml:space="preserve">
          <source>Permissible undefined behavior ranges from &lt;strong&gt;ignoring the situation completely with unpredictable results&lt;/strong&gt;, to behaving during translation or program execution in a documented manner characteristic of the environment (with or without the issuance of a diagnostic message), to terminating a translation or execution (with the issuance of a diagnostic message).</source>
          <target state="translated">허용되지 않는 정의 된 동작은 &lt;strong&gt;예측할 수없는 결과로 상황을 완전히 무시하는&lt;/strong&gt; 것에서부터 환경의 문서화 된 방식 (진단 메시지 발행 여부에 관계없이)으로 번역 또는 프로그램 실행 중 행동, 번역 또는 실행 종료 (발급 포함)에 이르기까지 다양합니다. 진단 메시지).</target>
        </trans-unit>
        <trans-unit id="f4c7eb67efae2426128053994ca5a87e8f8fc518" translate="yes" xml:space="preserve">
          <source>Same as implementation-defined but not documented</source>
          <target state="translated">구현 정의와 동일하지만 문서화되지 않음</target>
        </trans-unit>
        <trans-unit id="bfdc4a7a8214fa75e47089f0c3154e682f509bac" translate="yes" xml:space="preserve">
          <source>Section 1.9 of the C++ standard also mentions undefined behavior's two less dangerous brothers, &lt;strong&gt;unspecified behavior&lt;/strong&gt; and &lt;strong&gt;implementation-defined behavior&lt;/strong&gt;:</source>
          <target state="translated">C ++ 표준의 섹션 1.9에는 정의되지 않은 동작의 덜 위험한 두 형제, &lt;strong&gt;지정되지 않은 동작&lt;/strong&gt; 및 &lt;strong&gt;구현 정의 된 동작&lt;/strong&gt; 도 언급 &lt;strong&gt;되어&lt;/strong&gt; &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="34669cae5d82e706134e0fee4b3402d81d5ed84b" translate="yes" xml:space="preserve">
          <source>Sometimes C++ Standard doesn't impose particular behavior on some constructs but says instead that a particular, well defined behavior has to be chosen and &lt;strong&gt;described&lt;/strong&gt; by particular implementation (version of library). So user can still know exactly how will program behave even though Standard doesn't describe this.</source>
          <target state="translated">때로는 C ++ Standard는 일부 구문에 특정 동작을 부과하지 않지만 대신 특정 구현 (라이브러리 버전)에 의해 잘 정의 된 특정 동작을 선택하고 &lt;strong&gt;설명&lt;/strong&gt; 해야한다고 말합니다. 따라서 표준에서 설명하지 않아도 사용자는 프로그램이 어떻게 작동하는지 정확하게 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8adb8ad36deb332dc2e827438bafa13e25c65398" translate="yes" xml:space="preserve">
          <source>Specifically, section 1.3.24 states:</source>
          <target state="translated">특히 1.3.24 절에는 다음이 명시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="db0c3d454e250e7c9214ed030c2b4fe7f4dd68e8" translate="yes" xml:space="preserve">
          <source>The difference between implementation-defined and unspecified, is that the compiler is supposed to pick a behavior in the first case but it doesn't have to in the second case. For example, an implementation must have one and only one definition of &lt;code&gt;sizeof(int)&lt;/code&gt;. So, it can't say that &lt;code&gt;sizeof(int)&lt;/code&gt; is 4 for some portion of the program and 8 for others. Unlike unspecified behavior, where the compiler can say OK I am gonna evaluate these arguments left-to-right and the next function's arguments are evaluated right-to-left. It can happen in the same program, that's why it is called &lt;strong&gt;&lt;em&gt;unspecified&lt;/em&gt;&lt;/strong&gt;. In fact, C++ could have been made easier if some of the unspecified behaviors were specified. Take a look here at &lt;a href=&quot;http://www2.research.att.com/~bs/bs_faq2.html#undefined&quot;&gt;Dr. Stroustrup's answer for that&lt;/a&gt;:</source>
          <target state="translated">구현 정의와 지정되지 않은 차이점은 컴파일러가 첫 번째 경우 동작을 선택해야하지만 두 번째 경우에는 필요하지 않다는 것입니다. 예를 들어, 구현에는 &lt;code&gt;sizeof(int)&lt;/code&gt; 정의가 하나만 있어야합니다. 따라서 &lt;code&gt;sizeof(int)&lt;/code&gt; 가 프로그램의 일부에 대해서는 4이고 다른 부분에 대해서는 8이라고 말할 수 없습니다. 컴파일러가 OK라고 말할 수있는 지정되지 않은 동작과 달리이 인수를 왼쪽에서 오른쪽으로 평가하고 다음 함수의 인수를 오른쪽에서 왼쪽으로 평가합니다. 동일한 프로그램에서 발생할 수 있으므로 &lt;strong&gt;&lt;em&gt;unspecified&lt;/em&gt;&lt;/strong&gt; 라고합니다. 실제로 지정되지 않은 동작 중 일부를 지정하면 C ++가 더 쉬워 질 수 있습니다. &lt;a href=&quot;http://www2.research.att.com/~bs/bs_faq2.html#undefined&quot;&gt;Stroustrup 박사의 답변을&lt;/a&gt; 여기에서 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="13d01a83f882b45a7b8274361567d50862b09497" translate="yes" xml:space="preserve">
          <source>The effect of attempting to modify a string literal is undefined.</source>
          <target state="translated">문자열 리터럴을 수정하려는 결과는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8d8507b91d1b68503fc0556c8b0fc10ce87230ca" translate="yes" xml:space="preserve">
          <source>The language doesn't specify the evaluation, left to right or right to left! So an unspecified behavior may or mayn't result in an undefined behavior, but certainly your program should not produce an unspecified behavior.</source>
          <target state="translated">언어는 왼쪽에서 오른쪽으로 또는 오른쪽에서 왼쪽으로 평가를 지정하지 않습니다! 따라서 지정되지 않은 동작은 정의되지 않은 동작을 초래할 수도 있고 아닐 수도 있지만 프로그램에서 지정되지 않은 동작을 생성해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="03592da1d7f63ec108b81c8b1804b6691b9b3d0d" translate="yes" xml:space="preserve">
          <source>The language says that we have data-types. The compiler vendors specify what sizes shall they use, and provide a documentation of what they did.</source>
          <target state="translated">언어에는 데이터 유형이 있다고 말합니다. 컴파일러 공급 업체는 사용할 크기를 지정하고 수행 한 작업에 대한 문서를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="3fc47a5be1124c057ad6f2eacce91011ff65e6a4" translate="yes" xml:space="preserve">
          <source>The only difference between Implementation-Defined Behavior and Undefined Behavior is that the former requires that implementations define and document a consistent behavior &lt;em&gt;even in cases where nothing the implementation could possibly do would be useful&lt;/em&gt;.  The dividing line between them is not whether it would generally be useful for implementations to define behaviors (compiler writers should define useful behaviors when practical whether the Standard requires them to or not) but &lt;em&gt;whether there might be implementations where defining a behavior would be simultaneously costly and useless&lt;/em&gt;.  A judgment that such implementations might exist does not in any way, shape, or form, imply any judgment about the usefulness of supporting a defined behavior on other platforms.</source>
          <target state="translated">구현 정의 동작과 정의되지 않은 동작의 유일한 차이점은 구현 구현 &lt;em&gt;이 도움이 될 수없는 경우에도 구현에서&lt;/em&gt; 일관된 동작을 정의하고 문서화해야한다는 점입니다. 이들 사이의 구분선은 일반적으로 구현에서 동작을 정의하는 것이 유용한 지 여부 (컴파일러 작성자가 표준에서 요구하는지 여부에 관계없이 유용한 동작을 정의해야 함)가 아니라 &lt;em&gt;동작 정의가 동시에 비용이 많이 드는 구현이 있는지 여부입니다. 쓸모없는&lt;/em&gt; . 이러한 구현이 존재할 수 있다는 판단은 어떤 방식, 형태 또는 형태로도 다른 플랫폼에서 정의 된 동작을 지원하는 데 유용하다는 판단을 내포하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8e6faa7e4973d1b2d9160e16d12bcd7f321dc76f" translate="yes" xml:space="preserve">
          <source>The preferred philosophy among some of today's compiler writers, however, would suggest that because &lt;code&gt;v&lt;/code&gt; can only be negative if the program is going to engage in Undefined Behavior, there's no reason to have the program clip the negative range of &lt;code&gt;v&lt;/code&gt;.  Even though left-shifting of negative values used to be supported on every single compiler of significance, and a large amount of existing code relies upon that behavior, modern philosophy would interpret the fact that the Standard says that left-shifting negative values is UB as implying that compiler writers should feel free to ignore that.</source>
          <target state="translated">그러나 오늘날의 컴파일러 작성자 중 선호되는 철학은 프로그램이 정의되지 않은 동작에 관여하는 경우 &lt;code&gt;v&lt;/code&gt; 가 음수 일 수 있기 때문에 프로그램이 음수 범위 &lt;code&gt;v&lt;/code&gt; 의 클립을 가질 이유가 없음을 시사합니다. 음수 값의 왼쪽 이동이 모든 단일 컴파일러에서 지원되는 데 사용되었지만 기존 코드의 상당수가 그 동작에 의존하지만 현대 철학은 왼쪽 이동 음수 값이 다음과 같이 UB라는 사실을 표준에서 해석합니다. 컴파일러 작성자가이를 무시해도된다는 것을 암시합니다.</target>
        </trans-unit>
        <trans-unit id="9d036d9e98b9050d932b30c3ad251a8f116fe3fa" translate="yes" xml:space="preserve">
          <source>The semantic descriptions in this International Standard define a parameterized nondeterministic abstract machine.</source>
          <target state="translated">이 국제 표준의 의미 론적 설명은 매개 변수화 된 비결정론 적 추상 기계를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="19030c219a55b7d14c74fef4b37a31512d06bca0" translate="yes" xml:space="preserve">
          <source>The terms &lt;em&gt;unspecified&lt;/em&gt; behavior, &lt;em&gt;undefined&lt;/em&gt; behavior, and &lt;em&gt;implementation-defined&lt;/em&gt; behavior are used to categorize the result of writing programs whose properties the Standard does not, or cannot, completely describe.  The goal of adopting this categorization is to allow a certain variety among implementations which permits quality of implementation to be an active force in the marketplace as well as to allow certain popular extensions, without removing the cachet of conformance to the Standard.  Appendix F to the Standard catalogs those behaviors which fall into one of these three categories.</source>
          <target state="translated">&lt;em&gt;지정되지 않은&lt;/em&gt; 동작, &lt;em&gt;정의되지 않은&lt;/em&gt; 동작 및 &lt;em&gt;구현 정의 된&lt;/em&gt; 동작이라는 용어는 표준이 속성을 완전히 설명하지 않거나 완전히 설명 할 수없는 프로그램 작성 결과를 분류하는 데 사용됩니다. 이 분류를 채택하는 목적은 표준에 따른 적합성을 제거하지 않고도 구현 품질을 시장에서 적극적으로 강화할 수있을뿐만 아니라 시장에서 활발한 힘을 발휘할 수 있도록하는 다양한 구현을 허용하는 것입니다. 표준에 대한 부록 F는이 세 가지 범주 중 하나에 해당하는 행동을 정리합니다.</target>
        </trans-unit>
        <trans-unit id="7dab400ceb2afc2f8c18d46d1d68aff6ae94bb2c" translate="yes" xml:space="preserve">
          <source>The variable &lt;code&gt;p&lt;/code&gt; points to the string literal &lt;code&gt;&quot;hello!\n&quot;&lt;/code&gt;, and the two assignments below try to modify that string literal. What does this program do? According to section 2.14.5 paragraph 11 of the C++ standard, it invokes &lt;em&gt;undefined behavior&lt;/em&gt;:</source>
          <target state="translated">변수 &lt;code&gt;p&lt;/code&gt; 는 문자열 리터럴 &lt;code&gt;&quot;hello!\n&quot;&lt;/code&gt; 가리키고 아래 두 할당은 해당 문자열 리터럴을 수정하려고합니다. 이 프로그램은 무엇을합니까? C ++ 표준의 2.14.5 단락 11에 따르면 &lt;em&gt;정의되지 않은 동작을&lt;/em&gt; 호출합니다.</target>
        </trans-unit>
        <trans-unit id="b7cebcf19e1557782154ebbd8c8c7d81807ec461" translate="yes" xml:space="preserve">
          <source>Their final summary:</source>
          <target state="translated">그들의 최종 요약 :</target>
        </trans-unit>
        <trans-unit id="c9484df72a4301a0e58a21f280b9f6ef65c82d56" translate="yes" xml:space="preserve">
          <source>To sum up, unspecified behavior is usually something you shouldn't
  worry about, unless your software is required to be portable.
  Conversely, undefined behavior is always undesirable and should never
  occur.</source>
          <target state="translated">요약하면, 지정되지 않은 동작은 일반적으로 소프트웨어를 휴대 할 수있는 경우가 아니라면 걱정하지 않아도됩니다. 반대로 정의되지 않은 동작은 항상 바람직하지 않으며 절대 발생하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="5f0d39b8bae2a64f0cad3be5b95af63211bb7407" translate="yes" xml:space="preserve">
          <source>Undefined, unspecified and implementation-defined behavior</source>
          <target state="translated">정의되지 않은 지정되지 않은 구현 정의 동작</target>
        </trans-unit>
        <trans-unit id="588daf6c4c6ee3a04c3826fd5936ab1a8d2ab32c" translate="yes" xml:space="preserve">
          <source>Undefined-</source>
          <target state="translated">Undefined-</target>
        </trans-unit>
        <trans-unit id="96b97090ac320fedc26b22d09f94f06081349d26" translate="yes" xml:space="preserve">
          <source>Unfortunately, since the mid 1990s compiler writers have started to interpret the lack of behavioral mandates as an judgment that behavioral guarantees aren't worth the cost even in application fields where they're vital, and even on systems where they cost practically nothing.  Instead of treating UB as an invitation to exercise reasonable judgment, compiler writers have started treating it as an excuse &lt;em&gt;not&lt;/em&gt; to do so.</source>
          <target state="translated">불행하게도, 1990 년대 중반부터 컴파일러 제작자들은 행동 보장의 부족이 행동 보장이 중요하지 않은 응용 분야와 실질적으로 비용이 들지 않는 시스템에서도 비용 가치가 없다는 판단으로 해석하기 시작했습니다. UB를 합리적인 판단의 초청으로 취급하는 대신 컴파일러 작성자는 UB를 그렇게하지 &lt;em&gt;않는&lt;/em&gt; 변명으로 취급하기 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="030d71a8247686614320a9edf9e2d1ccd4e8d22b" translate="yes" xml:space="preserve">
          <source>Unspecified -</source>
          <target state="translated">불특정-</target>
        </trans-unit>
        <trans-unit id="a7708e91a446b4023bb1b77f84bcfd74a92520ac" translate="yes" xml:space="preserve">
          <source>Well, this is basically a straight copy-paste from the standard</source>
          <target state="translated">글쎄, 이것은 기본적으로 표준에서 직접 복사하여 붙여 넣습니다.</target>
        </trans-unit>
        <trans-unit id="87ad9d2884c3adbac2b3aade98d1e68308202232" translate="yes" xml:space="preserve">
          <source>What can you do to avoid running into undefined behavior? Basically, you have to read &lt;a href=&quot;https://stackoverflow.com/questions/388242/&quot;&gt;good C++ books&lt;/a&gt; by authors who know what they're talking about. Screw internet tutorials. Screw bullschildt.</source>
          <target state="translated">정의되지 않은 동작을 피하기 위해 무엇을 할 수 있습니까? 기본적으로, 당신은 그들이 무엇을 말하는지 알고있는 저자에 의해 &lt;a href=&quot;https://stackoverflow.com/questions/388242/&quot;&gt;좋은 C ++ 책&lt;/a&gt; 을 읽어야합니다. 인터넷 자습서를 조이십시오. 스크류 불스 어린이.</target>
        </trans-unit>
        <trans-unit id="08b722f8a37c3500626a622dbbf668cdcb065041" translate="yes" xml:space="preserve">
          <source>What is undefined behavior in C and C++?  What about unspecified behavior and implementation-defined behavior?  What is the difference between them?</source>
          <target state="translated">C 및 C ++에서 정의되지 않은 동작은 무엇입니까? 지정되지 않은 동작 및 구현 정의 된 동작은 어떻습니까? 그들 사이의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d0694b1543421d75294f9e15d7ae60bbe8c4dfec" translate="yes" xml:space="preserve">
          <source>When the program encounters construct that is not defined according to C++ Standard it is allowed to do whatever it wants to do ( maybe send an email to me or maybe send an email to you or maybe ignore the code completely).</source>
          <target state="translated">프로그램이 C ++ 표준에 따라 정의되지 않은 구문을 발견하면 원하는 모든 작업을 수행 할 수 있습니다 (이메일을 보내거나 이메일을 보내거나 코드를 완전히 무시할 수 있음).</target>
        </trans-unit>
        <trans-unit id="77c0292370d7dde2bb9273762fc4aa0ed7281573" translate="yes" xml:space="preserve">
          <source>Which function of these two is executed first?</source>
          <target state="translated">이 두 가지 중 어떤 기능이 먼저 실행됩니까?</target>
        </trans-unit>
        <trans-unit id="36ed259ac8c492d01bbcc825c13c77a68f563188" translate="yes" xml:space="preserve">
          <source>You are doing something wrong. For example, you have a very large value in an &lt;code&gt;int&lt;/code&gt; that doesn't fit in &lt;code&gt;char&lt;/code&gt;. How do you put that value in &lt;code&gt;char&lt;/code&gt;? actually there is no way! Anything could happen, but the most sensible thing would be to take the first byte of that int and put it in &lt;code&gt;char&lt;/code&gt;. It is just wrong to do that to assign the first byte, but thats what happens under the hood.</source>
          <target state="translated">당신은 뭔가 잘못하고 있습니다. 예를 들어, &lt;code&gt;char&lt;/code&gt; 에 맞지 않는 &lt;code&gt;int&lt;/code&gt; 값이 매우 큽니다. 그 값을 &lt;code&gt;char&lt;/code&gt; 에 어떻게 넣습니까? 실제로 방법은 없습니다! 어떤 일이든 일어날 수 있지만 가장 현명한 것은 int의 첫 번째 바이트를 가져 와서 &lt;code&gt;char&lt;/code&gt; 에 넣는 것입니다. 첫 번째 바이트를 할당하는 것은 잘못된 일이지만 그 결과는 후드 아래에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f107d231dbf1b031ddde5ed61218906955140fa4" translate="yes" xml:space="preserve">
          <source>a two's-complement implementation would not have to expend any effort
whatsoever to treat the expression &lt;code&gt;v &amp;lt;&amp;lt; pow&lt;/code&gt; as a two's-complement shift
without regard for whether &lt;code&gt;v&lt;/code&gt; was positive or negative.</source>
          <target state="translated">2의 보수 구현은 &lt;code&gt;v&lt;/code&gt; 가 양수인지 부정적인 지에 관계없이 표현 &lt;code&gt;v &amp;lt;&amp;lt; pow&lt;/code&gt; 를 2의 보수 시프트로 취급하기 위해 어떠한 노력도 들일 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b45f1d608a58c018e47110174b4665c9870aed4d" translate="yes" xml:space="preserve">
          <source>behavior for which this International Standard imposes no requirements
  [ Note: Undefined behavior may be expected when this International
  Standard omits any explicit definition of behavior or when a program
  uses an erroneous construct or erroneous data. Permissible undefined
  behavior ranges from ignoring the situation completely with
  unpredictable results, to behaving during translation or program
  execution in a documented manner characteristic of the environment
  (with or without the issuance of a diagnostic message), to terminating
  a translation or execution (with the issuance of a diagnostic
  message). Many erroneous program constructs do not engender undefined
  behavior; they are required to be diagnosed. &amp;mdash; end note ]</source>
          <target state="translated">이 국제 표준이 요구 사항을 부과하지 않는 행동 [참고 :이 국제 표준이 명시적인 행동 정의를 생략하거나 프로그램이 잘못된 구성 또는 잘못된 데이터를 사용하는 경우 정의되지 않은 동작이 예상 될 수 있습니다. 허용되지 않는 정의 된 동작은 예측할 수없는 결과로 상황을 완전히 무시하는 것부터, 환경의 특징적인 문서화 된 방식으로 진단 또는 프로그램 실행 중 (진단 메시지 발행 여부에 관계없이), 번역 또는 실행 종료 (발급 포함)에 이르기까지 다양합니다. 진단 메시지). 많은 잘못된 프로그램 구성은 정의되지 않은 동작을 유발하지 않습니다. 그들은 진단을 받아야합니다. &amp;mdash; 끝 참고]</target>
        </trans-unit>
        <trans-unit id="9724be63aed3070bfa520e88b4fcb6e7eaf4caeb" translate="yes" xml:space="preserve">
          <source>behavior, for a well-formed program construct and correct data, that
  depends on the implementation [ Note: The implementation is not
  required to document which behavior occurs. The range of possible
  behaviors is usually delineated by this International Standard. &amp;mdash; end
  note ]</source>
          <target state="translated">구현에 의존하는 올바른 형식의 프로그램 구성 및 올바른 데이터에 대한 동작 [참고 : 구현은 어떤 동작이 발생하는지 문서화 할 필요가 없습니다. 가능한 행동의 범위는 일반적으로이 국제 표준에 의해 묘사됩니다. &amp;mdash; 끝 참고]</target>
        </trans-unit>
        <trans-unit id="979dc22a1216b408e243d86c25ba9776652b3efb" translate="yes" xml:space="preserve">
          <source>behavior, for a well-formed program construct and correct data, that
  depends on the implementation and that each implementation documents</source>
          <target state="translated">구현 및 각 구현 문서에 따라 올바르게 구성된 프로그램 구성 및 올바른 데이터에 대한 동작</target>
        </trans-unit>
        <trans-unit id="2f6826c50a9aeeefffb662cd6899c5ec00cf5c96" translate="yes" xml:space="preserve">
          <source>for &lt;code&gt;fun(fun1(), fun2());&lt;/code&gt; isn't the
  behaviour &quot;implementation defined&quot;?
  The compiler has to choose one or the
  other course, after all?</source>
          <target state="translated">&lt;code&gt;fun(fun1(), fun2());&lt;/code&gt; 위해 (fun1 (), fun2 ()); &quot;구현 정의&quot;동작이 아닙니까? 컴파일러는 결국 하나 또는 다른 코스를 선택해야합니까?</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
