<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/23803743">
    <body>
      <group id="23803743">
        <trans-unit id="d463b26974837023cc7ad53507041d2aebfdc1be" translate="yes" xml:space="preserve">
          <source>But I've handled everything!</source>
          <target state="translated">しかし、私はすべてを処理してきました!</target>
        </trans-unit>
        <trans-unit id="9a97fbbd5882f028939bfdc7a4245822a12bcdf7" translate="yes" xml:space="preserve">
          <source>But the pattern works!</source>
          <target state="translated">でも、パターンが効いている!</target>
        </trans-unit>
        <trans-unit id="4c40f4a06af79b41fb859dec058bac4cf3132e55" translate="yes" xml:space="preserve">
          <source>How do I avoid it?</source>
          <target state="translated">どうやって回避すればいいの?</target>
        </trans-unit>
        <trans-unit id="584e40c1c7e7fc5e383937c3094b6f856810ce95" translate="yes" xml:space="preserve">
          <source>I was writing code that does something that looks like:</source>
          <target state="translated">みたいなことをするコードを書いていました。</target>
        </trans-unit>
        <trans-unit id="78c494d437c77be2e279eab36aa77d81a4e064db" translate="yes" xml:space="preserve">
          <source>If the other promise is rejected, this will happen unnoticed instead of being propagated to the new promise (where it would get handled) - and the new promise stays forever pending, which can induce leaks.</source>
          <target state="translated">他方の約束が拒否された場合、これは新しい約束に伝搬される代わりに(処理される)気づかれずに起こります-そして、新しい約束は永遠に保留されたままであり、これはリークを誘発する可能性があります。</target>
        </trans-unit>
        <trans-unit id="d03382a81d47290526320fb2606a097eb0cca71b" translate="yes" xml:space="preserve">
          <source>If you have found a need to compose some promises in a new way that is not supported by an existing helper function, writing your own function with unavoidable Deferreds should be your last option. Consider switching to a more featureful library, and/or file a bug against your current library. Its maintainer should be able to derive the composition from existing functions, implement a new helper function for you and/or help to identify the edge cases that need to be handled.</source>
          <target state="translated">もし、既存のヘルパー関数ではサポートされていない新しい方法でいくつかのプロミスを作成する必要性を見つけた場合、避けられないDeferredsを使って自分自身の関数を書くことが最後の選択肢になるはずです。より機能的なライブラリに乗り換えることを検討するか、現在のライブラリに対してバグを報告してください。メンテナは既存の関数から構成を導き出したり、あなたのために新しいヘルパー関数を実装したり、あるいは処理する必要があるエッジケースを特定するのを手伝ったりすることができるはずです。</target>
        </trans-unit>
        <trans-unit id="5c624500020a55f10538c6babd053e29af66d0d0" translate="yes" xml:space="preserve">
          <source>In contrast, using &lt;code&gt;.then()&lt;/code&gt; does automatically take care of both these scenarios, and rejects the new promise when an error happens:</source>
          <target state="translated">対照的に、 &lt;code&gt;.then()&lt;/code&gt; を使用すると、これらの両方のシナリオが自動的に処理され、エラーが発生すると新しいプロミスが拒否されます。</target>
        </trans-unit>
        <trans-unit id="c697d96b47b4558dcea7c3ee69875565650cd408" translate="yes" xml:space="preserve">
          <source>Lucky you. Unfortunately, it probably doesn't, as you likely forgot some edge case. In more than half of the occurrences I've seen, the author has forgotten to take care of the error handler:</source>
          <target state="translated">運がいいわね 残念ながら、おそらくエッジケースを忘れているのでしょう。私が見てきた事例の半分以上では、作者はエラーハンドラの処理を忘れていました。</target>
        </trans-unit>
        <trans-unit id="16c08558c2d717018f6b9bfd532dd645d7234b87" translate="yes" xml:space="preserve">
          <source>Promises are all about making asynchronous code more readable and behave like synchronous code without hiding that fact. Promises represent an abstraction over a value of one time operation, they abstract the notion of a statement or expression in a programming language.</source>
          <target state="translated">プロミスは、非同期コードをより読みやすくし、その事実を隠すことなく同期コードのように振る舞うことができるようにするためのものです。プロミスは1回の操作の値を抽象化したもので、プログラミング言語の文や式の概念を抽象化したものです。</target>
        </trans-unit>
        <trans-unit id="6f797568bd1d423fb144770de4b46fabf2b4bfda" translate="yes" xml:space="preserve">
          <source>Promises can chain with &lt;code&gt;.then&lt;/code&gt; and you can return promises directly. Your code in &lt;code&gt;getStuffDone&lt;/code&gt; can be rewritten as:</source>
          <target state="translated">&lt;code&gt;.then&lt;/code&gt; と連鎖でき、 Promiseを直接返すことができます。 &lt;code&gt;getStuffDone&lt;/code&gt; のコードは、 次のように書き直すことができます。</target>
        </trans-unit>
        <trans-unit id="8097b762ceecf7d68be6216c08dedc164dba44ff" translate="yes" xml:space="preserve">
          <source>Quoting Esailija:</source>
          <target state="translated">エサイリヤを引用して</target>
        </trans-unit>
        <trans-unit id="0bccfd81ecfac55bdc03876c77c0d1c61d21c60f" translate="yes" xml:space="preserve">
          <source>Really? Good. However, this will be pretty detailed and copious, especially if you use a promise library that supports other features like cancellation or message passing. Or maybe it will in the future, or you want to swap your library against a better one? You won't want to rewrite your code for that.</source>
          <target state="translated">そうなの?いいですね。しかし、これはかなり詳細で膨大なものになるでしょう、特にキャンセルやメッセージパッシングのような他の機能をサポートしているプロミスライブラリを使用している場合には。あるいは、将来的にはそうなるかもしれませんし、ライブラリをより良いものと交換したいかもしれません。そのためにコードを書き換える必要はないでしょう。</target>
        </trans-unit>
        <trans-unit id="95ae7d2eac0a04f289028492957415bee7ffca9c" translate="yes" xml:space="preserve">
          <source>So whenever you find yourself manually creating a &lt;code&gt;Promise&lt;/code&gt; or &lt;code&gt;Deferred&lt;/code&gt; and already existing promises are involved, &lt;strong&gt;check the library API first&lt;/strong&gt;. The Deferred antipattern is often applied by people who see promises [only] as an observer pattern - but &lt;a href=&quot;https://stackoverflow.com/a/22562045/1048572&quot;&gt;promises are &lt;em&gt;more&lt;/em&gt; than callbacks&lt;/a&gt;: they are supposed to be composable. Every decent library has lots of easy-to-use functions for the composition of promises in every thinkable manner, taking care of all the low-level stuff you don't want to deal with.</source>
          <target state="translated">そのため、手動で &lt;code&gt;Promise&lt;/code&gt; または &lt;code&gt;Deferred&lt;/code&gt; を作成していて、既存のPromiseが関係している&lt;strong&gt;場合は、最初にライブラリAPIを確認してください&lt;/strong&gt; 。 Deferredアンチパターンは、promise [のみ]をオブザーバーパターンと見なす人々によって適用されることが多いですが、promiseは&lt;a href=&quot;https://stackoverflow.com/a/22562045/1048572&quot;&gt;コールバック&lt;em&gt;以上の&lt;/em&gt;もので&lt;/a&gt;あり、構成可能であると想定されています。 すべてのまともなライブラリには、扱いたくないすべての低レベルのものを処理しながら、あらゆる考えられる方法で約束を構成するための使いやすい関数がたくさんあります。</target>
        </trans-unit>
        <trans-unit id="3d1f6f295c540696bd4099bedb1fc040e1690074" translate="yes" xml:space="preserve">
          <source>Someone told me this is called the &quot;&lt;strong&gt;deferred antipattern&lt;/strong&gt;&quot; or the &quot;&lt;strong&gt;&lt;code&gt;Promise&lt;/code&gt; constructor antipattern&lt;/strong&gt;&quot; respectively, what's bad about this code and why is this called an &lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-pattern&quot;&gt;antipattern&lt;/a&gt;?</source>
          <target state="translated">これはそれぞれ「 &lt;strong&gt;遅延アンチパターン&lt;/strong&gt; 」または「 &lt;strong&gt; &lt;code&gt;Promise&lt;/code&gt; コンストラクタアンチパターン&lt;/strong&gt; 」と呼ばれていると誰かから言われました。このコードの何が悪いのですか、なぜこれが&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-pattern&quot;&gt;アンチパターン&lt;/a&gt;と呼ばれているのですか？</target>
        </trans-unit>
        <trans-unit id="7a23c851439738d803901faf67e4cac821196be9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern&quot;&gt;deferred antipattern (now explicit-construction anti-pattern)&lt;/a&gt; coined by &lt;a href=&quot;https://stackoverflow.com/users/995876/esailija&quot;&gt;Esailija&lt;/a&gt; is a common anti-pattern people who are new to promises make, I've made it myself when I first used promises. The problem with the above code is that is fails to utilize the fact that promises chain.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/995876/esailija&quot;&gt;Esailija&lt;/a&gt;によって作られた&lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern&quot;&gt;延期されたアンチパターン（現在は明示的な構造のアンチパターン）&lt;/a&gt;は、約束をするのが初めての一般的なアンチパターンの人々です。 上記のコードの問題は、チェーンを約束するという事実を利用できないことです。</target>
        </trans-unit>
        <trans-unit id="e2e27400f54901a0ecae605efd0011c4e88268c9" translate="yes" xml:space="preserve">
          <source>The deferred antipattern is not only cumbersome, but also &lt;strong&gt;error-prone&lt;/strong&gt;. Using &lt;code&gt;.then()&lt;/code&gt; for chaining is much safer.</source>
          <target state="translated">延期されたアンチパターンは扱いにくいだけでなく、 &lt;strong&gt;エラーが発生しやすくなり&lt;/strong&gt;ます。 連鎖に &lt;code&gt;.then()&lt;/code&gt; を使用すると、はるかに安全です。</target>
        </trans-unit>
        <trans-unit id="18fb9dd6b7cd9c91e71bc29bd32cd10bb395d10d" translate="yes" xml:space="preserve">
          <source>The libraries' methods (&lt;code&gt;then&lt;/code&gt;) do not only natively support all the features, they also might have certain optimisations in place. Using them will likely make your code faster, or at least allow to be optimised by future revisions of the library.</source>
          <target state="translated">ライブラリのメソッド（）は、すべての機能をネイティブにサポートするだけでなく、特定の最適化を行っている場合もあります。 それらを使用すると、コードがより高速になるか、少なくともライブラリの将来のリビジョンで最適化できるようになります。</target>
        </trans-unit>
        <trans-unit id="2eed8676d1b400b9f1b270ba066b31f5a3735696" translate="yes" xml:space="preserve">
          <source>The same thing happens in the case that your callback code causes an error - e.g. when &lt;code&gt;result&lt;/code&gt; doesn't have a &lt;code&gt;property&lt;/code&gt; and an exception is thrown. That would go unhandled and leave the new promise unresolved.</source>
          <target state="translated">コールバックコードでエラーが発生した場合も同じことが起こります。たとえば、 &lt;code&gt;result&lt;/code&gt; &lt;code&gt;property&lt;/code&gt; がなく、例外がスローされた場合などです。 それは処理されず、新しい約束は未解決のままになります。</target>
        </trans-unit>
        <trans-unit id="48f86e52ac2282fd43a6ed5f87a48d42e64b8a3d" translate="yes" xml:space="preserve">
          <source>This is the most common anti-pattern. It is easy to fall into this when you don't really understand promises and think of them as glorified event emitters or callback utility. Let's recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel.</source>
          <target state="translated">これは最も一般的なアンチパターンです。プロミスをよく理解していなくて、プロミスを単なるイベントエミッタやコールバックユーティリティだと思っていると、このパターンに陥りやすくなります。要約すると、プロミスとは、同期コードで失われたフラットインデントや1つの例外チャンネルなどのプロパティを非同期コードに保持させることです。</target>
        </trans-unit>
        <trans-unit id="5a484eea5f14c1c496f8c9174a9affe5766ca420" translate="yes" xml:space="preserve">
          <source>What is the explicit promise construction antipattern and how do I avoid it</source>
          <target state="translated">明示的な約束構造のアンチパターンとは何か、それを回避するにはどうすればいいのか</target>
        </trans-unit>
        <trans-unit id="a4f9b46538829f0dbddc910df6d8c7ba996d66b5" translate="yes" xml:space="preserve">
          <source>What's wrong with it?</source>
          <target state="translated">何が悪いの?</target>
        </trans-unit>
        <trans-unit id="d1577db3a89bbc4504b44d01b65d4f6e6eb5ddc3" translate="yes" xml:space="preserve">
          <source>You should only use deferred objects when you are &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;converting an API to promises&lt;/a&gt; and can't do it automatically, or when you're writing aggregation functions that are easier expressed this way.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;APIをpromiseに変換&lt;/a&gt;して自動的に実行できない場合、またはこの方法で簡単に表現できる集計関数を作成している場合にのみ、遅延オブジェクトを使用する必要があります 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
