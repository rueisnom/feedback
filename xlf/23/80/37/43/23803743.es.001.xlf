<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/23803743">
    <body>
      <group id="23803743">
        <trans-unit id="d463b26974837023cc7ad53507041d2aebfdc1be" translate="yes" xml:space="preserve">
          <source>But I've handled everything!</source>
          <target state="translated">¡Pero yo me he encargado de todo!</target>
        </trans-unit>
        <trans-unit id="9a97fbbd5882f028939bfdc7a4245822a12bcdf7" translate="yes" xml:space="preserve">
          <source>But the pattern works!</source>
          <target state="translated">¡Pero el patrón funciona!</target>
        </trans-unit>
        <trans-unit id="4c40f4a06af79b41fb859dec058bac4cf3132e55" translate="yes" xml:space="preserve">
          <source>How do I avoid it?</source>
          <target state="translated">¿Cómo lo evito?</target>
        </trans-unit>
        <trans-unit id="584e40c1c7e7fc5e383937c3094b6f856810ce95" translate="yes" xml:space="preserve">
          <source>I was writing code that does something that looks like:</source>
          <target state="translated">Estaba escribiendo un código que hace algo que parece:</target>
        </trans-unit>
        <trans-unit id="78c494d437c77be2e279eab36aa77d81a4e064db" translate="yes" xml:space="preserve">
          <source>If the other promise is rejected, this will happen unnoticed instead of being propagated to the new promise (where it would get handled) - and the new promise stays forever pending, which can induce leaks.</source>
          <target state="translated">Si la otra promesa es rechazada,esto pasará desapercibido en lugar de ser propagado a la nueva promesa (donde se manejaría)-y la nueva promesa queda pendiente para siempre,lo que puede inducir fugas.</target>
        </trans-unit>
        <trans-unit id="d03382a81d47290526320fb2606a097eb0cca71b" translate="yes" xml:space="preserve">
          <source>If you have found a need to compose some promises in a new way that is not supported by an existing helper function, writing your own function with unavoidable Deferreds should be your last option. Consider switching to a more featureful library, and/or file a bug against your current library. Its maintainer should be able to derive the composition from existing functions, implement a new helper function for you and/or help to identify the edge cases that need to be handled.</source>
          <target state="translated">Si ha encontrado la necesidad de componer algunas promesas de una nueva forma que no esté apoyada por una función de ayuda existente,escribir su propia función con Deferreds inevitables debería ser su última opción.Considere la posibilidad de cambiar a una biblioteca con más funciones,o bien presente un error en su biblioteca actual.Su mantenedor debería ser capaz de derivar la composición de las funciones existentes,implementar una nueva función de ayuda para usted y/o ayudar a identificar los casos límite que deben ser tratados.</target>
        </trans-unit>
        <trans-unit id="5c624500020a55f10538c6babd053e29af66d0d0" translate="yes" xml:space="preserve">
          <source>In contrast, using &lt;code&gt;.then()&lt;/code&gt; does automatically take care of both these scenarios, and rejects the new promise when an error happens:</source>
          <target state="translated">Por el contrario, el uso de &lt;code&gt;.then()&lt;/code&gt; ocupa autom&amp;aacute;ticamente de estos dos escenarios y rechaza la nueva promesa cuando ocurre un error:</target>
        </trans-unit>
        <trans-unit id="c697d96b47b4558dcea7c3ee69875565650cd408" translate="yes" xml:space="preserve">
          <source>Lucky you. Unfortunately, it probably doesn't, as you likely forgot some edge case. In more than half of the occurrences I've seen, the author has forgotten to take care of the error handler:</source>
          <target state="translated">Qué afortunado.Desafortunadamente,probablemente no lo hace,ya que probablemente olvidaste algún caso límite.En más de la mitad de los casos que he visto,el autor ha olvidado ocuparse del manejador de errores:</target>
        </trans-unit>
        <trans-unit id="16c08558c2d717018f6b9bfd532dd645d7234b87" translate="yes" xml:space="preserve">
          <source>Promises are all about making asynchronous code more readable and behave like synchronous code without hiding that fact. Promises represent an abstraction over a value of one time operation, they abstract the notion of a statement or expression in a programming language.</source>
          <target state="translated">Las promesas se refieren a hacer más legible el código asíncrono y a comportarse como un código síncrono sin ocultar ese hecho.Las promesas representan una abstracción sobre un valor de una operación de tiempo,abstraen la noción de una declaración o expresión en un lenguaje de programación.</target>
        </trans-unit>
        <trans-unit id="6f797568bd1d423fb144770de4b46fabf2b4bfda" translate="yes" xml:space="preserve">
          <source>Promises can chain with &lt;code&gt;.then&lt;/code&gt; and you can return promises directly. Your code in &lt;code&gt;getStuffDone&lt;/code&gt; can be rewritten as:</source>
          <target state="translated">Las promesas pueden encadenarse con &lt;code&gt;.then&lt;/code&gt; y usted puede devolverlas directamente. Su c&amp;oacute;digo en &lt;code&gt;getStuffDone&lt;/code&gt; puede reescribirse como:</target>
        </trans-unit>
        <trans-unit id="8097b762ceecf7d68be6216c08dedc164dba44ff" translate="yes" xml:space="preserve">
          <source>Quoting Esailija:</source>
          <target state="translated">Citando a Esailija:</target>
        </trans-unit>
        <trans-unit id="0bccfd81ecfac55bdc03876c77c0d1c61d21c60f" translate="yes" xml:space="preserve">
          <source>Really? Good. However, this will be pretty detailed and copious, especially if you use a promise library that supports other features like cancellation or message passing. Or maybe it will in the future, or you want to swap your library against a better one? You won't want to rewrite your code for that.</source>
          <target state="translated">¿En serio? Bien.Sin embargo,esto será bastante detallado y copioso,especialmente si usas una biblioteca de promesas que soporte otras características como la cancelación o el paso de mensajes.O tal vez lo haga en el futuro,o quieres cambiar tu biblioteca por una mejor? No querrás reescribir tu código para eso.</target>
        </trans-unit>
        <trans-unit id="95ae7d2eac0a04f289028492957415bee7ffca9c" translate="yes" xml:space="preserve">
          <source>So whenever you find yourself manually creating a &lt;code&gt;Promise&lt;/code&gt; or &lt;code&gt;Deferred&lt;/code&gt; and already existing promises are involved, &lt;strong&gt;check the library API first&lt;/strong&gt;. The Deferred antipattern is often applied by people who see promises [only] as an observer pattern - but &lt;a href=&quot;https://stackoverflow.com/a/22562045/1048572&quot;&gt;promises are &lt;em&gt;more&lt;/em&gt; than callbacks&lt;/a&gt;: they are supposed to be composable. Every decent library has lots of easy-to-use functions for the composition of promises in every thinkable manner, taking care of all the low-level stuff you don't want to deal with.</source>
          <target state="translated">Por lo tanto, cada vez que se encuentre creando manualmente una &lt;code&gt;Promise&lt;/code&gt; o una Promesa &lt;code&gt;Deferred&lt;/code&gt; y ya est&amp;eacute;n involucradas, &lt;strong&gt;consulte primero la API de la biblioteca&lt;/strong&gt; . El antipatr&amp;oacute;n diferido a menudo es aplicado por personas que ven las promesas [solo] como un patr&amp;oacute;n de observaci&amp;oacute;n, pero las &lt;a href=&quot;https://stackoverflow.com/a/22562045/1048572&quot;&gt;promesas son &lt;em&gt;m&amp;aacute;s&lt;/em&gt; que devoluciones de llamada&lt;/a&gt; : se supone que son componibles. Cada biblioteca decente tiene muchas funciones f&amp;aacute;ciles de usar para la composici&amp;oacute;n de promesas de todas las maneras imaginables, cuidando todas las cosas de bajo nivel con las que no desea lidiar.</target>
        </trans-unit>
        <trans-unit id="3d1f6f295c540696bd4099bedb1fc040e1690074" translate="yes" xml:space="preserve">
          <source>Someone told me this is called the &quot;&lt;strong&gt;deferred antipattern&lt;/strong&gt;&quot; or the &quot;&lt;strong&gt;&lt;code&gt;Promise&lt;/code&gt; constructor antipattern&lt;/strong&gt;&quot; respectively, what's bad about this code and why is this called an &lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-pattern&quot;&gt;antipattern&lt;/a&gt;?</source>
          <target state="translated">Alguien me dijo que esto se llama &quot; &lt;strong&gt;antipatr&amp;oacute;n diferido&lt;/strong&gt; &quot; o &quot; &lt;strong&gt;antipatr&amp;oacute;n de constructor de promesas&lt;/strong&gt; &quot; respectivamente, &amp;iquest;qu&amp;eacute; tiene de malo este c&amp;oacute;digo y por qu&amp;eacute; se llama &lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-pattern&quot;&gt;antipatr&amp;oacute;n&lt;/a&gt; ?</target>
        </trans-unit>
        <trans-unit id="7a23c851439738d803901faf67e4cac821196be9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern&quot;&gt;deferred antipattern (now explicit-construction anti-pattern)&lt;/a&gt; coined by &lt;a href=&quot;https://stackoverflow.com/users/995876/esailija&quot;&gt;Esailija&lt;/a&gt; is a common anti-pattern people who are new to promises make, I've made it myself when I first used promises. The problem with the above code is that is fails to utilize the fact that promises chain.</source>
          <target state="translated">El &lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern&quot;&gt;antipatr&amp;oacute;n diferido (ahora antipatr&amp;oacute;n de construcci&amp;oacute;n expl&amp;iacute;cita)&lt;/a&gt; acu&amp;ntilde;ado por &lt;a href=&quot;https://stackoverflow.com/users/995876/esailija&quot;&gt;Esailija&lt;/a&gt; es un antipatr&amp;oacute;n com&amp;uacute;n que las personas que son nuevas en las promesas hacen, lo hice yo mismo cuando las us&amp;eacute; por primera vez. El problema con el c&amp;oacute;digo anterior es que no puede utilizar el hecho de que promete la cadena.</target>
        </trans-unit>
        <trans-unit id="e2e27400f54901a0ecae605efd0011c4e88268c9" translate="yes" xml:space="preserve">
          <source>The deferred antipattern is not only cumbersome, but also &lt;strong&gt;error-prone&lt;/strong&gt;. Using &lt;code&gt;.then()&lt;/code&gt; for chaining is much safer.</source>
          <target state="translated">El antipatr&amp;oacute;n diferido no solo es engorroso, sino tambi&amp;eacute;n &lt;strong&gt;propenso a errores&lt;/strong&gt; . Usar &lt;code&gt;.then()&lt;/code&gt; para encadenar es mucho m&amp;aacute;s seguro.</target>
        </trans-unit>
        <trans-unit id="18fb9dd6b7cd9c91e71bc29bd32cd10bb395d10d" translate="yes" xml:space="preserve">
          <source>The libraries' methods (&lt;code&gt;then&lt;/code&gt;) do not only natively support all the features, they also might have certain optimisations in place. Using them will likely make your code faster, or at least allow to be optimised by future revisions of the library.</source>
          <target state="translated">Los m&amp;eacute;todos de las bibliotecas ( &lt;code&gt;then&lt;/code&gt; ) no solo admiten de forma nativa todas las caracter&amp;iacute;sticas, sino que tambi&amp;eacute;n pueden tener ciertas optimizaciones en su lugar. Su uso probablemente acelerar&amp;aacute; su c&amp;oacute;digo, o al menos permitir&amp;aacute; que sea optimizado por futuras revisiones de la biblioteca.</target>
        </trans-unit>
        <trans-unit id="2eed8676d1b400b9f1b270ba066b31f5a3735696" translate="yes" xml:space="preserve">
          <source>The same thing happens in the case that your callback code causes an error - e.g. when &lt;code&gt;result&lt;/code&gt; doesn't have a &lt;code&gt;property&lt;/code&gt; and an exception is thrown. That would go unhandled and leave the new promise unresolved.</source>
          <target state="translated">Lo mismo sucede en el caso de que su c&amp;oacute;digo de devoluci&amp;oacute;n de llamada provoque un error, por ejemplo, cuando el &lt;code&gt;result&lt;/code&gt; ado no tiene una &lt;code&gt;property&lt;/code&gt; y se produce una excepci&amp;oacute;n. Eso quedar&amp;iacute;a sin control y dejar&amp;iacute;a la nueva promesa sin resolver.</target>
        </trans-unit>
        <trans-unit id="48f86e52ac2282fd43a6ed5f87a48d42e64b8a3d" translate="yes" xml:space="preserve">
          <source>This is the most common anti-pattern. It is easy to fall into this when you don't really understand promises and think of them as glorified event emitters or callback utility. Let's recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel.</source>
          <target state="translated">Este es el antipatrón más común.Es fácil caer en esto cuando no entiendes realmente las promesas y piensas en ellas como emisores de eventos glorificados o utilidad de devolución de llamada.Recapitulemos:las promesas se refieren a hacer que el código asíncrono retenga la mayoría de las propiedades perdidas del código síncrono como la indentación plana y un canal de excepción.</target>
        </trans-unit>
        <trans-unit id="5a484eea5f14c1c496f8c9174a9affe5766ca420" translate="yes" xml:space="preserve">
          <source>What is the explicit promise construction antipattern and how do I avoid it</source>
          <target state="translated">¿Cuál es la promesa explícita antipatrón de construcción y cómo la evito?</target>
        </trans-unit>
        <trans-unit id="a4f9b46538829f0dbddc910df6d8c7ba996d66b5" translate="yes" xml:space="preserve">
          <source>What's wrong with it?</source>
          <target state="translated">¿Qué tiene de malo?</target>
        </trans-unit>
        <trans-unit id="d1577db3a89bbc4504b44d01b65d4f6e6eb5ddc3" translate="yes" xml:space="preserve">
          <source>You should only use deferred objects when you are &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;converting an API to promises&lt;/a&gt; and can't do it automatically, or when you're writing aggregation functions that are easier expressed this way.</source>
          <target state="translated">Solo debe usar objetos diferidos cuando &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;convierte una API a promesas&lt;/a&gt; y no puede hacerlo autom&amp;aacute;ticamente, o cuando escribe funciones de agregaci&amp;oacute;n que se expresan m&amp;aacute;s f&amp;aacute;cilmente de esta manera.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
