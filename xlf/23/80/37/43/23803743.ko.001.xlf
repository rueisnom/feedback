<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/23803743">
    <body>
      <group id="23803743">
        <trans-unit id="d463b26974837023cc7ad53507041d2aebfdc1be" translate="yes" xml:space="preserve">
          <source>But I've handled everything!</source>
          <target state="translated">그러나 나는 모든 것을 처리했습니다!</target>
        </trans-unit>
        <trans-unit id="9a97fbbd5882f028939bfdc7a4245822a12bcdf7" translate="yes" xml:space="preserve">
          <source>But the pattern works!</source>
          <target state="translated">그러나 패턴이 작동합니다!</target>
        </trans-unit>
        <trans-unit id="4c40f4a06af79b41fb859dec058bac4cf3132e55" translate="yes" xml:space="preserve">
          <source>How do I avoid it?</source>
          <target state="translated">어떻게 피할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="584e40c1c7e7fc5e383937c3094b6f856810ce95" translate="yes" xml:space="preserve">
          <source>I was writing code that does something that looks like:</source>
          <target state="translated">나는 다음과 같은 것을하는 코드를 작성하고있었습니다.</target>
        </trans-unit>
        <trans-unit id="78c494d437c77be2e279eab36aa77d81a4e064db" translate="yes" xml:space="preserve">
          <source>If the other promise is rejected, this will happen unnoticed instead of being propagated to the new promise (where it would get handled) - and the new promise stays forever pending, which can induce leaks.</source>
          <target state="translated">다른 약속이 거부되면, 이것은 새로운 약속 (처리 될 곳)으로 전파되는 대신 눈에 띄지 않게됩니다. 새로운 약속은 영원히 보류되어 누출을 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d03382a81d47290526320fb2606a097eb0cca71b" translate="yes" xml:space="preserve">
          <source>If you have found a need to compose some promises in a new way that is not supported by an existing helper function, writing your own function with unavoidable Deferreds should be your last option. Consider switching to a more featureful library, and/or file a bug against your current library. Its maintainer should be able to derive the composition from existing functions, implement a new helper function for you and/or help to identify the edge cases that need to be handled.</source>
          <target state="translated">기존 헬퍼 함수에서 지원하지 않는 새로운 방식으로 일부 약속을 작성해야하는 경우, 피할 수없는 지연으로 고유 한 함수를 작성하는 것이 마지막 옵션이어야합니다. 보다 유용한 라이브러리로 전환하거나 현재 라이브러리에 버그를 신고하십시오. 관리자는 기존 기능에서 컴포지션을 도출하고, 새로운 도우미 기능을 구현하고 /하거나 처리해야하는 에지 사례를 식별 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="5c624500020a55f10538c6babd053e29af66d0d0" translate="yes" xml:space="preserve">
          <source>In contrast, using &lt;code&gt;.then()&lt;/code&gt; does automatically take care of both these scenarios, and rejects the new promise when an error happens:</source>
          <target state="translated">반대로 &lt;code&gt;.then()&lt;/code&gt; 사용 하면 두 시나리오를 자동으로 처리하고 오류가 발생하면 새로운 약속을 거부합니다.</target>
        </trans-unit>
        <trans-unit id="c697d96b47b4558dcea7c3ee69875565650cd408" translate="yes" xml:space="preserve">
          <source>Lucky you. Unfortunately, it probably doesn't, as you likely forgot some edge case. In more than half of the occurrences I've seen, the author has forgotten to take care of the error handler:</source>
          <target state="translated">운이 좋다 불행히도, 일부 경우를 잊어 버렸을 가능성이 높습니다. 내가 본 사건의 절반 이상에서 저자는 오류 처리기를 처리하는 것을 잊었습니다.</target>
        </trans-unit>
        <trans-unit id="16c08558c2d717018f6b9bfd532dd645d7234b87" translate="yes" xml:space="preserve">
          <source>Promises are all about making asynchronous code more readable and behave like synchronous code without hiding that fact. Promises represent an abstraction over a value of one time operation, they abstract the notion of a statement or expression in a programming language.</source>
          <target state="translated">약속은 비동기 코드를 더 읽기 쉽게 만들고 그 사실을 숨기지 않고 동기 코드처럼 동작하는 것입니다. 약속은 한 번의 연산 값에 대한 추상화를 나타내며, 프로그래밍 언어로 된 문장이나 표현의 개념을 추상화합니다.</target>
        </trans-unit>
        <trans-unit id="6f797568bd1d423fb144770de4b46fabf2b4bfda" translate="yes" xml:space="preserve">
          <source>Promises can chain with &lt;code&gt;.then&lt;/code&gt; and you can return promises directly. Your code in &lt;code&gt;getStuffDone&lt;/code&gt; can be rewritten as:</source>
          <target state="translated">약속은.와 &lt;code&gt;.then&lt;/code&gt; 수 있으며 약속을 직접 반환 할 수 있습니다. &lt;code&gt;getStuffDone&lt;/code&gt; 의 코드는 다음 과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8097b762ceecf7d68be6216c08dedc164dba44ff" translate="yes" xml:space="preserve">
          <source>Quoting Esailija:</source>
          <target state="translated">Esailija 인용 :</target>
        </trans-unit>
        <trans-unit id="0bccfd81ecfac55bdc03876c77c0d1c61d21c60f" translate="yes" xml:space="preserve">
          <source>Really? Good. However, this will be pretty detailed and copious, especially if you use a promise library that supports other features like cancellation or message passing. Or maybe it will in the future, or you want to swap your library against a better one? You won't want to rewrite your code for that.</source>
          <target state="translated">정말? 좋은. 그러나 이는 특히 취소 또는 메시지 전달과 같은 다른 기능을 지원하는 약속 라이브러리를 사용하는 경우 매우 상세하고 풍부합니다. 아니면 미래에 또는 라이브러리를 더 나은 라이브러리로 바꾸고 싶습니까? 이를 위해 코드를 다시 작성하고 싶지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="95ae7d2eac0a04f289028492957415bee7ffca9c" translate="yes" xml:space="preserve">
          <source>So whenever you find yourself manually creating a &lt;code&gt;Promise&lt;/code&gt; or &lt;code&gt;Deferred&lt;/code&gt; and already existing promises are involved, &lt;strong&gt;check the library API first&lt;/strong&gt;. The Deferred antipattern is often applied by people who see promises [only] as an observer pattern - but &lt;a href=&quot;https://stackoverflow.com/a/22562045/1048572&quot;&gt;promises are &lt;em&gt;more&lt;/em&gt; than callbacks&lt;/a&gt;: they are supposed to be composable. Every decent library has lots of easy-to-use functions for the composition of promises in every thinkable manner, taking care of all the low-level stuff you don't want to deal with.</source>
          <target state="translated">따라서 &lt;code&gt;Promise&lt;/code&gt; 또는 &lt;code&gt;Deferred&lt;/code&gt; 수동으로 작성하고 기존 약속이 포함 된 &lt;strong&gt;경우 라이브러리 API를 먼저 확인하십시오&lt;/strong&gt; . 지연된 반 패턴은 종종 약속 만 관찰자 패턴으로 보는 사람들에 의해 적용되지만 &lt;a href=&quot;https://stackoverflow.com/a/22562045/1048572&quot;&gt;약속은 콜백 이상&lt;/a&gt; 입니다. 모든 양질의 라이브러리에는 다루기 싫은 모든 하위 수준의 자료를 처리하면서 모든 생각할 수있는 방식으로 약속을 구성하는 데 사용하기 쉬운 많은 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d1f6f295c540696bd4099bedb1fc040e1690074" translate="yes" xml:space="preserve">
          <source>Someone told me this is called the &quot;&lt;strong&gt;deferred antipattern&lt;/strong&gt;&quot; or the &quot;&lt;strong&gt;&lt;code&gt;Promise&lt;/code&gt; constructor antipattern&lt;/strong&gt;&quot; respectively, what's bad about this code and why is this called an &lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-pattern&quot;&gt;antipattern&lt;/a&gt;?</source>
          <target state="translated">누군가 나에게 이것을 &quot; &lt;strong&gt;지연된 반 패턴&lt;/strong&gt; &quot;또는 &quot; &lt;strong&gt; &lt;code&gt;Promise&lt;/code&gt; 생성자 반&lt;/strong&gt; &lt;strong&gt;패턴&lt;/strong&gt; &quot;이라고 말했는데,이 코드에 대해 나쁜 점은 무엇이며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-pattern&quot;&gt;반 패턴&lt;/a&gt; 이라고 불리는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7a23c851439738d803901faf67e4cac821196be9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern&quot;&gt;deferred antipattern (now explicit-construction anti-pattern)&lt;/a&gt; coined by &lt;a href=&quot;https://stackoverflow.com/users/995876/esailija&quot;&gt;Esailija&lt;/a&gt; is a common anti-pattern people who are new to promises make, I've made it myself when I first used promises. The problem with the above code is that is fails to utilize the fact that promises chain.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/995876/esailija&quot;&gt;Esailija&lt;/a&gt; 가 개발 한 &lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern&quot;&gt;연기 된 반 패턴 (현재 명시 적 구성 반 패턴)&lt;/a&gt; 은 약속을 처음 접하는 일반적인 반 패턴 사람들입니다. 처음 약속을 사용할 때 직접 만들었습니다. 위의 코드의 문제점은 체인을 약속하는 사실을 활용하지 못한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e2e27400f54901a0ecae605efd0011c4e88268c9" translate="yes" xml:space="preserve">
          <source>The deferred antipattern is not only cumbersome, but also &lt;strong&gt;error-prone&lt;/strong&gt;. Using &lt;code&gt;.then()&lt;/code&gt; for chaining is much safer.</source>
          <target state="translated">지연된 반 패턴은 번거로울뿐만 아니라 &lt;strong&gt;오류가 발생하기 쉽습니다&lt;/strong&gt; . 체인에 &lt;code&gt;.then()&lt;/code&gt; 을 사용하는 것이 훨씬 안전합니다.</target>
        </trans-unit>
        <trans-unit id="18fb9dd6b7cd9c91e71bc29bd32cd10bb395d10d" translate="yes" xml:space="preserve">
          <source>The libraries' methods (&lt;code&gt;then&lt;/code&gt;) do not only natively support all the features, they also might have certain optimisations in place. Using them will likely make your code faster, or at least allow to be optimised by future revisions of the library.</source>
          <target state="translated">라이브러리의 메소드 ()는 모든 기능을 기본적으로 지원할뿐만 아니라 특정 최적화 기능을 갖추고있을 수도 있습니다. 그것들을 사용하면 코드가 더 빨라지거나 최소한 라이브러리의 개정판으로 최적화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2eed8676d1b400b9f1b270ba066b31f5a3735696" translate="yes" xml:space="preserve">
          <source>The same thing happens in the case that your callback code causes an error - e.g. when &lt;code&gt;result&lt;/code&gt; doesn't have a &lt;code&gt;property&lt;/code&gt; and an exception is thrown. That would go unhandled and leave the new promise unresolved.</source>
          <target state="translated">콜백 코드에서 오류가 발생하는 경우에도 마찬가지입니다. 예를 들어 &lt;code&gt;result&lt;/code&gt; 에 &lt;code&gt;property&lt;/code&gt; 이없고 예외가 발생한 경우. 그것은 처리되지 않고 새 약속을 해결하지 않은 채로 둡니다.</target>
        </trans-unit>
        <trans-unit id="48f86e52ac2282fd43a6ed5f87a48d42e64b8a3d" translate="yes" xml:space="preserve">
          <source>This is the most common anti-pattern. It is easy to fall into this when you don't really understand promises and think of them as glorified event emitters or callback utility. Let's recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel.</source>
          <target state="translated">이것은 가장 일반적인 안티 패턴입니다. 약속을 실제로 이해하지 못하고 약속을 영광스러운 이벤트 이미 터 또는 콜백 유틸리티로 생각할 때 여기에 빠지기 쉽습니다. 요약하자면 약속은 비동기 코드가 플랫 들여 쓰기 및 하나의 예외 채널과 같은 동기 코드의 손실 된 속성을 대부분 유지하도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a484eea5f14c1c496f8c9174a9affe5766ca420" translate="yes" xml:space="preserve">
          <source>What is the explicit promise construction antipattern and how do I avoid it</source>
          <target state="translated">명백한 약속 건설 반 패턴은 무엇이며 어떻게 피할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="a4f9b46538829f0dbddc910df6d8c7ba996d66b5" translate="yes" xml:space="preserve">
          <source>What's wrong with it?</source>
          <target state="translated">무슨 일이야?</target>
        </trans-unit>
        <trans-unit id="d1577db3a89bbc4504b44d01b65d4f6e6eb5ddc3" translate="yes" xml:space="preserve">
          <source>You should only use deferred objects when you are &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;converting an API to promises&lt;/a&gt; and can't do it automatically, or when you're writing aggregation functions that are easier expressed this way.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;API를 약속으로 변환하고&lt;/a&gt; 이를 자동으로 수행 할 수 없거나 이러한 방식으로 표현하기 쉬운 집계 함수를 작성할 때만 지연된 오브젝트를 사용해야합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
