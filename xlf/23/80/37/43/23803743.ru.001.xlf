<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/23803743">
    <body>
      <group id="23803743">
        <trans-unit id="d463b26974837023cc7ad53507041d2aebfdc1be" translate="yes" xml:space="preserve">
          <source>But I've handled everything!</source>
          <target state="translated">Но я со всем разобрался!</target>
        </trans-unit>
        <trans-unit id="9a97fbbd5882f028939bfdc7a4245822a12bcdf7" translate="yes" xml:space="preserve">
          <source>But the pattern works!</source>
          <target state="translated">Но шаблон работает!</target>
        </trans-unit>
        <trans-unit id="4c40f4a06af79b41fb859dec058bac4cf3132e55" translate="yes" xml:space="preserve">
          <source>How do I avoid it?</source>
          <target state="translated">Как мне избежать этого?</target>
        </trans-unit>
        <trans-unit id="584e40c1c7e7fc5e383937c3094b6f856810ce95" translate="yes" xml:space="preserve">
          <source>I was writing code that does something that looks like:</source>
          <target state="translated">Я писал код,который делает что-то похожее:</target>
        </trans-unit>
        <trans-unit id="78c494d437c77be2e279eab36aa77d81a4e064db" translate="yes" xml:space="preserve">
          <source>If the other promise is rejected, this will happen unnoticed instead of being propagated to the new promise (where it would get handled) - and the new promise stays forever pending, which can induce leaks.</source>
          <target state="translated">Если другое обещание будет отвергнуто,то это произойдет незамеченным,вместо того,чтобы быть переданным новому обещанию (где оно будет обработано)-и новое обещание останется в ожидании навсегда,что может привести к утечкам.</target>
        </trans-unit>
        <trans-unit id="d03382a81d47290526320fb2606a097eb0cca71b" translate="yes" xml:space="preserve">
          <source>If you have found a need to compose some promises in a new way that is not supported by an existing helper function, writing your own function with unavoidable Deferreds should be your last option. Consider switching to a more featureful library, and/or file a bug against your current library. Its maintainer should be able to derive the composition from existing functions, implement a new helper function for you and/or help to identify the edge cases that need to be handled.</source>
          <target state="translated">Если Вы нашли необходимость в составлении некоторых обещаний новым способом,который не поддерживается существующими вспомогательными функциями,то написание собственной функции с неизбежными деферредами должно быть Вашим последним вариантом.Подумайте о том,чтобы перейти на более функциональную библиотеку,а также или отправить ошибку против вашей текущей библиотеки.Ее сопровождающий должен быть в состоянии извлечь композицию из существующих функций,реализовать новую вспомогательную функцию для вас andor помочь определить крайние случаи,которые необходимо обработать.</target>
        </trans-unit>
        <trans-unit id="5c624500020a55f10538c6babd053e29af66d0d0" translate="yes" xml:space="preserve">
          <source>In contrast, using &lt;code&gt;.then()&lt;/code&gt; does automatically take care of both these scenarios, and rejects the new promise when an error happens:</source>
          <target state="translated">Напротив, использование &lt;code&gt;.then()&lt;/code&gt; автоматически позаботится об обоих этих сценариях и отклонит новое обещание при возникновении ошибки:</target>
        </trans-unit>
        <trans-unit id="c697d96b47b4558dcea7c3ee69875565650cd408" translate="yes" xml:space="preserve">
          <source>Lucky you. Unfortunately, it probably doesn't, as you likely forgot some edge case. In more than half of the occurrences I've seen, the author has forgotten to take care of the error handler:</source>
          <target state="translated">Повезло тебе.К сожалению,скорее всего,нет,так как ты,скорее всего,забыл какой-нибудь крайний случай.Более чем в половине случаев,которые я видел,автор забыл позаботиться об обработчике ошибок:</target>
        </trans-unit>
        <trans-unit id="16c08558c2d717018f6b9bfd532dd645d7234b87" translate="yes" xml:space="preserve">
          <source>Promises are all about making asynchronous code more readable and behave like synchronous code without hiding that fact. Promises represent an abstraction over a value of one time operation, they abstract the notion of a statement or expression in a programming language.</source>
          <target state="translated">Обещания заключаются в том,чтобы сделать асинхронный код более читабельным и вести себя как синхронный код,не скрывая этого факта.Обещания представляют собой абстракцию над значением одноразовой операции,они абстрагируют понятие оператора или выражения в языке программирования.</target>
        </trans-unit>
        <trans-unit id="6f797568bd1d423fb144770de4b46fabf2b4bfda" translate="yes" xml:space="preserve">
          <source>Promises can chain with &lt;code&gt;.then&lt;/code&gt; and you can return promises directly. Your code in &lt;code&gt;getStuffDone&lt;/code&gt; can be rewritten as:</source>
          <target state="translated">Обещания могут &lt;code&gt;.then&lt;/code&gt; с .then, и вы можете возвращать обещания напрямую. Ваш код в &lt;code&gt;getStuffDone&lt;/code&gt; может быть переписан как:</target>
        </trans-unit>
        <trans-unit id="8097b762ceecf7d68be6216c08dedc164dba44ff" translate="yes" xml:space="preserve">
          <source>Quoting Esailija:</source>
          <target state="translated">Цитирую Эсаилию:</target>
        </trans-unit>
        <trans-unit id="0bccfd81ecfac55bdc03876c77c0d1c61d21c60f" translate="yes" xml:space="preserve">
          <source>Really? Good. However, this will be pretty detailed and copious, especially if you use a promise library that supports other features like cancellation or message passing. Or maybe it will in the future, or you want to swap your library against a better one? You won't want to rewrite your code for that.</source>
          <target state="translated">Правда? Хорошо.Тем не менее,это будет довольно подробно и много,особенно если вы используете библиотеку обещаний,которая поддерживает другие функции,такие как отмена или передача сообщений.Или,может быть,это будет в будущем,или вы хотите поменять вашу библиотеку на лучшую? Вы не захотите переписывать свой код для этого.</target>
        </trans-unit>
        <trans-unit id="95ae7d2eac0a04f289028492957415bee7ffca9c" translate="yes" xml:space="preserve">
          <source>So whenever you find yourself manually creating a &lt;code&gt;Promise&lt;/code&gt; or &lt;code&gt;Deferred&lt;/code&gt; and already existing promises are involved, &lt;strong&gt;check the library API first&lt;/strong&gt;. The Deferred antipattern is often applied by people who see promises [only] as an observer pattern - but &lt;a href=&quot;https://stackoverflow.com/a/22562045/1048572&quot;&gt;promises are &lt;em&gt;more&lt;/em&gt; than callbacks&lt;/a&gt;: they are supposed to be composable. Every decent library has lots of easy-to-use functions for the composition of promises in every thinkable manner, taking care of all the low-level stuff you don't want to deal with.</source>
          <target state="translated">Поэтому всякий раз, когда вы обнаруживаете, что создаете &lt;code&gt;Promise&lt;/code&gt; или &lt;code&gt;Deferred&lt;/code&gt; вручную, и уже задействованы уже существующие обещания, &lt;strong&gt;сначала проверьте библиотечный API&lt;/strong&gt; . Отложенный антипаттерн часто применяется людьми, которые видят обещания [только] как образец наблюдателя - но &lt;a href=&quot;https://stackoverflow.com/a/22562045/1048572&quot;&gt;обещания - это &lt;em&gt;больше,&lt;/em&gt; чем обратные вызовы&lt;/a&gt; : они должны быть составными. Каждая приличная библиотека имеет множество простых в использовании функций для составления обещаний всеми возможными способами, заботясь обо всех вещах низкого уровня, с которыми вы не хотите иметь дело.</target>
        </trans-unit>
        <trans-unit id="3d1f6f295c540696bd4099bedb1fc040e1690074" translate="yes" xml:space="preserve">
          <source>Someone told me this is called the &quot;&lt;strong&gt;deferred antipattern&lt;/strong&gt;&quot; or the &quot;&lt;strong&gt;&lt;code&gt;Promise&lt;/code&gt; constructor antipattern&lt;/strong&gt;&quot; respectively, what's bad about this code and why is this called an &lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-pattern&quot;&gt;antipattern&lt;/a&gt;?</source>
          <target state="translated">Кто-то сказал мне, что это называется &amp;laquo; &lt;strong&gt;отложенным антипаттерном&lt;/strong&gt; &amp;raquo; или &amp;laquo; &lt;strong&gt;антипаттерном конструктора &lt;code&gt;Promise&lt;/code&gt; &lt;/strong&gt; &amp;raquo; соответственно, что плохого в этом коде и почему он называется &lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-pattern&quot;&gt;антипаттерном&lt;/a&gt; ?</target>
        </trans-unit>
        <trans-unit id="7a23c851439738d803901faf67e4cac821196be9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern&quot;&gt;deferred antipattern (now explicit-construction anti-pattern)&lt;/a&gt; coined by &lt;a href=&quot;https://stackoverflow.com/users/995876/esailija&quot;&gt;Esailija&lt;/a&gt; is a common anti-pattern people who are new to promises make, I've made it myself when I first used promises. The problem with the above code is that is fails to utilize the fact that promises chain.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern&quot;&gt;Отложенный антипаттерн (в настоящее время анти-паттерн явной конструкции),&lt;/a&gt; придуманный &lt;a href=&quot;https://stackoverflow.com/users/995876/esailija&quot;&gt;Эсайлией,&lt;/a&gt; является распространенным анти-паттерном людей, которые плохо знакомы с обещаниями, я сделал это сам, когда впервые использовал обещания. Проблема с приведенным выше кодом заключается в том, что он не использует тот факт, что обещает цепочку.</target>
        </trans-unit>
        <trans-unit id="e2e27400f54901a0ecae605efd0011c4e88268c9" translate="yes" xml:space="preserve">
          <source>The deferred antipattern is not only cumbersome, but also &lt;strong&gt;error-prone&lt;/strong&gt;. Using &lt;code&gt;.then()&lt;/code&gt; for chaining is much safer.</source>
          <target state="translated">Отложенный антипаттерн не только громоздок, но и &lt;strong&gt;подвержен ошибкам&lt;/strong&gt; . Использование &lt;code&gt;.then()&lt;/code&gt; для создания цепочек намного безопаснее.</target>
        </trans-unit>
        <trans-unit id="18fb9dd6b7cd9c91e71bc29bd32cd10bb395d10d" translate="yes" xml:space="preserve">
          <source>The libraries' methods (&lt;code&gt;then&lt;/code&gt;) do not only natively support all the features, they also might have certain optimisations in place. Using them will likely make your code faster, or at least allow to be optimised by future revisions of the library.</source>
          <target state="translated">Методы библиотек ( &lt;code&gt;then&lt;/code&gt; ) не только изначально поддерживают все функции, они также могут иметь определенные оптимизации. Их использование, скорее всего, сделает ваш код быстрее или, по крайней мере, позволит оптимизировать будущие изменения библиотеки.</target>
        </trans-unit>
        <trans-unit id="2eed8676d1b400b9f1b270ba066b31f5a3735696" translate="yes" xml:space="preserve">
          <source>The same thing happens in the case that your callback code causes an error - e.g. when &lt;code&gt;result&lt;/code&gt; doesn't have a &lt;code&gt;property&lt;/code&gt; and an exception is thrown. That would go unhandled and leave the new promise unresolved.</source>
          <target state="translated">То же самое происходит в том случае, если ваш код обратного вызова вызывает ошибку - например, когда &lt;code&gt;result&lt;/code&gt; не имеет &lt;code&gt;property&lt;/code&gt; и генерируется исключение. Это было бы необработанным и оставило бы новое обещание нерешенным.</target>
        </trans-unit>
        <trans-unit id="48f86e52ac2282fd43a6ed5f87a48d42e64b8a3d" translate="yes" xml:space="preserve">
          <source>This is the most common anti-pattern. It is easy to fall into this when you don't really understand promises and think of them as glorified event emitters or callback utility. Let's recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel.</source>
          <target state="translated">Это самый распространенный анти-образец.В это легко попасть,если вы не понимаете обещаний и думаете о них,как о прославленных эмиттерах событий или утилитах обратного вызова.Резюмируя,обещания заключаются в том,чтобы заставить асинхронный код сохранить большую часть потерянных свойств синхронного кода,таких как плоский отступ и один канал исключений.</target>
        </trans-unit>
        <trans-unit id="5a484eea5f14c1c496f8c9174a9affe5766ca420" translate="yes" xml:space="preserve">
          <source>What is the explicit promise construction antipattern and how do I avoid it</source>
          <target state="translated">Что является явным обещанием строительной антипатрии и как мне избежать этого.</target>
        </trans-unit>
        <trans-unit id="a4f9b46538829f0dbddc910df6d8c7ba996d66b5" translate="yes" xml:space="preserve">
          <source>What's wrong with it?</source>
          <target state="translated">Что с ним не так?</target>
        </trans-unit>
        <trans-unit id="d1577db3a89bbc4504b44d01b65d4f6e6eb5ddc3" translate="yes" xml:space="preserve">
          <source>You should only use deferred objects when you are &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;converting an API to promises&lt;/a&gt; and can't do it automatically, or when you're writing aggregation functions that are easier expressed this way.</source>
          <target state="translated">Вы должны использовать отложенные объекты только тогда, когда вы &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;конвертируете API в обещания&lt;/a&gt; и не можете делать это автоматически, или когда вы пишете функции агрегации, которые проще выразить таким образом.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
