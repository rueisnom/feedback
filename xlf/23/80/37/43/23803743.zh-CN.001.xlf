<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/23803743">
    <body>
      <group id="23803743">
        <trans-unit id="d463b26974837023cc7ad53507041d2aebfdc1be" translate="yes" xml:space="preserve">
          <source>But I've handled everything!</source>
          <target state="translated">但我已经处理好了一切!</target>
        </trans-unit>
        <trans-unit id="9a97fbbd5882f028939bfdc7a4245822a12bcdf7" translate="yes" xml:space="preserve">
          <source>But the pattern works!</source>
          <target state="translated">但这个模式很有效!</target>
        </trans-unit>
        <trans-unit id="4c40f4a06af79b41fb859dec058bac4cf3132e55" translate="yes" xml:space="preserve">
          <source>How do I avoid it?</source>
          <target state="translated">如何避免?</target>
        </trans-unit>
        <trans-unit id="584e40c1c7e7fc5e383937c3094b6f856810ce95" translate="yes" xml:space="preserve">
          <source>I was writing code that does something that looks like:</source>
          <target state="translated">我在写代码,做一些看起来像这样的事情。</target>
        </trans-unit>
        <trans-unit id="78c494d437c77be2e279eab36aa77d81a4e064db" translate="yes" xml:space="preserve">
          <source>If the other promise is rejected, this will happen unnoticed instead of being propagated to the new promise (where it would get handled) - and the new promise stays forever pending, which can induce leaks.</source>
          <target state="translated">如果另一个承诺被拒绝,这种情况会在不被注意到的情况下发生,而不是传播到新的承诺(在那里会得到处理)--而新的承诺会永远停留在悬而未决的状态,这可能会诱发泄密。</target>
        </trans-unit>
        <trans-unit id="d03382a81d47290526320fb2606a097eb0cca71b" translate="yes" xml:space="preserve">
          <source>If you have found a need to compose some promises in a new way that is not supported by an existing helper function, writing your own function with unavoidable Deferreds should be your last option. Consider switching to a more featureful library, and/or file a bug against your current library. Its maintainer should be able to derive the composition from existing functions, implement a new helper function for you and/or help to identify the edge cases that need to be handled.</source>
          <target state="translated">如果你发现需要用一种新的方式来编写一些承诺,而现有的帮助函数不支持的话,那么编写自己的函数,加上不可避免的Deferreds应该是你最后的选择。考虑切换到一个功能更强大的库,或者对你当前的库提出bug。它的维护者应该能够从现有的函数中推导出组成,为你实现一个新的辅助函数,或者帮助你识别需要处理的边缘情况。</target>
        </trans-unit>
        <trans-unit id="5c624500020a55f10538c6babd053e29af66d0d0" translate="yes" xml:space="preserve">
          <source>In contrast, using &lt;code&gt;.then()&lt;/code&gt; does automatically take care of both these scenarios, and rejects the new promise when an error happens:</source>
          <target state="translated">相反，使用 &lt;code&gt;.then()&lt;/code&gt; 会自动处理这两种情况，并在发生错误时拒绝新的承诺：</target>
        </trans-unit>
        <trans-unit id="c697d96b47b4558dcea7c3ee69875565650cd408" translate="yes" xml:space="preserve">
          <source>Lucky you. Unfortunately, it probably doesn't, as you likely forgot some edge case. In more than half of the occurrences I've seen, the author has forgotten to take care of the error handler:</source>
          <target state="translated">你很幸运。不幸的是,它可能没有,因为你很可能忘记了一些边缘情况。在我见过的超过一半的情况下,作者忘记了对错误处理程序的照顾。</target>
        </trans-unit>
        <trans-unit id="16c08558c2d717018f6b9bfd532dd645d7234b87" translate="yes" xml:space="preserve">
          <source>Promises are all about making asynchronous code more readable and behave like synchronous code without hiding that fact. Promises represent an abstraction over a value of one time operation, they abstract the notion of a statement or expression in a programming language.</source>
          <target state="translated">承诺的作用就是让异步代码更易读,表现得像同步代码一样,但又不掩盖这个事实。承诺代表了对一个时间操作的值的抽象,它们抽象了编程语言中的语句或表达式的概念。</target>
        </trans-unit>
        <trans-unit id="6f797568bd1d423fb144770de4b46fabf2b4bfda" translate="yes" xml:space="preserve">
          <source>Promises can chain with &lt;code&gt;.then&lt;/code&gt; and you can return promises directly. Your code in &lt;code&gt;getStuffDone&lt;/code&gt; can be rewritten as:</source>
          <target state="translated">承诺可以与 &lt;code&gt;.then&lt;/code&gt; 链接 ，您可以直接返回承诺。 您在 &lt;code&gt;getStuffDone&lt;/code&gt; 中的代码可以重写为：</target>
        </trans-unit>
        <trans-unit id="8097b762ceecf7d68be6216c08dedc164dba44ff" translate="yes" xml:space="preserve">
          <source>Quoting Esailija:</source>
          <target state="translated">引述Esailija的话:</target>
        </trans-unit>
        <trans-unit id="0bccfd81ecfac55bdc03876c77c0d1c61d21c60f" translate="yes" xml:space="preserve">
          <source>Really? Good. However, this will be pretty detailed and copious, especially if you use a promise library that supports other features like cancellation or message passing. Or maybe it will in the future, or you want to swap your library against a better one? You won't want to rewrite your code for that.</source>
          <target state="translated">真的吗?很好。然而,这将是相当详细和繁琐的,尤其是如果你使用的是支持其他功能的承诺库,比如取消或消息传递等功能的承诺库。或者说,也许它将来会支持,或者你想用更好的库来交换你的库?你不会想为此重写你的代码。</target>
        </trans-unit>
        <trans-unit id="95ae7d2eac0a04f289028492957415bee7ffca9c" translate="yes" xml:space="preserve">
          <source>So whenever you find yourself manually creating a &lt;code&gt;Promise&lt;/code&gt; or &lt;code&gt;Deferred&lt;/code&gt; and already existing promises are involved, &lt;strong&gt;check the library API first&lt;/strong&gt;. The Deferred antipattern is often applied by people who see promises [only] as an observer pattern - but &lt;a href=&quot;https://stackoverflow.com/a/22562045/1048572&quot;&gt;promises are &lt;em&gt;more&lt;/em&gt; than callbacks&lt;/a&gt;: they are supposed to be composable. Every decent library has lots of easy-to-use functions for the composition of promises in every thinkable manner, taking care of all the low-level stuff you don't want to deal with.</source>
          <target state="translated">因此，每当您发现自己手动创建 &lt;code&gt;Promise&lt;/code&gt; 或 &lt;code&gt;Deferred&lt;/code&gt; 并且涉及已经存在的Promise时 ， &lt;strong&gt;请首先检查库API&lt;/strong&gt; 。 Deferred反模式通常由将promise（仅）视为观察者模式的人应用，但是&lt;a href=&quot;https://stackoverflow.com/a/22562045/1048572&quot;&gt;promise不仅仅是回调&lt;/a&gt; ：它们应该是可组合的。 每个体面的图书馆都有许多易于使用的功能，以各种可想而知的方式来构成承诺，可以处理所有您不想处理的低级内容。</target>
        </trans-unit>
        <trans-unit id="3d1f6f295c540696bd4099bedb1fc040e1690074" translate="yes" xml:space="preserve">
          <source>Someone told me this is called the &quot;&lt;strong&gt;deferred antipattern&lt;/strong&gt;&quot; or the &quot;&lt;strong&gt;&lt;code&gt;Promise&lt;/code&gt; constructor antipattern&lt;/strong&gt;&quot; respectively, what's bad about this code and why is this called an &lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-pattern&quot;&gt;antipattern&lt;/a&gt;?</source>
          <target state="translated">有人告诉我这分别称为&amp;ldquo; &lt;strong&gt;延迟反模式&lt;/strong&gt; &amp;rdquo;或&amp;ldquo; &lt;strong&gt; &lt;code&gt;Promise&lt;/code&gt; 构造函数反模式&lt;/strong&gt; &amp;rdquo;，这段代码有什么不好之处，为什么&lt;a href=&quot;https://en.wikipedia.org/wiki/Anti-pattern&quot;&gt;又将&lt;/a&gt;其称为反模式 ？</target>
        </trans-unit>
        <trans-unit id="7a23c851439738d803901faf67e4cac821196be9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern&quot;&gt;deferred antipattern (now explicit-construction anti-pattern)&lt;/a&gt; coined by &lt;a href=&quot;https://stackoverflow.com/users/995876/esailija&quot;&gt;Esailija&lt;/a&gt; is a common anti-pattern people who are new to promises make, I've made it myself when I first used promises. The problem with the above code is that is fails to utilize the fact that promises chain.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/995876/esailija&quot;&gt;Esailija&lt;/a&gt;创造的&lt;a href=&quot;https://github.com/petkaantonov/bluebird/wiki/Promise-anti-patterns#the-deferred-anti-pattern&quot;&gt;递延反模式（现在是显式构造反模式）&lt;/a&gt;是一个新的对诺言做出新承诺的普通反模式人，当我第一次使用诺言时，我自己就做出了。 上面代码的问题是无法利用承诺链的事实。</target>
        </trans-unit>
        <trans-unit id="e2e27400f54901a0ecae605efd0011c4e88268c9" translate="yes" xml:space="preserve">
          <source>The deferred antipattern is not only cumbersome, but also &lt;strong&gt;error-prone&lt;/strong&gt;. Using &lt;code&gt;.then()&lt;/code&gt; for chaining is much safer.</source>
          <target state="translated">延迟的反模式不仅麻烦，而且&lt;strong&gt;容易出错&lt;/strong&gt; 。 使用 &lt;code&gt;.then()&lt;/code&gt; 进行链接要安全得多。</target>
        </trans-unit>
        <trans-unit id="18fb9dd6b7cd9c91e71bc29bd32cd10bb395d10d" translate="yes" xml:space="preserve">
          <source>The libraries' methods (&lt;code&gt;then&lt;/code&gt;) do not only natively support all the features, they also might have certain optimisations in place. Using them will likely make your code faster, or at least allow to be optimised by future revisions of the library.</source>
          <target state="translated">库的方法（ &lt;code&gt;then&lt;/code&gt; ）不仅本地支持所有功能，而且还可能具有某些优化功能。 使用它们可能会使您的代码更快，或者至少允许通过该库的未来版本进行优化。</target>
        </trans-unit>
        <trans-unit id="2eed8676d1b400b9f1b270ba066b31f5a3735696" translate="yes" xml:space="preserve">
          <source>The same thing happens in the case that your callback code causes an error - e.g. when &lt;code&gt;result&lt;/code&gt; doesn't have a &lt;code&gt;property&lt;/code&gt; and an exception is thrown. That would go unhandled and leave the new promise unresolved.</source>
          <target state="translated">在回调代码导致错误的情况下也会发生相同的事情-例如，当 &lt;code&gt;result&lt;/code&gt; 没有 &lt;code&gt;property&lt;/code&gt; 并且引发异常时。 那将无法处理，并使新的承诺无法实现。</target>
        </trans-unit>
        <trans-unit id="48f86e52ac2282fd43a6ed5f87a48d42e64b8a3d" translate="yes" xml:space="preserve">
          <source>This is the most common anti-pattern. It is easy to fall into this when you don't really understand promises and think of them as glorified event emitters or callback utility. Let's recap: promises are about making asynchronous code retain most of the lost properties of synchronous code such as flat indentation and one exception channel.</source>
          <target state="translated">这是最常见的反模式。当你不真正理解承诺的时候,很容易落入其中,把它们当成是美化的事件发射器或回调实用程序。让我们回顾一下:承诺就是让异步代码保留了同步代码的大部分丢失的属性,比如扁平化的缩进和一个异常通道。</target>
        </trans-unit>
        <trans-unit id="5a484eea5f14c1c496f8c9174a9affe5766ca420" translate="yes" xml:space="preserve">
          <source>What is the explicit promise construction antipattern and how do I avoid it</source>
          <target state="translated">什么是显性承诺建设反例,如何避免?</target>
        </trans-unit>
        <trans-unit id="a4f9b46538829f0dbddc910df6d8c7ba996d66b5" translate="yes" xml:space="preserve">
          <source>What's wrong with it?</source>
          <target state="translated">这有什么问题吗?</target>
        </trans-unit>
        <trans-unit id="d1577db3a89bbc4504b44d01b65d4f6e6eb5ddc3" translate="yes" xml:space="preserve">
          <source>You should only use deferred objects when you are &lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;converting an API to promises&lt;/a&gt; and can't do it automatically, or when you're writing aggregation functions that are easier expressed this way.</source>
          <target state="translated">仅在&lt;a href=&quot;https://stackoverflow.com/questions/22519784/how-do-i-convert-an-existing-callback-api-to-promises&quot;&gt;将API转换为Promise&lt;/a&gt;且无法自动执行时，或者在编写以这种方式表示的聚合函数时，才应使用延迟对象。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
