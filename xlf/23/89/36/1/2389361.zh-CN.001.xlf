<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/2389361">
    <body>
      <group id="2389361">
        <trans-unit id="325456df475221c1ef6e54223033b6bbc4319e40" translate="yes" xml:space="preserve">
          <source>&quot;Move&quot; your HEAD back to the desired commit.</source>
          <target state="translated">&quot;移动 &quot;你的head返回到所需的提交。</target>
        </trans-unit>
        <trans-unit id="61d42c1e98b427b9a26d8300709bdf0b98ed9d8f" translate="yes" xml:space="preserve">
          <source>&quot;Undo&quot; the given commit or commit range.</source>
          <target state="translated">&quot;撤销 &quot;指定的提交或提交范围。</target>
        </trans-unit>
        <trans-unit id="802e1da120c1f89aabbfdf52d39bdbae621bb87b" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;--merge&lt;/code&gt; option has nothing to do with the merge. It's just like &lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt;, but safer since it doesn't touch uncommitted changes.)</source>
          <target state="translated">（ &lt;code&gt;--merge&lt;/code&gt; 选项与合并无关。就像 &lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; 一样 ，但是更安全，因为它不会涉及未提交的更改。）</target>
        </trans-unit>
        <trans-unit id="de00e86b4b1adf7de42f72b04311752a53fdd076" translate="yes" xml:space="preserve">
          <source>--merge</source>
          <target state="translated">--merge</target>
        </trans-unit>
        <trans-unit id="4ecd5f0567755f3060a0a13616b8c5f76326c0b5" translate="yes" xml:space="preserve">
          <source>...gave me the following status.</source>
          <target state="translated">...给了我以下情况:</target>
        </trans-unit>
        <trans-unit id="28b300090e2627ad40216640d6db41b809ac2535" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HEAD&lt;/code&gt; is simply a reference to the current commit (latest) on the current branch.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 只是对当前分支上当前提交（最新）的引用。</target>
        </trans-unit>
        <trans-unit id="7a57403f4c67e271246c31134de2561578e1aff1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git push origin HEAD --force&lt;/code&gt; (Sending the new local master branch to origin/master)</source>
          <target state="translated">&lt;code&gt;git push origin HEAD --force&lt;/code&gt; （将新的本地master分支发送到origin / master）</target>
        </trans-unit>
        <trans-unit id="e175277d5a42e50ec6e6479703ed7804c2ac364c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reflog&lt;/code&gt; might return something like:</source>
          <target state="translated">&lt;code&gt;git reflog&lt;/code&gt; 可能返回类似以下内容：</target>
        </trans-unit>
        <trans-unit id="a4749f1dc2409947d7d60e018e360ecb9d38a626" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reflog&lt;/code&gt; will display any change which updated the &lt;code&gt;HEAD&lt;/code&gt; and checking out the desired reflog entry will set the &lt;code&gt;HEAD&lt;/code&gt; back to this commit.</source>
          <target state="translated">&lt;code&gt;git reflog&lt;/code&gt; 将显示任何更新了 &lt;code&gt;HEAD&lt;/code&gt; 的更改，并且签出所需的reflog条目会将 &lt;code&gt;HEAD&lt;/code&gt; 设置为此提交。</target>
        </trans-unit>
        <trans-unit id="6824acf82d333773d4cb1b528a8ee507942d3b97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard commitHash&lt;/code&gt; (you should use the commit that you want to restart, eg. 44a587491e32eafa1638aca7738)</source>
          <target state="translated">&lt;code&gt;git reset --hard commitHash&lt;/code&gt; （您应该使用要重新启动的提交，例如44a587491e32eafa1638aca7738）</target>
        </trans-unit>
        <trans-unit id="afe03d7202852f20a848103e8366601b6dd5a207" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Abort Merge&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1）中止合并&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="604fd099bd7cd9da0358f5149a0d3954897871d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Reset HEAD to remote branch&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2）将HEAD重置为远程分支&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1d90f072973b270bb411541b730bd6f99ace1422" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Delete current branch, and checkout again from the remote repository&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3）删除当前分支，然后再次从远程存储库中签出&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="759f848871d3d6afad67df3eb9500a6fb9eed6f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://git-scm.com/docs/git-reset&quot;&gt;&lt;code&gt;git reset --hard &amp;lt;commit_id&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://git-scm.com/docs/git-reset&quot;&gt; &lt;code&gt;git reset --hard &amp;lt;commit_id&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ded496589b80899aa4a4ac207caa1e2ae9791023" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://git-scm.com/docs/git-revert&quot;&gt;&lt;code&gt;git revert &amp;lt;sha-1&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://git-scm.com/docs/git-revert&quot;&gt; &lt;code&gt;git revert &amp;lt;sha-1&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5941d87399c11b4c01ccb41bbd0ab033fe969fd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;code&gt;First of all what is HEAD?&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;First of all what is HEAD?&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1253bf83df98a1b2c7a29a783edb0908bb3dd47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;code&gt;detached HEAD&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;detached HEAD&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="70dc12e1edbd51a0e4e9cfdd87cb6a28be10a15d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be aware that any modified and uncommitted/unstashed files will be reset to their unmodified state&lt;/strong&gt;. To keep them either stash changes away or see &lt;code&gt;--merge&lt;/code&gt; option below.</source>
          <target state="translated">&lt;strong&gt;请注意，任何已修改和未提交/未破坏的文件都将重置为未修改状态&lt;/strong&gt; 。 要保留它们或 &lt;code&gt;--merge&lt;/code&gt; 更改，或参见下面的--merge选项。</target>
        </trans-unit>
        <trans-unit id="785ae5f8e57e7bb1825787323ff5e8191b3b952c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Every time the HEAD is modified there will be a new entry in the &lt;code&gt;reflog&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;每次修改HEAD时， &lt;code&gt;reflog&lt;/code&gt; 中都会有一个新条目&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f4c249f9857d39172dcc4c1c2fe983b88b979cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rationale:&lt;/strong&gt; Reverting a merge is hard. There are too many solutions, depending on many factors such as whether you've committed or pushed your merge or if there were new commits since your merge. Also you still need to have a relatively deep understanding of git to adapt these solutions to your case. If you blindly follow some instructions, you can end up with an &quot;empty merge&quot; where nothing will be merged, and further merge attempts will make Git tell you &quot;Already up to date&quot;.</source>
          <target state="translated">&lt;strong&gt;理由：&lt;/strong&gt;恢复合并非常困难。 解决方案太多，取决于许多因素，例如您是否提交或推送了合并，或者自合并以来是否有新的提交。 同样，您仍然需要对git有较深的了解，以使这些解决方案适合您的情况。 如果您盲目地遵循一些说明，则可以得到&amp;ldquo;空合并&amp;rdquo;，其中什么都不会合并，并且进一步的合并尝试将使Git告诉您&amp;ldquo;已经是最新的&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="49c900ba5a0475e269165d778322be2846b3c474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Solution:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92822cdea3fbd4b6814a2bc1aeca9e144c90d3b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Strategy:&lt;/strong&gt; Create a new branch from where everything was good.</source>
          <target state="translated">&lt;strong&gt;策略：&lt;/strong&gt;从一切都很好的地方创建一个新分支。</target>
        </trans-unit>
        <trans-unit id="ebe69bfea64d906fe3fed1ef6e4fa226ee0104fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You have to change your HEAD, Not yours of course but git HEAD....&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;您必须更改您的HEAD，当然不是您的，而是git HEAD...。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7878cb7ef8c06d6486adcc9797b87c6465365093" translate="yes" xml:space="preserve">
          <source>A few options on how to recover from a detached HEAD:</source>
          <target state="translated">关于脱发后如何恢复的几个方案。</target>
        </trans-unit>
        <trans-unit id="d76df7a30f5ed122045ac3a75d6c4e419b411614" translate="yes" xml:space="preserve">
          <source>A further tip is to use the &lt;code&gt;--merge&lt;/code&gt; switch instead of &lt;code&gt;--hard&lt;/code&gt; since it doesn't reset files unnecessarily:</source>
          <target state="translated">另一个提示是使用 &lt;code&gt;--merge&lt;/code&gt; 开关而不是 &lt;code&gt;--hard&lt;/code&gt; ,因为它不会不必要地重置文件：</target>
        </trans-unit>
        <trans-unit id="c07f89042a4dd0ffc371963b232a49b6b7957ea5" translate="yes" xml:space="preserve">
          <source>A new commit with the undo patch will be committed while the original commit will remain in the history as well.</source>
          <target state="translated">一个新的提交与未做的补丁将被提交,而原来的提交也将保留在历史中。</target>
        </trans-unit>
        <trans-unit id="e5ac1659dd41072099f4d92d4a46bfdef39eb5cd" translate="yes" xml:space="preserve">
          <source>After a failed merge, when there is no &lt;code&gt;MERGE_HEAD&lt;/code&gt;, the failed merge can be undone with &lt;code&gt;git reset --merge&lt;/code&gt;, but not necessarily with &lt;code&gt;git merge --abort&lt;/code&gt;, &lt;strong&gt;so they are not only old and new syntax for the same thing&lt;/strong&gt;.</source>
          <target state="translated">合并失败后，如果没有 &lt;code&gt;MERGE_HEAD&lt;/code&gt; ，则可以使用 &lt;code&gt;git reset --merge&lt;/code&gt; 撤消失败的合并，但不必使用 &lt;code&gt;git merge --abort&lt;/code&gt; 撤消 ， &lt;strong&gt;因此它们不仅是同一事物的新旧语法&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9f5185d6277f1eba54caf7e60862955de339e287" translate="yes" xml:space="preserve">
          <source>Apply your right commits on the top of the right version of your repository by:</source>
          <target state="translated">通过在你的版本库的顶部应用你正确的提交。</target>
        </trans-unit>
        <trans-unit id="8a2844ea9ae989611adb5d08b55a7e2692655a53" translate="yes" xml:space="preserve">
          <source>As @Velmont suggested below in his answer, in this direct case using:</source>
          <target state="translated">正如@Velmont在下面的回答中所建议的,在这种情况下,直接使用:</target>
        </trans-unit>
        <trans-unit id="bc34ab887f36ec36b3e87a27a89b2efbc3dd7f7c" translate="yes" xml:space="preserve">
          <source>As you can see there &lt;code&gt;reset &amp;amp;&amp;amp; checkout&lt;/code&gt; modify the &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">如您所见， &lt;code&gt;reset &amp;amp;&amp;amp; checkout&lt;/code&gt; 修改了 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c5b6d235893c7cb7d9b70b9455462c17203536e6" translate="yes" xml:space="preserve">
          <source>Assuming your local master was not ahead of origin/master, you should be able to do</source>
          <target state="translated">假设你的地主不在原点主之前,你应该可以做到</target>
        </trans-unit>
        <trans-unit id="741385c466ef2ed2d072c32f555bfc099c9a7290" translate="yes" xml:space="preserve">
          <source>At this point, I saw the status message changed, so I tried doing a &lt;code&gt;git pull&lt;/code&gt;, and that seemed to work:</source>
          <target state="translated">在这一点上，我看到状态消息已更改，因此我尝试执行 &lt;code&gt;git pull&lt;/code&gt; ，这似乎可行：</target>
        </trans-unit>
        <trans-unit id="d73bafdf80b0a79ad2440bd70a0301445a0e504f" translate="yes" xml:space="preserve">
          <source>At this point, you can create a branch and start to work from this point on.</source>
          <target state="translated">这时,你可以创建一个分支,并从这一点开始工作。</target>
        </trans-unit>
        <trans-unit id="647929631e179f99ce2862dfa69111519a73acaa" translate="yes" xml:space="preserve">
          <source>Based upon some &lt;a href=&quot;http://www.gitready.com/intermediate/2009/03/16/rolling-back-changes-with-revert.html&quot;&gt;instructions I found&lt;/a&gt;, I tried running</source>
          <target state="translated">根据&lt;a href=&quot;http://www.gitready.com/intermediate/2009/03/16/rolling-back-changes-with-revert.html&quot;&gt;我发现的&lt;/a&gt;一些说明 ，我尝试运行</target>
        </trans-unit>
        <trans-unit id="add278ff9d7fbde2d4afd50132edee7adca64baa" translate="yes" xml:space="preserve">
          <source>Be sure to revert the revert if you're committing the branch again, like Linus said.</source>
          <target state="translated">一定要像Linus说的那样,如果你再次提交分支,一定要还原还原。</target>
        </trans-unit>
        <trans-unit id="1d4a2ba4128b23314b33fba35bc6aba78172b2a8" translate="yes" xml:space="preserve">
          <source>But actually, it is worth noticing that &lt;code&gt;git merge --abort&lt;/code&gt; is only equivalent to &lt;code&gt;git reset --merge&lt;/code&gt; given that &lt;code&gt;MERGE_HEAD&lt;/code&gt; is present. This can be read in the Git help for merge command.</source>
          <target state="translated">但实际上，值得注意的是， &lt;code&gt;MERGE_HEAD&lt;/code&gt; 存在 &lt;code&gt;git reset --merge&lt;/code&gt; ， &lt;code&gt;git merge --abort&lt;/code&gt; 仅等效于git reset --merge 。 可以在Git帮助中的合并命令中阅读。</target>
        </trans-unit>
        <trans-unit id="8343394d0b6fe219dae1e4cbcd2dfa56532a9f01" translate="yes" xml:space="preserve">
          <source>By using cherry-pick (the changes introduced by some existing commits)</source>
          <target state="translated">通过使用cherry-pick(一些现有提交的修改)</target>
        </trans-unit>
        <trans-unit id="763f4d79d626bfc47f2d63b4e9b5674356833785" translate="yes" xml:space="preserve">
          <source>Check it out (go back in time):</source>
          <target state="translated">仔细看一下(回过头去)。</target>
        </trans-unit>
        <trans-unit id="2f9302a11f149b660f4bbb181d2c6b2213165b8d" translate="yes" xml:space="preserve">
          <source>Check which commits you'd like to re-commit on the top of the previous correct version by:</source>
          <target state="translated">通过以下方式检查你想在之前正确版本的基础上重新提交哪些提交。</target>
        </trans-unit>
        <trans-unit id="9438d39d2891c592bbacacd8a10774d67bc0a1e7" translate="yes" xml:space="preserve">
          <source>Commit: &lt;code&gt;git commit&lt;/code&gt;</source>
          <target state="translated">提交： &lt;code&gt;git commit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37aaf5680093dad358c2bf506bd149419025e2a9" translate="yes" xml:space="preserve">
          <source>Concretely,</source>
          <target state="translated">Concretely,</target>
        </trans-unit>
        <trans-unit id="5af3839edce03334a51705ceb0c5dca7bfc39de3" translate="yes" xml:space="preserve">
          <source>Considering, you are working on develop branch in local repo, that syncs with remote/develop branch, you can do as below:</source>
          <target state="translated">考虑到你是在本地repo中开发分支,与远程开发分支同步,你可以按照下面的方法来做。</target>
        </trans-unit>
        <trans-unit id="a1672055cfcbedce57a1a29f1bf34bf34cfb36b5" translate="yes" xml:space="preserve">
          <source>Create a new branch from there and check it out:</source>
          <target state="translated">从那里创建一个新的分支,并检查它。</target>
        </trans-unit>
        <trans-unit id="255b2030ca33b51942c51609856638b7f0d7036c" translate="yes" xml:space="preserve">
          <source>Doing this...</source>
          <target state="translated">这样做.....</target>
        </trans-unit>
        <trans-unit id="816c010f06e6282726e365cc46b8ba04a725a585" translate="yes" xml:space="preserve">
          <source>Essentially, your merge &lt;code&gt;sha&lt;/code&gt; will be pointing to &lt;code&gt;HEAD@{0}&lt;/code&gt; if nothing else was committed after the merge and so &lt;code&gt;HEAD@{1}&lt;/code&gt; will be the previous point before the merge.</source>
          <target state="translated">本质上，如果合并后没有其他任何操作，则合并 &lt;code&gt;sha&lt;/code&gt; 将指向 &lt;code&gt;HEAD@{0}&lt;/code&gt; ，因此 &lt;code&gt;HEAD@{1}&lt;/code&gt; 将是合并之前的前一点。</target>
        </trans-unit>
        <trans-unit id="dc5484edea2fa1e7dc2a50403cdcd377264d521b" translate="yes" xml:space="preserve">
          <source>Find the revision that you want to receive the merge:</source>
          <target state="translated">找到你要接收合并的版本。</target>
        </trans-unit>
        <trans-unit id="51874dafb788a11b05b16847cfddf30e5530f335" translate="yes" xml:space="preserve">
          <source>First checking the right changes before merging them:</source>
          <target state="translated">首先检查正确的变更,然后再进行合并。</target>
        </trans-unit>
        <trans-unit id="17a9dfef7180d2cac4e3adda3a13506469db0227" translate="yes" xml:space="preserve">
          <source>First do &lt;code&gt;git reset --merge ORIG_HEAD&lt;/code&gt;</source>
          <target state="translated">首先做 &lt;code&gt;git reset --merge ORIG_HEAD&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d20206d045ba70ce71d8e61189dee4b3b09f7ff6" translate="yes" xml:space="preserve">
          <source>First, make sure that you've committed everything.</source>
          <target state="translated">首先,要确保你已经承诺了一切。</target>
        </trans-unit>
        <trans-unit id="8f668e1fab0f8bd3cff902ea5b1e65d5e96936fe" translate="yes" xml:space="preserve">
          <source>Fix your merge conflicts.</source>
          <target state="translated">修复你的合并冲突。</target>
        </trans-unit>
        <trans-unit id="75a1298429a484b33b7a8fd039a60535b3fa0ba1" translate="yes" xml:space="preserve">
          <source>Follow the link to the first/left parent (the one on your current branch before the merge, usually red for me)</source>
          <target state="translated">按照链接到左边的第一个父亲(合并前你当前分支上的那个分支,通常对我来说是红色的</target>
        </trans-unit>
        <trans-unit id="a21677fbf79c4f24fdce4efc4921ae3367808920" translate="yes" xml:space="preserve">
          <source>For example, I accidentally merged a develop branch into master and wanted to undo that. Using the following steps:</source>
          <target state="translated">例如,我不小心将一个开发分支合并到master,想撤销这个分支。使用下面的步骤。</target>
        </trans-unit>
        <trans-unit id="1e194ec8910b7058663e07c84da3ca131553b7a1" translate="yes" xml:space="preserve">
          <source>For those looking to reset after changes are pushed, do this
(Because this is the first post seen for any git reset merge questions)</source>
          <target state="translated">对于那些想在推送更改后重置的人来说,可以这样做(因为这是第一个看到的git重置合并问题的帖子</target>
        </trans-unit>
        <trans-unit id="44bf1ed54764304b5fc570d446d2980533e7b553" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;man git merge&lt;/code&gt;:</source>
          <target state="translated">来自 &lt;code&gt;man git merge&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="8043bd119d31e66c1d70d0e3001444d0b121e729" translate="yes" xml:space="preserve">
          <source>Good luck and go ahead!</source>
          <target state="translated">祝你们好运,走吧!</target>
        </trans-unit>
        <trans-unit id="c22d554933e904a95169c18c110c1f0e4f441168" translate="yes" xml:space="preserve">
          <source>Got to this question also looking to revert to match origin (ie, NO commits ahead of origin). Researching further, found there's a &lt;code&gt;reset&lt;/code&gt; command for exactly that:</source>
          <target state="translated">遇到这个问题时，也希望还原为匹配原点（即，在原点之前没有提交）。 进一步研究，发现有一个确切的 &lt;code&gt;reset&lt;/code&gt; 命令：</target>
        </trans-unit>
        <trans-unit id="0df541da1603fd706be139871c50875511174718" translate="yes" xml:space="preserve">
          <source>I don't want my branch to be ahead by any number of commits. How do I get back to that point?</source>
          <target state="translated">我不希望我的分支领先于任何数量的提交。如何才能回到那个点?</target>
        </trans-unit>
        <trans-unit id="43cc9dd5cf07954eb5f3ddb5f6da228ccc77880f" translate="yes" xml:space="preserve">
          <source>I just read this page as I'd accidentally merged a testing branch instead of my release branch with master for deploying (website, master is what is live).  The testing branch has two other branches merged to it and totals about six commits.</source>
          <target state="translated">我刚读到这个页面,因为我不小心把一个测试分支合并了一个测试分支,而不是我的发布分支和master的部署分支(网站,master是live)。测试分支有另外两个分支合并到了它,总共大约有六个提交。</target>
        </trans-unit>
        <trans-unit id="c8472f20eb671f27fce11198dbf9eb37f7ecd402" translate="yes" xml:space="preserve">
          <source>I then had to type in the same &lt;code&gt;git reset&lt;/code&gt; command several more times.  Each time I did that, the message changed by one as you can see below.</source>
          <target state="translated">然后，我不得不多次输入相同的 &lt;code&gt;git reset&lt;/code&gt; 命令。 每次我这样做时，该消息都会变成一个，如下所示。</target>
        </trans-unit>
        <trans-unit id="6aa11a668f525796780c5491a4a593498f6e7964" translate="yes" xml:space="preserve">
          <source>I think you can do &lt;code&gt;git rebase -i [hash] [branch_name]&lt;/code&gt;  where &lt;code&gt;[hash]&lt;/code&gt; is the identifying hash for however far back you want to rewind plus one (or however many commits back you want to go) and then delete the lines for the commits in the editor that you don't want any more. Save the file. Exit. Pray. And it should be rewound. You might have to do a &lt;code&gt;git reset --hard&lt;/code&gt;, but it should be good at this point. You can also use this to pull specific commits out of a stack, if you don't want to keep them in your history, but that can leave your repository in a state that you probably don't want.</source>
          <target state="translated">我认为您可以执行 &lt;code&gt;git rebase -i [hash] [branch_name]&lt;/code&gt; ，其中 &lt;code&gt;[hash]&lt;/code&gt; 是要倒带的倒数加上一个（或想倒回的提交数）的标识性哈希，然后删除以下行在编辑器中提交您不再想要的内容。 保存文件。 出口。 祈祷。 应该倒退。 您可能必须执行 &lt;code&gt;git reset --hard&lt;/code&gt; ，但此时应该很好。 如果您不想将特定的提交保留在历史记录中，则还可以使用它从堆栈中拉出特定的提交，但这会使您的存储库处于您可能不希望的状态。</target>
        </trans-unit>
        <trans-unit id="8248febcb055ef8ca8699cace925f0a5821f500b" translate="yes" xml:space="preserve">
          <source>I was able to resolve this problem with a single command that doesn't involve looking up a commit id.</source>
          <target state="translated">我能够用一条不涉及查找提交ID的命令来解决这个问题。</target>
        </trans-unit>
        <trans-unit id="df99b058b0781479579f97b096c6c5af7edee135" translate="yes" xml:space="preserve">
          <source>If the changes have been pushed you can use &lt;code&gt;git revert &amp;lt;branch_name&amp;gt;&lt;/code&gt; instead. Be sure to check out how to use &lt;a href=&quot;https://kolosek.com/git-reset-revert-and-checkout/&quot;&gt;git revert and git checkout&lt;/a&gt; in other scenarios as well.</source>
          <target state="translated">如果更改已被推送，则可以改用 &lt;code&gt;git revert &amp;lt;branch_name&amp;gt;&lt;/code&gt; 。 一定要检查出如何在其他情况下使用&lt;a href=&quot;https://kolosek.com/git-reset-revert-and-checkout/&quot;&gt;git revert和git checkout&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="c733929cdcbfaa01743e87a82f82e9031d738b19" translate="yes" xml:space="preserve">
          <source>If you are in a middle of merging you can always abort it
&lt;code&gt;git merge --abort&lt;/code&gt;</source>
          <target state="translated">如果您正在合并，可以随时中止 &lt;code&gt;git merge --abort&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9422c352652972680951f708ebef99f16b1a9f28" translate="yes" xml:space="preserve">
          <source>If you are in-between a bad merge (mistakenly done with wrong branch), and wanted to avoid the merge to go back to the branch latest as below:</source>
          <target state="translated">如果你是在一个错误的合并之间(错误的分支),并想避免合并到最新的分支,如下图所示。</target>
        </trans-unit>
        <trans-unit id="d6f1d087b9e3b013912752ff8a2acdef26394710" translate="yes" xml:space="preserve">
          <source>If you are not on the latest commit - meaning that &lt;code&gt;HEAD&lt;/code&gt; is pointing to a prior commit in history its called &lt;strong&gt;&lt;em&gt;&lt;code&gt;detached HEAD&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">如果您不在最新提交上，这意味着 &lt;code&gt;HEAD&lt;/code&gt; 指向历史上的先前提交，则称为&lt;strong&gt;&lt;em&gt; &lt;code&gt;detached HEAD&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad48d228d16dd9b23f14b53b640eb7fba65cf765" translate="yes" xml:space="preserve">
          <source>If you are working from remote develop branch, you can reset HEAD to the last commit on remote branch as below:</source>
          <target state="translated">如果你在远程开发分支中工作,你可以将HEAD重置为远程分支的最后一次提交,如下图所示。</target>
        </trans-unit>
        <trans-unit id="de10e059bcc25df5c903ac3a24896852e6f0b52b" translate="yes" xml:space="preserve">
          <source>If you committed the merge:</source>
          <target state="translated">如果你承诺的合并。</target>
        </trans-unit>
        <trans-unit id="bdde193ae9900f18f1aefc8ea40bbd791db2176b" translate="yes" xml:space="preserve">
          <source>If you didn't commit it yet, you can only use</source>
          <target state="translated">如果你还没有提交,你只能用</target>
        </trans-unit>
        <trans-unit id="5c5307bfa35d80268fa745bac89332c90bfc1b46" translate="yes" xml:space="preserve">
          <source>If you notice that you need to revert immediately after the merge and you haven't done anything else after the merge attempt, you can just issue this command:
&lt;code&gt;git reset --hard HEAD@{1}&lt;/code&gt;.</source>
          <target state="translated">如果您发现您需要在合并后立即还原，并且在合并尝试后没有执行任何其他操作，则可以发出以下命令： &lt;code&gt;git reset --hard HEAD@{1}&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="17b89e12d2b1d5e24223e0c7be5a31fd496b87f0" translate="yes" xml:space="preserve">
          <source>If you want a command-line solution, I suggest to just go with MBO's answer.</source>
          <target state="translated">如果你想要一个命令行的解决方案,我建议直接用MBO的答案。</target>
        </trans-unit>
        <trans-unit id="7337bb9dba1c56278b312febd484bb1b7e35dd12" translate="yes" xml:space="preserve">
          <source>If you're a newbie, you might like the graphical approach:</source>
          <target state="translated">如果你是个新手,也许你会喜欢这种图文并茂的方式。</target>
        </trans-unit>
        <trans-unit id="8aa0bf4f5380038f6198232bad4787999633cfce" translate="yes" xml:space="preserve">
          <source>If your merge and the corresponding commits were not pushed yet, you can always switch to another branch, delete the original one and re-create it.</source>
          <target state="translated">如果你的合并和对应的提交还没有推送,可以随时切换到另一个分支,删除原来的分支,再重新创建。</target>
        </trans-unit>
        <trans-unit id="8f986375773f0a4dab0c0d575adbaa74d652fd7c" translate="yes" xml:space="preserve">
          <source>In case when you have problems and your master branch didn't have any local changes, you can reset to &lt;code&gt;origin/master&lt;/code&gt;.</source>
          <target state="translated">万一遇到问题，并且您的master分支没有任何本地更改，则可以重置为 &lt;code&gt;origin/master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e72587463d0d1969e2293dad5931fd1c8b888b81" translate="yes" xml:space="preserve">
          <source>In this case, you will want to reset your branch with &lt;code&gt;git reset --hard &amp;lt;branch_name&amp;gt;&lt;/code&gt;. If you want to save your changes before reseting them be sure to create a new branch and &lt;code&gt;git checkout &amp;lt;branch_name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，您将需要使用 &lt;code&gt;git reset --hard &amp;lt;branch_name&amp;gt;&lt;/code&gt; 重置分支。 如果要在重置之前保存更改，请确保创建一个新分支并 &lt;code&gt;git checkout &amp;lt;branch_name&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="835e8186de0e2139ff91974a3572c6199aa893a7" translate="yes" xml:space="preserve">
          <source>It can be done multiple ways.</source>
          <target state="translated">它可以通过多种方式进行。</target>
        </trans-unit>
        <trans-unit id="b470f7ffd6798a18488ff3231577f66b2a1afdb6" translate="yes" xml:space="preserve">
          <source>It is strange that the simplest command was missing. Most answers work, but undoing the merge you just did, &lt;strong&gt;this is the easy and safe way&lt;/strong&gt;:</source>
          <target state="translated">最简单的命令丢失了很奇怪。 大多数答案都有效，但是撤消您刚才所做的合并， &lt;strong&gt;这是简单安全的方法&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="28cb6898f26ef59eaba0b3945ea6e16dadd0d527" translate="yes" xml:space="preserve">
          <source>It will get you back 1 commit.</source>
          <target state="translated">它可以让你回到1个承诺。</target>
        </trans-unit>
        <trans-unit id="f93d593515bdc4144771c2caa5447a305f5fb840" translate="yes" xml:space="preserve">
          <source>It will undo the merge (and everything that you did).</source>
          <target state="translated">它将撤销合并(以及你所做的一切)。</target>
        </trans-unit>
        <trans-unit id="59b33677d3f238b3babbf1857be058678bbb2c81" translate="yes" xml:space="preserve">
          <source>Its saver and simpler then resets described in many answers above</source>
          <target state="translated">它比上面的许多答案中描述的重置更省事,也更简单。</target>
        </trans-unit>
        <trans-unit id="85ce981d17031f57fc1b54541928100f47a775aa" translate="yes" xml:space="preserve">
          <source>Just create new branch, then cherry-pick desired commits to it.</source>
          <target state="translated">只需创建一个新的分支,然后在其上挑选想要的提交。</target>
        </trans-unit>
        <trans-unit id="f27c343c95e3214cc8cf642e3566d29eaf52ce71" translate="yes" xml:space="preserve">
          <source>Just for an extra option to look at, I've been mostly following the branching model described here: &lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot;&gt;http://nvie.com/posts/a-successful-git-branching-model/&lt;/a&gt; and as such have been merging with &lt;code&gt;--no-ff&lt;/code&gt; (no fast forward) usually.</source>
          <target state="translated">只是为了查看其他选项，我主要遵循此处描述的分支模型： &lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot;&gt;http&lt;/a&gt; ： //nvie.com/posts/a-successful-git-branching-model/ ，因此，它与 &lt;code&gt;--no-ff&lt;/code&gt; 通常不行（不快进）。</target>
        </trans-unit>
        <trans-unit id="1b2a74eb85dfd5b245e9780e2ee545ae6423e346" translate="yes" xml:space="preserve">
          <source>Kick off &lt;code&gt;gitk&lt;/code&gt; (from the command line, or right click in file browser if you have that)</source>
          <target state="translated">启动 &lt;code&gt;gitk&lt;/code&gt; （从命令行启动，或者在文件浏览器中右键单击）</target>
        </trans-unit>
        <trans-unit id="9c2cf4980576515018dcf281a59a80f8a5defd69" translate="yes" xml:space="preserve">
          <source>Lately, I've been using &lt;code&gt;git reflog&lt;/code&gt; to help with this. This mostly only works if the merge JUST happened, and it was on your machine.</source>
          <target state="translated">最近，我一直在使用 &lt;code&gt;git reflog&lt;/code&gt; 来帮助解决这个问题。 这仅在合并刚刚发生且仅在您的计算机上时才有效。</target>
        </trans-unit>
        <trans-unit id="143ecefea61961efc839f245f46701a865e8be24" translate="yes" xml:space="preserve">
          <source>Let's say you want to merge &lt;code&gt;dev&lt;/code&gt; into &lt;code&gt;feature-1&lt;/code&gt;.</source>
          <target state="translated">假设您要将 &lt;code&gt;dev&lt;/code&gt; 合并到 &lt;code&gt;feature-1&lt;/code&gt; 中 。</target>
        </trans-unit>
        <trans-unit id="c826fb47a708860edd83b926939efe96b331ff29" translate="yes" xml:space="preserve">
          <source>Merge: &lt;code&gt;git merge dev&lt;/code&gt;</source>
          <target state="translated">合并： &lt;code&gt;git merge dev&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caff5dbaaa425ac112f82a29a97c63ddfbb16edd" translate="yes" xml:space="preserve">
          <source>Note: (&lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/RelNotes/2.7.0.txt&quot;&gt;Since Git 2.7&lt;/a&gt;)</source>
          <target state="translated">注意：（ &lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/RelNotes/2.7.0.txt&quot;&gt;自Git 2.7起&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="b7db6b8a5b44621ffd1d3012155c989da65a2db2" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;@{u}&lt;/code&gt; is shorthand for &lt;code&gt;origin/master&lt;/code&gt;. (And, of course, you need that remote repository for this to work.)</source>
          <target state="translated">注意： &lt;code&gt;@{u}&lt;/code&gt; 是 &lt;code&gt;origin/master&lt;/code&gt; 的简写。 （当然，您需要该远程存储库才能正常工作。）</target>
        </trans-unit>
        <trans-unit id="2336afddcbd6b8c91db172d6af697f8cee8a4aa7" translate="yes" xml:space="preserve">
          <source>Now you can restart your merge:</source>
          <target state="translated">现在你可以重新启动你的合并了。</target>
        </trans-unit>
        <trans-unit id="e93ccff76d508309e8632c2d0a5de77b9d27c8ad" translate="yes" xml:space="preserve">
          <source>Okay, the answers other people here gave me were close, but it didn't work. Here's what I did.</source>
          <target state="translated">好吧,这里的其他人给我的答案很接近,但没有成功。我是这么做的</target>
        </trans-unit>
        <trans-unit id="7ac36912c0f775fe1d1f2c950c02c302154902e9" translate="yes" xml:space="preserve">
          <source>Old-school:</source>
          <target state="translated">Old-school:</target>
        </trans-unit>
        <trans-unit id="f8f107162d476c4c3d61d37ecf054ad642e5634f" translate="yes" xml:space="preserve">
          <source>Older syntax:</source>
          <target state="translated">较老的语法。</target>
        </trans-unit>
        <trans-unit id="763f2dd4255ea2a1dd599c21e06de6d56c84c77c" translate="yes" xml:space="preserve">
          <source>On the command line, it will look like this- SHA-1 instead of the branch name since the &lt;code&gt;HEAD&lt;/code&gt; is not pointing to the tip of the current branch</source>
          <target state="translated">在命令行上，它看起来像这样-SHA-1而不是分支名称，因为 &lt;code&gt;HEAD&lt;/code&gt; 并不指向当前分支的尖端</target>
        </trans-unit>
        <trans-unit id="952805b92e642b0e556543a1ca6d8386c41d6fb9" translate="yes" xml:space="preserve">
          <source>On the selected commit, right-click &quot;Reset branch  to here&quot;, pick the hard reset there</source>
          <target state="translated">在选定的提交上,右键单击 &quot;重设分支到这里&quot;,选择那里的硬重置</target>
        </trans-unit>
        <trans-unit id="c271dd52be8061bb235a10202e34d1d8931ad6d7" translate="yes" xml:space="preserve">
          <source>Or by cherry-picking the range of commits by:</source>
          <target state="translated">或通过偷工减料的方式,由。</target>
        </trans-unit>
        <trans-unit id="e64f39d14a7177892469d39e5bf8234bb87da140" translate="yes" xml:space="preserve">
          <source>Or even &lt;code&gt;HEAD^^&lt;/code&gt; to revert that revert commit. You can always give a full SHA reference if you're not sure how many steps back you should take.</source>
          <target state="translated">甚至 &lt;code&gt;HEAD^^&lt;/code&gt; 可以还原该还原提交。 如果您不确定应该返回多少步骤，则始终可以提供完整的SHA参考。</target>
        </trans-unit>
        <trans-unit id="950aeb777ec53567180decadaacecd984d98545f" translate="yes" xml:space="preserve">
          <source>Personally I find &lt;code&gt;git reset --merge&lt;/code&gt; much more powerful and useful in everyday work, so that's the one I always use.</source>
          <target state="translated">我个人觉得 &lt;code&gt;git reset --merge&lt;/code&gt; 在日常工作中合并起来更加强大和有用，所以这就是我一直使用的方法。</target>
        </trans-unit>
        <trans-unit id="8f6875e65a9f446b5cbbda749bcaab9d8a133268" translate="yes" xml:space="preserve">
          <source>Remove your local branch (local, not remote) and pull it again. This way you'll undo the changes on your master branch and anyone will be affected by the change you don't want to push. Start it over.</source>
          <target state="translated">移除你的本地分支(本地的,不是远程的),然后再拉一次。这样一来,你会撤销你的主分支上的更改,任何人都会受到你不想推送的更改的影响。重新开始。</target>
        </trans-unit>
        <trans-unit id="334349e182a1a9bce03cc62e966ca7b44024d875" translate="yes" xml:space="preserve">
          <source>Resets the index and updates the files in the working tree that are different between &amp;lt;commit&amp;gt; and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added).</source>
          <target state="translated">重置索引并更新工作树中&amp;lt;commit&amp;gt;和HEAD之间不同的文件，但保留那些索引和工作树中不同的文件（即那些尚未添加的更改）。</target>
        </trans-unit>
        <trans-unit id="fc9e581b11eb0b9775efb5c50a984923c9d05459" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Undoing-Things&quot;&gt;chapter 4 in the Git book&lt;/a&gt; and &lt;a href=&quot;http://opensource.apple.com/source/Git/Git-26/src/git-htmldocs/howto/revert-a-faulty-merge.txt&quot;&gt;the original post by Linus Torvalds&lt;/a&gt;.</source>
          <target state="translated">请参阅&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Undoing-Things&quot;&gt;Git书中的第4章和&lt;/a&gt; &lt;a href=&quot;http://opensource.apple.com/source/Git/Git-26/src/git-htmldocs/howto/revert-a-faulty-merge.txt&quot;&gt;Linus Torvalds的原始帖子&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="274b6215158331f2fe726e7c73e61ffa2099ff28" translate="yes" xml:space="preserve">
          <source>So before answering let's add some background, explaining what is this &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">因此，在回答之前，让我们添加一些背景，解释什么是 &lt;code&gt;HEAD&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7d463af4fb364637f2c63bf67569e71bb8b0540" translate="yes" xml:space="preserve">
          <source>So long story short, my commands came down to this:</source>
          <target state="translated">所以长话短说,我的命令是这样的。</target>
        </trans-unit>
        <trans-unit id="b147c3dc3a4f5cd9fb62164e17ab88631309f7a0" translate="yes" xml:space="preserve">
          <source>So to revert the whole commit I just needed one &lt;code&gt;git reset --hard HEAD^&lt;/code&gt; and it reverted the whole merge.  Since the merges weren't fast forwarded the merge was a block and one step back is &quot;branch not merged&quot;.</source>
          <target state="translated">因此，要还原整个提交，我只需要一个 &lt;code&gt;git reset --hard HEAD^&lt;/code&gt; 还原整个合并。 由于合并不快进，因此合并是一个块，而后退一步是&amp;ldquo;分支未合并&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="58ab8c9c41be63fb49c1413b152baa6edf2f22cb" translate="yes" xml:space="preserve">
          <source>The accepted answer didn't work for me but this command achieved the results I was looking for.</source>
          <target state="translated">接受的答案对我来说并不奏效,但这个命令却达到了我想要的效果。</target>
        </trans-unit>
        <trans-unit id="b3f2e65392b9f0e8aa7a4993b688832907bfb6ea" translate="yes" xml:space="preserve">
          <source>The content of &lt;code&gt;HEAD&lt;/code&gt; is stored inside &lt;code&gt;.git/HEAD&lt;/code&gt; and it contains the 40 bytes SHA-1 of the current commit.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 的内容存储在 &lt;code&gt;.git/HEAD&lt;/code&gt; 内 ，它包含当前提交的40个字节的SHA-1。</target>
        </trans-unit>
        <trans-unit id="d27a11b12a9dbf604d123bb3c78535210f4fee84" translate="yes" xml:space="preserve">
          <source>The first line indicates that a merge occurred. The 2nd line is the time before my merge. I simply &lt;code&gt;git reset --hard 43b6032&lt;/code&gt; to force this branch to track from before the merge, and carry-on.</source>
          <target state="translated">第一行表示发生了合并。 第二行是我合并之前的时间。 我只是 &lt;code&gt;git reset --hard 43b6032&lt;/code&gt; 强制该分支从合并和随身携带之前跟踪。</target>
        </trans-unit>
        <trans-unit id="24a5287316a1f0cc421b296f0c8899ca9eb1f1fe" translate="yes" xml:space="preserve">
          <source>The ref &lt;code&gt;ORIG_HEAD&lt;/code&gt; will point to the original commit from before the merge.</source>
          <target state="translated">引用 &lt;code&gt;ORIG_HEAD&lt;/code&gt; 将指向合并之前的原始提交。</target>
        </trans-unit>
        <trans-unit id="c71cf6f7e1fa90c9f775afb4665ce2a1c30fa080" translate="yes" xml:space="preserve">
          <source>The reset command will &quot;undo&quot; any changes made in the given commit.</source>
          <target state="translated">重置命令将 &quot;撤销 &quot;给定的提交中的任何更改。</target>
        </trans-unit>
        <trans-unit id="36c246d74e903f15f19b4b4f468b11a19c85273b" translate="yes" xml:space="preserve">
          <source>The simplest answer is the one given by odinho - Velmont</source>
          <target state="translated">最简单的答案是odinho-Velmont给出的答案。</target>
        </trans-unit>
        <trans-unit id="46315a8a488aa1c363f4b4d714215eeb7a26054c" translate="yes" xml:space="preserve">
          <source>The simplest of the simplest chance, much simpler than anything said here:</source>
          <target state="translated">最简单的机缘,比这里说的要简单得多。</target>
        </trans-unit>
        <trans-unit id="9b2e3fbc4a5b3fb872c2498efc43407e3f692226" translate="yes" xml:space="preserve">
          <source>Then reset your repository to the previous working state:</source>
          <target state="translated">然后重置你的存储库到之前的工作状态。</target>
        </trans-unit>
        <trans-unit id="8beae3e1c748b27b319e9c6a97130b919dfd0ff3" translate="yes" xml:space="preserve">
          <source>Then your local &lt;code&gt;master&lt;/code&gt; branch should look identical to &lt;code&gt;origin/master&lt;/code&gt;.</source>
          <target state="translated">然后，您的本地 &lt;code&gt;master&lt;/code&gt; 分支应该看起来与 &lt;code&gt;origin/master&lt;/code&gt; 相同。</target>
        </trans-unit>
        <trans-unit id="b79a2fb8df89268894c41e909d37a43d4b13ea2c" translate="yes" xml:space="preserve">
          <source>There can only be a single &lt;code&gt;HEAD&lt;/code&gt; at any given time. (excluding &lt;code&gt;git worktree&lt;/code&gt;)</source>
          <target state="translated">在任何给定时间只能有一个 &lt;code&gt;HEAD&lt;/code&gt; 。 （不包括 &lt;code&gt;git worktree&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="ee7a6bc20b5ced1a19cd919e8fe98498e8d60f93" translate="yes" xml:space="preserve">
          <source>There's also another way:</source>
          <target state="translated">还有另外一种方法。</target>
        </trans-unit>
        <trans-unit id="97f119941e0910625204f7480028f0a6a531a6b9" translate="yes" xml:space="preserve">
          <source>This command will checkout to a given commit.</source>
          <target state="translated">这个命令将结账到给定的提交。</target>
        </trans-unit>
        <trans-unit id="cb080ba85575f06731354104952be0e724ba0807" translate="yes" xml:space="preserve">
          <source>This schema illustrates which command does what.</source>
          <target state="translated">这个模式说明了哪个命令做什么。</target>
        </trans-unit>
        <trans-unit id="5a3220d59f02442d914b999dc0551d7558f09d53" translate="yes" xml:space="preserve">
          <source>This will checkout new branch pointing to the desired commit.</source>
          <target state="translated">这将检查出指向所需提交的新分支。</target>
        </trans-unit>
        <trans-unit id="deecf3786f5adeab0a8d032a5b74b01cb144271d" translate="yes" xml:space="preserve">
          <source>This will get you back to your desired commit</source>
          <target state="translated">这将会让你回到你想要的承诺</target>
        </trans-unit>
        <trans-unit id="e2895e088abf9a616278de29a61ed7e4f342becb" translate="yes" xml:space="preserve">
          <source>This will reset in a way that you won't get the merged changes back again after pull.</source>
          <target state="translated">这样一来,你就不会在拉取后再次获得合并后的变化,就会重置。</target>
        </trans-unit>
        <trans-unit id="7fd4a8fd7ec982f6eeaf3304f86596bb5c7f052c" translate="yes" xml:space="preserve">
          <source>This worked for me..!!</source>
          <target state="translated">这个对我很有效...........!</target>
        </trans-unit>
        <trans-unit id="b7eb3bb87713872bb7fb72eaecd2f0608217ce8a" translate="yes" xml:space="preserve">
          <source>To undo a merge &lt;strong&gt;that was already pushed&lt;/strong&gt;:</source>
          <target state="translated">撤消&lt;strong&gt;已经推送&lt;/strong&gt;的合并：</target>
        </trans-unit>
        <trans-unit id="2cdbb6097aab99db57c477d72d879e6369243bc1" translate="yes" xml:space="preserve">
          <source>Undo a Git merge that hasn't been pushed yet</source>
          <target state="translated">撤销还没有被推送的Git合并</target>
        </trans-unit>
        <trans-unit id="98d579d6b2feb5d3f566d9acd6f952651cef03e9" translate="yes" xml:space="preserve">
          <source>Use the hash which was there before your wrongly merged commit.</source>
          <target state="translated">使用在你错误的合并提交之前的哈希。</target>
        </trans-unit>
        <trans-unit id="fc867b197aa26ecdfcad95077e04446aa1aff0e4" translate="yes" xml:space="preserve">
          <source>Voila! Master is at the same stage as origin, and your mis-merged state is erased.</source>
          <target state="translated">呜呼! 主人与原点相同的阶段,你的错误融合状态被抹去了。</target>
        </trans-unit>
        <trans-unit id="793042088cb8459ce5c14d4a24b0d792d5cdf413" translate="yes" xml:space="preserve">
          <source>When you're satisfied with the results, delete the old branch: &lt;code&gt;git branch --delete feature-1&lt;/code&gt;</source>
          <target state="translated">对结果满意后，删除旧分支： &lt;code&gt;git branch --delete feature-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0011e4747bd810c3d224a314d8ab4beba79f4baa" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;git reflog&lt;/code&gt; check which commit is one prior the merge (&lt;code&gt;git reflog&lt;/code&gt; will be a better option than &lt;code&gt;git log&lt;/code&gt;). Then you can reset it using:</source>
          <target state="translated">使用 &lt;code&gt;git reflog&lt;/code&gt; 检查哪个提交是合并之前的提交（ &lt;code&gt;git reflog&lt;/code&gt; 比 &lt;code&gt;git log&lt;/code&gt; 更好的选择）。 然后您可以使用以下方法重置它：</target>
        </trans-unit>
        <trans-unit id="13583b9b58d16e13b4045f8b4dc5dc8cf2fcf94d" translate="yes" xml:space="preserve">
          <source>With modern Git, you can:</source>
          <target state="translated">使用现代Git,你可以。</target>
        </trans-unit>
        <trans-unit id="8d7ba780922a5b5b9083423774fa25b354a9397d" translate="yes" xml:space="preserve">
          <source>With newer Git versions, if you have not committed the merge yet &lt;em&gt;and you have a merge conflict&lt;/em&gt;, you can simply do:</source>
          <target state="translated">使用较新的Git版本，如果您尚未提交合并&lt;em&gt;并且发生合并冲突&lt;/em&gt; ，则只需执行以下操作：</target>
        </trans-unit>
        <trans-unit id="749ea1d959a0ebe37deff012bb88a6a69cbb9195" translate="yes" xml:space="preserve">
          <source>Within my master branch, I did a &lt;code&gt;git merge some-other-branch&lt;/code&gt; locally, but never pushed the changes to origin master. I didn't mean to merge, so I'd like to undo it. When doing a &lt;code&gt;git status&lt;/code&gt; after my merge, I was getting this message:</source>
          <target state="translated">在我的master分支中，我在本地进行了 &lt;code&gt;git merge some-other-branch&lt;/code&gt; ，但从未将更改推送到Origin master。 我不是故意要合并的，所以我想撤消它。 合并后执行 &lt;code&gt;git status&lt;/code&gt; 时 ，收到以下消息：</target>
        </trans-unit>
        <trans-unit id="c30858403c3524d58a855843ab75efd449f6a789" translate="yes" xml:space="preserve">
          <source>You can always use the &lt;code&gt;reflog&lt;/code&gt; as well.</source>
          <target state="translated">您也可以始终使用 &lt;code&gt;reflog&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a3bbbefa1b0426e85af4fa26c3447a6f934d5419" translate="yes" xml:space="preserve">
          <source>You can easily spot the merge commit there - the first node from the top with two parents</source>
          <target state="translated">你可以很容易发现那里的合并提交--从顶部的第一个节点开始,有两个父节点</target>
        </trans-unit>
        <trans-unit id="e15587c1837f5e19f9351270c2815c88b5e542be" translate="yes" xml:space="preserve">
          <source>You can reset the state to a specific commit with &lt;code&gt;git reset --hard &amp;lt;commit_id&amp;gt;&lt;/code&gt; as well.</source>
          <target state="translated">您也可以使用 &lt;code&gt;git reset --hard &amp;lt;commit_id&amp;gt;&lt;/code&gt; 将状态重置为特定的提交。</target>
        </trans-unit>
        <trans-unit id="8f73fd4d1a2fb9c134e6408b124ae401253ea5bf" translate="yes" xml:space="preserve">
          <source>You can use only two commands to revert a merge or restart by a specific commit:</source>
          <target state="translated">你只能使用两个命令来恢复合并或通过特定的提交重启。</target>
        </trans-unit>
        <trans-unit id="0e85334a85eabbba69e127248b7653400b792033" translate="yes" xml:space="preserve">
          <source>You could use &lt;code&gt;git reflog&lt;/code&gt; to find the previous checkout. Sometimes that's a good state you want to return back to.</source>
          <target state="translated">您可以使用 &lt;code&gt;git reflog&lt;/code&gt; 查找先前的结帐。 有时候，这是您想要返回的良好状态。</target>
        </trans-unit>
        <trans-unit id="0fb11ff32e4960861c70effb62bc534ca973adeb" translate="yes" xml:space="preserve">
          <source>You should reset to the previous commit. This should work:</source>
          <target state="translated">你应该重置到之前的提交。这样做应该可以了。</target>
        </trans-unit>
        <trans-unit id="e48e60b16c6224a1624a1b5146a75d4b7007bff0" translate="yes" xml:space="preserve">
          <source>[This] can only be run after the merge has resulted in conflicts. &lt;code&gt;git merge --abort&lt;/code&gt; will abort the merge process and try to reconstruct the pre-merge state.</source>
          <target state="translated">[this]仅在合并导致冲突后才能运行。 &lt;code&gt;git merge --abort&lt;/code&gt; 将中止合并过程，并尝试重构合并前的状态。</target>
        </trans-unit>
        <trans-unit id="fa81328d53b03b6761d4913e440f88f24c75bc59" translate="yes" xml:space="preserve">
          <source>but now I'm getting this message with &lt;code&gt;git status&lt;/code&gt;:</source>
          <target state="translated">但是现在我收到了 &lt;code&gt;git status&lt;/code&gt; 的消息：</target>
        </trans-unit>
        <trans-unit id="274ee127098a717cbb4871f1838bd7d85769251f" translate="yes" xml:space="preserve">
          <source>might yield better results, as it should preserve your changes. &lt;code&gt;ORIG_HEAD&lt;/code&gt; will point to a commit directly before merge has occurred, so you don't have to hunt for it yourself.</source>
          <target state="translated">可能会产生更好的结果，因为它可以保留您的更改。 &lt;code&gt;ORIG_HEAD&lt;/code&gt; 会在合并发生之前直接指向一个提交，因此您不必自己寻找它。</target>
        </trans-unit>
        <trans-unit id="debc17af5f0a5a0a067f6e38c88e5aa5ee4bb285" translate="yes" xml:space="preserve">
          <source>or using &lt;code&gt;--hard&lt;/code&gt; (&lt;strong&gt;this will remove all local, not committed changes!&lt;/strong&gt;):</source>
          <target state="translated">或使用 &lt;code&gt;--hard&lt;/code&gt; （ &lt;strong&gt;这将删除所有本地未提交的更改！&lt;/strong&gt; ）：</target>
        </trans-unit>
        <trans-unit id="8193a36fd2edc40fc568684fc3ab68aed1391e26" translate="yes" xml:space="preserve">
          <source>where this is the range of the correct commits which you've committed (excluding wrongly committed merge).</source>
          <target state="translated">这里是你所提交的正确提交的范围(不包括错误提交的合并)。</target>
        </trans-unit>
        <trans-unit id="2af794d5040a7de2611fdfb9d6c67760667c73a6" translate="yes" xml:space="preserve">
          <source>you can also use the &lt;code&gt;git rebase --no-autostash&lt;/code&gt; as well.</source>
          <target state="translated">您还可以使用 &lt;code&gt;git rebase --no-autostash&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
