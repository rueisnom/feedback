<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2389361">
    <body>
      <group id="2389361">
        <trans-unit id="325456df475221c1ef6e54223033b6bbc4319e40" translate="yes" xml:space="preserve">
          <source>&quot;Move&quot; your HEAD back to the desired commit.</source>
          <target state="translated">HEAD를 원하는 커밋으로 &quot;이동&quot;하십시오.</target>
        </trans-unit>
        <trans-unit id="61d42c1e98b427b9a26d8300709bdf0b98ed9d8f" translate="yes" xml:space="preserve">
          <source>&quot;Undo&quot; the given commit or commit range.</source>
          <target state="translated">지정된 커밋 또는 커밋 범위를 &quot;실행 취소&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="802e1da120c1f89aabbfdf52d39bdbae621bb87b" translate="yes" xml:space="preserve">
          <source>(The &lt;code&gt;--merge&lt;/code&gt; option has nothing to do with the merge. It's just like &lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt;, but safer since it doesn't touch uncommitted changes.)</source>
          <target state="translated">&lt;code&gt;--merge&lt;/code&gt; 옵션은 병합과 관련이 없습니다. &lt;code&gt;git reset --hard ORIG_HEAD&lt;/code&gt; 와 비슷하지만 커밋되지 않은 변경 사항을 건드리지 않기 때문에 더 안전합니다.</target>
        </trans-unit>
        <trans-unit id="de00e86b4b1adf7de42f72b04311752a53fdd076" translate="yes" xml:space="preserve">
          <source>--merge</source>
          <target state="translated">--merge</target>
        </trans-unit>
        <trans-unit id="4ecd5f0567755f3060a0a13616b8c5f76326c0b5" translate="yes" xml:space="preserve">
          <source>...gave me the following status.</source>
          <target state="translated">... 다음 상태를 알려주세요.</target>
        </trans-unit>
        <trans-unit id="28b300090e2627ad40216640d6db41b809ac2535" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;HEAD&lt;/code&gt; is simply a reference to the current commit (latest) on the current branch.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 는 단순히 현재 분기의 현재 커밋 (최신)에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="7a57403f4c67e271246c31134de2561578e1aff1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git push origin HEAD --force&lt;/code&gt; (Sending the new local master branch to origin/master)</source>
          <target state="translated">&lt;code&gt;git push origin HEAD --force&lt;/code&gt; (새로운 로컬 마스터 브랜치를 origin / master로 보내기)</target>
        </trans-unit>
        <trans-unit id="e175277d5a42e50ec6e6479703ed7804c2ac364c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reflog&lt;/code&gt; might return something like:</source>
          <target state="translated">&lt;code&gt;git reflog&lt;/code&gt; 는 다음과 같은 것을 반환 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="a4749f1dc2409947d7d60e018e360ecb9d38a626" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reflog&lt;/code&gt; will display any change which updated the &lt;code&gt;HEAD&lt;/code&gt; and checking out the desired reflog entry will set the &lt;code&gt;HEAD&lt;/code&gt; back to this commit.</source>
          <target state="translated">&lt;code&gt;git reflog&lt;/code&gt; 는 &lt;code&gt;HEAD&lt;/code&gt; 를 업데이트 한 모든 변경 사항을 표시하며 원하는 reflog 항목을 체크 아웃하면 &lt;code&gt;HEAD&lt;/code&gt; 가이 커밋으로 다시 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6824acf82d333773d4cb1b528a8ee507942d3b97" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard commitHash&lt;/code&gt; (you should use the commit that you want to restart, eg. 44a587491e32eafa1638aca7738)</source>
          <target state="translated">&lt;code&gt;git reset --hard commitHash&lt;/code&gt; (예 : 44a587491e32eafa1638aca7738와 같이 다시 시작하려는 커밋을 사용해야 함)</target>
        </trans-unit>
        <trans-unit id="afe03d7202852f20a848103e8366601b6dd5a207" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) Abort Merge&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) 중단 병합&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="604fd099bd7cd9da0358f5149a0d3954897871d0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) Reset HEAD to remote branch&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2) HEAD를 원격 지점으로 재설정&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1d90f072973b270bb411541b730bd6f99ace1422" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Delete current branch, and checkout again from the remote repository&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3) 현재 브랜치를 삭제하고 원격 저장소에서 다시 체크 아웃하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="759f848871d3d6afad67df3eb9500a6fb9eed6f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://git-scm.com/docs/git-reset&quot;&gt;&lt;code&gt;git reset --hard &amp;lt;commit_id&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://git-scm.com/docs/git-reset&quot;&gt; &lt;code&gt;git reset --hard &amp;lt;commit_id&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ded496589b80899aa4a4ac207caa1e2ae9791023" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://git-scm.com/docs/git-revert&quot;&gt;&lt;code&gt;git revert &amp;lt;sha-1&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://git-scm.com/docs/git-revert&quot;&gt; &lt;code&gt;git revert &amp;lt;sha-1&amp;gt;&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5941d87399c11b4c01ccb41bbd0ab033fe969fd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;code&gt;First of all what is HEAD?&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;First of all what is HEAD?&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1253bf83df98a1b2c7a29a783edb0908bb3dd47" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;&lt;code&gt;detached HEAD&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt; &lt;code&gt;detached HEAD&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="70dc12e1edbd51a0e4e9cfdd87cb6a28be10a15d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Be aware that any modified and uncommitted/unstashed files will be reset to their unmodified state&lt;/strong&gt;. To keep them either stash changes away or see &lt;code&gt;--merge&lt;/code&gt; option below.</source>
          <target state="translated">&lt;strong&gt;수정 및 커미트되지 않은 / 스 태치되지 않은 파일은 수정되지 않은 상태로 재설정됩니다&lt;/strong&gt; . 변경 사항을 숨기거나 아래의 &lt;code&gt;--merge&lt;/code&gt; 옵션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="785ae5f8e57e7bb1825787323ff5e8191b3b952c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Every time the HEAD is modified there will be a new entry in the &lt;code&gt;reflog&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;HEAD가 수정 될 때마다 &lt;code&gt;reflog&lt;/code&gt; 에 새로운 항목이 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f4c249f9857d39172dcc4c1c2fe983b88b979cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Rationale:&lt;/strong&gt; Reverting a merge is hard. There are too many solutions, depending on many factors such as whether you've committed or pushed your merge or if there were new commits since your merge. Also you still need to have a relatively deep understanding of git to adapt these solutions to your case. If you blindly follow some instructions, you can end up with an &quot;empty merge&quot; where nothing will be merged, and further merge attempts will make Git tell you &quot;Already up to date&quot;.</source>
          <target state="translated">&lt;strong&gt;근거 :&lt;/strong&gt; 병합을 되 돌리는 것은 어렵다. 병합을 커밋했는지 또는 푸시했는지 또는 병합 이후 새로운 커밋이 있는지 여부와 같은 많은 요인에 따라 솔루션이 너무 많습니다. 또한 이러한 솔루션을 사례에 맞게 조정하려면 git에 대해 비교적 깊이 이해해야합니다. 맹목적으로 몇 가지 지침을 따르면, 아무것도 병합되지 않는 &quot;빈 병합&quot;으로 끝날 수 있으며, 추가 병합 시도로 인해 Git이 &quot;이미 최신 상태&quot;라고 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="49c900ba5a0475e269165d778322be2846b3c474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Solution:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92822cdea3fbd4b6814a2bc1aeca9e144c90d3b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Strategy:&lt;/strong&gt; Create a new branch from where everything was good.</source>
          <target state="translated">&lt;strong&gt;전략 :&lt;/strong&gt; 모든 것이 좋은 곳에서 새로운 지점을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="ebe69bfea64d906fe3fed1ef6e4fa226ee0104fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You have to change your HEAD, Not yours of course but git HEAD....&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;물론 HEAD를 바꿔야합니다. 물론 git HEAD ....&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7878cb7ef8c06d6486adcc9797b87c6465365093" translate="yes" xml:space="preserve">
          <source>A few options on how to recover from a detached HEAD:</source>
          <target state="translated">분리 된 HEAD에서 복구하는 방법에 대한 몇 가지 옵션 :</target>
        </trans-unit>
        <trans-unit id="d76df7a30f5ed122045ac3a75d6c4e419b411614" translate="yes" xml:space="preserve">
          <source>A further tip is to use the &lt;code&gt;--merge&lt;/code&gt; switch instead of &lt;code&gt;--hard&lt;/code&gt; since it doesn't reset files unnecessarily:</source>
          <target state="translated">추가 팁은 불필요하게 파일을 재설정하지 않기 때문에 &lt;code&gt;--hard&lt;/code&gt; 대신 &lt;code&gt;--merge&lt;/code&gt; 스위치를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c07f89042a4dd0ffc371963b232a49b6b7957ea5" translate="yes" xml:space="preserve">
          <source>A new commit with the undo patch will be committed while the original commit will remain in the history as well.</source>
          <target state="translated">실행 취소 패치가 포함 된 새로운 커밋은 커밋되지만 원래 커밋도 기록에 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5ac1659dd41072099f4d92d4a46bfdef39eb5cd" translate="yes" xml:space="preserve">
          <source>After a failed merge, when there is no &lt;code&gt;MERGE_HEAD&lt;/code&gt;, the failed merge can be undone with &lt;code&gt;git reset --merge&lt;/code&gt;, but not necessarily with &lt;code&gt;git merge --abort&lt;/code&gt;, &lt;strong&gt;so they are not only old and new syntax for the same thing&lt;/strong&gt;.</source>
          <target state="translated">실패한 병합 후 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 가 없으면 &lt;code&gt;git reset --merge&lt;/code&gt; --merge 를 사용하여 실패한 병합을 취소 할 수 있지만 반드시 &lt;code&gt;git merge --abort&lt;/code&gt; 를 사용 하지 않아도 &lt;strong&gt;되므로 동일한 구문에 대한 이전 구문과 새로운 구문 일뿐입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9f5185d6277f1eba54caf7e60862955de339e287" translate="yes" xml:space="preserve">
          <source>Apply your right commits on the top of the right version of your repository by:</source>
          <target state="translated">올바른 버전의 저장소 위에 올바른 커밋을 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="8a2844ea9ae989611adb5d08b55a7e2692655a53" translate="yes" xml:space="preserve">
          <source>As @Velmont suggested below in his answer, in this direct case using:</source>
          <target state="translated">@Velmont는 그의 대답에서 아래에 제안한 것처럼,이 직접적인 경우에는 다음을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bc34ab887f36ec36b3e87a27a89b2efbc3dd7f7c" translate="yes" xml:space="preserve">
          <source>As you can see there &lt;code&gt;reset &amp;amp;&amp;amp; checkout&lt;/code&gt; modify the &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">보시다시피 &lt;code&gt;reset &amp;amp;&amp;amp; checkout&lt;/code&gt; &lt;code&gt;HEAD&lt;/code&gt; 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="c5b6d235893c7cb7d9b70b9455462c17203536e6" translate="yes" xml:space="preserve">
          <source>Assuming your local master was not ahead of origin/master, you should be able to do</source>
          <target state="translated">로컬 마스터가 원산지 / 마스터보다 앞서 있다고 가정하면 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="741385c466ef2ed2d072c32f555bfc099c9a7290" translate="yes" xml:space="preserve">
          <source>At this point, I saw the status message changed, so I tried doing a &lt;code&gt;git pull&lt;/code&gt;, and that seemed to work:</source>
          <target state="translated">이 시점에서 상태 메시지가 변경되는 것을 보았으므로 &lt;code&gt;git pull&lt;/code&gt; 을 시도했지만 작동하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="d73bafdf80b0a79ad2440bd70a0301445a0e504f" translate="yes" xml:space="preserve">
          <source>At this point, you can create a branch and start to work from this point on.</source>
          <target state="translated">이제 지점을 만들고이 지점부터 작업을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="647929631e179f99ce2862dfa69111519a73acaa" translate="yes" xml:space="preserve">
          <source>Based upon some &lt;a href=&quot;http://www.gitready.com/intermediate/2009/03/16/rolling-back-changes-with-revert.html&quot;&gt;instructions I found&lt;/a&gt;, I tried running</source>
          <target state="translated">&lt;a href=&quot;http://www.gitready.com/intermediate/2009/03/16/rolling-back-changes-with-revert.html&quot;&gt;내가 찾은 지침에&lt;/a&gt; 따라 달리기를 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="add278ff9d7fbde2d4afd50132edee7adca64baa" translate="yes" xml:space="preserve">
          <source>Be sure to revert the revert if you're committing the branch again, like Linus said.</source>
          <target state="translated">Linus가 말한 것처럼 지점을 다시 커밋하는 경우 되돌리기를 되 돌리십시오.</target>
        </trans-unit>
        <trans-unit id="1d4a2ba4128b23314b33fba35bc6aba78172b2a8" translate="yes" xml:space="preserve">
          <source>But actually, it is worth noticing that &lt;code&gt;git merge --abort&lt;/code&gt; is only equivalent to &lt;code&gt;git reset --merge&lt;/code&gt; given that &lt;code&gt;MERGE_HEAD&lt;/code&gt; is present. This can be read in the Git help for merge command.</source>
          <target state="translated">그러나 실제로 &lt;code&gt;git merge --abort&lt;/code&gt; 는 MERGE_HEAD 가있는 경우 &lt;code&gt;git reset --merge&lt;/code&gt; --merge 와 동일하다는 점에 &lt;code&gt;MERGE_HEAD&lt;/code&gt; 가 있습니다. 이것은 병합 명령에 대한 Git 도움말에서 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8343394d0b6fe219dae1e4cbcd2dfa56532a9f01" translate="yes" xml:space="preserve">
          <source>By using cherry-pick (the changes introduced by some existing commits)</source>
          <target state="translated">cherry-pick (기존 커밋이 도입 한 변경 사항) 사용</target>
        </trans-unit>
        <trans-unit id="763f4d79d626bfc47f2d63b4e9b5674356833785" translate="yes" xml:space="preserve">
          <source>Check it out (go back in time):</source>
          <target state="translated">그것을 확인하십시오 (시간으로 되돌아 가십시오) :</target>
        </trans-unit>
        <trans-unit id="2f9302a11f149b660f4bbb181d2c6b2213165b8d" translate="yes" xml:space="preserve">
          <source>Check which commits you'd like to re-commit on the top of the previous correct version by:</source>
          <target state="translated">이전 올바른 버전의 맨 위에 어떤 커밋을 다시 커밋 할 것인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9438d39d2891c592bbacacd8a10774d67bc0a1e7" translate="yes" xml:space="preserve">
          <source>Commit: &lt;code&gt;git commit&lt;/code&gt;</source>
          <target state="translated">커밋 : &lt;code&gt;git commit&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37aaf5680093dad358c2bf506bd149419025e2a9" translate="yes" xml:space="preserve">
          <source>Concretely,</source>
          <target state="translated">Concretely,</target>
        </trans-unit>
        <trans-unit id="5af3839edce03334a51705ceb0c5dca7bfc39de3" translate="yes" xml:space="preserve">
          <source>Considering, you are working on develop branch in local repo, that syncs with remote/develop branch, you can do as below:</source>
          <target state="translated">원격 / 개발 지점과 동기화되는 로컬 리포지토리에서 지점을 개발하고 있다고 생각하면 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1672055cfcbedce57a1a29f1bf34bf34cfb36b5" translate="yes" xml:space="preserve">
          <source>Create a new branch from there and check it out:</source>
          <target state="translated">거기에서 새 브랜치를 만들고 체크 아웃하십시오.</target>
        </trans-unit>
        <trans-unit id="255b2030ca33b51942c51609856638b7f0d7036c" translate="yes" xml:space="preserve">
          <source>Doing this...</source>
          <target state="translated">이 작업을 수행하는 중 ...</target>
        </trans-unit>
        <trans-unit id="816c010f06e6282726e365cc46b8ba04a725a585" translate="yes" xml:space="preserve">
          <source>Essentially, your merge &lt;code&gt;sha&lt;/code&gt; will be pointing to &lt;code&gt;HEAD@{0}&lt;/code&gt; if nothing else was committed after the merge and so &lt;code&gt;HEAD@{1}&lt;/code&gt; will be the previous point before the merge.</source>
          <target state="translated">기본적으로 병합 이후에 다른 것이 커밋되지 않으면 병합 &lt;code&gt;sha&lt;/code&gt; 는 &lt;code&gt;HEAD@{0}&lt;/code&gt; 가리 키므로 &lt;code&gt;HEAD@{1}&lt;/code&gt; 은 병합 이전의 지점이됩니다.</target>
        </trans-unit>
        <trans-unit id="dc5484edea2fa1e7dc2a50403cdcd377264d521b" translate="yes" xml:space="preserve">
          <source>Find the revision that you want to receive the merge:</source>
          <target state="translated">병합을 받으려는 개정을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="51874dafb788a11b05b16847cfddf30e5530f335" translate="yes" xml:space="preserve">
          <source>First checking the right changes before merging them:</source>
          <target state="translated">올바른 변경 사항을 병합하기 전에 먼저 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="17a9dfef7180d2cac4e3adda3a13506469db0227" translate="yes" xml:space="preserve">
          <source>First do &lt;code&gt;git reset --merge ORIG_HEAD&lt;/code&gt;</source>
          <target state="translated">먼저 &lt;code&gt;git reset --merge ORIG_HEAD&lt;/code&gt; 를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d20206d045ba70ce71d8e61189dee4b3b09f7ff6" translate="yes" xml:space="preserve">
          <source>First, make sure that you've committed everything.</source>
          <target state="translated">먼저 모든 것을 커밋했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8f668e1fab0f8bd3cff902ea5b1e65d5e96936fe" translate="yes" xml:space="preserve">
          <source>Fix your merge conflicts.</source>
          <target state="translated">병합 충돌을 해결하십시오.</target>
        </trans-unit>
        <trans-unit id="75a1298429a484b33b7a8fd039a60535b3fa0ba1" translate="yes" xml:space="preserve">
          <source>Follow the link to the first/left parent (the one on your current branch before the merge, usually red for me)</source>
          <target state="translated">첫 번째 / 왼쪽 부모에 대한 링크를 따르십시오 (병합 전에 현재 지점의 링크, 일반적으로 나에게 빨간색)</target>
        </trans-unit>
        <trans-unit id="a21677fbf79c4f24fdce4efc4921ae3367808920" translate="yes" xml:space="preserve">
          <source>For example, I accidentally merged a develop branch into master and wanted to undo that. Using the following steps:</source>
          <target state="translated">예를 들어, 실수로 개발 브랜치를 마스터로 병합하고 실행 취소하려고했습니다. 다음 단계를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e194ec8910b7058663e07c84da3ca131553b7a1" translate="yes" xml:space="preserve">
          <source>For those looking to reset after changes are pushed, do this
(Because this is the first post seen for any git reset merge questions)</source>
          <target state="translated">변경 사항을 푸시 한 후 재설정하려는 사람들은 이것을 수행하십시오 (이것은 git reset merge 질문에 대해 처음으로 보여 졌기 때문에)</target>
        </trans-unit>
        <trans-unit id="44bf1ed54764304b5fc570d446d2980533e7b553" translate="yes" xml:space="preserve">
          <source>From &lt;code&gt;man git merge&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;man git merge&lt;/code&gt; 에서 :</target>
        </trans-unit>
        <trans-unit id="8043bd119d31e66c1d70d0e3001444d0b121e729" translate="yes" xml:space="preserve">
          <source>Good luck and go ahead!</source>
          <target state="translated">행운을 빌어 요!</target>
        </trans-unit>
        <trans-unit id="c22d554933e904a95169c18c110c1f0e4f441168" translate="yes" xml:space="preserve">
          <source>Got to this question also looking to revert to match origin (ie, NO commits ahead of origin). Researching further, found there's a &lt;code&gt;reset&lt;/code&gt; command for exactly that:</source>
          <target state="translated">이 질문으로 인해 원점과 일치하도록 되돌릴 수 있습니다 (즉, NO는 원점보다 앞선 커밋). 더 연구 한 결과 정확히 다음에 대한 &lt;code&gt;reset&lt;/code&gt; 명령이 있음을 발견했습니다.</target>
        </trans-unit>
        <trans-unit id="0df541da1603fd706be139871c50875511174718" translate="yes" xml:space="preserve">
          <source>I don't want my branch to be ahead by any number of commits. How do I get back to that point?</source>
          <target state="translated">나는 커밋이 앞당겨지기를 원하지 않습니다. 그 시점으로 돌아가려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="43cc9dd5cf07954eb5f3ddb5f6da228ccc77880f" translate="yes" xml:space="preserve">
          <source>I just read this page as I'd accidentally merged a testing branch instead of my release branch with master for deploying (website, master is what is live).  The testing branch has two other branches merged to it and totals about six commits.</source>
          <target state="translated">실수로 릴리스 브랜치 대신 테스트 브랜치를 배치하기 위해 마스터와 마스터 브랜치를 병합했기 때문에이 페이지를 읽었습니다 (웹 사이트, 마스터는 살아있는 것입니다). 테스트 지점에는 두 개의 다른 지점이 병합되어 있으며 총 약 6 개의 커밋이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8472f20eb671f27fce11198dbf9eb37f7ecd402" translate="yes" xml:space="preserve">
          <source>I then had to type in the same &lt;code&gt;git reset&lt;/code&gt; command several more times.  Each time I did that, the message changed by one as you can see below.</source>
          <target state="translated">그런 다음 동일한 &lt;code&gt;git reset&lt;/code&gt; 명령을 여러 번 입력해야했습니다. 내가 그렇게 할 때마다 아래에서 볼 수 있듯이 메시지가 하나씩 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="6aa11a668f525796780c5491a4a593498f6e7964" translate="yes" xml:space="preserve">
          <source>I think you can do &lt;code&gt;git rebase -i [hash] [branch_name]&lt;/code&gt;  where &lt;code&gt;[hash]&lt;/code&gt; is the identifying hash for however far back you want to rewind plus one (or however many commits back you want to go) and then delete the lines for the commits in the editor that you don't want any more. Save the file. Exit. Pray. And it should be rewound. You might have to do a &lt;code&gt;git reset --hard&lt;/code&gt;, but it should be good at this point. You can also use this to pull specific commits out of a stack, if you don't want to keep them in your history, but that can leave your repository in a state that you probably don't want.</source>
          <target state="translated">나는 당신이 &lt;code&gt;git rebase -i [hash] [branch_name]&lt;/code&gt; 할 수 있다고 생각한다 . 여기서 &lt;code&gt;[hash]&lt;/code&gt; 는 식별 해시이지만 다시 되감기를 원한다면 1을 더하고 (또는 많은 커밋을 원한다) 행을 삭제하십시오. 더 이상 원하지 않는 편집기의 커밋. 파일을 저장하십시오. 출구. 빌다. 그리고 다시 감아 야합니다. &lt;code&gt;git reset --hard&lt;/code&gt; 를 수행해야 할 수도 있지만이 시점에서는 양호해야합니다. 히스토리에 보관하지 않으려는 경우 특정 커밋을 스택에서 가져 오기 위해 저장소를 사용할 수 있지만 저장소를 원하지 않는 상태로 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8248febcb055ef8ca8699cace925f0a5821f500b" translate="yes" xml:space="preserve">
          <source>I was able to resolve this problem with a single command that doesn't involve looking up a commit id.</source>
          <target state="translated">커밋 ID를 조회하지 않는 단일 명령 으로이 문제를 해결할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="df99b058b0781479579f97b096c6c5af7edee135" translate="yes" xml:space="preserve">
          <source>If the changes have been pushed you can use &lt;code&gt;git revert &amp;lt;branch_name&amp;gt;&lt;/code&gt; instead. Be sure to check out how to use &lt;a href=&quot;https://kolosek.com/git-reset-revert-and-checkout/&quot;&gt;git revert and git checkout&lt;/a&gt; in other scenarios as well.</source>
          <target state="translated">변경 사항이 적용되면 &lt;code&gt;git revert &amp;lt;branch_name&amp;gt;&lt;/code&gt; 을 대신 사용할 수 있습니다. 다른 시나리오에서도 &lt;a href=&quot;https://kolosek.com/git-reset-revert-and-checkout/&quot;&gt;git revert 및 git checkout&lt;/a&gt; 사용 방법을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c733929cdcbfaa01743e87a82f82e9031d738b19" translate="yes" xml:space="preserve">
          <source>If you are in a middle of merging you can always abort it
&lt;code&gt;git merge --abort&lt;/code&gt;</source>
          <target state="translated">병합하는 중간에 언제든지 &lt;code&gt;git merge --abort&lt;/code&gt; 를 중단 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9422c352652972680951f708ebef99f16b1a9f28" translate="yes" xml:space="preserve">
          <source>If you are in-between a bad merge (mistakenly done with wrong branch), and wanted to avoid the merge to go back to the branch latest as below:</source>
          <target state="translated">잘못된 병합 사이에 있고 (잘못 잘못된 분기로 수행됨) 병합이 다음과 같이 최신 지점으로 다시 돌아가는 것을 피하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="d6f1d087b9e3b013912752ff8a2acdef26394710" translate="yes" xml:space="preserve">
          <source>If you are not on the latest commit - meaning that &lt;code&gt;HEAD&lt;/code&gt; is pointing to a prior commit in history its called &lt;strong&gt;&lt;em&gt;&lt;code&gt;detached HEAD&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">최신 커밋에 있지 않은 경우 &lt;code&gt;HEAD&lt;/code&gt; 가 히스토리에서 이전 커밋을 가리키며 &lt;strong&gt;&lt;em&gt; &lt;code&gt;detached HEAD&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="ad48d228d16dd9b23f14b53b640eb7fba65cf765" translate="yes" xml:space="preserve">
          <source>If you are working from remote develop branch, you can reset HEAD to the last commit on remote branch as below:</source>
          <target state="translated">원격 개발 브랜치에서 작업중인 경우 다음과 같이 HEAD를 원격 브랜치의 마지막 커밋으로 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de10e059bcc25df5c903ac3a24896852e6f0b52b" translate="yes" xml:space="preserve">
          <source>If you committed the merge:</source>
          <target state="translated">병합을 커밋 한 경우 :</target>
        </trans-unit>
        <trans-unit id="bdde193ae9900f18f1aefc8ea40bbd791db2176b" translate="yes" xml:space="preserve">
          <source>If you didn't commit it yet, you can only use</source>
          <target state="translated">아직 커밋하지 않은 경우에만 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5c5307bfa35d80268fa745bac89332c90bfc1b46" translate="yes" xml:space="preserve">
          <source>If you notice that you need to revert immediately after the merge and you haven't done anything else after the merge attempt, you can just issue this command:
&lt;code&gt;git reset --hard HEAD@{1}&lt;/code&gt;.</source>
          <target state="translated">병합 직후에 되돌려 야하고 병합 시도 후 다른 작업을 수행하지 않은 경우 &lt;code&gt;git reset --hard HEAD@{1}&lt;/code&gt; 명령을 실행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="17b89e12d2b1d5e24223e0c7be5a31fd496b87f0" translate="yes" xml:space="preserve">
          <source>If you want a command-line solution, I suggest to just go with MBO's answer.</source>
          <target state="translated">커맨드 라인 솔루션을 원한다면 MBO의 대답을 따르십시오.</target>
        </trans-unit>
        <trans-unit id="7337bb9dba1c56278b312febd484bb1b7e35dd12" translate="yes" xml:space="preserve">
          <source>If you're a newbie, you might like the graphical approach:</source>
          <target state="translated">초보자 인 경우 그래픽 방식이 마음에 듭니다.</target>
        </trans-unit>
        <trans-unit id="8aa0bf4f5380038f6198232bad4787999633cfce" translate="yes" xml:space="preserve">
          <source>If your merge and the corresponding commits were not pushed yet, you can always switch to another branch, delete the original one and re-create it.</source>
          <target state="translated">병합 및 해당 커밋이 아직 푸시되지 않은 경우 언제든지 다른 브랜치로 전환하고 원래 브랜치를 삭제 한 다음 다시 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f986375773f0a4dab0c0d575adbaa74d652fd7c" translate="yes" xml:space="preserve">
          <source>In case when you have problems and your master branch didn't have any local changes, you can reset to &lt;code&gt;origin/master&lt;/code&gt;.</source>
          <target state="translated">문제가 있고 마스터 브랜치에 로컬 변경 사항이없는 경우 &lt;code&gt;origin/master&lt;/code&gt; 로 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e72587463d0d1969e2293dad5931fd1c8b888b81" translate="yes" xml:space="preserve">
          <source>In this case, you will want to reset your branch with &lt;code&gt;git reset --hard &amp;lt;branch_name&amp;gt;&lt;/code&gt;. If you want to save your changes before reseting them be sure to create a new branch and &lt;code&gt;git checkout &amp;lt;branch_name&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;git reset --hard &amp;lt;branch_name&amp;gt;&lt;/code&gt; 으로 브랜치를 재설정하려고합니다. 재설정하기 전에 변경 사항을 저장하려면 새 분기를 만들고 &lt;code&gt;git checkout &amp;lt;branch_name&amp;gt;&lt;/code&gt; 을 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="835e8186de0e2139ff91974a3572c6199aa893a7" translate="yes" xml:space="preserve">
          <source>It can be done multiple ways.</source>
          <target state="translated">여러 가지 방법으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b470f7ffd6798a18488ff3231577f66b2a1afdb6" translate="yes" xml:space="preserve">
          <source>It is strange that the simplest command was missing. Most answers work, but undoing the merge you just did, &lt;strong&gt;this is the easy and safe way&lt;/strong&gt;:</source>
          <target state="translated">가장 간단한 명령이 누락 된 것은 이상합니다. 대부분의 답변은 효과가 있지만 방금 병합을 취소 &lt;strong&gt;하면 쉽고 안전한 방법입니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="28cb6898f26ef59eaba0b3945ea6e16dadd0d527" translate="yes" xml:space="preserve">
          <source>It will get you back 1 commit.</source>
          <target state="translated">커밋 1을 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="f93d593515bdc4144771c2caa5447a305f5fb840" translate="yes" xml:space="preserve">
          <source>It will undo the merge (and everything that you did).</source>
          <target state="translated">병합 (및 수행 한 모든 작업)을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="59b33677d3f238b3babbf1857be058678bbb2c81" translate="yes" xml:space="preserve">
          <source>Its saver and simpler then resets described in many answers above</source>
          <target state="translated">절약되고 간단하며 위의 많은 답변에서 설명한 재설정</target>
        </trans-unit>
        <trans-unit id="85ce981d17031f57fc1b54541928100f47a775aa" translate="yes" xml:space="preserve">
          <source>Just create new branch, then cherry-pick desired commits to it.</source>
          <target state="translated">새로운 브랜치를 만들고 나서 원하는 커밋을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="f27c343c95e3214cc8cf642e3566d29eaf52ce71" translate="yes" xml:space="preserve">
          <source>Just for an extra option to look at, I've been mostly following the branching model described here: &lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot;&gt;http://nvie.com/posts/a-successful-git-branching-model/&lt;/a&gt; and as such have been merging with &lt;code&gt;--no-ff&lt;/code&gt; (no fast forward) usually.</source>
          <target state="translated">추가 옵션을 보려면 여기에 설명 된 분기 모델을 주로 따르고 있습니다 : &lt;a href=&quot;http://nvie.com/posts/a-successful-git-branching-model/&quot;&gt;http://nvie.com/posts/a-successful-git-branching-model/&lt;/a&gt; 일반적으로 &lt;code&gt;--no-ff&lt;/code&gt; (빨리 감기 없음).</target>
        </trans-unit>
        <trans-unit id="1b2a74eb85dfd5b245e9780e2ee545ae6423e346" translate="yes" xml:space="preserve">
          <source>Kick off &lt;code&gt;gitk&lt;/code&gt; (from the command line, or right click in file browser if you have that)</source>
          <target state="translated">&lt;code&gt;gitk&lt;/code&gt; 를 시작하십시오 (명령 줄에서 또는 파일 브라우저에서 마우스 오른쪽 버튼을 클릭하십시오)</target>
        </trans-unit>
        <trans-unit id="9c2cf4980576515018dcf281a59a80f8a5defd69" translate="yes" xml:space="preserve">
          <source>Lately, I've been using &lt;code&gt;git reflog&lt;/code&gt; to help with this. This mostly only works if the merge JUST happened, and it was on your machine.</source>
          <target state="translated">최근에 &lt;code&gt;git reflog&lt;/code&gt; 를 사용 하여이 문제를 해결했습니다. 이것은 단지 병합 JUST가 발생하고 컴퓨터에있는 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="143ecefea61961efc839f245f46701a865e8be24" translate="yes" xml:space="preserve">
          <source>Let's say you want to merge &lt;code&gt;dev&lt;/code&gt; into &lt;code&gt;feature-1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dev&lt;/code&gt; 를 &lt;code&gt;feature-1&lt;/code&gt; 에 병합한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="c826fb47a708860edd83b926939efe96b331ff29" translate="yes" xml:space="preserve">
          <source>Merge: &lt;code&gt;git merge dev&lt;/code&gt;</source>
          <target state="translated">병합 : &lt;code&gt;git merge dev&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="caff5dbaaa425ac112f82a29a97c63ddfbb16edd" translate="yes" xml:space="preserve">
          <source>Note: (&lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/RelNotes/2.7.0.txt&quot;&gt;Since Git 2.7&lt;/a&gt;)</source>
          <target state="translated">참고 : ( &lt;a href=&quot;https://github.com/git/git/blob/master/Documentation/RelNotes/2.7.0.txt&quot;&gt;Git 2.7 이후&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b7db6b8a5b44621ffd1d3012155c989da65a2db2" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;@{u}&lt;/code&gt; is shorthand for &lt;code&gt;origin/master&lt;/code&gt;. (And, of course, you need that remote repository for this to work.)</source>
          <target state="translated">참고 : &lt;code&gt;@{u}&lt;/code&gt; 는 &lt;code&gt;origin/master&lt;/code&gt; 의 약어입니다. (물론 이것이 작동하려면 원격 저장소가 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="2336afddcbd6b8c91db172d6af697f8cee8a4aa7" translate="yes" xml:space="preserve">
          <source>Now you can restart your merge:</source>
          <target state="translated">이제 병합을 다시 시작할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e93ccff76d508309e8632c2d0a5de77b9d27c8ad" translate="yes" xml:space="preserve">
          <source>Okay, the answers other people here gave me were close, but it didn't work. Here's what I did.</source>
          <target state="translated">좋아, 다른 사람들이 나에게 준 대답은 가깝지 만 작동하지 않았습니다. 여기 내가 한 일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ac36912c0f775fe1d1f2c950c02c302154902e9" translate="yes" xml:space="preserve">
          <source>Old-school:</source>
          <target state="translated">Old-school:</target>
        </trans-unit>
        <trans-unit id="f8f107162d476c4c3d61d37ecf054ad642e5634f" translate="yes" xml:space="preserve">
          <source>Older syntax:</source>
          <target state="translated">이전 구문 :</target>
        </trans-unit>
        <trans-unit id="763f2dd4255ea2a1dd599c21e06de6d56c84c77c" translate="yes" xml:space="preserve">
          <source>On the command line, it will look like this- SHA-1 instead of the branch name since the &lt;code&gt;HEAD&lt;/code&gt; is not pointing to the tip of the current branch</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 가 현재 분기의 끝을 가리 키지 않기 때문에 명령 줄에서 분기 이름 대신 다음과 같이 SHA-1처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="952805b92e642b0e556543a1ca6d8386c41d6fb9" translate="yes" xml:space="preserve">
          <source>On the selected commit, right-click &quot;Reset branch  to here&quot;, pick the hard reset there</source>
          <target state="translated">선택한 커밋에서 &quot;여기로 분기 재설정&quot;을 마우스 오른쪽 단추로 클릭하고 하드 재설정을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="c271dd52be8061bb235a10202e34d1d8931ad6d7" translate="yes" xml:space="preserve">
          <source>Or by cherry-picking the range of commits by:</source>
          <target state="translated">또는 다음과 같이 커밋 범위를 체리 따기 :</target>
        </trans-unit>
        <trans-unit id="e64f39d14a7177892469d39e5bf8234bb87da140" translate="yes" xml:space="preserve">
          <source>Or even &lt;code&gt;HEAD^^&lt;/code&gt; to revert that revert commit. You can always give a full SHA reference if you're not sure how many steps back you should take.</source>
          <target state="translated">또는 &lt;code&gt;HEAD^^&lt;/code&gt; 도 되돌리기 커밋을 되돌릴 수 있습니다. 얼마나 많은 단계를 거쳐야할지 확실하지 않은 경우 언제든지 SHA 전체를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="950aeb777ec53567180decadaacecd984d98545f" translate="yes" xml:space="preserve">
          <source>Personally I find &lt;code&gt;git reset --merge&lt;/code&gt; much more powerful and useful in everyday work, so that's the one I always use.</source>
          <target state="translated">개인적으로 &lt;code&gt;git reset --merge&lt;/code&gt; 은 일상 작업에서 훨씬 강력하고 유용하므로 항상 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8f6875e65a9f446b5cbbda749bcaab9d8a133268" translate="yes" xml:space="preserve">
          <source>Remove your local branch (local, not remote) and pull it again. This way you'll undo the changes on your master branch and anyone will be affected by the change you don't want to push. Start it over.</source>
          <target state="translated">로컬 지점 (원격이 아닌 로컬)을 제거하고 다시 당기십시오. 이런 식으로 마스터 브랜치에서 변경 사항을 취소하면 푸시하지 않으려는 변경 사항에 영향을받는 사람이 있습니다. 다시 시작해</target>
        </trans-unit>
        <trans-unit id="334349e182a1a9bce03cc62e966ca7b44024d875" translate="yes" xml:space="preserve">
          <source>Resets the index and updates the files in the working tree that are different between &amp;lt;commit&amp;gt; and HEAD, but keeps those which are different between the index and working tree (i.e. which have changes which have not been added).</source>
          <target state="translated">인덱스를 재설정하고 &amp;lt;commit&amp;gt;과 HEAD가 다른 작업 트리의 파일을 업데이트하지만 인덱스와 작업 트리가 다른 파일 (예 : 추가되지 않은 변경 사항)은 유지합니다.</target>
        </trans-unit>
        <trans-unit id="fc9e581b11eb0b9775efb5c50a984923c9d05459" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Undoing-Things&quot;&gt;chapter 4 in the Git book&lt;/a&gt; and &lt;a href=&quot;http://opensource.apple.com/source/Git/Git-26/src/git-htmldocs/howto/revert-a-faulty-merge.txt&quot;&gt;the original post by Linus Torvalds&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://git-scm.com/book/en/Git-Basics-Undoing-Things&quot;&gt;Git 책의 4 장&lt;/a&gt; 과 &lt;a href=&quot;http://opensource.apple.com/source/Git/Git-26/src/git-htmldocs/howto/revert-a-faulty-merge.txt&quot;&gt;Linus Torvalds의 원본 게시물을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="274b6215158331f2fe726e7c73e61ffa2099ff28" translate="yes" xml:space="preserve">
          <source>So before answering let's add some background, explaining what is this &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">대답하기 전에이 &lt;code&gt;HEAD&lt;/code&gt; 가 무엇인지 설명하는 배경을 추가해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="d7d463af4fb364637f2c63bf67569e71bb8b0540" translate="yes" xml:space="preserve">
          <source>So long story short, my commands came down to this:</source>
          <target state="translated">짧은 이야기로, 내 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b147c3dc3a4f5cd9fb62164e17ab88631309f7a0" translate="yes" xml:space="preserve">
          <source>So to revert the whole commit I just needed one &lt;code&gt;git reset --hard HEAD^&lt;/code&gt; and it reverted the whole merge.  Since the merges weren't fast forwarded the merge was a block and one step back is &quot;branch not merged&quot;.</source>
          <target state="translated">전체 커밋을 되돌리려면 하나의 &lt;code&gt;git reset --hard HEAD^&lt;/code&gt; 필요했고 전체 병합을 되돌 렸습니다. 병합이 빨리 전달되지 않았기 때문에 병합은 블록이고 한 단계 뒤로 &quot;분기 병합되지 않음&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="58ab8c9c41be63fb49c1413b152baa6edf2f22cb" translate="yes" xml:space="preserve">
          <source>The accepted answer didn't work for me but this command achieved the results I was looking for.</source>
          <target state="translated">허용 된 답변이 저에게 효과가 없었지만이 명령은 내가 찾고있는 결과를 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="b3f2e65392b9f0e8aa7a4993b688832907bfb6ea" translate="yes" xml:space="preserve">
          <source>The content of &lt;code&gt;HEAD&lt;/code&gt; is stored inside &lt;code&gt;.git/HEAD&lt;/code&gt; and it contains the 40 bytes SHA-1 of the current commit.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 의 내용은 &lt;code&gt;.git/HEAD&lt;/code&gt; 에 저장되며 현재 커밋의 40 바이트 SHA-1을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="d27a11b12a9dbf604d123bb3c78535210f4fee84" translate="yes" xml:space="preserve">
          <source>The first line indicates that a merge occurred. The 2nd line is the time before my merge. I simply &lt;code&gt;git reset --hard 43b6032&lt;/code&gt; to force this branch to track from before the merge, and carry-on.</source>
          <target state="translated">첫 번째 줄은 병합이 발생했음을 나타냅니다. 두 번째 줄은 병합 전의 시간입니다. 나는 단순히 &lt;code&gt;git reset --hard 43b6032&lt;/code&gt; 를 사용하여 병합하기 전에이 분기를 추적하고 계속 수행합니다.</target>
        </trans-unit>
        <trans-unit id="24a5287316a1f0cc421b296f0c8899ca9eb1f1fe" translate="yes" xml:space="preserve">
          <source>The ref &lt;code&gt;ORIG_HEAD&lt;/code&gt; will point to the original commit from before the merge.</source>
          <target state="translated">참조 &lt;code&gt;ORIG_HEAD&lt;/code&gt; 는 병합 전의 원래 커밋을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="c71cf6f7e1fa90c9f775afb4665ce2a1c30fa080" translate="yes" xml:space="preserve">
          <source>The reset command will &quot;undo&quot; any changes made in the given commit.</source>
          <target state="translated">reset 명령은 지정된 커밋에서 변경 한 내용을 &quot;실행 취소&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="36c246d74e903f15f19b4b4f468b11a19c85273b" translate="yes" xml:space="preserve">
          <source>The simplest answer is the one given by odinho - Velmont</source>
          <target state="translated">가장 간단한 답변은 odinho가 제공 한 답변입니다-Velmont</target>
        </trans-unit>
        <trans-unit id="46315a8a488aa1c363f4b4d714215eeb7a26054c" translate="yes" xml:space="preserve">
          <source>The simplest of the simplest chance, much simpler than anything said here:</source>
          <target state="translated">가장 간단한 기회 중 가장 간단한 것은 여기에 언급 된 것보다 훨씬 간단합니다.</target>
        </trans-unit>
        <trans-unit id="9b2e3fbc4a5b3fb872c2498efc43407e3f692226" translate="yes" xml:space="preserve">
          <source>Then reset your repository to the previous working state:</source>
          <target state="translated">그런 다음 저장소를 이전 작업 상태로 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="8beae3e1c748b27b319e9c6a97130b919dfd0ff3" translate="yes" xml:space="preserve">
          <source>Then your local &lt;code&gt;master&lt;/code&gt; branch should look identical to &lt;code&gt;origin/master&lt;/code&gt;.</source>
          <target state="translated">그런 다음 로컬 &lt;code&gt;master&lt;/code&gt; 브랜치는 &lt;code&gt;origin/master&lt;/code&gt; 와 동일하게 보입니다.</target>
        </trans-unit>
        <trans-unit id="b79a2fb8df89268894c41e909d37a43d4b13ea2c" translate="yes" xml:space="preserve">
          <source>There can only be a single &lt;code&gt;HEAD&lt;/code&gt; at any given time. (excluding &lt;code&gt;git worktree&lt;/code&gt;)</source>
          <target state="translated">주어진 시간에 하나의 &lt;code&gt;HEAD&lt;/code&gt; 만있을 수 있습니다. ( &lt;code&gt;git worktree&lt;/code&gt; 제외)</target>
        </trans-unit>
        <trans-unit id="ee7a6bc20b5ced1a19cd919e8fe98498e8d60f93" translate="yes" xml:space="preserve">
          <source>There's also another way:</source>
          <target state="translated">또 다른 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="97f119941e0910625204f7480028f0a6a531a6b9" translate="yes" xml:space="preserve">
          <source>This command will checkout to a given commit.</source>
          <target state="translated">이 명령은 주어진 커밋을 체크 아웃합니다.</target>
        </trans-unit>
        <trans-unit id="cb080ba85575f06731354104952be0e724ba0807" translate="yes" xml:space="preserve">
          <source>This schema illustrates which command does what.</source>
          <target state="translated">이 스키마는 어떤 명령이 무엇을 수행하는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="5a3220d59f02442d914b999dc0551d7558f09d53" translate="yes" xml:space="preserve">
          <source>This will checkout new branch pointing to the desired commit.</source>
          <target state="translated">원하는 커밋을 가리키는 새 분기를 체크 아웃합니다.</target>
        </trans-unit>
        <trans-unit id="deecf3786f5adeab0a8d032a5b74b01cb144271d" translate="yes" xml:space="preserve">
          <source>This will get you back to your desired commit</source>
          <target state="translated">원하는 커밋으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="e2895e088abf9a616278de29a61ed7e4f342becb" translate="yes" xml:space="preserve">
          <source>This will reset in a way that you won't get the merged changes back again after pull.</source>
          <target state="translated">풀 후 병합 된 변경 사항을 다시 가져 오지 않는 방식으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="7fd4a8fd7ec982f6eeaf3304f86596bb5c7f052c" translate="yes" xml:space="preserve">
          <source>This worked for me..!!</source>
          <target state="translated">이것은 나를 위해 일했다 .. !!</target>
        </trans-unit>
        <trans-unit id="b7eb3bb87713872bb7fb72eaecd2f0608217ce8a" translate="yes" xml:space="preserve">
          <source>To undo a merge &lt;strong&gt;that was already pushed&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;이미 푸시&lt;/strong&gt; 된 병합을 취소하려면</target>
        </trans-unit>
        <trans-unit id="2cdbb6097aab99db57c477d72d879e6369243bc1" translate="yes" xml:space="preserve">
          <source>Undo a Git merge that hasn't been pushed yet</source>
          <target state="translated">아직 푸시되지 않은 Git 병합 실행 취소</target>
        </trans-unit>
        <trans-unit id="98d579d6b2feb5d3f566d9acd6f952651cef03e9" translate="yes" xml:space="preserve">
          <source>Use the hash which was there before your wrongly merged commit.</source>
          <target state="translated">잘못 병합 된 커밋 전에 있던 해시를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fc867b197aa26ecdfcad95077e04446aa1aff0e4" translate="yes" xml:space="preserve">
          <source>Voila! Master is at the same stage as origin, and your mis-merged state is erased.</source>
          <target state="translated">짜잔! 마스터는 원점과 같은 단계에 있으며 잘못 병합 된 상태는 지워집니다.</target>
        </trans-unit>
        <trans-unit id="793042088cb8459ce5c14d4a24b0d792d5cdf413" translate="yes" xml:space="preserve">
          <source>When you're satisfied with the results, delete the old branch: &lt;code&gt;git branch --delete feature-1&lt;/code&gt;</source>
          <target state="translated">결과에 만족하면 이전 분기를 삭제하십시오 &lt;code&gt;git branch --delete feature-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0011e4747bd810c3d224a314d8ab4beba79f4baa" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;git reflog&lt;/code&gt; check which commit is one prior the merge (&lt;code&gt;git reflog&lt;/code&gt; will be a better option than &lt;code&gt;git log&lt;/code&gt;). Then you can reset it using:</source>
          <target state="translated">&lt;code&gt;git reflog&lt;/code&gt; 를 사용하면 어떤 커밋이 병합보다 먼저 수행되는지 확인하십시오 ( &lt;code&gt;git reflog&lt;/code&gt; 가 &lt;code&gt;git log&lt;/code&gt; 보다 나은 옵션입니다). 그런 다음 다음을 사용하여 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13583b9b58d16e13b4045f8b4dc5dc8cf2fcf94d" translate="yes" xml:space="preserve">
          <source>With modern Git, you can:</source>
          <target state="translated">현대 Git을 사용하면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8d7ba780922a5b5b9083423774fa25b354a9397d" translate="yes" xml:space="preserve">
          <source>With newer Git versions, if you have not committed the merge yet &lt;em&gt;and you have a merge conflict&lt;/em&gt;, you can simply do:</source>
          <target state="translated">최신 Git 버전에서는 아직 병합을 커밋하지 않았고 &lt;em&gt;병합 충돌&lt;/em&gt; 이있는 경우 간단하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="749ea1d959a0ebe37deff012bb88a6a69cbb9195" translate="yes" xml:space="preserve">
          <source>Within my master branch, I did a &lt;code&gt;git merge some-other-branch&lt;/code&gt; locally, but never pushed the changes to origin master. I didn't mean to merge, so I'd like to undo it. When doing a &lt;code&gt;git status&lt;/code&gt; after my merge, I was getting this message:</source>
          <target state="translated">내 마스터 브랜치 내에서 로컬로 &lt;code&gt;git merge some-other-branch&lt;/code&gt; 했지만 변경 사항을 원본 마스터로 푸시하지 않았습니다. 병합을 의미하지 않았으므로 실행 취소하고 싶습니다. 병합 후 &lt;code&gt;git status&lt;/code&gt; 수행 할 때이 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c30858403c3524d58a855843ab75efd449f6a789" translate="yes" xml:space="preserve">
          <source>You can always use the &lt;code&gt;reflog&lt;/code&gt; as well.</source>
          <target state="translated">언제든지 &lt;code&gt;reflog&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3bbbefa1b0426e85af4fa26c3447a6f934d5419" translate="yes" xml:space="preserve">
          <source>You can easily spot the merge commit there - the first node from the top with two parents</source>
          <target state="translated">거기에 병합 커밋을 쉽게 찾을 수 있습니다-두 부모가있는 맨 처음 노드</target>
        </trans-unit>
        <trans-unit id="e15587c1837f5e19f9351270c2815c88b5e542be" translate="yes" xml:space="preserve">
          <source>You can reset the state to a specific commit with &lt;code&gt;git reset --hard &amp;lt;commit_id&amp;gt;&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;git reset --hard &amp;lt;commit_id&amp;gt;&lt;/code&gt; 를 사용하여 상태를 특정 커밋으로 재설정 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f73fd4d1a2fb9c134e6408b124ae401253ea5bf" translate="yes" xml:space="preserve">
          <source>You can use only two commands to revert a merge or restart by a specific commit:</source>
          <target state="translated">두 가지 명령 만 사용하여 병합을 되돌 리거나 특정 커밋으로 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e85334a85eabbba69e127248b7653400b792033" translate="yes" xml:space="preserve">
          <source>You could use &lt;code&gt;git reflog&lt;/code&gt; to find the previous checkout. Sometimes that's a good state you want to return back to.</source>
          <target state="translated">&lt;code&gt;git reflog&lt;/code&gt; 를 사용하여 이전 체크 아웃을 찾을 수 있습니다. 때때로 그것은 당신이 돌아오고 싶은 좋은 상태입니다.</target>
        </trans-unit>
        <trans-unit id="0fb11ff32e4960861c70effb62bc534ca973adeb" translate="yes" xml:space="preserve">
          <source>You should reset to the previous commit. This should work:</source>
          <target state="translated">이전 커밋으로 재설정해야합니다. 이것은 작동해야합니다 :</target>
        </trans-unit>
        <trans-unit id="e48e60b16c6224a1624a1b5146a75d4b7007bff0" translate="yes" xml:space="preserve">
          <source>[This] can only be run after the merge has resulted in conflicts. &lt;code&gt;git merge --abort&lt;/code&gt; will abort the merge process and try to reconstruct the pre-merge state.</source>
          <target state="translated">[이]는 병합으로 인해 충돌이 발생한 후에 만 ​​실행할 수 있습니다. &lt;code&gt;git merge --abort&lt;/code&gt; 는 병합 프로세스를 중단하고 병합 전 상태를 재구성하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="fa81328d53b03b6761d4913e440f88f24c75bc59" translate="yes" xml:space="preserve">
          <source>but now I'm getting this message with &lt;code&gt;git status&lt;/code&gt;:</source>
          <target state="translated">하지만 이제 &lt;code&gt;git status&lt;/code&gt; 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="274ee127098a717cbb4871f1838bd7d85769251f" translate="yes" xml:space="preserve">
          <source>might yield better results, as it should preserve your changes. &lt;code&gt;ORIG_HEAD&lt;/code&gt; will point to a commit directly before merge has occurred, so you don't have to hunt for it yourself.</source>
          <target state="translated">변경 사항을 보존해야하므로 더 나은 결과를 얻을 수 있습니다. &lt;code&gt;ORIG_HEAD&lt;/code&gt; 는 병합이 발생하기 직전에 커밋을 가리 키므로 직접 추적 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="debc17af5f0a5a0a067f6e38c88e5aa5ee4bb285" translate="yes" xml:space="preserve">
          <source>or using &lt;code&gt;--hard&lt;/code&gt; (&lt;strong&gt;this will remove all local, not committed changes!&lt;/strong&gt;):</source>
          <target state="translated">또는 &lt;code&gt;--hard&lt;/code&gt; 사용 ( &lt;strong&gt;커밋되지 않은 모든 로컬 변경 사항을 제거합니다!&lt;/strong&gt; ) :</target>
        </trans-unit>
        <trans-unit id="8193a36fd2edc40fc568684fc3ab68aed1391e26" translate="yes" xml:space="preserve">
          <source>where this is the range of the correct commits which you've committed (excluding wrongly committed merge).</source>
          <target state="translated">여기서 이것은 커밋 한 올바른 커밋 범위입니다 (잘못 커밋 된 병합 제외).</target>
        </trans-unit>
        <trans-unit id="2af794d5040a7de2611fdfb9d6c67760667c73a6" translate="yes" xml:space="preserve">
          <source>you can also use the &lt;code&gt;git rebase --no-autostash&lt;/code&gt; as well.</source>
          <target state="translated">&lt;code&gt;git rebase --no-autostash&lt;/code&gt; 도 사용할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
