<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/2334712">
    <body>
      <group id="2334712">
        <trans-unit id="a6db237cb15dc6222516efd5984a9145dbc0f882" translate="yes" xml:space="preserve">
          <source>1. Select update</source>
          <target state="translated">1. 업데이트 선택</target>
        </trans-unit>
        <trans-unit id="12e617b2c899e5fba0e5b8f16143f14d7cc298b6" translate="yes" xml:space="preserve">
          <source>2. Update with a common table expression</source>
          <target state="translated">2. 공통 테이블 표현식으로 업데이트</target>
        </trans-unit>
        <trans-unit id="8e5338a63434e5c3e10fe72dd742cd8350e1b109" translate="yes" xml:space="preserve">
          <source>3. Merge</source>
          <target state="translated">3. 병합</target>
        </trans-unit>
        <trans-unit id="8ae828188aacb871b19eb4e24820ab423c5766a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE from SELECT with INNER JOIN in SQL Database&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;SQL 데이터베이스에서 INNER JOIN을 사용하여 SELECT에서 업데이트&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c85c58dec99e5ab948d510b95570ff7548c7b434" translate="yes" xml:space="preserve">
          <source>Alternatively:</source>
          <target state="translated">Alternatively:</target>
        </trans-unit>
        <trans-unit id="23ee30a41eb1bec107c317e951af729b8abc74a2" translate="yes" xml:space="preserve">
          <source>And if you wanted to join the table with itself (which won't happen too often):</source>
          <target state="translated">그리고 테이블 자체를 조인하려면 (너무 자주 발생하지는 않음) :</target>
        </trans-unit>
        <trans-unit id="9f074973253f46d6b4ca6d0fcdc4045a6b7ad96c" translate="yes" xml:space="preserve">
          <source>Another possibility not mentioned yet is to just chuck the &lt;code&gt;SELECT&lt;/code&gt; statement itself into a CTE and then update the CTE.</source>
          <target state="translated">아직 언급되지 않은 또 다른 가능성은 &lt;code&gt;SELECT&lt;/code&gt; 문 자체를 CTE로 척킹 한 다음 CTE를 업데이트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5df2a338a5490823cb4630f93855c0656a853dc5" translate="yes" xml:space="preserve">
          <source>At first, I have created a table named with &lt;strong&gt;schoolold&lt;/strong&gt; and inserted few records with respect to their column names and execute it.</source>
          <target state="translated">처음에는 &lt;strong&gt;schoolold&lt;/strong&gt; 라는 이름의 테이블을 만들고 열 이름과 관련하여 몇 가지 레코드를 삽입하고 실행했습니다.</target>
        </trans-unit>
        <trans-unit id="ca567dda33cdf7058994a40bb9ef4db135c7d283" translate="yes" xml:space="preserve">
          <source>Code:</source>
          <target state="translated">Code:</target>
        </trans-unit>
        <trans-unit id="4e6b721549afcbe3ec27904c7d5818f8239f19d1" translate="yes" xml:space="preserve">
          <source>Consolidating all the different approaches here.</source>
          <target state="translated">모든 다른 접근 방식을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="64bbcdd81675cf9f18de523eb7c4a05c2c9c79a6" translate="yes" xml:space="preserve">
          <source>EITHER:</source>
          <target state="translated">EITHER:</target>
        </trans-unit>
        <trans-unit id="ec223c0aa7af03b59f24a249af0e10b95089ff81" translate="yes" xml:space="preserve">
          <source>For the record (and others searching like I was), you can do it in MySQL like this:</source>
          <target state="translated">레코드 (및 내가 검색 한 다른 사람들)를 위해 MySQL에서 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="597fda30429b893a14eb4baef2cbcaa423bca592" translate="yes" xml:space="preserve">
          <source>Here is another useful syntax:</source>
          <target state="translated">또 다른 유용한 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b4a1d3eb8c724cba5ae23033d6b1d7e56d1549f" translate="yes" xml:space="preserve">
          <source>How do I UPDATE from a SELECT in SQL Server</source>
          <target state="translated">SQL Server의 SELECT에서 업데이트하는 방법</target>
        </trans-unit>
        <trans-unit id="6163cb655132efe6f5340ac347d7e2e786db4dc7" translate="yes" xml:space="preserve">
          <source>I add this only so you can see a quick way to write it so that you can check what will be updated before doing the update.</source>
          <target state="translated">나는 이것을 추가하기 만하면 업데이트를 작성하기 전에 업데이트 할 내용을 확인할 수 있도록 빠른 작성 방법을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e7cf57ce36f67fb425be1e80cd0a51878760cb5" translate="yes" xml:space="preserve">
          <source>I usually need to document what I did, so I use the &lt;code&gt;&quot;results to Text&quot;&lt;/code&gt; option when I run the roll-backed query and I save both the script and the result of the OUTPUT. (Of course this is not practical if I changed too many rows)</source>
          <target state="translated">일반적으로 수행 한 작업을 문서화해야하므로 롤백 된 쿼리를 실행할 때 &lt;code&gt;&quot;results to Text&quot;&lt;/code&gt; 옵션 을 사용하고 스크립트와 OUTPUT 결과를 모두 저장합니다. (물론 너무 많은 행을 변경하면 실용적이지 않습니다)</target>
        </trans-unit>
        <trans-unit id="d07e91971c2656c1f8d2cc5468323636557a6371" translate="yes" xml:space="preserve">
          <source>I would add:</source>
          <target state="translated">나는 추가 할 것이다 :</target>
        </trans-unit>
        <trans-unit id="34bd41323655b82ae85b2e7c6fab50f8cc1e7463" translate="yes" xml:space="preserve">
          <source>I'd modify &lt;a href=&quot;https://stackoverflow.com/questions/2334712/how-do-i-update-from-a-select-in-sql-server/2334741#2334741&quot;&gt;Robin's excellent answer&lt;/a&gt; to the following:</source>
          <target state="translated">다음에 &lt;a href=&quot;https://stackoverflow.com/questions/2334712/how-do-i-update-from-a-select-in-sql-server/2334741#2334741&quot;&gt;대한 Robin의 탁월한 답변&lt;/a&gt; 을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="ae70593daf230df3ad330f99150f2ce9154e3459" translate="yes" xml:space="preserve">
          <source>If the ID column name is the same in both tables then just put the table name before the table to be updated and use an alias for the selected table, i.e.:</source>
          <target state="translated">ID 열 이름이 두 테이블에서 동일하면 업데이트 할 테이블 앞에 테이블 이름을 넣고 선택한 테이블의 별명을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="310d7c7e8e8a6a1f36a8e0af5629b60f810dbc86" translate="yes" xml:space="preserve">
          <source>If you are using SQL Server you can update one table from another without specifying a join and simply link the two from the &lt;code&gt;where&lt;/code&gt; clause. This makes a much simpler SQL query:</source>
          <target state="translated">SQL Server를 사용하는 경우 조인을 지정하지 않고 한 테이블을 다른 테이블에서 업데이트하고 &lt;code&gt;where&lt;/code&gt; 절에서 두 테이블을 간단히 연결할 수 있습니다. 이것은 훨씬 간단한 SQL 쿼리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="66d6ee6a83190cab5a50d815a64a3f67bb626be3" translate="yes" xml:space="preserve">
          <source>If you use &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQL&quot;&gt;MySQL&lt;/a&gt; instead of SQL Server, the syntax is:</source>
          <target state="translated">SQL Server 대신 &lt;a href=&quot;http://en.wikipedia.org/wiki/MySQL&quot;&gt;MySQL&lt;/a&gt; 을 사용하는 경우 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9d137e5e17e7c93441c71acb79e306686ef38be7" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;SQL Server&lt;/strong&gt;, it is possible to &lt;code&gt;INSERT&lt;/code&gt; into a table using a &lt;code&gt;SELECT&lt;/code&gt; statement:</source>
          <target state="translated">&lt;strong&gt;SQL Server&lt;/strong&gt; 에서는 &lt;code&gt;SELECT&lt;/code&gt; 문을 사용하여 테이블에 &lt;code&gt;INSERT&lt;/code&gt; 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afdf980e0647f936faf92d524e2a83f3295c7c3b" translate="yes" xml:space="preserve">
          <source>In SQL Server 2008 (or better), use &lt;a href=&quot;http://technet.microsoft.com/en-us/library/bb510625.aspx&quot;&gt;&lt;code&gt;MERGE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">SQL Server 2008 이상에서는 &lt;a href=&quot;http://technet.microsoft.com/en-us/library/bb510625.aspx&quot;&gt; &lt;code&gt;MERGE&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="264420f4045c826a62ea1ce9d40fca059d9612a7" translate="yes" xml:space="preserve">
          <source>In the accepted answer, after the:</source>
          <target state="translated">허용 된 답변에서 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ecbe78816c662ff6b7b2316de35cd13a495b8027" translate="yes" xml:space="preserve">
          <source>In this Merge statement, we can do inset if not finding a matching record in the target, but exist in the source and please find syntax:</source>
          <target state="translated">이 Merge 문에서 대상에서 일치하는 레코드를 찾지 못하더라도 소스에 존재하고 구문을 찾으면 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88f84f1e6147f6d5cd2049ad44777851802abdeb" translate="yes" xml:space="preserve">
          <source>Is it also possible to &lt;em&gt;update&lt;/em&gt; via a &lt;code&gt;SELECT&lt;/code&gt;? I have a temporary table containing the values and would like to update another table using those values. Perhaps something like this:</source>
          <target state="translated">&lt;code&gt;SELECT&lt;/code&gt; 를 통해 &lt;em&gt;업데이트&lt;/em&gt; 할 수도 있습니까? 값이 포함 된 임시 테이블이 있고 해당 값을 사용하여 다른 테이블을 업데이트하고 싶습니다. 아마도 이런 식으로 뭔가 :</target>
        </trans-unit>
        <trans-unit id="5861767b66be84f25d10d2fd87039268f3919e17" translate="yes" xml:space="preserve">
          <source>It checks if it is null or not by using &quot;WHERE EXIST&quot;.</source>
          <target state="translated">&quot;WHERE EXIST&quot;를 사용하여 널인지 여부를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="ea8f0d02371e3267b086392b1f463d0c520d86e5" translate="yes" xml:space="preserve">
          <source>Merge</source>
          <target state="translated">Merge</target>
        </trans-unit>
        <trans-unit id="859d2556ee716a0dd6830db6fe75522430460f70" translate="yes" xml:space="preserve">
          <source>Now, Here I want to make some changes in third and fourth row, to complete this action, I execute &lt;strong&gt;UPDATE&lt;/strong&gt; command with &lt;strong&gt;INNER JOIN&lt;/strong&gt;.</source>
          <target state="translated">이제 여기에서 세 번째와 네 번째 행을 약간 변경 하여이 작업을 완료하기 위해 &lt;strong&gt;INNER JOIN으로&lt;/strong&gt; &lt;strong&gt;UPDATE&lt;/strong&gt; 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="6f253cbf35cc30170ea6d83c8b71ed090a9a84a9" translate="yes" xml:space="preserve">
          <source>OR:</source>
          <target state="translated">OR:</target>
        </trans-unit>
        <trans-unit id="ae046f8264a421573cb3bdd7c9a4107d4822e032" translate="yes" xml:space="preserve">
          <source>One way</source>
          <target state="translated">일방 통행</target>
        </trans-unit>
        <trans-unit id="4d0d532988ce58f7b2e5599cf6cf11cd57fb3552" translate="yes" xml:space="preserve">
          <source>Option 1: Using Inner Join:</source>
          <target state="translated">옵션 1 : 내부 결합 사용 :</target>
        </trans-unit>
        <trans-unit id="a8da7dc74252fed3569a661e4898568980fcf2ed" translate="yes" xml:space="preserve">
          <source>Option 2: Co related Sub query</source>
          <target state="translated">옵션 2 : 공동 관련 하위 쿼리</target>
        </trans-unit>
        <trans-unit id="dd3b86d1ef21b9fb2e1edc30f524e7afb491b1ad" translate="yes" xml:space="preserve">
          <source>Product</source>
          <target state="translated">Product</target>
        </trans-unit>
        <trans-unit id="c28d43ef3d1608534365376661ff7aa377d9795f" translate="yes" xml:space="preserve">
          <source>Product_BAK</source>
          <target state="translated">Product_BAK</target>
        </trans-unit>
        <trans-unit id="057f604cfd130a0a114581ef746411f9aefbbf31" translate="yes" xml:space="preserve">
          <source>Sample data</source>
          <target state="translated">샘플 데이터</target>
        </trans-unit>
        <trans-unit id="ac22d3ff6a4ab09237cc3b7bf6b615da67d28a9a" translate="yes" xml:space="preserve">
          <source>Sample data set:</source>
          <target state="translated">샘플 데이터 세트 :</target>
        </trans-unit>
        <trans-unit id="a885fa38466d4bd62aeabd9091990192bf07fb14" translate="yes" xml:space="preserve">
          <source>Sample table structure is below and will update from Product_BAK to Product table.</source>
          <target state="translated">샘플 테이블 구조는 다음과 같으며 Product_BAK에서 ​​Product 테이블로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="f57b7f6a501fde8a54afcaf184fd8a80e6e18221" translate="yes" xml:space="preserve">
          <source>Select update</source>
          <target state="translated">업데이트 선택</target>
        </trans-unit>
        <trans-unit id="f203f9c1371f88096532cc5edf4d48f39a8ec51f" translate="yes" xml:space="preserve">
          <source>Since there are too many replies of this post, which are most heavily up-voted, I thought I would provide my suggestion here too. Although the question is very interesting, I have seen in many forum sites and made a solution using &lt;strong&gt;INNER JOIN&lt;/strong&gt; with screenshots.</source>
          <target state="translated">이 게시물에 대한 답변이 너무 많아서 가장 많이 투표되었으므로 여기에 제안을 제공 할 것이라고 생각했습니다. 질문이 매우 흥미롭지 만 많은 포럼 사이트에서 보았고 스크린 샷이있는 &lt;strong&gt;INNER JOIN&lt;/strong&gt; 을 사용하여 솔루션을 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="ff2db8496ee2f5b1dc186ef72b80c4a2a0210409" translate="yes" xml:space="preserve">
          <source>The below solution works for a MySQL database:</source>
          <target state="translated">아래 솔루션은 MySQL 데이터베이스에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="69178d01b42e3b1b091bb3e063abd9e97f9d6d74" translate="yes" xml:space="preserve">
          <source>The following example uses a derived table, a SELECT statement after the FROM clause, to return the old and new values for further updates:</source>
          <target state="translated">다음 예는 FROM 절 뒤에 나오는 SELECT 문인 파생 테이블을 사용하여 추가 업데이트를 위해 이전 값과 새 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="890166d57a9f2f8522ba5852dea74b1a098fd677" translate="yes" xml:space="preserve">
          <source>The other way is to use a derived table:</source>
          <target state="translated">다른 방법은 파생 테이블을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f7cb1081d82eda9c534a3c27875e232d12f9508f" translate="yes" xml:space="preserve">
          <source>The other way to update from a select statement:</source>
          <target state="translated">select 문에서 업데이트하는 다른 방법 :</target>
        </trans-unit>
        <trans-unit id="78a5fb1ccec0d1689f1cd92635848a9c25d4b8b6" translate="yes" xml:space="preserve">
          <source>The simple way to do it is:</source>
          <target state="translated">이를 수행하는 간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ca6788a482a79f6fca0be90f3ace330152a68d76" translate="yes" xml:space="preserve">
          <source>The syntax for the UPDATE statement when updating one table with data from another table in SQL Server</source>
          <target state="translated">SQL Server에서 다른 테이블의 데이터로 한 테이블을 업데이트 할 때 UPDATE 문의 구문</target>
        </trans-unit>
        <trans-unit id="1a611dc4c9c46b9470e10b78a319e6e87ec7c0e4" translate="yes" xml:space="preserve">
          <source>Then I created a new table named with &lt;strong&gt;schoolnew&lt;/strong&gt; and similarly executed above actions on it.</source>
          <target state="translated">그런 다음 &lt;strong&gt;schoolnew&lt;/strong&gt; 라는 새 테이블을 만들고 위의 작업을 비슷하게 실행했습니다.</target>
        </trans-unit>
        <trans-unit id="b3d383993aefb9ae725a4aac5e171b70a0bfda99" translate="yes" xml:space="preserve">
          <source>Then I executed &lt;strong&gt;SELECT&lt;/strong&gt; command to view inserted records.</source>
          <target state="translated">그런 다음 &lt;strong&gt;SELECT&lt;/strong&gt; 명령을 실행하여 삽입 된 레코드를 봅니다.</target>
        </trans-unit>
        <trans-unit id="83476670ffcf0675cfc76e2331748f4d7aebaee4" translate="yes" xml:space="preserve">
          <source>Then, to view inserted records in it, I execute SELECT command.</source>
          <target state="translated">그런 다음 삽입 된 레코드를 보려면 SELECT 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="5f4f2cc4d6f98f7383465abbbf596fc5bceb618b" translate="yes" xml:space="preserve">
          <source>There is even a &lt;strong&gt;shorter method&lt;/strong&gt; and it might be surprising for you:</source>
          <target state="translated">&lt;strong&gt;더 짧은 방법&lt;/strong&gt; 이 있으며 놀랍습니다.</target>
        </trans-unit>
        <trans-unit id="6c2c3157d51048ac3c8bbd057ac3153e5cc5e1b4" translate="yes" xml:space="preserve">
          <source>This also has the same limitation as the proprietary &lt;code&gt;UPDATE ... FROM&lt;/code&gt; syntax shown in four of the other answers. If the source table is on the many side of a one-to-many join then it is undeterministic which of the possible matching joined records will be used in the &lt;code&gt;Update&lt;/code&gt; (an issue that &lt;code&gt;MERGE&lt;/code&gt; avoids by raising an error if there is an attempt to update the same row more than once).</source>
          <target state="translated">이것은 또한 다른 네 가지 답변에 표시된 독점 &lt;code&gt;UPDATE ... FROM&lt;/code&gt; 구문과 동일한 제한 사항이 있습니다. 소스 테이블이 일대 다 조인의 여러면에있는 경우 &lt;code&gt;Update&lt;/code&gt; 에서 사용할 수있는 일치하는 조인 레코드 중 어떤 것이 일치하는지 결정되지 않습니다 (메시지가 같은 행을 두 번 이상 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="8f0ff4ee486e4b330713830d13ef829452fdeac3" translate="yes" xml:space="preserve">
          <source>This has the benefit that it is easy to run the &lt;code&gt;SELECT&lt;/code&gt; statement on its own first to sanity check the results, but it does requires you to alias the columns as above if they are named the same in source and target tables.</source>
          <target state="translated">이는 결과를 점검하기 위해 자체적으로 &lt;code&gt;SELECT&lt;/code&gt; 문을 실행하기 쉽다는 이점이 있지만, 소스 및 목표 테이블에서 이름이 동일하면 컬럼을 별명으로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="7484e7042a31c4089ae242ee3c4a8395da0199f5" translate="yes" xml:space="preserve">
          <source>This may be a niche reason to perform an update (for example, mainly used in a procedure), or may be obvious to others, but it should also be stated that you can perform an update-select statement without using join (in case the tables you're updating between have no common field).</source>
          <target state="translated">이는 업데이트를 수행해야하는 틈새 이유 (예 : 주로 프로 시저에서 사용됨)이거나 다른 사람에게는 분명 할 수 있지만 조인을 사용하지 않고 update-select 문을 수행 할 수 있다고 명시해야합니다 ( 사이에 업데이트하는 테이블에는 공통 필드가 없습니다).</target>
        </trans-unit>
        <trans-unit id="2e00df46395d37228b3f82bad148f68bcb36d568" translate="yes" xml:space="preserve">
          <source>To make sure you are updating what you want, select first</source>
          <target state="translated">원하는 것을 업데이트하려면 먼저 선택하십시오</target>
        </trans-unit>
        <trans-unit id="c03367e0bedac9f1546349e531e58104aa9f31c9" translate="yes" xml:space="preserve">
          <source>To view the changes I execute the &lt;strong&gt;SELECT&lt;/strong&gt; command.</source>
          <target state="translated">변경 사항을 보려면 &lt;strong&gt;SELECT&lt;/strong&gt; 명령을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="7af526ac1431c476f42f44fb4df1a6ccb24c3cf6" translate="yes" xml:space="preserve">
          <source>Update with a common table expression</source>
          <target state="translated">공통 테이블 표현식으로 업데이트</target>
        </trans-unit>
        <trans-unit id="184f36dd119b7ff0fa7e0f779377c79d00d2bd08" translate="yes" xml:space="preserve">
          <source>Updating through &lt;code&gt;CTE&lt;/code&gt; is more readable than the other answers here:</source>
          <target state="translated">&lt;code&gt;CTE&lt;/code&gt; 를 통한 업데이트는 다른 답변보다 읽기 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="0fb907939ff96b5c326dd4b12142c6d3282dc7e7" translate="yes" xml:space="preserve">
          <source>Using alias:</source>
          <target state="translated">별명 사용 :</target>
        </trans-unit>
        <trans-unit id="01b93305e15b2174941c18c38783c3ed050cd4ef" translate="yes" xml:space="preserve">
          <source>What I usually do is putting everything in a roll backed transaction and using the &lt;code&gt;&quot;OUTPUT&quot;&lt;/code&gt;: in this way I see everything that is about to happen. When I am happy with what I see, I change the &lt;code&gt;ROLLBACK&lt;/code&gt; into &lt;code&gt;COMMIT&lt;/code&gt;.</source>
          <target state="translated">내가 보통하는 일은 롤백 된 트랜잭션에 모든 것을 넣고 &lt;code&gt;&quot;OUTPUT&quot;&lt;/code&gt; 을 사용하는 것입니다. 이런 식으로 나는 일어날 모든 것을 본다. 내가 보는 것에 만족하면 &lt;code&gt;ROLLBACK&lt;/code&gt; 을 &lt;code&gt;COMMIT&lt;/code&gt; 로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="480998eb6efe873d2266691d7723b85cc6a4d656" translate="yes" xml:space="preserve">
          <source>Without a WHERE clause, you'll affect even rows that don't need to be affected, which could (possibly) cause index recalculation or fire triggers that really shouldn't have been fired.</source>
          <target state="translated">WHERE 절이 없으면 영향을받을 필요가없는 행에도 영향을 미쳐 실제로 실행되어서는 안되는 인덱스 재 계산 또는 트리거를 유발할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc2b6d2797e20d024181f3fcfcfb60b14cc507ea" translate="yes" xml:space="preserve">
          <source>You can see how Third and Fourth records of table &lt;strong&gt;schoolold&lt;/strong&gt; easily replaced with table &lt;strong&gt;schoolnew&lt;/strong&gt; by using INNER JOIN with UPDATE statement.</source>
          <target state="translated">INNER JOIN with UPDATE 문을 사용하여 테이블 &lt;strong&gt;스쿨&lt;/strong&gt; 의 세 번째 및 네 번째 레코드가 테이블 &lt;strong&gt;스쿨&lt;/strong&gt; 테이블 &lt;strong&gt;로&lt;/strong&gt; 쉽게 대체 된 방법을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b996753603660c27dedf32869e4b9a0c601ba19c" translate="yes" xml:space="preserve">
          <source>You can use from this for update in sql server</source>
          <target state="translated">SQL Server에서 업데이트를 위해 이것을 사용할 수 있습니다</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
