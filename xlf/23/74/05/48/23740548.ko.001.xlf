<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/23740548">
    <body>
      <group id="23740548">
        <trans-unit id="46eec30438cc774dfe89ee6fc8322ef329974f81" translate="yes" xml:space="preserve">
          <source>-After trying this for a while</source>
          <target state="translated">-한동안 시도한 후</target>
        </trans-unit>
        <trans-unit id="862341ae9494327cda571a07ef73a817052026e7" translate="yes" xml:space="preserve">
          <source>1. Use AJAX to get the data you need from the server</source>
          <target state="translated">1. AJAX를 사용하여 서버에서 필요한 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d4c2d7c60449a4e8a50591946728b8a55af5c574" translate="yes" xml:space="preserve">
          <source>2. Echo the data into the page somewhere, and use JavaScript to get the information from the DOM</source>
          <target state="translated">2. 데이터를 페이지 어딘가에 에코하고 JavaScript를 사용하여 DOM에서 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d546fa1ec8ac92e73b01fef0eec4306cdbb7922b" translate="yes" xml:space="preserve">
          <source>3. Echo the data directly to JavaScript</source>
          <target state="translated">3. 데이터를 JavaScript로 직접 에코</target>
        </trans-unit>
        <trans-unit id="8ad8c9c0edec3fbde987709801a7a144ff369744" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.php.net/manual/en/function.setcookie.php&quot;&gt;Setting a cookie&lt;/a&gt; is really not very difficult, you just assign it a value:</source>
          <target state="translated">&lt;a href=&quot;http://www.php.net/manual/en/function.setcookie.php&quot;&gt;쿠키를 설정하는&lt;/a&gt; 것은 그리 어렵지 않습니다 . 쿠키 에 값을 지정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="ccb0fc54a2d30cd9681fbe79d88f9fb00705ace9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$PHPVar&lt;/code&gt; encoded as UTF-8, Unicode.</source>
          <target state="translated">UTF-8, 유니 코드로 인코딩 된 &lt;code&gt;$PHPVar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e6aa5105da17aeb29cfb7228192ee1fe3f079c69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest&quot;&gt;Using XMLHttpRequest - MDN&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest&quot;&gt;XMLHttpRequest 사용-MDN&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="12538cb28bb57e2de5e2e36e792f1d468f0b79e9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest&quot;&gt;XMLHttpRequest object reference - MDN&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest&quot;&gt;XMLHttpRequest 객체 참조-MDN&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fef4cf36ef38d6a43241496d862b3b0e14229d31" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-ajax-call&quot;&gt;How do I return the response from an asynchronous call?&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/14220321/how-to-return-the-response-from-an-ajax-call&quot;&gt;비동기 호출에서 응답을 어떻게 반환합니까?&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dc8002d44629e19fb8be35797acc3d6a95bf69ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Allows for asynchronous data transfer&lt;/strong&gt; - Getting the information from PHP might be time/resources expensive. Sometimes you just don't want to wait for the information, load the page, and have the information reach whenever.</source>
          <target state="translated">&lt;strong&gt;비동기식 데이터 전송 가능&lt;/strong&gt; -PHP에서 정보를 얻는 데 시간 / 자원이 많이 소요될 수 있습니다. 때로는 정보를 기다렸다가 페이지를로드하고 정보가 도달 할 때까지 원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="10c7bb50f381a1578a2d3b11326496c69af1ab61" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Better separation between layers&lt;/strong&gt; - If tomorrow you stop using PHP, and want to move to a servlet, a REST API, or some other service, you don't have to change much of the JavaScript code.</source>
          <target state="translated">&lt;strong&gt;계층 간 더 나은 분리&lt;/strong&gt; -내일 PHP 사용을 중단하고 서블릿, REST API 또는 다른 서비스로 이동하려는 경우 많은 JavaScript 코드를 변경할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="af5e48ceb48ed07de598bfb063f04f1de1679311" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Data is not directly found on the markup&lt;/strong&gt; - This means that your markup is kept clean of any additional data, and only JavaScript sees it.</source>
          <target state="translated">&lt;strong&gt;마크 업에서 데이터를 직접 찾을 수 없음&lt;/strong&gt; -이는 마크 업에서 추가 데이터를 깨끗하게 유지하며 JavaScript 만 볼 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="e760b2ca0e6a5121c1ae41a18ca3fbeffb5c5f64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Dirties up the Source&lt;/strong&gt; - Data that PHP generates is outputted directly to the HTML source, meaning that you get a bigger and less focused HTML source.</source>
          <target state="translated">&lt;strong&gt;소스를 더럽 힙니다&lt;/strong&gt; -PHP가 생성하는 데이터는 HTML 소스로 직접 출력되므로 더 크고 덜 집중된 HTML 소스를 얻게됩니다.</target>
        </trans-unit>
        <trans-unit id="d23c2645362bec7cbfffeaa8030ab34246141ca0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Does not dirty source&lt;/strong&gt; - Variables are outputted directly to JavaScript, so the DOM is not affected.</source>
          <target state="translated">&lt;strong&gt;더티 소스가 아님&lt;/strong&gt; -변수가 JavaScript로 직접 출력되므로 DOM은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a8efcde412aa0784b1cf3438ab9e0970583f8316" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Encode the variable as JSON&lt;/strong&gt; - JSON looks very close to JavaScript objects and &lt;em&gt;most&lt;/em&gt; JSON objects are valid JavaScript variables.</source>
          <target state="translated">&lt;strong&gt;변수를 JSON으로 인코딩-JSON은&lt;/strong&gt; JavaScript 객체와 매우 유사하며 &lt;em&gt;대부분의&lt;/em&gt; JSON 객체는 유효한 JavaScript 변수입니다.</target>
        </trans-unit>
        <trans-unit id="b00a400c5865b38d4a89f1b5a752e46beb1ee71a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fast&lt;/strong&gt; - DOM operations are often quick, and you can store and access a lot of data relatively quickly.</source>
          <target state="translated">&lt;strong&gt;빠름&lt;/strong&gt; -DOM 작업이 빠르며 많은 데이터를 비교적 빠르게 저장하고 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="733b3e090efc1ab3767d95e0ec4f08a1357ab427" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Harder to get structured data&lt;/strong&gt; - Structured data will have to be valid HTML, otherwise you'll have to escape and convert strings yourself.</source>
          <target state="translated">&lt;strong&gt;구조화 된 데이터를 얻는 것이 더 어렵습니다&lt;/strong&gt; -구조화 된 데이터는 유효한 HTML이어야합니다. 그렇지 않으면 문자열을 직접 이스케이프하고 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="34128605373047345591619006457e85b5c1f1b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;JS&lt;/strong&gt;&lt;em&gt;(yourexternal.js)&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;JS&lt;/strong&gt;&lt;em&gt;(yourexternal.js)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c84101ad7c4a0f6775e58c6652b6c6ae94763990" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Latency&lt;/strong&gt; - AJAX creates an HTTP request, and HTTP requests are carried over network and have network latencies.</source>
          <target state="translated">&lt;strong&gt;지연 시간&lt;/strong&gt; -AJAX는 HTTP 요청을 생성하고 HTTP 요청은 네트워크를 통해 전달되며 네트워크 지연이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d080282a7ebce3dc7e3a2709dd1cf6ce26546537" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More readable&lt;/strong&gt; - JavaScript is JavaScript, PHP is PHP. Without mixing the two, you get more readable code on both languages.</source>
          <target state="translated">&lt;strong&gt;더 읽기&lt;/strong&gt; -JavaScript는 JavaScript, PHP는 PHP입니다. 둘을 혼합하지 않으면 두 언어 모두에서 더 읽기 쉬운 코드를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8e01739d5b6815e58b82ad6033855dbc821cb51" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b86f02d233610bf5027dc98685331fe1c7e25ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OUTPUT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OUTPUT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="226c6d195092d25e48f4779200988ceb25b71b01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Output&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="c0ea0dc97baa1d4c675361104fa844e8cea6bf02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;PHP&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;PHP&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f95e90683350b47754a297318c573269d8508ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Postscript:&lt;/strong&gt; You have to be &lt;em&gt;very&lt;/em&gt; aware of XSS attack vectors when you inject anything from PHP to JavaScript. It's &lt;em&gt;very&lt;/em&gt; hard to escape values properly and it's context sensitive. If you're unsure how to deal with XSS, or unaware of it - please read &lt;a href=&quot;https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)&quot;&gt;this OWASP article&lt;/a&gt;, &lt;a href=&quot;https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet&quot;&gt;this one&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/questions/71328/what-are-the-best-practices-for-avoiding-xss-attacks-in-a-php-site&quot;&gt;this question&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Postscript :&lt;/strong&gt; PHP에서 JavaScript로 무엇이든 삽입 할 때 XSS 공격 경로에 대해 잘 알고 있어야합니다. 값을 올바르게 이스케이프하는 &lt;em&gt;것은 매우&lt;/em&gt; 어렵고 상황에 따라 다릅니다. XSS 처리 방법을 잘 모르거나 모르는 &lt;a href=&quot;https://www.owasp.org/index.php/Cross-site_Scripting_(XSS)&quot;&gt;경우이 OWASP 기사&lt;/a&gt; , &lt;a href=&quot;https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet&quot;&gt;이&lt;/a&gt; 기사 및 &lt;a href=&quot;https://stackoverflow.com/questions/71328/what-are-the-best-practices-for-avoiding-xss-attacks-in-a-php-site&quot;&gt;이 질문을&lt;/a&gt; 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="008d12f30693a6dfdddb775daaf95b3aec1f33b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Potentially Unsemantic Markup&lt;/strong&gt; - Usually, what happens is that you use some sort of &lt;code&gt;&amp;lt;input type=hidden&amp;gt;&lt;/code&gt; to store the information, because it's easier to get the information out of &lt;code&gt;inputNode.value&lt;/code&gt;, but doing so means that you have a meaningless element in your HTML. HTML has the &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; element for data about the document, and HTML 5 introduces &lt;code&gt;data-*&lt;/code&gt; attributes for data specifically for reading with JavaScript that can be associated with particular elements.</source>
          <target state="translated">&lt;strong&gt;잠재적으로 의미가없는 마크 업&lt;/strong&gt; -일반적으로 발생하는 정보는 정보를 저장하기 위해 일종의 &lt;code&gt;&amp;lt;input type=hidden&amp;gt;&lt;/code&gt; 을 사용하는 것입니다. &lt;code&gt;inputNode.value&lt;/code&gt; 에서 정보를 가져 오는 것이 더 쉽기 때문에 의미없는 요소가 있음을 의미합니다. 당신의 HTML. HTML에는 문서에 대한 데이터에 대한 &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; 요소가 있으며 HTML 5에는 특정 요소와 연관 될 수있는 JavaScript로 읽을 데이터에 대한 &lt;code&gt;data-*&lt;/code&gt; 속성이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="298deaf78fc9d84f89b8dd403d2b57c8597230b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;STEP 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1 단계&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf565f25a6f29853f22c43df4846df3d2f59f474" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;STEP 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2 단계&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb67fb2211bcefe810184c828bb2d3f1c746b855" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Set a cookie&lt;/strong&gt; - cookies are headers sent in HTTP requests that both the server and client can read.</source>
          <target state="translated">&lt;strong&gt;쿠키 설정&lt;/strong&gt; -쿠키는 서버와 클라이언트 모두가 읽을 수있는 HTTP 요청으로 전송 된 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="b1a93cc84e675d25be823ba0798f571385163387" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simply use one of the following methods.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다음 방법 중 하나를 사용하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1c6d882c37f5a67c2e26e186fe16ff93e4ba82f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;State&lt;/strong&gt; - Data fetched via a separate HTTP request won't include any information from the HTTP request that fetched the HTML document. You may need this information (e.g., if the HTML document is generated in response to a form submission) and, if you do, will have to transfer it across somehow. If you have ruled out embedding the data in the page (which you have if you are using this technique) then that limits you to cookies/sessions which may be subject to race conditions.</source>
          <target state="translated">&lt;strong&gt;상태&lt;/strong&gt; -별도의 HTTP 요청을 통해 가져온 데이터에는 HTML 문서를 가져온 HTTP 요청의 정보가 포함되지 않습니다. 이 정보가 필요할 수 있습니다 (예 : 양식 제출에 대한 응답으로 HTML 문서가 생성 된 경우). 필요한 경우 어떻게 든 전송해야합니다. 페이지에 데이터를 포함하지 않은 경우 (이 기술을 사용하는 경우) 경쟁 조건에 따라 쿠키 / 세션으로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="fe8449584afd652ee96e5a74a972156ec3b9cf1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tightly couples PHP to your data logic&lt;/strong&gt; - Because PHP is used in presentation, you can't separate the two cleanly.</source>
          <target state="translated">&lt;strong&gt;PHP를 데이터 로직에 밀접하게 연결&lt;/strong&gt; -PHP는 프리젠 테이션에 사용되므로 두 가지를 완전히 분리 할 수 ​​없습니다.</target>
        </trans-unit>
        <trans-unit id="aad7c87eb312788d6d0ca28c9179b01c72dc28de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Very easily implemented&lt;/strong&gt; - It takes very little to implement this, and understand.</source>
          <target state="translated">&lt;strong&gt;매우 쉽게 구현&lt;/strong&gt; -구현하고 이해하는 데 거의 걸리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d0c4ef37b3faa43c6825a3a747130178439dac04" translate="yes" xml:space="preserve">
          <source>A complete tutorial can be found &lt;a href=&quot;http://qnimate.com/assign-javascript-variables-using-wordpressphp/&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">전체 튜토리얼은 &lt;a href=&quot;http://qnimate.com/assign-javascript-variables-using-wordpressphp/&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c439e86e818ec76af3a3fd77e3e1a18e5ad28b4e" translate="yes" xml:space="preserve">
          <source>After much research, I found the easiest method is to pass all kinds of variables easily.</source>
          <target state="translated">많은 연구 끝에 가장 쉬운 방법은 모든 종류의 변수를 쉽게 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c74b4cb177cfc424544fa7f4912bde5042a2cef3" translate="yes" xml:space="preserve">
          <source>Also you should note that the PHP code output is insecure and should be filtered with &lt;code&gt;json_encode()&lt;/code&gt;.</source>
          <target state="translated">또한 PHP 코드 출력이 안전하지 않으며 &lt;code&gt;json_encode()&lt;/code&gt; 로 필터링해야합니다.</target>
        </trans-unit>
        <trans-unit id="69949a2d3916283fd36fd850404fc48c56ce668b" translate="yes" xml:space="preserve">
          <source>Although it works, however it slows down the performance. As PHP is a server-side script while JavaScript is a user side.</source>
          <target state="translated">작동하지만 성능이 느려집니다. PHP는 서버 측 스크립트이고 JavaScript는 사용자측입니다.</target>
        </trans-unit>
        <trans-unit id="7820f70754b5d5e61dd409d6ef8b1bba8fc3fb87" translate="yes" xml:space="preserve">
          <source>Am I writing a website or an application?</source>
          <target state="translated">웹 사이트 나 응용 프로그램을 작성하고 있습니까?</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="29023f9af8c36cba36059ee86f933ef640033d91" translate="yes" xml:space="preserve">
          <source>And your JavaScript code looks like this:</source>
          <target state="translated">그리고 JavaScript 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd368b723a066eda6d70720191b43b06f7eda3f8" translate="yes" xml:space="preserve">
          <source>And, &lt;code&gt;print_scripts()&lt;/code&gt; method of the above example will send this output:</source>
          <target state="translated">그리고 위 예제의 &lt;code&gt;print_scripts()&lt;/code&gt; 메소드는 다음과 같은 출력을 보냅니다 :</target>
        </trans-unit>
        <trans-unit id="b291beb8793f4f3308c463951165dad483715a6c" translate="yes" xml:space="preserve">
          <source>Application</source>
          <target state="translated">Application</target>
        </trans-unit>
        <trans-unit id="8fd06dd0460aa42824404dde19644aba3a0c2914" translate="yes" xml:space="preserve">
          <source>As @Second Rikudo points out, for it to work correctly &lt;code&gt;$val&lt;/code&gt; would need to contain the closing parenthesis, for example: &lt;code&gt;$val=&quot;42);&quot;&lt;/code&gt;</source>
          <target state="translated">@Second Rikudo가 지적했듯이 &lt;code&gt;$val&lt;/code&gt; 이 올바르게 작동하려면 $ val 은 닫는 괄호를 포함해야합니다 (예 : &lt;code&gt;$val=&quot;42);&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="82152b3e2ef4efcab6d6236fa8d91f4468fa798e" translate="yes" xml:space="preserve">
          <source>As other commenters have stated, AJAX is one possible solution, but the cons outweigh the pros: it has a latency and it is harder to program (it needs the code to retrieve the value both server- and client-side), when a simpler escaping function should suffice.</source>
          <target state="translated">다른 논평자들이 말했듯이, AJAX는 하나의 가능한 솔루션이지만 단점은 장점보다 뛰어납니다 : 대기 시간이 길고 프로그래밍하기가 더 어렵습니다 (서버 및 클라이언트 측 모두 값을 검색하는 코드가 필요합니다). 탈출 기능으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="164c63d22cd065bb4bc3fc7baf2dbd2ec61a2357" translate="yes" xml:space="preserve">
          <source>As per your code</source>
          <target state="translated">귀하의 코드에 따라</target>
        </trans-unit>
        <trans-unit id="3a44722e596bef5ceddfae3350cdd1b6136ffdd1" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;$value&lt;/code&gt; is &lt;code&gt;json_encode&lt;/code&gt;able on the PHP side (it usually is). This technique is what Stack Overflow does with its chat for example (only using .NET instead of PHP).</source>
          <target state="translated">&lt;code&gt;$value&lt;/code&gt; 가 PHP 측에서 &lt;code&gt;json_encode&lt;/code&gt; 가능하다고 가정합니다 (보통). 이 기술은 스택 오버플로가 채팅에서 수행하는 작업입니다 (PHP 대신 .NET 만 사용).</target>
        </trans-unit>
        <trans-unit id="c118b0b0e835e36366353b7b99dc3946b9eed95e" translate="yes" xml:space="preserve">
          <source>Because I didn't notice the missing parenthesis in &lt;code&gt;myPlugin.start(&amp;lt;?=$val?&amp;gt;&lt;/code&gt; :-\</source>
          <target state="translated">&lt;code&gt;myPlugin.start(&amp;lt;?=$val?&amp;gt;&lt;/code&gt; :-\에서 빠진 괄호를 보지 못했기 때문에</target>
        </trans-unit>
        <trans-unit id="64f754f22c7ea2f537581583a9e1795173d0aedb" translate="yes" xml:space="preserve">
          <source>But in JavaScript this is a syntax error.</source>
          <target state="translated">그러나 JavaScript에서 이것은 구문 오류입니다.</target>
        </trans-unit>
        <trans-unit id="d1a608b56b4924aac3d153ca85219dcb34e76a9e" translate="yes" xml:space="preserve">
          <source>But there's a big gotcha. If you're using it in events, you need to run &lt;code&gt;htmlspecialchars()&lt;/code&gt; on the result in order to make it correct code. And then you have to either be careful to use double quotes to enclose the event, or always add &lt;code&gt;ENT_QUOTES&lt;/code&gt; to htmlspecialchars. For example:</source>
          <target state="translated">그러나 큰 문제가 있습니다. 이벤트에서 사용하는 경우 올바른 코드를 만들려면 결과에서 &lt;code&gt;htmlspecialchars()&lt;/code&gt; 를 실행해야합니다. 그런 다음 큰 따옴표를 사용하여 이벤트를 묶거나 항상 htmlspecialchars에 &lt;code&gt;ENT_QUOTES&lt;/code&gt; 를 추가해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="317f903d7b7564d2ab36ba047922882bbb8794a6" translate="yes" xml:space="preserve">
          <source>Call &lt;em&gt;AJAX&lt;/em&gt; to recieve &lt;em&gt;JSON&lt;/em&gt; file</source>
          <target state="translated">&lt;em&gt;JSON&lt;/em&gt; 파일을 받기 위해 &lt;em&gt;AJAX&lt;/em&gt; 호출</target>
        </trans-unit>
        <trans-unit id="0fce782e49b19de850642908a7ec08707b6cfa53" translate="yes" xml:space="preserve">
          <source>Cons</source>
          <target state="translated">Cons</target>
        </trans-unit>
        <trans-unit id="2dd9f4cc14ec1bf52b6278d055d1483dda369c44" translate="yes" xml:space="preserve">
          <source>Console output</source>
          <target state="translated">콘솔 출력</target>
        </trans-unit>
        <trans-unit id="bd9b735341ec69897d1e20d25163dd94c6dadd2b" translate="yes" xml:space="preserve">
          <source>Convert &lt;em&gt;JSON&lt;/em&gt; into &lt;em&gt;Javascript&lt;/em&gt; object</source>
          <target state="translated">&lt;em&gt;JSON&lt;/em&gt; 을 &lt;em&gt;Javascript&lt;/em&gt; 객체로 변환</target>
        </trans-unit>
        <trans-unit id="72f0b5653e89c4baa4b3ab62dc42c03c457100e0" translate="yes" xml:space="preserve">
          <source>Convert the data into &lt;em&gt;JSON&lt;/em&gt;</source>
          <target state="translated">데이터를 &lt;em&gt;JSON&lt;/em&gt; 으로 변환</target>
        </trans-unit>
        <trans-unit id="dc86b372fd5d410744764f31f04997c73988b44e" translate="yes" xml:space="preserve">
          <source>Cookies are good for a little data. This is what tracking services often do.</source>
          <target state="translated">쿠키는 작은 데이터에 좋습니다. 이것이 추적 서비스가 자주하는 일입니다.</target>
        </trans-unit>
        <trans-unit id="68c8137816197867081029b6f0f3cde8f1113ffe" translate="yes" xml:space="preserve">
          <source>Echo the data directly to JavaScript.</source>
          <target state="translated">데이터를 JavaScript로 직접 에코하십시오.</target>
        </trans-unit>
        <trans-unit id="5e354e4af87a2f3e24a346e30b270f4b3dcd6f8d" translate="yes" xml:space="preserve">
          <source>Echo the data into the page somewhere, and use JavaScript to get the information from the DOM.</source>
          <target state="translated">데이터를 페이지 어딘가에 에코하고 JavaScript를 사용하여 DOM에서 정보를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="3a1dacae667cdf3b83bd2c5ed36666b2c0c74153" translate="yes" xml:space="preserve">
          <source>Encode what the server had to say in the initial request.</source>
          <target state="translated">초기 요청에서 서버가 말한 내용을 인코딩하십시오.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="cdb5b3a12ec034b209bab623c4ce3a3671ca0676" translate="yes" xml:space="preserve">
          <source>Explanation of the problem</source>
          <target state="translated">문제 설명</target>
        </trans-unit>
        <trans-unit id="64eeb1e8052d2c09ab850b1b746650979268dd7c" translate="yes" xml:space="preserve">
          <source>First PHP is run, it generates the HTML that is served to the client.</source>
          <target state="translated">먼저 PHP가 실행되면 클라이언트에 제공되는 HTML이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7c1147e46e98fc4b1d30aa11d0172cafb2edc8f3" translate="yes" xml:space="preserve">
          <source>First, let's understand the flow of events when a page is served from our server:</source>
          <target state="translated">먼저 서버에서 페이지가 제공 될 때 이벤트 흐름을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="3b3167511d5c059c2404a798c3f217c821b0b98e" translate="yes" xml:space="preserve">
          <source>First, set a script's source directly to a PHP file.</source>
          <target state="translated">먼저, 스크립트 소스를 PHP 파일로 직접 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0d58205f97c9d7eb168226cdf232ff6a57d8750d" translate="yes" xml:space="preserve">
          <source>For those who have some problem using below code and it keep showing &lt;code&gt;&amp;lt;?php echo $username?&amp;gt;&lt;/code&gt; or something like this, go edit the httpd.conf in the mime_module section by add this 'AddType application/x-httpd-php .html .htm' because it may be disabled by default.</source>
          <target state="translated">아래 코드를 사용하는 데 문제가 있고 &lt;code&gt;&amp;lt;?php echo $username?&amp;gt;&lt;/code&gt; 또는 이와 비슷한 것을 계속 표시하려면 mime_module 섹션에서 http'.conf를 편집하여 'AddType application / x-httpd-php .html .htm '은 기본적으로 비활성화되어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e30d6aac813417d581bd798bb4422107881ac34" translate="yes" xml:space="preserve">
          <source>Good luck!</source>
          <target state="translated">행운을 빕니다!</target>
        </trans-unit>
        <trans-unit id="beac9a7099547c58790a38aa21decac1317eb57e" translate="yes" xml:space="preserve">
          <source>Here is a short hand rolled parser, but the answer I linked to right above this has better tested ones:</source>
          <target state="translated">다음은 짧은 손으로 구르는 파서입니다. 그러나 바로 위의 링크가 더 나은 테스트를 거쳤습니다.</target>
        </trans-unit>
        <trans-unit id="61d33eda66526ac9e5b34e0b5e5036ca3a5484ee" translate="yes" xml:space="preserve">
          <source>Here is is the trick:</source>
          <target state="translated">요령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bcb62a51d573957d494f7c013f964cc6c8a67423" translate="yes" xml:space="preserve">
          <source>Here is one I do not see posted as an option. It is similar to using Ajax, but clearly different.</source>
          <target state="translated">다음은 옵션으로 게시되지 않은 것입니다. Ajax를 사용하는 것과 비슷하지만 분명히 다릅니다.</target>
        </trans-unit>
        <trans-unit id="ddf703231aacf673416bffbd9d07075b0d7fe71a" translate="yes" xml:space="preserve">
          <source>Here is the JavaScript code</source>
          <target state="translated">JavaScript 코드는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="9cf080919dfc82edac7797598bdc2917b01a82bc" translate="yes" xml:space="preserve">
          <source>Here is your &lt;strong&gt;'PHP'&lt;/strong&gt; to use that variable:</source>
          <target state="translated">해당 변수를 사용하는 &lt;strong&gt;'PHP'&lt;/strong&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7447988092dd326f69095975e256793b6ee5fc9b" translate="yes" xml:space="preserve">
          <source>How do I pass variables and data from PHP to JavaScript</source>
          <target state="translated">PHP에서 JavaScript로 변수와 데이터를 전달하는 방법</target>
        </trans-unit>
        <trans-unit id="2de995d6a21f5ba6542676ca487b3feceb18aa34" translate="yes" xml:space="preserve">
          <source>However, you can't use &lt;code&gt;htmlspecialchars&lt;/code&gt; on regular JavaScript code (code enclosed in &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;...&lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt; tags). That makes use of this function prone to mistakes, by forgetting to &lt;code&gt;htmlspecialchars&lt;/code&gt; the result when writing event code.</source>
          <target state="translated">그러나 일반 JavaScript 코드 ( &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; ... &lt;code&gt;&amp;lt;/script&amp;gt;&lt;/code&gt; 태그로 묶인 코드)에는 &lt;code&gt;htmlspecialchars&lt;/code&gt; 를 사용할 수 없습니다. 이벤트 코드를 작성할 때 결과를 &lt;code&gt;htmlspecialchars&lt;/code&gt; 로 잊어 버림 으로써이 기능을 실수로 사용하기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="f205480dde098e0ceb6af5bbb02af0b31e4bbddd" translate="yes" xml:space="preserve">
          <source>I have JavaScript code that needs &lt;code&gt;val&lt;/code&gt; and looks along the lines of:</source>
          <target state="translated">나는 &lt;code&gt;val&lt;/code&gt; 이 필요하고 다음 줄을 보는 JavaScript 코드를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6be29b03831ced1f45ac2b7208c97ecd67d127d3" translate="yes" xml:space="preserve">
          <source>I have a variable in PHP, and I need its value in my JavaScript code. How can I get my variable from PHP to JavaScript?</source>
          <target state="translated">PHP에 변수가 있으며 JavaScript 코드에 값이 필요합니다. PHP에서 JavaScript로 변수를 가져 오려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="89b02d2b4b59dce9f89219584bf077cb3e047ff9" translate="yes" xml:space="preserve">
          <source>I have code that looks like this:</source>
          <target state="translated">다음과 같은 코드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8082d8cf01987bd2024be4ab2444fbd234ba939d" translate="yes" xml:space="preserve">
          <source>I have come out with an easy method to assign JavaScript variables using PHP.</source>
          <target state="translated">PHP를 사용하여 JavaScript 변수를 할당하는 쉬운 방법을 찾았습니다.</target>
        </trans-unit>
        <trans-unit id="68c264ab997254314e73ef260dbbff7c2eebca39" translate="yes" xml:space="preserve">
          <source>I quite like the way the WordPress works with its &lt;a href=&quot;http://codex.wordpress.org/Function_Reference/wp_enqueue_script&quot;&gt;enqueue&lt;/a&gt; and &lt;a href=&quot;http://codex.wordpress.org/Function_Reference/wp_localize_script&quot;&gt;localize&lt;/a&gt; functions, so following that model, I wrote a simple class for putting a scripts into page according to the script dependencies, and for making additional data available for the script.</source>
          <target state="translated">나는 워드 프레스가 그 &lt;a href=&quot;http://codex.wordpress.org/Function_Reference/wp_enqueue_script&quot;&gt;enqueue&lt;/a&gt; 와 &lt;a href=&quot;http://codex.wordpress.org/Function_Reference/wp_localize_script&quot;&gt;localize&lt;/a&gt; 함수로 작동하는 방식을 아주 좋아한다. 그래서 그 모델에 따라 스크립트 의존성에 따라 스크립트를 페이지에 넣고 스크립트에 추가 데이터를 제공하는 간단한 클래스를 작성했다.</target>
        </trans-unit>
        <trans-unit id="8bf317e8eed1372b6549dd6f1a1e7180202cc7db" translate="yes" xml:space="preserve">
          <source>I usually use data-* attributes in HTML.</source>
          <target state="translated">나는 보통 HTML에서 data- * 속성을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ce6e20fee9e1027b19ea63c6b1b2755152f93df7" translate="yes" xml:space="preserve">
          <source>I would &lt;em&gt;not&lt;/em&gt; recommend making another request &lt;em&gt;unless your site is an application&lt;/em&gt; for getting that information from the server.</source>
          <target state="translated">&lt;em&gt;귀하의 사이트가&lt;/em&gt; 서버에서 해당 정보를 얻기 &lt;em&gt;위한 응용 프로그램이 아닌 경우&lt;/em&gt; 다른 요청을하는 &lt;em&gt;것은&lt;/em&gt; 권장 &lt;em&gt;하지 않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ea8815b5031f3bc30ddd0b55289d44e66321d03f" translate="yes" xml:space="preserve">
          <source>I'll assume that the data to transmit is a string.</source>
          <target state="translated">전송할 데이터가 문자열이라고 가정하겠습니다.</target>
        </trans-unit>
        <trans-unit id="a6c4fe8cac40c48cf80aded9c2c2026061a8f4b6" translate="yes" xml:space="preserve">
          <source>I'm going to try a simpler answer:</source>
          <target state="translated">더 간단한 답변을 시도하겠습니다.</target>
        </trans-unit>
        <trans-unit id="0a13bc97160fe132329442cd8f2d20a4245d1bcd" translate="yes" xml:space="preserve">
          <source>If you're writing an application - suddenly the initial load time isn't always as important as the ongoing performance of the application, and it starts to pay off to load data and code separately.</source>
          <target state="translated">애플리케이션을 작성하는 경우-갑자기 초기로드 시간이 애플리케이션의 지속적인 성능만큼 항상 중요하지는 않으며 데이터와 코드를 개별적으로로드하기 위해 비용을 지불하기 시작합니다.</target>
        </trans-unit>
        <trans-unit id="ddf54c58245dfd07b5f8af3f7f8cb68d527d86a2" translate="yes" xml:space="preserve">
          <source>Implementation Example</source>
          <target state="translated">구현 예</target>
        </trans-unit>
        <trans-unit id="1bbd085e7cab3189e6219acec776d97464e0179e" translate="yes" xml:space="preserve">
          <source>Implementation is relatively straightforward:</source>
          <target state="translated">구현은 비교적 간단합니다.</target>
        </trans-unit>
        <trans-unit id="b32f566fe85d5afe02db0c806334334aaaa0746c" translate="yes" xml:space="preserve">
          <source>In any of your JavaScript code called on the page, simply call those variables.</source>
          <target state="translated">페이지에서 호출 된 JavaScript 코드에서 해당 변수를 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="709dcab1528bab051ad73bb55366dd3a9b5d739f" translate="yes" xml:space="preserve">
          <source>In no particular order:</source>
          <target state="translated">특별한 순서는 없습니다 :</target>
        </trans-unit>
        <trans-unit id="558aa7016f0efeff04b711ada0d3ebab7db88a0e" translate="yes" xml:space="preserve">
          <source>In the server script, you have two variables, and you are trying to send them to the client scripts:</source>
          <target state="translated">서버 스크립트에는 두 개의 변수가 있으며이를 클라이언트 스크립트로 보내려고합니다.</target>
        </trans-unit>
        <trans-unit id="384112f5db9aa7bf720e4c12e53aa26ef2c3f7ee" translate="yes" xml:space="preserve">
          <source>In this post, we'll examine each of the above methods, and see the pros and cons of each, as well as how to implement them.</source>
          <target state="translated">이 글에서는 위의 각 방법을 살펴보고 각각의 장단점과 그 구현 방법을 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="46cc4226c5a54a93c923df482f127de134bec924" translate="yes" xml:space="preserve">
          <source>It doesn't work because &lt;code&gt;$val&lt;/code&gt; is undefined as far as JavaScript is concerned, i.e. the PHP code did not output anything for &lt;code&gt;$val&lt;/code&gt;. Try viewing the source in your browser and here is what you'll see:</source>
          <target state="translated">JavaScript와 관련하여 &lt;code&gt;$val&lt;/code&gt; 이 정의되지 않았기 때문에 작동하지 않습니다. 즉, PHP 코드가 &lt;code&gt;$val&lt;/code&gt; 대해 아무것도 출력하지 않았습니다. 브라우저에서 소스를보고 다음과 같이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="7facb037bd365aa06bac702dc7ca142f124d71f3" translate="yes" xml:space="preserve">
          <source>It uses HTML5 data attributes to store PHP variables and then it's assigned to JavaScript on page load.</source>
          <target state="translated">HTML5 데이터 속성을 사용하여 PHP 변수를 저장 한 다음 페이지로드시 JavaScript에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="494a40dc2d11ce0dbef08a01b0b28c311c21c249" translate="yes" xml:space="preserve">
          <source>It's possible to write a function that does not have that problem, and can be used both in events and in regular JavaScript code, as long as you enclose your events always in single quotes, or always in double quotes. Here is my proposal, requiring them to be in double quotes (which I prefer):</source>
          <target state="translated">이벤트를 항상 작은 따옴표 나 큰 따옴표로 묶는 한, 문제가없는 함수를 작성할 수 있으며 이벤트와 일반 JavaScript 코드 모두에서 사용할 수 있습니다. 여기 내 제안은 큰 따옴표로 묶어야합니다 (내가 선호하는).</target>
        </trans-unit>
        <trans-unit id="3e31c5e3e9f20beab60925115644ad5bdfa13944" translate="yes" xml:space="preserve">
          <source>Let's say your variable is always integer. In that case this is easier:</source>
          <target state="translated">변수가 항상 정수라고 가정 해 봅시다. 이 경우 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="539b1634269f84e6d1b0a5512f50505fc1088004" translate="yes" xml:space="preserve">
          <source>Let's say your variable is not an integer, but if you try above method you will get something like this:</source>
          <target state="translated">변수가 정수가 아니라고 가정하지만 위의 방법을 시도하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="c42905fc70a76e1fcc61c03881ec129752d0f6ea" translate="yes" xml:space="preserve">
          <source>Meaning that the PHP will now produce &lt;code&gt;myPlugin.start(42);&lt;/code&gt; and will work as expected when executed by the JavaScript code.</source>
          <target state="translated">PHP가 이제 &lt;code&gt;myPlugin.start(42);&lt;/code&gt; 생성한다는 것을 의미합니다 . JavaScript 코드에 의해 실행될 때 예상대로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="1b8c9de85e6fbb0e299b3b6751348c22b18c7b8f" translate="yes" xml:space="preserve">
          <source>My answer &lt;a href=&quot;https://stackoverflow.com/questions/14220321/how-do-i-return-the-response-from-an-asynchronous-call/16825593#16825593&quot;&gt;here&lt;/a&gt; explains how to load data using AJAX in JavaScript:</source>
          <target state="translated">내 대답은 JavaScript에서 AJAX를 사용하여 데이터를로드하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8f0501484184e845f57d52608b9ec3c8aa5589be" translate="yes" xml:space="preserve">
          <source>Now you can get value using DOM, use innerHTML of span id, in this case you don't need to do any call to server, or Ajax or another thing.</source>
          <target state="translated">이제 DOM을 사용하여 가치를 얻고 span id의 innerHTML을 사용할 수 있습니다.이 경우 서버 또는 Ajax 또는 다른 것을 호출 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="8068f871b027293d0305822f527c9cc2ca174cdd" translate="yes" xml:space="preserve">
          <source>Now you have a JavaScript variable called &lt;code&gt;'name'&lt;/code&gt;, and here is your JavaScript code to use that variable:</source>
          <target state="translated">이제 &lt;code&gt;'name'&lt;/code&gt; 이라는 JavaScript 변수가 있으며 해당 변수를 사용하는 JavaScript 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd1b835ef4cc7fda335fe35740e43b557d50fa20" translate="yes" xml:space="preserve">
          <source>Now, the server just needs to contain a &lt;code&gt;/your/url&lt;/code&gt; route/file that contains code that grabs the data and does something with it, in your case:</source>
          <target state="translated">이제 서버에는 데이터를 가져 와서 무언가를 수행하는 코드가 포함 된 &lt;code&gt;/your/url&lt;/code&gt; 경로 / 파일 만 있으면됩니다.</target>
        </trans-unit>
        <trans-unit id="ef563b295e2f40acee867a5bd36f9f01c3a53e2d" translate="yes" xml:space="preserve">
          <source>Once we have more data, we can encode it with JSON inside a JavaScript variable instead:</source>
          <target state="translated">더 많은 데이터가 있으면 대신 JavaScript 변수 내에서 JSON으로 인코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04b6afd362e171e5451b9cda1fd5570671306875" translate="yes" xml:space="preserve">
          <source>Or with jQuery:</source>
          <target state="translated">또는 jQuery를 사용하여 :</target>
        </trans-unit>
        <trans-unit id="935b8c8a12491212e450a47c864d20f91db3f9f8" translate="yes" xml:space="preserve">
          <source>PHP 5.2.0 or more</source>
          <target state="translated">PHP 5.2.0 이상</target>
        </trans-unit>
        <trans-unit id="84083370162d72d8f9d3e15fe561f0204aaadf33" translate="yes" xml:space="preserve">
          <source>Pros</source>
          <target state="translated">Pros</target>
        </trans-unit>
        <trans-unit id="e943bdabd69b9682d2a49eb6728d02f4e4f4f78a" translate="yes" xml:space="preserve">
          <source>Regardless the fact that the script 'jquery' is enqueued after the 'jquery-ui', it is printed before because it is defined in 'jquery-ui' that it depends on 'jquery'.
Additional data for the 'custom-script' are inside a new script block and are placed in front of it, it contains &lt;code&gt;mydata&lt;/code&gt; object that holds additional data, now available to 'custom-script'.</source>
          <target state="translated">스크립트 'jquery'가 'jquery-ui'다음에 대기한다는 사실에 관계없이 'jquery'에 의존하는 'jquery-ui'에 정의되어 있기 때문에 이전에 인쇄됩니다. 'custom-script'에 대한 추가 데이터는 새 스크립트 블록 안에 있으며 그 앞에 배치되며 추가 데이터를 보유한 &lt;code&gt;mydata&lt;/code&gt; 객체를 포함하며 이제 'custom-script'에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d25e7a07e733a6697ed9341862313ab610df792" translate="yes" xml:space="preserve">
          <source>Send more requests from the client &lt;em&gt;after&lt;/em&gt; the initial request is done.</source>
          <target state="translated">초기 요청이 완료된 &lt;em&gt;후&lt;/em&gt; 클라이언트에서 더 많은 요청을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f0daee716c96994db229612b39760267e7f30bb0" translate="yes" xml:space="preserve">
          <source>Sending more requests from the client after the initial request is done is &lt;strong&gt;slow&lt;/strong&gt; as it requires more HTTP requests which have significant overhead. Moreover, it requires &lt;em&gt;asynchronousity&lt;/em&gt; as making an AJAX request requires a handler for when it's complete.</source>
          <target state="translated">초기 요청이 완료된 후 클라이언트에서 더 많은 요청을 보내면 상당한 오버 헤드가있는 더 많은 HTTP 요청이 필요하므로 &lt;strong&gt;속도&lt;/strong&gt; 가 &lt;strong&gt;느립니다&lt;/strong&gt; . 또한 AJAX 요청을 수행하려면 완료시 핸들러가 필요하므로 &lt;em&gt;비동기 성&lt;/em&gt; 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="36b9daa2428f82a34b30f9492aa4a3ea4b6fecf3" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;abcd&lt;/code&gt; in JSON is &lt;code&gt;&quot;abcd&quot;&lt;/code&gt;, it looks like this:</source>
          <target state="translated">JSON의 &lt;code&gt;abcd&lt;/code&gt; 는 &lt;code&gt;&quot;abcd&quot;&lt;/code&gt; 이므로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6dc911661d90433fc535ccd9f64a4fd2ce0a938f" translate="yes" xml:space="preserve">
          <source>So in PHP we have a function call &lt;code&gt;json_encode&lt;/code&gt; that encode string to a JSON object.</source>
          <target state="translated">따라서 PHP에는 문자열을 JSON 객체로 인코딩하는 함수 호출 &lt;code&gt;json_encode&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc95d8a79911147005cceb642ebe959da78a017f" translate="yes" xml:space="preserve">
          <source>So really, the core thing to remember here is that &lt;strong&gt;HTTP is stateless&lt;/strong&gt;. Once a request left the server, the server can not touch it. So, that leaves our options to:</source>
          <target state="translated">따라서 여기서 기억해야 할 핵심은 &lt;strong&gt;HTTP는 stateless&lt;/strong&gt; 입니다. 요청이 서버를 떠나면 서버는이를 만질 수 없습니다. 따라서 우리의 옵션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0232ae782ec7496a58b1ecda2b63db17bc4df3c9" translate="yes" xml:space="preserve">
          <source>So, we're back to escaping. &lt;code&gt;json_encode($string)&lt;/code&gt; works &lt;em&gt;if&lt;/em&gt; you encode the source string as UTF-8 first in case it is not already, because &lt;code&gt;json_encode&lt;/code&gt; requires UTF-8 data. If the string is in ISO-8859-1 then you can simply use &lt;code&gt;json_encode(utf8_encode($string))&lt;/code&gt;; otherwise you can always use &lt;code&gt;iconv&lt;/code&gt; to do the conversion first.</source>
          <target state="translated">그래서 우리는 탈출로 돌아 왔습니다. &lt;code&gt;json_encode($string)&lt;/code&gt; 는 소스 문자열이 아직 UTF-8이 아닌 경우를 대비하여 먼저 UTF-8로 인코딩하면 작동 &lt;em&gt;합니다.&lt;/em&gt; &lt;code&gt;json_encode&lt;/code&gt; 에는 UTF-8 데이터가 필요하기 때문입니다. 문자열이 ISO-8859-1 인 경우 간단히 &lt;code&gt;json_encode(utf8_encode($string))&lt;/code&gt; 사용할 수 있습니다. 그렇지 않으면 항상 &lt;code&gt;iconv&lt;/code&gt; 를 사용하여 먼저 변환을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05b004a92e5eda3ec6e47516b582fc25b61b35b9" translate="yes" xml:space="preserve">
          <source>Solutions</source>
          <target state="translated">Solutions</target>
        </trans-unit>
        <trans-unit id="414f1973914ff9a699ed29ac2dc98f4a89261b97" translate="yes" xml:space="preserve">
          <source>Some more reading material</source>
          <target state="translated">더 읽을 거리</target>
        </trans-unit>
        <trans-unit id="d303d8fe99ead8753ac43620504e67e444495a4a" translate="yes" xml:space="preserve">
          <source>That's the core question you should be asking yourself is:</source>
          <target state="translated">그것은 당신이 스스로에게 물어봐야 할 핵심 질문입니다.</target>
        </trans-unit>
        <trans-unit id="c17dee84fbe20cbd7cf46952b6d2e914dd81a25b" translate="yes" xml:space="preserve">
          <source>The above combination of the two files will alert &lt;code&gt;42&lt;/code&gt; when the file finishes loading.</source>
          <target state="translated">위의 두 파일 조합은 파일로드가 완료되면 &lt;code&gt;42&lt;/code&gt; 를 경고합니다.</target>
        </trans-unit>
        <trans-unit id="3098de74828e2d89faf8205c1e204b80788ce5ab" translate="yes" xml:space="preserve">
          <source>The apple color is yellow, the strawberry color is red and the kiwi
  color is green.</source>
          <target state="translated">사과 색은 노란색, 딸기 색은 빨간색, 키위 색은 녹색입니다.</target>
        </trans-unit>
        <trans-unit id="df2d6642b13d7b99a1a257d4525a9179b63d431b" translate="yes" xml:space="preserve">
          <source>The call to the &lt;code&gt;enqueue_script()&lt;/code&gt; function is for adding script, setting the source and dependencies on other scripts, and additional data needed for the script.</source>
          <target state="translated">&lt;code&gt;enqueue_script()&lt;/code&gt; 함수 호출은 스크립트 추가, 다른 스크립트에 대한 소스 및 종속성 설정 및 스크립트에 필요한 추가 데이터를위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="60f2098fa6a6c9e65a6e087a4688e064b5e93b7b" translate="yes" xml:space="preserve">
          <source>The function requires PHP 5.4+. Example usage:</source>
          <target state="translated">이 기능에는 PHP 5.4+가 필요합니다. 사용법 예 :</target>
        </trans-unit>
        <trans-unit id="27c838ffc4b408d431a304030fcd64624193ea14" translate="yes" xml:space="preserve">
          <source>Then in &quot;your_php_file.php&quot;:</source>
          <target state="translated">그런 다음 &quot;your_php_file.php&quot;에서</target>
        </trans-unit>
        <trans-unit id="6e13348cd254065765f4ea515a928d4fa2d6ab9c" translate="yes" xml:space="preserve">
          <source>Then, the HTML is delivered to the client, after PHP is done with it, I'd like to emphasize that once the code leaves the server - PHP is done with it and can no longer access it.</source>
          <target state="translated">그런 다음 HTML이 클라이언트에 전달되고 PHP가 완료되면 코드가 서버를 떠나면 PHP가 완료되어 더 이상 액세스 할 수 없다는 것을 강조하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="8d3eb2239e46d313d3ae7db1193e3ffc72676396" translate="yes" xml:space="preserve">
          <source>Then, the HTML with JavaScript reaches the client, which can execute JavaScript on that HTML.</source>
          <target state="translated">그런 다음 JavaScript가 포함 된 HTML이 클라이언트에 도달하여 해당 HTML에서 JavaScript를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3d8cf715946572dd0d6d6871113da4d59dbb7a7" translate="yes" xml:space="preserve">
          <source>Then, you can &lt;a href=&quot;https://stackoverflow.com/questions/5639346/shortest-function-for-reading-a-cookie-in-javascript&quot;&gt;read it with JavaScript&lt;/a&gt; using &lt;code&gt;document.cookie&lt;/code&gt;:</source>
          <target state="translated">그런 다음 &lt;code&gt;document.cookie&lt;/code&gt; 를 사용하여 &lt;a href=&quot;https://stackoverflow.com/questions/5639346/shortest-function-for-reading-a-cookie-in-javascript&quot;&gt;JavaScript로 읽을&lt;/a&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c084fe03c55501aa730afdae5f7a028f58de4094" translate="yes" xml:space="preserve">
          <source>There are actually several approaches to do this. Some require more overhead than others, and some are considered better than others.</source>
          <target state="translated">실제로 몇 가지 방법이 있습니다. 어떤 것들은 다른 것보다 더 많은 오버 헤드를 요구하고, 어떤 것들은 다른 것보다 더 나은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="feac1ce6e2afa0a863a60c7486a1a4568bdd2fdf" translate="yes" xml:space="preserve">
          <source>This doesn't work because PHP will try to treat &lt;code&gt;myPlugin&lt;/code&gt; as a constant and when that fails it will try to treat it as the string &lt;code&gt;'myPlugin'&lt;/code&gt; which it will try to concatenate with the output of the PHP function &lt;code&gt;start()&lt;/code&gt; and since that is undefined it will produce a fatal error.</source>
          <target state="translated">PHP가 &lt;code&gt;myPlugin&lt;/code&gt; 을 상수로 취급하려고 시도하기 때문에 작동하지 않으며 실패하면 PHP 함수 &lt;code&gt;start()&lt;/code&gt; 의 출력과 연결하려고하는 &lt;code&gt;'myPlugin'&lt;/code&gt; 문자열로 처리하려고 시도합니다. 정의되지 않으면 치명적인 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fe7e574eda61e3fa9cc5e33b749a9961dbdca531" translate="yes" xml:space="preserve">
          <source>This example uses jQuery, but it can be adapted for another library or vanilla JavaScript.</source>
          <target state="translated">이 예제는 jQuery를 사용하지만 다른 라이브러리 또는 바닐라 JavaScript에 맞게 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4d485ec2600bea1a330df3b8934fc1e855097d6" translate="yes" xml:space="preserve">
          <source>This is probably the easiest to understand.</source>
          <target state="translated">아마도 가장 이해하기 쉬울 것입니다.</target>
        </trans-unit>
        <trans-unit id="bc99bf322dbbdd311a8d1cd8525a8764ec3b2525" translate="yes" xml:space="preserve">
          <source>This method is considered the best, because &lt;strong&gt;your server side and client side scripts are completely separate&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;서버 측 스크립트와 클라이언트 측 스크립트는 완전히 분리되어 있으므로이&lt;/strong&gt; 방법이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="817a2a8d86a0360d021ad43e19b78eba66eb8039" translate="yes" xml:space="preserve">
          <source>This method is less preferable to AJAX, but it still has its advantages. It's still &lt;em&gt;relatively&lt;/em&gt; separated between PHP and JavaScript in a sense that there is no PHP directly in the JavaScript.</source>
          <target state="translated">이 방법은 AJAX보다 덜 바람직하지만 여전히 장점이 있습니다. JavaScript에는 직접 PHP가 없다는 점에서 PHP와 JavaScript가 &lt;em&gt;상대적으로&lt;/em&gt; 분리되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="a764cec272addae3a75e62bf06bab87a936aec4f" translate="yes" xml:space="preserve">
          <source>This way, our JavaScript file asks for the data and shows it rather than asking for code or for layout. This is cleaner and starts to pay off as the application gets higher. It's also better separation of concerns and it allows testing the client side code without any server side technology involved which is another plus.</source>
          <target state="translated">이런 식으로 JavaScript 파일은 코드를 요구하거나 레이아웃을 요구하지 않고 데이터를 요청하고 보여줍니다. 이것은 더 깨끗하고 응용 프로그램이 높아질수록 돈을 지불하기 시작합니다. 또한 문제를보다 효과적으로 분리 할 수 ​​있으며 서버 측 기술없이 클라이언트 측 코드를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">이 시도:</target>
        </trans-unit>
        <trans-unit id="25f14026851d4d9317240563a4da69d9f7427ccc" translate="yes" xml:space="preserve">
          <source>Use AJAX to get the data you need from the server.</source>
          <target state="translated">AJAX를 사용하여 서버에서 필요한 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="2e8a57cc5c472f4ac3b071979a38e80db7e59e87" translate="yes" xml:space="preserve">
          <source>Website</source>
          <target state="translated">Website</target>
        </trans-unit>
        <trans-unit id="9d9ec8a09d1900696979b0e6e683945b24278c99" translate="yes" xml:space="preserve">
          <source>Websites are mainly page based, and the page load times needs to be as fast as possible (for example - Wikipedia). Web applications are more AJAX heavy and perform a lot of round trips to get the client fast information (for example - a stock dashboard).</source>
          <target state="translated">웹 사이트는 주로 페이지 기반이며 페이지로드 시간은 최대한 빨라야합니다 (예 : Wikipedia). 웹 애플리케이션은 AJAX를 많이 사용하고 클라이언트에게 빠른 정보 (예 : 재고 대시 보드)를 얻기 위해 많은 왕복을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b7c0e3aafda76649c0e02fe3119acea93028b54a" translate="yes" xml:space="preserve">
          <source>While this is most likely to work, since the PHP code is producing valid JavaScript with the expected arguments, if it fails, chances are it's because &lt;code&gt;myPlugin&lt;/code&gt; isn't ready yet. Check your order of execution.</source>
          <target state="translated">PHP 코드가 예상되는 인수로 유효한 JavaScript를 생성하므로 실패 할 경우 &lt;code&gt;myPlugin&lt;/code&gt; 이 아직 준비되지 않았기 때문일 수 있습니다. 실행 순서를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c164b4ac2cac911dd7348633f6c2d71dfd32289f" translate="yes" xml:space="preserve">
          <source>With AJAX, you need two pages, one is where PHP generates the output, and the second is where JavaScript gets that output:</source>
          <target state="translated">AJAX를 사용하면 두 페이지가 필요합니다. 하나는 PHP가 출력을 생성하는 곳이고 두 번째는 JavaScript가 해당 출력을 얻는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="413e55e9d66eac66f9a12aadd1c15b3bcaf80fc4" translate="yes" xml:space="preserve">
          <source>With this, the idea is to create some sort of element which will not be displayed to the user, but is visible to JavaScript.</source>
          <target state="translated">이를 통해 사용자에게는 표시되지 않지만 JavaScript에서는 볼 수있는 일종의 요소를 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="331aa2907869a83fe8dc9692376762ae5c7e8a68" translate="yes" xml:space="preserve">
          <source>You can read more about the dataset property here: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.dataset&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.dataset&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.dataset&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement.dataset&lt;/a&gt; 에서 dataset 속성에 대한 자세한 내용을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9e77e702dff57a309e0f4f15f5ad6ed2ecf16a6" translate="yes" xml:space="preserve">
          <source>You can use same method for arrays:</source>
          <target state="translated">배열에 동일한 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0c8d4a13ea45c5c3ec4ac14765af97fc2677c4d" translate="yes" xml:space="preserve">
          <source>You could even pass a variable back to the PHP file such as this example:</source>
          <target state="translated">이 예제와 같이 변수를 PHP 파일로 다시 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="779c6c7b3025e227f3a406338c878ce8b7b4ce08" translate="yes" xml:space="preserve">
          <source>You have two ways to tackle the issue</source>
          <target state="translated">이 문제를 해결하는 두 가지 방법이 있습니다</target>
        </trans-unit>
        <trans-unit id="b3ee624442b8df315cfaa849bed4a1f6347453a2" translate="yes" xml:space="preserve">
          <source>You want fast response times which have a &lt;em&gt;huge&lt;/em&gt; impact on conversion and load times. Making Ajax requests is slow for the initial uptime in this case and unneeded.</source>
          <target state="translated">변환 및로드 시간에 &lt;em&gt;큰&lt;/em&gt; 영향을주는 빠른 응답 시간을 원합니다. 이 경우 초기 가동 시간 동안 Ajax 요청이 느리고 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6da3a4d9e4b8d67c7deb98c5c4316435aa9d5b2a" translate="yes" xml:space="preserve">
          <source>Your page will print it using PHP, and you JavaScript will get value using DOM.</source>
          <target state="translated">페이지는 PHP를 사용하여 인쇄하고 JavaScript를 사용하면 DOM을 사용하여 가치를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5985c385fec59acb14a3dfb3afd274b5076d788c" translate="yes" xml:space="preserve">
          <source>and that will work. It's just assigning a JavaScript variable and then passing the value of an existing PHP variable. Since PHP writes the JavaScript lines here, it has the value of of the PHP variable and can pass it directly.</source>
          <target state="translated">작동합니다. JavaScript 변수를 할당 한 다음 기존 PHP 변수의 값을 전달하면됩니다. PHP는 여기에 JavaScript 행을 작성하므로 PHP 변수의 값을 가지며 직접 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1cc092559279170ed7e71a59d5995be436b0137f" translate="yes" xml:space="preserve">
          <source>get-data.php</source>
          <target state="translated">get-data.php</target>
        </trans-unit>
        <trans-unit id="bb6499b8e938f92a3695fff1afe57edea4b9efb7" translate="yes" xml:space="preserve">
          <source>index.php</source>
          <target state="translated">index.php</target>
        </trans-unit>
        <trans-unit id="0331c939dd50377997ef480e27946ba6c992ad55" translate="yes" xml:space="preserve">
          <source>index.php (or whatever the actual page is named like)</source>
          <target state="translated">index.php (또는 실제 페이지의 이름이 무엇이든)</target>
        </trans-unit>
        <trans-unit id="478730f4ba2a5cea495fccabc06cbed30cf87247" translate="yes" xml:space="preserve">
          <source>json_encode() requires:</source>
          <target state="translated">json_encode ()에는 다음이 필요합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
