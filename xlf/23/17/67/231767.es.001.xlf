<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/231767">
    <body>
      <group id="231767">
        <trans-unit id="3ab3cb492545479a81b590f95c9c450455ddcdb4" translate="yes" xml:space="preserve">
          <source>&quot;&lt;em&gt;next&lt;/em&gt;&quot; is a message sent to a closure, created by the &quot;&lt;em&gt;iter&lt;/em&gt;&quot; call.</source>
          <target state="translated">&quot; &lt;em&gt;siguiente&lt;/em&gt; &quot; es un mensaje enviado a un cierre, creado por la llamada &quot; &lt;em&gt;iter&lt;/em&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="1c0a4cfbcf63e8fb4ae3a319aeb3fe7f9e9106c2" translate="yes" xml:space="preserve">
          <source>&amp;hellip; repeat previous step, until&amp;hellip;</source>
          <target state="translated">... repita el paso anterior, hasta ...</target>
        </trans-unit>
        <trans-unit id="a6bd3f8f802396a1fb3f884b82392e785e8a7356" translate="yes" xml:space="preserve">
          <source>(Appendix critiques a couple of answers, including the top one, and discusses the use of &lt;code&gt;return&lt;/code&gt; in a generator.)</source>
          <target state="translated">(El ap&amp;eacute;ndice critica un par de respuestas, incluida la principal, y analiza el uso del &lt;code&gt;return&lt;/code&gt; en un generador).</target>
        </trans-unit>
        <trans-unit id="911bcad209bd54af6df884267feb81dcf90ade83" translate="yes" xml:space="preserve">
          <source>(My below answer only speaks from the perspective of using Python generator, not the &lt;a href=&quot;https://stackoverflow.com/questions/8389812/how-are-generators-and-coroutines-implemented-in-cpython&quot;&gt;underlying implementation of generator mechanism&lt;/a&gt;, which involves some tricks of stack and heap manipulation.)</source>
          <target state="translated">(Mi respuesta a continuaci&amp;oacute;n solo habla desde la perspectiva del uso del generador Python, no de la &lt;a href=&quot;https://stackoverflow.com/questions/8389812/how-are-generators-and-coroutines-implemented-in-cpython&quot;&gt;implementaci&amp;oacute;n subyacente del mecanismo generador&lt;/a&gt; , que implica algunos trucos de la manipulaci&amp;oacute;n de la pila y el mont&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="afb37c24b5b881de80de7247dc75c21ceafe07ec" translate="yes" xml:space="preserve">
          <source>(Now I want to talk about the rationale behind &lt;code&gt;generator&lt;/code&gt;, and the &lt;code&gt;iterator&lt;/code&gt; based on my own understanding. I hope this can help you grasp the &lt;strong&gt;&lt;em&gt;essential motivation&lt;/em&gt;&lt;/strong&gt; of iterator and generator. Such concept shows up in other languages as well such as C#.)</source>
          <target state="translated">(Ahora quiero hablar sobre la l&amp;oacute;gica detr&amp;aacute;s del &lt;code&gt;generator&lt;/code&gt; , y el &lt;code&gt;iterator&lt;/code&gt; basado en mi propia comprensi&amp;oacute;n. Espero que esto pueda ayudarlo a comprender la &lt;strong&gt;&lt;em&gt;motivaci&amp;oacute;n esencial&lt;/em&gt;&lt;/strong&gt; del iterador y el generador. Tal concepto aparece en otros lenguajes, como C #).</target>
        </trans-unit>
        <trans-unit id="adc9c0af7e633a543a37a61fedbb4daccf85e945" translate="yes" xml:space="preserve">
          <source>(and specifically a type of coroutine, but continuations represent the more general mechanism to understand what is going on).</source>
          <target state="translated">(y específicamente un tipo de corutina,pero las continuaciones representan el mecanismo más general para entender lo que está pasando).</target>
        </trans-unit>
        <trans-unit id="5375d7ac510abd4ae6e424a7dc969f2441dd692e" translate="yes" xml:space="preserve">
          <source>--  Nick Coghlan   |   ncoghlan at gmail.com   |   Brisbane, Australia</source>
          <target state="translated">ncoghlan at gmail.com</target>
        </trans-unit>
        <trans-unit id="62855b351e703dcbddfc4ef993d2891ccb386e20" translate="yes" xml:space="preserve">
          <source>... then remember that a generator is an &lt;em&gt;iterator&lt;/em&gt;; that is, it is one-time-use. If you want to reuse it, you should call &lt;code&gt;myRange(...)&lt;/code&gt; again. If you need to use the result twice, convert the result to a list and store it in a variable &lt;code&gt;x = list(myRange(5))&lt;/code&gt;. Those who absolutely need to clone a generator (for example, who are doing terrifyingly hackish metaprogramming) can use &lt;a href=&quot;https://docs.python.org/2/library/itertools.html#itertools.tee&quot;&gt;&lt;code&gt;itertools.tee&lt;/code&gt;&lt;/a&gt; if absolutely necessary, since the copyable iterator Python &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_Enhancement_Proposal#Development&quot;&gt;PEP&lt;/a&gt; standards proposal has been deferred.</source>
          <target state="translated">... luego recuerda que un generador es un &lt;em&gt;iterador&lt;/em&gt; ; es decir, es de un solo uso. Si desea reutilizarlo, debe llamar a &lt;code&gt;myRange(...)&lt;/code&gt; nuevamente. Si necesita usar el resultado dos veces, &lt;code&gt;x = list(myRange(5))&lt;/code&gt; en una lista y almac&amp;eacute;nelo en una variable x = lista (myRange (5)) . Aquellos que absolutamente necesitan clonar un generador (por ejemplo, que est&amp;aacute;n haciendo una metaprogramaci&amp;oacute;n terriblemente hack) pueden usar &lt;a href=&quot;https://docs.python.org/2/library/itertools.html#itertools.tee&quot;&gt; &lt;code&gt;itertools.tee&lt;/code&gt; &lt;/a&gt; si es absolutamente necesario, ya que la propuesta de est&amp;aacute;ndares Python &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_Enhancement_Proposal#Development&quot;&gt;PEP de&lt;/a&gt; iterador copiable ha sido diferida.</target>
        </trans-unit>
        <trans-unit id="164d0459345ae6f00bc812c7394f8917ff09c4bc" translate="yes" xml:space="preserve">
          <source>...provide the next data in the series.</source>
          <target state="translated">...proporcionar los siguientes datos de la serie.</target>
        </trans-unit>
        <trans-unit id="391e35abadb8cf99afd59f9fdc30216a58ce407f" translate="yes" xml:space="preserve">
          <source>...relinquish CPU execution until the iterator advances.</source>
          <target state="translated">...renunciar a la ejecución de la CPU hasta que el iterador avance.</target>
        </trans-unit>
        <trans-unit id="1827a89fdabc2940a265095fb52eea3cd75fc746" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This step corresponds to &lt;code&gt;def&lt;/code&gt;ining the generator function, i.e. the function containing a &lt;code&gt;yield&lt;/code&gt;.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Este paso corresponde a definir la funci&amp;oacute;n del generador, es decir, la funci&amp;oacute;n que contiene un &lt;code&gt;yield&lt;/code&gt; .&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="22db8f278d2cf3273c51bb64d7f5260d4584c88d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This step corresponds to calling &lt;code&gt;.next()&lt;/code&gt; on the generator object.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Este paso corresponde a llamar a &lt;code&gt;.next()&lt;/code&gt; en el objeto generador.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="721dffe48ec31d738fb17ec67ecedf85cc9ef1cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This step corresponds to calling the generator function which returns a generator object.&lt;/b&gt; Note that you don't tell me any numbers yet; you just grab your paper and pencil.</source>
          <target state="translated">&lt;b&gt;Este paso corresponde a llamar a la funci&amp;oacute;n de generador que devuelve un objeto generador.&lt;/b&gt; Tenga en cuenta que todav&amp;iacute;a no me dice ning&amp;uacute;n n&amp;uacute;mero; solo agarra tu papel y l&amp;aacute;piz.</target>
        </trans-unit>
        <trans-unit id="b9a955eec36cf4b6c9a4e64ce4bf09d433135e6a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This step corresponds to the generator object ending its job, and raising a &lt;code&gt;StopIteration&lt;/code&gt; exception&lt;/b&gt; The generator function does not need to raise the exception. It's raised automatically when the function ends or issues a &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;Este paso corresponde al objeto generador que finaliza su trabajo y &lt;code&gt;StopIteration&lt;/code&gt; una excepci&amp;oacute;n StopIteration.&lt;/b&gt; La funci&amp;oacute;n generadora no necesita generar la excepci&amp;oacute;n. Se genera autom&amp;aacute;ticamente cuando la funci&amp;oacute;n finaliza o emite un &lt;code&gt;return&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f08ebcf021089bec1572b041eac525a374a0d033" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list.extend&lt;/code&gt; calls an iterator until it's exhausted. In the case of the code sample you posted, it would be much clearer to just return a tuple and append that to the list.</source>
          <target state="translated">&lt;code&gt;list.extend&lt;/code&gt; llama a un iterador hasta que se agota. En el caso de la muestra de c&amp;oacute;digo que public&amp;oacute;, ser&amp;iacute;a mucho m&amp;aacute;s claro devolver una tupla y agregarla a la lista.</target>
        </trans-unit>
        <trans-unit id="5fea5fac7cbf1b26fe6763d6386ee47d486dbda6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list&lt;/code&gt; and &lt;code&gt;generator&lt;/code&gt; are twins</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; a y &lt;code&gt;generator&lt;/code&gt; son gemelos</target>
        </trans-unit>
        <trans-unit id="9902af71eb478ea1b302fe4da1da7cf183f39ef8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mylist&lt;/code&gt; is an &lt;em&gt;iterable&lt;/em&gt;. When you use a list comprehension, you create a list, and so an iterable:</source>
          <target state="translated">&lt;code&gt;mylist&lt;/code&gt; es un &lt;em&gt;iterable&lt;/em&gt; . Cuando usas una comprensi&amp;oacute;n de lista, creas una lista, y as&amp;iacute; un iterable:</target>
        </trans-unit>
        <trans-unit id="38f4e38094ba58e67ca37899086f5ea94d637159" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt; are twins</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; y &lt;code&gt;yield&lt;/code&gt; son gemelos</target>
        </trans-unit>
        <trans-unit id="7b01d9479576f8dc8ce3cf24ecbd8c38827200bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; forms an expression that allows data to be sent into the generator (see footnote 3)</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; forma una expresi&amp;oacute;n que permite enviar datos al generador (ver nota 3)</target>
        </trans-unit>
        <trans-unit id="393afd38f0f130b369c23e78f4c43a313a970250" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Syntactic_sugar&quot;&gt;sugary&lt;/a&gt; way to say</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; es una forma &lt;a href=&quot;https://en.wikipedia.org/wiki/Syntactic_sugar&quot;&gt;azucarada&lt;/a&gt; de decir</target>
        </trans-unit>
        <trans-unit id="f0678b46e10ca9ffeda185128b6349088f185f67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; is a keyword that is used like &lt;code&gt;return&lt;/code&gt;, except the function will return a generator.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; es una palabra clave que se utiliza como &lt;code&gt;return&lt;/code&gt; , excepto que la funci&amp;oacute;n devolver&amp;aacute; un generador.</target>
        </trans-unit>
        <trans-unit id="d4184f15f233616d72aa7e7ca25ec3a4265c4298" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; is just like &lt;code&gt;return&lt;/code&gt; - it returns whatever you tell it to (as a generator). The difference is that the next time you call the generator, execution starts from the last call to the &lt;code&gt;yield&lt;/code&gt; statement. Unlike return, &lt;strong&gt;the stack frame is not cleaned up when a yield occurs, however control is transferred back to the caller, so its state will resume the next time the function is called.&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; es como el &lt;code&gt;return&lt;/code&gt; : devuelve todo lo que le dices (como generador). La diferencia es que la pr&amp;oacute;xima vez que llame al generador, la ejecuci&amp;oacute;n comienza desde la &amp;uacute;ltima llamada hasta la declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; . A diferencia del retorno, &lt;strong&gt;el marco de la pila no se limpia cuando se produce un rendimiento, sin embargo, el control se transfiere nuevamente al llamante, por lo que su estado se reanudar&amp;aacute; la pr&amp;oacute;xima vez que se llame a la funci&amp;oacute;n.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f48e19febbab48404940d230045aa3e927e5e30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; is like a return element for a function. The difference is, that the &lt;code&gt;yield&lt;/code&gt; element turns a function into a generator. A generator behaves just like a function until something is 'yielded'. The generator stops until it is next called, and continues from exactly the same point as it started. You can get a sequence of all the 'yielded' values in one, by calling &lt;code&gt;list(generator())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; es como un elemento de retorno para una funci&amp;oacute;n. La diferencia es que el elemento de &lt;code&gt;yield&lt;/code&gt; convierte una funci&amp;oacute;n en un generador. Un generador se comporta como una funci&amp;oacute;n hasta que algo se &quot;produce&quot;. El generador se detiene hasta la pr&amp;oacute;xima llamada y contin&amp;uacute;a exactamente desde el mismo punto en que comenz&amp;oacute;. Puede obtener una secuencia de todos los valores 'cedidos' en uno, llamando a &lt;code&gt;list(generator())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce79dbc24d94277033832b51d011f10c74c51c55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; provides an 
easy way of &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#generator-types&quot;&gt;implementing the iterator protocol&lt;/a&gt;, defined by the following two methods: 
&lt;code&gt;__iter__&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; (Python 2) or &lt;code&gt;__next__&lt;/code&gt; (Python 3).  Both of those methods
make an object an iterator that you could type-check with the &lt;code&gt;Iterator&lt;/code&gt; Abstract Base 
Class from the &lt;code&gt;collections&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; proporciona una manera f&amp;aacute;cil de &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#generator-types&quot;&gt;implementar el protocolo iterador&lt;/a&gt; , definido por los dos m&amp;eacute;todos siguientes: &lt;code&gt;__iter__&lt;/code&gt; y &lt;code&gt;next&lt;/code&gt; (Python 2) o &lt;code&gt;__next__&lt;/code&gt; (Python 3). Ambos m&amp;eacute;todos hacen que un objeto sea un iterador que puede verificar con la clase base abstracta &lt;code&gt;Iterator&lt;/code&gt; del m&amp;oacute;dulo de &lt;code&gt;collections&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72b1d67b42a7bcd2f82b7a63ae89928f2425a004" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caller:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Caller:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cff026d6f9aa06262d0a44145fc01e31f8076361" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Generator:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Generator:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c38bed66dadc73d83b4620730a13bb214521445c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/strong&gt; is only legal inside of a function definition, and &lt;strong&gt;the inclusion of &lt;code&gt;yield&lt;/code&gt; in a function definition makes it return a generator.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/strong&gt; solo es legal dentro de una definici&amp;oacute;n de funci&amp;oacute;n, y &lt;strong&gt;la inclusi&amp;oacute;n del &lt;code&gt;yield&lt;/code&gt; en una definici&amp;oacute;n de funci&amp;oacute;n hace que devuelva un generador.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="229ca9910a03e900f64ebcb32c51dbc86e43eacf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Execution Control Transfer gotcha&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Control de Ejecuci&amp;oacute;n Transferencia gotcha&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="653263d633592b8035eb87354035a2aedee82289" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As a Python generator:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Como generador de Python:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="daa7df2500b97f81040621f58d60cce72d811842" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Funciones de llamada&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b934a0ad7383658a04e1dbb7356e9f956f6fa54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For Python 3, use&lt;code&gt;print(corner_street_atm.__next__())&lt;/code&gt; or &lt;code&gt;print(next(corner_street_atm))&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Para Python 3, use &lt;code&gt;print(corner_street_atm.__next__())&lt;/code&gt; o &lt;code&gt;print(next(corner_street_atm))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="867dc1e5830b6274ed3a21ce05e3f7d42fcc32aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the result from the code:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Este es el resultado del c&amp;oacute;digo:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57c3f7ae705716465207e976c5f8b4654e8b8e23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using lexical closures instead of generators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usar cierres l&amp;eacute;xicos en lugar de generadores&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb818cdf73632877fa6680be81278640e6f5f261" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using object closures instead of generators&lt;/strong&gt; (because &lt;a href=&quot;http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent&quot;&gt;ClosuresAndObjectsAreEquivalent&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;Uso de cierres de objetos en lugar de generadores&lt;/strong&gt; (porque &lt;a href=&quot;http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent&quot;&gt;ClosuresAndObjectsAreEquivalent&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6cd1618b874d384cc3e5eb172422b1adea86fbd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What does the &lt;code&gt;yield&lt;/code&gt; keyword do in Python?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Qu&amp;eacute; hace la palabra clave de &lt;code&gt;yield&lt;/code&gt; en Python?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf577700a9ff9e3f004ffc00209080b9c3eba6b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yield is an object&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;El rendimiento es un objeto&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5bb3a856024a662b96de26aecfd9bd37f19227ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;return&lt;/strong&gt; (in function)</source>
          <target state="translated">&lt;strong&gt;volver&lt;/strong&gt; (en funci&amp;oacute;n)</target>
        </trans-unit>
        <trans-unit id="9a40ecb26c7c8562eed416b67a93ab45567e9bd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;yield&lt;/strong&gt; &amp;mdash; give way or relinquish (as in political power)</source>
          <target state="translated">&lt;strong&gt;ceder&lt;/strong&gt; - ceder o ceder (como en el poder pol&amp;iacute;tico)</target>
        </trans-unit>
        <trans-unit id="bccdd99e0ed80b5b71ebb537cdf27634a356412a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;yield&lt;/strong&gt; &amp;mdash; produce or provide (as in agriculture)</source>
          <target state="translated">&lt;strong&gt;rendimiento&lt;/strong&gt; - producir o proporcionar (como en la agricultura)</target>
        </trans-unit>
        <trans-unit id="2c3677668ae12b29cf20934e6d983bdb8043dd08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;yield&lt;/strong&gt; (in function)</source>
          <target state="translated">&lt;strong&gt;rendimiento&lt;/strong&gt; (en funci&amp;oacute;n)</target>
        </trans-unit>
        <trans-unit id="26de2c12b563c2f9a7febaaeb02a1b7ff942e453" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
1. This piece of code was written by Jochen Schulz (jrschulz), who made a great Python library for metric spaces. This is the link to the complete source: &lt;a href=&quot;http://well-adjusted.de/~jrschulz/mspace/&quot;&gt;Module mspace&lt;/a&gt;.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;1. Este c&amp;oacute;digo fue escrito por Jochen Schulz (jrschulz), quien hizo una gran biblioteca de Python para espacios m&amp;eacute;tricos.&lt;/sub&gt; &lt;sub&gt;Este es el enlace a la fuente completa: &lt;a href=&quot;http://well-adjusted.de/~jrschulz/mspace/&quot;&gt;M&amp;oacute;dulo mspace&lt;/a&gt; .&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="f79576b025501c7eb386682a764849f89c207838" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;code&gt;yield&lt;/code&gt; was originally introduced as a statement, meaning that it 
could only appear at the beginning of a line in a code block. 
Now &lt;code&gt;yield&lt;/code&gt; creates a yield expression. 
&lt;a href=&quot;https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt&quot;&gt;https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt&lt;/a&gt; 
This change was &lt;a href=&quot;https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators&quot;&gt;proposed&lt;/a&gt; to allow a user to send data into the generator just as
one might receive it. To send data, one must be able to assign it to something, and
for that, a statement just won't work.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt; &lt;code&gt;yield&lt;/code&gt; se introdujo originalmente como una declaraci&amp;oacute;n, lo que significa que solo pod&amp;iacute;a aparecer al comienzo de una l&amp;iacute;nea en un bloque de c&amp;oacute;digo.&lt;/sub&gt; &lt;sub&gt;Ahora el &lt;code&gt;yield&lt;/code&gt; crea una expresi&amp;oacute;n de rendimiento.&lt;/sub&gt; &lt;sub&gt;&lt;a href=&quot;https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt&quot;&gt;https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt&lt;/a&gt; Este cambio se &lt;a href=&quot;https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators&quot;&gt;propuso&lt;/a&gt; para permitir que un usuario env&amp;iacute;e datos al generador tal como uno podr&amp;iacute;a recibirlos.&lt;/sub&gt; &lt;sub&gt;Para enviar datos, uno debe poder asignarlos a algo, y para eso, una declaraci&amp;oacute;n simplemente no funcionar&amp;aacute;.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="3ecaefffce9acc4aec2e8eb1485d8144441fb64a" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt; This means, for example, that &lt;code&gt;xrange&lt;/code&gt; objects (&lt;code&gt;range&lt;/code&gt; in Python 3) aren't &lt;code&gt;Iterator&lt;/code&gt;s, even though they are iterable, because they can be reused. Like lists, their &lt;code&gt;__iter__&lt;/code&gt; methods return iterator objects.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;Esto significa, por ejemplo, que los objetos &lt;code&gt;xrange&lt;/code&gt; ( &lt;code&gt;range&lt;/code&gt; en Python 3) no son &lt;code&gt;Iterator&lt;/code&gt; , aunque son iterables, porque pueden reutilizarse.&lt;/sub&gt; &lt;sub&gt;Al igual que las listas, sus m&amp;eacute;todos &lt;code&gt;__iter__&lt;/code&gt; devuelven objetos iteradores.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="6d4047120e95ed7d93b8ea0918529c67a9bc43e4" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;The languages CLU, Sather, and Icon were referenced in the proposal
to introduce the concept of generators to Python. The general idea is
that a function can maintain internal state and yield intermediate 
data points on demand by the user. This promised to be &lt;a href=&quot;https://www.python.org/dev/peps/pep-0255/&quot;&gt;superior in performance 
to other approaches, including Python threading&lt;/a&gt;, which isn't even available on some systems.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;Se hizo referencia a los lenguajes CLU, Sather e Icon en la propuesta para introducir el concepto de generadores en Python.&lt;/sub&gt; &lt;sub&gt;La idea general es que una funci&amp;oacute;n puede mantener el estado interno y generar puntos de datos intermedios a pedido del usuario.&lt;/sub&gt; &lt;sub&gt;Esto prometi&amp;oacute; ser &lt;a href=&quot;https://www.python.org/dev/peps/pep-0255/&quot;&gt;superior en rendimiento a otros enfoques, incluido el subprocesamiento de Python&lt;/a&gt; , que ni siquiera est&amp;aacute; disponible en algunos sistemas.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="45728cd7c825dedfa1bf52fd66ed620c707bd5e8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;return&lt;/code&gt; in a function will return a single value.</source>
          <target state="translated">Un &lt;code&gt;return&lt;/code&gt; en una funci&amp;oacute;n devolver&amp;aacute; un valor &amp;uacute;nico.</target>
        </trans-unit>
        <trans-unit id="f4dca203541c03ec91c7704f277f8cc1b514af3a" translate="yes" xml:space="preserve">
          <source>A feature of an &lt;code&gt;Iterator&lt;/code&gt;&lt;a href=&quot;https://docs.python.org/2/glossary.html#term-iterator&quot;&gt;is that once exhausted&lt;/a&gt;, you can't reuse or reset it:</source>
          <target state="translated">Una caracter&amp;iacute;stica de un &lt;code&gt;Iterator&lt;/code&gt; &lt;a href=&quot;https://docs.python.org/2/glossary.html#term-iterator&quot;&gt;es que una vez agotado&lt;/a&gt; , no puede reutilizarlo o restablecerlo:</target>
        </trans-unit>
        <trans-unit id="bc88bfb2c2db80515dc1ecb96783382a954c2f20" translate="yes" xml:space="preserve">
          <source>A function with &lt;a href=&quot;https://docs.python.org/reference/expressions.html#yieldexpr&quot;&gt;&lt;strong&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, when called, &lt;strong&gt;returns a &lt;a href=&quot;https://docs.python.org/2/tutorial/classes.html#generators&quot;&gt;Generator&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">Una funci&amp;oacute;n con &lt;a href=&quot;https://docs.python.org/reference/expressions.html#yieldexpr&quot;&gt;&lt;strong&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; , cuando se llama, &lt;strong&gt;devuelve un &lt;a href=&quot;https://docs.python.org/2/tutorial/classes.html#generators&quot;&gt;generador&lt;/a&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="897499bfe1868bc9f693489cbbf23e92d00c56ab" translate="yes" xml:space="preserve">
          <source>A generator can also be &lt;strong&gt;sent information&lt;/strong&gt;, making it conceptually a &lt;strong&gt;coroutine&lt;/strong&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n se puede &lt;strong&gt;enviar informaci&amp;oacute;n a&lt;/strong&gt; un generador, haci&amp;eacute;ndolo conceptualmente una &lt;strong&gt;rutina&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9738265b02043df1ee0a4dc75d4ad9e6a30481dd" translate="yes" xml:space="preserve">
          <source>A generator differs from a function in the sense that it is lazy. It accomplishes this by maintaining it's local state and allowing you to resume whenever you need to.</source>
          <target state="translated">Un generador difiere de una función en el sentido de que es perezoso.Lo logra manteniendo su estado local y permitiéndole reanudar cuando lo necesite.</target>
        </trans-unit>
        <trans-unit id="1f888f43eb25e3718593933b4335447760fb8473" translate="yes" xml:space="preserve">
          <source>A generator is iterable. What is an &lt;em&gt;iterable&lt;/em&gt;? It's anything like a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;range&lt;/code&gt; or dict-view, with a &lt;em&gt;built-in protocol for visiting each element in a certain order&lt;/em&gt;.</source>
          <target state="translated">Un generador es iterable. &amp;iquest;Qu&amp;eacute; es un &lt;em&gt;iterable&lt;/em&gt; ? Es algo as&amp;iacute; como una &lt;code&gt;list&lt;/code&gt; a o &lt;code&gt;set&lt;/code&gt; o &lt;code&gt;range&lt;/code&gt; o vista de dictado, con un &lt;em&gt;protocolo incorporado para visitar cada elemento en un orden determinado&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="40806863ce6fa16185eff4ee6a143d5d9c549f75" translate="yes" xml:space="preserve">
          <source>A real life example would be something like reading a file line by line or if you just want to make a generator.</source>
          <target state="translated">Un ejemplo de la vida real sería algo como leer un archivo línea por línea o si sólo quieres hacer un generador.</target>
        </trans-unit>
        <trans-unit id="44cb9a9a8788c105610a9684a6bc2a2b8a67003f" translate="yes" xml:space="preserve">
          <source>A syntax is proposed for a generator to delegate part of its operations to another generator. This allows a section of code containing 'yield' to be factored out and placed in another generator. Additionally, the subgenerator is allowed to return with a value, and the value is made available to the delegating generator.</source>
          <target state="translated">Se propone una sintaxis para que un generador delegue parte de sus operaciones a otro generador.Esto permite que una sección del código que contiene &quot;rendimiento&quot; sea factorizada y colocada en otro generador.Además,se permite que el subgenerador regrese con un valor,y el valor se pone a disposición del generador que lo delega.</target>
        </trans-unit>
        <trans-unit id="74447fa535e8bb207f72d52e27e00da4cbc34ba7" translate="yes" xml:space="preserve">
          <source>Again, this is a pretty contrived example, you probably would use itertools if you really wanted to count to 50 billion. :)</source>
          <target state="translated">De nuevo,este es un ejemplo bastante artificioso,probablemente usarías las herramientas de iteración si realmente quisieras contar hasta 50 mil millones.:)</target>
        </trans-unit>
        <trans-unit id="bd27eb03f93b277d1b217b449e15ffaa08956520" translate="yes" xml:space="preserve">
          <source>All great answers, however a bit difficult for newbies.</source>
          <target state="translated">Todas las grandes respuestas,aunque un poco difíciles para los novatos.</target>
        </trans-unit>
        <trans-unit id="2fab016fc71934fbba31dba4e6e38ca3818acafb" translate="yes" xml:space="preserve">
          <source>Also, note that &lt;code&gt;yield&lt;/code&gt; can be used in coroutines as the dual of their use in generator functions.  Although it isn't the same use as your code snippet, &lt;code&gt;(yield)&lt;/code&gt; can be used as an expression in a function.  When a caller sends a value to the method using the &lt;code&gt;send()&lt;/code&gt; method, then the coroutine will execute until the next &lt;code&gt;(yield)&lt;/code&gt; statement is encountered.</source>
          <target state="translated">Adem&amp;aacute;s, tenga en cuenta que el &lt;code&gt;yield&lt;/code&gt; se puede utilizar en las rutinas como el doble de su uso en las funciones del generador. Aunque no es el mismo uso que el fragmento de c&amp;oacute;digo, &lt;code&gt;(yield)&lt;/code&gt; se puede usar como una expresi&amp;oacute;n en una funci&amp;oacute;n. Cuando una persona que llama env&amp;iacute;a un valor al m&amp;eacute;todo usando el m&amp;eacute;todo &lt;code&gt;send()&lt;/code&gt; , entonces la rutina se ejecutar&amp;aacute; hasta que se encuentre la siguiente declaraci&amp;oacute;n &lt;code&gt;(yield)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c56156759c86e1fd4089d77e11250c9e375078a7" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;expression_list&lt;/code&gt; is basically any number of expressions separated by commas - essentially, in Python 2, you can stop the generator with &lt;code&gt;return&lt;/code&gt;, but you can't return a value.</source>
          <target state="translated">Una &lt;code&gt;expression_list&lt;/code&gt; es b&amp;aacute;sicamente cualquier n&amp;uacute;mero de expresiones separadas por comas; esencialmente, en Python 2, puede detener el generador con &lt;code&gt;return&lt;/code&gt; , pero no puede devolver un valor.</target>
        </trans-unit>
        <trans-unit id="81d45d4bfb0fa5b224eac8c43cc82a19dfb43fe4" translate="yes" xml:space="preserve">
          <source>An easy example to understand what it is: &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">Un ejemplo sencillo para entender qu&amp;eacute; es: &lt;code&gt;yield&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cdd85aeb410d39ea117f7d9f6130e19b2898ccdb" translate="yes" xml:space="preserve">
          <source>An example? Let's see the possible orders of arrival for a four-horse race:</source>
          <target state="translated">¿Un ejemplo? Veamos las posibles órdenes de llegada para una carrera de cuatro caballos:</target>
        </trans-unit>
        <trans-unit id="29b15a5d175843895768eba634b31bff250c477b" translate="yes" xml:space="preserve">
          <source>An iterable is the last part of a list comprehension, and all generators are iterable, so they're often used like so:</source>
          <target state="translated">Un iterable es la última parte de la comprensión de una lista,y todos los generadores son iterables,por lo que a menudo se usan así:</target>
        </trans-unit>
        <trans-unit id="81d8a56bb9735baf48091b3e5b5e287b1b2e4127" translate="yes" xml:space="preserve">
          <source>An iterator is just a fancy sounding term for an object that has a &lt;code&gt;next()&lt;/code&gt; method.  So a yield-ed function ends up being something like this:</source>
          <target state="translated">Un iterador es solo un t&amp;eacute;rmino elegante para un objeto que tiene un m&amp;eacute;todo &lt;code&gt;next()&lt;/code&gt; . Entonces, una funci&amp;oacute;n de rendimiento termina siendo algo como esto:</target>
        </trans-unit>
        <trans-unit id="d914dca0e9f94be2a010606114630680fc2fbce8" translate="yes" xml:space="preserve">
          <source>And if necessary, we can type-check like this:</source>
          <target state="translated">Y si es necesario,podemos hacer una comprobación a máquina como esta:</target>
        </trans-unit>
        <trans-unit id="8b152c57dd4e6896c2e2d3a2c969268781a04e11" translate="yes" xml:space="preserve">
          <source>And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples, and generators! This is called duck typing and is one of the reasons why Python is so cool. But this is another story, for another question...</source>
          <target state="translated">Y funciona porque a Python no le importa si el argumento de un método es una lista o no.¡Python espera iterables así que trabajará con cadenas,listas,tuplas y generadores! Esto se llama &quot;duck typing&quot; y es una de las razones por las que Python es tan genial.Pero esta es otra historia,para otra pregunta...</target>
        </trans-unit>
        <trans-unit id="97fbec56b74d699d8da84f4466277b6823b52c60" translate="yes" xml:space="preserve">
          <source>And now we can delegate functionality to a sub-generator and it can be used
by a generator just as above:</source>
          <target state="translated">Y ahora podemos delegar la funcionalidad a un subgenerador y puede ser utilizado por un generador como el anterior:</target>
        </trans-unit>
        <trans-unit id="bdec22c07b1756ea41e55aa6af803ad40c179f4d" translate="yes" xml:space="preserve">
          <source>And now we can send data into the generator. (&lt;a href=&quot;https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators&quot;&gt;Sending &lt;code&gt;None&lt;/code&gt; is 
the same as calling &lt;code&gt;next&lt;/code&gt;&lt;/a&gt;.) :</source>
          <target state="translated">Y ahora podemos enviar datos al generador. ( &lt;a href=&quot;https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators&quot;&gt;Enviar &lt;code&gt;None&lt;/code&gt; es lo mismo que llamar a &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="df8f95772f413efb0c2dbf265ff4862fae1c7bc4" translate="yes" xml:space="preserve">
          <source>And this is the caller:</source>
          <target state="translated">Y esta es la persona que llama:</target>
        </trans-unit>
        <trans-unit id="3b57182086d6c04e166187f3787e8d917fd59442" translate="yes" xml:space="preserve">
          <source>Answer Outline/Summary</source>
          <target state="translated">Resumen de respuestas</target>
        </trans-unit>
        <trans-unit id="c3c07bbc3573c4c760856487909b704db42f46ae" translate="yes" xml:space="preserve">
          <source>Appendix:</source>
          <target state="translated">Appendix:</target>
        </trans-unit>
        <trans-unit id="f7153a3ed77229b8ef3f57eb201522d76e468e8a" translate="yes" xml:space="preserve">
          <source>As I understand, when we want to process a bunch of data, we usually first store the data somewhere and then process it one by one. But this &lt;em&gt;naive&lt;/em&gt; approach is problematic. If the data volume is huge, it's expensive to store them as a whole beforehand. &lt;strong&gt;So instead of storing the &lt;code&gt;data&lt;/code&gt; itself directly, why not store some kind of &lt;code&gt;metadata&lt;/code&gt; indirectly, i.e. &lt;code&gt;the logic how the data is computed&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">Seg&amp;uacute;n tengo entendido, cuando queremos procesar un mont&amp;oacute;n de datos, generalmente primero almacenamos los datos en alg&amp;uacute;n lugar y luego los procesamos uno por uno. Pero este enfoque &lt;em&gt;ingenuo&lt;/em&gt; es problem&amp;aacute;tico. Si el volumen de datos es enorme, es costoso almacenarlos como un todo de antemano. &lt;strong&gt;Entonces, en lugar de almacenar los &lt;code&gt;data&lt;/code&gt; directamente, &amp;iquest;por qu&amp;eacute; no almacenar alg&amp;uacute;n tipo de &lt;code&gt;metadata&lt;/code&gt; indirectamente, es decir, &lt;code&gt;the logic how the data is computed&lt;/code&gt; &lt;/strong&gt; ?</target>
        </trans-unit>
        <trans-unit id="71b8419f2c05a320eab84f0ff210eed5a7aa3f59" translate="yes" xml:space="preserve">
          <source>As an analogy, &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt; are twins. &lt;code&gt;return&lt;/code&gt; means 'return and stop' whereas 'yield` means 'return, but continue'</source>
          <target state="translated">Como analog&amp;iacute;a, el &lt;code&gt;return&lt;/code&gt; y el &lt;code&gt;yield&lt;/code&gt; son gemelos. &lt;code&gt;return&lt;/code&gt; significa 'return and stop' mientras que 'yield' significa 'return, but continue'</target>
        </trans-unit>
        <trans-unit id="9399c22507893ea92efd2d3d7bd85d4924662fa9" translate="yes" xml:space="preserve">
          <source>As you can see both functions do the same thing. The only difference is &lt;code&gt;return_dates()&lt;/code&gt; gives a list and &lt;code&gt;yield_dates()&lt;/code&gt; gives a generator.</source>
          <target state="translated">Como puede ver, ambas funciones hacen lo mismo. La &amp;uacute;nica diferencia es &lt;code&gt;return_dates()&lt;/code&gt; da una lista y &lt;code&gt;yield_dates()&lt;/code&gt; da un generador.</target>
        </trans-unit>
        <trans-unit id="135740deb1c52c950dd9825f622468250cfec310" translate="yes" xml:space="preserve">
          <source>As you can see, in the first case &lt;code&gt;foo&lt;/code&gt; holds the entire list in memory at once. It's not a big deal for a list with 5 elements, but what if you want a list of 5 million? Not only is this a huge memory eater, it also costs a lot of time to build at the time that the function is called.</source>
          <target state="translated">Como puede ver, en el primer caso, &lt;code&gt;foo&lt;/code&gt; guarda la lista completa en la memoria a la vez. No es un gran problema para una lista con 5 elementos, pero &amp;iquest;qu&amp;eacute; pasa si quieres una lista de 5 millones? No solo es un gran devorador de memoria, sino que tambi&amp;eacute;n cuesta mucho tiempo construirlo en el momento en que se llama a la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5bbe3ddff5d188e8a248228bc2152ed147d1b379" translate="yes" xml:space="preserve">
          <source>Behind the scenes</source>
          <target state="translated">Entre bastidores</target>
        </trans-unit>
        <trans-unit id="5b6a80379109f3fc6042e0737cbf5d072100c51f" translate="yes" xml:space="preserve">
          <source>Both functions do the same thing, but &lt;code&gt;yield&lt;/code&gt; uses three lines instead of five and has one less variable to worry about.</source>
          <target state="translated">Ambas funciones hacen lo mismo, pero el &lt;code&gt;yield&lt;/code&gt; usa tres l&amp;iacute;neas en lugar de cinco y tiene una variable menos de la que preocuparse.</target>
        </trans-unit>
        <trans-unit id="cca4c988c7e1babe71c97f7849efb9f46f5d36d6" translate="yes" xml:space="preserve">
          <source>Bottom line, until the developers of CPython tell us otherwise: &lt;strong&gt;Don't put &lt;code&gt;yield&lt;/code&gt; in a generator expression or comprehension.&lt;/strong&gt;</source>
          <target state="translated">En &lt;strong&gt;pocas palabras&lt;/strong&gt; , hasta que los desarrolladores de CPython nos digan lo contrario: &lt;strong&gt;no ponga el &lt;code&gt;yield&lt;/code&gt; en una expresi&amp;oacute;n o comprensi&amp;oacute;n generadora.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d08cdf468566d1e5880decf4e3f20a483dff611f" translate="yes" xml:space="preserve">
          <source>Brilliant choice of the word &lt;code&gt;yield&lt;/code&gt; because &lt;a href=&quot;https://www.google.com/search?q=yield+meaning&quot;&gt;both meanings&lt;/a&gt; apply:</source>
          <target state="translated">Elecci&amp;oacute;n brillante de la palabra &lt;code&gt;yield&lt;/code&gt; porque se aplican &lt;a href=&quot;https://www.google.com/search?q=yield+meaning&quot;&gt;ambos significados&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="18cf04f82308b4c79617d9344cd8cccedc5948df" translate="yes" xml:space="preserve">
          <source>Built-in lists, dictionaries, tuples, sets, files.</source>
          <target state="translated">Listas incorporadas,diccionarios,tuplas,conjuntos,archivos.</target>
        </trans-unit>
        <trans-unit id="ace5b94af148161c793a05983917f7f7008ae80a" translate="yes" xml:space="preserve">
          <source>But in your code, it gets a generator, which is good because:</source>
          <target state="translated">Pero en tu código,tiene un generador,lo cual es bueno porque:</target>
        </trans-unit>
        <trans-unit id="e41053f2e7b7818b717e108be50e7b8bc56bf7fd" translate="yes" xml:space="preserve">
          <source>But this is inefficient because</source>
          <target state="translated">Pero esto es ineficiente porque</target>
        </trans-unit>
        <trans-unit id="112200cd9ac4f291717eeda13db581f83c118af7" translate="yes" xml:space="preserve">
          <source>But you could easily implement (and conceptualize) generators as a simple, specific case of continuation passing style:</source>
          <target state="translated">Pero podría implementar (y conceptualizar)fácilmente los generadores como un caso simple y específico de estilo de paso de continuación:</target>
        </trans-unit>
        <trans-unit id="224ba6c7dc6ef4515b36b8503f362933f7f951ca" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;iter(mylist)&lt;/code&gt; -&amp;gt; this returns an object with a &lt;code&gt;next()&lt;/code&gt; method (or &lt;code&gt;__next__()&lt;/code&gt; in Python 3).</source>
          <target state="translated">Llamar &lt;code&gt;iter(mylist)&lt;/code&gt; -&amp;gt; esto devuelve un objeto con un m&amp;eacute;todo &lt;code&gt;next()&lt;/code&gt; (o &lt;code&gt;__next__()&lt;/code&gt; en Python 3).</target>
        </trans-unit>
        <trans-unit id="4fdabc45b3bad82e2c9c7d5aa68f04b364ec25ac" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;yielderFunction()&lt;/code&gt; doesn't run its code, but makes a generator out of the code. (Maybe it's a good idea to name such things with the &lt;code&gt;yielder&lt;/code&gt; prefix for readability.)</source>
          <target state="translated">Llamar a &lt;code&gt;yielderFunction()&lt;/code&gt; no ejecuta su c&amp;oacute;digo, pero crea un generador del c&amp;oacute;digo. (Tal vez sea una buena idea nombrar tales cosas con el prefijo de &lt;code&gt;yielder&lt;/code&gt; para facilitar la lectura).</target>
        </trans-unit>
        <trans-unit id="d4e40bacc080c668ae12d6659592822c4592d6dc" translate="yes" xml:space="preserve">
          <source>Cheers, Nick.</source>
          <target state="translated">Salud,Nick.</target>
        </trans-unit>
        <trans-unit id="fa1fe25132badc6a4700de54339362efef6cccf3" translate="yes" xml:space="preserve">
          <source>Compare function to the original definition.</source>
          <target state="translated">Compare la función con la definición original.</target>
        </trans-unit>
        <trans-unit id="422466cb355bfaa6b435c10bfd2011e9037906cc" translate="yes" xml:space="preserve">
          <source>Compare the following examples:</source>
          <target state="translated">Compare los siguientes ejemplos:</target>
        </trans-unit>
        <trans-unit id="23177d88df5aa8c7d73ae1fbc8fbc37e2afda7be" translate="yes" xml:space="preserve">
          <source>Comparing example to &quot;just returning a list&quot;</source>
          <target state="translated">Comparando el ejemplo con &quot;sólo devolver una lista&quot;</target>
        </trans-unit>
        <trans-unit id="13ee7709c64ae8875430c0fce8f630d0fd20adab" translate="yes" xml:space="preserve">
          <source>Comparing to &lt;code&gt;return&lt;/code&gt; which runs once and stops, &lt;code&gt;yield&lt;/code&gt; runs times you planed.
You can interpret &lt;code&gt;return&lt;/code&gt; as &lt;code&gt;return one of them&lt;/code&gt;, and &lt;code&gt;yield&lt;/code&gt; as &lt;code&gt;return all of them&lt;/code&gt;. This is called &lt;code&gt;iterable&lt;/code&gt;.</source>
          <target state="translated">En comparaci&amp;oacute;n con el &lt;code&gt;return&lt;/code&gt; que se ejecuta una vez y se detiene, el &lt;code&gt;yield&lt;/code&gt; ejecuta veces planificadas. Puede interpretar &lt;code&gt;return&lt;/code&gt; como &lt;code&gt;return one of them&lt;/code&gt; , y &lt;code&gt;yield&lt;/code&gt; como &lt;code&gt;return all of them&lt;/code&gt; . Esto se llama &lt;code&gt;iterable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="d93505eddd729749377d3ebb203709c807a5b6b0" translate="yes" xml:space="preserve">
          <source>Continuations in programming languages theory are a much more fundamental kind of computation, but they are not often used, because they are extremely hard to reason about and also very difficult to implement. But the idea of what a continuation is, is straightforward: it is the state of a computation that has not yet finished. In this state, the current values of variables, the operations that have yet to be performed, and so on, are saved. Then at some point later in the program the continuation can be invoked, such that the program's variables are reset to that state and the operations that were saved are carried out.</source>
          <target state="translated">Las continuidades en la teoría de los lenguajes de programación son un tipo de computación mucho más fundamental,pero no se utilizan a menudo,porque son extremadamente difíciles de razonar y también muy difíciles de implementar.Pero la idea de lo que es una continuación es sencilla:es el estado de un cálculo que aún no ha terminado.En este estado se guardan los valores actuales de las variables,las operaciones que aún no se han realizado,etc.Luego,en algún momento posterior del programa se puede invocar la continuación,de manera que las variables del programa se vuelven a poner en ese estado y se realizan las operaciones que se guardaron.</target>
        </trans-unit>
        <trans-unit id="b72e044549c84a332ce620bd9e0a6adabcb6a3af" translate="yes" xml:space="preserve">
          <source>Continuations, in this more general form, can be implemented in two ways. In the &lt;code&gt;call/cc&lt;/code&gt; way, the program's stack is literally saved and then when the continuation is invoked, the stack is restored.</source>
          <target state="translated">Las continuaciones, en esta forma m&amp;aacute;s general, se pueden implementar de dos maneras. En la &lt;code&gt;call/cc&lt;/code&gt; , la pila del programa se guarda literalmente y luego, cuando se invoca la continuaci&amp;oacute;n, la pila se restaura.</target>
        </trans-unit>
        <trans-unit id="2c47bc7e9e1cccd861bf2f12386c3a01928597e8" translate="yes" xml:space="preserve">
          <source>Controlling a generator exhaustion</source>
          <target state="translated">Controlar el agotamiento de un generador</target>
        </trans-unit>
        <trans-unit id="fe65bca192a86197c66d7cf330e1537caa61c387" translate="yes" xml:space="preserve">
          <source>Cooperative Delegation to Sub-Coroutine with &lt;code&gt;yield from&lt;/code&gt;</source>
          <target state="translated">Delegaci&amp;oacute;n Cooperativa a Sub-Corutina con &lt;code&gt;yield from&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33163af7bd841f674f77c35298225e94a5016009" translate="yes" xml:space="preserve">
          <source>Coroutines:</source>
          <target state="translated">Coroutines:</target>
        </trans-unit>
        <trans-unit id="abfb94ac57644f17a8adf8955a59558bd94c3b33" translate="yes" xml:space="preserve">
          <source>Critique of answer suggesting &lt;code&gt;yield&lt;/code&gt; in a generator expression or comprehension.</source>
          <target state="translated">Cr&amp;iacute;tica de la respuesta que sugiere &lt;code&gt;yield&lt;/code&gt; en una expresi&amp;oacute;n o comprensi&amp;oacute;n generadora.</target>
        </trans-unit>
        <trans-unit id="a9c0621bff7dcefce6457fdee9b6bcef2e0f3d8a" translate="yes" xml:space="preserve">
          <source>Critique of the Top/Accepted Answer**</source>
          <target state="translated">Crítica de la respuesta más aceptada**</target>
        </trans-unit>
        <trans-unit id="391058e00a0cf1fea23f9021af0e6821cda75f41" translate="yes" xml:space="preserve">
          <source>Different behavior:</source>
          <target state="translated">Un comportamiento diferente:</target>
        </trans-unit>
        <trans-unit id="4beaba95c78d5c63061a997dcde838cb3d1a985b" translate="yes" xml:space="preserve">
          <source>Does that make more sense or just confuse you more?  :)</source>
          <target state="translated">¿Tiene eso más sentido o sólo te confunde más? :)</target>
        </trans-unit>
        <trans-unit id="478cc5edb794118536367238291728364671b4c5" translate="yes" xml:space="preserve">
          <source>Don't confuse your Iterables, Iterators, and Generators</source>
          <target state="translated">No confundas tus Iterables,Iteradores y Generadores</target>
        </trans-unit>
        <trans-unit id="c5ebf51ae7871d62102efa654179e7b2cbd98826" translate="yes" xml:space="preserve">
          <source>Either way, an iterator is created, i.e. some object that can give you the data you want. The OO approach may be a bit complex. Anyway, which one to use is up to you.</source>
          <target state="translated">De cualquier manera,se crea un iterador,es decir,un objeto que puede darte los datos que quieres.El enfoque de OO puede ser un poco complejo.De todos modos,cuál de ellos usar depende de ti.</target>
        </trans-unit>
        <trans-unit id="17dcf8ce994111b56509be2581c55631ea92717d" translate="yes" xml:space="preserve">
          <source>Everything you can use &quot;&lt;code&gt;for... in...&lt;/code&gt;&quot; on is an iterable; &lt;code&gt;lists&lt;/code&gt;, &lt;code&gt;strings&lt;/code&gt;, files...</source>
          <target state="translated">Todo lo que puede usar &quot; &lt;code&gt;for... in...&lt;/code&gt; &quot; en es iterable; &lt;code&gt;lists&lt;/code&gt; , &lt;code&gt;strings&lt;/code&gt; , archivos ...</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="a58924e6ca70e15697b41c0fd8af77f8e3655bd0" translate="yes" xml:space="preserve">
          <source>First, the &lt;strong&gt;iterator protocol&lt;/strong&gt; - when you write</source>
          <target state="translated">Primero, el &lt;strong&gt;protocolo iterador&lt;/strong&gt; : cuando escribes</target>
        </trans-unit>
        <trans-unit id="ab464772e390ee8b69cf6e6fbb14dd8f889ce77c" translate="yes" xml:space="preserve">
          <source>First, we must queue up the generator with the builtin function, &lt;a href=&quot;https://docs.python.org/2/library/functions.html#next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;. It will 
call the appropriate &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;__next__&lt;/code&gt; method, depending on the version of
Python you are using:</source>
          <target state="translated">Primero, debemos poner en cola el generador con la funci&amp;oacute;n incorporada, &lt;a href=&quot;https://docs.python.org/2/library/functions.html#next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;__next__&lt;/code&gt; m&amp;eacute;todo &lt;code&gt;next&lt;/code&gt; o __next__ apropiado, dependiendo de la versi&amp;oacute;n de Python que est&amp;eacute; utilizando:</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="87881092dde77e187d0bf9cb4e0f744846b558a8" translate="yes" xml:space="preserve">
          <source>For example, I'm trying to understand this code&lt;sup&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/sup&gt;:</source>
          <target state="translated">Por ejemplo, estoy tratando de entender este c&amp;oacute;digo &lt;sup&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4359df1244f408dd74c85feea20108563cf47ea0" translate="yes" xml:space="preserve">
          <source>For more accurate information, read about &lt;a href=&quot;http://docs.python.org/library/stdtypes.html#iterator-types&quot;&gt;iterator types&lt;/a&gt;, the &lt;a href=&quot;http://docs.python.org/reference/simple_stmts.html#yield&quot;&gt;yield statement&lt;/a&gt; and &lt;a href=&quot;http://docs.python.org/glossary.html#term-generator&quot;&gt;generators&lt;/a&gt; in the Python documentation.</source>
          <target state="translated">Para obtener informaci&amp;oacute;n m&amp;aacute;s precisa, lea sobre los &lt;a href=&quot;http://docs.python.org/library/stdtypes.html#iterator-types&quot;&gt;tipos de iteradores&lt;/a&gt; , la &lt;a href=&quot;http://docs.python.org/reference/simple_stmts.html#yield&quot;&gt;declaraci&amp;oacute;n de rendimiento&lt;/a&gt; y los &lt;a href=&quot;http://docs.python.org/glossary.html#term-generator&quot;&gt;generadores&lt;/a&gt; en la documentaci&amp;oacute;n de Python.</target>
        </trans-unit>
        <trans-unit id="ab34884b9c5a1c376f359e896bfa36ac9404ee1e" translate="yes" xml:space="preserve">
          <source>For more insight as to what's happening behind the scenes, the &lt;code&gt;for&lt;/code&gt; loop can be rewritten to this:</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre lo que sucede detr&amp;aacute;s de escena, el bucle &lt;code&gt;for&lt;/code&gt; se puede reescribir a esto:</target>
        </trans-unit>
        <trans-unit id="b3b09a14c47c5a101227ecf4d23816285925f6d5" translate="yes" xml:space="preserve">
          <source>For those who prefer a minimal working example, meditate on this interactive Python session:</source>
          <target state="translated">Para aquellos que prefieran un ejemplo de trabajo mínimo,mediten en esta sesión interactiva de Python:</target>
        </trans-unit>
        <trans-unit id="50c79418c72adb6d21a9a53d6133434acd4b25f6" translate="yes" xml:space="preserve">
          <source>From &lt;em&gt;&lt;a href=&quot;http://www.python.org/dev/peps/pep-0380/&quot;&gt;PEP 380 -- Syntax for Delegating to a Subgenerator&lt;/a&gt;&lt;/em&gt;:</source>
          <target state="translated">De &lt;em&gt;&lt;a href=&quot;http://www.python.org/dev/peps/pep-0380/&quot;&gt;PEP 380 - Sintaxis para delegar a un subgenerador&lt;/a&gt;&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="12e842703e6cd07e003a70536ed53b1cad820600" translate="yes" xml:space="preserve">
          <source>From a programming viewpoint, the iterators are implemented as &lt;a href=&quot;http://en.wikipedia.org/wiki/Thunk_(functional_programming)&quot;&gt;thunks&lt;/a&gt;.</source>
          <target state="translated">Desde el punto de vista de la programaci&amp;oacute;n, los iteradores se implementan como &lt;a href=&quot;http://en.wikipedia.org/wiki/Thunk_(functional_programming)&quot;&gt;thunks&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c04b84b0d27f22df1bc44e709e3324e4728e5047" translate="yes" xml:space="preserve">
          <source>Further, there is an &lt;a href=&quot;http://bugs.python.org/issue10544&quot;&gt;outstanding issue (10544)&lt;/a&gt; which seems to be pointing in the direction of this &lt;em&gt;never&lt;/em&gt; being a good idea (PyPy, a Python implementation written in Python, is already raising syntax warnings.)</source>
          <target state="translated">Adem&amp;aacute;s, hay un &lt;a href=&quot;http://bugs.python.org/issue10544&quot;&gt;problema pendiente (10544)&lt;/a&gt; que parece apuntar en la direcci&amp;oacute;n de que esto &lt;em&gt;nunca&lt;/em&gt; es una buena idea (PyPy, una implementaci&amp;oacute;n de Python escrita en Python, ya est&amp;aacute; generando advertencias de sintaxis).</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="ea270aafef5ea2be7a50c15d8f3cf44425aa37b7" translate="yes" xml:space="preserve">
          <source>Generators and coroutines are a cool way to set up data-flow type applications.  I thought it would be worthwhile knowing about the other use of the &lt;code&gt;yield&lt;/code&gt; statement in functions.</source>
          <target state="translated">Los generadores y las rutinas son una forma genial de configurar aplicaciones de tipo flujo de datos. Pens&amp;eacute; que valdr&amp;iacute;a la pena saber sobre el otro uso de la declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; en las funciones.</target>
        </trans-unit>
        <trans-unit id="179018c67d6955b4f49df82ba24dc3b04e776679" translate="yes" xml:space="preserve">
          <source>Generators are iterators because they implement the &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#iterator-types&quot;&gt;&lt;strong&gt;iterator protocol&lt;/strong&gt;&lt;/a&gt;, so you can iterate over them.</source>
          <target state="translated">Los generadores son iteradores porque implementan el &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#iterator-types&quot;&gt;&lt;strong&gt;protocolo de iterador&lt;/strong&gt;&lt;/a&gt; , por lo que puede iterar sobre ellos.</target>
        </trans-unit>
        <trans-unit id="a5e08e7b38a556477cdbe545a9f764632125d102" translate="yes" xml:space="preserve">
          <source>Generators are iterators, a kind of iterable &lt;strong&gt;you can only iterate over once&lt;/strong&gt;. Generators do not store all the values in memory, &lt;strong&gt;they generate the values on the fly&lt;/strong&gt;:</source>
          <target state="translated">Los generadores son iteradores, un tipo de iterativo &lt;strong&gt;que solo puede iterar una vez&lt;/strong&gt; . Los generadores no almacenan todos los valores en la memoria, &lt;strong&gt;generan los valores sobre la marcha&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="682b0796dd83f3fd0ad45f54f168909fac114df8" translate="yes" xml:space="preserve">
          <source>Generators.</source>
          <target state="translated">Generators.</target>
        </trans-unit>
        <trans-unit id="30755c71dba128a057a2e8b31c452388bed51a8e" translate="yes" xml:space="preserve">
          <source>Generators:</source>
          <target state="translated">Generators:</target>
        </trans-unit>
        <trans-unit id="d054231a90af4e28b960cfe94d5c8186673ab51e" translate="yes" xml:space="preserve">
          <source>Gets an iterator for &lt;code&gt;mylist&lt;/code&gt;:</source>
          <target state="translated">Obtiene un iterador para &lt;code&gt;mylist&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c8a20bbe7bfc35516518ea627afd092d0e96e4cc" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;mylist&lt;/code&gt; is an &lt;em&gt;iterable&lt;/em&gt; because it implements the iterator protocol. In a user-defined class, you can implement the &lt;code&gt;__iter__()&lt;/code&gt; method to make instances of your class iterable. This method should return an &lt;em&gt;iterator&lt;/em&gt;. An iterator is an object with a &lt;code&gt;next()&lt;/code&gt; method. It is possible to implement both &lt;code&gt;__iter__()&lt;/code&gt; and &lt;code&gt;next()&lt;/code&gt; on the same class, and have &lt;code&gt;__iter__()&lt;/code&gt; return &lt;code&gt;self&lt;/code&gt;. This will work for simple cases, but not when you want two iterators looping over the same object at the same time.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;mylist&lt;/code&gt; es &lt;em&gt;iterable&lt;/em&gt; porque implementa el protocolo iterador. En una clase definida por el usuario, puede implementar el &lt;code&gt;__iter__()&lt;/code&gt; para hacer que las instancias de su clase sean iterables. Este m&amp;eacute;todo deber&amp;iacute;a devolver un &lt;em&gt;iterador&lt;/em&gt; . Un iterador es un objeto con un m&amp;eacute;todo &lt;code&gt;next()&lt;/code&gt; . Es posible implementar &lt;code&gt;__iter__()&lt;/code&gt; y &lt;code&gt;next()&lt;/code&gt; en la misma clase, y tener &lt;code&gt;__iter__()&lt;/code&gt; return &lt;code&gt;self&lt;/code&gt; . Esto funcionar&amp;aacute; para casos simples, pero no cuando desee que dos iteradores se repitan sobre el mismo objeto al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="0e79b5d88ed3c6e491dd1236e901c3ae33f6911d" translate="yes" xml:space="preserve">
          <source>Here are some Python examples of how to actually implement generators as if Python did not provide syntactic sugar for them:</source>
          <target state="translated">Aquí hay algunos ejemplos de Python de cómo implementar realmente los generadores como si Python no les proporcionara azúcar sintáctico:</target>
        </trans-unit>
        <trans-unit id="a3efbd24d9780439598b7e67d051e0a6314b264c" translate="yes" xml:space="preserve">
          <source>Here is a demonstration which uses the structure of R6RS, but the semantics is absolutely identical to Python's. It's the same model of computation, and only a change in syntax is required to rewrite it in Python.</source>
          <target state="translated">Aquí hay una demostración que utiliza la estructura de R6RS,pero la semántica es absolutamente idéntica a la de Python.Es el mismo modelo de cálculo,y sólo se requiere un cambio de sintaxis para reescribirlo en Python.</target>
        </trans-unit>
        <trans-unit id="5172df8a142b5de0fd37381a2dbff76cdb21ea9b" translate="yes" xml:space="preserve">
          <source>Here is a mental image of what &lt;code&gt;yield&lt;/code&gt; does.</source>
          <target state="translated">Aqu&amp;iacute; hay una imagen mental de lo que hace el &lt;code&gt;yield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea724b816190320574ae29c6484ba706b02e562b" translate="yes" xml:space="preserve">
          <source>Here is a simple example:</source>
          <target state="translated">Aquí hay un ejemplo simple:</target>
        </trans-unit>
        <trans-unit id="823fc4d20942e0533416446349c24b8a063855e9" translate="yes" xml:space="preserve">
          <source>Here is an example in plain language. I will provide a correspondence between high-level human concepts to low-level Python concepts.</source>
          <target state="translated">Aquí hay un ejemplo en lenguaje sencillo.Proporcionaré una correspondencia entre los conceptos humanos de alto nivel y los conceptos de Python de bajo nivel.</target>
        </trans-unit>
        <trans-unit id="c4be0889ef73ed93c610ebfab505f5cb8fc53788" translate="yes" xml:space="preserve">
          <source>Here is an example which &lt;code&gt;yield&lt;/code&gt; is definitely best for:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo para el que el &lt;code&gt;yield&lt;/code&gt; es definitivamente mejor:</target>
        </trans-unit>
        <trans-unit id="6617e5991223485f0a00e8961fec1ddd85153c85" translate="yes" xml:space="preserve">
          <source>Here is an example, take note of the &lt;code&gt;received&lt;/code&gt; variable, which will point to the data that is sent to the generator:</source>
          <target state="translated">Aqu&amp;iacute; hay un ejemplo, tome nota de la variable &lt;code&gt;received&lt;/code&gt; , que apuntar&amp;aacute; a los datos que se env&amp;iacute;an al generador:</target>
        </trans-unit>
        <trans-unit id="89aa700446679e9b8d5b65f7b661f79a7e178b5e" translate="yes" xml:space="preserve">
          <source>Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once.</source>
          <target state="translated">Aquí es un ejemplo inútil,pero es útil cuando sabes que tu función devolverá un enorme conjunto de valores que sólo tendrás que leer una vez.</target>
        </trans-unit>
        <trans-unit id="eeb09fb712bc1579dd70a54645ad53925ce84c23" translate="yes" xml:space="preserve">
          <source>Here's a simple &lt;code&gt;yield&lt;/code&gt; based approach, to compute the fibonacci series, explained:</source>
          <target state="translated">Aqu&amp;iacute; hay un enfoque simple basado en el &lt;code&gt;yield&lt;/code&gt; , para calcular la serie de Fibonacci, explicado:</target>
        </trans-unit>
        <trans-unit id="d5531c22206a07d82c2ec43020b326ceb13fdc0a" translate="yes" xml:space="preserve">
          <source>How you might use generators</source>
          <target state="translated">Cómo podría usar los generadores</target>
        </trans-unit>
        <trans-unit id="d332df6254754940f55d36631c669c40c1993a88" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;yield from&lt;/code&gt; also allows for delegation to subgenerators, 
which will be explained in the following section on cooperative delegation with sub-coroutines.</source>
          <target state="translated">Sin embargo, el &lt;code&gt;yield from&lt;/code&gt; tambi&amp;eacute;n permite la delegaci&amp;oacute;n a subgeneradores, lo que se explicar&amp;aacute; en la siguiente secci&amp;oacute;n sobre delegaci&amp;oacute;n cooperativa con sub-corutinas.</target>
        </trans-unit>
        <trans-unit id="f7b0cdd1500200d6f1d896513a1bb21305470aa6" translate="yes" xml:space="preserve">
          <source>I am not a Python developer, but it looks to me &lt;code&gt;yield&lt;/code&gt; holds the position of program flow and the next loop start from &quot;yield&quot; position. It seems like it is waiting at that position, and just before that, returning a value outside, and next time continues to work.</source>
          <target state="translated">No soy un desarrollador de Python, pero me parece que el &lt;code&gt;yield&lt;/code&gt; mantiene la posici&amp;oacute;n de flujo del programa y el siguiente ciclo comienza desde la posici&amp;oacute;n de &quot;rendimiento&quot;. Parece que est&amp;aacute; esperando en esa posici&amp;oacute;n, y justo antes de eso, devuelve un valor afuera, y la pr&amp;oacute;xima vez contin&amp;uacute;a trabajando.</target>
        </trans-unit>
        <trans-unit id="7e9ed01bd64f5c7896a84a3e0de95a03f1c43874" translate="yes" xml:space="preserve">
          <source>I ask you, &quot;tell me the next number&quot;, and you tell me the first number; after that, you wait for me to ask you for the next number. It's your job to remember where you were, what numbers you have already said, and what is the next number. I don't care about the details.</source>
          <target state="translated">Te pregunto,&quot;dime el siguiente número&quot;,y tú me dices el primer número;después de eso,esperas que te pregunte el siguiente número.Es tu trabajo recordar dónde estuviste,qué números ya has dicho,y cuál es el siguiente número.No me importan los detalles.</target>
        </trans-unit>
        <trans-unit id="ae297b474260c70e731c6a136da6c3a9aef2dfb5" translate="yes" xml:space="preserve">
          <source>I assume you have learned the &lt;code&gt;return&lt;/code&gt; statement.</source>
          <target state="translated">Supongo que has aprendido la declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bff8648a9749f500c9b8ad13ccf39b8881ec210" translate="yes" xml:space="preserve">
          <source>I believe I have covered all aspects of the following question:</source>
          <target state="translated">Creo que he cubierto todos los aspectos de la siguiente pregunta:</target>
        </trans-unit>
        <trans-unit id="a679dadd1d940ee0fc56a1b939523e2268a7d0ab" translate="yes" xml:space="preserve">
          <source>I call you and tell you that I want a sequence of numbers which is produced in a specific way, and I let you know what the algorithm is.</source>
          <target state="translated">Te llamo y te digo que quiero una secuencia de números que se produzca de una manera específica,y te hago saber cuál es el algoritmo.</target>
        </trans-unit>
        <trans-unit id="b123a6615d9a46f5c9c87bd3114b75d2fd201567" translate="yes" xml:space="preserve">
          <source>I like to think of a thread as having a stack (even when it's not implemented that way).</source>
          <target state="translated">Me gusta pensar que un hilo tiene una pila (incluso cuando no se implementa de esa manera).</target>
        </trans-unit>
        <trans-unit id="776c90801148362b805a9659dc082980e40d4245" translate="yes" xml:space="preserve">
          <source>I should note that this &lt;em&gt;is&lt;/em&gt; an oversimplification for illustrative purposes. :)</source>
          <target state="translated">Debo se&amp;ntilde;alar que se &lt;em&gt;trata de&lt;/em&gt; una simplificaci&amp;oacute;n excesiva con fines ilustrativos. :)</target>
        </trans-unit>
        <trans-unit id="cb5a08e181cbeb658f35df743832a692b6761240" translate="yes" xml:space="preserve">
          <source>I want to operate on a sequence of numbers, but I don't want to bother my self with the creation of that sequence, I want only to focus on the operation I want to do. So, I do the following:</source>
          <target state="translated">Quiero operar en una secuencia de números,pero no quiero molestarme con la creación de esa secuencia,sólo quiero concentrarme en la operación que quiero hacer.Así que hago lo siguiente:</target>
        </trans-unit>
        <trans-unit id="a3a2a857bfdd4d4fc3add0498fdaf773cfe37b55" translate="yes" xml:space="preserve">
          <source>I was going to post &quot;read page 19 of Beazley's 'Python: Essential Reference' for a quick description of generators&quot;, but so many others have posted good descriptions already.</source>
          <target state="translated">Iba a publicar &quot;leer la página 19 del 'Python' de Beazley:Essential Reference' para una rápida descripción de los generadores&quot;,pero muchos otros ya han publicado buenas descripciones.</target>
        </trans-unit>
        <trans-unit id="a101ee9df37442be51ecc059a7eaa91d1dd5f763" translate="yes" xml:space="preserve">
          <source>I'd agree that's a sensible place for us to end up, as any code
  relying on the current behaviour is really too clever to be
  maintainable.</source>
          <target state="translated">Estoy de acuerdo en que es un lugar sensato para que terminemos,ya que cualquier código que se base en el comportamiento actual es realmente demasiado inteligente para ser mantenible.</target>
        </trans-unit>
        <trans-unit id="1f609c272028fe91fcfd70e16ea920d4901be9b2" translate="yes" xml:space="preserve">
          <source>I'm OK with either approach.  Leaving things the way they are in Python 3
      is no good, IMHO.</source>
          <target state="translated">Estoy de acuerdo con cualquier enfoque.Dejar las cosas como están en Python 3 no es bueno,IMHO.</target>
        </trans-unit>
        <trans-unit id="f3a52ccfeb39b7c960e43a846a1980250d8002bd" translate="yes" xml:space="preserve">
          <source>If the compiler detects the &lt;code&gt;yield&lt;/code&gt; keyword &lt;em&gt;anywhere&lt;/em&gt; inside a function, that function no longer returns via the &lt;code&gt;return&lt;/code&gt; statement. &lt;strong&gt;&lt;em&gt;Instead&lt;/em&gt;&lt;/strong&gt;, it &lt;strong&gt;immediately&lt;/strong&gt; returns a &lt;strong&gt;lazy &quot;pending list&quot; object&lt;/strong&gt; called a generator</source>
          <target state="translated">Si el compilador detecta la palabra clave de &lt;code&gt;yield&lt;/code&gt; &lt;em&gt;cualquier lugar&lt;/em&gt; dentro de una funci&amp;oacute;n, esa funci&amp;oacute;n ya no regresa a trav&amp;eacute;s de la instrucci&amp;oacute;n &lt;code&gt;return&lt;/code&gt; . &lt;strong&gt;&lt;em&gt;En su lugar&lt;/em&gt;&lt;/strong&gt; , devuelve &lt;strong&gt;inmediatamente&lt;/strong&gt; un objeto &lt;strong&gt;perezoso de &quot;lista pendiente&quot;&lt;/strong&gt; llamado generador</target>
        </trans-unit>
        <trans-unit id="863b82de998a8840db9f970356b780625e865e98" translate="yes" xml:space="preserve">
          <source>If you need &lt;strong&gt;multiple passes&lt;/strong&gt; and the series isn't too long, just call &lt;code&gt;list()&lt;/code&gt; on it:</source>
          <target state="translated">Si necesita &lt;strong&gt;varios pases&lt;/strong&gt; y la serie no es demasiado larga, simplemente llame a &lt;code&gt;list()&lt;/code&gt; en ella:</target>
        </trans-unit>
        <trans-unit id="8e81f608f52f839d0787e210b24258db0ad4019d" translate="yes" xml:space="preserve">
          <source>If you want &lt;strong&gt;a function to return a huge set of values&lt;/strong&gt;, use &lt;code&gt;yield&lt;/code&gt;.</source>
          <target state="translated">Si desea que &lt;strong&gt;una funci&amp;oacute;n devuelva un gran conjunto de valores&lt;/strong&gt; , utilice el &lt;code&gt;yield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e30ae315ff14bf5d22d79d19890817eba23a8df" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://docs.python.org/2/reference/simple_stmts.html#the-return-statement&quot;&gt;Python 2&lt;/a&gt;:</source>
          <target state="translated">En &lt;a href=&quot;https://docs.python.org/2/reference/simple_stmts.html#the-return-statement&quot;&gt;Python 2&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ff77817e2891cf318ae9092b17aa58414c356493" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-return-statement&quot;&gt;Python 3&lt;/a&gt;:</source>
          <target state="translated">En &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-return-statement&quot;&gt;Python 3&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="01f20dd2f471369e8b09d4eee95c6fa431042ca7" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Controlling a generator exhaustion&lt;/strong&gt; he calls the &lt;code&gt;.next&lt;/code&gt; method, when instead he should use the builtin function, &lt;code&gt;next&lt;/code&gt;. It would be an appropriate layer of indirection, because his code does not work in Python 3.</source>
          <target state="translated">Al &lt;strong&gt;controlar el agotamiento de un generador&lt;/strong&gt; , llama al m&amp;eacute;todo &lt;code&gt;.next&lt;/code&gt; , cuando en su lugar deber&amp;iacute;a usar la funci&amp;oacute;n incorporada, a &lt;code&gt;next&lt;/code&gt; . Ser&amp;iacute;a una capa apropiada de indirecci&amp;oacute;n, porque su c&amp;oacute;digo no funciona en Python 3.</target>
        </trans-unit>
        <trans-unit id="9d6c893042f47fbe024cf470eea2e0d66f65c064" translate="yes" xml:space="preserve">
          <source>In Python 3, you can &lt;strong&gt;delegate&lt;/strong&gt; from one generator to another in both directions with &lt;strong&gt;&lt;code&gt;yield from&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">En Python 3, puede &lt;strong&gt;delegar&lt;/strong&gt; de un generador a otro en ambas direcciones con &lt;strong&gt; &lt;code&gt;yield from&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8ddb3a147bbf4149f8203b3ca2fa59434dcfe553" translate="yes" xml:space="preserve">
          <source>In Python-speak, an &lt;em&gt;iterable&lt;/em&gt; is any object which &quot;understands the concept of a for-loop&quot; like a list &lt;code&gt;[1,2,3]&lt;/code&gt;, and an &lt;em&gt;iterator&lt;/em&gt; is a specific instance of the requested for-loop like &lt;code&gt;[1,2,3].__iter__()&lt;/code&gt;. A &lt;em&gt;generator&lt;/em&gt; is exactly the same as any iterator, except for the way it was written (with function syntax).</source>
          <target state="translated">En Python-speak, un &lt;em&gt;iterable&lt;/em&gt; es cualquier objeto que &quot;comprende el concepto de un ciclo for&quot; como una lista &lt;code&gt;[1,2,3]&lt;/code&gt; , y un &lt;em&gt;iterador&lt;/em&gt; es una instancia espec&amp;iacute;fica del ciclo for for solicitado &lt;code&gt;[1,2,3].__iter__()&lt;/code&gt; . Un &lt;em&gt;generador&lt;/em&gt; es exactamente igual a cualquier iterador, excepto por la forma en que fue escrito (con la sintaxis de la funci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="174c5ef25999552b6ac3e98b79e66dc670f6ce7e" translate="yes" xml:space="preserve">
          <source>In a generator function, the &lt;code&gt;return&lt;/code&gt; statement indicates that the generator is done and will cause &lt;code&gt;StopIteration&lt;/code&gt; to be raised. The returned value (if any) is used as an argument to construct &lt;code&gt;StopIteration&lt;/code&gt; and becomes the &lt;code&gt;StopIteration.value&lt;/code&gt; attribute.</source>
          <target state="translated">En una funci&amp;oacute;n de generador, la declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; indica que el generador est&amp;aacute; hecho y har&amp;aacute; que se &lt;code&gt;StopIteration&lt;/code&gt; . El valor devuelto (si lo hay) se usa como argumento para construir &lt;code&gt;StopIteration&lt;/code&gt; y se convierte en el atributo &lt;code&gt;StopIteration.value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a40ea84cb1072d7d399fbe3b382af1883bc53737" translate="yes" xml:space="preserve">
          <source>In a generator function, the &lt;code&gt;return&lt;/code&gt; statement is not allowed to include an &lt;code&gt;expression_list&lt;/code&gt;. In that context, a bare &lt;code&gt;return&lt;/code&gt; indicates that the generator is done and will cause &lt;code&gt;StopIteration&lt;/code&gt; to be raised.</source>
          <target state="translated">En una funci&amp;oacute;n generadora, la declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; no puede incluir una &lt;code&gt;expression_list&lt;/code&gt; . En ese contexto, un simple &lt;code&gt;return&lt;/code&gt; indica que el generador est&amp;aacute; listo y har&amp;aacute; que se &lt;code&gt;StopIteration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe5f6300dd7512030712c12beefa508ff061926a" translate="yes" xml:space="preserve">
          <source>In a nutshell: &lt;strong&gt;a generator is a lazy, incrementally-pending list&lt;/strong&gt;, and &lt;strong&gt;&lt;code&gt;yield&lt;/code&gt; statements allow you to use function notation to program the list values&lt;/strong&gt; the generator should incrementally spit out.</source>
          <target state="translated">En pocas palabras: &lt;strong&gt;un generador es una lista perezosa e incrementalmente pendiente&lt;/strong&gt; , y las &lt;strong&gt;declaraciones de &lt;code&gt;yield&lt;/code&gt; permiten usar la notaci&amp;oacute;n de funci&amp;oacute;n para programar los valores de&lt;/strong&gt; la &lt;strong&gt;lista que&lt;/strong&gt; el generador debe escupir gradualmente.</target>
        </trans-unit>
        <trans-unit id="a0169a7972621076b895fe9b5351a9c054ff5aa8" translate="yes" xml:space="preserve">
          <source>In conclusion, as a metaphor to grok it:</source>
          <target state="translated">En conclusión,como una metáfora para tantear el terreno:</target>
        </trans-unit>
        <trans-unit id="65df69d0bd87c71c73d55034f2acb57286f92bd2" translate="yes" xml:space="preserve">
          <source>In continuation passing style (CPS), continuations are just normal functions (only in languages where functions are first class) which the programmer explicitly manages and passes around to subroutines. In this style, program state is represented by closures (and the variables that happen to be encoded in them) rather than variables that reside somewhere on the stack. Functions that manage control flow accept continuation as arguments (in some variations of CPS, functions may accept multiple continuations) and manipulate control flow by invoking them by simply calling them and returning afterwards. A very simple example of continuation passing style is as follows:</source>
          <target state="translated">En el estilo de paso de continuación (CPS),las continuaciones son sólo funciones normales (sólo en los lenguajes en los que las funciones son de primera clase)que el programador gestiona explícitamente y pasa a las subrutinas.En este estilo,el estado del programa se representa por cierres (y las variables que resultan estar codificadas en ellos)en lugar de las variables que residen en algún lugar de la pila.Las funciones que gestionan el flujo de control aceptan la continuación como argumento (en algunas variaciones de CPS,las funciones pueden aceptar múltiples continuaciones)y manipulan el flujo de control invocándolas simplemente llamándolas y volviendo después.Un ejemplo muy simple de estilo de paso de continuación es el siguiente:</target>
        </trans-unit>
        <trans-unit id="f90a21a794093245566d4b9689b0360b69b80989" translate="yes" xml:space="preserve">
          <source>In summary, the &lt;code&gt;yield&lt;/code&gt; statement transforms your function into a factory that produces a special object called a &lt;code&gt;generator&lt;/code&gt; which wraps around the body of your original function. When the &lt;code&gt;generator&lt;/code&gt; is iterated, it executes your function  until it reaches the next &lt;code&gt;yield&lt;/code&gt; then suspends execution and evaluates to the value passed to &lt;code&gt;yield&lt;/code&gt;. It repeats this process on each iteration until the path of execution exits the function. For instance,</source>
          <target state="translated">En resumen, la declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; transforma su funci&amp;oacute;n en una f&amp;aacute;brica que produce un objeto especial llamado &lt;code&gt;generator&lt;/code&gt; que envuelve el cuerpo de su funci&amp;oacute;n original. Cuando se itera el &lt;code&gt;generator&lt;/code&gt; , ejecuta su funci&amp;oacute;n hasta que alcanza el siguiente &lt;code&gt;yield&lt;/code&gt; luego suspende la ejecuci&amp;oacute;n y eval&amp;uacute;a el valor pasado al &lt;code&gt;yield&lt;/code&gt; . Repite este proceso en cada iteraci&amp;oacute;n hasta que la ruta de ejecuci&amp;oacute;n salga de la funci&amp;oacute;n. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="dbb3601dd734c0edf841aa944a55cbabed686850" translate="yes" xml:space="preserve">
          <source>In terms of getting there, we'll likely want:</source>
          <target state="translated">En términos de llegar allí,es probable que queramos:</target>
        </trans-unit>
        <trans-unit id="af70c38bd0efc99a5d44a07df4047e8a92d9ae06" translate="yes" xml:space="preserve">
          <source>In the case of your code, the function &lt;code&gt;get_child_candidates&lt;/code&gt; is acting like an iterator so that when you extend your list, it adds one element at a time to the new list.</source>
          <target state="translated">En el caso de su c&amp;oacute;digo, la funci&amp;oacute;n &lt;code&gt;get_child_candidates&lt;/code&gt; act&amp;uacute;a como un iterador para que cuando extienda su lista, agregue un elemento a la vez a la nueva lista.</target>
        </trans-unit>
        <trans-unit id="791078267dbf81f5f1c3cf2eb3971161ef95c26f" translate="yes" xml:space="preserve">
          <source>In the second case, &lt;code&gt;bar&lt;/code&gt; just gives you a generator. A generator is an iterable--which means you can use it in a &lt;code&gt;for&lt;/code&gt; loop, etc, but each value can only be accessed once. All the values are also not stored in memory at the same time; the generator object &quot;remembers&quot; where it was in the looping the last time you called it--this way, if you're using an iterable to (say) count to 50 billion, you don't have to count to 50 billion all at once and store the 50 billion numbers to count through.</source>
          <target state="translated">En el segundo caso, la &lt;code&gt;bar&lt;/code&gt; ra solo te da un generador. Un generador es iterable, lo que significa que puede usarlo en un ciclo &lt;code&gt;for&lt;/code&gt; , etc., pero a cada valor solo se puede acceder una vez. Todos los valores tampoco se almacenan en la memoria al mismo tiempo; el objeto generador &quot;recuerda&quot; d&amp;oacute;nde estaba en el bucle la &amp;uacute;ltima vez que lo llam&amp;oacute;, de esta manera, si est&amp;aacute; utilizando un iterable para (digamos) contar hasta 50 mil millones, no tiene que contar hasta 50 mil millones a la vez y almacenar los 50 mil millones de n&amp;uacute;meros para contar.</target>
        </trans-unit>
        <trans-unit id="bd951975204b594b5a324c588bdc33476765e99f" translate="yes" xml:space="preserve">
          <source>In this (very simplistic) example, the programmer saves the operation of actually writing the file into a continuation (which can potentially be a very complex operation with many details to write out), and then passes that continuation (i.e, as a first-class closure) to another operator which does some more processing, and then calls it if necessary. (I use this design pattern a lot in actual GUI programming, either because it saves me lines of code or, more importantly, to manage control flow after GUI events trigger.)</source>
          <target state="translated">En este ejemplo (muy simplista),el programador guarda la operación de escribir realmente el archivo en una continuación (que puede ser potencialmente una operación muy compleja con muchos detalles que escribir),y luego pasa esa continuación (es decir,como un cierre de primera clase)a otro operador que hace un poco más de procesamiento,y luego la llama si es necesario.(Utilizo mucho este patrón de diseño en la programación real de GUI,ya sea porque me ahorra líneas de código o,más importante aún,para manejar el flujo de control después de que los eventos de GUI se disparen).</target>
        </trans-unit>
        <trans-unit id="d137b802f3a324a2d71f425b20cbe30685de8a31" translate="yes" xml:space="preserve">
          <source>Indirectly, if you provide &lt;code&gt;fib&lt;/code&gt; to a &lt;code&gt;for&lt;/code&gt; loop, a &lt;code&gt;list&lt;/code&gt; initializer, a &lt;code&gt;tuple&lt;/code&gt; initializer, or anything else that expects an object that generates/produces values, you'll &quot;consume&quot; the generator until no more values can be produced by it (and it returns):</source>
          <target state="translated">Indirectamente, si proporciona &lt;code&gt;fib&lt;/code&gt; a un bucle &lt;code&gt;for&lt;/code&gt; , un inicializador de &lt;code&gt;list&lt;/code&gt; a , un inicializador de &lt;code&gt;tuple&lt;/code&gt; o cualquier otra cosa que espere que un objeto genere / produzca valores, &quot;consumir&amp;aacute;&quot; el generador hasta que no pueda producir m&amp;aacute;s valores ( y vuelve):</target>
        </trans-unit>
        <trans-unit id="1484d552dab70171147c52a184472f4c770e78cd" translate="yes" xml:space="preserve">
          <source>Insert a line &lt;code&gt;result = []&lt;/code&gt; at the start of the function.</source>
          <target state="translated">Inserte un &lt;code&gt;result = []&lt;/code&gt; l&amp;iacute;nea = [] al comienzo de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f65bc680a718b8079e23b9ac8d4b6ee9a4e7033d" translate="yes" xml:space="preserve">
          <source>Insert a line &lt;code&gt;return result&lt;/code&gt; at the bottom of the function.</source>
          <target state="translated">Inserte un &lt;code&gt;return result&lt;/code&gt; l&amp;iacute;nea en la parte inferior de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ddae4c2e0ba5c800a528da8a2d033235effb5bce" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;yield&lt;/code&gt; statements, if you had three &lt;code&gt;return&lt;/code&gt; statements in &lt;code&gt;f123()&lt;/code&gt; only the first would get executed, and the function would exit. But &lt;code&gt;f123()&lt;/code&gt; is no ordinary function. When &lt;code&gt;f123()&lt;/code&gt; is called, it &lt;em&gt;does not&lt;/em&gt; return any of the values in the yield statements! It returns a generator object. Also, the function does not really exit - it goes into a suspended state. When the &lt;code&gt;for&lt;/code&gt; loop tries to loop over the generator object, the function resumes from its suspended state at the very next line after the &lt;code&gt;yield&lt;/code&gt; it previously returned from, executes the next line of code, in this case, a &lt;code&gt;yield&lt;/code&gt; statement, and returns that as the next item. This happens until the function exits, at which point the generator raises &lt;code&gt;StopIteration&lt;/code&gt;, and the loop exits.</source>
          <target state="translated">En lugar de declaraciones de &lt;code&gt;yield&lt;/code&gt; , si tuviera tres declaraciones de &lt;code&gt;return&lt;/code&gt; en &lt;code&gt;f123()&lt;/code&gt; solo se ejecutar&amp;iacute;a la primera y la funci&amp;oacute;n saldr&amp;iacute;a. Pero &lt;code&gt;f123()&lt;/code&gt; no es una funci&amp;oacute;n ordinaria. Cuando se llama a &lt;code&gt;f123()&lt;/code&gt; , &amp;iexcl; &lt;em&gt;no&lt;/em&gt; devuelve ninguno de los valores en las declaraciones de rendimiento! Devuelve un objeto generador. Adem&amp;aacute;s, la funci&amp;oacute;n realmente no sale, pasa a un estado suspendido. Cuando el bucle &lt;code&gt;for&lt;/code&gt; intenta recorrer el objeto generador, la funci&amp;oacute;n se reanuda desde su estado suspendido en la l&amp;iacute;nea siguiente despu&amp;eacute;s del &lt;code&gt;yield&lt;/code&gt; que regres&amp;oacute; anteriormente, ejecuta la siguiente l&amp;iacute;nea de c&amp;oacute;digo, en este caso, una declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; y devuelve ese como el siguiente art&amp;iacute;culo. Esto sucede hasta que sale la funci&amp;oacute;n, en cuyo punto el generador eleva &lt;code&gt;StopIteration&lt;/code&gt; y el ciclo sale.</target>
        </trans-unit>
        <trans-unit id="6ba67eec9e92df05acdf46af85244d2e3cb47ac2" translate="yes" xml:space="preserve">
          <source>Instead of this:</source>
          <target state="translated">En lugar de esto:</target>
        </trans-unit>
        <trans-unit id="a2128e769c0a333306ebd59207294d6e72de5845" translate="yes" xml:space="preserve">
          <source>It can be useful for various things like controlling access to a resource.</source>
          <target state="translated">Puede ser útil para varias cosas como controlar el acceso a un recurso.</target>
        </trans-unit>
        <trans-unit id="815bab4f701d81dd1ca8739066ea47b1ea845181" translate="yes" xml:space="preserve">
          <source>It is confused on what makes an &lt;strong&gt;iterable&lt;/strong&gt;, just using a list as an example. See my references above, but in summary: an iterable has an &lt;code&gt;__iter__&lt;/code&gt; method returning an &lt;strong&gt;iterator&lt;/strong&gt;. An &lt;strong&gt;iterator&lt;/strong&gt; provides a &lt;code&gt;.next&lt;/code&gt; (Python 2 or &lt;code&gt;.__next__&lt;/code&gt; (Python 3) method, which is implicitly called by &lt;code&gt;for&lt;/code&gt; loops until it raises &lt;code&gt;StopIteration&lt;/code&gt;, and once it does, it will continue to do so.</source>
          <target state="translated">Est&amp;aacute; confundido sobre lo que hace que sea &lt;strong&gt;iterable&lt;/strong&gt; , solo usando una lista como ejemplo. Vea mis referencias arriba, pero en resumen: un iterable tiene un m&amp;eacute;todo &lt;code&gt;__iter__&lt;/code&gt; que devuelve un &lt;strong&gt;iterador&lt;/strong&gt; . Un &lt;strong&gt;iterador&lt;/strong&gt; proporciona un &lt;code&gt;.next&lt;/code&gt; (Python 2 o &lt;code&gt;.__next__&lt;/code&gt; (Python 3), que se llama impl&amp;iacute;citamente por bucles hasta que genera &lt;code&gt;StopIteration&lt;/code&gt; , y una vez que lo hace, continuar&amp;aacute; haci&amp;eacute;ndolo.</target>
        </trans-unit>
        <trans-unit id="d0e5a74aff1c87c165974074b746e9b876037387" translate="yes" xml:space="preserve">
          <source>It is just the same except you used &lt;code&gt;()&lt;/code&gt; instead of &lt;code&gt;[]&lt;/code&gt;. BUT, you &lt;strong&gt;cannot&lt;/strong&gt; perform &lt;code&gt;for i in mygenerator&lt;/code&gt; a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end calculating 4, one by one.</source>
          <target state="translated">Es igual, excepto que us&amp;oacute; &lt;code&gt;()&lt;/code&gt; en lugar de &lt;code&gt;[]&lt;/code&gt; . PERO, no &lt;strong&gt;puede&lt;/strong&gt; realizar &lt;code&gt;for i in mygenerator&lt;/code&gt; una segunda vez ya que los generadores solo se pueden usar una vez: calculan 0, luego se olvidan y calculan 1, y terminan de calcular 4, uno por uno.</target>
        </trans-unit>
        <trans-unit id="05428c01ccee190c5ac8f4e2b026d5698fe85729" translate="yes" xml:space="preserve">
          <source>It really helps simplify some problems, and makes some things easier to work with.</source>
          <target state="translated">Realmente ayuda a simplificar algunos problemas,y hace que algunas cosas sean más fáciles de trabajar.</target>
        </trans-unit>
        <trans-unit id="ce1006cada79cecc9b2fc03861f35b39cd056555" translate="yes" xml:space="preserve">
          <source>It seems to be an interesting and nice ability :D</source>
          <target state="translated">Parece ser una habilidad interesante y agradable.</target>
        </trans-unit>
        <trans-unit id="a4c8c5a8330bec1551d58ebddad1eca41f75c743" translate="yes" xml:space="preserve">
          <source>It then uses a generator expression to describe what a generator is. Since a generator is simply a convenient way to create an &lt;strong&gt;iterator&lt;/strong&gt;, it only confuses the matter, and we still have not yet gotten to the &lt;code&gt;yield&lt;/code&gt; part.</source>
          <target state="translated">Luego usa una expresi&amp;oacute;n generadora para describir qu&amp;eacute; es un generador. Dado que un generador es simplemente una forma conveniente de crear un &lt;strong&gt;iterador&lt;/strong&gt; , solo confunde el asunto, y todav&amp;iacute;a no hemos llegado a la parte de &lt;code&gt;yield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b525c9fdafab13df3793783112dad0c5e7c47f0" translate="yes" xml:space="preserve">
          <source>It turns out that &lt;code&gt;yield&lt;/code&gt; does a lot. I'm sure I could add even more 
thorough examples to this. If you want more or have some constructive criticism, let me know by commenting
below.</source>
          <target state="translated">Resulta que el &lt;code&gt;yield&lt;/code&gt; hace mucho. Estoy seguro de que podr&amp;iacute;a agregar ejemplos a&amp;uacute;n m&amp;aacute;s completos a esto. Si desea m&amp;aacute;s o tiene alguna cr&amp;iacute;tica constructiva, h&amp;aacute;gamelo saber comentando a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="bedfd4c2b8ac96435e9dab026a1ad6ca9d8e9595" translate="yes" xml:space="preserve">
          <source>It's returning a generator. I'm not particularly familiar with Python, but I believe it's the same kind of thing as &lt;a href=&quot;http://csharpindepth.com/Articles/Chapter11/StreamingAndIterators.aspx&quot;&gt;C#'s iterator blocks&lt;/a&gt; if you're familiar with those.</source>
          <target state="translated">Est&amp;aacute; devolviendo un generador. No estoy particularmente familiarizado con Python, pero creo que es el mismo tipo de cosas que &lt;a href=&quot;http://csharpindepth.com/Articles/Chapter11/StreamingAndIterators.aspx&quot;&gt;los bloques iteradores de C #&lt;/a&gt; si est&amp;aacute; familiarizado con ellos.</target>
        </trans-unit>
        <trans-unit id="b62a14283b71537aa375bb5504d321c2fa6f966c" translate="yes" xml:space="preserve">
          <source>It's the core about &lt;code&gt;yield&lt;/code&gt;.</source>
          <target state="translated">Es el n&amp;uacute;cleo del &lt;code&gt;yield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dd80eea3f6c51bf5b9c13a8a47609bd55b30e0e" translate="yes" xml:space="preserve">
          <source>Iterables</source>
          <target state="translated">Iterables</target>
        </trans-unit>
        <trans-unit id="d8b8f9a4e83121e284417429816033e650e4b4db" translate="yes" xml:space="preserve">
          <source>Iteration is a process implying iterables (implementing the &lt;code&gt;__iter__()&lt;/code&gt; method) and iterators (implementing the &lt;code&gt;__next__()&lt;/code&gt; method).
Iterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables.</source>
          <target state="translated">La iteraci&amp;oacute;n es un proceso que implica iterables (implementando el &lt;code&gt;__iter__()&lt;/code&gt; ) e iteradores (implementando el &lt;code&gt;__next__()&lt;/code&gt; ). Iterables son los objetos de los que puede obtener un iterador. Los iteradores son objetos que le permiten iterar en iterables.</target>
        </trans-unit>
        <trans-unit id="0ae5cba6a7258c212d3cd38a207c7e9817fe838e" translate="yes" xml:space="preserve">
          <source>Itertools, your best friend</source>
          <target state="translated">Itertools,tu mejor amigo</target>
        </trans-unit>
        <trans-unit id="45989d87a7cb5c27f41e09694e3e18fcead4c711" translate="yes" xml:space="preserve">
          <source>Itertools? This was not relevant to what &lt;code&gt;yield&lt;/code&gt; does at all.</source>
          <target state="translated">Itertools? Esto no fue relevante para lo que el &lt;code&gt;yield&lt;/code&gt; hace en absoluto.</target>
        </trans-unit>
        <trans-unit id="4092678f14b36035b0f14d72fd89eede06817d6a" translate="yes" xml:space="preserve">
          <source>Keep calling the &lt;code&gt;next()&lt;/code&gt; method on the iterator returned from step 1. The return value from &lt;code&gt;next()&lt;/code&gt; is assigned to &lt;code&gt;x&lt;/code&gt; and the loop body is executed. If an exception &lt;code&gt;StopIteration&lt;/code&gt; is raised from within &lt;code&gt;next()&lt;/code&gt;, it means there are no more values in the iterator and the loop is exited.</source>
          <target state="translated">Siga llamando al m&amp;eacute;todo &lt;code&gt;next()&lt;/code&gt; en el iterador devuelto desde el paso 1. El valor de retorno de &lt;code&gt;next()&lt;/code&gt; se asigna a &lt;code&gt;x&lt;/code&gt; y se ejecuta el cuerpo del bucle. Si se &lt;code&gt;StopIteration&lt;/code&gt; una excepci&amp;oacute;n StopIteration desde &lt;code&gt;next()&lt;/code&gt; , significa que no hay m&amp;aacute;s valores en el iterador y se cierra el bucle.</target>
        </trans-unit>
        <trans-unit id="02ece3e82c3cc947abccfde61ed0ddf58d180562" translate="yes" xml:space="preserve">
          <source>Let's define a function &lt;code&gt;makeRange&lt;/code&gt; that's just like Python's &lt;code&gt;range&lt;/code&gt;. Calling &lt;code&gt;makeRange(n)&lt;/code&gt; RETURNS A GENERATOR:</source>
          <target state="translated">Definamos una funci&amp;oacute;n &lt;code&gt;makeRange&lt;/code&gt; que sea igual que el &lt;code&gt;range&lt;/code&gt; de Python. Llamar a &lt;code&gt;makeRange(n)&lt;/code&gt; UN GENERADOR:</target>
        </trans-unit>
        <trans-unit id="17e789352f0c8efe4814e81b930cce60ca106303" translate="yes" xml:space="preserve">
          <source>Like every answer suggests, &lt;code&gt;yield&lt;/code&gt; is used for creating a sequence generator. It's used for generating some sequence dynamically. For example, while reading a file line by line on a network, you can use the &lt;code&gt;yield&lt;/code&gt; function as follows:</source>
          <target state="translated">Como sugiere cada respuesta, el &lt;code&gt;yield&lt;/code&gt; se usa para crear un generador de secuencia. Se usa para generar alguna secuencia din&amp;aacute;micamente. Por ejemplo, mientras lee un archivo l&amp;iacute;nea por l&amp;iacute;nea en una red, puede usar la funci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; siguiente manera:</target>
        </trans-unit>
        <trans-unit id="f1e0ba1d127fcef46948db3881dab6eede1ff0a8" translate="yes" xml:space="preserve">
          <source>Luckily Guido and his team were generous enough to develop generators so we could just do this;</source>
          <target state="translated">Por suerte Guido y su equipo fueron lo suficientemente generosos para desarrollar generadores para que pudiéramos hacer esto;</target>
        </trans-unit>
        <trans-unit id="ea2bbc6304080fdb00b621f7aa3245c1e64e92e2" translate="yes" xml:space="preserve">
          <source>Many people use &lt;code&gt;return&lt;/code&gt; rather than &lt;code&gt;yield&lt;/code&gt;, but in some cases &lt;code&gt;yield&lt;/code&gt; can be more efficient and easier to work with.</source>
          <target state="translated">Muchas personas usan el &lt;code&gt;return&lt;/code&gt; lugar del &lt;code&gt;yield&lt;/code&gt; , pero en algunos casos el &lt;code&gt;yield&lt;/code&gt; puede ser m&amp;aacute;s eficiente y m&amp;aacute;s f&amp;aacute;cil de trabajar.</target>
        </trans-unit>
        <trans-unit id="f1ecc57d869eaa2aeb4f14bb021fbf641a09a4cf" translate="yes" xml:space="preserve">
          <source>Minutiae</source>
          <target state="translated">Minutiae</target>
        </trans-unit>
        <trans-unit id="63298b940ce76e1f6554f705d9938c3451b0daf7" translate="yes" xml:space="preserve">
          <source>More importantly, &lt;code&gt;yield&lt;/code&gt; is a &lt;strong&gt;barrier&lt;/strong&gt;.</source>
          <target state="translated">M&amp;aacute;s importante a&amp;uacute;n, el &lt;code&gt;yield&lt;/code&gt; es una &lt;strong&gt;barrera&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="260be5bd97364077b3283e9557a7cf6fccbc23dd" translate="yes" xml:space="preserve">
          <source>Moreover &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;this&lt;/a&gt; will introduce (since Python 3.5):</source>
          <target state="translated">Adem&amp;aacute;s, &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;esto&lt;/a&gt; introducir&amp;aacute; (desde Python 3.5):</target>
        </trans-unit>
        <trans-unit id="f90dd4485580d3bdc59a261e1ec77656145f7983" translate="yes" xml:space="preserve">
          <source>My vote is it be a SyntaxError since you're not getting what you expect from
    the syntax.</source>
          <target state="translated">Mi voto es que sea un error de sintaxis,ya que no se obtiene lo que se espera de la sintaxis.</target>
        </trans-unit>
        <trans-unit id="6d2a636bd1ba1e865b86d549524144e1fe118a22" translate="yes" xml:space="preserve">
          <source>No discussion of the methods that &lt;code&gt;yield&lt;/code&gt; provides along with the new functionality &lt;code&gt;yield from&lt;/code&gt; in Python 3. &lt;strong&gt;The top/accepted answer is a very incomplete answer.&lt;/strong&gt;</source>
          <target state="translated">No se discuten los m&amp;eacute;todos que proporciona el &lt;code&gt;yield&lt;/code&gt; junto con el &lt;code&gt;yield from&lt;/code&gt; la nueva funcionalidad de Python 3. &lt;strong&gt;La respuesta superior / aceptada es una respuesta muy incompleta.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="957edece43529861540ff3f36e5e7a2451ec8ff3" translate="yes" xml:space="preserve">
          <source>Normally, most people would not care about the following distinctions and probably want to stop reading here.</source>
          <target state="translated">Normalmente,a la mayoría de la gente no le importarían las siguientes distinciones y probablemente querría dejar de leer aquí.</target>
        </trans-unit>
        <trans-unit id="f8c793e525ecfff42fd9cd9042640febe5190bea" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;def&lt;/code&gt;ining a function which contains a &lt;code&gt;yield&lt;/code&gt; keyword is not the only way to create a generator; it's just the easiest way to create one.</source>
          <target state="translated">Tenga en cuenta que definir una funci&amp;oacute;n que contiene una palabra clave de &lt;code&gt;yield&lt;/code&gt; no es la &amp;uacute;nica forma de crear un generador; Es la forma m&amp;aacute;s f&amp;aacute;cil de crear uno.</target>
        </trans-unit>
        <trans-unit id="c9d2501fc158d349dfef0af0d5919d70d9574d6f" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;for&lt;/code&gt; loop doesn't know what kind of object it's dealing with - it just follows the iterator protocol, and is happy to get item after item as it calls &lt;code&gt;next()&lt;/code&gt;. Built-in lists return their items one by one, dictionaries return the &lt;em&gt;keys&lt;/em&gt; one by one, files return the &lt;em&gt;lines&lt;/em&gt; one by one, etc. And generators return... well that's where &lt;code&gt;yield&lt;/code&gt; comes in:</source>
          <target state="translated">Tenga en cuenta que un bucle &lt;code&gt;for&lt;/code&gt; no sabe con qu&amp;eacute; tipo de objeto se trata: solo sigue el protocolo iterador y se complace en obtener elemento tras elemento cuando llama a &lt;code&gt;next()&lt;/code&gt; . Las listas incorporadas devuelven sus elementos uno por uno, los diccionarios devuelven las &lt;em&gt;claves&lt;/em&gt; una por una, los archivos devuelven las &lt;em&gt;l&amp;iacute;neas&lt;/em&gt; una por una, etc. Y los generadores regresan ... bueno, ah&amp;iacute; es donde entra el &lt;code&gt;yield&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d0983c67f73b9198117de75714eca1653ab0ab62" translate="yes" xml:space="preserve">
          <source>Now let's talk about generators in Python. Generators are a specific subtype of continuation. Whereas &lt;strong&gt;continuations are able in general to save the state of a &lt;em&gt;computation&lt;/em&gt;&lt;/strong&gt; (i.e., the program's call stack), &lt;strong&gt;generators are only able to save the state of iteration over an &lt;em&gt;iterator&lt;/em&gt;&lt;/strong&gt;. Although, this definition is slightly misleading for certain use cases of generators. For instance:</source>
          <target state="translated">Ahora hablemos de generadores en Python. Los generadores son un subtipo espec&amp;iacute;fico de continuaci&amp;oacute;n. Mientras que las &lt;strong&gt;continuaciones pueden en general guardar el estado de un &lt;em&gt;c&amp;aacute;lculo&lt;/em&gt;&lt;/strong&gt; (es decir, la pila de llamadas del programa), los &lt;strong&gt;generadores solo pueden guardar el estado de iteraci&amp;oacute;n sobre un &lt;em&gt;iterador&lt;/em&gt;&lt;/strong&gt; . Aunque, esta definici&amp;oacute;n es ligeramente enga&amp;ntilde;osa para ciertos casos de uso de generadores. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="cbea0f398a5f710fc8e5fc5cc6c1aa916df7b9fc" translate="yes" xml:space="preserve">
          <source>Now the hard part:</source>
          <target state="translated">Ahora la parte difícil:</target>
        </trans-unit>
        <trans-unit id="96065685d9b9c8665dca19ef4217583b206991ad" translate="yes" xml:space="preserve">
          <source>Now upon each iteration a function on the generator called &lt;code&gt;next()&lt;/code&gt; executes the function until it either reaches a 'yield' statement in which it stops and  'yields' the value or reaches the end of the function. In this case on the first call, &lt;code&gt;next()&lt;/code&gt; executes up to the yield statement and yield 'n', on the next call it will execute the  increment statement, jump back to the 'while', evaluate it, and if true, it will stop and yield 'n' again, it will continue that way until the while condition returns false and the generator jumps to the end of the function.</source>
          <target state="translated">Ahora, en cada iteraci&amp;oacute;n, una funci&amp;oacute;n en el generador llamada &lt;code&gt;next()&lt;/code&gt; ejecuta la funci&amp;oacute;n hasta que alcanza una declaraci&amp;oacute;n de 'rendimiento' en la que se detiene y 'produce' el valor o llega al final de la funci&amp;oacute;n. En este caso, en la primera llamada, &lt;code&gt;next()&lt;/code&gt; ejecuta hasta la declaraci&amp;oacute;n de rendimiento y el rendimiento 'n', en la pr&amp;oacute;xima llamada ejecutar&amp;aacute; la declaraci&amp;oacute;n de incremento, volver&amp;aacute; al 'while', la evaluar&amp;aacute; y, si es verdadero, se detendr&amp;aacute; y producir&amp;aacute; 'n' nuevamente, continuar&amp;aacute; de esa manera hasta que la condici&amp;oacute;n while vuelva falsa y el generador salte al final de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6f591e3f872109c5472337a1e87fe9e3bcde0a83" translate="yes" xml:space="preserve">
          <source>Now, enter in the REPL:</source>
          <target state="translated">Ahora,introduzca en la REPL:</target>
        </trans-unit>
        <trans-unit id="e92a9d3b2c29a2e3bc4353c33fa7bff82dd4846f" translate="yes" xml:space="preserve">
          <source>Now, recall that &lt;code&gt;yield from&lt;/code&gt; is available in Python 3. This allows us to delegate
coroutines to a subcoroutine:</source>
          <target state="translated">Ahora, recuerde que el &lt;code&gt;yield from&lt;/code&gt; est&amp;aacute; disponible en Python 3. Esto nos permite delegar corutinas a una subcorutina:</target>
        </trans-unit>
        <trans-unit id="5a307763317a3a7bc6e71bc9264167d7ad80a27e" translate="yes" xml:space="preserve">
          <source>Now, you win to get all the numbers.</source>
          <target state="translated">Ahora,usted gana para obtener todos los números.</target>
        </trans-unit>
        <trans-unit id="b6987f5b93c9acf22eca3106831b92a972ad34e6" translate="yes" xml:space="preserve">
          <source>On 30 January 2017 at 19:05, Brett Cannon  wrote:</source>
          <target state="translated">El 30 de enero de 2017 a las 19:05,Brett Cannon escribió:</target>
        </trans-unit>
        <trans-unit id="85c98d1e4740c518785320f781b5df7464816e4c" translate="yes" xml:space="preserve">
          <source>On Sun, 29 Jan 2017 at 16:39 Craig Rodrigues  wrote:</source>
          <target state="translated">El domingo 29 de enero de 2017 a las 16:39 Craig Rodrigues escribió:</target>
        </trans-unit>
        <trans-unit id="effbc2c26171feae094bbbc8c2b18c68368e591a" translate="yes" xml:space="preserve">
          <source>One can yield data programmatically, for example:</source>
          <target state="translated">Se pueden obtener datos de forma programada,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="8ec523094d69740bf96305160c0edf4de24e608c" translate="yes" xml:space="preserve">
          <source>One more step we can rewrite &lt;code&gt;yield&lt;/code&gt; statement with &lt;code&gt;return&lt;/code&gt;</source>
          <target state="translated">Un paso m&amp;aacute;s podemos reescribir la declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; con &lt;code&gt;return&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b31a591d4d9d64b9d692dc2c86bc55fc3a7bde29" translate="yes" xml:space="preserve">
          <source>Original version:</source>
          <target state="translated">Versión original:</target>
        </trans-unit>
        <trans-unit id="bee143e2a96019cef9b2e3c68a2e94c347f68a59" translate="yes" xml:space="preserve">
          <source>Other Methods: close and throw</source>
          <target state="translated">Otros métodos:cerrar y tirar</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="5f07ef89f002df2bf1789a1e70ac0785b82990f2" translate="yes" xml:space="preserve">
          <source>Please note: generators can actually be used for many more things, such as &lt;a href=&quot;http://www.dabeaz.com/coroutines/index.html&quot;&gt;implementing coroutines&lt;/a&gt; or non-deterministic programming or other elegant things. However, the &quot;lazy lists&quot; viewpoint I present here is the most common use you will find.</source>
          <target state="translated">Tenga en cuenta que los generadores se pueden usar para muchas cosas m&amp;aacute;s, como &lt;a href=&quot;http://www.dabeaz.com/coroutines/index.html&quot;&gt;implementar corutinas&lt;/a&gt; o programaci&amp;oacute;n no determinista u otras cosas elegantes. Sin embargo, el punto de vista de &quot;listas perezosas&quot; que presento aqu&amp;iacute; es el uso m&amp;aacute;s com&amp;uacute;n que encontrar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="00d9b100b9bcc674781b9766a8e6870f8757ebdd" translate="yes" xml:space="preserve">
          <source>Py3k warning in 2.7.x</source>
          <target state="translated">Advertencia de Py3k en 2.7.x</target>
        </trans-unit>
        <trans-unit id="cef032cf531f21b2c9cdf6eb64b001d4fb256c9b" translate="yes" xml:space="preserve">
          <source>Python compiles the function, encounters the &lt;code&gt;yield&lt;/code&gt; keyword and simply returns a generator object back at you. Not very helpful it seems.</source>
          <target state="translated">Python compila la funci&amp;oacute;n, encuentra la palabra clave de &lt;code&gt;yield&lt;/code&gt; y simplemente le devuelve un objeto generador. No muy &amp;uacute;til parece.</target>
        </trans-unit>
        <trans-unit id="c0e695374f96756b35fdfe22b9dbb044371df33d" translate="yes" xml:space="preserve">
          <source>Python performs the following two steps:</source>
          <target state="translated">Python realiza los siguientes dos pasos:</target>
        </trans-unit>
        <trans-unit id="c35284ab3425210def57302b5a65e2b0a11149ab" translate="yes" xml:space="preserve">
          <source>Remember that this is just pseudocode and the actual implementation of generators in Python is more complex. But as an exercise to understand what is going on, try to use continuation passing style to implement generator objects without use of the &lt;code&gt;yield&lt;/code&gt; keyword.</source>
          <target state="translated">Recuerde que esto es solo un seudoc&amp;oacute;digo y la implementaci&amp;oacute;n real de generadores en Python es m&amp;aacute;s compleja. Pero como un ejercicio para comprender lo que est&amp;aacute; sucediendo, intente usar el estilo de paso de continuaci&amp;oacute;n para implementar objetos generadores sin usar la palabra clave de &lt;code&gt;yield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ac5b61c45f411038301d2404cf4fec54441c6ad" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;return&lt;/code&gt; with &lt;code&gt;yield&lt;/code&gt;:</source>
          <target state="translated">Reemplazar &lt;code&gt;return&lt;/code&gt; con &lt;code&gt;yield&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d3afd790e348a0c26c0be34d40ecc9f41e19d26d" translate="yes" xml:space="preserve">
          <source>Replace each &lt;code&gt;yield expr&lt;/code&gt; with &lt;code&gt;result.append(expr)&lt;/code&gt;.</source>
          <target state="translated">Reemplace cada &lt;code&gt;yield expr&lt;/code&gt; con &lt;code&gt;result.append(expr)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25e781fe1df53bae8a289d02fbdb77ae6469547c" translate="yes" xml:space="preserve">
          <source>Run it:</source>
          <target state="translated">Ejecútalo:</target>
        </trans-unit>
        <trans-unit id="97dadded1b9f2fcec4b19ca00a996516c8982a2c" translate="yes" xml:space="preserve">
          <source>Same behavior:</source>
          <target state="translated">El mismo comportamiento:</target>
        </trans-unit>
        <trans-unit id="5a97a974883d7bcd43990ce0a93d8ca9aa864bfd" translate="yes" xml:space="preserve">
          <source>Say you wanted to create a your own &lt;code&gt;range&lt;/code&gt; function that produces an iterable range of numbers, you could do it like so,</source>
          <target state="translated">Supongamos que desea crear su propia funci&amp;oacute;n de &lt;code&gt;range&lt;/code&gt; que produce un rango iterable de n&amp;uacute;meros, podr&amp;iacute;a hacerlo as&amp;iacute;,</target>
        </trans-unit>
        <trans-unit id="2ab0369f1d5983f084d45c352d30c1446684eceb" translate="yes" xml:space="preserve">
          <source>See, you get only a single number rather than a list of them. &lt;code&gt;return&lt;/code&gt; never allows you prevail happily, just implements once and quit.</source>
          <target state="translated">Mira, solo obtienes un solo n&amp;uacute;mero en lugar de una lista de ellos. &lt;code&gt;return&lt;/code&gt; nunca le permite prevalecer felizmente, solo implemente una vez y salga.</target>
        </trans-unit>
        <trans-unit id="010b0672dea78d8c4aa4f2420058adae5991abbe" translate="yes" xml:space="preserve">
          <source>Shortcut to understanding &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">Atajo para comprender el &lt;code&gt;yield&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7942e6cc5e90e1d35d5f04820acc2b178f0f857" translate="yes" xml:space="preserve">
          <source>Similarly, with a &lt;code&gt;tuple&lt;/code&gt; initializer:</source>
          <target state="translated">Del mismo modo, con un inicializador de &lt;code&gt;tuple&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b2196b60ca80d641d8c512b27441745d29a9bae0" translate="yes" xml:space="preserve">
          <source>Since yield is an expression, it has been touted by some as interesting to use it in comprehensions or generator expression - in spite of citing no particularly good use-case.</source>
          <target state="translated">Dado que el rendimiento es una expresión,algunos han dicho que es interesante utilizarlo para la comprensión o la expresión generadora,a pesar de no citar ningún caso de uso particularmente bueno.</target>
        </trans-unit>
        <trans-unit id="eb2327b341cffc04d124fdbbf7357dcf2a6b1dc4" translate="yes" xml:space="preserve">
          <source>So it's a kind of a frozen function that the generator is hanging onto.</source>
          <target state="translated">Así que es una especie de función congelada a la que se aferra el generador.</target>
        </trans-unit>
        <trans-unit id="19673e758686be33a34cf32a2f95654be99c541b" translate="yes" xml:space="preserve">
          <source>So that's the iterator protocol, many objects implement this protocol:</source>
          <target state="translated">Así que ese es el protocolo del iterador,muchos objetos implementan este protocolo:</target>
        </trans-unit>
        <trans-unit id="9bd6893f306954b22b5c6d426e694f0b79db960f" translate="yes" xml:space="preserve">
          <source>So the generator object is sort of like an adapter - at one end it exhibits the iterator protocol, by exposing &lt;code&gt;__iter__()&lt;/code&gt; and &lt;code&gt;next()&lt;/code&gt; methods to keep the &lt;code&gt;for&lt;/code&gt; loop happy. At the other end, however, it runs the function just enough to get the next value out of it, and puts it back in suspended mode.</source>
          <target state="translated">Entonces, el objeto generador es algo as&amp;iacute; como un adaptador: en un extremo exhibe el protocolo iterador, al exponer los &lt;code&gt;__iter__()&lt;/code&gt; y &lt;code&gt;next()&lt;/code&gt; para mantener el ciclo &lt;code&gt;for&lt;/code&gt; feliz. Sin embargo, en el otro extremo, ejecuta la funci&amp;oacute;n lo suficiente como para obtener el siguiente valor y la vuelve a poner en modo suspendido.</target>
        </trans-unit>
        <trans-unit id="0846a1b0282a9b40bd6407dbf79fde868f3d33b4" translate="yes" xml:space="preserve">
          <source>So, how do you generate these values? This can either be done directly by using the built-in function &lt;code&gt;next&lt;/code&gt;, or, indirectly by feeding it to a construct that consumes values.</source>
          <target state="translated">Entonces, &amp;iquest;c&amp;oacute;mo se generan estos valores? Esto puede hacerse directamente usando la funci&amp;oacute;n incorporada &lt;code&gt;next&lt;/code&gt; o indirectamente alimentando a una construcci&amp;oacute;n que consume valores.</target>
        </trans-unit>
        <trans-unit id="5a9e453ff9384952ce4f468ed81ccbae376c01b4" translate="yes" xml:space="preserve">
          <source>Sometime later, I tell you, &quot;OK, get ready to tell me the sequence of numbers&quot;.</source>
          <target state="translated">Algún tiempo después,te digo:&quot;Bien,prepárate para decirme la secuencia de números&quot;.</target>
        </trans-unit>
        <trans-unit id="f19056e03502445791c22a8e19229c5e20a55381" translate="yes" xml:space="preserve">
          <source>SyntaxError in 3.8</source>
          <target state="translated">SintaxisError en 3.8</target>
        </trans-unit>
        <trans-unit id="567e7ba961e72df760eb88d4a21163100151b70e" translate="yes" xml:space="preserve">
          <source>SyntaxWarning or DeprecationWarning in 3.7</source>
          <target state="translated">Advertencia de Sintaxis o DeprecaciónAdvertencia en 3.7</target>
        </trans-unit>
        <trans-unit id="9ab0a0362c832896068559a5fa49081174de2ddf" translate="yes" xml:space="preserve">
          <source>That is, it will run the code in your function from the beginning until it hits &lt;code&gt;yield&lt;/code&gt;. Then, it&amp;rsquo;ll return the first value of the loop.</source>
          <target state="translated">Es decir, ejecutar&amp;aacute; el c&amp;oacute;digo en su funci&amp;oacute;n desde el principio hasta que alcance el &lt;code&gt;yield&lt;/code&gt; . Luego, devolver&amp;aacute; el primer valor del bucle.</target>
        </trans-unit>
        <trans-unit id="838208781647d2859f5be9f1f69a5eae0736b9bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;close&lt;/code&gt; method raises &lt;code&gt;GeneratorExit&lt;/code&gt; at the point the function 
execution was frozen. This will also be called by &lt;code&gt;__del__&lt;/code&gt; so you 
can put any cleanup code where you handle the &lt;code&gt;GeneratorExit&lt;/code&gt;:</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;close&lt;/code&gt; genera &lt;code&gt;GeneratorExit&lt;/code&gt; en el punto en que se congela la ejecuci&amp;oacute;n de la funci&amp;oacute;n. Esto tambi&amp;eacute;n lo llamar&amp;aacute; &lt;code&gt;__del__&lt;/code&gt; para que pueda poner cualquier c&amp;oacute;digo de limpieza donde maneje la &lt;code&gt;GeneratorExit&lt;/code&gt; del generador :</target>
        </trans-unit>
        <trans-unit id="a3d45fcf0497296d8e1482b4554df59b5eedf048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extend()&lt;/code&gt; method is a list object method that expects an iterable and adds its values to the list.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;extend()&lt;/code&gt; es un m&amp;eacute;todo de objeto de lista que espera un iterable y agrega sus valores a la lista.</target>
        </trans-unit>
        <trans-unit id="29609fb0ada2ba2818fb2a90a695577b51e87c1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gi_code&lt;/code&gt; and &lt;code&gt;gi_frame&lt;/code&gt; fields are where the frozen state is stored. Exploring them with &lt;code&gt;dir(..)&lt;/code&gt;, we can confirm that our mental model above is credible.</source>
          <target state="translated">Los campos &lt;code&gt;gi_code&lt;/code&gt; y &lt;code&gt;gi_frame&lt;/code&gt; son donde se almacena el estado congelado. Al explorarlos con &lt;code&gt;dir(..)&lt;/code&gt; , podemos confirmar que nuestro modelo mental anterior es cre&amp;iacute;ble.</target>
        </trans-unit>
        <trans-unit id="d96f54e7ea72522d78f3384a3336d7ad5556bc22" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; statement in a generator</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; en un generador</target>
        </trans-unit>
        <trans-unit id="77154ad361e61b0b0ba81607182893014c0d1a34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; keyword is reduced to two simple facts:</source>
          <target state="translated">La palabra clave de &lt;code&gt;yield&lt;/code&gt; se reduce a dos hechos simples:</target>
        </trans-unit>
        <trans-unit id="dc5a0f0208c180c85b5d0c4f32b9d8172d5659ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; keyword simply collects returning results. Think of &lt;code&gt;yield&lt;/code&gt; like &lt;code&gt;return +=&lt;/code&gt;</source>
          <target state="translated">La palabra clave de &lt;code&gt;yield&lt;/code&gt; simplemente recopila resultados que regresan. Piense en el &lt;code&gt;yield&lt;/code&gt; como &lt;code&gt;return +=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="569b8a7334a018ddbbd0be69dd1861bc7484befb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement in Python returns a generator. A generator in Python is a function that returns</source>
          <target state="translated">La declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; en Python devuelve un generador. Un generador en Python es una funci&amp;oacute;n que devuelve</target>
        </trans-unit>
        <trans-unit id="286c50d08b635ef15bfeee9cc3db60c93c6ad474" translate="yes" xml:space="preserve">
          <source>The CPython core developers are &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2017-January/147301.html&quot;&gt;discussing deprecating its allowance&lt;/a&gt;.
Here's a relevant post from the mailing list:</source>
          <target state="translated">Los desarrolladores principales de CPython est&amp;aacute;n &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2017-January/147301.html&quot;&gt;discutiendo la depreciaci&amp;oacute;n de su asignaci&amp;oacute;n&lt;/a&gt; . Aqu&amp;iacute; hay una publicaci&amp;oacute;n relevante de la lista de correo:</target>
        </trans-unit>
        <trans-unit id="4e3fe55c48ec33c0b2a6787983638ea6d62f5711" translate="yes" xml:space="preserve">
          <source>The OO approach, we wrap the metadata &lt;code&gt;as a class&lt;/code&gt;. This is the so-called &lt;code&gt;iterator&lt;/code&gt; who implements the iterator protocol (i.e. the &lt;code&gt;__next__()&lt;/code&gt;, and &lt;code&gt;__iter__()&lt;/code&gt; methods). This is also the commonly seen &lt;a href=&quot;https://en.wikipedia.org/wiki/Iterator_pattern#Python&quot;&gt;iterator design pattern&lt;/a&gt;.</source>
          <target state="translated">El enfoque OO, envolvemos los metadatos &lt;code&gt;as a class&lt;/code&gt; . Este es el llamado &lt;code&gt;iterator&lt;/code&gt; que implementa el protocolo de iterador (es decir, los &lt;code&gt;__next__()&lt;/code&gt; y &lt;code&gt;__iter__()&lt;/code&gt; ). Este es tambi&amp;eacute;n el &lt;a href=&quot;https://en.wikipedia.org/wiki/Iterator_pattern#Python&quot;&gt;patr&amp;oacute;n de dise&amp;ntilde;o de iterador&lt;/a&gt; com&amp;uacute;nmente visto.</target>
        </trans-unit>
        <trans-unit id="b36d36ae5461cd703d79e055f55c9ebb36c41eab" translate="yes" xml:space="preserve">
          <source>The above example can be thought of as merely creating a list which you append to and return:</source>
          <target state="translated">El ejemplo anterior puede pensarse como una mera creación de una lista a la que se añade y se devuelve:</target>
        </trans-unit>
        <trans-unit id="384fee2b6ad3d7469cdf79c4d54b9d63ea5ae224" translate="yes" xml:space="preserve">
          <source>The above simple generator is also equivalent to the below - as of Python 3.3 (and not available in Python 2), you can use &lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/&quot;&gt;&lt;code&gt;yield from&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">El generador simple anterior tambi&amp;eacute;n es equivalente al siguiente: a partir de Python 3.3 (y no est&amp;aacute; disponible en Python 2), puede usar el &lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/&quot;&gt; &lt;code&gt;yield from&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e62f3d84017118479b990b0d86c245c11aa0d847" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;next()&lt;/code&gt; just calls the objects &lt;code&gt;.next()&lt;/code&gt; function, which is a part of the &quot;iteration protocol&quot; and is found on all iterators. You can manually use the &lt;code&gt;next()&lt;/code&gt; function (and other parts of the iteration protocol) to implement fancy things, usually at the expense of readability, so try to avoid doing that...</source>
          <target state="translated">La funci&amp;oacute;n incorporada &lt;code&gt;next()&lt;/code&gt; solo llama a la funci&amp;oacute;n de objetos &lt;code&gt;.next()&lt;/code&gt; , que es parte del &quot;protocolo de iteraci&amp;oacute;n&quot; y se encuentra en todos los iteradores. Puede usar manualmente la funci&amp;oacute;n &lt;code&gt;next()&lt;/code&gt; (y otras partes del protocolo de iteraci&amp;oacute;n) para implementar cosas sofisticadas, generalmente a expensas de la legibilidad, as&amp;iacute; que trate de evitar hacer eso ...</target>
        </trans-unit>
        <trans-unit id="7de99b1c48ee10b1bddb666e63ca36fa1bf9d357" translate="yes" xml:space="preserve">
          <source>The difference between a list &lt;code&gt;return&lt;/code&gt; outputs and the object &lt;code&gt;yield&lt;/code&gt; output is:</source>
          <target state="translated">La diferencia entre una salida de &lt;code&gt;return&lt;/code&gt; lista y la salida de &lt;code&gt;yield&lt;/code&gt; del objeto es:</target>
        </trans-unit>
        <trans-unit id="bb49489746a020a2dc0a0d8886122c8ac1c8272f" translate="yes" xml:space="preserve">
          <source>The execution control will be transferred from getNextLines() to the &lt;code&gt;for&lt;/code&gt; loop when yield is executed. Thus, every time getNextLines() is invoked, execution begins from the point where it was paused last time.</source>
          <target state="translated">El control de ejecuci&amp;oacute;n se transferir&amp;aacute; de getNextLines () al bucle &lt;code&gt;for&lt;/code&gt; cuando se ejecute el rendimiento. Por lo tanto, cada vez que se invoca getNextLines (), la ejecuci&amp;oacute;n comienza desde el punto donde se detuvo la &amp;uacute;ltima vez.</target>
        </trans-unit>
        <trans-unit id="9574ade792214860025139f4da109ddb0dd74095" translate="yes" xml:space="preserve">
          <source>The first time the &lt;code&gt;for&lt;/code&gt; calls the generator object created from your function, it will run the code in your function from the beginning until it hits &lt;code&gt;yield&lt;/code&gt;, then it'll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting &lt;code&gt;yield&lt;/code&gt;. That can be because the loop has come to an end, or because you no longer satisfy an &lt;code&gt;&quot;if/else&quot;&lt;/code&gt;.</source>
          <target state="translated">La primera vez que &lt;code&gt;for&lt;/code&gt; llama al objeto generador creado a partir de su funci&amp;oacute;n, ejecutar&amp;aacute; el c&amp;oacute;digo en su funci&amp;oacute;n desde el principio hasta que alcance el &lt;code&gt;yield&lt;/code&gt; , luego devolver&amp;aacute; el primer valor del bucle. Luego, cada llamada posterior ejecutar&amp;aacute; otra iteraci&amp;oacute;n del bucle que ha escrito en la funci&amp;oacute;n y devolver&amp;aacute; el siguiente valor. Esto continuar&amp;aacute; hasta que el generador se considere vac&amp;iacute;o, lo que sucede cuando la funci&amp;oacute;n se ejecuta sin alcanzar el &lt;code&gt;yield&lt;/code&gt; . Eso puede ser porque el ciclo ha llegado a su fin, o porque ya no satisface un &lt;code&gt;&quot;if/else&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55b6d1db997b3f1403e7e44c2927b50a091ed779" translate="yes" xml:space="preserve">
          <source>The functional approach, we wrap the metadata &lt;code&gt;as a function&lt;/code&gt;. This is
the so-called &lt;code&gt;generator function&lt;/code&gt;. But under the hood, the returned &lt;code&gt;generator object&lt;/code&gt; still &lt;code&gt;IS-A&lt;/code&gt; iterator because it also implements the iterator protocol.</source>
          <target state="translated">El enfoque funcional, envolvemos los metadatos &lt;code&gt;as a function&lt;/code&gt; . Esta es la llamada &lt;code&gt;generator function&lt;/code&gt; . Pero bajo el cap&amp;oacute;, el &lt;code&gt;generator object&lt;/code&gt; devuelto sigue siendo &lt;code&gt;IS-A&lt;/code&gt; iterador IS-A porque tambi&amp;eacute;n implementa el protocolo iterador.</target>
        </trans-unit>
        <trans-unit id="ad5e73ec25fc40ac5fd2ca20c474cd6986e30ab3" translate="yes" xml:space="preserve">
          <source>The generator remembers it was paused at &lt;code&gt;yield value&lt;/code&gt; and resumes from there. The next message is printed and the search for the &lt;code&gt;yield&lt;/code&gt; statement to pause at it performed again (due to the &lt;code&gt;while&lt;/code&gt; loop).</source>
          <target state="translated">El generador recuerda que se detuvo al &lt;code&gt;yield value&lt;/code&gt; y se reanuda desde all&amp;iacute;. Se imprime el siguiente mensaje y la b&amp;uacute;squeda de la declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; para pausar se realiza nuevamente (debido al ciclo while).</target>
        </trans-unit>
        <trans-unit id="956ec5707ad9efc1beeb86871d9e095c1cace192" translate="yes" xml:space="preserve">
          <source>The generator type is a sub-type of iterator:</source>
          <target state="translated">El tipo de generador es un subtipo de iterador:</target>
        </trans-unit>
        <trans-unit id="89f016e32a8da16e8af307b674da7c0f4716f8a7" translate="yes" xml:space="preserve">
          <source>The grammar currently allows any expression in a list comprehension.</source>
          <target state="translated">La gramática permite actualmente cualquier expresión en una lista de comprensión.</target>
        </trans-unit>
        <trans-unit id="edf75537a05166775dfd15ba5c8a40896c6f403e" translate="yes" xml:space="preserve">
          <source>The idea for generators comes from other languages (see footnote 1) with varying implementations. In Python's Generators, the execution of the code is &lt;a href=&quot;https://docs.python.org/3.5/glossary.html#term-generator-iterator&quot;&gt;frozen&lt;/a&gt; at the point of the yield. When the generator is called (methods are discussed below) execution resumes and then freezes at the next yield.</source>
          <target state="translated">La idea de los generadores proviene de otros idiomas (ver nota 1) con implementaciones variables. En los Generadores de Python, la ejecuci&amp;oacute;n del c&amp;oacute;digo se &lt;a href=&quot;https://docs.python.org/3.5/glossary.html#term-generator-iterator&quot;&gt;congela&lt;/a&gt; en el punto del rendimiento. Cuando se llama al generador (los m&amp;eacute;todos se analizan a continuaci&amp;oacute;n), la ejecuci&amp;oacute;n se reanuda y luego se congela en el siguiente rendimiento.</target>
        </trans-unit>
        <trans-unit id="305c568102291c5cb1ca7281807fa2c9a3b573fc" translate="yes" xml:space="preserve">
          <source>The itertools module contains special functions to manipulate iterables. Ever wish to duplicate a generator?
Chain two generators? Group values in a nested list with a one-liner? &lt;code&gt;Map / Zip&lt;/code&gt; without creating another list?</source>
          <target state="translated">El m&amp;oacute;dulo itertools contiene funciones especiales para manipular iterables. &amp;iquest;Alguna vez quisiste duplicar un generador? &amp;iquest;Cadena de dos generadores? &amp;iquest;Agrupar valores en una lista anidada con una l&amp;iacute;nea? &lt;code&gt;Map / Zip&lt;/code&gt; sin crear otra lista?</target>
        </trans-unit>
        <trans-unit id="6f58a19a2dd95bc1b3cbfc74f010f82f5559c58c" translate="yes" xml:space="preserve">
          <source>The key idea is that the compiler/interpreter/whatever does some trickery so that as far as the caller is concerned, they can keep calling next() and it will keep returning values - &lt;em&gt;as if the generator method was paused&lt;/em&gt;. Now obviously you can't really &quot;pause&quot; a method, so the compiler builds a state machine for you to remember where you currently are and what the local variables etc look like. This is much easier than writing an iterator yourself.</source>
          <target state="translated">La idea clave es que el compilador / int&amp;eacute;rprete / lo que sea haga alg&amp;uacute;n truco para que, en lo que respecta a la persona que llama, pueda seguir llamando a next () y seguir&amp;aacute; devolviendo valores, &lt;em&gt;como si el m&amp;eacute;todo generador estuviera en pausa&lt;/em&gt; . Ahora, obviamente, no puede realmente &quot;pausar&quot; un m&amp;eacute;todo, por lo que el compilador construye una m&amp;aacute;quina de estados para que recuerde d&amp;oacute;nde se encuentra actualmente y c&amp;oacute;mo son las variables locales, etc. Esto es mucho m&amp;aacute;s f&amp;aacute;cil que escribir un iterador usted mismo.</target>
        </trans-unit>
        <trans-unit id="92d79cb061c23c0b97be5b3c6bcac7a9343bbb0e" translate="yes" xml:space="preserve">
          <source>The loop iterates on a list, but the list expands while the loop is being iterated :-) It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, &lt;code&gt;candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))&lt;/code&gt; exhaust all the values of the generator, but &lt;code&gt;while&lt;/code&gt; keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node.</source>
          <target state="translated">El ciclo itera en una lista, pero la lista se expande mientras se repite el ciclo :-) Es una forma concisa de revisar todos estos datos anidados, incluso si es un poco peligroso, ya que puede terminar con un ciclo infinito. En este caso, los &lt;code&gt;candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))&lt;/code&gt; agotan todos los valores del generador, pero al mismo &lt;code&gt;while&lt;/code&gt; siguen creando nuevos objetos generadores que producir&amp;aacute;n valores diferentes de los anteriores ya que no se aplica en el mismo nodo.</target>
        </trans-unit>
        <trans-unit id="fa326100d98f456e392b2f2fad538e2c0e77b226" translate="yes" xml:space="preserve">
          <source>The most famous user of the iterator protocol is the &lt;code&gt;for&lt;/code&gt; command in Python. So, whenever you do a:</source>
          <target state="translated">El usuario m&amp;aacute;s famoso del protocolo iterador es el comando &lt;code&gt;for&lt;/code&gt; en Python. Entonces, cada vez que haces un:</target>
        </trans-unit>
        <trans-unit id="db347df1c70b1f578850ca66fe264ef9284adcde" translate="yes" xml:space="preserve">
          <source>The new syntax also opens up some opportunities for optimisation when one generator re-yields values produced by another.</source>
          <target state="translated">La nueva sintaxis también abre algunas oportunidades de optimización cuando un generador vuelve a producir valores producidos por otro.</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">La salida es:</target>
        </trans-unit>
        <trans-unit id="65c10c8b7349834a5510a50665946231ee354c64" translate="yes" xml:space="preserve">
          <source>The power comes from using the generator with a loop that calculates a sequence, the generator executes the loop stopping each time to 'yield' the next result of the calculation, in this way it calculates a list on the fly, the benefit being the memory saved for especially large calculations</source>
          <target state="translated">La energía proviene de usar el generador con un lazo que calcula una secuencia,el generador ejecuta el lazo deteniéndose cada vez para &quot;rendir&quot; el siguiente resultado del cálculo,de esta manera calcula una lista sobre la marcha,el beneficio es la memoria guardada para cálculos especialmente grandes</target>
        </trans-unit>
        <trans-unit id="fc99ade7c7b098191b4ad77e911e56c56415f9b0" translate="yes" xml:space="preserve">
          <source>The rest of this post will, without loss of generality, conceptualize continuations as CPS, because it is a hell of a lot easier to understand and read.</source>
          <target state="translated">El resto de este post,sin perder la generalidad,conceptualizará las continuaciones como CPS,porque es mucho más fácil de entender y leer.</target>
        </trans-unit>
        <trans-unit id="a8c92b7c9011965f168156df7f932f40277a20fa" translate="yes" xml:space="preserve">
          <source>The truth is Python performs the above two steps anytime it wants to &lt;em&gt;loop over&lt;/em&gt; the contents of an object - so it could be a for loop, but it could also be code like &lt;code&gt;otherlist.extend(mylist)&lt;/code&gt; (where &lt;code&gt;otherlist&lt;/code&gt; is a Python list).</source>
          <target state="translated">La verdad es que Python realiza los dos pasos anteriores en cualquier momento que quiera &lt;em&gt;recorrer&lt;/em&gt; el contenido de un objeto, por lo que podr&amp;iacute;a ser un ciclo for, pero tambi&amp;eacute;n podr&amp;iacute;a ser un c&amp;oacute;digo como &lt;code&gt;otherlist.extend(mylist)&lt;/code&gt; (donde &lt;code&gt;otherlist&lt;/code&gt; es una lista de Python) .</target>
        </trans-unit>
        <trans-unit id="02672c2bae3577e3b6b8642a622474b7f6f3b750" translate="yes" xml:space="preserve">
          <source>The unquoted results are what's printed. The quoted result is what is returned from &lt;code&gt;yield&lt;/code&gt;. Call &lt;code&gt;next&lt;/code&gt; again now:</source>
          <target state="translated">Los resultados sin comillas son lo que se imprime. El resultado citado es lo que se devuelve del &lt;code&gt;yield&lt;/code&gt; . Llame al &lt;code&gt;next&lt;/code&gt; nuevamente ahora:</target>
        </trans-unit>
        <trans-unit id="b738047d593c9d45f3f7f40a6e4eb41f8b25d5d8" translate="yes" xml:space="preserve">
          <source>Then I can use it in other code like this:</source>
          <target state="translated">Entonces puedo usarlo en otro código como este:</target>
        </trans-unit>
        <trans-unit id="22b87c58846e1f25413204d0a0b8a1d8ed0faa70" translate="yes" xml:space="preserve">
          <source>Then just &lt;code&gt;import itertools&lt;/code&gt;.</source>
          <target state="translated">Entonces solo &lt;code&gt;import itertools&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68d7286f8dc4f85d70f3ddd2982d475286c52f12" translate="yes" xml:space="preserve">
          <source>Then, every other call will run the loop you have written in the function one more time, returning the next value until there isn't any value to return.</source>
          <target state="translated">Entonces,cualquier otra llamada ejecutará el bucle que has escrito en la función una vez más,devolviendo el siguiente valor hasta que no haya ningún valor que devolver.</target>
        </trans-unit>
        <trans-unit id="3bb53270d0d4b4b1c8ffaa313d2acf3c3c850136" translate="yes" xml:space="preserve">
          <source>Then, your code will continue from where it left off each time &lt;code&gt;for&lt;/code&gt; uses the generator.</source>
          <target state="translated">Luego, su c&amp;oacute;digo continuar&amp;aacute; desde donde lo dej&amp;oacute; cada vez &lt;code&gt;for&lt;/code&gt; use el generador.</target>
        </trans-unit>
        <trans-unit id="959039a43531d3c4457a69589ed899271db1489a" translate="yes" xml:space="preserve">
          <source>There are 2 approaches to wrap such metadata.</source>
          <target state="translated">Hay dos enfoques para envolver tales metadatos.</target>
        </trans-unit>
        <trans-unit id="1e019b6ab061a03c5c91f64a23063b53844dc5f0" translate="yes" xml:space="preserve">
          <source>There are lots of ways to implement this computation. I used mutation, but it is easy to do it without mutation, by returning the current value and the next yielder.</source>
          <target state="translated">Hay muchas maneras de implementar este cálculo.He usado la mutación,pero es fácil hacerlo sin la mutación,devolviendo el valor actual y el siguiente rendimiento.</target>
        </trans-unit>
        <trans-unit id="2d7b67871d58c1c22337093d7853eafa16e73e0b" translate="yes" xml:space="preserve">
          <source>There comes &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">Viene el &lt;code&gt;yield&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0a32cb8e02d7bb4ce6cf72881e646c325fc9731" translate="yes" xml:space="preserve">
          <source>There is another &lt;code&gt;yield&lt;/code&gt; use and meaning (since Python 3.3):</source>
          <target state="translated">Hay otro uso de &lt;code&gt;yield&lt;/code&gt; y significado (desde Python 3.3):</target>
        </trans-unit>
        <trans-unit id="3efe40491ef4b5d01abc9316e30e10c965a4a4c9" translate="yes" xml:space="preserve">
          <source>There is more about it in this article about &lt;a href=&quot;http://effbot.org/zone/python-for-statement.htm&quot;&gt;how &lt;code&gt;for&lt;/code&gt; loops work&lt;/a&gt;.</source>
          <target state="translated">Hay m&amp;aacute;s sobre esto en este art&amp;iacute;culo sobre &lt;a href=&quot;http://effbot.org/zone/python-for-statement.htm&quot;&gt;c&amp;oacute;mo funcionan los bucles&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f47398ac35d029b6377a0b4ddaede2532b3994a" translate="yes" xml:space="preserve">
          <source>There is one major difference, though; see the last section.</source>
          <target state="translated">Hay una gran diferencia,sin embargo;ver la última sección.</target>
        </trans-unit>
        <trans-unit id="dfe628b44e21e48a9a1638275ee2cab7d93e4a99" translate="yes" xml:space="preserve">
          <source>There is one type of answer that I don't feel has been given yet, among the many great answers that describe how to use generators. Here is the programming language theory answer:</source>
          <target state="translated">Hay un tipo de respuesta que no creo que se haya dado todavía,entre las muchas grandes respuestas que describen cómo usar los generadores.Aquí está la respuesta de la teoría del lenguaje de programación:</target>
        </trans-unit>
        <trans-unit id="869f60d5d93fd508128a38611098256c7978879c" translate="yes" xml:space="preserve">
          <source>There's one extra thing to mention: a function that yields doesn't actually have to terminate. I've written code like this:</source>
          <target state="translated">Hay una cosa extra que mencionar:una función que cede no tiene por qué terminar.He escrito un código como este:</target>
        </trans-unit>
        <trans-unit id="761653d5f6ddfd0071e0c9f8287f586c348d08cd" translate="yes" xml:space="preserve">
          <source>These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.</source>
          <target state="translated">Estos iterables son prácticos porque puedes leerlos tanto como quieras,pero guardas todos los valores en la memoria y esto no es siempre lo que quieres cuando tienes muchos valores.</target>
        </trans-unit>
        <trans-unit id="847e29854b26173ea7127ee888f4830e76ab29e1" translate="yes" xml:space="preserve">
          <source>Think of it this way:</source>
          <target state="translated">Piénsalo de esta manera:</target>
        </trans-unit>
        <trans-unit id="ccd34f995b2f074874396138bbe200b9f454f73e" translate="yes" xml:space="preserve">
          <source>This code actually loops over that array twice! :(</source>
          <target state="translated">¡Este código en realidad hace un bucle sobre esa matriz dos veces!</target>
        </trans-unit>
        <trans-unit id="8d161d7ff1bebc685509da31091434ec70757135" translate="yes" xml:space="preserve">
          <source>This code contains several smart parts:</source>
          <target state="translated">Este código contiene varias partes inteligentes:</target>
        </trans-unit>
        <trans-unit id="95d467a037a72f1d404c008c65683f34bbcb709d" translate="yes" xml:space="preserve">
          <source>This is basically what the Python interpreter does with the above code:</source>
          <target state="translated">Esto es básicamente lo que el intérprete de Python hace con el código anterior:</target>
        </trans-unit>
        <trans-unit id="ea2ea6265215d15078974a1d7665827ca856c901" translate="yes" xml:space="preserve">
          <source>This is because the presence of &lt;code&gt;yield&lt;/code&gt; signaled to Python that you want to create a &lt;em&gt;generator&lt;/em&gt;, that is, an object that generates values on demand.</source>
          <target state="translated">Esto se debe a que la presencia de &lt;code&gt;yield&lt;/code&gt; indic&amp;oacute; a Python que desea crear un &lt;em&gt;generador&lt;/em&gt; , es decir, un objeto que genere valores a pedido.</target>
        </trans-unit>
        <trans-unit id="54444ced92aaabea39a670c4bad4931fb55ea203" translate="yes" xml:space="preserve">
          <source>This is clearly a reasonable iterable whose behavior is well defined -- each time the generator iterates over it, it returns 4 (and does so forever). But it isn't probably the prototypical type of iterable that comes to mind when thinking of iterators (i.e., &lt;code&gt;for x in collection: do_something(x)&lt;/code&gt;). This example illustrates the power of generators: if anything is an iterator, a generator can save the state of its iteration.</source>
          <target state="translated">Este es claramente un iterable razonable cuyo comportamiento est&amp;aacute; bien definido: cada vez que el generador itera sobre &amp;eacute;l, devuelve 4 (y lo hace para siempre). Pero no es probablemente el tipo protot&amp;iacute;pico de iterable que viene a la mente cuando se piensa en iteradores (es decir, &lt;code&gt;for x in collection: do_something(x)&lt;/code&gt; ). Este ejemplo ilustra el poder de los generadores: si algo es un iterador, un generador puede guardar el estado de su iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6b729e4e5167e0f6ea0ad29b09ff6d8212c4d8e9" translate="yes" xml:space="preserve">
          <source>This is how the &quot;Python iteration protocol&quot; works. That is, what is going on when you do &lt;code&gt;list(makeRange(5))&lt;/code&gt;. This is what I describe earlier as a &quot;lazy, incremental list&quot;.</source>
          <target state="translated">As&amp;iacute; es como funciona el &quot;protocolo de iteraci&amp;oacute;n de Python&quot;. Es decir, lo que sucede cuando haces una &lt;code&gt;list(makeRange(5))&lt;/code&gt; . Esto es lo que describ&amp;iacute; anteriormente como una &quot;lista lenta e incremental&quot;.</target>
        </trans-unit>
        <trans-unit id="d3493820819de86b02fd63f645e29ae4e0b50631" translate="yes" xml:space="preserve">
          <source>This is the most simple use case of generators. As you said, it can be used to write efficient permutations, using yield to push things up through the call stack instead of using some sort of stack variable. Generators can also be used for specialized tree traversal, and all manner of other things.</source>
          <target state="translated">Este es el caso de uso más simple de los generadores.Como dijiste,puede ser usado para escribir permutaciones eficientes,usando el rendimiento para empujar las cosas hacia arriba a través de la pila de llamadas en lugar de usar algún tipo de variable de pila.Los generadores también pueden ser utilizados para el cruce de árboles especializados,y todo tipo de otras cosas.</target>
        </trans-unit>
        <trans-unit id="f172eb1953bc01c27cabdd6f9c836e9c3d1d5872" translate="yes" xml:space="preserve">
          <source>This is what a generator does (a function that contains a &lt;code&gt;yield&lt;/code&gt;); it starts executing, pauses whenever it does a &lt;code&gt;yield&lt;/code&gt;, and when asked for a &lt;code&gt;.next()&lt;/code&gt; value it continues from the point it was last. It fits perfectly by design with the iterator protocol of Python, which describes how to sequentially request values.</source>
          <target state="translated">Esto es lo que hace un generador (una funci&amp;oacute;n que contiene un &lt;code&gt;yield&lt;/code&gt; ); comienza a ejecutarse, se detiene cada vez que produce un &lt;code&gt;yield&lt;/code&gt; , y cuando se le solicita un valor &lt;code&gt;.next()&lt;/code&gt; contin&amp;uacute;a desde el punto en que fue el &amp;uacute;ltimo. Encaja perfectamente por dise&amp;ntilde;o con el protocolo iterador de Python, que describe c&amp;oacute;mo solicitar valores secuencialmente.</target>
        </trans-unit>
        <trans-unit id="c64469b38e358bb60db655f2f7dead53a870f525" translate="yes" xml:space="preserve">
          <source>This trick may give you an idea of the logic behind the function, but what actually happens with &lt;code&gt;yield&lt;/code&gt; is significantly different than what happens in the list based approach. In many cases, the yield approach will be a lot more memory efficient and faster too. In other cases, this trick will get you stuck in an infinite loop, even though the original function works just fine. Read on to learn more...</source>
          <target state="translated">Este truco puede darle una idea de la l&amp;oacute;gica detr&amp;aacute;s de la funci&amp;oacute;n, pero lo que realmente sucede con el &lt;code&gt;yield&lt;/code&gt; es significativamente diferente de lo que sucede en el enfoque basado en listas. En muchos casos, el enfoque de rendimiento ser&amp;aacute; mucho m&amp;aacute;s eficiente en memoria y m&amp;aacute;s r&amp;aacute;pido tambi&amp;eacute;n. En otros casos, este truco te atrapar&amp;aacute; en un bucle infinito, aunque la funci&amp;oacute;n original funcione bien. Sigue leyendo para aprender m&amp;aacute;s ...</target>
        </trans-unit>
        <trans-unit id="fe901acdbaffa726773d1aa79c953022a37c87a8" translate="yes" xml:space="preserve">
          <source>This was my first &quot;aha&quot; moment with yield.</source>
          <target state="translated">Este fue mi primer momento &quot;aha&quot; con el rendimiento.</target>
        </trans-unit>
        <trans-unit id="06ea075137bd0bbc68755225020ab2be38ff24de" translate="yes" xml:space="preserve">
          <source>Thus in short, a function with the following code</source>
          <target state="translated">Así,en resumen,una función con el siguiente código</target>
        </trans-unit>
        <trans-unit id="5d4b050e5c318bdd9abdf7fc385ecbec5643af7f" translate="yes" xml:space="preserve">
          <source>Thus, in the unlikely event that you are failing to do something like this...</source>
          <target state="translated">Por lo tanto,en el improbable caso de que usted no haga algo como esto...</target>
        </trans-unit>
        <trans-unit id="af7dabd9ee0abc1597b9509efda1778a58b95bbe" translate="yes" xml:space="preserve">
          <source>To force the generator to immediately return its pending values, you can pass it into &lt;code&gt;list()&lt;/code&gt; (just like you could any iterable):</source>
          <target state="translated">Para forzar al generador a que devuelva inmediatamente sus valores pendientes, puede pasarlo a &lt;code&gt;list()&lt;/code&gt; (tal como lo har&amp;iacute;a con cualquier iterable):</target>
        </trans-unit>
        <trans-unit id="c0114d7058a0e2d82c0d2df0bb48add203549c89" translate="yes" xml:space="preserve">
          <source>To get a better feel for generators, you can play around with the &lt;code&gt;itertools&lt;/code&gt; module (be sure to use &lt;code&gt;chain.from_iterable&lt;/code&gt; rather than &lt;code&gt;chain&lt;/code&gt; when warranted). For example, you might even use generators to implement infinitely-long lazy lists like &lt;code&gt;itertools.count()&lt;/code&gt;. You could implement your own &lt;code&gt;def enumerate(iterable): zip(count(), iterable)&lt;/code&gt;, or alternatively do so with the &lt;code&gt;yield&lt;/code&gt; keyword in a while-loop.</source>
          <target state="translated">Para tener una mejor idea de los generadores, puede jugar con el m&amp;oacute;dulo &lt;code&gt;itertools&lt;/code&gt; (aseg&amp;uacute;rese de usar &lt;code&gt;chain.from_iterable&lt;/code&gt; en lugar de &lt;code&gt;chain&lt;/code&gt; cuando est&amp;eacute; justificado). Por ejemplo, incluso podr&amp;iacute;a usar generadores para implementar listas perezosas infinitamente largas como &lt;code&gt;itertools.count()&lt;/code&gt; . Puede implementar su propio &lt;code&gt;def enumerate(iterable): zip(count(), iterable)&lt;/code&gt; o, alternativamente, hacerlo con la palabra clave de &lt;code&gt;yield&lt;/code&gt; en un ciclo while.</target>
        </trans-unit>
        <trans-unit id="47ee4ff7a14b54f8654a7b96763d1d5353cfb7c7" translate="yes" xml:space="preserve">
          <source>To help understand what a &lt;code&gt;yield&lt;/code&gt; does in the following code, you can use your finger to trace the cycle through any code that has a &lt;code&gt;yield&lt;/code&gt;.  Every time your finger hits the &lt;code&gt;yield&lt;/code&gt;, you have to wait for a &lt;code&gt;next&lt;/code&gt; or a &lt;code&gt;send&lt;/code&gt; to be entered.  When a &lt;code&gt;next&lt;/code&gt; is called, you trace through the code until you hit the &lt;code&gt;yield&lt;/code&gt;&amp;hellip; the code on the right of the &lt;code&gt;yield&lt;/code&gt; is evaluated and returned to the caller&amp;hellip; then you wait.  When &lt;code&gt;next&lt;/code&gt; is called again, you perform another loop through the code.  However, you'll note that in a coroutine, &lt;code&gt;yield&lt;/code&gt; can also be used with a &lt;code&gt;send&lt;/code&gt;&amp;hellip; which will send a value from the caller &lt;em&gt;into&lt;/em&gt; the yielding function. If a &lt;code&gt;send&lt;/code&gt; is given, then &lt;code&gt;yield&lt;/code&gt; receives the value sent, and spits it out the left hand side&amp;hellip; then the trace through the code progresses until you hit the &lt;code&gt;yield&lt;/code&gt; again (returning the value at the end, as if &lt;code&gt;next&lt;/code&gt; was called).</source>
          <target state="translated">Para ayudar a comprender qu&amp;eacute; hace un &lt;code&gt;yield&lt;/code&gt; en el siguiente c&amp;oacute;digo, puede usar su dedo para rastrear el ciclo a trav&amp;eacute;s de cualquier c&amp;oacute;digo que tenga un &lt;code&gt;yield&lt;/code&gt; . Cada vez que su dedo alcanza el &lt;code&gt;yield&lt;/code&gt; , debe esperar a que se ingrese el &lt;code&gt;next&lt;/code&gt; o un &lt;code&gt;send&lt;/code&gt; . Cuando se llama a un &lt;code&gt;next&lt;/code&gt; , rastrea el c&amp;oacute;digo hasta que alcanza el &lt;code&gt;yield&lt;/code&gt; ... el c&amp;oacute;digo a la derecha del &lt;code&gt;yield&lt;/code&gt; se eval&amp;uacute;a y se devuelve a la persona que llama ... luego espera. Cuando se vuelve a llamar a &lt;code&gt;next&lt;/code&gt; , realiza otro ciclo a trav&amp;eacute;s del c&amp;oacute;digo. Sin embargo, notar&amp;aacute; que en una rutina, el &lt;code&gt;yield&lt;/code&gt; tambi&amp;eacute;n se puede usar con un &lt;code&gt;send&lt;/code&gt; ... que enviar&amp;aacute; un valor de la persona que llama &lt;em&gt;a&lt;/em&gt; la funci&amp;oacute;n de rendimiento. Si se &lt;code&gt;send&lt;/code&gt; un env&amp;iacute;o , entonces el &lt;code&gt;yield&lt;/code&gt; recibe el valor enviado, y lo escupe por el lado izquierdo ... luego el rastreo a trav&amp;eacute;s del c&amp;oacute;digo progresa hasta que vuelva a alcanzar el &lt;code&gt;yield&lt;/code&gt; (devolviendo el valor al final, como si se llamara a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="b2f6f90d2c166bfe4363d100db6a325bd8c53d50" translate="yes" xml:space="preserve">
          <source>To implement iterators, generators, and thread pools for concurrent execution, etc. as thunks (also called anonymous functions), one uses messages sent to a closure object, which has a dispatcher, and the dispatcher answers to &quot;messages&quot;.</source>
          <target state="translated">Para implementar los iteradores,generadores y grupos de hilos para la ejecución simultánea,etc.como thunks (también llamados funciones anónimas),se utilizan mensajes enviados a un objeto de cierre,que tiene un despachador,y el despachador responde a los &quot;mensajes&quot;.</target>
        </trans-unit>
        <trans-unit id="9115b0a8c20c76763e2640100aa35118070b6a7e" translate="yes" xml:space="preserve">
          <source>To master &lt;code&gt;yield&lt;/code&gt;, you must understand that &lt;strong&gt;when you call the function, the code you have written in the function body does not run.&lt;/strong&gt; The function only returns the generator object, this is a bit tricky :-)</source>
          <target state="translated">Para dominar el &lt;code&gt;yield&lt;/code&gt; , debe comprender que &lt;strong&gt;cuando llama a la funci&amp;oacute;n, el c&amp;oacute;digo que ha escrito en el cuerpo de la funci&amp;oacute;n no se ejecuta.&lt;/strong&gt; La funci&amp;oacute;n solo devuelve el objeto generador, esto es un poco complicado :-)</target>
        </trans-unit>
        <trans-unit id="7b9662418d3af2db32eb7c9811a63029be459951" translate="yes" xml:space="preserve">
          <source>To reiterate: Continuations can save the state of a program's stack and generators can save the state of iteration. This means that continuations are more a lot powerful than generators, but also that generators are a lot, lot easier. They are easier for the language designer to implement, and they are easier for the programmer to use (if you have some time to burn, try to read and understand &lt;a href=&quot;http://www.madore.org/~david/computers/callcc.html&quot;&gt;this page about continuations and call/cc&lt;/a&gt;).</source>
          <target state="translated">Para reiterar: las continuaciones pueden guardar el estado de la pila de un programa y los generadores pueden guardar el estado de la iteraci&amp;oacute;n. Esto significa que las continuaciones son mucho m&amp;aacute;s poderosas que los generadores, pero tambi&amp;eacute;n que los generadores son mucho m&amp;aacute;s f&amp;aacute;ciles. Son m&amp;aacute;s f&amp;aacute;ciles de implementar para el dise&amp;ntilde;ador de lenguaje, y son m&amp;aacute;s f&amp;aacute;ciles de usar para el programador (si tiene algo de tiempo para grabar, intente leer y comprender &lt;a href=&quot;http://www.madore.org/~david/computers/callcc.html&quot;&gt;esta p&amp;aacute;gina sobre las continuaciones y call / cc&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="855f35ae228f90d1d655b0f84b71dcd8c195b750" translate="yes" xml:space="preserve">
          <source>To understand what &lt;code&gt;yield&lt;/code&gt; does, you must understand what &lt;em&gt;generators&lt;/em&gt; are. And before you can understand generators, you must understand &lt;em&gt;iterables&lt;/em&gt;.</source>
          <target state="translated">Para comprender qu&amp;eacute; &lt;code&gt;yield&lt;/code&gt; produce, debe comprender qu&amp;eacute; son los &lt;em&gt;generadores&lt;/em&gt; . Y antes de que pueda comprender los generadores, debe comprender los &lt;em&gt;iterables&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3e68d29cff9fbdfeadc382da40caa5670dec8b66" translate="yes" xml:space="preserve">
          <source>Try to get a num_list with &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="translated">Intenta obtener una lista num_ con &lt;code&gt;return&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eb3e1a1dbeab210622a6dce745b27ec3fd6ceec" translate="yes" xml:space="preserve">
          <source>Understanding the inner mechanisms of iteration</source>
          <target state="translated">Comprensión de los mecanismos internos de la iteración</target>
        </trans-unit>
        <trans-unit id="4965a83c485d39c529c9df84037bbc4eae475d84" translate="yes" xml:space="preserve">
          <source>User-defined classes that implement &lt;code&gt;__iter__()&lt;/code&gt;.</source>
          <target state="translated">Clases definidas por el usuario que implementan &lt;code&gt;__iter__()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68ac05f8fef6cd332ab57a59a59a7b6765c2f5ba" translate="yes" xml:space="preserve">
          <source>Uses the iterator to loop over items:</source>
          <target state="translated">Utiliza el iterador para hacer un bucle sobre los objetos:</target>
        </trans-unit>
        <trans-unit id="9bbf05762b1e4da7eb5da4e2336f231ae41d9fab" translate="yes" xml:space="preserve">
          <source>Using the built-in &lt;code&gt;next()&lt;/code&gt; function, you directly invoke &lt;code&gt;.next&lt;/code&gt;/&lt;code&gt;__next__&lt;/code&gt;, forcing the generator to produce a value:</source>
          <target state="translated">Usando la funci&amp;oacute;n &lt;code&gt;next()&lt;/code&gt; incorporada, &lt;code&gt;.next&lt;/code&gt; directamente .next / &lt;code&gt;__next__&lt;/code&gt; , forzando al generador a producir un valor:</target>
        </trans-unit>
        <trans-unit id="bcee0bd785aa39b558b7c8bc31ae6f288f6986a3" translate="yes" xml:space="preserve">
          <source>Usually we pass a list to it:</source>
          <target state="translated">Normalmente le pasamos una lista:</target>
        </trans-unit>
        <trans-unit id="3e5ea4b6c7fb3c82481552aaaf2cefbefc296023" translate="yes" xml:space="preserve">
          <source>Usually, you can write code that doesn't use generators but implements the same logic. One option is to use the temporary list 'trick' I mentioned before. That will not work in all cases, for e.g. if you have infinite loops, or it may make inefficient use of memory when you have a really long list. The other approach is to implement a new iterable class SomethingIter that keeps the state in instance members and performs the next logical step in it's next() (or &lt;strong&gt;next&lt;/strong&gt;() in Python 3) method. Depending on the logic, the code inside the next() method may end up looking very complex and be prone to bugs. Here generators provide a clean and easy solution.</source>
          <target state="translated">Por lo general, puede escribir c&amp;oacute;digo que no use generadores pero implemente la misma l&amp;oacute;gica. Una opci&amp;oacute;n es usar la lista temporal 'truco' que mencion&amp;eacute; antes. Eso no funcionar&amp;aacute; en todos los casos, por ejemplo, si tiene bucles infinitos, o puede hacer un uso ineficiente de la memoria cuando tiene una lista realmente larga. El otro enfoque es implementar una nueva clase iterable SomethingIter que mantenga el estado en los miembros de la instancia y realice el siguiente paso l&amp;oacute;gico en su m&amp;eacute;todo next () (o &lt;strong&gt;next&lt;/strong&gt; () en Python 3). Dependiendo de la l&amp;oacute;gica, el c&amp;oacute;digo dentro del m&amp;eacute;todo next () puede terminar pareciendo muy complejo y propenso a errores. Aqu&amp;iacute; los generadores proporcionan una soluci&amp;oacute;n limpia y f&amp;aacute;cil.</target>
        </trans-unit>
        <trans-unit id="b60b494a256a412f7ab8c496c30174516878d2d5" translate="yes" xml:space="preserve">
          <source>What does the “yield” keyword do</source>
          <target state="translated">¿Qué hace la palabra clave &quot;ceder&quot;?</target>
        </trans-unit>
        <trans-unit id="8564153bf26487e9c47a7a365dd4a37cb1949c87" translate="yes" xml:space="preserve">
          <source>What happens when the method &lt;code&gt;_get_child_candidates&lt;/code&gt; is called?
Is a list returned? A single element? Is it called again? When will subsequent calls stop?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; sucede cuando se llama al m&amp;eacute;todo &lt;code&gt;_get_child_candidates&lt;/code&gt; ? &amp;iquest;Se devuelve una lista? &amp;iquest;Un solo elemento? &amp;iquest;Se llama de nuevo? &amp;iquest;Cu&amp;aacute;ndo se detendr&amp;aacute;n las llamadas posteriores?</target>
        </trans-unit>
        <trans-unit id="1b4f84d352af15ddc950c1b08d4d361ed4f38885" translate="yes" xml:space="preserve">
          <source>What is the use of the &lt;code&gt;yield&lt;/code&gt; keyword in Python, and what does it do?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es el uso de la palabra clave de &lt;code&gt;yield&lt;/code&gt; en Python y qu&amp;eacute; hace?</target>
        </trans-unit>
        <trans-unit id="a3a6372570b3576b2b5dd78ff44c4dd57682334c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;next()&lt;/code&gt; is called subsequently, it retrieves the function's belongings onto the stack and re-animates it. The function continues to compute from where it left off, oblivious to the fact that it had just spent an eternity in cold storage.</source>
          <target state="translated">Cuando se llama a &lt;code&gt;next()&lt;/code&gt; posteriormente, recupera las pertenencias de la funci&amp;oacute;n en la pila y la vuelve a animar. La funci&amp;oacute;n contin&amp;uacute;a calculando desde donde se detuvo, ajena al hecho de que acababa de pasar una eternidad en almacenamiento en fr&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="0aca1dde96511b6083cb83899e9046f371ad1461" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;yield&lt;/code&gt; is used instead of a &lt;code&gt;return&lt;/code&gt; in a python function, that function is turned into something special called &lt;code&gt;generator function&lt;/code&gt;. That function will return an object of &lt;code&gt;generator&lt;/code&gt; type. &lt;strong&gt;The &lt;code&gt;yield&lt;/code&gt; keyword is a flag to notify the python compiler to treat such function specially.&lt;/strong&gt; Normal functions will terminate once some value is returned from it. But with the help of the compiler, the generator function &lt;strong&gt;can be thought of&lt;/strong&gt; as resumable. That is, the execution context will be restored and the execution will continue from last run. Until you explicitly call return, which will raise a &lt;code&gt;StopIteration&lt;/code&gt; exception (which is also part of the iterator protocol), or reach the end of the function. I found a lot of references about &lt;code&gt;generator&lt;/code&gt; but this &lt;a href=&quot;https://docs.python.org/dev/howto/functional.html#generators&quot;&gt;one&lt;/a&gt; from the &lt;code&gt;functional programming perspective&lt;/code&gt; is the most digestable.</source>
          <target state="translated">Cuando se usa el &lt;code&gt;yield&lt;/code&gt; lugar de un &lt;code&gt;return&lt;/code&gt; en una funci&amp;oacute;n python, esa funci&amp;oacute;n se convierte en algo especial llamado &lt;code&gt;generator function&lt;/code&gt; . Esa funci&amp;oacute;n devolver&amp;aacute; un objeto de tipo &lt;code&gt;generator&lt;/code&gt; . &lt;strong&gt;La palabra clave de &lt;code&gt;yield&lt;/code&gt; es una bandera para notificar al compilador de Python para tratar dicha funci&amp;oacute;n especialmente.&lt;/strong&gt; Las funciones normales finalizar&amp;aacute;n una vez que se devuelva alg&amp;uacute;n valor. Pero con la ayuda del compilador, la funci&amp;oacute;n del generador &lt;strong&gt;puede considerarse&lt;/strong&gt; como reanudable. Es decir, el contexto de ejecuci&amp;oacute;n se restaurar&amp;aacute; y la ejecuci&amp;oacute;n continuar&amp;aacute; desde la &amp;uacute;ltima ejecuci&amp;oacute;n. Hasta que llame expl&amp;iacute;citamente a return, que generar&amp;aacute; una excepci&amp;oacute;n &lt;code&gt;StopIteration&lt;/code&gt; (que tambi&amp;eacute;n es parte del protocolo iterador), o llegar&amp;aacute; al final de la funci&amp;oacute;n. Encontr&amp;eacute; muchas referencias sobre el &lt;code&gt;generator&lt;/code&gt; pero esta desde la &lt;code&gt;functional programming perspective&lt;/code&gt; es la m&amp;aacute;s digerible.</target>
        </trans-unit>
        <trans-unit id="b4956520f1ca1888af160527fdbeadaee79d2a28" translate="yes" xml:space="preserve">
          <source>When a normal function is called, it puts its local variables on the stack, does some computation, then clears the stack and returns. The values of its local variables are never seen again.</source>
          <target state="translated">Cuando se llama una función normal,pone sus variables locales en la pila,hace algunos cálculos,luego borra la pila y regresa.Los valores de sus variables locales no se vuelven a ver nunca más.</target>
        </trans-unit>
        <trans-unit id="958c8511d450491ba26702ca0bd0c2811dde47aa" translate="yes" xml:space="preserve">
          <source>When we call the second function, it behaves very differently to the first. The &lt;code&gt;yield&lt;/code&gt; statement might be unreachable, but if it's present anywhere, it changes the nature of what we're dealing with.</source>
          <target state="translated">Cuando llamamos a la segunda funci&amp;oacute;n, se comporta de manera muy diferente a la primera. La declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; puede ser inalcanzable, pero si est&amp;aacute; presente en alg&amp;uacute;n lugar, cambia la naturaleza de lo que estamos tratando.</target>
        </trans-unit>
        <trans-unit id="550768170ef01550f901dfdde3779cde4dea9c6b" translate="yes" xml:space="preserve">
          <source>When you create a list, you can read its items one by one. Reading its items one by one is called iteration:</source>
          <target state="translated">Cuando creas una lista,puedes leer sus elementos uno por uno.La lectura de sus elementos uno por uno se llama iteración:</target>
        </trans-unit>
        <trans-unit id="3b7f697cea53ab4cee00328eb8586bf8e9cddc3b" translate="yes" xml:space="preserve">
          <source>When you enter this into your REPL and then try and call it, you'll get a mystifying result:</source>
          <target state="translated">Cuando lo introduzcas en tu REPL y luego intentes llamarlo,obtendrás un resultado desconcertante:</target>
        </trans-unit>
        <trans-unit id="0e20678b0bb4c25b8fa4c7b3b518c72e5245ebc8" translate="yes" xml:space="preserve">
          <source>When you first invoke &lt;code&gt;fib&lt;/code&gt; by calling it:</source>
          <target state="translated">Cuando &lt;code&gt;fib&lt;/code&gt; por primera vez fib llam&amp;aacute;ndolo:</target>
        </trans-unit>
        <trans-unit id="b514c61a51b4ead83e3fa823a9f1c657b29464d0" translate="yes" xml:space="preserve">
          <source>When you request an iterator from a list, it creates a new iterator. However, when you request an iterator from an iterator (which you would rarely do), it just gives you a copy of itself.</source>
          <target state="translated">Cuando se solicita un iterador de una lista,se crea un nuevo iterador.Sin embargo,cuando solicitas un iterador de un iterador (lo cual raramente harías),sólo te da una copia de sí mismo.</target>
        </trans-unit>
        <trans-unit id="b7cc0f0bf3ed5fc052470ce219aa6f3e30a8013e" translate="yes" xml:space="preserve">
          <source>When you see a function with &lt;code&gt;yield&lt;/code&gt; statements, apply this easy trick to understand what will happen:</source>
          <target state="translated">Cuando vea una funci&amp;oacute;n con declaraciones de &lt;code&gt;yield&lt;/code&gt; , aplique este sencillo truco para comprender lo que suceder&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="2f6c491a0995ee077800eec24720b11c6e7f2988" translate="yes" xml:space="preserve">
          <source>When you then request it generates the first value, directly or indirectly, it executes all statements that it finds, until it encounters a &lt;code&gt;yield&lt;/code&gt;, it then yields back the value you supplied to &lt;code&gt;yield&lt;/code&gt; and pauses. For an example that better demonstrates this, let's use some &lt;code&gt;print&lt;/code&gt; calls (replace with &lt;code&gt;print &quot;text&quot;&lt;/code&gt; if on Python 2):</source>
          <target state="translated">Cuando solicita que genere el primer valor, directa o indirectamente, ejecuta todas las declaraciones que encuentra, hasta que encuentra un &lt;code&gt;yield&lt;/code&gt; , luego devuelve el valor que proporcion&amp;oacute; para &lt;code&gt;yield&lt;/code&gt; y hace una pausa. Para un ejemplo que demuestre esto mejor, usemos algunas llamadas de &lt;code&gt;print&lt;/code&gt; (reemplace con &lt;code&gt;print &quot;text&quot;&lt;/code&gt; si est&amp;aacute; en Python 2):</target>
        </trans-unit>
        <trans-unit id="224be01d8e5c7c05d7fa83727c243ea08c1b6325" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;yield&lt;/code&gt; is called, it tells the function to return a continuation.  When the function is called again, it starts from wherever it left off. So, in pseudo-pseudocode (i.e., not pseudocode, but not code) the generator's &lt;code&gt;next&lt;/code&gt; method is basically as follows:</source>
          <target state="translated">Cada vez que se llama &lt;code&gt;yield&lt;/code&gt; , le dice a la funci&amp;oacute;n que devuelva una continuaci&amp;oacute;n. Cuando se vuelve a llamar a la funci&amp;oacute;n, comienza desde donde la dej&amp;oacute;. Entonces, en pseudo-pseudoc&amp;oacute;digo (es decir, no pseudoc&amp;oacute;digo, pero no c&amp;oacute;digo), el &lt;code&gt;next&lt;/code&gt; m&amp;eacute;todo del generador es b&amp;aacute;sicamente el siguiente:</target>
        </trans-unit>
        <trans-unit id="f26fb14b01ccba778163556c3df5281b63e8507c" translate="yes" xml:space="preserve">
          <source>Whenever you find yourself building a list from scratch, &lt;code&gt;yield&lt;/code&gt; each piece instead.</source>
          <target state="translated">Cada vez que te encuentres construyendo una lista desde cero, &lt;code&gt;yield&lt;/code&gt; cada pieza en su lugar.</target>
        </trans-unit>
        <trans-unit id="365379f34df99ca9b0a193c6b7d8ec4a2986c91d" translate="yes" xml:space="preserve">
          <source>While a lot of answers show why you'd use a &lt;code&gt;yield&lt;/code&gt; to create a generator, there are more uses for &lt;code&gt;yield&lt;/code&gt;.  It's quite easy to make a coroutine, which enables the passing of information between two blocks of code.  I won't repeat any of the fine examples that have already been given about using &lt;code&gt;yield&lt;/code&gt; to create a generator.</source>
          <target state="translated">Si bien muchas respuestas muestran por qu&amp;eacute; usar&amp;iacute;a un &lt;code&gt;yield&lt;/code&gt; para crear un generador, hay m&amp;aacute;s usos para el &lt;code&gt;yield&lt;/code&gt; . Es bastante f&amp;aacute;cil hacer una rutina, que permite el paso de informaci&amp;oacute;n entre dos bloques de c&amp;oacute;digo. No repetir&amp;eacute; ninguno de los buenos ejemplos que ya se han dado sobre el uso del &lt;code&gt;yield&lt;/code&gt; para crear un generador.</target>
        </trans-unit>
        <trans-unit id="08166f360bf5ae486bc24968f9bf3f260bd29d10" translate="yes" xml:space="preserve">
          <source>Why Use Generators?</source>
          <target state="translated">¿Por qué usar generadores?</target>
        </trans-unit>
        <trans-unit id="2bba704c3c5538921356a3f491c4600284327828" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;yield&lt;/code&gt; function, when its code begins to run (i.e. after the function is called, returning a generator object, whose &lt;code&gt;next()&lt;/code&gt; method is then invoked), it similarly puts its local variables onto the stack and computes for a while. But then, when it hits the &lt;code&gt;yield&lt;/code&gt; statement, before clearing its part of the stack and returning, it takes a snapshot of its local variables and stores them in the generator object. It also writes down the place where it's currently up to in its code (i.e. the particular &lt;code&gt;yield&lt;/code&gt; statement).</source>
          <target state="translated">Con una funci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; , cuando su c&amp;oacute;digo comienza a ejecutarse (es decir, despu&amp;eacute;s de que se llama a la funci&amp;oacute;n, devolviendo un objeto generador, cuyo m&amp;eacute;todo &lt;code&gt;next()&lt;/code&gt; se invoca), coloca sus variables locales de manera similar en la pila y calcula durante un tiempo. Pero luego, cuando llega a la declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; , antes de borrar su parte de la pila y regresar, toma una instant&amp;aacute;nea de sus variables locales y las almacena en el objeto generador. Tambi&amp;eacute;n escribe el lugar donde est&amp;aacute; actualmente en su c&amp;oacute;digo (es decir, la declaraci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; particular).</target>
        </trans-unit>
        <trans-unit id="8425e30a55cb65d01335e276892c145cda45d14d" translate="yes" xml:space="preserve">
          <source>Yay - no more &lt;code&gt;yield&lt;/code&gt; statements! Read and figure out code.</source>
          <target state="translated">Yay, &amp;iexcl;no m&amp;aacute;s declaraciones de &lt;code&gt;yield&lt;/code&gt; ! Leer y descifrar el c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="33b0fd0f74faa27daf44c1c690d408e467aa0dd1" translate="yes" xml:space="preserve">
          <source>Yield</source>
          <target state="translated">Yield</target>
        </trans-unit>
        <trans-unit id="48f955098d7be7968cf5c16d1f085bb59f48b670" translate="yes" xml:space="preserve">
          <source>Yield gives you a generator.</source>
          <target state="translated">El rendimiento te da un generador.</target>
        </trans-unit>
        <trans-unit id="cacdcd91fde152ba93b046096635f8dd9f810e6b" translate="yes" xml:space="preserve">
          <source>Yield is &lt;strong&gt;lazy&lt;/strong&gt;, it puts off computation. A function with a yield in it &lt;em&gt;doesn't actually execute at all when you call it.&lt;/em&gt; It returns an &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#yieldexpr&quot;&gt;iterator object&lt;/a&gt; that remembers where it left off. Each time you call &lt;code&gt;next()&lt;/code&gt; on the iterator (this happens in a for-loop) execution inches forward to the next yield. &lt;code&gt;return&lt;/code&gt; raises StopIteration and ends the series (this is the natural end of a for-loop).</source>
          <target state="translated">El rendimiento es &lt;strong&gt;perezoso&lt;/strong&gt; , pospone el c&amp;aacute;lculo. Una funci&amp;oacute;n con un rendimiento &lt;em&gt;no se ejecuta en absoluto cuando la llamas.&lt;/em&gt; Devuelve un &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#yieldexpr&quot;&gt;objeto iterador&lt;/a&gt; que recuerda d&amp;oacute;nde lo dej&amp;oacute;. Cada vez que llama a &lt;code&gt;next()&lt;/code&gt; en el iterador (esto sucede en un bucle for) la ejecuci&amp;oacute;n avanza pulgadas hasta el siguiente rendimiento. &lt;code&gt;return&lt;/code&gt; eleva StopIteration y finaliza la serie (este es el final natural de un ciclo for).</target>
        </trans-unit>
        <trans-unit id="ba1346186897dbbfeb506927791cbf680a8824df" translate="yes" xml:space="preserve">
          <source>Yield is &lt;strong&gt;single-pass&lt;/strong&gt;: you can only iterate through once. When a function has a yield in it we call it a &lt;a href=&quot;https://stackoverflow.com/a/1756342/673991&quot;&gt;generator function&lt;/a&gt;. And an &lt;a href=&quot;https://stackoverflow.com/a/9884501/673991&quot;&gt;iterator&lt;/a&gt; is what it returns. Those terms are revealing. We lose the convenience of a container, but gain the power of a series that's computed as needed, and arbitrarily long.</source>
          <target state="translated">El rendimiento es de un &lt;strong&gt;solo paso&lt;/strong&gt; : solo puede iterar una vez. Cuando una funci&amp;oacute;n tiene un rendimiento, la llamamos &lt;a href=&quot;https://stackoverflow.com/a/1756342/673991&quot;&gt;funci&amp;oacute;n generadora&lt;/a&gt; . Y un &lt;a href=&quot;https://stackoverflow.com/a/9884501/673991&quot;&gt;iterador&lt;/a&gt; es lo que devuelve. Esos t&amp;eacute;rminos son reveladores. Perdemos la comodidad de un contenedor, pero obtenemos el poder de una serie que se calcula seg&amp;uacute;n sea necesario y arbitrariamente larga.</target>
        </trans-unit>
        <trans-unit id="8eb3142ec6ce40811e7cb41ff05374c2da24d165" translate="yes" xml:space="preserve">
          <source>Yield is &lt;strong&gt;versatile&lt;/strong&gt;. Data doesn't have to be stored all together, it can be made available one at a time. It can be infinite.</source>
          <target state="translated">El rendimiento es &lt;strong&gt;vers&amp;aacute;til&lt;/strong&gt; . Los datos no tienen que almacenarse todos juntos, pueden estar disponibles uno a la vez. Puede ser infinito.</target>
        </trans-unit>
        <trans-unit id="42e3a00c8f296b5fa17180ed67b9949807587502" translate="yes" xml:space="preserve">
          <source>You can also throw an exception which can be handled in the generator
or propagated back to the user:</source>
          <target state="translated">También puede lanzar una excepción que puede ser manejada en el generador o propagada al usuario:</target>
        </trans-unit>
        <trans-unit id="3ad9323c26f58229cc6c89459957a3157bf59a21" translate="yes" xml:space="preserve">
          <source>You can read more about the precise semantics of &lt;code&gt;yield from&lt;/code&gt; in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/#formal-semantics&quot;&gt;PEP 380.&lt;/a&gt;</source>
          <target state="translated">Puede leer m&amp;aacute;s sobre la sem&amp;aacute;ntica precisa del &lt;code&gt;yield from&lt;/code&gt; en &lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/#formal-semantics&quot;&gt;PEP 380.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="170b20ccfec99da9235a6ef28068af3e2591fc27" translate="yes" xml:space="preserve">
          <source>You can stop here, or read a little bit to see an advanced use of a generator:</source>
          <target state="translated">Puedes parar aquí,o leer un poco para ver un uso avanzado de un generador:</target>
        </trans-unit>
        <trans-unit id="56ff330d6def0407146a91a863f8fc2587a5c6d6" translate="yes" xml:space="preserve">
          <source>You can use it in your code as follows:</source>
          <target state="translated">Puedes usarlo en tu código de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="82929aa8decc455ab58ff5e64314ac91e1a3d659" translate="yes" xml:space="preserve">
          <source>You create an array that you only use once (this wastes memory)</source>
          <target state="translated">Creas una matriz que sólo se usa una vez (esto desperdicia la memoria)</target>
        </trans-unit>
        <trans-unit id="e5238c336d39149ce635875c88df949f1a84273e" translate="yes" xml:space="preserve">
          <source>You don't need to read the values twice.</source>
          <target state="translated">No necesitas leer los valores dos veces.</target>
        </trans-unit>
        <trans-unit id="02fbf8c8568af6ce36580f6ee74a1c505f605eb0" translate="yes" xml:space="preserve">
          <source>You may have a lot of children and you don't want them all stored in memory.</source>
          <target state="translated">Puede que tengas muchos hijos y no quieres que todos se guarden en la memoria.</target>
        </trans-unit>
        <trans-unit id="e5126053bf6eeea52bae61ffbf604541a9b1ae8d" translate="yes" xml:space="preserve">
          <source>You will always get [0, 1, 2] from a list object but only could retrieve them from 'the object &lt;code&gt;yield&lt;/code&gt; output' once. So, it has a new name &lt;code&gt;generator&lt;/code&gt; object as displayed in &lt;code&gt;Out[11]: &amp;lt;generator object num_list at 0x10327c990&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Siempre obtendr&amp;aacute; [0, 1, 2] de un objeto de lista, pero solo podr&amp;aacute; recuperarlos de 'la salida de &lt;code&gt;yield&lt;/code&gt; del objeto' una vez. Por lo tanto, tiene un nuevo objeto &lt;code&gt;generator&lt;/code&gt; nombres como se muestra en &lt;code&gt;Out[11]: &amp;lt;generator object num_list at 0x10327c990&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f8b14bde35e7bc3becf466f732823047f257702" translate="yes" xml:space="preserve">
          <source>You'll have to make another if you want to use its functionality again (see footnote 2):</source>
          <target state="translated">Tendrás que hacer otro si quieres usar su funcionalidad de nuevo (ver nota 2):</target>
        </trans-unit>
        <trans-unit id="7ea7dca3eb3be682f93182ec4cb7bfa2d14d36ad" translate="yes" xml:space="preserve">
          <source>Your code explained</source>
          <target state="translated">Tu código explicó</target>
        </trans-unit>
        <trans-unit id="4c58039107bd67500d2d3318769f8f423735fd2d" translate="yes" xml:space="preserve">
          <source>[This is the step most people forget to tell you about]</source>
          <target state="translated">[Este es el paso del que la mayoría de la gente olvida hablarte]</target>
        </trans-unit>
        <trans-unit id="822a8e24b36ceb4904c03d9fb614f6c229c4b157" translate="yes" xml:space="preserve">
          <source>and use it like this;</source>
          <target state="translated">y lo usan así;</target>
        </trans-unit>
        <trans-unit id="a77a5320b0aaedb8d68bfda55fda0542b3d92a2f" translate="yes" xml:space="preserve">
          <source>build a series of stuff</source>
          <target state="translated">construir una serie de cosas</target>
        </trans-unit>
        <trans-unit id="d3e0b619b3729b20359ab7068cacec3bc130b31e" translate="yes" xml:space="preserve">
          <source>continuations</source>
          <target state="translated">continuations</target>
        </trans-unit>
        <trans-unit id="8225801242495db96d7b6f7c5559aeb4cf7bcbd2" translate="yes" xml:space="preserve">
          <source>do this:</source>
          <target state="translated">hacer esto:</target>
        </trans-unit>
        <trans-unit id="70098eefec2efcfcd1042865cc5c5b7d99f6abcc" translate="yes" xml:space="preserve">
          <source>eventually, you might come to an end. You don't tell me a number; you just shout, &quot;hold your horses! I'm done! No more numbers!&quot;</source>
          <target state="translated">eventualmente,podrías llegar a un final.No me dices un número;sólo gritas,&quot;¡deténgase! ¡Ya he terminado! ¡No más números!&quot;</target>
        </trans-unit>
        <trans-unit id="4920bb1daf53da0a3e71fa2a9e6eb26483536f6d" translate="yes" xml:space="preserve">
          <source>it doesn't matter if &lt;code&gt;sequence&lt;/code&gt; is a list, a string, a dictionary or a generator &lt;em&gt;object&lt;/em&gt; like described above; the result is the same: you read items off a sequence one by one.</source>
          <target state="translated">no importa si la &lt;code&gt;sequence&lt;/code&gt; es una lista, una cadena, un diccionario o un &lt;em&gt;objeto&lt;/em&gt; generador como se describe anteriormente; el resultado es el mismo: lee los elementos de una secuencia uno por uno.</target>
        </trans-unit>
        <trans-unit id="3fc77b0bc00895bd9fb6a9b4c27987e556677c13" translate="yes" xml:space="preserve">
          <source>like barrier in the CUDA language, it will not transfer control until it gets
  completed.</source>
          <target state="translated">como barrera en el lenguaje CUDA,no transferirá el control hasta que se complete.</target>
        </trans-unit>
        <trans-unit id="75e2309b5e1075332554d77f44b43d1c7f6a103e" translate="yes" xml:space="preserve">
          <source>simply outputs</source>
          <target state="translated">simplemente salidas</target>
        </trans-unit>
        <trans-unit id="7f9590246b59001286048a3a2c09550745ee2ab7" translate="yes" xml:space="preserve">
          <source>to avoid coroutines being confused with a regular generator (today &lt;code&gt;yield&lt;/code&gt; is used in both).</source>
          <target state="translated">para evitar que las corutinas se confundan con un generador regular (hoy se usa el &lt;code&gt;yield&lt;/code&gt; en ambos).</target>
        </trans-unit>
        <trans-unit id="2c520454aaae8b0b40814f37e538a2a4da92490e" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;yield&lt;/code&gt; keyword is actually syntactic sugar for the real generator function, basically something like:</source>
          <target state="translated">donde la palabra clave de &lt;code&gt;yield&lt;/code&gt; es en realidad az&amp;uacute;car sint&amp;aacute;ctica para la funci&amp;oacute;n de generador real, b&amp;aacute;sicamente algo como:</target>
        </trans-unit>
        <trans-unit id="d893c24989b32aee817b8346e7ad376f369b2d24" translate="yes" xml:space="preserve">
          <source>will print</source>
          <target state="translated">se imprimirá</target>
        </trans-unit>
        <trans-unit id="4ebe44985fd81b0255b36a096600873c8ed8bf99" translate="yes" xml:space="preserve">
          <source>you have a generator object now waiting for a command for it to generate a value. Use &lt;code&gt;next&lt;/code&gt; and see what get's printed:</source>
          <target state="translated">ahora tiene un objeto generador esperando un comando para que genere un valor. Use a &lt;code&gt;next&lt;/code&gt; y vea lo que se imprime:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
