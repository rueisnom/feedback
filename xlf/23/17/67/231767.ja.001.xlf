<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/231767">
    <body>
      <group id="231767">
        <trans-unit id="3ab3cb492545479a81b590f95c9c450455ddcdb4" translate="yes" xml:space="preserve">
          <source>&quot;&lt;em&gt;next&lt;/em&gt;&quot; is a message sent to a closure, created by the &quot;&lt;em&gt;iter&lt;/em&gt;&quot; call.</source>
          <target state="translated">「 &lt;em&gt;next&lt;/em&gt; 」は、「 &lt;em&gt;iter&lt;/em&gt; 」呼び出しによって作成された、クロージャーに送信されるメッセージです。</target>
        </trans-unit>
        <trans-unit id="1c0a4cfbcf63e8fb4ae3a319aeb3fe7f9e9106c2" translate="yes" xml:space="preserve">
          <source>&amp;hellip; repeat previous step, until&amp;hellip;</source>
          <target state="translated">&amp;hellip;まで、前のステップを繰り返します&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="a6bd3f8f802396a1fb3f884b82392e785e8a7356" translate="yes" xml:space="preserve">
          <source>(Appendix critiques a couple of answers, including the top one, and discusses the use of &lt;code&gt;return&lt;/code&gt; in a generator.)</source>
          <target state="translated">（付録では、上位のものを含むいくつかの回答を批評し、ジェネレーターでの &lt;code&gt;return&lt;/code&gt; の使用について説明しています。）</target>
        </trans-unit>
        <trans-unit id="911bcad209bd54af6df884267feb81dcf90ade83" translate="yes" xml:space="preserve">
          <source>(My below answer only speaks from the perspective of using Python generator, not the &lt;a href=&quot;https://stackoverflow.com/questions/8389812/how-are-generators-and-coroutines-implemented-in-cpython&quot;&gt;underlying implementation of generator mechanism&lt;/a&gt;, which involves some tricks of stack and heap manipulation.)</source>
          <target state="translated">（以下の私の回答は、Pythonジェネレーターの使用の観点からのみ述べており、スタックとヒープ操作のいくつかのトリックを伴う&lt;a href=&quot;https://stackoverflow.com/questions/8389812/how-are-generators-and-coroutines-implemented-in-cpython&quot;&gt;ジェネレーターメカニズムの基礎となる実装ではあり&lt;/a&gt;ません。）</target>
        </trans-unit>
        <trans-unit id="afb37c24b5b881de80de7247dc75c21ceafe07ec" translate="yes" xml:space="preserve">
          <source>(Now I want to talk about the rationale behind &lt;code&gt;generator&lt;/code&gt;, and the &lt;code&gt;iterator&lt;/code&gt; based on my own understanding. I hope this can help you grasp the &lt;strong&gt;&lt;em&gt;essential motivation&lt;/em&gt;&lt;/strong&gt; of iterator and generator. Such concept shows up in other languages as well such as C#.)</source>
          <target state="translated">（私は &lt;code&gt;generator&lt;/code&gt; 背後にある理論的根拠と自分の理解に基づいた &lt;code&gt;iterator&lt;/code&gt; について話したいと思います 。これがイテレーターとジェネレーターの&lt;strong&gt;&lt;em&gt;本質的な動機&lt;/em&gt;&lt;/strong&gt;を理解するのに役立つことを願っています。このような概念は、C＃などの他の言語にも現れます。）</target>
        </trans-unit>
        <trans-unit id="adc9c0af7e633a543a37a61fedbb4daccf85e945" translate="yes" xml:space="preserve">
          <source>(and specifically a type of coroutine, but continuations represent the more general mechanism to understand what is going on).</source>
          <target state="translated">(そして、具体的にはコルーチンの一種であるが、継続は何が起こっているかを理解するためのより一般的なメカニズムを表している)。</target>
        </trans-unit>
        <trans-unit id="5375d7ac510abd4ae6e424a7dc969f2441dd692e" translate="yes" xml:space="preserve">
          <source>--  Nick Coghlan   |   ncoghlan at gmail.com   |   Brisbane, Australia</source>
          <target state="translated">ncoghlan at gmail.com</target>
        </trans-unit>
        <trans-unit id="62855b351e703dcbddfc4ef993d2891ccb386e20" translate="yes" xml:space="preserve">
          <source>... then remember that a generator is an &lt;em&gt;iterator&lt;/em&gt;; that is, it is one-time-use. If you want to reuse it, you should call &lt;code&gt;myRange(...)&lt;/code&gt; again. If you need to use the result twice, convert the result to a list and store it in a variable &lt;code&gt;x = list(myRange(5))&lt;/code&gt;. Those who absolutely need to clone a generator (for example, who are doing terrifyingly hackish metaprogramming) can use &lt;a href=&quot;https://docs.python.org/2/library/itertools.html#itertools.tee&quot;&gt;&lt;code&gt;itertools.tee&lt;/code&gt;&lt;/a&gt; if absolutely necessary, since the copyable iterator Python &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_Enhancement_Proposal#Development&quot;&gt;PEP&lt;/a&gt; standards proposal has been deferred.</source>
          <target state="translated">...次に、ジェネレータは&lt;em&gt;イテレータ&lt;/em&gt;であることを思い出してください。 つまり、使い捨てです。 再利用する場合は、 &lt;code&gt;myRange(...)&lt;/code&gt; を再度呼び出す必要があります。 結果を2回使用する必要がある場合は、結果をリストに変換し、それを変数 &lt;code&gt;x = list(myRange(5))&lt;/code&gt; ます。 コピー可能なイテレータPython &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_Enhancement_Proposal#Development&quot;&gt;PEP&lt;/a&gt;標準の提案が延期されているため、ジェネレータのクローンを絶対に作成する必要がある場合（恐ろしくハッキーなメタプログラミングを行う場合など）は、絶対に必要な場合は&lt;a href=&quot;https://docs.python.org/2/library/itertools.html#itertools.tee&quot;&gt; &lt;code&gt;itertools.tee&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="164d0459345ae6f00bc812c7394f8917ff09c4bc" translate="yes" xml:space="preserve">
          <source>...provide the next data in the series.</source>
          <target state="translated">...シリーズの次のデータを提供します。</target>
        </trans-unit>
        <trans-unit id="391e35abadb8cf99afd59f9fdc30216a58ce407f" translate="yes" xml:space="preserve">
          <source>...relinquish CPU execution until the iterator advances.</source>
          <target state="translated">...イテレータが進むまでCPUの実行を放棄します。</target>
        </trans-unit>
        <trans-unit id="1827a89fdabc2940a265095fb52eea3cd75fc746" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This step corresponds to &lt;code&gt;def&lt;/code&gt;ining the generator function, i.e. the function containing a &lt;code&gt;yield&lt;/code&gt;.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;このステップは、ジェネレーター関数、つまり、 &lt;code&gt;yield&lt;/code&gt; を含む関数の定義に対応します。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="22db8f278d2cf3273c51bb64d7f5260d4584c88d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This step corresponds to calling &lt;code&gt;.next()&lt;/code&gt; on the generator object.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;この手順は、ジェネレータオブジェクトで &lt;code&gt;.next()&lt;/code&gt; を呼び出すことに対応します。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="721dffe48ec31d738fb17ec67ecedf85cc9ef1cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This step corresponds to calling the generator function which returns a generator object.&lt;/b&gt; Note that you don't tell me any numbers yet; you just grab your paper and pencil.</source>
          <target state="translated">&lt;b&gt;このステップは、ジェネレーターオブジェクトを返すジェネレーター関数の呼び出しに対応します。&lt;/b&gt; まだ数値を教えていないことに注意してください。 紙と鉛筆をつかむだけです。</target>
        </trans-unit>
        <trans-unit id="b9a955eec36cf4b6c9a4e64ce4bf09d433135e6a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This step corresponds to the generator object ending its job, and raising a &lt;code&gt;StopIteration&lt;/code&gt; exception&lt;/b&gt; The generator function does not need to raise the exception. It's raised automatically when the function ends or issues a &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;このステップは、ジョブを終了し、 &lt;code&gt;StopIteration&lt;/code&gt; 例外を発生させるジェネレーターオブジェクトに対応します&lt;/b&gt; 。ジェネレーター関数は&lt;b&gt;例外を&lt;/b&gt;発生させる必要はありません。 関数が終了したとき、または &lt;code&gt;return&lt;/code&gt; を発行したときに自動的に発生します。</target>
        </trans-unit>
        <trans-unit id="f08ebcf021089bec1572b041eac525a374a0d033" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list.extend&lt;/code&gt; calls an iterator until it's exhausted. In the case of the code sample you posted, it would be much clearer to just return a tuple and append that to the list.</source>
          <target state="translated">&lt;code&gt;list.extend&lt;/code&gt; は、使い尽くされるまでイテレータを呼び出します。 投稿したコードサンプルの場合、タプルを返してリストに追加するほうがはるかに明確です。</target>
        </trans-unit>
        <trans-unit id="5fea5fac7cbf1b26fe6763d6386ee47d486dbda6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list&lt;/code&gt; and &lt;code&gt;generator&lt;/code&gt; are twins</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; と &lt;code&gt;generator&lt;/code&gt; は双子です</target>
        </trans-unit>
        <trans-unit id="9902af71eb478ea1b302fe4da1da7cf183f39ef8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mylist&lt;/code&gt; is an &lt;em&gt;iterable&lt;/em&gt;. When you use a list comprehension, you create a list, and so an iterable:</source>
          <target state="translated">&lt;code&gt;mylist&lt;/code&gt; は&lt;em&gt;反復可能&lt;/em&gt;です。 リスト内包表記を使用すると、リストが作成されるため、反復可能になります。</target>
        </trans-unit>
        <trans-unit id="38f4e38094ba58e67ca37899086f5ea94d637159" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt; are twins</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; と &lt;code&gt;yield&lt;/code&gt; は双子です</target>
        </trans-unit>
        <trans-unit id="7b01d9479576f8dc8ce3cf24ecbd8c38827200bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; forms an expression that allows data to be sent into the generator (see footnote 3)</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; は、データをジェネレーターに送信できるようにする式を形成します（脚注3を参照）。</target>
        </trans-unit>
        <trans-unit id="393afd38f0f130b369c23e78f4c43a313a970250" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Syntactic_sugar&quot;&gt;sugary&lt;/a&gt; way to say</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; は&lt;a href=&quot;https://en.wikipedia.org/wiki/Syntactic_sugar&quot;&gt;甘い&lt;/a&gt;言い方です</target>
        </trans-unit>
        <trans-unit id="f0678b46e10ca9ffeda185128b6349088f185f67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; is a keyword that is used like &lt;code&gt;return&lt;/code&gt;, except the function will return a generator.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; は、関数がジェネレータを返すことを除いて、 &lt;code&gt;return&lt;/code&gt; のように使用されるキーワードです。</target>
        </trans-unit>
        <trans-unit id="d4184f15f233616d72aa7e7ca25ec3a4265c4298" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; is just like &lt;code&gt;return&lt;/code&gt; - it returns whatever you tell it to (as a generator). The difference is that the next time you call the generator, execution starts from the last call to the &lt;code&gt;yield&lt;/code&gt; statement. Unlike return, &lt;strong&gt;the stack frame is not cleaned up when a yield occurs, however control is transferred back to the caller, so its state will resume the next time the function is called.&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; は &lt;code&gt;return&lt;/code&gt; と同じです-（ジェネレーターとして）何を言っても返します。 違いは、次にジェネレータを呼び出すときに、 &lt;code&gt;yield&lt;/code&gt; ステートメントの最後の呼び出しから実行が開始されることです。 returnとは異なり&lt;strong&gt;、yieldが発生してもスタックフレームはクリーンアップされませんが、制御は呼び出し元に戻されるため、関数が次に呼び出されたときにその状態が再開されます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f48e19febbab48404940d230045aa3e927e5e30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; is like a return element for a function. The difference is, that the &lt;code&gt;yield&lt;/code&gt; element turns a function into a generator. A generator behaves just like a function until something is 'yielded'. The generator stops until it is next called, and continues from exactly the same point as it started. You can get a sequence of all the 'yielded' values in one, by calling &lt;code&gt;list(generator())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; は、関数の戻り要素のようなものです。 違いは、 &lt;code&gt;yield&lt;/code&gt; 要素が関数をジェネレーターに変換することです。 ジェネレーターは、何かが「生成」されるまで、関数のように動作します。 ジェネレーターは次に呼び出されるまで停止し、開始時とまったく同じポイントから続行します。 &lt;code&gt;list(generator())&lt;/code&gt; を呼び出すことで、すべての「降伏した」値のシーケンスを1つに取得できます。</target>
        </trans-unit>
        <trans-unit id="ce79dbc24d94277033832b51d011f10c74c51c55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; provides an 
easy way of &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#generator-types&quot;&gt;implementing the iterator protocol&lt;/a&gt;, defined by the following two methods: 
&lt;code&gt;__iter__&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; (Python 2) or &lt;code&gt;__next__&lt;/code&gt; (Python 3).  Both of those methods
make an object an iterator that you could type-check with the &lt;code&gt;Iterator&lt;/code&gt; Abstract Base 
Class from the &lt;code&gt;collections&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; は、2つのメソッド &lt;code&gt;__iter__&lt;/code&gt; と &lt;code&gt;next&lt;/code&gt; （Python 2）または &lt;code&gt;__next__&lt;/code&gt; （Python 3）で定義され&lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#generator-types&quot;&gt;たイテレータープロトコル&lt;/a&gt;を実装する簡単な方法を提供します。 これらのメソッドはどちらもオブジェクトをイテレータにし、 &lt;code&gt;collections&lt;/code&gt; モジュールの &lt;code&gt;Iterator&lt;/code&gt; 抽象基本クラスで型チェックできるようにします。</target>
        </trans-unit>
        <trans-unit id="72b1d67b42a7bcd2f82b7a63ae89928f2425a004" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caller:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Caller:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cff026d6f9aa06262d0a44145fc01e31f8076361" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Generator:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Generator:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c38bed66dadc73d83b4620730a13bb214521445c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/strong&gt; is only legal inside of a function definition, and &lt;strong&gt;the inclusion of &lt;code&gt;yield&lt;/code&gt; in a function definition makes it return a generator.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/strong&gt;は関数定義内でのみ有効であり、関数定義&lt;strong&gt;に &lt;code&gt;yield&lt;/code&gt; を含めると、ジェネレータが返されます。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="229ca9910a03e900f64ebcb32c51dbc86e43eacf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Execution Control Transfer gotcha&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;実行制御転送の問題&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="653263d633592b8035eb87354035a2aedee82289" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As a Python generator:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pythonジェネレータとして：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="daa7df2500b97f81040621f58d60cce72d811842" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;関数の呼び出し&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b934a0ad7383658a04e1dbb7356e9f956f6fa54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For Python 3, use&lt;code&gt;print(corner_street_atm.__next__())&lt;/code&gt; or &lt;code&gt;print(next(corner_street_atm))&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; Python 3の場合は、 &lt;code&gt;print(corner_street_atm.__next__())&lt;/code&gt; または &lt;code&gt;print(next(corner_street_atm))&lt;/code&gt; を使用してください</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="867dc1e5830b6274ed3a21ce05e3f7d42fcc32aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the result from the code:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;これはコードの結果です：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57c3f7ae705716465207e976c5f8b4654e8b8e23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using lexical closures instead of generators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ジェネレーターの代わりに字句閉鎖を使用する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb818cdf73632877fa6680be81278640e6f5f261" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using object closures instead of generators&lt;/strong&gt; (because &lt;a href=&quot;http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent&quot;&gt;ClosuresAndObjectsAreEquivalent&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;ジェネレーターの代わりにオブジェクトクロージャーを使用する&lt;/strong&gt; （ &lt;a href=&quot;http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent&quot;&gt;ClosuresAndObjectsAreEquivalentの&lt;/a&gt;ため）</target>
        </trans-unit>
        <trans-unit id="6cd1618b874d384cc3e5eb172422b1adea86fbd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What does the &lt;code&gt;yield&lt;/code&gt; keyword do in Python?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pythonで &lt;code&gt;yield&lt;/code&gt; キーワードは何をしますか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf577700a9ff9e3f004ffc00209080b9c3eba6b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yield is an object&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;収量はオブジェクトです&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5bb3a856024a662b96de26aecfd9bd37f19227ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;return&lt;/strong&gt; (in function)</source>
          <target state="translated">&lt;strong&gt;戻り値&lt;/strong&gt; （関数内）</target>
        </trans-unit>
        <trans-unit id="9a40ecb26c7c8562eed416b67a93ab45567e9bd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;yield&lt;/strong&gt; &amp;mdash; give way or relinquish (as in political power)</source>
          <target state="translated">&lt;strong&gt;利回り&lt;/strong&gt; &amp;mdash;道を譲るか放棄するか（政治権力の場合と同様）</target>
        </trans-unit>
        <trans-unit id="bccdd99e0ed80b5b71ebb537cdf27634a356412a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;yield&lt;/strong&gt; &amp;mdash; produce or provide (as in agriculture)</source>
          <target state="translated">&lt;strong&gt;収量&lt;/strong&gt; &amp;mdash;生産または提供（農業など）</target>
        </trans-unit>
        <trans-unit id="2c3677668ae12b29cf20934e6d983bdb8043dd08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;yield&lt;/strong&gt; (in function)</source>
          <target state="translated">&lt;strong&gt;収量&lt;/strong&gt; （関数内）</target>
        </trans-unit>
        <trans-unit id="26de2c12b563c2f9a7febaaeb02a1b7ff942e453" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
1. This piece of code was written by Jochen Schulz (jrschulz), who made a great Python library for metric spaces. This is the link to the complete source: &lt;a href=&quot;http://well-adjusted.de/~jrschulz/mspace/&quot;&gt;Module mspace&lt;/a&gt;.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;1.このコードは、メトリック空間用の優れたPythonライブラリを作成したJochen Schulz（jrschulz）によって書かれました。&lt;/sub&gt; &lt;sub&gt;これは完全なソースへのリンクです： &lt;a href=&quot;http://well-adjusted.de/~jrschulz/mspace/&quot;&gt;Module mspace&lt;/a&gt; 。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="f79576b025501c7eb386682a764849f89c207838" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;code&gt;yield&lt;/code&gt; was originally introduced as a statement, meaning that it 
could only appear at the beginning of a line in a code block. 
Now &lt;code&gt;yield&lt;/code&gt; creates a yield expression. 
&lt;a href=&quot;https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt&quot;&gt;https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt&lt;/a&gt; 
This change was &lt;a href=&quot;https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators&quot;&gt;proposed&lt;/a&gt; to allow a user to send data into the generator just as
one might receive it. To send data, one must be able to assign it to something, and
for that, a statement just won't work.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt; &lt;code&gt;yield&lt;/code&gt; はもともとステートメントとして導入されました。つまり、コードブロックの行の先頭にしか出現できませんでした。&lt;/sub&gt; &lt;sub&gt;ここで &lt;code&gt;yield&lt;/code&gt; は、yield式を作成します。&lt;/sub&gt; &lt;sub&gt;&lt;a href=&quot;https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt&quot;&gt;https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt&lt;/a&gt;この変更は、ユーザーがデータを受信するのと同じように、ユーザーがジェネレーターにデータを送信できるようにするために&lt;a href=&quot;https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators&quot;&gt;提案され&lt;/a&gt;ました。&lt;/sub&gt; &lt;sub&gt;データを送信するには、データを何かに割り当てることができなければなりません。そのためには、ステートメントが機能しません。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="3ecaefffce9acc4aec2e8eb1485d8144441fb64a" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt; This means, for example, that &lt;code&gt;xrange&lt;/code&gt; objects (&lt;code&gt;range&lt;/code&gt; in Python 3) aren't &lt;code&gt;Iterator&lt;/code&gt;s, even though they are iterable, because they can be reused. Like lists, their &lt;code&gt;__iter__&lt;/code&gt; methods return iterator objects.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;これは、たとえば、 &lt;code&gt;xrange&lt;/code&gt; オブジェクト（Python 3では &lt;code&gt;range&lt;/code&gt; ）は、反復可能であっても、再利用できるため、 &lt;code&gt;Iterator&lt;/code&gt; ではないことを意味します。&lt;/sub&gt; &lt;sub&gt;リストと同様に、それらの &lt;code&gt;__iter__&lt;/code&gt; メソッドはイテレータオブジェクトを返します。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="6d4047120e95ed7d93b8ea0918529c67a9bc43e4" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;The languages CLU, Sather, and Icon were referenced in the proposal
to introduce the concept of generators to Python. The general idea is
that a function can maintain internal state and yield intermediate 
data points on demand by the user. This promised to be &lt;a href=&quot;https://www.python.org/dev/peps/pep-0255/&quot;&gt;superior in performance 
to other approaches, including Python threading&lt;/a&gt;, which isn't even available on some systems.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;CLU、Sather、およびIcon言語は、Pythonにジェネレーターの概念を導入する提案で参照されました。&lt;/sub&gt; &lt;sub&gt;一般的な考え方は、関数は内部状態を維持し、ユーザーの要求に応じて中間データポイントを生成できるということです。&lt;/sub&gt; &lt;sub&gt;これにより、一部のシステムでは利用できない&lt;a href=&quot;https://www.python.org/dev/peps/pep-0255/&quot;&gt;Pythonスレッド化など、他のアプローチよりもパフォーマンス&lt;/a&gt;が優れていることが約束されました。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="45728cd7c825dedfa1bf52fd66ed620c707bd5e8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;return&lt;/code&gt; in a function will return a single value.</source>
          <target state="translated">関数の戻り値は単一の値を返します。</target>
        </trans-unit>
        <trans-unit id="f4dca203541c03ec91c7704f277f8cc1b514af3a" translate="yes" xml:space="preserve">
          <source>A feature of an &lt;code&gt;Iterator&lt;/code&gt;&lt;a href=&quot;https://docs.python.org/2/glossary.html#term-iterator&quot;&gt;is that once exhausted&lt;/a&gt;, you can't reuse or reset it:</source>
          <target state="translated">&lt;code&gt;Iterator&lt;/code&gt; の特徴&lt;a href=&quot;https://docs.python.org/2/glossary.html#term-iterator&quot;&gt;は、一度使い尽くされると&lt;/a&gt; 、それを再利用したりリセットしたりできないことです。</target>
        </trans-unit>
        <trans-unit id="bc88bfb2c2db80515dc1ecb96783382a954c2f20" translate="yes" xml:space="preserve">
          <source>A function with &lt;a href=&quot;https://docs.python.org/reference/expressions.html#yieldexpr&quot;&gt;&lt;strong&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, when called, &lt;strong&gt;returns a &lt;a href=&quot;https://docs.python.org/2/tutorial/classes.html#generators&quot;&gt;Generator&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">呼び出されると、 &lt;a href=&quot;https://docs.python.org/reference/expressions.html#yieldexpr&quot;&gt;&lt;strong&gt; &lt;code&gt;yield&lt;/code&gt; を&lt;/strong&gt;&lt;/a&gt;持つ関数&lt;strong&gt;は&lt;a href=&quot;https://docs.python.org/2/tutorial/classes.html#generators&quot;&gt;Generatorを&lt;/a&gt;返します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="897499bfe1868bc9f693489cbbf23e92d00c56ab" translate="yes" xml:space="preserve">
          <source>A generator can also be &lt;strong&gt;sent information&lt;/strong&gt;, making it conceptually a &lt;strong&gt;coroutine&lt;/strong&gt;.</source>
          <target state="translated">ジェネレータに&lt;strong&gt;は情報を送信する&lt;/strong&gt;こともでき、概念的には&lt;strong&gt;コルーチンになり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="9738265b02043df1ee0a4dc75d4ad9e6a30481dd" translate="yes" xml:space="preserve">
          <source>A generator differs from a function in the sense that it is lazy. It accomplishes this by maintaining it's local state and allowing you to resume whenever you need to.</source>
          <target state="translated">ジェネレータは、レイジーであるという点で関数とは異なります。これは、ローカルな状態を維持し、必要なときにいつでも再開できるようにすることで実現しています。</target>
        </trans-unit>
        <trans-unit id="1f888f43eb25e3718593933b4335447760fb8473" translate="yes" xml:space="preserve">
          <source>A generator is iterable. What is an &lt;em&gt;iterable&lt;/em&gt;? It's anything like a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;range&lt;/code&gt; or dict-view, with a &lt;em&gt;built-in protocol for visiting each element in a certain order&lt;/em&gt;.</source>
          <target state="translated">ジェネレータは反復可能です。 &lt;em&gt;イテラブル&lt;/em&gt;とは何ですか？ これは、 &lt;code&gt;list&lt;/code&gt; 、 &lt;code&gt;set&lt;/code&gt; 、 &lt;code&gt;range&lt;/code&gt; または辞書ビューのようなもの&lt;em&gt;であり、特定の順序で各要素にアクセスするための組み込みプロトコルを備えています&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="40806863ce6fa16185eff4ee6a143d5d9c549f75" translate="yes" xml:space="preserve">
          <source>A real life example would be something like reading a file line by line or if you just want to make a generator.</source>
          <target state="translated">実際の例としては、ファイルを一行ずつ読むようなものや、ジェネレータを作りたい場合などがあります。</target>
        </trans-unit>
        <trans-unit id="44cb9a9a8788c105610a9684a6bc2a2b8a67003f" translate="yes" xml:space="preserve">
          <source>A syntax is proposed for a generator to delegate part of its operations to another generator. This allows a section of code containing 'yield' to be factored out and placed in another generator. Additionally, the subgenerator is allowed to return with a value, and the value is made available to the delegating generator.</source>
          <target state="translated">ジェネレータがその操作の一部を別のジェネレータに委譲するための構文が提案されています。これにより、'yield'を含むコードの一部分をファクトアウトし、別のジェネレータに配置することができるようになります。さらに、サブジェネレーターは値を持って返すことが許され、その値は委任したジェネレーターが利用できるようになります。</target>
        </trans-unit>
        <trans-unit id="74447fa535e8bb207f72d52e27e00da4cbc34ba7" translate="yes" xml:space="preserve">
          <source>Again, this is a pretty contrived example, you probably would use itertools if you really wanted to count to 50 billion. :)</source>
          <target state="translated">繰り返しになりますが、これは非常にコントラバスな例です。もし本当に500億まで数えたいのであれば、itertoolsを使うでしょう。)</target>
        </trans-unit>
        <trans-unit id="bd27eb03f93b277d1b217b449e15ffaa08956520" translate="yes" xml:space="preserve">
          <source>All great answers, however a bit difficult for newbies.</source>
          <target state="translated">どれも素晴らしい回答ですが、初心者には少し難しいかもしれません。</target>
        </trans-unit>
        <trans-unit id="2fab016fc71934fbba31dba4e6e38ca3818acafb" translate="yes" xml:space="preserve">
          <source>Also, note that &lt;code&gt;yield&lt;/code&gt; can be used in coroutines as the dual of their use in generator functions.  Although it isn't the same use as your code snippet, &lt;code&gt;(yield)&lt;/code&gt; can be used as an expression in a function.  When a caller sends a value to the method using the &lt;code&gt;send()&lt;/code&gt; method, then the coroutine will execute until the next &lt;code&gt;(yield)&lt;/code&gt; statement is encountered.</source>
          <target state="translated">また、 &lt;code&gt;yield&lt;/code&gt; は、コルーチンでジェネレーター関数での使用の二重として使用できることに注意してください。 これはコードスニペットとは異なりますが、 &lt;code&gt;(yield)&lt;/code&gt; を関数の式として使用できます。 呼び出し元が &lt;code&gt;send()&lt;/code&gt; メソッドを使用してメソッドに値を送信すると、コルーチンは次の &lt;code&gt;(yield)&lt;/code&gt; ステートメントが検出されるまで実行されます。</target>
        </trans-unit>
        <trans-unit id="c56156759c86e1fd4089d77e11250c9e375078a7" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;expression_list&lt;/code&gt; is basically any number of expressions separated by commas - essentially, in Python 2, you can stop the generator with &lt;code&gt;return&lt;/code&gt;, but you can't return a value.</source>
          <target state="translated">&lt;code&gt;expression_list&lt;/code&gt; は基本的に、コンマで区切られた任意の数の式です。基本的に、Python 2では &lt;code&gt;return&lt;/code&gt; でジェネレーターを停止できますが、値を返すことはできません。</target>
        </trans-unit>
        <trans-unit id="81d45d4bfb0fa5b224eac8c43cc82a19dfb43fe4" translate="yes" xml:space="preserve">
          <source>An easy example to understand what it is: &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">それが何であるかを理解する簡単な例： &lt;code&gt;yield&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cdd85aeb410d39ea117f7d9f6130e19b2898ccdb" translate="yes" xml:space="preserve">
          <source>An example? Let's see the possible orders of arrival for a four-horse race:</source>
          <target state="translated">一例?4頭立てのレースで考えられる着順を見てみましょう。</target>
        </trans-unit>
        <trans-unit id="29b15a5d175843895768eba634b31bff250c477b" translate="yes" xml:space="preserve">
          <source>An iterable is the last part of a list comprehension, and all generators are iterable, so they're often used like so:</source>
          <target state="translated">イテレート可能なものはリスト内包の最後の部分で、すべての生成器がイテレート可能なので、このように使われることが多いです。</target>
        </trans-unit>
        <trans-unit id="81d8a56bb9735baf48091b3e5b5e287b1b2e4127" translate="yes" xml:space="preserve">
          <source>An iterator is just a fancy sounding term for an object that has a &lt;code&gt;next()&lt;/code&gt; method.  So a yield-ed function ends up being something like this:</source>
          <target state="translated">イテレータとは、 &lt;code&gt;next()&lt;/code&gt; メソッドを持つオブジェクトを表す洗練された用語です。 したがって、yield-ed関数は次のようになります。</target>
        </trans-unit>
        <trans-unit id="d914dca0e9f94be2a010606114630680fc2fbce8" translate="yes" xml:space="preserve">
          <source>And if necessary, we can type-check like this:</source>
          <target state="translated">そして、必要に応じて、このようにタイプチェックをします。</target>
        </trans-unit>
        <trans-unit id="8b152c57dd4e6896c2e2d3a2c969268781a04e11" translate="yes" xml:space="preserve">
          <source>And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples, and generators! This is called duck typing and is one of the reasons why Python is so cool. But this is another story, for another question...</source>
          <target state="translated">そして、Pythonはメソッドの引数がリストであるかどうかを気にしないので動作します。Pythonはイテレートを期待しているので、文字列、リスト、タプル、ジェネレータで動作します!これはダックタイピングと呼ばれています。これはダックタイピングと呼ばれ、Pythonがとてもクールな理由の一つです。しかし、これは別の質問のための別の話です...</target>
        </trans-unit>
        <trans-unit id="97fbec56b74d699d8da84f4466277b6823b52c60" translate="yes" xml:space="preserve">
          <source>And now we can delegate functionality to a sub-generator and it can be used
by a generator just as above:</source>
          <target state="translated">そして、機能をサブジェネレーターに委譲することができるようになり、上記のようにジェネレーターで使用することができるようになりました。</target>
        </trans-unit>
        <trans-unit id="bdec22c07b1756ea41e55aa6af803ad40c179f4d" translate="yes" xml:space="preserve">
          <source>And now we can send data into the generator. (&lt;a href=&quot;https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators&quot;&gt;Sending &lt;code&gt;None&lt;/code&gt; is 
the same as calling &lt;code&gt;next&lt;/code&gt;&lt;/a&gt;.) :</source>
          <target state="translated">これで、ジェネレータにデータを送信できます。 （ &lt;a href=&quot;https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators&quot;&gt; &lt;code&gt;None&lt;/code&gt; を送信することは &lt;code&gt;next&lt;/code&gt; を呼び出すことと同じ&lt;/a&gt;です。）：</target>
        </trans-unit>
        <trans-unit id="df8f95772f413efb0c2dbf265ff4862fae1c7bc4" translate="yes" xml:space="preserve">
          <source>And this is the caller:</source>
          <target state="translated">そして、こちらが発信者です。</target>
        </trans-unit>
        <trans-unit id="3b57182086d6c04e166187f3787e8d917fd59442" translate="yes" xml:space="preserve">
          <source>Answer Outline/Summary</source>
          <target state="translated">回答概要概要</target>
        </trans-unit>
        <trans-unit id="c3c07bbc3573c4c760856487909b704db42f46ae" translate="yes" xml:space="preserve">
          <source>Appendix:</source>
          <target state="translated">Appendix:</target>
        </trans-unit>
        <trans-unit id="f7153a3ed77229b8ef3f57eb201522d76e468e8a" translate="yes" xml:space="preserve">
          <source>As I understand, when we want to process a bunch of data, we usually first store the data somewhere and then process it one by one. But this &lt;em&gt;naive&lt;/em&gt; approach is problematic. If the data volume is huge, it's expensive to store them as a whole beforehand. &lt;strong&gt;So instead of storing the &lt;code&gt;data&lt;/code&gt; itself directly, why not store some kind of &lt;code&gt;metadata&lt;/code&gt; indirectly, i.e. &lt;code&gt;the logic how the data is computed&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">私が理解しているように、大量のデータを処理する場合、通常は最初にデータをどこかに保存してから、1つずつ処理します。 しかし、この&lt;em&gt;素朴な&lt;/em&gt;アプローチには問題があります。 データ量が大きい場合は、事前に全体として保存しておくとコストがかかります。 &lt;strong&gt;したがって、 &lt;code&gt;data&lt;/code&gt; 自体を直接保存するのではなく &lt;code&gt;the logic how the data is computed&lt;/code&gt; 、ある種の &lt;code&gt;metadata&lt;/code&gt; 間接的に保存してみませんか&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="71b8419f2c05a320eab84f0ff210eed5a7aa3f59" translate="yes" xml:space="preserve">
          <source>As an analogy, &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt; are twins. &lt;code&gt;return&lt;/code&gt; means 'return and stop' whereas 'yield` means 'return, but continue'</source>
          <target state="translated">アナロジーとして、 &lt;code&gt;return&lt;/code&gt; と &lt;code&gt;yield&lt;/code&gt; は双子です。 &lt;code&gt;return&lt;/code&gt; は 'return and stop'を意味し、 'yield`は' return、but continue 'を意味します</target>
        </trans-unit>
        <trans-unit id="9399c22507893ea92efd2d3d7bd85d4924662fa9" translate="yes" xml:space="preserve">
          <source>As you can see both functions do the same thing. The only difference is &lt;code&gt;return_dates()&lt;/code&gt; gives a list and &lt;code&gt;yield_dates()&lt;/code&gt; gives a generator.</source>
          <target state="translated">ご覧のとおり、両方の関数は同じことを行います。 唯一の違いは、 &lt;code&gt;return_dates()&lt;/code&gt; がリストを提供し、 &lt;code&gt;yield_dates()&lt;/code&gt; がジェネレーターを提供することです。</target>
        </trans-unit>
        <trans-unit id="135740deb1c52c950dd9825f622468250cfec310" translate="yes" xml:space="preserve">
          <source>As you can see, in the first case &lt;code&gt;foo&lt;/code&gt; holds the entire list in memory at once. It's not a big deal for a list with 5 elements, but what if you want a list of 5 million? Not only is this a huge memory eater, it also costs a lot of time to build at the time that the function is called.</source>
          <target state="translated">ご覧のとおり、最初のケースでは、 &lt;code&gt;foo&lt;/code&gt; はリスト全体を一度にメモリに保持します。 5つの要素を持つリストでは大した問題ではありませんが、500万のリストが必要な場合はどうでしょうか。 これは巨大なメモリイーターであるだけでなく、関数が呼び出されたときにビルドするのに多くの時間がかかります。</target>
        </trans-unit>
        <trans-unit id="5bbe3ddff5d188e8a248228bc2152ed147d1b379" translate="yes" xml:space="preserve">
          <source>Behind the scenes</source>
          <target state="translated">舞台裏</target>
        </trans-unit>
        <trans-unit id="5b6a80379109f3fc6042e0737cbf5d072100c51f" translate="yes" xml:space="preserve">
          <source>Both functions do the same thing, but &lt;code&gt;yield&lt;/code&gt; uses three lines instead of five and has one less variable to worry about.</source>
          <target state="translated">どちらの関数も同じことを行いますが、 &lt;code&gt;yield&lt;/code&gt; は5行ではなく3行を使用しており、心配する変数が1つ少なくなっています。</target>
        </trans-unit>
        <trans-unit id="cca4c988c7e1babe71c97f7849efb9f46f5d36d6" translate="yes" xml:space="preserve">
          <source>Bottom line, until the developers of CPython tell us otherwise: &lt;strong&gt;Don't put &lt;code&gt;yield&lt;/code&gt; in a generator expression or comprehension.&lt;/strong&gt;</source>
          <target state="translated">結論として、CPythonの開発者が別のことを言うまで： &lt;strong&gt;ジェネレーターの式や理解に &lt;code&gt;yield&lt;/code&gt; を入れないでください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d08cdf468566d1e5880decf4e3f20a483dff611f" translate="yes" xml:space="preserve">
          <source>Brilliant choice of the word &lt;code&gt;yield&lt;/code&gt; because &lt;a href=&quot;https://www.google.com/search?q=yield+meaning&quot;&gt;both meanings&lt;/a&gt; apply:</source>
          <target state="translated">&lt;a href=&quot;https://www.google.com/search?q=yield+meaning&quot;&gt;両方の意味が&lt;/a&gt;当てはまるため、 &lt;code&gt;yield&lt;/code&gt; という単語の優れた選択：</target>
        </trans-unit>
        <trans-unit id="18cf04f82308b4c79617d9344cd8cccedc5948df" translate="yes" xml:space="preserve">
          <source>Built-in lists, dictionaries, tuples, sets, files.</source>
          <target state="translated">組み込みのリスト、辞書、タプル、セット、ファイル。</target>
        </trans-unit>
        <trans-unit id="ace5b94af148161c793a05983917f7f7008ae80a" translate="yes" xml:space="preserve">
          <source>But in your code, it gets a generator, which is good because:</source>
          <target state="translated">しかし、あなたのコードでは、それはジェネレータを取得します。</target>
        </trans-unit>
        <trans-unit id="e41053f2e7b7818b717e108be50e7b8bc56bf7fd" translate="yes" xml:space="preserve">
          <source>But this is inefficient because</source>
          <target state="translated">しかし、これは次のような理由で非効率的です。</target>
        </trans-unit>
        <trans-unit id="112200cd9ac4f291717eeda13db581f83c118af7" translate="yes" xml:space="preserve">
          <source>But you could easily implement (and conceptualize) generators as a simple, specific case of continuation passing style:</source>
          <target state="translated">しかし、継続パススタイルの単純で具体的なケースとして、ジェネレータを簡単に実装(概念化)することができます。</target>
        </trans-unit>
        <trans-unit id="224ba6c7dc6ef4515b36b8503f362933f7f951ca" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;iter(mylist)&lt;/code&gt; -&amp;gt; this returns an object with a &lt;code&gt;next()&lt;/code&gt; method (or &lt;code&gt;__next__()&lt;/code&gt; in Python 3).</source>
          <target state="translated">&lt;code&gt;iter(mylist)&lt;/code&gt; を呼び出す-&amp;gt;これは、 &lt;code&gt;next()&lt;/code&gt; メソッド（またはPython 3では &lt;code&gt;__next__()&lt;/code&gt; でオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="4fdabc45b3bad82e2c9c7d5aa68f04b364ec25ac" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;yielderFunction()&lt;/code&gt; doesn't run its code, but makes a generator out of the code. (Maybe it's a good idea to name such things with the &lt;code&gt;yielder&lt;/code&gt; prefix for readability.)</source>
          <target state="translated">&lt;code&gt;yielderFunction()&lt;/code&gt; を呼び出してもコードは実行されませんが、コードからジェネレーターが作成されます。 （おそらく、読みやすいように、そのようなものには、 &lt;code&gt;yielder&lt;/code&gt; プレフィックスを付けた方がいいでしょう。）</target>
        </trans-unit>
        <trans-unit id="d4e40bacc080c668ae12d6659592822c4592d6dc" translate="yes" xml:space="preserve">
          <source>Cheers, Nick.</source>
          <target state="translated">乾杯 ニック</target>
        </trans-unit>
        <trans-unit id="fa1fe25132badc6a4700de54339362efef6cccf3" translate="yes" xml:space="preserve">
          <source>Compare function to the original definition.</source>
          <target state="translated">機能を元の定義と比較します。</target>
        </trans-unit>
        <trans-unit id="422466cb355bfaa6b435c10bfd2011e9037906cc" translate="yes" xml:space="preserve">
          <source>Compare the following examples:</source>
          <target state="translated">以下の例を比較してみてください。</target>
        </trans-unit>
        <trans-unit id="23177d88df5aa8c7d73ae1fbc8fbc37e2afda7be" translate="yes" xml:space="preserve">
          <source>Comparing example to &quot;just returning a list&quot;</source>
          <target state="translated">リストを返すだけ」との比較例</target>
        </trans-unit>
        <trans-unit id="13ee7709c64ae8875430c0fce8f630d0fd20adab" translate="yes" xml:space="preserve">
          <source>Comparing to &lt;code&gt;return&lt;/code&gt; which runs once and stops, &lt;code&gt;yield&lt;/code&gt; runs times you planed.
You can interpret &lt;code&gt;return&lt;/code&gt; as &lt;code&gt;return one of them&lt;/code&gt;, and &lt;code&gt;yield&lt;/code&gt; as &lt;code&gt;return all of them&lt;/code&gt;. This is called &lt;code&gt;iterable&lt;/code&gt;.</source>
          <target state="translated">一度実行して停止する &lt;code&gt;return&lt;/code&gt; と比較して、計画した実行時間を &lt;code&gt;yield&lt;/code&gt; ます。 &lt;code&gt;return one of them&lt;/code&gt; &lt;code&gt;return&lt;/code&gt; と解釈し 、 &lt;code&gt;yield&lt;/code&gt; &lt;code&gt;return all of them&lt;/code&gt; と解釈できます 。 これは &lt;code&gt;iterable&lt;/code&gt; と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="d93505eddd729749377d3ebb203709c807a5b6b0" translate="yes" xml:space="preserve">
          <source>Continuations in programming languages theory are a much more fundamental kind of computation, but they are not often used, because they are extremely hard to reason about and also very difficult to implement. But the idea of what a continuation is, is straightforward: it is the state of a computation that has not yet finished. In this state, the current values of variables, the operations that have yet to be performed, and so on, are saved. Then at some point later in the program the continuation can be invoked, such that the program's variables are reset to that state and the operations that were saved are carried out.</source>
          <target state="translated">プログラミング言語の理論における継続とは、もっと根本的な計算のことですが、推論するのが非常に難しく、また実装するのも非常に難しいので、あまり使われることはありません。しかし、継続とは何かという考えは簡単です。この状態では、変数の現在の値や、まだ実行されていない演算などが保存されています。そして、プログラムの後のある時点で、プログラムの変数がその状態にリセットされ、保存されていた操作が実行されるように、継続を呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="b72e044549c84a332ce620bd9e0a6adabcb6a3af" translate="yes" xml:space="preserve">
          <source>Continuations, in this more general form, can be implemented in two ways. In the &lt;code&gt;call/cc&lt;/code&gt; way, the program's stack is literally saved and then when the continuation is invoked, the stack is restored.</source>
          <target state="translated">このより一般的な形式の継続は、2つの方法で実装できます。 &lt;code&gt;call/cc&lt;/code&gt; の方法では、プログラムのスタックは文字通り保存され、継続が呼び出されると、スタックが復元されます。</target>
        </trans-unit>
        <trans-unit id="2c47bc7e9e1cccd861bf2f12386c3a01928597e8" translate="yes" xml:space="preserve">
          <source>Controlling a generator exhaustion</source>
          <target state="translated">発電機の消耗を制御する</target>
        </trans-unit>
        <trans-unit id="fe65bca192a86197c66d7cf330e1537caa61c387" translate="yes" xml:space="preserve">
          <source>Cooperative Delegation to Sub-Coroutine with &lt;code&gt;yield from&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;yield from&lt;/code&gt; 伴うサブコルーチンへの協力的な委任</target>
        </trans-unit>
        <trans-unit id="33163af7bd841f674f77c35298225e94a5016009" translate="yes" xml:space="preserve">
          <source>Coroutines:</source>
          <target state="translated">Coroutines:</target>
        </trans-unit>
        <trans-unit id="abfb94ac57644f17a8adf8955a59558bd94c3b33" translate="yes" xml:space="preserve">
          <source>Critique of answer suggesting &lt;code&gt;yield&lt;/code&gt; in a generator expression or comprehension.</source>
          <target state="translated">発電機の表現または理解における &lt;code&gt;yield&lt;/code&gt; を示唆する回答の批評。</target>
        </trans-unit>
        <trans-unit id="a9c0621bff7dcefce6457fdee9b6bcef2e0f3d8a" translate="yes" xml:space="preserve">
          <source>Critique of the Top/Accepted Answer**</source>
          <target state="translated">トップの批評受諾された回答**。</target>
        </trans-unit>
        <trans-unit id="391058e00a0cf1fea23f9021af0e6821cda75f41" translate="yes" xml:space="preserve">
          <source>Different behavior:</source>
          <target state="translated">行動が違う</target>
        </trans-unit>
        <trans-unit id="4beaba95c78d5c63061a997dcde838cb3d1a985b" translate="yes" xml:space="preserve">
          <source>Does that make more sense or just confuse you more?  :)</source>
          <target state="translated">その方が意味があるのか、それとももっと混乱させるだけなのか :)</target>
        </trans-unit>
        <trans-unit id="478cc5edb794118536367238291728364671b4c5" translate="yes" xml:space="preserve">
          <source>Don't confuse your Iterables, Iterators, and Generators</source>
          <target state="translated">イテレータブル、イテレータ、ジェネレータを混同しないように</target>
        </trans-unit>
        <trans-unit id="c5ebf51ae7871d62102efa654179e7b2cbd98826" translate="yes" xml:space="preserve">
          <source>Either way, an iterator is created, i.e. some object that can give you the data you want. The OO approach may be a bit complex. Anyway, which one to use is up to you.</source>
          <target state="translated">いずれにしても、イテレータが作成されます。OOアプローチは少し複雑かもしれません。いずれにしても、どちらを使うかはあなた次第です。</target>
        </trans-unit>
        <trans-unit id="17dcf8ce994111b56509be2581c55631ea92717d" translate="yes" xml:space="preserve">
          <source>Everything you can use &quot;&lt;code&gt;for... in...&lt;/code&gt;&quot; on is an iterable; &lt;code&gt;lists&lt;/code&gt;, &lt;code&gt;strings&lt;/code&gt;, files...</source>
          <target state="translated">「 &lt;code&gt;for... in...&lt;/code&gt; 」 で使用できるものはすべて反復可能です。 &lt;code&gt;lists&lt;/code&gt; 、 &lt;code&gt;strings&lt;/code&gt; 、ファイル...</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="a58924e6ca70e15697b41c0fd8af77f8e3655bd0" translate="yes" xml:space="preserve">
          <source>First, the &lt;strong&gt;iterator protocol&lt;/strong&gt; - when you write</source>
          <target state="translated">まず、 &lt;strong&gt;イテレータプロトコル&lt;/strong&gt; -あなたが書くとき</target>
        </trans-unit>
        <trans-unit id="ab464772e390ee8b69cf6e6fbb14dd8f889ce77c" translate="yes" xml:space="preserve">
          <source>First, we must queue up the generator with the builtin function, &lt;a href=&quot;https://docs.python.org/2/library/functions.html#next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;. It will 
call the appropriate &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;__next__&lt;/code&gt; method, depending on the version of
Python you are using:</source>
          <target state="translated">最初に、組み込み関数&lt;a href=&quot;https://docs.python.org/2/library/functions.html#next&quot;&gt; &lt;code&gt;next&lt;/code&gt; で&lt;/a&gt;ジェネレータをキューに入れる必要があります。 使用しているPythonのバージョンに応じて、適切な &lt;code&gt;next&lt;/code&gt; または &lt;code&gt;__next__&lt;/code&gt; メソッドを呼び出します。</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="87881092dde77e187d0bf9cb4e0f744846b558a8" translate="yes" xml:space="preserve">
          <source>For example, I'm trying to understand this code&lt;sup&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/sup&gt;:</source>
          <target state="translated">たとえば、私はこのコードを理解しようとしています&lt;sup&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/sup&gt; ：</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="4359df1244f408dd74c85feea20108563cf47ea0" translate="yes" xml:space="preserve">
          <source>For more accurate information, read about &lt;a href=&quot;http://docs.python.org/library/stdtypes.html#iterator-types&quot;&gt;iterator types&lt;/a&gt;, the &lt;a href=&quot;http://docs.python.org/reference/simple_stmts.html#yield&quot;&gt;yield statement&lt;/a&gt; and &lt;a href=&quot;http://docs.python.org/glossary.html#term-generator&quot;&gt;generators&lt;/a&gt; in the Python documentation.</source>
          <target state="translated">より正確な情報については、Pythonのドキュメントで、 &lt;a href=&quot;http://docs.python.org/library/stdtypes.html#iterator-types&quot;&gt;イテレータ型&lt;/a&gt; 、 &lt;a href=&quot;http://docs.python.org/reference/simple_stmts.html#yield&quot;&gt;yieldステートメント&lt;/a&gt; 、 &lt;a href=&quot;http://docs.python.org/glossary.html#term-generator&quot;&gt;ジェネレータ&lt;/a&gt;について読んでください。</target>
        </trans-unit>
        <trans-unit id="ab34884b9c5a1c376f359e896bfa36ac9404ee1e" translate="yes" xml:space="preserve">
          <source>For more insight as to what's happening behind the scenes, the &lt;code&gt;for&lt;/code&gt; loop can be rewritten to this:</source>
          <target state="translated">舞台裏で何が起こっているのかをより深く理解する &lt;code&gt;for&lt;/code&gt; に、 forループを次のように書き直すことができます。</target>
        </trans-unit>
        <trans-unit id="b3b09a14c47c5a101227ecf4d23816285925f6d5" translate="yes" xml:space="preserve">
          <source>For those who prefer a minimal working example, meditate on this interactive Python session:</source>
          <target state="translated">最小限の作業例をお望みの方は、このインタラクティブなPythonセッションに目を瞑ってみてください。</target>
        </trans-unit>
        <trans-unit id="50c79418c72adb6d21a9a53d6133434acd4b25f6" translate="yes" xml:space="preserve">
          <source>From &lt;em&gt;&lt;a href=&quot;http://www.python.org/dev/peps/pep-0380/&quot;&gt;PEP 380 -- Syntax for Delegating to a Subgenerator&lt;/a&gt;&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.python.org/dev/peps/pep-0380/&quot;&gt;PEP 380&lt;/a&gt;&lt;/em&gt;から&lt;em&gt;-サブジェネレーターに委任するための構文&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="12e842703e6cd07e003a70536ed53b1cad820600" translate="yes" xml:space="preserve">
          <source>From a programming viewpoint, the iterators are implemented as &lt;a href=&quot;http://en.wikipedia.org/wiki/Thunk_(functional_programming)&quot;&gt;thunks&lt;/a&gt;.</source>
          <target state="translated">プログラミングの観点から、イテレータは&lt;a href=&quot;http://en.wikipedia.org/wiki/Thunk_(functional_programming)&quot;&gt;サンク&lt;/a&gt;として実装されます。</target>
        </trans-unit>
        <trans-unit id="c04b84b0d27f22df1bc44e709e3324e4728e5047" translate="yes" xml:space="preserve">
          <source>Further, there is an &lt;a href=&quot;http://bugs.python.org/issue10544&quot;&gt;outstanding issue (10544)&lt;/a&gt; which seems to be pointing in the direction of this &lt;em&gt;never&lt;/em&gt; being a good idea (PyPy, a Python implementation written in Python, is already raising syntax warnings.)</source>
          <target state="translated">さらに、これが良い考えで&lt;em&gt;はない&lt;/em&gt;という方向を指しているように見える&lt;a href=&quot;http://bugs.python.org/issue10544&quot;&gt;未解決の問題（10544）が&lt;/a&gt;あります（Pythonで記述されたPython実装であるPyPyは、すでに構文警告を引き起こしています）。</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="ea270aafef5ea2be7a50c15d8f3cf44425aa37b7" translate="yes" xml:space="preserve">
          <source>Generators and coroutines are a cool way to set up data-flow type applications.  I thought it would be worthwhile knowing about the other use of the &lt;code&gt;yield&lt;/code&gt; statement in functions.</source>
          <target state="translated">ジェネレータとコルーチンは、データフロータイプのアプリケーションを設定するためのクールな方法です。 関数での &lt;code&gt;yield&lt;/code&gt; ステートメントの他の使い方について知っておく価値があると思いました。</target>
        </trans-unit>
        <trans-unit id="179018c67d6955b4f49df82ba24dc3b04e776679" translate="yes" xml:space="preserve">
          <source>Generators are iterators because they implement the &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#iterator-types&quot;&gt;&lt;strong&gt;iterator protocol&lt;/strong&gt;&lt;/a&gt;, so you can iterate over them.</source>
          <target state="translated">ジェネレータはイテレータ&lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#iterator-types&quot;&gt;&lt;strong&gt;プロトコル&lt;/strong&gt;&lt;/a&gt;を実装しているため、 &lt;strong&gt;イテレータです&lt;/strong&gt; 。したがって、ジェネレータを反復できます。</target>
        </trans-unit>
        <trans-unit id="a5e08e7b38a556477cdbe545a9f764632125d102" translate="yes" xml:space="preserve">
          <source>Generators are iterators, a kind of iterable &lt;strong&gt;you can only iterate over once&lt;/strong&gt;. Generators do not store all the values in memory, &lt;strong&gt;they generate the values on the fly&lt;/strong&gt;:</source>
          <target state="translated">ジェネレーターはイテレーターであり、 &lt;strong&gt;1回しかイテレートできない&lt;/strong&gt;イテラブルの一種です。 ジェネレータはすべての値をメモリに保存するのではなく&lt;strong&gt;、その場で値を生成します&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="682b0796dd83f3fd0ad45f54f168909fac114df8" translate="yes" xml:space="preserve">
          <source>Generators.</source>
          <target state="translated">Generators.</target>
        </trans-unit>
        <trans-unit id="30755c71dba128a057a2e8b31c452388bed51a8e" translate="yes" xml:space="preserve">
          <source>Generators:</source>
          <target state="translated">Generators:</target>
        </trans-unit>
        <trans-unit id="d054231a90af4e28b960cfe94d5c8186673ab51e" translate="yes" xml:space="preserve">
          <source>Gets an iterator for &lt;code&gt;mylist&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;mylist&lt;/code&gt; のイテレータを取得します。</target>
        </trans-unit>
        <trans-unit id="c8a20bbe7bfc35516518ea627afd092d0e96e4cc" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;mylist&lt;/code&gt; is an &lt;em&gt;iterable&lt;/em&gt; because it implements the iterator protocol. In a user-defined class, you can implement the &lt;code&gt;__iter__()&lt;/code&gt; method to make instances of your class iterable. This method should return an &lt;em&gt;iterator&lt;/em&gt;. An iterator is an object with a &lt;code&gt;next()&lt;/code&gt; method. It is possible to implement both &lt;code&gt;__iter__()&lt;/code&gt; and &lt;code&gt;next()&lt;/code&gt; on the same class, and have &lt;code&gt;__iter__()&lt;/code&gt; return &lt;code&gt;self&lt;/code&gt;. This will work for simple cases, but not when you want two iterators looping over the same object at the same time.</source>
          <target state="translated">&lt;code&gt;mylist&lt;/code&gt; は反復子プロトコルを実装しているため、 &lt;em&gt;反復可能&lt;/em&gt;です。 ユーザー定義クラスでは、 &lt;code&gt;__iter__()&lt;/code&gt; メソッドを実装して、クラスのインスタンスを反復可能にすることができます。 このメソッドは&lt;em&gt;イテレータ&lt;/em&gt;を返す必要があり&lt;em&gt;ます&lt;/em&gt; 。 イテレータは、 &lt;code&gt;next()&lt;/code&gt; メソッドを持つオブジェクトです。 同じクラスに &lt;code&gt;__iter__()&lt;/code&gt; と &lt;code&gt;next()&lt;/code&gt; の両方を実装し、 __ &lt;code&gt;__iter__()&lt;/code&gt; に &lt;code&gt;self&lt;/code&gt; を返すようにすることが可能です。 これは単純なケースでは機能しますが、同じオブジェクトを同時にループする2つのイテレータが必要な場合は機能しません。</target>
        </trans-unit>
        <trans-unit id="0e79b5d88ed3c6e491dd1236e901c3ae33f6911d" translate="yes" xml:space="preserve">
          <source>Here are some Python examples of how to actually implement generators as if Python did not provide syntactic sugar for them:</source>
          <target state="translated">ここでは、Pythonがジェネレーターに構文糖を提供していないかのように、実際にジェネレーターを実装するためのPythonの例をいくつか紹介します。</target>
        </trans-unit>
        <trans-unit id="a3efbd24d9780439598b7e67d051e0a6314b264c" translate="yes" xml:space="preserve">
          <source>Here is a demonstration which uses the structure of R6RS, but the semantics is absolutely identical to Python's. It's the same model of computation, and only a change in syntax is required to rewrite it in Python.</source>
          <target state="translated">ここではR6RSの構造を使ったデモを紹介しますが、セマンティクスはPythonと全く同じです。計算モデルは同じで、Pythonで書き換えるには構文を変更するだけです。</target>
        </trans-unit>
        <trans-unit id="5172df8a142b5de0fd37381a2dbff76cdb21ea9b" translate="yes" xml:space="preserve">
          <source>Here is a mental image of what &lt;code&gt;yield&lt;/code&gt; does.</source>
          <target state="translated">ここに &lt;code&gt;yield&lt;/code&gt; が何をするかについての精神的なイメージがあります。</target>
        </trans-unit>
        <trans-unit id="ea724b816190320574ae29c6484ba706b02e562b" translate="yes" xml:space="preserve">
          <source>Here is a simple example:</source>
          <target state="translated">簡単な例を挙げてみます。</target>
        </trans-unit>
        <trans-unit id="823fc4d20942e0533416446349c24b8a063855e9" translate="yes" xml:space="preserve">
          <source>Here is an example in plain language. I will provide a correspondence between high-level human concepts to low-level Python concepts.</source>
          <target state="translated">ここでは平易な言葉で例を示します。高レベルの人間の概念と低レベルのPythonの概念との対応を提供します。</target>
        </trans-unit>
        <trans-unit id="c4be0889ef73ed93c610ebfab505f5cb8fc53788" translate="yes" xml:space="preserve">
          <source>Here is an example which &lt;code&gt;yield&lt;/code&gt; is definitely best for:</source>
          <target state="translated">以下は、 &lt;code&gt;yield&lt;/code&gt; が間違いなく最適な例です。</target>
        </trans-unit>
        <trans-unit id="6617e5991223485f0a00e8961fec1ddd85153c85" translate="yes" xml:space="preserve">
          <source>Here is an example, take note of the &lt;code&gt;received&lt;/code&gt; variable, which will point to the data that is sent to the generator:</source>
          <target state="translated">次に例を示します。ジェネレーターに送信されるデータを指す &lt;code&gt;received&lt;/code&gt; 変数に注意してください。</target>
        </trans-unit>
        <trans-unit id="89aa700446679e9b8d5b65f7b661f79a7e178b5e" translate="yes" xml:space="preserve">
          <source>Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once.</source>
          <target state="translated">ここでは役に立たない例ですが、関数が巨大な値のセットを返すことがわかっていて、一度だけ読み込む必要がある場合に便利です。</target>
        </trans-unit>
        <trans-unit id="eeb09fb712bc1579dd70a54645ad53925ce84c23" translate="yes" xml:space="preserve">
          <source>Here's a simple &lt;code&gt;yield&lt;/code&gt; based approach, to compute the fibonacci series, explained:</source>
          <target state="translated">フィボナッチ数列を計算するための簡単な &lt;code&gt;yield&lt;/code&gt; ベースのアプローチは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="d5531c22206a07d82c2ec43020b326ceb13fdc0a" translate="yes" xml:space="preserve">
          <source>How you might use generators</source>
          <target state="translated">ジェネレーターの使い方</target>
        </trans-unit>
        <trans-unit id="d332df6254754940f55d36631c669c40c1993a88" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;yield from&lt;/code&gt; also allows for delegation to subgenerators, 
which will be explained in the following section on cooperative delegation with sub-coroutines.</source>
          <target state="translated">ただし、 &lt;code&gt;yield from&lt;/code&gt; はサブジェネレーターへの委任も可能にします。これについては、サブコルーチンとの協調委任に関する次のセクションで説明します。</target>
        </trans-unit>
        <trans-unit id="f7b0cdd1500200d6f1d896513a1bb21305470aa6" translate="yes" xml:space="preserve">
          <source>I am not a Python developer, but it looks to me &lt;code&gt;yield&lt;/code&gt; holds the position of program flow and the next loop start from &quot;yield&quot; position. It seems like it is waiting at that position, and just before that, returning a value outside, and next time continues to work.</source>
          <target state="translated">私はPython開発者ではありませんが、 &lt;code&gt;yield&lt;/code&gt; はプログラムフローの位置を保持し、次のループは「yield」の位置から始まります。 その位置で待っているようで、その直前に外に値を返し、次回は動き続けます。</target>
        </trans-unit>
        <trans-unit id="7e9ed01bd64f5c7896a84a3e0de95a03f1c43874" translate="yes" xml:space="preserve">
          <source>I ask you, &quot;tell me the next number&quot;, and you tell me the first number; after that, you wait for me to ask you for the next number. It's your job to remember where you were, what numbers you have already said, and what is the next number. I don't care about the details.</source>
          <target state="translated">私が「次の数字を教えて」と聞くと、あなたは最初の数字を言い、その後は私が次の数字を聞くのを待ちます。どこにいたのか、すでに言った番号は何番か、次の番号は何番かを覚えるのはあなたの仕事です。細かいことは気にしない。</target>
        </trans-unit>
        <trans-unit id="ae297b474260c70e731c6a136da6c3a9aef2dfb5" translate="yes" xml:space="preserve">
          <source>I assume you have learned the &lt;code&gt;return&lt;/code&gt; statement.</source>
          <target state="translated">私はあなたが &lt;code&gt;return&lt;/code&gt; ステートメントを学んだと思います。</target>
        </trans-unit>
        <trans-unit id="5bff8648a9749f500c9b8ad13ccf39b8881ec210" translate="yes" xml:space="preserve">
          <source>I believe I have covered all aspects of the following question:</source>
          <target state="translated">以下の質問については、すべて網羅していると思います。</target>
        </trans-unit>
        <trans-unit id="a679dadd1d940ee0fc56a1b939523e2268a7d0ab" translate="yes" xml:space="preserve">
          <source>I call you and tell you that I want a sequence of numbers which is produced in a specific way, and I let you know what the algorithm is.</source>
          <target state="translated">私はあなたに電話をして、特定の方法で生成される数字の列が欲しいと伝え、そのアルゴリズムが何であるかをあなたに知らせます。</target>
        </trans-unit>
        <trans-unit id="b123a6615d9a46f5c9c87bd3114b75d2fd201567" translate="yes" xml:space="preserve">
          <source>I like to think of a thread as having a stack (even when it's not implemented that way).</source>
          <target state="translated">スレッドはスタックを持っていると考えるのが好きです(そのように実装されていなくても)。</target>
        </trans-unit>
        <trans-unit id="776c90801148362b805a9659dc082980e40d4245" translate="yes" xml:space="preserve">
          <source>I should note that this &lt;em&gt;is&lt;/em&gt; an oversimplification for illustrative purposes. :)</source>
          <target state="translated">これ&lt;em&gt;は&lt;/em&gt; 、説明のために単純化しすぎていることに注意してください。 :)</target>
        </trans-unit>
        <trans-unit id="cb5a08e181cbeb658f35df743832a692b6761240" translate="yes" xml:space="preserve">
          <source>I want to operate on a sequence of numbers, but I don't want to bother my self with the creation of that sequence, I want only to focus on the operation I want to do. So, I do the following:</source>
          <target state="translated">数字の並びを操作したいのですが、その並びを作ることに自分を悩ませたくないので、自分のやりたい操作だけに集中したいのです。そこで、私は次のようにしています。</target>
        </trans-unit>
        <trans-unit id="a3a2a857bfdd4d4fc3add0498fdaf773cfe37b55" translate="yes" xml:space="preserve">
          <source>I was going to post &quot;read page 19 of Beazley's 'Python: Essential Reference' for a quick description of generators&quot;, but so many others have posted good descriptions already.</source>
          <target state="translated">私は「Beazley's 'Python.Essential Reference'を読むとジェネレータの簡単な説明がわかる」と投稿しようと思ったのですが、他の多くの方がすでに良い説明を投稿されています。</target>
        </trans-unit>
        <trans-unit id="a101ee9df37442be51ecc059a7eaa91d1dd5f763" translate="yes" xml:space="preserve">
          <source>I'd agree that's a sensible place for us to end up, as any code
  relying on the current behaviour is really too clever to be
  maintainable.</source>
          <target state="translated">現在の振る舞いに依存したコードは、保守性を高めるにはあまりにも巧妙すぎるので、これが賢明な行き着く先だと思います。</target>
        </trans-unit>
        <trans-unit id="1f609c272028fe91fcfd70e16ea920d4901be9b2" translate="yes" xml:space="preserve">
          <source>I'm OK with either approach.  Leaving things the way they are in Python 3
      is no good, IMHO.</source>
          <target state="translated">私はどちらのアプローチでも構いません。Python 3のままにしておくのは、IMHO的にはよくありません。</target>
        </trans-unit>
        <trans-unit id="f3a52ccfeb39b7c960e43a846a1980250d8002bd" translate="yes" xml:space="preserve">
          <source>If the compiler detects the &lt;code&gt;yield&lt;/code&gt; keyword &lt;em&gt;anywhere&lt;/em&gt; inside a function, that function no longer returns via the &lt;code&gt;return&lt;/code&gt; statement. &lt;strong&gt;&lt;em&gt;Instead&lt;/em&gt;&lt;/strong&gt;, it &lt;strong&gt;immediately&lt;/strong&gt; returns a &lt;strong&gt;lazy &quot;pending list&quot; object&lt;/strong&gt; called a generator</source>
          <target state="translated">コンパイラーが関数内の&lt;em&gt;どこかで&lt;/em&gt; &lt;code&gt;yield&lt;/code&gt; キーワードを検出すると、その関数は &lt;code&gt;return&lt;/code&gt; ステートメントを介して戻りません。 &lt;strong&gt;&lt;em&gt;代わりに&lt;/em&gt;&lt;/strong&gt; 、ジェネレータと呼ばれる&lt;strong&gt;遅延「保留リスト」オブジェクトを&lt;/strong&gt; &lt;strong&gt;すぐに&lt;/strong&gt;返します</target>
        </trans-unit>
        <trans-unit id="863b82de998a8840db9f970356b780625e865e98" translate="yes" xml:space="preserve">
          <source>If you need &lt;strong&gt;multiple passes&lt;/strong&gt; and the series isn't too long, just call &lt;code&gt;list()&lt;/code&gt; on it:</source>
          <target state="translated">&lt;strong&gt;複数のパス&lt;/strong&gt;が必要で、シリーズが長すぎない場合&lt;strong&gt;は&lt;/strong&gt; 、それに &lt;code&gt;list()&lt;/code&gt; を呼び出します 。</target>
        </trans-unit>
        <trans-unit id="8e81f608f52f839d0787e210b24258db0ad4019d" translate="yes" xml:space="preserve">
          <source>If you want &lt;strong&gt;a function to return a huge set of values&lt;/strong&gt;, use &lt;code&gt;yield&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;関数が大量の値のセットを返す&lt;/strong&gt;ようにしたい場合は、 &lt;code&gt;yield&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="9e30ae315ff14bf5d22d79d19890817eba23a8df" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://docs.python.org/2/reference/simple_stmts.html#the-return-statement&quot;&gt;Python 2&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/2/reference/simple_stmts.html#the-return-statement&quot;&gt;Python 2の場合&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="ff77817e2891cf318ae9092b17aa58414c356493" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-return-statement&quot;&gt;Python 3&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-return-statement&quot;&gt;Python 3の場合&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="01f20dd2f471369e8b09d4eee95c6fa431042ca7" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Controlling a generator exhaustion&lt;/strong&gt; he calls the &lt;code&gt;.next&lt;/code&gt; method, when instead he should use the builtin function, &lt;code&gt;next&lt;/code&gt;. It would be an appropriate layer of indirection, because his code does not work in Python 3.</source>
          <target state="translated">&lt;strong&gt;ジェネレーターの枯渇の制御で、&lt;/strong&gt;彼は &lt;code&gt;.next&lt;/code&gt; メソッドを呼び出します。代わりに、組み込み関数 &lt;code&gt;next&lt;/code&gt; を使用する必要があります。 彼のコードはPython 3では機能しないため、これは間接参照の適切なレイヤーになります。</target>
        </trans-unit>
        <trans-unit id="9d6c893042f47fbe024cf470eea2e0d66f65c064" translate="yes" xml:space="preserve">
          <source>In Python 3, you can &lt;strong&gt;delegate&lt;/strong&gt; from one generator to another in both directions with &lt;strong&gt;&lt;code&gt;yield from&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">Python 3では、 &lt;strong&gt; &lt;code&gt;yield from&lt;/code&gt; を使用&lt;/strong&gt;して、あるジェネレーターから別のジェネレーターに双方向で&lt;strong&gt;委任&lt;/strong&gt;できます。</target>
        </trans-unit>
        <trans-unit id="8ddb3a147bbf4149f8203b3ca2fa59434dcfe553" translate="yes" xml:space="preserve">
          <source>In Python-speak, an &lt;em&gt;iterable&lt;/em&gt; is any object which &quot;understands the concept of a for-loop&quot; like a list &lt;code&gt;[1,2,3]&lt;/code&gt;, and an &lt;em&gt;iterator&lt;/em&gt; is a specific instance of the requested for-loop like &lt;code&gt;[1,2,3].__iter__()&lt;/code&gt;. A &lt;em&gt;generator&lt;/em&gt; is exactly the same as any iterator, except for the way it was written (with function syntax).</source>
          <target state="translated">Pythonで言うと、 &lt;em&gt;反復可能&lt;/em&gt;オブジェクトはリスト &lt;code&gt;[1,2,3]&lt;/code&gt; のように「forループの概念を理解する」任意のオブジェクトであり、 &lt;em&gt;イテレータ&lt;/em&gt;は &lt;code&gt;[1,2,3].__iter__()&lt;/code&gt; ように要求されたforループの特定のインスタンスです、3] .__ iter __（） 。 &lt;em&gt;ジェネレーター&lt;/em&gt;は、それが（関数構文で）作成された方法を除いて、イテレーターとまったく同じです。</target>
        </trans-unit>
        <trans-unit id="174c5ef25999552b6ac3e98b79e66dc670f6ce7e" translate="yes" xml:space="preserve">
          <source>In a generator function, the &lt;code&gt;return&lt;/code&gt; statement indicates that the generator is done and will cause &lt;code&gt;StopIteration&lt;/code&gt; to be raised. The returned value (if any) is used as an argument to construct &lt;code&gt;StopIteration&lt;/code&gt; and becomes the &lt;code&gt;StopIteration.value&lt;/code&gt; attribute.</source>
          <target state="translated">ジェネレーター関数では、 &lt;code&gt;return&lt;/code&gt; ステートメントはジェネレーターが完了し、 &lt;code&gt;StopIteration&lt;/code&gt; が発生することを示します。 戻り値（存在する場合）は、 &lt;code&gt;StopIteration.value&lt;/code&gt; を構築するための引数として使用され、 StopIteration.value属性になります。</target>
        </trans-unit>
        <trans-unit id="a40ea84cb1072d7d399fbe3b382af1883bc53737" translate="yes" xml:space="preserve">
          <source>In a generator function, the &lt;code&gt;return&lt;/code&gt; statement is not allowed to include an &lt;code&gt;expression_list&lt;/code&gt;. In that context, a bare &lt;code&gt;return&lt;/code&gt; indicates that the generator is done and will cause &lt;code&gt;StopIteration&lt;/code&gt; to be raised.</source>
          <target state="translated">ジェネレーター関数では、 &lt;code&gt;return&lt;/code&gt; ステートメントに &lt;code&gt;expression_list&lt;/code&gt; を含めることはできません。 そのコンテキストでは、ベア &lt;code&gt;return&lt;/code&gt; はジェネレータが完了し、 &lt;code&gt;StopIteration&lt;/code&gt; が発生することを示します。</target>
        </trans-unit>
        <trans-unit id="fe5f6300dd7512030712c12beefa508ff061926a" translate="yes" xml:space="preserve">
          <source>In a nutshell: &lt;strong&gt;a generator is a lazy, incrementally-pending list&lt;/strong&gt;, and &lt;strong&gt;&lt;code&gt;yield&lt;/code&gt; statements allow you to use function notation to program the list values&lt;/strong&gt; the generator should incrementally spit out.</source>
          <target state="translated">簡単に言うと&lt;strong&gt;、ジェネレーターは遅延する段階的に保留中のリスト&lt;/strong&gt;であり、 &lt;strong&gt; &lt;code&gt;yield&lt;/code&gt; ステートメントを使用すると、関数表記を使用して&lt;/strong&gt; 、ジェネレーターが段階的に吐き出す&lt;strong&gt;リスト値をプログラムできます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="a0169a7972621076b895fe9b5351a9c054ff5aa8" translate="yes" xml:space="preserve">
          <source>In conclusion, as a metaphor to grok it:</source>
          <target state="translated">結論から言うと、それをグロッキングするための比喩として。</target>
        </trans-unit>
        <trans-unit id="65df69d0bd87c71c73d55034f2acb57286f92bd2" translate="yes" xml:space="preserve">
          <source>In continuation passing style (CPS), continuations are just normal functions (only in languages where functions are first class) which the programmer explicitly manages and passes around to subroutines. In this style, program state is represented by closures (and the variables that happen to be encoded in them) rather than variables that reside somewhere on the stack. Functions that manage control flow accept continuation as arguments (in some variations of CPS, functions may accept multiple continuations) and manipulate control flow by invoking them by simply calling them and returning afterwards. A very simple example of continuation passing style is as follows:</source>
          <target state="translated">コンティニュエーションパッシングスタイル(CPS)では、コンティニュエーションは通常の関数(関数がファーストクラスの言語でのみ)で、プログラマが明示的に管理してサブルーチンに渡すものです。このスタイルでは、プログラムの状態はスタック上のどこかに存在する変数ではなく、クロージャ(と、その中にたまたまエンコードされた変数)によって表現されます。制御フローを管理する関数は、引数として継続を受け入れ(CPSのいくつかのバリエーションでは、関数は複数の継続を受け入れることができます)、単にそれらを呼び出して後に返すことによってそれらを呼び出すことで制御フローを操作します。継続を渡すスタイルの非常に簡単な例を以下に示します。</target>
        </trans-unit>
        <trans-unit id="f90a21a794093245566d4b9689b0360b69b80989" translate="yes" xml:space="preserve">
          <source>In summary, the &lt;code&gt;yield&lt;/code&gt; statement transforms your function into a factory that produces a special object called a &lt;code&gt;generator&lt;/code&gt; which wraps around the body of your original function. When the &lt;code&gt;generator&lt;/code&gt; is iterated, it executes your function  until it reaches the next &lt;code&gt;yield&lt;/code&gt; then suspends execution and evaluates to the value passed to &lt;code&gt;yield&lt;/code&gt;. It repeats this process on each iteration until the path of execution exits the function. For instance,</source>
          <target state="translated">要約すると、 &lt;code&gt;yield&lt;/code&gt; ステートメントは、関数を、元の関数の本体をラップする &lt;code&gt;generator&lt;/code&gt; と呼ばれる特別なオブジェクトを生成するファクトリーに変換します。 &lt;code&gt;generator&lt;/code&gt; が反復されると、次の &lt;code&gt;yield&lt;/code&gt; に到達するまで関数が実行され、実行が中断され、 &lt;code&gt;yield&lt;/code&gt; に渡された値に評価されます。 実行パスが関数を終了するまで、反復ごとにこのプロセスを繰り返します。 例えば、</target>
        </trans-unit>
        <trans-unit id="dbb3601dd734c0edf841aa944a55cbabed686850" translate="yes" xml:space="preserve">
          <source>In terms of getting there, we'll likely want:</source>
          <target state="translated">そこにたどり着くという意味では、私たちはおそらく欲しがるでしょう。</target>
        </trans-unit>
        <trans-unit id="af70c38bd0efc99a5d44a07df4047e8a92d9ae06" translate="yes" xml:space="preserve">
          <source>In the case of your code, the function &lt;code&gt;get_child_candidates&lt;/code&gt; is acting like an iterator so that when you extend your list, it adds one element at a time to the new list.</source>
          <target state="translated">コードの場合、関数 &lt;code&gt;get_child_candidates&lt;/code&gt; はイテレータのように機能するため、リストを拡張すると、一度に1つの要素が新しいリストに追加されます。</target>
        </trans-unit>
        <trans-unit id="791078267dbf81f5f1c3cf2eb3971161ef95c26f" translate="yes" xml:space="preserve">
          <source>In the second case, &lt;code&gt;bar&lt;/code&gt; just gives you a generator. A generator is an iterable--which means you can use it in a &lt;code&gt;for&lt;/code&gt; loop, etc, but each value can only be accessed once. All the values are also not stored in memory at the same time; the generator object &quot;remembers&quot; where it was in the looping the last time you called it--this way, if you're using an iterable to (say) count to 50 billion, you don't have to count to 50 billion all at once and store the 50 billion numbers to count through.</source>
          <target state="translated">2番目のケースでは、 &lt;code&gt;bar&lt;/code&gt; はジェネレーターを提供するだけです。 ジェネレータは反復可能です。つまり、 &lt;code&gt;for&lt;/code&gt; ループなどで使用できますが、各値にアクセスできるのは1回だけです。 すべての値が同時にメモリに保存されるわけではありません。 ジェネレーターオブジェクトは、最後に呼び出したときにループしていた場所を「記憶」します。つまり、反復可能オブジェクトを使用して（たとえば）500億にカウントする場合、すべてを500億にカウントする必要はありません。一度に500億の数値を保存して、カウントします。</target>
        </trans-unit>
        <trans-unit id="bd951975204b594b5a324c588bdc33476765e99f" translate="yes" xml:space="preserve">
          <source>In this (very simplistic) example, the programmer saves the operation of actually writing the file into a continuation (which can potentially be a very complex operation with many details to write out), and then passes that continuation (i.e, as a first-class closure) to another operator which does some more processing, and then calls it if necessary. (I use this design pattern a lot in actual GUI programming, either because it saves me lines of code or, more importantly, to manage control flow after GUI events trigger.)</source>
          <target state="translated">この(非常に単純な)例では、プログラマは実際にファイルを書き出す操作をコンティニュエーションに保存し(これは、書き出すべき詳細が多く非常に複雑な操作になる可能性があります)、そのコンティニュエーションを(つまり、ファーストクラスのクロージャとして)別の演算子に渡して、さらに処理を行い、必要に応じてそれを呼び出します。(私は実際のGUIプログラミングでこの設計パターンを多用しています。コードの行数を節約できるから、あるいは、GUIイベントがトリガーした後の制御フローを管理するためです)</target>
        </trans-unit>
        <trans-unit id="d137b802f3a324a2d71f425b20cbe30685de8a31" translate="yes" xml:space="preserve">
          <source>Indirectly, if you provide &lt;code&gt;fib&lt;/code&gt; to a &lt;code&gt;for&lt;/code&gt; loop, a &lt;code&gt;list&lt;/code&gt; initializer, a &lt;code&gt;tuple&lt;/code&gt; initializer, or anything else that expects an object that generates/produces values, you'll &quot;consume&quot; the generator until no more values can be produced by it (and it returns):</source>
          <target state="translated">間接的に、 &lt;code&gt;for&lt;/code&gt; ループ、 &lt;code&gt;list&lt;/code&gt; 初期化子、 &lt;code&gt;tuple&lt;/code&gt; 初期化子、または値を生成/生成するオブジェクトを期待するその他のものに &lt;code&gt;fib&lt;/code&gt; を提供する場合、それによって値が生成されなくなるまでジェネレータを「消費」します（そしてそれは戻る）：</target>
        </trans-unit>
        <trans-unit id="1484d552dab70171147c52a184472f4c770e78cd" translate="yes" xml:space="preserve">
          <source>Insert a line &lt;code&gt;result = []&lt;/code&gt; at the start of the function.</source>
          <target state="translated">関数の先頭に行 &lt;code&gt;result = []&lt;/code&gt; を挿入します。</target>
        </trans-unit>
        <trans-unit id="f65bc680a718b8079e23b9ac8d4b6ee9a4e7033d" translate="yes" xml:space="preserve">
          <source>Insert a line &lt;code&gt;return result&lt;/code&gt; at the bottom of the function.</source>
          <target state="translated">関数の下部に改行 &lt;code&gt;return result&lt;/code&gt; を挿入します。</target>
        </trans-unit>
        <trans-unit id="ddae4c2e0ba5c800a528da8a2d033235effb5bce" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;yield&lt;/code&gt; statements, if you had three &lt;code&gt;return&lt;/code&gt; statements in &lt;code&gt;f123()&lt;/code&gt; only the first would get executed, and the function would exit. But &lt;code&gt;f123()&lt;/code&gt; is no ordinary function. When &lt;code&gt;f123()&lt;/code&gt; is called, it &lt;em&gt;does not&lt;/em&gt; return any of the values in the yield statements! It returns a generator object. Also, the function does not really exit - it goes into a suspended state. When the &lt;code&gt;for&lt;/code&gt; loop tries to loop over the generator object, the function resumes from its suspended state at the very next line after the &lt;code&gt;yield&lt;/code&gt; it previously returned from, executes the next line of code, in this case, a &lt;code&gt;yield&lt;/code&gt; statement, and returns that as the next item. This happens until the function exits, at which point the generator raises &lt;code&gt;StopIteration&lt;/code&gt;, and the loop exits.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; ステートメントの代わりに、 &lt;code&gt;f123()&lt;/code&gt; に 3つの &lt;code&gt;return&lt;/code&gt; ステートメントがある場合、最初のステートメントだけが実行され、関数は終了します。 しかし、 &lt;code&gt;f123()&lt;/code&gt; は通常の関数ではありません。 &lt;code&gt;f123()&lt;/code&gt; が呼び出されても、yieldステートメントの値&lt;em&gt;は&lt;/em&gt;返され&lt;em&gt;ません&lt;/em&gt; 。 ジェネレーターオブジェクトを返します。 また、関数は実際には終了せず、一時停止状態になります。 &lt;code&gt;for&lt;/code&gt; ループがジェネレーターオブジェクトをループしようとすると、関数は、以前に返された &lt;code&gt;yield&lt;/code&gt; の直後の次の行で中断状態から再開し、次のコード行（この場合は、 &lt;code&gt;yield&lt;/code&gt; ステートメント）を実行し、それを返します次のアイテムとして。 これは、関数が終了するまで発生します。その時点で、ジェネレーターが &lt;code&gt;StopIteration&lt;/code&gt; を発生させ、ループが終了します。</target>
        </trans-unit>
        <trans-unit id="6ba67eec9e92df05acdf46af85244d2e3cb47ac2" translate="yes" xml:space="preserve">
          <source>Instead of this:</source>
          <target state="translated">これの代わりに</target>
        </trans-unit>
        <trans-unit id="a2128e769c0a333306ebd59207294d6e72de5845" translate="yes" xml:space="preserve">
          <source>It can be useful for various things like controlling access to a resource.</source>
          <target state="translated">リソースへのアクセスを制御するなど、様々なことに役立ちます。</target>
        </trans-unit>
        <trans-unit id="815bab4f701d81dd1ca8739066ea47b1ea845181" translate="yes" xml:space="preserve">
          <source>It is confused on what makes an &lt;strong&gt;iterable&lt;/strong&gt;, just using a list as an example. See my references above, but in summary: an iterable has an &lt;code&gt;__iter__&lt;/code&gt; method returning an &lt;strong&gt;iterator&lt;/strong&gt;. An &lt;strong&gt;iterator&lt;/strong&gt; provides a &lt;code&gt;.next&lt;/code&gt; (Python 2 or &lt;code&gt;.__next__&lt;/code&gt; (Python 3) method, which is implicitly called by &lt;code&gt;for&lt;/code&gt; loops until it raises &lt;code&gt;StopIteration&lt;/code&gt;, and once it does, it will continue to do so.</source>
          <target state="translated">例としてリストを使用するだけで、 &lt;strong&gt;iterableを&lt;/strong&gt;作成する方法について混乱しています。 上記の参考文献を参照してください。ただし、要約すると、反復可能 &lt;code&gt;__iter__&lt;/code&gt; には、 &lt;strong&gt;反復子を&lt;/strong&gt;返す__iter__メソッドがあり&lt;strong&gt;ます&lt;/strong&gt; 。 &lt;strong&gt;イテレータ&lt;/strong&gt;は &lt;code&gt;.next&lt;/code&gt; （Python 2または &lt;code&gt;.__next__&lt;/code&gt; （Python 3）メソッドを提供し&lt;strong&gt;ます。これ&lt;/strong&gt;は、 StopIterationが発生するまで &lt;code&gt;for&lt;/code&gt; ループによって暗黙的に呼び出され、一度発生すると、引き続き実行されます。</target>
        </trans-unit>
        <trans-unit id="d0e5a74aff1c87c165974074b746e9b876037387" translate="yes" xml:space="preserve">
          <source>It is just the same except you used &lt;code&gt;()&lt;/code&gt; instead of &lt;code&gt;[]&lt;/code&gt;. BUT, you &lt;strong&gt;cannot&lt;/strong&gt; perform &lt;code&gt;for i in mygenerator&lt;/code&gt; a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end calculating 4, one by one.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; の代わりに &lt;code&gt;()&lt;/code&gt; を使用したことを除いて、まったく同じです。 しかし、ジェネレーターは一度しか使用&lt;strong&gt;できない&lt;/strong&gt;ため &lt;code&gt;for i in mygenerator&lt;/code&gt; 2回実行する&lt;strong&gt;ことはできません。&lt;/strong&gt;ジェネレーターは0を計算し、それを忘れて1を計算し、4の計算を1つずつ終了します。</target>
        </trans-unit>
        <trans-unit id="05428c01ccee190c5ac8f4e2b026d5698fe85729" translate="yes" xml:space="preserve">
          <source>It really helps simplify some problems, and makes some things easier to work with.</source>
          <target state="translated">それは本当にいくつかの問題を単純化するのに役立ちますし、いくつかの作業をより簡単にしてくれます。</target>
        </trans-unit>
        <trans-unit id="ce1006cada79cecc9b2fc03861f35b39cd056555" translate="yes" xml:space="preserve">
          <source>It seems to be an interesting and nice ability :D</source>
          <target state="translated">面白くて素敵な能力のようです :D</target>
        </trans-unit>
        <trans-unit id="a4c8c5a8330bec1551d58ebddad1eca41f75c743" translate="yes" xml:space="preserve">
          <source>It then uses a generator expression to describe what a generator is. Since a generator is simply a convenient way to create an &lt;strong&gt;iterator&lt;/strong&gt;, it only confuses the matter, and we still have not yet gotten to the &lt;code&gt;yield&lt;/code&gt; part.</source>
          <target state="translated">次に、ジェネレータ式を使用して、ジェネレータとは何かを説明します。 ジェネレータは単に&lt;strong&gt;イテレータ&lt;/strong&gt;を作成するための便利な方法であるため、問題を混乱させるだけであり、まだ &lt;code&gt;yield&lt;/code&gt; 部分に到達していません。</target>
        </trans-unit>
        <trans-unit id="2b525c9fdafab13df3793783112dad0c5e7c47f0" translate="yes" xml:space="preserve">
          <source>It turns out that &lt;code&gt;yield&lt;/code&gt; does a lot. I'm sure I could add even more 
thorough examples to this. If you want more or have some constructive criticism, let me know by commenting
below.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; は多くの効果があることがわかります。 これにさらに徹底した例を追加できると確信しています。 もっと知りたい、または建設的な批判がある場合は、以下のコメントでお知らせください。</target>
        </trans-unit>
        <trans-unit id="bedfd4c2b8ac96435e9dab026a1ad6ca9d8e9595" translate="yes" xml:space="preserve">
          <source>It's returning a generator. I'm not particularly familiar with Python, but I believe it's the same kind of thing as &lt;a href=&quot;http://csharpindepth.com/Articles/Chapter11/StreamingAndIterators.aspx&quot;&gt;C#'s iterator blocks&lt;/a&gt; if you're familiar with those.</source>
          <target state="translated">ジェネレーターを返します。 私は特にPythonに精通していませんが、 &lt;a href=&quot;http://csharpindepth.com/Articles/Chapter11/StreamingAndIterators.aspx&quot;&gt;C＃のイテレーターブロック&lt;/a&gt;と同じようなものだと思います。</target>
        </trans-unit>
        <trans-unit id="b62a14283b71537aa375bb5504d321c2fa6f966c" translate="yes" xml:space="preserve">
          <source>It's the core about &lt;code&gt;yield&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; の核心です。</target>
        </trans-unit>
        <trans-unit id="4dd80eea3f6c51bf5b9c13a8a47609bd55b30e0e" translate="yes" xml:space="preserve">
          <source>Iterables</source>
          <target state="translated">Iterables</target>
        </trans-unit>
        <trans-unit id="d8b8f9a4e83121e284417429816033e650e4b4db" translate="yes" xml:space="preserve">
          <source>Iteration is a process implying iterables (implementing the &lt;code&gt;__iter__()&lt;/code&gt; method) and iterators (implementing the &lt;code&gt;__next__()&lt;/code&gt; method).
Iterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables.</source>
          <target state="translated">反復は、反復可能 &lt;code&gt;__next__()&lt;/code&gt; （ &lt;code&gt;__iter__()&lt;/code&gt; メソッドの実装）と反復子（ __next __（）メソッドの実装）を意味するプロセスです。 イテラブルは、イテレータを取得できるオブジェクトです。 イテレータは、イテラブルを反復できるオブジェクトです。</target>
        </trans-unit>
        <trans-unit id="0ae5cba6a7258c212d3cd38a207c7e9817fe838e" translate="yes" xml:space="preserve">
          <source>Itertools, your best friend</source>
          <target state="translated">Itertools、あなたの親友</target>
        </trans-unit>
        <trans-unit id="45989d87a7cb5c27f41e09694e3e18fcead4c711" translate="yes" xml:space="preserve">
          <source>Itertools? This was not relevant to what &lt;code&gt;yield&lt;/code&gt; does at all.</source>
          <target state="translated">Itertools？ これは、 &lt;code&gt;yield&lt;/code&gt; が何をするかとはまったく関係がありませんでした。</target>
        </trans-unit>
        <trans-unit id="4092678f14b36035b0f14d72fd89eede06817d6a" translate="yes" xml:space="preserve">
          <source>Keep calling the &lt;code&gt;next()&lt;/code&gt; method on the iterator returned from step 1. The return value from &lt;code&gt;next()&lt;/code&gt; is assigned to &lt;code&gt;x&lt;/code&gt; and the loop body is executed. If an exception &lt;code&gt;StopIteration&lt;/code&gt; is raised from within &lt;code&gt;next()&lt;/code&gt;, it means there are no more values in the iterator and the loop is exited.</source>
          <target state="translated">手順1から返された反復子で &lt;code&gt;next()&lt;/code&gt; メソッドを呼び出し続けます。next &lt;code&gt;next()&lt;/code&gt; からの戻り値が &lt;code&gt;x&lt;/code&gt; に割り当てられ、ループ本体が実行されます。 &lt;code&gt;next()&lt;/code&gt; 内から例外 &lt;code&gt;StopIteration&lt;/code&gt; が発生した場合、イテレーターに値がなくなり、ループが終了します。</target>
        </trans-unit>
        <trans-unit id="02ece3e82c3cc947abccfde61ed0ddf58d180562" translate="yes" xml:space="preserve">
          <source>Let's define a function &lt;code&gt;makeRange&lt;/code&gt; that's just like Python's &lt;code&gt;range&lt;/code&gt;. Calling &lt;code&gt;makeRange(n)&lt;/code&gt; RETURNS A GENERATOR:</source>
          <target state="translated">Pythonの &lt;code&gt;range&lt;/code&gt; のような関数 &lt;code&gt;makeRange&lt;/code&gt; を定義しましょう。 &lt;code&gt;makeRange(n)&lt;/code&gt; を呼び出すと、 ジェネレータが返されます。</target>
        </trans-unit>
        <trans-unit id="17e789352f0c8efe4814e81b930cce60ca106303" translate="yes" xml:space="preserve">
          <source>Like every answer suggests, &lt;code&gt;yield&lt;/code&gt; is used for creating a sequence generator. It's used for generating some sequence dynamically. For example, while reading a file line by line on a network, you can use the &lt;code&gt;yield&lt;/code&gt; function as follows:</source>
          <target state="translated">すべての回答が示唆するように、 &lt;code&gt;yield&lt;/code&gt; はシーケンスジェネレーターの作成に使用されます。 シーケンスを動的に生成するために使用されます。 たとえば、ネットワーク上でファイルを1行ずつ読み取るときに、 &lt;code&gt;yield&lt;/code&gt; 関数を次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="f1e0ba1d127fcef46948db3881dab6eede1ff0a8" translate="yes" xml:space="preserve">
          <source>Luckily Guido and his team were generous enough to develop generators so we could just do this;</source>
          <target state="translated">幸いにもグイドと彼のチームは発電機を開発するのに十分な寛大さを持っていたので、私たちはこれを行うことができました。</target>
        </trans-unit>
        <trans-unit id="ea2bbc6304080fdb00b621f7aa3245c1e64e92e2" translate="yes" xml:space="preserve">
          <source>Many people use &lt;code&gt;return&lt;/code&gt; rather than &lt;code&gt;yield&lt;/code&gt;, but in some cases &lt;code&gt;yield&lt;/code&gt; can be more efficient and easier to work with.</source>
          <target state="translated">多くの人は、 &lt;code&gt;yield&lt;/code&gt; ではなく &lt;code&gt;return&lt;/code&gt; を使用しますが、 &lt;code&gt;yield&lt;/code&gt; の方が効率的で扱いやすい場合があります。</target>
        </trans-unit>
        <trans-unit id="f1ecc57d869eaa2aeb4f14bb021fbf641a09a4cf" translate="yes" xml:space="preserve">
          <source>Minutiae</source>
          <target state="translated">Minutiae</target>
        </trans-unit>
        <trans-unit id="63298b940ce76e1f6554f705d9938c3451b0daf7" translate="yes" xml:space="preserve">
          <source>More importantly, &lt;code&gt;yield&lt;/code&gt; is a &lt;strong&gt;barrier&lt;/strong&gt;.</source>
          <target state="translated">さらに重要なのは、 &lt;code&gt;yield&lt;/code&gt; が&lt;strong&gt;障壁となっていること&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="260be5bd97364077b3283e9557a7cf6fccbc23dd" translate="yes" xml:space="preserve">
          <source>Moreover &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;this&lt;/a&gt; will introduce (since Python 3.5):</source>
          <target state="translated">さらに、 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;これ&lt;/a&gt;が導入されます（Python 3.5以降）：</target>
        </trans-unit>
        <trans-unit id="f90dd4485580d3bdc59a261e1ec77656145f7983" translate="yes" xml:space="preserve">
          <source>My vote is it be a SyntaxError since you're not getting what you expect from
    the syntax.</source>
          <target state="translated">私の一票は、構文から期待されるものを得ていないので、SyntaxErrorであることです。</target>
        </trans-unit>
        <trans-unit id="6d2a636bd1ba1e865b86d549524144e1fe118a22" translate="yes" xml:space="preserve">
          <source>No discussion of the methods that &lt;code&gt;yield&lt;/code&gt; provides along with the new functionality &lt;code&gt;yield from&lt;/code&gt; in Python 3. &lt;strong&gt;The top/accepted answer is a very incomplete answer.&lt;/strong&gt;</source>
          <target state="translated">Python 3 &lt;strong&gt;の&lt;/strong&gt;新しい機能である &lt;code&gt;yield from&lt;/code&gt; に加えて、 &lt;code&gt;yield&lt;/code&gt; が提供するメソッドについての議論はありません。 &lt;strong&gt;トップ/受け入れられた答えは非常に不完全な答えです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="957edece43529861540ff3f36e5e7a2451ec8ff3" translate="yes" xml:space="preserve">
          <source>Normally, most people would not care about the following distinctions and probably want to stop reading here.</source>
          <target state="translated">通常、ほとんどの人は以下のような区別は気にしないだろうし、おそらくここで読むのをやめたいと思うだろう。</target>
        </trans-unit>
        <trans-unit id="f8c793e525ecfff42fd9cd9042640febe5190bea" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;def&lt;/code&gt;ining a function which contains a &lt;code&gt;yield&lt;/code&gt; keyword is not the only way to create a generator; it's just the easiest way to create one.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; キーワードを含む関数を定義することがジェネレーターを作成する唯一の方法ではないことに注意してください。 作成する最も簡単な方法です。</target>
        </trans-unit>
        <trans-unit id="c9d2501fc158d349dfef0af0d5919d70d9574d6f" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;for&lt;/code&gt; loop doesn't know what kind of object it's dealing with - it just follows the iterator protocol, and is happy to get item after item as it calls &lt;code&gt;next()&lt;/code&gt;. Built-in lists return their items one by one, dictionaries return the &lt;em&gt;keys&lt;/em&gt; one by one, files return the &lt;em&gt;lines&lt;/em&gt; one by one, etc. And generators return... well that's where &lt;code&gt;yield&lt;/code&gt; comes in:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループは、処理するオブジェクトの種類を認識しないことに注意してください。イテレータプロトコルに従うだけであり、 &lt;code&gt;next()&lt;/code&gt; を呼び出すときに項目ごとに取得できます。 組み込みリストはアイテムを1つずつ返し、ディクショナリは&lt;em&gt;キーを&lt;/em&gt; 1つずつ返し、ファイルは&lt;em&gt;行を&lt;/em&gt; 1つずつ返します。そして、ジェネレーターが返します。</target>
        </trans-unit>
        <trans-unit id="d0983c67f73b9198117de75714eca1653ab0ab62" translate="yes" xml:space="preserve">
          <source>Now let's talk about generators in Python. Generators are a specific subtype of continuation. Whereas &lt;strong&gt;continuations are able in general to save the state of a &lt;em&gt;computation&lt;/em&gt;&lt;/strong&gt; (i.e., the program's call stack), &lt;strong&gt;generators are only able to save the state of iteration over an &lt;em&gt;iterator&lt;/em&gt;&lt;/strong&gt;. Although, this definition is slightly misleading for certain use cases of generators. For instance:</source>
          <target state="translated">次に、Pythonのジェネレーターについて説明します。 ジェネレーターは継続の特定のサブタイプです。 &lt;strong&gt;継続は一般に&lt;em&gt;計算&lt;/em&gt;の状態&lt;/strong&gt; （つまり、プログラムの呼び出しスタック） &lt;strong&gt;を保存でき&lt;/strong&gt;ますが、 &lt;strong&gt;ジェネレーターは&lt;em&gt;イテレーター&lt;/em&gt;の反復の状態のみを保存でき&lt;em&gt;ます&lt;/em&gt;&lt;/strong&gt; 。 ただし、この定義は、ジェネレーターの特定のユースケースでは少し誤解を招きます。 例えば：</target>
        </trans-unit>
        <trans-unit id="cbea0f398a5f710fc8e5fc5cc6c1aa916df7b9fc" translate="yes" xml:space="preserve">
          <source>Now the hard part:</source>
          <target state="translated">今は大変なことになっています。</target>
        </trans-unit>
        <trans-unit id="96065685d9b9c8665dca19ef4217583b206991ad" translate="yes" xml:space="preserve">
          <source>Now upon each iteration a function on the generator called &lt;code&gt;next()&lt;/code&gt; executes the function until it either reaches a 'yield' statement in which it stops and  'yields' the value or reaches the end of the function. In this case on the first call, &lt;code&gt;next()&lt;/code&gt; executes up to the yield statement and yield 'n', on the next call it will execute the  increment statement, jump back to the 'while', evaluate it, and if true, it will stop and yield 'n' again, it will continue that way until the while condition returns false and the generator jumps to the end of the function.</source>
          <target state="translated">今度は、反復のたびに、 &lt;code&gt;next()&lt;/code&gt; と呼ばれるジェネレーターの関数が、関数を実行して「yield」ステートメントに到達し、停止して値を「yield」するか、関数の最後に到達します。 この場合、最初の呼び出しで &lt;code&gt;next()&lt;/code&gt; はyieldステートメントまで実行して「n」を生成し、次の呼び出しでインクリメントステートメントを実行して「while」に戻り、評価し、trueの場合は停止して再び「n」を生成し、while条件がfalseを返し、ジェネレーターが関数の最後にジャンプするまでそのように続きます。</target>
        </trans-unit>
        <trans-unit id="6f591e3f872109c5472337a1e87fe9e3bcde0a83" translate="yes" xml:space="preserve">
          <source>Now, enter in the REPL:</source>
          <target state="translated">では、REPLに入力します。</target>
        </trans-unit>
        <trans-unit id="e92a9d3b2c29a2e3bc4353c33fa7bff82dd4846f" translate="yes" xml:space="preserve">
          <source>Now, recall that &lt;code&gt;yield from&lt;/code&gt; is available in Python 3. This allows us to delegate
coroutines to a subcoroutine:</source>
          <target state="translated">ここで、 &lt;code&gt;yield from&lt;/code&gt; がPython 3で利用可能であることを思い出してください。これにより、コルーチンをサブコルーチンに委任できます。</target>
        </trans-unit>
        <trans-unit id="5a307763317a3a7bc6e71bc9264167d7ad80a27e" translate="yes" xml:space="preserve">
          <source>Now, you win to get all the numbers.</source>
          <target state="translated">さあ、すべての数字を手に入れるために勝利を手に入れてください。</target>
        </trans-unit>
        <trans-unit id="b6987f5b93c9acf22eca3106831b92a972ad34e6" translate="yes" xml:space="preserve">
          <source>On 30 January 2017 at 19:05, Brett Cannon  wrote:</source>
          <target state="translated">2017年1月30日19:05にブレット・キャノンが書きました。</target>
        </trans-unit>
        <trans-unit id="85c98d1e4740c518785320f781b5df7464816e4c" translate="yes" xml:space="preserve">
          <source>On Sun, 29 Jan 2017 at 16:39 Craig Rodrigues  wrote:</source>
          <target state="translated">On Sun,29 Jan 2017 at 16:39 Craig Rodrigues wrote.</target>
        </trans-unit>
        <trans-unit id="effbc2c26171feae094bbbc8c2b18c68368e591a" translate="yes" xml:space="preserve">
          <source>One can yield data programmatically, for example:</source>
          <target state="translated">例えば、プログラムでデータを生成することができます。</target>
        </trans-unit>
        <trans-unit id="8ec523094d69740bf96305160c0edf4de24e608c" translate="yes" xml:space="preserve">
          <source>One more step we can rewrite &lt;code&gt;yield&lt;/code&gt; statement with &lt;code&gt;return&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; で &lt;code&gt;yield&lt;/code&gt; ステートメントを書き直すことができるもう1つのステップ</target>
        </trans-unit>
        <trans-unit id="b31a591d4d9d64b9d692dc2c86bc55fc3a7bde29" translate="yes" xml:space="preserve">
          <source>Original version:</source>
          <target state="translated">オリジナルバージョン。</target>
        </trans-unit>
        <trans-unit id="bee143e2a96019cef9b2e3c68a2e94c347f68a59" translate="yes" xml:space="preserve">
          <source>Other Methods: close and throw</source>
          <target state="translated">他の方法:閉じて投げる</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="5f07ef89f002df2bf1789a1e70ac0785b82990f2" translate="yes" xml:space="preserve">
          <source>Please note: generators can actually be used for many more things, such as &lt;a href=&quot;http://www.dabeaz.com/coroutines/index.html&quot;&gt;implementing coroutines&lt;/a&gt; or non-deterministic programming or other elegant things. However, the &quot;lazy lists&quot; viewpoint I present here is the most common use you will find.</source>
          <target state="translated">注：ジェネレーターは、実際には&lt;a href=&quot;http://www.dabeaz.com/coroutines/index.html&quot;&gt;コルーチンの実装&lt;/a&gt;や非決定的プログラミングなどのエレガントなものなど、さらに多くのことに使用できます。 ただし、ここで説明する「遅延リスト」の視点は、最も一般的な用途です。</target>
        </trans-unit>
        <trans-unit id="00d9b100b9bcc674781b9766a8e6870f8757ebdd" translate="yes" xml:space="preserve">
          <source>Py3k warning in 2.7.x</source>
          <target state="translated">2.7.x での Py3k の警告</target>
        </trans-unit>
        <trans-unit id="cef032cf531f21b2c9cdf6eb64b001d4fb256c9b" translate="yes" xml:space="preserve">
          <source>Python compiles the function, encounters the &lt;code&gt;yield&lt;/code&gt; keyword and simply returns a generator object back at you. Not very helpful it seems.</source>
          <target state="translated">Pythonは関数をコンパイルし、 &lt;code&gt;yield&lt;/code&gt; キーワードを検出して、ジェネレーターオブジェクトを返します。 あまり役に立たないようです。</target>
        </trans-unit>
        <trans-unit id="c0e695374f96756b35fdfe22b9dbb044371df33d" translate="yes" xml:space="preserve">
          <source>Python performs the following two steps:</source>
          <target state="translated">Pythonは以下の2つのステップを実行します。</target>
        </trans-unit>
        <trans-unit id="c35284ab3425210def57302b5a65e2b0a11149ab" translate="yes" xml:space="preserve">
          <source>Remember that this is just pseudocode and the actual implementation of generators in Python is more complex. But as an exercise to understand what is going on, try to use continuation passing style to implement generator objects without use of the &lt;code&gt;yield&lt;/code&gt; keyword.</source>
          <target state="translated">これは単なる擬似コードであり、Pythonでのジェネレータの実際の実装はより複雑であることを覚えておいてください。 しかし、何が起こっているかを理解するための練習として、 &lt;code&gt;yield&lt;/code&gt; キーワードを使用せずに、継続渡しスタイルを使用してジェネレーターオブジェクトを実装してみてください。</target>
        </trans-unit>
        <trans-unit id="1ac5b61c45f411038301d2404cf4fec54441c6ad" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;return&lt;/code&gt; with &lt;code&gt;yield&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; を &lt;code&gt;yield&lt;/code&gt; に置き換えます：</target>
        </trans-unit>
        <trans-unit id="d3afd790e348a0c26c0be34d40ecc9f41e19d26d" translate="yes" xml:space="preserve">
          <source>Replace each &lt;code&gt;yield expr&lt;/code&gt; with &lt;code&gt;result.append(expr)&lt;/code&gt;.</source>
          <target state="translated">各 &lt;code&gt;yield expr&lt;/code&gt; を &lt;code&gt;result.append(expr)&lt;/code&gt; に置き換えます。</target>
        </trans-unit>
        <trans-unit id="25e781fe1df53bae8a289d02fbdb77ae6469547c" translate="yes" xml:space="preserve">
          <source>Run it:</source>
          <target state="translated">それを実行してください。</target>
        </trans-unit>
        <trans-unit id="97dadded1b9f2fcec4b19ca00a996516c8982a2c" translate="yes" xml:space="preserve">
          <source>Same behavior:</source>
          <target state="translated">同じ行動だ</target>
        </trans-unit>
        <trans-unit id="5a97a974883d7bcd43990ce0a93d8ca9aa864bfd" translate="yes" xml:space="preserve">
          <source>Say you wanted to create a your own &lt;code&gt;range&lt;/code&gt; function that produces an iterable range of numbers, you could do it like so,</source>
          <target state="translated">反復可能な範囲の数値を生成する独自の &lt;code&gt;range&lt;/code&gt; 関数を作成したいとします。</target>
        </trans-unit>
        <trans-unit id="2ab0369f1d5983f084d45c352d30c1446684eceb" translate="yes" xml:space="preserve">
          <source>See, you get only a single number rather than a list of them. &lt;code&gt;return&lt;/code&gt; never allows you prevail happily, just implements once and quit.</source>
          <target state="translated">ほら、あなたはそれらのリストではなく単一の数だけを得る。 &lt;code&gt;return&lt;/code&gt; はあなたが幸福に勝つことを決して許さず、一度実装するだけで終了します。</target>
        </trans-unit>
        <trans-unit id="010b0672dea78d8c4aa4f2420058adae5991abbe" translate="yes" xml:space="preserve">
          <source>Shortcut to understanding &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; を理解するためのショートカット</target>
        </trans-unit>
        <trans-unit id="a7942e6cc5e90e1d35d5f04820acc2b178f0f857" translate="yes" xml:space="preserve">
          <source>Similarly, with a &lt;code&gt;tuple&lt;/code&gt; initializer:</source>
          <target state="translated">同様に、 &lt;code&gt;tuple&lt;/code&gt; 初期化子を使って：</target>
        </trans-unit>
        <trans-unit id="b2196b60ca80d641d8c512b27441745d29a9bae0" translate="yes" xml:space="preserve">
          <source>Since yield is an expression, it has been touted by some as interesting to use it in comprehensions or generator expression - in spite of citing no particularly good use-case.</source>
          <target state="translated">yieldは表現なので、特に良い使用例を挙げていないにもかかわらず、理解やジェネレーター表現に使うのが面白いと一部で話題になっています。</target>
        </trans-unit>
        <trans-unit id="eb2327b341cffc04d124fdbbf7357dcf2a6b1dc4" translate="yes" xml:space="preserve">
          <source>So it's a kind of a frozen function that the generator is hanging onto.</source>
          <target state="translated">つまり、ジェネレーターがしがみついているのは、ある種の凍結された機能なんですね。</target>
        </trans-unit>
        <trans-unit id="19673e758686be33a34cf32a2f95654be99c541b" translate="yes" xml:space="preserve">
          <source>So that's the iterator protocol, many objects implement this protocol:</source>
          <target state="translated">これがイテレータプロトコルで、多くのオブジェクトがこのプロトコルを実装しています。</target>
        </trans-unit>
        <trans-unit id="9bd6893f306954b22b5c6d426e694f0b79db960f" translate="yes" xml:space="preserve">
          <source>So the generator object is sort of like an adapter - at one end it exhibits the iterator protocol, by exposing &lt;code&gt;__iter__()&lt;/code&gt; and &lt;code&gt;next()&lt;/code&gt; methods to keep the &lt;code&gt;for&lt;/code&gt; loop happy. At the other end, however, it runs the function just enough to get the next value out of it, and puts it back in suspended mode.</source>
          <target state="translated">したがって、ジェネレーターオブジェクトはアダプターのようなものです &lt;code&gt;__iter__()&lt;/code&gt; および &lt;code&gt;next()&lt;/code&gt; メソッドを公開して &lt;code&gt;for&lt;/code&gt; ループを正常に保つことにより、イテレータープロトコルを示します。 ただし、もう一方の端では、次の値を取得するのに十分なだけ関数を実行し、一時停止モードに戻します。</target>
        </trans-unit>
        <trans-unit id="0846a1b0282a9b40bd6407dbf79fde868f3d33b4" translate="yes" xml:space="preserve">
          <source>So, how do you generate these values? This can either be done directly by using the built-in function &lt;code&gt;next&lt;/code&gt;, or, indirectly by feeding it to a construct that consumes values.</source>
          <target state="translated">では、これらの値をどのように生成しますか？ これは、組み込み関数 &lt;code&gt;next&lt;/code&gt; を使用して直接行うことも、値を使用する構成にそれを供給することによって間接的に行うこともできます。</target>
        </trans-unit>
        <trans-unit id="5a9e453ff9384952ce4f468ed81ccbae376c01b4" translate="yes" xml:space="preserve">
          <source>Sometime later, I tell you, &quot;OK, get ready to tell me the sequence of numbers&quot;.</source>
          <target state="translated">後日、「よし、準備をして数字の羅列を教えてくれ」と言う。</target>
        </trans-unit>
        <trans-unit id="f19056e03502445791c22a8e19229c5e20a55381" translate="yes" xml:space="preserve">
          <source>SyntaxError in 3.8</source>
          <target state="translated">3.8 の SyntaxError</target>
        </trans-unit>
        <trans-unit id="567e7ba961e72df760eb88d4a21163100151b70e" translate="yes" xml:space="preserve">
          <source>SyntaxWarning or DeprecationWarning in 3.7</source>
          <target state="translated">3.7 での SyntaxWarning または DeprecationWarning</target>
        </trans-unit>
        <trans-unit id="9ab0a0362c832896068559a5fa49081174de2ddf" translate="yes" xml:space="preserve">
          <source>That is, it will run the code in your function from the beginning until it hits &lt;code&gt;yield&lt;/code&gt;. Then, it&amp;rsquo;ll return the first value of the loop.</source>
          <target state="translated">つまり、関数のコードを最初から &lt;code&gt;yield&lt;/code&gt; に到達するまで実行します。 次に、ループの最初の値を返します。</target>
        </trans-unit>
        <trans-unit id="838208781647d2859f5be9f1f69a5eae0736b9bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;close&lt;/code&gt; method raises &lt;code&gt;GeneratorExit&lt;/code&gt; at the point the function 
execution was frozen. This will also be called by &lt;code&gt;__del__&lt;/code&gt; so you 
can put any cleanup code where you handle the &lt;code&gt;GeneratorExit&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;close&lt;/code&gt; メソッドは、関数の実行が凍結された時点で &lt;code&gt;GeneratorExit&lt;/code&gt; を発生させます。 これは &lt;code&gt;__del__&lt;/code&gt; からも呼び出されるため、 &lt;code&gt;GeneratorExit&lt;/code&gt; を処理するクリーンアップコードを配置できます。</target>
        </trans-unit>
        <trans-unit id="a3d45fcf0497296d8e1482b4554df59b5eedf048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extend()&lt;/code&gt; method is a list object method that expects an iterable and adds its values to the list.</source>
          <target state="translated">&lt;code&gt;extend()&lt;/code&gt; メソッドは、反復可能オブジェクトを期待し、その値をリストに追加するリストオブジェクトメソッドです。</target>
        </trans-unit>
        <trans-unit id="29609fb0ada2ba2818fb2a90a695577b51e87c1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gi_code&lt;/code&gt; and &lt;code&gt;gi_frame&lt;/code&gt; fields are where the frozen state is stored. Exploring them with &lt;code&gt;dir(..)&lt;/code&gt;, we can confirm that our mental model above is credible.</source>
          <target state="translated">&lt;code&gt;gi_code&lt;/code&gt; および &lt;code&gt;gi_frame&lt;/code&gt; フィールドは、凍結状態が格納される場所です。 それらを &lt;code&gt;dir(..)&lt;/code&gt; で調査すると、上記のメンタルモデルが信頼できることが確認できます。</target>
        </trans-unit>
        <trans-unit id="d96f54e7ea72522d78f3384a3336d7ad5556bc22" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; statement in a generator</source>
          <target state="translated">ジェネレーターの &lt;code&gt;return&lt;/code&gt; ステートメント</target>
        </trans-unit>
        <trans-unit id="77154ad361e61b0b0ba81607182893014c0d1a34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; keyword is reduced to two simple facts:</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; キーワードは2つの単純な事実に削減されます。</target>
        </trans-unit>
        <trans-unit id="dc5a0f0208c180c85b5d0c4f32b9d8172d5659ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; keyword simply collects returning results. Think of &lt;code&gt;yield&lt;/code&gt; like &lt;code&gt;return +=&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; キーワードは、返される結果を収集するだけです。 &lt;code&gt;return +=&lt;/code&gt; ような &lt;code&gt;yield&lt;/code&gt; 考えてください</target>
        </trans-unit>
        <trans-unit id="569b8a7334a018ddbbd0be69dd1861bc7484befb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement in Python returns a generator. A generator in Python is a function that returns</source>
          <target state="translated">Pythonの &lt;code&gt;yield&lt;/code&gt; ステートメントはジェネレーターを返します。 Pythonのジェネレータは、次を返す関数です</target>
        </trans-unit>
        <trans-unit id="286c50d08b635ef15bfeee9cc3db60c93c6ad474" translate="yes" xml:space="preserve">
          <source>The CPython core developers are &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2017-January/147301.html&quot;&gt;discussing deprecating its allowance&lt;/a&gt;.
Here's a relevant post from the mailing list:</source>
          <target state="translated">CPythonのコア開発者は&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2017-January/147301.html&quot;&gt;、その許容範囲の廃止について話し合ってい&lt;/a&gt;ます。 メーリングリストからの関連する投稿は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="4e3fe55c48ec33c0b2a6787983638ea6d62f5711" translate="yes" xml:space="preserve">
          <source>The OO approach, we wrap the metadata &lt;code&gt;as a class&lt;/code&gt;. This is the so-called &lt;code&gt;iterator&lt;/code&gt; who implements the iterator protocol (i.e. the &lt;code&gt;__next__()&lt;/code&gt;, and &lt;code&gt;__iter__()&lt;/code&gt; methods). This is also the commonly seen &lt;a href=&quot;https://en.wikipedia.org/wiki/Iterator_pattern#Python&quot;&gt;iterator design pattern&lt;/a&gt;.</source>
          <target state="translated">OOアプローチでは、メタデータ &lt;code&gt;as a class&lt;/code&gt; ラップします。 これは、イテレータプロトコル（つまり、 &lt;code&gt;__next__()&lt;/code&gt; および &lt;code&gt;__iter__()&lt;/code&gt; メソッド）を実装する、いわゆる &lt;code&gt;iterator&lt;/code&gt; です。 これは、よく見られる&lt;a href=&quot;https://en.wikipedia.org/wiki/Iterator_pattern#Python&quot;&gt;反復子の設計パターンでもあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="b36d36ae5461cd703d79e055f55c9ebb36c41eab" translate="yes" xml:space="preserve">
          <source>The above example can be thought of as merely creating a list which you append to and return:</source>
          <target state="translated">上記の例は、単にリストに追加して返すリストを作成していると考えることができます。</target>
        </trans-unit>
        <trans-unit id="384fee2b6ad3d7469cdf79c4d54b9d63ea5ae224" translate="yes" xml:space="preserve">
          <source>The above simple generator is also equivalent to the below - as of Python 3.3 (and not available in Python 2), you can use &lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/&quot;&gt;&lt;code&gt;yield from&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">上記の単純なジェネレーターは、以下のものとも同等です。Python3.3以降（Python 2では使用できません）、 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/&quot;&gt; &lt;code&gt;yield from&lt;/code&gt; &lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="e62f3d84017118479b990b0d86c245c11aa0d847" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;next()&lt;/code&gt; just calls the objects &lt;code&gt;.next()&lt;/code&gt; function, which is a part of the &quot;iteration protocol&quot; and is found on all iterators. You can manually use the &lt;code&gt;next()&lt;/code&gt; function (and other parts of the iteration protocol) to implement fancy things, usually at the expense of readability, so try to avoid doing that...</source>
          <target state="translated">組み込み関数 &lt;code&gt;next()&lt;/code&gt; は、「反復プロトコル」の一部であり、すべての反復 &lt;code&gt;.next()&lt;/code&gt; あるオブジェクト.next（）関数を呼び出すだけです。 &lt;code&gt;next()&lt;/code&gt; 関数（および反復プロトコルの他の部分）を手動で使用して、通常は読みやすさを犠牲にして豪華なことを実装できるので、そうしないようにしてください...</target>
        </trans-unit>
        <trans-unit id="7de99b1c48ee10b1bddb666e63ca36fa1bf9d357" translate="yes" xml:space="preserve">
          <source>The difference between a list &lt;code&gt;return&lt;/code&gt; outputs and the object &lt;code&gt;yield&lt;/code&gt; output is:</source>
          <target state="translated">リスト &lt;code&gt;return&lt;/code&gt; 出力とオブジェクト &lt;code&gt;yield&lt;/code&gt; 出力の違いは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="bb49489746a020a2dc0a0d8886122c8ac1c8272f" translate="yes" xml:space="preserve">
          <source>The execution control will be transferred from getNextLines() to the &lt;code&gt;for&lt;/code&gt; loop when yield is executed. Thus, every time getNextLines() is invoked, execution begins from the point where it was paused last time.</source>
          <target state="translated">実行制御は、yieldが実行されるときにgetNextLines（）から &lt;code&gt;for&lt;/code&gt; ループに転送されます。 したがって、getNextLines（）が呼び出されるたびに、最後に一時停止したところから実行が開始されます。</target>
        </trans-unit>
        <trans-unit id="9574ade792214860025139f4da109ddb0dd74095" translate="yes" xml:space="preserve">
          <source>The first time the &lt;code&gt;for&lt;/code&gt; calls the generator object created from your function, it will run the code in your function from the beginning until it hits &lt;code&gt;yield&lt;/code&gt;, then it'll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting &lt;code&gt;yield&lt;/code&gt;. That can be because the loop has come to an end, or because you no longer satisfy an &lt;code&gt;&quot;if/else&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; が関数から作成されたジェネレーターオブジェクトを初めて呼び出すと、関数のコードが最初から &lt;code&gt;yield&lt;/code&gt; に到達するまで実行され、ループの最初の値が返されます。 その後、後続の各呼び出しは、関数に記述したループの別の反復を実行し、次の値を返します。 これは、ジェネレーターが空であると見なされるまで続きます。これは、関数が &lt;code&gt;yield&lt;/code&gt; にヒットせずに実行されるときに発生します。 ループが終了したか、 &lt;code&gt;&quot;if/else&quot;&lt;/code&gt; 満たさなくなったことが原因である可能性があります。</target>
        </trans-unit>
        <trans-unit id="55b6d1db997b3f1403e7e44c2927b50a091ed779" translate="yes" xml:space="preserve">
          <source>The functional approach, we wrap the metadata &lt;code&gt;as a function&lt;/code&gt;. This is
the so-called &lt;code&gt;generator function&lt;/code&gt;. But under the hood, the returned &lt;code&gt;generator object&lt;/code&gt; still &lt;code&gt;IS-A&lt;/code&gt; iterator because it also implements the iterator protocol.</source>
          <target state="translated">関数型のアプローチでは、メタデータ &lt;code&gt;as a function&lt;/code&gt; ラップします 。 これは、いわゆる &lt;code&gt;generator function&lt;/code&gt; です。 ただし、内部的には、返された &lt;code&gt;generator object&lt;/code&gt; は &lt;code&gt;IS-A&lt;/code&gt; イテレータであり、これはイテレータプロトコルも実装しているためです。</target>
        </trans-unit>
        <trans-unit id="ad5e73ec25fc40ac5fd2ca20c474cd6986e30ab3" translate="yes" xml:space="preserve">
          <source>The generator remembers it was paused at &lt;code&gt;yield value&lt;/code&gt; and resumes from there. The next message is printed and the search for the &lt;code&gt;yield&lt;/code&gt; statement to pause at it performed again (due to the &lt;code&gt;while&lt;/code&gt; loop).</source>
          <target state="translated">ジェネレーターは、 &lt;code&gt;yield value&lt;/code&gt; 一時停止したことを記憶し、そこから再開します。 次のメッセージが出力され、（ &lt;code&gt;while&lt;/code&gt; ループにより）停止するための &lt;code&gt;yield&lt;/code&gt; ステートメントの検索が再度実行されます。</target>
        </trans-unit>
        <trans-unit id="956ec5707ad9efc1beeb86871d9e095c1cace192" translate="yes" xml:space="preserve">
          <source>The generator type is a sub-type of iterator:</source>
          <target state="translated">ジェネレータ型はイテレータのサブタイプです。</target>
        </trans-unit>
        <trans-unit id="89f016e32a8da16e8af307b674da7c0f4716f8a7" translate="yes" xml:space="preserve">
          <source>The grammar currently allows any expression in a list comprehension.</source>
          <target state="translated">文法では現在、リスト理解の中で任意の表現を許可しています。</target>
        </trans-unit>
        <trans-unit id="edf75537a05166775dfd15ba5c8a40896c6f403e" translate="yes" xml:space="preserve">
          <source>The idea for generators comes from other languages (see footnote 1) with varying implementations. In Python's Generators, the execution of the code is &lt;a href=&quot;https://docs.python.org/3.5/glossary.html#term-generator-iterator&quot;&gt;frozen&lt;/a&gt; at the point of the yield. When the generator is called (methods are discussed below) execution resumes and then freezes at the next yield.</source>
          <target state="translated">ジェネレータのアイデアは、さまざまな実装を持つ他の言語（脚注1を参照）に由来しています。 Pythonのジェネレータでは、コードの実行は、yieldの時点で&lt;a href=&quot;https://docs.python.org/3.5/glossary.html#term-generator-iterator&quot;&gt;凍結さ&lt;/a&gt;れます。 ジェネレーターが呼び出されると（メソッドについては以下で説明します）、実行が再開され、次の収量でフリーズします。</target>
        </trans-unit>
        <trans-unit id="305c568102291c5cb1ca7281807fa2c9a3b573fc" translate="yes" xml:space="preserve">
          <source>The itertools module contains special functions to manipulate iterables. Ever wish to duplicate a generator?
Chain two generators? Group values in a nested list with a one-liner? &lt;code&gt;Map / Zip&lt;/code&gt; without creating another list?</source>
          <target state="translated">itertoolsモジュールには、反復可能オブジェクトを操作するための特別な関数が含まれています。 ジェネレータを複製したいですか？ 2つのジェネレーターをチェーンしますか？ ネストされたリストの値をワンライナーでグループ化しますか？ 別のリストを作成せずに &lt;code&gt;Map / Zip&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="6f58a19a2dd95bc1b3cbfc74f010f82f5559c58c" translate="yes" xml:space="preserve">
          <source>The key idea is that the compiler/interpreter/whatever does some trickery so that as far as the caller is concerned, they can keep calling next() and it will keep returning values - &lt;em&gt;as if the generator method was paused&lt;/em&gt;. Now obviously you can't really &quot;pause&quot; a method, so the compiler builds a state machine for you to remember where you currently are and what the local variables etc look like. This is much easier than writing an iterator yourself.</source>
          <target state="translated">重要なアイデアは、コンパイラー/インタープリター/なんらかのトリックを実行して、呼び出し元に関する限り、next（）を呼び出し続け&lt;em&gt;、ジェネレーターメソッドが一時停止されているかの&lt;/em&gt;ように値を返し続けるということです。 明らかに、メソッドを実際に「一時停止」することはできないため、コンパイラーは、現在の場所やローカル変数などがどのように見えるかを覚えておくための状態マシンを構築します。 これは自分でイテレータを書くよりもはるかに簡単です。</target>
        </trans-unit>
        <trans-unit id="92d79cb061c23c0b97be5b3c6bcac7a9343bbb0e" translate="yes" xml:space="preserve">
          <source>The loop iterates on a list, but the list expands while the loop is being iterated :-) It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, &lt;code&gt;candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))&lt;/code&gt; exhaust all the values of the generator, but &lt;code&gt;while&lt;/code&gt; keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node.</source>
          <target state="translated">ループはリストで反復されますが、ループが反復されている間、リストは拡張されます:-)無限ループになる可能性があるため少し危険でも、これらのネストされたすべてのデータを処理する簡潔な方法です。 この場合、 &lt;code&gt;candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))&lt;/code&gt; はジェネレーターのすべての値を使い果たしますが、同じオブジェクトに適用されていないため、前の値とは異なる値を生成する新しいジェネレーターオブジェクトを作成 &lt;code&gt;while&lt;/code&gt; 続けますノード。</target>
        </trans-unit>
        <trans-unit id="fa326100d98f456e392b2f2fad538e2c0e77b226" translate="yes" xml:space="preserve">
          <source>The most famous user of the iterator protocol is the &lt;code&gt;for&lt;/code&gt; command in Python. So, whenever you do a:</source>
          <target state="translated">イテレータプロトコルの最も有名なユーザーは、Pythonの &lt;code&gt;for&lt;/code&gt; コマンドです。 だから、あなたがするたびに：</target>
        </trans-unit>
        <trans-unit id="db347df1c70b1f578850ca66fe264ef9284adcde" translate="yes" xml:space="preserve">
          <source>The new syntax also opens up some opportunities for optimisation when one generator re-yields values produced by another.</source>
          <target state="translated">新しい構文は、あるジェネレータが別のジェネレータによって生成された値を再収束させる際に、最適化のためのいくつかの機会を提供します。</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">出力されます。</target>
        </trans-unit>
        <trans-unit id="65c10c8b7349834a5510a50665946231ee354c64" translate="yes" xml:space="preserve">
          <source>The power comes from using the generator with a loop that calculates a sequence, the generator executes the loop stopping each time to 'yield' the next result of the calculation, in this way it calculates a list on the fly, the benefit being the memory saved for especially large calculations</source>
          <target state="translated">ジェネレータはループを毎回停止して計算の次の結果を「生成」するためにループを実行します。</target>
        </trans-unit>
        <trans-unit id="fc99ade7c7b098191b4ad77e911e56c56415f9b0" translate="yes" xml:space="preserve">
          <source>The rest of this post will, without loss of generality, conceptualize continuations as CPS, because it is a hell of a lot easier to understand and read.</source>
          <target state="translated">この投稿の残りの部分は、一般性を損なうことなく、連続性をCPSとして概念化します。</target>
        </trans-unit>
        <trans-unit id="a8c92b7c9011965f168156df7f932f40277a20fa" translate="yes" xml:space="preserve">
          <source>The truth is Python performs the above two steps anytime it wants to &lt;em&gt;loop over&lt;/em&gt; the contents of an object - so it could be a for loop, but it could also be code like &lt;code&gt;otherlist.extend(mylist)&lt;/code&gt; (where &lt;code&gt;otherlist&lt;/code&gt; is a Python list).</source>
          <target state="translated">真実は、Pythonがオブジェクトのコンテンツを&lt;em&gt;ループし&lt;/em&gt;たいときはいつでも上記の2つのステップを実行することです。そのため、forループになる可能性がありますが、 &lt;code&gt;otherlist.extend(mylist)&lt;/code&gt; （ &lt;code&gt;otherlist&lt;/code&gt; はPythonリスト）のようなコードでもかまいません。 。</target>
        </trans-unit>
        <trans-unit id="02672c2bae3577e3b6b8642a622474b7f6f3b750" translate="yes" xml:space="preserve">
          <source>The unquoted results are what's printed. The quoted result is what is returned from &lt;code&gt;yield&lt;/code&gt;. Call &lt;code&gt;next&lt;/code&gt; again now:</source>
          <target state="translated">引用符で囲まれていない結果が出力されます。 引用された結果は、 &lt;code&gt;yield&lt;/code&gt; から返されるものです。 今すぐもう一度電話してください：</target>
        </trans-unit>
        <trans-unit id="b738047d593c9d45f3f7f40a6e4eb41f8b25d5d8" translate="yes" xml:space="preserve">
          <source>Then I can use it in other code like this:</source>
          <target state="translated">そうすれば、こんな感じで他のコードでも使えますね。</target>
        </trans-unit>
        <trans-unit id="22b87c58846e1f25413204d0a0b8a1d8ed0faa70" translate="yes" xml:space="preserve">
          <source>Then just &lt;code&gt;import itertools&lt;/code&gt;.</source>
          <target state="translated">次に、 &lt;code&gt;import itertools&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="68d7286f8dc4f85d70f3ddd2982d475286c52f12" translate="yes" xml:space="preserve">
          <source>Then, every other call will run the loop you have written in the function one more time, returning the next value until there isn't any value to return.</source>
          <target state="translated">そうすると、他の呼び出しの度に、関数に書いたループをもう一回実行して、返す値がなくなるまで次の値を返してくれます。</target>
        </trans-unit>
        <trans-unit id="3bb53270d0d4b4b1c8ffaa313d2acf3c3c850136" translate="yes" xml:space="preserve">
          <source>Then, your code will continue from where it left off each time &lt;code&gt;for&lt;/code&gt; uses the generator.</source>
          <target state="translated">その後、ジェネレーター &lt;code&gt;for&lt;/code&gt; 使用するたびに、コードは中断したところから続行されます。</target>
        </trans-unit>
        <trans-unit id="959039a43531d3c4457a69589ed899271db1489a" translate="yes" xml:space="preserve">
          <source>There are 2 approaches to wrap such metadata.</source>
          <target state="translated">このようなメタデータをラップするには2つのアプローチがあります。</target>
        </trans-unit>
        <trans-unit id="1e019b6ab061a03c5c91f64a23063b53844dc5f0" translate="yes" xml:space="preserve">
          <source>There are lots of ways to implement this computation. I used mutation, but it is easy to do it without mutation, by returning the current value and the next yielder.</source>
          <target state="translated">この計算を実装する方法はたくさんあります。私は mutation を使いましたが、mutation を使わずに、現在の値と次のyelder を返すことで簡単にできます。</target>
        </trans-unit>
        <trans-unit id="2d7b67871d58c1c22337093d7853eafa16e73e0b" translate="yes" xml:space="preserve">
          <source>There comes &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; があります</target>
        </trans-unit>
        <trans-unit id="b0a32cb8e02d7bb4ce6cf72881e646c325fc9731" translate="yes" xml:space="preserve">
          <source>There is another &lt;code&gt;yield&lt;/code&gt; use and meaning (since Python 3.3):</source>
          <target state="translated">別の &lt;code&gt;yield&lt;/code&gt; 使用と意味があります（Python 3.3以降）：</target>
        </trans-unit>
        <trans-unit id="3efe40491ef4b5d01abc9316e30e10c965a4a4c9" translate="yes" xml:space="preserve">
          <source>There is more about it in this article about &lt;a href=&quot;http://effbot.org/zone/python-for-statement.htm&quot;&gt;how &lt;code&gt;for&lt;/code&gt; loops work&lt;/a&gt;.</source>
          <target state="translated">この記事では&lt;a href=&quot;http://effbot.org/zone/python-for-statement.htm&quot;&gt;、 &lt;code&gt;for&lt;/code&gt; ループのしくみ&lt;/a&gt;について詳しく説明しています 。</target>
        </trans-unit>
        <trans-unit id="6f47398ac35d029b6377a0b4ddaede2532b3994a" translate="yes" xml:space="preserve">
          <source>There is one major difference, though; see the last section.</source>
          <target state="translated">しかし、一つだけ大きな違いがあります。</target>
        </trans-unit>
        <trans-unit id="dfe628b44e21e48a9a1638275ee2cab7d93e4a99" translate="yes" xml:space="preserve">
          <source>There is one type of answer that I don't feel has been given yet, among the many great answers that describe how to use generators. Here is the programming language theory answer:</source>
          <target state="translated">ジェネレーターの使い方を説明する数多くの素晴らしい回答の中で、まだ与えられていないと感じる回答のタイプがあります。ここでは、プログラミング言語理論の答えを紹介します。</target>
        </trans-unit>
        <trans-unit id="869f60d5d93fd508128a38611098256c7978879c" translate="yes" xml:space="preserve">
          <source>There's one extra thing to mention: a function that yields doesn't actually have to terminate. I've written code like this:</source>
          <target state="translated">もう一つ余計なことがあります。私はこのようなコードを書いたことがあります。</target>
        </trans-unit>
        <trans-unit id="761653d5f6ddfd0071e0c9f8287f586c348d08cd" translate="yes" xml:space="preserve">
          <source>These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.</source>
          <target state="translated">これらのイテレータブルは読みたいだけ読めるので便利ですが、すべての値をメモリに保存してしまうので、たくさんの値を持っているときには必ずしも望むものではありません。</target>
        </trans-unit>
        <trans-unit id="847e29854b26173ea7127ee888f4830e76ab29e1" translate="yes" xml:space="preserve">
          <source>Think of it this way:</source>
          <target state="translated">このように考えてみてください。</target>
        </trans-unit>
        <trans-unit id="ccd34f995b2f074874396138bbe200b9f454f73e" translate="yes" xml:space="preserve">
          <source>This code actually loops over that array twice! :(</source>
          <target state="translated">このコードは、実際にその配列を2回ループしています!</target>
        </trans-unit>
        <trans-unit id="8d161d7ff1bebc685509da31091434ec70757135" translate="yes" xml:space="preserve">
          <source>This code contains several smart parts:</source>
          <target state="translated">このコードには、いくつかのスマートな部分が含まれています。</target>
        </trans-unit>
        <trans-unit id="95d467a037a72f1d404c008c65683f34bbcb709d" translate="yes" xml:space="preserve">
          <source>This is basically what the Python interpreter does with the above code:</source>
          <target state="translated">これは基本的には上記のコードを使ってPythonインタプリタが行うことです。</target>
        </trans-unit>
        <trans-unit id="ea2ea6265215d15078974a1d7665827ca856c901" translate="yes" xml:space="preserve">
          <source>This is because the presence of &lt;code&gt;yield&lt;/code&gt; signaled to Python that you want to create a &lt;em&gt;generator&lt;/em&gt;, that is, an object that generates values on demand.</source>
          <target state="translated">これは、 &lt;em&gt;ジェネレーター&lt;/em&gt; 、つまりオンデマンドで値を生成するオブジェクトを作成することをPythonに通知する &lt;code&gt;yield&lt;/code&gt; が存在するためです。</target>
        </trans-unit>
        <trans-unit id="54444ced92aaabea39a670c4bad4931fb55ea203" translate="yes" xml:space="preserve">
          <source>This is clearly a reasonable iterable whose behavior is well defined -- each time the generator iterates over it, it returns 4 (and does so forever). But it isn't probably the prototypical type of iterable that comes to mind when thinking of iterators (i.e., &lt;code&gt;for x in collection: do_something(x)&lt;/code&gt;). This example illustrates the power of generators: if anything is an iterator, a generator can save the state of its iteration.</source>
          <target state="translated">これは明らかに、その動作が明確に定義された妥当なイテラブルです。ジェネレーターがそれを反復するたびに、4を返します（これは永久に繰り返されます）。 しかし、イテレータについて考えるときに頭に浮かぶのは、おそらくプロトタイプのイテラブルではありません（つまり、 &lt;code&gt;for x in collection: do_something(x)&lt;/code&gt; ）。 この例は、ジェネレーターの能力を示しています。イテレーターが何かある場合、ジェネレーターはイテレーションの状態を保存できます。</target>
        </trans-unit>
        <trans-unit id="6b729e4e5167e0f6ea0ad29b09ff6d8212c4d8e9" translate="yes" xml:space="preserve">
          <source>This is how the &quot;Python iteration protocol&quot; works. That is, what is going on when you do &lt;code&gt;list(makeRange(5))&lt;/code&gt;. This is what I describe earlier as a &quot;lazy, incremental list&quot;.</source>
          <target state="translated">これが「Python反復プロトコル」の仕組みです。 つまり、 &lt;code&gt;list(makeRange(5))&lt;/code&gt; を実行するとどうなるでしょうか。 これは、先ほど「遅延、増分リスト」として説明したものです。</target>
        </trans-unit>
        <trans-unit id="d3493820819de86b02fd63f645e29ae4e0b50631" translate="yes" xml:space="preserve">
          <source>This is the most simple use case of generators. As you said, it can be used to write efficient permutations, using yield to push things up through the call stack instead of using some sort of stack variable. Generators can also be used for specialized tree traversal, and all manner of other things.</source>
          <target state="translated">これはジェネレータの最もシンプルな使用例です。あなたが言ったように、これは効率的な順列を書くために使われ、ある種のスタック変数を使う代わりに yield を使って呼び出しスタックを押し上げることができます。ジェネレータは、特殊な木の探索やその他のあらゆる方法でも使用できます。</target>
        </trans-unit>
        <trans-unit id="f172eb1953bc01c27cabdd6f9c836e9c3d1d5872" translate="yes" xml:space="preserve">
          <source>This is what a generator does (a function that contains a &lt;code&gt;yield&lt;/code&gt;); it starts executing, pauses whenever it does a &lt;code&gt;yield&lt;/code&gt;, and when asked for a &lt;code&gt;.next()&lt;/code&gt; value it continues from the point it was last. It fits perfectly by design with the iterator protocol of Python, which describes how to sequentially request values.</source>
          <target state="translated">これはジェネレーターが行うことです（ &lt;code&gt;yield&lt;/code&gt; を含む関数）。 実行を開始し、 &lt;code&gt;yield&lt;/code&gt; を実行するたびに一時停止し、 &lt;code&gt;.next()&lt;/code&gt; 値を要求されると、最後のポイントから続行します。 これは、Pythonのイテレータプロトコルとの設計により完全に適合します。これは、値を順番に要求する方法を説明します。</target>
        </trans-unit>
        <trans-unit id="c64469b38e358bb60db655f2f7dead53a870f525" translate="yes" xml:space="preserve">
          <source>This trick may give you an idea of the logic behind the function, but what actually happens with &lt;code&gt;yield&lt;/code&gt; is significantly different than what happens in the list based approach. In many cases, the yield approach will be a lot more memory efficient and faster too. In other cases, this trick will get you stuck in an infinite loop, even though the original function works just fine. Read on to learn more...</source>
          <target state="translated">このトリックは、関数の背後にあるロジックのアイデアをあなたに与えるかもしれませんが、実際に &lt;code&gt;yield&lt;/code&gt; で起こることはリストベースのアプローチで起こることとはかなり異なります。 多くの場合、yieldアプローチの方がはるかにメモリ効率が高く、高速です。 他の場合では、元の関数が正常に機能しても、このトリックによって無限ループに陥る可能性があります。 続きを読む...</target>
        </trans-unit>
        <trans-unit id="fe901acdbaffa726773d1aa79c953022a37c87a8" translate="yes" xml:space="preserve">
          <source>This was my first &quot;aha&quot; moment with yield.</source>
          <target state="translated">これは、私にとって初めての「あーっ」と思った瞬間でした。</target>
        </trans-unit>
        <trans-unit id="06ea075137bd0bbc68755225020ab2be38ff24de" translate="yes" xml:space="preserve">
          <source>Thus in short, a function with the following code</source>
          <target state="translated">したがって、簡単に言えば、以下のコードを持つ関数</target>
        </trans-unit>
        <trans-unit id="5d4b050e5c318bdd9abdf7fc385ecbec5643af7f" translate="yes" xml:space="preserve">
          <source>Thus, in the unlikely event that you are failing to do something like this...</source>
          <target state="translated">このように、万が一、こんな失敗をしてしまった場合には</target>
        </trans-unit>
        <trans-unit id="af7dabd9ee0abc1597b9509efda1778a58b95bbe" translate="yes" xml:space="preserve">
          <source>To force the generator to immediately return its pending values, you can pass it into &lt;code&gt;list()&lt;/code&gt; (just like you could any iterable):</source>
          <target state="translated">ジェネレーターに保留中の値を即座に返すように強制するには、それを &lt;code&gt;list()&lt;/code&gt; に渡します（イテラブルと同じように）。</target>
        </trans-unit>
        <trans-unit id="c0114d7058a0e2d82c0d2df0bb48add203549c89" translate="yes" xml:space="preserve">
          <source>To get a better feel for generators, you can play around with the &lt;code&gt;itertools&lt;/code&gt; module (be sure to use &lt;code&gt;chain.from_iterable&lt;/code&gt; rather than &lt;code&gt;chain&lt;/code&gt; when warranted). For example, you might even use generators to implement infinitely-long lazy lists like &lt;code&gt;itertools.count()&lt;/code&gt;. You could implement your own &lt;code&gt;def enumerate(iterable): zip(count(), iterable)&lt;/code&gt;, or alternatively do so with the &lt;code&gt;yield&lt;/code&gt; keyword in a while-loop.</source>
          <target state="translated">ジェネレーターの感触を良くするために、 &lt;code&gt;itertools&lt;/code&gt; モジュールをいじってみてください （保証されている場合は、 &lt;code&gt;chain&lt;/code&gt; ではなく &lt;code&gt;chain.from_iterable&lt;/code&gt; を使用してください ）。 たとえば、ジェネレータを使用して、 &lt;code&gt;itertools.count()&lt;/code&gt; のような無限に長い遅延リストを実装することもできます。 独自の &lt;code&gt;def enumerate(iterable): zip(count(), iterable)&lt;/code&gt; 実装することも、whileループの &lt;code&gt;yield&lt;/code&gt; キーワードを使用して実装することもできます。</target>
        </trans-unit>
        <trans-unit id="47ee4ff7a14b54f8654a7b96763d1d5353cfb7c7" translate="yes" xml:space="preserve">
          <source>To help understand what a &lt;code&gt;yield&lt;/code&gt; does in the following code, you can use your finger to trace the cycle through any code that has a &lt;code&gt;yield&lt;/code&gt;.  Every time your finger hits the &lt;code&gt;yield&lt;/code&gt;, you have to wait for a &lt;code&gt;next&lt;/code&gt; or a &lt;code&gt;send&lt;/code&gt; to be entered.  When a &lt;code&gt;next&lt;/code&gt; is called, you trace through the code until you hit the &lt;code&gt;yield&lt;/code&gt;&amp;hellip; the code on the right of the &lt;code&gt;yield&lt;/code&gt; is evaluated and returned to the caller&amp;hellip; then you wait.  When &lt;code&gt;next&lt;/code&gt; is called again, you perform another loop through the code.  However, you'll note that in a coroutine, &lt;code&gt;yield&lt;/code&gt; can also be used with a &lt;code&gt;send&lt;/code&gt;&amp;hellip; which will send a value from the caller &lt;em&gt;into&lt;/em&gt; the yielding function. If a &lt;code&gt;send&lt;/code&gt; is given, then &lt;code&gt;yield&lt;/code&gt; receives the value sent, and spits it out the left hand side&amp;hellip; then the trace through the code progresses until you hit the &lt;code&gt;yield&lt;/code&gt; again (returning the value at the end, as if &lt;code&gt;next&lt;/code&gt; was called).</source>
          <target state="translated">次のコードで &lt;code&gt;yield&lt;/code&gt; が何をするのかを理解するのに役立つように、あなたの指を使って &lt;code&gt;yield&lt;/code&gt; を持つコードを介してサイクルをトレースできます。 指が &lt;code&gt;yield&lt;/code&gt; に達するたびに、 &lt;code&gt;next&lt;/code&gt; または &lt;code&gt;send&lt;/code&gt; が入力されるのを待つ必要があります。 &lt;code&gt;next&lt;/code&gt; が呼び出されると、 &lt;code&gt;yield&lt;/code&gt; に到達するまでコードをトレースします。&amp;hellip; yieldの右側のコードが評価され、呼び出し元に返されます&amp;hellip;その後、待機します。 &lt;code&gt;next&lt;/code&gt; が再び呼び出されると、コードを介して別のループを実行します。 ただし、コルーチンでは、 &lt;code&gt;yield&lt;/code&gt; を &lt;code&gt;send&lt;/code&gt; と共に使用することもできます 。これは、呼び出し元から値をyield関数に送信します。 &lt;code&gt;send&lt;/code&gt; が指定されている場合、 &lt;code&gt;yield&lt;/code&gt; は送信された値を受け取り、左側にそれを吐き出します。次にコードをたどるトレースは、 &lt;code&gt;yield&lt;/code&gt; が再度ヒットするまで続行されます（ &lt;code&gt;next&lt;/code&gt; が呼び出されたかのように最後に値を返します）。</target>
        </trans-unit>
        <trans-unit id="b2f6f90d2c166bfe4363d100db6a325bd8c53d50" translate="yes" xml:space="preserve">
          <source>To implement iterators, generators, and thread pools for concurrent execution, etc. as thunks (also called anonymous functions), one uses messages sent to a closure object, which has a dispatcher, and the dispatcher answers to &quot;messages&quot;.</source>
          <target state="translated">同時実行のためのイテレータ、ジェネレータ、スレッドプールなどをThunks(匿名関数とも呼ばれる)として実装するには、ディスパッチャを持つクロージャオブジェクトに送られるメッセージを利用し、ディスパッチャが「メッセージ」に答えるという方法があります。</target>
        </trans-unit>
        <trans-unit id="9115b0a8c20c76763e2640100aa35118070b6a7e" translate="yes" xml:space="preserve">
          <source>To master &lt;code&gt;yield&lt;/code&gt;, you must understand that &lt;strong&gt;when you call the function, the code you have written in the function body does not run.&lt;/strong&gt; The function only returns the generator object, this is a bit tricky :-)</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; をマスター&lt;strong&gt;するには、関数を呼び出すときに、関数本体に記述したコードが実行され&lt;/strong&gt;ないことを理解する必要&lt;strong&gt;があります。&lt;/strong&gt; 関数はジェネレーターオブジェクトのみを返します。これは少しトリッキーです:-)</target>
        </trans-unit>
        <trans-unit id="7b9662418d3af2db32eb7c9811a63029be459951" translate="yes" xml:space="preserve">
          <source>To reiterate: Continuations can save the state of a program's stack and generators can save the state of iteration. This means that continuations are more a lot powerful than generators, but also that generators are a lot, lot easier. They are easier for the language designer to implement, and they are easier for the programmer to use (if you have some time to burn, try to read and understand &lt;a href=&quot;http://www.madore.org/~david/computers/callcc.html&quot;&gt;this page about continuations and call/cc&lt;/a&gt;).</source>
          <target state="translated">繰り返します：継続はプログラムのスタックの状態を保存でき、ジェネレーターは反復の状態を保存できます。 これは、継続がジェネレータよりも強力であることを意味しますが、ジェネレータははるかに簡単です。 これらは、言語デザイナーが実装しやすく、プログラマーが使用しやすくなっています（書き込みに時間があれば、 &lt;a href=&quot;http://www.madore.org/~david/computers/callcc.html&quot;&gt;継続とcall / ccに関するこのページ&lt;/a&gt;を読んで理解してください ）。</target>
        </trans-unit>
        <trans-unit id="855f35ae228f90d1d655b0f84b71dcd8c195b750" translate="yes" xml:space="preserve">
          <source>To understand what &lt;code&gt;yield&lt;/code&gt; does, you must understand what &lt;em&gt;generators&lt;/em&gt; are. And before you can understand generators, you must understand &lt;em&gt;iterables&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; が何をするかを理解するには、 &lt;em&gt;ジェネレータと&lt;/em&gt;は何かを理解する必要があります。 ジェネレータを理解する前に、 &lt;em&gt;イテラブルを&lt;/em&gt;理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="3e68d29cff9fbdfeadc382da40caa5670dec8b66" translate="yes" xml:space="preserve">
          <source>Try to get a num_list with &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; で num_listを取得してみてください。</target>
        </trans-unit>
        <trans-unit id="3eb3e1a1dbeab210622a6dce745b27ec3fd6ceec" translate="yes" xml:space="preserve">
          <source>Understanding the inner mechanisms of iteration</source>
          <target state="translated">イテレーションの内部メカニズムを理解する</target>
        </trans-unit>
        <trans-unit id="4965a83c485d39c529c9df84037bbc4eae475d84" translate="yes" xml:space="preserve">
          <source>User-defined classes that implement &lt;code&gt;__iter__()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__iter__()&lt;/code&gt; を実装するユーザー定義クラス。</target>
        </trans-unit>
        <trans-unit id="68ac05f8fef6cd332ab57a59a59a7b6765c2f5ba" translate="yes" xml:space="preserve">
          <source>Uses the iterator to loop over items:</source>
          <target state="translated">イテレータを使用して項目をループします。</target>
        </trans-unit>
        <trans-unit id="9bbf05762b1e4da7eb5da4e2336f231ae41d9fab" translate="yes" xml:space="preserve">
          <source>Using the built-in &lt;code&gt;next()&lt;/code&gt; function, you directly invoke &lt;code&gt;.next&lt;/code&gt;/&lt;code&gt;__next__&lt;/code&gt;, forcing the generator to produce a value:</source>
          <target state="translated">組み込みの &lt;code&gt;next()&lt;/code&gt; 関数を使用して、直接 &lt;code&gt;.next&lt;/code&gt; / &lt;code&gt;__next__&lt;/code&gt; を呼び出し、ジェネレーターに値を生成させます。</target>
        </trans-unit>
        <trans-unit id="bcee0bd785aa39b558b7c8bc31ae6f288f6986a3" translate="yes" xml:space="preserve">
          <source>Usually we pass a list to it:</source>
          <target state="translated">通常はリストを渡します。</target>
        </trans-unit>
        <trans-unit id="3e5ea4b6c7fb3c82481552aaaf2cefbefc296023" translate="yes" xml:space="preserve">
          <source>Usually, you can write code that doesn't use generators but implements the same logic. One option is to use the temporary list 'trick' I mentioned before. That will not work in all cases, for e.g. if you have infinite loops, or it may make inefficient use of memory when you have a really long list. The other approach is to implement a new iterable class SomethingIter that keeps the state in instance members and performs the next logical step in it's next() (or &lt;strong&gt;next&lt;/strong&gt;() in Python 3) method. Depending on the logic, the code inside the next() method may end up looking very complex and be prone to bugs. Here generators provide a clean and easy solution.</source>
          <target state="translated">通常、ジェネレーターを使用しないが同じロジックを実装するコードを作成できます。 1つのオプションは、前に述べた一時的な「トリック」リストを使用することです。 たとえば、無限ループがある場合や、非常に長いリストがある場合にメモリを非効率的に使用する場合など、すべてのケースで機能するわけではありません。 もう1つの方法は、インスタンスメンバーの状態を保持し、そのnext（）（またはPython 3では&lt;strong&gt;next&lt;/strong&gt; （））メソッドで次の論理ステップを実行する新しい反復可能なクラスSomethingIterを実装することです。 ロジックによっては、next（）メソッド内のコードが非常に複雑になり、バグが発生しやすくなる場合があります。 ここでジェネレーターは、クリーンで簡単なソリューションを提供します。</target>
        </trans-unit>
        <trans-unit id="b60b494a256a412f7ab8c496c30174516878d2d5" translate="yes" xml:space="preserve">
          <source>What does the “yield” keyword do</source>
          <target state="translated">歩留まり」というキーワードは何をするのか</target>
        </trans-unit>
        <trans-unit id="8564153bf26487e9c47a7a365dd4a37cb1949c87" translate="yes" xml:space="preserve">
          <source>What happens when the method &lt;code&gt;_get_child_candidates&lt;/code&gt; is called?
Is a list returned? A single element? Is it called again? When will subsequent calls stop?</source>
          <target state="translated">メソッド &lt;code&gt;_get_child_candidates&lt;/code&gt; が呼び出されるとどうなりますか？ リストは返されますか？ 単一の要素？ また呼ばれる？ 以降の通話はいつ停止しますか？</target>
        </trans-unit>
        <trans-unit id="1b4f84d352af15ddc950c1b08d4d361ed4f38885" translate="yes" xml:space="preserve">
          <source>What is the use of the &lt;code&gt;yield&lt;/code&gt; keyword in Python, and what does it do?</source>
          <target state="translated">Pythonの &lt;code&gt;yield&lt;/code&gt; キーワードの使用とは何ですか？</target>
        </trans-unit>
        <trans-unit id="a3a6372570b3576b2b5dd78ff44c4dd57682334c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;next()&lt;/code&gt; is called subsequently, it retrieves the function's belongings onto the stack and re-animates it. The function continues to compute from where it left off, oblivious to the fact that it had just spent an eternity in cold storage.</source>
          <target state="translated">&lt;code&gt;next()&lt;/code&gt; が呼び出されると、関数の所有物がスタックに取得され、再度アニメーション化されます。 関数は、コールドストレージに永遠を費やしたという事実に気づかずに、中断したところから計算を続けます。</target>
        </trans-unit>
        <trans-unit id="0aca1dde96511b6083cb83899e9046f371ad1461" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;yield&lt;/code&gt; is used instead of a &lt;code&gt;return&lt;/code&gt; in a python function, that function is turned into something special called &lt;code&gt;generator function&lt;/code&gt;. That function will return an object of &lt;code&gt;generator&lt;/code&gt; type. &lt;strong&gt;The &lt;code&gt;yield&lt;/code&gt; keyword is a flag to notify the python compiler to treat such function specially.&lt;/strong&gt; Normal functions will terminate once some value is returned from it. But with the help of the compiler, the generator function &lt;strong&gt;can be thought of&lt;/strong&gt; as resumable. That is, the execution context will be restored and the execution will continue from last run. Until you explicitly call return, which will raise a &lt;code&gt;StopIteration&lt;/code&gt; exception (which is also part of the iterator protocol), or reach the end of the function. I found a lot of references about &lt;code&gt;generator&lt;/code&gt; but this &lt;a href=&quot;https://docs.python.org/dev/howto/functional.html#generators&quot;&gt;one&lt;/a&gt; from the &lt;code&gt;functional programming perspective&lt;/code&gt; is the most digestable.</source>
          <target state="translated">Python関数で &lt;code&gt;return&lt;/code&gt; の代わりに &lt;code&gt;yield&lt;/code&gt; を使用すると、その関数は &lt;code&gt;generator function&lt;/code&gt; と呼ばれる特別なものに変わります 。 この関数は、 &lt;code&gt;generator&lt;/code&gt; タイプのオブジェクトを返します。 &lt;strong&gt; &lt;code&gt;yield&lt;/code&gt; キーワードは、Pythonコンパイラにそのような関数を特別に処理するよう通知するためのフラグです。&lt;/strong&gt; 通常の関数は、値が返されると終了します。 しかし、コンパイラーの助けを借りて、ジェネレーター関数&lt;strong&gt;は&lt;/strong&gt;再開可能で&lt;strong&gt;あると考えることができます&lt;/strong&gt; 。 つまり、実行コンテキストが復元され、最後の実行から実行が続行されます。 returnを明示的に呼び出すまでは、 &lt;code&gt;StopIteration&lt;/code&gt; 例外（イテレータプロトコルの一部でもあります）が発生するか、関数の最後に到達します。 私は &lt;code&gt;generator&lt;/code&gt; に関する多くのリファレンスを見つけましたが、 &lt;code&gt;functional programming perspective&lt;/code&gt; はこれが最も消化しやすいものです。</target>
        </trans-unit>
        <trans-unit id="b4956520f1ca1888af160527fdbeadaee79d2a28" translate="yes" xml:space="preserve">
          <source>When a normal function is called, it puts its local variables on the stack, does some computation, then clears the stack and returns. The values of its local variables are never seen again.</source>
          <target state="translated">通常の関数が呼ばれると、そのローカル変数をスタックに置き、何らかの計算を行い、スタックをクリアして返します。そのローカル変数の値は二度と見られません。</target>
        </trans-unit>
        <trans-unit id="958c8511d450491ba26702ca0bd0c2811dde47aa" translate="yes" xml:space="preserve">
          <source>When we call the second function, it behaves very differently to the first. The &lt;code&gt;yield&lt;/code&gt; statement might be unreachable, but if it's present anywhere, it changes the nature of what we're dealing with.</source>
          <target state="translated">2番目の関数を呼び出すと、最初の関数とは非常に異なる動作をします。 &lt;code&gt;yield&lt;/code&gt; ステートメントは到達不可能かもしれませんが、それがどこかに存在する場合、それは私たちが扱っているものの性質を変更します。</target>
        </trans-unit>
        <trans-unit id="550768170ef01550f901dfdde3779cde4dea9c6b" translate="yes" xml:space="preserve">
          <source>When you create a list, you can read its items one by one. Reading its items one by one is called iteration:</source>
          <target state="translated">リストを作成すると、そのリストの項目を一つずつ読むことができます。リストの項目を一つずつ読み取ることをイテレーションといいます。</target>
        </trans-unit>
        <trans-unit id="3b7f697cea53ab4cee00328eb8586bf8e9cddc3b" translate="yes" xml:space="preserve">
          <source>When you enter this into your REPL and then try and call it, you'll get a mystifying result:</source>
          <target state="translated">これをREPLに入力してから呼び出してみると、謎の結果が出てきます。</target>
        </trans-unit>
        <trans-unit id="0e20678b0bb4c25b8fa4c7b3b518c72e5245ebc8" translate="yes" xml:space="preserve">
          <source>When you first invoke &lt;code&gt;fib&lt;/code&gt; by calling it:</source>
          <target state="translated">&lt;code&gt;fib&lt;/code&gt; を最初に呼び出すときに、次のように呼び出します。</target>
        </trans-unit>
        <trans-unit id="b514c61a51b4ead83e3fa823a9f1c657b29464d0" translate="yes" xml:space="preserve">
          <source>When you request an iterator from a list, it creates a new iterator. However, when you request an iterator from an iterator (which you would rarely do), it just gives you a copy of itself.</source>
          <target state="translated">リストからイテレータを要求すると、新しいイテレータを作成します。しかし、イテレータからイテレータを要求すると(これは滅多にしないでしょう)、それ自体のコピーを与えるだけです。</target>
        </trans-unit>
        <trans-unit id="b7cc0f0bf3ed5fc052470ce219aa6f3e30a8013e" translate="yes" xml:space="preserve">
          <source>When you see a function with &lt;code&gt;yield&lt;/code&gt; statements, apply this easy trick to understand what will happen:</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; ステートメントのある関数を見つけたら、次の簡単なトリックを適用して何が起こるかを理解します。</target>
        </trans-unit>
        <trans-unit id="2f6c491a0995ee077800eec24720b11c6e7f2988" translate="yes" xml:space="preserve">
          <source>When you then request it generates the first value, directly or indirectly, it executes all statements that it finds, until it encounters a &lt;code&gt;yield&lt;/code&gt;, it then yields back the value you supplied to &lt;code&gt;yield&lt;/code&gt; and pauses. For an example that better demonstrates this, let's use some &lt;code&gt;print&lt;/code&gt; calls (replace with &lt;code&gt;print &quot;text&quot;&lt;/code&gt; if on Python 2):</source>
          <target state="translated">次に、最初または最初の値を生成するように要求すると、直接または間接的に、見つかったすべてのステートメントが実行され、 &lt;code&gt;yield&lt;/code&gt; が見つかるまで、 &lt;code&gt;yield&lt;/code&gt; と休止のために指定した値が返されます。 これをよりよく示す例として、いくつかの &lt;code&gt;print&lt;/code&gt; 呼び出しを使用してみましょう（Python 2の場合は、 &lt;code&gt;print &quot;text&quot;&lt;/code&gt; 置き換えます ）。</target>
        </trans-unit>
        <trans-unit id="224be01d8e5c7c05d7fa83727c243ea08c1b6325" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;yield&lt;/code&gt; is called, it tells the function to return a continuation.  When the function is called again, it starts from wherever it left off. So, in pseudo-pseudocode (i.e., not pseudocode, but not code) the generator's &lt;code&gt;next&lt;/code&gt; method is basically as follows:</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; が呼び出されると、継続を返すように関数に指示します。 関数が再度呼び出されると、関数は中断したところから開始します。 したがって、疑似疑似コード（つまり、疑似コードではなくコードではない）では、ジェネレーターの &lt;code&gt;next&lt;/code&gt; メソッドは基本的に次のようになります。</target>
        </trans-unit>
        <trans-unit id="f26fb14b01ccba778163556c3df5281b63e8507c" translate="yes" xml:space="preserve">
          <source>Whenever you find yourself building a list from scratch, &lt;code&gt;yield&lt;/code&gt; each piece instead.</source>
          <target state="translated">リストを最初から作成している場合は、代わりに各部分を &lt;code&gt;yield&lt;/code&gt; ます。</target>
        </trans-unit>
        <trans-unit id="365379f34df99ca9b0a193c6b7d8ec4a2986c91d" translate="yes" xml:space="preserve">
          <source>While a lot of answers show why you'd use a &lt;code&gt;yield&lt;/code&gt; to create a generator, there are more uses for &lt;code&gt;yield&lt;/code&gt;.  It's quite easy to make a coroutine, which enables the passing of information between two blocks of code.  I won't repeat any of the fine examples that have already been given about using &lt;code&gt;yield&lt;/code&gt; to create a generator.</source>
          <target state="translated">多くの回答が、 &lt;code&gt;yield&lt;/code&gt; を使用してジェネレーターを作成する理由を示していますが、 yieldの使用法は他にもあります。 コルーチンを作成するのは非常に簡単で、2つのコードブロック間で情報を受け渡すことができます。 ここでは、 &lt;code&gt;yield&lt;/code&gt; を使用してジェネレーターを作成する方法について既に説明した優れた例は繰り返さないことにします。</target>
        </trans-unit>
        <trans-unit id="08166f360bf5ae486bc24968f9bf3f260bd29d10" translate="yes" xml:space="preserve">
          <source>Why Use Generators?</source>
          <target state="translated">なぜジェネレーターを使うのか?</target>
        </trans-unit>
        <trans-unit id="2bba704c3c5538921356a3f491c4600284327828" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;yield&lt;/code&gt; function, when its code begins to run (i.e. after the function is called, returning a generator object, whose &lt;code&gt;next()&lt;/code&gt; method is then invoked), it similarly puts its local variables onto the stack and computes for a while. But then, when it hits the &lt;code&gt;yield&lt;/code&gt; statement, before clearing its part of the stack and returning, it takes a snapshot of its local variables and stores them in the generator object. It also writes down the place where it's currently up to in its code (i.e. the particular &lt;code&gt;yield&lt;/code&gt; statement).</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 関数を使用すると、コードの実行が開始されると（つまり、関数が呼び出されてジェネレーターオブジェクトが返され、その &lt;code&gt;next()&lt;/code&gt; メソッドが呼び出されると）、同様にローカル変数がスタックに配置され、しばらく計算されます。 しかし、 &lt;code&gt;yield&lt;/code&gt; ステートメントにヒットすると、スタックの一部をクリアして戻る前に、ローカル変数のスナップショットを取得してジェネレーターオブジェクトに格納します。 また、コード内の現在の場所（つまり、特定の &lt;code&gt;yield&lt;/code&gt; ステートメント）も書き留めます。</target>
        </trans-unit>
        <trans-unit id="8425e30a55cb65d01335e276892c145cda45d14d" translate="yes" xml:space="preserve">
          <source>Yay - no more &lt;code&gt;yield&lt;/code&gt; statements! Read and figure out code.</source>
          <target state="translated">やった-これ以上の &lt;code&gt;yield&lt;/code&gt; 声明はありません！ コードを読んで理解してください。</target>
        </trans-unit>
        <trans-unit id="33b0fd0f74faa27daf44c1c690d408e467aa0dd1" translate="yes" xml:space="preserve">
          <source>Yield</source>
          <target state="translated">Yield</target>
        </trans-unit>
        <trans-unit id="48f955098d7be7968cf5c16d1f085bb59f48b670" translate="yes" xml:space="preserve">
          <source>Yield gives you a generator.</source>
          <target state="translated">イールドはジェネレーターを提供してくれます。</target>
        </trans-unit>
        <trans-unit id="cacdcd91fde152ba93b046096635f8dd9f810e6b" translate="yes" xml:space="preserve">
          <source>Yield is &lt;strong&gt;lazy&lt;/strong&gt;, it puts off computation. A function with a yield in it &lt;em&gt;doesn't actually execute at all when you call it.&lt;/em&gt; It returns an &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#yieldexpr&quot;&gt;iterator object&lt;/a&gt; that remembers where it left off. Each time you call &lt;code&gt;next()&lt;/code&gt; on the iterator (this happens in a for-loop) execution inches forward to the next yield. &lt;code&gt;return&lt;/code&gt; raises StopIteration and ends the series (this is the natural end of a for-loop).</source>
          <target state="translated">収量は&lt;strong&gt;怠惰であり&lt;/strong&gt; 、計算を先送りにします。 収量が含まれる関数は、 &lt;em&gt;呼び出しても実際&lt;/em&gt;に&lt;em&gt;はまったく実行されません。&lt;/em&gt; 中断したところを記憶する&lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#yieldexpr&quot;&gt;反復子オブジェクト&lt;/a&gt;を返します。 イテレータで &lt;code&gt;next()&lt;/code&gt; を呼び出すたびに（これはforループで発生します）、次のyieldまで数インチ先に実行されます。 &lt;code&gt;return&lt;/code&gt; はStopIterationを発生させ、シリーズを終了します（これはforループの自然な終わりです）。</target>
        </trans-unit>
        <trans-unit id="ba1346186897dbbfeb506927791cbf680a8824df" translate="yes" xml:space="preserve">
          <source>Yield is &lt;strong&gt;single-pass&lt;/strong&gt;: you can only iterate through once. When a function has a yield in it we call it a &lt;a href=&quot;https://stackoverflow.com/a/1756342/673991&quot;&gt;generator function&lt;/a&gt;. And an &lt;a href=&quot;https://stackoverflow.com/a/9884501/673991&quot;&gt;iterator&lt;/a&gt; is what it returns. Those terms are revealing. We lose the convenience of a container, but gain the power of a series that's computed as needed, and arbitrarily long.</source>
          <target state="translated">歩留まりは&lt;strong&gt;シングルパス&lt;/strong&gt;です。反復できるのは1回だけです。 関数にyieldがある場合、それを&lt;a href=&quot;https://stackoverflow.com/a/1756342/673991&quot;&gt;ジェネレーター関数&lt;/a&gt;と呼びます 。 そして&lt;a href=&quot;https://stackoverflow.com/a/9884501/673991&quot;&gt;イテレータ&lt;/a&gt;はそれが返すものです。 それらの用語は明らかになっています。 コンテナーの利便性は失われますが、必要に応じて計算され、任意に長くなるシリーズの能力が得られます。</target>
        </trans-unit>
        <trans-unit id="8eb3142ec6ce40811e7cb41ff05374c2da24d165" translate="yes" xml:space="preserve">
          <source>Yield is &lt;strong&gt;versatile&lt;/strong&gt;. Data doesn't have to be stored all together, it can be made available one at a time. It can be infinite.</source>
          <target state="translated">収量は&lt;strong&gt;多用途&lt;/strong&gt;です。 データをまとめて保存する必要はありません。一度に1つずつ利用できるようにすることができます。 それは無限になり得ます。</target>
        </trans-unit>
        <trans-unit id="42e3a00c8f296b5fa17180ed67b9949807587502" translate="yes" xml:space="preserve">
          <source>You can also throw an exception which can be handled in the generator
or propagated back to the user:</source>
          <target state="translated">ジェネレータで処理したり、ユーザに伝搬させたりする例外を投げることもできます。</target>
        </trans-unit>
        <trans-unit id="3ad9323c26f58229cc6c89459957a3157bf59a21" translate="yes" xml:space="preserve">
          <source>You can read more about the precise semantics of &lt;code&gt;yield from&lt;/code&gt; in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/#formal-semantics&quot;&gt;PEP 380.&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;yield from&lt;/code&gt; の正確なセマンティクスについて詳しくは、 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/#formal-semantics&quot;&gt;PEP 380を参照してください。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="170b20ccfec99da9235a6ef28068af3e2591fc27" translate="yes" xml:space="preserve">
          <source>You can stop here, or read a little bit to see an advanced use of a generator:</source>
          <target state="translated">ここで止めてもいいし、ジェネレーターの高度な使い方を少し読んでみてもいいと思います。</target>
        </trans-unit>
        <trans-unit id="56ff330d6def0407146a91a863f8fc2587a5c6d6" translate="yes" xml:space="preserve">
          <source>You can use it in your code as follows:</source>
          <target state="translated">以下のようにコードの中で使うことができます。</target>
        </trans-unit>
        <trans-unit id="82929aa8decc455ab58ff5e64314ac91e1a3d659" translate="yes" xml:space="preserve">
          <source>You create an array that you only use once (this wastes memory)</source>
          <target state="translated">一度しか使用しない配列を作成します(これはメモリを無駄にします)。</target>
        </trans-unit>
        <trans-unit id="e5238c336d39149ce635875c88df949f1a84273e" translate="yes" xml:space="preserve">
          <source>You don't need to read the values twice.</source>
          <target state="translated">値を二度読みする必要はありません。</target>
        </trans-unit>
        <trans-unit id="02fbf8c8568af6ce36580f6ee74a1c505f605eb0" translate="yes" xml:space="preserve">
          <source>You may have a lot of children and you don't want them all stored in memory.</source>
          <target state="translated">お子さんが多いかもしれませんし、全てを記憶の中に保存しておくのは避けたいですよね。</target>
        </trans-unit>
        <trans-unit id="e5126053bf6eeea52bae61ffbf604541a9b1ae8d" translate="yes" xml:space="preserve">
          <source>You will always get [0, 1, 2] from a list object but only could retrieve them from 'the object &lt;code&gt;yield&lt;/code&gt; output' once. So, it has a new name &lt;code&gt;generator&lt;/code&gt; object as displayed in &lt;code&gt;Out[11]: &amp;lt;generator object num_list at 0x10327c990&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">リストオブジェクトから常に[0、1、2]を取得しますが、「オブジェクト &lt;code&gt;yield&lt;/code&gt; 出力」から取得できるのは1回だけです。 したがって、 &lt;code&gt;Out[11]: &amp;lt;generator object num_list at 0x10327c990&amp;gt;&lt;/code&gt; 表示されているように、新しい名前 &lt;code&gt;generator&lt;/code&gt; オブジェクトがあります。</target>
        </trans-unit>
        <trans-unit id="2f8b14bde35e7bc3becf466f732823047f257702" translate="yes" xml:space="preserve">
          <source>You'll have to make another if you want to use its functionality again (see footnote 2):</source>
          <target state="translated">またその機能を使いたい場合は別のものを作る必要があります(脚注2参照)。</target>
        </trans-unit>
        <trans-unit id="7ea7dca3eb3be682f93182ec4cb7bfa2d14d36ad" translate="yes" xml:space="preserve">
          <source>Your code explained</source>
          <target state="translated">あなたのコードの説明</target>
        </trans-unit>
        <trans-unit id="4c58039107bd67500d2d3318769f8f423735fd2d" translate="yes" xml:space="preserve">
          <source>[This is the step most people forget to tell you about]</source>
          <target state="translated">【ほとんどの人が伝え忘れているこのステップ】。</target>
        </trans-unit>
        <trans-unit id="822a8e24b36ceb4904c03d9fb614f6c229c4b157" translate="yes" xml:space="preserve">
          <source>and use it like this;</source>
          <target state="translated">と、こんな感じで使ってみてください。</target>
        </trans-unit>
        <trans-unit id="a77a5320b0aaedb8d68bfda55fda0542b3d92a2f" translate="yes" xml:space="preserve">
          <source>build a series of stuff</source>
          <target state="translated">積み上げる</target>
        </trans-unit>
        <trans-unit id="d3e0b619b3729b20359ab7068cacec3bc130b31e" translate="yes" xml:space="preserve">
          <source>continuations</source>
          <target state="translated">continuations</target>
        </trans-unit>
        <trans-unit id="8225801242495db96d7b6f7c5559aeb4cf7bcbd2" translate="yes" xml:space="preserve">
          <source>do this:</source>
          <target state="translated">これをしてください。</target>
        </trans-unit>
        <trans-unit id="70098eefec2efcfcd1042865cc5c5b7d99f6abcc" translate="yes" xml:space="preserve">
          <source>eventually, you might come to an end. You don't tell me a number; you just shout, &quot;hold your horses! I'm done! No more numbers!&quot;</source>
          <target state="translated">そのうち、あなたも終わりを迎えるかもしれません。番号は教えてくれず、ただ「待て!」と叫ぶだけです。私は終わりだ!もう番号はいらない!&quot;</target>
        </trans-unit>
        <trans-unit id="4920bb1daf53da0a3e71fa2a9e6eb26483536f6d" translate="yes" xml:space="preserve">
          <source>it doesn't matter if &lt;code&gt;sequence&lt;/code&gt; is a list, a string, a dictionary or a generator &lt;em&gt;object&lt;/em&gt; like described above; the result is the same: you read items off a sequence one by one.</source>
          <target state="translated">&lt;code&gt;sequence&lt;/code&gt; がリスト、文字列、辞書、または上記のようなジェネレーター&lt;em&gt;オブジェクトで&lt;/em&gt;あるかどうかは関係ありません。 結果は同じです。シーケンスからアイテムを1つずつ読み取ります。</target>
        </trans-unit>
        <trans-unit id="3fc77b0bc00895bd9fb6a9b4c27987e556677c13" translate="yes" xml:space="preserve">
          <source>like barrier in the CUDA language, it will not transfer control until it gets
  completed.</source>
          <target state="translated">CUDA言語のバリアのように、それが完成するまで制御を転送しません。</target>
        </trans-unit>
        <trans-unit id="75e2309b5e1075332554d77f44b43d1c7f6a103e" translate="yes" xml:space="preserve">
          <source>simply outputs</source>
          <target state="translated">単純出力</target>
        </trans-unit>
        <trans-unit id="7f9590246b59001286048a3a2c09550745ee2ab7" translate="yes" xml:space="preserve">
          <source>to avoid coroutines being confused with a regular generator (today &lt;code&gt;yield&lt;/code&gt; is used in both).</source>
          <target state="translated">コルーチンが通常のジェネレーターと混同されないようにするため（今日の &lt;code&gt;yield&lt;/code&gt; は両方で使用されます）。</target>
        </trans-unit>
        <trans-unit id="2c520454aaae8b0b40814f37e538a2a4da92490e" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;yield&lt;/code&gt; keyword is actually syntactic sugar for the real generator function, basically something like:</source>
          <target state="translated">ここで、 &lt;code&gt;yield&lt;/code&gt; キーワードは実際には実際のジェネレーター関数の構文糖であり、基本的には次のようなものです。</target>
        </trans-unit>
        <trans-unit id="d893c24989b32aee817b8346e7ad376f369b2d24" translate="yes" xml:space="preserve">
          <source>will print</source>
          <target state="translated">印刷されます</target>
        </trans-unit>
        <trans-unit id="4ebe44985fd81b0255b36a096600873c8ed8bf99" translate="yes" xml:space="preserve">
          <source>you have a generator object now waiting for a command for it to generate a value. Use &lt;code&gt;next&lt;/code&gt; and see what get's printed:</source>
          <target state="translated">値を生成するためのコマンドを待機しているジェネレーターオブジェクトがあります。 &lt;code&gt;next&lt;/code&gt; を使用して、何が印刷されるかを確認します。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
