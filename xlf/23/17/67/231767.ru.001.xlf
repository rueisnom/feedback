<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/231767">
    <body>
      <group id="231767">
        <trans-unit id="3ab3cb492545479a81b590f95c9c450455ddcdb4" translate="yes" xml:space="preserve">
          <source>&quot;&lt;em&gt;next&lt;/em&gt;&quot; is a message sent to a closure, created by the &quot;&lt;em&gt;iter&lt;/em&gt;&quot; call.</source>
          <target state="translated">&amp;laquo; &lt;em&gt;next&lt;/em&gt; &amp;raquo; - это сообщение, отправленное закрытию, созданное вызовом &amp;laquo; &lt;em&gt;iter&lt;/em&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="1c0a4cfbcf63e8fb4ae3a319aeb3fe7f9e9106c2" translate="yes" xml:space="preserve">
          <source>&amp;hellip; repeat previous step, until&amp;hellip;</source>
          <target state="translated">... повторять предыдущий шаг, пока ...</target>
        </trans-unit>
        <trans-unit id="a6bd3f8f802396a1fb3f884b82392e785e8a7356" translate="yes" xml:space="preserve">
          <source>(Appendix critiques a couple of answers, including the top one, and discusses the use of &lt;code&gt;return&lt;/code&gt; in a generator.)</source>
          <target state="translated">(Приложение критикует пару ответов, включая верхний, и обсуждает использование &lt;code&gt;return&lt;/code&gt; в генераторе.)</target>
        </trans-unit>
        <trans-unit id="911bcad209bd54af6df884267feb81dcf90ade83" translate="yes" xml:space="preserve">
          <source>(My below answer only speaks from the perspective of using Python generator, not the &lt;a href=&quot;https://stackoverflow.com/questions/8389812/how-are-generators-and-coroutines-implemented-in-cpython&quot;&gt;underlying implementation of generator mechanism&lt;/a&gt;, which involves some tricks of stack and heap manipulation.)</source>
          <target state="translated">(Мой ответ ниже говорит только с точки зрения использования генератора Python, а не &lt;a href=&quot;https://stackoverflow.com/questions/8389812/how-are-generators-and-coroutines-implemented-in-cpython&quot;&gt;базовой реализации механизма генератора&lt;/a&gt; , который включает в себя некоторые приемы работы со стеком и кучей.)</target>
        </trans-unit>
        <trans-unit id="afb37c24b5b881de80de7247dc75c21ceafe07ec" translate="yes" xml:space="preserve">
          <source>(Now I want to talk about the rationale behind &lt;code&gt;generator&lt;/code&gt;, and the &lt;code&gt;iterator&lt;/code&gt; based on my own understanding. I hope this can help you grasp the &lt;strong&gt;&lt;em&gt;essential motivation&lt;/em&gt;&lt;/strong&gt; of iterator and generator. Such concept shows up in other languages as well such as C#.)</source>
          <target state="translated">(Теперь я хочу поговорить об обосновании &lt;code&gt;generator&lt;/code&gt; и об &lt;code&gt;iterator&lt;/code&gt; основанном на моем собственном понимании. Надеюсь, это поможет вам понять &lt;strong&gt;&lt;em&gt;основную мотивацию&lt;/em&gt;&lt;/strong&gt; итератора и генератора. Такая концепция проявляется и в других языках, таких как C #.)</target>
        </trans-unit>
        <trans-unit id="adc9c0af7e633a543a37a61fedbb4daccf85e945" translate="yes" xml:space="preserve">
          <source>(and specifically a type of coroutine, but continuations represent the more general mechanism to understand what is going on).</source>
          <target state="translated">(и,в частности,тип корутины,но продолжения представляют собой более общий механизм для понимания того,что происходит).</target>
        </trans-unit>
        <trans-unit id="5375d7ac510abd4ae6e424a7dc969f2441dd692e" translate="yes" xml:space="preserve">
          <source>--  Nick Coghlan   |   ncoghlan at gmail.com   |   Brisbane, Australia</source>
          <target state="translated">ncoghlan at gmail.com</target>
        </trans-unit>
        <trans-unit id="62855b351e703dcbddfc4ef993d2891ccb386e20" translate="yes" xml:space="preserve">
          <source>... then remember that a generator is an &lt;em&gt;iterator&lt;/em&gt;; that is, it is one-time-use. If you want to reuse it, you should call &lt;code&gt;myRange(...)&lt;/code&gt; again. If you need to use the result twice, convert the result to a list and store it in a variable &lt;code&gt;x = list(myRange(5))&lt;/code&gt;. Those who absolutely need to clone a generator (for example, who are doing terrifyingly hackish metaprogramming) can use &lt;a href=&quot;https://docs.python.org/2/library/itertools.html#itertools.tee&quot;&gt;&lt;code&gt;itertools.tee&lt;/code&gt;&lt;/a&gt; if absolutely necessary, since the copyable iterator Python &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_Enhancement_Proposal#Development&quot;&gt;PEP&lt;/a&gt; standards proposal has been deferred.</source>
          <target state="translated">... потом помните, что генератор - это &lt;em&gt;итератор&lt;/em&gt; ; то есть одноразовое использование. Если вы хотите использовать его повторно, вам следует &lt;code&gt;myRange(...)&lt;/code&gt; вызвать myRange (...) . Если вам нужно использовать результат дважды, преобразуйте результат в список и сохраните его в переменной &lt;code&gt;x = list(myRange(5))&lt;/code&gt; . Те, кому абсолютно необходимо клонировать генератор (например, кто выполняет ужасно хакерское метапрограммирование), могут использовать &lt;a href=&quot;https://docs.python.org/2/library/itertools.html#itertools.tee&quot;&gt; &lt;code&gt;itertools.tee&lt;/code&gt; ,&lt;/a&gt; если это абсолютно необходимо, так как предложение стандартов Python &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_Enhancement_Proposal#Development&quot;&gt;PEP для&lt;/a&gt; итератора было отложено.</target>
        </trans-unit>
        <trans-unit id="164d0459345ae6f00bc812c7394f8917ff09c4bc" translate="yes" xml:space="preserve">
          <source>...provide the next data in the series.</source>
          <target state="translated">...предоставить следующие данные в серии.</target>
        </trans-unit>
        <trans-unit id="391e35abadb8cf99afd59f9fdc30216a58ce407f" translate="yes" xml:space="preserve">
          <source>...relinquish CPU execution until the iterator advances.</source>
          <target state="translated">...отказаться от выполнения процессора до тех пор,пока итератор не продвинется.</target>
        </trans-unit>
        <trans-unit id="1827a89fdabc2940a265095fb52eea3cd75fc746" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This step corresponds to &lt;code&gt;def&lt;/code&gt;ining the generator function, i.e. the function containing a &lt;code&gt;yield&lt;/code&gt;.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Этот шаг соответствует &lt;code&gt;def&lt;/code&gt; функции генератора, то есть функции, содержащей &lt;code&gt;yield&lt;/code&gt; .&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="22db8f278d2cf3273c51bb64d7f5260d4584c88d" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This step corresponds to calling &lt;code&gt;.next()&lt;/code&gt; on the generator object.&lt;/b&gt;</source>
          <target state="translated">&lt;b&gt;Этот шаг соответствует вызову &lt;code&gt;.next()&lt;/code&gt; для объекта генератора.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="721dffe48ec31d738fb17ec67ecedf85cc9ef1cd" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This step corresponds to calling the generator function which returns a generator object.&lt;/b&gt; Note that you don't tell me any numbers yet; you just grab your paper and pencil.</source>
          <target state="translated">&lt;b&gt;Этот шаг соответствует вызову функции генератора, которая возвращает объект генератора.&lt;/b&gt; Обратите внимание, что вы еще не сказали мне никаких чисел; Вы просто берете свою бумагу и карандаш.</target>
        </trans-unit>
        <trans-unit id="b9a955eec36cf4b6c9a4e64ce4bf09d433135e6a" translate="yes" xml:space="preserve">
          <source>&lt;b&gt;This step corresponds to the generator object ending its job, and raising a &lt;code&gt;StopIteration&lt;/code&gt; exception&lt;/b&gt; The generator function does not need to raise the exception. It's raised automatically when the function ends or issues a &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="translated">&lt;b&gt;Этот шаг соответствует объекту-генератору, завершающему свою работу и &lt;code&gt;StopIteration&lt;/code&gt; исключение StopIteration&lt;/b&gt; Функция-генератор не должна вызывать исключение. Он вызывается автоматически, когда функция завершается или выдает &lt;code&gt;return&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f08ebcf021089bec1572b041eac525a374a0d033" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list.extend&lt;/code&gt; calls an iterator until it's exhausted. In the case of the code sample you posted, it would be much clearer to just return a tuple and append that to the list.</source>
          <target state="translated">&lt;code&gt;list.extend&lt;/code&gt; вызывает итератор, пока он не исчерпан. В случае с примером кода, который вы опубликовали, было бы намного проще просто вернуть кортеж и добавить его в список.</target>
        </trans-unit>
        <trans-unit id="5fea5fac7cbf1b26fe6763d6386ee47d486dbda6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;list&lt;/code&gt; and &lt;code&gt;generator&lt;/code&gt; are twins</source>
          <target state="translated">&lt;code&gt;list&lt;/code&gt; и &lt;code&gt;generator&lt;/code&gt; близнецы</target>
        </trans-unit>
        <trans-unit id="9902af71eb478ea1b302fe4da1da7cf183f39ef8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;mylist&lt;/code&gt; is an &lt;em&gt;iterable&lt;/em&gt;. When you use a list comprehension, you create a list, and so an iterable:</source>
          <target state="translated">&lt;code&gt;mylist&lt;/code&gt; является &lt;em&gt;повторяемым&lt;/em&gt; . Когда вы используете понимание списка, вы создаете список, и поэтому повторяемый:</target>
        </trans-unit>
        <trans-unit id="38f4e38094ba58e67ca37899086f5ea94d637159" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;return&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt; are twins</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; и &lt;code&gt;yield&lt;/code&gt; близнецы</target>
        </trans-unit>
        <trans-unit id="7b01d9479576f8dc8ce3cf24ecbd8c38827200bf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; forms an expression that allows data to be sent into the generator (see footnote 3)</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; формирует выражение, позволяющее отправлять данные в генератор (см. сноску 3).</target>
        </trans-unit>
        <trans-unit id="393afd38f0f130b369c23e78f4c43a313a970250" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Syntactic_sugar&quot;&gt;sugary&lt;/a&gt; way to say</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; - это &lt;a href=&quot;https://en.wikipedia.org/wiki/Syntactic_sugar&quot;&gt;сладкий&lt;/a&gt; способ сказать</target>
        </trans-unit>
        <trans-unit id="f0678b46e10ca9ffeda185128b6349088f185f67" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; is a keyword that is used like &lt;code&gt;return&lt;/code&gt;, except the function will return a generator.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; - это ключевое слово, которое используется как &lt;code&gt;return&lt;/code&gt; , за исключением того, что функция вернет генератор.</target>
        </trans-unit>
        <trans-unit id="d4184f15f233616d72aa7e7ca25ec3a4265c4298" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; is just like &lt;code&gt;return&lt;/code&gt; - it returns whatever you tell it to (as a generator). The difference is that the next time you call the generator, execution starts from the last call to the &lt;code&gt;yield&lt;/code&gt; statement. Unlike return, &lt;strong&gt;the stack frame is not cleaned up when a yield occurs, however control is transferred back to the caller, so its state will resume the next time the function is called.&lt;/strong&gt;</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; аналогичен &lt;code&gt;return&lt;/code&gt; - он возвращает все, что вы ему сказали (как генератор). Разница в том, что при следующем вызове генератора выполнение начинается с последнего вызова оператора &lt;code&gt;yield&lt;/code&gt; . В отличие от return, &lt;strong&gt;кадр стека не очищается при возникновении выхода, однако управление передается обратно вызывающей стороне, поэтому его состояние возобновится при следующем вызове функции.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f48e19febbab48404940d230045aa3e927e5e30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; is like a return element for a function. The difference is, that the &lt;code&gt;yield&lt;/code&gt; element turns a function into a generator. A generator behaves just like a function until something is 'yielded'. The generator stops until it is next called, and continues from exactly the same point as it started. You can get a sequence of all the 'yielded' values in one, by calling &lt;code&gt;list(generator())&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; подобен возвращаемому элементу для функции. Разница в том, что элемент &lt;code&gt;yield&lt;/code&gt; превращает функцию в генератор. Генератор ведет себя так же, как функция, пока что-то &amp;laquo;не получено&amp;raquo;. Генератор останавливается до следующего вызова и продолжает работу с той же точки, с которой он был запущен. Вы можете получить последовательность всех &amp;laquo;полученных&amp;raquo; значений в одном, вызвав &lt;code&gt;list(generator())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce79dbc24d94277033832b51d011f10c74c51c55" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;yield&lt;/code&gt; provides an 
easy way of &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#generator-types&quot;&gt;implementing the iterator protocol&lt;/a&gt;, defined by the following two methods: 
&lt;code&gt;__iter__&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt; (Python 2) or &lt;code&gt;__next__&lt;/code&gt; (Python 3).  Both of those methods
make an object an iterator that you could type-check with the &lt;code&gt;Iterator&lt;/code&gt; Abstract Base 
Class from the &lt;code&gt;collections&lt;/code&gt; module.</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; предоставляет простой способ &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#generator-types&quot;&gt;реализации протокола итератора&lt;/a&gt; , который определяется следующими двумя методами: &lt;code&gt;__iter__&lt;/code&gt; и &lt;code&gt;next&lt;/code&gt; (Python 2) или &lt;code&gt;__next__&lt;/code&gt; (Python 3). Оба эти метода делают объект итератором, который можно проверить типом с помощью абстрактного базового класса &lt;code&gt;Iterator&lt;/code&gt; из модуля &lt;code&gt;collections&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72b1d67b42a7bcd2f82b7a63ae89928f2425a004" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Caller:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Caller:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cff026d6f9aa06262d0a44145fc01e31f8076361" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Generator:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Generator:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c38bed66dadc73d83b4620730a13bb214521445c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/strong&gt; is only legal inside of a function definition, and &lt;strong&gt;the inclusion of &lt;code&gt;yield&lt;/code&gt; in a function definition makes it return a generator.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/strong&gt; допустим только внутри определения функции, и &lt;strong&gt;включение &lt;code&gt;yield&lt;/code&gt; в определение функции заставляет его возвращать генератор.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="229ca9910a03e900f64ebcb32c51dbc86e43eacf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Execution Control Transfer gotcha&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Контроль исполнения передачи получил&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="653263d633592b8035eb87354035a2aedee82289" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;As a Python generator:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Как генератор Python:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="daa7df2500b97f81040621f58d60cce72d811842" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вызов функций&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6b934a0ad7383658a04e1dbb7356e9f956f6fa54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; For Python 3, use&lt;code&gt;print(corner_street_atm.__next__())&lt;/code&gt; or &lt;code&gt;print(next(corner_street_atm))&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Для Python 3 используйте &lt;code&gt;print(corner_street_atm.__next__())&lt;/code&gt; или &lt;code&gt;print(next(corner_street_atm))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="284c0cc1c16634ee278d62d9da4d70563394d278" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TL;DR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TL;DR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="867dc1e5830b6274ed3a21ce05e3f7d42fcc32aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the result from the code:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Это результат из кода:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="57c3f7ae705716465207e976c5f8b4654e8b8e23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using lexical closures instead of generators&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Использование лексических замыканий вместо генераторов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fb818cdf73632877fa6680be81278640e6f5f261" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using object closures instead of generators&lt;/strong&gt; (because &lt;a href=&quot;http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent&quot;&gt;ClosuresAndObjectsAreEquivalent&lt;/a&gt;)</source>
          <target state="translated">&lt;strong&gt;Использование замыканий объектов вместо генераторов&lt;/strong&gt; (потому что &lt;a href=&quot;http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent&quot;&gt;ClosuresAndObjectsAreEquivalent&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="6cd1618b874d384cc3e5eb172422b1adea86fbd2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What does the &lt;code&gt;yield&lt;/code&gt; keyword do in Python?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что делает ключевое слово &lt;code&gt;yield&lt;/code&gt; в Python?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cf577700a9ff9e3f004ffc00209080b9c3eba6b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yield is an object&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Урожай является объектом&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5bb3a856024a662b96de26aecfd9bd37f19227ac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;return&lt;/strong&gt; (in function)</source>
          <target state="translated">&lt;strong&gt;возврат&lt;/strong&gt; (в функции)</target>
        </trans-unit>
        <trans-unit id="9a40ecb26c7c8562eed416b67a93ab45567e9bd8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;yield&lt;/strong&gt; &amp;mdash; give way or relinquish (as in political power)</source>
          <target state="translated">&lt;strong&gt;уступить&lt;/strong&gt; - уступить или отказаться (как при политической власти)</target>
        </trans-unit>
        <trans-unit id="bccdd99e0ed80b5b71ebb537cdf27634a356412a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;yield&lt;/strong&gt; &amp;mdash; produce or provide (as in agriculture)</source>
          <target state="translated">&lt;strong&gt;Урожай&lt;/strong&gt; - производить или предоставлять (как в сельском хозяйстве)</target>
        </trans-unit>
        <trans-unit id="2c3677668ae12b29cf20934e6d983bdb8043dd08" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;yield&lt;/strong&gt; (in function)</source>
          <target state="translated">&lt;strong&gt;доходность&lt;/strong&gt; (в функции)</target>
        </trans-unit>
        <trans-unit id="26de2c12b563c2f9a7febaaeb02a1b7ff942e453" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
1. This piece of code was written by Jochen Schulz (jrschulz), who made a great Python library for metric spaces. This is the link to the complete source: &lt;a href=&quot;http://well-adjusted.de/~jrschulz/mspace/&quot;&gt;Module mspace&lt;/a&gt;.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;1. Этот фрагмент кода был написан Йохеном Шульцем (jrschulz), который создал отличную библиотеку Python для метрических пространств.&lt;/sub&gt; &lt;sub&gt;Это ссылка на полный источник: &lt;a href=&quot;http://well-adjusted.de/~jrschulz/mspace/&quot;&gt;Модуль mspace&lt;/a&gt; .&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="f79576b025501c7eb386682a764849f89c207838" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;code&gt;yield&lt;/code&gt; was originally introduced as a statement, meaning that it 
could only appear at the beginning of a line in a code block. 
Now &lt;code&gt;yield&lt;/code&gt; creates a yield expression. 
&lt;a href=&quot;https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt&quot;&gt;https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt&lt;/a&gt; 
This change was &lt;a href=&quot;https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators&quot;&gt;proposed&lt;/a&gt; to allow a user to send data into the generator just as
one might receive it. To send data, one must be able to assign it to something, and
for that, a statement just won't work.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt; &lt;code&gt;yield&lt;/code&gt; изначально был представлен как оператор, то есть он мог появляться только в начале строки в блоке кода.&lt;/sub&gt; &lt;sub&gt;Теперь &lt;code&gt;yield&lt;/code&gt; создает выражение выхода.&lt;/sub&gt; &lt;sub&gt;&lt;a href=&quot;https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt&quot;&gt;https://docs.python.org/2/reference/simple_stmts.html#grammar-token-yield_stmt&lt;/a&gt; Это изменение было &lt;a href=&quot;https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators&quot;&gt;предложено,&lt;/a&gt; чтобы позволить пользователю отправлять данные в генератор так же, как они могут быть получены.&lt;/sub&gt; &lt;sub&gt;Чтобы отправить данные, нужно иметь возможность назначить их чему-либо, и для этого оператор просто не будет работать.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="3ecaefffce9acc4aec2e8eb1485d8144441fb64a" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt; This means, for example, that &lt;code&gt;xrange&lt;/code&gt; objects (&lt;code&gt;range&lt;/code&gt; in Python 3) aren't &lt;code&gt;Iterator&lt;/code&gt;s, even though they are iterable, because they can be reused. Like lists, their &lt;code&gt;__iter__&lt;/code&gt; methods return iterator objects.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;Это означает, например, что объекты &lt;code&gt;xrange&lt;/code&gt; ( &lt;code&gt;range&lt;/code&gt; в Python 3) не являются &lt;code&gt;Iterator&lt;/code&gt; , даже если они итеративные, потому что их можно использовать повторно.&lt;/sub&gt; &lt;sub&gt;Как и списки, их методы &lt;code&gt;__iter__&lt;/code&gt; возвращают объекты итератора.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="6d4047120e95ed7d93b8ea0918529c67a9bc43e4" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;The languages CLU, Sather, and Icon were referenced in the proposal
to introduce the concept of generators to Python. The general idea is
that a function can maintain internal state and yield intermediate 
data points on demand by the user. This promised to be &lt;a href=&quot;https://www.python.org/dev/peps/pep-0255/&quot;&gt;superior in performance 
to other approaches, including Python threading&lt;/a&gt;, which isn't even available on some systems.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;Языки CLU, Sather и Icon упоминались в предложении ввести концепцию генераторов в Python.&lt;/sub&gt; &lt;sub&gt;Общая идея заключается в том, что функция может поддерживать внутреннее состояние и выдавать промежуточные точки данных по требованию пользователя.&lt;/sub&gt; &lt;sub&gt;Это обещало быть &lt;a href=&quot;https://www.python.org/dev/peps/pep-0255/&quot;&gt;превосходным по производительности по сравнению с другими подходами, включая потоки Python&lt;/a&gt; , которые даже недоступны в некоторых системах.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="45728cd7c825dedfa1bf52fd66ed620c707bd5e8" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;return&lt;/code&gt; in a function will return a single value.</source>
          <target state="translated">&lt;code&gt;return&lt;/code&gt; в функции вернет одно значение.</target>
        </trans-unit>
        <trans-unit id="f4dca203541c03ec91c7704f277f8cc1b514af3a" translate="yes" xml:space="preserve">
          <source>A feature of an &lt;code&gt;Iterator&lt;/code&gt;&lt;a href=&quot;https://docs.python.org/2/glossary.html#term-iterator&quot;&gt;is that once exhausted&lt;/a&gt;, you can't reuse or reset it:</source>
          <target state="translated">Особенность &lt;code&gt;Iterator&lt;/code&gt; &lt;a href=&quot;https://docs.python.org/2/glossary.html#term-iterator&quot;&gt;заключается в том, что после его исчерпания&lt;/a&gt; вы не сможете повторно использовать или сбросить его:</target>
        </trans-unit>
        <trans-unit id="bc88bfb2c2db80515dc1ecb96783382a954c2f20" translate="yes" xml:space="preserve">
          <source>A function with &lt;a href=&quot;https://docs.python.org/reference/expressions.html#yieldexpr&quot;&gt;&lt;strong&gt;&lt;code&gt;yield&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, when called, &lt;strong&gt;returns a &lt;a href=&quot;https://docs.python.org/2/tutorial/classes.html#generators&quot;&gt;Generator&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">Функция с &lt;a href=&quot;https://docs.python.org/reference/expressions.html#yieldexpr&quot;&gt;&lt;strong&gt; &lt;code&gt;yield&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; при вызове &lt;strong&gt;возвращает &lt;a href=&quot;https://docs.python.org/2/tutorial/classes.html#generators&quot;&gt;генератор&lt;/a&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="897499bfe1868bc9f693489cbbf23e92d00c56ab" translate="yes" xml:space="preserve">
          <source>A generator can also be &lt;strong&gt;sent information&lt;/strong&gt;, making it conceptually a &lt;strong&gt;coroutine&lt;/strong&gt;.</source>
          <target state="translated">Генератору также может быть &lt;strong&gt;отправлена ​​информация&lt;/strong&gt; , что делает его концептуально &lt;strong&gt;сопрограммой&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9738265b02043df1ee0a4dc75d4ad9e6a30481dd" translate="yes" xml:space="preserve">
          <source>A generator differs from a function in the sense that it is lazy. It accomplishes this by maintaining it's local state and allowing you to resume whenever you need to.</source>
          <target state="translated">Генератор отличается от функции в том смысле,что он ленивый.Он достигает этого,поддерживая локальное состояние и позволяя вам возобновлять работу в любое время,когда это необходимо.</target>
        </trans-unit>
        <trans-unit id="1f888f43eb25e3718593933b4335447760fb8473" translate="yes" xml:space="preserve">
          <source>A generator is iterable. What is an &lt;em&gt;iterable&lt;/em&gt;? It's anything like a &lt;code&gt;list&lt;/code&gt; or &lt;code&gt;set&lt;/code&gt; or &lt;code&gt;range&lt;/code&gt; or dict-view, with a &lt;em&gt;built-in protocol for visiting each element in a certain order&lt;/em&gt;.</source>
          <target state="translated">Генератор повторяем. Что такое &lt;em&gt;повторяемый&lt;/em&gt; ? Это что-то вроде &lt;code&gt;list&lt;/code&gt; &lt;code&gt;set&lt;/code&gt; &lt;code&gt;range&lt;/code&gt; или диктовки, со &lt;em&gt;встроенным протоколом для посещения каждого элемента в определенном порядке&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="40806863ce6fa16185eff4ee6a143d5d9c549f75" translate="yes" xml:space="preserve">
          <source>A real life example would be something like reading a file line by line or if you just want to make a generator.</source>
          <target state="translated">Примером в реальной жизни может быть что-то вроде чтения файла строка за строкой или просто создание генератора.</target>
        </trans-unit>
        <trans-unit id="44cb9a9a8788c105610a9684a6bc2a2b8a67003f" translate="yes" xml:space="preserve">
          <source>A syntax is proposed for a generator to delegate part of its operations to another generator. This allows a section of code containing 'yield' to be factored out and placed in another generator. Additionally, the subgenerator is allowed to return with a value, and the value is made available to the delegating generator.</source>
          <target state="translated">Предлагается синтаксис для генератора,который делегирует часть своих операций другому генератору.Это позволяет учесть часть кода,содержащую 'yield' и поместить ее в другой генератор.Кроме того,субгенератору разрешается вернуться со значением,и это значение становится доступным для делегирующего генератора.</target>
        </trans-unit>
        <trans-unit id="74447fa535e8bb207f72d52e27e00da4cbc34ba7" translate="yes" xml:space="preserve">
          <source>Again, this is a pretty contrived example, you probably would use itertools if you really wanted to count to 50 billion. :)</source>
          <target state="translated">Опять же,это довольно надуманный пример,вы,вероятно,использовали бы итерационные инструменты,если бы действительно хотели сосчитать до 50 миллиардов.:)</target>
        </trans-unit>
        <trans-unit id="bd27eb03f93b277d1b217b449e15ffaa08956520" translate="yes" xml:space="preserve">
          <source>All great answers, however a bit difficult for newbies.</source>
          <target state="translated">Все отличные ответы,однако немного трудные для новичков.</target>
        </trans-unit>
        <trans-unit id="2fab016fc71934fbba31dba4e6e38ca3818acafb" translate="yes" xml:space="preserve">
          <source>Also, note that &lt;code&gt;yield&lt;/code&gt; can be used in coroutines as the dual of their use in generator functions.  Although it isn't the same use as your code snippet, &lt;code&gt;(yield)&lt;/code&gt; can be used as an expression in a function.  When a caller sends a value to the method using the &lt;code&gt;send()&lt;/code&gt; method, then the coroutine will execute until the next &lt;code&gt;(yield)&lt;/code&gt; statement is encountered.</source>
          <target state="translated">Также обратите внимание, что &lt;code&gt;yield&lt;/code&gt; может быть использован в сопрограммах как двойное их использование в функциях генератора. Хотя это не то же самое использование, что и ваш фрагмент кода, &lt;code&gt;(yield)&lt;/code&gt; может использоваться как выражение в функции. Когда вызывающая сторона отправляет значение методу с помощью метода &lt;code&gt;send()&lt;/code&gt; , сопрограмма будет выполняться до тех пор, пока не встретится следующий оператор &lt;code&gt;(yield)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c56156759c86e1fd4089d77e11250c9e375078a7" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;expression_list&lt;/code&gt; is basically any number of expressions separated by commas - essentially, in Python 2, you can stop the generator with &lt;code&gt;return&lt;/code&gt;, but you can't return a value.</source>
          <target state="translated">&lt;code&gt;expression_list&lt;/code&gt; - это, по сути, любое количество выражений, разделенных запятыми. По сути, в Python 2 вы можете остановить генератор с помощью &lt;code&gt;return&lt;/code&gt; , но вы не можете вернуть значение.</target>
        </trans-unit>
        <trans-unit id="81d45d4bfb0fa5b224eac8c43cc82a19dfb43fe4" translate="yes" xml:space="preserve">
          <source>An easy example to understand what it is: &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">Простой пример, чтобы понять, что это такое: &lt;code&gt;yield&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cdd85aeb410d39ea117f7d9f6130e19b2898ccdb" translate="yes" xml:space="preserve">
          <source>An example? Let's see the possible orders of arrival for a four-horse race:</source>
          <target state="translated">Пример? Давайте посмотрим возможные приказы о прибытии на скачки с четырьмя лошадьми:</target>
        </trans-unit>
        <trans-unit id="29b15a5d175843895768eba634b31bff250c477b" translate="yes" xml:space="preserve">
          <source>An iterable is the last part of a list comprehension, and all generators are iterable, so they're often used like so:</source>
          <target state="translated">Итерабельный-это последняя часть понимания списка,и все генераторы являются итерабельными,поэтому их часто используют именно так:</target>
        </trans-unit>
        <trans-unit id="81d8a56bb9735baf48091b3e5b5e287b1b2e4127" translate="yes" xml:space="preserve">
          <source>An iterator is just a fancy sounding term for an object that has a &lt;code&gt;next()&lt;/code&gt; method.  So a yield-ed function ends up being something like this:</source>
          <target state="translated">Итератор - это просто причудливый термин для объекта, у которого есть метод &lt;code&gt;next()&lt;/code&gt; . Таким образом, функция yield-ed в итоге выглядит примерно так:</target>
        </trans-unit>
        <trans-unit id="d914dca0e9f94be2a010606114630680fc2fbce8" translate="yes" xml:space="preserve">
          <source>And if necessary, we can type-check like this:</source>
          <target state="translated">И при необходимости,мы можем проверить вот так:</target>
        </trans-unit>
        <trans-unit id="8b152c57dd4e6896c2e2d3a2c969268781a04e11" translate="yes" xml:space="preserve">
          <source>And it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples, and generators! This is called duck typing and is one of the reasons why Python is so cool. But this is another story, for another question...</source>
          <target state="translated">И это работает,потому что Python не волнует,является ли аргумент метода списком или нет.Python ожидает итерабелей,поэтому он будет работать со строками,списками,кортежами и генераторами! Это называется утиным типированием и является одной из причин,почему Python так крут.Но это другая история,для другого вопроса...</target>
        </trans-unit>
        <trans-unit id="97fbec56b74d699d8da84f4466277b6823b52c60" translate="yes" xml:space="preserve">
          <source>And now we can delegate functionality to a sub-generator and it can be used
by a generator just as above:</source>
          <target state="translated">И теперь мы можем делегировать функциональность субгенератору,и он может использоваться генератором точно так же,как и выше:</target>
        </trans-unit>
        <trans-unit id="bdec22c07b1756ea41e55aa6af803ad40c179f4d" translate="yes" xml:space="preserve">
          <source>And now we can send data into the generator. (&lt;a href=&quot;https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators&quot;&gt;Sending &lt;code&gt;None&lt;/code&gt; is 
the same as calling &lt;code&gt;next&lt;/code&gt;&lt;/a&gt;.) :</source>
          <target state="translated">И теперь мы можем отправлять данные в генератор. ( &lt;a href=&quot;https://www.python.org/dev/peps/pep-0342/#specification-sending-values-into-generators&quot;&gt;Отправка &lt;code&gt;None&lt;/code&gt; - это то же самое, что вызов &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="df8f95772f413efb0c2dbf265ff4862fae1c7bc4" translate="yes" xml:space="preserve">
          <source>And this is the caller:</source>
          <target state="translated">А это звонящий:</target>
        </trans-unit>
        <trans-unit id="3b57182086d6c04e166187f3787e8d917fd59442" translate="yes" xml:space="preserve">
          <source>Answer Outline/Summary</source>
          <target state="translated">Описание ответаСводная информация</target>
        </trans-unit>
        <trans-unit id="c3c07bbc3573c4c760856487909b704db42f46ae" translate="yes" xml:space="preserve">
          <source>Appendix:</source>
          <target state="translated">Appendix:</target>
        </trans-unit>
        <trans-unit id="f7153a3ed77229b8ef3f57eb201522d76e468e8a" translate="yes" xml:space="preserve">
          <source>As I understand, when we want to process a bunch of data, we usually first store the data somewhere and then process it one by one. But this &lt;em&gt;naive&lt;/em&gt; approach is problematic. If the data volume is huge, it's expensive to store them as a whole beforehand. &lt;strong&gt;So instead of storing the &lt;code&gt;data&lt;/code&gt; itself directly, why not store some kind of &lt;code&gt;metadata&lt;/code&gt; indirectly, i.e. &lt;code&gt;the logic how the data is computed&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">Как я понимаю, когда мы хотим обработать кучу данных, мы обычно сначала храним данные где-то, а затем обрабатываем их одну за другой. Но такой &lt;em&gt;наивный&lt;/em&gt; подход проблематичен. Если объем данных огромен, заранее хранить их в целом дорого. &lt;strong&gt;Таким образом, вместо непосредственного хранения самих &lt;code&gt;data&lt;/code&gt; , почему бы не сохранить некоторые &lt;code&gt;metadata&lt;/code&gt; косвенно, то есть &lt;code&gt;the logic how the data is computed&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="71b8419f2c05a320eab84f0ff210eed5a7aa3f59" translate="yes" xml:space="preserve">
          <source>As an analogy, &lt;code&gt;return&lt;/code&gt; and &lt;code&gt;yield&lt;/code&gt; are twins. &lt;code&gt;return&lt;/code&gt; means 'return and stop' whereas 'yield` means 'return, but continue'</source>
          <target state="translated">По аналогии, &lt;code&gt;return&lt;/code&gt; и &lt;code&gt;yield&lt;/code&gt; близнецы. &lt;code&gt;return&lt;/code&gt; означает &amp;laquo;возврат и остановка&amp;raquo;, тогда как &amp;laquo;yield&amp;raquo; означает &amp;laquo;возвращение, но продолжить&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="9399c22507893ea92efd2d3d7bd85d4924662fa9" translate="yes" xml:space="preserve">
          <source>As you can see both functions do the same thing. The only difference is &lt;code&gt;return_dates()&lt;/code&gt; gives a list and &lt;code&gt;yield_dates()&lt;/code&gt; gives a generator.</source>
          <target state="translated">Как видите, обе функции выполняют одно и то же. Единственное отличие состоит в том, что &lt;code&gt;return_dates()&lt;/code&gt; выдает список, а &lt;code&gt;yield_dates()&lt;/code&gt; выдает генератор.</target>
        </trans-unit>
        <trans-unit id="135740deb1c52c950dd9825f622468250cfec310" translate="yes" xml:space="preserve">
          <source>As you can see, in the first case &lt;code&gt;foo&lt;/code&gt; holds the entire list in memory at once. It's not a big deal for a list with 5 elements, but what if you want a list of 5 million? Not only is this a huge memory eater, it also costs a lot of time to build at the time that the function is called.</source>
          <target state="translated">Как видите, в первом случае &lt;code&gt;foo&lt;/code&gt; хранит весь список в памяти сразу. Это не имеет большого значения для списка из 5 элементов, но что, если вы хотите список из 5 миллионов? Мало того, что это огромный пожиратель памяти, он также требует много времени для создания во время вызова функции.</target>
        </trans-unit>
        <trans-unit id="5bbe3ddff5d188e8a248228bc2152ed147d1b379" translate="yes" xml:space="preserve">
          <source>Behind the scenes</source>
          <target state="translated">За кулисами</target>
        </trans-unit>
        <trans-unit id="5b6a80379109f3fc6042e0737cbf5d072100c51f" translate="yes" xml:space="preserve">
          <source>Both functions do the same thing, but &lt;code&gt;yield&lt;/code&gt; uses three lines instead of five and has one less variable to worry about.</source>
          <target state="translated">Обе функции делают одно и то же, но &lt;code&gt;yield&lt;/code&gt; использует три строки вместо пяти и имеет на одну переменную меньше, о которой нужно беспокоиться.</target>
        </trans-unit>
        <trans-unit id="cca4c988c7e1babe71c97f7849efb9f46f5d36d6" translate="yes" xml:space="preserve">
          <source>Bottom line, until the developers of CPython tell us otherwise: &lt;strong&gt;Don't put &lt;code&gt;yield&lt;/code&gt; in a generator expression or comprehension.&lt;/strong&gt;</source>
          <target state="translated">В итоге, пока разработчики CPython не скажут нам иначе: &lt;strong&gt;не помещайте &lt;code&gt;yield&lt;/code&gt; в выражение или понимание генератора.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d08cdf468566d1e5880decf4e3f20a483dff611f" translate="yes" xml:space="preserve">
          <source>Brilliant choice of the word &lt;code&gt;yield&lt;/code&gt; because &lt;a href=&quot;https://www.google.com/search?q=yield+meaning&quot;&gt;both meanings&lt;/a&gt; apply:</source>
          <target state="translated">Блестящий выбор слова &lt;code&gt;yield&lt;/code&gt; , потому что применяются &lt;a href=&quot;https://www.google.com/search?q=yield+meaning&quot;&gt;оба значения&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="18cf04f82308b4c79617d9344cd8cccedc5948df" translate="yes" xml:space="preserve">
          <source>Built-in lists, dictionaries, tuples, sets, files.</source>
          <target state="translated">Встроенные списки,словари,кортежи,наборы,файлы.</target>
        </trans-unit>
        <trans-unit id="ace5b94af148161c793a05983917f7f7008ae80a" translate="yes" xml:space="preserve">
          <source>But in your code, it gets a generator, which is good because:</source>
          <target state="translated">Но в вашем коде,он получает генератор,что хорошо,потому что..:</target>
        </trans-unit>
        <trans-unit id="e41053f2e7b7818b717e108be50e7b8bc56bf7fd" translate="yes" xml:space="preserve">
          <source>But this is inefficient because</source>
          <target state="translated">Но это неэффективно,потому что</target>
        </trans-unit>
        <trans-unit id="112200cd9ac4f291717eeda13db581f83c118af7" translate="yes" xml:space="preserve">
          <source>But you could easily implement (and conceptualize) generators as a simple, specific case of continuation passing style:</source>
          <target state="translated">Но вы можете легко реализовать (и концептуализировать)генераторы как простой,специфический случай передачи стиля продолжения:</target>
        </trans-unit>
        <trans-unit id="224ba6c7dc6ef4515b36b8503f362933f7f951ca" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;iter(mylist)&lt;/code&gt; -&amp;gt; this returns an object with a &lt;code&gt;next()&lt;/code&gt; method (or &lt;code&gt;__next__()&lt;/code&gt; in Python 3).</source>
          <target state="translated">Вызовите &lt;code&gt;iter(mylist)&lt;/code&gt; -&amp;gt; это возвращает объект с методом &lt;code&gt;next()&lt;/code&gt; (или &lt;code&gt;__next__()&lt;/code&gt; в Python 3).</target>
        </trans-unit>
        <trans-unit id="4fdabc45b3bad82e2c9c7d5aa68f04b364ec25ac" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;yielderFunction()&lt;/code&gt; doesn't run its code, but makes a generator out of the code. (Maybe it's a good idea to name such things with the &lt;code&gt;yielder&lt;/code&gt; prefix for readability.)</source>
          <target state="translated">Вызов &lt;code&gt;yielderFunction()&lt;/code&gt; не запускает его код, но делает генератор из кода. (Может быть, это хорошая идея называть такие вещи префиксом &lt;code&gt;yielder&lt;/code&gt; для удобства чтения.)</target>
        </trans-unit>
        <trans-unit id="d4e40bacc080c668ae12d6659592822c4592d6dc" translate="yes" xml:space="preserve">
          <source>Cheers, Nick.</source>
          <target state="translated">Спасибо,Ник.</target>
        </trans-unit>
        <trans-unit id="fa1fe25132badc6a4700de54339362efef6cccf3" translate="yes" xml:space="preserve">
          <source>Compare function to the original definition.</source>
          <target state="translated">Сравните функцию с исходным определением.</target>
        </trans-unit>
        <trans-unit id="422466cb355bfaa6b435c10bfd2011e9037906cc" translate="yes" xml:space="preserve">
          <source>Compare the following examples:</source>
          <target state="translated">Сравните следующие примеры:</target>
        </trans-unit>
        <trans-unit id="23177d88df5aa8c7d73ae1fbc8fbc37e2afda7be" translate="yes" xml:space="preserve">
          <source>Comparing example to &quot;just returning a list&quot;</source>
          <target state="translated">Сравнение примера с &quot;просто возвратом списка&quot;</target>
        </trans-unit>
        <trans-unit id="13ee7709c64ae8875430c0fce8f630d0fd20adab" translate="yes" xml:space="preserve">
          <source>Comparing to &lt;code&gt;return&lt;/code&gt; which runs once and stops, &lt;code&gt;yield&lt;/code&gt; runs times you planed.
You can interpret &lt;code&gt;return&lt;/code&gt; as &lt;code&gt;return one of them&lt;/code&gt;, and &lt;code&gt;yield&lt;/code&gt; as &lt;code&gt;return all of them&lt;/code&gt;. This is called &lt;code&gt;iterable&lt;/code&gt;.</source>
          <target state="translated">По сравнению с &lt;code&gt;return&lt;/code&gt; который запускается один раз и останавливается, &lt;code&gt;yield&lt;/code&gt; запускает запланированные вами времена. Вы можете интерпретировать &lt;code&gt;return&lt;/code&gt; как &lt;code&gt;return one of them&lt;/code&gt; , а &lt;code&gt;yield&lt;/code&gt; как &lt;code&gt;return all of them&lt;/code&gt; . Это называется &lt;code&gt;iterable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="d93505eddd729749377d3ebb203709c807a5b6b0" translate="yes" xml:space="preserve">
          <source>Continuations in programming languages theory are a much more fundamental kind of computation, but they are not often used, because they are extremely hard to reason about and also very difficult to implement. But the idea of what a continuation is, is straightforward: it is the state of a computation that has not yet finished. In this state, the current values of variables, the operations that have yet to be performed, and so on, are saved. Then at some point later in the program the continuation can be invoked, such that the program's variables are reset to that state and the operations that were saved are carried out.</source>
          <target state="translated">Продолжения в теории языков программирования являются гораздо более фундаментальным видом вычислений,но они не часто используются,так как их крайне сложно обосновать,а также очень сложно реализовать.Но идея о том,что такое преемственность,проста:это состояние вычисления,которое еще не закончено.В этом состоянии сохраняются текущие значения переменных,операции,которые еще предстоит выполнить,и так далее.Затем в какой-то момент позже в программе может быть вызвано продолжение,так что переменные программы сбрасываются в это состояние и выполняются сохраненные операции.</target>
        </trans-unit>
        <trans-unit id="b72e044549c84a332ce620bd9e0a6adabcb6a3af" translate="yes" xml:space="preserve">
          <source>Continuations, in this more general form, can be implemented in two ways. In the &lt;code&gt;call/cc&lt;/code&gt; way, the program's stack is literally saved and then when the continuation is invoked, the stack is restored.</source>
          <target state="translated">Продолжения в этой более общей форме могут быть реализованы двумя способами. В способе &lt;code&gt;call/cc&lt;/code&gt; стек программы буквально сохраняется, а затем, когда вызывается продолжение, стек восстанавливается.</target>
        </trans-unit>
        <trans-unit id="2c47bc7e9e1cccd861bf2f12386c3a01928597e8" translate="yes" xml:space="preserve">
          <source>Controlling a generator exhaustion</source>
          <target state="translated">Управление истощением генератора</target>
        </trans-unit>
        <trans-unit id="fe65bca192a86197c66d7cf330e1537caa61c387" translate="yes" xml:space="preserve">
          <source>Cooperative Delegation to Sub-Coroutine with &lt;code&gt;yield from&lt;/code&gt;</source>
          <target state="translated">Совместная делегация в суб-сопрограмме с &lt;code&gt;yield from&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="33163af7bd841f674f77c35298225e94a5016009" translate="yes" xml:space="preserve">
          <source>Coroutines:</source>
          <target state="translated">Coroutines:</target>
        </trans-unit>
        <trans-unit id="abfb94ac57644f17a8adf8955a59558bd94c3b33" translate="yes" xml:space="preserve">
          <source>Critique of answer suggesting &lt;code&gt;yield&lt;/code&gt; in a generator expression or comprehension.</source>
          <target state="translated">Критика ответа, предполагающая &lt;code&gt;yield&lt;/code&gt; в выражении или понимании генератора.</target>
        </trans-unit>
        <trans-unit id="a9c0621bff7dcefce6457fdee9b6bcef2e0f3d8a" translate="yes" xml:space="preserve">
          <source>Critique of the Top/Accepted Answer**</source>
          <target state="translated">Критика &quot;ТопПринятого ответа &quot;**.</target>
        </trans-unit>
        <trans-unit id="391058e00a0cf1fea23f9021af0e6821cda75f41" translate="yes" xml:space="preserve">
          <source>Different behavior:</source>
          <target state="translated">Другое поведение:</target>
        </trans-unit>
        <trans-unit id="4beaba95c78d5c63061a997dcde838cb3d1a985b" translate="yes" xml:space="preserve">
          <source>Does that make more sense or just confuse you more?  :)</source>
          <target state="translated">Это имеет больше смысла или просто сбивает вас с толку? :)</target>
        </trans-unit>
        <trans-unit id="478cc5edb794118536367238291728364671b4c5" translate="yes" xml:space="preserve">
          <source>Don't confuse your Iterables, Iterators, and Generators</source>
          <target state="translated">Не путайте свои &quot;Итераторы&quot;,&quot;Итераторы&quot; и &quot;Генераторы&quot;...</target>
        </trans-unit>
        <trans-unit id="c5ebf51ae7871d62102efa654179e7b2cbd98826" translate="yes" xml:space="preserve">
          <source>Either way, an iterator is created, i.e. some object that can give you the data you want. The OO approach may be a bit complex. Anyway, which one to use is up to you.</source>
          <target state="translated">В любом случае,создается итератор,т.е.некий объект,который может дать вам нужные данные.Подход OO может быть немного сложным.В любом случае,какой из них зависит от вас.</target>
        </trans-unit>
        <trans-unit id="17dcf8ce994111b56509be2581c55631ea92717d" translate="yes" xml:space="preserve">
          <source>Everything you can use &quot;&lt;code&gt;for... in...&lt;/code&gt;&quot; on is an iterable; &lt;code&gt;lists&lt;/code&gt;, &lt;code&gt;strings&lt;/code&gt;, files...</source>
          <target state="translated">Все, что вы можете использовать &quot; &lt;code&gt;for... in...&lt;/code&gt; &quot;, является итеративным; &lt;code&gt;lists&lt;/code&gt; , &lt;code&gt;strings&lt;/code&gt; , файлы ...</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="a58924e6ca70e15697b41c0fd8af77f8e3655bd0" translate="yes" xml:space="preserve">
          <source>First, the &lt;strong&gt;iterator protocol&lt;/strong&gt; - when you write</source>
          <target state="translated">Во-первых, &lt;strong&gt;протокол итератора&lt;/strong&gt; - когда вы пишете</target>
        </trans-unit>
        <trans-unit id="ab464772e390ee8b69cf6e6fbb14dd8f889ce77c" translate="yes" xml:space="preserve">
          <source>First, we must queue up the generator with the builtin function, &lt;a href=&quot;https://docs.python.org/2/library/functions.html#next&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt;. It will 
call the appropriate &lt;code&gt;next&lt;/code&gt; or &lt;code&gt;__next__&lt;/code&gt; method, depending on the version of
Python you are using:</source>
          <target state="translated">Сначала мы должны поставить генератор в очередь с помощью встроенной функции, &lt;a href=&quot;https://docs.python.org/2/library/functions.html#next&quot;&gt; &lt;code&gt;next&lt;/code&gt; &lt;/a&gt; . Он будет вызывать соответствующий метод &lt;code&gt;next&lt;/code&gt; или &lt;code&gt;__next__&lt;/code&gt; , в зависимости от используемой версии Python:</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="87881092dde77e187d0bf9cb4e0f744846b558a8" translate="yes" xml:space="preserve">
          <source>For example, I'm trying to understand this code&lt;sup&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/sup&gt;:</source>
          <target state="translated">Например, я пытаюсь понять этот код &lt;sup&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="4359df1244f408dd74c85feea20108563cf47ea0" translate="yes" xml:space="preserve">
          <source>For more accurate information, read about &lt;a href=&quot;http://docs.python.org/library/stdtypes.html#iterator-types&quot;&gt;iterator types&lt;/a&gt;, the &lt;a href=&quot;http://docs.python.org/reference/simple_stmts.html#yield&quot;&gt;yield statement&lt;/a&gt; and &lt;a href=&quot;http://docs.python.org/glossary.html#term-generator&quot;&gt;generators&lt;/a&gt; in the Python documentation.</source>
          <target state="translated">Для получения более точной информации читайте о &lt;a href=&quot;http://docs.python.org/library/stdtypes.html#iterator-types&quot;&gt;типах итераторов&lt;/a&gt; , &lt;a href=&quot;http://docs.python.org/reference/simple_stmts.html#yield&quot;&gt;выражении yield&lt;/a&gt; и &lt;a href=&quot;http://docs.python.org/glossary.html#term-generator&quot;&gt;генераторах&lt;/a&gt; в документации по Python.</target>
        </trans-unit>
        <trans-unit id="ab34884b9c5a1c376f359e896bfa36ac9404ee1e" translate="yes" xml:space="preserve">
          <source>For more insight as to what's happening behind the scenes, the &lt;code&gt;for&lt;/code&gt; loop can be rewritten to this:</source>
          <target state="translated">Для большего понимания того, что происходит за кулисами, цикл &lt;code&gt;for&lt;/code&gt; можно переписать так:</target>
        </trans-unit>
        <trans-unit id="b3b09a14c47c5a101227ecf4d23816285925f6d5" translate="yes" xml:space="preserve">
          <source>For those who prefer a minimal working example, meditate on this interactive Python session:</source>
          <target state="translated">Для тех,кто предпочитает минимальный рабочий пример,медитируйте на этом интерактивном сеансе на питоне:</target>
        </trans-unit>
        <trans-unit id="50c79418c72adb6d21a9a53d6133434acd4b25f6" translate="yes" xml:space="preserve">
          <source>From &lt;em&gt;&lt;a href=&quot;http://www.python.org/dev/peps/pep-0380/&quot;&gt;PEP 380 -- Syntax for Delegating to a Subgenerator&lt;/a&gt;&lt;/em&gt;:</source>
          <target state="translated">От &lt;em&gt;&lt;a href=&quot;http://www.python.org/dev/peps/pep-0380/&quot;&gt;PEP 380 - Синтаксис для делегирования субгенератору&lt;/a&gt;&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="12e842703e6cd07e003a70536ed53b1cad820600" translate="yes" xml:space="preserve">
          <source>From a programming viewpoint, the iterators are implemented as &lt;a href=&quot;http://en.wikipedia.org/wiki/Thunk_(functional_programming)&quot;&gt;thunks&lt;/a&gt;.</source>
          <target state="translated">С точки зрения программирования, итераторы реализованы в виде &lt;a href=&quot;http://en.wikipedia.org/wiki/Thunk_(functional_programming)&quot;&gt;блоков&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c04b84b0d27f22df1bc44e709e3324e4728e5047" translate="yes" xml:space="preserve">
          <source>Further, there is an &lt;a href=&quot;http://bugs.python.org/issue10544&quot;&gt;outstanding issue (10544)&lt;/a&gt; which seems to be pointing in the direction of this &lt;em&gt;never&lt;/em&gt; being a good idea (PyPy, a Python implementation written in Python, is already raising syntax warnings.)</source>
          <target state="translated">Кроме того, существует &lt;a href=&quot;http://bugs.python.org/issue10544&quot;&gt;нерешенная проблема (10544),&lt;/a&gt; которая, кажется, указывает на то, что это &lt;em&gt;никогда не&lt;/em&gt; будет хорошей идеей (PyPy, реализация Python, написанная на Python, уже вызывает предупреждения синтаксиса.)</target>
        </trans-unit>
        <trans-unit id="a3e705cc61a19f33d7c9c030f107a70569966485" translate="yes" xml:space="preserve">
          <source>Generators</source>
          <target state="translated">Generators</target>
        </trans-unit>
        <trans-unit id="ea270aafef5ea2be7a50c15d8f3cf44425aa37b7" translate="yes" xml:space="preserve">
          <source>Generators and coroutines are a cool way to set up data-flow type applications.  I thought it would be worthwhile knowing about the other use of the &lt;code&gt;yield&lt;/code&gt; statement in functions.</source>
          <target state="translated">Генераторы и сопрограммы - отличный способ настроить приложения типа потока данных. Я подумал, что стоит знать о другом использовании оператора &lt;code&gt;yield&lt;/code&gt; в функциях.</target>
        </trans-unit>
        <trans-unit id="179018c67d6955b4f49df82ba24dc3b04e776679" translate="yes" xml:space="preserve">
          <source>Generators are iterators because they implement the &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#iterator-types&quot;&gt;&lt;strong&gt;iterator protocol&lt;/strong&gt;&lt;/a&gt;, so you can iterate over them.</source>
          <target state="translated">Генераторы являются итераторами, потому что они реализуют &lt;a href=&quot;https://docs.python.org/2/library/stdtypes.html#iterator-types&quot;&gt;&lt;strong&gt;протокол итератора&lt;/strong&gt;&lt;/a&gt; , поэтому вы можете выполнять итерации по ним.</target>
        </trans-unit>
        <trans-unit id="a5e08e7b38a556477cdbe545a9f764632125d102" translate="yes" xml:space="preserve">
          <source>Generators are iterators, a kind of iterable &lt;strong&gt;you can only iterate over once&lt;/strong&gt;. Generators do not store all the values in memory, &lt;strong&gt;they generate the values on the fly&lt;/strong&gt;:</source>
          <target state="translated">Генераторы - это итераторы, вид итерации, который &lt;strong&gt;вы можете повторять только один раз&lt;/strong&gt; . Генераторы не хранят все значения в памяти, &lt;strong&gt;они генерируют значения на лету&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="682b0796dd83f3fd0ad45f54f168909fac114df8" translate="yes" xml:space="preserve">
          <source>Generators.</source>
          <target state="translated">Generators.</target>
        </trans-unit>
        <trans-unit id="30755c71dba128a057a2e8b31c452388bed51a8e" translate="yes" xml:space="preserve">
          <source>Generators:</source>
          <target state="translated">Generators:</target>
        </trans-unit>
        <trans-unit id="d054231a90af4e28b960cfe94d5c8186673ab51e" translate="yes" xml:space="preserve">
          <source>Gets an iterator for &lt;code&gt;mylist&lt;/code&gt;:</source>
          <target state="translated">Получает итератор для &lt;code&gt;mylist&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c8a20bbe7bfc35516518ea627afd092d0e96e4cc" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;mylist&lt;/code&gt; is an &lt;em&gt;iterable&lt;/em&gt; because it implements the iterator protocol. In a user-defined class, you can implement the &lt;code&gt;__iter__()&lt;/code&gt; method to make instances of your class iterable. This method should return an &lt;em&gt;iterator&lt;/em&gt;. An iterator is an object with a &lt;code&gt;next()&lt;/code&gt; method. It is possible to implement both &lt;code&gt;__iter__()&lt;/code&gt; and &lt;code&gt;next()&lt;/code&gt; on the same class, and have &lt;code&gt;__iter__()&lt;/code&gt; return &lt;code&gt;self&lt;/code&gt;. This will work for simple cases, but not when you want two iterators looping over the same object at the same time.</source>
          <target state="translated">Здесь &lt;code&gt;mylist&lt;/code&gt; является &lt;em&gt;итеративным,&lt;/em&gt; поскольку он реализует протокол итератора. В пользовательском классе вы можете реализовать метод &lt;code&gt;__iter__()&lt;/code&gt; чтобы сделать экземпляры вашего класса итеративными. Этот метод должен возвращать &lt;em&gt;итератор&lt;/em&gt; . Итератор - это объект с методом &lt;code&gt;next()&lt;/code&gt; . Можно реализовать оба &lt;code&gt;__iter__()&lt;/code&gt; и &lt;code&gt;next()&lt;/code&gt; в одном и том же классе, и иметь &lt;code&gt;__iter__()&lt;/code&gt; возвращающие &lt;code&gt;self&lt;/code&gt; . Это будет работать для простых случаев, но не когда вы хотите, чтобы два итератора циклически обрабатывали один и тот же объект одновременно.</target>
        </trans-unit>
        <trans-unit id="0e79b5d88ed3c6e491dd1236e901c3ae33f6911d" translate="yes" xml:space="preserve">
          <source>Here are some Python examples of how to actually implement generators as if Python did not provide syntactic sugar for them:</source>
          <target state="translated">Вот несколько примеров того,как на Python реализовывать генераторы так,как будто Python не обеспечивает их синтаксическим сахаром:</target>
        </trans-unit>
        <trans-unit id="a3efbd24d9780439598b7e67d051e0a6314b264c" translate="yes" xml:space="preserve">
          <source>Here is a demonstration which uses the structure of R6RS, but the semantics is absolutely identical to Python's. It's the same model of computation, and only a change in syntax is required to rewrite it in Python.</source>
          <target state="translated">Вот демонстрация,использующая структуру R6RS,но семантика абсолютно идентична Python'у.Это та же самая модель вычислений,и для ее переписывания на Python требуется только изменение синтаксиса.</target>
        </trans-unit>
        <trans-unit id="5172df8a142b5de0fd37381a2dbff76cdb21ea9b" translate="yes" xml:space="preserve">
          <source>Here is a mental image of what &lt;code&gt;yield&lt;/code&gt; does.</source>
          <target state="translated">Вот мысленный образ того, что делает &lt;code&gt;yield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea724b816190320574ae29c6484ba706b02e562b" translate="yes" xml:space="preserve">
          <source>Here is a simple example:</source>
          <target state="translated">Вот простой пример:</target>
        </trans-unit>
        <trans-unit id="823fc4d20942e0533416446349c24b8a063855e9" translate="yes" xml:space="preserve">
          <source>Here is an example in plain language. I will provide a correspondence between high-level human concepts to low-level Python concepts.</source>
          <target state="translated">Вот пример на простом языке.Я представлю соответствие между человеческими концепциями высокого уровня и концепциями низкого уровня на питонском языке.</target>
        </trans-unit>
        <trans-unit id="c4be0889ef73ed93c610ebfab505f5cb8fc53788" translate="yes" xml:space="preserve">
          <source>Here is an example which &lt;code&gt;yield&lt;/code&gt; is definitely best for:</source>
          <target state="translated">Вот пример, для которого &lt;code&gt;yield&lt;/code&gt; определенно лучше:</target>
        </trans-unit>
        <trans-unit id="6617e5991223485f0a00e8961fec1ddd85153c85" translate="yes" xml:space="preserve">
          <source>Here is an example, take note of the &lt;code&gt;received&lt;/code&gt; variable, which will point to the data that is sent to the generator:</source>
          <target state="translated">Вот пример, обратите внимание на &lt;code&gt;received&lt;/code&gt; переменную, которая будет указывать на данные, которые отправляются в генератор:</target>
        </trans-unit>
        <trans-unit id="89aa700446679e9b8d5b65f7b661f79a7e178b5e" translate="yes" xml:space="preserve">
          <source>Here it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once.</source>
          <target state="translated">Вот бесполезный пример,но он удобен,когда вы знаете,что ваша функция вернет огромный набор значений,которые вам нужно будет прочитать только один раз.</target>
        </trans-unit>
        <trans-unit id="eeb09fb712bc1579dd70a54645ad53925ce84c23" translate="yes" xml:space="preserve">
          <source>Here's a simple &lt;code&gt;yield&lt;/code&gt; based approach, to compute the fibonacci series, explained:</source>
          <target state="translated">Вот простой подход, основанный на &lt;code&gt;yield&lt;/code&gt; , для вычисления ряда Фибоначчи:</target>
        </trans-unit>
        <trans-unit id="d5531c22206a07d82c2ec43020b326ceb13fdc0a" translate="yes" xml:space="preserve">
          <source>How you might use generators</source>
          <target state="translated">Как вы можете использовать генераторы</target>
        </trans-unit>
        <trans-unit id="d332df6254754940f55d36631c669c40c1993a88" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;yield from&lt;/code&gt; also allows for delegation to subgenerators, 
which will be explained in the following section on cooperative delegation with sub-coroutines.</source>
          <target state="translated">Однако &lt;code&gt;yield from&lt;/code&gt; также позволяет делегировать субгенераторам, что будет объяснено в следующем разделе о совместном делегировании с суб-сопрограммами.</target>
        </trans-unit>
        <trans-unit id="f7b0cdd1500200d6f1d896513a1bb21305470aa6" translate="yes" xml:space="preserve">
          <source>I am not a Python developer, but it looks to me &lt;code&gt;yield&lt;/code&gt; holds the position of program flow and the next loop start from &quot;yield&quot; position. It seems like it is waiting at that position, and just before that, returning a value outside, and next time continues to work.</source>
          <target state="translated">Я не являюсь разработчиком Python, но, как мне кажется, &lt;code&gt;yield&lt;/code&gt; сохраняет позицию потока программы, а следующий цикл начинается с позиции yield. Кажется, что он ждет в этой позиции, и только перед этим, возвращает значение за пределами, и в следующий раз продолжает работать.</target>
        </trans-unit>
        <trans-unit id="7e9ed01bd64f5c7896a84a3e0de95a03f1c43874" translate="yes" xml:space="preserve">
          <source>I ask you, &quot;tell me the next number&quot;, and you tell me the first number; after that, you wait for me to ask you for the next number. It's your job to remember where you were, what numbers you have already said, and what is the next number. I don't care about the details.</source>
          <target state="translated">Я прошу тебя:&quot;Скажи мне следующее число&quot;,а ты говоришь мне первое число;после этого ты ждешь,пока я спрошу тебя о следующем числе.Ваша задача-вспомнить,где вы были,какие номера вы уже сказали,и какой следующий номер.Меня не волнуют детали.</target>
        </trans-unit>
        <trans-unit id="ae297b474260c70e731c6a136da6c3a9aef2dfb5" translate="yes" xml:space="preserve">
          <source>I assume you have learned the &lt;code&gt;return&lt;/code&gt; statement.</source>
          <target state="translated">Я полагаю, вы узнали &lt;code&gt;return&lt;/code&gt; заявление.</target>
        </trans-unit>
        <trans-unit id="5bff8648a9749f500c9b8ad13ccf39b8881ec210" translate="yes" xml:space="preserve">
          <source>I believe I have covered all aspects of the following question:</source>
          <target state="translated">Полагаю,что я охватил все аспекты следующего вопроса:</target>
        </trans-unit>
        <trans-unit id="a679dadd1d940ee0fc56a1b939523e2268a7d0ab" translate="yes" xml:space="preserve">
          <source>I call you and tell you that I want a sequence of numbers which is produced in a specific way, and I let you know what the algorithm is.</source>
          <target state="translated">Я звоню вам и говорю,что мне нужна последовательность чисел,которая производится определенным образом,и я сообщаю вам,что это за алгоритм.</target>
        </trans-unit>
        <trans-unit id="b123a6615d9a46f5c9c87bd3114b75d2fd201567" translate="yes" xml:space="preserve">
          <source>I like to think of a thread as having a stack (even when it's not implemented that way).</source>
          <target state="translated">Мне нравится думать о потоке,как о стеке (даже если он не реализован таким образом).</target>
        </trans-unit>
        <trans-unit id="776c90801148362b805a9659dc082980e40d4245" translate="yes" xml:space="preserve">
          <source>I should note that this &lt;em&gt;is&lt;/em&gt; an oversimplification for illustrative purposes. :)</source>
          <target state="translated">Должен отметить, что это упрощение в иллюстративных целях. :)</target>
        </trans-unit>
        <trans-unit id="cb5a08e181cbeb658f35df743832a692b6761240" translate="yes" xml:space="preserve">
          <source>I want to operate on a sequence of numbers, but I don't want to bother my self with the creation of that sequence, I want only to focus on the operation I want to do. So, I do the following:</source>
          <target state="translated">Я хочу работать с последовательностью чисел,но я не хочу беспокоить себя созданием этой последовательности,я хочу сосредоточиться только на операции,которую я хочу сделать.Итак,я делаю следующее:</target>
        </trans-unit>
        <trans-unit id="a3a2a857bfdd4d4fc3add0498fdaf773cfe37b55" translate="yes" xml:space="preserve">
          <source>I was going to post &quot;read page 19 of Beazley's 'Python: Essential Reference' for a quick description of generators&quot;, but so many others have posted good descriptions already.</source>
          <target state="translated">Я собирался написать &quot;прочитать 19-ю страницу &quot;Пайтона&quot; Бизли:Essential Reference&quot; для быстрого описания генераторов&quot;,но многие другие уже разместили хорошие описания.</target>
        </trans-unit>
        <trans-unit id="a101ee9df37442be51ecc059a7eaa91d1dd5f763" translate="yes" xml:space="preserve">
          <source>I'd agree that's a sensible place for us to end up, as any code
  relying on the current behaviour is really too clever to be
  maintainable.</source>
          <target state="translated">Я бы согласился,что это разумное место для нас,так как любой код,полагающийся на текущее поведение,действительно слишком умен,чтобы его можно было поддерживать.</target>
        </trans-unit>
        <trans-unit id="1f609c272028fe91fcfd70e16ea920d4901be9b2" translate="yes" xml:space="preserve">
          <source>I'm OK with either approach.  Leaving things the way they are in Python 3
      is no good, IMHO.</source>
          <target state="translated">Я не против любого подхода.Оставлять все как есть на Питоне 3 нехорошо,ИМХО.</target>
        </trans-unit>
        <trans-unit id="f3a52ccfeb39b7c960e43a846a1980250d8002bd" translate="yes" xml:space="preserve">
          <source>If the compiler detects the &lt;code&gt;yield&lt;/code&gt; keyword &lt;em&gt;anywhere&lt;/em&gt; inside a function, that function no longer returns via the &lt;code&gt;return&lt;/code&gt; statement. &lt;strong&gt;&lt;em&gt;Instead&lt;/em&gt;&lt;/strong&gt;, it &lt;strong&gt;immediately&lt;/strong&gt; returns a &lt;strong&gt;lazy &quot;pending list&quot; object&lt;/strong&gt; called a generator</source>
          <target state="translated">Если компилятор обнаруживает ключевое слово &lt;code&gt;yield&lt;/code&gt; &lt;em&gt;где-либо&lt;/em&gt; внутри функции, эта функция больше не возвращается через оператор &lt;code&gt;return&lt;/code&gt; . &lt;strong&gt;&lt;em&gt;Вместо этого&lt;/em&gt;&lt;/strong&gt; он &lt;strong&gt;немедленно&lt;/strong&gt; возвращает &lt;strong&gt;ленивый объект &amp;laquo;список ожидания&amp;raquo;,&lt;/strong&gt; называемый генератором.</target>
        </trans-unit>
        <trans-unit id="863b82de998a8840db9f970356b780625e865e98" translate="yes" xml:space="preserve">
          <source>If you need &lt;strong&gt;multiple passes&lt;/strong&gt; and the series isn't too long, just call &lt;code&gt;list()&lt;/code&gt; on it:</source>
          <target state="translated">Если вам нужно &lt;strong&gt;несколько проходов,&lt;/strong&gt; и серия не слишком длинная, просто вызовите &lt;code&gt;list()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8e81f608f52f839d0787e210b24258db0ad4019d" translate="yes" xml:space="preserve">
          <source>If you want &lt;strong&gt;a function to return a huge set of values&lt;/strong&gt;, use &lt;code&gt;yield&lt;/code&gt;.</source>
          <target state="translated">Если вы хотите, &lt;strong&gt;чтобы функция возвращала огромный набор значений&lt;/strong&gt; , используйте &lt;code&gt;yield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e30ae315ff14bf5d22d79d19890817eba23a8df" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://docs.python.org/2/reference/simple_stmts.html#the-return-statement&quot;&gt;Python 2&lt;/a&gt;:</source>
          <target state="translated">В &lt;a href=&quot;https://docs.python.org/2/reference/simple_stmts.html#the-return-statement&quot;&gt;Python 2&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="ff77817e2891cf318ae9092b17aa58414c356493" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-return-statement&quot;&gt;Python 3&lt;/a&gt;:</source>
          <target state="translated">В &lt;a href=&quot;https://docs.python.org/3/reference/simple_stmts.html#the-return-statement&quot;&gt;Python 3&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="01f20dd2f471369e8b09d4eee95c6fa431042ca7" translate="yes" xml:space="preserve">
          <source>In &lt;strong&gt;Controlling a generator exhaustion&lt;/strong&gt; he calls the &lt;code&gt;.next&lt;/code&gt; method, when instead he should use the builtin function, &lt;code&gt;next&lt;/code&gt;. It would be an appropriate layer of indirection, because his code does not work in Python 3.</source>
          <target state="translated">В &lt;strong&gt;Управлении исчерпанием генератора&lt;/strong&gt; он вызывает метод &lt;code&gt;.next&lt;/code&gt; , когда вместо этого он должен использовать встроенную функцию, &lt;code&gt;next&lt;/code&gt; . Это был бы соответствующий уровень косвенности, потому что его код не работает в Python 3.</target>
        </trans-unit>
        <trans-unit id="9d6c893042f47fbe024cf470eea2e0d66f65c064" translate="yes" xml:space="preserve">
          <source>In Python 3, you can &lt;strong&gt;delegate&lt;/strong&gt; from one generator to another in both directions with &lt;strong&gt;&lt;code&gt;yield from&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">В Python 3 вы можете &lt;strong&gt;делегировать&lt;/strong&gt; от одного генератора другому в обоих направлениях с помощью &lt;strong&gt; &lt;code&gt;yield from&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8ddb3a147bbf4149f8203b3ca2fa59434dcfe553" translate="yes" xml:space="preserve">
          <source>In Python-speak, an &lt;em&gt;iterable&lt;/em&gt; is any object which &quot;understands the concept of a for-loop&quot; like a list &lt;code&gt;[1,2,3]&lt;/code&gt;, and an &lt;em&gt;iterator&lt;/em&gt; is a specific instance of the requested for-loop like &lt;code&gt;[1,2,3].__iter__()&lt;/code&gt;. A &lt;em&gt;generator&lt;/em&gt; is exactly the same as any iterator, except for the way it was written (with function syntax).</source>
          <target state="translated">В языке Python &lt;em&gt;итеративный&lt;/em&gt; - это любой объект, который &amp;laquo;понимает концепцию цикла for&amp;raquo;, например, список &lt;code&gt;[1,2,3]&lt;/code&gt; , а &lt;em&gt;итератор&lt;/em&gt; - это конкретный экземпляр запрошенного цикла for, например &lt;code&gt;[1,2,3].__iter__()&lt;/code&gt; . &lt;em&gt;Генератор&lt;/em&gt; точно такой же, как и любой итератор, за исключением того, как он был написан (с синтаксисом функции).</target>
        </trans-unit>
        <trans-unit id="174c5ef25999552b6ac3e98b79e66dc670f6ce7e" translate="yes" xml:space="preserve">
          <source>In a generator function, the &lt;code&gt;return&lt;/code&gt; statement indicates that the generator is done and will cause &lt;code&gt;StopIteration&lt;/code&gt; to be raised. The returned value (if any) is used as an argument to construct &lt;code&gt;StopIteration&lt;/code&gt; and becomes the &lt;code&gt;StopIteration.value&lt;/code&gt; attribute.</source>
          <target state="translated">В функции генератора оператор &lt;code&gt;return&lt;/code&gt; указывает на то, что генератор завершен и будет вызывать &lt;code&gt;StopIteration&lt;/code&gt; . Возвращаемое значение (если оно есть) используется в качестве аргумента для создания &lt;code&gt;StopIteration&lt;/code&gt; и становится атрибутом &lt;code&gt;StopIteration.value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a40ea84cb1072d7d399fbe3b382af1883bc53737" translate="yes" xml:space="preserve">
          <source>In a generator function, the &lt;code&gt;return&lt;/code&gt; statement is not allowed to include an &lt;code&gt;expression_list&lt;/code&gt;. In that context, a bare &lt;code&gt;return&lt;/code&gt; indicates that the generator is done and will cause &lt;code&gt;StopIteration&lt;/code&gt; to be raised.</source>
          <target state="translated">В функции-генераторе оператор &lt;code&gt;return&lt;/code&gt; не может включать &lt;code&gt;expression_list&lt;/code&gt; список. В этом контексте пустой &lt;code&gt;return&lt;/code&gt; указывает на то, что генератор завершен и вызовет &lt;code&gt;StopIteration&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe5f6300dd7512030712c12beefa508ff061926a" translate="yes" xml:space="preserve">
          <source>In a nutshell: &lt;strong&gt;a generator is a lazy, incrementally-pending list&lt;/strong&gt;, and &lt;strong&gt;&lt;code&gt;yield&lt;/code&gt; statements allow you to use function notation to program the list values&lt;/strong&gt; the generator should incrementally spit out.</source>
          <target state="translated">В двух словах: &lt;strong&gt;генератор - это ленивый, постепенно увеличивающийся список&lt;/strong&gt; , а &lt;strong&gt;операторы &lt;code&gt;yield&lt;/code&gt; позволяют использовать функцию обозначения для программирования значений списка, которые&lt;/strong&gt; генератор должен постепенно выводить.</target>
        </trans-unit>
        <trans-unit id="a0169a7972621076b895fe9b5351a9c054ff5aa8" translate="yes" xml:space="preserve">
          <source>In conclusion, as a metaphor to grok it:</source>
          <target state="translated">В заключение,в качестве метафоры для гроука:</target>
        </trans-unit>
        <trans-unit id="65df69d0bd87c71c73d55034f2acb57286f92bd2" translate="yes" xml:space="preserve">
          <source>In continuation passing style (CPS), continuations are just normal functions (only in languages where functions are first class) which the programmer explicitly manages and passes around to subroutines. In this style, program state is represented by closures (and the variables that happen to be encoded in them) rather than variables that reside somewhere on the stack. Functions that manage control flow accept continuation as arguments (in some variations of CPS, functions may accept multiple continuations) and manipulate control flow by invoking them by simply calling them and returning afterwards. A very simple example of continuation passing style is as follows:</source>
          <target state="translated">В продолжении стиля передачи (CPS)продолжения являются обычными функциями (только в языках,где функции являются первоклассными),которые программист явно управляет и передает подпрограммам.В этом стиле состояние программы представлено замыканиями (и переменными,которые в них кодируются),а не переменными,которые находятся где-то на стеке.Функции,управляющие потоком управления,принимают продолжения в качестве аргументов (в некоторых вариациях CPS функции могут принимать несколько продолжений)и манипулируют потоком управления,просто вызывая их и возвращаясь после.Очень простым примером стиля передачи продолжений является следующий:</target>
        </trans-unit>
        <trans-unit id="f90a21a794093245566d4b9689b0360b69b80989" translate="yes" xml:space="preserve">
          <source>In summary, the &lt;code&gt;yield&lt;/code&gt; statement transforms your function into a factory that produces a special object called a &lt;code&gt;generator&lt;/code&gt; which wraps around the body of your original function. When the &lt;code&gt;generator&lt;/code&gt; is iterated, it executes your function  until it reaches the next &lt;code&gt;yield&lt;/code&gt; then suspends execution and evaluates to the value passed to &lt;code&gt;yield&lt;/code&gt;. It repeats this process on each iteration until the path of execution exits the function. For instance,</source>
          <target state="translated">Таким образом, оператор &lt;code&gt;yield&lt;/code&gt; превращает вашу функцию в фабрику, которая создает специальный объект, называемый &lt;code&gt;generator&lt;/code&gt; который оборачивает тело вашей исходной функции. Когда &lt;code&gt;generator&lt;/code&gt; повторяется, он выполняет вашу функцию, пока не достигнет следующего &lt;code&gt;yield&lt;/code&gt; затем приостанавливает выполнение и оценивает значение, переданное в &lt;code&gt;yield&lt;/code&gt; . Он повторяет этот процесс на каждой итерации, пока путь выполнения не выйдет из функции. Например,</target>
        </trans-unit>
        <trans-unit id="dbb3601dd734c0edf841aa944a55cbabed686850" translate="yes" xml:space="preserve">
          <source>In terms of getting there, we'll likely want:</source>
          <target state="translated">С точки зрения попадания туда,мы,скорее всего,захотим:</target>
        </trans-unit>
        <trans-unit id="af70c38bd0efc99a5d44a07df4047e8a92d9ae06" translate="yes" xml:space="preserve">
          <source>In the case of your code, the function &lt;code&gt;get_child_candidates&lt;/code&gt; is acting like an iterator so that when you extend your list, it adds one element at a time to the new list.</source>
          <target state="translated">В случае вашего кода функция &lt;code&gt;get_child_candidates&lt;/code&gt; действует как итератор, поэтому при расширении списка она добавляет один элемент за один раз в новый список.</target>
        </trans-unit>
        <trans-unit id="791078267dbf81f5f1c3cf2eb3971161ef95c26f" translate="yes" xml:space="preserve">
          <source>In the second case, &lt;code&gt;bar&lt;/code&gt; just gives you a generator. A generator is an iterable--which means you can use it in a &lt;code&gt;for&lt;/code&gt; loop, etc, but each value can only be accessed once. All the values are also not stored in memory at the same time; the generator object &quot;remembers&quot; where it was in the looping the last time you called it--this way, if you're using an iterable to (say) count to 50 billion, you don't have to count to 50 billion all at once and store the 50 billion numbers to count through.</source>
          <target state="translated">Во втором случае, &lt;code&gt;bar&lt;/code&gt; просто дает вам генератор. Генератор является итеративным - это означает, что вы можете использовать его в цикле &lt;code&gt;for&lt;/code&gt; и т. Д., Но к каждому значению можно получить доступ только один раз. Все значения также не сохраняются в памяти одновременно; объект генератора &amp;laquo;запоминает&amp;raquo;, где он находился в цикле в последний раз, когда вы его вызывали - таким образом, если вы используете итеративный подсчет (скажем) до 50 миллиардов, вам не нужно считать до 50 миллиардов всех и запомните 50 миллиардов номеров</target>
        </trans-unit>
        <trans-unit id="bd951975204b594b5a324c588bdc33476765e99f" translate="yes" xml:space="preserve">
          <source>In this (very simplistic) example, the programmer saves the operation of actually writing the file into a continuation (which can potentially be a very complex operation with many details to write out), and then passes that continuation (i.e, as a first-class closure) to another operator which does some more processing, and then calls it if necessary. (I use this design pattern a lot in actual GUI programming, either because it saves me lines of code or, more importantly, to manage control flow after GUI events trigger.)</source>
          <target state="translated">В этом (очень упрощенном)примере,программист сохраняет операцию фактической записи файла в продолжение (что потенциально может быть очень сложной операцией с множеством деталей для записи),а затем передает это продолжение (т.е.как первоклассное закрытие)другому оператору,который делает некоторую дополнительную обработку,а затем вызывает его,если это необходимо.(Я часто использую этот шаблон проектирования в реальном программировании GUI,либо потому что он экономит мне строки кода,либо,что более важно,для управления потоком управления после срабатывания событий GUI).</target>
        </trans-unit>
        <trans-unit id="d137b802f3a324a2d71f425b20cbe30685de8a31" translate="yes" xml:space="preserve">
          <source>Indirectly, if you provide &lt;code&gt;fib&lt;/code&gt; to a &lt;code&gt;for&lt;/code&gt; loop, a &lt;code&gt;list&lt;/code&gt; initializer, a &lt;code&gt;tuple&lt;/code&gt; initializer, or anything else that expects an object that generates/produces values, you'll &quot;consume&quot; the generator until no more values can be produced by it (and it returns):</source>
          <target state="translated">Косвенно, если вы предоставите &lt;code&gt;fib&lt;/code&gt; &lt;code&gt;for&lt;/code&gt; цикла for , инициализатора &lt;code&gt;list&lt;/code&gt; инициализатора &lt;code&gt;tuple&lt;/code&gt; или чего-либо еще, что ожидает объект, который генерирует / производит значения, вы будете &amp;laquo;потреблять&amp;raquo; генератор, пока он не сможет произвести больше значений ( и оно возвращается)</target>
        </trans-unit>
        <trans-unit id="1484d552dab70171147c52a184472f4c770e78cd" translate="yes" xml:space="preserve">
          <source>Insert a line &lt;code&gt;result = []&lt;/code&gt; at the start of the function.</source>
          <target state="translated">Вставьте строку &lt;code&gt;result = []&lt;/code&gt; в начале функции.</target>
        </trans-unit>
        <trans-unit id="f65bc680a718b8079e23b9ac8d4b6ee9a4e7033d" translate="yes" xml:space="preserve">
          <source>Insert a line &lt;code&gt;return result&lt;/code&gt; at the bottom of the function.</source>
          <target state="translated">Вставьте результат &lt;code&gt;return result&lt;/code&gt; строки внизу функции.</target>
        </trans-unit>
        <trans-unit id="ddae4c2e0ba5c800a528da8a2d033235effb5bce" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;yield&lt;/code&gt; statements, if you had three &lt;code&gt;return&lt;/code&gt; statements in &lt;code&gt;f123()&lt;/code&gt; only the first would get executed, and the function would exit. But &lt;code&gt;f123()&lt;/code&gt; is no ordinary function. When &lt;code&gt;f123()&lt;/code&gt; is called, it &lt;em&gt;does not&lt;/em&gt; return any of the values in the yield statements! It returns a generator object. Also, the function does not really exit - it goes into a suspended state. When the &lt;code&gt;for&lt;/code&gt; loop tries to loop over the generator object, the function resumes from its suspended state at the very next line after the &lt;code&gt;yield&lt;/code&gt; it previously returned from, executes the next line of code, in this case, a &lt;code&gt;yield&lt;/code&gt; statement, and returns that as the next item. This happens until the function exits, at which point the generator raises &lt;code&gt;StopIteration&lt;/code&gt;, and the loop exits.</source>
          <target state="translated">Вместо операторов &lt;code&gt;yield&lt;/code&gt; , если в &lt;code&gt;f123()&lt;/code&gt; было три оператора &lt;code&gt;return&lt;/code&gt; выполнялась только первая, и функция завершалась . Но &lt;code&gt;f123()&lt;/code&gt; не обычная функция. Когда &lt;code&gt;f123()&lt;/code&gt; , он &lt;em&gt;не&lt;/em&gt; возвращает никаких значений в операторах yield! Возвращает объект генератора. Кроме того, функция на самом деле не выходит - она ​​переходит в состояние ожидания. Когда цикл &lt;code&gt;for&lt;/code&gt; пытается зациклить объект-генератор, функция возвращается из своего приостановленного состояния на самой следующей строке после ранее возвращенного результата &lt;code&gt;yield&lt;/code&gt; , выполняет следующую строку кода, в данном случае оператор &lt;code&gt;yield&lt;/code&gt; , и возвращает как следующий пункт. Это происходит до тех пор, пока функция не выйдет, и в этот момент генератор вызывает &lt;code&gt;StopIteration&lt;/code&gt; и цикл завершается.</target>
        </trans-unit>
        <trans-unit id="6ba67eec9e92df05acdf46af85244d2e3cb47ac2" translate="yes" xml:space="preserve">
          <source>Instead of this:</source>
          <target state="translated">Вместо этого:</target>
        </trans-unit>
        <trans-unit id="a2128e769c0a333306ebd59207294d6e72de5845" translate="yes" xml:space="preserve">
          <source>It can be useful for various things like controlling access to a resource.</source>
          <target state="translated">Он может быть полезен для различных вещей,например,для контроля доступа к ресурсу.</target>
        </trans-unit>
        <trans-unit id="815bab4f701d81dd1ca8739066ea47b1ea845181" translate="yes" xml:space="preserve">
          <source>It is confused on what makes an &lt;strong&gt;iterable&lt;/strong&gt;, just using a list as an example. See my references above, but in summary: an iterable has an &lt;code&gt;__iter__&lt;/code&gt; method returning an &lt;strong&gt;iterator&lt;/strong&gt;. An &lt;strong&gt;iterator&lt;/strong&gt; provides a &lt;code&gt;.next&lt;/code&gt; (Python 2 or &lt;code&gt;.__next__&lt;/code&gt; (Python 3) method, which is implicitly called by &lt;code&gt;for&lt;/code&gt; loops until it raises &lt;code&gt;StopIteration&lt;/code&gt;, and once it does, it will continue to do so.</source>
          <target state="translated">Он запутался в том, что делает &lt;strong&gt;итеративным&lt;/strong&gt; , просто используя список в качестве примера. См. Мои ссылки выше, но в заключение: итерируемый имеет метод &lt;code&gt;__iter__&lt;/code&gt; , возвращающий &lt;strong&gt;итератор&lt;/strong&gt; . &lt;strong&gt;Итератор&lt;/strong&gt; предоставляет &lt;code&gt;.next&lt;/code&gt; (Python 2 или &lt;code&gt;.__next__&lt;/code&gt; (Python 3)), который неявно вызывается &lt;code&gt;for&lt;/code&gt; циклов for до тех пор, пока он не &lt;code&gt;StopIteration&lt;/code&gt; , и, как только он это сделает, он продолжит это делать.</target>
        </trans-unit>
        <trans-unit id="d0e5a74aff1c87c165974074b746e9b876037387" translate="yes" xml:space="preserve">
          <source>It is just the same except you used &lt;code&gt;()&lt;/code&gt; instead of &lt;code&gt;[]&lt;/code&gt;. BUT, you &lt;strong&gt;cannot&lt;/strong&gt; perform &lt;code&gt;for i in mygenerator&lt;/code&gt; a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end calculating 4, one by one.</source>
          <target state="translated">Это то же самое, за исключением того, что вы использовали &lt;code&gt;()&lt;/code&gt; вместо &lt;code&gt;[]&lt;/code&gt; . НО, вы &lt;strong&gt;не можете&lt;/strong&gt; выполнить &lt;code&gt;for i in mygenerator&lt;/code&gt; второй раз, так как генераторы могут использоваться только один раз: они вычисляют 0, затем забывают об этом и вычисляют 1, и заканчивают вычислять 4, один за другим.</target>
        </trans-unit>
        <trans-unit id="05428c01ccee190c5ac8f4e2b026d5698fe85729" translate="yes" xml:space="preserve">
          <source>It really helps simplify some problems, and makes some things easier to work with.</source>
          <target state="translated">Это действительно помогает упростить некоторые проблемы и делает некоторые вещи проще в работе.</target>
        </trans-unit>
        <trans-unit id="ce1006cada79cecc9b2fc03861f35b39cd056555" translate="yes" xml:space="preserve">
          <source>It seems to be an interesting and nice ability :D</source>
          <target state="translated">Похоже,это интересная и приятная способность :D</target>
        </trans-unit>
        <trans-unit id="a4c8c5a8330bec1551d58ebddad1eca41f75c743" translate="yes" xml:space="preserve">
          <source>It then uses a generator expression to describe what a generator is. Since a generator is simply a convenient way to create an &lt;strong&gt;iterator&lt;/strong&gt;, it only confuses the matter, and we still have not yet gotten to the &lt;code&gt;yield&lt;/code&gt; part.</source>
          <target state="translated">Затем он использует выражение генератора, чтобы описать, что такое генератор. Поскольку генератор - это просто удобный способ создания &lt;strong&gt;итератора&lt;/strong&gt; , он только сбивает с толку, а мы до сих пор еще не дошли до части &lt;code&gt;yield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b525c9fdafab13df3793783112dad0c5e7c47f0" translate="yes" xml:space="preserve">
          <source>It turns out that &lt;code&gt;yield&lt;/code&gt; does a lot. I'm sure I could add even more 
thorough examples to this. If you want more or have some constructive criticism, let me know by commenting
below.</source>
          <target state="translated">Оказывается, &lt;code&gt;yield&lt;/code&gt; делает много. Я уверен, что мог бы добавить еще более подробные примеры к этому. Если вы хотите больше или имеете конструктивную критику, дайте мне знать, комментируя ниже.</target>
        </trans-unit>
        <trans-unit id="bedfd4c2b8ac96435e9dab026a1ad6ca9d8e9595" translate="yes" xml:space="preserve">
          <source>It's returning a generator. I'm not particularly familiar with Python, but I believe it's the same kind of thing as &lt;a href=&quot;http://csharpindepth.com/Articles/Chapter11/StreamingAndIterators.aspx&quot;&gt;C#'s iterator blocks&lt;/a&gt; if you're familiar with those.</source>
          <target state="translated">Это возвращает генератор. Я не особенно знаком с Python, но я считаю, что это то же самое, что &lt;a href=&quot;http://csharpindepth.com/Articles/Chapter11/StreamingAndIterators.aspx&quot;&gt;и блоки итераторов C #,&lt;/a&gt; если вы знакомы с ними.</target>
        </trans-unit>
        <trans-unit id="b62a14283b71537aa375bb5504d321c2fa6f966c" translate="yes" xml:space="preserve">
          <source>It's the core about &lt;code&gt;yield&lt;/code&gt;.</source>
          <target state="translated">Это суть о &lt;code&gt;yield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dd80eea3f6c51bf5b9c13a8a47609bd55b30e0e" translate="yes" xml:space="preserve">
          <source>Iterables</source>
          <target state="translated">Iterables</target>
        </trans-unit>
        <trans-unit id="d8b8f9a4e83121e284417429816033e650e4b4db" translate="yes" xml:space="preserve">
          <source>Iteration is a process implying iterables (implementing the &lt;code&gt;__iter__()&lt;/code&gt; method) and iterators (implementing the &lt;code&gt;__next__()&lt;/code&gt; method).
Iterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables.</source>
          <target state="translated">Итерация - это процесс, подразумевающий итераторы (реализующие метод &lt;code&gt;__iter__()&lt;/code&gt; ) и итераторы (реализующие метод &lt;code&gt;__next__()&lt;/code&gt; ). Итерации - это любые объекты, от которых вы можете получить итератор. Итераторы - это объекты, которые позволяют вам повторять итерации.</target>
        </trans-unit>
        <trans-unit id="0ae5cba6a7258c212d3cd38a207c7e9817fe838e" translate="yes" xml:space="preserve">
          <source>Itertools, your best friend</source>
          <target state="translated">Итертулс,твой лучший друг</target>
        </trans-unit>
        <trans-unit id="45989d87a7cb5c27f41e09694e3e18fcead4c711" translate="yes" xml:space="preserve">
          <source>Itertools? This was not relevant to what &lt;code&gt;yield&lt;/code&gt; does at all.</source>
          <target state="translated">Itertools? Это не имело отношения к тому, что &lt;code&gt;yield&lt;/code&gt; вообще делает.</target>
        </trans-unit>
        <trans-unit id="4092678f14b36035b0f14d72fd89eede06817d6a" translate="yes" xml:space="preserve">
          <source>Keep calling the &lt;code&gt;next()&lt;/code&gt; method on the iterator returned from step 1. The return value from &lt;code&gt;next()&lt;/code&gt; is assigned to &lt;code&gt;x&lt;/code&gt; and the loop body is executed. If an exception &lt;code&gt;StopIteration&lt;/code&gt; is raised from within &lt;code&gt;next()&lt;/code&gt;, it means there are no more values in the iterator and the loop is exited.</source>
          <target state="translated">Продолжайте вызывать метод &lt;code&gt;next()&lt;/code&gt; на итераторе, возвращаемом с шага 1. Возвращаемое значение &lt;code&gt;next()&lt;/code&gt; присваивается &lt;code&gt;x&lt;/code&gt; , и тело цикла выполняется. Если исключение &lt;code&gt;StopIteration&lt;/code&gt; вызывается изнутри &lt;code&gt;next()&lt;/code&gt; , это означает, что в итераторе больше нет значений и цикл завершается.</target>
        </trans-unit>
        <trans-unit id="02ece3e82c3cc947abccfde61ed0ddf58d180562" translate="yes" xml:space="preserve">
          <source>Let's define a function &lt;code&gt;makeRange&lt;/code&gt; that's just like Python's &lt;code&gt;range&lt;/code&gt;. Calling &lt;code&gt;makeRange(n)&lt;/code&gt; RETURNS A GENERATOR:</source>
          <target state="translated">Давайте определим функцию &lt;code&gt;makeRange&lt;/code&gt; , которая похожа на &lt;code&gt;range&lt;/code&gt; Python. Вызов &lt;code&gt;makeRange(n)&lt;/code&gt; ВОЗВРАЩАЕТ ГЕНЕРАТОР:</target>
        </trans-unit>
        <trans-unit id="17e789352f0c8efe4814e81b930cce60ca106303" translate="yes" xml:space="preserve">
          <source>Like every answer suggests, &lt;code&gt;yield&lt;/code&gt; is used for creating a sequence generator. It's used for generating some sequence dynamically. For example, while reading a file line by line on a network, you can use the &lt;code&gt;yield&lt;/code&gt; function as follows:</source>
          <target state="translated">Как и предполагает каждый ответ, &lt;code&gt;yield&lt;/code&gt; используется для создания генератора последовательности. Он используется для генерации некоторой последовательности динамически. Например, читая файл построчно в сети, вы можете использовать функцию &lt;code&gt;yield&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="f1e0ba1d127fcef46948db3881dab6eede1ff0a8" translate="yes" xml:space="preserve">
          <source>Luckily Guido and his team were generous enough to develop generators so we could just do this;</source>
          <target state="translated">К счастью,Гвидо и его команда были достаточно щедры,чтобы разработать генераторы,так что мы могли просто сделать это;</target>
        </trans-unit>
        <trans-unit id="ea2bbc6304080fdb00b621f7aa3245c1e64e92e2" translate="yes" xml:space="preserve">
          <source>Many people use &lt;code&gt;return&lt;/code&gt; rather than &lt;code&gt;yield&lt;/code&gt;, but in some cases &lt;code&gt;yield&lt;/code&gt; can be more efficient and easier to work with.</source>
          <target state="translated">Многие люди используют &lt;code&gt;return&lt;/code&gt; а не &lt;code&gt;yield&lt;/code&gt; , но в некоторых случаях &lt;code&gt;yield&lt;/code&gt; может быть более эффективным и с ним легче работать.</target>
        </trans-unit>
        <trans-unit id="f1ecc57d869eaa2aeb4f14bb021fbf641a09a4cf" translate="yes" xml:space="preserve">
          <source>Minutiae</source>
          <target state="translated">Minutiae</target>
        </trans-unit>
        <trans-unit id="63298b940ce76e1f6554f705d9938c3451b0daf7" translate="yes" xml:space="preserve">
          <source>More importantly, &lt;code&gt;yield&lt;/code&gt; is a &lt;strong&gt;barrier&lt;/strong&gt;.</source>
          <target state="translated">Что еще более важно, &lt;code&gt;yield&lt;/code&gt; является &lt;strong&gt;барьером&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="260be5bd97364077b3283e9557a7cf6fccbc23dd" translate="yes" xml:space="preserve">
          <source>Moreover &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;this&lt;/a&gt; will introduce (since Python 3.5):</source>
          <target state="translated">Более того, &lt;a href=&quot;https://www.python.org/dev/peps/pep-0492/&quot;&gt;это&lt;/a&gt; представит (начиная с Python 3.5):</target>
        </trans-unit>
        <trans-unit id="f90dd4485580d3bdc59a261e1ec77656145f7983" translate="yes" xml:space="preserve">
          <source>My vote is it be a SyntaxError since you're not getting what you expect from
    the syntax.</source>
          <target state="translated">Я голосую за SyntaxError,так как вы не получаете то,что ожидаете от синтаксиса.</target>
        </trans-unit>
        <trans-unit id="6d2a636bd1ba1e865b86d549524144e1fe118a22" translate="yes" xml:space="preserve">
          <source>No discussion of the methods that &lt;code&gt;yield&lt;/code&gt; provides along with the new functionality &lt;code&gt;yield from&lt;/code&gt; in Python 3. &lt;strong&gt;The top/accepted answer is a very incomplete answer.&lt;/strong&gt;</source>
          <target state="translated">Никакое обсуждение методов, которые предоставляет &lt;code&gt;yield&lt;/code&gt; вместе с новой функциональностью, предоставлено в Python 3. &lt;strong&gt;Ответ верх / принят - очень неполный ответ.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="957edece43529861540ff3f36e5e7a2451ec8ff3" translate="yes" xml:space="preserve">
          <source>Normally, most people would not care about the following distinctions and probably want to stop reading here.</source>
          <target state="translated">Обычно большинство людей не заботятся о следующих различиях и,вероятно,хотят перестать читать здесь.</target>
        </trans-unit>
        <trans-unit id="f8c793e525ecfff42fd9cd9042640febe5190bea" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;def&lt;/code&gt;ining a function which contains a &lt;code&gt;yield&lt;/code&gt; keyword is not the only way to create a generator; it's just the easiest way to create one.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;def&lt;/code&gt; функции, содержащей ключевое слово &lt;code&gt;yield&lt;/code&gt; , - не единственный способ создания генератора; это просто самый простой способ создать его.</target>
        </trans-unit>
        <trans-unit id="c9d2501fc158d349dfef0af0d5919d70d9574d6f" translate="yes" xml:space="preserve">
          <source>Note that a &lt;code&gt;for&lt;/code&gt; loop doesn't know what kind of object it's dealing with - it just follows the iterator protocol, and is happy to get item after item as it calls &lt;code&gt;next()&lt;/code&gt;. Built-in lists return their items one by one, dictionaries return the &lt;em&gt;keys&lt;/em&gt; one by one, files return the &lt;em&gt;lines&lt;/em&gt; one by one, etc. And generators return... well that's where &lt;code&gt;yield&lt;/code&gt; comes in:</source>
          <target state="translated">Обратите внимание, что цикл &lt;code&gt;for&lt;/code&gt; не знает, с каким объектом он имеет дело - он просто следует протоколу итератора и рад получить элемент за элементом при вызове &lt;code&gt;next()&lt;/code&gt; . Встроенные списки возвращают свои элементы один за другим, словари возвращают &lt;em&gt;ключи&lt;/em&gt; один за другим, файлы возвращают &lt;em&gt;строки&lt;/em&gt; одну за другой и т. Д. И генераторы возвращают ... что ж, вот где происходит &lt;code&gt;yield&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d0983c67f73b9198117de75714eca1653ab0ab62" translate="yes" xml:space="preserve">
          <source>Now let's talk about generators in Python. Generators are a specific subtype of continuation. Whereas &lt;strong&gt;continuations are able in general to save the state of a &lt;em&gt;computation&lt;/em&gt;&lt;/strong&gt; (i.e., the program's call stack), &lt;strong&gt;generators are only able to save the state of iteration over an &lt;em&gt;iterator&lt;/em&gt;&lt;/strong&gt;. Although, this definition is slightly misleading for certain use cases of generators. For instance:</source>
          <target state="translated">Теперь поговорим о генераторах в Python. Генераторы - это определенный подтип продолжения. В то время как &lt;strong&gt;продолжения в целом могут сохранять состояние &lt;em&gt;вычислений&lt;/em&gt;&lt;/strong&gt; (т. Е. Стек вызовов программы), &lt;strong&gt;генераторы могут сохранять состояние итерации только через &lt;em&gt;итератор&lt;/em&gt;&lt;/strong&gt; . Хотя это определение слегка вводит в заблуждение для определенных случаев использования генераторов. Например:</target>
        </trans-unit>
        <trans-unit id="cbea0f398a5f710fc8e5fc5cc6c1aa916df7b9fc" translate="yes" xml:space="preserve">
          <source>Now the hard part:</source>
          <target state="translated">Теперь самое сложное:</target>
        </trans-unit>
        <trans-unit id="96065685d9b9c8665dca19ef4217583b206991ad" translate="yes" xml:space="preserve">
          <source>Now upon each iteration a function on the generator called &lt;code&gt;next()&lt;/code&gt; executes the function until it either reaches a 'yield' statement in which it stops and  'yields' the value or reaches the end of the function. In this case on the first call, &lt;code&gt;next()&lt;/code&gt; executes up to the yield statement and yield 'n', on the next call it will execute the  increment statement, jump back to the 'while', evaluate it, and if true, it will stop and yield 'n' again, it will continue that way until the while condition returns false and the generator jumps to the end of the function.</source>
          <target state="translated">Теперь после каждой итерации функция в генераторе, вызываемая &lt;code&gt;next()&lt;/code&gt; выполняет функцию до тех пор, пока она не достигнет оператора yield, в котором она останавливается и &amp;laquo;возвращает&amp;raquo; значение, или достигает конца функции. В этом случае при первом вызове &lt;code&gt;next()&lt;/code&gt; выполняется до оператора yield и выдает &amp;laquo;n&amp;raquo;, при следующем вызове выполняет оператор приращения, возвращается к &amp;laquo;времени&amp;raquo;, оценивает его и, если оно истинно, остановится и снова выдаст 'n', так будет продолжаться до тех пор, пока условие while не вернет false и генератор не перейдет к концу функции.</target>
        </trans-unit>
        <trans-unit id="6f591e3f872109c5472337a1e87fe9e3bcde0a83" translate="yes" xml:space="preserve">
          <source>Now, enter in the REPL:</source>
          <target state="translated">Теперь введите REPL:</target>
        </trans-unit>
        <trans-unit id="e92a9d3b2c29a2e3bc4353c33fa7bff82dd4846f" translate="yes" xml:space="preserve">
          <source>Now, recall that &lt;code&gt;yield from&lt;/code&gt; is available in Python 3. This allows us to delegate
coroutines to a subcoroutine:</source>
          <target state="translated">Теперь напомним, что &lt;code&gt;yield from&lt;/code&gt; доступен в Python 3. Это позволяет нам делегировать сопрограммы в подгруппу:</target>
        </trans-unit>
        <trans-unit id="5a307763317a3a7bc6e71bc9264167d7ad80a27e" translate="yes" xml:space="preserve">
          <source>Now, you win to get all the numbers.</source>
          <target state="translated">Теперь ты выигрываешь,чтобы получить все цифры.</target>
        </trans-unit>
        <trans-unit id="b6987f5b93c9acf22eca3106831b92a972ad34e6" translate="yes" xml:space="preserve">
          <source>On 30 January 2017 at 19:05, Brett Cannon  wrote:</source>
          <target state="translated">30 января 2017 года в 19:05 Бретт Кэннон писал:</target>
        </trans-unit>
        <trans-unit id="85c98d1e4740c518785320f781b5df7464816e4c" translate="yes" xml:space="preserve">
          <source>On Sun, 29 Jan 2017 at 16:39 Craig Rodrigues  wrote:</source>
          <target state="translated">На солнце,29 января 2017 года в 16:39 Крейг Родригес написал:</target>
        </trans-unit>
        <trans-unit id="effbc2c26171feae094bbbc8c2b18c68368e591a" translate="yes" xml:space="preserve">
          <source>One can yield data programmatically, for example:</source>
          <target state="translated">Например,можно получить данные программно:</target>
        </trans-unit>
        <trans-unit id="8ec523094d69740bf96305160c0edf4de24e608c" translate="yes" xml:space="preserve">
          <source>One more step we can rewrite &lt;code&gt;yield&lt;/code&gt; statement with &lt;code&gt;return&lt;/code&gt;</source>
          <target state="translated">Еще один шаг, который мы можем переписать с помощью &lt;code&gt;return&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b31a591d4d9d64b9d692dc2c86bc55fc3a7bde29" translate="yes" xml:space="preserve">
          <source>Original version:</source>
          <target state="translated">Оригинальная версия:</target>
        </trans-unit>
        <trans-unit id="bee143e2a96019cef9b2e3c68a2e94c347f68a59" translate="yes" xml:space="preserve">
          <source>Other Methods: close and throw</source>
          <target state="translated">Другие методы:закрыть и бросить</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="5f07ef89f002df2bf1789a1e70ac0785b82990f2" translate="yes" xml:space="preserve">
          <source>Please note: generators can actually be used for many more things, such as &lt;a href=&quot;http://www.dabeaz.com/coroutines/index.html&quot;&gt;implementing coroutines&lt;/a&gt; or non-deterministic programming or other elegant things. However, the &quot;lazy lists&quot; viewpoint I present here is the most common use you will find.</source>
          <target state="translated">Обратите внимание: генераторы могут использоваться для многих других целей, таких как &lt;a href=&quot;http://www.dabeaz.com/coroutines/index.html&quot;&gt;реализация сопрограмм,&lt;/a&gt; недетерминированное программирование или другие элегантные вещи. Тем не менее, точка зрения &amp;laquo;ленивых списков&amp;raquo;, которую я здесь представляю, является наиболее распространенной областью использования, которую вы найдете.</target>
        </trans-unit>
        <trans-unit id="00d9b100b9bcc674781b9766a8e6870f8757ebdd" translate="yes" xml:space="preserve">
          <source>Py3k warning in 2.7.x</source>
          <target state="translated">Предупреждение Py3k в 2.7.x</target>
        </trans-unit>
        <trans-unit id="cef032cf531f21b2c9cdf6eb64b001d4fb256c9b" translate="yes" xml:space="preserve">
          <source>Python compiles the function, encounters the &lt;code&gt;yield&lt;/code&gt; keyword and simply returns a generator object back at you. Not very helpful it seems.</source>
          <target state="translated">Python компилирует функцию, встречает ключевое слово &lt;code&gt;yield&lt;/code&gt; и просто возвращает объект генератора обратно к вам. Не очень полезно, кажется.</target>
        </trans-unit>
        <trans-unit id="c0e695374f96756b35fdfe22b9dbb044371df33d" translate="yes" xml:space="preserve">
          <source>Python performs the following two steps:</source>
          <target state="translated">Питон выполняет следующие два шага:</target>
        </trans-unit>
        <trans-unit id="c35284ab3425210def57302b5a65e2b0a11149ab" translate="yes" xml:space="preserve">
          <source>Remember that this is just pseudocode and the actual implementation of generators in Python is more complex. But as an exercise to understand what is going on, try to use continuation passing style to implement generator objects without use of the &lt;code&gt;yield&lt;/code&gt; keyword.</source>
          <target state="translated">Помните, что это просто псевдокод, и фактическая реализация генераторов в Python более сложна. Но в качестве упражнения, чтобы понять, что происходит, попробуйте использовать стиль передачи продолжения для реализации объектов генератора без использования ключевого слова &lt;code&gt;yield&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ac5b61c45f411038301d2404cf4fec54441c6ad" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;return&lt;/code&gt; with &lt;code&gt;yield&lt;/code&gt;:</source>
          <target state="translated">Заменить &lt;code&gt;return&lt;/code&gt; на &lt;code&gt;yield&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d3afd790e348a0c26c0be34d40ecc9f41e19d26d" translate="yes" xml:space="preserve">
          <source>Replace each &lt;code&gt;yield expr&lt;/code&gt; with &lt;code&gt;result.append(expr)&lt;/code&gt;.</source>
          <target state="translated">Замените каждый &lt;code&gt;yield expr&lt;/code&gt; на &lt;code&gt;result.append(expr)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25e781fe1df53bae8a289d02fbdb77ae6469547c" translate="yes" xml:space="preserve">
          <source>Run it:</source>
          <target state="translated">Запускай:</target>
        </trans-unit>
        <trans-unit id="97dadded1b9f2fcec4b19ca00a996516c8982a2c" translate="yes" xml:space="preserve">
          <source>Same behavior:</source>
          <target state="translated">То же самое поведение:</target>
        </trans-unit>
        <trans-unit id="5a97a974883d7bcd43990ce0a93d8ca9aa864bfd" translate="yes" xml:space="preserve">
          <source>Say you wanted to create a your own &lt;code&gt;range&lt;/code&gt; function that produces an iterable range of numbers, you could do it like so,</source>
          <target state="translated">Скажем, вы хотите создать свою собственную функцию &lt;code&gt;range&lt;/code&gt; которая производит итеративный диапазон чисел, вы можете сделать это так,</target>
        </trans-unit>
        <trans-unit id="2ab0369f1d5983f084d45c352d30c1446684eceb" translate="yes" xml:space="preserve">
          <source>See, you get only a single number rather than a list of them. &lt;code&gt;return&lt;/code&gt; never allows you prevail happily, just implements once and quit.</source>
          <target state="translated">Видите, вы получаете только один номер, а не их список. &lt;code&gt;return&lt;/code&gt; никогда не позволяет вам счастливо победить, просто реализуетесь один раз и выходите.</target>
        </trans-unit>
        <trans-unit id="010b0672dea78d8c4aa4f2420058adae5991abbe" translate="yes" xml:space="preserve">
          <source>Shortcut to understanding &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">Ярлык для понимания &lt;code&gt;yield&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7942e6cc5e90e1d35d5f04820acc2b178f0f857" translate="yes" xml:space="preserve">
          <source>Similarly, with a &lt;code&gt;tuple&lt;/code&gt; initializer:</source>
          <target state="translated">Точно так же с инициализатором &lt;code&gt;tuple&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b2196b60ca80d641d8c512b27441745d29a9bae0" translate="yes" xml:space="preserve">
          <source>Since yield is an expression, it has been touted by some as interesting to use it in comprehensions or generator expression - in spite of citing no particularly good use-case.</source>
          <target state="translated">Поскольку урожайность является выражением,некоторые считают его интересным использовать в понятиях или в выражении генератора-несмотря на то,что не привели ни одного особенно хорошего варианта использования.</target>
        </trans-unit>
        <trans-unit id="eb2327b341cffc04d124fdbbf7357dcf2a6b1dc4" translate="yes" xml:space="preserve">
          <source>So it's a kind of a frozen function that the generator is hanging onto.</source>
          <target state="translated">Так что это своего рода замороженная функция,за которую держится генератор.</target>
        </trans-unit>
        <trans-unit id="19673e758686be33a34cf32a2f95654be99c541b" translate="yes" xml:space="preserve">
          <source>So that's the iterator protocol, many objects implement this protocol:</source>
          <target state="translated">Итак,это протокол итератора,многие объекты реализуют этот протокол:</target>
        </trans-unit>
        <trans-unit id="9bd6893f306954b22b5c6d426e694f0b79db960f" translate="yes" xml:space="preserve">
          <source>So the generator object is sort of like an adapter - at one end it exhibits the iterator protocol, by exposing &lt;code&gt;__iter__()&lt;/code&gt; and &lt;code&gt;next()&lt;/code&gt; methods to keep the &lt;code&gt;for&lt;/code&gt; loop happy. At the other end, however, it runs the function just enough to get the next value out of it, and puts it back in suspended mode.</source>
          <target state="translated">Таким образом, объект генератора подобен адаптеру - на одном конце он демонстрирует протокол итератора, предоставляя &lt;code&gt;__iter__()&lt;/code&gt; и &lt;code&gt;next()&lt;/code&gt; чтобы цикл &lt;code&gt;for&lt;/code&gt; был доволен. На другом конце, однако, он запускает функцию, достаточную для того, чтобы получить из нее следующее значение, и переводит ее обратно в режим ожидания.</target>
        </trans-unit>
        <trans-unit id="0846a1b0282a9b40bd6407dbf79fde868f3d33b4" translate="yes" xml:space="preserve">
          <source>So, how do you generate these values? This can either be done directly by using the built-in function &lt;code&gt;next&lt;/code&gt;, or, indirectly by feeding it to a construct that consumes values.</source>
          <target state="translated">Итак, как вы генерируете эти значения? Это можно сделать либо напрямую, используя &lt;code&gt;next&lt;/code&gt; встроенную функцию, либо косвенно, передав ее в конструкцию, которая потребляет значения.</target>
        </trans-unit>
        <trans-unit id="5a9e453ff9384952ce4f468ed81ccbae376c01b4" translate="yes" xml:space="preserve">
          <source>Sometime later, I tell you, &quot;OK, get ready to tell me the sequence of numbers&quot;.</source>
          <target state="translated">Через некоторое время,я говорю тебе:&quot;Хорошо,приготовься сказать мне последовательность чисел&quot;.</target>
        </trans-unit>
        <trans-unit id="f19056e03502445791c22a8e19229c5e20a55381" translate="yes" xml:space="preserve">
          <source>SyntaxError in 3.8</source>
          <target state="translated">Синтаксическая ошибка в 3.8</target>
        </trans-unit>
        <trans-unit id="567e7ba961e72df760eb88d4a21163100151b70e" translate="yes" xml:space="preserve">
          <source>SyntaxWarning or DeprecationWarning in 3.7</source>
          <target state="translated">Предупреждение о синтаксисе или ослабленииПредупреждение о синтаксисе в 3.7</target>
        </trans-unit>
        <trans-unit id="9ab0a0362c832896068559a5fa49081174de2ddf" translate="yes" xml:space="preserve">
          <source>That is, it will run the code in your function from the beginning until it hits &lt;code&gt;yield&lt;/code&gt;. Then, it&amp;rsquo;ll return the first value of the loop.</source>
          <target state="translated">То есть он будет запускать код в вашей функции с самого начала, пока не достигнет &lt;code&gt;yield&lt;/code&gt; . Затем он вернет первое значение цикла.</target>
        </trans-unit>
        <trans-unit id="838208781647d2859f5be9f1f69a5eae0736b9bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;close&lt;/code&gt; method raises &lt;code&gt;GeneratorExit&lt;/code&gt; at the point the function 
execution was frozen. This will also be called by &lt;code&gt;__del__&lt;/code&gt; so you 
can put any cleanup code where you handle the &lt;code&gt;GeneratorExit&lt;/code&gt;:</source>
          <target state="translated">Метод &lt;code&gt;close&lt;/code&gt; вызывает &lt;code&gt;GeneratorExit&lt;/code&gt; в тот момент, когда выполнение функции было заморожено. Это также будет вызываться &lt;code&gt;__del__&lt;/code&gt; , так что вы можете поместить любой код очистки, где вы обрабатываете &lt;code&gt;GeneratorExit&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a3d45fcf0497296d8e1482b4554df59b5eedf048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extend()&lt;/code&gt; method is a list object method that expects an iterable and adds its values to the list.</source>
          <target state="translated">Метод &lt;code&gt;extend()&lt;/code&gt; - это метод объекта списка, который ожидает итерацию и добавляет ее значения в список.</target>
        </trans-unit>
        <trans-unit id="29609fb0ada2ba2818fb2a90a695577b51e87c1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gi_code&lt;/code&gt; and &lt;code&gt;gi_frame&lt;/code&gt; fields are where the frozen state is stored. Exploring them with &lt;code&gt;dir(..)&lt;/code&gt;, we can confirm that our mental model above is credible.</source>
          <target state="translated">В &lt;code&gt;gi_code&lt;/code&gt; и &lt;code&gt;gi_frame&lt;/code&gt; хранится замороженное состояние. Изучая их с помощью &lt;code&gt;dir(..)&lt;/code&gt; , мы можем подтвердить, что наша ментальная модель выше заслуживает доверия.</target>
        </trans-unit>
        <trans-unit id="d96f54e7ea72522d78f3384a3336d7ad5556bc22" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;return&lt;/code&gt; statement in a generator</source>
          <target state="translated">Оператор &lt;code&gt;return&lt;/code&gt; в генераторе</target>
        </trans-unit>
        <trans-unit id="77154ad361e61b0b0ba81607182893014c0d1a34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; keyword is reduced to two simple facts:</source>
          <target state="translated">Ключевое слово &lt;code&gt;yield&lt;/code&gt; сводится к двум простым фактам:</target>
        </trans-unit>
        <trans-unit id="dc5a0f0208c180c85b5d0c4f32b9d8172d5659ac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; keyword simply collects returning results. Think of &lt;code&gt;yield&lt;/code&gt; like &lt;code&gt;return +=&lt;/code&gt;</source>
          <target state="translated">Ключевое слово &lt;code&gt;yield&lt;/code&gt; просто собирает возвращаемые результаты. Думайте о &lt;code&gt;yield&lt;/code&gt; как о &lt;code&gt;return +=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="569b8a7334a018ddbbd0be69dd1861bc7484befb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; statement in Python returns a generator. A generator in Python is a function that returns</source>
          <target state="translated">Оператор &lt;code&gt;yield&lt;/code&gt; в Python возвращает генератор. Генератор в Python - это функция, которая возвращает</target>
        </trans-unit>
        <trans-unit id="286c50d08b635ef15bfeee9cc3db60c93c6ad474" translate="yes" xml:space="preserve">
          <source>The CPython core developers are &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2017-January/147301.html&quot;&gt;discussing deprecating its allowance&lt;/a&gt;.
Here's a relevant post from the mailing list:</source>
          <target state="translated">Разработчики ядра CPython &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2017-January/147301.html&quot;&gt;обсуждают отказ от его разрешения&lt;/a&gt; . Вот соответствующий пост из списка рассылки:</target>
        </trans-unit>
        <trans-unit id="4e3fe55c48ec33c0b2a6787983638ea6d62f5711" translate="yes" xml:space="preserve">
          <source>The OO approach, we wrap the metadata &lt;code&gt;as a class&lt;/code&gt;. This is the so-called &lt;code&gt;iterator&lt;/code&gt; who implements the iterator protocol (i.e. the &lt;code&gt;__next__()&lt;/code&gt;, and &lt;code&gt;__iter__()&lt;/code&gt; methods). This is also the commonly seen &lt;a href=&quot;https://en.wikipedia.org/wiki/Iterator_pattern#Python&quot;&gt;iterator design pattern&lt;/a&gt;.</source>
          <target state="translated">Подход OO, мы &lt;code&gt;as a class&lt;/code&gt; метаданные в класс . Это так называемый &lt;code&gt;iterator&lt;/code&gt; который реализует протокол итератора (то есть &lt;code&gt;__next__()&lt;/code&gt; и &lt;code&gt;__iter__()&lt;/code&gt; ). Это также часто встречающийся &lt;a href=&quot;https://en.wikipedia.org/wiki/Iterator_pattern#Python&quot;&gt;шаблон проектирования итераторов&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b36d36ae5461cd703d79e055f55c9ebb36c41eab" translate="yes" xml:space="preserve">
          <source>The above example can be thought of as merely creating a list which you append to and return:</source>
          <target state="translated">Приведенный выше пример можно рассматривать как простое создание списка,к которому вы добавляете и который возвращаете:</target>
        </trans-unit>
        <trans-unit id="384fee2b6ad3d7469cdf79c4d54b9d63ea5ae224" translate="yes" xml:space="preserve">
          <source>The above simple generator is also equivalent to the below - as of Python 3.3 (and not available in Python 2), you can use &lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/&quot;&gt;&lt;code&gt;yield from&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Приведенный выше простой генератор также эквивалентен приведенному ниже - &lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/&quot;&gt; &lt;code&gt;yield from&lt;/code&gt; &lt;/a&gt; Python 3.3 (и недоступен в Python 2), вы можете использовать yield из :</target>
        </trans-unit>
        <trans-unit id="e62f3d84017118479b990b0d86c245c11aa0d847" translate="yes" xml:space="preserve">
          <source>The built-in function &lt;code&gt;next()&lt;/code&gt; just calls the objects &lt;code&gt;.next()&lt;/code&gt; function, which is a part of the &quot;iteration protocol&quot; and is found on all iterators. You can manually use the &lt;code&gt;next()&lt;/code&gt; function (and other parts of the iteration protocol) to implement fancy things, usually at the expense of readability, so try to avoid doing that...</source>
          <target state="translated">Встроенная функция &lt;code&gt;next()&lt;/code&gt; просто вызывает &lt;code&gt;.next()&lt;/code&gt; objects .next () , которая является частью &amp;laquo;протокола итерации&amp;raquo; и встречается на всех итераторах. Вы можете вручную использовать функцию &lt;code&gt;next()&lt;/code&gt; (и другие части протокола итерации) для реализации необычных вещей, обычно за счет читабельности, поэтому постарайтесь не делать этого ...</target>
        </trans-unit>
        <trans-unit id="7de99b1c48ee10b1bddb666e63ca36fa1bf9d357" translate="yes" xml:space="preserve">
          <source>The difference between a list &lt;code&gt;return&lt;/code&gt; outputs and the object &lt;code&gt;yield&lt;/code&gt; output is:</source>
          <target state="translated">Разница между выходными данными списка и выходными данными объекта:</target>
        </trans-unit>
        <trans-unit id="bb49489746a020a2dc0a0d8886122c8ac1c8272f" translate="yes" xml:space="preserve">
          <source>The execution control will be transferred from getNextLines() to the &lt;code&gt;for&lt;/code&gt; loop when yield is executed. Thus, every time getNextLines() is invoked, execution begins from the point where it was paused last time.</source>
          <target state="translated">Управление выполнением будет передано из getNextLines () в цикл &lt;code&gt;for&lt;/code&gt; при выполнении yield. Таким образом, каждый раз, когда вызывается getNextLines (), выполнение начинается с того места, где оно было приостановлено в последний раз.</target>
        </trans-unit>
        <trans-unit id="9574ade792214860025139f4da109ddb0dd74095" translate="yes" xml:space="preserve">
          <source>The first time the &lt;code&gt;for&lt;/code&gt; calls the generator object created from your function, it will run the code in your function from the beginning until it hits &lt;code&gt;yield&lt;/code&gt;, then it'll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting &lt;code&gt;yield&lt;/code&gt;. That can be because the loop has come to an end, or because you no longer satisfy an &lt;code&gt;&quot;if/else&quot;&lt;/code&gt;.</source>
          <target state="translated">При первом вызове &lt;code&gt;for&lt;/code&gt; вызывает объект генератора, созданный из вашей функции, он будет запускать код вашей функции с самого начала, пока не достигнет &lt;code&gt;yield&lt;/code&gt; , а затем вернет первое значение цикла. Затем при каждом последующем вызове выполняется другая итерация цикла, который вы написали в функции, и возвращается следующее значение. Это будет продолжаться до тех пор, пока генератор не будет считаться пустым, что происходит, когда функция запускается без нажатия на &lt;code&gt;yield&lt;/code&gt; . Это может быть из-за того, что цикл подошел к концу или из-за того, что вы больше не удовлетворяете &lt;code&gt;&quot;if/else&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55b6d1db997b3f1403e7e44c2927b50a091ed779" translate="yes" xml:space="preserve">
          <source>The functional approach, we wrap the metadata &lt;code&gt;as a function&lt;/code&gt;. This is
the so-called &lt;code&gt;generator function&lt;/code&gt;. But under the hood, the returned &lt;code&gt;generator object&lt;/code&gt; still &lt;code&gt;IS-A&lt;/code&gt; iterator because it also implements the iterator protocol.</source>
          <target state="translated">Функциональный подход, мы оборачиваем метаданные &lt;code&gt;as a function&lt;/code&gt; . Это так называемая &lt;code&gt;generator function&lt;/code&gt; . Но под капотом возвращенный &lt;code&gt;generator object&lt;/code&gt; все еще является итератором &lt;code&gt;IS-A&lt;/code&gt; , поскольку он также реализует протокол итератора.</target>
        </trans-unit>
        <trans-unit id="ad5e73ec25fc40ac5fd2ca20c474cd6986e30ab3" translate="yes" xml:space="preserve">
          <source>The generator remembers it was paused at &lt;code&gt;yield value&lt;/code&gt; and resumes from there. The next message is printed and the search for the &lt;code&gt;yield&lt;/code&gt; statement to pause at it performed again (due to the &lt;code&gt;while&lt;/code&gt; loop).</source>
          <target state="translated">Генератор запоминает, что он был приостановлен на уровне &lt;code&gt;yield value&lt;/code&gt; и возобновляет оттуда. Следующее сообщение печатается, и поиск оператора &lt;code&gt;yield&lt;/code&gt; для приостановки выполняется снова (из-за цикла while).</target>
        </trans-unit>
        <trans-unit id="956ec5707ad9efc1beeb86871d9e095c1cace192" translate="yes" xml:space="preserve">
          <source>The generator type is a sub-type of iterator:</source>
          <target state="translated">Тип генератора является подтипом итератора:</target>
        </trans-unit>
        <trans-unit id="89f016e32a8da16e8af307b674da7c0f4716f8a7" translate="yes" xml:space="preserve">
          <source>The grammar currently allows any expression in a list comprehension.</source>
          <target state="translated">Грамматика в настоящее время позволяет любое выражение в понимании списка.</target>
        </trans-unit>
        <trans-unit id="edf75537a05166775dfd15ba5c8a40896c6f403e" translate="yes" xml:space="preserve">
          <source>The idea for generators comes from other languages (see footnote 1) with varying implementations. In Python's Generators, the execution of the code is &lt;a href=&quot;https://docs.python.org/3.5/glossary.html#term-generator-iterator&quot;&gt;frozen&lt;/a&gt; at the point of the yield. When the generator is called (methods are discussed below) execution resumes and then freezes at the next yield.</source>
          <target state="translated">Идея для генераторов исходит из других языков (см. Сноску 1) с различными реализациями. В генераторах Python выполнение кода &lt;a href=&quot;https://docs.python.org/3.5/glossary.html#term-generator-iterator&quot;&gt;заморожено&lt;/a&gt; в точке выхода. Когда вызывается генератор (методы обсуждаются ниже), выполнение возобновляется, а затем останавливается при следующем выходе.</target>
        </trans-unit>
        <trans-unit id="305c568102291c5cb1ca7281807fa2c9a3b573fc" translate="yes" xml:space="preserve">
          <source>The itertools module contains special functions to manipulate iterables. Ever wish to duplicate a generator?
Chain two generators? Group values in a nested list with a one-liner? &lt;code&gt;Map / Zip&lt;/code&gt; without creating another list?</source>
          <target state="translated">Модуль itertools содержит специальные функции для управления итерациями. Вы когда-нибудь хотели дублировать генератор? Цепочка двух генераторов? Группировать значения во вложенном списке с одной линией? &lt;code&gt;Map / Zip&lt;/code&gt; без создания другого списка?</target>
        </trans-unit>
        <trans-unit id="6f58a19a2dd95bc1b3cbfc74f010f82f5559c58c" translate="yes" xml:space="preserve">
          <source>The key idea is that the compiler/interpreter/whatever does some trickery so that as far as the caller is concerned, they can keep calling next() and it will keep returning values - &lt;em&gt;as if the generator method was paused&lt;/em&gt;. Now obviously you can't really &quot;pause&quot; a method, so the compiler builds a state machine for you to remember where you currently are and what the local variables etc look like. This is much easier than writing an iterator yourself.</source>
          <target state="translated">Ключевая идея заключается в том, что компилятор / интерпретатор / что-либо делает какую-то хитрость, чтобы, что касается вызывающего, они могли продолжать вызывать next (), и он продолжит возвращать значения - &lt;em&gt;как если бы метод генератора был приостановлен&lt;/em&gt; . Теперь, очевидно, вы не можете &amp;laquo;приостановить&amp;raquo; метод, поэтому компилятор создает конечный автомат, чтобы вы помнили, где вы сейчас находитесь и как выглядят локальные переменные и т. Д. Это гораздо проще, чем написать итератор самостоятельно.</target>
        </trans-unit>
        <trans-unit id="92d79cb061c23c0b97be5b3c6bcac7a9343bbb0e" translate="yes" xml:space="preserve">
          <source>The loop iterates on a list, but the list expands while the loop is being iterated :-) It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, &lt;code&gt;candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))&lt;/code&gt; exhaust all the values of the generator, but &lt;code&gt;while&lt;/code&gt; keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node.</source>
          <target state="translated">Цикл повторяется в списке, но список расширяется во время итерации цикла :-) Это краткий способ пройти через все эти вложенные данные, даже если это немного опасно, так как вы можете получить бесконечный цикл. В этом случае &lt;code&gt;candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))&lt;/code&gt; исчерпывает все значения генератора, но &lt;code&gt;while&lt;/code&gt; продолжает создавать новые объекты генератора, которые будут генерировать значения, отличные от предыдущих, поскольку он не применяется к одному и тому же узел.</target>
        </trans-unit>
        <trans-unit id="fa326100d98f456e392b2f2fad538e2c0e77b226" translate="yes" xml:space="preserve">
          <source>The most famous user of the iterator protocol is the &lt;code&gt;for&lt;/code&gt; command in Python. So, whenever you do a:</source>
          <target state="translated">Самым известным пользователем протокола итератора является команда &lt;code&gt;for&lt;/code&gt; в Python. Итак, всякий раз, когда вы делаете:</target>
        </trans-unit>
        <trans-unit id="db347df1c70b1f578850ca66fe264ef9284adcde" translate="yes" xml:space="preserve">
          <source>The new syntax also opens up some opportunities for optimisation when one generator re-yields values produced by another.</source>
          <target state="translated">Новый синтаксис также открывает некоторые возможности для оптимизации,когда один генератор повторно генерирует значения,генерируемые другим.</target>
        </trans-unit>
        <trans-unit id="b74ff8ee45b0b8f3cea227a5cb8b0ca2512e0fa1" translate="yes" xml:space="preserve">
          <source>The output is:</source>
          <target state="translated">Выход:</target>
        </trans-unit>
        <trans-unit id="65c10c8b7349834a5510a50665946231ee354c64" translate="yes" xml:space="preserve">
          <source>The power comes from using the generator with a loop that calculates a sequence, the generator executes the loop stopping each time to 'yield' the next result of the calculation, in this way it calculates a list on the fly, the benefit being the memory saved for especially large calculations</source>
          <target state="translated">Энергия поступает от использования генератора с циклом,который вычисляет последовательность,генератор выполняет остановку цикла каждый раз,чтобы &quot;дать&quot; следующий результат вычисления,таким образом,он вычисляет список на лету,преимуществом является память,сохраненная для особенно больших вычислений</target>
        </trans-unit>
        <trans-unit id="fc99ade7c7b098191b4ad77e911e56c56415f9b0" translate="yes" xml:space="preserve">
          <source>The rest of this post will, without loss of generality, conceptualize continuations as CPS, because it is a hell of a lot easier to understand and read.</source>
          <target state="translated">Остальная часть этого поста будет,без потери обобщения,концептуализировать продолжения как CPS,потому что это чертовски легко понять и прочитать.</target>
        </trans-unit>
        <trans-unit id="a8c92b7c9011965f168156df7f932f40277a20fa" translate="yes" xml:space="preserve">
          <source>The truth is Python performs the above two steps anytime it wants to &lt;em&gt;loop over&lt;/em&gt; the contents of an object - so it could be a for loop, but it could also be code like &lt;code&gt;otherlist.extend(mylist)&lt;/code&gt; (where &lt;code&gt;otherlist&lt;/code&gt; is a Python list).</source>
          <target state="translated">Правда в том, что Python выполняет вышеупомянутые два шага в любое время, когда он хочет &lt;em&gt;перебрать&lt;/em&gt; содержимое объекта - так что это может быть цикл for, но это также может быть код, подобный &lt;code&gt;otherlist.extend(mylist)&lt;/code&gt; (где &lt;code&gt;otherlist&lt;/code&gt; - это список Python) ,</target>
        </trans-unit>
        <trans-unit id="02672c2bae3577e3b6b8642a622474b7f6f3b750" translate="yes" xml:space="preserve">
          <source>The unquoted results are what's printed. The quoted result is what is returned from &lt;code&gt;yield&lt;/code&gt;. Call &lt;code&gt;next&lt;/code&gt; again now:</source>
          <target state="translated">Результаты без кавычек - то, что напечатано. Указанный результат - это то, что возвращается из &lt;code&gt;yield&lt;/code&gt; . Звоните &lt;code&gt;next&lt;/code&gt; снова сейчас:</target>
        </trans-unit>
        <trans-unit id="b738047d593c9d45f3f7f40a6e4eb41f8b25d5d8" translate="yes" xml:space="preserve">
          <source>Then I can use it in other code like this:</source>
          <target state="translated">Тогда я смогу использовать его в другом коде,как этот:</target>
        </trans-unit>
        <trans-unit id="22b87c58846e1f25413204d0a0b8a1d8ed0faa70" translate="yes" xml:space="preserve">
          <source>Then just &lt;code&gt;import itertools&lt;/code&gt;.</source>
          <target state="translated">Тогда просто &lt;code&gt;import itertools&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68d7286f8dc4f85d70f3ddd2982d475286c52f12" translate="yes" xml:space="preserve">
          <source>Then, every other call will run the loop you have written in the function one more time, returning the next value until there isn't any value to return.</source>
          <target state="translated">Затем при каждом следующем вызове еще раз будет выполняться написанный в функции цикл,возвращающий следующее значение до тех пор,пока не будет возвращено ни одного значения.</target>
        </trans-unit>
        <trans-unit id="3bb53270d0d4b4b1c8ffaa313d2acf3c3c850136" translate="yes" xml:space="preserve">
          <source>Then, your code will continue from where it left off each time &lt;code&gt;for&lt;/code&gt; uses the generator.</source>
          <target state="translated">Затем ваш код будет продолжаться с того места, где он остановился каждый раз, &lt;code&gt;for&lt;/code&gt; использует генератор.</target>
        </trans-unit>
        <trans-unit id="959039a43531d3c4457a69589ed899271db1489a" translate="yes" xml:space="preserve">
          <source>There are 2 approaches to wrap such metadata.</source>
          <target state="translated">Существует 2 подхода к обёртыванию таких метаданных.</target>
        </trans-unit>
        <trans-unit id="1e019b6ab061a03c5c91f64a23063b53844dc5f0" translate="yes" xml:space="preserve">
          <source>There are lots of ways to implement this computation. I used mutation, but it is easy to do it without mutation, by returning the current value and the next yielder.</source>
          <target state="translated">Существует множество способов реализации этих вычислений.Я использовал мутацию,но это легко сделать без мутации,вернув текущее значение и следующий доходчик.</target>
        </trans-unit>
        <trans-unit id="2d7b67871d58c1c22337093d7853eafa16e73e0b" translate="yes" xml:space="preserve">
          <source>There comes &lt;code&gt;yield&lt;/code&gt;</source>
          <target state="translated">Там приходит &lt;code&gt;yield&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b0a32cb8e02d7bb4ce6cf72881e646c325fc9731" translate="yes" xml:space="preserve">
          <source>There is another &lt;code&gt;yield&lt;/code&gt; use and meaning (since Python 3.3):</source>
          <target state="translated">Существует еще одно использование и значение &lt;code&gt;yield&lt;/code&gt; (начиная с Python 3.3):</target>
        </trans-unit>
        <trans-unit id="3efe40491ef4b5d01abc9316e30e10c965a4a4c9" translate="yes" xml:space="preserve">
          <source>There is more about it in this article about &lt;a href=&quot;http://effbot.org/zone/python-for-statement.htm&quot;&gt;how &lt;code&gt;for&lt;/code&gt; loops work&lt;/a&gt;.</source>
          <target state="translated">В этой статье рассказывается больше о &lt;a href=&quot;http://effbot.org/zone/python-for-statement.htm&quot;&gt;том, как работают циклы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f47398ac35d029b6377a0b4ddaede2532b3994a" translate="yes" xml:space="preserve">
          <source>There is one major difference, though; see the last section.</source>
          <target state="translated">Однако есть одно существенное различие;см.последний раздел.</target>
        </trans-unit>
        <trans-unit id="dfe628b44e21e48a9a1638275ee2cab7d93e4a99" translate="yes" xml:space="preserve">
          <source>There is one type of answer that I don't feel has been given yet, among the many great answers that describe how to use generators. Here is the programming language theory answer:</source>
          <target state="translated">Есть один тип ответа,который,как мне кажется,еще не был дан,среди множества прекрасных ответов,которые описывают,как использовать генераторы.Вот ответ из теории языка программирования:</target>
        </trans-unit>
        <trans-unit id="869f60d5d93fd508128a38611098256c7978879c" translate="yes" xml:space="preserve">
          <source>There's one extra thing to mention: a function that yields doesn't actually have to terminate. I've written code like this:</source>
          <target state="translated">Есть еще одна вещь,о которой следует упомянуть:функция,которая дает урожай,на самом деле не должна заканчиваться.Я написал такой код:</target>
        </trans-unit>
        <trans-unit id="761653d5f6ddfd0071e0c9f8287f586c348d08cd" translate="yes" xml:space="preserve">
          <source>These iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.</source>
          <target state="translated">Эти итерабельные таблицы удобны,потому что вы можете читать их сколько угодно,но вы храните все значения в памяти,и это не всегда то,что вы хотите,когда у вас много значений.</target>
        </trans-unit>
        <trans-unit id="847e29854b26173ea7127ee888f4830e76ab29e1" translate="yes" xml:space="preserve">
          <source>Think of it this way:</source>
          <target state="translated">Подумай об этом так:</target>
        </trans-unit>
        <trans-unit id="ccd34f995b2f074874396138bbe200b9f454f73e" translate="yes" xml:space="preserve">
          <source>This code actually loops over that array twice! :(</source>
          <target state="translated">Этот код на самом деле дважды зацикливается на этом массиве! :((</target>
        </trans-unit>
        <trans-unit id="8d161d7ff1bebc685509da31091434ec70757135" translate="yes" xml:space="preserve">
          <source>This code contains several smart parts:</source>
          <target state="translated">Этот код содержит несколько умных частей:</target>
        </trans-unit>
        <trans-unit id="95d467a037a72f1d404c008c65683f34bbcb709d" translate="yes" xml:space="preserve">
          <source>This is basically what the Python interpreter does with the above code:</source>
          <target state="translated">В основном это то,что интерпретатор Python делает с приведённым выше кодом:</target>
        </trans-unit>
        <trans-unit id="ea2ea6265215d15078974a1d7665827ca856c901" translate="yes" xml:space="preserve">
          <source>This is because the presence of &lt;code&gt;yield&lt;/code&gt; signaled to Python that you want to create a &lt;em&gt;generator&lt;/em&gt;, that is, an object that generates values on demand.</source>
          <target state="translated">Это связано с тем, что наличие &lt;code&gt;yield&lt;/code&gt; сообщает Python, что вы хотите создать &lt;em&gt;генератор&lt;/em&gt; , то есть объект, который генерирует значения по требованию.</target>
        </trans-unit>
        <trans-unit id="54444ced92aaabea39a670c4bad4931fb55ea203" translate="yes" xml:space="preserve">
          <source>This is clearly a reasonable iterable whose behavior is well defined -- each time the generator iterates over it, it returns 4 (and does so forever). But it isn't probably the prototypical type of iterable that comes to mind when thinking of iterators (i.e., &lt;code&gt;for x in collection: do_something(x)&lt;/code&gt;). This example illustrates the power of generators: if anything is an iterator, a generator can save the state of its iteration.</source>
          <target state="translated">Это явно разумная итерация, поведение которой четко определено - каждый раз, когда генератор повторяет ее, он возвращает 4 (и делает это всегда). Но это, вероятно, не тип прототипа итерируемого, который приходит на ум, когда мы думаем об итераторах (то есть &lt;code&gt;for x in collection: do_something(x)&lt;/code&gt; ). Этот пример иллюстрирует мощь генераторов: если что-то является итератором, генератор может сохранить состояние своей итерации.</target>
        </trans-unit>
        <trans-unit id="6b729e4e5167e0f6ea0ad29b09ff6d8212c4d8e9" translate="yes" xml:space="preserve">
          <source>This is how the &quot;Python iteration protocol&quot; works. That is, what is going on when you do &lt;code&gt;list(makeRange(5))&lt;/code&gt;. This is what I describe earlier as a &quot;lazy, incremental list&quot;.</source>
          <target state="translated">Вот как работает &amp;laquo;Протокол итерации Python&amp;raquo;. То есть то, что происходит, когда вы делаете &lt;code&gt;list(makeRange(5))&lt;/code&gt; . Это то, что я описываю ранее как &amp;laquo;ленивый, добавочный список&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d3493820819de86b02fd63f645e29ae4e0b50631" translate="yes" xml:space="preserve">
          <source>This is the most simple use case of generators. As you said, it can be used to write efficient permutations, using yield to push things up through the call stack instead of using some sort of stack variable. Generators can also be used for specialized tree traversal, and all manner of other things.</source>
          <target state="translated">Это самый простой случай использования генераторов.Как Вы сказали,его можно использовать для записи эффективных перестановок,используя доходность для проталкивания вещей вверх через стек вызовов,вместо того,чтобы использовать какую-то переменную стека.Генераторы также могут быть использованы для специализированного обхода дерева,и всевозможных других вещей.</target>
        </trans-unit>
        <trans-unit id="f172eb1953bc01c27cabdd6f9c836e9c3d1d5872" translate="yes" xml:space="preserve">
          <source>This is what a generator does (a function that contains a &lt;code&gt;yield&lt;/code&gt;); it starts executing, pauses whenever it does a &lt;code&gt;yield&lt;/code&gt;, and when asked for a &lt;code&gt;.next()&lt;/code&gt; value it continues from the point it was last. It fits perfectly by design with the iterator protocol of Python, which describes how to sequentially request values.</source>
          <target state="translated">Это то, что делает генератор (функция, которая содержит &lt;code&gt;yield&lt;/code&gt; ); он начинает выполнение, делает паузу всякий раз, когда производит &lt;code&gt;yield&lt;/code&gt; , а когда его запрашивают значение &lt;code&gt;.next()&lt;/code&gt; он продолжает с того места, где он был последним. По замыслу он идеально сочетается с протоколом итератора Python, который описывает, как последовательно запрашивать значения.</target>
        </trans-unit>
        <trans-unit id="c64469b38e358bb60db655f2f7dead53a870f525" translate="yes" xml:space="preserve">
          <source>This trick may give you an idea of the logic behind the function, but what actually happens with &lt;code&gt;yield&lt;/code&gt; is significantly different than what happens in the list based approach. In many cases, the yield approach will be a lot more memory efficient and faster too. In other cases, this trick will get you stuck in an infinite loop, even though the original function works just fine. Read on to learn more...</source>
          <target state="translated">Этот прием может дать вам представление о логике функции, но то, что на самом деле происходит с &lt;code&gt;yield&lt;/code&gt; , значительно отличается от того, что происходит в подходе на основе списка. Во многих случаях подход с выходом будет намного более эффективным и быстрее. В других случаях этот трюк застрянет в бесконечном цикле, даже если оригинальная функция работает просто отлично. Читайте дальше, чтобы узнать больше...</target>
        </trans-unit>
        <trans-unit id="fe901acdbaffa726773d1aa79c953022a37c87a8" translate="yes" xml:space="preserve">
          <source>This was my first &quot;aha&quot; moment with yield.</source>
          <target state="translated">Это был мой первый &quot;ага&quot; момент с уступчивостью.</target>
        </trans-unit>
        <trans-unit id="06ea075137bd0bbc68755225020ab2be38ff24de" translate="yes" xml:space="preserve">
          <source>Thus in short, a function with the following code</source>
          <target state="translated">Таким образом,вкратце,функция со следующим кодом</target>
        </trans-unit>
        <trans-unit id="5d4b050e5c318bdd9abdf7fc385ecbec5643af7f" translate="yes" xml:space="preserve">
          <source>Thus, in the unlikely event that you are failing to do something like this...</source>
          <target state="translated">Таким образом,в маловероятном случае,если ты не сможешь сделать что-то подобное...</target>
        </trans-unit>
        <trans-unit id="af7dabd9ee0abc1597b9509efda1778a58b95bbe" translate="yes" xml:space="preserve">
          <source>To force the generator to immediately return its pending values, you can pass it into &lt;code&gt;list()&lt;/code&gt; (just like you could any iterable):</source>
          <target state="translated">Чтобы заставить генератор немедленно возвращать ожидающие значения, вы можете передать его в &lt;code&gt;list()&lt;/code&gt; (так же, как и любой итеративный):</target>
        </trans-unit>
        <trans-unit id="c0114d7058a0e2d82c0d2df0bb48add203549c89" translate="yes" xml:space="preserve">
          <source>To get a better feel for generators, you can play around with the &lt;code&gt;itertools&lt;/code&gt; module (be sure to use &lt;code&gt;chain.from_iterable&lt;/code&gt; rather than &lt;code&gt;chain&lt;/code&gt; when warranted). For example, you might even use generators to implement infinitely-long lazy lists like &lt;code&gt;itertools.count()&lt;/code&gt;. You could implement your own &lt;code&gt;def enumerate(iterable): zip(count(), iterable)&lt;/code&gt;, or alternatively do so with the &lt;code&gt;yield&lt;/code&gt; keyword in a while-loop.</source>
          <target state="translated">Чтобы лучше понять генераторы, вы можете поиграться с модулем &lt;code&gt;itertools&lt;/code&gt; (обязательно используйте &lt;code&gt;chain.from_iterable&lt;/code&gt; , а не &lt;code&gt;chain&lt;/code&gt; при наличии гарантии). Например, вы можете даже использовать генераторы для реализации бесконечно длинных ленивых списков, таких как &lt;code&gt;itertools.count()&lt;/code&gt; . Вы можете реализовать свой собственный &lt;code&gt;def enumerate(iterable): zip(count(), iterable)&lt;/code&gt; , или, альтернативно, сделать это с помощью ключевого слова &lt;code&gt;yield&lt;/code&gt; в цикле while.</target>
        </trans-unit>
        <trans-unit id="47ee4ff7a14b54f8654a7b96763d1d5353cfb7c7" translate="yes" xml:space="preserve">
          <source>To help understand what a &lt;code&gt;yield&lt;/code&gt; does in the following code, you can use your finger to trace the cycle through any code that has a &lt;code&gt;yield&lt;/code&gt;.  Every time your finger hits the &lt;code&gt;yield&lt;/code&gt;, you have to wait for a &lt;code&gt;next&lt;/code&gt; or a &lt;code&gt;send&lt;/code&gt; to be entered.  When a &lt;code&gt;next&lt;/code&gt; is called, you trace through the code until you hit the &lt;code&gt;yield&lt;/code&gt;&amp;hellip; the code on the right of the &lt;code&gt;yield&lt;/code&gt; is evaluated and returned to the caller&amp;hellip; then you wait.  When &lt;code&gt;next&lt;/code&gt; is called again, you perform another loop through the code.  However, you'll note that in a coroutine, &lt;code&gt;yield&lt;/code&gt; can also be used with a &lt;code&gt;send&lt;/code&gt;&amp;hellip; which will send a value from the caller &lt;em&gt;into&lt;/em&gt; the yielding function. If a &lt;code&gt;send&lt;/code&gt; is given, then &lt;code&gt;yield&lt;/code&gt; receives the value sent, and spits it out the left hand side&amp;hellip; then the trace through the code progresses until you hit the &lt;code&gt;yield&lt;/code&gt; again (returning the value at the end, as if &lt;code&gt;next&lt;/code&gt; was called).</source>
          <target state="translated">Чтобы помочь понять, что делает &lt;code&gt;yield&lt;/code&gt; в следующем коде, вы можете использовать палец для отслеживания цикла по любому коду, который имеет &lt;code&gt;yield&lt;/code&gt; . Каждый раз, когда ваш палец достигает &lt;code&gt;yield&lt;/code&gt; , вы должны ждать &lt;code&gt;next&lt;/code&gt; или &lt;code&gt;send&lt;/code&gt; которые будут введены. Когда вызывается &lt;code&gt;next&lt;/code&gt; , вы прослеживаете код до тех пор, пока не достигнете &lt;code&gt;yield&lt;/code&gt; ... код справа от &lt;code&gt;yield&lt;/code&gt; оценивается и возвращается вызывающей стороне ... затем вы ждете. Когда &lt;code&gt;next&lt;/code&gt; вызывается снова, вы выполняете еще один цикл по коду. Однако вы заметите, что в сопрограмме &lt;code&gt;yield&lt;/code&gt; также может быть использован с &lt;code&gt;send&lt;/code&gt; ..., который отправит значение из вызывающей стороны &lt;em&gt;в&lt;/em&gt; функцию уступки. Если дано значение &lt;code&gt;send&lt;/code&gt; , то &lt;code&gt;yield&lt;/code&gt; возвращает полученное значение и выплевывает его на левую сторону ... затем трассировка в коде продолжается до тех пор, пока вы снова не дойдете до &lt;code&gt;yield&lt;/code&gt; (возвращая значение в конце, как если бы вызывался &lt;code&gt;next&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b2f6f90d2c166bfe4363d100db6a325bd8c53d50" translate="yes" xml:space="preserve">
          <source>To implement iterators, generators, and thread pools for concurrent execution, etc. as thunks (also called anonymous functions), one uses messages sent to a closure object, which has a dispatcher, and the dispatcher answers to &quot;messages&quot;.</source>
          <target state="translated">Для реализации итераторов,генераторов,пулов потоков для параллельного выполнения и т.д.в качестве элементов (также называемых анонимными функциями)используются сообщения,посылаемые объекту закрытия,в котором есть диспетчер,а диспетчер отвечает на &quot;сообщения&quot;.</target>
        </trans-unit>
        <trans-unit id="9115b0a8c20c76763e2640100aa35118070b6a7e" translate="yes" xml:space="preserve">
          <source>To master &lt;code&gt;yield&lt;/code&gt;, you must understand that &lt;strong&gt;when you call the function, the code you have written in the function body does not run.&lt;/strong&gt; The function only returns the generator object, this is a bit tricky :-)</source>
          <target state="translated">Чтобы справиться с &lt;code&gt;yield&lt;/code&gt; , вы должны понимать, что &lt;strong&gt;при вызове функции код, написанный в теле функции, не запускается.&lt;/strong&gt; Функция возвращает только объект генератора, это немного сложно :-)</target>
        </trans-unit>
        <trans-unit id="7b9662418d3af2db32eb7c9811a63029be459951" translate="yes" xml:space="preserve">
          <source>To reiterate: Continuations can save the state of a program's stack and generators can save the state of iteration. This means that continuations are more a lot powerful than generators, but also that generators are a lot, lot easier. They are easier for the language designer to implement, and they are easier for the programmer to use (if you have some time to burn, try to read and understand &lt;a href=&quot;http://www.madore.org/~david/computers/callcc.html&quot;&gt;this page about continuations and call/cc&lt;/a&gt;).</source>
          <target state="translated">Повторим: продолжения могут сохранять состояние стека программы, а генераторы могут сохранять состояние итерации. Это означает, что продолжения более мощные, чем генераторы, но также и то, что генераторы намного, намного проще. Их легче реализовать для языкового дизайнера, и их легче использовать программисту (если у вас есть время для записи, попробуйте прочитать и понять &lt;a href=&quot;http://www.madore.org/~david/computers/callcc.html&quot;&gt;эту страницу о продолжениях и вызвать / cc&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="855f35ae228f90d1d655b0f84b71dcd8c195b750" translate="yes" xml:space="preserve">
          <source>To understand what &lt;code&gt;yield&lt;/code&gt; does, you must understand what &lt;em&gt;generators&lt;/em&gt; are. And before you can understand generators, you must understand &lt;em&gt;iterables&lt;/em&gt;.</source>
          <target state="translated">Чтобы понять, что &lt;code&gt;yield&lt;/code&gt; , вы должны понимать, что такое &lt;em&gt;генераторы&lt;/em&gt; . И прежде чем вы сможете понять генераторы, вы должны понять &lt;em&gt;итерируемые&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3e68d29cff9fbdfeadc382da40caa5670dec8b66" translate="yes" xml:space="preserve">
          <source>Try to get a num_list with &lt;code&gt;return&lt;/code&gt;.</source>
          <target state="translated">Попробуйте получить num_list с &lt;code&gt;return&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eb3e1a1dbeab210622a6dce745b27ec3fd6ceec" translate="yes" xml:space="preserve">
          <source>Understanding the inner mechanisms of iteration</source>
          <target state="translated">Понимание внутренних механизмов итерации</target>
        </trans-unit>
        <trans-unit id="4965a83c485d39c529c9df84037bbc4eae475d84" translate="yes" xml:space="preserve">
          <source>User-defined classes that implement &lt;code&gt;__iter__()&lt;/code&gt;.</source>
          <target state="translated">Пользовательские классы, которые реализуют &lt;code&gt;__iter__()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68ac05f8fef6cd332ab57a59a59a7b6765c2f5ba" translate="yes" xml:space="preserve">
          <source>Uses the iterator to loop over items:</source>
          <target state="translated">Использует итератор для зацикливания элементов:</target>
        </trans-unit>
        <trans-unit id="9bbf05762b1e4da7eb5da4e2336f231ae41d9fab" translate="yes" xml:space="preserve">
          <source>Using the built-in &lt;code&gt;next()&lt;/code&gt; function, you directly invoke &lt;code&gt;.next&lt;/code&gt;/&lt;code&gt;__next__&lt;/code&gt;, forcing the generator to produce a value:</source>
          <target state="translated">Используя встроенную функцию &lt;code&gt;next()&lt;/code&gt; , вы напрямую вызываете &lt;code&gt;.next&lt;/code&gt; / &lt;code&gt;__next__&lt;/code&gt; , заставляя генератор вывести значение:</target>
        </trans-unit>
        <trans-unit id="bcee0bd785aa39b558b7c8bc31ae6f288f6986a3" translate="yes" xml:space="preserve">
          <source>Usually we pass a list to it:</source>
          <target state="translated">Обычно мы передаем ему список:</target>
        </trans-unit>
        <trans-unit id="3e5ea4b6c7fb3c82481552aaaf2cefbefc296023" translate="yes" xml:space="preserve">
          <source>Usually, you can write code that doesn't use generators but implements the same logic. One option is to use the temporary list 'trick' I mentioned before. That will not work in all cases, for e.g. if you have infinite loops, or it may make inefficient use of memory when you have a really long list. The other approach is to implement a new iterable class SomethingIter that keeps the state in instance members and performs the next logical step in it's next() (or &lt;strong&gt;next&lt;/strong&gt;() in Python 3) method. Depending on the logic, the code inside the next() method may end up looking very complex and be prone to bugs. Here generators provide a clean and easy solution.</source>
          <target state="translated">Обычно вы можете написать код, который не использует генераторы, но реализует ту же логику. Одним из вариантов является использование временного списка &amp;laquo;трюк&amp;raquo;, о котором я упоминал ранее. Это не будет работать во всех случаях, например, если у вас бесконечные циклы, или это может привести к неэффективному использованию памяти, когда у вас действительно длинный список. Другой подход заключается в реализации нового итерируемого класса SomethingIter, который сохраняет состояние в членах экземпляра и выполняет следующий логический шаг в своем методе next () (или &lt;strong&gt;next&lt;/strong&gt; () в Python 3). В зависимости от логики код внутри метода next () может выглядеть очень сложным и быть подверженным ошибкам. Здесь генераторы обеспечивают чистое и простое решение.</target>
        </trans-unit>
        <trans-unit id="b60b494a256a412f7ab8c496c30174516878d2d5" translate="yes" xml:space="preserve">
          <source>What does the “yield” keyword do</source>
          <target state="translated">Что делает ключевое слово &quot;yield&quot;</target>
        </trans-unit>
        <trans-unit id="8564153bf26487e9c47a7a365dd4a37cb1949c87" translate="yes" xml:space="preserve">
          <source>What happens when the method &lt;code&gt;_get_child_candidates&lt;/code&gt; is called?
Is a list returned? A single element? Is it called again? When will subsequent calls stop?</source>
          <target state="translated">Что происходит, когда &lt;code&gt;_get_child_candidates&lt;/code&gt; метод _get_child_candidates ? Список возвращен? Единственный элемент? Это называется снова? Когда прекратятся последующие звонки?</target>
        </trans-unit>
        <trans-unit id="1b4f84d352af15ddc950c1b08d4d361ed4f38885" translate="yes" xml:space="preserve">
          <source>What is the use of the &lt;code&gt;yield&lt;/code&gt; keyword in Python, and what does it do?</source>
          <target state="translated">Что такое ключевое слово &lt;code&gt;yield&lt;/code&gt; в Python и для чего оно нужно?</target>
        </trans-unit>
        <trans-unit id="a3a6372570b3576b2b5dd78ff44c4dd57682334c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;next()&lt;/code&gt; is called subsequently, it retrieves the function's belongings onto the stack and re-animates it. The function continues to compute from where it left off, oblivious to the fact that it had just spent an eternity in cold storage.</source>
          <target state="translated">Когда впоследствии вызывается &lt;code&gt;next()&lt;/code&gt; , он извлекает принадлежащие функции в стек и реанимирует их. Функция продолжает вычислять с того места, где она остановилась, не обращая внимания на тот факт, что она только что провела вечность в холодильной камере.</target>
        </trans-unit>
        <trans-unit id="0aca1dde96511b6083cb83899e9046f371ad1461" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;yield&lt;/code&gt; is used instead of a &lt;code&gt;return&lt;/code&gt; in a python function, that function is turned into something special called &lt;code&gt;generator function&lt;/code&gt;. That function will return an object of &lt;code&gt;generator&lt;/code&gt; type. &lt;strong&gt;The &lt;code&gt;yield&lt;/code&gt; keyword is a flag to notify the python compiler to treat such function specially.&lt;/strong&gt; Normal functions will terminate once some value is returned from it. But with the help of the compiler, the generator function &lt;strong&gt;can be thought of&lt;/strong&gt; as resumable. That is, the execution context will be restored and the execution will continue from last run. Until you explicitly call return, which will raise a &lt;code&gt;StopIteration&lt;/code&gt; exception (which is also part of the iterator protocol), or reach the end of the function. I found a lot of references about &lt;code&gt;generator&lt;/code&gt; but this &lt;a href=&quot;https://docs.python.org/dev/howto/functional.html#generators&quot;&gt;one&lt;/a&gt; from the &lt;code&gt;functional programming perspective&lt;/code&gt; is the most digestable.</source>
          <target state="translated">Когда &lt;code&gt;yield&lt;/code&gt; используется вместо &lt;code&gt;return&lt;/code&gt; в функции python, эта функция превращается в нечто особенное, называемое &lt;code&gt;generator function&lt;/code&gt; . Эта функция вернет объект типа &lt;code&gt;generator&lt;/code&gt; . &lt;strong&gt;Ключевое слово &lt;code&gt;yield&lt;/code&gt; - это флаг, который уведомляет компилятор python о специальной обработке такой функции.&lt;/strong&gt; Нормальные функции завершатся, когда из него будет возвращено некоторое значение. Но с помощью компилятора функцию генератора &lt;strong&gt;можно считать&lt;/strong&gt; возобновляемой. То есть контекст выполнения будет восстановлен, и выполнение будет продолжено с последнего запуска. Пока вы явно не &lt;code&gt;StopIteration&lt;/code&gt; return, что вызовет исключение StopIteration (которое также является частью протокола итератора), или не достигнет конца функции. Я нашел много ссылок на &lt;code&gt;generator&lt;/code&gt; но этот с &lt;code&gt;functional programming perspective&lt;/code&gt; является наиболее усваиваемым.</target>
        </trans-unit>
        <trans-unit id="b4956520f1ca1888af160527fdbeadaee79d2a28" translate="yes" xml:space="preserve">
          <source>When a normal function is called, it puts its local variables on the stack, does some computation, then clears the stack and returns. The values of its local variables are never seen again.</source>
          <target state="translated">Когда вызывается обычная функция,она помещает свои локальные переменные в стек,производит некоторые вычисления,затем очищает стек и возвращает.Значения ее локальных переменных больше никогда не видны.</target>
        </trans-unit>
        <trans-unit id="958c8511d450491ba26702ca0bd0c2811dde47aa" translate="yes" xml:space="preserve">
          <source>When we call the second function, it behaves very differently to the first. The &lt;code&gt;yield&lt;/code&gt; statement might be unreachable, but if it's present anywhere, it changes the nature of what we're dealing with.</source>
          <target state="translated">Когда мы вызываем вторую функцию, она ведет себя совершенно иначе, чем первая. Оператор &lt;code&gt;yield&lt;/code&gt; может быть недоступен, но если он присутствует где-либо, он меняет природу того, с чем мы имеем дело.</target>
        </trans-unit>
        <trans-unit id="550768170ef01550f901dfdde3779cde4dea9c6b" translate="yes" xml:space="preserve">
          <source>When you create a list, you can read its items one by one. Reading its items one by one is called iteration:</source>
          <target state="translated">Когда вы создаете список,вы можете читать его элементы по одному.Чтение его элементов по одному называется итерацией:</target>
        </trans-unit>
        <trans-unit id="3b7f697cea53ab4cee00328eb8586bf8e9cddc3b" translate="yes" xml:space="preserve">
          <source>When you enter this into your REPL and then try and call it, you'll get a mystifying result:</source>
          <target state="translated">Когда вы введете это в ваш REPL,а затем попробуете назвать его,вы получите мистифицирующий результат:</target>
        </trans-unit>
        <trans-unit id="0e20678b0bb4c25b8fa4c7b3b518c72e5245ebc8" translate="yes" xml:space="preserve">
          <source>When you first invoke &lt;code&gt;fib&lt;/code&gt; by calling it:</source>
          <target state="translated">Когда вы впервые вызываете &lt;code&gt;fib&lt;/code&gt; , вызывая его:</target>
        </trans-unit>
        <trans-unit id="b514c61a51b4ead83e3fa823a9f1c657b29464d0" translate="yes" xml:space="preserve">
          <source>When you request an iterator from a list, it creates a new iterator. However, when you request an iterator from an iterator (which you would rarely do), it just gives you a copy of itself.</source>
          <target state="translated">Когда вы запрашиваете итератор из списка,он создает новый итератор.Однако,когда вы запрашиваете итератор из списка (что вы делаете редко),он просто даёт вам копию самого себя.</target>
        </trans-unit>
        <trans-unit id="b7cc0f0bf3ed5fc052470ce219aa6f3e30a8013e" translate="yes" xml:space="preserve">
          <source>When you see a function with &lt;code&gt;yield&lt;/code&gt; statements, apply this easy trick to understand what will happen:</source>
          <target state="translated">Когда вы увидите функцию с операторами &lt;code&gt;yield&lt;/code&gt; , примените этот простой трюк, чтобы понять, что произойдет:</target>
        </trans-unit>
        <trans-unit id="2f6c491a0995ee077800eec24720b11c6e7f2988" translate="yes" xml:space="preserve">
          <source>When you then request it generates the first value, directly or indirectly, it executes all statements that it finds, until it encounters a &lt;code&gt;yield&lt;/code&gt;, it then yields back the value you supplied to &lt;code&gt;yield&lt;/code&gt; and pauses. For an example that better demonstrates this, let's use some &lt;code&gt;print&lt;/code&gt; calls (replace with &lt;code&gt;print &quot;text&quot;&lt;/code&gt; if on Python 2):</source>
          <target state="translated">Когда вы затем запрашиваете, он генерирует первое значение, прямо или косвенно, он выполняет все операторы, которые он находит, до тех пор, пока не встретит &lt;code&gt;yield&lt;/code&gt; , а затем возвращает значение, которое вы указали для &lt;code&gt;yield&lt;/code&gt; , и делает паузы. Для примера, который лучше демонстрирует это, давайте использовать некоторые вызовы &lt;code&gt;print&lt;/code&gt; (замените на &lt;code&gt;print &quot;text&quot;&lt;/code&gt; , если на Python 2):</target>
        </trans-unit>
        <trans-unit id="224be01d8e5c7c05d7fa83727c243ea08c1b6325" translate="yes" xml:space="preserve">
          <source>Whenever &lt;code&gt;yield&lt;/code&gt; is called, it tells the function to return a continuation.  When the function is called again, it starts from wherever it left off. So, in pseudo-pseudocode (i.e., not pseudocode, but not code) the generator's &lt;code&gt;next&lt;/code&gt; method is basically as follows:</source>
          <target state="translated">Каждый раз, когда вызывается &lt;code&gt;yield&lt;/code&gt; , он сообщает функции, что она должна возвращать продолжение. Когда функция вызывается снова, она начинается с того места, где она остановилась. Таким образом, в псевдопсевдокоде (т.е. не псевдокоде, а не коде) &lt;code&gt;next&lt;/code&gt; метод генератора в основном следующий:</target>
        </trans-unit>
        <trans-unit id="f26fb14b01ccba778163556c3df5281b63e8507c" translate="yes" xml:space="preserve">
          <source>Whenever you find yourself building a list from scratch, &lt;code&gt;yield&lt;/code&gt; each piece instead.</source>
          <target state="translated">Всякий раз, когда вы обнаруживаете, что строите список с нуля, используйте вместо этого каждый кусок.</target>
        </trans-unit>
        <trans-unit id="365379f34df99ca9b0a193c6b7d8ec4a2986c91d" translate="yes" xml:space="preserve">
          <source>While a lot of answers show why you'd use a &lt;code&gt;yield&lt;/code&gt; to create a generator, there are more uses for &lt;code&gt;yield&lt;/code&gt;.  It's quite easy to make a coroutine, which enables the passing of information between two blocks of code.  I won't repeat any of the fine examples that have already been given about using &lt;code&gt;yield&lt;/code&gt; to create a generator.</source>
          <target state="translated">Хотя многие ответы показывают, почему вы использовали бы &lt;code&gt;yield&lt;/code&gt; для создания генератора, есть и другие способы использования &lt;code&gt;yield&lt;/code&gt; . Сделать сопрограмму довольно просто, что позволяет передавать информацию между двумя блоками кода. Я не буду повторять ни одного из прекрасных примеров, которые уже были приведены об использовании &lt;code&gt;yield&lt;/code&gt; для создания генератора.</target>
        </trans-unit>
        <trans-unit id="08166f360bf5ae486bc24968f9bf3f260bd29d10" translate="yes" xml:space="preserve">
          <source>Why Use Generators?</source>
          <target state="translated">Зачем использовать генераторы?</target>
        </trans-unit>
        <trans-unit id="2bba704c3c5538921356a3f491c4600284327828" translate="yes" xml:space="preserve">
          <source>With a &lt;code&gt;yield&lt;/code&gt; function, when its code begins to run (i.e. after the function is called, returning a generator object, whose &lt;code&gt;next()&lt;/code&gt; method is then invoked), it similarly puts its local variables onto the stack and computes for a while. But then, when it hits the &lt;code&gt;yield&lt;/code&gt; statement, before clearing its part of the stack and returning, it takes a snapshot of its local variables and stores them in the generator object. It also writes down the place where it's currently up to in its code (i.e. the particular &lt;code&gt;yield&lt;/code&gt; statement).</source>
          <target state="translated">С помощью функции &lt;code&gt;yield&lt;/code&gt; , когда ее код начинает работать (т. Е. После вызова функции, возвращающей объект генератора, чей метод &lt;code&gt;next()&lt;/code&gt; затем вызывается), он аналогичным образом помещает свои локальные переменные в стек и вычисляет некоторое время. Но затем, когда он попадает в оператор &lt;code&gt;yield&lt;/code&gt; , прежде чем очистить свою часть стека и вернуться, он делает снимок своих локальных переменных и сохраняет их в объекте генератора. Он также записывает в своем коде место, где он находится в данный момент (т. Е. Конкретный оператор &lt;code&gt;yield&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8425e30a55cb65d01335e276892c145cda45d14d" translate="yes" xml:space="preserve">
          <source>Yay - no more &lt;code&gt;yield&lt;/code&gt; statements! Read and figure out code.</source>
          <target state="translated">Yay - больше никаких заявлений о доходах! Прочитайте и выясните код.</target>
        </trans-unit>
        <trans-unit id="33b0fd0f74faa27daf44c1c690d408e467aa0dd1" translate="yes" xml:space="preserve">
          <source>Yield</source>
          <target state="translated">Yield</target>
        </trans-unit>
        <trans-unit id="48f955098d7be7968cf5c16d1f085bb59f48b670" translate="yes" xml:space="preserve">
          <source>Yield gives you a generator.</source>
          <target state="translated">Уступка дает тебе генератор.</target>
        </trans-unit>
        <trans-unit id="cacdcd91fde152ba93b046096635f8dd9f810e6b" translate="yes" xml:space="preserve">
          <source>Yield is &lt;strong&gt;lazy&lt;/strong&gt;, it puts off computation. A function with a yield in it &lt;em&gt;doesn't actually execute at all when you call it.&lt;/em&gt; It returns an &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#yieldexpr&quot;&gt;iterator object&lt;/a&gt; that remembers where it left off. Each time you call &lt;code&gt;next()&lt;/code&gt; on the iterator (this happens in a for-loop) execution inches forward to the next yield. &lt;code&gt;return&lt;/code&gt; raises StopIteration and ends the series (this is the natural end of a for-loop).</source>
          <target state="translated">Выход &lt;strong&gt;ленивый&lt;/strong&gt; , он откладывает вычисления. Функция с выходом в нем &lt;em&gt;фактически не выполняется вообще, когда вы ее вызываете.&lt;/em&gt; Он возвращает &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#yieldexpr&quot;&gt;объект итератора,&lt;/a&gt; который запоминает, где он остановился. Каждый раз, когда вы вызываете &lt;code&gt;next()&lt;/code&gt; на итераторе (это происходит в цикле for), выполнение в дюймах вперед до следующего выхода. &lt;code&gt;return&lt;/code&gt; вызывает StopIteration и заканчивает серию (это естественный конец цикла for).</target>
        </trans-unit>
        <trans-unit id="ba1346186897dbbfeb506927791cbf680a8824df" translate="yes" xml:space="preserve">
          <source>Yield is &lt;strong&gt;single-pass&lt;/strong&gt;: you can only iterate through once. When a function has a yield in it we call it a &lt;a href=&quot;https://stackoverflow.com/a/1756342/673991&quot;&gt;generator function&lt;/a&gt;. And an &lt;a href=&quot;https://stackoverflow.com/a/9884501/673991&quot;&gt;iterator&lt;/a&gt; is what it returns. Those terms are revealing. We lose the convenience of a container, but gain the power of a series that's computed as needed, and arbitrarily long.</source>
          <target state="translated">Урожай &lt;strong&gt;однопроходный&lt;/strong&gt; : вы можете &lt;strong&gt;пройти&lt;/strong&gt; только один раз. Когда у функции есть выход, мы называем ее &lt;a href=&quot;https://stackoverflow.com/a/1756342/673991&quot;&gt;функцией генератора&lt;/a&gt; . И &lt;a href=&quot;https://stackoverflow.com/a/9884501/673991&quot;&gt;итератор&lt;/a&gt; - это то, что он возвращает. Эти условия являются показательными. Мы теряем удобство контейнера, но получаем мощность серии, которая вычисляется по мере необходимости и произвольно долго.</target>
        </trans-unit>
        <trans-unit id="8eb3142ec6ce40811e7cb41ff05374c2da24d165" translate="yes" xml:space="preserve">
          <source>Yield is &lt;strong&gt;versatile&lt;/strong&gt;. Data doesn't have to be stored all together, it can be made available one at a time. It can be infinite.</source>
          <target state="translated">Урожай &lt;strong&gt;универсален&lt;/strong&gt; . Данные не должны храниться все вместе, они могут быть доступны по одному за раз. Это может быть бесконечно.</target>
        </trans-unit>
        <trans-unit id="42e3a00c8f296b5fa17180ed67b9949807587502" translate="yes" xml:space="preserve">
          <source>You can also throw an exception which can be handled in the generator
or propagated back to the user:</source>
          <target state="translated">Вы также можете бросить исключение,которое может быть обработано в генераторе или передано обратно пользователю:</target>
        </trans-unit>
        <trans-unit id="3ad9323c26f58229cc6c89459957a3157bf59a21" translate="yes" xml:space="preserve">
          <source>You can read more about the precise semantics of &lt;code&gt;yield from&lt;/code&gt; in &lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/#formal-semantics&quot;&gt;PEP 380.&lt;/a&gt;</source>
          <target state="translated">Вы можете прочитать больше о точной семантике &lt;code&gt;yield from&lt;/code&gt; в &lt;a href=&quot;https://www.python.org/dev/peps/pep-0380/#formal-semantics&quot;&gt;PEP 380.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="170b20ccfec99da9235a6ef28068af3e2591fc27" translate="yes" xml:space="preserve">
          <source>You can stop here, or read a little bit to see an advanced use of a generator:</source>
          <target state="translated">Вы можете остановиться здесь или почитать немного,чтобы увидеть расширенное использование генератора:</target>
        </trans-unit>
        <trans-unit id="56ff330d6def0407146a91a863f8fc2587a5c6d6" translate="yes" xml:space="preserve">
          <source>You can use it in your code as follows:</source>
          <target state="translated">Вы можете использовать его в своем коде следующим образом:</target>
        </trans-unit>
        <trans-unit id="82929aa8decc455ab58ff5e64314ac91e1a3d659" translate="yes" xml:space="preserve">
          <source>You create an array that you only use once (this wastes memory)</source>
          <target state="translated">Вы создаете массив,который используете только один раз (это приводит к потере памяти).</target>
        </trans-unit>
        <trans-unit id="e5238c336d39149ce635875c88df949f1a84273e" translate="yes" xml:space="preserve">
          <source>You don't need to read the values twice.</source>
          <target state="translated">Тебе не нужно читать значения дважды.</target>
        </trans-unit>
        <trans-unit id="02fbf8c8568af6ce36580f6ee74a1c505f605eb0" translate="yes" xml:space="preserve">
          <source>You may have a lot of children and you don't want them all stored in memory.</source>
          <target state="translated">У вас может быть много детей,и вы не хотите,чтобы они все хранились в памяти.</target>
        </trans-unit>
        <trans-unit id="e5126053bf6eeea52bae61ffbf604541a9b1ae8d" translate="yes" xml:space="preserve">
          <source>You will always get [0, 1, 2] from a list object but only could retrieve them from 'the object &lt;code&gt;yield&lt;/code&gt; output' once. So, it has a new name &lt;code&gt;generator&lt;/code&gt; object as displayed in &lt;code&gt;Out[11]: &amp;lt;generator object num_list at 0x10327c990&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Вы всегда будете получать [0, 1, 2] из объекта списка, но только один раз сможете получить их из &amp;laquo;выхода объекта&amp;raquo;. Итак, у него есть новый объект &lt;code&gt;generator&lt;/code&gt; имен, как показано в &lt;code&gt;Out[11]: &amp;lt;generator object num_list at 0x10327c990&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f8b14bde35e7bc3becf466f732823047f257702" translate="yes" xml:space="preserve">
          <source>You'll have to make another if you want to use its functionality again (see footnote 2):</source>
          <target state="translated">Вам придется сделать еще один,если вы захотите снова использовать его функциональность (см.сноску 2):</target>
        </trans-unit>
        <trans-unit id="7ea7dca3eb3be682f93182ec4cb7bfa2d14d36ad" translate="yes" xml:space="preserve">
          <source>Your code explained</source>
          <target state="translated">Ваш код объяснил</target>
        </trans-unit>
        <trans-unit id="4c58039107bd67500d2d3318769f8f423735fd2d" translate="yes" xml:space="preserve">
          <source>[This is the step most people forget to tell you about]</source>
          <target state="translated">[Это шаг,о котором большинство людей забывают тебе рассказать]</target>
        </trans-unit>
        <trans-unit id="822a8e24b36ceb4904c03d9fb614f6c229c4b157" translate="yes" xml:space="preserve">
          <source>and use it like this;</source>
          <target state="translated">и использовать его вот так;</target>
        </trans-unit>
        <trans-unit id="a77a5320b0aaedb8d68bfda55fda0542b3d92a2f" translate="yes" xml:space="preserve">
          <source>build a series of stuff</source>
          <target state="translated">создавать ряд вещей</target>
        </trans-unit>
        <trans-unit id="d3e0b619b3729b20359ab7068cacec3bc130b31e" translate="yes" xml:space="preserve">
          <source>continuations</source>
          <target state="translated">continuations</target>
        </trans-unit>
        <trans-unit id="8225801242495db96d7b6f7c5559aeb4cf7bcbd2" translate="yes" xml:space="preserve">
          <source>do this:</source>
          <target state="translated">сделай это:</target>
        </trans-unit>
        <trans-unit id="70098eefec2efcfcd1042865cc5c5b7d99f6abcc" translate="yes" xml:space="preserve">
          <source>eventually, you might come to an end. You don't tell me a number; you just shout, &quot;hold your horses! I'm done! No more numbers!&quot;</source>
          <target state="translated">в конце концов,ты можешь подойти к концу.Ты не говоришь мне номер,ты просто кричишь:&quot;Держите своих лошадей! С меня хватит! Больше никаких номеров!&quot;</target>
        </trans-unit>
        <trans-unit id="4920bb1daf53da0a3e71fa2a9e6eb26483536f6d" translate="yes" xml:space="preserve">
          <source>it doesn't matter if &lt;code&gt;sequence&lt;/code&gt; is a list, a string, a dictionary or a generator &lt;em&gt;object&lt;/em&gt; like described above; the result is the same: you read items off a sequence one by one.</source>
          <target state="translated">не имеет значения, является ли &lt;code&gt;sequence&lt;/code&gt; списком, строкой, словарем или &lt;em&gt;объектом-&lt;/em&gt; генератором, как описано выше; результат тот же: вы читаете элементы из последовательности один за другим.</target>
        </trans-unit>
        <trans-unit id="3fc77b0bc00895bd9fb6a9b4c27987e556677c13" translate="yes" xml:space="preserve">
          <source>like barrier in the CUDA language, it will not transfer control until it gets
  completed.</source>
          <target state="translated">как и барьер в языке CUDA,он не передаст управление,пока не будет завершен.</target>
        </trans-unit>
        <trans-unit id="75e2309b5e1075332554d77f44b43d1c7f6a103e" translate="yes" xml:space="preserve">
          <source>simply outputs</source>
          <target state="translated">просто выходы</target>
        </trans-unit>
        <trans-unit id="7f9590246b59001286048a3a2c09550745ee2ab7" translate="yes" xml:space="preserve">
          <source>to avoid coroutines being confused with a regular generator (today &lt;code&gt;yield&lt;/code&gt; is used in both).</source>
          <target state="translated">чтобы не перепутать сопрограммы с обычным генератором (сегодня в обоих случаях используется &lt;code&gt;yield&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2c520454aaae8b0b40814f37e538a2a4da92490e" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;yield&lt;/code&gt; keyword is actually syntactic sugar for the real generator function, basically something like:</source>
          <target state="translated">где ключевое слово &lt;code&gt;yield&lt;/code&gt; на самом деле является синтаксическим сахаром для реальной функции генератора, что-то вроде:</target>
        </trans-unit>
        <trans-unit id="d893c24989b32aee817b8346e7ad376f369b2d24" translate="yes" xml:space="preserve">
          <source>will print</source>
          <target state="translated">будет печатать</target>
        </trans-unit>
        <trans-unit id="4ebe44985fd81b0255b36a096600873c8ed8bf99" translate="yes" xml:space="preserve">
          <source>you have a generator object now waiting for a command for it to generate a value. Use &lt;code&gt;next&lt;/code&gt; and see what get's printed:</source>
          <target state="translated">у вас есть объект генератора, ожидающий команду для создания значения. Используйте &lt;code&gt;next&lt;/code&gt; и посмотрите, что напечатано:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
