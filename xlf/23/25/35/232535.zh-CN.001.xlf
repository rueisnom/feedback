<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/232535">
    <body>
      <group id="232535">
        <trans-unit id="290dca3ab720e1a5481fc7d2b2daac691a5ecb5a" translate="yes" xml:space="preserve">
          <source>(Action) matches the signature of the method to be called i.e. (&lt;code&gt;Func&amp;lt;string,string,int&amp;gt;&lt;/code&gt; or &lt;code&gt;Action&amp;lt;bool&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（Action）匹配要调用的方法的签名，即（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Func&amp;lt;string,string,int&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Action&amp;lt;bool&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eade1fee26c0d1bbb44af59dd13e2489047a6b1f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;((Action)GenericMethod&amp;lt;object&amp;gt;)&lt;/code&gt; refers to the delegate for a specific method.  &lt;code&gt;((Func&amp;lt;string, int&amp;gt;)GenericMethod&amp;lt;object&amp;gt;)&lt;/code&gt;
refers to a different overload of GenericMethod</source>
          <target state="translated">&lt;code&gt;((Action)GenericMethod&amp;lt;object&amp;gt;)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;引用特定方法的委托。 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;((Func&amp;lt;string, int&amp;gt;)GenericMethod&amp;lt;object&amp;gt;)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 引用了GenericMethod的另一个重载&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6a0d78764959f75f1c68a022f5bd6b24043de989" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Process&lt;/code&gt; is a generic instance method that writes the real type of the passed argument (by using the &lt;code&gt;GetType()&lt;/code&gt; method) and the type of the generic parameter (by using &lt;code&gt;typeof&lt;/code&gt; operator).</source>
          <target state="translated">&lt;code&gt;Process&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是通用实例方法，它编写传递的参数的实类型（通过使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GetType()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法）和通用参数的类型（通过使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;typeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9097a22fe8a8346d04ab4f4d592127c641a5df14" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Here is a complete example&lt;/strong&gt; how to call this method to instantiate and use a &lt;code&gt;Dictionary&amp;lt;String, int&amp;gt;&lt;/code&gt; :</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一个完整的示例，&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;说明如何调用此方法以实例化和使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Dictionary&amp;lt;String, int&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b0b37dffa6e6122d271d9e18dfbb71a232abb0a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nobody provided the &quot;&lt;em&gt;classic Reflection&lt;/em&gt;&quot; solution, so here is a complete code example:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有人提供&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;经典的反射&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo;解决方案，因此这里是完整的代码示例：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4b2dbb7dd3fe023446263ea126c7b75aa47f762" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3e03bcbed0df764147b039386dd063669f0a622" translate="yes" xml:space="preserve">
          <source>Actually, if you try to get the result value in the previous example then you'll get a runtime error in the second loop iteration. This is because you tried to save the return value of a void function.</source>
          <target state="translated">实际上,如果你在前面的例子中试图获取结果值,那么在第二次循环迭代时,你会得到一个运行时错误。这是因为你尝试保存了一个void函数的返回值。</target>
        </trans-unit>
        <trans-unit id="6948afca7dccd71e85dc3ca8c088ba64645a55fb" translate="yes" xml:space="preserve">
          <source>Adding on to &lt;a href=&quot;https://stackoverflow.com/questions/232535/how-do-i-use-reflection-to-call-a-generic-method/5134251#5134251&quot;&gt;Adrian Gallero's answer&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;加上&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/232535/how-do-i-use-reflection-to-call-a-generic-method/5134251#5134251&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adrian Gallero的答案&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="33e2d283d2aad7d67769d4f55add11d23ef1e453" translate="yes" xml:space="preserve">
          <source>And here's the output of this program:</source>
          <target state="translated">这里是这个程序的输出。</target>
        </trans-unit>
        <trans-unit id="99919dbd92d3b1040229c15105c4f8bceb3982a4" translate="yes" xml:space="preserve">
          <source>And you're done. Works a charm!</source>
          <target state="translated">然后你就可以了。很有魅力!</target>
        </trans-unit>
        <trans-unit id="216a63bdbdc9d45a52c7753edbb2667c6fd32804" translate="yes" xml:space="preserve">
          <source>As @Bevan highlighted, I do not need to create an array when calling the MakeGenericMethod function as it takes in params and I do not need to create an object in order to get the types as I can just pass the types directly to this function. In my case, since I have the types predefined in another class, I simply changed my code to:</source>
          <target state="translated">正如@Bevan强调的那样,当调用MakeGenericMethod函数时,我不需要创建一个数组,因为它接收了参数,我不需要创建一个对象来获取类型,因为我可以直接将类型传递给这个函数。在我的例子中,因为我在另一个类中预设了类型,所以我只需将代码改成。</target>
        </trans-unit>
        <trans-unit id="799d027859f5995cd505ea490d7a05d319fff312" translate="yes" xml:space="preserve">
          <source>As I have my types predefined, I first create the &quot;dummy&quot; objects that represent the observable collection (U) and the object stored in it (T) and that will be used below to get their type when calling the Make</source>
          <target state="translated">因为我已经预先定义了我的类型,所以我首先创建了 &quot;dummy &quot;对象,代表可观察集合(U)和存储在其中的对象(T),下面调用Make</target>
        </trans-unit>
        <trans-unit id="bcc3a3e9403f5f488724ebeb608a3b693141e853" translate="yes" xml:space="preserve">
          <source>As noted, a lot of this is simpler as of C# 4 using &lt;code&gt;dynamic&lt;/code&gt; - if you can use type inference, of course. It doesn't help in cases where type inference isn't available, such as the exact example in the question.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如前所述，从C＃4开始，使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;dynamic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;很多事情都比较简单&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-当然，如果可以使用类型推断。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在类型推断不可用的情况下（如问题中的确切示例），它无济于事。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc935acf2946f21ff5a8104d6caf3a54e8ca9c72" translate="yes" xml:space="preserve">
          <source>Assume your method is defined as follows in an Helpers class:</source>
          <target state="translated">假设你的方法在Helpers类中的定义如下。</target>
        </trans-unit>
        <trans-unit id="e496fd20136d4bb7828ebb0ab925b1bd977208e4" translate="yes" xml:space="preserve">
          <source>Bar</source>
          <target state="translated">Bar</target>
        </trans-unit>
        <trans-unit id="11bbdd21c0418fc331acb348f91073f99e050d4f" translate="yes" xml:space="preserve">
          <source>Below is a simple example that illustrates how some errors can be caught at compile time (commented code) and other at runtime. It also shows how the DLR tries to resolve which method to call.</source>
          <target state="translated">下面是一个简单的例子,说明了一些错误如何在编译时(注释的代码)和其他错误在运行时被捕获。它还展示了DLR如何尝试解决调用哪个方法。</target>
        </trans-unit>
        <trans-unit id="2c2798ed71d0e9561c4ff9c754ef9e2ce7109cde" translate="yes" xml:space="preserve">
          <source>By casting the object argument to &lt;code&gt;dynamic&lt;/code&gt; type we deferred providing the type parameter until runtime. When the &lt;code&gt;Process&lt;/code&gt; method is called with the &lt;code&gt;dynamic&lt;/code&gt; argument then the compiler doesn't care about the type of this argument. The compiler generates code that at runtime checks the real types of passed arguments (by using reflection) and choose the best method to call. Here there is only this one generic method, so it's invoked with a proper type parameter.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过将对象参数转换为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;dynamic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型，我们推迟提供类型参数，直到运行时。当&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt; &lt;code&gt;dynamic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;参数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Process&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法时&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，编译器将不在乎此参数的类型。编译器生成的代码在运行时检查传递的参数的真实类型（通过使用反射），并选择最佳的调用方法。这里只有一种通用方法，因此使用适当的类型参数调用它。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a8ab9b59067b625e5d1277f4587a383ced70d22f" translate="yes" xml:space="preserve">
          <source>Calling a generic method from type info involves three steps.</source>
          <target state="translated">从类型信息中调用一个通用方法包括三个步骤。</target>
        </trans-unit>
        <trans-unit id="b2de9db1a09abb77e65ac60c781e70bcfe2b06e3" translate="yes" xml:space="preserve">
          <source>Calling a generic method with a type parameter known only at runtime can be greatly simplified by using a &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264741.aspx&quot;&gt;&lt;code&gt;dynamic&lt;/code&gt;&lt;/a&gt; type instead of the reflection API.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264741.aspx&quot;&gt; &lt;code&gt;dynamic&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型而不是反射API，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以大大简化使用仅在运行时才知道的类型参数调用通用方法的过程&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="700051fbfe581fb9c5bfa257409b6321d2417148" translate="yes" xml:space="preserve">
          <source>Consider the following sample code - inside the &lt;code&gt;Example()&lt;/code&gt; method, what's the most concise way to invoke &lt;code&gt;GenericMethod&amp;lt;T&amp;gt;()&lt;/code&gt; using the &lt;code&gt;Type&lt;/code&gt; stored in the &lt;code&gt;myType&lt;/code&gt; variable?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;考虑以下示例代码-在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Example()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内部，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;存储在&lt;/font&gt; &lt;code&gt;myType&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt; &lt;code&gt;Type&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GenericMethod&amp;lt;T&amp;gt;()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的最简洁方法是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;什么？&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2064efa8dc3c980cf7e4c32b5acd966878f7a566" translate="yes" xml:space="preserve">
          <source>Create a lambda expression where the body is a call to your desired method.</source>
          <target state="translated">创建一个lambda表达式,其中body是对你想要的方法的调用。</target>
        </trans-unit>
        <trans-unit id="a217db111f67c2f7402aa3b03890c7a22a0b43dd" translate="yes" xml:space="preserve">
          <source>Extract the body and cast to MethodCallExpression</source>
          <target state="translated">提取主体并投给MethodCallExpression</target>
        </trans-unit>
        <trans-unit id="640cece90ac2b8fb0b824605e1912102c78e8327" translate="yes" xml:space="preserve">
          <source>For a static method, pass &lt;code&gt;null&lt;/code&gt; as the first argument to &lt;code&gt;Invoke&lt;/code&gt;. That's nothing to do with generic methods - it's just normal reflection.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于静态方法，将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;null&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为第一个参数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;传递&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Invoke&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这与泛型方法无关-只是正常的反映。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="55a34421347462e3f49de09230d42ac8cc3ca24b" translate="yes" xml:space="preserve">
          <source>From inside the class that contains the methods:</source>
          <target state="translated">从包含方法的类内部。</target>
        </trans-unit>
        <trans-unit id="00a31b6c428bbb944f073d8f4b1f127ee082778f" translate="yes" xml:space="preserve">
          <source>From outside of the class that contains the methods:</source>
          <target state="translated">从包含方法的类外,。</target>
        </trans-unit>
        <trans-unit id="d70b8f016157b260f321a2fb4335baa273a26ce5" translate="yes" xml:space="preserve">
          <source>Get the generic method definition from the method</source>
          <target state="translated">从方法中获取通用方法的定义</target>
        </trans-unit>
        <trans-unit id="7b847379849d8d7a344d32e4c647e0ab4351d5a9" translate="yes" xml:space="preserve">
          <source>Here we again execute some method by casting the argument to the &lt;code&gt;dynamic&lt;/code&gt; type. Only verification of first argument's type is postponed to runtime. You will get a compiler error if the name of the method you're calling doesn't exist or if other arguments are invalid (wrong number of arguments or wrong types).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里，我们通过将参数强制转换为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;dynamic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来再次执行某种方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。仅对第一个参数类型的验证被推迟到运行时。如果您正在调用的方法的名称不存在，或者其他参数无效（参数数目错误或类型错误），则会出现编译器错误。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0315a9e740160f0ca13b2d84138fc111d8391914" translate="yes" xml:space="preserve">
          <source>How do I use reflection to call a generic method</source>
          <target state="translated">如何使用反射来调用一个通用方法</target>
        </trans-unit>
        <trans-unit id="a4c3790710308f94a83a5dd5f3888b53d1435d7e" translate="yes" xml:space="preserve">
          <source>If the generic method you want to call don't have an argument of a parametrized type (so its type parameter can't be inferred) then you can wrap the invocation of the generic method in a helper method like in the following example:</source>
          <target state="translated">如果你想调用的泛型方法没有一个参数是参数化的类型(所以它的类型参数无法推断),那么你可以像下面的例子一样,将泛型方法的调用封装在一个辅助方法中。</target>
        </trans-unit>
        <trans-unit id="627cef4b3bc7960549ca0a42a2e855e9f22addfa" translate="yes" xml:space="preserve">
          <source>If you want to call a generic method, that in &quot;normal&quot; usage would have had its type inferred, then it simply comes to casting the object of unknown type to &lt;code&gt;dynamic&lt;/code&gt;. Here's an example:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果要调用泛型方法，则在&amp;ldquo;正常&amp;rdquo;用法中会推断出其类型，那么它只是将未知类型的对象转换为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;dynamic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是一个例子：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c816ba8015c5a6ba4fca39da061e639a87d64575" translate="yes" xml:space="preserve">
          <source>In C#, the name of a method, i.e. &quot;ToString&quot; or &quot;GenericMethod&quot; actually refers to a group of methods that may contain one or more methods.  Until you provide the types of the method parameters, it is not known which
method you are referring to.</source>
          <target state="translated">在C#中,一个方法的名称,即 &quot;ToString &quot;或 &quot;GenericMethod &quot;实际上是指可能包含一个或多个方法的方法组。直到你提供了方法参数的类型,才知道你指的是哪个方法。</target>
        </trans-unit>
        <trans-unit id="64a7903f2368131e45db46d0f45ddc31af324f43" translate="yes" xml:space="preserve">
          <source>In my case, U type is always an observable collection storing object of type T.</source>
          <target state="translated">在我的例子中,U类型始终是一个可观察的集合,存储着T类型的对象。</target>
        </trans-unit>
        <trans-unit id="663ed56d7bd2f9b2f4412cef83d93fb68be5fa68" translate="yes" xml:space="preserve">
          <source>In this example, the output is the same as if you wrote:</source>
          <target state="translated">在这个例子中,输出和你写的一样。</target>
        </trans-unit>
        <trans-unit id="8d9004c4286a60de60fb05088f82267bb1577163" translate="yes" xml:space="preserve">
          <source>Increased type safety</source>
          <target state="translated">提高了类型的安全性</target>
        </trans-unit>
        <trans-unit id="11ecb9e238d47d2076d7d3c7840c7fa92320873c" translate="yes" xml:space="preserve">
          <source>Inspired by &lt;a href=&quot;https://stackoverflow.com/a/3958029/1016343&quot;&gt;Enigmativity's answer&lt;/a&gt; - let's assume you have two (or more) classes, like</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;受到&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/3958029/1016343&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;谜团答案的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;启发&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-假设您有两个（或更多）类，例如&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2e858ba310b42e6a40b6de119e75801635cd79b4" translate="yes" xml:space="preserve">
          <source>It is also a little dangerous in that you lose compile-time check for &lt;code&gt;GenericMethod&lt;/code&gt;. If you later do a refactoring and rename &lt;code&gt;GenericMethod&lt;/code&gt;, this code won't notice and will fail at run time. Also, if there is any post-processing of the assembly (for example obfuscating or removing unused methods/classes) this code might break too.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还有一点危险，就是您会丢失&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GenericMethod&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译时检查&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您稍后进行重构并重命名&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GenericMethod&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则此代码将不会引起注意，并且会在运行时失败。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另外，如果程序集有任何后处理（例如，混淆或删除未使用的方法/类），则此代码也可能会中断。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="49a8f72f1d6e69c26774d5b7330e9f867d36e46c" translate="yes" xml:space="preserve">
          <source>Just an addition to the original answer. While this will work:</source>
          <target state="translated">只是在原有答案的基础上增加了一个补充。虽然这样就可以了。</target>
        </trans-unit>
        <trans-unit id="164862777ffc462fddf1ecc891e3c07dadf1cb8b" translate="yes" xml:space="preserve">
          <source>Method 1: Use GetMethod() or GetMethods() with appropriate types or binding flags.</source>
          <target state="translated">方法一:使用GetMethod()或GetMethods(),并使用适当的类型或绑定标志。</target>
        </trans-unit>
        <trans-unit id="ac41f3ed4518f772f2950c9bfbe7e27d036c4e08" translate="yes" xml:space="preserve">
          <source>Method 2: Create a delegate, get the MethodInfo object and then call GetGenericMethodDefinition</source>
          <target state="translated">方法二:创建一个代表,获取MethodInfo对象,然后调用GetGenericMethodDefinition</target>
        </trans-unit>
        <trans-unit id="808836eb797ce4820ccc2b563d024dd00085ac83" translate="yes" xml:space="preserve">
          <source>Method 3: Create a lambda expression containing a method call expression, get the MethodInfo object and then GetGenericMethodDefinition</source>
          <target state="translated">方法三:创建一个包含方法调用表达式的lambda表达式,获取MethodInfo对象,然后GetGenericMethodDefinition</target>
        </trans-unit>
        <trans-unit id="ac9a8276adb665176231fee6f408b81a6e2597bb" translate="yes" xml:space="preserve">
          <source>Once that's done, you need to call the Invoke method as mentioned above.</source>
          <target state="translated">完成后,你需要像上面提到的那样调用Invoke方法。</target>
        </trans-unit>
        <trans-unit id="1ccc6e3ed223e001f1f7a3f43c0c7bf5565c0c7f" translate="yes" xml:space="preserve">
          <source>Other way to do the same would be to create a new wrapper class, and create it through &lt;code&gt;Activator&lt;/code&gt;. I don't know if there is a better way.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完成此操作的其他方法是创建一个新的包装器类，然后通过&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Activator&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建它&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我不知道是否有更好的方法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="18ffe6774cd6052e6a5429ac8ddd7f451be8e518" translate="yes" xml:space="preserve">
          <source>Return type gotcha</source>
          <target state="translated">返回类型GETCHA</target>
        </trans-unit>
        <trans-unit id="09fae740bb06d7d7836a868121bf72704812d0cf" translate="yes" xml:space="preserve">
          <source>So far, the above call is pretty much identical as to what was explained above but with a small difference when you need have to pass multiple parameters to it.</source>
          <target state="translated">到目前为止,上面的调用与上面解释的基本相同,但有一点不同的是,当你需要将多个参数传递给它的时候,就必须要传递给它。</target>
        </trans-unit>
        <trans-unit id="a3945ea8d27fd43e9d99eb3c8a9fd73ce87c698d" translate="yes" xml:space="preserve">
          <source>So, if you know the method you are linking to at compile time, and this isn't called millions of times so overhead doesn't matter, I would change this code to be:</source>
          <target state="translated">所以,如果你知道你在编译时链接的方法是什么,而且这个方法没有被调用数百万次,所以开销并不重要,我会把这个代码改成。</target>
        </trans-unit>
        <trans-unit id="82810cb97184cf542141f811b63d90bc5de31d1b" translate="yes" xml:space="preserve">
          <source>Square</source>
          <target state="translated">Square</target>
        </trans-unit>
        <trans-unit id="9b41eacb7403e5d890688714639a7294557df4ab" translate="yes" xml:space="preserve">
          <source>Step 1 is getting the MethodInfo for the generic method definition</source>
          <target state="translated">步骤1是获取通用方法定义的方法信息</target>
        </trans-unit>
        <trans-unit id="67d9de28a183a084af65257a905a688ecdd5e6bb" translate="yes" xml:space="preserve">
          <source>Step 2 is calling MakeGenericMethod to create a generic method with the appropriate type(s).</source>
          <target state="translated">第二步是调用MakeGenericMethod来创建一个具有相应类型的通用方法。</target>
        </trans-unit>
        <trans-unit id="8b661a119a98f836903907c7eb9f961379a66036" translate="yes" xml:space="preserve">
          <source>Step 3 is invoking the method with the appropriate arguments.</source>
          <target state="translated">第三步是用适当的参数调用方法。</target>
        </trans-unit>
        <trans-unit id="9943c087af287bfa4af41a991331b810939f0875" translate="yes" xml:space="preserve">
          <source>TLDR: Calling a known generic method with a type object can be accomplished by:</source>
          <target state="translated">TLDR:用类型对象调用一个已知的通用方法可以通过以下方式完成。</target>
        </trans-unit>
        <trans-unit id="6308d99e0166e934578bd1cf387a50a19d5eb3a2" translate="yes" xml:space="preserve">
          <source>Thanks again for highlighting this @Bevan.</source>
          <target state="translated">再次感谢@Bevan强调了这一点。</target>
        </trans-unit>
        <trans-unit id="a93a951faeaee285bd27afc60718dea76dbba251" translate="yes" xml:space="preserve">
          <source>The above &lt;code&gt;DynamicDictionaryFactory&lt;/code&gt; class has a method</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上面的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;DynamicDictionaryFactory&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类有一个方法&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a8778d3f2682fbdfb38526c3f44aad540599bb50" translate="yes" xml:space="preserve">
          <source>The version with a dynamic type is definitely shorter and easier to write. You also shouldn't worry about performance of calling this function multiple times. The next call with arguments of the same type should be faster thanks to the &lt;a href=&quot;http://blogs.msdn.com/b/samng/archive/2008/10/29/dynamic-in-c.aspx&quot;&gt;caching&lt;/a&gt; mechanism in DLR. Of course, you can write code that cache invoked delegates, but by using the &lt;code&gt;dynamic&lt;/code&gt; type you get this behaviour for free.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有动态类型的版本肯定更短并且更容易编写。您也不必担心多次调用此函数的性能。借助&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DLR中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.msdn.com/b/samng/archive/2008/10/29/dynamic-in-c.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;缓存&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;机制，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;下一次具有相同类型参数的调用应更快&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。当然，您可以编写代码来缓存调用的委托，但是通过使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;dynamic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型，您可以免费获得此行为。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a1c8be7af2cd4942d425c8acbca54b27f3a0fd1c" translate="yes" xml:space="preserve">
          <source>Then call the GetMethod to find your Generic function:</source>
          <target state="translated">然后调用GetMethod找到你的Generic函数。</target>
        </trans-unit>
        <trans-unit id="c44ea81c31c9bb2a9faf2f4ed6872c9d33de9413" translate="yes" xml:space="preserve">
          <source>Then you can implement an &lt;strong&gt;Extension method&lt;/strong&gt; like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，您可以实现&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;扩展方法，&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fb135918ceddb6a1d5e34c0fb0e83d4f111ed8bf" translate="yes" xml:space="preserve">
          <source>This breaks down to</source>
          <target state="translated">这可以分解为</target>
        </trans-unit>
        <trans-unit id="a8960ad7737b28ec4ae581cd4869cfab688d34bf" translate="yes" xml:space="preserve">
          <source>This is my 2 cents based on &lt;a href=&quot;https://stackoverflow.com/questions/232535/how-do-i-use-reflection-to-call-a-generic-method/27870198#27870198&quot;&gt;Grax's answer&lt;/a&gt;, but with two parameters required for a generic method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;根据&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/232535/how-do-i-use-reflection-to-call-a-generic-method/27870198#27870198&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Grax的回答&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是我的2美分&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是对于一般方法，需要两个参数。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b3015b46b324fde3ee4d8dd94da83a586e9c2768" translate="yes" xml:space="preserve">
          <source>To use this technique the type must be known from the actual object (not just an instance of the &lt;code&gt;Type&lt;/code&gt; class). Otherwise, you have to create an object of that type or use the standard reflection API &lt;a href=&quot;https://stackoverflow.com/a/232621/350384&quot;&gt;solution&lt;/a&gt;. You can create an object by using the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/wccyzw83%28v=vs.110%29.aspx&quot;&gt;Activator.CreateInstance&lt;/a&gt; method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要使用此技术，必须从实际对象中知道类型（不仅仅是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Type&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的实例&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;否则，您必须创建该类型的对象或使用标准的反射API &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/232621/350384&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解决方案&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/wccyzw83%28v=vs.110%29.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Activator.CreateInstance&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建一个对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9022f7a3300139eca4da2ae6055f0933304d153a" translate="yes" xml:space="preserve">
          <source>What is really great about using &lt;code&gt;dynamic&lt;/code&gt; object as a replacement for using reflection API is that you only lose compile time checking of this particular type that you don't know until runtime. Other arguments and the name of the method are staticly analysed by the compiler as usual. If you remove or add more arguments, change their types or rename method name then you'll get a compile-time error. This won't happen if you provide the method name as a string in &lt;code&gt;Type.GetMethod&lt;/code&gt; and arguments as the objects array in &lt;code&gt;MethodInfo.Invoke&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;dynamic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象代替反射API的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;真正&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;好处是，您只会丢失在运行时才知道的这种特定类型的编译时检查。编译器照常静态分析其他参数和方法名称。如果删除或添加更多参数，更改其类型或重命名方法名称，则会出现编译时错误。如果在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Type.GetMethod&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中将方法名称提供为字符串，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;MethodInfo.Invoke&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中将参数提供为对象数组，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则不会发生这种情况&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="79c6d1b5dee1d9cd5b14b69f29197a6a7def0b37" translate="yes" xml:space="preserve">
          <source>What's the best way to call a generic method when the type parameter isn't known at compile time, but instead is obtained dynamically at runtime?</source>
          <target state="translated">当类型参数在编译时不知道,而是在运行时动态获取时,如何调用通用方法?</target>
        </trans-unit>
        <trans-unit id="1b7a47c991c2d8b5beb9c96b965196f41193a463" translate="yes" xml:space="preserve">
          <source>When the above console application is executed, we get the correct, expected result:</source>
          <target state="translated">当上面的控制台应用程序被执行时,我们得到了正确的、预期的结果。</target>
        </trans-unit>
        <trans-unit id="dce830c550f9fdfb467286f2d4635ef7a543116b" translate="yes" xml:space="preserve">
          <source>When you pass the &lt;code&gt;dynamic&lt;/code&gt; argument to a method then this call is &lt;a href=&quot;http://blogs.msdn.com/b/ericlippert/archive/2012/02/06/what-is-quot-binding-quot-and-what-makes-it-late.aspx&quot;&gt;lately bound&lt;/a&gt;. Method overload resolution happens at runtime and tries to choose the best overload. So if you invoke the &lt;code&gt;ProcessItem&lt;/code&gt; method with an object of &lt;code&gt;BarItem&lt;/code&gt; type then you'll actually call the non-generic method, because it is a better match for this type. However, you'll get a runtime error when you pass an argument of the &lt;code&gt;Alpha&lt;/code&gt; type because there's no method that can handle this object (a generic method has the constraint &lt;code&gt;where T : IItem&lt;/code&gt; and &lt;code&gt;Alpha&lt;/code&gt; class doesn't implement this interface). But that's the whole point. The compiler doesn't have information that this call is valid. You as a programmer know this, and you should make sure that this code runs without errors.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当您将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;dynamic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;参数传递给方法时，此调用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.msdn.com/b/ericlippert/archive/2012/02/06/what-is-quot-binding-quot-and-what-makes-it-late.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最近会绑定&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。方法重载解析在运行时发生，并尝试选择最佳重载。因此，如果&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt; &lt;code&gt;BarItem&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ProcessItem&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则实际上将调用非泛型方法，因为它与该类型更好地匹配。但是，传递&lt;/font&gt; &lt;code&gt;Alpha&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;类型&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的参数时会出现运行时错误，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为没有方法可以处理此对象（通用方法具有以下约束&lt;/font&gt; &lt;code&gt;where T : IItem&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt; &lt;code&gt;Alpha&lt;/code&gt; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类未实现此接口）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但这就是重点。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译器没有有关此调用有效的信息。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为程序员，您知道这一点，并且应确保该代码运行无误。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8404bf1a6dddcdc8393275d5ed416ce9e721c54f" translate="yes" xml:space="preserve">
          <source>When you're calling a non-void method with a parameter of dynamic type, its return type will probably &lt;a href=&quot;http://blogs.msdn.com/b/ericlippert/archive/2012/11/05/dynamic-contagion-part-one.aspx&quot;&gt;be &lt;code&gt;dynamic&lt;/code&gt; too&lt;/a&gt;. So if you'd change previous example to this code:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当你调用动态类型的参数的非空方法，它的返回类型可能&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.msdn.com/b/ericlippert/archive/2012/11/05/dynamic-contagion-part-one.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;dynamic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;太&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，如果您将前面的示例更改为以下代码：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fedfbc7c2bbd6eca438e3ee81dc7bea49d38ab49" translate="yes" xml:space="preserve">
          <source>While not very pretty, you have a compile time reference to &lt;code&gt;GenericMethod&lt;/code&gt; here, and if you refactor, delete or do anything with &lt;code&gt;GenericMethod&lt;/code&gt;, this code will keep working, or at least break at compile time (if for example you remove &lt;code&gt;GenericMethod&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;虽然不是很漂亮，但是您&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GenericMethod&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的编译时参考&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且如果您重构，删除&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GenericMethod&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或对其进行任何操作&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，此代码将继续工作，或者至少在编译时中断（例如，如果您删除&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GenericMethod&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec22391a4f2500abe458e94af602de0364dc138c" translate="yes" xml:space="preserve">
          <source>With C# 4.0, reflection isn't necessary as the DLR can call it using runtime types. Since using the DLR library is kind of a pain dynamically (instead of the C# compiler generating code for you), the open source framework &lt;a href=&quot;https://github.com/ekonbenefits/dynamitey&quot;&gt;Dynamitey&lt;/a&gt; (.net standard 1.5) gives you easy cached run-time access to the same calls the compiler would generate for you.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C＃4.0中，不需要反射，因为DLR可以使用运行时类型进行调用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于动态使用DLR库很麻烦（而不是C＃编译器为您生成代码），因此开源框架&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/ekonbenefits/dynamitey&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dynamitey&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（.net标准1.5）使您可以轻松地缓存运行时访问编译器将生成的相同调用为了你。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fcd000c27dc69c7663b53e7a3d73eb6fdfd2d157" translate="yes" xml:space="preserve">
          <source>With this, you can simply invoke &lt;code&gt;Foo&lt;/code&gt; like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样，您可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;像下面这样&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;简单地调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Foo&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42897873d05394d080118009dfd1350d62ee67d6" translate="yes" xml:space="preserve">
          <source>You need to pass an Type[] array to the MakeGenericMethod function that contains the &quot;dummy&quot; objects' types that were create above:</source>
          <target state="translated">你需要向MakeGenericMethod函数传递一个Type[]数组,这个数组包含了上面创建的 &quot;dummy &quot;对象的类型。</target>
        </trans-unit>
        <trans-unit id="853cd5b66a7e2b293f546f0344c027aef902486f" translate="yes" xml:space="preserve">
          <source>You need to use reflection to get the method to start with, then &quot;construct&quot; it by supplying type arguments with &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.reflection.methodinfo.makegenericmethod.aspx&quot;&gt;MakeGenericMethod&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您需要使用反射来使方法开始，然后通过为&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.reflection.methodinfo.makegenericmethod.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MakeGenericMethod&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提供类型参数来&amp;ldquo;构造&amp;rdquo;它&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="23069e59f1bd650765a9a30fef468aa3c1c13002" translate="yes" xml:space="preserve">
          <source>You'll get a runtime error if the type doesn't match.</source>
          <target state="translated">如果类型不匹配,你会得到一个运行时错误。</target>
        </trans-unit>
        <trans-unit id="cd48c0cf5ab841d4c18ac071da7961a84838cc65" translate="yes" xml:space="preserve">
          <source>and it creates and returns an IDictionary instance, the types of whose keys and values are exactly the specified on the call &lt;code&gt;keyType&lt;/code&gt; and &lt;code&gt;valueType&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并创建并返回一个IDictionary实例，其实例的键和值的类型恰好在调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;keyType&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;valueType&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上指定&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a3a44f4007c44bb308dc019adec528028384da4" translate="yes" xml:space="preserve">
          <source>and you want to call the method &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;code&gt;Bar&lt;/code&gt; and &lt;code&gt;Square&lt;/code&gt;, which is declared as</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并且您要&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt; &lt;code&gt;Bar&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt; &lt;code&gt;Square&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;调用方法&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Foo&amp;lt;T&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，该方法声明为&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="373f9635c978d1478015369c2f1c35e7f368020a" translate="yes" xml:space="preserve">
          <source>myClassInfo contains 2 properties of type &lt;code&gt;Type&lt;/code&gt; which I set at run time based on an enum value passed to the constructor and will provide me with the relevant types which I then use in the MakeGenericMethod.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;myClassInfo包含2个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Type&lt;/code&gt; 类型的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;属性&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我在运行时根据传递给构造函数的枚举值进行设置，并将为我提供相关的类型，然后在MakeGenericMethod中使用这些类型。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea239bd275bdb1c60259e5ce696669042c884ce3" translate="yes" xml:space="preserve">
          <source>then the type of the result object would be &lt;code&gt;dynamic&lt;/code&gt;. This is because the compiler don't always know which method will be called. If you know the return type of the function call then you should &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264736.aspx&quot;&gt;implicitly convert&lt;/a&gt; it to the required type so the rest of the code is statically typed:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那么结果对象的类型将是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;dynamic&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是因为编译器并不总是知道将调用哪个方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您知道函数调用的返回类型，则应&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd264736.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;隐式转换&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为所需的类型，以便其余代码为静态类型：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a372cbfc24988c0b6b54696156394bd41662428f" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;GenericMethod&amp;lt;object&amp;gt;&lt;/code&gt; is the method name to call and any type that satisfies the generic constraints.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其中&lt;/font&gt;&lt;/font&gt; &lt;code&gt;GenericMethod&amp;lt;object&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是要调用的方法名称，以及满足常规约束的任何类型。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c46221efe69e51d85aefd32ebaa97fd5956d92c8" translate="yes" xml:space="preserve">
          <source>which works for every class. In this case, it will output:</source>
          <target state="translated">它对每个类都有效。在这种情况下,它将输出。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
