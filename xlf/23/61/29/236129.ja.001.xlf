<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/236129">
    <body>
      <group id="236129">
        <trans-unit id="edcb0f44cc7dfb094ba440e1b7696a327b163cfe" translate="yes" xml:space="preserve">
          <source>... or create the &lt;code&gt;vector&lt;/code&gt; directly:</source>
          <target state="translated">...または直接 &lt;code&gt;vector&lt;/code&gt; を作成します：</target>
        </trans-unit>
        <trans-unit id="daf67907bca13add6181e99993d1c333b0460b26" translate="yes" xml:space="preserve">
          <source>A good point is that in &lt;code&gt;separators&lt;/code&gt; you can pass more than one character.</source>
          <target state="translated">良い点は、 &lt;code&gt;separators&lt;/code&gt; は複数の文字を渡すことができるということです。</target>
        </trans-unit>
        <trans-unit id="3885f98f0b7796bc84d063ed9149766d457a3c80" translate="yes" xml:space="preserve">
          <source>A possible solution using Boost might be:</source>
          <target state="translated">Boostを使った解決策として考えられるのは</target>
        </trans-unit>
        <trans-unit id="c3721b3abeee59011fa0e483bff445ac1cd186ad" translate="yes" xml:space="preserve">
          <source>Additionally it does not do the (extremely inefficient) return of result, but rather it passes the tokens as a reference, thus also allowing you to build up tokens using multiple calls if you so wished.</source>
          <target state="translated">さらに、(非常に非効率的な)結果を返すのではなく、トークンを参照として渡します。</target>
        </trans-unit>
        <trans-unit id="60f636a484c97d6136fbab261aac3f0769baa3e3" translate="yes" xml:space="preserve">
          <source>All it needs is &lt;code&gt;std::string&lt;/code&gt;... the rest are optional. It does not use streams or the boost library, but is flexible enough to be able to accept some of these foreign types naturally.</source>
          <target state="translated">必要なのは &lt;code&gt;std::string&lt;/code&gt; ...で、残りはオプションです。 ストリームやブーストライブラリは使用しませんが、これらの外部型の一部を自然に受け入れることができるほど柔軟です。</target>
        </trans-unit>
        <trans-unit id="c9c6db698f80734384e3824d88d70b12ee11ad29" translate="yes" xml:space="preserve">
          <source>And just because it does not implement a &lt;code&gt;typedef&lt;/code&gt; called iterator or overload the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator does not mean it is bad code. I use C functions quite frequently. For example, &lt;a href=&quot;http://en.cppreference.com/w/c/io/fprintf&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/c/io/fscanf&quot;&gt;&lt;code&gt;scanf&lt;/code&gt;&lt;/a&gt; both are faster than &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cin&quot;&gt;&lt;code&gt;std::cin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cout&quot;&gt;&lt;code&gt;std::cout&lt;/code&gt;&lt;/a&gt; (significantly), the &lt;a href=&quot;http://en.cppreference.com/w/c/io/fopen&quot;&gt;&lt;code&gt;fopen&lt;/code&gt;&lt;/a&gt; syntax is a lot more friendly for binary types, and they also tend to produce smaller EXEs.</source>
          <target state="translated">また、イテレータと呼ばれる &lt;code&gt;typedef&lt;/code&gt; を実装していない、または &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 演算子をオーバーロードしていないからといって、それが悪いコードであるとは限りません。 C関数をかなり頻繁に使用しています。 たとえば、 &lt;a href=&quot;http://en.cppreference.com/w/c/io/fprintf&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt;と&lt;a href=&quot;http://en.cppreference.com/w/c/io/fscanf&quot;&gt; &lt;code&gt;scanf&lt;/code&gt; は&lt;/a&gt;どちらも&lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cin&quot;&gt; &lt;code&gt;std::cin&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cout&quot;&gt; &lt;code&gt;std::cout&lt;/code&gt; &lt;/a&gt; （大幅に）よりも高速であり、 &lt;a href=&quot;http://en.cppreference.com/w/c/io/fopen&quot;&gt; &lt;code&gt;fopen&lt;/code&gt; &lt;/a&gt;構文はバイナリタイプに対してはるかに使いやすく、また、より小さなEXEを生成する傾向があります。</target>
        </trans-unit>
        <trans-unit id="6870791be3a59b2da2de603a0be80d00918affe3" translate="yes" xml:space="preserve">
          <source>Don't get sold on this &lt;strong&gt;&quot;Elegance over performance&quot;&lt;/strong&gt; deal.</source>
          <target state="translated">この&lt;strong&gt;「パフォーマンスよりも優雅」な&lt;/strong&gt;取引で売られないでください。</target>
        </trans-unit>
        <trans-unit id="12735fab994dcd7b5adae72726b9a46ab4afa992" translate="yes" xml:space="preserve">
          <source>Example code including convenient template:</source>
          <target state="translated">便利なテンプレートを含むコード例</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">使用例。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="2705b643a0f80d229f05dcb52e5d3ae40b25b515" translate="yes" xml:space="preserve">
          <source>For example, this splits &quot;AQueryTrades&quot; into &quot;A&quot;, &quot;Query&quot; and &quot;Trades&quot;.  The function works with narrow and wide strings. Because it respects the current locale it splits &quot;Raumfahrt&amp;Uuml;berwachungsVerordnung&quot; into &quot;Raumfahrt&quot;, &quot;&amp;Uuml;berwachungs&quot; and &quot;Verordnung&quot;.</source>
          <target state="translated">たとえば、これは「AQueryTrades」を「A」、「Query」、および「Trades」に分割します。 この関数は、狭い文字列と広い文字列で機能します。 現在のロケールを尊重するため、「Raumfahrt&amp;Uuml;berwachungsVerordnung」を「Raumfahrt」、「&amp;Uuml;berwachungs」、「Verordnung」に分割します。</target>
        </trans-unit>
        <trans-unit id="de52debc28e040370100e81fc36a534b35a68c1a" translate="yes" xml:space="preserve">
          <source>For those with whom it does not sit well to sacrifice all efficiency for code size and see &quot;efficient&quot; as a type of elegance, the following should hit a sweet spot (and I think the template container class is an awesomely elegant addition.):</source>
          <target state="translated">コードサイズのためにすべての効率を犠牲にして「効率的」をエレガンスの一種とみなすことがうまくいかない人のために、以下のものがスイートスポットにヒットするはずです(そして、テンプレートコンテナクラスは非常にエレガントな追加だと思います)。</target>
        </trans-unit>
        <trans-unit id="f805399e635e59badeb8d25438ef59ca9d0781ff" translate="yes" xml:space="preserve">
          <source>For what it's worth, here's another way to extract tokens from an input string, relying only on standard library facilities. It's an example of the power and elegance behind the design of the STL.</source>
          <target state="translated">参考までに、入力文字列からトークンを抽出する別の方法を紹介します。これは、STLのデザインの背後にあるパワーとエレガンスの例です。</target>
        </trans-unit>
        <trans-unit id="e6608506d839180b9e39fabbdc1e4720408a5c00" translate="yes" xml:space="preserve">
          <source>Get &lt;a href=&quot;http://www.boost.org/&quot;&gt;Boost&lt;/a&gt; ! : -)</source>
          <target state="translated">&lt;a href=&quot;http://www.boost.org/&quot;&gt;ブーストを&lt;/a&gt;ゲット！ ：-）</target>
        </trans-unit>
        <trans-unit id="829b1be11ab5027516a4c431a8773cbefd7348b8" translate="yes" xml:space="preserve">
          <source>Here is a split function that:</source>
          <target state="translated">ここに分割関数があります。</target>
        </trans-unit>
        <trans-unit id="4caf1473b9c810e10c38b1b0cdb53f2d370028f3" translate="yes" xml:space="preserve">
          <source>Here's a simple solution that uses only the standard regex library</source>
          <target state="translated">標準の正規表現ライブラリのみを使用したシンプルなソリューションは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">一例を挙げてみます。</target>
        </trans-unit>
        <trans-unit id="a780475444a036f8986b27e4e0681b9956fc67b0" translate="yes" xml:space="preserve">
          <source>Here's another solution. It's compact and reasonably efficient:</source>
          <target state="translated">ここにもう一つの解決策があります。それはコンパクトで合理的に効率的です。</target>
        </trans-unit>
        <trans-unit id="78859cf5ab12634a3057d2cf55d540f4dd043078" translate="yes" xml:space="preserve">
          <source>Here's another way of doing it..</source>
          <target state="translated">別の方法を紹介します。</target>
        </trans-unit>
        <trans-unit id="d30b6f4a9867c924c643828218cb2533ca6fed31" translate="yes" xml:space="preserve">
          <source>Heres a regex solution that only uses the standard regex library.  (I'm a little rusty, so there may be a few syntax errors, but this is at least the general idea)</source>
          <target state="translated">標準の正規表現ライブラリのみを使用した正規表現ソリューションです。(私は少し錆びついているので、いくつかの構文エラーがあるかもしれませんが、これは少なくとも一般的な考えです)</target>
        </trans-unit>
        <trans-unit id="ad839725a134bd1b6392b1c21e805b0f7cc756d8" translate="yes" xml:space="preserve">
          <source>How do I iterate over the words of a string</source>
          <target state="translated">文字列の単語を反復処理するには</target>
        </trans-unit>
        <trans-unit id="8164d0d639169c81b13b17bc3d347e5df03097ea" translate="yes" xml:space="preserve">
          <source>However, you can either use C's &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/strtok&quot;&gt;&lt;code&gt;strtok()&lt;/code&gt;&lt;/a&gt; function by using the &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/c_str&quot;&gt;&lt;code&gt;std::string::c_str()&lt;/code&gt;&lt;/a&gt; member, or you can write your own. Here is a code sample I found after a quick Google search (&lt;strong&gt;&quot;STL string split&quot;&lt;/strong&gt;):</source>
          <target state="translated">ただし、 &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/c_str&quot;&gt; &lt;code&gt;std::string::c_str()&lt;/code&gt; &lt;/a&gt;メンバーを使用してCの&lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/strtok&quot;&gt; &lt;code&gt;strtok()&lt;/code&gt; &lt;/a&gt;関数を使用することも、独自に作成することもできます。 これは、簡単なGoogle検索（ &lt;strong&gt;&quot;STL string split&quot;&lt;/strong&gt; ）の後に見つけたコードサンプルです。</target>
        </trans-unit>
        <trans-unit id="edbd5b3edc642567da5a827b6b2f8804da091757" translate="yes" xml:space="preserve">
          <source>I have a 2 lines solution to this problem:</source>
          <target state="translated">この問題を2行で解決しています。</target>
        </trans-unit>
        <trans-unit id="d9d3bf7ae6779586aa4c434765f7f1f0997b6b1f" translate="yes" xml:space="preserve">
          <source>I hope someone else can find this as useful as I do.</source>
          <target state="translated">私と同じように誰かに参考にしてもらえればと思います。</target>
        </trans-unit>
        <trans-unit id="3a73403c1957cc0e33fdc441ae726cc999f4942c" translate="yes" xml:space="preserve">
          <source>I like the following because it puts the results into a vector, supports a string as a delim and gives control over keeping empty values. But, it doesn't look as good then.</source>
          <target state="translated">結果をベクターに入れたり、デリムとして文字列をサポートしていたり、空の値を保持する制御をしてくれたりするので、私は以下のようなものが好きです。しかし、それでは見栄えが悪い。</target>
        </trans-unit>
        <trans-unit id="70af1c7cf8dbf905cd7d9ae6fe84ef064af7b8b3" translate="yes" xml:space="preserve">
          <source>I like to use the boost/regex methods for this task since they provide maximum flexibility for specifying the splitting criteria.</source>
          <target state="translated">私はこのタスクにboostregexメソッドを使いたいと思っています。</target>
        </trans-unit>
        <trans-unit id="a3e013d54b198746029363a080be9d65c71513bc" translate="yes" xml:space="preserve">
          <source>I made this because I needed an easy way to split strings and c-based strings... Hopefully someone else can find it useful as well. Also it doesn't rely on tokens and you can use fields as delimiters, which is another key I needed.</source>
          <target state="translated">文字列とcベースの文字列を簡単に分割する方法が必要だったので、これを作ってみました。誰か他の人がこれを使えるようになるといいですね。また、これはトークンに依存していないので、フィールドを区切り文字として使うことができ、これも私が必要としていたもう一つのキーです。</target>
        </trans-unit>
        <trans-unit id="01bc5ba0fa755484bd526b58e86a0cea76a28bf8" translate="yes" xml:space="preserve">
          <source>I use this to split string by a delimiter. The first puts the results in a pre-constructed vector, the second returns a new vector.</source>
          <target state="translated">文字列をデリミタで分割するときに使います。最初のものは結果をあらかじめ構築されたベクターに入れ、2番目のものは新しいベクターを返します。</target>
        </trans-unit>
        <trans-unit id="d02b633661d0af2f5aac614aedf4fd95b95fc7fc" translate="yes" xml:space="preserve">
          <source>I usually choose to use &lt;code&gt;std::vector&amp;lt;std::string&amp;gt;&lt;/code&gt; types as my second parameter (&lt;code&gt;ContainerT&lt;/code&gt;)... but &lt;code&gt;list&amp;lt;&amp;gt;&lt;/code&gt; is way faster than &lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt; for when direct access is not needed, and you can even create your own string class and use something like &lt;code&gt;std::list&amp;lt;subString&amp;gt;&lt;/code&gt; where &lt;code&gt;subString&lt;/code&gt; does not do any copies for incredible speed increases.</source>
          <target state="translated">通常、2番目のパラメーター（ &lt;code&gt;ContainerT&lt;/code&gt; ）として &lt;code&gt;std::vector&amp;lt;std::string&amp;gt;&lt;/code&gt; 型を使用することを選択します...しかし、直接アクセスが必要ない場合、 &lt;code&gt;list&amp;lt;&amp;gt;&lt;/code&gt; は &lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt; よりもはるかに高速であり、作成することもできます独自の文字列クラスを使用し、 &lt;code&gt;std::list&amp;lt;subString&amp;gt;&lt;/code&gt; ようなものを使用してください。</target>
        </trans-unit>
        <trans-unit id="98ba3b0af09fe29627f5fe02ee9af975d3e8d35b" translate="yes" xml:space="preserve">
          <source>I usually only check to split on spaces and commas, so I also have this default function:</source>
          <target state="translated">普段はスペースとカンマでしか分割チェックしていないので、このデフォルト機能もあります。</target>
        </trans-unit>
        <trans-unit id="8e91045629e7a5c9e98dde7928f173bbd7764caa" translate="yes" xml:space="preserve">
          <source>I'm sure there's improvements that can be made to even further improve its elegance and please do by all means</source>
          <target state="translated">さらなる気品の向上のためにも改善点はあると思いますので、ぜひお願いします。</target>
        </trans-unit>
        <trans-unit id="a3b5e6ebe32255aa5a8cbb511d5478625952fbff" translate="yes" xml:space="preserve">
          <source>I'm trying to iterate over the words of a string.</source>
          <target state="translated">文字列の単語を反復処理しようとしています。</target>
        </trans-unit>
        <trans-unit id="e5807a479143bdef2e06556aa0b30259912e246a" translate="yes" xml:space="preserve">
          <source>I've rolled my own using strtok and used boost to split a string.  The best method I have found is the &lt;a href=&quot;http://www.partow.net/programming/strtk/&quot;&gt;C++ String Toolkit Library&lt;/a&gt;.  It is incredibly flexible and fast.</source>
          <target state="translated">私はstrtokを使用して自分自身をロールバックし、ブーストを使用して文字列を分割しました。 私が見つけた最良の方法は&lt;a href=&quot;http://www.partow.net/programming/strtk/&quot;&gt;C ++ String Toolkit Library&lt;/a&gt;です。 非常に柔軟で高速です。</target>
        </trans-unit>
        <trans-unit id="80bd129398d2a58cb60b25313fb43865351f69bf" translate="yes" xml:space="preserve">
          <source>If splitting a string at multiple delimiters while skipping empty tokens is desired, this version may be used:</source>
          <target state="translated">空のトークンをスキップしながら複数のデリミタで文字列を分割したい場合は、このバージョンを使用することができます。</target>
        </trans-unit>
        <trans-unit id="7589cbcf380a78c9803a11402f160a9053a8278d" translate="yes" xml:space="preserve">
          <source>If you have questions about the code sample, leave a comment and I will explain.</source>
          <target state="translated">コードサンプルについて質問があれば、コメントを残してください。</target>
        </trans-unit>
        <trans-unit id="4af4cc4098db3af77c2383b7caef397b8c5d31c3" translate="yes" xml:space="preserve">
          <source>If you like to use boost, but want to use a whole string as delimiter (instead of single characters as in most of the previously proposed solutions), you can use the &lt;code&gt;boost_split_iterator&lt;/code&gt;.</source>
          <target state="translated">boostを使用したいが、区切り文字として（以前に提案されたほとんどのソリューションのように単一の文字の代わりに）文字列全体を使用したい場合は、 &lt;code&gt;boost_split_iterator&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="a644a073e06e3986597fbf1fcf4f2d6a9c572e35" translate="yes" xml:space="preserve">
          <source>Instead of copying the extracted tokens to an output stream, one could insert them into a container, using the same generic &lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; algorithm.</source>
          <target state="translated">抽出されたトークンを出力ストリームにコピーする代わりに、同じ一般的な&lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;アルゴリズムを使用して、それらをコンテナーに挿入できます。</target>
        </trans-unit>
        <trans-unit id="06e57f321253a6ce49b846a26ffcbdfdd422b91f" translate="yes" xml:space="preserve">
          <source>Is there a more elegant way to do this?</source>
          <target state="translated">もっとエレガントな方法はありませんか?</target>
        </trans-unit>
        <trans-unit id="ae8fe7d96f18b204a67c12bb20b01019014e820d" translate="yes" xml:space="preserve">
          <source>It can also be easily expanded to skip empty tokens:</source>
          <target state="translated">また、空のトークンをスキップするために簡単に拡張することができます。</target>
        </trans-unit>
        <trans-unit id="e2ba82430e6d8796d64675e8c1fa0c82bcbabce7" translate="yes" xml:space="preserve">
          <source>It can easily be templatised to handle string separators, wide strings, etc.</source>
          <target state="translated">文字列の区切り文字や幅の広い文字列などを簡単にテンプレート化して扱うことができます。</target>
        </trans-unit>
        <trans-unit id="28d90795bfb34c48b119d7f6cb9d197ea65a4073" translate="yes" xml:space="preserve">
          <source>It's more than double as fast as the fastest tokenize on this page and almost 5 times faster than some others. Also with the perfect parameter types you can eliminate all string and list copies for additional speed increases.</source>
          <target state="translated">このページで紹介している最速のtokenizeの2倍以上、他のいくつかのものよりも5倍近く高速です。また、完璧なパラメータ型を使用することで、文字列とリストのコピーをすべて排除することができ、さらなる高速化が可能です。</target>
        </trans-unit>
        <trans-unit id="69d1271bac1d9c309e788d9ea67be98ca0e136bf" translate="yes" xml:space="preserve">
          <source>Lastly it allows you to specify whether to trim empty tokens from the results via a last optional parameter.</source>
          <target state="translated">最後に、最後のオプションのパラメータで結果から空のトークンをトリミングするかどうかを指定することができます。</target>
        </trans-unit>
        <trans-unit id="a1630c87ca12f86b482c8b5c22149b511943f7cb" translate="yes" xml:space="preserve">
          <source>Limited by imagination ;)</source>
          <target state="translated">想像力によって制限される ;)</target>
        </trans-unit>
        <trans-unit id="2fe5047d67353f0846aa94b0fe23a67a2b32150c" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;std::upper&lt;/code&gt; should be really passed as function template argument. Then the more generalized from of this function can split at delimiters like &lt;code&gt;&quot;,&quot;&lt;/code&gt;, &lt;code&gt;&quot;;&quot;&lt;/code&gt; or &lt;code&gt;&quot; &quot;&lt;/code&gt; too.</source>
          <target state="translated">&lt;code&gt;std::upper&lt;/code&gt; は、関数テンプレートの引数として実際に渡される必要があります。 次に、この関数のより一般化されたfromは、 &lt;code&gt;&quot;,&quot;&lt;/code&gt; 、 &lt;code&gt;&quot;;&quot;&lt;/code&gt; などの区切り文字で分割できます。 または &lt;code&gt;&quot; &quot;&lt;/code&gt; も。</target>
        </trans-unit>
        <trans-unit id="3af42b55fb6cb79a028f48fc9dddef7a1b09c406" translate="yes" xml:space="preserve">
          <source>Note that I'm not interested in C string functions or that kind of character manipulation/access. Also, please give precedence to elegance over efficiency in your answer.</source>
          <target state="translated">私はC言語の文字列関数やそのような文字操作アクセスには興味がないことに注意してください。また、あなたの回答では、効率よりも優雅さを優先してください。</target>
        </trans-unit>
        <trans-unit id="1e2cb5802a91f46a1cfa9c5a877feee94d00ecb2" translate="yes" xml:space="preserve">
          <source>Note that splitting &lt;code&gt;&quot;&quot;&lt;/code&gt; results in a single empty string and splitting &lt;code&gt;&quot;,&quot;&lt;/code&gt; (ie. sep) results in two empty strings.</source>
          <target state="translated">&lt;code&gt;&quot;&quot;&lt;/code&gt; を分割すると1つの空の文字列になり、 &lt;code&gt;&quot;,&quot;&lt;/code&gt; （つまりsep）を分割すると2つの空の文字列になります。</target>
        </trans-unit>
        <trans-unit id="2eed498a91867681e33df9807e93e65e867e0bff" translate="yes" xml:space="preserve">
          <source>Note that this solution does not skip empty tokens, so the following will find 4 items, one of which is empty:</source>
          <target state="translated">この解決策は空のトークンをスキップしないので、以下のように4つの項目を見つけ、そのうちの1つが空であることに注意してください。</target>
        </trans-unit>
        <trans-unit id="fe5714fb716282b1a9a1fc9fcd3bd604250fb787" translate="yes" xml:space="preserve">
          <source>Note, if you want to split &lt;code&gt;wstring&lt;/code&gt; instead of &lt;code&gt;string&lt;/code&gt;,</source>
          <target state="translated">注意： &lt;code&gt;string&lt;/code&gt; ではなく &lt;code&gt;wstring&lt;/code&gt; を分割したい場合、</target>
        </trans-unit>
        <trans-unit id="d172c279b9365bde131c6c6226972701d76e01c5" translate="yes" xml:space="preserve">
          <source>Note, you might also want to take the string argument by reference, depending on your compiler.</source>
          <target state="translated">コンパイラによっては、文字列の引数を参照で取りたい場合もあるかもしれません。</target>
        </trans-unit>
        <trans-unit id="94d45ad4e48fcad61e269a1e3312579ec200054b" translate="yes" xml:space="preserve">
          <source>Of course, Boost has a &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html#id3483755&quot;&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt; that works partially like that. And, if by 'white-space', you really do mean any type of white-space, using Boost's split with &lt;code&gt;is_any_of()&lt;/code&gt; works great.</source>
          <target state="translated">もちろん、Boostには&lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html#id3483755&quot;&gt; &lt;code&gt;split()&lt;/code&gt; があり&lt;/a&gt; 、そのように部分的に機能します。 そして、もし「空白」とは、 &lt;code&gt;is_any_of()&lt;/code&gt; でBoostの分割を使用することで、あらゆる種類の空白を意味します。</target>
        </trans-unit>
        <trans-unit id="feefe8647d3c18455c7284d73e5e9b156c6be204" translate="yes" xml:space="preserve">
          <source>Recently I had to split a camel-cased word into subwords.  There are no delimiters, just upper characters.</source>
          <target state="translated">最近、ラクダを使った単語をサブワードに分割しなければならなくなった。区切り文字はなく、上位文字だけです。</target>
        </trans-unit>
        <trans-unit id="58fd97bc0d3ae9571cb48bf3cbc2a8e1eca6001f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">詳細は&lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html&quot;&gt;ドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="b8776bac563a3c1a8c473120ed91905a5d046e8c" translate="yes" xml:space="preserve">
          <source>Short and elegant</source>
          <target state="translated">ショート&amp;エレガント</target>
        </trans-unit>
        <trans-unit id="3f5a90e2a6ed10327b773e990c6e9c0718937bb8" translate="yes" xml:space="preserve">
          <source>So far I used the one in &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_C++_Libraries&quot;&gt;Boost&lt;/a&gt;, but I needed something that doesn't depends on it, so I came to this:</source>
          <target state="translated">これまでは&lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_C++_Libraries&quot;&gt;Boost&lt;/a&gt;の1つを使用していましたが、それに依存しないものが必要だったので、次のようにしました。</target>
        </trans-unit>
        <trans-unit id="567e164602261d048d22e25b3917128629c66b84" translate="yes" xml:space="preserve">
          <source>StringSplitter.cpp:</source>
          <target state="translated">StringSplitter.cpp:</target>
        </trans-unit>
        <trans-unit id="fb0c5461cacf796c6e710a8542a3699900e2261b" translate="yes" xml:space="preserve">
          <source>StringSplitter.hpp:</source>
          <target state="translated">StringSplitter.hpp:</target>
        </trans-unit>
        <trans-unit id="87fdba3e4c7e285121516a72fc35fd71bc4a6cde" translate="yes" xml:space="preserve">
          <source>Taken from: &lt;a href=&quot;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&quot;&gt;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&lt;/a&gt;</source>
          <target state="translated">取得元： &lt;a href=&quot;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&quot;&gt;http&lt;/a&gt; : //oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html</target>
        </trans-unit>
        <trans-unit id="27ce8f54f6936c89f8e51e510065e4a26b283c12" translate="yes" xml:space="preserve">
          <source>That's it! And that's just one way to use the tokenizer, like how to just 
count words:</source>
          <target state="translated">これで終わりです。それもトークンライザーの使い方の一つで、単語を数えるだけの方法とかね。</target>
        </trans-unit>
        <trans-unit id="1ca5e115b2a47f2d37422e0fdbcba3af6a5d68c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.cplusplus.com/reference/sstream/stringstream/&quot;&gt;stringstream&lt;/a&gt; can be convenient if you need to parse the string by non-space symbols:</source>
          <target state="translated">&lt;a href=&quot;http://www.cplusplus.com/reference/sstream/stringstream/&quot;&gt;stringstream&lt;/a&gt;は、スペース以外の記号で文字列を解析する必要がある場合に便利です。</target>
        </trans-unit>
        <trans-unit id="8996313f0643de07b9f50a3028ea25719a41ceed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;[\\s,]+&quot;&lt;/code&gt; checks for spaces (&lt;code&gt;\\s&lt;/code&gt;) and commas (&lt;code&gt;,&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&quot;[\\s,]+&quot;&lt;/code&gt; は、スペース（ &lt;code&gt;\\s&lt;/code&gt; ）とコンマ（ &lt;code&gt;,&lt;/code&gt; ）をチェックします。</target>
        </trans-unit>
        <trans-unit id="6440dc5c41f1e26931bf178eb530b739c544e1ac" translate="yes" xml:space="preserve">
          <source>The STL does not have such a method available already.</source>
          <target state="translated">STLには、そのような方法はすでに用意されていません。</target>
        </trans-unit>
        <trans-unit id="40333814fcb573c6e93835452764a1fd1397b1c5" translate="yes" xml:space="preserve">
          <source>The best solution I have right now is:</source>
          <target state="translated">私が今持っている最良の解決策は</target>
        </trans-unit>
        <trans-unit id="db7cbd55c362ea33208ce7a702e9447099a6f9c8" translate="yes" xml:space="preserve">
          <source>The goal was to make it similar to C#'s Split() method where splitting a string is as easy as:</source>
          <target state="translated">文字列を分割するのが簡単なC#のSplit()メソッドに似たようなものを目指しました。</target>
        </trans-unit>
        <trans-unit id="782c41e695434ee735cd0174735b03a0b9649dd4" translate="yes" xml:space="preserve">
          <source>The regex argument allows checking for multiple arguments (spaces, commas, etc.)</source>
          <target state="translated">正規表現引数は、複数の引数(スペース、カンマなど)をチェックすることができます。</target>
        </trans-unit>
        <trans-unit id="4d069b0b95a55b35a35a8b4b59549329da87bfe1" translate="yes" xml:space="preserve">
          <source>The string can be assumed to be composed of words separated by whitespace.</source>
          <target state="translated">文字列は、空白で区切られた単語で構成されていると仮定することができます。</target>
        </trans-unit>
        <trans-unit id="79cdca9b5545e633e42e3fbbe559a2da01c3450f" translate="yes" xml:space="preserve">
          <source>The toolkit has much more flexibility than this simple example shows but its utility in parsing a string into useful elements is incredible.</source>
          <target state="translated">このツールキットは、この単純な例で示されているよりもはるかに柔軟性がありますが、文字列を解析して有用な要素に変換する際の実用性は信じられないほどです。</target>
        </trans-unit>
        <trans-unit id="b9f02d4eee5583a864c93d46145ec1e7bda76eb3" translate="yes" xml:space="preserve">
          <source>Then instead of printing you can put it in a vector.</source>
          <target state="translated">そして、印刷するのではなく、ベクターに入れることができます。</target>
        </trans-unit>
        <trans-unit id="b9fb5bf7a2591fc1e35a2993ba89c0b9e5a42d7c" translate="yes" xml:space="preserve">
          <source>There is a function named &lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstring/strtok/&quot;&gt;&lt;code&gt;strtok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstring/strtok/&quot;&gt; &lt;code&gt;strtok&lt;/code&gt; &lt;/a&gt;という名前の関数があります。</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="593e97883525d037a4f64854c6d74628bb9c3388" translate="yes" xml:space="preserve">
          <source>This answer takes the string and puts it into a vector of strings. It uses the boost library.</source>
          <target state="translated">この答えは文字列を受け取り、それを文字列のベクトルに入れます。ブーストライブラリを使用しています。</target>
        </trans-unit>
        <trans-unit id="c631e791df3de892d29ad086f68ab5babfed0ac1" translate="yes" xml:space="preserve">
          <source>This approach might be even faster than the &lt;code&gt;stringstream&lt;/code&gt; approach. And since this is a generic template function it can be used to split other types of strings (wchar, etc. or UTF-8) using all kinds of delimiters.</source>
          <target state="translated">このアプローチは、 &lt;code&gt;stringstream&lt;/code&gt; アプローチよりもさらに高速な場合があります。 また、これは汎用テンプレート関数であるため、あらゆる種類の区切り文字を使用して、他のタイプの文字列（wcharなどまたはUTF-8）を分割するために使用できます。</target>
        </trans-unit>
        <trans-unit id="1b3c86d3a6486e114dab28e263dacbf6a3306c6b" translate="yes" xml:space="preserve">
          <source>This example gives the output -</source>
          <target state="translated">この例では、次のような出力が得られます。</target>
        </trans-unit>
        <trans-unit id="c769bf1282bd7c3be136c3c14a81ae993c455324" translate="yes" xml:space="preserve">
          <source>This is my favorite way to iterate through a string. You can do whatever you want per word.</source>
          <target state="translated">これは、文字列を反復処理するための私のお気に入りの方法です。単語単位で好きなようにできます。</target>
        </trans-unit>
        <trans-unit id="e22101f4f90eb21775516823db9e88caba9d9f7d" translate="yes" xml:space="preserve">
          <source>This is similar to Stack&amp;nbsp;Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c&quot;&gt;How do I tokenize a string in C++?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">これはスタックオーバーフローの質問に似て&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c&quot;&gt;います。C++で文字列をトークン化するにはどうすればよいですか？&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe7b02c0b7fcd609149b7d62126921ead63257e3" translate="yes" xml:space="preserve">
          <source>To keep empty entries (by default empties will be excluded):</source>
          <target state="translated">空のエントリを保持する(デフォルトでは空のエントリは除外されます)。</target>
        </trans-unit>
        <trans-unit id="93b920172684c22d81bc0d960c610f3b8f689afc" translate="yes" xml:space="preserve">
          <source>To use it with a vector of strings (Edit: Since someone pointed out not to inherit STL classes... hrmf ;) ) :</source>
          <target state="translated">文字列のベクトルで使用するには(編集:誰かがSTLクラスを継承しないように指摘したので...hrmf ;).</target>
        </trans-unit>
        <trans-unit id="2e911d11c79fa6e8338a0ec81f67859eba88f7d8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;std::stringstream&lt;/code&gt; as you have works perfectly fine, and do exactly what you wanted. If you're just looking for different way of doing things though, you can use &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find&quot;&gt;&lt;code&gt;std::find()&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find_first_of&quot;&gt;&lt;code&gt;std::find_first_of()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/substr&quot;&gt;&lt;code&gt;std::string::substr()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">あなたが持っているように &lt;code&gt;std::stringstream&lt;/code&gt; を使うことは完全にうまくいき、あなたが望んだことを正確に行います。 ただし、別の方法で&lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find&quot;&gt; &lt;code&gt;std::find()&lt;/code&gt; &lt;/a&gt;する場合は、 std :: find（） / &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find_first_of&quot;&gt; &lt;code&gt;std::find_first_of()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/substr&quot;&gt; &lt;code&gt;std::string::substr()&lt;/code&gt; &lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="7193f7a53cfe214ffe06f99029f6ee29bdef2653" translate="yes" xml:space="preserve">
          <source>What about this:</source>
          <target state="translated">これはどうなんだ?</target>
        </trans-unit>
        <trans-unit id="d713ca8d870cdfeb112abd654479d42242f3e918" translate="yes" xml:space="preserve">
          <source>Will output:</source>
          <target state="translated">出力します。</target>
        </trans-unit>
        <trans-unit id="5d81f64d4366d191a3ca38ee4fbfad99f8b4b7a2" translate="yes" xml:space="preserve">
          <source>Yet another flexible and fast way</source>
          <target state="translated">もう一つの柔軟で迅速な方法</target>
        </trans-unit>
        <trans-unit id="b8ad87877e333c9158dc06959d9121266c779f94" translate="yes" xml:space="preserve">
          <source>accepts multiple delimiters</source>
          <target state="translated">複数の区切り文字を受け付けます。</target>
        </trans-unit>
        <trans-unit id="de73eac0c305038f0437bc6a1f994a5a4379ed28" translate="yes" xml:space="preserve">
          <source>an</source>
          <target state="translated">an</target>
        </trans-unit>
        <trans-unit id="1028f44eb0896c7451136d0f6e58eb2118691f1d" translate="yes" xml:space="preserve">
          <source>can use any string as delimiter, also can be used with binary data (std::string supports binary data, including nulls)</source>
          <target state="translated">任意の文字列を区切り文字として使用できます。 バイナリデータと一緒に使用することもできます (std::string はヌルを含むバイナリデータをサポートしています)。</target>
        </trans-unit>
        <trans-unit id="da81ca0e477c7b07303dc4b796a57547c89b20ed" translate="yes" xml:space="preserve">
          <source>change all &lt;code&gt;sregex_token_iterator&lt;/code&gt; to &lt;code&gt;wsregex_token_iterator&lt;/code&gt;</source>
          <target state="translated">すべての &lt;code&gt;sregex_token_iterator&lt;/code&gt; を &lt;code&gt;wsregex_token_iterator&lt;/code&gt; に変更します</target>
        </trans-unit>
        <trans-unit id="2ba6f0eafff4f195043d9ca955616d7781f08d24" translate="yes" xml:space="preserve">
          <source>change all &lt;code&gt;std::regex&lt;/code&gt; to &lt;code&gt;std::wregex&lt;/code&gt;</source>
          <target state="translated">すべての &lt;code&gt;std::regex&lt;/code&gt; を &lt;code&gt;std::wregex&lt;/code&gt; 変更します</target>
        </trans-unit>
        <trans-unit id="65f449d134d2005340cabace69bd7e0efc454270" translate="yes" xml:space="preserve">
          <source>cstring</source>
          <target state="translated">cstring</target>
        </trans-unit>
        <trans-unit id="c3499c2729730a7f807efb8676a92dcb6f8a3f8f" translate="yes" xml:space="preserve">
          <source>example</source>
          <target state="translated">example</target>
        </trans-unit>
        <trans-unit id="8a1e7cb60b05f12ba21bd9eac3c5ab6bc4e4b943" translate="yes" xml:space="preserve">
          <source>ignores empty tokens (can easily be changed)</source>
          <target state="translated">空のトークンを無視します (簡単に変更できます)</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="3b59820c89e372d8d136229501895f9f8b1ff990" translate="yes" xml:space="preserve">
          <source>is generic</source>
          <target state="translated">が一般的</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="79620d35c76fd53c042f55457d80adf808303eb0" translate="yes" xml:space="preserve">
          <source>uses standard C++ (no boost)</source>
          <target state="translated">標準のC++を使用しています(ブーストはしていません</target>
        </trans-unit>
        <trans-unit id="a2cddef2f25af8d8750e5e21bb62b1d96d3f5636" translate="yes" xml:space="preserve">
          <source>using:</source>
          <target state="translated">using:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
