<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/236129">
    <body>
      <group id="236129">
        <trans-unit id="edcb0f44cc7dfb094ba440e1b7696a327b163cfe" translate="yes" xml:space="preserve">
          <source>... or create the &lt;code&gt;vector&lt;/code&gt; directly:</source>
          <target state="translated">...或直接创建 &lt;code&gt;vector&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="daf67907bca13add6181e99993d1c333b0460b26" translate="yes" xml:space="preserve">
          <source>A good point is that in &lt;code&gt;separators&lt;/code&gt; you can pass more than one character.</source>
          <target state="translated">很好的一点是，在 &lt;code&gt;separators&lt;/code&gt; 可以传递多个字符。</target>
        </trans-unit>
        <trans-unit id="3885f98f0b7796bc84d063ed9149766d457a3c80" translate="yes" xml:space="preserve">
          <source>A possible solution using Boost might be:</source>
          <target state="translated">使用Boost的一个可能的解决方案可能是:</target>
        </trans-unit>
        <trans-unit id="c3721b3abeee59011fa0e483bff445ac1cd186ad" translate="yes" xml:space="preserve">
          <source>Additionally it does not do the (extremely inefficient) return of result, but rather it passes the tokens as a reference, thus also allowing you to build up tokens using multiple calls if you so wished.</source>
          <target state="translated">此外,它不做结果的返回(效率极低),而是将令牌作为引用来传递,因此,如果你愿意的话,也可以使用多个调用来建立令牌。</target>
        </trans-unit>
        <trans-unit id="60f636a484c97d6136fbab261aac3f0769baa3e3" translate="yes" xml:space="preserve">
          <source>All it needs is &lt;code&gt;std::string&lt;/code&gt;... the rest are optional. It does not use streams or the boost library, but is flexible enough to be able to accept some of these foreign types naturally.</source>
          <target state="translated">它需要的只是 &lt;code&gt;std::string&lt;/code&gt; ...其余都是可选的。 它不使用流或boost库，但足够灵活以能够自然地接受其中一些外部类型。</target>
        </trans-unit>
        <trans-unit id="c9c6db698f80734384e3824d88d70b12ee11ad29" translate="yes" xml:space="preserve">
          <source>And just because it does not implement a &lt;code&gt;typedef&lt;/code&gt; called iterator or overload the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator does not mean it is bad code. I use C functions quite frequently. For example, &lt;a href=&quot;http://en.cppreference.com/w/c/io/fprintf&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/c/io/fscanf&quot;&gt;&lt;code&gt;scanf&lt;/code&gt;&lt;/a&gt; both are faster than &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cin&quot;&gt;&lt;code&gt;std::cin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cout&quot;&gt;&lt;code&gt;std::cout&lt;/code&gt;&lt;/a&gt; (significantly), the &lt;a href=&quot;http://en.cppreference.com/w/c/io/fopen&quot;&gt;&lt;code&gt;fopen&lt;/code&gt;&lt;/a&gt; syntax is a lot more friendly for binary types, and they also tend to produce smaller EXEs.</source>
          <target state="translated">仅仅因为它没有实现称为迭代器的 &lt;code&gt;typedef&lt;/code&gt; 或重载 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 操作符，并不意味着它是错误的代码。 我经常使用C函数。 例如， &lt;a href=&quot;http://en.cppreference.com/w/c/io/fprintf&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://en.cppreference.com/w/c/io/fscanf&quot;&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;/a&gt;都比&lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cin&quot;&gt; &lt;code&gt;std::cin&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cout&quot;&gt; &lt;code&gt;std::cout&lt;/code&gt; &lt;/a&gt;都快（明显）， &lt;a href=&quot;http://en.cppreference.com/w/c/io/fopen&quot;&gt; &lt;code&gt;fopen&lt;/code&gt; &lt;/a&gt;语法对二进制类型友好得多，并且它们也倾向于生成更小的EXE。</target>
        </trans-unit>
        <trans-unit id="6870791be3a59b2da2de603a0be80d00918affe3" translate="yes" xml:space="preserve">
          <source>Don't get sold on this &lt;strong&gt;&quot;Elegance over performance&quot;&lt;/strong&gt; deal.</source>
          <target state="translated">不要因为这项&lt;strong&gt;&amp;ldquo;绩效&lt;/strong&gt;上的&lt;strong&gt;优雅&amp;rdquo;&lt;/strong&gt;交易而被出售。</target>
        </trans-unit>
        <trans-unit id="12735fab994dcd7b5adae72726b9a46ab4afa992" translate="yes" xml:space="preserve">
          <source>Example code including convenient template:</source>
          <target state="translated">示例代码,包括方便的模板。</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">用例:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="2705b643a0f80d229f05dcb52e5d3ae40b25b515" translate="yes" xml:space="preserve">
          <source>For example, this splits &quot;AQueryTrades&quot; into &quot;A&quot;, &quot;Query&quot; and &quot;Trades&quot;.  The function works with narrow and wide strings. Because it respects the current locale it splits &quot;Raumfahrt&amp;Uuml;berwachungsVerordnung&quot; into &quot;Raumfahrt&quot;, &quot;&amp;Uuml;berwachungs&quot; and &quot;Verordnung&quot;.</source>
          <target state="translated">例如，这将&amp;ldquo; AQueryTrades&amp;rdquo;拆分为&amp;ldquo; A&amp;rdquo;，&amp;ldquo; Query&amp;rdquo;和&amp;ldquo; Trades&amp;rdquo;。 该函数适用于窄字符串和宽字符串。 因为它尊重当前语言环境，所以将&amp;ldquo;Raumfahrt&amp;Uuml;berwachungsVerordnung&amp;rdquo;分为&amp;ldquo; Raumfahrt&amp;rdquo;，&amp;ldquo;&amp;Uuml;berwachungs&amp;rdquo;和&amp;ldquo; Verordnung&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="de52debc28e040370100e81fc36a534b35a68c1a" translate="yes" xml:space="preserve">
          <source>For those with whom it does not sit well to sacrifice all efficiency for code size and see &quot;efficient&quot; as a type of elegance, the following should hit a sweet spot (and I think the template container class is an awesomely elegant addition.):</source>
          <target state="translated">对于那些不愿意为了代码的大小而牺牲所有的效率,并把 &quot;高效 &quot;看成是一种优雅的类型的人来说,下面的内容应该是一个很好的点(我认为模板容器类是一个非常优雅的补充)。</target>
        </trans-unit>
        <trans-unit id="f805399e635e59badeb8d25438ef59ca9d0781ff" translate="yes" xml:space="preserve">
          <source>For what it's worth, here's another way to extract tokens from an input string, relying only on standard library facilities. It's an example of the power and elegance behind the design of the STL.</source>
          <target state="translated">值得一提的是,这里有另一种从输入字符串中提取令牌的方法,只依靠标准的库设施。这是STL设计背后强大而优雅的一个例子。</target>
        </trans-unit>
        <trans-unit id="e6608506d839180b9e39fabbdc1e4720408a5c00" translate="yes" xml:space="preserve">
          <source>Get &lt;a href=&quot;http://www.boost.org/&quot;&gt;Boost&lt;/a&gt; ! : -)</source>
          <target state="translated">获取&lt;a href=&quot;http://www.boost.org/&quot;&gt;助推&lt;/a&gt; ！ ：-）</target>
        </trans-unit>
        <trans-unit id="829b1be11ab5027516a4c431a8773cbefd7348b8" translate="yes" xml:space="preserve">
          <source>Here is a split function that:</source>
          <target state="translated">这里有一个分裂函数,。</target>
        </trans-unit>
        <trans-unit id="4caf1473b9c810e10c38b1b0cdb53f2d370028f3" translate="yes" xml:space="preserve">
          <source>Here's a simple solution that uses only the standard regex library</source>
          <target state="translated">这里有一个简单的解决方案,它只使用标准的regex库。</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="a780475444a036f8986b27e4e0681b9956fc67b0" translate="yes" xml:space="preserve">
          <source>Here's another solution. It's compact and reasonably efficient:</source>
          <target state="translated">这里有另一个解决方案。它结构紧凑,效率合理。</target>
        </trans-unit>
        <trans-unit id="78859cf5ab12634a3057d2cf55d540f4dd043078" translate="yes" xml:space="preserve">
          <source>Here's another way of doing it..</source>
          <target state="translated">这是另一种方法。</target>
        </trans-unit>
        <trans-unit id="d30b6f4a9867c924c643828218cb2533ca6fed31" translate="yes" xml:space="preserve">
          <source>Heres a regex solution that only uses the standard regex library.  (I'm a little rusty, so there may be a few syntax errors, but this is at least the general idea)</source>
          <target state="translated">这是一个只使用标准的regex库的regex解决方案。(我有点生疏,所以可能会有一些语法上的错误,但至少这是个大概的想法)</target>
        </trans-unit>
        <trans-unit id="ad839725a134bd1b6392b1c21e805b0f7cc756d8" translate="yes" xml:space="preserve">
          <source>How do I iterate over the words of a string</source>
          <target state="translated">如何迭代一个字符串中的单词?</target>
        </trans-unit>
        <trans-unit id="8164d0d639169c81b13b17bc3d347e5df03097ea" translate="yes" xml:space="preserve">
          <source>However, you can either use C's &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/strtok&quot;&gt;&lt;code&gt;strtok()&lt;/code&gt;&lt;/a&gt; function by using the &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/c_str&quot;&gt;&lt;code&gt;std::string::c_str()&lt;/code&gt;&lt;/a&gt; member, or you can write your own. Here is a code sample I found after a quick Google search (&lt;strong&gt;&quot;STL string split&quot;&lt;/strong&gt;):</source>
          <target state="translated">但是，您可以通过使用&lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/c_str&quot;&gt; &lt;code&gt;std::string::c_str()&lt;/code&gt; &lt;/a&gt;成员来使用C的&lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/strtok&quot;&gt; &lt;code&gt;strtok()&lt;/code&gt; &lt;/a&gt;函数，也可以编写自己的函数。 这是我在快速Google搜索后找到的代码示例（ &lt;strong&gt;&amp;ldquo; STL字符串拆分&amp;rdquo;&lt;/strong&gt; ）：</target>
        </trans-unit>
        <trans-unit id="edbd5b3edc642567da5a827b6b2f8804da091757" translate="yes" xml:space="preserve">
          <source>I have a 2 lines solution to this problem:</source>
          <target state="translated">对于这个问题,我有2条线的解决方案。</target>
        </trans-unit>
        <trans-unit id="d9d3bf7ae6779586aa4c434765f7f1f0997b6b1f" translate="yes" xml:space="preserve">
          <source>I hope someone else can find this as useful as I do.</source>
          <target state="translated">我希望别人也能像我一样觉得有用。</target>
        </trans-unit>
        <trans-unit id="3a73403c1957cc0e33fdc441ae726cc999f4942c" translate="yes" xml:space="preserve">
          <source>I like the following because it puts the results into a vector, supports a string as a delim and gives control over keeping empty values. But, it doesn't look as good then.</source>
          <target state="translated">我喜欢下面的方法,因为它把结果放到一个向量中,支持字符串作为delim,并且可以控制保留空值。但是,这样的话就没有那么好看了。</target>
        </trans-unit>
        <trans-unit id="70af1c7cf8dbf905cd7d9ae6fe84ef064af7b8b3" translate="yes" xml:space="preserve">
          <source>I like to use the boost/regex methods for this task since they provide maximum flexibility for specifying the splitting criteria.</source>
          <target state="translated">在这个任务中,我喜欢使用bootregex方法,因为它们为指定分割标准提供了最大的灵活性。</target>
        </trans-unit>
        <trans-unit id="a3e013d54b198746029363a080be9d65c71513bc" translate="yes" xml:space="preserve">
          <source>I made this because I needed an easy way to split strings and c-based strings... Hopefully someone else can find it useful as well. Also it doesn't rely on tokens and you can use fields as delimiters, which is another key I needed.</source>
          <target state="translated">我做这个是因为我需要一个简单的方法来拆分字符串和基于C的字符串......希望别人也能找到它的用处。此外,它不依赖令牌,你可以使用字段作为分隔符,这是我需要的另一个关键。</target>
        </trans-unit>
        <trans-unit id="01bc5ba0fa755484bd526b58e86a0cea76a28bf8" translate="yes" xml:space="preserve">
          <source>I use this to split string by a delimiter. The first puts the results in a pre-constructed vector, the second returns a new vector.</source>
          <target state="translated">我用这个来用分界符分割字符串。前者将结果放在一个预构建的向量中,后者返回一个新的向量。</target>
        </trans-unit>
        <trans-unit id="d02b633661d0af2f5aac614aedf4fd95b95fc7fc" translate="yes" xml:space="preserve">
          <source>I usually choose to use &lt;code&gt;std::vector&amp;lt;std::string&amp;gt;&lt;/code&gt; types as my second parameter (&lt;code&gt;ContainerT&lt;/code&gt;)... but &lt;code&gt;list&amp;lt;&amp;gt;&lt;/code&gt; is way faster than &lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt; for when direct access is not needed, and you can even create your own string class and use something like &lt;code&gt;std::list&amp;lt;subString&amp;gt;&lt;/code&gt; where &lt;code&gt;subString&lt;/code&gt; does not do any copies for incredible speed increases.</source>
          <target state="translated">我通常选择使用 &lt;code&gt;std::vector&amp;lt;std::string&amp;gt;&lt;/code&gt; 类型作为第二个参数（ &lt;code&gt;ContainerT&lt;/code&gt; ）...但是在不需要直接访问的情况下， &lt;code&gt;list&amp;lt;&amp;gt;&lt;/code&gt; 比 &lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt; 快得多，甚至可以创建您自己的字符串类，并使用类似 &lt;code&gt;std::list&amp;lt;subString&amp;gt;&lt;/code&gt; ，其中 &lt;code&gt;subString&lt;/code&gt; 不执行任何复制以实现惊人的速度提高。</target>
        </trans-unit>
        <trans-unit id="98ba3b0af09fe29627f5fe02ee9af975d3e8d35b" translate="yes" xml:space="preserve">
          <source>I usually only check to split on spaces and commas, so I also have this default function:</source>
          <target state="translated">我通常只在空格和逗号上检查分割,所以我也有这个默认功能。</target>
        </trans-unit>
        <trans-unit id="8e91045629e7a5c9e98dde7928f173bbd7764caa" translate="yes" xml:space="preserve">
          <source>I'm sure there's improvements that can be made to even further improve its elegance and please do by all means</source>
          <target state="translated">我相信在这里可以做一些改进,以进一步提高它的优雅程度,请大家尽一切可能去做。</target>
        </trans-unit>
        <trans-unit id="a3b5e6ebe32255aa5a8cbb511d5478625952fbff" translate="yes" xml:space="preserve">
          <source>I'm trying to iterate over the words of a string.</source>
          <target state="translated">我在尝试着迭代一串串的单词。</target>
        </trans-unit>
        <trans-unit id="e5807a479143bdef2e06556aa0b30259912e246a" translate="yes" xml:space="preserve">
          <source>I've rolled my own using strtok and used boost to split a string.  The best method I have found is the &lt;a href=&quot;http://www.partow.net/programming/strtk/&quot;&gt;C++ String Toolkit Library&lt;/a&gt;.  It is incredibly flexible and fast.</source>
          <target state="translated">我使用strtok滚动了自己的文件，并使用boost来拆分字符串。 我发现的最佳方法是&lt;a href=&quot;http://www.partow.net/programming/strtk/&quot;&gt;C ++ String Toolkit库&lt;/a&gt; 。 它非常灵活和快速。</target>
        </trans-unit>
        <trans-unit id="80bd129398d2a58cb60b25313fb43865351f69bf" translate="yes" xml:space="preserve">
          <source>If splitting a string at multiple delimiters while skipping empty tokens is desired, this version may be used:</source>
          <target state="translated">如果需要在跳过空令牌的同时在多个分隔符处分割字符串,可以使用这个版本。</target>
        </trans-unit>
        <trans-unit id="7589cbcf380a78c9803a11402f160a9053a8278d" translate="yes" xml:space="preserve">
          <source>If you have questions about the code sample, leave a comment and I will explain.</source>
          <target state="translated">如果你对代码样本有疑问,请留言,我会给你解释。</target>
        </trans-unit>
        <trans-unit id="4af4cc4098db3af77c2383b7caef397b8c5d31c3" translate="yes" xml:space="preserve">
          <source>If you like to use boost, but want to use a whole string as delimiter (instead of single characters as in most of the previously proposed solutions), you can use the &lt;code&gt;boost_split_iterator&lt;/code&gt;.</source>
          <target state="translated">如果您想使用boost，但想使用整个字符串作为定界符（而不是像大多数先前提出的解决方案中那样使用单个字符），则可以使用 &lt;code&gt;boost_split_iterator&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a644a073e06e3986597fbf1fcf4f2d6a9c572e35" translate="yes" xml:space="preserve">
          <source>Instead of copying the extracted tokens to an output stream, one could insert them into a container, using the same generic &lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; algorithm.</source>
          <target state="translated">与其将提取的令牌复制到输出流，还可以使用相同的通用&lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt;算法将其插入容器。</target>
        </trans-unit>
        <trans-unit id="06e57f321253a6ce49b846a26ffcbdfdd422b91f" translate="yes" xml:space="preserve">
          <source>Is there a more elegant way to do this?</source>
          <target state="translated">有没有更优雅的方法?</target>
        </trans-unit>
        <trans-unit id="ae8fe7d96f18b204a67c12bb20b01019014e820d" translate="yes" xml:space="preserve">
          <source>It can also be easily expanded to skip empty tokens:</source>
          <target state="translated">它还可以很容易地扩展到跳过空令牌。</target>
        </trans-unit>
        <trans-unit id="e2ba82430e6d8796d64675e8c1fa0c82bcbabce7" translate="yes" xml:space="preserve">
          <source>It can easily be templatised to handle string separators, wide strings, etc.</source>
          <target state="translated">它可以很容易地模板化,以处理字符串分离器、宽字符串等。</target>
        </trans-unit>
        <trans-unit id="28d90795bfb34c48b119d7f6cb9d197ea65a4073" translate="yes" xml:space="preserve">
          <source>It's more than double as fast as the fastest tokenize on this page and almost 5 times faster than some others. Also with the perfect parameter types you can eliminate all string and list copies for additional speed increases.</source>
          <target state="translated">它的速度是本页面上最快的tokenize的两倍以上,几乎是其他一些tokenize的5倍。同时通过完美的参数类型,你可以消除所有的字符串和列表副本,以获得额外的速度提升。</target>
        </trans-unit>
        <trans-unit id="69d1271bac1d9c309e788d9ea67be98ca0e136bf" translate="yes" xml:space="preserve">
          <source>Lastly it allows you to specify whether to trim empty tokens from the results via a last optional parameter.</source>
          <target state="translated">最后,它允许你通过最后一个可选参数指定是否从结果中修剪空令牌。</target>
        </trans-unit>
        <trans-unit id="a1630c87ca12f86b482c8b5c22149b511943f7cb" translate="yes" xml:space="preserve">
          <source>Limited by imagination ;)</source>
          <target state="translated">受限于想象力;)</target>
        </trans-unit>
        <trans-unit id="2fe5047d67353f0846aa94b0fe23a67a2b32150c" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;std::upper&lt;/code&gt; should be really passed as function template argument. Then the more generalized from of this function can split at delimiters like &lt;code&gt;&quot;,&quot;&lt;/code&gt;, &lt;code&gt;&quot;;&quot;&lt;/code&gt; or &lt;code&gt;&quot; &quot;&lt;/code&gt; too.</source>
          <target state="translated">注意 &lt;code&gt;std::upper&lt;/code&gt; 应该真正作为函数模板参数传递。 然后，此函数的更广泛的缩写可以在定界符（如 &lt;code&gt;&quot;,&quot;&lt;/code&gt; ， &lt;code&gt;&quot;;&quot;&lt;/code&gt; 处拆分。 或 &lt;code&gt;&quot; &quot;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3af42b55fb6cb79a028f48fc9dddef7a1b09c406" translate="yes" xml:space="preserve">
          <source>Note that I'm not interested in C string functions or that kind of character manipulation/access. Also, please give precedence to elegance over efficiency in your answer.</source>
          <target state="translated">请注意,我对C语言的字符串函数或那种字符操作access不感兴趣。另外,请你在回答时优先考虑优雅而不是效率。</target>
        </trans-unit>
        <trans-unit id="1e2cb5802a91f46a1cfa9c5a877feee94d00ecb2" translate="yes" xml:space="preserve">
          <source>Note that splitting &lt;code&gt;&quot;&quot;&lt;/code&gt; results in a single empty string and splitting &lt;code&gt;&quot;,&quot;&lt;/code&gt; (ie. sep) results in two empty strings.</source>
          <target state="translated">请注意，分割 &lt;code&gt;&quot;&quot;&lt;/code&gt; 导致一个空字符串，分割 &lt;code&gt;&quot;,&quot;&lt;/code&gt; （即sep）会导致两个空字符串。</target>
        </trans-unit>
        <trans-unit id="2eed498a91867681e33df9807e93e65e867e0bff" translate="yes" xml:space="preserve">
          <source>Note that this solution does not skip empty tokens, so the following will find 4 items, one of which is empty:</source>
          <target state="translated">注意,这个方案不会跳过空令牌,所以下面会找到4个项目,其中一个是空的。</target>
        </trans-unit>
        <trans-unit id="fe5714fb716282b1a9a1fc9fcd3bd604250fb787" translate="yes" xml:space="preserve">
          <source>Note, if you want to split &lt;code&gt;wstring&lt;/code&gt; instead of &lt;code&gt;string&lt;/code&gt;,</source>
          <target state="translated">请注意，如果您想分割 &lt;code&gt;wstring&lt;/code&gt; 而不是 &lt;code&gt;string&lt;/code&gt; ，</target>
        </trans-unit>
        <trans-unit id="d172c279b9365bde131c6c6226972701d76e01c5" translate="yes" xml:space="preserve">
          <source>Note, you might also want to take the string argument by reference, depending on your compiler.</source>
          <target state="translated">注意,你可能也想通过引用来获取字符串参数,这取决于你的编译器。</target>
        </trans-unit>
        <trans-unit id="94d45ad4e48fcad61e269a1e3312579ec200054b" translate="yes" xml:space="preserve">
          <source>Of course, Boost has a &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html#id3483755&quot;&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt; that works partially like that. And, if by 'white-space', you really do mean any type of white-space, using Boost's split with &lt;code&gt;is_any_of()&lt;/code&gt; works great.</source>
          <target state="translated">当然，Boost具有一个&lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html#id3483755&quot;&gt; &lt;code&gt;split()&lt;/code&gt; &lt;/a&gt; ，部分工作原理是这样的。 而且，如果使用&amp;ldquo;空白&amp;rdquo;，则实际上意味着任何类型的空白，将Boost的split与 &lt;code&gt;is_any_of()&lt;/code&gt; 一起使用效果很好。</target>
        </trans-unit>
        <trans-unit id="feefe8647d3c18455c7284d73e5e9b156c6be204" translate="yes" xml:space="preserve">
          <source>Recently I had to split a camel-cased word into subwords.  There are no delimiters, just upper characters.</source>
          <target state="translated">最近我要把一个骆驼号的字拆成子字。没有分界符,只有上位字。</target>
        </trans-unit>
        <trans-unit id="58fd97bc0d3ae9571cb48bf3cbc2a8e1eca6001f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">有关详细信息，请参见&lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html&quot;&gt;文档&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="b8776bac563a3c1a8c473120ed91905a5d046e8c" translate="yes" xml:space="preserve">
          <source>Short and elegant</source>
          <target state="translated">简洁而优雅</target>
        </trans-unit>
        <trans-unit id="3f5a90e2a6ed10327b773e990c6e9c0718937bb8" translate="yes" xml:space="preserve">
          <source>So far I used the one in &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_C++_Libraries&quot;&gt;Boost&lt;/a&gt;, but I needed something that doesn't depends on it, so I came to this:</source>
          <target state="translated">到目前为止，我在&lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_C++_Libraries&quot;&gt;Boost中&lt;/a&gt;使用了一个，但是我需要一些不依赖它的东西，所以我来了：</target>
        </trans-unit>
        <trans-unit id="567e164602261d048d22e25b3917128629c66b84" translate="yes" xml:space="preserve">
          <source>StringSplitter.cpp:</source>
          <target state="translated">StringSplitter.cpp:</target>
        </trans-unit>
        <trans-unit id="fb0c5461cacf796c6e710a8542a3699900e2261b" translate="yes" xml:space="preserve">
          <source>StringSplitter.hpp:</source>
          <target state="translated">StringSplitter.hpp:</target>
        </trans-unit>
        <trans-unit id="87fdba3e4c7e285121516a72fc35fd71bc4a6cde" translate="yes" xml:space="preserve">
          <source>Taken from: &lt;a href=&quot;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&quot;&gt;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&lt;/a&gt;</source>
          <target state="translated">摘自： &lt;a href=&quot;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&quot;&gt;http&lt;/a&gt; : //oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html</target>
        </trans-unit>
        <trans-unit id="27ce8f54f6936c89f8e51e510065e4a26b283c12" translate="yes" xml:space="preserve">
          <source>That's it! And that's just one way to use the tokenizer, like how to just 
count words:</source>
          <target state="translated">就是这样的! 而这只是代币器的一种使用方法,比如怎么只是数字。</target>
        </trans-unit>
        <trans-unit id="1ca5e115b2a47f2d37422e0fdbcba3af6a5d68c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.cplusplus.com/reference/sstream/stringstream/&quot;&gt;stringstream&lt;/a&gt; can be convenient if you need to parse the string by non-space symbols:</source>
          <target state="translated">如果您需要按非空格符号解析字符串，则&lt;a href=&quot;http://www.cplusplus.com/reference/sstream/stringstream/&quot;&gt;stringstream&lt;/a&gt;可能会很方便：</target>
        </trans-unit>
        <trans-unit id="8996313f0643de07b9f50a3028ea25719a41ceed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;[\\s,]+&quot;&lt;/code&gt; checks for spaces (&lt;code&gt;\\s&lt;/code&gt;) and commas (&lt;code&gt;,&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&quot;[\\s,]+&quot;&lt;/code&gt; 检查空格（ &lt;code&gt;\\s&lt;/code&gt; ）和逗号（ &lt;code&gt;,&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="6440dc5c41f1e26931bf178eb530b739c544e1ac" translate="yes" xml:space="preserve">
          <source>The STL does not have such a method available already.</source>
          <target state="translated">STL目前还没有这样的方法。</target>
        </trans-unit>
        <trans-unit id="40333814fcb573c6e93835452764a1fd1397b1c5" translate="yes" xml:space="preserve">
          <source>The best solution I have right now is:</source>
          <target state="translated">我现在最好的解决办法是:</target>
        </trans-unit>
        <trans-unit id="db7cbd55c362ea33208ce7a702e9447099a6f9c8" translate="yes" xml:space="preserve">
          <source>The goal was to make it similar to C#'s Split() method where splitting a string is as easy as:</source>
          <target state="translated">目标是使其类似于C#的Split()方法,在这个方法中,拆分字符串就像拆分字符串一样简单。</target>
        </trans-unit>
        <trans-unit id="782c41e695434ee735cd0174735b03a0b9649dd4" translate="yes" xml:space="preserve">
          <source>The regex argument allows checking for multiple arguments (spaces, commas, etc.)</source>
          <target state="translated">regex参数允许检查多个参数(空格、逗号等)。</target>
        </trans-unit>
        <trans-unit id="4d069b0b95a55b35a35a8b4b59549329da87bfe1" translate="yes" xml:space="preserve">
          <source>The string can be assumed to be composed of words separated by whitespace.</source>
          <target state="translated">可以认为这个字符串是由用空格隔开的单词组成。</target>
        </trans-unit>
        <trans-unit id="79cdca9b5545e633e42e3fbbe559a2da01c3450f" translate="yes" xml:space="preserve">
          <source>The toolkit has much more flexibility than this simple example shows but its utility in parsing a string into useful elements is incredible.</source>
          <target state="translated">该工具箱的灵活性比这个简单的例子要大得多,但它在将字符串解析成有用的元素方面的实用性是令人难以置信的。</target>
        </trans-unit>
        <trans-unit id="b9f02d4eee5583a864c93d46145ec1e7bda76eb3" translate="yes" xml:space="preserve">
          <source>Then instead of printing you can put it in a vector.</source>
          <target state="translated">然后你可以把它放在矢量中,而不是打印出来。</target>
        </trans-unit>
        <trans-unit id="b9fb5bf7a2591fc1e35a2993ba89c0b9e5a42d7c" translate="yes" xml:space="preserve">
          <source>There is a function named &lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstring/strtok/&quot;&gt;&lt;code&gt;strtok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">有一个名为&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstring/strtok/&quot;&gt; &lt;code&gt;strtok&lt;/code&gt; &lt;/a&gt;的函数。</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="593e97883525d037a4f64854c6d74628bb9c3388" translate="yes" xml:space="preserve">
          <source>This answer takes the string and puts it into a vector of strings. It uses the boost library.</source>
          <target state="translated">这个答案会把字符串放到一个字符串向量中。它使用了 boost 库。</target>
        </trans-unit>
        <trans-unit id="c631e791df3de892d29ad086f68ab5babfed0ac1" translate="yes" xml:space="preserve">
          <source>This approach might be even faster than the &lt;code&gt;stringstream&lt;/code&gt; approach. And since this is a generic template function it can be used to split other types of strings (wchar, etc. or UTF-8) using all kinds of delimiters.</source>
          <target state="translated">这种方法可能比 &lt;code&gt;stringstream&lt;/code&gt; 方法甚至更快。 由于这是一个通用的模板函数，因此可以使用各种分隔符将其拆分为其他类型的字符串（wchar等或UTF-8）。</target>
        </trans-unit>
        <trans-unit id="1b3c86d3a6486e114dab28e263dacbf6a3306c6b" translate="yes" xml:space="preserve">
          <source>This example gives the output -</source>
          <target state="translated">这个例子给出的输出是</target>
        </trans-unit>
        <trans-unit id="c769bf1282bd7c3be136c3c14a81ae993c455324" translate="yes" xml:space="preserve">
          <source>This is my favorite way to iterate through a string. You can do whatever you want per word.</source>
          <target state="translated">这是我最喜欢的迭代字符串的方法。你可以对每个字做任何你想做的事情。</target>
        </trans-unit>
        <trans-unit id="e22101f4f90eb21775516823db9e88caba9d9f7d" translate="yes" xml:space="preserve">
          <source>This is similar to Stack&amp;nbsp;Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c&quot;&gt;How do I tokenize a string in C++?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">这类似于堆栈溢出问题， &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c&quot;&gt;如何在C ++中标记字符串？&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="fe7b02c0b7fcd609149b7d62126921ead63257e3" translate="yes" xml:space="preserve">
          <source>To keep empty entries (by default empties will be excluded):</source>
          <target state="translated">要保留空的条目(默认为空的将被排除)。</target>
        </trans-unit>
        <trans-unit id="93b920172684c22d81bc0d960c610f3b8f689afc" translate="yes" xml:space="preserve">
          <source>To use it with a vector of strings (Edit: Since someone pointed out not to inherit STL classes... hrmf ;) ) :</source>
          <target state="translated">要使用它的字符串向量(编辑:由于有人指出不要继承STL类.....hrmf;)。</target>
        </trans-unit>
        <trans-unit id="2e911d11c79fa6e8338a0ec81f67859eba88f7d8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;std::stringstream&lt;/code&gt; as you have works perfectly fine, and do exactly what you wanted. If you're just looking for different way of doing things though, you can use &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find&quot;&gt;&lt;code&gt;std::find()&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find_first_of&quot;&gt;&lt;code&gt;std::find_first_of()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/substr&quot;&gt;&lt;code&gt;std::string::substr()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">使用 &lt;code&gt;std::stringstream&lt;/code&gt; 可以正常工作，并且完全按照您的要求进行。 如果您只是在寻找不同的处理方式，则可以使用&lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find&quot;&gt; &lt;code&gt;std::find()&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find_first_of&quot;&gt; &lt;code&gt;std::find_first_of()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/substr&quot;&gt; &lt;code&gt;std::string::substr()&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="7193f7a53cfe214ffe06f99029f6ee29bdef2653" translate="yes" xml:space="preserve">
          <source>What about this:</source>
          <target state="translated">那这个呢?</target>
        </trans-unit>
        <trans-unit id="d713ca8d870cdfeb112abd654479d42242f3e918" translate="yes" xml:space="preserve">
          <source>Will output:</source>
          <target state="translated">将输出。</target>
        </trans-unit>
        <trans-unit id="5d81f64d4366d191a3ca38ee4fbfad99f8b4b7a2" translate="yes" xml:space="preserve">
          <source>Yet another flexible and fast way</source>
          <target state="translated">另一种灵活、快捷的方式</target>
        </trans-unit>
        <trans-unit id="b8ad87877e333c9158dc06959d9121266c779f94" translate="yes" xml:space="preserve">
          <source>accepts multiple delimiters</source>
          <target state="translated">接受多个分界符</target>
        </trans-unit>
        <trans-unit id="de73eac0c305038f0437bc6a1f994a5a4379ed28" translate="yes" xml:space="preserve">
          <source>an</source>
          <target state="translated">an</target>
        </trans-unit>
        <trans-unit id="1028f44eb0896c7451136d0f6e58eb2118691f1d" translate="yes" xml:space="preserve">
          <source>can use any string as delimiter, also can be used with binary data (std::string supports binary data, including nulls)</source>
          <target state="translated">可以使用任何字符串作为分隔符,也可以使用二进制数据(std::string支持二进制数据,包括nulls)。</target>
        </trans-unit>
        <trans-unit id="da81ca0e477c7b07303dc4b796a57547c89b20ed" translate="yes" xml:space="preserve">
          <source>change all &lt;code&gt;sregex_token_iterator&lt;/code&gt; to &lt;code&gt;wsregex_token_iterator&lt;/code&gt;</source>
          <target state="translated">将所有 &lt;code&gt;sregex_token_iterator&lt;/code&gt; 更改为 &lt;code&gt;wsregex_token_iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ba6f0eafff4f195043d9ca955616d7781f08d24" translate="yes" xml:space="preserve">
          <source>change all &lt;code&gt;std::regex&lt;/code&gt; to &lt;code&gt;std::wregex&lt;/code&gt;</source>
          <target state="translated">将所有 &lt;code&gt;std::regex&lt;/code&gt; 更改为 &lt;code&gt;std::wregex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65f449d134d2005340cabace69bd7e0efc454270" translate="yes" xml:space="preserve">
          <source>cstring</source>
          <target state="translated">cstring</target>
        </trans-unit>
        <trans-unit id="c3499c2729730a7f807efb8676a92dcb6f8a3f8f" translate="yes" xml:space="preserve">
          <source>example</source>
          <target state="translated">example</target>
        </trans-unit>
        <trans-unit id="8a1e7cb60b05f12ba21bd9eac3c5ab6bc4e4b943" translate="yes" xml:space="preserve">
          <source>ignores empty tokens (can easily be changed)</source>
          <target state="translated">忽略空令牌(可轻易更改)</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="3b59820c89e372d8d136229501895f9f8b1ff990" translate="yes" xml:space="preserve">
          <source>is generic</source>
          <target state="translated">是通用的</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="79620d35c76fd53c042f55457d80adf808303eb0" translate="yes" xml:space="preserve">
          <source>uses standard C++ (no boost)</source>
          <target state="translated">使用标准的C++(无升压</target>
        </trans-unit>
        <trans-unit id="a2cddef2f25af8d8750e5e21bb62b1d96d3f5636" translate="yes" xml:space="preserve">
          <source>using:</source>
          <target state="translated">using:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
