<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/236129">
    <body>
      <group id="236129">
        <trans-unit id="edcb0f44cc7dfb094ba440e1b7696a327b163cfe" translate="yes" xml:space="preserve">
          <source>... or create the &lt;code&gt;vector&lt;/code&gt; directly:</source>
          <target state="translated">... 또는 &lt;code&gt;vector&lt;/code&gt; 직접 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="daf67907bca13add6181e99993d1c333b0460b26" translate="yes" xml:space="preserve">
          <source>A good point is that in &lt;code&gt;separators&lt;/code&gt; you can pass more than one character.</source>
          <target state="translated">좋은 점은 &lt;code&gt;separators&lt;/code&gt; 에서 두 개 이상의 문자를 전달할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3885f98f0b7796bc84d063ed9149766d457a3c80" translate="yes" xml:space="preserve">
          <source>A possible solution using Boost might be:</source>
          <target state="translated">Boost를 사용하여 가능한 해결책은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3721b3abeee59011fa0e483bff445ac1cd186ad" translate="yes" xml:space="preserve">
          <source>Additionally it does not do the (extremely inefficient) return of result, but rather it passes the tokens as a reference, thus also allowing you to build up tokens using multiple calls if you so wished.</source>
          <target state="translated">또한 결과의 (매우 비효율적 인) 반환을 수행하지는 않지만 대신 토큰을 참조로 전달하므로 원하는 경우 여러 호출을 사용하여 토큰을 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="60f636a484c97d6136fbab261aac3f0769baa3e3" translate="yes" xml:space="preserve">
          <source>All it needs is &lt;code&gt;std::string&lt;/code&gt;... the rest are optional. It does not use streams or the boost library, but is flexible enough to be able to accept some of these foreign types naturally.</source>
          <target state="translated">필요한 것은 &lt;code&gt;std::string&lt;/code&gt; ... 나머지는 선택 사항입니다. 스트림이나 부스트 라이브러리를 사용하지 않지만 이러한 외부 유형 중 일부를 자연스럽게 수용 할 수있을 정도로 유연합니다.</target>
        </trans-unit>
        <trans-unit id="c9c6db698f80734384e3824d88d70b12ee11ad29" translate="yes" xml:space="preserve">
          <source>And just because it does not implement a &lt;code&gt;typedef&lt;/code&gt; called iterator or overload the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator does not mean it is bad code. I use C functions quite frequently. For example, &lt;a href=&quot;http://en.cppreference.com/w/c/io/fprintf&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/c/io/fscanf&quot;&gt;&lt;code&gt;scanf&lt;/code&gt;&lt;/a&gt; both are faster than &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cin&quot;&gt;&lt;code&gt;std::cin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cout&quot;&gt;&lt;code&gt;std::cout&lt;/code&gt;&lt;/a&gt; (significantly), the &lt;a href=&quot;http://en.cppreference.com/w/c/io/fopen&quot;&gt;&lt;code&gt;fopen&lt;/code&gt;&lt;/a&gt; syntax is a lot more friendly for binary types, and they also tend to produce smaller EXEs.</source>
          <target state="translated">그리고 iterator 또는 type &amp;lt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 연산자라는 &lt;code&gt;typedef&lt;/code&gt; 를 구현하지 않아서 코드가 잘못되었다는 의미는 아닙니다. C 함수를 자주 사용합니다. 예를 들어, &lt;a href=&quot;http://en.cppreference.com/w/c/io/fprintf&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;http://en.cppreference.com/w/c/io/fscanf&quot;&gt; &lt;code&gt;scanf&lt;/code&gt; 는&lt;/a&gt; 모두 &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cin&quot;&gt; &lt;code&gt;std::cin&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cout&quot;&gt; &lt;code&gt;std::cout&lt;/code&gt; &lt;/a&gt; (상당히)보다 빠르며 &lt;a href=&quot;http://en.cppreference.com/w/c/io/fopen&quot;&gt; &lt;code&gt;fopen&lt;/code&gt; &lt;/a&gt; 구문은 이진 형식에 훨씬 더 친숙하며 더 작은 EXE를 생성하는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6870791be3a59b2da2de603a0be80d00918affe3" translate="yes" xml:space="preserve">
          <source>Don't get sold on this &lt;strong&gt;&quot;Elegance over performance&quot;&lt;/strong&gt; deal.</source>
          <target state="translated">이 &lt;strong&gt;&quot;성능&lt;/strong&gt; 에 대한 &lt;strong&gt;우아함&quot;&lt;/strong&gt; 거래에서 판매하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="12735fab994dcd7b5adae72726b9a46ab4afa992" translate="yes" xml:space="preserve">
          <source>Example code including convenient template:</source>
          <target state="translated">편리한 템플릿을 포함한 예제 코드 :</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="2705b643a0f80d229f05dcb52e5d3ae40b25b515" translate="yes" xml:space="preserve">
          <source>For example, this splits &quot;AQueryTrades&quot; into &quot;A&quot;, &quot;Query&quot; and &quot;Trades&quot;.  The function works with narrow and wide strings. Because it respects the current locale it splits &quot;Raumfahrt&amp;Uuml;berwachungsVerordnung&quot; into &quot;Raumfahrt&quot;, &quot;&amp;Uuml;berwachungs&quot; and &quot;Verordnung&quot;.</source>
          <target state="translated">예를 들어 &quot;AQueryTrades&quot;를 &quot;A&quot;, &quot;Query&quot;및 &quot;Trades&quot;로 분할합니다. 이 기능은 좁고 넓은 문자열에서 작동합니다. 현재 로캘을 존중하기 때문에 &quot;Raumfahrt&amp;Uuml;berwachungsVerordnung&quot;을 &quot;Raumfahrt&quot;, &quot;&amp;Uuml;berwachungs&quot;및 &quot;Verordnung&quot;으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="de52debc28e040370100e81fc36a534b35a68c1a" translate="yes" xml:space="preserve">
          <source>For those with whom it does not sit well to sacrifice all efficiency for code size and see &quot;efficient&quot; as a type of elegance, the following should hit a sweet spot (and I think the template container class is an awesomely elegant addition.):</source>
          <target state="translated">코드 크기의 모든 효율성을 희생하고 우아함의 일종으로 &quot;효율적인&quot;것을 보는 것이 좋지 않은 사람들에게는 다음과 같은 장점이 있습니다 (템플릿 컨테이너 클래스는 놀랍도록 우아한 추가라고 생각합니다).</target>
        </trans-unit>
        <trans-unit id="f805399e635e59badeb8d25438ef59ca9d0781ff" translate="yes" xml:space="preserve">
          <source>For what it's worth, here's another way to extract tokens from an input string, relying only on standard library facilities. It's an example of the power and elegance behind the design of the STL.</source>
          <target state="translated">가치있는 것을 위해 표준 라이브러리 기능에만 의존하여 입력 문자열에서 토큰을 추출하는 또 다른 방법이 있습니다. STL 디자인의 힘과 우아함의 예입니다.</target>
        </trans-unit>
        <trans-unit id="e6608506d839180b9e39fabbdc1e4720408a5c00" translate="yes" xml:space="preserve">
          <source>Get &lt;a href=&quot;http://www.boost.org/&quot;&gt;Boost&lt;/a&gt; ! : -)</source>
          <target state="translated">&lt;a href=&quot;http://www.boost.org/&quot;&gt;부스트를 잡아&lt;/a&gt; ! :-)</target>
        </trans-unit>
        <trans-unit id="829b1be11ab5027516a4c431a8773cbefd7348b8" translate="yes" xml:space="preserve">
          <source>Here is a split function that:</source>
          <target state="translated">다음은 스플릿 기능입니다.</target>
        </trans-unit>
        <trans-unit id="4caf1473b9c810e10c38b1b0cdb53f2d370028f3" translate="yes" xml:space="preserve">
          <source>Here's a simple solution that uses only the standard regex library</source>
          <target state="translated">표준 정규식 라이브러리 만 사용하는 간단한 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a780475444a036f8986b27e4e0681b9956fc67b0" translate="yes" xml:space="preserve">
          <source>Here's another solution. It's compact and reasonably efficient:</source>
          <target state="translated">다른 해결책이 있습니다. 작고 합리적으로 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="78859cf5ab12634a3057d2cf55d540f4dd043078" translate="yes" xml:space="preserve">
          <source>Here's another way of doing it..</source>
          <target state="translated">또 다른 방법이 있습니다 ..</target>
        </trans-unit>
        <trans-unit id="d30b6f4a9867c924c643828218cb2533ca6fed31" translate="yes" xml:space="preserve">
          <source>Heres a regex solution that only uses the standard regex library.  (I'm a little rusty, so there may be a few syntax errors, but this is at least the general idea)</source>
          <target state="translated">표준 정규식 라이브러리 만 사용하는 정규식 솔루션입니다. (나는 약간 녹슨, 그래서 몇 가지 구문 오류가있을 수 있지만 이것은 적어도 일반적인 아이디어입니다)</target>
        </trans-unit>
        <trans-unit id="ad839725a134bd1b6392b1c21e805b0f7cc756d8" translate="yes" xml:space="preserve">
          <source>How do I iterate over the words of a string</source>
          <target state="translated">문자열의 단어를 어떻게 반복합니까?</target>
        </trans-unit>
        <trans-unit id="8164d0d639169c81b13b17bc3d347e5df03097ea" translate="yes" xml:space="preserve">
          <source>However, you can either use C's &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/strtok&quot;&gt;&lt;code&gt;strtok()&lt;/code&gt;&lt;/a&gt; function by using the &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/c_str&quot;&gt;&lt;code&gt;std::string::c_str()&lt;/code&gt;&lt;/a&gt; member, or you can write your own. Here is a code sample I found after a quick Google search (&lt;strong&gt;&quot;STL string split&quot;&lt;/strong&gt;):</source>
          <target state="translated">그러나 &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/c_str&quot;&gt; &lt;code&gt;std::string::c_str()&lt;/code&gt; &lt;/a&gt; 멤버를 사용하여 C의 &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/strtok&quot;&gt; &lt;code&gt;strtok()&lt;/code&gt; &lt;/a&gt; 함수를 사용하거나 직접 작성할 수 있습니다. 빠른 Google 검색 후 찾은 코드 샘플 ( &lt;strong&gt;&quot;STL string split&quot;&lt;/strong&gt; )은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="edbd5b3edc642567da5a827b6b2f8804da091757" translate="yes" xml:space="preserve">
          <source>I have a 2 lines solution to this problem:</source>
          <target state="translated">이 문제에 대한 2 줄 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9d3bf7ae6779586aa4c434765f7f1f0997b6b1f" translate="yes" xml:space="preserve">
          <source>I hope someone else can find this as useful as I do.</source>
          <target state="translated">다른 사람이 내가하는 것처럼 유용한 것을 찾을 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="3a73403c1957cc0e33fdc441ae726cc999f4942c" translate="yes" xml:space="preserve">
          <source>I like the following because it puts the results into a vector, supports a string as a delim and gives control over keeping empty values. But, it doesn't look as good then.</source>
          <target state="translated">결과를 벡터에 넣고 문자열을 delim로 지원하고 빈 값을 유지하는 것을 제어하기 때문에 다음을 좋아합니다. 그러나 그때는 좋지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70af1c7cf8dbf905cd7d9ae6fe84ef064af7b8b3" translate="yes" xml:space="preserve">
          <source>I like to use the boost/regex methods for this task since they provide maximum flexibility for specifying the splitting criteria.</source>
          <target state="translated">나는이 기준에 부스트 / 정규식 방법을 사용하고 싶습니다. 분할 기준을 지정할 때 최대한의 유연성을 제공하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="a3e013d54b198746029363a080be9d65c71513bc" translate="yes" xml:space="preserve">
          <source>I made this because I needed an easy way to split strings and c-based strings... Hopefully someone else can find it useful as well. Also it doesn't rely on tokens and you can use fields as delimiters, which is another key I needed.</source>
          <target state="translated">문자열과 c 기반 문자열을 쉽게 분리 할 수있는 방법이 필요했기 때문에 이것을 만들었습니다. 다른 사람도 유용하게 사용할 수 있기를 바랍니다. 또한 토큰에 의존하지 않으며 필드를 구분 기호로 사용할 수 있습니다. 이는 필자가 필요한 또 다른 키입니다.</target>
        </trans-unit>
        <trans-unit id="01bc5ba0fa755484bd526b58e86a0cea76a28bf8" translate="yes" xml:space="preserve">
          <source>I use this to split string by a delimiter. The first puts the results in a pre-constructed vector, the second returns a new vector.</source>
          <target state="translated">이것을 사용하여 문자열을 구분 기호로 나눕니다. 첫 번째는 결과를 미리 구성된 벡터에 넣고 두 번째는 새 벡터를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d02b633661d0af2f5aac614aedf4fd95b95fc7fc" translate="yes" xml:space="preserve">
          <source>I usually choose to use &lt;code&gt;std::vector&amp;lt;std::string&amp;gt;&lt;/code&gt; types as my second parameter (&lt;code&gt;ContainerT&lt;/code&gt;)... but &lt;code&gt;list&amp;lt;&amp;gt;&lt;/code&gt; is way faster than &lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt; for when direct access is not needed, and you can even create your own string class and use something like &lt;code&gt;std::list&amp;lt;subString&amp;gt;&lt;/code&gt; where &lt;code&gt;subString&lt;/code&gt; does not do any copies for incredible speed increases.</source>
          <target state="translated">나는 일반적으로 &lt;code&gt;std::vector&amp;lt;std::string&amp;gt;&lt;/code&gt; 유형을 두 번째 매개 변수 ( &lt;code&gt;ContainerT&lt;/code&gt; )로 사용하도록 선택하지만 직접 액세스가 필요하지 않은 경우 &lt;code&gt;list&amp;lt;&amp;gt;&lt;/code&gt; 는 &lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt; 보다 빠릅니다. 자신의 문자열 클래스를 사용하고 &lt;code&gt;std::list&amp;lt;subString&amp;gt;&lt;/code&gt; 과 같은 것을 사용하십시오. 여기서 &lt;code&gt;subString&lt;/code&gt; 은 놀라운 속도 증가를 위해 복사를 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98ba3b0af09fe29627f5fe02ee9af975d3e8d35b" translate="yes" xml:space="preserve">
          <source>I usually only check to split on spaces and commas, so I also have this default function:</source>
          <target state="translated">나는 보통 공백과 쉼표로만 분할하도록 확인 하므로이 기본 기능도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e91045629e7a5c9e98dde7928f173bbd7764caa" translate="yes" xml:space="preserve">
          <source>I'm sure there's improvements that can be made to even further improve its elegance and please do by all means</source>
          <target state="translated">우아함을 더욱 향상시킬 수있는 개선 사항이 있다고 확신합니다.</target>
        </trans-unit>
        <trans-unit id="a3b5e6ebe32255aa5a8cbb511d5478625952fbff" translate="yes" xml:space="preserve">
          <source>I'm trying to iterate over the words of a string.</source>
          <target state="translated">문자열의 단어를 반복하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e5807a479143bdef2e06556aa0b30259912e246a" translate="yes" xml:space="preserve">
          <source>I've rolled my own using strtok and used boost to split a string.  The best method I have found is the &lt;a href=&quot;http://www.partow.net/programming/strtk/&quot;&gt;C++ String Toolkit Library&lt;/a&gt;.  It is incredibly flexible and fast.</source>
          <target state="translated">strtok을 사용하여 내 자신을 굴려서 boost를 사용하여 문자열을 나눕니다. 내가 찾은 가장 좋은 방법은 &lt;a href=&quot;http://www.partow.net/programming/strtk/&quot;&gt;C ++ String Toolkit Library&lt;/a&gt; 입니다. 매우 유연하고 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="80bd129398d2a58cb60b25313fb43865351f69bf" translate="yes" xml:space="preserve">
          <source>If splitting a string at multiple delimiters while skipping empty tokens is desired, this version may be used:</source>
          <target state="translated">빈 토큰을 건너 뛰면서 여러 구분 기호로 문자열을 분할하려는 경우이 버전을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7589cbcf380a78c9803a11402f160a9053a8278d" translate="yes" xml:space="preserve">
          <source>If you have questions about the code sample, leave a comment and I will explain.</source>
          <target state="translated">코드 샘플에 대해 궁금한 점이 있으면 의견을 남겨 주시면 설명하겠습니다.</target>
        </trans-unit>
        <trans-unit id="4af4cc4098db3af77c2383b7caef397b8c5d31c3" translate="yes" xml:space="preserve">
          <source>If you like to use boost, but want to use a whole string as delimiter (instead of single characters as in most of the previously proposed solutions), you can use the &lt;code&gt;boost_split_iterator&lt;/code&gt;.</source>
          <target state="translated">boost를 사용하고 싶지만 이전에 제안 된 대부분의 솔루션에서와 같이 단일 문자 대신 전체 문자열을 구분 기호로 사용하려면 &lt;code&gt;boost_split_iterator&lt;/code&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a644a073e06e3986597fbf1fcf4f2d6a9c572e35" translate="yes" xml:space="preserve">
          <source>Instead of copying the extracted tokens to an output stream, one could insert them into a container, using the same generic &lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; algorithm.</source>
          <target state="translated">추출 된 토큰을 출력 스트림에 복사하는 대신 동일한 일반 &lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 알고리즘을 사용하여 컨테이너에 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06e57f321253a6ce49b846a26ffcbdfdd422b91f" translate="yes" xml:space="preserve">
          <source>Is there a more elegant way to do this?</source>
          <target state="translated">더 우아한 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="ae8fe7d96f18b204a67c12bb20b01019014e820d" translate="yes" xml:space="preserve">
          <source>It can also be easily expanded to skip empty tokens:</source>
          <target state="translated">빈 토큰을 건너 뛰도록 쉽게 확장 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2ba82430e6d8796d64675e8c1fa0c82bcbabce7" translate="yes" xml:space="preserve">
          <source>It can easily be templatised to handle string separators, wide strings, etc.</source>
          <target state="translated">문자열 구분 기호, 넓은 문자열 등을 쉽게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="28d90795bfb34c48b119d7f6cb9d197ea65a4073" translate="yes" xml:space="preserve">
          <source>It's more than double as fast as the fastest tokenize on this page and almost 5 times faster than some others. Also with the perfect parameter types you can eliminate all string and list copies for additional speed increases.</source>
          <target state="translated">이 페이지에서 가장 빠른 토큰 화보다 두 배 이상 빠르며 다른 것보다 거의 5 배 빠릅니다. 또한 완벽한 매개 변수 유형을 사용하면 추가 문자열 증가를 위해 모든 문자열 및 목록 사본을 제거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="69d1271bac1d9c309e788d9ea67be98ca0e136bf" translate="yes" xml:space="preserve">
          <source>Lastly it allows you to specify whether to trim empty tokens from the results via a last optional parameter.</source>
          <target state="translated">마지막으로 마지막 선택적 매개 변수를 통해 결과에서 빈 토큰을 트리밍할지 여부를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a1630c87ca12f86b482c8b5c22149b511943f7cb" translate="yes" xml:space="preserve">
          <source>Limited by imagination ;)</source>
          <target state="translated">상상력에 의해 제한;)</target>
        </trans-unit>
        <trans-unit id="2fe5047d67353f0846aa94b0fe23a67a2b32150c" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;std::upper&lt;/code&gt; should be really passed as function template argument. Then the more generalized from of this function can split at delimiters like &lt;code&gt;&quot;,&quot;&lt;/code&gt;, &lt;code&gt;&quot;;&quot;&lt;/code&gt; or &lt;code&gt;&quot; &quot;&lt;/code&gt; too.</source>
          <target state="translated">&lt;code&gt;std::upper&lt;/code&gt; 는 실제로 함수 템플릿 인수로 전달되어야합니다. 그런 다음이 함수를보다 일반화하면 &lt;code&gt;&quot;,&quot;&lt;/code&gt; , &lt;code&gt;&quot;;&quot;&lt;/code&gt; 와 같은 구분 기호로 나눌 수 있습니다 . 또는 &lt;code&gt;&quot; &quot;&lt;/code&gt; 도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="3af42b55fb6cb79a028f48fc9dddef7a1b09c406" translate="yes" xml:space="preserve">
          <source>Note that I'm not interested in C string functions or that kind of character manipulation/access. Also, please give precedence to elegance over efficiency in your answer.</source>
          <target state="translated">C 문자열 함수 나 그런 종류의 문자 조작 / 액세스에는 관심이 없습니다. 또한 답변의 효율성보다 우아함을 우선시하십시오.</target>
        </trans-unit>
        <trans-unit id="1e2cb5802a91f46a1cfa9c5a877feee94d00ecb2" translate="yes" xml:space="preserve">
          <source>Note that splitting &lt;code&gt;&quot;&quot;&lt;/code&gt; results in a single empty string and splitting &lt;code&gt;&quot;,&quot;&lt;/code&gt; (ie. sep) results in two empty strings.</source>
          <target state="translated">&lt;code&gt;&quot;&quot;&lt;/code&gt; 를 분할하면 단일 빈 문자열이 생성되고 &lt;code&gt;&quot;,&quot;&lt;/code&gt; (예 : sep)를 분할하면 두 개의 빈 문자열이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="2eed498a91867681e33df9807e93e65e867e0bff" translate="yes" xml:space="preserve">
          <source>Note that this solution does not skip empty tokens, so the following will find 4 items, one of which is empty:</source>
          <target state="translated">이 솔루션은 빈 토큰을 건너 뛰지 않으므로 다음은 4 개의 항목 중 하나가 비어있는 것을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="fe5714fb716282b1a9a1fc9fcd3bd604250fb787" translate="yes" xml:space="preserve">
          <source>Note, if you want to split &lt;code&gt;wstring&lt;/code&gt; instead of &lt;code&gt;string&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;string&lt;/code&gt; 대신 &lt;code&gt;wstring&lt;/code&gt; 을 분할하려면</target>
        </trans-unit>
        <trans-unit id="d172c279b9365bde131c6c6226972701d76e01c5" translate="yes" xml:space="preserve">
          <source>Note, you might also want to take the string argument by reference, depending on your compiler.</source>
          <target state="translated">컴파일러에 따라 문자열 인수를 참조로 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="94d45ad4e48fcad61e269a1e3312579ec200054b" translate="yes" xml:space="preserve">
          <source>Of course, Boost has a &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html#id3483755&quot;&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt; that works partially like that. And, if by 'white-space', you really do mean any type of white-space, using Boost's split with &lt;code&gt;is_any_of()&lt;/code&gt; works great.</source>
          <target state="translated">물론 Boost에는 &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html#id3483755&quot;&gt; &lt;code&gt;split()&lt;/code&gt; &lt;/a&gt; 이 부분적으로 작동합니다. 그리고 'white-space'에 의해 &lt;code&gt;is_any_of()&lt;/code&gt; 와 함께 Boost의 split을 사용하면 실제로 어떤 유형의 공백도 의미합니다.</target>
        </trans-unit>
        <trans-unit id="feefe8647d3c18455c7284d73e5e9b156c6be204" translate="yes" xml:space="preserve">
          <source>Recently I had to split a camel-cased word into subwords.  There are no delimiters, just upper characters.</source>
          <target state="translated">최근에 나는 낙타로 된 단어를 하위 단어로 나누었습니다. 구분 기호가 없으며 대문자 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="58fd97bc0d3ae9571cb48bf3cbc2a8e1eca6001f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html&quot;&gt;설명서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b8776bac563a3c1a8c473120ed91905a5d046e8c" translate="yes" xml:space="preserve">
          <source>Short and elegant</source>
          <target state="translated">짧고 우아한</target>
        </trans-unit>
        <trans-unit id="3f5a90e2a6ed10327b773e990c6e9c0718937bb8" translate="yes" xml:space="preserve">
          <source>So far I used the one in &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_C++_Libraries&quot;&gt;Boost&lt;/a&gt;, but I needed something that doesn't depends on it, so I came to this:</source>
          <target state="translated">지금까지 &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_C++_Libraries&quot;&gt;Boost&lt;/a&gt; 에서 하나를 사용했지만 그것에 의존하지 않는 것이 필요했기 때문에 다음과 같이했습니다.</target>
        </trans-unit>
        <trans-unit id="567e164602261d048d22e25b3917128629c66b84" translate="yes" xml:space="preserve">
          <source>StringSplitter.cpp:</source>
          <target state="translated">StringSplitter.cpp:</target>
        </trans-unit>
        <trans-unit id="fb0c5461cacf796c6e710a8542a3699900e2261b" translate="yes" xml:space="preserve">
          <source>StringSplitter.hpp:</source>
          <target state="translated">StringSplitter.hpp:</target>
        </trans-unit>
        <trans-unit id="87fdba3e4c7e285121516a72fc35fd71bc4a6cde" translate="yes" xml:space="preserve">
          <source>Taken from: &lt;a href=&quot;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&quot;&gt;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&quot;&gt;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="27ce8f54f6936c89f8e51e510065e4a26b283c12" translate="yes" xml:space="preserve">
          <source>That's it! And that's just one way to use the tokenizer, like how to just 
count words:</source>
          <target state="translated">그게 다야! 그리고 그것은 단어를 세는 방법과 같이 토크 나이저를 사용하는 한 가지 방법입니다.</target>
        </trans-unit>
        <trans-unit id="1ca5e115b2a47f2d37422e0fdbcba3af6a5d68c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.cplusplus.com/reference/sstream/stringstream/&quot;&gt;stringstream&lt;/a&gt; can be convenient if you need to parse the string by non-space symbols:</source>
          <target state="translated">공백이 아닌 기호로 문자열을 구문 분석해야하는 경우 &lt;a href=&quot;http://www.cplusplus.com/reference/sstream/stringstream/&quot;&gt;stringstream&lt;/a&gt; 이 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="8996313f0643de07b9f50a3028ea25719a41ceed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;[\\s,]+&quot;&lt;/code&gt; checks for spaces (&lt;code&gt;\\s&lt;/code&gt;) and commas (&lt;code&gt;,&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&quot;[\\s,]+&quot;&lt;/code&gt; 는 공백 ( &lt;code&gt;\\s&lt;/code&gt; ) 및 쉼표 ( &lt;code&gt;,&lt;/code&gt; )를 확인합니다.</target>
        </trans-unit>
        <trans-unit id="6440dc5c41f1e26931bf178eb530b739c544e1ac" translate="yes" xml:space="preserve">
          <source>The STL does not have such a method available already.</source>
          <target state="translated">STL에는 이러한 방법이 아직 없습니다.</target>
        </trans-unit>
        <trans-unit id="40333814fcb573c6e93835452764a1fd1397b1c5" translate="yes" xml:space="preserve">
          <source>The best solution I have right now is:</source>
          <target state="translated">내가 지금 가지고있는 가장 좋은 해결책은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="db7cbd55c362ea33208ce7a702e9447099a6f9c8" translate="yes" xml:space="preserve">
          <source>The goal was to make it similar to C#'s Split() method where splitting a string is as easy as:</source>
          <target state="translated">목표는 문자열을 쉽게 분할하는 C #의 Split () 메서드와 비슷하게 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="782c41e695434ee735cd0174735b03a0b9649dd4" translate="yes" xml:space="preserve">
          <source>The regex argument allows checking for multiple arguments (spaces, commas, etc.)</source>
          <target state="translated">정규식 인수를 사용하면 여러 인수 (공백, 쉼표 등)를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d069b0b95a55b35a35a8b4b59549329da87bfe1" translate="yes" xml:space="preserve">
          <source>The string can be assumed to be composed of words separated by whitespace.</source>
          <target state="translated">문자열은 공백으로 구분 된 단어로 구성되어 있다고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79cdca9b5545e633e42e3fbbe559a2da01c3450f" translate="yes" xml:space="preserve">
          <source>The toolkit has much more flexibility than this simple example shows but its utility in parsing a string into useful elements is incredible.</source>
          <target state="translated">툴킷은이 간단한 예제보다 훨씬 융통성이 있지만 문자열을 유용한 요소로 파싱하는 유틸리티는 놀랍습니다.</target>
        </trans-unit>
        <trans-unit id="b9f02d4eee5583a864c93d46145ec1e7bda76eb3" translate="yes" xml:space="preserve">
          <source>Then instead of printing you can put it in a vector.</source>
          <target state="translated">그런 다음 인쇄하는 대신 벡터에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9fb5bf7a2591fc1e35a2993ba89c0b9e5a42d7c" translate="yes" xml:space="preserve">
          <source>There is a function named &lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstring/strtok/&quot;&gt;&lt;code&gt;strtok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstring/strtok/&quot;&gt; &lt;code&gt;strtok&lt;/code&gt; &lt;/a&gt; 이라는 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="593e97883525d037a4f64854c6d74628bb9c3388" translate="yes" xml:space="preserve">
          <source>This answer takes the string and puts it into a vector of strings. It uses the boost library.</source>
          <target state="translated">이 답변은 문자열을 가져 와서 문자열 벡터로 만듭니다. 부스트 라이브러리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c631e791df3de892d29ad086f68ab5babfed0ac1" translate="yes" xml:space="preserve">
          <source>This approach might be even faster than the &lt;code&gt;stringstream&lt;/code&gt; approach. And since this is a generic template function it can be used to split other types of strings (wchar, etc. or UTF-8) using all kinds of delimiters.</source>
          <target state="translated">이 접근 방식은 &lt;code&gt;stringstream&lt;/code&gt; 접근 방식보다 훨씬 빠릅니다. 그리고 이것은 일반적인 템플릿 함수이기 때문에 모든 종류의 구분자를 사용하여 다른 유형의 문자열 (wchar 등 또는 UTF-8)을 분할하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b3c86d3a6486e114dab28e263dacbf6a3306c6b" translate="yes" xml:space="preserve">
          <source>This example gives the output -</source>
          <target state="translated">이 예제는 출력을 제공합니다-</target>
        </trans-unit>
        <trans-unit id="c769bf1282bd7c3be136c3c14a81ae993c455324" translate="yes" xml:space="preserve">
          <source>This is my favorite way to iterate through a string. You can do whatever you want per word.</source>
          <target state="translated">이것은 문자열을 반복하는 가장 좋아하는 방법입니다. 단어마다 원하는대로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e22101f4f90eb21775516823db9e88caba9d9f7d" translate="yes" xml:space="preserve">
          <source>This is similar to Stack&amp;nbsp;Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c&quot;&gt;How do I tokenize a string in C++?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">이것은 &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c&quot;&gt;C ++에서 문자열을 어떻게 토큰 화합니까?&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fe7b02c0b7fcd609149b7d62126921ead63257e3" translate="yes" xml:space="preserve">
          <source>To keep empty entries (by default empties will be excluded):</source>
          <target state="translated">빈 항목을 유지하려면 (기본적으로 비어 있음) 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="93b920172684c22d81bc0d960c610f3b8f689afc" translate="yes" xml:space="preserve">
          <source>To use it with a vector of strings (Edit: Since someone pointed out not to inherit STL classes... hrmf ;) ) :</source>
          <target state="translated">문자열 벡터와 함께 사용하려면 (편집 : 누군가가 STL 클래스를 상속하지 않기로 지적했기 때문에 ... hrmf;)) :</target>
        </trans-unit>
        <trans-unit id="2e911d11c79fa6e8338a0ec81f67859eba88f7d8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;std::stringstream&lt;/code&gt; as you have works perfectly fine, and do exactly what you wanted. If you're just looking for different way of doing things though, you can use &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find&quot;&gt;&lt;code&gt;std::find()&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find_first_of&quot;&gt;&lt;code&gt;std::find_first_of()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/substr&quot;&gt;&lt;code&gt;std::string::substr()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;std::stringstream&lt;/code&gt; 을 사용하면 완벽하게 작동하고 원하는 것을 정확하게 수행 할 수 있습니다. 그래도 다른 방식으로 작업을 수행하려는 경우 &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find&quot;&gt; &lt;code&gt;std::find()&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find_first_of&quot;&gt; &lt;code&gt;std::find_first_of()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/substr&quot;&gt; &lt;code&gt;std::string::substr()&lt;/code&gt; &lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="7193f7a53cfe214ffe06f99029f6ee29bdef2653" translate="yes" xml:space="preserve">
          <source>What about this:</source>
          <target state="translated">이건 어때?</target>
        </trans-unit>
        <trans-unit id="d713ca8d870cdfeb112abd654479d42242f3e918" translate="yes" xml:space="preserve">
          <source>Will output:</source>
          <target state="translated">출력합니다 :</target>
        </trans-unit>
        <trans-unit id="5d81f64d4366d191a3ca38ee4fbfad99f8b4b7a2" translate="yes" xml:space="preserve">
          <source>Yet another flexible and fast way</source>
          <target state="translated">또 다른 유연하고 빠른 방법</target>
        </trans-unit>
        <trans-unit id="b8ad87877e333c9158dc06959d9121266c779f94" translate="yes" xml:space="preserve">
          <source>accepts multiple delimiters</source>
          <target state="translated">여러 구분 기호를 허용합니다</target>
        </trans-unit>
        <trans-unit id="de73eac0c305038f0437bc6a1f994a5a4379ed28" translate="yes" xml:space="preserve">
          <source>an</source>
          <target state="translated">an</target>
        </trans-unit>
        <trans-unit id="1028f44eb0896c7451136d0f6e58eb2118691f1d" translate="yes" xml:space="preserve">
          <source>can use any string as delimiter, also can be used with binary data (std::string supports binary data, including nulls)</source>
          <target state="translated">모든 문자열을 구분 기호로 사용할 수 있으며 이진 데이터와 함께 사용할 수도 있습니다 (std :: string은 null을 포함한 이진 데이터를 지원함)</target>
        </trans-unit>
        <trans-unit id="da81ca0e477c7b07303dc4b796a57547c89b20ed" translate="yes" xml:space="preserve">
          <source>change all &lt;code&gt;sregex_token_iterator&lt;/code&gt; to &lt;code&gt;wsregex_token_iterator&lt;/code&gt;</source>
          <target state="translated">모든 &lt;code&gt;sregex_token_iterator&lt;/code&gt; 를 &lt;code&gt;wsregex_token_iterator&lt;/code&gt; 로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="2ba6f0eafff4f195043d9ca955616d7781f08d24" translate="yes" xml:space="preserve">
          <source>change all &lt;code&gt;std::regex&lt;/code&gt; to &lt;code&gt;std::wregex&lt;/code&gt;</source>
          <target state="translated">모든 &lt;code&gt;std::regex&lt;/code&gt; 를 &lt;code&gt;std::wregex&lt;/code&gt; 로 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="65f449d134d2005340cabace69bd7e0efc454270" translate="yes" xml:space="preserve">
          <source>cstring</source>
          <target state="translated">cstring</target>
        </trans-unit>
        <trans-unit id="c3499c2729730a7f807efb8676a92dcb6f8a3f8f" translate="yes" xml:space="preserve">
          <source>example</source>
          <target state="translated">example</target>
        </trans-unit>
        <trans-unit id="8a1e7cb60b05f12ba21bd9eac3c5ab6bc4e4b943" translate="yes" xml:space="preserve">
          <source>ignores empty tokens (can easily be changed)</source>
          <target state="translated">빈 토큰을 무시합니다 (쉽게 변경할 수 있음)</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="3b59820c89e372d8d136229501895f9f8b1ff990" translate="yes" xml:space="preserve">
          <source>is generic</source>
          <target state="translated">일반적이다</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="79620d35c76fd53c042f55457d80adf808303eb0" translate="yes" xml:space="preserve">
          <source>uses standard C++ (no boost)</source>
          <target state="translated">표준 C ++ 사용 (부스트 없음)</target>
        </trans-unit>
        <trans-unit id="a2cddef2f25af8d8750e5e21bb62b1d96d3f5636" translate="yes" xml:space="preserve">
          <source>using:</source>
          <target state="translated">using:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
