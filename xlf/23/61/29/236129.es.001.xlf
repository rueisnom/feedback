<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/236129">
    <body>
      <group id="236129">
        <trans-unit id="edcb0f44cc7dfb094ba440e1b7696a327b163cfe" translate="yes" xml:space="preserve">
          <source>... or create the &lt;code&gt;vector&lt;/code&gt; directly:</source>
          <target state="translated">... o crea el &lt;code&gt;vector&lt;/code&gt; directamente:</target>
        </trans-unit>
        <trans-unit id="daf67907bca13add6181e99993d1c333b0460b26" translate="yes" xml:space="preserve">
          <source>A good point is that in &lt;code&gt;separators&lt;/code&gt; you can pass more than one character.</source>
          <target state="translated">Un buen punto es que en los &lt;code&gt;separators&lt;/code&gt; puede pasar m&amp;aacute;s de un car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="3885f98f0b7796bc84d063ed9149766d457a3c80" translate="yes" xml:space="preserve">
          <source>A possible solution using Boost might be:</source>
          <target state="translated">Una posible solución usando Boost podría ser:</target>
        </trans-unit>
        <trans-unit id="c3721b3abeee59011fa0e483bff445ac1cd186ad" translate="yes" xml:space="preserve">
          <source>Additionally it does not do the (extremely inefficient) return of result, but rather it passes the tokens as a reference, thus also allowing you to build up tokens using multiple calls if you so wished.</source>
          <target state="translated">Además,no hace la devolución (extremadamente ineficiente)del resultado,sino que pasa las fichas como referencia,lo que también le permite acumular fichas utilizando múltiples llamadas si así lo desea.</target>
        </trans-unit>
        <trans-unit id="60f636a484c97d6136fbab261aac3f0769baa3e3" translate="yes" xml:space="preserve">
          <source>All it needs is &lt;code&gt;std::string&lt;/code&gt;... the rest are optional. It does not use streams or the boost library, but is flexible enough to be able to accept some of these foreign types naturally.</source>
          <target state="translated">Todo lo que necesita es &lt;code&gt;std::string&lt;/code&gt; ... el resto son opcionales. No utiliza secuencias ni la biblioteca de impulso, pero es lo suficientemente flexible como para poder aceptar algunos de estos tipos for&amp;aacute;neos de forma natural.</target>
        </trans-unit>
        <trans-unit id="c9c6db698f80734384e3824d88d70b12ee11ad29" translate="yes" xml:space="preserve">
          <source>And just because it does not implement a &lt;code&gt;typedef&lt;/code&gt; called iterator or overload the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator does not mean it is bad code. I use C functions quite frequently. For example, &lt;a href=&quot;http://en.cppreference.com/w/c/io/fprintf&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/c/io/fscanf&quot;&gt;&lt;code&gt;scanf&lt;/code&gt;&lt;/a&gt; both are faster than &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cin&quot;&gt;&lt;code&gt;std::cin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cout&quot;&gt;&lt;code&gt;std::cout&lt;/code&gt;&lt;/a&gt; (significantly), the &lt;a href=&quot;http://en.cppreference.com/w/c/io/fopen&quot;&gt;&lt;code&gt;fopen&lt;/code&gt;&lt;/a&gt; syntax is a lot more friendly for binary types, and they also tend to produce smaller EXEs.</source>
          <target state="translated">Y solo porque no implemente un &lt;code&gt;typedef&lt;/code&gt; llamado iterador o sobrecargue el operador &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; no significa que sea un c&amp;oacute;digo incorrecto. Yo uso las funciones de C con bastante frecuencia. Por ejemplo, &lt;a href=&quot;http://en.cppreference.com/w/c/io/fprintf&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;http://en.cppreference.com/w/c/io/fscanf&quot;&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;/a&gt; son m&amp;aacute;s r&amp;aacute;pidos que &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cin&quot;&gt; &lt;code&gt;std::cin&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cout&quot;&gt; &lt;code&gt;std::cout&lt;/code&gt; &lt;/a&gt; (significativamente), la sintaxis &lt;a href=&quot;http://en.cppreference.com/w/c/io/fopen&quot;&gt; &lt;code&gt;fopen&lt;/code&gt; &lt;/a&gt; es mucho m&amp;aacute;s amigable para los tipos binarios, y tambi&amp;eacute;n tienden a producir EXE m&amp;aacute;s peque&amp;ntilde;os.</target>
        </trans-unit>
        <trans-unit id="6870791be3a59b2da2de603a0be80d00918affe3" translate="yes" xml:space="preserve">
          <source>Don't get sold on this &lt;strong&gt;&quot;Elegance over performance&quot;&lt;/strong&gt; deal.</source>
          <target state="translated">No se deje vender por este acuerdo de &lt;strong&gt;&quot;Elegancia sobre rendimiento&quot;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="12735fab994dcd7b5adae72726b9a46ab4afa992" translate="yes" xml:space="preserve">
          <source>Example code including convenient template:</source>
          <target state="translated">Código de ejemplo incluyendo una plantilla conveniente:</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">Ejemplo de uso:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="2705b643a0f80d229f05dcb52e5d3ae40b25b515" translate="yes" xml:space="preserve">
          <source>For example, this splits &quot;AQueryTrades&quot; into &quot;A&quot;, &quot;Query&quot; and &quot;Trades&quot;.  The function works with narrow and wide strings. Because it respects the current locale it splits &quot;Raumfahrt&amp;Uuml;berwachungsVerordnung&quot; into &quot;Raumfahrt&quot;, &quot;&amp;Uuml;berwachungs&quot; and &quot;Verordnung&quot;.</source>
          <target state="translated">Por ejemplo, esto divide &quot;AQueryTrades&quot; en &quot;A&quot;, &quot;Query&quot; y &quot;Trades&quot;. La funci&amp;oacute;n funciona con cadenas estrechas y anchas. Debido a que respeta el entorno local actual, divide &quot;Raumfahrt&amp;Uuml;berwachungsVerordnung&quot; en &quot;Raumfahrt&quot;, &quot;&amp;Uuml;berwachungs&quot; y &quot;Verordnung&quot;.</target>
        </trans-unit>
        <trans-unit id="de52debc28e040370100e81fc36a534b35a68c1a" translate="yes" xml:space="preserve">
          <source>For those with whom it does not sit well to sacrifice all efficiency for code size and see &quot;efficient&quot; as a type of elegance, the following should hit a sweet spot (and I think the template container class is an awesomely elegant addition.):</source>
          <target state="translated">Para aquellos con los que no les sienta bien sacrificar toda la eficiencia por el tamaño del código y ver la &quot;eficiencia&quot; como un tipo de elegancia,lo siguiente debería dar en el clavo (y creo que la clase de contenedor de plantilla es una adición increíblemente elegante):</target>
        </trans-unit>
        <trans-unit id="f805399e635e59badeb8d25438ef59ca9d0781ff" translate="yes" xml:space="preserve">
          <source>For what it's worth, here's another way to extract tokens from an input string, relying only on standard library facilities. It's an example of the power and elegance behind the design of the STL.</source>
          <target state="translated">Por si sirve de algo,aquí hay otra forma de extraer fichas de una cadena de entrada,confiando sólo en las instalaciones estándar de la biblioteca.Es un ejemplo del poder y la elegancia que hay detrás del diseño del STL.</target>
        </trans-unit>
        <trans-unit id="e6608506d839180b9e39fabbdc1e4720408a5c00" translate="yes" xml:space="preserve">
          <source>Get &lt;a href=&quot;http://www.boost.org/&quot;&gt;Boost&lt;/a&gt; ! : -)</source>
          <target state="translated">&amp;iexcl;Obt&amp;eacute;n &lt;a href=&quot;http://www.boost.org/&quot;&gt;impulso&lt;/a&gt; ! : -)</target>
        </trans-unit>
        <trans-unit id="829b1be11ab5027516a4c431a8773cbefd7348b8" translate="yes" xml:space="preserve">
          <source>Here is a split function that:</source>
          <target state="translated">Aquí hay una función de división que:</target>
        </trans-unit>
        <trans-unit id="4caf1473b9c810e10c38b1b0cdb53f2d370028f3" translate="yes" xml:space="preserve">
          <source>Here's a simple solution that uses only the standard regex library</source>
          <target state="translated">Aquí hay una solución simple que utiliza sólo la biblioteca estándar de regex</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">Aquí hay un ejemplo:</target>
        </trans-unit>
        <trans-unit id="a780475444a036f8986b27e4e0681b9956fc67b0" translate="yes" xml:space="preserve">
          <source>Here's another solution. It's compact and reasonably efficient:</source>
          <target state="translated">Aquí hay otra solución.Es compacta y razonablemente eficiente:</target>
        </trans-unit>
        <trans-unit id="78859cf5ab12634a3057d2cf55d540f4dd043078" translate="yes" xml:space="preserve">
          <source>Here's another way of doing it..</source>
          <target state="translated">Aquí hay otra forma de hacerlo...</target>
        </trans-unit>
        <trans-unit id="d30b6f4a9867c924c643828218cb2533ca6fed31" translate="yes" xml:space="preserve">
          <source>Heres a regex solution that only uses the standard regex library.  (I'm a little rusty, so there may be a few syntax errors, but this is at least the general idea)</source>
          <target state="translated">Aquí hay una solución regex que sólo usa la biblioteca regex estándar.(Estoy un poco oxidado,así que puede haber algunos errores de sintaxis,pero esta es al menos la idea general)</target>
        </trans-unit>
        <trans-unit id="ad839725a134bd1b6392b1c21e805b0f7cc756d8" translate="yes" xml:space="preserve">
          <source>How do I iterate over the words of a string</source>
          <target state="translated">¿Cómo puedo iterar sobre las palabras de una cadena</target>
        </trans-unit>
        <trans-unit id="8164d0d639169c81b13b17bc3d347e5df03097ea" translate="yes" xml:space="preserve">
          <source>However, you can either use C's &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/strtok&quot;&gt;&lt;code&gt;strtok()&lt;/code&gt;&lt;/a&gt; function by using the &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/c_str&quot;&gt;&lt;code&gt;std::string::c_str()&lt;/code&gt;&lt;/a&gt; member, or you can write your own. Here is a code sample I found after a quick Google search (&lt;strong&gt;&quot;STL string split&quot;&lt;/strong&gt;):</source>
          <target state="translated">Sin embargo, puede usar la &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/strtok&quot;&gt; &lt;code&gt;strtok()&lt;/code&gt; &lt;/a&gt; &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/c_str&quot;&gt; &lt;code&gt;std::string::c_str()&lt;/code&gt; &lt;/a&gt; C usando el miembro std :: string :: c_str () , o puede escribir la suya propia. Aqu&amp;iacute; hay una muestra de c&amp;oacute;digo que encontr&amp;eacute; despu&amp;eacute;s de una b&amp;uacute;squeda r&amp;aacute;pida en Google ( &lt;strong&gt;&quot;divisi&amp;oacute;n de cadena STL&quot;&lt;/strong&gt; ):</target>
        </trans-unit>
        <trans-unit id="edbd5b3edc642567da5a827b6b2f8804da091757" translate="yes" xml:space="preserve">
          <source>I have a 2 lines solution to this problem:</source>
          <target state="translated">Tengo una solución de dos líneas para este problema:</target>
        </trans-unit>
        <trans-unit id="d9d3bf7ae6779586aa4c434765f7f1f0997b6b1f" translate="yes" xml:space="preserve">
          <source>I hope someone else can find this as useful as I do.</source>
          <target state="translated">Espero que alguien más pueda encontrar esto tan útil como yo.</target>
        </trans-unit>
        <trans-unit id="3a73403c1957cc0e33fdc441ae726cc999f4942c" translate="yes" xml:space="preserve">
          <source>I like the following because it puts the results into a vector, supports a string as a delim and gives control over keeping empty values. But, it doesn't look as good then.</source>
          <target state="translated">Me gusta lo siguiente porque pone los resultados en un vector,soporta una cadena como delimitador y da control sobre el mantenimiento de valores vacíos.Pero,no se ve tan bien entonces.</target>
        </trans-unit>
        <trans-unit id="70af1c7cf8dbf905cd7d9ae6fe84ef064af7b8b3" translate="yes" xml:space="preserve">
          <source>I like to use the boost/regex methods for this task since they provide maximum flexibility for specifying the splitting criteria.</source>
          <target state="translated">Me gusta utilizar los métodos de Boostregex para esta tarea,ya que proporcionan la máxima flexibilidad para especificar los criterios de división.</target>
        </trans-unit>
        <trans-unit id="a3e013d54b198746029363a080be9d65c71513bc" translate="yes" xml:space="preserve">
          <source>I made this because I needed an easy way to split strings and c-based strings... Hopefully someone else can find it useful as well. Also it doesn't rely on tokens and you can use fields as delimiters, which is another key I needed.</source>
          <target state="translated">Hice esto porque necesitaba una forma fácil de dividir las cuerdas y las cuerdas en Do...Con suerte,alguien más puede encontrarlo útil también.Además no depende de fichas y puedes usar campos como delimitadores,que es otra clave que necesitaba.</target>
        </trans-unit>
        <trans-unit id="01bc5ba0fa755484bd526b58e86a0cea76a28bf8" translate="yes" xml:space="preserve">
          <source>I use this to split string by a delimiter. The first puts the results in a pre-constructed vector, the second returns a new vector.</source>
          <target state="translated">Uso esto para dividir la cuerda por un delimitador.El primero pone los resultados en un vector pre-construido,el segundo devuelve un nuevo vector.</target>
        </trans-unit>
        <trans-unit id="d02b633661d0af2f5aac614aedf4fd95b95fc7fc" translate="yes" xml:space="preserve">
          <source>I usually choose to use &lt;code&gt;std::vector&amp;lt;std::string&amp;gt;&lt;/code&gt; types as my second parameter (&lt;code&gt;ContainerT&lt;/code&gt;)... but &lt;code&gt;list&amp;lt;&amp;gt;&lt;/code&gt; is way faster than &lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt; for when direct access is not needed, and you can even create your own string class and use something like &lt;code&gt;std::list&amp;lt;subString&amp;gt;&lt;/code&gt; where &lt;code&gt;subString&lt;/code&gt; does not do any copies for incredible speed increases.</source>
          <target state="translated">Por lo general, elijo usar los tipos &lt;code&gt;std::vector&amp;lt;std::string&amp;gt;&lt;/code&gt; como mi segundo par&amp;aacute;metro ( &lt;code&gt;ContainerT&lt;/code&gt; ) ... pero la &lt;code&gt;list&amp;lt;&amp;gt;&lt;/code&gt; es mucho m&amp;aacute;s r&amp;aacute;pida que el &lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt; para cuando no se necesita acceso directo, e incluso puede crear su propia clase de cadena y use algo como &lt;code&gt;std::list&amp;lt;subString&amp;gt;&lt;/code&gt; donde &lt;code&gt;subString&lt;/code&gt; no hace copias para incrementos de velocidad incre&amp;iacute;bles.</target>
        </trans-unit>
        <trans-unit id="98ba3b0af09fe29627f5fe02ee9af975d3e8d35b" translate="yes" xml:space="preserve">
          <source>I usually only check to split on spaces and commas, so I also have this default function:</source>
          <target state="translated">Normalmente sólo compruebo los espacios y las comas,así que también tengo esta función por defecto:</target>
        </trans-unit>
        <trans-unit id="8e91045629e7a5c9e98dde7928f173bbd7764caa" translate="yes" xml:space="preserve">
          <source>I'm sure there's improvements that can be made to even further improve its elegance and please do by all means</source>
          <target state="translated">Estoy seguro de que hay mejoras que se pueden hacer para mejorar aún más su elegancia y por favor haga por todos los medios</target>
        </trans-unit>
        <trans-unit id="a3b5e6ebe32255aa5a8cbb511d5478625952fbff" translate="yes" xml:space="preserve">
          <source>I'm trying to iterate over the words of a string.</source>
          <target state="translated">Estoy tratando de iterar sobre las palabras de una cuerda.</target>
        </trans-unit>
        <trans-unit id="e5807a479143bdef2e06556aa0b30259912e246a" translate="yes" xml:space="preserve">
          <source>I've rolled my own using strtok and used boost to split a string.  The best method I have found is the &lt;a href=&quot;http://www.partow.net/programming/strtk/&quot;&gt;C++ String Toolkit Library&lt;/a&gt;.  It is incredibly flexible and fast.</source>
          <target state="translated">Lamin&amp;eacute; la m&amp;iacute;a usando strtok y us&amp;eacute; boost para dividir una cadena. El mejor m&amp;eacute;todo que he encontrado es la &lt;a href=&quot;http://www.partow.net/programming/strtk/&quot;&gt;Biblioteca de C ++ String Toolkit&lt;/a&gt; . Es incre&amp;iacute;blemente flexible y r&amp;aacute;pido.</target>
        </trans-unit>
        <trans-unit id="80bd129398d2a58cb60b25313fb43865351f69bf" translate="yes" xml:space="preserve">
          <source>If splitting a string at multiple delimiters while skipping empty tokens is desired, this version may be used:</source>
          <target state="translated">Si se desea dividir una cadena en múltiples delimitadores mientras se saltan las fichas vacías,se puede utilizar esta versión:</target>
        </trans-unit>
        <trans-unit id="7589cbcf380a78c9803a11402f160a9053a8278d" translate="yes" xml:space="preserve">
          <source>If you have questions about the code sample, leave a comment and I will explain.</source>
          <target state="translated">Si tiene preguntas sobre la muestra de código,deje un comentario y se lo explicaré.</target>
        </trans-unit>
        <trans-unit id="4af4cc4098db3af77c2383b7caef397b8c5d31c3" translate="yes" xml:space="preserve">
          <source>If you like to use boost, but want to use a whole string as delimiter (instead of single characters as in most of the previously proposed solutions), you can use the &lt;code&gt;boost_split_iterator&lt;/code&gt;.</source>
          <target state="translated">Si desea usar boost, pero desea usar una cadena completa como delimitador (en lugar de caracteres individuales como en la mayor&amp;iacute;a de las soluciones propuestas anteriormente), puede usar &lt;code&gt;boost_split_iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a644a073e06e3986597fbf1fcf4f2d6a9c572e35" translate="yes" xml:space="preserve">
          <source>Instead of copying the extracted tokens to an output stream, one could insert them into a container, using the same generic &lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; algorithm.</source>
          <target state="translated">En lugar de copiar los tokens extra&amp;iacute;dos en una secuencia de salida, uno podr&amp;iacute;a insertarlos en un contenedor, utilizando el mismo algoritmo gen&amp;eacute;rico de &lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06e57f321253a6ce49b846a26ffcbdfdd422b91f" translate="yes" xml:space="preserve">
          <source>Is there a more elegant way to do this?</source>
          <target state="translated">¿Hay una forma más elegante de hacer esto?</target>
        </trans-unit>
        <trans-unit id="ae8fe7d96f18b204a67c12bb20b01019014e820d" translate="yes" xml:space="preserve">
          <source>It can also be easily expanded to skip empty tokens:</source>
          <target state="translated">También se puede ampliar fácilmente para saltar las fichas vacías:</target>
        </trans-unit>
        <trans-unit id="e2ba82430e6d8796d64675e8c1fa0c82bcbabce7" translate="yes" xml:space="preserve">
          <source>It can easily be templatised to handle string separators, wide strings, etc.</source>
          <target state="translated">Puede ser fácilmente tentado a manejar separadores de cuerdas,cuerdas anchas,etc.</target>
        </trans-unit>
        <trans-unit id="28d90795bfb34c48b119d7f6cb9d197ea65a4073" translate="yes" xml:space="preserve">
          <source>It's more than double as fast as the fastest tokenize on this page and almost 5 times faster than some others. Also with the perfect parameter types you can eliminate all string and list copies for additional speed increases.</source>
          <target state="translated">Es más del doble de rápido que la ficha más rápida de esta página y casi 5 veces más rápido que algunas otras.También con los tipos de parámetros perfectos puedes eliminar todas las copias de cadenas y listas para aumentar la velocidad.</target>
        </trans-unit>
        <trans-unit id="69d1271bac1d9c309e788d9ea67be98ca0e136bf" translate="yes" xml:space="preserve">
          <source>Lastly it allows you to specify whether to trim empty tokens from the results via a last optional parameter.</source>
          <target state="translated">Por último,permite especificar si se recortan las fichas vacías de los resultados mediante un último parámetro opcional.</target>
        </trans-unit>
        <trans-unit id="a1630c87ca12f86b482c8b5c22149b511943f7cb" translate="yes" xml:space="preserve">
          <source>Limited by imagination ;)</source>
          <target state="translated">Limitado por la imaginación ;)</target>
        </trans-unit>
        <trans-unit id="2fe5047d67353f0846aa94b0fe23a67a2b32150c" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;std::upper&lt;/code&gt; should be really passed as function template argument. Then the more generalized from of this function can split at delimiters like &lt;code&gt;&quot;,&quot;&lt;/code&gt;, &lt;code&gt;&quot;;&quot;&lt;/code&gt; or &lt;code&gt;&quot; &quot;&lt;/code&gt; too.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;std::upper&lt;/code&gt; deber&amp;iacute;a pasar realmente como argumento de plantilla de funci&amp;oacute;n. Entonces el m&amp;aacute;s generalizado de esta funci&amp;oacute;n puede dividirse en delimitadores como &lt;code&gt;&quot;,&quot;&lt;/code&gt; , &lt;code&gt;&quot;;&quot;&lt;/code&gt; o &lt;code&gt;&quot; &quot;&lt;/code&gt; tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="3af42b55fb6cb79a028f48fc9dddef7a1b09c406" translate="yes" xml:space="preserve">
          <source>Note that I'm not interested in C string functions or that kind of character manipulation/access. Also, please give precedence to elegance over efficiency in your answer.</source>
          <target state="translated">Tenga en cuenta que no estoy interesado en las funciones de la cadena C o en ese tipo de acceso de manipulación de caracteres.Además,por favor,dé prioridad a la elegancia sobre la eficiencia en su respuesta.</target>
        </trans-unit>
        <trans-unit id="1e2cb5802a91f46a1cfa9c5a877feee94d00ecb2" translate="yes" xml:space="preserve">
          <source>Note that splitting &lt;code&gt;&quot;&quot;&lt;/code&gt; results in a single empty string and splitting &lt;code&gt;&quot;,&quot;&lt;/code&gt; (ie. sep) results in two empty strings.</source>
          <target state="translated">Tenga en cuenta que dividir &lt;code&gt;&quot;&quot;&lt;/code&gt; da como resultado una &amp;uacute;nica cadena vac&amp;iacute;a y dividir &lt;code&gt;&quot;,&quot;&lt;/code&gt; (es decir, sep) da como resultado dos cadenas vac&amp;iacute;as.</target>
        </trans-unit>
        <trans-unit id="2eed498a91867681e33df9807e93e65e867e0bff" translate="yes" xml:space="preserve">
          <source>Note that this solution does not skip empty tokens, so the following will find 4 items, one of which is empty:</source>
          <target state="translated">Tenga en cuenta que esta solución no se salta las fichas vacías,por lo que a continuación encontrará 4 elementos,uno de los cuales está vacío:</target>
        </trans-unit>
        <trans-unit id="fe5714fb716282b1a9a1fc9fcd3bd604250fb787" translate="yes" xml:space="preserve">
          <source>Note, if you want to split &lt;code&gt;wstring&lt;/code&gt; instead of &lt;code&gt;string&lt;/code&gt;,</source>
          <target state="translated">Tenga en cuenta que si desea dividir &lt;code&gt;wstring&lt;/code&gt; en lugar de &lt;code&gt;string&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="d172c279b9365bde131c6c6226972701d76e01c5" translate="yes" xml:space="preserve">
          <source>Note, you might also want to take the string argument by reference, depending on your compiler.</source>
          <target state="translated">Nota,puede que también quieras tomar el argumento de la cadena por referencia,dependiendo de tu compilador.</target>
        </trans-unit>
        <trans-unit id="94d45ad4e48fcad61e269a1e3312579ec200054b" translate="yes" xml:space="preserve">
          <source>Of course, Boost has a &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html#id3483755&quot;&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt; that works partially like that. And, if by 'white-space', you really do mean any type of white-space, using Boost's split with &lt;code&gt;is_any_of()&lt;/code&gt; works great.</source>
          <target state="translated">Por supuesto, Boost tiene un &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html#id3483755&quot;&gt; &lt;code&gt;split()&lt;/code&gt; &lt;/a&gt; que funciona parcialmente de esa manera. Y, si por 'espacio en blanco', realmente se &lt;code&gt;is_any_of()&lt;/code&gt; cualquier tipo de espacio en blanco, usar la divisi&amp;oacute;n de Boost con is_any_of () funciona muy bien.</target>
        </trans-unit>
        <trans-unit id="feefe8647d3c18455c7284d73e5e9b156c6be204" translate="yes" xml:space="preserve">
          <source>Recently I had to split a camel-cased word into subwords.  There are no delimiters, just upper characters.</source>
          <target state="translated">Recientemente tuve que dividir una palabra con forma de camello en subpalabras.No hay delimitadores,sólo caracteres superiores.</target>
        </trans-unit>
        <trans-unit id="58fd97bc0d3ae9571cb48bf3cbc2a8e1eca6001f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">Consulte la &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html&quot;&gt;documentaci&amp;oacute;n&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="b8776bac563a3c1a8c473120ed91905a5d046e8c" translate="yes" xml:space="preserve">
          <source>Short and elegant</source>
          <target state="translated">Corto y elegante</target>
        </trans-unit>
        <trans-unit id="3f5a90e2a6ed10327b773e990c6e9c0718937bb8" translate="yes" xml:space="preserve">
          <source>So far I used the one in &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_C++_Libraries&quot;&gt;Boost&lt;/a&gt;, but I needed something that doesn't depends on it, so I came to this:</source>
          <target state="translated">Hasta ahora utilic&amp;eacute; el de &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_C++_Libraries&quot;&gt;Boost&lt;/a&gt; , pero necesitaba algo que no dependiera de &amp;eacute;l, as&amp;iacute; que llegu&amp;eacute; a esto:</target>
        </trans-unit>
        <trans-unit id="567e164602261d048d22e25b3917128629c66b84" translate="yes" xml:space="preserve">
          <source>StringSplitter.cpp:</source>
          <target state="translated">StringSplitter.cpp:</target>
        </trans-unit>
        <trans-unit id="fb0c5461cacf796c6e710a8542a3699900e2261b" translate="yes" xml:space="preserve">
          <source>StringSplitter.hpp:</source>
          <target state="translated">StringSplitter.hpp:</target>
        </trans-unit>
        <trans-unit id="87fdba3e4c7e285121516a72fc35fd71bc4a6cde" translate="yes" xml:space="preserve">
          <source>Taken from: &lt;a href=&quot;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&quot;&gt;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&lt;/a&gt;</source>
          <target state="translated">Tomado de: &lt;a href=&quot;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&quot;&gt;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="27ce8f54f6936c89f8e51e510065e4a26b283c12" translate="yes" xml:space="preserve">
          <source>That's it! And that's just one way to use the tokenizer, like how to just 
count words:</source>
          <target state="translated">¡Eso es! Y esa es sólo una forma de usar el tokenizer,como la de contar palabras:</target>
        </trans-unit>
        <trans-unit id="1ca5e115b2a47f2d37422e0fdbcba3af6a5d68c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.cplusplus.com/reference/sstream/stringstream/&quot;&gt;stringstream&lt;/a&gt; can be convenient if you need to parse the string by non-space symbols:</source>
          <target state="translated">El &lt;a href=&quot;http://www.cplusplus.com/reference/sstream/stringstream/&quot;&gt;flujo de cadena&lt;/a&gt; puede ser conveniente si necesita analizar la cadena por s&amp;iacute;mbolos que no sean espacios:</target>
        </trans-unit>
        <trans-unit id="8996313f0643de07b9f50a3028ea25719a41ceed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;[\\s,]+&quot;&lt;/code&gt; checks for spaces (&lt;code&gt;\\s&lt;/code&gt;) and commas (&lt;code&gt;,&lt;/code&gt;).</source>
          <target state="translated">El &lt;code&gt;&quot;[\\s,]+&quot;&lt;/code&gt; busca espacios ( &lt;code&gt;\\s&lt;/code&gt; ) y comas ( &lt;code&gt;,&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6440dc5c41f1e26931bf178eb530b739c544e1ac" translate="yes" xml:space="preserve">
          <source>The STL does not have such a method available already.</source>
          <target state="translated">La STL no dispone ya de tal método.</target>
        </trans-unit>
        <trans-unit id="40333814fcb573c6e93835452764a1fd1397b1c5" translate="yes" xml:space="preserve">
          <source>The best solution I have right now is:</source>
          <target state="translated">La mejor solución que tengo ahora mismo es:</target>
        </trans-unit>
        <trans-unit id="db7cbd55c362ea33208ce7a702e9447099a6f9c8" translate="yes" xml:space="preserve">
          <source>The goal was to make it similar to C#'s Split() method where splitting a string is as easy as:</source>
          <target state="translated">El objetivo era hacerlo similar al método Split()de C#donde dividir una cadena es tan fácil como:</target>
        </trans-unit>
        <trans-unit id="782c41e695434ee735cd0174735b03a0b9649dd4" translate="yes" xml:space="preserve">
          <source>The regex argument allows checking for multiple arguments (spaces, commas, etc.)</source>
          <target state="translated">El argumento regex permite comprobar varios argumentos (espacios,comas,etc.)</target>
        </trans-unit>
        <trans-unit id="4d069b0b95a55b35a35a8b4b59549329da87bfe1" translate="yes" xml:space="preserve">
          <source>The string can be assumed to be composed of words separated by whitespace.</source>
          <target state="translated">Se puede suponer que la cadena está compuesta por palabras separadas por espacios en blanco.</target>
        </trans-unit>
        <trans-unit id="79cdca9b5545e633e42e3fbbe559a2da01c3450f" translate="yes" xml:space="preserve">
          <source>The toolkit has much more flexibility than this simple example shows but its utility in parsing a string into useful elements is incredible.</source>
          <target state="translated">El conjunto de herramientas tiene mucha más flexibilidad de lo que muestra este simple ejemplo,pero su utilidad para analizar una cadena de elementos útiles es increíble.</target>
        </trans-unit>
        <trans-unit id="b9f02d4eee5583a864c93d46145ec1e7bda76eb3" translate="yes" xml:space="preserve">
          <source>Then instead of printing you can put it in a vector.</source>
          <target state="translated">Entonces en lugar de imprimirlo puedes ponerlo en un vector.</target>
        </trans-unit>
        <trans-unit id="b9fb5bf7a2591fc1e35a2993ba89c0b9e5a42d7c" translate="yes" xml:space="preserve">
          <source>There is a function named &lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstring/strtok/&quot;&gt;&lt;code&gt;strtok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Hay una funci&amp;oacute;n llamada &lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstring/strtok/&quot;&gt; &lt;code&gt;strtok&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="593e97883525d037a4f64854c6d74628bb9c3388" translate="yes" xml:space="preserve">
          <source>This answer takes the string and puts it into a vector of strings. It uses the boost library.</source>
          <target state="translated">Esta respuesta toma la cuerda y la pone en un vector de cuerdas.Utiliza la librería de impulso.</target>
        </trans-unit>
        <trans-unit id="c631e791df3de892d29ad086f68ab5babfed0ac1" translate="yes" xml:space="preserve">
          <source>This approach might be even faster than the &lt;code&gt;stringstream&lt;/code&gt; approach. And since this is a generic template function it can be used to split other types of strings (wchar, etc. or UTF-8) using all kinds of delimiters.</source>
          <target state="translated">Este enfoque podr&amp;iacute;a ser incluso m&amp;aacute;s r&amp;aacute;pido que el enfoque del &lt;code&gt;stringstream&lt;/code&gt; . Y dado que esta es una funci&amp;oacute;n de plantilla gen&amp;eacute;rica, puede usarse para dividir otros tipos de cadenas (wchar, etc. o UTF-8) usando todo tipo de delimitadores.</target>
        </trans-unit>
        <trans-unit id="1b3c86d3a6486e114dab28e263dacbf6a3306c6b" translate="yes" xml:space="preserve">
          <source>This example gives the output -</source>
          <target state="translated">Este ejemplo da la salida -</target>
        </trans-unit>
        <trans-unit id="c769bf1282bd7c3be136c3c14a81ae993c455324" translate="yes" xml:space="preserve">
          <source>This is my favorite way to iterate through a string. You can do whatever you want per word.</source>
          <target state="translated">Esta es mi forma favorita de iterar a través de una cuerda.Puedes hacer lo que quieras por palabra.</target>
        </trans-unit>
        <trans-unit id="e22101f4f90eb21775516823db9e88caba9d9f7d" translate="yes" xml:space="preserve">
          <source>This is similar to Stack&amp;nbsp;Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c&quot;&gt;How do I tokenize a string in C++?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Esto es similar a la pregunta de desbordamiento de pila &amp;iquest; &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c&quot;&gt;C&amp;oacute;mo tokenizo una cadena en C ++?&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fe7b02c0b7fcd609149b7d62126921ead63257e3" translate="yes" xml:space="preserve">
          <source>To keep empty entries (by default empties will be excluded):</source>
          <target state="translated">Para mantener las entradas vacías (por defecto se excluirán los vacíos):</target>
        </trans-unit>
        <trans-unit id="93b920172684c22d81bc0d960c610f3b8f689afc" translate="yes" xml:space="preserve">
          <source>To use it with a vector of strings (Edit: Since someone pointed out not to inherit STL classes... hrmf ;) ) :</source>
          <target state="translated">Para usarlo con un vector de cuerdas (Editar:Ya que alguien señaló no heredar las clases de STL...hrmf ;)):</target>
        </trans-unit>
        <trans-unit id="2e911d11c79fa6e8338a0ec81f67859eba88f7d8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;std::stringstream&lt;/code&gt; as you have works perfectly fine, and do exactly what you wanted. If you're just looking for different way of doing things though, you can use &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find&quot;&gt;&lt;code&gt;std::find()&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find_first_of&quot;&gt;&lt;code&gt;std::find_first_of()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/substr&quot;&gt;&lt;code&gt;std::string::substr()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Usar &lt;code&gt;std::stringstream&lt;/code&gt; como lo ha hecho funciona perfectamente bien y hacer exactamente lo que quer&amp;iacute;a. Sin embargo, si solo est&amp;aacute; buscando una forma diferente de hacer las cosas, puede usar &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find&quot;&gt; &lt;code&gt;std::find()&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find_first_of&quot;&gt; &lt;code&gt;std::find_first_of()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/substr&quot;&gt; &lt;code&gt;std::string::substr()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7193f7a53cfe214ffe06f99029f6ee29bdef2653" translate="yes" xml:space="preserve">
          <source>What about this:</source>
          <target state="translated">¿Qué hay de esto?</target>
        </trans-unit>
        <trans-unit id="d713ca8d870cdfeb112abd654479d42242f3e918" translate="yes" xml:space="preserve">
          <source>Will output:</source>
          <target state="translated">Saldrá:</target>
        </trans-unit>
        <trans-unit id="5d81f64d4366d191a3ca38ee4fbfad99f8b4b7a2" translate="yes" xml:space="preserve">
          <source>Yet another flexible and fast way</source>
          <target state="translated">Otra forma flexible y rápida</target>
        </trans-unit>
        <trans-unit id="b8ad87877e333c9158dc06959d9121266c779f94" translate="yes" xml:space="preserve">
          <source>accepts multiple delimiters</source>
          <target state="translated">acepta múltiples delimitadores</target>
        </trans-unit>
        <trans-unit id="de73eac0c305038f0437bc6a1f994a5a4379ed28" translate="yes" xml:space="preserve">
          <source>an</source>
          <target state="translated">an</target>
        </trans-unit>
        <trans-unit id="1028f44eb0896c7451136d0f6e58eb2118691f1d" translate="yes" xml:space="preserve">
          <source>can use any string as delimiter, also can be used with binary data (std::string supports binary data, including nulls)</source>
          <target state="translated">puede utilizar cualquier cadena como delimitador,también se puede utilizar con datos binarios (std::string soporta datos binarios,incluyendo nulos)</target>
        </trans-unit>
        <trans-unit id="da81ca0e477c7b07303dc4b796a57547c89b20ed" translate="yes" xml:space="preserve">
          <source>change all &lt;code&gt;sregex_token_iterator&lt;/code&gt; to &lt;code&gt;wsregex_token_iterator&lt;/code&gt;</source>
          <target state="translated">cambie todo &lt;code&gt;sregex_token_iterator&lt;/code&gt; a &lt;code&gt;wsregex_token_iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ba6f0eafff4f195043d9ca955616d7781f08d24" translate="yes" xml:space="preserve">
          <source>change all &lt;code&gt;std::regex&lt;/code&gt; to &lt;code&gt;std::wregex&lt;/code&gt;</source>
          <target state="translated">cambiar todo &lt;code&gt;std::regex&lt;/code&gt; a &lt;code&gt;std::wregex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65f449d134d2005340cabace69bd7e0efc454270" translate="yes" xml:space="preserve">
          <source>cstring</source>
          <target state="translated">cstring</target>
        </trans-unit>
        <trans-unit id="c3499c2729730a7f807efb8676a92dcb6f8a3f8f" translate="yes" xml:space="preserve">
          <source>example</source>
          <target state="translated">example</target>
        </trans-unit>
        <trans-unit id="8a1e7cb60b05f12ba21bd9eac3c5ab6bc4e4b943" translate="yes" xml:space="preserve">
          <source>ignores empty tokens (can easily be changed)</source>
          <target state="translated">ignora las fichas vacías (se pueden cambiar fácilmente)</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="translated">is</target>
        </trans-unit>
        <trans-unit id="3b59820c89e372d8d136229501895f9f8b1ff990" translate="yes" xml:space="preserve">
          <source>is generic</source>
          <target state="translated">es genérico</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="79620d35c76fd53c042f55457d80adf808303eb0" translate="yes" xml:space="preserve">
          <source>uses standard C++ (no boost)</source>
          <target state="translated">utiliza el estándar C++(no hay impulso)</target>
        </trans-unit>
        <trans-unit id="a2cddef2f25af8d8750e5e21bb62b1d96d3f5636" translate="yes" xml:space="preserve">
          <source>using:</source>
          <target state="translated">using:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
