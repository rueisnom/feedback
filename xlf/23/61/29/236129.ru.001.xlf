<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/236129">
    <body>
      <group id="236129">
        <trans-unit id="edcb0f44cc7dfb094ba440e1b7696a327b163cfe" translate="yes" xml:space="preserve">
          <source>... or create the &lt;code&gt;vector&lt;/code&gt; directly:</source>
          <target state="translated">... или создайте &lt;code&gt;vector&lt;/code&gt; напрямую:</target>
        </trans-unit>
        <trans-unit id="daf67907bca13add6181e99993d1c333b0460b26" translate="yes" xml:space="preserve">
          <source>A good point is that in &lt;code&gt;separators&lt;/code&gt; you can pass more than one character.</source>
          <target state="translated">Хорошим моментом является то, что в &lt;code&gt;separators&lt;/code&gt; вы можете передать более одного символа.</target>
        </trans-unit>
        <trans-unit id="3885f98f0b7796bc84d063ed9149766d457a3c80" translate="yes" xml:space="preserve">
          <source>A possible solution using Boost might be:</source>
          <target state="translated">Возможным решением может быть использование Boost:</target>
        </trans-unit>
        <trans-unit id="c3721b3abeee59011fa0e483bff445ac1cd186ad" translate="yes" xml:space="preserve">
          <source>Additionally it does not do the (extremely inefficient) return of result, but rather it passes the tokens as a reference, thus also allowing you to build up tokens using multiple calls if you so wished.</source>
          <target state="translated">Кроме того,он не производит (крайне неэффективный)возврат результата,а скорее передает маркеры в качестве ссылки,что также позволяет вам строить маркеры с помощью нескольких вызовов,если вы того пожелаете.</target>
        </trans-unit>
        <trans-unit id="60f636a484c97d6136fbab261aac3f0769baa3e3" translate="yes" xml:space="preserve">
          <source>All it needs is &lt;code&gt;std::string&lt;/code&gt;... the rest are optional. It does not use streams or the boost library, but is flexible enough to be able to accept some of these foreign types naturally.</source>
          <target state="translated">Все, что ему нужно, это &lt;code&gt;std::string&lt;/code&gt; ... остальное необязательно. Он не использует потоки или библиотеку надстройки, но достаточно гибок, чтобы иметь возможность естественным образом принимать некоторые из этих внешних типов.</target>
        </trans-unit>
        <trans-unit id="c9c6db698f80734384e3824d88d70b12ee11ad29" translate="yes" xml:space="preserve">
          <source>And just because it does not implement a &lt;code&gt;typedef&lt;/code&gt; called iterator or overload the &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; operator does not mean it is bad code. I use C functions quite frequently. For example, &lt;a href=&quot;http://en.cppreference.com/w/c/io/fprintf&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/c/io/fscanf&quot;&gt;&lt;code&gt;scanf&lt;/code&gt;&lt;/a&gt; both are faster than &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cin&quot;&gt;&lt;code&gt;std::cin&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cout&quot;&gt;&lt;code&gt;std::cout&lt;/code&gt;&lt;/a&gt; (significantly), the &lt;a href=&quot;http://en.cppreference.com/w/c/io/fopen&quot;&gt;&lt;code&gt;fopen&lt;/code&gt;&lt;/a&gt; syntax is a lot more friendly for binary types, and they also tend to produce smaller EXEs.</source>
          <target state="translated">И только потому, что он не реализует определение типа, называемое итератором или перегрузкой, оператор &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; не означает, что это плохой код. Я использую функции C довольно часто. Например, &lt;a href=&quot;http://en.cppreference.com/w/c/io/fprintf&quot;&gt; &lt;code&gt;printf&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;http://en.cppreference.com/w/c/io/fscanf&quot;&gt; &lt;code&gt;scanf&lt;/code&gt; &lt;/a&gt; работают быстрее, чем &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cin&quot;&gt; &lt;code&gt;std::cin&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;http://en.cppreference.com/w/cpp/io/cout&quot;&gt; &lt;code&gt;std::cout&lt;/code&gt; &lt;/a&gt; (значительно), синтаксис &lt;a href=&quot;http://en.cppreference.com/w/c/io/fopen&quot;&gt; &lt;code&gt;fopen&lt;/code&gt; &lt;/a&gt; намного удобнее для двоичных типов, и они также имеют тенденцию создавать меньшие EXE-файлы.</target>
        </trans-unit>
        <trans-unit id="6870791be3a59b2da2de603a0be80d00918affe3" translate="yes" xml:space="preserve">
          <source>Don't get sold on this &lt;strong&gt;&quot;Elegance over performance&quot;&lt;/strong&gt; deal.</source>
          <target state="translated">Не продавайте по этой сделке &lt;strong&gt;&amp;laquo;Элегантность над производительностью&amp;raquo;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="12735fab994dcd7b5adae72726b9a46ab4afa992" translate="yes" xml:space="preserve">
          <source>Example code including convenient template:</source>
          <target state="translated">Пример кода,включающий удобный шаблон:</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">Пример использования:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="2705b643a0f80d229f05dcb52e5d3ae40b25b515" translate="yes" xml:space="preserve">
          <source>For example, this splits &quot;AQueryTrades&quot; into &quot;A&quot;, &quot;Query&quot; and &quot;Trades&quot;.  The function works with narrow and wide strings. Because it respects the current locale it splits &quot;Raumfahrt&amp;Uuml;berwachungsVerordnung&quot; into &quot;Raumfahrt&quot;, &quot;&amp;Uuml;berwachungs&quot; and &quot;Verordnung&quot;.</source>
          <target state="translated">Например, это разделяет &amp;laquo;AQueryTrades&amp;raquo; на &amp;laquo;A&amp;raquo;, &amp;laquo;Query&amp;raquo; и &amp;laquo;Trades&amp;raquo;. Функция работает с узкими и широкими строками. Поскольку он уважает текущую локализацию, он разделяет &amp;laquo;Raumfahrt&amp;Uuml;berwachungsVerordnung&amp;raquo; на &amp;laquo;Raumfahrt&amp;raquo;, &amp;laquo;Uberwachungs&amp;raquo; и &amp;laquo;Verordnung&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="de52debc28e040370100e81fc36a534b35a68c1a" translate="yes" xml:space="preserve">
          <source>For those with whom it does not sit well to sacrifice all efficiency for code size and see &quot;efficient&quot; as a type of elegance, the following should hit a sweet spot (and I think the template container class is an awesomely elegant addition.):</source>
          <target state="translated">Для тех,с кем он не сидит хорошо,чтобы пожертвовать всей эффективности для размера кода и видеть &quot;эффективным&quot;,как вид элегантности,следующие должны попасть в сладкое место (и я думаю,что класс шаблона контейнера является удивительно элегантным дополнением.):</target>
        </trans-unit>
        <trans-unit id="f805399e635e59badeb8d25438ef59ca9d0781ff" translate="yes" xml:space="preserve">
          <source>For what it's worth, here's another way to extract tokens from an input string, relying only on standard library facilities. It's an example of the power and elegance behind the design of the STL.</source>
          <target state="translated">Вот еще один способ извлечения токенов из входной строки,полагаясь только на стандартные средства библиотеки.Это пример мощи и элегантности,лежащих в основе дизайна STL.</target>
        </trans-unit>
        <trans-unit id="e6608506d839180b9e39fabbdc1e4720408a5c00" translate="yes" xml:space="preserve">
          <source>Get &lt;a href=&quot;http://www.boost.org/&quot;&gt;Boost&lt;/a&gt; ! : -)</source>
          <target state="translated">Получите &lt;a href=&quot;http://www.boost.org/&quot;&gt;Boost&lt;/a&gt; ! : -)</target>
        </trans-unit>
        <trans-unit id="829b1be11ab5027516a4c431a8773cbefd7348b8" translate="yes" xml:space="preserve">
          <source>Here is a split function that:</source>
          <target state="translated">Вот это разделение функций:</target>
        </trans-unit>
        <trans-unit id="4caf1473b9c810e10c38b1b0cdb53f2d370028f3" translate="yes" xml:space="preserve">
          <source>Here's a simple solution that uses only the standard regex library</source>
          <target state="translated">Вот простое решение,использующее только стандартную регекс-библиотеку.</target>
        </trans-unit>
        <trans-unit id="51e85e4e8113fb3e1f07e1727e78d73f5f0043e6" translate="yes" xml:space="preserve">
          <source>Here's an example:</source>
          <target state="translated">Вот пример:</target>
        </trans-unit>
        <trans-unit id="a780475444a036f8986b27e4e0681b9956fc67b0" translate="yes" xml:space="preserve">
          <source>Here's another solution. It's compact and reasonably efficient:</source>
          <target state="translated">Вот еще одно решение.Оно компактно и достаточно эффективно:</target>
        </trans-unit>
        <trans-unit id="78859cf5ab12634a3057d2cf55d540f4dd043078" translate="yes" xml:space="preserve">
          <source>Here's another way of doing it..</source>
          <target state="translated">Вот еще один способ...</target>
        </trans-unit>
        <trans-unit id="d30b6f4a9867c924c643828218cb2533ca6fed31" translate="yes" xml:space="preserve">
          <source>Heres a regex solution that only uses the standard regex library.  (I'm a little rusty, so there may be a few syntax errors, but this is at least the general idea)</source>
          <target state="translated">Речь идет о регекс-решении,использующем только стандартную регекс-библиотеку.(Я немного заржавел,так что может быть несколько синтаксических ошибок,но это,по крайней мере,общая идея).</target>
        </trans-unit>
        <trans-unit id="ad839725a134bd1b6392b1c21e805b0f7cc756d8" translate="yes" xml:space="preserve">
          <source>How do I iterate over the words of a string</source>
          <target state="translated">Как мне выполнить итерацию над словами строки...</target>
        </trans-unit>
        <trans-unit id="8164d0d639169c81b13b17bc3d347e5df03097ea" translate="yes" xml:space="preserve">
          <source>However, you can either use C's &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/strtok&quot;&gt;&lt;code&gt;strtok()&lt;/code&gt;&lt;/a&gt; function by using the &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/c_str&quot;&gt;&lt;code&gt;std::string::c_str()&lt;/code&gt;&lt;/a&gt; member, or you can write your own. Here is a code sample I found after a quick Google search (&lt;strong&gt;&quot;STL string split&quot;&lt;/strong&gt;):</source>
          <target state="translated">Однако вы можете либо использовать функцию &lt;a href=&quot;http://en.cppreference.com/w/c/string/byte/strtok&quot;&gt; &lt;code&gt;strtok()&lt;/code&gt; &lt;/a&gt; C, используя член &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/c_str&quot;&gt; &lt;code&gt;std::string::c_str()&lt;/code&gt; &lt;/a&gt; , либо написать свою собственную. Вот пример кода, который я нашел после быстрого поиска в Google ( &lt;strong&gt;&amp;laquo;разделение строки STL&amp;raquo;&lt;/strong&gt; ):</target>
        </trans-unit>
        <trans-unit id="edbd5b3edc642567da5a827b6b2f8804da091757" translate="yes" xml:space="preserve">
          <source>I have a 2 lines solution to this problem:</source>
          <target state="translated">У меня есть двухстрочное решение этой проблемы:</target>
        </trans-unit>
        <trans-unit id="d9d3bf7ae6779586aa4c434765f7f1f0997b6b1f" translate="yes" xml:space="preserve">
          <source>I hope someone else can find this as useful as I do.</source>
          <target state="translated">Надеюсь,кто-нибудь другой найдет это столь же полезным,как и я.</target>
        </trans-unit>
        <trans-unit id="3a73403c1957cc0e33fdc441ae726cc999f4942c" translate="yes" xml:space="preserve">
          <source>I like the following because it puts the results into a vector, supports a string as a delim and gives control over keeping empty values. But, it doesn't look as good then.</source>
          <target state="translated">Мне нравится следующее,потому что он помещает результаты в вектор,поддерживает строку в качестве разделителя и дает контроль над сохранением пустых значений.Но тогда это выглядит не очень хорошо.</target>
        </trans-unit>
        <trans-unit id="70af1c7cf8dbf905cd7d9ae6fe84ef064af7b8b3" translate="yes" xml:space="preserve">
          <source>I like to use the boost/regex methods for this task since they provide maximum flexibility for specifying the splitting criteria.</source>
          <target state="translated">Мне нравится использовать методы boostregex для этой задачи,так как они обеспечивают максимальную гибкость при задании критериев разделения.</target>
        </trans-unit>
        <trans-unit id="a3e013d54b198746029363a080be9d65c71513bc" translate="yes" xml:space="preserve">
          <source>I made this because I needed an easy way to split strings and c-based strings... Hopefully someone else can find it useful as well. Also it doesn't rely on tokens and you can use fields as delimiters, which is another key I needed.</source>
          <target state="translated">Я сделал это,потому что мне нужен был простой способ разделить строки и строки на С-образной основе...Надеюсь,кто-нибудь другой тоже найдет это полезным.Также он не полагается на маркеры,и вы можете использовать поля в качестве разделителей,что является еще одним ключом,который мне был нужен.</target>
        </trans-unit>
        <trans-unit id="01bc5ba0fa755484bd526b58e86a0cea76a28bf8" translate="yes" xml:space="preserve">
          <source>I use this to split string by a delimiter. The first puts the results in a pre-constructed vector, the second returns a new vector.</source>
          <target state="translated">Я использую это,чтобы разделить строку на разделитель.Первый помещает результат в предварительно сконструированный вектор,второй возвращает новый вектор.</target>
        </trans-unit>
        <trans-unit id="d02b633661d0af2f5aac614aedf4fd95b95fc7fc" translate="yes" xml:space="preserve">
          <source>I usually choose to use &lt;code&gt;std::vector&amp;lt;std::string&amp;gt;&lt;/code&gt; types as my second parameter (&lt;code&gt;ContainerT&lt;/code&gt;)... but &lt;code&gt;list&amp;lt;&amp;gt;&lt;/code&gt; is way faster than &lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt; for when direct access is not needed, and you can even create your own string class and use something like &lt;code&gt;std::list&amp;lt;subString&amp;gt;&lt;/code&gt; where &lt;code&gt;subString&lt;/code&gt; does not do any copies for incredible speed increases.</source>
          <target state="translated">Я обычно выбираю типы &lt;code&gt;std::vector&amp;lt;std::string&amp;gt;&lt;/code&gt; качестве второго параметра ( &lt;code&gt;ContainerT&lt;/code&gt; ) ... но &lt;code&gt;list&amp;lt;&amp;gt;&lt;/code&gt; намного быстрее, чем &lt;code&gt;vector&amp;lt;&amp;gt;&lt;/code&gt; когда прямой доступ не нужен, и вы даже можете создать свой собственный строковый класс и используйте что-то вроде &lt;code&gt;std::list&amp;lt;subString&amp;gt;&lt;/code&gt; где &lt;code&gt;subString&lt;/code&gt; не делает никаких копий для невероятного увеличения скорости.</target>
        </trans-unit>
        <trans-unit id="98ba3b0af09fe29627f5fe02ee9af975d3e8d35b" translate="yes" xml:space="preserve">
          <source>I usually only check to split on spaces and commas, so I also have this default function:</source>
          <target state="translated">Обычно я проверяю только на пробелы и запятые,так что у меня также есть эта функция по умолчанию:</target>
        </trans-unit>
        <trans-unit id="8e91045629e7a5c9e98dde7928f173bbd7764caa" translate="yes" xml:space="preserve">
          <source>I'm sure there's improvements that can be made to even further improve its elegance and please do by all means</source>
          <target state="translated">Я уверен,что есть улучшения,которые могут быть сделаны,чтобы еще больше улучшить его элегантность и,пожалуйста,сделайте все возможное.</target>
        </trans-unit>
        <trans-unit id="a3b5e6ebe32255aa5a8cbb511d5478625952fbff" translate="yes" xml:space="preserve">
          <source>I'm trying to iterate over the words of a string.</source>
          <target state="translated">Я пытаюсь выполнить итерацию над словами струны.</target>
        </trans-unit>
        <trans-unit id="e5807a479143bdef2e06556aa0b30259912e246a" translate="yes" xml:space="preserve">
          <source>I've rolled my own using strtok and used boost to split a string.  The best method I have found is the &lt;a href=&quot;http://www.partow.net/programming/strtk/&quot;&gt;C++ String Toolkit Library&lt;/a&gt;.  It is incredibly flexible and fast.</source>
          <target state="translated">Я свернул свой собственный, используя strtok, и использовал boost, чтобы разбить строку. Лучший метод, который я нашел, - это &lt;a href=&quot;http://www.partow.net/programming/strtk/&quot;&gt;C ++ String Toolkit Library&lt;/a&gt; . Это невероятно гибкий и быстрый.</target>
        </trans-unit>
        <trans-unit id="80bd129398d2a58cb60b25313fb43865351f69bf" translate="yes" xml:space="preserve">
          <source>If splitting a string at multiple delimiters while skipping empty tokens is desired, this version may be used:</source>
          <target state="translated">Если желательно разделить строку на несколько разделителей и пропустить пустые маркеры,то можно использовать эту версию:</target>
        </trans-unit>
        <trans-unit id="7589cbcf380a78c9803a11402f160a9053a8278d" translate="yes" xml:space="preserve">
          <source>If you have questions about the code sample, leave a comment and I will explain.</source>
          <target state="translated">Если у Вас возникли вопросы по поводу примера кода,оставьте комментарий,и я объясню.</target>
        </trans-unit>
        <trans-unit id="4af4cc4098db3af77c2383b7caef397b8c5d31c3" translate="yes" xml:space="preserve">
          <source>If you like to use boost, but want to use a whole string as delimiter (instead of single characters as in most of the previously proposed solutions), you can use the &lt;code&gt;boost_split_iterator&lt;/code&gt;.</source>
          <target state="translated">Если вам нравится использовать boost, но вы хотите использовать целую строку в качестве разделителя (вместо отдельных символов, как в большинстве ранее предложенных решений), вы можете использовать &lt;code&gt;boost_split_iterator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a644a073e06e3986597fbf1fcf4f2d6a9c572e35" translate="yes" xml:space="preserve">
          <source>Instead of copying the extracted tokens to an output stream, one could insert them into a container, using the same generic &lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; algorithm.</source>
          <target state="translated">Вместо того, чтобы копировать извлеченные токены в выходной поток, их можно вставить в контейнер, используя тот же общий алгоритм &lt;a href=&quot;https://en.cppreference.com/w/cpp/algorithm/copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="06e57f321253a6ce49b846a26ffcbdfdd422b91f" translate="yes" xml:space="preserve">
          <source>Is there a more elegant way to do this?</source>
          <target state="translated">Есть ли более элегантный способ сделать это?</target>
        </trans-unit>
        <trans-unit id="ae8fe7d96f18b204a67c12bb20b01019014e820d" translate="yes" xml:space="preserve">
          <source>It can also be easily expanded to skip empty tokens:</source>
          <target state="translated">Его также можно легко расширить,чтобы пропустить пустые жетоны:</target>
        </trans-unit>
        <trans-unit id="e2ba82430e6d8796d64675e8c1fa0c82bcbabce7" translate="yes" xml:space="preserve">
          <source>It can easily be templatised to handle string separators, wide strings, etc.</source>
          <target state="translated">Его можно легко соблазнить для работы с струнными сепараторами,широкими струнами и т.д.</target>
        </trans-unit>
        <trans-unit id="28d90795bfb34c48b119d7f6cb9d197ea65a4073" translate="yes" xml:space="preserve">
          <source>It's more than double as fast as the fastest tokenize on this page and almost 5 times faster than some others. Also with the perfect parameter types you can eliminate all string and list copies for additional speed increases.</source>
          <target state="translated">Он более чем в два раза быстрее,чем самый быстрый токен на этой странице и почти в 5 раз быстрее,чем некоторые другие.Также с идеальными типами параметров вы можете исключить все копии строк и списков для дополнительного увеличения скорости.</target>
        </trans-unit>
        <trans-unit id="69d1271bac1d9c309e788d9ea67be98ca0e136bf" translate="yes" xml:space="preserve">
          <source>Lastly it allows you to specify whether to trim empty tokens from the results via a last optional parameter.</source>
          <target state="translated">Наконец,он позволяет указать,следует ли обрезать пустые маркеры из результатов с помощью последнего необязательного параметра.</target>
        </trans-unit>
        <trans-unit id="a1630c87ca12f86b482c8b5c22149b511943f7cb" translate="yes" xml:space="preserve">
          <source>Limited by imagination ;)</source>
          <target state="translated">Ограниченное воображением ;)</target>
        </trans-unit>
        <trans-unit id="2fe5047d67353f0846aa94b0fe23a67a2b32150c" translate="yes" xml:space="preserve">
          <source>Note &lt;code&gt;std::upper&lt;/code&gt; should be really passed as function template argument. Then the more generalized from of this function can split at delimiters like &lt;code&gt;&quot;,&quot;&lt;/code&gt;, &lt;code&gt;&quot;;&quot;&lt;/code&gt; or &lt;code&gt;&quot; &quot;&lt;/code&gt; too.</source>
          <target state="translated">Обратите внимание, что &lt;code&gt;std::upper&lt;/code&gt; действительно нужно передавать как аргумент шаблона функции. Тогда более обобщенный из этой функции может быть разделен на разделители, как &lt;code&gt;&quot;,&quot;&lt;/code&gt; , &lt;code&gt;&quot;;&quot;&lt;/code&gt; или &lt;code&gt;&quot; &quot;&lt;/code&gt; тоже.</target>
        </trans-unit>
        <trans-unit id="3af42b55fb6cb79a028f48fc9dddef7a1b09c406" translate="yes" xml:space="preserve">
          <source>Note that I'm not interested in C string functions or that kind of character manipulation/access. Also, please give precedence to elegance over efficiency in your answer.</source>
          <target state="translated">Обратите внимание,что меня не интересуют функции C string или подобного рода манипуляции с символами.Также,пожалуйста,отдайте предпочтение элегантности перед эффективностью в вашем ответе.</target>
        </trans-unit>
        <trans-unit id="1e2cb5802a91f46a1cfa9c5a877feee94d00ecb2" translate="yes" xml:space="preserve">
          <source>Note that splitting &lt;code&gt;&quot;&quot;&lt;/code&gt; results in a single empty string and splitting &lt;code&gt;&quot;,&quot;&lt;/code&gt; (ie. sep) results in two empty strings.</source>
          <target state="translated">Обратите внимание, что разделение &lt;code&gt;&quot;&quot;&lt;/code&gt; приводит к одной пустой строке, а разделение &lt;code&gt;&quot;,&quot;&lt;/code&gt; (т.е. sep) приводит к двум пустым строкам.</target>
        </trans-unit>
        <trans-unit id="2eed498a91867681e33df9807e93e65e867e0bff" translate="yes" xml:space="preserve">
          <source>Note that this solution does not skip empty tokens, so the following will find 4 items, one of which is empty:</source>
          <target state="translated">Обратите внимание,что это решение не пропускает пустые маркеры,поэтому ниже вы найдете 4 элемента,один из которых пуст:</target>
        </trans-unit>
        <trans-unit id="fe5714fb716282b1a9a1fc9fcd3bd604250fb787" translate="yes" xml:space="preserve">
          <source>Note, if you want to split &lt;code&gt;wstring&lt;/code&gt; instead of &lt;code&gt;string&lt;/code&gt;,</source>
          <target state="translated">Обратите внимание, если вы хотите разделить &lt;code&gt;wstring&lt;/code&gt; вместо &lt;code&gt;string&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="d172c279b9365bde131c6c6226972701d76e01c5" translate="yes" xml:space="preserve">
          <source>Note, you might also want to take the string argument by reference, depending on your compiler.</source>
          <target state="translated">Обратите внимание,что в зависимости от вашего компилятора,вы можете взять строковый аргумент по ссылке.</target>
        </trans-unit>
        <trans-unit id="94d45ad4e48fcad61e269a1e3312579ec200054b" translate="yes" xml:space="preserve">
          <source>Of course, Boost has a &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html#id3483755&quot;&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/a&gt; that works partially like that. And, if by 'white-space', you really do mean any type of white-space, using Boost's split with &lt;code&gt;is_any_of()&lt;/code&gt; works great.</source>
          <target state="translated">Конечно, в Boost есть функция &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html#id3483755&quot;&gt; &lt;code&gt;split()&lt;/code&gt; &lt;/a&gt; которая работает частично так. И, если под &amp;laquo;пробелами&amp;raquo; вы действительно подразумеваете любой тип пробелов, использование разделения Boost с &lt;code&gt;is_any_of()&lt;/code&gt; прекрасно работает.</target>
        </trans-unit>
        <trans-unit id="feefe8647d3c18455c7284d73e5e9b156c6be204" translate="yes" xml:space="preserve">
          <source>Recently I had to split a camel-cased word into subwords.  There are no delimiters, just upper characters.</source>
          <target state="translated">Недавно мне пришлось разделить слово в верблюжьей упряжке на подслова.Нет разделителей,только верхние символы.</target>
        </trans-unit>
        <trans-unit id="58fd97bc0d3ae9571cb48bf3cbc2a8e1eca6001f" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html&quot;&gt;documentation&lt;/a&gt; for details.</source>
          <target state="translated">Смотрите &lt;a href=&quot;http://www.boost.org/doc/libs/1_36_0/doc/html/string_algo/usage.html&quot;&gt;документацию&lt;/a&gt; для деталей.</target>
        </trans-unit>
        <trans-unit id="b8776bac563a3c1a8c473120ed91905a5d046e8c" translate="yes" xml:space="preserve">
          <source>Short and elegant</source>
          <target state="translated">Короткий и элегантный</target>
        </trans-unit>
        <trans-unit id="3f5a90e2a6ed10327b773e990c6e9c0718937bb8" translate="yes" xml:space="preserve">
          <source>So far I used the one in &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_C++_Libraries&quot;&gt;Boost&lt;/a&gt;, but I needed something that doesn't depends on it, so I came to this:</source>
          <target state="translated">До сих пор я использовал тот в &lt;a href=&quot;http://en.wikipedia.org/wiki/Boost_C++_Libraries&quot;&gt;Boost&lt;/a&gt; , но мне нужно что-то, что не зависит от этого, поэтому я пришел к этому:</target>
        </trans-unit>
        <trans-unit id="567e164602261d048d22e25b3917128629c66b84" translate="yes" xml:space="preserve">
          <source>StringSplitter.cpp:</source>
          <target state="translated">StringSplitter.cpp:</target>
        </trans-unit>
        <trans-unit id="fb0c5461cacf796c6e710a8542a3699900e2261b" translate="yes" xml:space="preserve">
          <source>StringSplitter.hpp:</source>
          <target state="translated">StringSplitter.hpp:</target>
        </trans-unit>
        <trans-unit id="87fdba3e4c7e285121516a72fc35fd71bc4a6cde" translate="yes" xml:space="preserve">
          <source>Taken from: &lt;a href=&quot;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&quot;&gt;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&lt;/a&gt;</source>
          <target state="translated">Взято из: &lt;a href=&quot;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&quot;&gt;http://oopweb.com/CPP/Documents/CPPHOWTO/Volume/C++Programming-HOWTO-7.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="27ce8f54f6936c89f8e51e510065e4a26b283c12" translate="yes" xml:space="preserve">
          <source>That's it! And that's just one way to use the tokenizer, like how to just 
count words:</source>
          <target state="translated">Вот так! И это всего лишь один из способов использовать токенайзер,например,как просто считать слова:</target>
        </trans-unit>
        <trans-unit id="1ca5e115b2a47f2d37422e0fdbcba3af6a5d68c4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.cplusplus.com/reference/sstream/stringstream/&quot;&gt;stringstream&lt;/a&gt; can be convenient if you need to parse the string by non-space symbols:</source>
          <target state="translated">Поток &lt;a href=&quot;http://www.cplusplus.com/reference/sstream/stringstream/&quot;&gt;строки&lt;/a&gt; может быть удобен, если вам нужно проанализировать строку по непробельным символам:</target>
        </trans-unit>
        <trans-unit id="8996313f0643de07b9f50a3028ea25719a41ceed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;[\\s,]+&quot;&lt;/code&gt; checks for spaces (&lt;code&gt;\\s&lt;/code&gt;) and commas (&lt;code&gt;,&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;&quot;[\\s,]+&quot;&lt;/code&gt; проверяет пробелы ( &lt;code&gt;\\s&lt;/code&gt; ) и запятые ( &lt;code&gt;,&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6440dc5c41f1e26931bf178eb530b739c544e1ac" translate="yes" xml:space="preserve">
          <source>The STL does not have such a method available already.</source>
          <target state="translated">В STL такого метода уже нет.</target>
        </trans-unit>
        <trans-unit id="40333814fcb573c6e93835452764a1fd1397b1c5" translate="yes" xml:space="preserve">
          <source>The best solution I have right now is:</source>
          <target state="translated">Лучшее решение,которое у меня сейчас есть:</target>
        </trans-unit>
        <trans-unit id="db7cbd55c362ea33208ce7a702e9447099a6f9c8" translate="yes" xml:space="preserve">
          <source>The goal was to make it similar to C#'s Split() method where splitting a string is as easy as:</source>
          <target state="translated">Целью было сделать его похожим на метод Split()на C#,где разбиение строки так же просто,как и разбиение строки:</target>
        </trans-unit>
        <trans-unit id="782c41e695434ee735cd0174735b03a0b9649dd4" translate="yes" xml:space="preserve">
          <source>The regex argument allows checking for multiple arguments (spaces, commas, etc.)</source>
          <target state="translated">Регекс-параметр позволяет проверять несколько аргументов (пробелы,запятые и т.д.).</target>
        </trans-unit>
        <trans-unit id="4d069b0b95a55b35a35a8b4b59549329da87bfe1" translate="yes" xml:space="preserve">
          <source>The string can be assumed to be composed of words separated by whitespace.</source>
          <target state="translated">Можно предположить,что строка состоит из слов,разделенных пробелами.</target>
        </trans-unit>
        <trans-unit id="79cdca9b5545e633e42e3fbbe559a2da01c3450f" translate="yes" xml:space="preserve">
          <source>The toolkit has much more flexibility than this simple example shows but its utility in parsing a string into useful elements is incredible.</source>
          <target state="translated">Инструментарий обладает гораздо большей гибкостью,чем показывает этот простой пример,но его полезность при разборе строки на полезные элементы просто невероятна.</target>
        </trans-unit>
        <trans-unit id="b9f02d4eee5583a864c93d46145ec1e7bda76eb3" translate="yes" xml:space="preserve">
          <source>Then instead of printing you can put it in a vector.</source>
          <target state="translated">Тогда вместо печати вы можете поместить его в вектор.</target>
        </trans-unit>
        <trans-unit id="b9fb5bf7a2591fc1e35a2993ba89c0b9e5a42d7c" translate="yes" xml:space="preserve">
          <source>There is a function named &lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstring/strtok/&quot;&gt;&lt;code&gt;strtok&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Есть функция с именем &lt;a href=&quot;http://www.cplusplus.com/reference/clibrary/cstring/strtok/&quot;&gt; &lt;code&gt;strtok&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7971e6a051104074fdae0f02322417b6eb5695a2" translate="yes" xml:space="preserve">
          <source>This</source>
          <target state="translated">This</target>
        </trans-unit>
        <trans-unit id="593e97883525d037a4f64854c6d74628bb9c3388" translate="yes" xml:space="preserve">
          <source>This answer takes the string and puts it into a vector of strings. It uses the boost library.</source>
          <target state="translated">Этот ответ берет строку и помещает ее в вектор строк.Он использует библиотеку boost.</target>
        </trans-unit>
        <trans-unit id="c631e791df3de892d29ad086f68ab5babfed0ac1" translate="yes" xml:space="preserve">
          <source>This approach might be even faster than the &lt;code&gt;stringstream&lt;/code&gt; approach. And since this is a generic template function it can be used to split other types of strings (wchar, etc. or UTF-8) using all kinds of delimiters.</source>
          <target state="translated">Этот подход может быть даже быстрее, чем подход &lt;code&gt;stringstream&lt;/code&gt; . А поскольку это общая шаблонная функция, ее можно использовать для разделения строк других типов (wchar и т. Д. Или UTF-8) с использованием всех видов разделителей.</target>
        </trans-unit>
        <trans-unit id="1b3c86d3a6486e114dab28e263dacbf6a3306c6b" translate="yes" xml:space="preserve">
          <source>This example gives the output -</source>
          <target state="translated">В этом примере выводится -</target>
        </trans-unit>
        <trans-unit id="c769bf1282bd7c3be136c3c14a81ae993c455324" translate="yes" xml:space="preserve">
          <source>This is my favorite way to iterate through a string. You can do whatever you want per word.</source>
          <target state="translated">Это мой любимый способ итерации через струну.Ты можешь делать все,что хочешь за слово.</target>
        </trans-unit>
        <trans-unit id="e22101f4f90eb21775516823db9e88caba9d9f7d" translate="yes" xml:space="preserve">
          <source>This is similar to Stack&amp;nbsp;Overflow question &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c&quot;&gt;How do I tokenize a string in C++?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Это похоже на вопрос переполнения стека. &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/53849/how-do-i-tokenize-a-string-in-c&quot;&gt;Как мне токенизировать строку в C ++?&lt;/a&gt;&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="fe7b02c0b7fcd609149b7d62126921ead63257e3" translate="yes" xml:space="preserve">
          <source>To keep empty entries (by default empties will be excluded):</source>
          <target state="translated">Сохранять пустые записи (по умолчанию пустые записи будут исключены):</target>
        </trans-unit>
        <trans-unit id="93b920172684c22d81bc0d960c610f3b8f689afc" translate="yes" xml:space="preserve">
          <source>To use it with a vector of strings (Edit: Since someone pointed out not to inherit STL classes... hrmf ;) ) :</source>
          <target state="translated">Использовать его с вектором строк (Правка:Так как кто-то указал не наследовать STL классы...hrmf ;)):</target>
        </trans-unit>
        <trans-unit id="2e911d11c79fa6e8338a0ec81f67859eba88f7d8" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;std::stringstream&lt;/code&gt; as you have works perfectly fine, and do exactly what you wanted. If you're just looking for different way of doing things though, you can use &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find&quot;&gt;&lt;code&gt;std::find()&lt;/code&gt;&lt;/a&gt;/&lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find_first_of&quot;&gt;&lt;code&gt;std::find_first_of()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/substr&quot;&gt;&lt;code&gt;std::string::substr()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Использование &lt;code&gt;std::stringstream&lt;/code&gt; как у вас, прекрасно работает и делает именно то, что вы хотели. Если вы просто ищете другой способ сделать что-то, вы можете использовать &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find&quot;&gt; &lt;code&gt;std::find()&lt;/code&gt; &lt;/a&gt; / &lt;a href=&quot;http://en.cppreference.com/w/cpp/algorithm/find_first_of&quot;&gt; &lt;code&gt;std::find_first_of()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;http://en.cppreference.com/w/cpp/string/basic_string/substr&quot;&gt; &lt;code&gt;std::string::substr()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7193f7a53cfe214ffe06f99029f6ee29bdef2653" translate="yes" xml:space="preserve">
          <source>What about this:</source>
          <target state="translated">А как насчет этого:</target>
        </trans-unit>
        <trans-unit id="d713ca8d870cdfeb112abd654479d42242f3e918" translate="yes" xml:space="preserve">
          <source>Will output:</source>
          <target state="translated">Выходит:</target>
        </trans-unit>
        <trans-unit id="5d81f64d4366d191a3ca38ee4fbfad99f8b4b7a2" translate="yes" xml:space="preserve">
          <source>Yet another flexible and fast way</source>
          <target state="translated">Еще один гибкий и быстрый способ</target>
        </trans-unit>
        <trans-unit id="b8ad87877e333c9158dc06959d9121266c779f94" translate="yes" xml:space="preserve">
          <source>accepts multiple delimiters</source>
          <target state="translated">принимает несколько разделителей</target>
        </trans-unit>
        <trans-unit id="de73eac0c305038f0437bc6a1f994a5a4379ed28" translate="yes" xml:space="preserve">
          <source>an</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1028f44eb0896c7451136d0f6e58eb2118691f1d" translate="yes" xml:space="preserve">
          <source>can use any string as delimiter, also can be used with binary data (std::string supports binary data, including nulls)</source>
          <target state="translated">может использовать любую строку в качестве разделителя,также может использоваться с бинарными данными (std::string поддерживает бинарные данные,включая нули)</target>
        </trans-unit>
        <trans-unit id="da81ca0e477c7b07303dc4b796a57547c89b20ed" translate="yes" xml:space="preserve">
          <source>change all &lt;code&gt;sregex_token_iterator&lt;/code&gt; to &lt;code&gt;wsregex_token_iterator&lt;/code&gt;</source>
          <target state="translated">изменить все &lt;code&gt;sregex_token_iterator&lt;/code&gt; на &lt;code&gt;wsregex_token_iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ba6f0eafff4f195043d9ca955616d7781f08d24" translate="yes" xml:space="preserve">
          <source>change all &lt;code&gt;std::regex&lt;/code&gt; to &lt;code&gt;std::wregex&lt;/code&gt;</source>
          <target state="translated">изменить все &lt;code&gt;std::regex&lt;/code&gt; на &lt;code&gt;std::wregex&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65f449d134d2005340cabace69bd7e0efc454270" translate="yes" xml:space="preserve">
          <source>cstring</source>
          <target state="translated">cstring</target>
        </trans-unit>
        <trans-unit id="c3499c2729730a7f807efb8676a92dcb6f8a3f8f" translate="yes" xml:space="preserve">
          <source>example</source>
          <target state="translated">example</target>
        </trans-unit>
        <trans-unit id="8a1e7cb60b05f12ba21bd9eac3c5ab6bc4e4b943" translate="yes" xml:space="preserve">
          <source>ignores empty tokens (can easily be changed)</source>
          <target state="translated">игнорирует пустые маркеры (легко меняется)</target>
        </trans-unit>
        <trans-unit id="b47f363e2b430c0647f14deea3eced9b0ef300ce" translate="yes" xml:space="preserve">
          <source>is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b59820c89e372d8d136229501895f9f8b1ff990" translate="yes" xml:space="preserve">
          <source>is generic</source>
          <target state="translated">универсальный</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="79620d35c76fd53c042f55457d80adf808303eb0" translate="yes" xml:space="preserve">
          <source>uses standard C++ (no boost)</source>
          <target state="translated">использует стандартный C++(без усиления)</target>
        </trans-unit>
        <trans-unit id="a2cddef2f25af8d8750e5e21bb62b1d96d3f5636" translate="yes" xml:space="preserve">
          <source>using:</source>
          <target state="translated">using:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
