<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/332365">
    <body>
      <group id="332365">
        <trans-unit id="f5dccbefc9eb641263e9035c2feacfbb42ddecab" translate="yes" xml:space="preserve">
          <source>' )</source>
          <target state="translated">')</target>
        </trans-unit>
        <trans-unit id="a0f651cde227a7b6a2f745cc1abcae1e478af7dd" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;All code examples in this answer were run on a PostgreSQL 9.1.2 database server.&lt;/em&gt;)</source>
          <target state="translated">( &lt;em&gt;이 답변의 모든 코드 예제는 PostgreSQL 9.1.2 데이터베이스 서버에서 실행되었습니다.&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="2e2f5034350c8def8869f07ee89d9d21bf27cfa2" translate="yes" xml:space="preserve">
          <source>(for example) to add the new student, where the &lt;code&gt;$xxx&lt;/code&gt; variable contents was taken directly out of an HTML form, without checking format nor escaping special characters.</source>
          <target state="translated">예를 들어 &lt;code&gt;$xxx&lt;/code&gt; 변수 내용이 형식을 확인하거나 특수 문자를 이스케이프하지 않고 HTML 양식에서 직접 가져온 새 학생을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fdfe2e70fde31449eb3c2bab22ca555028d85e07" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Source: &lt;a href=&quot;https://xkcd.com/327/&quot;&gt;https://xkcd.com/327/&lt;/a&gt;)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(출처 : &lt;a href=&quot;https://xkcd.com/327/&quot;&gt;https://xkcd.com/327/&lt;/a&gt; )&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22e2aaa76f874c66b707cacfaa9f76f22b05d735" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It drops the students table.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;학생 테이블을 떨어 뜨립니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7df5880bf1ba6e654e04c1e22cc8c944922f40cc" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;sup&gt;Edited &lt;strong&gt;&lt;em&gt;again&lt;/em&gt;&lt;/strong&gt; as per &lt;a href=&quot;https://stackoverflow.com/users/287586/dan04&quot;&gt;dan04&lt;/a&gt;'s astute comment&lt;/sup&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/users/287586/dan04&quot;&gt;dan04&lt;/a&gt; 의 독창적 인 설명에 따라 &lt;strong&gt;&lt;em&gt;다시&lt;/em&gt;&lt;/strong&gt; 편집&lt;/sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="bb625ab0058fc67ab4b565ae8d8e1039f625de02" translate="yes" xml:space="preserve">
          <source>A single quote is the start and end of a string. A semicolon is the end of a statement. So if they were doing a select like this:</source>
          <target state="translated">작은 따옴표는 문자열의 시작과 끝입니다. 세미콜론은 문장의 끝입니다. 그래서 그들이 이와 같은 선택을하고 있다면 :</target>
        </trans-unit>
        <trans-unit id="019a59a22cb46f0149dfc5d8931593e59be710d8" translate="yes" xml:space="preserve">
          <source>Add a new record to the Students table with a Name value of 'Robert'</source>
          <target state="translated">이름 값이 'Robert'인 Students 테이블에 새 레코드를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="9fc8a6c3ef2f442e2ab6de0ab4090a41c331c51f" translate="yes" xml:space="preserve">
          <source>After the values from the first name, middle name textbox &lt;em&gt;FNMName.Text&lt;/em&gt; (which is &lt;code&gt;Robert'); DROP TABLE STUDENTS; --&lt;/code&gt;) and the last name textbox &lt;em&gt;LName.Text&lt;/em&gt; (let's call it &lt;code&gt;Derper&lt;/code&gt;) are concatenated with the rest of the query, the result is now actually &lt;em&gt;two queries&lt;/em&gt; separated by the &lt;a href=&quot;http://en.wikipedia.org/wiki/SQL#Language_elements&quot;&gt;statement terminator&lt;/a&gt; (semicolon).  The second query has been &lt;strong&gt;injected&lt;/strong&gt; into the first.  When the code executes this query against the database, it will look like this</source>
          <target state="translated">이름의 값 뒤에 중간 이름 텍스트 상자 &lt;em&gt;FNMName.Text&lt;/em&gt; ( &lt;code&gt;Robert'); DROP TABLE STUDENTS; --&lt;/code&gt; 드롭 테이블 학생; - )와 성 텍스트 상자 &lt;em&gt;LName.Text&lt;/em&gt; ( &lt;em&gt;Derper&lt;/em&gt; 라고 함)는 나머지 쿼리와 연결되며 결과는 실제로 &lt;a href=&quot;http://en.wikipedia.org/wiki/SQL#Language_elements&quot;&gt;명령문 종료 자&lt;/a&gt; (세미콜론)로 구분 된 &lt;em&gt;두 개의 쿼리&lt;/em&gt; 입니다. 두 번째 쿼리는 첫 번째 쿼리에 &lt;strong&gt;삽입&lt;/strong&gt; 되었습니다. 코드가 데이터베이스에 대해이 쿼리를 실행하면 다음과 같이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="131934a34697f59c9b548cee1ee07df44489f026" translate="yes" xml:space="preserve">
          <source>And someone enters the name &lt;code&gt;Robert'); DROP TABLE STUDENTS; --&lt;/code&gt;</source>
          <target state="translated">그리고 누군가 &lt;code&gt;Robert'); DROP TABLE STUDENTS; --&lt;/code&gt; 이름을 입력 ); 드롭 테이블 학생; -</target>
        </trans-unit>
        <trans-unit id="b200166f579d9d7d277600fbbc63e5e7c3c3bd94" translate="yes" xml:space="preserve">
          <source>As everyone else has pointed out already, the &lt;code&gt;');&lt;/code&gt; closes the original statement and then a second statement follows. Most frameworks, including languages like PHP, have default security settings by now that don't allow multiple statements in one SQL string. In PHP, for example, you can only run multiple statements in one SQL string by using the &lt;code&gt;mysqli_multi_query&lt;/code&gt; function.</source>
          <target state="translated">다른 사람들이 이미 지적했듯이 &lt;code&gt;');&lt;/code&gt; 원래 문장을 닫고 두 번째 문장이 이어집니다. PHP와 같은 언어를 포함한 대부분의 프레임 워크에는 기본 보안 설정이있어 하나의 SQL 문자열에 여러 명령문을 허용하지 않습니다. 예를 들어, PHP에서는 &lt;code&gt;mysqli_multi_query&lt;/code&gt; 함수를 사용하여 하나의 SQL 문자열에서만 여러 명령문을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa7e84b685e35609e43c1cebf379c461d7c891aa" translate="yes" xml:space="preserve">
          <source>As noted by the XKCD comic, one way of protecting against SQL injection attacks is to sanitize database inputs, such as by escaping special characters, so that they cannot modify the underlying SQL command and therefore cannot cause execution of arbitrary SQL code.  If you use parameterized queries, such as by using &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/yy6y35y8.aspx&quot;&gt;&lt;code&gt;SqlParameter&lt;/code&gt;&lt;/a&gt; in ADO.NET, the input will, at minimum, be automatically sanitized to guard against SQL injection.</source>
          <target state="translated">XKCD 만화에서 알 수 있듯이 SQL 삽입 공격을 방지하는 한 가지 방법은 특수 문자를 이스케이프 처리하는 등의 방법으로 기본 SQL 명령을 수정할 수 없으므로 임의의 SQL 코드가 실행될 수 없도록 데이터베이스 입력을 삭제하는 것입니다. ADO.NET에서 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/yy6y35y8.aspx&quot;&gt; &lt;code&gt;SqlParameter&lt;/code&gt; &lt;/a&gt; 를 사용하는 등의 매개 변수화 된 쿼리를 사용하는 경우 SQL 주입을 방지하기 위해 최소한 입력이 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="87829ea42fc70807b5291e8b0b9f0e46c8bca893" translate="yes" xml:space="preserve">
          <source>But a clever user can supply whatever they want:</source>
          <target state="translated">그러나 영리한 사용자는 원하는 것을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce2f5da38f14260cb520df0b6cf6ea2e91248b7c" translate="yes" xml:space="preserve">
          <source>Delete the Students table</source>
          <target state="translated">학생 테이블 삭제</target>
        </trans-unit>
        <trans-unit id="c5a98777d68005235e5c5992186f39d71f52499d" translate="yes" xml:space="preserve">
          <source>Everything past the second query is &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms181627.aspx&quot;&gt;marked as a comment&lt;/a&gt;:  &lt;code&gt;--', 'Derper')&lt;/code&gt;</source>
          <target state="translated">두 번째 쿼리 이후의 모든 내용 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms181627.aspx&quot;&gt;은 주석으로 표시됩니다&lt;/a&gt; &lt;code&gt;--', 'Derper')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f33300310e5de518f91c41d40a5ef517fad1fdfe" translate="yes" xml:space="preserve">
          <source>Everything's fine. Now imagine you provide this string as the password:</source>
          <target state="translated">다 좋아. 이제이 문자열을 암호로 제공한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="c187e1d066434050adebcb225730c5347293b540" translate="yes" xml:space="preserve">
          <source>Example of PHP vulnerable code using PDO:</source>
          <target state="translated">PDO를 사용하는 PHP 취약한 코드의 예 :</target>
        </trans-unit>
        <trans-unit id="26ed4305eca2e4ca311ed3cb1f6c8de24c1bae8b" translate="yes" xml:space="preserve">
          <source>FWIW, I also think the comic in question has an important detail wrong: if you're thinking about &lt;em&gt;sanitizing&lt;/em&gt; your database inputs, as the comic suggests, you're still doing it wrong. Instead, you should think in terms of &lt;em&gt;quarantining&lt;/em&gt; your database inputs, and the correct way to do this is via parameterized queries.</source>
          <target state="translated">FWIW, 나는 또한 문제의 만화가 중요한 세부 사항이 잘못되었다고 생각합니다. 만화가 제안한 것처럼 데이터베이스 입력을 &lt;em&gt;살균&lt;/em&gt; 하는 것에 대해 생각하고 있다면 여전히 잘못하고 있습니다. 대신 데이터베이스 입력을 &lt;em&gt;격리&lt;/em&gt; 하는 관점에서 생각해야하며이를 수행하는 올바른 방법은 매개 변수화 된 쿼리를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8379d9d413b61d4aa6abb0ecd900209b2ade4480" translate="yes" xml:space="preserve">
          <source>How does the SQL injection from the “Bobby Tables” XKCD comic work</source>
          <target state="translated">&quot;Bobby Tables&quot;XKCD 만화에서 SQL 삽입은 어떻게 작동합니까</target>
        </trans-unit>
        <trans-unit id="7764fec83ece4bf060d4c0efc0b3928e567ed559" translate="yes" xml:space="preserve">
          <source>However, sanitizing inputs at the application level may not stop more advanced SQL injection techniques. For example, &lt;a href=&quot;https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string&quot;&gt;there are ways to circumvent the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; PHP function&lt;/a&gt;. For added protection, many database systems support &lt;a href=&quot;https://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;&lt;em&gt;prepared statements&lt;/em&gt;&lt;/a&gt;. If properly implemented in the backend, prepared statements can make SQL injection impossible by treating data inputs as semantically separate from the rest of the command.</source>
          <target state="translated">그러나 응용 프로그램 수준에서 입력을 삭제해도 고급 SQL 주입 기술이 중단되지 않을 수 있습니다. 예를 들어, &lt;a href=&quot;https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string&quot;&gt; &lt;code&gt;mysql_real_escape_string&lt;/code&gt; PHP 함수를 우회하는 방법이 있습니다&lt;/a&gt; . 추가 보호를 위해 많은 데이터베이스 시스템이 &lt;a href=&quot;https://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;&lt;em&gt;준비된 명령문을&lt;/em&gt;&lt;/a&gt; 지원 &lt;em&gt;합니다&lt;/em&gt; . 백엔드에서 올바르게 구현 된 경우 준비된 명령문은 데이터 입력을 의미 적으로 나머지 명령과 분리하여 처리하여 SQL 삽입을 불가능하게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5cfce95e395b48a50005b91951a8e612e3b5b9" translate="yes" xml:space="preserve">
          <source>I know both &lt;code&gt;'&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; are for comments, but doesn't the word &lt;code&gt;DROP&lt;/code&gt; get commented as well since it is part of the same line?</source>
          <target state="translated">나는 &lt;code&gt;'&lt;/code&gt; 와 &lt;code&gt;--&lt;/code&gt; 가 모두 주석 이라는 것을 알고 있지만 같은 줄의 일부이기 때문에 &lt;code&gt;DROP&lt;/code&gt; 이라는 단어도 주석을 달지 않습니까?</target>
        </trans-unit>
        <trans-unit id="a604718c1a9d707cb8e65adc266b636e6570cdff" translate="yes" xml:space="preserve">
          <source>INSERT INTO Students VALUES ( '</source>
          <target state="translated">학생의 가치관에 삽입 ( '</target>
        </trans-unit>
        <trans-unit id="461191a3dafd5a83379f796a40bfa1b1193c6cd3" translate="yes" xml:space="preserve">
          <source>If student_name is the one given, that does the selection with the name &quot;Robert&quot; and then drops the table.  The &quot;-- &quot; part changes the rest of the given query into a comment.</source>
          <target state="translated">student_name이 주어진 이름이면 &quot;Robert&quot;라는 이름으로 선택을 수행 한 다음 테이블을 삭제합니다. &quot;-&quot;부분은 주어진 쿼리의 나머지 부분을 주석으로 변경합니다.</target>
        </trans-unit>
        <trans-unit id="139dafd9d52972e29c58ae782bf096e4a550dcc5" translate="yes" xml:space="preserve">
          <source>If you provide &lt;code&gt;peter&lt;/code&gt; as the username and &lt;code&gt;secret&lt;/code&gt; as the password, the resulting SQL string would look like this:</source>
          <target state="translated">&lt;code&gt;peter&lt;/code&gt; 을 사용자 이름으로 제공하고 &lt;code&gt;secret&lt;/code&gt; 을 암호로 제공하면 결과 SQL 문자열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9bdf72b4d7e09fec8b6e948d4c391a1889ecf5d9" translate="yes" xml:space="preserve">
          <source>In this case, ' is not a comment character.  It's used to delimit string literals.  The comic artist is banking on the idea that the school in question has dynamic sql somewhere that looks something like this:</source>
          <target state="translated">이 경우 '는 주석 문자가 아닙니다. 문자열 리터럴을 구분하는 데 사용됩니다. 만화가는 문제의 학교에 다음과 같은 동적 SQL이 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="19c6a7a74341e9efe95de0fdb1852846d3f4021e" translate="yes" xml:space="preserve">
          <source>It's important to notice that during the &lt;code&gt;INSERT&lt;/code&gt; operation the application isn't checking the input for any special characters, and is therefore allowing arbitrary input to be entered into the SQL command. This means that a malicious user can insert, into a field normally intended for user input, special symbols such as quotes along with arbitrary SQL code to cause the database system to execute it, hence &lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL&amp;nbsp;&lt;em&gt;injection&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; 조작 중에 응용 프로그램은 특수 문자에 대한 입력을 점검하지 않으므로 SQL 명령에 임의의 입력을 입력 할 수 있습니다. 이는 악의적 인 사용자가 일반적으로 사용자 입력을 목적으로하는 필드에 따옴표와 같은 특수 기호를 임의의 SQL 코드와 함께 삽입하여 데이터베이스 시스템이이를 실행하도록하여 &lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL &lt;em&gt;주입&lt;/em&gt;&lt;/a&gt; 을 수행 할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a912262d2aa40547772a8e800c0f213bec8d8d54" translate="yes" xml:space="preserve">
          <source>Just looking at:</source>
          <target state="translated">그냥보고 :</target>
        </trans-unit>
        <trans-unit id="49aa9e517ee2cc59732b724e9ab3b7522a1ed9ce" translate="yes" xml:space="preserve">
          <source>Let's assume the application uses the following SQL to insert data into the table:</source>
          <target state="translated">애플리케이션이 다음 SQL을 사용하여 데이터를 테이블에 삽입한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="30b44dcf7150c4c363ba1edcf66e4cf3db5207e2" translate="yes" xml:space="preserve">
          <source>Let's say the name was used in a variable, &lt;code&gt;$Name&lt;/code&gt;.  You then run this query:</source>
          <target state="translated">이름이 변수 &lt;code&gt;$Name&lt;/code&gt; 에 사용되었다고 가정 해 봅시다. 그런 다음이 쿼리를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="8d860cdc3777611007e2d6ff4d20e28c2a6d7ead" translate="yes" xml:space="preserve">
          <source>Mmm, I am too slow, I see already 8 answers before mine in the orange band... :-) A popular topic, it seems.</source>
          <target state="translated">음, 나는 너무 느리다. 나는 주황색 밴드에서 나의 앞에 8 개의 대답을 벌써 본다. :-) 대중적인 주제, 그것은 보인다.</target>
        </trans-unit>
        <trans-unit id="d91e053c54896e652403b7bc76d0d5c47b82c0e8" translate="yes" xml:space="preserve">
          <source>Mom supposed the database programmer made a request looking like:</source>
          <target state="translated">엄마는 데이터베이스 프로그래머가 다음과 같이 요청했다고 가정했습니다.</target>
        </trans-unit>
        <trans-unit id="96bb971af970b55c072ef0967dfb0650a326ca16" translate="yes" xml:space="preserve">
          <source>Mostly we will try to patch forms input. But this is not the only place where you can get attacked with SQL injection. You can do very simple attack with URL which send data through GET request;
Consider the fallowing example:</source>
          <target state="translated">대부분 양식 입력을 패치하려고합니다. 그러나 이것이 SQL 인젝션으로 공격받을 수있는 유일한 곳은 아닙니다. GET 요청을 통해 데이터를 보내는 URL로 매우 간단한 공격을 수행 할 수 있습니다. 다음 예를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="bc011a90b27267bbf94983c51810cde1d11b8154" translate="yes" xml:space="preserve">
          <source>No one pointed this out before so through I might alert some of you.</source>
          <target state="translated">아무도 당신을 경고하기 전에 이것을 지적하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="db882356d5143646304aa5d620f5a86bb8a20a10" translate="yes" xml:space="preserve">
          <source>No, &lt;code&gt;'&lt;/code&gt; isn't a comment in SQL, but a delimiter.</source>
          <target state="translated">아니요, &lt;code&gt;'&lt;/code&gt; 는 SQL의 주석이 아니라 구분 기호입니다.</target>
        </trans-unit>
        <trans-unit id="4d11e639fabc057421eb05c7aa5bad84e45a7b76" translate="yes" xml:space="preserve">
          <source>Now someone could try something like this</source>
          <target state="translated">이제 누군가 이런 식으로 시도 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="de20cc0fa527aedc63635b0e9bb07117e87ba818" translate="yes" xml:space="preserve">
          <source>Now the query would be something like this (to search the student table)</source>
          <target state="translated">이제 쿼리는 다음과 같습니다 (학생 테이블을 검색하기 위해)</target>
        </trans-unit>
        <trans-unit id="7646e113eeae59dc18798a0466c8a3f0c8a20b6b" translate="yes" xml:space="preserve">
          <source>On some systems, the &lt;code&gt;select&lt;/code&gt; would get ran first followed by the &lt;code&gt;drop&lt;/code&gt; statement! The message is: DONT EMBED VALUES INTO YOUR SQL. Instead use parameters!</source>
          <target state="translated">일부 시스템에서는 &lt;code&gt;select&lt;/code&gt; 가 먼저 실행 된 후 &lt;code&gt;drop&lt;/code&gt; 문이 실행됩니다! 메시지는 다음과 같습니다. SQL에 값이 없습니다. 대신 매개 변수를 사용하십시오!</target>
        </trans-unit>
        <trans-unit id="983c898ac23c7963028dec422bc84cc391ab0264" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;foobar&lt;/code&gt; with the actual name of the student. A normal insert operation would look like this:</source>
          <target state="translated">&lt;code&gt;foobar&lt;/code&gt; 를 학생의 실제 이름으로 바꿉니다. 일반적인 삽입 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6245c95fed8f15a937f9961aafd6f5047abf8924" translate="yes" xml:space="preserve">
          <source>Robert Tables</source>
          <target state="translated">로버트 테이블</target>
        </trans-unit>
        <trans-unit id="0c2b7d925905b95e3db45c6bf19999ae433aedd2" translate="yes" xml:space="preserve">
          <source>Robert'); DROP TABLE Students; --</source>
          <target state="translated">Robert '); DROP TABLE 학생; -</target>
        </trans-unit>
        <trans-unit id="37120a5976df382d07bdbca079622bcbe6aa10b9" translate="yes" xml:space="preserve">
          <source>SQL injection is the database equivalent of a remote &lt;a href=&quot;http://en.wikipedia.org/wiki/Arbitrary_code_execution&quot;&gt;arbitrary code execution&lt;/a&gt; vulnerability in an operating system or application.  The potential impact of a successful SQL injection attack cannot be underestimated--depending on the database system and application configuration, it can be used by an attacker to cause data loss (as in this case), gain unauthorized access to data, or even execute arbitrary code on the host machine itself.</source>
          <target state="translated">SQL 주입은 운영 체제 또는 응용 프로그램의 원격 &lt;a href=&quot;http://en.wikipedia.org/wiki/Arbitrary_code_execution&quot;&gt;임의 코드 실행&lt;/a&gt; 취약점과 동등한 데이터베이스입니다. 성공적인 SQL 주입 공격의 잠재적 영향은 데이터베이스 시스템 및 응용 프로그램 구성에 따라 과소 평가할 수 없으며 공격자가 데이터 손실 (이 경우와 같이)을 유발하거나 데이터에 대한 무단 액세스를 얻거나 심지어 실행할 수도 있습니다 호스트 시스템 자체의 임의 코드</target>
        </trans-unit>
        <trans-unit id="3026fffcc7a3643389d223c1b0e95482127105a3" translate="yes" xml:space="preserve">
          <source>Say you naively wrote a student creation method like this:</source>
          <target state="translated">다음과 같이 학생 생성 방법을 순진하게 작성했다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="ddb93c7ca1ae41e329036ba77ece07624d6a8bbd" translate="yes" xml:space="preserve">
          <source>Since the admin account has high privileges deleting the table from this account is possible.</source>
          <target state="translated">관리자 계정에는 높은 권한이 있으므로이 계정에서 테이블을 삭제할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9663830b177751610a508e2d8647db1deab1d0cb" translate="yes" xml:space="preserve">
          <source>Since the user input is not sanitized, The above query has is manipulated into 2 parts</source>
          <target state="translated">사용자 입력이 삭제되지 않았으므로 위의 쿼리는 두 부분으로 조작됩니다.</target>
        </trans-unit>
        <trans-unit id="dd9a0d6b67b9bbba7661f7e23c2b4420d6344c6e" translate="yes" xml:space="preserve">
          <source>So if &lt;code&gt;$firstName&lt;/code&gt; contains &lt;code&gt;Robert'); DROP TABLE students; --&lt;/code&gt; the database program will execute the following request directly on the DB:</source>
          <target state="translated">&lt;code&gt;$firstName&lt;/code&gt; 에 &lt;code&gt;Robert'); DROP TABLE students; --&lt;/code&gt; 가 포함되어 있다면 ); DROP TABLE 학생; - 데이터베이스 프로그램은 DB에서 직접 다음 요청을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="a465c66b5dc128bd57f8fcdcf456255c8a8a7859" translate="yes" xml:space="preserve">
          <source>So now the ' character ends the string literal before the programmer was expecting it.  Combined with the ; character to end the statement, an attacker can now add whatever sql they want.  The -- comment at the end is to make sure any remaining sql in the original statement does not prevent the query from compiling on the server.</source>
          <target state="translated">이제 '문자는 프로그래머가 예상하기 전에 문자열 리터럴을 끝냅니다. 와 결합하여; 공격자는 이제 원하는 SQL을 추가 할 수 있습니다. 끝에-주석은 원래 명령문에 남아있는 SQL이 서버에서 쿼리를 컴파일하지 못하게하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e96ce08b6516eb0bdfd1e8209b76ce5401e37a1" translate="yes" xml:space="preserve">
          <source>Solution - use PDO prepare() &amp;amp; bindParam() methods:</source>
          <target state="translated">솔루션-PDO Prepare () 및 bindParam () 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5ff57f4185e884322f43c9c59da60f12f41285ea" translate="yes" xml:space="preserve">
          <source>TL;DR</source>
          <target state="translated">TL;DR</target>
        </trans-unit>
        <trans-unit id="ed7851e23950df599910f44b392a86be5fb06a01" translate="yes" xml:space="preserve">
          <source>That would enable you to log in to any account without knowing the password. So you don't need to be able to use two statements in order to use SQL injection, although you can do more destructive things if you are able to supply multiple statements.</source>
          <target state="translated">암호를 몰라도 모든 계정에 로그인 할 수 있습니다. 따라서 SQL 삽입을 사용하기 위해 두 개의 명령문을 사용할 필요는 없지만 여러 명령문을 제공 할 수 있으면 더 파괴적인 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f01ea093d0abce096b0f1ba94e2bd02ddf0d650" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;');&lt;/code&gt; ends the query, it doesn't start a comment. Then it drops the students table and comments the rest of the query that was supposed to be executed.</source>
          <target state="translated">&lt;code&gt;');&lt;/code&gt; 쿼리를 끝내면 주석이 시작되지 않습니다. 그런 다음 학생 테이블을 삭제하고 실행될 나머지 쿼리를 주석으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2d5e55ae2ea8efc24225552a86bfc8c2a77c138d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'&lt;/code&gt; character in SQL is used  for string constants. In this case it is used for ending the string constant and not for comment.</source>
          <target state="translated">SQL에서 &lt;code&gt;'&lt;/code&gt; 문자는 문자열 상수에 사용됩니다. 이 경우 주석이 아닌 문자열 상수를 종료하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f92ff1774fac1c9b4900067042e78a60943008ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'&lt;/code&gt; in the student's name is not a comment, it's the closing &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms179899.aspx&quot;&gt;string delimiter&lt;/a&gt;.  Since the student's name is a string, it's needed syntactically to complete the hypothetical query.  Injection attacks only work &lt;em&gt;when the SQL query they inject results in valid SQL&lt;/em&gt;.</source>
          <target state="translated">학생 이름의 &lt;code&gt;'&lt;/code&gt; 은 주석이 아니며 닫는 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms179899.aspx&quot;&gt;문자열 구분 기호&lt;/a&gt; 입니다. 학생의 이름은 문자열이므로 가상 쿼리를 완료하려면 구문 적으로 필요합니다. 주입 공격은 주입 &lt;em&gt;한 SQL 쿼리가 유효한 SQL 결과를 얻을&lt;/em&gt; 때만 작동 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="aceae0413666e84da23e62ac60c8bac74e2f5d8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; only comments the remainder of the line.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 나머지 줄만 주석으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="74098fc9f260146c228104b6c65f525edc48784f" translate="yes" xml:space="preserve">
          <source>The SQL injection here is the result of the name of the student terminating the statement and including a separate &lt;code&gt;DROP TABLE&lt;/code&gt; command; the two dashes at the end of the input are intended to comment out any leftover code that would otherwise cause an error. The last line of the output confirms that the database server has dropped the table.</source>
          <target state="translated">여기에 SQL 삽입은 명령문을 종료하고 별도의 &lt;code&gt;DROP TABLE&lt;/code&gt; 명령을 포함하는 학생 이름의 결과입니다. 입력 끝에있는 두 개의 대시는 남은 코드를 주석 처리하여 오류가 발생할 수 있습니다. 출력의 마지막 행은 데이터베이스 서버가 테이블을 삭제했음을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="d2e3583e0dbe2234f515adc562e653eb57e46697" translate="yes" xml:space="preserve">
          <source>The SQL would become:</source>
          <target state="translated">SQL은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="98ed052ab768c42b4c51024ac95005d02b55e79b" translate="yes" xml:space="preserve">
          <source>The code is mistakenly placing anything the user supplied as the variable. You wanted the SQL to be:</source>
          <target state="translated">코드가 실수로 사용자가 변수로 제공 한 것을 배치하고 있습니다. SQL이되기를 원했습니다.</target>
        </trans-unit>
        <trans-unit id="1a1f5503c8dacf159b36aa6dc81597f075d43234" translate="yes" xml:space="preserve">
          <source>The code to retrieve user name from request is</source>
          <target state="translated">요청에서 사용자 이름을 검색하는 코드는</target>
        </trans-unit>
        <trans-unit id="133d738d5f98f614bed15f518ef065e70ac0ec32" translate="yes" xml:space="preserve">
          <source>The double dash (--) will just comment out remaining part of the query.</source>
          <target state="translated">이중 대시 (-)는 쿼리의 나머지 부분을 주석 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1504af61394d6829bd808405ed9344a3c5620dec" translate="yes" xml:space="preserve">
          <source>The first one will do the normal search.</source>
          <target state="translated">첫 번째는 일반 검색을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="c406de1c10a6141ff755969fdb6d8f9fd28f392b" translate="yes" xml:space="preserve">
          <source>The original code in the school's program probably looks something like</source>
          <target state="translated">학교 프로그램의 원래 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f92ec13c954912f1e1bcc65272443cfb80a31ce" translate="yes" xml:space="preserve">
          <source>The result?</source>
          <target state="translated">결과?</target>
        </trans-unit>
        <trans-unit id="c762df0f9ec734a489ffde76def0caa39fa5c6bb" translate="yes" xml:space="preserve">
          <source>The resultant query becomes</source>
          <target state="translated">결과 쿼리는</target>
        </trans-unit>
        <trans-unit id="5df6724d22e0babfe904b6b14173f098d3dab8ae" translate="yes" xml:space="preserve">
          <source>The second one will drop the table student if the account has sufficient privileges (Generally the school admin account will run such query and will have the privileges talked about above).</source>
          <target state="translated">두 번째 계정은 계정에 충분한 권한이있는 경우 테이블 학생을 삭제합니다 (일반적으로 학교 관리자 계정은 이러한 쿼리를 실행하고 위에서 언급 한 권한을 갖습니다).</target>
        </trans-unit>
        <trans-unit id="2d104507ada99e5d8537b24476a8fdc95e35ad06" translate="yes" xml:space="preserve">
          <source>The semicolon ends the insert command and starts another; the -- comments out the rest of the line. The DROP TABLE command is executed...</source>
          <target state="translated">세미콜론은 삽입 명령을 종료하고 다른 명령을 시작합니다. -나머지 줄을 주석으로 처리합니다. DROP TABLE 명령이 실행됩니다 ...</target>
        </trans-unit>
        <trans-unit id="30ed2dd959ffaed009b9812f05737346b7e5d2ed" translate="yes" xml:space="preserve">
          <source>The writer of the database probably did a</source>
          <target state="translated">데이터베이스 작성자가 아마</target>
        </trans-unit>
        <trans-unit id="0f86d3dd6c873d977a65f9095a5db0a162d4537d" translate="yes" xml:space="preserve">
          <source>Then the resulting SQL string would be this:</source>
          <target state="translated">그런 다음 결과 SQL 문자열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5c1a493136ed3ba8c5afdcf8999adbcbf6478f23" translate="yes" xml:space="preserve">
          <source>This drops (deletes) the student table.</source>
          <target state="translated">학생 테이블이 삭제 (삭제)됩니다.</target>
        </trans-unit>
        <trans-unit id="09d35ca1f5c9f54142fbc66f3b9ae42880e84716" translate="yes" xml:space="preserve">
          <source>This is dangerous as it can nullify password authentication, if present</source>
          <target state="translated">비밀번호 인증이있는 경우 비밀번호 인증을 무효화 할 수 있으므로 위험합니다.</target>
        </trans-unit>
        <trans-unit id="8a2d0b2b0e59d3e8ece42c60838ae2d5a4cbdb6e" translate="yes" xml:space="preserve">
          <source>This is how it works:
Lets suppose the administrator is looking for records of student</source>
          <target state="translated">작동 방식 : 관리자가 학생의 기록을 찾고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="fe81f720466bedf90225a9b8c3c25cc2caad04a3" translate="yes" xml:space="preserve">
          <source>This is the naive way to add text input into a query, and is &lt;em&gt;very bad&lt;/em&gt;, as you will see.</source>
          <target state="translated">이것은 쿼리에 텍스트 입력을 추가하는 순진한 방법이며 보시 &lt;em&gt;다시피 매우 나쁩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f4b6f2ee70fc32667125f99134f18f48f6d5e0e2" translate="yes" xml:space="preserve">
          <source>This is why bind parameters are a good thing.</source>
          <target state="translated">이것이 바인드 매개 변수가 좋은 이유입니다.</target>
        </trans-unit>
        <trans-unit id="f34eda5ca211eb3175806664d5fd38d21af5eda6" translate="yes" xml:space="preserve">
          <source>To make it clear what's happening, let's try this with a simple table containing only the name field and add a single row:</source>
          <target state="translated">무슨 일이 일어나고 있는지 명확히하기 위해 이름 필드 만 포함하는 간단한 테이블로 시도하고 단일 행을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="69e18205e6435018fec90b85d4e3a87afed1d5d3" translate="yes" xml:space="preserve">
          <source>Try to replace table_name with the real table name. If he get your table name right they would empty your table! &lt;strong&gt;(It is very easy to brut force this URL with simple script)&lt;/strong&gt;</source>
          <target state="translated">table_name을 실제 테이블 이름으로 바꾸십시오. 그가 당신의 테이블 이름을 올바르게 얻는다면 그들은 당신의 테이블을 비울 것입니다! &lt;strong&gt;(단순한 스크립트로이 URL을 강제로 처리하는 것은 매우 쉽습니다)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bafa483229452946a2498bdf56c79df0cbc5f7e3" translate="yes" xml:space="preserve">
          <source>What does this SQL do:</source>
          <target state="translated">이 SQL의 기능은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="e256ca0ab96555169f167cecea8df3dedc1d6266" translate="yes" xml:space="preserve">
          <source>What gets run on the database is this query:</source>
          <target state="translated">데이터베이스에서 실행되는 것은 다음 쿼리입니다.</target>
        </trans-unit>
        <trans-unit id="21339d9c4840b2a2bb4902b933d347e8cb815a77" translate="yes" xml:space="preserve">
          <source>What happens when we insert Little Bobby Tables's name into the table?</source>
          <target state="translated">Little Bobby Tables 이름을 테이블에 삽입하면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="daa8241056744ddd3490433b4056a17c6aaf1a07" translate="yes" xml:space="preserve">
          <source>What you get is:</source>
          <target state="translated">당신이 얻는 것은 :</target>
        </trans-unit>
        <trans-unit id="1ce587cc039592196a56f7601d62743da75474c3" translate="yes" xml:space="preserve">
          <source>When we query the table, we get this:</source>
          <target state="translated">테이블을 쿼리하면 다음과 같은 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="a0a70210ca826c39f74e99f7815e7828691e7797" translate="yes" xml:space="preserve">
          <source>You can, however, manipulate an existing SQL statement via SQL injection without having to add a second statement. Let's say you have a login system which checks a username and a password with this simple select:</source>
          <target state="translated">그러나 두 번째 명령문을 추가하지 않고도 SQL 삽입을 통해 기존 SQL 문을 조작 할 수 있습니다. 이 간단한 선택으로 사용자 이름과 비밀번호를 확인하는 로그인 시스템이 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="b1d33b75385409327c7ad149de2f5700e2332439" translate="yes" xml:space="preserve">
          <source>You don't need to input form data to make SQL injection.</source>
          <target state="translated">SQL 삽입을 위해 양식 데이터를 입력 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="506b8b70be03f131ecad01eb971b38a21bfc62da" translate="yes" xml:space="preserve">
          <source>Your query would look something like this...</source>
          <target state="translated">귀하의 검색어는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84e0def289034c082b05baf61e91d33a82183f27" translate="yes" xml:space="preserve">
          <source>Your url would look 
&lt;a href=&quot;http://yoursite.com/show?id=1&quot;&gt;http://yoursite.com/show?id=1&lt;/a&gt;</source>
          <target state="translated">URL은 &lt;a href=&quot;http://yoursite.com/show?id=1&quot;&gt;http://yoursite.com/show?id=1로&lt;/a&gt; 보입니다.</target>
        </trans-unit>
        <trans-unit id="5150b572e20984159df6524b5d5ea5e28030eaec" translate="yes" xml:space="preserve">
          <source>` )</source>
          <target state="translated">`)</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="6bd9dfe1efad33667e69e751d695397aab30aac7" translate="yes" xml:space="preserve">
          <source>ie. it will terminate early the insert statement, execute whatever malicious code the cracker wants, then comment out whatever remainder of code there might be.</source>
          <target state="translated">즉. insert 문을 일찍 종료하고 크래커가 원하는 악성 코드를 실행 한 다음 나머지 코드가 있으면 주석 처리합니다.</target>
        </trans-unit>
        <trans-unit id="7eace1c108e9774e1c99d6e09e4b22fb30e874ff" translate="yes" xml:space="preserve">
          <source>which, in plain English, roughly translates to the two queries:</source>
          <target state="translated">일반 영어로 두 가지 쿼리로 대략적으로 번역됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
