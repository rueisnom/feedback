<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/332365">
    <body>
      <group id="332365">
        <trans-unit id="f5dccbefc9eb641263e9035c2feacfbb42ddecab" translate="yes" xml:space="preserve">
          <source>' )</source>
          <target state="translated">' )</target>
        </trans-unit>
        <trans-unit id="a0f651cde227a7b6a2f745cc1abcae1e478af7dd" translate="yes" xml:space="preserve">
          <source>(&lt;em&gt;All code examples in this answer were run on a PostgreSQL 9.1.2 database server.&lt;/em&gt;)</source>
          <target state="translated">（ &lt;em&gt;此答案中的所有代码示例均在PostgreSQL 9.1.2数据库服务器上运行。&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="2e2f5034350c8def8869f07ee89d9d21bf27cfa2" translate="yes" xml:space="preserve">
          <source>(for example) to add the new student, where the &lt;code&gt;$xxx&lt;/code&gt; variable contents was taken directly out of an HTML form, without checking format nor escaping special characters.</source>
          <target state="translated">（例如）添加新学生，其中 &lt;code&gt;$xxx&lt;/code&gt; 变量内容直接从HTML表单中获取，而无需检查格式或转义特殊字符。</target>
        </trans-unit>
        <trans-unit id="fdfe2e70fde31449eb3c2bab22ca555028d85e07" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Source: &lt;a href=&quot;https://xkcd.com/327/&quot;&gt;https://xkcd.com/327/&lt;/a&gt;)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（来源： &lt;a href=&quot;https://xkcd.com/327/&quot;&gt;https&lt;/a&gt; : //xkcd.com/327/ ）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22e2aaa76f874c66b707cacfaa9f76f22b05d735" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It drops the students table.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;它放下学生桌。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7df5880bf1ba6e654e04c1e22cc8c944922f40cc" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;sup&gt;Edited &lt;strong&gt;&lt;em&gt;again&lt;/em&gt;&lt;/strong&gt; as per &lt;a href=&quot;https://stackoverflow.com/users/287586/dan04&quot;&gt;dan04&lt;/a&gt;'s astute comment&lt;/sup&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;sup&gt;根据&lt;a href=&quot;https://stackoverflow.com/users/287586/dan04&quot;&gt;dan04&lt;/a&gt;的敏锐评论&lt;strong&gt;&lt;em&gt;重新&lt;/em&gt;&lt;/strong&gt;编辑&lt;/sup&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="bb625ab0058fc67ab4b565ae8d8e1039f625de02" translate="yes" xml:space="preserve">
          <source>A single quote is the start and end of a string. A semicolon is the end of a statement. So if they were doing a select like this:</source>
          <target state="translated">单引号是一个字符串的开头和结尾。分号是语句的结尾。所以,如果他们做的是这样的选择。</target>
        </trans-unit>
        <trans-unit id="019a59a22cb46f0149dfc5d8931593e59be710d8" translate="yes" xml:space="preserve">
          <source>Add a new record to the Students table with a Name value of 'Robert'</source>
          <target state="translated">在学生表中添加一条新记录,名称为'Robert'。</target>
        </trans-unit>
        <trans-unit id="9fc8a6c3ef2f442e2ab6de0ab4090a41c331c51f" translate="yes" xml:space="preserve">
          <source>After the values from the first name, middle name textbox &lt;em&gt;FNMName.Text&lt;/em&gt; (which is &lt;code&gt;Robert'); DROP TABLE STUDENTS; --&lt;/code&gt;) and the last name textbox &lt;em&gt;LName.Text&lt;/em&gt; (let's call it &lt;code&gt;Derper&lt;/code&gt;) are concatenated with the rest of the query, the result is now actually &lt;em&gt;two queries&lt;/em&gt; separated by the &lt;a href=&quot;http://en.wikipedia.org/wiki/SQL#Language_elements&quot;&gt;statement terminator&lt;/a&gt; (semicolon).  The second query has been &lt;strong&gt;injected&lt;/strong&gt; into the first.  When the code executes this query against the database, it will look like this</source>
          <target state="translated">在名字的值之后，中间名称文本框&lt;em&gt;FNMName.Text&lt;/em&gt; （是 &lt;code&gt;Robert'); DROP TABLE STUDENTS; --&lt;/code&gt; 拖放表学生； - ）和姓氏文本框&lt;em&gt;LName.Text&lt;/em&gt; （我们称其为 &lt;code&gt;Derper&lt;/code&gt; ）与其余查询串联在一起，结果实际上是&lt;em&gt;两个查询，&lt;/em&gt;由&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL#Language_elements&quot;&gt;语句终止符&lt;/a&gt; （分号）分隔。 第二个查询已&lt;strong&gt;注入&lt;/strong&gt;到第一个查询中。 当代码对数据库执行此查询时，它将看起来像这样</target>
        </trans-unit>
        <trans-unit id="131934a34697f59c9b548cee1ee07df44489f026" translate="yes" xml:space="preserve">
          <source>And someone enters the name &lt;code&gt;Robert'); DROP TABLE STUDENTS; --&lt;/code&gt;</source>
          <target state="translated">有人输入 &lt;code&gt;Robert'); DROP TABLE STUDENTS; --&lt;/code&gt; 的名字； 拖放表学生； -</target>
        </trans-unit>
        <trans-unit id="b200166f579d9d7d277600fbbc63e5e7c3c3bd94" translate="yes" xml:space="preserve">
          <source>As everyone else has pointed out already, the &lt;code&gt;');&lt;/code&gt; closes the original statement and then a second statement follows. Most frameworks, including languages like PHP, have default security settings by now that don't allow multiple statements in one SQL string. In PHP, for example, you can only run multiple statements in one SQL string by using the &lt;code&gt;mysqli_multi_query&lt;/code&gt; function.</source>
          <target state="translated">正如其他人已经指出的那样， &lt;code&gt;');&lt;/code&gt; 关闭原始语句，然后再执行第二条语句。 到目前为止，大多数框架（包括PHP之类的语言）都具有默认的安全设置，这些设置不允许在一个SQL字符串中包含多个语句。 例如，在PHP中，只能使用 &lt;code&gt;mysqli_multi_query&lt;/code&gt; 函数在一个SQL字符串中运行多个语句。</target>
        </trans-unit>
        <trans-unit id="aa7e84b685e35609e43c1cebf379c461d7c891aa" translate="yes" xml:space="preserve">
          <source>As noted by the XKCD comic, one way of protecting against SQL injection attacks is to sanitize database inputs, such as by escaping special characters, so that they cannot modify the underlying SQL command and therefore cannot cause execution of arbitrary SQL code.  If you use parameterized queries, such as by using &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/yy6y35y8.aspx&quot;&gt;&lt;code&gt;SqlParameter&lt;/code&gt;&lt;/a&gt; in ADO.NET, the input will, at minimum, be automatically sanitized to guard against SQL injection.</source>
          <target state="translated">正如XKCD漫画所指出的那样，防止SQL注入攻击的一种方法是对数据库输入进行清理，例如转义特殊字符，以使它们无法修改基础SQL命令，从而不会导致执行任意SQL代码。 如果使用参数化查询（例如通过在ADO.NET中使用&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/yy6y35y8.aspx&quot;&gt; &lt;code&gt;SqlParameter&lt;/code&gt; &lt;/a&gt; ），则输入将至少自动进行清理以防止SQL注入。</target>
        </trans-unit>
        <trans-unit id="87829ea42fc70807b5291e8b0b9f0e46c8bca893" translate="yes" xml:space="preserve">
          <source>But a clever user can supply whatever they want:</source>
          <target state="translated">但聪明的用户可以提供他们想要的东西。</target>
        </trans-unit>
        <trans-unit id="ce2f5da38f14260cb520df0b6cf6ea2e91248b7c" translate="yes" xml:space="preserve">
          <source>Delete the Students table</source>
          <target state="translated">删除学生表</target>
        </trans-unit>
        <trans-unit id="c5a98777d68005235e5c5992186f39d71f52499d" translate="yes" xml:space="preserve">
          <source>Everything past the second query is &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms181627.aspx&quot;&gt;marked as a comment&lt;/a&gt;:  &lt;code&gt;--', 'Derper')&lt;/code&gt;</source>
          <target state="translated">第二个查询之后的所有内容都&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms181627.aspx&quot;&gt;标记为注释&lt;/a&gt; ： &lt;code&gt;--', 'Derper')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f33300310e5de518f91c41d40a5ef517fad1fdfe" translate="yes" xml:space="preserve">
          <source>Everything's fine. Now imagine you provide this string as the password:</source>
          <target state="translated">一切都很好。现在想象一下,你提供这个字符串作为密码。</target>
        </trans-unit>
        <trans-unit id="c187e1d066434050adebcb225730c5347293b540" translate="yes" xml:space="preserve">
          <source>Example of PHP vulnerable code using PDO:</source>
          <target state="translated">使用PDO的PHP漏洞代码示例。</target>
        </trans-unit>
        <trans-unit id="26ed4305eca2e4ca311ed3cb1f6c8de24c1bae8b" translate="yes" xml:space="preserve">
          <source>FWIW, I also think the comic in question has an important detail wrong: if you're thinking about &lt;em&gt;sanitizing&lt;/em&gt; your database inputs, as the comic suggests, you're still doing it wrong. Instead, you should think in terms of &lt;em&gt;quarantining&lt;/em&gt; your database inputs, and the correct way to do this is via parameterized queries.</source>
          <target state="translated">FWIW，我还认为所涉及的漫画有一个重要的细节错误：如果您正在考虑&lt;em&gt;清理&lt;/em&gt;数据库输入（正如漫画所暗示的那样），那么您仍然做错了。 相反，您应该考虑&lt;em&gt;隔离&lt;/em&gt;数据库输入，而正确的方法是通过参数化查询。</target>
        </trans-unit>
        <trans-unit id="8379d9d413b61d4aa6abb0ecd900209b2ade4480" translate="yes" xml:space="preserve">
          <source>How does the SQL injection from the “Bobby Tables” XKCD comic work</source>
          <target state="translated">波比表》XKCD漫画中的SQL注入是如何进行的?</target>
        </trans-unit>
        <trans-unit id="7764fec83ece4bf060d4c0efc0b3928e567ed559" translate="yes" xml:space="preserve">
          <source>However, sanitizing inputs at the application level may not stop more advanced SQL injection techniques. For example, &lt;a href=&quot;https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string&quot;&gt;there are ways to circumvent the &lt;code&gt;mysql_real_escape_string&lt;/code&gt; PHP function&lt;/a&gt;. For added protection, many database systems support &lt;a href=&quot;https://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;&lt;em&gt;prepared statements&lt;/em&gt;&lt;/a&gt;. If properly implemented in the backend, prepared statements can make SQL injection impossible by treating data inputs as semantically separate from the rest of the command.</source>
          <target state="translated">但是，在应用程序级别清理输入可能不会停止更高级的SQL注入技术。 例如， &lt;a href=&quot;https://stackoverflow.com/questions/5741187/sql-injection-that-gets-around-mysql-real-escape-string&quot;&gt;有一些方法可以绕过 &lt;code&gt;mysql_real_escape_string&lt;/code&gt; PHP函数&lt;/a&gt; 。 为了增加保护，许多数据库系统都支持&lt;a href=&quot;https://en.wikipedia.org/wiki/Prepared_statement&quot;&gt;&lt;em&gt;预备语句&lt;/em&gt;&lt;/a&gt; 。 如果在后端正确实现，则预备语句可以通过将数据输入与其余命令在语义上分开来使SQL注入无法进行。</target>
        </trans-unit>
        <trans-unit id="9c5cfce95e395b48a50005b91951a8e612e3b5b9" translate="yes" xml:space="preserve">
          <source>I know both &lt;code&gt;'&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; are for comments, but doesn't the word &lt;code&gt;DROP&lt;/code&gt; get commented as well since it is part of the same line?</source>
          <target state="translated">我知道 &lt;code&gt;'&lt;/code&gt; 和 &lt;code&gt;--&lt;/code&gt; 都是注释，但是 &lt;code&gt;DROP&lt;/code&gt; 这个词不是同一行的一部分吗？</target>
        </trans-unit>
        <trans-unit id="a604718c1a9d707cb8e65adc266b636e6570cdff" translate="yes" xml:space="preserve">
          <source>INSERT INTO Students VALUES ( '</source>
          <target state="translated">INSERT INTO Student VALUES('</target>
        </trans-unit>
        <trans-unit id="461191a3dafd5a83379f796a40bfa1b1193c6cd3" translate="yes" xml:space="preserve">
          <source>If student_name is the one given, that does the selection with the name &quot;Robert&quot; and then drops the table.  The &quot;-- &quot; part changes the rest of the given query into a comment.</source>
          <target state="translated">如果给定的是 student_name,则以 &quot;Robert &quot;为名进行选择,然后丢弃该表。&quot;---&quot;部分会将给定查询的其余部分改变为注释。</target>
        </trans-unit>
        <trans-unit id="139dafd9d52972e29c58ae782bf096e4a550dcc5" translate="yes" xml:space="preserve">
          <source>If you provide &lt;code&gt;peter&lt;/code&gt; as the username and &lt;code&gt;secret&lt;/code&gt; as the password, the resulting SQL string would look like this:</source>
          <target state="translated">如果提供 &lt;code&gt;peter&lt;/code&gt; 作为用户名并提供 &lt;code&gt;secret&lt;/code&gt; 作为密码，则生成的SQL字符串将如下所示：</target>
        </trans-unit>
        <trans-unit id="9bdf72b4d7e09fec8b6e948d4c391a1889ecf5d9" translate="yes" xml:space="preserve">
          <source>In this case, ' is not a comment character.  It's used to delimit string literals.  The comic artist is banking on the idea that the school in question has dynamic sql somewhere that looks something like this:</source>
          <target state="translated">在这种情况下,'不是注释字符。它是用来分隔字符串的字面意义。漫画家是基于这样的想法,即该学校有一个动态的sql,看起来像这样。</target>
        </trans-unit>
        <trans-unit id="19c6a7a74341e9efe95de0fdb1852846d3f4021e" translate="yes" xml:space="preserve">
          <source>It's important to notice that during the &lt;code&gt;INSERT&lt;/code&gt; operation the application isn't checking the input for any special characters, and is therefore allowing arbitrary input to be entered into the SQL command. This means that a malicious user can insert, into a field normally intended for user input, special symbols such as quotes along with arbitrary SQL code to cause the database system to execute it, hence &lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL&amp;nbsp;&lt;em&gt;injection&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">重要的是要注意，在 &lt;code&gt;INSERT&lt;/code&gt; 操作期间，应用程序不会检查输入是否有任何特殊字符，因此允许将任意输入输入到SQL命令中。 这意味着恶意用户可以在通常用于用户输入的字段中插入特殊符号（例如引号）以及任意SQL代码，以使数据库系统执行该操作，从而进行&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL &lt;em&gt;注入&lt;/em&gt;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="a912262d2aa40547772a8e800c0f213bec8d8d54" translate="yes" xml:space="preserve">
          <source>Just looking at:</source>
          <target state="translated">只是看了看。</target>
        </trans-unit>
        <trans-unit id="49aa9e517ee2cc59732b724e9ab3b7522a1ed9ce" translate="yes" xml:space="preserve">
          <source>Let's assume the application uses the following SQL to insert data into the table:</source>
          <target state="translated">让我们假设应用程序使用下面的SQL将数据插入到表中。</target>
        </trans-unit>
        <trans-unit id="30b44dcf7150c4c363ba1edcf66e4cf3db5207e2" translate="yes" xml:space="preserve">
          <source>Let's say the name was used in a variable, &lt;code&gt;$Name&lt;/code&gt;.  You then run this query:</source>
          <target state="translated">假设该名称用于变量 &lt;code&gt;$Name&lt;/code&gt; 。 然后，您运行以下查询：</target>
        </trans-unit>
        <trans-unit id="8d860cdc3777611007e2d6ff4d20e28c2a6d7ead" translate="yes" xml:space="preserve">
          <source>Mmm, I am too slow, I see already 8 answers before mine in the orange band... :-) A popular topic, it seems.</source>
          <target state="translated">嗯,我太慢了,我在橘色带里看到已经有8个答案在我之前的答案了......:-)看来是个热门话题啊。</target>
        </trans-unit>
        <trans-unit id="d91e053c54896e652403b7bc76d0d5c47b82c0e8" translate="yes" xml:space="preserve">
          <source>Mom supposed the database programmer made a request looking like:</source>
          <target state="translated">妈妈应该是数据库程序员提出的要求,看起来像。</target>
        </trans-unit>
        <trans-unit id="96bb971af970b55c072ef0967dfb0650a326ca16" translate="yes" xml:space="preserve">
          <source>Mostly we will try to patch forms input. But this is not the only place where you can get attacked with SQL injection. You can do very simple attack with URL which send data through GET request;
Consider the fallowing example:</source>
          <target state="translated">大多数情况下,我们会尝试对表单输入进行修补。但这并不是唯一可以被SQL注入攻击的地方。你可以通过GET请求发送数据的URL进行非常简单的攻击;下面的例子是这样的。</target>
        </trans-unit>
        <trans-unit id="bc011a90b27267bbf94983c51810cde1d11b8154" translate="yes" xml:space="preserve">
          <source>No one pointed this out before so through I might alert some of you.</source>
          <target state="translated">之前没有人指出,所以我可能会提醒你们中的一些人。</target>
        </trans-unit>
        <trans-unit id="db882356d5143646304aa5d620f5a86bb8a20a10" translate="yes" xml:space="preserve">
          <source>No, &lt;code&gt;'&lt;/code&gt; isn't a comment in SQL, but a delimiter.</source>
          <target state="translated">不， &lt;code&gt;'&lt;/code&gt; 不是SQL中的注释，而是定界符。</target>
        </trans-unit>
        <trans-unit id="4d11e639fabc057421eb05c7aa5bad84e45a7b76" translate="yes" xml:space="preserve">
          <source>Now someone could try something like this</source>
          <target state="translated">现在有人可以试试这样的东西</target>
        </trans-unit>
        <trans-unit id="de20cc0fa527aedc63635b0e9bb07117e87ba818" translate="yes" xml:space="preserve">
          <source>Now the query would be something like this (to search the student table)</source>
          <target state="translated">现在的查询方式是这样的(搜索学生表</target>
        </trans-unit>
        <trans-unit id="7646e113eeae59dc18798a0466c8a3f0c8a20b6b" translate="yes" xml:space="preserve">
          <source>On some systems, the &lt;code&gt;select&lt;/code&gt; would get ran first followed by the &lt;code&gt;drop&lt;/code&gt; statement! The message is: DONT EMBED VALUES INTO YOUR SQL. Instead use parameters!</source>
          <target state="translated">在某些系统上， &lt;code&gt;select&lt;/code&gt; 将首先运行，然后是 &lt;code&gt;drop&lt;/code&gt; 语句！ 消息是：不要将值嵌入SQL。 而是使用参数！</target>
        </trans-unit>
        <trans-unit id="983c898ac23c7963028dec422bc84cc391ab0264" translate="yes" xml:space="preserve">
          <source>Replace &lt;code&gt;foobar&lt;/code&gt; with the actual name of the student. A normal insert operation would look like this:</source>
          <target state="translated">将 &lt;code&gt;foobar&lt;/code&gt; 替换为学生的实际姓名。 正常的插入操作如下所示：</target>
        </trans-unit>
        <trans-unit id="6245c95fed8f15a937f9961aafd6f5047abf8924" translate="yes" xml:space="preserve">
          <source>Robert Tables</source>
          <target state="translated">Robert Tables</target>
        </trans-unit>
        <trans-unit id="0c2b7d925905b95e3db45c6bf19999ae433aedd2" translate="yes" xml:space="preserve">
          <source>Robert'); DROP TABLE Students; --</source>
          <target state="translated">Robert'));DROP TABLE学生;----</target>
        </trans-unit>
        <trans-unit id="37120a5976df382d07bdbca079622bcbe6aa10b9" translate="yes" xml:space="preserve">
          <source>SQL injection is the database equivalent of a remote &lt;a href=&quot;http://en.wikipedia.org/wiki/Arbitrary_code_execution&quot;&gt;arbitrary code execution&lt;/a&gt; vulnerability in an operating system or application.  The potential impact of a successful SQL injection attack cannot be underestimated--depending on the database system and application configuration, it can be used by an attacker to cause data loss (as in this case), gain unauthorized access to data, or even execute arbitrary code on the host machine itself.</source>
          <target state="translated">SQL注入等同于操作系统或应用程序中的远程&lt;a href=&quot;http://en.wikipedia.org/wiki/Arbitrary_code_execution&quot;&gt;任意代码执行&lt;/a&gt;漏洞。 不能低估一次成功的SQL注入攻击的潜在影响-根据数据库系统和应用程序配置，攻击者可以使用它来导致数据丢失（在这种情况下），获得对数据的未授权访问甚至执行主机本身上的任意代码。</target>
        </trans-unit>
        <trans-unit id="3026fffcc7a3643389d223c1b0e95482127105a3" translate="yes" xml:space="preserve">
          <source>Say you naively wrote a student creation method like this:</source>
          <target state="translated">说你天真地写出了这样的学生创作方法。</target>
        </trans-unit>
        <trans-unit id="ddb93c7ca1ae41e329036ba77ece07624d6a8bbd" translate="yes" xml:space="preserve">
          <source>Since the admin account has high privileges deleting the table from this account is possible.</source>
          <target state="translated">由于管理员账户拥有高权限,所以可以从这个账户中删除表。</target>
        </trans-unit>
        <trans-unit id="9663830b177751610a508e2d8647db1deab1d0cb" translate="yes" xml:space="preserve">
          <source>Since the user input is not sanitized, The above query has is manipulated into 2 parts</source>
          <target state="translated">由于用户的输入没有经过消毒处理,所以上面的查询被操作成2个部分</target>
        </trans-unit>
        <trans-unit id="dd9a0d6b67b9bbba7661f7e23c2b4420d6344c6e" translate="yes" xml:space="preserve">
          <source>So if &lt;code&gt;$firstName&lt;/code&gt; contains &lt;code&gt;Robert'); DROP TABLE students; --&lt;/code&gt; the database program will execute the following request directly on the DB:</source>
          <target state="translated">因此，如果 &lt;code&gt;$firstName&lt;/code&gt; 包含 &lt;code&gt;Robert'); DROP TABLE students; --&lt;/code&gt; DROP TABLE学生； -数据库程序将直接在DB上执行以下请求：</target>
        </trans-unit>
        <trans-unit id="a465c66b5dc128bd57f8fcdcf456255c8a8a7859" translate="yes" xml:space="preserve">
          <source>So now the ' character ends the string literal before the programmer was expecting it.  Combined with the ; character to end the statement, an attacker can now add whatever sql they want.  The -- comment at the end is to make sure any remaining sql in the original statement does not prevent the query from compiling on the server.</source>
          <target state="translated">因此,现在'字符在程序员预料到它之前就结束了字符串的字段。结合;字符来结束语句,攻击者现在可以添加任何他们想要的SQL。结尾的 ---注释是为了确保原始语句中的任何剩余的 sql 不会阻止服务器上的查询编译。</target>
        </trans-unit>
        <trans-unit id="5e96ce08b6516eb0bdfd1e8209b76ce5401e37a1" translate="yes" xml:space="preserve">
          <source>Solution - use PDO prepare() &amp;amp; bindParam() methods:</source>
          <target state="translated">解决方案-使用PDO prepare（）和bindParam（）方法：</target>
        </trans-unit>
        <trans-unit id="5ff57f4185e884322f43c9c59da60f12f41285ea" translate="yes" xml:space="preserve">
          <source>TL;DR</source>
          <target state="translated">TL;DR</target>
        </trans-unit>
        <trans-unit id="ed7851e23950df599910f44b392a86be5fb06a01" translate="yes" xml:space="preserve">
          <source>That would enable you to log in to any account without knowing the password. So you don't need to be able to use two statements in order to use SQL injection, although you can do more destructive things if you are able to supply multiple statements.</source>
          <target state="translated">这将使你可以在不知道密码的情况下登录任何账户。所以,你不需要能够使用两条语句就可以使用SQL注入,虽然如果你能够提供多条语句,你可以做更多的破坏性的事情。</target>
        </trans-unit>
        <trans-unit id="6f01ea093d0abce096b0f1ba94e2bd02ddf0d650" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;');&lt;/code&gt; ends the query, it doesn't start a comment. Then it drops the students table and comments the rest of the query that was supposed to be executed.</source>
          <target state="translated">&lt;code&gt;');&lt;/code&gt; 结束查询，它不会开始注释。 然后，它删除了students表并注释了应该执行的其余查询。</target>
        </trans-unit>
        <trans-unit id="2d5e55ae2ea8efc24225552a86bfc8c2a77c138d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'&lt;/code&gt; character in SQL is used  for string constants. In this case it is used for ending the string constant and not for comment.</source>
          <target state="translated">SQL中的 &lt;code&gt;'&lt;/code&gt; 字符用于字符串常量。 在这种情况下，它用于结束字符串常量，而不用于注释。</target>
        </trans-unit>
        <trans-unit id="f92ff1774fac1c9b4900067042e78a60943008ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'&lt;/code&gt; in the student's name is not a comment, it's the closing &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms179899.aspx&quot;&gt;string delimiter&lt;/a&gt;.  Since the student's name is a string, it's needed syntactically to complete the hypothetical query.  Injection attacks only work &lt;em&gt;when the SQL query they inject results in valid SQL&lt;/em&gt;.</source>
          <target state="translated">学生姓名中的 &lt;code&gt;'&lt;/code&gt; 不是注释，是结束&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms179899.aspx&quot;&gt;字符串定界符&lt;/a&gt; 。 由于学生的名字是一个字符串，因此在语法上需要它来完成假设的查询。 注入攻击仅&lt;em&gt;在其将有效查询注入结果的SQL查询时&lt;/em&gt;起作用。</target>
        </trans-unit>
        <trans-unit id="aceae0413666e84da23e62ac60c8bac74e2f5d8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--&lt;/code&gt; only comments the remainder of the line.</source>
          <target state="translated">&lt;code&gt;--&lt;/code&gt; 仅注释该行的其余部分。</target>
        </trans-unit>
        <trans-unit id="74098fc9f260146c228104b6c65f525edc48784f" translate="yes" xml:space="preserve">
          <source>The SQL injection here is the result of the name of the student terminating the statement and including a separate &lt;code&gt;DROP TABLE&lt;/code&gt; command; the two dashes at the end of the input are intended to comment out any leftover code that would otherwise cause an error. The last line of the output confirms that the database server has dropped the table.</source>
          <target state="translated">此处的SQL注入是终止该语句的学生名称的结果，并包括一个单独的 &lt;code&gt;DROP TABLE&lt;/code&gt; 命令； 输入末尾的两个破折号用于注释掉所有否则会导致错误的剩余代码。 输出的最后一行确认数据库服务器已删除该表。</target>
        </trans-unit>
        <trans-unit id="d2e3583e0dbe2234f515adc562e653eb57e46697" translate="yes" xml:space="preserve">
          <source>The SQL would become:</source>
          <target state="translated">SQL将成为:</target>
        </trans-unit>
        <trans-unit id="98ed052ab768c42b4c51024ac95005d02b55e79b" translate="yes" xml:space="preserve">
          <source>The code is mistakenly placing anything the user supplied as the variable. You wanted the SQL to be:</source>
          <target state="translated">这段代码错误地将用户提供的任何东西都作为变量放置。你想要的SQL是。</target>
        </trans-unit>
        <trans-unit id="1a1f5503c8dacf159b36aa6dc81597f075d43234" translate="yes" xml:space="preserve">
          <source>The code to retrieve user name from request is</source>
          <target state="translated">从请求中获取用户名的代码是</target>
        </trans-unit>
        <trans-unit id="133d738d5f98f614bed15f518ef065e70ac0ec32" translate="yes" xml:space="preserve">
          <source>The double dash (--) will just comment out remaining part of the query.</source>
          <target state="translated">双破折号(--)只是注释了查询的剩余部分。</target>
        </trans-unit>
        <trans-unit id="1504af61394d6829bd808405ed9344a3c5620dec" translate="yes" xml:space="preserve">
          <source>The first one will do the normal search.</source>
          <target state="translated">前者会做正常的搜索。</target>
        </trans-unit>
        <trans-unit id="c406de1c10a6141ff755969fdb6d8f9fd28f392b" translate="yes" xml:space="preserve">
          <source>The original code in the school's program probably looks something like</source>
          <target state="translated">学校程序中的原始代码大概是这样的样子</target>
        </trans-unit>
        <trans-unit id="1f92ec13c954912f1e1bcc65272443cfb80a31ce" translate="yes" xml:space="preserve">
          <source>The result?</source>
          <target state="translated">结果呢?</target>
        </trans-unit>
        <trans-unit id="c762df0f9ec734a489ffde76def0caa39fa5c6bb" translate="yes" xml:space="preserve">
          <source>The resultant query becomes</source>
          <target state="translated">由此产生的查询变为</target>
        </trans-unit>
        <trans-unit id="5df6724d22e0babfe904b6b14173f098d3dab8ae" translate="yes" xml:space="preserve">
          <source>The second one will drop the table student if the account has sufficient privileges (Generally the school admin account will run such query and will have the privileges talked about above).</source>
          <target state="translated">第二种,如果账号有足够的权限,就会把表学生丢掉(一般来说,学校的管理员账号会运行这样的查询,会有上面讲到的权限)。</target>
        </trans-unit>
        <trans-unit id="2d104507ada99e5d8537b24476a8fdc95e35ad06" translate="yes" xml:space="preserve">
          <source>The semicolon ends the insert command and starts another; the -- comments out the rest of the line. The DROP TABLE command is executed...</source>
          <target state="translated">分号结束插入命令并开始另一个命令;----注释了该行的其余部分。DROP TABLE命令被执行.....。</target>
        </trans-unit>
        <trans-unit id="30ed2dd959ffaed009b9812f05737346b7e5d2ed" translate="yes" xml:space="preserve">
          <source>The writer of the database probably did a</source>
          <target state="translated">数据库的作者可能做了一个</target>
        </trans-unit>
        <trans-unit id="0f86d3dd6c873d977a65f9095a5db0a162d4537d" translate="yes" xml:space="preserve">
          <source>Then the resulting SQL string would be this:</source>
          <target state="translated">那么得出的SQL字符串是这样的。</target>
        </trans-unit>
        <trans-unit id="5c1a493136ed3ba8c5afdcf8999adbcbf6478f23" translate="yes" xml:space="preserve">
          <source>This drops (deletes) the student table.</source>
          <target state="translated">这样一来,学生表就会被(删除)。</target>
        </trans-unit>
        <trans-unit id="09d35ca1f5c9f54142fbc66f3b9ae42880e84716" translate="yes" xml:space="preserve">
          <source>This is dangerous as it can nullify password authentication, if present</source>
          <target state="translated">这是很危险的,因为如果存在的话,会使密码认证失效。</target>
        </trans-unit>
        <trans-unit id="8a2d0b2b0e59d3e8ece42c60838ae2d5a4cbdb6e" translate="yes" xml:space="preserve">
          <source>This is how it works:
Lets suppose the administrator is looking for records of student</source>
          <target state="translated">这就是它的工作原理。假设管理员正在寻找学生的记录</target>
        </trans-unit>
        <trans-unit id="fe81f720466bedf90225a9b8c3c25cc2caad04a3" translate="yes" xml:space="preserve">
          <source>This is the naive way to add text input into a query, and is &lt;em&gt;very bad&lt;/em&gt;, as you will see.</source>
          <target state="translated">如您所见，这是将文本输入添加到查询中的简单方法，并且&lt;em&gt;非常糟糕&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="f4b6f2ee70fc32667125f99134f18f48f6d5e0e2" translate="yes" xml:space="preserve">
          <source>This is why bind parameters are a good thing.</source>
          <target state="translated">这就是为什么绑定参数是个好东西。</target>
        </trans-unit>
        <trans-unit id="f34eda5ca211eb3175806664d5fd38d21af5eda6" translate="yes" xml:space="preserve">
          <source>To make it clear what's happening, let's try this with a simple table containing only the name field and add a single row:</source>
          <target state="translated">为了清楚地说明情况,让我们用一个只包含名称字段的简单表格来尝试一下,并添加一行。</target>
        </trans-unit>
        <trans-unit id="69e18205e6435018fec90b85d4e3a87afed1d5d3" translate="yes" xml:space="preserve">
          <source>Try to replace table_name with the real table name. If he get your table name right they would empty your table! &lt;strong&gt;(It is very easy to brut force this URL with simple script)&lt;/strong&gt;</source>
          <target state="translated">尝试用实际的表名替换table_name。 如果他正确设置了您的表名，他们将清空您的表！ &lt;strong&gt;（用简单的脚本强行强制使用此URL很容易）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bafa483229452946a2498bdf56c79df0cbc5f7e3" translate="yes" xml:space="preserve">
          <source>What does this SQL do:</source>
          <target state="translated">这个SQL是做什么的。</target>
        </trans-unit>
        <trans-unit id="e256ca0ab96555169f167cecea8df3dedc1d6266" translate="yes" xml:space="preserve">
          <source>What gets run on the database is this query:</source>
          <target state="translated">在数据库中运行的是这样的查询。</target>
        </trans-unit>
        <trans-unit id="21339d9c4840b2a2bb4902b933d347e8cb815a77" translate="yes" xml:space="preserve">
          <source>What happens when we insert Little Bobby Tables's name into the table?</source>
          <target state="translated">当我们将小波比表的名字插入到表格中时,会发生什么情况?</target>
        </trans-unit>
        <trans-unit id="daa8241056744ddd3490433b4056a17c6aaf1a07" translate="yes" xml:space="preserve">
          <source>What you get is:</source>
          <target state="translated">你得到的是。</target>
        </trans-unit>
        <trans-unit id="1ce587cc039592196a56f7601d62743da75474c3" translate="yes" xml:space="preserve">
          <source>When we query the table, we get this:</source>
          <target state="translated">当我们查询该表时,我们得到这样的结果。</target>
        </trans-unit>
        <trans-unit id="a0a70210ca826c39f74e99f7815e7828691e7797" translate="yes" xml:space="preserve">
          <source>You can, however, manipulate an existing SQL statement via SQL injection without having to add a second statement. Let's say you have a login system which checks a username and a password with this simple select:</source>
          <target state="translated">但是,你可以通过SQL注入来操作现有的SQL语句,而不需要添加第二个语句。假设你有一个登录系统,用这个简单的选择来检查用户名和密码。</target>
        </trans-unit>
        <trans-unit id="b1d33b75385409327c7ad149de2f5700e2332439" translate="yes" xml:space="preserve">
          <source>You don't need to input form data to make SQL injection.</source>
          <target state="translated">你不需要输入表单数据就可以进行SQL注入。</target>
        </trans-unit>
        <trans-unit id="506b8b70be03f131ecad01eb971b38a21bfc62da" translate="yes" xml:space="preserve">
          <source>Your query would look something like this...</source>
          <target state="translated">你的询问看起来像这样......</target>
        </trans-unit>
        <trans-unit id="84e0def289034c082b05baf61e91d33a82183f27" translate="yes" xml:space="preserve">
          <source>Your url would look 
&lt;a href=&quot;http://yoursite.com/show?id=1&quot;&gt;http://yoursite.com/show?id=1&lt;/a&gt;</source>
          <target state="translated">您的网址应为&lt;a href=&quot;http://yoursite.com/show?id=1&quot;&gt;http://yoursite.com/show?id=1&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5150b572e20984159df6524b5d5ea5e28030eaec" translate="yes" xml:space="preserve">
          <source>` )</source>
          <target state="translated">` )</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="6bd9dfe1efad33667e69e751d695397aab30aac7" translate="yes" xml:space="preserve">
          <source>ie. it will terminate early the insert statement, execute whatever malicious code the cracker wants, then comment out whatever remainder of code there might be.</source>
          <target state="translated">即:它将提前终止插入语句,执行破解者想要的任何恶意代码,然后注释出可能存在的任何剩余代码。</target>
        </trans-unit>
        <trans-unit id="7eace1c108e9774e1c99d6e09e4b22fb30e874ff" translate="yes" xml:space="preserve">
          <source>which, in plain English, roughly translates to the two queries:</source>
          <target state="translated">用通俗的英语来说,大致可以翻译成两个疑问。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
