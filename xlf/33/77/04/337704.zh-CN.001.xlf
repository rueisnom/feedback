<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/337704">
    <body>
      <group id="337704">
        <trans-unit id="48f19cdab83f69f332c2f5fcb40c9ec7eaf89ca1" translate="yes" xml:space="preserve">
          <source>(Of course, &quot;pivot&quot; must return as many rows as the maximum number of
items we can find in the list)</source>
          <target state="translated">(当然,&quot;pivot &quot;必须返回的行数必须与我们在列表中能找到的最大行数一样多)</target>
        </trans-unit>
        <trans-unit id="dee8436afe3eef1c33541c551908ae7951d32018" translate="yes" xml:space="preserve">
          <source>(Yes, I will agree that this is an obscure case.  Probably one that is not likely to be tested.  We wouldn't expect a wildcard in a column value.  We may assume that the application prevents such a value from being stored.  But in my experience, I've rarely seen a database constraint that specifically disallowed characters or patterns that would be considered wildcards on the right side of a &lt;code&gt;LIKE&lt;/code&gt; comparison operator.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（是的，我会同意这是一个晦涩的案例。很可能不会进行测试。我们不会期望在列值中使用通配符。我们可能会假定该应用程序阻止存储该值。但是根据我的经验，我很少看到数据库约束明确禁止在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;LIKE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;比较运算符&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右侧被视为通配符的字符或模式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d9796c38c06486ee44725f02212200e0e19ef822" translate="yes" xml:space="preserve">
          <source>(new version posted on 6/4/13).</source>
          <target state="translated">(新版贴在6413上)。</target>
        </trans-unit>
        <trans-unit id="78bf7b6b27c8792a1b6240a992597a2169e13c12" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL injection&lt;/a&gt; (taking what would appear to be user supplied information, and including that in the SQL text rather than supplying them through bind variables.  Using bind variables isn't required, it's just one convenient approach to thwart with SQL injection.  There are other ways to deal with it:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL注入&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（采用看似由用户提供的信息，并将其包括在SQL文本中，而不是通过绑定变量提供它们。不需要使用绑定变量，这只是挫败SQL注入的一种便捷方法。还有其他方法处理方法：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a6e53cd33415c69a4bdf01a31b33c9cdd34fccfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INSERT&lt;/code&gt; each look-up value into that column.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每个查找值插入该列。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac17bef807ba02b72de1e63fe25d0cf263de4816" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Addendum&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Addendum&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="cac28b87690e0244dc4499e21d80ce7f137a57b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/1196908?opt.withExecutionPlan=true#executionPlan&quot;&gt;SEDE - Live Demo&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/1196908?opt.withExecutionPlan=true#executionPlan&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SEDE-现场演示&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8282433139e0a1e1ac6d41141b59ccceb433f13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/481811&quot;&gt;LiveDemo&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/481811&quot;&gt;LiveDemo&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d7cc78633528ed1105f6ee787b57caf8b5aca4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A function where ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个功能在哪里？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce6064f3be2a2c0c2b244a4e5aa061cd081bde6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CREDITS FOR: Dinakar Nethi&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;致谢：Dinakar Nethi&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a8e521f362bc99965c4c0a3defa878eb3c31799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cliffs notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;悬崖笔记：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8115e639335d833240663506049d0442b68dbba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusion&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4dbfdda273078557fedd54082b0a22e178bc8cdf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DDL Script:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DDL脚本：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a555be6a06e633fb60d1ff7483e33da5b5ada3a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Domain knowledge&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;领域知识&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="252a44c26d52bbbdee3f05ef052068c571e8e15c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E. Find rows by list of values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;E.按值列表查找行&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67d3195b93a234f68cebcb65f2e721c5d575f4bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;
Create the table called SelectedTags using the following script.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编辑：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 使用以下脚本创建名为SelectedTags的表。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67c8cacdeb62d71990d850b41caea868fe7455b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Escape the escape&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;逃脱&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f05f137eb1a56908403bfbf2320629bc58403b99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inline expression gets messy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内联表达式变得凌乱&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="600e0ea4701a71484fccb509e0fd2655945c518e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Obscure corner case&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;暗角机箱&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b63eb5ee1a8de97b89ae2ad28cf585e5487ee5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Other issues recapitulated&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;总结其他问题&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80bf15d2aa8f62da4288c48a4b4967714fe0679e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Patching a hole&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;修补孔&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0b37171896c661e0a5bb56c2f1e263143165f10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Queries with large lists:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;清单较大的查询：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="38950a26e45ab68986a78cabd9db01f0fec39a5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Queries with reusable execution plans, called multiple times by simply changing the parameters or if the query is complicated:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有可重复使用的执行计划的查询，只需更改参数或查询比较复杂即可多次调用：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82001c1ced780a951a7c6f3798a7838f8bd5de2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Selected answer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;选择的答案&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23461227354b053ccf166a361a0b790e10fba24a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Some problems with % character&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;％字符的一些问题&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9441af39c3c3128da7ddf830bf1d1d5d69405d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;T-SQL:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;T-SQL:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a0dc348f82c1d40f9d8a3a84a3bb9786ff40a7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The underscore too&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;下划线也是&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f62f9cd4d15d0b544b7ee98f587e4a539f1b27d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Those pesky brackets&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那些讨厌的括号&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7822cac6cb84dcb1f769dc18ac0d5e0e14b57cf2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Your case/simple queries with few parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您的案例/简单查询，只需几个参数：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="554b441ed3b70f63af83d232d29f2422b76a4a30" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Original question has requirement &lt;code&gt;SQL Server 2008&lt;/code&gt;. Because this question is often used as duplicate, I've added this answer as reference. &lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原始问题有要求&lt;/font&gt;&lt;/font&gt; &lt;code&gt;SQL Server 2008&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为这个问题经常被重复使用，所以我添加了这个答案作为参考。&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ef5c31c764d5981c9a8f620d4a86708fe1cafd16" translate="yes" xml:space="preserve">
          <source>A full worked example below</source>
          <target state="translated">下面是一个完整的工作实例</target>
        </trans-unit>
        <trans-unit id="0ea255bf74e697155208b49c499a61c81d0083e5" translate="yes" xml:space="preserve">
          <source>Also, SQL&amp;nbsp;Server 7 and later will &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa175264(SQL.80).aspx&quot;&gt;auto-parameterize queries&lt;/a&gt;, so using parameters isn't really necessary from a performance standpoint - it is, however, &lt;em&gt;critical&lt;/em&gt; from a security standpoint - especially with user inputted data like this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而且，SQL Server 7和更高版本将&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa175264(SQL.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自动对查询&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行参数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此从性能的角度来看，实际上并不需要使用参数-但是，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从安全的角度来看&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，使用参数&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;至关重要&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（尤其是对于这样的用户输入数据）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cb65fbb9fdbacb8813819ce6fe844531bf67c562" translate="yes" xml:space="preserve">
          <source>And that function may have some differences in behavior, dependent on the DBMS and version.  (A shout out to all you Java developers so keen on being able to use any database engine interchangeably.)</source>
          <target state="translated">而这个函数可能会有一些行为上的差异,这取决于DBMS和版本。(在此向所有热衷于可以互换使用任何数据库引擎的Java开发者们表示敬意)</target>
        </trans-unit>
        <trans-unit id="e7647df632ba6a5ad2e75cfdb6f974350f2e7424" translate="yes" xml:space="preserve">
          <source>And the function:</source>
          <target state="translated">和功能。</target>
        </trans-unit>
        <trans-unit id="cccf532bbfa1429eb9f3289f7400d714e8a760fa" translate="yes" xml:space="preserve">
          <source>Another possible solution is instead of passing a variable number of arguments to a stored procedure, pass a single string containing the names you're after, but make them unique by surrounding them with '&amp;lt;&amp;gt;'. Then use PATINDEX to find the names:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一种可能的解决方案是，不将可变数量的参数传递给存储过程，而是传递包含您要使用的名称的单个字符串，但通过用'&amp;lt;&amp;gt;'包围它们来使其唯一。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后使用PATINDEX查找名称：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03d0b83415d956ac04c59f569a6227895ab74272" translate="yes" xml:space="preserve">
          <source>Anyway, if you run this in the highly recommended &lt;a href=&quot;http://www.linqpad.net/&quot;&gt;LINQPad&lt;/a&gt;, and run this query, you can view the actual SQL that the SQL LINQ provider generated. It'll show you each of the values getting parameterized into an &lt;code&gt;IN&lt;/code&gt; clause.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无论如何，如果在强烈推荐的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.linqpad.net/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LINQPad中&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运行此命令并运行此查询，则可以查看SQL LINQ提供程序生成的实际SQL。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它将向您显示每个值被参数化为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;IN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子句。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="23b01d595f6060073511290535fff818b9114f31" translate="yes" xml:space="preserve">
          <source>But as soon as I saw it, I immediately saw a potential problem with it, and it's not my nature to let it slide.  I don't mean to be critical of the efforts of others.  I know many developers take their work very personally, because they invest so much into it and they care so much about it.  So please understand, this is not a personal attack.  What I'm identifying here is the type of problem that crops up in production rather than testing.</source>
          <target state="translated">但我一看到这句话,立刻就看出了其中可能存在的问题,我的本性是不屑一顾。我并没有批评别人的努力的意思。我知道很多开发者对自己的工作非常重视,因为他们投入了那么多的精力,对工作非常在意。所以请理解,这不是针对个人的攻击。我这里指的是生产中出现的问题类型,而不是测试中出现的问题。</target>
        </trans-unit>
        <trans-unit id="1f6dc5172459fe319cfcc98bb14b0e0d6d765a74" translate="yes" xml:space="preserve">
          <source>But in terms generalizing this approach, let's also consider the more obscure corner cases, like when the &lt;code&gt;Name&lt;/code&gt; column contains a wildcard character (as recognized by the LIKE predicate.)  The wildcard character I see most commonly used is &lt;code&gt;%&lt;/code&gt; (a percent sign.). So let's deal with that here now, and later go on to other cases.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是从广义上来说，我们还要考虑更晦涩的转折情况，例如当&amp;ldquo; &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;列包含通配符（如LIKE谓词所识别。）我看到的最常用的通配符是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（百分号）。 。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，让我们现在在这里进行处理，然后再处理其他情况。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef0d5d39e697ffe1ba99b0761754afc9c4f40372" translate="yes" xml:space="preserve">
          <source>But that same row will &lt;strong&gt;not&lt;/strong&gt; be returned if the order of the search terms is reversed:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果搜索条件的顺序相反，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不会&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;返回&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同一行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ad02e2300cc6443c140b0ea75769de719b9a2f50" translate="yes" xml:space="preserve">
          <source>But, absent the specialized knowledge and a guarantee, it's important for us to at least consider handling those obscure corner cases, and consider whether the behavior is reasonable and &quot;per the specification&quot;.</source>
          <target state="translated">但是,在没有专业的知识和保证的情况下,我们至少要考虑到处理那些晦涩难懂的边角料,考虑到行为是否合理,是否 &quot;按规范&quot;。</target>
        </trans-unit>
        <trans-unit id="f8eb3248811492e79afeba88e2112b19fd5e3085" translate="yes" xml:space="preserve">
          <source>Cheers.</source>
          <target state="translated">Cheers.</target>
        </trans-unit>
        <trans-unit id="bfee5586db97ea7e6e02b3fe7c5e0b9a70a81809" translate="yes" xml:space="preserve">
          <source>Consider a Name value of &lt;code&gt;'pe%ter'&lt;/code&gt;.  (For the examples here, I use a literal string value in place of the column name.)  A row with a Name value of `'pe%ter' would be returned by a query of the form:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;考虑名称值&lt;/font&gt;&lt;/font&gt; &lt;code&gt;'pe%ter'&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（对于这里的示例，我使用文字字符串值代替列名。）查询形式将返回名称值为''pe％ter'的行：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d017cf77fe2c73ed635d1a483b157ec724242736" translate="yes" xml:space="preserve">
          <source>Create a &lt;em&gt;temp table&lt;/em&gt; with one column.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用一列&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建一个&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;临时表&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8136fc8a2e6515b930f0753b1f85b9ddce86d5f8" translate="yes" xml:space="preserve">
          <source>DDL Script:</source>
          <target state="translated">DDL脚本。</target>
        </trans-unit>
        <trans-unit id="02a4f4b6de45d5c7489decc7ab589a9afa2cb60e" translate="yes" xml:space="preserve">
          <source>Depending on your goals it might be of use.</source>
          <target state="translated">根据你的目标,它可能会派上用场。</target>
        </trans-unit>
        <trans-unit id="b2d970495b8509db54eabd95430be025d9b303c2" translate="yes" xml:space="preserve">
          <source>Dynamic SQL, maybe with parameters if testing shows better performance.</source>
          <target state="translated">动态SQL,如果测试显示性能更好的话,或许可以用参数。</target>
        </trans-unit>
        <trans-unit id="2c79c2f8fe6cef139b77391f6699a0512a187188" translate="yes" xml:space="preserve">
          <source>Edit:</source>
          <target state="translated">Edit:</target>
        </trans-unit>
        <trans-unit id="9b4f7c19764919f3700623d10af2eaf2e9fd3645" translate="yes" xml:space="preserve">
          <source>Fiddler demo</source>
          <target state="translated">Fiddler演示</target>
        </trans-unit>
        <trans-unit id="026dacaafe85baaf736570c8698095c25f19b7af" translate="yes" xml:space="preserve">
          <source>Finding matching pairs of brackets shouldn't be that hard.  It's a little more difficult than handling the occurrences of singleton % and _.  (Note that it's not sufficient to just escape all occurrences of brackets, because a singleton bracket is considered to be a literal, and doesn't need to be escaped. The logic is getting a little fuzzier than I can handle without running more test cases.)</source>
          <target state="translated">找到匹配的括号对应该不难。(注意,仅仅转义掉所有的括号的出现是不够的,因为单子括号被认为是一个字面意思,不需要转义。如果不运行更多的测试用例,这个逻辑就会变得有些模糊,我无法处理。)</target>
        </trans-unit>
        <trans-unit id="956bf832223f45c34ec12226533b916e6709dbb5" translate="yes" xml:space="preserve">
          <source>First, you have to create a type</source>
          <target state="translated">首先,你必须创建一个类型</target>
        </trans-unit>
        <trans-unit id="d676f66cb4ad07fb96444f3511cde73425052bf9" translate="yes" xml:space="preserve">
          <source>For SQL Server 2008, you can use a &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb675163.aspx&quot;&gt;table valued parameter&lt;/a&gt;. It's a bit of work, but it is arguably cleaner than &lt;a href=&quot;https://stackoverflow.com/questions/337704/parameterizing-a-sql-in-clause#337792&quot;&gt;my other method&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于SQL Server 2008，可以使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb675163.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表值参数&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这有点费力，但可以说比&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/337704/parameterizing-a-sql-in-clause#337792&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我的其他方法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;干净&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="227f0d29bb06ad813fae5f94026e2af979d5e192" translate="yes" xml:space="preserve">
          <source>For a variable number of arguments like this the only way I'm aware of is to either generate the SQL explicitly or do something that involves populating a temporary table with the items you want and joining against the temp table.</source>
          <target state="translated">对于像这样的可变参数数,我所知道的唯一方法就是显式生成SQL,或者是用你想要的项目填充一个临时表,然后加入到临时表中。</target>
        </trans-unit>
        <trans-unit id="fe75486630ba5a7fcd537b56d8939d238184983f" translate="yes" xml:space="preserve">
          <source>For your case anything you do, be it parameterization with a fixed number of items in the list (null if not used), dynamically building the query with or without parameters, or using stored procedures with table valued parameters will not make much of a difference. However, my general recommendations are as follows:</source>
          <target state="translated">对于你的情况,你所做的任何事情,不管是在列表中使用固定数量的参数化(如果不使用,则为null),动态地建立查询,或者使用存储过程中的表值参数,都不会有太大的区别。不过,我一般的建议如下。</target>
        </trans-unit>
        <trans-unit id="c849be4c99e78b71f4be145f175e981782cb4a3d" translate="yes" xml:space="preserve">
          <source>Having IN( 'tag1', 'tag2', 'tag1', 'tag1', 'tag1' ) will be easily optimized away by SQL Server. Plus, you get direct index seeks</source>
          <target state="translated">拥有IN('tag1','tag2','tag1','tag1','tag1','tag1','tag1','tag1'),就可以很容易地被SQL Server优化。此外,你还可以获得直接的索引寻求</target>
        </trans-unit>
        <trans-unit id="0883a1359a7ef9fb3528dc28cd0c0ad2edfa8b13" translate="yes" xml:space="preserve">
          <source>Here Dapper does the thinking, so you don't have to. Something similar is possible with &lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;LINQ&amp;nbsp;to&amp;nbsp;SQL&lt;/a&gt;, of course:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dapper在这里进行思考，因此您不必这样做。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LINQ to SQL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能会发生类似的事情&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec20b27947e409494d8b39aff65011bcad68b37c" translate="yes" xml:space="preserve">
          <source>Here is another alternative. Just pass a comma-delimited list as a string parameter to the stored procedure and:</source>
          <target state="translated">这里有另一种选择。只需将一个逗号分隔的列表作为字符串参数传递给存储过程,然后。</target>
        </trans-unit>
        <trans-unit id="3bef9b813806d919c0ef17520cdcae6d63be6a13" translate="yes" xml:space="preserve">
          <source>Here is another answer to this problem.</source>
          <target state="translated">下面是这个问题的另一个答案。</target>
        </trans-unit>
        <trans-unit id="8058dd0239d0ce0f235c473fee26724245a2479d" translate="yes" xml:space="preserve">
          <source>Here is the code for the UDF &lt;em&gt;(I got it from Stack Overflow somewhere, i can't find the source right now)&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是UDF的代码&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（我是从Stack Overflow的某个地方获得的，我现在找不到源）&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d9c357ac321a2c270d39faa0087485f24d73d7b" translate="yes" xml:space="preserve">
          <source>Here is the split function I use.</source>
          <target state="translated">下面是我使用的拆分功能。</target>
        </trans-unit>
        <trans-unit id="31b408cd5989d3b3a9e85be52bf44f860e81198e" translate="yes" xml:space="preserve">
          <source>Here's a quick-and-dirty technique I have used:</source>
          <target state="translated">下面是我用过的一个快刀斩乱麻的技巧。</target>
        </trans-unit>
        <trans-unit id="450492771c56d95cbcd05fb281ef0131265e08c9" translate="yes" xml:space="preserve">
          <source>Here's a technique that recreates a local table to be used in a query string. Doing it this way eliminates all parsing problems.</source>
          <target state="translated">这里有一个技术,可以在查询字符串中重新创建一个本地表。这样做可以消除所有的解析问题。</target>
        </trans-unit>
        <trans-unit id="e6ad03598d810f4f2eebf49dfe172e701f6b4e08" translate="yes" xml:space="preserve">
          <source>Here's the CTE version.</source>
          <target state="translated">下面是CTE版本。</target>
        </trans-unit>
        <trans-unit id="bc4f98564ef32ef0f8fb6179097d52a7744bb920" translate="yes" xml:space="preserve">
          <source>How do I parameterize a query containing an &lt;code&gt;IN&lt;/code&gt; clause with a variable number of arguments, like this one?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我该如何对包含一个&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;带有可变数量参数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;IN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子句&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的查询&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行参数化？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bb54217d9c4d37d19fb2185c0c208e0cb24405d" translate="yes" xml:space="preserve">
          <source>I believe others have already sufficiently pointed out some of the other commonly considered areas of concern:</source>
          <target state="translated">我相信其他人已经充分指出了其他一些通常被认为值得关注的领域。</target>
        </trans-unit>
        <trans-unit id="e7734598a6d1c2cfa95be739746a7afb394b36a1" translate="yes" xml:space="preserve">
          <source>I have also seen stored procedures that had 500 parameters with default values of null, and having WHERE Column1 IN (@Param1, @Param2, @Param3, ..., @Param500). This caused SQL to build a temp table, do a sort/distinct, and then do a table scan instead of an index seek. That is essentially what you would be doing by parameterizing that query, although on a small enough scale that it won't make a noticeable difference. I highly recommend against having NULL in your IN lists, as if that gets changed to a NOT IN it will not act as intended. You could dynamically build the parameter list, but the only obvious thing that you would gain is that the objects would escape the single quotes for you. That approach is also slightly slower on the application end since the objects have to parse the query to find the parameters. It may or may not be faster on SQL, as parameterized queries call sp_prepare, sp_execute for as many times you execute the query, followed by sp_unprepare.</source>
          <target state="translated">我也见过有存储过程有500个参数默认值为null的存储过程,并且有WHERE Column1 IN(@Param1、@Param2、@Param3、...、@Param500)。这导致了SQL建立一个临时表,做一个sortdistinct,然后做一个表扫描,而不是索引查找。这基本上就是你通过参数化查询所要做的事情,虽然规模很小,但不会有明显的区别。我强烈建议不要在IN列表中使用NULL,因为如果把它改成NOT IN,它将不符合预期。你可以动态地建立参数列表,但唯一明显的好处是,你将获得的对象将为你转义单引号。这种方法在应用端也会稍微慢一些,因为对象必须解析查询来查找参数。在SQL上可能会更快,也可能不会更快,因为参数化的查询会调用sp_prepare、sp_execute,你执行查询的次数越多,就会调用sp_unprepare。</target>
        </trans-unit>
        <trans-unit id="d82e71ada8a62159ea70852009714bf5aa14c66d" translate="yes" xml:space="preserve">
          <source>I have an answer that doesn't require a UDF, XML
Because IN accepts a select statement
e.g. SELECT * FROM Test where Data IN (SELECT Value FROM TABLE)</source>
          <target state="translated">我有一个不需要UDF的答案,XML因为IN接受一个select语句,例如SELECT*FROM Test where Data IN (SELECT Value FROM TABLE)。</target>
        </trans-unit>
        <trans-unit id="2180e8cc79db8111713b3a38b9273505d784397f" translate="yes" xml:space="preserve">
          <source>I have seen the split functions take longer to execute than the query themselves in many cases where the parameters get large. A stored procedure with table valued parameters in SQL 2008 is the only other option I would consider, although this will probably be slower in your case. TVP will probably only be faster for large lists if you are searching on the primary key of the TVP, because SQL will build a temporary table for the list anyway (if the list is large). You won't know for sure unless you test it.</source>
          <target state="translated">我见过在许多参数变大的情况下,拆分函数的执行时间比查询本身要长。在SQL 2008中,使用表值参数的存储过程是我唯一会考虑的其他选择,尽管这可能会在你的情况下更慢。如果你是在TVP的主键上进行查询,TVP可能只有在大的列表中才会更快,因为SQL会为这个列表建立一个临时表(如果列表很大的话)。除非你进行测试,否则你无法确定。</target>
        </trans-unit>
        <trans-unit id="e2d5c5e674c7b6a4cb6b4676422df0cbb9e45827" translate="yes" xml:space="preserve">
          <source>I heard Jeff/Joel talk about this on the podcast today (&lt;em&gt;&lt;a href=&quot;http://itc.conversationsnetwork.org/audio/download/ITC.SO-Episode34-2008.12.16.mp3&quot;&gt;episode 34&lt;/a&gt;&lt;/em&gt;, 2008-12-16 (MP3, 31&amp;nbsp;MB), 1 h 03 min 38 secs - 1 h 06 min 45 secs), and I thought I recalled Stack&amp;nbsp;Overflow was using &lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;LINQ&amp;nbsp;to&amp;nbsp;SQL&lt;/a&gt;, but maybe it was ditched. Here's the same thing in LINQ&amp;nbsp;to&amp;nbsp;SQL.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我今天在播客上听到Jeff / Joel谈论这个话题（&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;http://itc.conversationsnetwork.org/audio/download/ITC.SO-Episode34-2008.12.16.mp3&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第34集&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，2008-12-16（MP3，31 MB），1小时03分38秒-1小时06分45秒），我以为我想起了Stack Overflow在使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LINQ to SQL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是也许已经放弃了。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这在LINQ to SQL中也是一样。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68e1d98c1bde1a441a049af1b527a7799aebbbe2" translate="yes" xml:space="preserve">
          <source>I like Joel Spolsky's approach.  It's clever.  And it works.</source>
          <target state="translated">我喜欢Joel Spolsky的方法。它很聪明。而且很管用。</target>
        </trans-unit>
        <trans-unit id="10c3a107dda505aa2f5d453923b47dd798c81981" translate="yes" xml:space="preserve">
          <source>I never got around to profiling exactly how &lt;em&gt;fast&lt;/em&gt; it was, but in my situation it was needed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我从来没有完全了解&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;速度&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是在我的情况下是必需的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="82c8befdd145dc1a6bf86c2be33fbcb496ad3fd6" translate="yes" xml:space="preserve">
          <source>I prefer this approach to escaping because it works in Oracle and MySQL as well as SQL Server.  (I usually use the \ backslash as the escape character, since that's the character we use in regular expressions. But why be constrained by convention!</source>
          <target state="translated">与转义相比,我更喜欢这种方法,因为它在Oracle和MySQL以及SQL Server中都可以使用。(我通常使用反斜线作为转义字符,因为我们在正则表达式中使用的就是这个字符。但是,为什么要受制于惯例呢?</target>
        </trans-unit>
        <trans-unit id="af4243377878f11b07ae3404abe46df5a7ff9d2a" translate="yes" xml:space="preserve">
          <source>I think this is a case when a static query is just not the way to go. Dynamically build the list for your in clause, escape your single quotes, and dynamically build SQL. In this case you probably won't see much of a difference with any method due to the small list, but the most efficient method really is to send the SQL exactly as it is written in your post. I think it is a good habit to write it the most efficient way, rather than to do what makes the prettiest code, or consider it bad practice to dynamically build SQL.</source>
          <target state="translated">我认为这种情况下,静态查询就是不适合。为你的in子句动态建立列表,转义你的单引号,动态建立SQL。在这种情况下,由于列表太小,你可能用任何方法都看不出有什么区别,但是最有效的方法真的是完全按照你的帖子里写的那样发送SQL。我认为用最有效的方法写,而不是做最漂亮的代码,或者认为动态构建SQL是一种很好的习惯,或者说动态构建SQL是不好的做法。</target>
        </trans-unit>
        <trans-unit id="470eb3bd8dc8f9275680a731f7a00e1369b18132" translate="yes" xml:space="preserve">
          <source>I use a more concise version &lt;a href=&quot;https://stackoverflow.com/a/337792/16587&quot;&gt;of the top voted answer&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/337792/16587&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;投票结果最&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;简洁&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的答案&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77c29b34770822e532945f81b425ab2daa5931cd" translate="yes" xml:space="preserve">
          <source>I would pass a table type parameter (since it's &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;SQL Server 2008&lt;/a&gt;), and do a &lt;code&gt;where exists&lt;/code&gt;, or inner join. You may also use XML, using &lt;code&gt;sp_xml_preparedocument&lt;/code&gt;, and then even index that temporary table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我将传递一个表类型参数（因为它是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），然后执行&lt;/font&gt;&lt;/font&gt; &lt;code&gt;where exists&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或内部&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;联接&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您还可以使用XML，使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sp_xml_preparedocument&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，然后甚至索引该临时表。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38e00a81ddf5f6fe0b6b36105aa8782ef2784f85" translate="yes" xml:space="preserve">
          <source>I would prefer not to use a dedicated stored procedure for this (or XML), but if there is some elegant way specific to &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;SQL Server 2008&lt;/a&gt;, I am open to that.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我不希望对此（或XML）使用专用的存储过程，但是如果有一些特定于&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;优雅方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我可以接受。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d99406eb70ce3918021a57f108a598c46ca958e8" translate="yes" xml:space="preserve">
          <source>I'd approach this by default with passing a table valued function (that returns a table from a string) to the IN condition.</source>
          <target state="translated">我默认的做法是将一个表值函数(从字符串中返回表)传给IN条件。</target>
        </trans-unit>
        <trans-unit id="358e1888dd9c3dc6a6d8b8f74729dc1edef55c23" translate="yes" xml:space="preserve">
          <source>If needed you can insert it into a temp table, index it, then run a join...</source>
          <target state="translated">如果需要的话,你可以把它插入到一个临时表中,建立索引,然后运行一个联接.....</target>
        </trans-unit>
        <trans-unit id="1be3fb0e541f55904b67a0c3a768429469841e69" translate="yes" xml:space="preserve">
          <source>If we have strings stored inside the IN clause with the comma(,) delimited, we can use the charindex function to get the values. If you use .NET, then you can map with SqlParameters.</source>
          <target state="translated">如果我们在IN子句中存储了用逗号(,)分隔的字符串,我们可以使用charindex函数来获取值。如果你使用的是.NET,那么你可以用SqlParameters进行映射。</target>
        </trans-unit>
        <trans-unit id="c1a9ec97b4d93a4f86712c4f1a87de838971feee" translate="yes" xml:space="preserve">
          <source>If you are calling from .NET, you could use &lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;Dapper dot net&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果从.NET调用，则可以使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dapper点网&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dd00bd710d5c5d138e7a5c14fe395b67a569d86e" translate="yes" xml:space="preserve">
          <source>If you have enough RAM, I'd expect SQL&amp;nbsp;Server would probably cache a plan for the common counts of parameters as well. I suppose you could always add five parameters, and let the unspecified tags be NULL - the query plan should be the same, but it seems pretty ugly to me and I'm not sure that it'd worth the micro-optimization (although, on Stack&amp;nbsp;Overflow - it may very well be worth it).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您有足够的RAM，我希望SQL Server可能还会为通用的参数计数缓存一个计划。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我想您总是可以添加五个参数，并且将未指定的标签设置为NULL-查询计划应该相同，但是对我来说似乎很难看，而且我不确定是否值得进行微优化（不过，堆栈溢出-可能非常值得）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="13efe4ce5cd750e79baf7a01290267049374c466" translate="yes" xml:space="preserve">
          <source>If you're really interested in performance and don't want to iterate through the loop twice, here's a less beautiful version:</source>
          <target state="translated">如果你真的对性能有兴趣,又不想重复迭代两次,这里有一个不那么漂亮的版本。</target>
        </trans-unit>
        <trans-unit id="0c540b5e6699b2c7b611bcf7af1cd074053d21fd" translate="yes" xml:space="preserve">
          <source>If you're unlucky enough to be stuck on &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2005&quot;&gt;SQL Server 2005&lt;/a&gt; you could add a &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Language_Runtime&quot;&gt;CLR&lt;/a&gt; function like this,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您不幸遇到&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2005&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2005的问题&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，可以添加这样的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Language_Runtime&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CLR&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数，&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2f991e2ce21fbc2b508a3faff72c5094821362eb" translate="yes" xml:space="preserve">
          <source>If you've got &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;SQL Server 2008&lt;/a&gt; or later I'd use a &lt;a href=&quot;https://stackoverflow.com/questions/5595353/how-to-pass-table-value-parameters-to-stored-procedure-from-net-code&quot;&gt;Table Valued Parameter&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您拥有&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或更高版本，则可以使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/5595353/how-to-pass-table-value-parameters-to-stored-procedure-from-net-code&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表值参数&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b26bb26a3dff833054084925292a26c85610a666" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://en.wikipedia.org/wiki/ColdFusion&quot;&gt;ColdFusion&lt;/a&gt; we just do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/ColdFusion&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ColdFusion中，&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们只做：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae0b31a603e2cadba5386706372b442225ace3da" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SQL Server 2016+&lt;/code&gt; you could use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/mt684588.aspx&quot;&gt;&lt;code&gt;STRING_SPLIT&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;SQL Server 2016+&lt;/code&gt; 中,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/mt684588.aspx&quot;&gt; &lt;code&gt;STRING_SPLIT&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77792ff8ecdb0ffcc2759ed0fc092e6107edf5e4" translate="yes" xml:space="preserve">
          <source>In SQL Server 2016+ another possibility is to use the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn921879.aspx&quot;&gt;&lt;code&gt;OPENJSON&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在SQL Server 2016+中，另一种可能性是使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn921879.aspx&quot;&gt; &lt;code&gt;OPENJSON&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9f1f4abb84eb41057375a32c3581100f5fffce9" translate="yes" xml:space="preserve">
          <source>In my opinion, the best source to solve this problem, is what has been posted on this site:</source>
          <target state="translated">在我看来,要解决这个问题,最好的源头,就是这个网站上的帖子。</target>
        </trans-unit>
        <trans-unit id="d01a0b1abba0430fb1dfbb704c154c9812f0edb7" translate="yes" xml:space="preserve">
          <source>In the C# code you do something like this:</source>
          <target state="translated">在C#代码中,你会做这样的事情。</target>
        </trans-unit>
        <trans-unit id="5dad346a862dade5a2ce260292058579877f3e81" translate="yes" xml:space="preserve">
          <source>In the SQL you have a clause like this:</source>
          <target state="translated">在SQL中,你有一个像这样的子句。</target>
        </trans-unit>
        <trans-unit id="c9ac14f5f553dbf81735a238c4aec23e0f9b9b3d" translate="yes" xml:space="preserve">
          <source>In this query, the number of arguments could be anywhere from 1 to 5.</source>
          <target state="translated">在这个查询中,参数的数量可以是1到5。</target>
        </trans-unit>
        <trans-unit id="1ccc36caa6c571f60a777db830b24b1bd0152f89" translate="yes" xml:space="preserve">
          <source>Injection concerns aside, take care to note that constructing the command text to accomodate a variable number of parameters (as above) impede's SQL server's ability to take advantage of cached queries. The net result is that you almost certainly lose the value of using parameters in the first place (as opposed to merely inserting the predicate strings into the SQL itself).</source>
          <target state="translated">抛开注入的问题不谈,请注意,构造命令文本以适应可变数量的参数(如上所述)会阻碍SQL服务器利用缓存查询的能力。最终的结果是,你几乎肯定会失去使用参数的价值(而不是仅仅将谓语字符串插入到SQL本身)。</target>
        </trans-unit>
        <trans-unit id="cfe8f3b2b9656fa087b047b0c76f57d8888a9b38" translate="yes" xml:space="preserve">
          <source>Instead of using an &lt;code&gt;IN&lt;/code&gt;, you can then just use your standard &lt;code&gt;JOIN&lt;/code&gt; rules. ( Flexibility++ )</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;除了使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;IN&lt;/code&gt; 之外&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您还可以使用标准的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;JOIN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;规则。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（灵活性++）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6531c8cd756afd65aa968ac013e26ebeae12e8e9" translate="yes" xml:space="preserve">
          <source>It almost goes without saying that we might not want &lt;code&gt;pe%ter&lt;/code&gt; to match peanut butter, no matter how much he likes it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;几乎不用说，我们可能不希望&lt;/font&gt;&lt;/font&gt; &lt;code&gt;pe%ter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;搭配花生酱，无论他多么喜欢。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a8aa17b73c9976e345417d180c7b625a957911aa" translate="yes" xml:space="preserve">
          <source>It does loop through the tag parameters twice; but that doesn't matter most of the time (it won't be your bottleneck; if it is, unroll the loop).</source>
          <target state="translated">它确实会在标签参数中循环两次;但大多数时候这并不重要(它不会成为你的瓶颈;如果是的话,请取消循环)。</target>
        </trans-unit>
        <trans-unit id="4b7b04c75db0a99e0f8a75786d727c9a060cda70" translate="yes" xml:space="preserve">
          <source>Joel Spolsky's approach is clever.  And it works reasonably, it's going to exhibit predictable behavior and predictable performance, given &quot;normal&quot; values, and with the normative edge cases, such as NULL and the empty string.  And it may be sufficient for a particular application.</source>
          <target state="translated">Joel Spolsky的方法很聪明。而且它的工作原理是合理的,它将表现出可预测的行为和可预测的性能,给定 &quot;正常 &quot;的值,并与NULL和空字符串等常态的边缘情况下,它将表现出可预测的行为和可预测的性能。而且对于特定的应用来说,它可能已经足够了。</target>
        </trans-unit>
        <trans-unit id="ef078c7764d0dfe131b3ce83b313bd5d0f32a413" translate="yes" xml:space="preserve">
          <source>Let me state right here, that this is &lt;strong&gt;not an answer&lt;/strong&gt; to the original question.  There are already some demonstrations of that in other good answers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;让我在这里声明，这&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不是&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对原始问题&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的答案&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;其他好的答案中已经有一些示范。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac08ba80594a0659efb8968aea37e16a79e71676" translate="yes" xml:space="preserve">
          <source>Make sure you don't have any &lt;code&gt;|&lt;/code&gt;, blank, or null tags or this won't work</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;确保您没有任何&lt;/font&gt;&lt;/font&gt; &lt;code&gt;|&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，空白或空标签，否则将无法使用&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4c8a0f32fd7f5b545c1fc32faeff3a3ddeb8716" translate="yes" xml:space="preserve">
          <source>May be we can use XML here:</source>
          <target state="translated">也许我们可以在这里使用XML。</target>
        </trans-unit>
        <trans-unit id="cc703fb9e22b2d4125214daa80ed8744a1971657" translate="yes" xml:space="preserve">
          <source>No infinite variability for you.  Only finite variability.</source>
          <target state="translated">对你来说,没有无限的变数。只有有限的可变性。</target>
        </trans-unit>
        <trans-unit id="b17bd2c4be5e9e38316d4ca5e4bba27b293c90cd" translate="yes" xml:space="preserve">
          <source>No, this is not open to &lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL injection&lt;/a&gt;. The only injected text into CommandText is not based on user input. It's solely based on the hardcoded &quot;@tag&quot; prefix, and the index of an array. The index will &lt;em&gt;always&lt;/em&gt; be an integer, is not user generated, and is safe.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不，这对&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL注入&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不开放&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;唯一注入到CommandText中的文本不是基于用户输入的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它仅基于硬编码的&amp;ldquo; @tag&amp;rdquo;前缀和数组的索引。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;索引将&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;始终&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是整数，不是用户生成的，并且是安全的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81f8d03283d9b4204147b22834f1cd053335add0" translate="yes" xml:space="preserve">
          <source>Not that cached query plans aren't valuable, but IMO this query isn't nearly complicated enough to see much benefit from it. While the compilation costs may approach (or even exceed) the execution costs, you're still talking milliseconds.</source>
          <target state="translated">并不是说缓存查询计划没有价值,但是IMO这个查询还不够复杂,还没有看到它的好处。虽然编译成本可能会接近(甚至超过)执行成本,但你说的还是毫秒。</target>
        </trans-unit>
        <trans-unit id="a039ae3772c1ef49d778f9f8c4b67934ff2c1fc3" translate="yes" xml:space="preserve">
          <source>Now that we're on a roll, we can add another &lt;code&gt;REPLACE&lt;/code&gt; handle the underscore wildcard.   And just for fun, this time, we'll use $ as the escape character.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，我们可以进行下一步了，我们可以添加另一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;REPLACE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;处理下划线通配符。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只是为了好玩，这次，我们将$作为转义字符。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01625438b5c7959ea81cd00f7a3084a534d6307d" translate="yes" xml:space="preserve">
          <source>Now we can match the literal %.  Of course, when we have a column name, we're going to need to dynamically escape the wildcard.  We can use the &lt;code&gt;REPLACE&lt;/code&gt; function to find occurrences of the &lt;code&gt;%&lt;/code&gt;character and insert a backslash character in front of each one, like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在我们可以匹配文字％。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，当我们有一个列名时，我们将需要动态转义通配符。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;REPLACE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;函数查找出现的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字符，并在每个字符前面插入反斜杠字符，如下所示：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6998781be11fbddbbca54848518598754741b9b1" translate="yes" xml:space="preserve">
          <source>Okay, so, if we don't handle that as an inline expression in the SQL, the closest alternative we have is a user defined function.  And we know that won't speed things up any (unless we can define an index on it, like we could with Oracle.)  If we've got to create a function, we might better do that in the code that calls the SQL statement.</source>
          <target state="translated">好吧,如果我们不在SQL中以内联表达式的形式处理,那么最接近的选择就是用户定义的函数。而且我们知道这并不能提高速度(除非我们能像Oracle那样定义一个索引),如果我们必须要创建一个函数,我们最好在调用SQL语句的代码中执行。</target>
        </trans-unit>
        <trans-unit id="b73b20450025066dadaf1b5da5e8b07536a277f8" translate="yes" xml:space="preserve">
          <source>Once you got this your code would be as simple as this:</source>
          <target state="translated">一旦你得到这个,你的代码就会像这样简单。</target>
        </trans-unit>
        <trans-unit id="2cd8064f013da44c7a421743d1d148268bb442b0" translate="yes" xml:space="preserve">
          <source>One approach to patching this hole is to escape the &lt;code&gt;%&lt;/code&gt; wildcard character.  (For anyone not familiar with the escape clause on the operator, here's a link to the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa933232(SQL.80).aspx&quot;&gt;SQL Server documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;修补此漏洞的一种方法是转义&lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通配符。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（对于不熟悉运算符上的转义子句的任何人，这是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa933232(SQL.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server文档&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的链接&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d785d1b371bf1e0d416a3c1cf4b58af9de8c0682" translate="yes" xml:space="preserve">
          <source>Parameterize an SQL IN clause</source>
          <target state="translated">对SQL IN子句进行参数化</target>
        </trans-unit>
        <trans-unit id="8bd73e8b6032d828eaae575e172d15ae190e9acc" translate="yes" xml:space="preserve">
          <source>Related: &lt;a href=&quot;https://www.brentozar.com/archive/2020/02/how-to-pass-a-list-of-values-into-a-stored-procedure/&quot;&gt;How to Pass a List of Values Into a Stored Procedure&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;相关：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.brentozar.com/archive/2020/02/how-to-pass-a-list-of-values-into-a-stored-procedure/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如何将值列表传递到存储过程&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7c790d520ea0368c427f57e2c38a9f1b62f724a" translate="yes" xml:space="preserve">
          <source>SQL Server also allows for wildcard characters to be treated as literals by enclosing them in brackets &lt;code&gt;[]&lt;/code&gt;.  So we're not done fixing yet, at least for SQL Server.  Since pairs of brackets have special meaning, we'll need to escape those as well.  If we manage to properly escape the brackets, then at least we won't have to bother with the hyphen &lt;code&gt;-&lt;/code&gt; and the carat &lt;code&gt;^&lt;/code&gt; within the brackets.  And we can leave any &lt;code&gt;%&lt;/code&gt;and &lt;code&gt;_&lt;/code&gt; characters inside the brackets escaped, since we'll have basically disabled the special meaning of the brackets.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server还允许通过将通配符括在方括号&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[]&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，将通配符视为文字&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，至少在SQL Server中，我们还没有完成修复。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于成对的括号具有特殊含义，因此我们也需要对它们进行转义。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果我们设法正确地逃脱了括号，那么至少我们不必打扰连字符&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以及&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;括号内的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;克拉&lt;/font&gt;&lt;/font&gt; &lt;code&gt;^&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并且我们可以保留&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;括号内的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任何&lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;_&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字符，因为我们将基本上禁用括号的特殊含义。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf5871ddbc56fc0f2c14226259e67209782850cc" translate="yes" xml:space="preserve">
          <source>SQL with dynamic parameters.</source>
          <target state="translated">SQL的动态参数。</target>
        </trans-unit>
        <trans-unit id="b34e6d11a266a89b525b0c300696a7d0682681bf" translate="yes" xml:space="preserve">
          <source>See the answer from Mark Brackett for the preferred answer that I (and 231 others) upvoted. The approach given in his answer allows 1) for effective use of bind variables, and 2) for predicates that are sargable.</source>
          <target state="translated">请看 Mark Brackett 的回答,我(和其他 231 人)推荐的答案。他的答案中给出的方法允许1)有效地使用绑定变量,2)对于可谓语的可谓语。</target>
        </trans-unit>
        <trans-unit id="178bfb059f4a1822cfbe2ec9ebe2c39718e33adf" translate="yes" xml:space="preserve">
          <source>So basically if the count is 0 then there is no filter and everything goes through.  If the count is higher than 0 the then the value must be in the list, but the list has been padded out to five with impossible values (so that the SQL still makes sense)</source>
          <target state="translated">所以基本上如果计数是0,那么就没有过滤器,一切都会通过。如果计数大于0,那么这个值必须在列表中,但列表中的值已经被填充到5个不可能的值(这样SQL仍然有意义</target>
        </trans-unit>
        <trans-unit id="30f329f8fb37cb3f59749389eca8fa0f6f4ac58d" translate="yes" xml:space="preserve">
          <source>So here's the C# code:</source>
          <target state="translated">所以这里是C#的代码。</target>
        </trans-unit>
        <trans-unit id="01e03d9a83d6e670a41622f3b700936b34789926" translate="yes" xml:space="preserve">
          <source>So that solves the problem with the % wildcard.  Almost.</source>
          <target state="translated">所以这就解决了%通配符的问题。差不多了。</target>
        </trans-unit>
        <trans-unit id="bc224aea5e1e203f177bffceb162be21609d9157" translate="yes" xml:space="preserve">
          <source>So you have the string</source>
          <target state="translated">所以,你有了这个字符串</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="ac1dd42bff5436684704cd8cecb553fb4a51748f" translate="yes" xml:space="preserve">
          <source>Sometimes the lame solution is the only one that actually works.</source>
          <target state="translated">有时,蹩脚的解决方案是唯一一个真正有效的解决方案。</target>
        </trans-unit>
        <trans-unit id="2187e96ff77893224d6a4fbd66eeac75a0523097" translate="yes" xml:space="preserve">
          <source>Stored procedure with table valued parameters. If the list can vary by a large amount use WITH RECOMPILE on the stored procedure, or simply use dynamic SQL without parameters to generate a new execution plan for each query.</source>
          <target state="translated">带表值参数的存储过程。如果列表的变化量很大,可以在存储过程上使用 WITH RECOMPILE,或者干脆使用无参数的动态SQL为每个查询生成一个新的执行计划。</target>
        </trans-unit>
        <trans-unit id="49b0933c48745bbe595589a84f3c999c1aac15aa" translate="yes" xml:space="preserve">
          <source>Syscomments. Dinakar Nethi</source>
          <target state="translated">系统评论。Dinakar Nethi</target>
        </trans-unit>
        <trans-unit id="f56c9210a9e2c9a6ed7f60b0c1718d038683158e" translate="yes" xml:space="preserve">
          <source>T-SQL:</source>
          <target state="translated">T-SQL:</target>
        </trans-unit>
        <trans-unit id="e03134a806a1e31e6209b7319743bf47eb301543" translate="yes" xml:space="preserve">
          <source>That inline expression in the SQL is getting longer and uglier.  We can probably make it work, but heaven help the poor soul that comes behind and has to decipher it.  As much of a fan I am for inline expressions, I'm inclined not use one here, mainly because I don't want to have to leave a comment explaining the reason for the mess, and apologizing for it.</source>
          <target state="translated">SQL中的那个内联表达式越来越长,越来越丑。我们也许可以让它工作,但老天爷会帮助后面的可怜的人破译它。尽管我是内联表达式的粉丝,但我倾向于不在这里使用内联表达式,主要是因为我不想在这里留下一个评论,解释一下为什么会出现这样的混乱,并为此道歉。</target>
        </trans-unit>
        <trans-unit id="0ccc088929d1deebf84e0a4fa97b04fa55774e0d" translate="yes" xml:space="preserve">
          <source>That's it. And, yes, LINQ already looks backwards enough, but the &lt;code&gt;Contains&lt;/code&gt; clause seems extra backwards to me. When I had to do a similar query for a project at work, I naturally tried to do this the wrong way by doing a join between the local array and the SQL Server table, figuring the LINQ&amp;nbsp;to&amp;nbsp;SQL translator would be smart enough to handle the translation somehow. It didn't, but it did provide an error message that was descriptive and pointed me towards using &lt;em&gt;Contains&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而已。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而且，是的，LINQ已经足够向后看，但是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Contains&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;子句对我而言似乎是额外向后的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当我必须对工作中的项目进行类似的查询时，我自然会尝试通过在本地数组和SQL Server表之间进行联接来以错误的方式执行此操作，从而弄清楚LINQ to SQL转换器将足够聪明来处理翻译莫名其妙。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它没有，但是确实提供了描述性的错误消息，并向我指出了使用&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Contains&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8ff37281903edcab5bee93dfd2354fea3795197" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/337817/5070879&quot;&gt;accepted answer&lt;/a&gt; will of course work and it is one of the way to go, but it is anti-pattern.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/337817/5070879&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;接受的答案&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然工作的意愿，这是要走的路，但它是反模式。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8eba07cdda4ea60d10a9bebc962b106ed7a8920a" translate="yes" xml:space="preserve">
          <source>The Oracle version:</source>
          <target state="translated">甲骨文的版本。</target>
        </trans-unit>
        <trans-unit id="9d1745ae6f89bcb6009c23298fa1e007d88d88a9" translate="yes" xml:space="preserve">
          <source>The behavior we observe is kind of odd.  Changing the order of the search terms in the list changes the result set.</source>
          <target state="translated">我们观察到的行为有点奇怪。改变列表中搜索词的顺序会改变结果集。</target>
        </trans-unit>
        <trans-unit id="5476b01df6c35abd19c57b5f47c1bc4611a97014" translate="yes" xml:space="preserve">
          <source>The general pattern is easy to extend and can be used for passing more complex tables.</source>
          <target state="translated">一般的模式很容易扩展,可以用来传递比较复杂的表格。</target>
        </trans-unit>
        <trans-unit id="fa033af9de3767d4d1bb2976f14c8950c3e8c353" translate="yes" xml:space="preserve">
          <source>The only winning move is not to play.</source>
          <target state="translated">唯一的制胜法宝就是不玩了。</target>
        </trans-unit>
        <trans-unit id="b9583a9b4dce8989dd711d081c33d9ffd91c7a42" translate="yes" xml:space="preserve">
          <source>The original question was &lt;strong&gt;&quot;How do I parameterize a query ...&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最初的问题是&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;如何参数化查询...&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="66954bd1bf64a819018f1c94116a783f1d835163" translate="yes" xml:space="preserve">
          <source>The performance is terrible. &lt;code&gt;LIKE &quot;%...%&quot;&lt;/code&gt; queries are not indexed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表现很糟糕。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;LIKE &quot;%...%&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;查询未编制索引。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c595b1a23d029415bc9530e69c56a7bf52a907e6" translate="yes" xml:space="preserve">
          <source>The proper way IMHO is to store the list in a character string (limited in length by what the DBMS support); the only trick is that (in order to simplify processing) I have a separator (a comma in my example) at the beginning and at the end of the string. The idea is to &quot;normalize on the fly&quot;, turning the list into a one-column table that contains one row per value. This allows you to turn</source>
          <target state="translated">IMHO的正确方法是将列表存储在一个字符串中(长度受DBMS支持的长度限制);唯一的技巧是(为了简化处理),我在字符串的开头和结尾处用了一个分隔符(在我的例子中用逗号)。这样做的目的是 &quot;即时归一化&quot;,将列表变成一个单列表,每个值只包含一行。这样,你就可以把</target>
        </trans-unit>
        <trans-unit id="080963f0ce43b16a038ca3c1cafb8009937c4fa2" translate="yes" xml:space="preserve">
          <source>The reuse of execution plans for stored procedures or parameterized queries may give you a performance gain, but it will lock you in to one execution plan determined by the first query that is executed. That may be less than ideal for subsequent queries in many cases. In your case, reuse of execution plans will probably be a plus, but it might not make any difference at all as the example is a really simple query.</source>
          <target state="translated">重用存储过程或参数化查询的执行计划,可能会给你带来性能上的提升,但它会把你锁定在由第一次执行的查询决定的一个执行计划上。在许多情况下,这对于后续的查询可能不是很理想。在你的情况下,重用执行计划可能是一个加分项,但由于这个例子是一个非常简单的查询,所以可能不会有任何区别。</target>
        </trans-unit>
        <trans-unit id="a8eb233e5b6e8d0a30d47b4e1de065627dccaad7" translate="yes" xml:space="preserve">
          <source>The string can be built in any language. In this example I used SQL since that was the original problem I was trying to solve. I needed a clean way to pass in table data on the fly in a string to be executed later.</source>
          <target state="translated">这个字符串可以用任何语言建立。在这个例子中,我使用了SQL,因为这是我最初想解决的问题。我需要一个干净的方法来传递表数据,在一个字符串中飞快地传入表数据,然后再执行。</target>
        </trans-unit>
        <trans-unit id="2a379f85b2c923f924ec4c11add17ee12c66803a" translate="yes" xml:space="preserve">
          <source>The user inputted values are still stuffed into parameters, so there is no vulnerability there.</source>
          <target state="translated">用户输入的值仍然被塞进了参数中,所以那里没有漏洞。</target>
        </trans-unit>
        <trans-unit id="46a9f25a51ce70904d83b4d2fdcce6438b367f5c" translate="yes" xml:space="preserve">
          <source>The values stored in the column may allow for % or _ characters, but a constraint may require those values to be escaped, perhaps using a defined character, such that the values are LIKE comparison &quot;safe&quot;.  Again, a quick comment about the allowed set of values, and in particular which character is used as an escape character, and go with Joel Spolsky's approach.</source>
          <target state="translated">存储在列中的值可能允许使用%或_字符,但约束条件可能要求这些值被转义,或许使用一个定义的字符,这样的值是LIKE比较 &quot;安全 &quot;的。还是那句话,关于允许的值集,特别是使用哪个字符作为转义字符,还是要跟Joel Spolsky的方法走。</target>
        </trans-unit>
        <trans-unit id="432f039b6ee44f960eebe9edc61390d464e6ea6f" translate="yes" xml:space="preserve">
          <source>Then all you have to do is pass the string as 1 parameter.</source>
          <target state="translated">那么你所要做的就是把字符串作为1个参数来传递。</target>
        </trans-unit>
        <trans-unit id="caabdeeafa5990eb317cda420543a417692b60d4" translate="yes" xml:space="preserve">
          <source>Then, your ADO.NET code looks like this:</source>
          <target state="translated">然后,你的ADO.NET代码看起来像这样。</target>
        </trans-unit>
        <trans-unit id="92d757149ae4a77513eaebec2ba6645d7436a4bb" translate="yes" xml:space="preserve">
          <source>There are other ways to accomplish this that some people may consider cleaner, so please keep reading.</source>
          <target state="translated">还有其他的方法,有的人可能认为比较干净,请继续阅读。</target>
        </trans-unit>
        <trans-unit id="4ce52d75168ac74d2698141558de7e48bb776b1d" translate="yes" xml:space="preserve">
          <source>This approach is blogged about in &lt;a href=&quot;http://blogs.msdn.com/b/sqlserverstorageengine/archive/2015/11/03/openjson-one-of-best-ways-to-select-rows-by-list-of-id.aspx&quot;&gt;OPENJSON - one of best ways to select rows by list of ids&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这种方法是在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.msdn.com/b/sqlserverstorageengine/archive/2015/11/03/openjson-one-of-best-ways-to-select-rows-by-list-of-id.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;OPENJSON&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;发布的，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过ID列表选择行的最佳方法之一&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="958feb18dbf8f4056efe483472623f67177a7660" translate="yes" xml:space="preserve">
          <source>This can be done with a recursive CTE, or a query with a number table (or Master..spt_value)</source>
          <target state="translated">这可以用递归CTE来完成,也可以用数字表(或Master...spt_value)的查询来完成。</target>
        </trans-unit>
        <trans-unit id="08e5e9a6033c33675e7649a6d1cc1cacfea07f45" translate="yes" xml:space="preserve">
          <source>This has a bit of added flexibility in what you can do, but it's more suited for situations where you have a large table to query, with good indexing, and you want to use the parametrized list more than once. Saves having to execute it twice and have all the sanitation done manually.</source>
          <target state="translated">这在你能做的事情上增加了一点灵活性,但它更适合于你有一个大表要查询的情况,有很好的索引,而且你想多次使用参数化的列表。省去了两次执行,并手动完成所有的卫生处理。</target>
        </trans-unit>
        <trans-unit id="89a375a792ce41774bf8ba73cfe56ee977890de5" translate="yes" xml:space="preserve">
          <source>This is gross, but if you are guaranteed to have at least one, you could do:</source>
          <target state="translated">这很恶心,但如果保证你至少有一个,你可以。</target>
        </trans-unit>
        <trans-unit id="e29e488795dec60c287f82fd01f7fc119e047f6e" translate="yes" xml:space="preserve">
          <source>This is possibly a half nasty way of doing it, I used it once, was rather effective.</source>
          <target state="translated">这可能是一个半下流的方法,我用过一次,是相当有效的。</target>
        </trans-unit>
        <trans-unit id="923766af9d49d6ee8ab01954e13903dc14406c7f" translate="yes" xml:space="preserve">
          <source>This is replacement for common anti-pattern such as creating a dynamic SQL string in application layer or Transact-SQL, or by using LIKE operator:</source>
          <target state="translated">这是在应用层或Transact-SQL中创建一个动态的SQL字符串,或使用LIKE操作符来替代常见的反模式。</target>
        </trans-unit>
        <trans-unit id="5222b471ee3028d31cfe5f8af34e316502210ba5" translate="yes" xml:space="preserve">
          <source>To improve the &lt;code&gt;STRING_SPLIT&lt;/code&gt; table function row estimation, it is a good idea to materialize splitted values as temporary table/table variable:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了改善&lt;/font&gt;&lt;/font&gt; &lt;code&gt;STRING_SPLIT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表函数的行估计，将分割值具体化为临时表/表变量是一个好主意：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2222e8c9448d0d44594f587bbcbc82c4ad1019e9" translate="yes" xml:space="preserve">
          <source>Two caveats:</source>
          <target state="translated">两件事情要注意:</target>
        </trans-unit>
        <trans-unit id="5440af73b429739161f6ba1b784dfd0beaa7c95f" translate="yes" xml:space="preserve">
          <source>Unfortunately, the techniques to slice a string are fairly product-specific.
Here is the SQL Server version:</source>
          <target state="translated">遗憾的是,切割字符串的技术是针对特定产品的。下面是SQL Server的版本。</target>
        </trans-unit>
        <trans-unit id="8fdf7787fac70523813d9ee461dc51c98f04f4ec" translate="yes" xml:space="preserve">
          <source>Unless you have a ridiculously long string, this should work well with the table index.</source>
          <target state="translated">除非你有一个非常长的字符串,否则这应该可以很好地配合表索引。</target>
        </trans-unit>
        <trans-unit id="2443ed13c972cd5cc6bdc47153849869b4ac0910" translate="yes" xml:space="preserve">
          <source>Use the following stored procedure. It uses a custom split function, which can be found &lt;a href=&quot;http://blogs.microsoft.co.il/blogs/itai/archive/2009/02/01/t-sql-split-function.aspx&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用以下存储过程。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它使用自定义拆分功能，可在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.microsoft.co.il/blogs/itai/archive/2009/02/01/t-sql-split-function.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此处&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;找到&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="fc4db109b0b74a21e7b65fe2cccd3e5e113eabea" translate="yes" xml:space="preserve">
          <source>Using a user defined type is optional. Creating the type is only created once and can be done ahead of time. Otherwise just add a full table type to the declaration in the string.</source>
          <target state="translated">使用用户定义的类型是可选的。创建类型只需创建一次,可以提前完成。否则只需在字符串中的声明中添加一个完整的表类型。</target>
        </trans-unit>
        <trans-unit id="ea109569ae92ebf585a2849dd893eef36a9892b4" translate="yes" xml:space="preserve">
          <source>We have function that creates a table variable that you can join to:</source>
          <target state="translated">我们有一个函数,可以创建一个表变量,你可以加入到其中。</target>
        </trans-unit>
        <trans-unit id="360d577f191fc4129da8ba5e7e42f6459f455eea" translate="yes" xml:space="preserve">
          <source>We may have specialized knowledge of the domain for the column, (that is, the set of allowable values enforced for the column.  We may know &lt;em&gt;a priori&lt;/em&gt; that the values stored in the column will never contain a percent sign, an underscore, or bracket pairs.  In that case, we just include a quick comment that those cases are covered.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们可能对列的域有专门的知识（即，为列强制执行的一组允许值。我们可能会&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;先验地&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;知道&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，存储在列中的值将永远不会包含百分号，下划线或方括号在这种情况下，我们只需要简要说明一下这些案例即可。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1eb0105114c419b879dc13efdb354bd9c4fdc800" translate="yes" xml:space="preserve">
          <source>We recognize that our solution has introduced another problem.  The escape character.  We see that we're also going to need to escape any occurrences of escape character itself.  This time, we use the ! as the escape character:</source>
          <target state="translated">我们认识到,我们的解决方案引入了另一个问题。即转义字符。我们看到,我们还需要转义字符本身的任何转义字符的出现。这一次,我们用 ! 作为转义字符。</target>
        </trans-unit>
        <trans-unit id="a7e764b14c40a72de7506566f1043d46bb0179bf" translate="yes" xml:space="preserve">
          <source>What I want to address here is the approach given in Joel Spolsky's answer, the answer &quot;selected&quot; as the right answer.</source>
          <target state="translated">这里我想说的是乔尔-斯波尔斯基在回答中给出的方法,即把 &quot;选择 &quot;作为正确答案。</target>
        </trans-unit>
        <trans-unit id="6450bd884edaaafc8f2c30b098dfab9b71545cba" translate="yes" xml:space="preserve">
          <source>Which will give you:</source>
          <target state="translated">哪一个会给你。</target>
        </trans-unit>
        <trans-unit id="c20d641e26d4310fe7f10673ba7c0d0a8a4f2ea5" translate="yes" xml:space="preserve">
          <source>Which you could use like this,</source>
          <target state="translated">你可以用这样的方法</target>
        </trans-unit>
        <trans-unit id="a1c640d00154452803b29c203f1d50877797b971" translate="yes" xml:space="preserve">
          <source>With that said, go ahead and flag this answer, downvote it, mark it as not an answer... do whatever you believe is right.</source>
          <target state="translated">说了这么多,你就去把这个答案打上标记,把它标记为不是答案........做你认为正确的事情。</target>
        </trans-unit>
        <trans-unit id="d453d5e94a94b047c31fc338808abef090d3c920" translate="yes" xml:space="preserve">
          <source>Yes, I've gone far afield from the original question.  But where else to leave this note concerning what I consider to be an important issue with the &quot;selected&quot; answer for a question?</source>
          <target state="translated">是的,我已经偏离了最初的问题。但是,关于我认为 &quot;选择 &quot;问题的 &quot;选择 &quot;答案的重要问题,还能在哪里留下这句话呢?</target>
        </trans-unit>
        <trans-unit id="c6194e2b66441e85c192f849cd73f13ef5f725d2" translate="yes" xml:space="preserve">
          <source>You can parameterize &lt;em&gt;each&lt;/em&gt; value, so something like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以参数化&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每个&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值，例如：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="540ae451a6a2159c5ecb0af841f18229951bd533" translate="yes" xml:space="preserve">
          <source>You can pass the parameter as a string</source>
          <target state="translated">你可以将参数作为一个字符串传递给</target>
        </trans-unit>
        <trans-unit id="02d42af71a7eac7a8292d95356882939546d4a05" translate="yes" xml:space="preserve">
          <source>You can use the above statement in your .NET code and map the parameter with SqlParameter.</source>
          <target state="translated">你可以在.NET代码中使用上面的语句,用SqlParameter映射参数。</target>
        </trans-unit>
        <trans-unit id="87437dc5ed8516a409cda3c960e12ffdcacc4b99" translate="yes" xml:space="preserve">
          <source>You really only need a way to convert the string into a table.</source>
          <target state="translated">你真的只需要一个将字符串转换为表格的方法。</target>
        </trans-unit>
        <trans-unit id="97e786164e7d144a82e75203dad2c623c0c11c82" translate="yes" xml:space="preserve">
          <source>and the MySQL version:</source>
          <target state="translated">和MySQL版本。</target>
        </trans-unit>
        <trans-unit id="3df8dd48aae8c0e7b8d71dd615f0f99c126b5e95" translate="yes" xml:space="preserve">
          <source>in (ct1,ct2, ct3 ... ctn)</source>
          <target state="translated">在(ct1,ct2,ct3 ....ctn)</target>
        </trans-unit>
        <trans-unit id="ce276f235956637e004c786d0c39a7ea5a549d44" translate="yes" xml:space="preserve">
          <source>in (select ...)</source>
          <target state="translated">在(选择...)</target>
        </trans-unit>
        <trans-unit id="edb6b110bc010a020fc6176e807d09190584bb53" translate="yes" xml:space="preserve">
          <source>into an</source>
          <target state="translated">变成</target>
        </trans-unit>
        <trans-unit id="5bc416d9e2f5537e6bed7be9378837b7a0d5e3d1" translate="yes" xml:space="preserve">
          <source>optimizer plan using index scan rather than index seeks, possible need for an expression or function for escaping wildcards (possible index on expression or function)</source>
          <target state="translated">优化器计划使用索引扫描而不是索引寻求,可能需要一个表达式或函数来转义通配符(表达式或函数上可能的索引</target>
        </trans-unit>
        <trans-unit id="0b307b480fb16b98df07abaaae5ec29863540be3" translate="yes" xml:space="preserve">
          <source>or (the solution I'd probably prefer) a regular join, if you just add a &quot;distinct&quot; to avoid problems with duplicate values in the list.</source>
          <target state="translated">或(我可能更喜欢的解决方案),如果你只是在列表中添加一个 &quot;单独的&quot;,以避免列表中的重复值问题。</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="cc20f4add2f0b69a52b77cefaa7e7f09d88dca49" translate="yes" xml:space="preserve">
          <source>using literal values in place of bind variables impacts scalability</source>
          <target state="translated">使用字面值代替绑定变量影响可扩展性</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
