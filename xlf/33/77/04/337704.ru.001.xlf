<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/337704">
    <body>
      <group id="337704">
        <trans-unit id="48f19cdab83f69f332c2f5fcb40c9ec7eaf89ca1" translate="yes" xml:space="preserve">
          <source>(Of course, &quot;pivot&quot; must return as many rows as the maximum number of
items we can find in the list)</source>
          <target state="translated">(Конечно,&quot;поворот&quot; должен возвращать столько строк,сколько максимальное количество элементов,которые мы можем найти в списке)</target>
        </trans-unit>
        <trans-unit id="dee8436afe3eef1c33541c551908ae7951d32018" translate="yes" xml:space="preserve">
          <source>(Yes, I will agree that this is an obscure case.  Probably one that is not likely to be tested.  We wouldn't expect a wildcard in a column value.  We may assume that the application prevents such a value from being stored.  But in my experience, I've rarely seen a database constraint that specifically disallowed characters or patterns that would be considered wildcards on the right side of a &lt;code&gt;LIKE&lt;/code&gt; comparison operator.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Да, я согласен, что это неясный случай. Вероятно, тот, который вряд ли будет проверен. Мы не ожидаем подстановочного знака в значении столбца. Мы можем предположить, что приложение предотвращает сохранение такого значения. Но по моему опыту, я редко видел ограничение базы данных, которое специально запрещало символы или шаблоны, которые считались бы подстановочными знаками справа от &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;оператора сравнения &lt;/font&gt;&lt;/font&gt; &lt;code&gt;LIKE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d9796c38c06486ee44725f02212200e0e19ef822" translate="yes" xml:space="preserve">
          <source>(new version posted on 6/4/13).</source>
          <target state="translated">(новая версия размещена на 6413).</target>
        </trans-unit>
        <trans-unit id="78bf7b6b27c8792a1b6240a992597a2169e13c12" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL injection&lt;/a&gt; (taking what would appear to be user supplied information, and including that in the SQL text rather than supplying them through bind variables.  Using bind variables isn't required, it's just one convenient approach to thwart with SQL injection.  There are other ways to deal with it:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Внедрение SQL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (взятие того, что представляется информацией, предоставленной пользователем, и включение ее в текст SQL, а не предоставление их через переменные связывания. Использование переменных связывания не требуется, это всего лишь один удобный способ помешать внедрению SQL. Есть и другие способы борьбы с этим:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a6e53cd33415c69a4bdf01a31b33c9cdd34fccfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INSERT&lt;/code&gt; each look-up value into that column.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; каждое значение поиска в этот столбец.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac17bef807ba02b72de1e63fe25d0cf263de4816" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Addendum&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Addendum&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="cac28b87690e0244dc4499e21d80ce7f137a57b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/1196908?opt.withExecutionPlan=true#executionPlan&quot;&gt;SEDE - Live Demo&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/1196908?opt.withExecutionPlan=true#executionPlan&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SEDE - Live Demo&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8282433139e0a1e1ac6d41141b59ccceb433f13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/481811&quot;&gt;LiveDemo&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/481811&quot;&gt;LiveDemo&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d7cc78633528ed1105f6ee787b57caf8b5aca4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A function where ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Функция где?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce6064f3be2a2c0c2b244a4e5aa061cd081bde6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CREDITS FOR: Dinakar Nethi&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;КРЕДИТЫ ДЛЯ: Динакар Нети&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a8e521f362bc99965c4c0a3defa878eb3c31799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cliffs notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Примечания скал:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8115e639335d833240663506049d0442b68dbba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusion&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4dbfdda273078557fedd54082b0a22e178bc8cdf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DDL Script:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Сценарий DDL:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a555be6a06e633fb60d1ff7483e33da5b5ada3a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Domain knowledge&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Базовые знания&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="252a44c26d52bbbdee3f05ef052068c571e8e15c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E. Find rows by list of values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;E. найти строки по списку значений&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67d3195b93a234f68cebcb65f2e721c5d575f4bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;
Create the table called SelectedTags using the following script.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;РЕДАКТИРОВАТЬ:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Создайте таблицу с именем SelectedTags, используя следующий скрипт.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67c8cacdeb62d71990d850b41caea868fe7455b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Escape the escape&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Избежать побега&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f05f137eb1a56908403bfbf2320629bc58403b99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inline expression gets messy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Встроенное выражение становится грязным&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="600e0ea4701a71484fccb509e0fd2655945c518e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Obscure corner case&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мрачный угловой чехол&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b63eb5ee1a8de97b89ae2ad28cf585e5487ee5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Other issues recapitulated&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другие вопросы перепросмотрены&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80bf15d2aa8f62da4288c48a4b4967714fe0679e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Patching a hole&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ямочный ремонт&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0b37171896c661e0a5bb56c2f1e263143165f10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Queries with large lists:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Запросы с большими списками:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="38950a26e45ab68986a78cabd9db01f0fec39a5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Queries with reusable execution plans, called multiple times by simply changing the parameters or if the query is complicated:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Запросы с повторно используемыми планами выполнения, вызываемые несколько раз простым изменением параметров или сложным запросом:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82001c1ced780a951a7c6f3798a7838f8bd5de2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Selected answer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Выбранный ответ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23461227354b053ccf166a361a0b790e10fba24a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Some problems with % character&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Некоторые проблемы с характером%&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9441af39c3c3128da7ddf830bf1d1d5d69405d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;T-SQL:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;T-SQL:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a0dc348f82c1d40f9d8a3a84a3bb9786ff40a7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The underscore too&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Подчеркивание тоже&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f62f9cd4d15d0b544b7ee98f587e4a539f1b27d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Those pesky brackets&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эти надоедливые скобки&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7822cac6cb84dcb1f769dc18ac0d5e0e14b57cf2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Your case/simple queries with few parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ваш случай / простые запросы с несколькими параметрами:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="554b441ed3b70f63af83d232d29f2422b76a4a30" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Original question has requirement &lt;code&gt;SQL Server 2008&lt;/code&gt;. Because this question is often used as duplicate, I've added this answer as reference. &lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Оригинальный вопрос имеет требование &lt;/font&gt;&lt;/font&gt; &lt;code&gt;SQL Server 2008&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку этот вопрос часто используется как дубликат, я добавил этот ответ в качестве ссылки.&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ef5c31c764d5981c9a8f620d4a86708fe1cafd16" translate="yes" xml:space="preserve">
          <source>A full worked example below</source>
          <target state="translated">Полный отработанный пример ниже</target>
        </trans-unit>
        <trans-unit id="0ea255bf74e697155208b49c499a61c81d0083e5" translate="yes" xml:space="preserve">
          <source>Also, SQL&amp;nbsp;Server 7 and later will &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa175264(SQL.80).aspx&quot;&gt;auto-parameterize queries&lt;/a&gt;, so using parameters isn't really necessary from a performance standpoint - it is, however, &lt;em&gt;critical&lt;/em&gt; from a security standpoint - especially with user inputted data like this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, SQL Server 7 и более поздние &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa175264(SQL.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;версии&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будут &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;автоматически параметризировать запросы&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , поэтому использование параметров на самом деле не является необходимым с точки зрения производительности - однако, это &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;критично&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с точки зрения безопасности - особенно с такими данными, которые вводятся пользователем.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cb65fbb9fdbacb8813819ce6fe844531bf67c562" translate="yes" xml:space="preserve">
          <source>And that function may have some differences in behavior, dependent on the DBMS and version.  (A shout out to all you Java developers so keen on being able to use any database engine interchangeably.)</source>
          <target state="translated">И эта функция может иметь некоторые различия в поведении,зависящие от СУБД и версии.(Крик всем вам,разработчикам Java,так хочется иметь возможность взаимозаменяемого использования любого движка СУБД).</target>
        </trans-unit>
        <trans-unit id="e7647df632ba6a5ad2e75cfdb6f974350f2e7424" translate="yes" xml:space="preserve">
          <source>And the function:</source>
          <target state="translated">И функция:</target>
        </trans-unit>
        <trans-unit id="cccf532bbfa1429eb9f3289f7400d714e8a760fa" translate="yes" xml:space="preserve">
          <source>Another possible solution is instead of passing a variable number of arguments to a stored procedure, pass a single string containing the names you're after, but make them unique by surrounding them with '&amp;lt;&amp;gt;'. Then use PATINDEX to find the names:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другое возможное решение - вместо передачи переменного числа аргументов хранимой процедуре, передать одну строку с именами, которые вы ищете, но сделайте их уникальными, заключив их в '&amp;lt;&amp;gt;'. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Затем используйте PATINDEX, чтобы найти имена:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03d0b83415d956ac04c59f569a6227895ab74272" translate="yes" xml:space="preserve">
          <source>Anyway, if you run this in the highly recommended &lt;a href=&quot;http://www.linqpad.net/&quot;&gt;LINQPad&lt;/a&gt;, and run this query, you can view the actual SQL that the SQL LINQ provider generated. It'll show you each of the values getting parameterized into an &lt;code&gt;IN&lt;/code&gt; clause.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В любом случае, если вы запустите это в настоятельно рекомендуемом &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.linqpad.net/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LINQPad&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и выполните этот запрос, вы сможете просмотреть фактический SQL, созданный поставщиком SQL LINQ. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он покажет вам каждое из значений, параметризованных в предложении &lt;/font&gt;&lt;/font&gt; &lt;code&gt;IN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="23b01d595f6060073511290535fff818b9114f31" translate="yes" xml:space="preserve">
          <source>But as soon as I saw it, I immediately saw a potential problem with it, and it's not my nature to let it slide.  I don't mean to be critical of the efforts of others.  I know many developers take their work very personally, because they invest so much into it and they care so much about it.  So please understand, this is not a personal attack.  What I'm identifying here is the type of problem that crops up in production rather than testing.</source>
          <target state="translated">Но как только я увидел его,я сразу же увидел потенциальную проблему,и не в моей природе позволять ему скользить.Я не хочу критиковать усилия других.Я знаю,что многие разработчики воспринимают свою работу очень близко к сердцу,потому что они так много в нее вкладывают и так заботятся о ней.Так что,пожалуйста,поймите,это не личная атака.То,что я идентифицирую здесь,это тип проблемы,которая возникает в производстве,а не в тестировании.</target>
        </trans-unit>
        <trans-unit id="1f6dc5172459fe319cfcc98bb14b0e0d6d765a74" translate="yes" xml:space="preserve">
          <source>But in terms generalizing this approach, let's also consider the more obscure corner cases, like when the &lt;code&gt;Name&lt;/code&gt; column contains a wildcard character (as recognized by the LIKE predicate.)  The wildcard character I see most commonly used is &lt;code&gt;%&lt;/code&gt; (a percent sign.). So let's deal with that here now, and later go on to other cases.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но в терминах, обобщающих этот подход, давайте также рассмотрим более неясные угловые случаи, например, когда &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;столбец &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; содержит подстановочный знак (как распознается предикатом LIKE.) Подстановочный знак, который я вижу наиболее часто используемым, - это &lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (знак процента). , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Итак, давайте разберемся с этим здесь и сейчас, а позже перейдем к другим случаям.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef0d5d39e697ffe1ba99b0761754afc9c4f40372" translate="yes" xml:space="preserve">
          <source>But that same row will &lt;strong&gt;not&lt;/strong&gt; be returned if the order of the search terms is reversed:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но эта же строка &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет возвращена, если порядок поисковых терминов обратный:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ad02e2300cc6443c140b0ea75769de719b9a2f50" translate="yes" xml:space="preserve">
          <source>But, absent the specialized knowledge and a guarantee, it's important for us to at least consider handling those obscure corner cases, and consider whether the behavior is reasonable and &quot;per the specification&quot;.</source>
          <target state="translated">Но,в отсутствие специализированных знаний и гарантии,для нас важно,по крайней мере,подумать о том,чтобы разобраться в этих непонятных угловых случаях,а также подумать о том,является ли поведение разумным и &quot;согласно спецификации&quot;.</target>
        </trans-unit>
        <trans-unit id="f8eb3248811492e79afeba88e2112b19fd5e3085" translate="yes" xml:space="preserve">
          <source>Cheers.</source>
          <target state="translated">Cheers.</target>
        </trans-unit>
        <trans-unit id="bfee5586db97ea7e6e02b3fe7c5e0b9a70a81809" translate="yes" xml:space="preserve">
          <source>Consider a Name value of &lt;code&gt;'pe%ter'&lt;/code&gt;.  (For the examples here, I use a literal string value in place of the column name.)  A row with a Name value of `'pe%ter' would be returned by a query of the form:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Рассмотрим значение имени &lt;/font&gt;&lt;/font&gt; &lt;code&gt;'pe%ter'&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Для примеров здесь я использую буквальное строковое значение вместо имени столбца.) Строка со значением Name `pe% ter 'будет возвращена запросом формы:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d017cf77fe2c73ed635d1a483b157ec724242736" translate="yes" xml:space="preserve">
          <source>Create a &lt;em&gt;temp table&lt;/em&gt; with one column.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Создайте &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;временную таблицу&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с одним столбцом.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8136fc8a2e6515b930f0753b1f85b9ddce86d5f8" translate="yes" xml:space="preserve">
          <source>DDL Script:</source>
          <target state="translated">Сценарий DDL:</target>
        </trans-unit>
        <trans-unit id="02a4f4b6de45d5c7489decc7ab589a9afa2cb60e" translate="yes" xml:space="preserve">
          <source>Depending on your goals it might be of use.</source>
          <target state="translated">В зависимости от ваших целей,он может быть полезен.</target>
        </trans-unit>
        <trans-unit id="b2d970495b8509db54eabd95430be025d9b303c2" translate="yes" xml:space="preserve">
          <source>Dynamic SQL, maybe with parameters if testing shows better performance.</source>
          <target state="translated">Динамический SQL,возможно,с параметрами,если тестирование показывает лучшую производительность.</target>
        </trans-unit>
        <trans-unit id="2c79c2f8fe6cef139b77391f6699a0512a187188" translate="yes" xml:space="preserve">
          <source>Edit:</source>
          <target state="translated">Edit:</target>
        </trans-unit>
        <trans-unit id="9b4f7c19764919f3700623d10af2eaf2e9fd3645" translate="yes" xml:space="preserve">
          <source>Fiddler demo</source>
          <target state="translated">Демонстрация скрипача</target>
        </trans-unit>
        <trans-unit id="026dacaafe85baaf736570c8698095c25f19b7af" translate="yes" xml:space="preserve">
          <source>Finding matching pairs of brackets shouldn't be that hard.  It's a little more difficult than handling the occurrences of singleton % and _.  (Note that it's not sufficient to just escape all occurrences of brackets, because a singleton bracket is considered to be a literal, and doesn't need to be escaped. The logic is getting a little fuzzier than I can handle without running more test cases.)</source>
          <target state="translated">Найти подходящие пары кронштейнов не должно быть так уж сложно.Это немного сложнее,чем обрабатывать вхождения однокнопочных % и _.(Заметим,что простого выхода из всех вхождений скобок недостаточно,так как однокнопочная скобка считается буквальной и не нуждается в выходе.Логика становится немного нечетче,чем я могу справиться,не запустив больше тестовых случаев).</target>
        </trans-unit>
        <trans-unit id="956bf832223f45c34ec12226533b916e6709dbb5" translate="yes" xml:space="preserve">
          <source>First, you have to create a type</source>
          <target state="translated">Сначала нужно создать тип</target>
        </trans-unit>
        <trans-unit id="d676f66cb4ad07fb96444f3511cde73425052bf9" translate="yes" xml:space="preserve">
          <source>For SQL Server 2008, you can use a &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb675163.aspx&quot;&gt;table valued parameter&lt;/a&gt;. It's a bit of work, but it is arguably cleaner than &lt;a href=&quot;https://stackoverflow.com/questions/337704/parameterizing-a-sql-in-clause#337792&quot;&gt;my other method&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для SQL Server 2008 вы можете использовать &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb675163.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;табличный параметр&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это немного работы, но это, возможно, чище, чем &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/337704/parameterizing-a-sql-in-clause#337792&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;мой другой метод&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="227f0d29bb06ad813fae5f94026e2af979d5e192" translate="yes" xml:space="preserve">
          <source>For a variable number of arguments like this the only way I'm aware of is to either generate the SQL explicitly or do something that involves populating a temporary table with the items you want and joining against the temp table.</source>
          <target state="translated">Для переменного количества аргументов,подобных этому,единственный способ,о котором я знаю,это либо явно сгенерировать SQL,либо сделать что-то,что включает в себя заполнение временной таблицы с нужными вам элементами и присоединение к таблице temp.</target>
        </trans-unit>
        <trans-unit id="fe75486630ba5a7fcd537b56d8939d238184983f" translate="yes" xml:space="preserve">
          <source>For your case anything you do, be it parameterization with a fixed number of items in the list (null if not used), dynamically building the query with or without parameters, or using stored procedures with table valued parameters will not make much of a difference. However, my general recommendations are as follows:</source>
          <target state="translated">В вашем случае все,что вы делаете,будь то параметризация с фиксированным количеством элементов в списке (null,если не используется),динамическое построение запроса с параметрами или без параметров,или использование хранимых процедур с параметрами,оцениваемыми по таблице,не будет иметь большого значения.Однако мои общие рекомендации следующие:</target>
        </trans-unit>
        <trans-unit id="c849be4c99e78b71f4be145f175e981782cb4a3d" translate="yes" xml:space="preserve">
          <source>Having IN( 'tag1', 'tag2', 'tag1', 'tag1', 'tag1' ) will be easily optimized away by SQL Server. Plus, you get direct index seeks</source>
          <target state="translated">Наличие IN('tag1','tag2','tag1','tag1','tag1')будет легко оптимизировано сервером SQL.Кроме того,вы получаете прямой поиск индексов</target>
        </trans-unit>
        <trans-unit id="0883a1359a7ef9fb3528dc28cd0c0ad2edfa8b13" translate="yes" xml:space="preserve">
          <source>Here Dapper does the thinking, so you don't have to. Something similar is possible with &lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;LINQ&amp;nbsp;to&amp;nbsp;SQL&lt;/a&gt;, of course:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Здесь Даппер думает, так что тебе не нужно. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Нечто подобное возможно с &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LINQ to SQL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , конечно:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec20b27947e409494d8b39aff65011bcad68b37c" translate="yes" xml:space="preserve">
          <source>Here is another alternative. Just pass a comma-delimited list as a string parameter to the stored procedure and:</source>
          <target state="translated">Вот еще одна альтернатива.Просто передайте разделенный запятыми список в качестве строкового параметра хранимой процедуре и:</target>
        </trans-unit>
        <trans-unit id="3bef9b813806d919c0ef17520cdcae6d63be6a13" translate="yes" xml:space="preserve">
          <source>Here is another answer to this problem.</source>
          <target state="translated">Вот еще один ответ на эту проблему.</target>
        </trans-unit>
        <trans-unit id="8058dd0239d0ce0f235c473fee26724245a2479d" translate="yes" xml:space="preserve">
          <source>Here is the code for the UDF &lt;em&gt;(I got it from Stack Overflow somewhere, i can't find the source right now)&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот код для UDF &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(я получил его где-то от переполнения стека, я не могу найти источник прямо сейчас)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d9c357ac321a2c270d39faa0087485f24d73d7b" translate="yes" xml:space="preserve">
          <source>Here is the split function I use.</source>
          <target state="translated">Вот функция разделения,которую я использую.</target>
        </trans-unit>
        <trans-unit id="31b408cd5989d3b3a9e85be52bf44f860e81198e" translate="yes" xml:space="preserve">
          <source>Here's a quick-and-dirty technique I have used:</source>
          <target state="translated">Вот быстрая и грязная техника,которую я использовал:</target>
        </trans-unit>
        <trans-unit id="450492771c56d95cbcd05fb281ef0131265e08c9" translate="yes" xml:space="preserve">
          <source>Here's a technique that recreates a local table to be used in a query string. Doing it this way eliminates all parsing problems.</source>
          <target state="translated">Вот техника,которая воссоздает локальную таблицу для использования в строке запроса.Выполнение этого способа устраняет все проблемы с синтаксическим анализом.</target>
        </trans-unit>
        <trans-unit id="e6ad03598d810f4f2eebf49dfe172e701f6b4e08" translate="yes" xml:space="preserve">
          <source>Here's the CTE version.</source>
          <target state="translated">Вот версия CTE.</target>
        </trans-unit>
        <trans-unit id="bc4f98564ef32ef0f8fb6179097d52a7744bb920" translate="yes" xml:space="preserve">
          <source>How do I parameterize a query containing an &lt;code&gt;IN&lt;/code&gt; clause with a variable number of arguments, like this one?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как я могу параметризовать запрос, содержащий предложение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;IN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с переменным числом аргументов, как этот?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bb54217d9c4d37d19fb2185c0c208e0cb24405d" translate="yes" xml:space="preserve">
          <source>I believe others have already sufficiently pointed out some of the other commonly considered areas of concern:</source>
          <target state="translated">Я считаю,что другие уже достаточно четко обозначили некоторые из других вопросов,вызывающих всеобщую озабоченность:</target>
        </trans-unit>
        <trans-unit id="e7734598a6d1c2cfa95be739746a7afb394b36a1" translate="yes" xml:space="preserve">
          <source>I have also seen stored procedures that had 500 parameters with default values of null, and having WHERE Column1 IN (@Param1, @Param2, @Param3, ..., @Param500). This caused SQL to build a temp table, do a sort/distinct, and then do a table scan instead of an index seek. That is essentially what you would be doing by parameterizing that query, although on a small enough scale that it won't make a noticeable difference. I highly recommend against having NULL in your IN lists, as if that gets changed to a NOT IN it will not act as intended. You could dynamically build the parameter list, but the only obvious thing that you would gain is that the objects would escape the single quotes for you. That approach is also slightly slower on the application end since the objects have to parse the query to find the parameters. It may or may not be faster on SQL, as parameterized queries call sp_prepare, sp_execute for as many times you execute the query, followed by sp_unprepare.</source>
          <target state="translated">Я также видел хранимые процедуры,которые имели 500 параметров со значениями по умолчанию,равными нулю,и имели ГДЕ столбец1 IN (@Param1,@Param2,@Param3,...,@Param500).Это заставило SQL построить временную таблицу,выполнить сортировку,а затем выполнить сканирование таблицы вместо поиска индекса.По сути,это то,что вы бы делали,параметризуя этот запрос,хотя и в достаточно маленьком масштабе,чтобы он не имел заметной разницы.Я настоятельно не рекомендую иметь NULL в ваших списках IN,так как если это изменится на NOT IN,то это будет действовать не так,как задумывалось.Вы можете динамически строить список параметров,но единственное очевидное,что вы получите-это то,что объекты будут избегать одиночных кавычек для вас.Такой подход также немного медленнее со стороны приложения,так как объекты должны разобрать запрос,чтобы найти параметры.На SQL это может быть быстрее,а может и нет,так как параметризованные запросы вызывают sp_prepare,sp_execute столько раз,сколько вы выполняете запрос,а затем sp_unprepare.</target>
        </trans-unit>
        <trans-unit id="d82e71ada8a62159ea70852009714bf5aa14c66d" translate="yes" xml:space="preserve">
          <source>I have an answer that doesn't require a UDF, XML
Because IN accepts a select statement
e.g. SELECT * FROM Test where Data IN (SELECT Value FROM TABLE)</source>
          <target state="translated">У меня есть ответ,который не требует UDF,XML,потому что IN принимает утверждение выбора,например,SELECT*FROM Test where Data IN (SELECT Value FROM TABLE)</target>
        </trans-unit>
        <trans-unit id="2180e8cc79db8111713b3a38b9273505d784397f" translate="yes" xml:space="preserve">
          <source>I have seen the split functions take longer to execute than the query themselves in many cases where the parameters get large. A stored procedure with table valued parameters in SQL 2008 is the only other option I would consider, although this will probably be slower in your case. TVP will probably only be faster for large lists if you are searching on the primary key of the TVP, because SQL will build a temporary table for the list anyway (if the list is large). You won't know for sure unless you test it.</source>
          <target state="translated">Я видел,что во многих случаях,когда параметры становятся большими,выполнение сплит-функций занимает больше времени,чем сам запрос.Хранимая процедура с параметрами,оцениваемыми по таблицам,в SQL 2008-это единственный вариант,который я бы рассматривал,хотя в вашем случае это,скорее всего,будет медленнее.TVP,вероятно,будет быстрее для больших списков,только если вы ищете по первичному ключу TVP,потому что SQL все равно построит временную таблицу для списка (если список большой).Вы не будете знать наверняка,пока не протестируете его.</target>
        </trans-unit>
        <trans-unit id="e2d5c5e674c7b6a4cb6b4676422df0cbb9e45827" translate="yes" xml:space="preserve">
          <source>I heard Jeff/Joel talk about this on the podcast today (&lt;em&gt;&lt;a href=&quot;http://itc.conversationsnetwork.org/audio/download/ITC.SO-Episode34-2008.12.16.mp3&quot;&gt;episode 34&lt;/a&gt;&lt;/em&gt;, 2008-12-16 (MP3, 31&amp;nbsp;MB), 1 h 03 min 38 secs - 1 h 06 min 45 secs), and I thought I recalled Stack&amp;nbsp;Overflow was using &lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;LINQ&amp;nbsp;to&amp;nbsp;SQL&lt;/a&gt;, but maybe it was ditched. Here's the same thing in LINQ&amp;nbsp;to&amp;nbsp;SQL.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я слышал, как Джефф / Джоэл говорил об этом сегодня на подкасте ( &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;http://itc.conversationsnetwork.org/audio/download/ITC.SO-Episode34-2008.12.16.mp3&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;серия 34&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 2008-12-16 (MP3, 31 МБ), 1 ч 03 мин 38 с - 1 ч 06 мин 45 с), и мне показалось, что я вспомнил переполнение стека использовал &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LINQ to SQL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но, возможно, он был исключен. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот то же самое в LINQ to SQL.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68e1d98c1bde1a441a049af1b527a7799aebbbe2" translate="yes" xml:space="preserve">
          <source>I like Joel Spolsky's approach.  It's clever.  And it works.</source>
          <target state="translated">Мне нравится подход Джоэла Спольски.Это умно.И он работает.</target>
        </trans-unit>
        <trans-unit id="10c3a107dda505aa2f5d453923b47dd798c81981" translate="yes" xml:space="preserve">
          <source>I never got around to profiling exactly how &lt;em&gt;fast&lt;/em&gt; it was, but in my situation it was needed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я никогда не удосужился понять, насколько &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;быстро&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; это было, но в моей ситуации это было необходимо.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="82c8befdd145dc1a6bf86c2be33fbcb496ad3fd6" translate="yes" xml:space="preserve">
          <source>I prefer this approach to escaping because it works in Oracle and MySQL as well as SQL Server.  (I usually use the \ backslash as the escape character, since that's the character we use in regular expressions. But why be constrained by convention!</source>
          <target state="translated">Я предпочитаю этот подход,потому что он работает в Oracle и MySQL,а также в SQL Server.(Обычно я использую обратный слеш \ в качестве экранирующего символа,так как это символ,который мы используем в регулярных выражениях.Но зачем ограничиваться конвенцией!</target>
        </trans-unit>
        <trans-unit id="af4243377878f11b07ae3404abe46df5a7ff9d2a" translate="yes" xml:space="preserve">
          <source>I think this is a case when a static query is just not the way to go. Dynamically build the list for your in clause, escape your single quotes, and dynamically build SQL. In this case you probably won't see much of a difference with any method due to the small list, but the most efficient method really is to send the SQL exactly as it is written in your post. I think it is a good habit to write it the most efficient way, rather than to do what makes the prettiest code, or consider it bad practice to dynamically build SQL.</source>
          <target state="translated">Я думаю,что это тот случай,когда статический запрос просто не подходит.Динамически стройте список для вашего в пункте,экранируйте одиночные кавычки и динамически стройте SQL.В этом случае вы,вероятно,не увидите большой разницы с любым методом из-за маленького списка,но самый эффективный метод на самом деле-это отправить SQL в точности так,как он написан в вашей заметке.Я считаю хорошей привычкой писать его наиболее эффективным способом,а не делать то,что делает красивейший код,или считать плохой практикой динамическую сборку SQL.</target>
        </trans-unit>
        <trans-unit id="470eb3bd8dc8f9275680a731f7a00e1369b18132" translate="yes" xml:space="preserve">
          <source>I use a more concise version &lt;a href=&quot;https://stackoverflow.com/a/337792/16587&quot;&gt;of the top voted answer&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я использую более краткую версию &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/337792/16587&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ответа с&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; наибольшим &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;количеством голосов&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77c29b34770822e532945f81b425ab2daa5931cd" translate="yes" xml:space="preserve">
          <source>I would pass a table type parameter (since it's &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;SQL Server 2008&lt;/a&gt;), and do a &lt;code&gt;where exists&lt;/code&gt;, or inner join. You may also use XML, using &lt;code&gt;sp_xml_preparedocument&lt;/code&gt;, and then even index that temporary table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я бы передавал параметр типа таблицы (поскольку это &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) и выполнял бы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;where exists&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;где существует&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , или внутреннее соединение. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы также можете использовать XML, используя &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sp_xml_preparedocument&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , а затем даже индексировать эту временную таблицу.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38e00a81ddf5f6fe0b6b36105aa8782ef2784f85" translate="yes" xml:space="preserve">
          <source>I would prefer not to use a dedicated stored procedure for this (or XML), but if there is some elegant way specific to &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;SQL Server 2008&lt;/a&gt;, I am open to that.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я предпочел бы не использовать выделенную хранимую процедуру для этого (или XML), но если есть какой-то элегантный способ, специфичный для &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , я открыт для этого.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d99406eb70ce3918021a57f108a598c46ca958e8" translate="yes" xml:space="preserve">
          <source>I'd approach this by default with passing a table valued function (that returns a table from a string) to the IN condition.</source>
          <target state="translated">Я бы подходил к этому по умолчанию с передачей функции оценки таблицы (которая возвращает таблицу из строки)в условие IN.</target>
        </trans-unit>
        <trans-unit id="358e1888dd9c3dc6a6d8b8f74729dc1edef55c23" translate="yes" xml:space="preserve">
          <source>If needed you can insert it into a temp table, index it, then run a join...</source>
          <target state="translated">При необходимости вы можете вставить его в временную таблицу,проиндексировать,затем запустить соединение...</target>
        </trans-unit>
        <trans-unit id="1be3fb0e541f55904b67a0c3a768429469841e69" translate="yes" xml:space="preserve">
          <source>If we have strings stored inside the IN clause with the comma(,) delimited, we can use the charindex function to get the values. If you use .NET, then you can map with SqlParameters.</source>
          <target state="translated">Если у нас внутри пункта IN хранятся строки с разделителем comma(,),то мы можем использовать функцию charindex для получения значений.Если вы используете .NET,то вы можете составлять карты с помощью SqlParameters.</target>
        </trans-unit>
        <trans-unit id="c1a9ec97b4d93a4f86712c4f1a87de838971feee" translate="yes" xml:space="preserve">
          <source>If you are calling from .NET, you could use &lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;Dapper dot net&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы звоните из .NET, вы можете использовать &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dapper dot net&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dd00bd710d5c5d138e7a5c14fe395b67a569d86e" translate="yes" xml:space="preserve">
          <source>If you have enough RAM, I'd expect SQL&amp;nbsp;Server would probably cache a plan for the common counts of parameters as well. I suppose you could always add five parameters, and let the unspecified tags be NULL - the query plan should be the same, but it seems pretty ugly to me and I'm not sure that it'd worth the micro-optimization (although, on Stack&amp;nbsp;Overflow - it may very well be worth it).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если у вас достаточно оперативной памяти, я ожидаю, что SQL Server, вероятно, также кеширует план для общего количества параметров. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я полагаю, что вы всегда можете добавить пять параметров и позволить неопределенным тегам быть NULL - план запроса должен быть таким же, но он кажется мне довольно уродливым, и я не уверен, что это стоило бы микрооптимизации (хотя, на переполнении стека - это вполне может стоить).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="13efe4ce5cd750e79baf7a01290267049374c466" translate="yes" xml:space="preserve">
          <source>If you're really interested in performance and don't want to iterate through the loop twice, here's a less beautiful version:</source>
          <target state="translated">Если вы действительно заинтересованы в производительности и не хотите дважды проходить итерацию по циклу,вот менее красивая версия:</target>
        </trans-unit>
        <trans-unit id="0c540b5e6699b2c7b611bcf7af1cd074053d21fd" translate="yes" xml:space="preserve">
          <source>If you're unlucky enough to be stuck on &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2005&quot;&gt;SQL Server 2005&lt;/a&gt; you could add a &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Language_Runtime&quot;&gt;CLR&lt;/a&gt; function like this,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вам не повезло застрять в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2005&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2005,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вы можете добавить функцию &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Language_Runtime&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CLR,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; например:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2f991e2ce21fbc2b508a3faff72c5094821362eb" translate="yes" xml:space="preserve">
          <source>If you've got &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;SQL Server 2008&lt;/a&gt; or later I'd use a &lt;a href=&quot;https://stackoverflow.com/questions/5595353/how-to-pass-table-value-parameters-to-stored-procedure-from-net-code&quot;&gt;Table Valued Parameter&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если у вас &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или более поздняя версия, я бы использовал параметр с &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/5595353/how-to-pass-table-value-parameters-to-stored-procedure-from-net-code&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;табличным значением&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b26bb26a3dff833054084925292a26c85610a666" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://en.wikipedia.org/wiki/ColdFusion&quot;&gt;ColdFusion&lt;/a&gt; we just do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/ColdFusion&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ColdFusion&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; мы просто делаем:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae0b31a603e2cadba5386706372b442225ace3da" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SQL Server 2016+&lt;/code&gt; you could use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/mt684588.aspx&quot;&gt;&lt;code&gt;STRING_SPLIT&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В &lt;/font&gt;&lt;/font&gt; &lt;code&gt;SQL Server 2016+&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; вы можете использовать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функцию &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/mt684588.aspx&quot;&gt; &lt;code&gt;STRING_SPLIT&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77792ff8ecdb0ffcc2759ed0fc092e6107edf5e4" translate="yes" xml:space="preserve">
          <source>In SQL Server 2016+ another possibility is to use the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn921879.aspx&quot;&gt;&lt;code&gt;OPENJSON&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В SQL Server 2016+ другой возможностью является использование &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функции &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn921879.aspx&quot;&gt; &lt;code&gt;OPENJSON&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9f1f4abb84eb41057375a32c3581100f5fffce9" translate="yes" xml:space="preserve">
          <source>In my opinion, the best source to solve this problem, is what has been posted on this site:</source>
          <target state="translated">На мой взгляд,лучшим источником для решения этой проблемы,является то,что было размещено на этом сайте:</target>
        </trans-unit>
        <trans-unit id="d01a0b1abba0430fb1dfbb704c154c9812f0edb7" translate="yes" xml:space="preserve">
          <source>In the C# code you do something like this:</source>
          <target state="translated">В коде C#ты делаешь что-то вроде этого:</target>
        </trans-unit>
        <trans-unit id="5dad346a862dade5a2ce260292058579877f3e81" translate="yes" xml:space="preserve">
          <source>In the SQL you have a clause like this:</source>
          <target state="translated">В SQL есть такой пункт:</target>
        </trans-unit>
        <trans-unit id="c9ac14f5f553dbf81735a238c4aec23e0f9b9b3d" translate="yes" xml:space="preserve">
          <source>In this query, the number of arguments could be anywhere from 1 to 5.</source>
          <target state="translated">В этом запросе количество аргументов может быть от 1 до 5.</target>
        </trans-unit>
        <trans-unit id="1ccc36caa6c571f60a777db830b24b1bd0152f89" translate="yes" xml:space="preserve">
          <source>Injection concerns aside, take care to note that constructing the command text to accomodate a variable number of parameters (as above) impede's SQL server's ability to take advantage of cached queries. The net result is that you almost certainly lose the value of using parameters in the first place (as opposed to merely inserting the predicate strings into the SQL itself).</source>
          <target state="translated">Обращая внимание на то,что построение текста команды с переменным количеством параметров (как описано выше)мешает SQL-серверу использовать преимущества кэшированных запросов.В результате вы почти наверняка теряете значение использования параметров в первую очередь (в отличие от простой вставки предикатных строк в сам SQL).</target>
        </trans-unit>
        <trans-unit id="cfe8f3b2b9656fa087b047b0c76f57d8888a9b38" translate="yes" xml:space="preserve">
          <source>Instead of using an &lt;code&gt;IN&lt;/code&gt;, you can then just use your standard &lt;code&gt;JOIN&lt;/code&gt; rules. ( Flexibility++ )</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вместо использования &lt;/font&gt;&lt;/font&gt; &lt;code&gt;IN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , вы можете просто использовать ваши стандартные &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;правила &lt;/font&gt;&lt;/font&gt; &lt;code&gt;JOIN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Гибкость ++)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6531c8cd756afd65aa968ac013e26ebeae12e8e9" translate="yes" xml:space="preserve">
          <source>It almost goes without saying that we might not want &lt;code&gt;pe%ter&lt;/code&gt; to match peanut butter, no matter how much he likes it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Само собой разумеется, что мы не хотим, чтобы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pe%ter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; соответствовал арахисовому маслу, независимо от того, насколько ему это нравится.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a8aa17b73c9976e345417d180c7b625a957911aa" translate="yes" xml:space="preserve">
          <source>It does loop through the tag parameters twice; but that doesn't matter most of the time (it won't be your bottleneck; if it is, unroll the loop).</source>
          <target state="translated">Он делает цикл через параметры тега дважды;но это не имеет значения большую часть времени (это не будет вашим узким местом;если это так,то разворачивайте цикл).</target>
        </trans-unit>
        <trans-unit id="4b7b04c75db0a99e0f8a75786d727c9a060cda70" translate="yes" xml:space="preserve">
          <source>Joel Spolsky's approach is clever.  And it works reasonably, it's going to exhibit predictable behavior and predictable performance, given &quot;normal&quot; values, and with the normative edge cases, such as NULL and the empty string.  And it may be sufficient for a particular application.</source>
          <target state="translated">Подход Джоэла Спольски умный.И он работает разумно,он будет демонстрировать предсказуемое поведение и предсказуемую производительность,при заданных &quot;нормальных&quot; значениях,и с нормативными граничными случаями,такими как NULL и пустая строка.И этого может быть достаточно для конкретного приложения.</target>
        </trans-unit>
        <trans-unit id="ef078c7764d0dfe131b3ce83b313bd5d0f32a413" translate="yes" xml:space="preserve">
          <source>Let me state right here, that this is &lt;strong&gt;not an answer&lt;/strong&gt; to the original question.  There are already some demonstrations of that in other good answers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Позвольте мне прямо здесь заявить, что это &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;не ответ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; на первоначальный вопрос. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Уже есть некоторые доказательства этого в других хороших ответах.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac08ba80594a0659efb8968aea37e16a79e71676" translate="yes" xml:space="preserve">
          <source>Make sure you don't have any &lt;code&gt;|&lt;/code&gt;, blank, or null tags or this won't work</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Убедитесь, что у вас нет &lt;/font&gt;&lt;/font&gt; &lt;code&gt;|&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, пустые или нулевые теги или это не сработает&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4c8a0f32fd7f5b545c1fc32faeff3a3ddeb8716" translate="yes" xml:space="preserve">
          <source>May be we can use XML here:</source>
          <target state="translated">Может быть,мы можем использовать XML здесь:</target>
        </trans-unit>
        <trans-unit id="cc703fb9e22b2d4125214daa80ed8744a1971657" translate="yes" xml:space="preserve">
          <source>No infinite variability for you.  Only finite variability.</source>
          <target state="translated">Для вас нет бесконечной вариабельности.Только конечная вариативность.</target>
        </trans-unit>
        <trans-unit id="b17bd2c4be5e9e38316d4ca5e4bba27b293c90cd" translate="yes" xml:space="preserve">
          <source>No, this is not open to &lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL injection&lt;/a&gt;. The only injected text into CommandText is not based on user input. It's solely based on the hardcoded &quot;@tag&quot; prefix, and the index of an array. The index will &lt;em&gt;always&lt;/em&gt; be an integer, is not user generated, and is safe.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Нет, это не открыто для &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;внедрения SQL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Единственный введенный текст в CommandText не основан на вводе пользователем. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он основан исключительно на жестко заданном префиксе &quot;@tag&quot; и индексе массива. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Индекс &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;всегда&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет целым числом, не генерируется пользователем и является безопасным.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81f8d03283d9b4204147b22834f1cd053335add0" translate="yes" xml:space="preserve">
          <source>Not that cached query plans aren't valuable, but IMO this query isn't nearly complicated enough to see much benefit from it. While the compilation costs may approach (or even exceed) the execution costs, you're still talking milliseconds.</source>
          <target state="translated">Не то чтобы кэшированные планы запросов не ценны,но IMO этот запрос не настолько сложен,чтобы увидеть много пользы от него.Несмотря на то,что затраты на компиляцию могут приближаться (или даже превышать)к затратам на выполнение,вы все равно говорите о миллисекундах.</target>
        </trans-unit>
        <trans-unit id="a039ae3772c1ef49d778f9f8c4b67934ff2c1fc3" translate="yes" xml:space="preserve">
          <source>Now that we're on a roll, we can add another &lt;code&gt;REPLACE&lt;/code&gt; handle the underscore wildcard.   And just for fun, this time, we'll use $ as the escape character.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь, когда мы на рулоне, мы можем добавить еще один &lt;/font&gt;&lt;/font&gt; &lt;code&gt;REPLACE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; обрабатывать подчеркивание подстановочные. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И просто для удовольствия, на этот раз мы будем использовать $ в качестве escape-символа.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01625438b5c7959ea81cd00f7a3084a534d6307d" translate="yes" xml:space="preserve">
          <source>Now we can match the literal %.  Of course, when we have a column name, we're going to need to dynamically escape the wildcard.  We can use the &lt;code&gt;REPLACE&lt;/code&gt; function to find occurrences of the &lt;code&gt;%&lt;/code&gt;character and insert a backslash character in front of each one, like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь мы можем сопоставить буквальный%. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Конечно, когда у нас есть имя столбца, нам нужно динамически экранировать шаблон. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мы можем использовать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функцию &lt;/font&gt;&lt;/font&gt; &lt;code&gt;REPLACE&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; чтобы найти вхождения &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;символа &lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и вставить символ обратной косой черты перед каждым, например так:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6998781be11fbddbbca54848518598754741b9b1" translate="yes" xml:space="preserve">
          <source>Okay, so, if we don't handle that as an inline expression in the SQL, the closest alternative we have is a user defined function.  And we know that won't speed things up any (unless we can define an index on it, like we could with Oracle.)  If we've got to create a function, we might better do that in the code that calls the SQL statement.</source>
          <target state="translated">Итак,если мы не будем обрабатывать это выражение как встроенное в SQL,то ближайшая альтернатива,которую мы имеем,это функция,определяемая пользователем.И мы знаем,что это ничего не ускорит (если только мы не сможем определить на ней индекс,как мы могли бы это сделать с Oracle).Если нам нужно создать функцию,то лучше сделать это в коде,который вызывает SQL выражение.</target>
        </trans-unit>
        <trans-unit id="b73b20450025066dadaf1b5da5e8b07536a277f8" translate="yes" xml:space="preserve">
          <source>Once you got this your code would be as simple as this:</source>
          <target state="translated">Как только ты получишь это,твой код будет так же прост,как и этот:</target>
        </trans-unit>
        <trans-unit id="2cd8064f013da44c7a421743d1d148268bb442b0" translate="yes" xml:space="preserve">
          <source>One approach to patching this hole is to escape the &lt;code&gt;%&lt;/code&gt; wildcard character.  (For anyone not familiar with the escape clause on the operator, here's a link to the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa933232(SQL.80).aspx&quot;&gt;SQL Server documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Один из подходов к исправлению этой дыры - избежать &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;символа подстановки &lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Для тех, кто не знаком с оператором escape, здесь есть ссылка на документацию по &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa933232(SQL.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d785d1b371bf1e0d416a3c1cf4b58af9de8c0682" translate="yes" xml:space="preserve">
          <source>Parameterize an SQL IN clause</source>
          <target state="translated">Параметрировать условие SQL IN</target>
        </trans-unit>
        <trans-unit id="8bd73e8b6032d828eaae575e172d15ae190e9acc" translate="yes" xml:space="preserve">
          <source>Related: &lt;a href=&quot;https://www.brentozar.com/archive/2020/02/how-to-pass-a-list-of-values-into-a-stored-procedure/&quot;&gt;How to Pass a List of Values Into a Stored Procedure&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Связанный: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.brentozar.com/archive/2020/02/how-to-pass-a-list-of-values-into-a-stored-procedure/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как передать список значений в хранимую процедуру&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7c790d520ea0368c427f57e2c38a9f1b62f724a" translate="yes" xml:space="preserve">
          <source>SQL Server also allows for wildcard characters to be treated as literals by enclosing them in brackets &lt;code&gt;[]&lt;/code&gt;.  So we're not done fixing yet, at least for SQL Server.  Since pairs of brackets have special meaning, we'll need to escape those as well.  If we manage to properly escape the brackets, then at least we won't have to bother with the hyphen &lt;code&gt;-&lt;/code&gt; and the carat &lt;code&gt;^&lt;/code&gt; within the brackets.  And we can leave any &lt;code&gt;%&lt;/code&gt;and &lt;code&gt;_&lt;/code&gt; characters inside the brackets escaped, since we'll have basically disabled the special meaning of the brackets.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server также позволяет обрабатывать символы подстановки как литералы, заключая их в квадратные скобки &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Итак, мы еще не закончили исправление, по крайней мере для SQL Server. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку пары скобок имеют особое значение, нам также нужно избегать их. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если нам удастся правильно убрать скобки, то, по крайней мере, нам не придется беспокоиться о дефисе &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и карате &lt;/font&gt;&lt;/font&gt; &lt;code&gt;^&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в скобках. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И мы можем оставить любые &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;символы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;_&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; внутри квадратных скобок, поскольку мы в основном отключили специальное значение квадратных скобок.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf5871ddbc56fc0f2c14226259e67209782850cc" translate="yes" xml:space="preserve">
          <source>SQL with dynamic parameters.</source>
          <target state="translated">SQL с динамическими параметрами.</target>
        </trans-unit>
        <trans-unit id="b34e6d11a266a89b525b0c300696a7d0682681bf" translate="yes" xml:space="preserve">
          <source>See the answer from Mark Brackett for the preferred answer that I (and 231 others) upvoted. The approach given in his answer allows 1) for effective use of bind variables, and 2) for predicates that are sargable.</source>
          <target state="translated">См.ответ от Марка Брекетта для предпочтительного ответа,который я (и 231 другой)отменил.Подход,приведенный в его ответе,позволяет 1)эффективно использовать переменные связывания,и 2)предикаты,которые являются sargable.</target>
        </trans-unit>
        <trans-unit id="178bfb059f4a1822cfbe2ec9ebe2c39718e33adf" translate="yes" xml:space="preserve">
          <source>So basically if the count is 0 then there is no filter and everything goes through.  If the count is higher than 0 the then the value must be in the list, but the list has been padded out to five with impossible values (so that the SQL still makes sense)</source>
          <target state="translated">Так что,в основном,если счет 0,то фильтра нет,и все проходит.Если счетчик больше 0,то значение должно быть в списке,но список был дополнен до пяти с невозможными значениями (так что SQL все еще имеет смысл).</target>
        </trans-unit>
        <trans-unit id="30f329f8fb37cb3f59749389eca8fa0f6f4ac58d" translate="yes" xml:space="preserve">
          <source>So here's the C# code:</source>
          <target state="translated">Итак,вот код C#:</target>
        </trans-unit>
        <trans-unit id="01e03d9a83d6e670a41622f3b700936b34789926" translate="yes" xml:space="preserve">
          <source>So that solves the problem with the % wildcard.  Almost.</source>
          <target state="translated">Это решает проблему с подстановочным знаком %.Почти.</target>
        </trans-unit>
        <trans-unit id="bc224aea5e1e203f177bffceb162be21609d9157" translate="yes" xml:space="preserve">
          <source>So you have the string</source>
          <target state="translated">Итак,у тебя есть струна</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="ac1dd42bff5436684704cd8cecb553fb4a51748f" translate="yes" xml:space="preserve">
          <source>Sometimes the lame solution is the only one that actually works.</source>
          <target state="translated">Иногда отстойное решение-единственное,что на самом деле работает.</target>
        </trans-unit>
        <trans-unit id="2187e96ff77893224d6a4fbd66eeac75a0523097" translate="yes" xml:space="preserve">
          <source>Stored procedure with table valued parameters. If the list can vary by a large amount use WITH RECOMPILE on the stored procedure, or simply use dynamic SQL without parameters to generate a new execution plan for each query.</source>
          <target state="translated">Процедура хранения с ценными параметрами таблицы.Если список может сильно отличаться,используйте WITH RECOMPILE на хранимой процедуре,или просто используйте динамический SQL без параметров,чтобы сгенерировать новый план выполнения для каждого запроса.</target>
        </trans-unit>
        <trans-unit id="49b0933c48745bbe595589a84f3c999c1aac15aa" translate="yes" xml:space="preserve">
          <source>Syscomments. Dinakar Nethi</source>
          <target state="translated">Сис-комментарии.Динакар Нетхи</target>
        </trans-unit>
        <trans-unit id="f56c9210a9e2c9a6ed7f60b0c1718d038683158e" translate="yes" xml:space="preserve">
          <source>T-SQL:</source>
          <target state="translated">T-SQL:</target>
        </trans-unit>
        <trans-unit id="e03134a806a1e31e6209b7319743bf47eb301543" translate="yes" xml:space="preserve">
          <source>That inline expression in the SQL is getting longer and uglier.  We can probably make it work, but heaven help the poor soul that comes behind and has to decipher it.  As much of a fan I am for inline expressions, I'm inclined not use one here, mainly because I don't want to have to leave a comment explaining the reason for the mess, and apologizing for it.</source>
          <target state="translated">Это строчное выражение в SQL становится все длиннее и уродливее.Вероятно,мы можем заставить его работать,но небеса помогают бедной душе,которая приходит сзади и должна расшифровать его.Как большой поклонник встраиваемых выражений,я склонен не использовать их здесь,в основном потому,что не хочу оставлять комментарий,объясняющий причину беспорядка,и приносящий извинения за это.</target>
        </trans-unit>
        <trans-unit id="0ccc088929d1deebf84e0a4fa97b04fa55774e0d" translate="yes" xml:space="preserve">
          <source>That's it. And, yes, LINQ already looks backwards enough, but the &lt;code&gt;Contains&lt;/code&gt; clause seems extra backwards to me. When I had to do a similar query for a project at work, I naturally tried to do this the wrong way by doing a join between the local array and the SQL Server table, figuring the LINQ&amp;nbsp;to&amp;nbsp;SQL translator would be smart enough to handle the translation somehow. It didn't, but it did provide an error message that was descriptive and pointed me towards using &lt;em&gt;Contains&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот и все. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И, да, LINQ уже выглядит достаточно задом наперед, но предложение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Contains&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; мне кажется слишком задом наперед. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда мне приходилось делать аналогичный запрос для проекта на работе, я, естественно, пытался сделать это неправильно, выполнив объединение между локальным массивом и таблицей SQL Server, полагая, что транслятор LINQ to SQL будет достаточно умен, чтобы справиться с перевод как-то. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это не так, но в нем содержалось сообщение об ошибке, которое содержало описание и указывало на использование &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Contains&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8ff37281903edcab5bee93dfd2354fea3795197" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/337817/5070879&quot;&gt;accepted answer&lt;/a&gt; will of course work and it is one of the way to go, but it is anti-pattern.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/337817/5070879&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Общепринятый ответ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; будет, конечно , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;работа , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;и это один из способов идти, но это анти-модель.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8eba07cdda4ea60d10a9bebc962b106ed7a8920a" translate="yes" xml:space="preserve">
          <source>The Oracle version:</source>
          <target state="translated">Версия Oracle:</target>
        </trans-unit>
        <trans-unit id="9d1745ae6f89bcb6009c23298fa1e007d88d88a9" translate="yes" xml:space="preserve">
          <source>The behavior we observe is kind of odd.  Changing the order of the search terms in the list changes the result set.</source>
          <target state="translated">Поведение,которое мы наблюдаем,довольно странное.Изменение порядка следования поисковых терминов в списке изменяет набор результатов.</target>
        </trans-unit>
        <trans-unit id="5476b01df6c35abd19c57b5f47c1bc4611a97014" translate="yes" xml:space="preserve">
          <source>The general pattern is easy to extend and can be used for passing more complex tables.</source>
          <target state="translated">Общий шаблон легко расширяется и может быть использован для прохождения более сложных таблиц.</target>
        </trans-unit>
        <trans-unit id="fa033af9de3767d4d1bb2976f14c8950c3e8c353" translate="yes" xml:space="preserve">
          <source>The only winning move is not to play.</source>
          <target state="translated">Единственный выигрышный ход-не играть.</target>
        </trans-unit>
        <trans-unit id="b9583a9b4dce8989dd711d081c33d9ffd91c7a42" translate="yes" xml:space="preserve">
          <source>The original question was &lt;strong&gt;&quot;How do I parameterize a query ...&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Первоначальный вопрос был &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;Как я могу параметризовать запрос ...&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="66954bd1bf64a819018f1c94116a783f1d835163" translate="yes" xml:space="preserve">
          <source>The performance is terrible. &lt;code&gt;LIKE &quot;%...%&quot;&lt;/code&gt; queries are not indexed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Производительность ужасная. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;LIKE &quot;%...%&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; запросы не индексируются.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c595b1a23d029415bc9530e69c56a7bf52a907e6" translate="yes" xml:space="preserve">
          <source>The proper way IMHO is to store the list in a character string (limited in length by what the DBMS support); the only trick is that (in order to simplify processing) I have a separator (a comma in my example) at the beginning and at the end of the string. The idea is to &quot;normalize on the fly&quot;, turning the list into a one-column table that contains one row per value. This allows you to turn</source>
          <target state="translated">Правильный способ IMHO-хранить список в символьной строке (ограниченной по длине тем,что поддерживает СУБД);единственная хитрость в том,что (для упрощения обработки)у меня есть разделитель (запятая в моем примере)в начале и в конце строки.Идея состоит в том,чтобы &quot;нормализовать на лету&quot;,превращая список в таблицу с одной колонкой,содержащую по одной строке на значение.Это позволит вам превратить</target>
        </trans-unit>
        <trans-unit id="080963f0ce43b16a038ca3c1cafb8009937c4fa2" translate="yes" xml:space="preserve">
          <source>The reuse of execution plans for stored procedures or parameterized queries may give you a performance gain, but it will lock you in to one execution plan determined by the first query that is executed. That may be less than ideal for subsequent queries in many cases. In your case, reuse of execution plans will probably be a plus, but it might not make any difference at all as the example is a really simple query.</source>
          <target state="translated">Повторное использование планов выполнения для хранимых процедур или параметризованных запросов может дать выигрыш в производительности,но это привяжет вас к одному плану выполнения,определенному первым выполненным запросом.Во многих случаях это может быть менее чем идеально для последующих запросов.В вашем случае повторное использование планов выполнения,вероятно,будет плюсом,но это может вообще не иметь никакого значения,так как пример-действительно простой запрос.</target>
        </trans-unit>
        <trans-unit id="a8eb233e5b6e8d0a30d47b4e1de065627dccaad7" translate="yes" xml:space="preserve">
          <source>The string can be built in any language. In this example I used SQL since that was the original problem I was trying to solve. I needed a clean way to pass in table data on the fly in a string to be executed later.</source>
          <target state="translated">Строка может быть построена на любом языке.В данном примере я использовал SQL,так как это было первоначальной задачей,которую я пытался решить.Мне нужен был чистый способ передавать данные в таблицах на лету в строке,которая будет выполняться позже.</target>
        </trans-unit>
        <trans-unit id="2a379f85b2c923f924ec4c11add17ee12c66803a" translate="yes" xml:space="preserve">
          <source>The user inputted values are still stuffed into parameters, so there is no vulnerability there.</source>
          <target state="translated">Вводимые пользователем значения все еще вставляются в параметры,поэтому уязвимости там нет.</target>
        </trans-unit>
        <trans-unit id="46a9f25a51ce70904d83b4d2fdcce6438b367f5c" translate="yes" xml:space="preserve">
          <source>The values stored in the column may allow for % or _ characters, but a constraint may require those values to be escaped, perhaps using a defined character, such that the values are LIKE comparison &quot;safe&quot;.  Again, a quick comment about the allowed set of values, and in particular which character is used as an escape character, and go with Joel Spolsky's approach.</source>
          <target state="translated">Значения,хранящиеся в столбце,могут допускать % или_символов,но ограничение может потребовать,чтобы эти значения были экранированы,возможно,используя определенный символ,таким образом,чтобы значения были &quot;безопасными&quot; для сравнения LIKE.Опять же,быстрый комментарий о допустимом наборе значений и,в частности,о том,какой символ используется в качестве экранирующего,идите с подходом Джоэла Спольского.</target>
        </trans-unit>
        <trans-unit id="432f039b6ee44f960eebe9edc61390d464e6ea6f" translate="yes" xml:space="preserve">
          <source>Then all you have to do is pass the string as 1 parameter.</source>
          <target state="translated">Тогда все,что вам нужно сделать,это передать строку в качестве 1 параметра.</target>
        </trans-unit>
        <trans-unit id="caabdeeafa5990eb317cda420543a417692b60d4" translate="yes" xml:space="preserve">
          <source>Then, your ADO.NET code looks like this:</source>
          <target state="translated">Тогда твой код ADO.NET выглядит вот так:</target>
        </trans-unit>
        <trans-unit id="92d757149ae4a77513eaebec2ba6645d7436a4bb" translate="yes" xml:space="preserve">
          <source>There are other ways to accomplish this that some people may consider cleaner, so please keep reading.</source>
          <target state="translated">Есть и другие способы добиться этого,которые некоторые люди могут считать более чистыми,так что,пожалуйста,продолжайте читать.</target>
        </trans-unit>
        <trans-unit id="4ce52d75168ac74d2698141558de7e48bb776b1d" translate="yes" xml:space="preserve">
          <source>This approach is blogged about in &lt;a href=&quot;http://blogs.msdn.com/b/sqlserverstorageengine/archive/2015/11/03/openjson-one-of-best-ways-to-select-rows-by-list-of-id.aspx&quot;&gt;OPENJSON - one of best ways to select rows by list of ids&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Об этом подходе рассказывается в &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.msdn.com/b/sqlserverstorageengine/archive/2015/11/03/openjson-one-of-best-ways-to-select-rows-by-list-of-id.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;OPENJSON - одном из лучших способов выбора строк по списку идентификаторов&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="958feb18dbf8f4056efe483472623f67177a7660" translate="yes" xml:space="preserve">
          <source>This can be done with a recursive CTE, or a query with a number table (or Master..spt_value)</source>
          <target state="translated">Это можно сделать с помощью рекурсивного CTE,или запроса с числовой таблицей (или Master...spt_value)</target>
        </trans-unit>
        <trans-unit id="08e5e9a6033c33675e7649a6d1cc1cacfea07f45" translate="yes" xml:space="preserve">
          <source>This has a bit of added flexibility in what you can do, but it's more suited for situations where you have a large table to query, with good indexing, and you want to use the parametrized list more than once. Saves having to execute it twice and have all the sanitation done manually.</source>
          <target state="translated">Это немного добавляет гибкости в том,что вы можете сделать,но это больше подходит для ситуаций,когда у вас есть большая таблица для запроса,с хорошей индексацией,и вы хотите использовать параметризованный список не один раз.Сохраняет необходимость выполнять его дважды,и все санитарные работы выполняются вручную.</target>
        </trans-unit>
        <trans-unit id="89a375a792ce41774bf8ba73cfe56ee977890de5" translate="yes" xml:space="preserve">
          <source>This is gross, but if you are guaranteed to have at least one, you could do:</source>
          <target state="translated">Это грубо,но если у вас гарантированно есть хотя бы один,вы могли бы это сделать:</target>
        </trans-unit>
        <trans-unit id="e29e488795dec60c287f82fd01f7fc119e047f6e" translate="yes" xml:space="preserve">
          <source>This is possibly a half nasty way of doing it, I used it once, was rather effective.</source>
          <target state="translated">Это,возможно,наполовину неприятный способ сделать это,я использовал его однажды,был довольно эффективным.</target>
        </trans-unit>
        <trans-unit id="923766af9d49d6ee8ab01954e13903dc14406c7f" translate="yes" xml:space="preserve">
          <source>This is replacement for common anti-pattern such as creating a dynamic SQL string in application layer or Transact-SQL, or by using LIKE operator:</source>
          <target state="translated">Это замена обычного анти-шаблона,такого как создание динамической SQL-строки на прикладном уровне или Transact-SQL,или использование оператора LIKE:</target>
        </trans-unit>
        <trans-unit id="5222b471ee3028d31cfe5f8af34e316502210ba5" translate="yes" xml:space="preserve">
          <source>To improve the &lt;code&gt;STRING_SPLIT&lt;/code&gt; table function row estimation, it is a good idea to materialize splitted values as temporary table/table variable:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы улучшить &lt;/font&gt;&lt;/font&gt; &lt;code&gt;STRING_SPLIT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; табличной функции &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;STRING_SPLIT&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , рекомендуется материализовать разделенные значения как временную переменную таблица / таблица:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2222e8c9448d0d44594f587bbcbc82c4ad1019e9" translate="yes" xml:space="preserve">
          <source>Two caveats:</source>
          <target state="translated">Две оговорки:</target>
        </trans-unit>
        <trans-unit id="5440af73b429739161f6ba1b784dfd0beaa7c95f" translate="yes" xml:space="preserve">
          <source>Unfortunately, the techniques to slice a string are fairly product-specific.
Here is the SQL Server version:</source>
          <target state="translated">К сожалению,методы нарезки строки достаточно специфичны для конкретного продукта.Вот версия сервера SQL:</target>
        </trans-unit>
        <trans-unit id="8fdf7787fac70523813d9ee461dc51c98f04f4ec" translate="yes" xml:space="preserve">
          <source>Unless you have a ridiculously long string, this should work well with the table index.</source>
          <target state="translated">Если у вас нет нелепо длинной строки,это должно хорошо работать с табличным индексом.</target>
        </trans-unit>
        <trans-unit id="2443ed13c972cd5cc6bdc47153849869b4ac0910" translate="yes" xml:space="preserve">
          <source>Use the following stored procedure. It uses a custom split function, which can be found &lt;a href=&quot;http://blogs.microsoft.co.il/blogs/itai/archive/2009/02/01/t-sql-split-function.aspx&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Используйте следующую хранимую процедуру. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Он использует пользовательскую функцию разделения, которую можно найти &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.microsoft.co.il/blogs/itai/archive/2009/02/01/t-sql-split-function.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;здесь&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="fc4db109b0b74a21e7b65fe2cccd3e5e113eabea" translate="yes" xml:space="preserve">
          <source>Using a user defined type is optional. Creating the type is only created once and can be done ahead of time. Otherwise just add a full table type to the declaration in the string.</source>
          <target state="translated">Использование определенного пользователем типа является необязательным.Создание типа создается только один раз и может быть сделано заранее.В противном случае просто добавьте к объявлению в строке полный табличный тип.</target>
        </trans-unit>
        <trans-unit id="ea109569ae92ebf585a2849dd893eef36a9892b4" translate="yes" xml:space="preserve">
          <source>We have function that creates a table variable that you can join to:</source>
          <target state="translated">У нас есть функция,которая создает переменную таблицы,к которой вы можете присоединиться:</target>
        </trans-unit>
        <trans-unit id="360d577f191fc4129da8ba5e7e42f6459f455eea" translate="yes" xml:space="preserve">
          <source>We may have specialized knowledge of the domain for the column, (that is, the set of allowable values enforced for the column.  We may know &lt;em&gt;a priori&lt;/em&gt; that the values stored in the column will never contain a percent sign, an underscore, or bracket pairs.  In that case, we just include a quick comment that those cases are covered.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мы , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;возможно, специальные знания в области для столбца, (то есть, набор допустимых значений насильственных для столбца. Мы можем знать &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;априорно&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , что значения , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;сохраненные в столбце никогда не будут содержать знак процента, подчеркивание, или кронштейну пары. В этом случае мы просто включаем быстрый комментарий, что эти случаи покрыты.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1eb0105114c419b879dc13efdb354bd9c4fdc800" translate="yes" xml:space="preserve">
          <source>We recognize that our solution has introduced another problem.  The escape character.  We see that we're also going to need to escape any occurrences of escape character itself.  This time, we use the ! as the escape character:</source>
          <target state="translated">Мы признаем,что наше решение привело к возникновению еще одной проблемы.Скрывающийся характер.Мы видим,что нам также потребуется избежать любого появления самого экранирующего символа.На этот раз мы используем ! в качестве экранирующего символа:</target>
        </trans-unit>
        <trans-unit id="a7e764b14c40a72de7506566f1043d46bb0179bf" translate="yes" xml:space="preserve">
          <source>What I want to address here is the approach given in Joel Spolsky's answer, the answer &quot;selected&quot; as the right answer.</source>
          <target state="translated">Здесь я хочу обратиться к подходу,приведенному в ответе Джоэла Спольского,ответ &quot;выбран&quot; как правильный.</target>
        </trans-unit>
        <trans-unit id="6450bd884edaaafc8f2c30b098dfab9b71545cba" translate="yes" xml:space="preserve">
          <source>Which will give you:</source>
          <target state="translated">Что даст тебе:</target>
        </trans-unit>
        <trans-unit id="c20d641e26d4310fe7f10673ba7c0d0a8a4f2ea5" translate="yes" xml:space="preserve">
          <source>Which you could use like this,</source>
          <target state="translated">Который тебе бы пригодился вот так,</target>
        </trans-unit>
        <trans-unit id="a1c640d00154452803b29c203f1d50877797b971" translate="yes" xml:space="preserve">
          <source>With that said, go ahead and flag this answer, downvote it, mark it as not an answer... do whatever you believe is right.</source>
          <target state="translated">Сделайте то,что считаете правильным,и пометьте этот ответ,процитируйте его,пометьте,что это не ответ...Делайте то,что считаете правильным.</target>
        </trans-unit>
        <trans-unit id="d453d5e94a94b047c31fc338808abef090d3c920" translate="yes" xml:space="preserve">
          <source>Yes, I've gone far afield from the original question.  But where else to leave this note concerning what I consider to be an important issue with the &quot;selected&quot; answer for a question?</source>
          <target state="translated">Да,я далеко ушел от первоначального вопроса.Но где еще оставить эту записку,касающуюся того,что я считаю важным вопросом с &quot;выбранным&quot; ответом на вопрос?</target>
        </trans-unit>
        <trans-unit id="c6194e2b66441e85c192f849cd73f13ef5f725d2" translate="yes" xml:space="preserve">
          <source>You can parameterize &lt;em&gt;each&lt;/em&gt; value, so something like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вы можете параметризовать &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;каждое&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; значение, так что-то вроде:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="540ae451a6a2159c5ecb0af841f18229951bd533" translate="yes" xml:space="preserve">
          <source>You can pass the parameter as a string</source>
          <target state="translated">Вы можете передать параметр как строку</target>
        </trans-unit>
        <trans-unit id="02d42af71a7eac7a8292d95356882939546d4a05" translate="yes" xml:space="preserve">
          <source>You can use the above statement in your .NET code and map the parameter with SqlParameter.</source>
          <target state="translated">Вы можете использовать приведенное выше утверждение в вашем .NET-коде и сопоставить параметр с SqlParameter.</target>
        </trans-unit>
        <trans-unit id="87437dc5ed8516a409cda3c960e12ffdcacc4b99" translate="yes" xml:space="preserve">
          <source>You really only need a way to convert the string into a table.</source>
          <target state="translated">Вам действительно нужен только способ преобразовать строку в таблицу.</target>
        </trans-unit>
        <trans-unit id="97e786164e7d144a82e75203dad2c623c0c11c82" translate="yes" xml:space="preserve">
          <source>and the MySQL version:</source>
          <target state="translated">и версию MySQL:</target>
        </trans-unit>
        <trans-unit id="3df8dd48aae8c0e7b8d71dd615f0f99c126b5e95" translate="yes" xml:space="preserve">
          <source>in (ct1,ct2, ct3 ... ctn)</source>
          <target state="translated">в (ct1,ct2,ct3...ctn)</target>
        </trans-unit>
        <trans-unit id="ce276f235956637e004c786d0c39a7ea5a549d44" translate="yes" xml:space="preserve">
          <source>in (select ...)</source>
          <target state="translated">в (выберите ...)</target>
        </trans-unit>
        <trans-unit id="edb6b110bc010a020fc6176e807d09190584bb53" translate="yes" xml:space="preserve">
          <source>into an</source>
          <target state="translated">в</target>
        </trans-unit>
        <trans-unit id="5bc416d9e2f5537e6bed7be9378837b7a0d5e3d1" translate="yes" xml:space="preserve">
          <source>optimizer plan using index scan rather than index seeks, possible need for an expression or function for escaping wildcards (possible index on expression or function)</source>
          <target state="translated">план оптимизатора,использующий индексное сканирование,а не индексный поиск,возможная необходимость в выражении или функции для экранирования подстановочных знаков (возможный индекс по выражению или функции)</target>
        </trans-unit>
        <trans-unit id="0b307b480fb16b98df07abaaae5ec29863540be3" translate="yes" xml:space="preserve">
          <source>or (the solution I'd probably prefer) a regular join, if you just add a &quot;distinct&quot; to avoid problems with duplicate values in the list.</source>
          <target state="translated">или (решение,которое я,вероятно,предпочел бы)регулярное соединение,если вы просто добавите &quot;отличный&quot;,чтобы избежать проблем с дублирующимися значениями в списке.</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="cc20f4add2f0b69a52b77cefaa7e7f09d88dca49" translate="yes" xml:space="preserve">
          <source>using literal values in place of bind variables impacts scalability</source>
          <target state="translated">использование буквальных значений вместо переменных связи влияет на масштабируемость</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
