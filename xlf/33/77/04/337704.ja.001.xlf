<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/337704">
    <body>
      <group id="337704">
        <trans-unit id="48f19cdab83f69f332c2f5fcb40c9ec7eaf89ca1" translate="yes" xml:space="preserve">
          <source>(Of course, &quot;pivot&quot; must return as many rows as the maximum number of
items we can find in the list)</source>
          <target state="translated">(もちろん、&quot;pivot &quot;はリストの中で見つけられる最大数の項目の数だけ行を返さなければなりません)</target>
        </trans-unit>
        <trans-unit id="dee8436afe3eef1c33541c551908ae7951d32018" translate="yes" xml:space="preserve">
          <source>(Yes, I will agree that this is an obscure case.  Probably one that is not likely to be tested.  We wouldn't expect a wildcard in a column value.  We may assume that the application prevents such a value from being stored.  But in my experience, I've rarely seen a database constraint that specifically disallowed characters or patterns that would be considered wildcards on the right side of a &lt;code&gt;LIKE&lt;/code&gt; comparison operator.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（はい、これはあいまいなケースであることに同意します。おそらくテストされる可能性が低いものです。列の値にワイルドカードが含まれることは想定されていません。アプリケーションがそのような値の格納を妨げていると想定する場合があります。しかし、私の経験では、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;LIKE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;比較演算子の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;右側でワイルドカードと見なされる文字またはパターンを特に許可しないデータベース制約を見たことはほとんどありません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d9796c38c06486ee44725f02212200e0e19ef822" translate="yes" xml:space="preserve">
          <source>(new version posted on 6/4/13).</source>
          <target state="translated">6413に新バージョンを掲載)。</target>
        </trans-unit>
        <trans-unit id="78bf7b6b27c8792a1b6240a992597a2169e13c12" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL injection&lt;/a&gt; (taking what would appear to be user supplied information, and including that in the SQL text rather than supplying them through bind variables.  Using bind variables isn't required, it's just one convenient approach to thwart with SQL injection.  There are other ways to deal with it:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQLインジェクション&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（ユーザーが入力した情報のように見えるものを取得し、バインド変数を介して提供するのではなく、SQLテキストにその情報を含めます。バインド変数を使用する必要はなく、SQLインジェクションを阻止する便利な方法の1つにすぎません。それを処理する方法：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a6e53cd33415c69a4bdf01a31b33c9cdd34fccfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INSERT&lt;/code&gt; each look-up value into that column.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その列に各ルックアップ値を。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac17bef807ba02b72de1e63fe25d0cf263de4816" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Addendum&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Addendum&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="cac28b87690e0244dc4499e21d80ce7f137a57b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/1196908?opt.withExecutionPlan=true#executionPlan&quot;&gt;SEDE - Live Demo&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/1196908?opt.withExecutionPlan=true#executionPlan&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SEDE-ライブデモ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8282433139e0a1e1ac6d41141b59ccceb433f13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/481811&quot;&gt;LiveDemo&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/481811&quot;&gt;LiveDemo&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d7cc78633528ed1105f6ee787b57caf8b5aca4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A function where ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;どこで関数？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce6064f3be2a2c0c2b244a4e5aa061cd081bde6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CREDITS FOR: Dinakar Nethi&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クレジット：Dinakar Nethi&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a8e521f362bc99965c4c0a3defa878eb3c31799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cliffs notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;崖のメモ：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8115e639335d833240663506049d0442b68dbba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusion&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4dbfdda273078557fedd54082b0a22e178bc8cdf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DDL Script:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;DDLスクリプト：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a555be6a06e633fb60d1ff7483e33da5b5ada3a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Domain knowledge&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;領域知識&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="252a44c26d52bbbdee3f05ef052068c571e8e15c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E. Find rows by list of values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;E.値のリストによって行を検索する&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67d3195b93a234f68cebcb65f2e721c5d575f4bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;
Create the table called SelectedTags using the following script.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;編集：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 次のスクリプトを使用してSelectedTagsというテーブルを作成します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67c8cacdeb62d71990d850b41caea868fe7455b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Escape the escape&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;エスケープエスケープ&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f05f137eb1a56908403bfbf2320629bc58403b99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inline expression gets messy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インライン式が乱れる&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="600e0ea4701a71484fccb509e0fd2655945c518e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Obscure corner case&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あいまいなコーナーケース&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b63eb5ee1a8de97b89ae2ad28cf585e5487ee5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Other issues recapitulated&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その他の問題の要約&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80bf15d2aa8f62da4288c48a4b4967714fe0679e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Patching a hole&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;穴をあける&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0b37171896c661e0a5bb56c2f1e263143165f10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Queries with large lists:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大きなリストを持つクエリ：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="38950a26e45ab68986a78cabd9db01f0fec39a5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Queries with reusable execution plans, called multiple times by simply changing the parameters or if the query is complicated:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;単純にパラメーターを変更することによって、またはクエリが複雑な場合に、複数回呼び出される再利用可能な実行プランを持つクエリ：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82001c1ced780a951a7c6f3798a7838f8bd5de2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Selected answer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;選択した回答&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23461227354b053ccf166a361a0b790e10fba24a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Some problems with % character&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;％文字に関するいくつかの問題&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9441af39c3c3128da7ddf830bf1d1d5d69405d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;T-SQL:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;T-SQL:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a0dc348f82c1d40f9d8a3a84a3bb9786ff40a7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The underscore too&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アンダースコアも&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f62f9cd4d15d0b544b7ee98f587e4a539f1b27d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Those pesky brackets&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それらの厄介な括弧&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7822cac6cb84dcb1f769dc18ac0d5e0e14b57cf2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Your case/simple queries with few parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;いくつかのパラメーターを使用したケース/単純なクエリ：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="554b441ed3b70f63af83d232d29f2422b76a4a30" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Original question has requirement &lt;code&gt;SQL Server 2008&lt;/code&gt;. Because this question is often used as duplicate, I've added this answer as reference. &lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;元の質問には&lt;/font&gt;&lt;/font&gt; &lt;code&gt;SQL Server 2008&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が必要です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この質問はよく重複して使用されるため、参照としてこの回答を追加しました。&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ef5c31c764d5981c9a8f620d4a86708fe1cafd16" translate="yes" xml:space="preserve">
          <source>A full worked example below</source>
          <target state="translated">以下に完全な実働例を示します。</target>
        </trans-unit>
        <trans-unit id="0ea255bf74e697155208b49c499a61c81d0083e5" translate="yes" xml:space="preserve">
          <source>Also, SQL&amp;nbsp;Server 7 and later will &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa175264(SQL.80).aspx&quot;&gt;auto-parameterize queries&lt;/a&gt;, so using parameters isn't really necessary from a performance standpoint - it is, however, &lt;em&gt;critical&lt;/em&gt; from a security standpoint - especially with user inputted data like this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、SQL Server 7以降では&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa175264(SQL.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クエリ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自動パラメーター化される&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ため、パフォーマンスの観点からはパラメーターを使用する必要はありません。ただし、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特にユーザーが入力したこのようなデータでは、セキュリティの観点からは&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重要&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cb65fbb9fdbacb8813819ce6fe844531bf67c562" translate="yes" xml:space="preserve">
          <source>And that function may have some differences in behavior, dependent on the DBMS and version.  (A shout out to all you Java developers so keen on being able to use any database engine interchangeably.)</source>
          <target state="translated">そして、その関数は、DBMSとバージョンに依存して、動作にいくつかの違いがあるかもしれません。(どのデータベースエンジンも互換性を持って使えるようにしたいと考えているJava開発者の皆さんへの感謝の意を込めて)。</target>
        </trans-unit>
        <trans-unit id="e7647df632ba6a5ad2e75cfdb6f974350f2e7424" translate="yes" xml:space="preserve">
          <source>And the function:</source>
          <target state="translated">そして、機能です。</target>
        </trans-unit>
        <trans-unit id="cccf532bbfa1429eb9f3289f7400d714e8a760fa" translate="yes" xml:space="preserve">
          <source>Another possible solution is instead of passing a variable number of arguments to a stored procedure, pass a single string containing the names you're after, but make them unique by surrounding them with '&amp;lt;&amp;gt;'. Then use PATINDEX to find the names:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;別の可能な解決策は、ストアドプロシージャに可変数の引数を渡す代わりに、後の名前を含む単一の文字列を渡すが、それらを '&amp;lt;&amp;gt;'で囲むことによって一意にすることです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次に、PATINDEXを使用して名前を検索します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03d0b83415d956ac04c59f569a6227895ab74272" translate="yes" xml:space="preserve">
          <source>Anyway, if you run this in the highly recommended &lt;a href=&quot;http://www.linqpad.net/&quot;&gt;LINQPad&lt;/a&gt;, and run this query, you can view the actual SQL that the SQL LINQ provider generated. It'll show you each of the values getting parameterized into an &lt;code&gt;IN&lt;/code&gt; clause.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;とにかく、これを強く推奨されている&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.linqpad.net/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LINQPad&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で実行し、このクエリを実行すると、SQL LINQプロバイダーが生成した実際のSQLを表示できます。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;IN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;句に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パラメーター化された各値が表示されます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="23b01d595f6060073511290535fff818b9114f31" translate="yes" xml:space="preserve">
          <source>But as soon as I saw it, I immediately saw a potential problem with it, and it's not my nature to let it slide.  I don't mean to be critical of the efforts of others.  I know many developers take their work very personally, because they invest so much into it and they care so much about it.  So please understand, this is not a personal attack.  What I'm identifying here is the type of problem that crops up in production rather than testing.</source>
          <target state="translated">しかし、それを見た途端、すぐに潜在的な問題点が見えてきて、それを見逃すのは私の性分ではありません。他の人の努力を批判しているわけではありません。多くの開発者が自分の仕事を非常に個人的に受け止めていることを知っています。ですから、これは個人的な攻撃ではないことをご理解ください。私がここで明らかにしているのは、テストではなく、制作現場で発生する問題のタイプです。</target>
        </trans-unit>
        <trans-unit id="1f6dc5172459fe319cfcc98bb14b0e0d6d765a74" translate="yes" xml:space="preserve">
          <source>But in terms generalizing this approach, let's also consider the more obscure corner cases, like when the &lt;code&gt;Name&lt;/code&gt; column contains a wildcard character (as recognized by the LIKE predicate.)  The wildcard character I see most commonly used is &lt;code&gt;%&lt;/code&gt; (a percent sign.). So let's deal with that here now, and later go on to other cases.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、このアプローチを一般化する観点から、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;列にワイルドカード文字（LIKE述語で認識される）が含まれている&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合など、よりあいまいなコーナーケースについても考えてみましょう&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。最もよく使用されるワイルドカード文字は&lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（パーセント記号）です。 。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それでは、ここでそれを処理して、後で他のケースに進みましょう。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef0d5d39e697ffe1ba99b0761754afc9c4f40372" translate="yes" xml:space="preserve">
          <source>But that same row will &lt;strong&gt;not&lt;/strong&gt; be returned if the order of the search terms is reversed:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、検索語の順序を逆にすると、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同じ行は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;返され&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ません&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ad02e2300cc6443c140b0ea75769de719b9a2f50" translate="yes" xml:space="preserve">
          <source>But, absent the specialized knowledge and a guarantee, it's important for us to at least consider handling those obscure corner cases, and consider whether the behavior is reasonable and &quot;per the specification&quot;.</source>
          <target state="translated">しかし、専門的な知識や保証がなければ、少なくともそういった曖昧な角のあるケースへの対応を検討し、その動作が合理的で「仕様通り」かどうかを検討することが重要です。</target>
        </trans-unit>
        <trans-unit id="f8eb3248811492e79afeba88e2112b19fd5e3085" translate="yes" xml:space="preserve">
          <source>Cheers.</source>
          <target state="translated">Cheers.</target>
        </trans-unit>
        <trans-unit id="bfee5586db97ea7e6e02b3fe7c5e0b9a70a81809" translate="yes" xml:space="preserve">
          <source>Consider a Name value of &lt;code&gt;'pe%ter'&lt;/code&gt;.  (For the examples here, I use a literal string value in place of the column name.)  A row with a Name value of `'pe%ter' would be returned by a query of the form:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nameの値が&lt;/font&gt;&lt;/font&gt; &lt;code&gt;'pe%ter'&lt;/code&gt; であるとし&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（ここの例では、列名の代わりにリテラル文字列値を使用しています。）Name値が「 'pe％ter'」の行は、次の形式のクエリによって返されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d017cf77fe2c73ed635d1a483b157ec724242736" translate="yes" xml:space="preserve">
          <source>Create a &lt;em&gt;temp table&lt;/em&gt; with one column.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1つの列を持つ&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一時テーブル&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作成し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8136fc8a2e6515b930f0753b1f85b9ddce86d5f8" translate="yes" xml:space="preserve">
          <source>DDL Script:</source>
          <target state="translated">DDLスクリプト。</target>
        </trans-unit>
        <trans-unit id="02a4f4b6de45d5c7489decc7ab589a9afa2cb60e" translate="yes" xml:space="preserve">
          <source>Depending on your goals it might be of use.</source>
          <target state="translated">目標によっては使えるかもしれません。</target>
        </trans-unit>
        <trans-unit id="b2d970495b8509db54eabd95430be025d9b303c2" translate="yes" xml:space="preserve">
          <source>Dynamic SQL, maybe with parameters if testing shows better performance.</source>
          <target state="translated">動的SQLは、テストでより良いパフォーマンスが示された場合には、パラメータを使用することができます。</target>
        </trans-unit>
        <trans-unit id="2c79c2f8fe6cef139b77391f6699a0512a187188" translate="yes" xml:space="preserve">
          <source>Edit:</source>
          <target state="translated">Edit:</target>
        </trans-unit>
        <trans-unit id="9b4f7c19764919f3700623d10af2eaf2e9fd3645" translate="yes" xml:space="preserve">
          <source>Fiddler demo</source>
          <target state="translated">フィドラーのデモ</target>
        </trans-unit>
        <trans-unit id="026dacaafe85baaf736570c8698095c25f19b7af" translate="yes" xml:space="preserve">
          <source>Finding matching pairs of brackets shouldn't be that hard.  It's a little more difficult than handling the occurrences of singleton % and _.  (Note that it's not sufficient to just escape all occurrences of brackets, because a singleton bracket is considered to be a literal, and doesn't need to be escaped. The logic is getting a little fuzzier than I can handle without running more test cases.)</source>
          <target state="translated">一致する大括弧のペアを見つけるのはそれほど難しいことではありません。これは、シングルトン % と_の出現を処理するよりも少し難しいです (シングルトンの括弧はリテラルとみなされ、エスケープする必要がないため、括弧の出現をすべてエスケープするだけでは十分ではないことに注意してください。これ以上テストケースを実行しないと、ロジックが少し曖昧になってきています)。</target>
        </trans-unit>
        <trans-unit id="956bf832223f45c34ec12226533b916e6709dbb5" translate="yes" xml:space="preserve">
          <source>First, you have to create a type</source>
          <target state="translated">まず、型を作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="d676f66cb4ad07fb96444f3511cde73425052bf9" translate="yes" xml:space="preserve">
          <source>For SQL Server 2008, you can use a &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb675163.aspx&quot;&gt;table valued parameter&lt;/a&gt;. It's a bit of work, but it is arguably cleaner than &lt;a href=&quot;https://stackoverflow.com/questions/337704/parameterizing-a-sql-in-clause#337792&quot;&gt;my other method&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008の場合、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb675163.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;テーブル値パラメーターを&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;少し手間はかかりますが&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/337704/parameterizing-a-sql-in-clause#337792&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、他の方法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;よりも間違いなくクリーンです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="227f0d29bb06ad813fae5f94026e2af979d5e192" translate="yes" xml:space="preserve">
          <source>For a variable number of arguments like this the only way I'm aware of is to either generate the SQL explicitly or do something that involves populating a temporary table with the items you want and joining against the temp table.</source>
          <target state="translated">このような可変数の引数の場合、私が知っている唯一の方法は、明示的にSQLを生成するか、一時テーブルに必要な項目を入力して一時テーブルと結合するかのどちらかを行うことです。</target>
        </trans-unit>
        <trans-unit id="fe75486630ba5a7fcd537b56d8939d238184983f" translate="yes" xml:space="preserve">
          <source>For your case anything you do, be it parameterization with a fixed number of items in the list (null if not used), dynamically building the query with or without parameters, or using stored procedures with table valued parameters will not make much of a difference. However, my general recommendations are as follows:</source>
          <target state="translated">あなたのケースでは、リスト内の項目数を固定してパラメータを設定したり(使用しない場合はnull)、パラメータの有無に関わらずクエリを動的に構築したり、テーブル値のパラメータを持つストアドプロシージャを使用したりしても、何をしても大した違いはありません。しかし、私の一般的な推奨事項は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="c849be4c99e78b71f4be145f175e981782cb4a3d" translate="yes" xml:space="preserve">
          <source>Having IN( 'tag1', 'tag2', 'tag1', 'tag1', 'tag1' ) will be easily optimized away by SQL Server. Plus, you get direct index seeks</source>
          <target state="translated">IN('tag1','tag2','tag1','tag1','tag1' )を持つことは、SQL Serverによって簡単に最適化されます。さらに、直接インデックスを求めることができます。</target>
        </trans-unit>
        <trans-unit id="0883a1359a7ef9fb3528dc28cd0c0ad2edfa8b13" translate="yes" xml:space="preserve">
          <source>Here Dapper does the thinking, so you don't have to. Something similar is possible with &lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;LINQ&amp;nbsp;to&amp;nbsp;SQL&lt;/a&gt;, of course:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここではDapperが考えているので、その必要はありません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もちろん、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LINQ to SQLでも&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同様のことが可能&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec20b27947e409494d8b39aff65011bcad68b37c" translate="yes" xml:space="preserve">
          <source>Here is another alternative. Just pass a comma-delimited list as a string parameter to the stored procedure and:</source>
          <target state="translated">もう一つの方法があります。ストアドプロシージャの文字列パラメータとしてカンマ区切りのリストを渡すだけです。</target>
        </trans-unit>
        <trans-unit id="3bef9b813806d919c0ef17520cdcae6d63be6a13" translate="yes" xml:space="preserve">
          <source>Here is another answer to this problem.</source>
          <target state="translated">この問題に対するもう一つの答えがここにあります。</target>
        </trans-unit>
        <trans-unit id="8058dd0239d0ce0f235c473fee26724245a2479d" translate="yes" xml:space="preserve">
          <source>Here is the code for the UDF &lt;em&gt;(I got it from Stack Overflow somewhere, i can't find the source right now)&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これが&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; UDFのコードです&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（Stack Overflowから入手したので、現在ソースを見つけることができません）。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d9c357ac321a2c270d39faa0087485f24d73d7b" translate="yes" xml:space="preserve">
          <source>Here is the split function I use.</source>
          <target state="translated">私が使っているスプリット関数はこんな感じです。</target>
        </trans-unit>
        <trans-unit id="31b408cd5989d3b3a9e85be52bf44f860e81198e" translate="yes" xml:space="preserve">
          <source>Here's a quick-and-dirty technique I have used:</source>
          <target state="translated">私が使った手っ取り早いテクニックをご紹介します。</target>
        </trans-unit>
        <trans-unit id="450492771c56d95cbcd05fb281ef0131265e08c9" translate="yes" xml:space="preserve">
          <source>Here's a technique that recreates a local table to be used in a query string. Doing it this way eliminates all parsing problems.</source>
          <target state="translated">ここでは、クエリ文字列で使用するローカルテーブルを再作成するテクニックを紹介します。この方法で行うと、パースの問題がすべて解消されます。</target>
        </trans-unit>
        <trans-unit id="e6ad03598d810f4f2eebf49dfe172e701f6b4e08" translate="yes" xml:space="preserve">
          <source>Here's the CTE version.</source>
          <target state="translated">CTE版はこちらです。</target>
        </trans-unit>
        <trans-unit id="bc4f98564ef32ef0f8fb6179097d52a7744bb920" translate="yes" xml:space="preserve">
          <source>How do I parameterize a query containing an &lt;code&gt;IN&lt;/code&gt; clause with a variable number of arguments, like this one?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このように、引数の数が可変の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;IN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;句を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;含むクエリをパラメーター化するにはどうすればよい&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ですか？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bb54217d9c4d37d19fb2185c0c208e0cb24405d" translate="yes" xml:space="preserve">
          <source>I believe others have already sufficiently pointed out some of the other commonly considered areas of concern:</source>
          <target state="translated">他の一般的に考えられる懸念事項については、既に他の方も十分に指摘されていると思います。</target>
        </trans-unit>
        <trans-unit id="e7734598a6d1c2cfa95be739746a7afb394b36a1" translate="yes" xml:space="preserve">
          <source>I have also seen stored procedures that had 500 parameters with default values of null, and having WHERE Column1 IN (@Param1, @Param2, @Param3, ..., @Param500). This caused SQL to build a temp table, do a sort/distinct, and then do a table scan instead of an index seek. That is essentially what you would be doing by parameterizing that query, although on a small enough scale that it won't make a noticeable difference. I highly recommend against having NULL in your IN lists, as if that gets changed to a NOT IN it will not act as intended. You could dynamically build the parameter list, but the only obvious thing that you would gain is that the objects would escape the single quotes for you. That approach is also slightly slower on the application end since the objects have to parse the query to find the parameters. It may or may not be faster on SQL, as parameterized queries call sp_prepare, sp_execute for as many times you execute the query, followed by sp_unprepare.</source>
          <target state="translated">また、500個のパラメータがデフォルト値のNULLで、WHERE Column1 IN (@Param1,@Param2,@Param3,...,@Param500)を持つストアド プロシージャを見たことがあります。これにより、SQL は一時テーブルを作成し、ソートディスティンクトを行い、インデックスシークではなくテーブルスキャンを行うようになりました。これは本質的には、クエリをパラメータ化することで行っていることと同じですが、規模が小さいので目立った違いはありません。INリストにNULLを入れないことを強くお勧めします。パラメータリストを動的に構築することもできますが、唯一の明白なことは、オブジェクトがシングルクォートをエスケープしてくれることです。この方法は、オブジェクトがパラメータを見つけるためにクエリを解析しなければならないので、アプリケーション側では少し遅くなります。パラメタ化されたクエリは、クエリを何回実行しても sp_prepare,sp_execute をコールし、その後 sp_unprepare をコールするからです。</target>
        </trans-unit>
        <trans-unit id="d82e71ada8a62159ea70852009714bf5aa14c66d" translate="yes" xml:space="preserve">
          <source>I have an answer that doesn't require a UDF, XML
Because IN accepts a select statement
e.g. SELECT * FROM Test where Data IN (SELECT Value FROM TABLE)</source>
          <target state="translated">私はUDFを必要としない答えを持っている、XMLはINがSELECT文を受け入れるので、例えばSELECT*FROM Testは、データIN(SELECT値FROM TABLE)を受け入れる</target>
        </trans-unit>
        <trans-unit id="2180e8cc79db8111713b3a38b9273505d784397f" translate="yes" xml:space="preserve">
          <source>I have seen the split functions take longer to execute than the query themselves in many cases where the parameters get large. A stored procedure with table valued parameters in SQL 2008 is the only other option I would consider, although this will probably be slower in your case. TVP will probably only be faster for large lists if you are searching on the primary key of the TVP, because SQL will build a temporary table for the list anyway (if the list is large). You won't know for sure unless you test it.</source>
          <target state="translated">私は、パラメータが大きくなるような場合には、スプリット関数の実行時間がクエリ自体よりも長くなるのを見たことがあります。SQL 2008では、テーブルに値を設定したパラメータを持つストアドプロシージャが唯一の選択肢となります。TVPは、TVPの主キーで検索している場合にのみ、おそらく大きなリストの場合に高速になるでしょう。テストしてみないと確かなことはわかりません。</target>
        </trans-unit>
        <trans-unit id="e2d5c5e674c7b6a4cb6b4676422df0cbb9e45827" translate="yes" xml:space="preserve">
          <source>I heard Jeff/Joel talk about this on the podcast today (&lt;em&gt;&lt;a href=&quot;http://itc.conversationsnetwork.org/audio/download/ITC.SO-Episode34-2008.12.16.mp3&quot;&gt;episode 34&lt;/a&gt;&lt;/em&gt;, 2008-12-16 (MP3, 31&amp;nbsp;MB), 1 h 03 min 38 secs - 1 h 06 min 45 secs), and I thought I recalled Stack&amp;nbsp;Overflow was using &lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;LINQ&amp;nbsp;to&amp;nbsp;SQL&lt;/a&gt;, but maybe it was ditched. Here's the same thing in LINQ&amp;nbsp;to&amp;nbsp;SQL.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;今日、ジェフ/ジョエルがポッドキャストでこれについて話しているのを聞きました（&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;http://itc.conversationsnetwork.org/audio/download/ITC.SO-Episode34-2008.12.16.mp3&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;エピソード&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 34、2008-12-16（MP3、31 MB）、1時間03分38秒-1時間06分45秒）。スタックオーバーフローを思い出したと思いました&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LINQ to SQL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ていましたが、破棄された可能性があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、LINQ to SQLでも同じです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68e1d98c1bde1a441a049af1b527a7799aebbbe2" translate="yes" xml:space="preserve">
          <source>I like Joel Spolsky's approach.  It's clever.  And it works.</source>
          <target state="translated">ジョエル・スポルスキーのアプローチが好きです。巧妙だし うまくいってる</target>
        </trans-unit>
        <trans-unit id="10c3a107dda505aa2f5d453923b47dd798c81981" translate="yes" xml:space="preserve">
          <source>I never got around to profiling exactly how &lt;em&gt;fast&lt;/em&gt; it was, but in my situation it was needed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それが&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;どれほど&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;速い&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;かを正確にプロファイリングすることはできませんでした&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が、私の状況ではそれが必要でした。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="82c8befdd145dc1a6bf86c2be33fbcb496ad3fd6" translate="yes" xml:space="preserve">
          <source>I prefer this approach to escaping because it works in Oracle and MySQL as well as SQL Server.  (I usually use the \ backslash as the escape character, since that's the character we use in regular expressions. But why be constrained by convention!</source>
          <target state="translated">このアプローチは、SQL Serverだけでなく、OracleやMySQLでも動作するので、私はエスケープよりもこのアプローチの方が好きです。(私は通常、エスケープ文字としてバックスラッシュを使用しています。しかし、なぜ慣習に縛られているのでしょうか!</target>
        </trans-unit>
        <trans-unit id="af4243377878f11b07ae3404abe46df5a7ff9d2a" translate="yes" xml:space="preserve">
          <source>I think this is a case when a static query is just not the way to go. Dynamically build the list for your in clause, escape your single quotes, and dynamically build SQL. In this case you probably won't see much of a difference with any method due to the small list, but the most efficient method really is to send the SQL exactly as it is written in your post. I think it is a good habit to write it the most efficient way, rather than to do what makes the prettiest code, or consider it bad practice to dynamically build SQL.</source>
          <target state="translated">これは、静的なクエリを使用することが適切ではない場合だと思います。in節のリストを動的に構築し、シングルクォーテーションをエスケープし、SQLを動的に構築します。この場合、リストが小さいので、どの方法を使ってもあまり違いはわからないと思いますが、本当に最も効率的な方法は、投稿に書いてある通りにSQLを送ることです。一番きれいなコードを作るために何かをするとか、SQLを動的にビルドするのは悪い習慣だと考えるよりも、一番効率的な方法で書くのが良い習慣だと思います。</target>
        </trans-unit>
        <trans-unit id="470eb3bd8dc8f9275680a731f7a00e1369b18132" translate="yes" xml:space="preserve">
          <source>I use a more concise version &lt;a href=&quot;https://stackoverflow.com/a/337792/16587&quot;&gt;of the top voted answer&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/337792/16587&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はトップ投票の回答の&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;より簡潔なバージョンを使用してい&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77c29b34770822e532945f81b425ab2daa5931cd" translate="yes" xml:space="preserve">
          <source>I would pass a table type parameter (since it's &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;SQL Server 2008&lt;/a&gt;), and do a &lt;code&gt;where exists&lt;/code&gt;, or inner join. You may also use XML, using &lt;code&gt;sp_xml_preparedocument&lt;/code&gt;, and then even index that temporary table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008であるため&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;テーブル型パラメーターを渡し、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;where exists&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または内部結合を実行します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sp_xml_preparedocument&lt;/code&gt; を&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用してXMLを使用し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、その一時テーブルにインデックス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;付ける&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;こともできます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38e00a81ddf5f6fe0b6b36105aa8782ef2784f85" translate="yes" xml:space="preserve">
          <source>I would prefer not to use a dedicated stored procedure for this (or XML), but if there is some elegant way specific to &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;SQL Server 2008&lt;/a&gt;, I am open to that.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これ（またはXML）に専用のストアドプロシージャを使用したくないのですが、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008に&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;固有のエレガントな方法がある場合は、それを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;受け入れます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d99406eb70ce3918021a57f108a598c46ca958e8" translate="yes" xml:space="preserve">
          <source>I'd approach this by default with passing a table valued function (that returns a table from a string) to the IN condition.</source>
          <target state="translated">私なら、デフォルトではIN条件にテーブル値関数(文字列からテーブルを返す)を渡してアプローチします。</target>
        </trans-unit>
        <trans-unit id="358e1888dd9c3dc6a6d8b8f74729dc1edef55c23" translate="yes" xml:space="preserve">
          <source>If needed you can insert it into a temp table, index it, then run a join...</source>
          <target state="translated">必要に応じて、一時テーブルに挿入し、インデックスを作成し、結合を実行することができます...</target>
        </trans-unit>
        <trans-unit id="1be3fb0e541f55904b67a0c3a768429469841e69" translate="yes" xml:space="preserve">
          <source>If we have strings stored inside the IN clause with the comma(,) delimited, we can use the charindex function to get the values. If you use .NET, then you can map with SqlParameters.</source>
          <target state="translated">カンマ(,)で区切られたIN句の中に文字列が格納されている場合、charindex関数を使用して値を取得することができます。.NETを使用している場合は、SqlParametersでマッピングすることができます。</target>
        </trans-unit>
        <trans-unit id="c1a9ec97b4d93a4f86712c4f1a87de838971feee" translate="yes" xml:space="preserve">
          <source>If you are calling from .NET, you could use &lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;Dapper dot net&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.NETから呼び出す場合は、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dapper dot netを&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dd00bd710d5c5d138e7a5c14fe395b67a569d86e" translate="yes" xml:space="preserve">
          <source>If you have enough RAM, I'd expect SQL&amp;nbsp;Server would probably cache a plan for the common counts of parameters as well. I suppose you could always add five parameters, and let the unspecified tags be NULL - the query plan should be the same, but it seems pretty ugly to me and I'm not sure that it'd worth the micro-optimization (although, on Stack&amp;nbsp;Overflow - it may very well be worth it).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;RAMが十分にある場合、SQL Serverはおそらくパラメーターの一般的なカウントのプランもキャッシュすることになると思います。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;常に5つのパラメーターを追加し、未指定のタグをNULLにすることができると思います。クエリプランは同じである必要がありますが、私にはかなり醜く思え、マイクロ最適化の価値があるかどうかはわかりません（ただし、 Stack Overflow-それはそれだけの価値があるかもしれません）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="13efe4ce5cd750e79baf7a01290267049374c466" translate="yes" xml:space="preserve">
          <source>If you're really interested in performance and don't want to iterate through the loop twice, here's a less beautiful version:</source>
          <target state="translated">本当にパフォーマンスに興味があって、ループを2回繰り返したくないのであれば、ここではあまり美しくないバージョンをご紹介します。</target>
        </trans-unit>
        <trans-unit id="0c540b5e6699b2c7b611bcf7af1cd074053d21fd" translate="yes" xml:space="preserve">
          <source>If you're unlucky enough to be stuck on &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2005&quot;&gt;SQL Server 2005&lt;/a&gt; you could add a &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Language_Runtime&quot;&gt;CLR&lt;/a&gt; function like this,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2005&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2005に&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;行き詰まるほど運が悪い場合は、次の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ような&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Language_Runtime&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CLR&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;追加できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2f991e2ce21fbc2b508a3faff72c5094821362eb" translate="yes" xml:space="preserve">
          <source>If you've got &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;SQL Server 2008&lt;/a&gt; or later I'd use a &lt;a href=&quot;https://stackoverflow.com/questions/5595353/how-to-pass-table-value-parameters-to-stored-procedure-from-net-code&quot;&gt;Table Valued Parameter&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あなたが持っている場合は&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008の&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以降を私が使用したい&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/5595353/how-to-pass-table-value-parameters-to-stored-procedure-from-net-code&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パラメータの大切な表を&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b26bb26a3dff833054084925292a26c85610a666" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://en.wikipedia.org/wiki/ColdFusion&quot;&gt;ColdFusion&lt;/a&gt; we just do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/ColdFusion&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ColdFusionの&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私達はちょうど行います。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae0b31a603e2cadba5386706372b442225ace3da" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SQL Server 2016+&lt;/code&gt; you could use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/mt684588.aspx&quot;&gt;&lt;code&gt;STRING_SPLIT&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;では&lt;/font&gt;&lt;/font&gt; &lt;code&gt;SQL Server 2016+&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;あなたは使用することができ&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/mt684588.aspx&quot;&gt; &lt;code&gt;STRING_SPLIT&lt;/code&gt; の&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;機能を：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77792ff8ecdb0ffcc2759ed0fc092e6107edf5e4" translate="yes" xml:space="preserve">
          <source>In SQL Server 2016+ another possibility is to use the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn921879.aspx&quot;&gt;&lt;code&gt;OPENJSON&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2016以降では、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn921879.aspx&quot;&gt; &lt;code&gt;OPENJSON&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用することも&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9f1f4abb84eb41057375a32c3581100f5fffce9" translate="yes" xml:space="preserve">
          <source>In my opinion, the best source to solve this problem, is what has been posted on this site:</source>
          <target state="translated">私の考えでは、この問題を解決するための最良のソースは、このサイトに掲載されているものです。</target>
        </trans-unit>
        <trans-unit id="d01a0b1abba0430fb1dfbb704c154c9812f0edb7" translate="yes" xml:space="preserve">
          <source>In the C# code you do something like this:</source>
          <target state="translated">C#のコードでは、次のようなことをします。</target>
        </trans-unit>
        <trans-unit id="5dad346a862dade5a2ce260292058579877f3e81" translate="yes" xml:space="preserve">
          <source>In the SQL you have a clause like this:</source>
          <target state="translated">SQLでは、このような句があります。</target>
        </trans-unit>
        <trans-unit id="c9ac14f5f553dbf81735a238c4aec23e0f9b9b3d" translate="yes" xml:space="preserve">
          <source>In this query, the number of arguments could be anywhere from 1 to 5.</source>
          <target state="translated">このクエリでは、引数の数は1から5のいずれかになります。</target>
        </trans-unit>
        <trans-unit id="1ccc36caa6c571f60a777db830b24b1bd0152f89" translate="yes" xml:space="preserve">
          <source>Injection concerns aside, take care to note that constructing the command text to accomodate a variable number of parameters (as above) impede's SQL server's ability to take advantage of cached queries. The net result is that you almost certainly lose the value of using parameters in the first place (as opposed to merely inserting the predicate strings into the SQL itself).</source>
          <target state="translated">インジェクションの懸念はさておき、(上記のように)可変数のパラメータに対応するようにコマンドテキストを作成すると、SQLサーバがキャッシュされたクエリを利用する能力を阻害することに注意してください。その結果、(単にSQL自体に述語の文字列を挿入するのとは対照的に)そもそもパラメータを使用することの価値をほぼ確実に失うことになります。</target>
        </trans-unit>
        <trans-unit id="cfe8f3b2b9656fa087b047b0c76f57d8888a9b38" translate="yes" xml:space="preserve">
          <source>Instead of using an &lt;code&gt;IN&lt;/code&gt;, you can then just use your standard &lt;code&gt;JOIN&lt;/code&gt; rules. ( Flexibility++ )</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;IN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用する代わりに&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、標準の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;JOIN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ルールを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（柔軟性++）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6531c8cd756afd65aa968ac013e26ebeae12e8e9" translate="yes" xml:space="preserve">
          <source>It almost goes without saying that we might not want &lt;code&gt;pe%ter&lt;/code&gt; to match peanut butter, no matter how much he likes it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;pe%ter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;pe％ter&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;がピーナッツバターとどれだけ好きでも、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;pe％ter&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;をマッチさ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;せたくないかもしれません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a8aa17b73c9976e345417d180c7b625a957911aa" translate="yes" xml:space="preserve">
          <source>It does loop through the tag parameters twice; but that doesn't matter most of the time (it won't be your bottleneck; if it is, unroll the loop).</source>
          <target state="translated">タグのパラメータを2回ループしますが、ほとんどの場合は問題になりません(ボトルネックにはなりません。</target>
        </trans-unit>
        <trans-unit id="4b7b04c75db0a99e0f8a75786d727c9a060cda70" translate="yes" xml:space="preserve">
          <source>Joel Spolsky's approach is clever.  And it works reasonably, it's going to exhibit predictable behavior and predictable performance, given &quot;normal&quot; values, and with the normative edge cases, such as NULL and the empty string.  And it may be sufficient for a particular application.</source>
          <target state="translated">ジョエル・スポルスキーのアプローチは賢い。そして、それは合理的に動作します。&quot;通常の &quot;値を与えられ、NULLや空文字列のような通常のエッジケースで、予測可能な動作と予測可能な性能を発揮します。そして、それは特定のアプリケーションには十分かもしれません。</target>
        </trans-unit>
        <trans-unit id="ef078c7764d0dfe131b3ce83b313bd5d0f32a413" translate="yes" xml:space="preserve">
          <source>Let me state right here, that this is &lt;strong&gt;not an answer&lt;/strong&gt; to the original question.  There are already some demonstrations of that in other good answers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここで、これは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;元の質問&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;に対する答えで&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ない&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことを述べて&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;おきます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他の良い答えには、すでにいくつかの実証があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac08ba80594a0659efb8968aea37e16a79e71676" translate="yes" xml:space="preserve">
          <source>Make sure you don't have any &lt;code&gt;|&lt;/code&gt;, blank, or null tags or this won't work</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ないことを確認してください&lt;/font&gt;&lt;/font&gt; &lt;code&gt;|&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、空白、またはnullタグ、またはこれは機能しません&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4c8a0f32fd7f5b545c1fc32faeff3a3ddeb8716" translate="yes" xml:space="preserve">
          <source>May be we can use XML here:</source>
          <target state="translated">ここではXMLが使えるかもしれません。</target>
        </trans-unit>
        <trans-unit id="cc703fb9e22b2d4125214daa80ed8744a1971657" translate="yes" xml:space="preserve">
          <source>No infinite variability for you.  Only finite variability.</source>
          <target state="translated">あなたには無限の変動性はありません。唯一の有限の変動性。</target>
        </trans-unit>
        <trans-unit id="b17bd2c4be5e9e38316d4ca5e4bba27b293c90cd" translate="yes" xml:space="preserve">
          <source>No, this is not open to &lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL injection&lt;/a&gt;. The only injected text into CommandText is not based on user input. It's solely based on the hardcoded &quot;@tag&quot; prefix, and the index of an array. The index will &lt;em&gt;always&lt;/em&gt; be an integer, is not user generated, and is safe.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;いいえ、これは&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQLインジェクションに&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は対応していません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CommandTextに挿入される唯一のテキストは、ユーザー入力に基づいていません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、ハードコードされた &quot;@tag&quot;プレフィックスと配列のインデックスのみに基づいています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インデックスは&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;常に&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;整数であり、ユーザー生成ではなく、安全です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81f8d03283d9b4204147b22834f1cd053335add0" translate="yes" xml:space="preserve">
          <source>Not that cached query plans aren't valuable, but IMO this query isn't nearly complicated enough to see much benefit from it. While the compilation costs may approach (or even exceed) the execution costs, you're still talking milliseconds.</source>
          <target state="translated">キャッシュされたクエリプランが価値がないというわけではありませんが、 IMOではこのクエリはその恩恵を受けられるほど複雑ではありません。コンパイルコストは実行コストに近づくかもしれませんが(あるいはそれを超えるかもしれません)、それでもまだミリ秒単位の話です。</target>
        </trans-unit>
        <trans-unit id="a039ae3772c1ef49d778f9f8c4b67934ff2c1fc3" translate="yes" xml:space="preserve">
          <source>Now that we're on a roll, we can add another &lt;code&gt;REPLACE&lt;/code&gt; handle the underscore wildcard.   And just for fun, this time, we'll use $ as the escape character.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;さあ、ロール&lt;/font&gt;&lt;/font&gt; &lt;code&gt;REPLACE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;なりました。アンダースコアワイルドカードを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;別の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;REPLACE&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハンドルで&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;追加でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そして、面白さのために、今回はエスケープ文字として$を使用します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01625438b5c7959ea81cd00f7a3084a534d6307d" translate="yes" xml:space="preserve">
          <source>Now we can match the literal %.  Of course, when we have a column name, we're going to need to dynamically escape the wildcard.  We can use the &lt;code&gt;REPLACE&lt;/code&gt; function to find occurrences of the &lt;code&gt;%&lt;/code&gt;character and insert a backslash character in front of each one, like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これで、リテラル％を照合できます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;もちろん、列名がある場合、ワイルドカードを動的にエスケープする必要があります。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;REPLACE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関数を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用して&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文字の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;出現&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;箇所&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を検索し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、次のようにそれぞれの前にバックスラッシュ文字を挿入できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6998781be11fbddbbca54848518598754741b9b1" translate="yes" xml:space="preserve">
          <source>Okay, so, if we don't handle that as an inline expression in the SQL, the closest alternative we have is a user defined function.  And we know that won't speed things up any (unless we can define an index on it, like we could with Oracle.)  If we've got to create a function, we might better do that in the code that calls the SQL statement.</source>
          <target state="translated">SQLのインライン式として処理しない場合、最も近い代替案はユーザ定義の関数です。関数を作成しなければならない場合は、SQL文を呼び出すコードの中でそれを行う方が良いかもしれません。</target>
        </trans-unit>
        <trans-unit id="b73b20450025066dadaf1b5da5e8b07536a277f8" translate="yes" xml:space="preserve">
          <source>Once you got this your code would be as simple as this:</source>
          <target state="translated">これを手に入れれば、あなたのコードは次のように簡単になります。</target>
        </trans-unit>
        <trans-unit id="2cd8064f013da44c7a421743d1d148268bb442b0" translate="yes" xml:space="preserve">
          <source>One approach to patching this hole is to escape the &lt;code&gt;%&lt;/code&gt; wildcard character.  (For anyone not familiar with the escape clause on the operator, here's a link to the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa933232(SQL.80).aspx&quot;&gt;SQL Server documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このホールにパッチを適用する1つの方法は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ワイルドカード文字&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;をエスケープすること&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（演算子のエスケープ句に慣れていない人のために、ここに&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa933232(SQL.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Serverのドキュメント&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;へのリンクがあり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d785d1b371bf1e0d416a3c1cf4b58af9de8c0682" translate="yes" xml:space="preserve">
          <source>Parameterize an SQL IN clause</source>
          <target state="translated">SQL IN 句をパラメータ化する</target>
        </trans-unit>
        <trans-unit id="8bd73e8b6032d828eaae575e172d15ae190e9acc" translate="yes" xml:space="preserve">
          <source>Related: &lt;a href=&quot;https://www.brentozar.com/archive/2020/02/how-to-pass-a-list-of-values-into-a-stored-procedure/&quot;&gt;How to Pass a List of Values Into a Stored Procedure&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;関連：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.brentozar.com/archive/2020/02/how-to-pass-a-list-of-values-into-a-stored-procedure/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値の一覧をストアドプロシージャに渡す方法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7c790d520ea0368c427f57e2c38a9f1b62f724a" translate="yes" xml:space="preserve">
          <source>SQL Server also allows for wildcard characters to be treated as literals by enclosing them in brackets &lt;code&gt;[]&lt;/code&gt;.  So we're not done fixing yet, at least for SQL Server.  Since pairs of brackets have special meaning, we'll need to escape those as well.  If we manage to properly escape the brackets, then at least we won't have to bother with the hyphen &lt;code&gt;-&lt;/code&gt; and the carat &lt;code&gt;^&lt;/code&gt; within the brackets.  And we can leave any &lt;code&gt;%&lt;/code&gt;and &lt;code&gt;_&lt;/code&gt; characters inside the brackets escaped, since we'll have basically disabled the special meaning of the brackets.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Serverでは、ワイルドカード文字を角かっこ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で囲むことにより、それらをリテラルとして扱うこともできます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、少なくともSQL Serverでは、まだ修正は完了していません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブラケットのペアには特別な意味があるため、それらもエスケープする必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我々は適切に括弧をエスケープするために管理する場合は、少なくとも我々はハイフンを気にする必要はありません&lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;とカラット&lt;/font&gt;&lt;/font&gt; &lt;code&gt;^&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;カッコ内。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、角括弧内の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;および&lt;/font&gt;&lt;/font&gt; &lt;code&gt;_&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文字はエスケープした&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ままにすることができ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。これは、角括弧の特別な意味を基本的に無効にしているためです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf5871ddbc56fc0f2c14226259e67209782850cc" translate="yes" xml:space="preserve">
          <source>SQL with dynamic parameters.</source>
          <target state="translated">動的なパラメータを持つSQL。</target>
        </trans-unit>
        <trans-unit id="b34e6d11a266a89b525b0c300696a7d0682681bf" translate="yes" xml:space="preserve">
          <source>See the answer from Mark Brackett for the preferred answer that I (and 231 others) upvoted. The approach given in his answer allows 1) for effective use of bind variables, and 2) for predicates that are sargable.</source>
          <target state="translated">私(と他の231人)がupvotedした好ましい回答については、Mark Brackettの回答を参照してください。彼の回答で与えられたアプローチでは、1)バインド変数を効果的に使用することができ、2)サーガブルな述語を使用することができます。</target>
        </trans-unit>
        <trans-unit id="178bfb059f4a1822cfbe2ec9ebe2c39718e33adf" translate="yes" xml:space="preserve">
          <source>So basically if the count is 0 then there is no filter and everything goes through.  If the count is higher than 0 the then the value must be in the list, but the list has been padded out to five with impossible values (so that the SQL still makes sense)</source>
          <target state="translated">つまり、基本的にはカウント数が0の場合はフィルタは存在せず、すべてが通過します。もしカウントが0よりも高ければ、その値はリストの中にあるはずですが、リストは不可能な値で5つの値が追加されています(SQLがまだ意味を持つように)。</target>
        </trans-unit>
        <trans-unit id="30f329f8fb37cb3f59749389eca8fa0f6f4ac58d" translate="yes" xml:space="preserve">
          <source>So here's the C# code:</source>
          <target state="translated">というわけで、C#のコードはこんな感じです。</target>
        </trans-unit>
        <trans-unit id="01e03d9a83d6e670a41622f3b700936b34789926" translate="yes" xml:space="preserve">
          <source>So that solves the problem with the % wildcard.  Almost.</source>
          <target state="translated">これで % ワイルドカードの問題が解決しました。ほとんどね。</target>
        </trans-unit>
        <trans-unit id="bc224aea5e1e203f177bffceb162be21609d9157" translate="yes" xml:space="preserve">
          <source>So you have the string</source>
          <target state="translated">ということは、文字列があるんですね。</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="ac1dd42bff5436684704cd8cecb553fb4a51748f" translate="yes" xml:space="preserve">
          <source>Sometimes the lame solution is the only one that actually works.</source>
          <target state="translated">ダサい解決策が、実際に効果を発揮することもあります。</target>
        </trans-unit>
        <trans-unit id="2187e96ff77893224d6a4fbd66eeac75a0523097" translate="yes" xml:space="preserve">
          <source>Stored procedure with table valued parameters. If the list can vary by a large amount use WITH RECOMPILE on the stored procedure, or simply use dynamic SQL without parameters to generate a new execution plan for each query.</source>
          <target state="translated">テーブル値のパラメータを持つストアドプロシージャ。リストが大量に変化する場合は、ストアドプロシージャでWITH RECOMPILEを使用するか、パラメータなしの動的SQLを使用して、各クエリごとに新しい実行計画を生成します。</target>
        </trans-unit>
        <trans-unit id="49b0933c48745bbe595589a84f3c999c1aac15aa" translate="yes" xml:space="preserve">
          <source>Syscomments. Dinakar Nethi</source>
          <target state="translated">システムコメント。ディナカーネチ</target>
        </trans-unit>
        <trans-unit id="f56c9210a9e2c9a6ed7f60b0c1718d038683158e" translate="yes" xml:space="preserve">
          <source>T-SQL:</source>
          <target state="translated">T-SQL:</target>
        </trans-unit>
        <trans-unit id="e03134a806a1e31e6209b7319743bf47eb301543" translate="yes" xml:space="preserve">
          <source>That inline expression in the SQL is getting longer and uglier.  We can probably make it work, but heaven help the poor soul that comes behind and has to decipher it.  As much of a fan I am for inline expressions, I'm inclined not use one here, mainly because I don't want to have to leave a comment explaining the reason for the mess, and apologizing for it.</source>
          <target state="translated">SQLのインライン式が長くなって醜くなってきています。おそらくうまくいくと思いますが、後から来てそれを解読しなければならない哀れな魂を天が助けてくれます。私はインライン式のファンですが、ここではインライン式を使わないようにしたいと思っています。</target>
        </trans-unit>
        <trans-unit id="0ccc088929d1deebf84e0a4fa97b04fa55774e0d" translate="yes" xml:space="preserve">
          <source>That's it. And, yes, LINQ already looks backwards enough, but the &lt;code&gt;Contains&lt;/code&gt; clause seems extra backwards to me. When I had to do a similar query for a project at work, I naturally tried to do this the wrong way by doing a join between the local array and the SQL Server table, figuring the LINQ&amp;nbsp;to&amp;nbsp;SQL translator would be smart enough to handle the translation somehow. It didn't, but it did provide an error message that was descriptive and pointed me towards using &lt;em&gt;Contains&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それでおしまい。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そして、はい、LINQは既に十分に後方を向いていますが、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Contains&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;句は私には後方に余分に見えます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作業中のプロジェクトに対して同様のクエリを実行する必要があったとき、ローカル配列とSQL Serverテーブルの間の結合を行うことにより、これを間違った方法で自然に実行しようとしました。LINQto SQLトランスレーターは、なんとか翻訳。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それはしませんでしたが、それは説明的で、私に&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Contains&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用するように指示するエラーメッセージを提供しました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8ff37281903edcab5bee93dfd2354fea3795197" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/337817/5070879&quot;&gt;accepted answer&lt;/a&gt; will of course work and it is one of the way to go, but it is anti-pattern.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/337817/5070879&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;受け入れ答えの&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コースワークの意志とそれが進むべき道の一つであるが、それはアンチパターンです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8eba07cdda4ea60d10a9bebc962b106ed7a8920a" translate="yes" xml:space="preserve">
          <source>The Oracle version:</source>
          <target state="translated">オラクル版。</target>
        </trans-unit>
        <trans-unit id="9d1745ae6f89bcb6009c23298fa1e007d88d88a9" translate="yes" xml:space="preserve">
          <source>The behavior we observe is kind of odd.  Changing the order of the search terms in the list changes the result set.</source>
          <target state="translated">私たちが観察している動作は、ちょっと奇妙なものです。リスト内の検索語の順序を変更すると、結果セットが変化します。</target>
        </trans-unit>
        <trans-unit id="5476b01df6c35abd19c57b5f47c1bc4611a97014" translate="yes" xml:space="preserve">
          <source>The general pattern is easy to extend and can be used for passing more complex tables.</source>
          <target state="translated">一般的なパターンは拡張が容易で、より複雑なテーブルを渡す際に使用することができます。</target>
        </trans-unit>
        <trans-unit id="fa033af9de3767d4d1bb2976f14c8950c3e8c353" translate="yes" xml:space="preserve">
          <source>The only winning move is not to play.</source>
          <target state="translated">唯一の勝ち手は遊ばないことです。</target>
        </trans-unit>
        <trans-unit id="b9583a9b4dce8989dd711d081c33d9ffd91c7a42" translate="yes" xml:space="preserve">
          <source>The original question was &lt;strong&gt;&quot;How do I parameterize a query ...&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;元の質問は&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「クエリをパラメータ化するにはどうすればよいですか...」&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;でした&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="66954bd1bf64a819018f1c94116a783f1d835163" translate="yes" xml:space="preserve">
          <source>The performance is terrible. &lt;code&gt;LIKE &quot;%...%&quot;&lt;/code&gt; queries are not indexed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;パフォーマンスはひどい。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;LIKE &quot;%...%&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クエリはインデックス付けされません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c595b1a23d029415bc9530e69c56a7bf52a907e6" translate="yes" xml:space="preserve">
          <source>The proper way IMHO is to store the list in a character string (limited in length by what the DBMS support); the only trick is that (in order to simplify processing) I have a separator (a comma in my example) at the beginning and at the end of the string. The idea is to &quot;normalize on the fly&quot;, turning the list into a one-column table that contains one row per value. This allows you to turn</source>
          <target state="translated">唯一のトリックは、(処理を簡単にするために)文字列の先頭と末尾にセパレータ(私の例ではカンマ)をつけることです。これは、「その場で正規化」して、リストを値ごとに1行を含む1列のテーブルにするというものです。これにより</target>
        </trans-unit>
        <trans-unit id="080963f0ce43b16a038ca3c1cafb8009937c4fa2" translate="yes" xml:space="preserve">
          <source>The reuse of execution plans for stored procedures or parameterized queries may give you a performance gain, but it will lock you in to one execution plan determined by the first query that is executed. That may be less than ideal for subsequent queries in many cases. In your case, reuse of execution plans will probably be a plus, but it might not make any difference at all as the example is a really simple query.</source>
          <target state="translated">ストアドプロシージャやパラメータ化されたクエリの実行計画を再利用することでパフォーマンスが向上するかもしれませんが、最初に実行されるクエリによって決定される実行計画に固定されてしまいます。これは多くの場合、後続のクエリにとっては理想的ではないかもしれません。あなたの場合、実行計画の再利用はおそらくプラスになるでしょうが、この例は本当に単純なクエリなので、全く違いはないかもしれません。</target>
        </trans-unit>
        <trans-unit id="a8eb233e5b6e8d0a30d47b4e1de065627dccaad7" translate="yes" xml:space="preserve">
          <source>The string can be built in any language. In this example I used SQL since that was the original problem I was trying to solve. I needed a clean way to pass in table data on the fly in a string to be executed later.</source>
          <target state="translated">文字列は任意の言語で構築することができます。この例では、私が解決しようとしていた元々の問題がSQLだったので、SQLを使用しました。私は、後で実行できるように、テーブルデータを文字列でその場で渡すクリーンな方法を必要としていました。</target>
        </trans-unit>
        <trans-unit id="2a379f85b2c923f924ec4c11add17ee12c66803a" translate="yes" xml:space="preserve">
          <source>The user inputted values are still stuffed into parameters, so there is no vulnerability there.</source>
          <target state="translated">ユーザーが入力した値はまだパラメータに詰め込まれているので、そこに脆弱性はありません。</target>
        </trans-unit>
        <trans-unit id="46a9f25a51ce70904d83b4d2fdcce6438b367f5c" translate="yes" xml:space="preserve">
          <source>The values stored in the column may allow for % or _ characters, but a constraint may require those values to be escaped, perhaps using a defined character, such that the values are LIKE comparison &quot;safe&quot;.  Again, a quick comment about the allowed set of values, and in particular which character is used as an escape character, and go with Joel Spolsky's approach.</source>
          <target state="translated">列に格納されている値は%または_文字を使用できますが、制約により、これらの値をエスケープする必要がある場合があり、おそらく定義された文字を使用して、値がLIKE比較「安全」になるようにします。繰り返しになりますが、許容される値のセット、特にどの文字をエスケープ文字として使用するかについて簡単にコメントし、ジョエル・スポルスキーのアプローチに従ってください。</target>
        </trans-unit>
        <trans-unit id="432f039b6ee44f960eebe9edc61390d464e6ea6f" translate="yes" xml:space="preserve">
          <source>Then all you have to do is pass the string as 1 parameter.</source>
          <target state="translated">あとは文字列を1つのパラメータとして渡せばいいだけです。</target>
        </trans-unit>
        <trans-unit id="caabdeeafa5990eb317cda420543a417692b60d4" translate="yes" xml:space="preserve">
          <source>Then, your ADO.NET code looks like this:</source>
          <target state="translated">すると、あなたのADO.NETのコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="92d757149ae4a77513eaebec2ba6645d7436a4bb" translate="yes" xml:space="preserve">
          <source>There are other ways to accomplish this that some people may consider cleaner, so please keep reading.</source>
          <target state="translated">他にも、人によってはきれいになると思う方法がありますので、ぜひ読み進めてみてください。</target>
        </trans-unit>
        <trans-unit id="4ce52d75168ac74d2698141558de7e48bb776b1d" translate="yes" xml:space="preserve">
          <source>This approach is blogged about in &lt;a href=&quot;http://blogs.msdn.com/b/sqlserverstorageengine/archive/2015/11/03/openjson-one-of-best-ways-to-select-rows-by-list-of-id.aspx&quot;&gt;OPENJSON - one of best ways to select rows by list of ids&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このアプローチについては、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.msdn.com/b/sqlserverstorageengine/archive/2015/11/03/openjson-one-of-best-ways-to-select-rows-by-list-of-id.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;OPENJSONで&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブログで&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;紹介されています&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。これ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、IDのリストによって行を選択する最良の方法の1つです&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="958feb18dbf8f4056efe483472623f67177a7660" translate="yes" xml:space="preserve">
          <source>This can be done with a recursive CTE, or a query with a number table (or Master..spt_value)</source>
          <target state="translated">これは、再帰的なCTE、または数値テーブル(またはMaster.spt_value)を使用したクエリで行うことができます。</target>
        </trans-unit>
        <trans-unit id="08e5e9a6033c33675e7649a6d1cc1cacfea07f45" translate="yes" xml:space="preserve">
          <source>This has a bit of added flexibility in what you can do, but it's more suited for situations where you have a large table to query, with good indexing, and you want to use the parametrized list more than once. Saves having to execute it twice and have all the sanitation done manually.</source>
          <target state="translated">これはできることに少し柔軟性を持たせていますが、クエリを実行するテーブルが大きく、インデックスが良く、パラメトリックリストを複数回使用したい場合に適しています。これを2回実行して、すべてのサニテーションを手動で行う必要がなくなります。</target>
        </trans-unit>
        <trans-unit id="89a375a792ce41774bf8ba73cfe56ee977890de5" translate="yes" xml:space="preserve">
          <source>This is gross, but if you are guaranteed to have at least one, you could do:</source>
          <target state="translated">これはキモいけど、最低でも1本は保証されてるならできるだろ。</target>
        </trans-unit>
        <trans-unit id="e29e488795dec60c287f82fd01f7fc119e047f6e" translate="yes" xml:space="preserve">
          <source>This is possibly a half nasty way of doing it, I used it once, was rather effective.</source>
          <target state="translated">これはもしかしたら中途半端なやり方かもしれませんが、私は一度使ったことがありますが、割と効果がありました。</target>
        </trans-unit>
        <trans-unit id="923766af9d49d6ee8ab01954e13903dc14406c7f" translate="yes" xml:space="preserve">
          <source>This is replacement for common anti-pattern such as creating a dynamic SQL string in application layer or Transact-SQL, or by using LIKE operator:</source>
          <target state="translated">アプリケーション層やTransact-SQLで動的SQL文字列を作成したり、LIKE演算子を使用したりするなど、一般的なアンチパターンを置き換えるものです。</target>
        </trans-unit>
        <trans-unit id="5222b471ee3028d31cfe5f8af34e316502210ba5" translate="yes" xml:space="preserve">
          <source>To improve the &lt;code&gt;STRING_SPLIT&lt;/code&gt; table function row estimation, it is a good idea to materialize splitted values as temporary table/table variable:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;STRING_SPLIT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;テーブル関数の行推定&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を改善するには、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分割&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;された&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値を一時テーブル/テーブル変数として具体化することをお勧めします。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2222e8c9448d0d44594f587bbcbc82c4ad1019e9" translate="yes" xml:space="preserve">
          <source>Two caveats:</source>
          <target state="translated">2つの注意点があります。</target>
        </trans-unit>
        <trans-unit id="5440af73b429739161f6ba1b784dfd0beaa7c95f" translate="yes" xml:space="preserve">
          <source>Unfortunately, the techniques to slice a string are fairly product-specific.
Here is the SQL Server version:</source>
          <target state="translated">残念ながら、文字列をスライスするテクニックはかなり製品固有のものです。こちらがSQL Server版です。</target>
        </trans-unit>
        <trans-unit id="8fdf7787fac70523813d9ee461dc51c98f04f4ec" translate="yes" xml:space="preserve">
          <source>Unless you have a ridiculously long string, this should work well with the table index.</source>
          <target state="translated">とんでもなく長い文字列を持っていない限り、これはテーブルインデックスとうまく機能するはずです。</target>
        </trans-unit>
        <trans-unit id="2443ed13c972cd5cc6bdc47153849869b4ac0910" translate="yes" xml:space="preserve">
          <source>Use the following stored procedure. It uses a custom split function, which can be found &lt;a href=&quot;http://blogs.microsoft.co.il/blogs/itai/archive/2009/02/01/t-sql-split-function.aspx&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次のストアドプロシージャを使用します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここでは、カスタムの分割関数を使用してい&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.microsoft.co.il/blogs/itai/archive/2009/02/01/t-sql-split-function.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="fc4db109b0b74a21e7b65fe2cccd3e5e113eabea" translate="yes" xml:space="preserve">
          <source>Using a user defined type is optional. Creating the type is only created once and can be done ahead of time. Otherwise just add a full table type to the declaration in the string.</source>
          <target state="translated">ユーザー定義の型の使用はオプションです。型の作成は一度だけ行われ、前もって行うことができます。それ以外の場合は、文字列内の宣言に完全なテーブル型を追加するだけです。</target>
        </trans-unit>
        <trans-unit id="ea109569ae92ebf585a2849dd893eef36a9892b4" translate="yes" xml:space="preserve">
          <source>We have function that creates a table variable that you can join to:</source>
          <target state="translated">ジョインできるテーブル変数を作成する関数があります。</target>
        </trans-unit>
        <trans-unit id="360d577f191fc4129da8ba5e7e42f6459f455eea" translate="yes" xml:space="preserve">
          <source>We may have specialized knowledge of the domain for the column, (that is, the set of allowable values enforced for the column.  We may know &lt;em&gt;a priori&lt;/em&gt; that the values stored in the column will never contain a percent sign, an underscore, or bracket pairs.  In that case, we just include a quick comment that those cases are covered.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;列のドメイン（つまり、列に適用される許容値のセット）の専門知識がある場合があります。列に&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;格納された値にパーセント記号、下線、または角かっこが含まれないことを&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;先験的に&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;知って&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;いる&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;その場合、それらのケースがカバーされているという簡単なコメントを含めるだけです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1eb0105114c419b879dc13efdb354bd9c4fdc800" translate="yes" xml:space="preserve">
          <source>We recognize that our solution has introduced another problem.  The escape character.  We see that we're also going to need to escape any occurrences of escape character itself.  This time, we use the ! as the escape character:</source>
          <target state="translated">私たちの解決策が別の問題を導入したことを認識しています。エスケープ文字です。エスケープ文字そのものをエスケープする必要があることがわかります。今回は、エスケープ文字として !</target>
        </trans-unit>
        <trans-unit id="a7e764b14c40a72de7506566f1043d46bb0179bf" translate="yes" xml:space="preserve">
          <source>What I want to address here is the approach given in Joel Spolsky's answer, the answer &quot;selected&quot; as the right answer.</source>
          <target state="translated">ここで私が取り上げたいのは、ジョエル・スポルスキーの答えの中で与えられたアプローチであり、正解として「選択された」答えです。</target>
        </trans-unit>
        <trans-unit id="6450bd884edaaafc8f2c30b098dfab9b71545cba" translate="yes" xml:space="preserve">
          <source>Which will give you:</source>
          <target state="translated">それがあなたに与えてくれる</target>
        </trans-unit>
        <trans-unit id="c20d641e26d4310fe7f10673ba7c0d0a8a4f2ea5" translate="yes" xml:space="preserve">
          <source>Which you could use like this,</source>
          <target state="translated">こんな風に使えるんだ</target>
        </trans-unit>
        <trans-unit id="a1c640d00154452803b29c203f1d50877797b971" translate="yes" xml:space="preserve">
          <source>With that said, go ahead and flag this answer, downvote it, mark it as not an answer... do whatever you believe is right.</source>
          <target state="translated">それはそうと、先に行って、この答えにフラグを立てて、それをダウンボイコットして、答えではないとマークしてください...あなたが正しいと信じるものは何でもしてください。</target>
        </trans-unit>
        <trans-unit id="d453d5e94a94b047c31fc338808abef090d3c920" translate="yes" xml:space="preserve">
          <source>Yes, I've gone far afield from the original question.  But where else to leave this note concerning what I consider to be an important issue with the &quot;selected&quot; answer for a question?</source>
          <target state="translated">はい、私は元の質問から遠く離れてしまいました。しかし、質問の「選択された」答えについて、私が重要な問題だと考えていることについて、他にどこにこのメモを残せばいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="c6194e2b66441e85c192f849cd73f13ef5f725d2" translate="yes" xml:space="preserve">
          <source>You can parameterize &lt;em&gt;each&lt;/em&gt; value, so something like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;各&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;値&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;をパラメーター化できる&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ので、次のようになります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="540ae451a6a2159c5ecb0af841f18229951bd533" translate="yes" xml:space="preserve">
          <source>You can pass the parameter as a string</source>
          <target state="translated">パラメータを文字列として渡すことができます。</target>
        </trans-unit>
        <trans-unit id="02d42af71a7eac7a8292d95356882939546d4a05" translate="yes" xml:space="preserve">
          <source>You can use the above statement in your .NET code and map the parameter with SqlParameter.</source>
          <target state="translated">上記のステートメントを .NET コードで使用して、パラメータを SqlParameter でマッピングすることができます。</target>
        </trans-unit>
        <trans-unit id="87437dc5ed8516a409cda3c960e12ffdcacc4b99" translate="yes" xml:space="preserve">
          <source>You really only need a way to convert the string into a table.</source>
          <target state="translated">本当に必要なのは文字列をテーブルに変換する方法だけです。</target>
        </trans-unit>
        <trans-unit id="97e786164e7d144a82e75203dad2c623c0c11c82" translate="yes" xml:space="preserve">
          <source>and the MySQL version:</source>
          <target state="translated">とMySQLのバージョンを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3df8dd48aae8c0e7b8d71dd615f0f99c126b5e95" translate="yes" xml:space="preserve">
          <source>in (ct1,ct2, ct3 ... ctn)</source>
          <target state="translated">で</target>
        </trans-unit>
        <trans-unit id="ce276f235956637e004c786d0c39a7ea5a549d44" translate="yes" xml:space="preserve">
          <source>in (select ...)</source>
          <target state="translated">で</target>
        </trans-unit>
        <trans-unit id="edb6b110bc010a020fc6176e807d09190584bb53" translate="yes" xml:space="preserve">
          <source>into an</source>
          <target state="translated">にして</target>
        </trans-unit>
        <trans-unit id="5bc416d9e2f5537e6bed7be9378837b7a0d5e3d1" translate="yes" xml:space="preserve">
          <source>optimizer plan using index scan rather than index seeks, possible need for an expression or function for escaping wildcards (possible index on expression or function)</source>
          <target state="translated">インデックスシークではなくインデックススキャンを使用するオプティマイザプラン、ワイルドカードをエスケープするための式や関数が必要になる可能性があります(式や関数上のインデックスの可能性があります)。</target>
        </trans-unit>
        <trans-unit id="0b307b480fb16b98df07abaaae5ec29863540be3" translate="yes" xml:space="preserve">
          <source>or (the solution I'd probably prefer) a regular join, if you just add a &quot;distinct&quot; to avoid problems with duplicate values in the list.</source>
          <target state="translated">リスト内の値が重複している問題を避けるために &quot;distinct &quot;を追加すれば、通常の結合を行うこともできます。</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="cc20f4add2f0b69a52b77cefaa7e7f09d88dca49" translate="yes" xml:space="preserve">
          <source>using literal values in place of bind variables impacts scalability</source>
          <target state="translated">バインド変数の代わりにリテラル値を使用するとスケーラビリティに影響を与える</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
