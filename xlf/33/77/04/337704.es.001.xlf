<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/337704">
    <body>
      <group id="337704">
        <trans-unit id="48f19cdab83f69f332c2f5fcb40c9ec7eaf89ca1" translate="yes" xml:space="preserve">
          <source>(Of course, &quot;pivot&quot; must return as many rows as the maximum number of
items we can find in the list)</source>
          <target state="translated">(Por supuesto,&quot;pivote&quot; debe devolver tantas filas como el número máximo de artículos que podamos encontrar en la lista)</target>
        </trans-unit>
        <trans-unit id="dee8436afe3eef1c33541c551908ae7951d32018" translate="yes" xml:space="preserve">
          <source>(Yes, I will agree that this is an obscure case.  Probably one that is not likely to be tested.  We wouldn't expect a wildcard in a column value.  We may assume that the application prevents such a value from being stored.  But in my experience, I've rarely seen a database constraint that specifically disallowed characters or patterns that would be considered wildcards on the right side of a &lt;code&gt;LIKE&lt;/code&gt; comparison operator.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(S&amp;iacute;, estar&amp;eacute; de acuerdo en que este es un caso oscuro. Probablemente uno que probablemente no sea probado. No esperar&amp;iacute;amos un comod&amp;iacute;n en el valor de una columna. Podemos suponer que la aplicaci&amp;oacute;n evita que se almacene dicho valor. Pero En mi experiencia, rara vez he visto una restricci&amp;oacute;n en la base de datos que espec&amp;iacute;ficamente no permit&amp;iacute;a caracteres o patrones que se considerar&amp;iacute;an comodines en el lado derecho de un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;operador de comparaci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;LIKE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d9796c38c06486ee44725f02212200e0e19ef822" translate="yes" xml:space="preserve">
          <source>(new version posted on 6/4/13).</source>
          <target state="translated">(nueva versión publicada en 6413).</target>
        </trans-unit>
        <trans-unit id="78bf7b6b27c8792a1b6240a992597a2169e13c12" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL injection&lt;/a&gt; (taking what would appear to be user supplied information, and including that in the SQL text rather than supplying them through bind variables.  Using bind variables isn't required, it's just one convenient approach to thwart with SQL injection.  There are other ways to deal with it:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Inyecci&amp;oacute;n de SQL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (tomar lo que parece ser informaci&amp;oacute;n suministrada por el usuario e incluirla en el texto de SQL en lugar de proporcionarla a trav&amp;eacute;s de variables de enlace. No es necesario usar variables de enlace, es solo un enfoque conveniente para frustrar con la inyecci&amp;oacute;n de SQL. Hay otros maneras de lidiar con eso:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a6e53cd33415c69a4bdf01a31b33c9cdd34fccfe" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;INSERT&lt;/code&gt; each look-up value into that column.</source>
          <target state="translated">&lt;code&gt;INSERT&lt;/code&gt; E&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cada valor de b&amp;uacute;squeda en esa columna.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac17bef807ba02b72de1e63fe25d0cf263de4816" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Addendum&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Addendum&lt;/em&gt;:</target>
        </trans-unit>
        <trans-unit id="cac28b87690e0244dc4499e21d80ce7f137a57b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/1196908?opt.withExecutionPlan=true#executionPlan&quot;&gt;SEDE - Live Demo&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/1196908?opt.withExecutionPlan=true#executionPlan&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SEDE - Demo en vivo&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8282433139e0a1e1ac6d41141b59ccceb433f13" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/481811&quot;&gt;LiveDemo&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://data.stackexchange.com/stackoverflow/query/481811&quot;&gt;LiveDemo&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d7cc78633528ed1105f6ee787b57caf8b5aca4c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A function where ?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una funci&amp;oacute;n donde?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ce6064f3be2a2c0c2b244a4e5aa061cd081bde6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CREDITS FOR: Dinakar Nethi&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CR&amp;Eacute;DITOS PARA: Dinakar Nethi&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a8e521f362bc99965c4c0a3defa878eb3c31799" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cliffs notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Notas de los acantilados:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8115e639335d833240663506049d0442b68dbba5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusion&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4dbfdda273078557fedd54082b0a22e178bc8cdf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;DDL Script:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Script DDL:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a555be6a06e633fb60d1ff7483e33da5b5ada3a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Domain knowledge&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Conocimiento del dominio&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="252a44c26d52bbbdee3f05ef052068c571e8e15c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;E. Find rows by list of values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;E. Encuentra filas por lista de valores&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67d3195b93a234f68cebcb65f2e721c5d575f4bc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;
Create the table called SelectedTags using the following script.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;EDITAR:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; cree la tabla llamada SelectedTags con el siguiente script.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67c8cacdeb62d71990d850b41caea868fe7455b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Escape the escape&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Escapar del escape&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f05f137eb1a56908403bfbf2320629bc58403b99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Inline expression gets messy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La expresi&amp;oacute;n en l&amp;iacute;nea se vuelve desordenada&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="600e0ea4701a71484fccb509e0fd2655945c518e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Obscure corner case&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Estuche de esquina oscuro&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5b63eb5ee1a8de97b89ae2ad28cf585e5487ee5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Other issues recapitulated&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otros temas recapitulados&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80bf15d2aa8f62da4288c48a4b4967714fe0679e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Patching a hole&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Parchar un agujero&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0b37171896c661e0a5bb56c2f1e263143165f10" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Queries with large lists:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Consultas con grandes listas:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="38950a26e45ab68986a78cabd9db01f0fec39a5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Queries with reusable execution plans, called multiple times by simply changing the parameters or if the query is complicated:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Consultas con planes de ejecuci&amp;oacute;n reutilizables, llamadas m&amp;uacute;ltiples veces simplemente cambiando los par&amp;aacute;metros o si la consulta es complicada:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="82001c1ced780a951a7c6f3798a7838f8bd5de2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Selected answer&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Respuesta seleccionada&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23461227354b053ccf166a361a0b790e10fba24a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Some problems with % character&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algunos problemas con% character&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9441af39c3c3128da7ddf830bf1d1d5d69405d68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;T-SQL:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;T-SQL:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6a0dc348f82c1d40f9d8a3a84a3bb9786ff40a7e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The underscore too&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El gui&amp;oacute;n bajo tambi&amp;eacute;n&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f62f9cd4d15d0b544b7ee98f587e4a539f1b27d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Those pesky brackets&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esos molestos brackets&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7822cac6cb84dcb1f769dc18ac0d5e0e14b57cf2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Your case/simple queries with few parameters:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Su caso / consultas simples con pocos par&amp;aacute;metros:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="554b441ed3b70f63af83d232d29f2422b76a4a30" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Original question has requirement &lt;code&gt;SQL Server 2008&lt;/code&gt;. Because this question is often used as duplicate, I've added this answer as reference. &lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La pregunta original tiene el requisito de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;SQL Server 2008&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Debido a que esta pregunta a menudo se usa como duplicado, he agregado esta respuesta como referencia.&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ef5c31c764d5981c9a8f620d4a86708fe1cafd16" translate="yes" xml:space="preserve">
          <source>A full worked example below</source>
          <target state="translated">A continuación se presenta un ejemplo completo</target>
        </trans-unit>
        <trans-unit id="0ea255bf74e697155208b49c499a61c81d0083e5" translate="yes" xml:space="preserve">
          <source>Also, SQL&amp;nbsp;Server 7 and later will &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa175264(SQL.80).aspx&quot;&gt;auto-parameterize queries&lt;/a&gt;, so using parameters isn't really necessary from a performance standpoint - it is, however, &lt;em&gt;critical&lt;/em&gt; from a security standpoint - especially with user inputted data like this.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adem&amp;aacute;s, SQL Server 7 y &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa175264(SQL.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;versiones&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; posteriores &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;parametrizar&amp;aacute;n autom&amp;aacute;ticamente las consultas&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , por lo que el uso de par&amp;aacute;metros no es realmente necesario desde el punto de vista del rendimiento; sin embargo, es &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cr&amp;iacute;tico&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; desde el punto de vista de la seguridad, especialmente con datos ingresados ​​por el usuario como este.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cb65fbb9fdbacb8813819ce6fe844531bf67c562" translate="yes" xml:space="preserve">
          <source>And that function may have some differences in behavior, dependent on the DBMS and version.  (A shout out to all you Java developers so keen on being able to use any database engine interchangeably.)</source>
          <target state="translated">Y esa función puede tener algunas diferencias en el comportamiento,dependiendo del DBMS y la versión.(Un saludo a todos los desarrolladores de Java tan interesados en poder usar cualquier motor de base de datos indistintamente.)</target>
        </trans-unit>
        <trans-unit id="e7647df632ba6a5ad2e75cfdb6f974350f2e7424" translate="yes" xml:space="preserve">
          <source>And the function:</source>
          <target state="translated">Y la función:</target>
        </trans-unit>
        <trans-unit id="cccf532bbfa1429eb9f3289f7400d714e8a760fa" translate="yes" xml:space="preserve">
          <source>Another possible solution is instead of passing a variable number of arguments to a stored procedure, pass a single string containing the names you're after, but make them unique by surrounding them with '&amp;lt;&amp;gt;'. Then use PATINDEX to find the names:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otra posible soluci&amp;oacute;n es en lugar de pasar un n&amp;uacute;mero variable de argumentos a un procedimiento almacenado, pasar una sola cadena que contenga los nombres que busca, pero hacerlos &amp;uacute;nicos rode&amp;aacute;ndolos con '&amp;lt;&amp;gt;'. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Luego use PATINDEX para encontrar los nombres:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="03d0b83415d956ac04c59f569a6227895ab74272" translate="yes" xml:space="preserve">
          <source>Anyway, if you run this in the highly recommended &lt;a href=&quot;http://www.linqpad.net/&quot;&gt;LINQPad&lt;/a&gt;, and run this query, you can view the actual SQL that the SQL LINQ provider generated. It'll show you each of the values getting parameterized into an &lt;code&gt;IN&lt;/code&gt; clause.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;De todos modos, si ejecuta esto en el &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.linqpad.net/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LINQPad&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; altamente recomendado &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;y ejecuta esta consulta, puede ver el SQL real que gener&amp;oacute; el proveedor LINQ de SQL. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Le mostrar&amp;aacute; cada uno de los valores que se parametrizan en una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cl&amp;aacute;usula &lt;/font&gt;&lt;/font&gt; &lt;code&gt;IN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="23b01d595f6060073511290535fff818b9114f31" translate="yes" xml:space="preserve">
          <source>But as soon as I saw it, I immediately saw a potential problem with it, and it's not my nature to let it slide.  I don't mean to be critical of the efforts of others.  I know many developers take their work very personally, because they invest so much into it and they care so much about it.  So please understand, this is not a personal attack.  What I'm identifying here is the type of problem that crops up in production rather than testing.</source>
          <target state="translated">Pero tan pronto como lo vi,inmediatamente vi un problema potencial con él,y no es mi naturaleza dejarlo pasar.No quiero ser crítico con los esfuerzos de los demás.Sé que muchos desarrolladores se toman su trabajo muy personalmente,porque invierten mucho en él y se preocupan mucho por él.Así que,por favor,entienda que esto no es un ataque personal.Lo que estoy identificando aquí es el tipo de problema que surge en la producción en lugar de las pruebas.</target>
        </trans-unit>
        <trans-unit id="1f6dc5172459fe319cfcc98bb14b0e0d6d765a74" translate="yes" xml:space="preserve">
          <source>But in terms generalizing this approach, let's also consider the more obscure corner cases, like when the &lt;code&gt;Name&lt;/code&gt; column contains a wildcard character (as recognized by the LIKE predicate.)  The wildcard character I see most commonly used is &lt;code&gt;%&lt;/code&gt; (a percent sign.). So let's deal with that here now, and later go on to other cases.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero en t&amp;eacute;rminos de generalizaci&amp;oacute;n de este enfoque, consideremos tambi&amp;eacute;n los casos de esquina m&amp;aacute;s oscuros, como cuando la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;columna &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; contiene un car&amp;aacute;cter comod&amp;iacute;n (como lo reconoce el predicado LIKE). El car&amp;aacute;cter comod&amp;iacute;n que veo m&amp;aacute;s com&amp;uacute;nmente usado es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (un signo de porcentaje). . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;As&amp;iacute; que lidiemos con eso aqu&amp;iacute; ahora, y luego pasemos a otros casos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef0d5d39e697ffe1ba99b0761754afc9c4f40372" translate="yes" xml:space="preserve">
          <source>But that same row will &lt;strong&gt;not&lt;/strong&gt; be returned if the order of the search terms is reversed:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero esa misma fila &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se devolver&amp;aacute; si se invierte el orden de los t&amp;eacute;rminos de b&amp;uacute;squeda:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ad02e2300cc6443c140b0ea75769de719b9a2f50" translate="yes" xml:space="preserve">
          <source>But, absent the specialized knowledge and a guarantee, it's important for us to at least consider handling those obscure corner cases, and consider whether the behavior is reasonable and &quot;per the specification&quot;.</source>
          <target state="translated">Pero,a falta de conocimientos especializados y de una garantía,es importante que al menos consideremos el manejo de esos oscuros casos de esquina,y consideremos si el comportamiento es razonable y &quot;según la especificación&quot;.</target>
        </trans-unit>
        <trans-unit id="f8eb3248811492e79afeba88e2112b19fd5e3085" translate="yes" xml:space="preserve">
          <source>Cheers.</source>
          <target state="translated">Cheers.</target>
        </trans-unit>
        <trans-unit id="bfee5586db97ea7e6e02b3fe7c5e0b9a70a81809" translate="yes" xml:space="preserve">
          <source>Consider a Name value of &lt;code&gt;'pe%ter'&lt;/code&gt;.  (For the examples here, I use a literal string value in place of the column name.)  A row with a Name value of `'pe%ter' would be returned by a query of the form:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Considere un valor de Nombre de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;'pe%ter'&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Para los ejemplos aqu&amp;iacute;, utilizo un valor de cadena literal en lugar del nombre de la columna). Una consulta del formulario devolver&amp;iacute;a una fila con un valor de Nombre de '' pe% ter '':&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d017cf77fe2c73ed635d1a483b157ec724242736" translate="yes" xml:space="preserve">
          <source>Create a &lt;em&gt;temp table&lt;/em&gt; with one column.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Crea una &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tabla temporal&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con una columna.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8136fc8a2e6515b930f0753b1f85b9ddce86d5f8" translate="yes" xml:space="preserve">
          <source>DDL Script:</source>
          <target state="translated">Guión DDL:</target>
        </trans-unit>
        <trans-unit id="02a4f4b6de45d5c7489decc7ab589a9afa2cb60e" translate="yes" xml:space="preserve">
          <source>Depending on your goals it might be of use.</source>
          <target state="translated">Dependiendo de sus objetivos podría ser de utilidad.</target>
        </trans-unit>
        <trans-unit id="b2d970495b8509db54eabd95430be025d9b303c2" translate="yes" xml:space="preserve">
          <source>Dynamic SQL, maybe with parameters if testing shows better performance.</source>
          <target state="translated">SQL dinámico,tal vez con parámetros si las pruebas muestran un mejor rendimiento.</target>
        </trans-unit>
        <trans-unit id="2c79c2f8fe6cef139b77391f6699a0512a187188" translate="yes" xml:space="preserve">
          <source>Edit:</source>
          <target state="translated">Edit:</target>
        </trans-unit>
        <trans-unit id="9b4f7c19764919f3700623d10af2eaf2e9fd3645" translate="yes" xml:space="preserve">
          <source>Fiddler demo</source>
          <target state="translated">Demostración de Fiddler</target>
        </trans-unit>
        <trans-unit id="026dacaafe85baaf736570c8698095c25f19b7af" translate="yes" xml:space="preserve">
          <source>Finding matching pairs of brackets shouldn't be that hard.  It's a little more difficult than handling the occurrences of singleton % and _.  (Note that it's not sufficient to just escape all occurrences of brackets, because a singleton bracket is considered to be a literal, and doesn't need to be escaped. The logic is getting a little fuzzier than I can handle without running more test cases.)</source>
          <target state="translated">Encontrar los pares de soportes que coincidan no debería ser tan difícil.Es un poco más difícil que manejar las ocurrencias de singleton % y _.(Nótese que no es suficiente con escapar todas las ocurrencias de los paréntesis,porque un par de singleton se considera un literal,y no necesita ser escapado.La lógica se está volviendo un poco más borrosa de lo que puedo manejar sin hacer más casos de prueba).</target>
        </trans-unit>
        <trans-unit id="956bf832223f45c34ec12226533b916e6709dbb5" translate="yes" xml:space="preserve">
          <source>First, you have to create a type</source>
          <target state="translated">Primero,tienes que crear un tipo</target>
        </trans-unit>
        <trans-unit id="d676f66cb4ad07fb96444f3511cde73425052bf9" translate="yes" xml:space="preserve">
          <source>For SQL Server 2008, you can use a &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb675163.aspx&quot;&gt;table valued parameter&lt;/a&gt;. It's a bit of work, but it is arguably cleaner than &lt;a href=&quot;https://stackoverflow.com/questions/337704/parameterizing-a-sql-in-clause#337792&quot;&gt;my other method&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para SQL Server 2008, puede usar un &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/bb675163.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;par&amp;aacute;metro con valores de tabla&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es un poco de trabajo, pero podr&amp;iacute;a decirse que es m&amp;aacute;s limpio que &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/337704/parameterizing-a-sql-in-clause#337792&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;mi otro m&amp;eacute;todo&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="227f0d29bb06ad813fae5f94026e2af979d5e192" translate="yes" xml:space="preserve">
          <source>For a variable number of arguments like this the only way I'm aware of is to either generate the SQL explicitly or do something that involves populating a temporary table with the items you want and joining against the temp table.</source>
          <target state="translated">Para un número variable de argumentos como este,la única forma que conozco es generar el SQL explícitamente o hacer algo que implique rellenar una tabla temporal con los elementos que desee y unirlos contra la tabla temporal.</target>
        </trans-unit>
        <trans-unit id="fe75486630ba5a7fcd537b56d8939d238184983f" translate="yes" xml:space="preserve">
          <source>For your case anything you do, be it parameterization with a fixed number of items in the list (null if not used), dynamically building the query with or without parameters, or using stored procedures with table valued parameters will not make much of a difference. However, my general recommendations are as follows:</source>
          <target state="translated">En su caso,cualquier cosa que haga,ya sea la parametrización con un número fijo de elementos de la lista (nulo si no se utiliza),la construcción dinámica de la consulta con o sin parámetros,o la utilización de procedimientos almacenados con parámetros valorados en la tabla,no supondrá una gran diferencia.Sin embargo,mis recomendaciones generales son las siguientes:</target>
        </trans-unit>
        <trans-unit id="c849be4c99e78b71f4be145f175e981782cb4a3d" translate="yes" xml:space="preserve">
          <source>Having IN( 'tag1', 'tag2', 'tag1', 'tag1', 'tag1' ) will be easily optimized away by SQL Server. Plus, you get direct index seeks</source>
          <target state="translated">Tener IN('tag1','tag2','tag1','tag1','tag1')será fácilmente optimizado por SQL Server.Además,se obtiene una búsqueda directa de índices</target>
        </trans-unit>
        <trans-unit id="0883a1359a7ef9fb3528dc28cd0c0ad2edfa8b13" translate="yes" xml:space="preserve">
          <source>Here Dapper does the thinking, so you don't have to. Something similar is possible with &lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;LINQ&amp;nbsp;to&amp;nbsp;SQL&lt;/a&gt;, of course:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; Dapper piensa, as&amp;iacute; que no tienes que hacerlo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algo similar es posible con &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LINQ to SQL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , por supuesto:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ec20b27947e409494d8b39aff65011bcad68b37c" translate="yes" xml:space="preserve">
          <source>Here is another alternative. Just pass a comma-delimited list as a string parameter to the stored procedure and:</source>
          <target state="translated">Aquí hay otra alternativa.Simplemente pase una lista delimitada por comas como parámetro de cadena al procedimiento almacenado y:</target>
        </trans-unit>
        <trans-unit id="3bef9b813806d919c0ef17520cdcae6d63be6a13" translate="yes" xml:space="preserve">
          <source>Here is another answer to this problem.</source>
          <target state="translated">Aquí hay otra respuesta a este problema.</target>
        </trans-unit>
        <trans-unit id="8058dd0239d0ce0f235c473fee26724245a2479d" translate="yes" xml:space="preserve">
          <source>Here is the code for the UDF &lt;em&gt;(I got it from Stack Overflow somewhere, i can't find the source right now)&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; est&amp;aacute; el c&amp;oacute;digo para el UDF &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(lo obtuve de Stack Overflow en alguna parte, no puedo encontrar la fuente en este momento)&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d9c357ac321a2c270d39faa0087485f24d73d7b" translate="yes" xml:space="preserve">
          <source>Here is the split function I use.</source>
          <target state="translated">Aquí está la función de división que uso.</target>
        </trans-unit>
        <trans-unit id="31b408cd5989d3b3a9e85be52bf44f860e81198e" translate="yes" xml:space="preserve">
          <source>Here's a quick-and-dirty technique I have used:</source>
          <target state="translated">Aquí hay una técnica rápida y sucia que he usado:</target>
        </trans-unit>
        <trans-unit id="450492771c56d95cbcd05fb281ef0131265e08c9" translate="yes" xml:space="preserve">
          <source>Here's a technique that recreates a local table to be used in a query string. Doing it this way eliminates all parsing problems.</source>
          <target state="translated">Aquí hay una técnica que recrea una tabla local para ser usada en una cadena de consulta.Haciéndolo de esta manera se eliminan todos los problemas de análisis.</target>
        </trans-unit>
        <trans-unit id="e6ad03598d810f4f2eebf49dfe172e701f6b4e08" translate="yes" xml:space="preserve">
          <source>Here's the CTE version.</source>
          <target state="translated">Aquí está la versión CTE.</target>
        </trans-unit>
        <trans-unit id="bc4f98564ef32ef0f8fb6179097d52a7744bb920" translate="yes" xml:space="preserve">
          <source>How do I parameterize a query containing an &lt;code&gt;IN&lt;/code&gt; clause with a variable number of arguments, like this one?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;C&amp;oacute;mo parametrizo una consulta que contiene una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cl&amp;aacute;usula &lt;/font&gt;&lt;/font&gt; &lt;code&gt;IN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con un n&amp;uacute;mero variable de argumentos, como este?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6bb54217d9c4d37d19fb2185c0c208e0cb24405d" translate="yes" xml:space="preserve">
          <source>I believe others have already sufficiently pointed out some of the other commonly considered areas of concern:</source>
          <target state="translated">Creo que otros ya han señalado suficientemente algunas de las otras áreas de preocupación comúnmente consideradas:</target>
        </trans-unit>
        <trans-unit id="e7734598a6d1c2cfa95be739746a7afb394b36a1" translate="yes" xml:space="preserve">
          <source>I have also seen stored procedures that had 500 parameters with default values of null, and having WHERE Column1 IN (@Param1, @Param2, @Param3, ..., @Param500). This caused SQL to build a temp table, do a sort/distinct, and then do a table scan instead of an index seek. That is essentially what you would be doing by parameterizing that query, although on a small enough scale that it won't make a noticeable difference. I highly recommend against having NULL in your IN lists, as if that gets changed to a NOT IN it will not act as intended. You could dynamically build the parameter list, but the only obvious thing that you would gain is that the objects would escape the single quotes for you. That approach is also slightly slower on the application end since the objects have to parse the query to find the parameters. It may or may not be faster on SQL, as parameterized queries call sp_prepare, sp_execute for as many times you execute the query, followed by sp_unprepare.</source>
          <target state="translated">También he visto procedimientos almacenados que tenían 500 parámetros con valores por defecto de nulos,y que tenían la columna WHERE1 IN (@Param1,@Param2,@Param3,...,@Param500).Esto provocó que SQL construyera una tabla temporal,hiciera un sortdistinct,y luego hiciera un escaneo de la tabla en lugar de una búsqueda de índices.Eso es esencialmente lo que se haría al parametrizar esa consulta,aunque a una escala lo suficientemente pequeña como para no hacer una diferencia notable.Recomiendo encarecidamente no tener NULL en sus listas de IN,ya que si eso se cambia a un NOT IN no actuará como se pretende.Podrías construir dinámicamente la lista de parámetros,pero lo único obvio que ganarías es que los objetos escaparan de las citas simples por ti.Este enfoque es también ligeramente más lento en el extremo de la aplicación,ya que los objetos tienen que analizar la consulta para encontrar los parámetros.Puede o no ser más rápido en SQL,ya que las consultas parametrizadas llaman a sp_prepare,sp_execute para cuantas veces se ejecute la consulta,seguido de sp_unprepare.</target>
        </trans-unit>
        <trans-unit id="d82e71ada8a62159ea70852009714bf5aa14c66d" translate="yes" xml:space="preserve">
          <source>I have an answer that doesn't require a UDF, XML
Because IN accepts a select statement
e.g. SELECT * FROM Test where Data IN (SELECT Value FROM TABLE)</source>
          <target state="translated">Tengo una respuesta que no requiere un UDF,XML porque IN acepta una sentencia selectora,por ejemplo,SELECT*FROM Test donde Data IN (SELECT Value FROM TABLE)</target>
        </trans-unit>
        <trans-unit id="2180e8cc79db8111713b3a38b9273505d784397f" translate="yes" xml:space="preserve">
          <source>I have seen the split functions take longer to execute than the query themselves in many cases where the parameters get large. A stored procedure with table valued parameters in SQL 2008 is the only other option I would consider, although this will probably be slower in your case. TVP will probably only be faster for large lists if you are searching on the primary key of the TVP, because SQL will build a temporary table for the list anyway (if the list is large). You won't know for sure unless you test it.</source>
          <target state="translated">He visto que las funciones de división tardan más en ejecutarse que la propia consulta en muchos casos en los que los parámetros son grandes.Un procedimiento almacenado con parámetros valorados en la tabla en SQL 2008 es la única otra opción que consideraría,aunque probablemente sea más lenta en su caso.La TVP probablemente sólo será más rápida para las listas grandes si se busca en la clave principal de la TVP,porque SQL construirá una tabla temporal para la lista de todos modos (si la lista es grande).No lo sabrá con seguridad a menos que la pruebe.</target>
        </trans-unit>
        <trans-unit id="e2d5c5e674c7b6a4cb6b4676422df0cbb9e45827" translate="yes" xml:space="preserve">
          <source>I heard Jeff/Joel talk about this on the podcast today (&lt;em&gt;&lt;a href=&quot;http://itc.conversationsnetwork.org/audio/download/ITC.SO-Episode34-2008.12.16.mp3&quot;&gt;episode 34&lt;/a&gt;&lt;/em&gt;, 2008-12-16 (MP3, 31&amp;nbsp;MB), 1 h 03 min 38 secs - 1 h 06 min 45 secs), and I thought I recalled Stack&amp;nbsp;Overflow was using &lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;LINQ&amp;nbsp;to&amp;nbsp;SQL&lt;/a&gt;, but maybe it was ditched. Here's the same thing in LINQ&amp;nbsp;to&amp;nbsp;SQL.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Escuch&amp;eacute; a Jeff / Joel hablar sobre esto en el podcast hoy ( &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;http://itc.conversationsnetwork.org/audio/download/ITC.SO-Episode34-2008.12.16.mp3&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;episodio 34&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 2008-12-16 (MP3, 31 MB), 1 h 03 min 38 segundos - 1 h 06 min 45 segundos), y pens&amp;eacute; que record&amp;eacute; el desbordamiento de pila estaba usando &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Language_Integrated_Query#LINQ_to_SQL&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;LINQ to SQL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pero tal vez fue abandonado. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; est&amp;aacute; lo mismo en LINQ to SQL.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="68e1d98c1bde1a441a049af1b527a7799aebbbe2" translate="yes" xml:space="preserve">
          <source>I like Joel Spolsky's approach.  It's clever.  And it works.</source>
          <target state="translated">Me gusta el enfoque de Joel Spolsky.Es inteligente.Y funciona.</target>
        </trans-unit>
        <trans-unit id="10c3a107dda505aa2f5d453923b47dd798c81981" translate="yes" xml:space="preserve">
          <source>I never got around to profiling exactly how &lt;em&gt;fast&lt;/em&gt; it was, but in my situation it was needed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nunca llegu&amp;eacute; a perfilar exactamente qu&amp;eacute; tan &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;r&amp;aacute;pido&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; era, pero en mi situaci&amp;oacute;n era necesario.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="82c8befdd145dc1a6bf86c2be33fbcb496ad3fd6" translate="yes" xml:space="preserve">
          <source>I prefer this approach to escaping because it works in Oracle and MySQL as well as SQL Server.  (I usually use the \ backslash as the escape character, since that's the character we use in regular expressions. But why be constrained by convention!</source>
          <target state="translated">Prefiero este enfoque a escapar porque funciona en Oracle y MySQL,así como en SQL Server.(Suelo usar la barra invertida como carácter de escape,ya que es el carácter que usamos en las expresiones regulares.Pero,¿por qué estar limitado por la convención?</target>
        </trans-unit>
        <trans-unit id="af4243377878f11b07ae3404abe46df5a7ff9d2a" translate="yes" xml:space="preserve">
          <source>I think this is a case when a static query is just not the way to go. Dynamically build the list for your in clause, escape your single quotes, and dynamically build SQL. In this case you probably won't see much of a difference with any method due to the small list, but the most efficient method really is to send the SQL exactly as it is written in your post. I think it is a good habit to write it the most efficient way, rather than to do what makes the prettiest code, or consider it bad practice to dynamically build SQL.</source>
          <target state="translated">Creo que este es un caso en el que una consulta estática no es el camino a seguir.Construye dinámicamente la lista para tu cláusula de entrada,escapa de tus comillas simples,y construye dinámicamente SQL.En este caso probablemente no verá mucha diferencia con ningún método debido a la pequeña lista,pero el método más eficiente realmente es enviar el SQL exactamente como está escrito en su mensaje.Creo que es un buen hábito escribirlo de la manera más eficiente,en lugar de hacer lo que hace el código más bonito,o considerar que es una mala práctica construir dinámicamente el SQL.</target>
        </trans-unit>
        <trans-unit id="470eb3bd8dc8f9275680a731f7a00e1369b18132" translate="yes" xml:space="preserve">
          <source>I use a more concise version &lt;a href=&quot;https://stackoverflow.com/a/337792/16587&quot;&gt;of the top voted answer&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Utilizo una versi&amp;oacute;n m&amp;aacute;s concisa &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/337792/16587&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;de la respuesta m&amp;aacute;s votada&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77c29b34770822e532945f81b425ab2daa5931cd" translate="yes" xml:space="preserve">
          <source>I would pass a table type parameter (since it's &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;SQL Server 2008&lt;/a&gt;), and do a &lt;code&gt;where exists&lt;/code&gt;, or inner join. You may also use XML, using &lt;code&gt;sp_xml_preparedocument&lt;/code&gt;, and then even index that temporary table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pasar&amp;iacute;a un par&amp;aacute;metro de tipo de tabla (ya que es &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) y har&amp;iacute;a un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;where exists&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o internal join. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Tambi&amp;eacute;n puede usar XML, usando &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sp_xml_preparedocument&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , y luego incluso indexar esa tabla temporal.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="38e00a81ddf5f6fe0b6b36105aa8782ef2784f85" translate="yes" xml:space="preserve">
          <source>I would prefer not to use a dedicated stored procedure for this (or XML), but if there is some elegant way specific to &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;SQL Server 2008&lt;/a&gt;, I am open to that.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Preferir&amp;iacute;a no usar un procedimiento almacenado dedicado para esto (o XML), pero si hay alguna forma elegante espec&amp;iacute;fica para &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , estoy abierto a eso.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d99406eb70ce3918021a57f108a598c46ca958e8" translate="yes" xml:space="preserve">
          <source>I'd approach this by default with passing a table valued function (that returns a table from a string) to the IN condition.</source>
          <target state="translated">Me acercaría a esto por defecto pasando una función de valor de tabla (que devuelve una tabla de una cadena)a la condición IN.</target>
        </trans-unit>
        <trans-unit id="358e1888dd9c3dc6a6d8b8f74729dc1edef55c23" translate="yes" xml:space="preserve">
          <source>If needed you can insert it into a temp table, index it, then run a join...</source>
          <target state="translated">Si es necesario,puedes insertarlo en una tabla temporal,indexarlo,y luego ejecutar una unión...</target>
        </trans-unit>
        <trans-unit id="1be3fb0e541f55904b67a0c3a768429469841e69" translate="yes" xml:space="preserve">
          <source>If we have strings stored inside the IN clause with the comma(,) delimited, we can use the charindex function to get the values. If you use .NET, then you can map with SqlParameters.</source>
          <target state="translated">Si tenemos cadenas almacenadas dentro de la cláusula IN con la coma(,)delimitada,podemos usar la función charindex para obtener los valores.Si usas .NET,entonces puedes mapear con SqlParameters.</target>
        </trans-unit>
        <trans-unit id="c1a9ec97b4d93a4f86712c4f1a87de838971feee" translate="yes" xml:space="preserve">
          <source>If you are calling from .NET, you could use &lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;Dapper dot net&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si llama desde .NET, puede usar &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/StackExchange/Dapper&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dapper dot net&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dd00bd710d5c5d138e7a5c14fe395b67a569d86e" translate="yes" xml:space="preserve">
          <source>If you have enough RAM, I'd expect SQL&amp;nbsp;Server would probably cache a plan for the common counts of parameters as well. I suppose you could always add five parameters, and let the unspecified tags be NULL - the query plan should be the same, but it seems pretty ugly to me and I'm not sure that it'd worth the micro-optimization (although, on Stack&amp;nbsp;Overflow - it may very well be worth it).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si tiene suficiente RAM, esperar&amp;iacute;a que SQL Server probablemente tambi&amp;eacute;n almacenara en cach&amp;eacute; un plan para los recuentos comunes de par&amp;aacute;metros. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Supongo que siempre puede agregar cinco par&amp;aacute;metros y dejar que las etiquetas no especificadas sean NULL: el plan de consulta debe ser el mismo, pero me parece bastante feo y no estoy seguro de que valga la pena la microoptimizaci&amp;oacute;n (aunque, en Desbordamiento de pila: puede valer la pena).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="13efe4ce5cd750e79baf7a01290267049374c466" translate="yes" xml:space="preserve">
          <source>If you're really interested in performance and don't want to iterate through the loop twice, here's a less beautiful version:</source>
          <target state="translated">Si estás realmente interesado en la actuación y no quieres iterar por el bucle dos veces,aquí tienes una versión menos hermosa:</target>
        </trans-unit>
        <trans-unit id="0c540b5e6699b2c7b611bcf7af1cd074053d21fd" translate="yes" xml:space="preserve">
          <source>If you're unlucky enough to be stuck on &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2005&quot;&gt;SQL Server 2005&lt;/a&gt; you could add a &lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Language_Runtime&quot;&gt;CLR&lt;/a&gt; function like this,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si tiene la mala suerte de estar atascado en &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2005&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2005&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , puede agregar una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;funci&amp;oacute;n &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Common_Language_Runtime&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CLR&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; como esta,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2f991e2ce21fbc2b508a3faff72c5094821362eb" translate="yes" xml:space="preserve">
          <source>If you've got &lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;SQL Server 2008&lt;/a&gt; or later I'd use a &lt;a href=&quot;https://stackoverflow.com/questions/5595353/how-to-pass-table-value-parameters-to-stored-procedure-from-net-code&quot;&gt;Table Valued Parameter&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si tiene &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Microsoft_SQL_Server#SQL_Server_2008&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server 2008&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o posterior, usar&amp;iacute;a un &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/5595353/how-to-pass-table-value-parameters-to-stored-procedure-from-net-code&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;par&amp;aacute;metro de valor de tabla&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b26bb26a3dff833054084925292a26c85610a666" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;http://en.wikipedia.org/wiki/ColdFusion&quot;&gt;ColdFusion&lt;/a&gt; we just do:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/ColdFusion&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ColdFusion&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; solo hacemos:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae0b31a603e2cadba5386706372b442225ace3da" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;SQL Server 2016+&lt;/code&gt; you could use &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/mt684588.aspx&quot;&gt;&lt;code&gt;STRING_SPLIT&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En &lt;/font&gt;&lt;/font&gt; &lt;code&gt;SQL Server 2016+&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; puede usar la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;funci&amp;oacute;n &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/mt684588.aspx&quot;&gt; &lt;code&gt;STRING_SPLIT&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77792ff8ecdb0ffcc2759ed0fc092e6107edf5e4" translate="yes" xml:space="preserve">
          <source>In SQL Server 2016+ another possibility is to use the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn921879.aspx&quot;&gt;&lt;code&gt;OPENJSON&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En SQL Server 2016+, otra posibilidad es usar la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;funci&amp;oacute;n &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/dn921879.aspx&quot;&gt; &lt;code&gt;OPENJSON&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9f1f4abb84eb41057375a32c3581100f5fffce9" translate="yes" xml:space="preserve">
          <source>In my opinion, the best source to solve this problem, is what has been posted on this site:</source>
          <target state="translated">En mi opinión,la mejor fuente para resolver este problema,es lo que se ha publicado en este sitio:</target>
        </trans-unit>
        <trans-unit id="d01a0b1abba0430fb1dfbb704c154c9812f0edb7" translate="yes" xml:space="preserve">
          <source>In the C# code you do something like this:</source>
          <target state="translated">En el código C#haces algo como esto:</target>
        </trans-unit>
        <trans-unit id="5dad346a862dade5a2ce260292058579877f3e81" translate="yes" xml:space="preserve">
          <source>In the SQL you have a clause like this:</source>
          <target state="translated">En el SQL tienes una cláusula como esta:</target>
        </trans-unit>
        <trans-unit id="c9ac14f5f553dbf81735a238c4aec23e0f9b9b3d" translate="yes" xml:space="preserve">
          <source>In this query, the number of arguments could be anywhere from 1 to 5.</source>
          <target state="translated">En esta consulta,el número de argumentos podría ser de 1 a 5.</target>
        </trans-unit>
        <trans-unit id="1ccc36caa6c571f60a777db830b24b1bd0152f89" translate="yes" xml:space="preserve">
          <source>Injection concerns aside, take care to note that constructing the command text to accomodate a variable number of parameters (as above) impede's SQL server's ability to take advantage of cached queries. The net result is that you almost certainly lose the value of using parameters in the first place (as opposed to merely inserting the predicate strings into the SQL itself).</source>
          <target state="translated">Dejando a un lado las preocupaciones de inyección,tenga cuidado de notar que la construcción del texto del comando para acomodar un número variable de parámetros (como arriba)impide la capacidad del servidor SQL de aprovechar las consultas en caché.El resultado neto es que casi con toda seguridad se pierde el valor de utilizar parámetros en primer lugar (en lugar de insertar simplemente las cadenas de predicados en el propio SQL).</target>
        </trans-unit>
        <trans-unit id="cfe8f3b2b9656fa087b047b0c76f57d8888a9b38" translate="yes" xml:space="preserve">
          <source>Instead of using an &lt;code&gt;IN&lt;/code&gt;, you can then just use your standard &lt;code&gt;JOIN&lt;/code&gt; rules. ( Flexibility++ )</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En lugar de usar un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;IN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , puede usar sus &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;reglas &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;est&amp;aacute;ndar &lt;/font&gt;&lt;/font&gt; &lt;code&gt;JOIN&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Flexibilidad ++)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6531c8cd756afd65aa968ac013e26ebeae12e8e9" translate="yes" xml:space="preserve">
          <source>It almost goes without saying that we might not want &lt;code&gt;pe%ter&lt;/code&gt; to match peanut butter, no matter how much he likes it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Casi no hace falta decir que es posible que no deseemos que el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;pe%ter&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; coincida con la mantequilla de man&amp;iacute;, sin importar cu&amp;aacute;nto le guste.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a8aa17b73c9976e345417d180c7b625a957911aa" translate="yes" xml:space="preserve">
          <source>It does loop through the tag parameters twice; but that doesn't matter most of the time (it won't be your bottleneck; if it is, unroll the loop).</source>
          <target state="translated">Hace un bucle a través de los parámetros de la etiqueta dos veces;pero eso no importa la mayoría de las veces (no será tu cuello de botella;si lo es,desenrolla el bucle).</target>
        </trans-unit>
        <trans-unit id="4b7b04c75db0a99e0f8a75786d727c9a060cda70" translate="yes" xml:space="preserve">
          <source>Joel Spolsky's approach is clever.  And it works reasonably, it's going to exhibit predictable behavior and predictable performance, given &quot;normal&quot; values, and with the normative edge cases, such as NULL and the empty string.  And it may be sufficient for a particular application.</source>
          <target state="translated">El enfoque de Joel Spolsky es inteligente.Y funciona razonablemente,va a exhibir un comportamiento predecible y un rendimiento predecible,dados los valores &quot;normales&quot;,y con los casos de borde normativo,como el NULL y la cadena vacía.Y puede ser suficiente para una aplicación particular.</target>
        </trans-unit>
        <trans-unit id="ef078c7764d0dfe131b3ce83b313bd5d0f32a413" translate="yes" xml:space="preserve">
          <source>Let me state right here, that this is &lt;strong&gt;not an answer&lt;/strong&gt; to the original question.  There are already some demonstrations of that in other good answers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Perm&amp;iacute;tanme decir aqu&amp;iacute;, que esta &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;una respuesta&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; a la pregunta original. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ya hay algunas demostraciones de eso en otras buenas respuestas.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac08ba80594a0659efb8968aea37e16a79e71676" translate="yes" xml:space="preserve">
          <source>Make sure you don't have any &lt;code&gt;|&lt;/code&gt;, blank, or null tags or this won't work</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aseg&amp;uacute;rate de no tener ninguno &lt;/font&gt;&lt;/font&gt; &lt;code&gt;|&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;, etiquetas en blanco o nulas o esto no funcionar&amp;aacute;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4c8a0f32fd7f5b545c1fc32faeff3a3ddeb8716" translate="yes" xml:space="preserve">
          <source>May be we can use XML here:</source>
          <target state="translated">Puede ser que podamos usar XML aquí:</target>
        </trans-unit>
        <trans-unit id="cc703fb9e22b2d4125214daa80ed8744a1971657" translate="yes" xml:space="preserve">
          <source>No infinite variability for you.  Only finite variability.</source>
          <target state="translated">No hay una variabilidad infinita para ti.Sólo una variabilidad finita.</target>
        </trans-unit>
        <trans-unit id="b17bd2c4be5e9e38316d4ca5e4bba27b293c90cd" translate="yes" xml:space="preserve">
          <source>No, this is not open to &lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;SQL injection&lt;/a&gt;. The only injected text into CommandText is not based on user input. It's solely based on the hardcoded &quot;@tag&quot; prefix, and the index of an array. The index will &lt;em&gt;always&lt;/em&gt; be an integer, is not user generated, and is safe.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No, esto no est&amp;aacute; abierto a la &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/SQL_injection&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;inyecci&amp;oacute;n SQL&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El &amp;uacute;nico texto inyectado en CommandText no se basa en la entrada del usuario. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Se basa &amp;uacute;nicamente en el prefijo &quot;@tag&quot; codificado y el &amp;iacute;ndice de una matriz. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El &amp;iacute;ndice &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;siempre&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ser&amp;aacute; un n&amp;uacute;mero entero, no es generado por el usuario y es seguro.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81f8d03283d9b4204147b22834f1cd053335add0" translate="yes" xml:space="preserve">
          <source>Not that cached query plans aren't valuable, but IMO this query isn't nearly complicated enough to see much benefit from it. While the compilation costs may approach (or even exceed) the execution costs, you're still talking milliseconds.</source>
          <target state="translated">No es que los planes de consulta almacenados no sean valiosos,pero la OMI no es lo suficientemente complicada como para ver muchos beneficios en ella.Aunque los costes de compilación pueden acercarse (o incluso exceder)los costes de ejecución,todavía se habla de milisegundos.</target>
        </trans-unit>
        <trans-unit id="a039ae3772c1ef49d778f9f8c4b67934ff2c1fc3" translate="yes" xml:space="preserve">
          <source>Now that we're on a roll, we can add another &lt;code&gt;REPLACE&lt;/code&gt; handle the underscore wildcard.   And just for fun, this time, we'll use $ as the escape character.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora que estamos en una lista, podemos agregar otro &lt;/font&gt;&lt;/font&gt; &lt;code&gt;REPLACE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; manejar el comod&amp;iacute;n subrayado. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y solo por diversi&amp;oacute;n, esta vez, usaremos $ como el personaje de escape.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="01625438b5c7959ea81cd00f7a3084a534d6307d" translate="yes" xml:space="preserve">
          <source>Now we can match the literal %.  Of course, when we have a column name, we're going to need to dynamically escape the wildcard.  We can use the &lt;code&gt;REPLACE&lt;/code&gt; function to find occurrences of the &lt;code&gt;%&lt;/code&gt;character and insert a backslash character in front of each one, like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora podemos hacer coincidir el% literal. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por supuesto, cuando tenemos un nombre de columna, vamos a necesitar escapar din&amp;aacute;micamente del comod&amp;iacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Podemos usar la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;funci&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;REPLACE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para encontrar ocurrencias del &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;car&amp;aacute;cter &lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; e insertar un car&amp;aacute;cter de barra diagonal inversa delante de cada uno, de esta manera:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6998781be11fbddbbca54848518598754741b9b1" translate="yes" xml:space="preserve">
          <source>Okay, so, if we don't handle that as an inline expression in the SQL, the closest alternative we have is a user defined function.  And we know that won't speed things up any (unless we can define an index on it, like we could with Oracle.)  If we've got to create a function, we might better do that in the code that calls the SQL statement.</source>
          <target state="translated">Bien,entonces,si no manejamos eso como una expresión en línea en el SQL,la alternativa más cercana que tenemos es una función definida por el usuario.Y sabemos que eso no acelerará las cosas (a menos que podamos definir un índice en ella,como podríamos hacer con Oracle.)Si tenemos que crear una función,mejor lo hacemos en el código que llama a la sentencia SQL.</target>
        </trans-unit>
        <trans-unit id="b73b20450025066dadaf1b5da5e8b07536a277f8" translate="yes" xml:space="preserve">
          <source>Once you got this your code would be as simple as this:</source>
          <target state="translated">Una vez que tengas esto,tu código será tan simple como esto:</target>
        </trans-unit>
        <trans-unit id="2cd8064f013da44c7a421743d1d148268bb442b0" translate="yes" xml:space="preserve">
          <source>One approach to patching this hole is to escape the &lt;code&gt;%&lt;/code&gt; wildcard character.  (For anyone not familiar with the escape clause on the operator, here's a link to the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa933232(SQL.80).aspx&quot;&gt;SQL Server documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un enfoque para parchar este agujero es escapar del &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;car&amp;aacute;cter comod&amp;iacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(Para cualquiera que no est&amp;eacute; familiarizado con la cl&amp;aacute;usula de escape del operador, aqu&amp;iacute; hay un enlace a la &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/aa933232(SQL.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;documentaci&amp;oacute;n de SQL Server&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d785d1b371bf1e0d416a3c1cf4b58af9de8c0682" translate="yes" xml:space="preserve">
          <source>Parameterize an SQL IN clause</source>
          <target state="translated">Parametrizar una cláusula SQL IN</target>
        </trans-unit>
        <trans-unit id="8bd73e8b6032d828eaae575e172d15ae190e9acc" translate="yes" xml:space="preserve">
          <source>Related: &lt;a href=&quot;https://www.brentozar.com/archive/2020/02/how-to-pass-a-list-of-values-into-a-stored-procedure/&quot;&gt;How to Pass a List of Values Into a Stored Procedure&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Relacionado: &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.brentozar.com/archive/2020/02/how-to-pass-a-list-of-values-into-a-stored-procedure/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C&amp;oacute;mo pasar una lista de valores a un procedimiento almacenado&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a7c790d520ea0368c427f57e2c38a9f1b62f724a" translate="yes" xml:space="preserve">
          <source>SQL Server also allows for wildcard characters to be treated as literals by enclosing them in brackets &lt;code&gt;[]&lt;/code&gt;.  So we're not done fixing yet, at least for SQL Server.  Since pairs of brackets have special meaning, we'll need to escape those as well.  If we manage to properly escape the brackets, then at least we won't have to bother with the hyphen &lt;code&gt;-&lt;/code&gt; and the carat &lt;code&gt;^&lt;/code&gt; within the brackets.  And we can leave any &lt;code&gt;%&lt;/code&gt;and &lt;code&gt;_&lt;/code&gt; characters inside the brackets escaped, since we'll have basically disabled the special meaning of the brackets.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SQL Server tambi&amp;eacute;n permite que los caracteres comod&amp;iacute;n se traten como literales encerr&amp;aacute;ndolos entre corchetes &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;As&amp;iacute; que todav&amp;iacute;a no hemos terminado de arreglar, al menos para SQL Server. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dado que los pares de par&amp;eacute;ntesis tienen un significado especial, tambi&amp;eacute;n necesitaremos escapar de esos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si logramos escapar adecuadamente de los corchetes, al menos no tendremos que molestarnos con el gui&amp;oacute;n &lt;/font&gt;&lt;/font&gt; &lt;code&gt;-&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y el quilate &lt;/font&gt;&lt;/font&gt; &lt;code&gt;^&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; dentro de los corchetes. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y podemos dejar cualquier &lt;/font&gt;&lt;/font&gt; &lt;code&gt;%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;_&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; caracteres dentro de los corchetes escapados, ya que b&amp;aacute;sicamente habremos deshabilitado el significado especial de los corchetes.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cf5871ddbc56fc0f2c14226259e67209782850cc" translate="yes" xml:space="preserve">
          <source>SQL with dynamic parameters.</source>
          <target state="translated">SQL con parámetros dinámicos.</target>
        </trans-unit>
        <trans-unit id="b34e6d11a266a89b525b0c300696a7d0682681bf" translate="yes" xml:space="preserve">
          <source>See the answer from Mark Brackett for the preferred answer that I (and 231 others) upvoted. The approach given in his answer allows 1) for effective use of bind variables, and 2) for predicates that are sargable.</source>
          <target state="translated">Vea la respuesta de Mark Brackett para la respuesta preferida que yo (y otros 231)votamos.El enfoque dado en su respuesta permite 1)para el uso efectivo de las variables bind,y 2)para los predicados que son sargentos.</target>
        </trans-unit>
        <trans-unit id="178bfb059f4a1822cfbe2ec9ebe2c39718e33adf" translate="yes" xml:space="preserve">
          <source>So basically if the count is 0 then there is no filter and everything goes through.  If the count is higher than 0 the then the value must be in the list, but the list has been padded out to five with impossible values (so that the SQL still makes sense)</source>
          <target state="translated">Así que,básicamente,si el recuento es 0,entonces no hay filtro y todo pasa.Si el conteo es mayor que 0 entonces el valor debe estar en la lista,pero la lista ha sido rellenada hasta cinco con valores imposibles (para que el SQL todavía tenga sentido)</target>
        </trans-unit>
        <trans-unit id="30f329f8fb37cb3f59749389eca8fa0f6f4ac58d" translate="yes" xml:space="preserve">
          <source>So here's the C# code:</source>
          <target state="translated">Así que aquí está el código C#:</target>
        </trans-unit>
        <trans-unit id="01e03d9a83d6e670a41622f3b700936b34789926" translate="yes" xml:space="preserve">
          <source>So that solves the problem with the % wildcard.  Almost.</source>
          <target state="translated">Así que eso resuelve el problema del % de comodín.Casi.</target>
        </trans-unit>
        <trans-unit id="bc224aea5e1e203f177bffceb162be21609d9157" translate="yes" xml:space="preserve">
          <source>So you have the string</source>
          <target state="translated">Así que tienes la cuerda</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="ac1dd42bff5436684704cd8cecb553fb4a51748f" translate="yes" xml:space="preserve">
          <source>Sometimes the lame solution is the only one that actually works.</source>
          <target state="translated">A veces,la solución más pobre es la única que realmente funciona.</target>
        </trans-unit>
        <trans-unit id="2187e96ff77893224d6a4fbd66eeac75a0523097" translate="yes" xml:space="preserve">
          <source>Stored procedure with table valued parameters. If the list can vary by a large amount use WITH RECOMPILE on the stored procedure, or simply use dynamic SQL without parameters to generate a new execution plan for each query.</source>
          <target state="translated">Procedimiento almacenado con parámetros de valor de tabla.Si la lista puede variar en gran medida utilice WITH RECOMPILE en el procedimiento almacenado,o simplemente utilice SQL dinámico sin parámetros para generar un nuevo plan de ejecución para cada consulta.</target>
        </trans-unit>
        <trans-unit id="49b0933c48745bbe595589a84f3c999c1aac15aa" translate="yes" xml:space="preserve">
          <source>Syscomments. Dinakar Nethi</source>
          <target state="translated">Sistemas.Dinakar Nethi</target>
        </trans-unit>
        <trans-unit id="f56c9210a9e2c9a6ed7f60b0c1718d038683158e" translate="yes" xml:space="preserve">
          <source>T-SQL:</source>
          <target state="translated">T-SQL:</target>
        </trans-unit>
        <trans-unit id="e03134a806a1e31e6209b7319743bf47eb301543" translate="yes" xml:space="preserve">
          <source>That inline expression in the SQL is getting longer and uglier.  We can probably make it work, but heaven help the poor soul that comes behind and has to decipher it.  As much of a fan I am for inline expressions, I'm inclined not use one here, mainly because I don't want to have to leave a comment explaining the reason for the mess, and apologizing for it.</source>
          <target state="translated">Esa expresión en línea en el SQL es cada vez más larga y fea.Probablemente podamos hacerla funcionar,pero que el cielo ayude a la pobre alma que viene detrás y tiene que descifrarla.Como soy un gran fan de las expresiones en línea,me inclino por no usar una aquí,principalmente porque no quiero tener que dejar un comentario explicando la razón del desorden,y disculpándome por ello.</target>
        </trans-unit>
        <trans-unit id="0ccc088929d1deebf84e0a4fa97b04fa55774e0d" translate="yes" xml:space="preserve">
          <source>That's it. And, yes, LINQ already looks backwards enough, but the &lt;code&gt;Contains&lt;/code&gt; clause seems extra backwards to me. When I had to do a similar query for a project at work, I naturally tried to do this the wrong way by doing a join between the local array and the SQL Server table, figuring the LINQ&amp;nbsp;to&amp;nbsp;SQL translator would be smart enough to handle the translation somehow. It didn't, but it did provide an error message that was descriptive and pointed me towards using &lt;em&gt;Contains&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Eso es. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y, s&amp;iacute;, LINQ ya mira lo suficientemente hacia atr&amp;aacute;s, pero la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cl&amp;aacute;usula &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Contains&lt;/code&gt; me&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; parece extra hacia atr&amp;aacute;s. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cuando tuve que hacer una consulta similar para un proyecto en el trabajo, naturalmente intent&amp;eacute; hacerlo de la manera incorrecta haciendo una uni&amp;oacute;n entre la matriz local y la tabla de SQL Server, pensando que el traductor LINQ to SQL ser&amp;iacute;a lo suficientemente inteligente como para manejar el traducci&amp;oacute;n de alguna manera. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;No lo hizo, pero proporcion&amp;oacute; un mensaje de error que fue descriptivo y me se&amp;ntilde;al&amp;oacute; hacia el uso de &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Contains&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8ff37281903edcab5bee93dfd2354fea3795197" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://stackoverflow.com/a/337817/5070879&quot;&gt;accepted answer&lt;/a&gt; will of course work and it is one of the way to go, but it is anti-pattern.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/337817/5070879&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;respuesta aceptada&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , por supuesto, funcionar&amp;aacute; y es uno de los caminos a seguir, pero es antipatr&amp;oacute;n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8eba07cdda4ea60d10a9bebc962b106ed7a8920a" translate="yes" xml:space="preserve">
          <source>The Oracle version:</source>
          <target state="translated">La versión del Oráculo:</target>
        </trans-unit>
        <trans-unit id="9d1745ae6f89bcb6009c23298fa1e007d88d88a9" translate="yes" xml:space="preserve">
          <source>The behavior we observe is kind of odd.  Changing the order of the search terms in the list changes the result set.</source>
          <target state="translated">El comportamiento que observamos es un poco extraño.Cambiar el orden de los términos de búsqueda en la lista cambia el conjunto de resultados.</target>
        </trans-unit>
        <trans-unit id="5476b01df6c35abd19c57b5f47c1bc4611a97014" translate="yes" xml:space="preserve">
          <source>The general pattern is easy to extend and can be used for passing more complex tables.</source>
          <target state="translated">La pauta general es fácil de extender y puede utilizarse para pasar tablas más complejas.</target>
        </trans-unit>
        <trans-unit id="fa033af9de3767d4d1bb2976f14c8950c3e8c353" translate="yes" xml:space="preserve">
          <source>The only winning move is not to play.</source>
          <target state="translated">El único movimiento ganador es no jugar.</target>
        </trans-unit>
        <trans-unit id="b9583a9b4dce8989dd711d081c33d9ffd91c7a42" translate="yes" xml:space="preserve">
          <source>The original question was &lt;strong&gt;&quot;How do I parameterize a query ...&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La pregunta original era &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;&amp;iquest;C&amp;oacute;mo parametrizo una consulta ...&quot;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="66954bd1bf64a819018f1c94116a783f1d835163" translate="yes" xml:space="preserve">
          <source>The performance is terrible. &lt;code&gt;LIKE &quot;%...%&quot;&lt;/code&gt; queries are not indexed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El rendimiento es terrible. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;LIKE &quot;%...%&quot;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no est&amp;aacute;n indexadas.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c595b1a23d029415bc9530e69c56a7bf52a907e6" translate="yes" xml:space="preserve">
          <source>The proper way IMHO is to store the list in a character string (limited in length by what the DBMS support); the only trick is that (in order to simplify processing) I have a separator (a comma in my example) at the beginning and at the end of the string. The idea is to &quot;normalize on the fly&quot;, turning the list into a one-column table that contains one row per value. This allows you to turn</source>
          <target state="translated">La forma apropiada de IMHO es almacenar la lista en una cadena de caracteres (limitada en su longitud por lo que soporta el SGBD);el único truco es que (para simplificar el procesamiento)tengo un separador (una coma en mi ejemplo)al principio y al final de la cadena.La idea es &quot;normalizar sobre la marcha&quot;,convirtiendo la lista en una tabla de una columna que contiene una fila por valor.Esto permite convertir</target>
        </trans-unit>
        <trans-unit id="080963f0ce43b16a038ca3c1cafb8009937c4fa2" translate="yes" xml:space="preserve">
          <source>The reuse of execution plans for stored procedures or parameterized queries may give you a performance gain, but it will lock you in to one execution plan determined by the first query that is executed. That may be less than ideal for subsequent queries in many cases. In your case, reuse of execution plans will probably be a plus, but it might not make any difference at all as the example is a really simple query.</source>
          <target state="translated">La reutilización de los planes de ejecución para los procedimientos almacenados o las consultas parametrizadas puede proporcionarle una ganancia de rendimiento,pero le encerrará en un plan de ejecución determinado por la primera consulta que se ejecute.Eso puede ser menos que ideal para las consultas posteriores en muchos casos.En su caso,la reutilización de los planes de ejecución será probablemente una ventaja,pero puede que no suponga ninguna diferencia ya que el ejemplo es una consulta realmente simple.</target>
        </trans-unit>
        <trans-unit id="a8eb233e5b6e8d0a30d47b4e1de065627dccaad7" translate="yes" xml:space="preserve">
          <source>The string can be built in any language. In this example I used SQL since that was the original problem I was trying to solve. I needed a clean way to pass in table data on the fly in a string to be executed later.</source>
          <target state="translated">La cuerda puede ser construida en cualquier idioma.En este ejemplo usé SQL ya que ese era el problema original que estaba tratando de resolver.Necesitaba una forma limpia de pasar datos de tablas sobre la marcha en una cadena para ser ejecutada más tarde.</target>
        </trans-unit>
        <trans-unit id="2a379f85b2c923f924ec4c11add17ee12c66803a" translate="yes" xml:space="preserve">
          <source>The user inputted values are still stuffed into parameters, so there is no vulnerability there.</source>
          <target state="translated">Los valores introducidos por el usuario todavía están metidos en los parámetros,por lo que no hay ninguna vulnerabilidad en ellos.</target>
        </trans-unit>
        <trans-unit id="46a9f25a51ce70904d83b4d2fdcce6438b367f5c" translate="yes" xml:space="preserve">
          <source>The values stored in the column may allow for % or _ characters, but a constraint may require those values to be escaped, perhaps using a defined character, such that the values are LIKE comparison &quot;safe&quot;.  Again, a quick comment about the allowed set of values, and in particular which character is used as an escape character, and go with Joel Spolsky's approach.</source>
          <target state="translated">Los valores almacenados en la columna pueden permitir caracteres de % o _,pero una restricción puede requerir que esos valores se escapen,tal vez utilizando un carácter definido,de manera que los valores sean COMO la comparación &quot;segura&quot;.De nuevo,un rápido comentario sobre el conjunto de valores permitidos,y en particular sobre qué carácter se utiliza como carácter de escape,e ir con el enfoque de Joel Spolsky.</target>
        </trans-unit>
        <trans-unit id="432f039b6ee44f960eebe9edc61390d464e6ea6f" translate="yes" xml:space="preserve">
          <source>Then all you have to do is pass the string as 1 parameter.</source>
          <target state="translated">Entonces todo lo que tienes que hacer es pasar la cadena como 1 parámetro.</target>
        </trans-unit>
        <trans-unit id="caabdeeafa5990eb317cda420543a417692b60d4" translate="yes" xml:space="preserve">
          <source>Then, your ADO.NET code looks like this:</source>
          <target state="translated">Entonces,tu código ADO.NET se ve así:</target>
        </trans-unit>
        <trans-unit id="92d757149ae4a77513eaebec2ba6645d7436a4bb" translate="yes" xml:space="preserve">
          <source>There are other ways to accomplish this that some people may consider cleaner, so please keep reading.</source>
          <target state="translated">Hay otras formas de lograrlo que algunas personas pueden considerar más limpias,así que por favor sigue leyendo.</target>
        </trans-unit>
        <trans-unit id="4ce52d75168ac74d2698141558de7e48bb776b1d" translate="yes" xml:space="preserve">
          <source>This approach is blogged about in &lt;a href=&quot;http://blogs.msdn.com/b/sqlserverstorageengine/archive/2015/11/03/openjson-one-of-best-ways-to-select-rows-by-list-of-id.aspx&quot;&gt;OPENJSON - one of best ways to select rows by list of ids&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Este enfoque se &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.msdn.com/b/sqlserverstorageengine/archive/2015/11/03/openjson-one-of-best-ways-to-select-rows-by-list-of-id.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bloguea&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;OPENJSON, una de las mejores formas de seleccionar filas por lista de identificadores&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="958feb18dbf8f4056efe483472623f67177a7660" translate="yes" xml:space="preserve">
          <source>This can be done with a recursive CTE, or a query with a number table (or Master..spt_value)</source>
          <target state="translated">Esto puede hacerse con un CTE recursivo,o una consulta con una tabla numérica (o Master..spt_value)</target>
        </trans-unit>
        <trans-unit id="08e5e9a6033c33675e7649a6d1cc1cacfea07f45" translate="yes" xml:space="preserve">
          <source>This has a bit of added flexibility in what you can do, but it's more suited for situations where you have a large table to query, with good indexing, and you want to use the parametrized list more than once. Saves having to execute it twice and have all the sanitation done manually.</source>
          <target state="translated">Esto tiene un poco más de flexibilidad en lo que puede hacer,pero es más adecuado para situaciones en las que tiene una gran tabla para consultar,con una buena indexación,y quiere usar la lista parametrizada más de una vez.Ahorra tener que ejecutarla dos veces y tener toda la limpieza hecha manualmente.</target>
        </trans-unit>
        <trans-unit id="89a375a792ce41774bf8ba73cfe56ee977890de5" translate="yes" xml:space="preserve">
          <source>This is gross, but if you are guaranteed to have at least one, you could do:</source>
          <target state="translated">Esto es asqueroso,pero si se garantiza que tienes al menos uno,podrías hacerlo:</target>
        </trans-unit>
        <trans-unit id="e29e488795dec60c287f82fd01f7fc119e047f6e" translate="yes" xml:space="preserve">
          <source>This is possibly a half nasty way of doing it, I used it once, was rather effective.</source>
          <target state="translated">Esta es posiblemente una forma medio desagradable de hacerlo,la usé una vez,fue bastante efectiva.</target>
        </trans-unit>
        <trans-unit id="923766af9d49d6ee8ab01954e13903dc14406c7f" translate="yes" xml:space="preserve">
          <source>This is replacement for common anti-pattern such as creating a dynamic SQL string in application layer or Transact-SQL, or by using LIKE operator:</source>
          <target state="translated">Esto es un reemplazo para los anti-patrones comunes como la creación de una cadena dinámica de SQL en la capa de aplicación o Transact-SQL,o mediante el uso del operador LIKE:</target>
        </trans-unit>
        <trans-unit id="5222b471ee3028d31cfe5f8af34e316502210ba5" translate="yes" xml:space="preserve">
          <source>To improve the &lt;code&gt;STRING_SPLIT&lt;/code&gt; table function row estimation, it is a good idea to materialize splitted values as temporary table/table variable:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para mejorar la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;estimaci&amp;oacute;n de fila de funci&amp;oacute;n de tabla &lt;/font&gt;&lt;/font&gt; &lt;code&gt;STRING_SPLIT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , es una buena idea materializar valores divididos como tabla / variable de tabla temporal:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2222e8c9448d0d44594f587bbcbc82c4ad1019e9" translate="yes" xml:space="preserve">
          <source>Two caveats:</source>
          <target state="translated">Dos advertencias:</target>
        </trans-unit>
        <trans-unit id="5440af73b429739161f6ba1b784dfd0beaa7c95f" translate="yes" xml:space="preserve">
          <source>Unfortunately, the techniques to slice a string are fairly product-specific.
Here is the SQL Server version:</source>
          <target state="translated">Desafortunadamente,las técnicas para cortar una cuerda son bastante específicas del producto.Aquí está la versión del servidor SQL:</target>
        </trans-unit>
        <trans-unit id="8fdf7787fac70523813d9ee461dc51c98f04f4ec" translate="yes" xml:space="preserve">
          <source>Unless you have a ridiculously long string, this should work well with the table index.</source>
          <target state="translated">A menos que tengas una cuerda ridículamente larga,esto debería funcionar bien con el índice de la mesa.</target>
        </trans-unit>
        <trans-unit id="2443ed13c972cd5cc6bdc47153849869b4ac0910" translate="yes" xml:space="preserve">
          <source>Use the following stored procedure. It uses a custom split function, which can be found &lt;a href=&quot;http://blogs.microsoft.co.il/blogs/itai/archive/2009/02/01/t-sql-split-function.aspx&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Use el siguiente procedimiento almacenado. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Utiliza una funci&amp;oacute;n de divisi&amp;oacute;n personalizada, que se puede encontrar &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://blogs.microsoft.co.il/blogs/itai/archive/2009/02/01/t-sql-split-function.aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aqu&amp;iacute;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc0e34154d952ed72b15f5d9618112640d548177" translate="yes" xml:space="preserve">
          <source>Use:</source>
          <target state="translated">Use:</target>
        </trans-unit>
        <trans-unit id="fc4db109b0b74a21e7b65fe2cccd3e5e113eabea" translate="yes" xml:space="preserve">
          <source>Using a user defined type is optional. Creating the type is only created once and can be done ahead of time. Otherwise just add a full table type to the declaration in the string.</source>
          <target state="translated">El uso de un tipo definido por el usuario es opcional.La creación del tipo sólo se hace una vez y se puede hacer con antelación.De lo contrario,sólo hay que añadir un tipo de tabla completa a la declaración en la cadena.</target>
        </trans-unit>
        <trans-unit id="ea109569ae92ebf585a2849dd893eef36a9892b4" translate="yes" xml:space="preserve">
          <source>We have function that creates a table variable that you can join to:</source>
          <target state="translated">Tenemos una función que crea una variable de la tabla a la que puedes unirte:</target>
        </trans-unit>
        <trans-unit id="360d577f191fc4129da8ba5e7e42f6459f455eea" translate="yes" xml:space="preserve">
          <source>We may have specialized knowledge of the domain for the column, (that is, the set of allowable values enforced for the column.  We may know &lt;em&gt;a priori&lt;/em&gt; that the values stored in the column will never contain a percent sign, an underscore, or bracket pairs.  In that case, we just include a quick comment that those cases are covered.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es posible que tengamos un conocimiento especializado del dominio de la columna (es decir, el conjunto de valores permitidos para la columna. Podemos saber &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;a priori&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; que los valores almacenados en la columna nunca contendr&amp;aacute;n un signo de porcentaje, un gui&amp;oacute;n bajo o un corchete En ese caso, solo incluimos un comentario r&amp;aacute;pido de que esos casos est&amp;aacute;n cubiertos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1eb0105114c419b879dc13efdb354bd9c4fdc800" translate="yes" xml:space="preserve">
          <source>We recognize that our solution has introduced another problem.  The escape character.  We see that we're also going to need to escape any occurrences of escape character itself.  This time, we use the ! as the escape character:</source>
          <target state="translated">Reconocemos que nuestra solución ha introducido otro problema.El personaje de la fuga.Vemos que también vamos a tener que escapar de cualquier ocurrencia de carácter de escape en sí.Esta vez,usamos el ! como el personaje de escape:</target>
        </trans-unit>
        <trans-unit id="a7e764b14c40a72de7506566f1043d46bb0179bf" translate="yes" xml:space="preserve">
          <source>What I want to address here is the approach given in Joel Spolsky's answer, the answer &quot;selected&quot; as the right answer.</source>
          <target state="translated">Lo que quiero abordar aquí es el enfoque dado en la respuesta de Joel Spolsky,la respuesta &quot;seleccionada&quot; como la respuesta correcta.</target>
        </trans-unit>
        <trans-unit id="6450bd884edaaafc8f2c30b098dfab9b71545cba" translate="yes" xml:space="preserve">
          <source>Which will give you:</source>
          <target state="translated">Lo que te dará:</target>
        </trans-unit>
        <trans-unit id="c20d641e26d4310fe7f10673ba7c0d0a8a4f2ea5" translate="yes" xml:space="preserve">
          <source>Which you could use like this,</source>
          <target state="translated">Que podrías usar así,</target>
        </trans-unit>
        <trans-unit id="a1c640d00154452803b29c203f1d50877797b971" translate="yes" xml:space="preserve">
          <source>With that said, go ahead and flag this answer, downvote it, mark it as not an answer... do whatever you believe is right.</source>
          <target state="translated">Dicho esto,adelante y marca esta respuesta,vota en contra,márcala como no una respuesta...haz lo que creas que es correcto.</target>
        </trans-unit>
        <trans-unit id="d453d5e94a94b047c31fc338808abef090d3c920" translate="yes" xml:space="preserve">
          <source>Yes, I've gone far afield from the original question.  But where else to leave this note concerning what I consider to be an important issue with the &quot;selected&quot; answer for a question?</source>
          <target state="translated">Sí,me he alejado mucho de la pregunta original.¿Pero dónde más dejar esta nota sobre lo que considero un asunto importante con la respuesta &quot;seleccionada&quot; para una pregunta?</target>
        </trans-unit>
        <trans-unit id="c6194e2b66441e85c192f849cd73f13ef5f725d2" translate="yes" xml:space="preserve">
          <source>You can parameterize &lt;em&gt;each&lt;/em&gt; value, so something like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Puede parametrizar &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;cada&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; valor, as&amp;iacute; que algo como:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="540ae451a6a2159c5ecb0af841f18229951bd533" translate="yes" xml:space="preserve">
          <source>You can pass the parameter as a string</source>
          <target state="translated">Puedes pasar el parámetro como una cadena</target>
        </trans-unit>
        <trans-unit id="02d42af71a7eac7a8292d95356882939546d4a05" translate="yes" xml:space="preserve">
          <source>You can use the above statement in your .NET code and map the parameter with SqlParameter.</source>
          <target state="translated">Puedes usar la declaración anterior en tu código .NET y mapear el parámetro con SqlParameter.</target>
        </trans-unit>
        <trans-unit id="87437dc5ed8516a409cda3c960e12ffdcacc4b99" translate="yes" xml:space="preserve">
          <source>You really only need a way to convert the string into a table.</source>
          <target state="translated">En realidad sólo necesitas una forma de convertir la cuerda en una tabla.</target>
        </trans-unit>
        <trans-unit id="97e786164e7d144a82e75203dad2c623c0c11c82" translate="yes" xml:space="preserve">
          <source>and the MySQL version:</source>
          <target state="translated">y la versión de MySQL:</target>
        </trans-unit>
        <trans-unit id="3df8dd48aae8c0e7b8d71dd615f0f99c126b5e95" translate="yes" xml:space="preserve">
          <source>in (ct1,ct2, ct3 ... ctn)</source>
          <target state="translated">en (ct1,ct2,ct3 ...ctn)</target>
        </trans-unit>
        <trans-unit id="ce276f235956637e004c786d0c39a7ea5a549d44" translate="yes" xml:space="preserve">
          <source>in (select ...)</source>
          <target state="translated">en (seleccione ...)</target>
        </trans-unit>
        <trans-unit id="edb6b110bc010a020fc6176e807d09190584bb53" translate="yes" xml:space="preserve">
          <source>into an</source>
          <target state="translated">en un</target>
        </trans-unit>
        <trans-unit id="5bc416d9e2f5537e6bed7be9378837b7a0d5e3d1" translate="yes" xml:space="preserve">
          <source>optimizer plan using index scan rather than index seeks, possible need for an expression or function for escaping wildcards (possible index on expression or function)</source>
          <target state="translated">plan de optimización utilizando el índice de exploración en lugar del índice de búsqueda,posible necesidad de una expresión o función para escapar de los comodines (posible índice en la expresión o función)</target>
        </trans-unit>
        <trans-unit id="0b307b480fb16b98df07abaaae5ec29863540be3" translate="yes" xml:space="preserve">
          <source>or (the solution I'd probably prefer) a regular join, if you just add a &quot;distinct&quot; to avoid problems with duplicate values in the list.</source>
          <target state="translated">o (la solución que probablemente preferiría)una unión regular,si sólo se añade un &quot;distinto&quot; para evitar problemas de valores duplicados en la lista.</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="cc20f4add2f0b69a52b77cefaa7e7f09d88dca49" translate="yes" xml:space="preserve">
          <source>using literal values in place of bind variables impacts scalability</source>
          <target state="translated">El uso de valores literales en lugar de variables vinculantes afecta a la escalabilidad</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
