<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/336859">
    <body>
      <group id="336859">
        <trans-unit id="759ade596a378339a3599da452aa422c31d07445" translate="yes" xml:space="preserve">
          <source>&quot;Anonymous&quot; &lt;code&gt;function&lt;/code&gt; Expression</source>
          <target state="translated">&quot;익명&quot; &lt;code&gt;function&lt;/code&gt; 표현식</target>
        </trans-unit>
        <trans-unit id="c513b3ca88a099b3024dc76dce26a4fc3fd75194" translate="yes" xml:space="preserve">
          <source>&quot;Anonymous&quot; &lt;code&gt;function&lt;/code&gt; Expression &lt;em&gt;(which despite the term, sometimes create functions with names)&lt;/em&gt;</source>
          <target state="translated">&quot;익명&quot; &lt;code&gt;function&lt;/code&gt; 표현식 &lt;em&gt;(이 용어에도 불구하고 때때로 이름을 가진 함수를 작성 함)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5faf09af21e3ee207861762a8a8fc90fff45652" translate="yes" xml:space="preserve">
          <source>(Note also that assignment should require a semicolon after the statement, while declaration prohibits it.)</source>
          <target state="translated">(선언에서는 선언이 금지하는 반면, 할당에는 명령문 뒤에 세미콜론이 필요합니다.)</target>
        </trans-unit>
        <trans-unit id="624606f5ae627bc4f6dabd67b23d018b1256e5ee" translate="yes" xml:space="preserve">
          <source>(Remember that &lt;code&gt;Array#map&lt;/code&gt; passes the entry as the first argument, and the index as the second.)</source>
          <target state="translated">&lt;code&gt;Array#map&lt;/code&gt; 은 항목을 첫 번째 인수로, 인덱스를 두 번째 인수로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="a6c2457af43114c5ee77f6c6836420d7fa86f67e" translate="yes" xml:space="preserve">
          <source>, this definition of &lt;code&gt;myfunction&lt;/code&gt; will override any previous definition, since it will be done at parse-time.</source>
          <target state="translated">이 &lt;code&gt;myfunction&lt;/code&gt; 정의는 구문 분석시 수행되므로 이전 정의를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="6ae78ea2e192017c2e6cecf189c9877327296eb4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://ejohn.org/apps/learn/#13&quot;&gt;Tests fail when the original ninja object is removed.&lt;/a&gt; (page 13)</source>
          <target state="translated">&lt;a href=&quot;http://ejohn.org/apps/learn/#13&quot;&gt;원래 닌자 개체를 제거하면 테스트가 실패합니다.&lt;/a&gt; (13 페이지)</target>
        </trans-unit>
        <trans-unit id="c9c4f8471c82ec45ea1185e07850a97d382be68f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://ejohn.org/apps/learn/#14&quot;&gt;If you name the function that will be called recursively, the tests will pass.&lt;/a&gt; (page 14)</source>
          <target state="translated">&lt;a href=&quot;http://ejohn.org/apps/learn/#14&quot;&gt;재귀 적으로 호출 될 함수의 이름을 지정하면 테스트가 통과됩니다.&lt;/a&gt; (14 페이지)</target>
        </trans-unit>
        <trans-unit id="976105ab4e318e4ac55a458be9a6999ab9810e70" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-arrow-function-definitions-static-semantics-early-errors&quot;&gt;&lt;code&gt;ArrowFunction : ArrowParameters =&amp;gt; ConciseBody&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-arrow-function-definitions-static-semantics-early-errors&quot;&gt; &lt;code&gt;ArrowFunction : ArrowParameters =&amp;gt; ConciseBody&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="49d146068ed625d5d7328105f5e36bab6f733a04" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/336868/2730064&quot;&gt;Greg's Answer&lt;/a&gt; is good enough, but I still would like to add something to it that I learned just now watching &lt;a href=&quot;https://en.wikipedia.org/wiki/Douglas_Crockford&quot;&gt;Douglas Crockford's&lt;/a&gt; videos.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/336868/2730064&quot;&gt;Greg의 답변&lt;/a&gt; 은 충분하지만 지금 &lt;a href=&quot;https://en.wikipedia.org/wiki/Douglas_Crockford&quot;&gt;Douglas Crockford의&lt;/a&gt; 비디오를 시청하면서 배운 내용을 추가하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="0c6835d261dfeeb9aa6c128ca4439678deec43ae" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/26394/eugene-lazutkin&quot;&gt;@EugeneLazutkin&lt;/a&gt; gives an example where he &lt;a href=&quot;https://stackoverflow.com/a/338053/&quot;&gt;names an assigned function to be able to use &lt;code&gt;shortcut()&lt;/code&gt;&lt;/a&gt; as an internal reference to itself. &lt;a href=&quot;http://ejohn.org/&quot;&gt;John Resig&lt;/a&gt; gives another example - &lt;em&gt;copying a recursive function assigned to another object&lt;/em&gt; in his &lt;a href=&quot;http://ejohn.org/apps/learn/&quot;&gt;Learning Advanced Javascript&lt;/a&gt; tutorial. While assigning functions to properties isn't strictly the question here, I recommend actively trying the tutorial out - run the code by clicking the button in the upper right corner, and double click the code to edit to your liking.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/26394/eugene-lazutkin&quot;&gt;@EugeneLazutkin&lt;/a&gt; 은 &lt;a href=&quot;https://stackoverflow.com/a/338053/&quot;&gt; &lt;code&gt;shortcut()&lt;/code&gt; &lt;/a&gt; 를 내부 참조로 사용할 수 있도록 할당 된 함수의 이름을 지정 하는 예를 제공합니다. &lt;a href=&quot;http://ejohn.org/&quot;&gt;John Resig&lt;/a&gt; 는 &lt;a href=&quot;http://ejohn.org/apps/learn/&quot;&gt;Learning Advanced Javascript&lt;/a&gt; tutorial에서 &lt;em&gt;다른 객체&lt;/em&gt; 에 &lt;em&gt;지정된 재귀 함수를 복사하는&lt;/em&gt; 또 다른 예를 제공합니다. 속성에 함수를 할당하는 것은 여기서 중요한 문제는 아니지만 적극적으로 튜토리얼을 시도하는 것이 좋습니다. 오른쪽 상단 모서리에있는 버튼을 클릭하여 코드를 실행하고 코드를 두 번 클릭하여 원하는대로 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="7b0c22340550205afa033ace7d2728b4aad0f9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Anonymous&lt;/code&gt; function expressions &lt;a href=&quot;https://jsperf.com/named-vs-anonymous-expressions&quot;&gt;appear to have better performance&lt;/a&gt;
  against &lt;code&gt;Named&lt;/code&gt; function expression.</source>
          <target state="translated">&lt;code&gt;Anonymous&lt;/code&gt; 함수 표현식 &lt;a href=&quot;https://jsperf.com/named-vs-anonymous-expressions&quot;&gt;은&lt;/a&gt; &lt;code&gt;Named&lt;/code&gt; 함수 표현식에 비해 성능이 더 우수한 것으로 보입니다 .</target>
        </trans-unit>
        <trans-unit id="c96f22714847a8babc3882697bb6248bc8fde655" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abc&lt;/code&gt; here is defined everywhere in the current scope:</source>
          <target state="translated">여기서 &lt;code&gt;abc&lt;/code&gt; 는 현재 범위의 모든 곳에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="33da11fb99d15d78d5a520754cccc634c18cce28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new Function()&lt;/code&gt; can be used to pass the function's body in a string. And hence this can be used to create dynamic functions. Also passing the script without executing the script.</source>
          <target state="translated">&lt;code&gt;new Function()&lt;/code&gt; 을 사용하여 함수 본문을 문자열로 전달할 수 있습니다. 따라서 동적 함수를 만드는 데 사용할 수 있습니다. 또한 스크립트를 실행하지 않고 스크립트를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="d921a21481f849741d142fe29c5ea098ea13f130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xyz&lt;/code&gt; here is defined from the point of assignment:</source>
          <target state="translated">여기서 &lt;code&gt;xyz&lt;/code&gt; 는 할당 지점에서 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="f861ab5b26e3b088b115db80714f64319137c837" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xyz&lt;/code&gt; is going to be defined as usual, &lt;code&gt;abc&lt;/code&gt; is undefined in all browsers but Internet&amp;nbsp;Explorer &amp;mdash; do not rely on it being defined. But it will be defined inside its body:</source>
          <target state="translated">&lt;code&gt;xyz&lt;/code&gt; 는 평소와 같이 정의되며 &lt;code&gt;abc&lt;/code&gt; 는 모든 브라우저에서 정의되지 않지만 Internet Explorer는 정의되어 있으므로 의존하지 마십시오. 그러나 그것은 몸 안에 정의 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="0996d262b069210bf614fbe919b57e1dcbed7423" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Another way to refer to itself is to use &lt;code&gt;arguments.callee&lt;/code&gt;, which is still relatively long, and not supported in the strict mode.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(자체를 참조하는 다른 방법은 &lt;code&gt;arguments.callee&lt;/code&gt; 를 사용하는 것입니다. arguments.callee 는 여전히 길고 엄격 모드에서는 지원되지 않습니다.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d089b89c261d900b8d8ac6af9b57fdc04eb3614b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(function)&lt;/em&gt;.name</source>
          <target state="translated">&lt;em&gt;(function)&lt;/em&gt;.name</target>
        </trans-unit>
        <trans-unit id="12f5dfe559b4186c923fded6e04fcd3ed6a3a0f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;But in the case with function declarations, the entire function body will be hoisted as well&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;그러나 함수 선언의 경우 전체 함수 본문도 함께 게양됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4bba3d17467d019bf50243da72010e06e9c2c779" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Function assigned to variable Example:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;변수에 지정된 기능 예 :&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="541cf619a3af25cde3b6df2217443cef1e854fc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;However, only the actual declarations are hoisted. by leaving assignments where they are.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;그러나 실제 선언 만 게양됩니다.&lt;/em&gt; &lt;em&gt;할당 된 위치를 그대로 둡니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77f992d8ae7a03a56428e18ae9187411b99ffeca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Javascript is called loosely typed language. Which means Javascript variables can hold value of any &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/7wkd9z69(v=vs.94).aspx&quot;&gt;Data-Type&lt;/a&gt;. Javascript automatically takes care of changing the variable-type based on the value/literal provided during runtime.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;자바 스크립트를 느슨하게 입력 한 언어라고합니다.&lt;/em&gt; &lt;em&gt;이는 Javascript 변수가 모든 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/7wkd9z69(v=vs.94).aspx&quot;&gt;Data-Type&lt;/a&gt; 값을 보유 할 수 있음을 의미합니다.&lt;/em&gt; &lt;em&gt;Javascript는 런타임 중에 제공된 값 / 리터럴에 따라 변수 유형 변경을 자동으로 처리합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e30fdc640add63f2972505e1f77a336d70750ed6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Function Expression&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. 함수 표현&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b2fd7065f9c16a465c2734b147eab3e80052db0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Function Declaration&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. 함수 선언&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1263cf84aad82d1a3af0dc6f1805903c828d3b71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://www.sitepoint.com/back-to-basics-javascript-hoisting/&quot;&gt;Hoisting&lt;/a&gt;&lt;/strong&gt;&lt;em&gt;is the JavaScript interpreter&amp;rsquo;s action of moving all variable and function declarations to the top of the current scope.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://www.sitepoint.com/back-to-basics-javascript-hoisting/&quot;&gt;호이 스팅&lt;/a&gt;&lt;/strong&gt; &lt;em&gt;은 모든 변수 및 함수 선언을 현재 범위의 맨 위로 이동하는 JavaScript 해석기의 동작입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f8747b2198f82905e46a1dbab75b4c9e9d7cdf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Variables&quot;&gt;Variable&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Variables&quot;&gt;Variable&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1335367051d267cd116cce2e6c150c50e7bd97ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/a/45759444/5081877&quot;&gt;ES5 Constructor Function Classes&lt;/a&gt;: Function objects created using Function.prototype.bind&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/a/45759444/5081877&quot;&gt;ES5 생성자 함수 클래스&lt;/a&gt; : Function.prototype.bind를 사용하여 생성 된 함수 객체&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="370b180b017647cca99bd02f7e986cfc2b8fde8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;About performance:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;성능 정보 :&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0fe5a78a445808092f814ad102d2a04ac9fb2f93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Chrome 62.0.3202&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;크롬 62.0.3202&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dae75490d4f79450f13d95e95c5513055074b89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Chrome Canary 63.0.3225&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;크롬 카나리아 63.0.3225&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8466249d1be58422b099d51dfe0e1f8cc0d6448" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;FireFox 55&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;파이어 폭스 55&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19552d8c7b704459a1b16248ad256dc0c0139741" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Firefox&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;Chrome Canary&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;Chrome&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Firefox&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;Chrome 카나리아&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;Chrome&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58c08f0bbcc6004dd7cb688f6907939c10e640b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES2015&lt;/strong&gt;: &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript 2015&lt;/a&gt; (also known as &quot;ES6&quot;)</source>
          <target state="translated">&lt;strong&gt;ES2015&lt;/strong&gt; : &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript 2015&lt;/a&gt; ( &quot;ES6&quot;이라고도 함)</target>
        </trans-unit>
        <trans-unit id="eccd9ae887601fcaf5c02293700ed6d0c8b205db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES5&lt;/strong&gt;: &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript 5th edition&lt;/a&gt;, 2009</source>
          <target state="translated">&lt;strong&gt;ES5&lt;/strong&gt; : &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript 5 판&lt;/a&gt; , 2009</target>
        </trans-unit>
        <trans-unit id="1ec7544bfadafd964172ff845f75d06fbafca512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function Declaration&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;함수 선언&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="469a2d465d6d3686feebc839c5b59f7f7284c5c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function Expression&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;함수 표현&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1a6cbedbfde0d5779de0a3fcf412af63bdea4f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function declarations&lt;/strong&gt; are faster, and that's what really matters in web dev right? ;)</source>
          <target state="translated">&lt;strong&gt;함수 선언&lt;/strong&gt; 이 더 빠르며 웹 개발에서 실제로 중요한 것이 무엇입니까? ;)</target>
        </trans-unit>
        <trans-unit id="f6569a24239dbe2b55280c9506730daaf0a33e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function expression:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;함수 표현 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="586c2626c76ccfb4558d9e83014f345dd1382003" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function statement:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;기능 설명 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="936746e12db1da44d0d71d56ca5aafef2816cddd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Function&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b3af9f83ea8d3b337e7d7b746f4759ca51365d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More technical information&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;더 많은 기술 정보&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="99755834340590f1e6358b23e87882e9a22abad2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This answer has been merged from &lt;a href=&quot;https://stackoverflow.com/questions/3435709/why-are-functions-in-javascript-set-to-global-variables-instead-of-plain-function&quot;&gt;another question&lt;/a&gt;, in which the major doubt and misconception from the OP was that identifiers declared with a &lt;code&gt;FunctionDeclaration&lt;/code&gt;, couldn't be overwritten which is not the case.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; :이 답변은 OP의 주요 의심과 오해가 &lt;code&gt;FunctionDeclaration&lt;/code&gt; 으로 선언 된 식별자를 덮어 쓸 수 없다는 &lt;a href=&quot;https://stackoverflow.com/questions/3435709/why-are-functions-in-javascript-set-to-global-variables-instead-of-plain-function&quot;&gt;또 다른 질문&lt;/a&gt; 에서 병합되었습니다.</target>
        </trans-unit>
        <trans-unit id="6a630a0d47ae66e4b85b0b41819338abf93e312a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why no error? We were always taught that expressions are executed from top to bottom(??)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;왜 오류가 없습니까?&lt;/strong&gt; &lt;strong&gt;우리는 항상식이 위에서 아래로 실행된다는 것을 배웠습니다 (??)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e98f3eda3b4182b03fb95ad990fb05e68273244" translate="yes" xml:space="preserve">
          <source>A Function Declaration defines a named function variable without
  requiring variable assignment. Function Declarations occur as
  standalone constructs and cannot be nested within non-function blocks.
  It&amp;rsquo;s helpful to think of them as siblings of Variable Declarations.
  Just as Variable Declarations must start with &amp;ldquo;var&amp;rdquo;, Function
  Declarations must begin with &amp;ldquo;function&amp;rdquo;.</source>
          <target state="translated">함수 선언은 변수 할당을 요구하지 않고 명명 된 함수 변수를 정의합니다. 함수 선언은 독립형 구조로 발생하며 비 기능 블록 내에 중첩 될 수 없습니다. 변수 선언의 형제로 생각하면 도움이됩니다. 변수 선언이 &quot;var&quot;로 시작해야하는 것처럼 함수 선언은 &quot;function&quot;으로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="e05d42878c1cb04c0e530b3d07925d7a26e19963" translate="yes" xml:space="preserve">
          <source>A Function Expression defines a function as a part of a larger
  expression syntax (typically a variable assignment ). Functions
  defined via Functions Expressions can be named or anonymous. Function
  Expressions must not start with &amp;ldquo;function&amp;rdquo; (hence the parentheses
  around the self invoking example below).</source>
          <target state="translated">함수 표현식은 함수를 더 큰 표현식 구문 (일반적으로 변수 할당)의 일부로 정의합니다. 함수 표현식을 통해 정의 된 함수는 이름을 지정하거나 익명으로 지정할 수 있습니다. 함수 표현식은 &quot;function&quot;으로 시작해서는 안됩니다 (따라서 아래의 자체 호출 예제 주위의 괄호).</target>
        </trans-unit>
        <trans-unit id="86c7d8de9fcbc249405893d86e8bf42e97cb3dc8" translate="yes" xml:space="preserve">
          <source>A better explanation to &lt;a href=&quot;https://stackoverflow.com/a/336868/2351696&quot;&gt;Greg's answer&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/336868/2351696&quot;&gt;그렉의 대답에&lt;/a&gt; 대한 더 나은 설명</target>
        </trans-unit>
        <trans-unit id="6ca6b62f63765f6b37e6981c3fed49c39887418d" translate="yes" xml:space="preserve">
          <source>A couple of things about arrow functions:</source>
          <target state="translated">화살표 기능에 대한 몇 가지 사항 :</target>
        </trans-unit>
        <trans-unit id="ba0bdb333e496781fbc28d1e1f11621acc2fdcab" translate="yes" xml:space="preserve">
          <source>A function declaration and a function expression assigned to a variable behave the same once the binding is established.</source>
          <target state="translated">변수에 지정된 함수 선언과 함수 표현식은 바인딩이 설정되면 동일하게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="586bbbe275e196b61f2bc269fbbcbefbe2f755d3" translate="yes" xml:space="preserve">
          <source>A function declaration can be placed anywhere in the code. Even if it is invoked before the definition appears in code, it gets executed as function declaration is committed to memory or in a way it is hoisted up, before any other code in the page starts execution.</source>
          <target state="translated">함수 선언은 코드의 어느 곳에 나 배치 할 수 있습니다. 정의가 코드에 나타나기 전에 호출 되더라도 함수 선언이 메모리에 커밋되거나 페이지의 다른 코드가 실행되기 전에 게양되는 방식으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="fe52a62968b799ba8d3437f69fe7e179496e354b" translate="yes" xml:space="preserve">
          <source>A function declaration defines a named function variable without requiring variable assignment. Function declarations occur as standalone constructs and cannot be nested within non-function blocks.</source>
          <target state="translated">함수 선언은 변수 할당없이 명명 된 함수 변수를 정의합니다. 함수 선언은 독립형 구조로 발생하며 비 기능 블록 내에 중첩 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dffe6e21959b36399921690a083098ea3f43b751" translate="yes" xml:space="preserve">
          <source>A function declaration is a &lt;em&gt;declaration&lt;/em&gt;; it's not a statement or expression. As such, you don't follow it with a &lt;code&gt;;&lt;/code&gt; (although doing so is harmless).</source>
          <target state="translated">함수 선언은 &lt;em&gt;선언입니다&lt;/em&gt; . 진술이나 표현이 아닙니다. 따라서, 당신은 그것을 따라 가지 않습니다 &lt;code&gt;;&lt;/code&gt; (그렇지만 무해합니다).</target>
        </trans-unit>
        <trans-unit id="c4b8b821c2b59fa8045994d19ff4ed224c59880d" translate="yes" xml:space="preserve">
          <source>A function declaration is processed when execution enters the context in which it appears, &lt;strong&gt;before&lt;/strong&gt; any step-by-step code is executed. The function it creates is given a proper name (&lt;code&gt;x&lt;/code&gt; in the example above), and that name is put in the scope in which the declaration appears.</source>
          <target state="translated">함수 선언은 단계별 코드가 실행 &lt;strong&gt;되기 전에&lt;/strong&gt; 실행이 나타나는 컨텍스트에 들어갈 때 처리됩니다. 그것이 생성하는 함수는 적절한 이름 (위 예제에서 &lt;code&gt;x&lt;/code&gt; ) 이 주어지고, 그 이름은 선언이 나타나는 범위에 놓입니다.</target>
        </trans-unit>
        <trans-unit id="6da90f6adb068378f7bee811147f83784b13cd26" translate="yes" xml:space="preserve">
          <source>A function expression defines a function as a part of a larger expression syntax (typically a variable assignment ). Functions defined via functions expressions can be named or anonymous. Function expressions should not start with &amp;ldquo;function&amp;rdquo;.</source>
          <target state="translated">함수 표현식은 함수를 더 큰 표현식 구문 (일반적으로 변수 할당)의 일부로 정의합니다. 함수 표현식을 통해 정의 된 함수는 이름을 지정하거나 익명으로 지정할 수 있습니다. 함수 표현식은 &quot;function&quot;으로 시작하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d1a8159e77618cdd4843f0dd77192ef3cc619005" translate="yes" xml:space="preserve">
          <source>A function expression, if not defined before calling it, will result in an error. Also, here the function definition itself is not moved to the top or committed to memory like in the function declarations. But the variable to which we assign the function gets hoisted up and &lt;strong&gt;undefined&lt;/strong&gt; gets assigned to it.</source>
          <target state="translated">함수 표현식을 호출하기 전에 정의하지 않으면 오류가 발생합니다. 또한 여기에서 함수 정의 자체는 함수 선언과 같이 맨 위로 이동하거나 메모리에 커밋되지 않습니다. 그러나 우리가 함수를 할당 한 변수는 게양되고 &lt;strong&gt;정의되지 않은&lt;/strong&gt; 변수가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="1e474c78af8f1973b4e36a580194a43c560f1983" translate="yes" xml:space="preserve">
          <source>A global property created by a &lt;code&gt;FunctionDeclaration&lt;/code&gt; can be overwritten without any problems just like a variable value, e.g.:</source>
          <target state="translated">&lt;code&gt;FunctionDeclaration&lt;/code&gt; 에 의해 생성 된 전역 속성은 변수 값과 같은 문제없이 다음과 같이 덮어 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="16985658b3a31ca6aeffc5a5893a992a5e8008b3" translate="yes" xml:space="preserve">
          <source>A must read:</source>
          <target state="translated">반드시 읽어야합니다.</target>
        </trans-unit>
        <trans-unit id="e868506d981fb5c0f6384bf8996fdae27caec377" translate="yes" xml:space="preserve">
          <source>About your edited first example (&lt;code&gt;foo = function() { alert('hello!'); };&lt;/code&gt;), it is an undeclared assignment, I would highly encourage you to always use the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">편집 된 첫 번째 예제 ( &lt;code&gt;foo = function() { alert('hello!'); };&lt;/code&gt; )에 대해서는 선언되지 않은 할당이므로 항상 &lt;code&gt;var&lt;/code&gt; 키워드를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3eb314099eec1e9d7c9302b330fab0de04e4d5a0" translate="yes" xml:space="preserve">
          <source>Accessor Function Initializer (ES5+)</source>
          <target state="translated">액세서 기능 이니셜 라이저 (ES5 +)</target>
        </trans-unit>
        <trans-unit id="5e996e3eab307a7b71ac3432752e7fdfb923a820" translate="yes" xml:space="preserve">
          <source>Also see &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/881515/&quot;&gt;How do I declare a namespace in JavaScript?&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/881515/&quot;&gt;JavaScript로 네임 스페이스를 선언하는 방법&lt;/a&gt;&lt;/em&gt; 도 참조하십시오 &lt;em&gt;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0da3dc3f13523455887513be16fc6b61206dd05d" translate="yes" xml:space="preserve">
          <source>Also, if you need more info about how hoisting works in JavaScript, visit the link below:</source>
          <target state="translated">또한 JavaScript에서 호이 스팅이 작동하는 방식에 대한 자세한 정보가 필요하면 아래 링크를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="14a4adf4af3f12e24e5839d70532eff9bbc83168" translate="yes" xml:space="preserve">
          <source>Also, it hoisted through a &lt;code&gt;return&lt;/code&gt; statement:</source>
          <target state="translated">또한 &lt;code&gt;return&lt;/code&gt; 진술을 통해 호이스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="83c03304952acf14e910695cd06f40d8b9fbbec0" translate="yes" xml:space="preserve">
          <source>Also, undeclared assignments throw a &lt;code&gt;ReferenceError&lt;/code&gt; on ECMAScript 5 under &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/&quot;&gt;Strict Mode&lt;/a&gt;.</source>
          <target state="translated">또한 선언되지 않은 할당은 &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/&quot;&gt;엄격한 모드&lt;/a&gt; 아래 ECMAScript 5에서 &lt;code&gt;ReferenceError&lt;/code&gt; 를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="d69902d08f0a65094ca17202194440fc3b8aeba6" translate="yes" xml:space="preserve">
          <source>Although doing this wasn't &lt;em&gt;specified&lt;/em&gt; until ES2015, it was an &lt;em&gt;allowable extension&lt;/em&gt; to support function declarations in blocks. Unfortunately (and inevitably), different engines did different things.</source>
          <target state="translated">이 작업은 ES2015까지 &lt;em&gt;지정&lt;/em&gt; 되지 않았지만 블록에서 함수 선언을 지원하는 &lt;em&gt;확장이 가능&lt;/em&gt; 했습니다. 불행하게도 (그리고 불가피하게), 다른 엔진은 다른 일을했습니다.</target>
        </trans-unit>
        <trans-unit id="711467f315de312047766526b3669d8afe66dbf2" translate="yes" xml:space="preserve">
          <source>An illustration of when to prefer the first method to the second one is when you need to avoid overriding a function's previous definitions.</source>
          <target state="translated">첫 번째 방법을 두 번째 방법보다 선호하는시기는 함수의 이전 정의를 무시하지 않아야 할 때를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="76e9af881baea20b41dca7056be9ed2866b3110e" translate="yes" xml:space="preserve">
          <source>An important reason is to add one and only one variable as the &quot;Root&quot; of your namespace...</source>
          <target state="translated">중요한 이유는 네임 스페이스의 &quot;루트&quot;로 하나의 변수 만 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="22aee645613b4be0feeee7c7d21978392526a1f5" translate="yes" xml:space="preserve">
          <source>And in a function expression</source>
          <target state="translated">그리고 함수 표현에서</target>
        </trans-unit>
        <trans-unit id="72c0421ee623967b8daecf32d64a58d316428622" translate="yes" xml:space="preserve">
          <source>And since they're processed &lt;em&gt;before&lt;/em&gt; step-by-step code is run, it's tricky to know what to do when they're in a control structure.</source>
          <target state="translated">또한 단계별 코드가 실행 &lt;em&gt;되기 전에&lt;/em&gt; 처리되므로 제어 구조에있을 때 수행 할 작업을 아는 것이 까다 롭습니다.</target>
        </trans-unit>
        <trans-unit id="721e0aa2d182321c9728514141b079a49fc8d164" translate="yes" xml:space="preserve">
          <source>And they are both hoisted to the top of the code.</source>
          <target state="translated">그리고 그들은 모두 코드 상단에 올라 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e93f2352a63f2f8ea04ce03020224e5e66bb84" translate="yes" xml:space="preserve">
          <source>And, a function declaration:</source>
          <target state="translated">그리고 함수 선언 :</target>
        </trans-unit>
        <trans-unit id="4c5054856e4bbef19e96d760e5ea9c34ecb00648" translate="yes" xml:space="preserve">
          <source>Another difference that is not mentioned in the other answers is that if you use the anonymous function</source>
          <target state="translated">다른 답변에서 언급되지 않은 또 다른 차이점은 익명 함수를 사용하면</target>
        </trans-unit>
        <trans-unit id="af3890af81c2b6252d1f34cfdef6f3003e49e4ce" translate="yes" xml:space="preserve">
          <source>Another good reason to use the combined style is to use a short internal name to refer to itself, while providing a long non-conflicting name for external users:</source>
          <target state="translated">결합 된 스타일을 사용하는 또 다른 좋은 이유는 짧은 내부 이름을 사용하여 자체를 참조하고 외부 사용자에게 긴 상충되지 않는 이름을 제공하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="edcabfa9c012840526618d1e04748f8c28cb2838" translate="yes" xml:space="preserve">
          <source>Another obvious difference between your two examples is that the first function doesn't have a name, but the second has it, which can be really useful when debugging (i.e. inspecting a call stack).</source>
          <target state="translated">두 예제의 또 다른 명백한 차이점은 첫 번째 함수에는 이름이 없지만 두 번째 함수에는 이름이 있다는 점입니다. 이는 디버깅 할 때 실제로 유용 할 수 있습니다 (예 : 호출 스택 검사).</target>
        </trans-unit>
        <trans-unit id="78b91f70d93cc43865f21e88db633ffc080cd555" translate="yes" xml:space="preserve">
          <source>Arrow Function Expression (ES2015+)</source>
          <target state="translated">화살표 함수 표현 (ES2015 +)</target>
        </trans-unit>
        <trans-unit id="95d9a52f48570a30b4afc03ec08d2692f827518e" translate="yes" xml:space="preserve">
          <source>Arrow Function Expression (ES2015+) &lt;em&gt;(which, like anonymous function expressions, don't involve an explicit name, and yet can create functions with names)&lt;/em&gt;</source>
          <target state="translated">화살표 함수 표현식 (ES2015 +) &lt;em&gt;(익명 함수 표현식과 같이 명시적인 이름은 포함하지 않지만 이름을 가진 함수는 작성할 수 있음)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd53a48e43711dae9eac565fec3530c9b4ee1e47" translate="yes" xml:space="preserve">
          <source>Arrow Function With &lt;code&gt;function add()&lt;/code&gt;</source>
          <target state="translated">화살표 &lt;code&gt;function add()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f99e80bb8fac409e2d6527343847643ed0c3e39" translate="yes" xml:space="preserve">
          <source>Arrow Function with &lt;code&gt;var add=function()&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;var add=function()&lt;/code&gt; 화살표 함수</target>
        </trans-unit>
        <trans-unit id="f70eea3b7a6f694be6cb95f16c6f6793125caccc" translate="yes" xml:space="preserve">
          <source>As of ES2015, the specification says what to do. In fact, it gives three separate things to do:</source>
          <target state="translated">ES2015 기준으로 사양에는 수행 할 작업이 나와 있습니다. 실제로 세 가지 별도의 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="1d02938e3888244803072ebfb20246bbdc0d0b95" translate="yes" xml:space="preserve">
          <source>As of this writing, V8, SpiderMonkey, Chakra and Nitro always refer to named functions by their names. They almost always refer to an anonymous function by its identifier if it has one.</source>
          <target state="translated">이 글을 쓰는 시점에서 V8, SpiderMonkey, Chakra 및 Nitro는 항상 이름으로 명명 된 기능을 참조합니다. 익명 함수는 식별자가있는 경우 항상 익명 함수를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="1b720c9c8412003b175b355c56b4ee5db0224dd0" translate="yes" xml:space="preserve">
          <source>As you'll have noticed with the above, you don't use the keyword &lt;code&gt;function&lt;/code&gt;; instead, you use &lt;code&gt;=&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">위에서 알 수 있듯이 키워드 &lt;code&gt;function&lt;/code&gt; 사용하지 않습니다. 대신 &lt;code&gt;=&amp;gt;&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b4999f76b7eca3d345d9076570ce3eedb86bebb2" translate="yes" xml:space="preserve">
          <source>Assign a variable to a function, means no Hoisting, as we know functions in JavaScript can Hoist, means they can be called before they get declared, while variables need to be declared before getting access to them, so means in this case we can not access the function before where it's declared, also it could be a way that you write your functions, for the functions which return another function, this kind of declaration could make sense, also in ECMA6 &amp;amp; above you can assign this to an arrow function which can be used to call anonymous functions, also this way of declaring is a better way to create Constructor functions in JavaScript.</source>
          <target state="translated">JavaScript에 함수가 호이스트 할 수 있다는 것을 알고 있듯이 변수를 함수에 할당하면 호이 스팅이 없음을 의미합니다. 선언하기 전에 호출 할 수 있음을 의미합니다. 선언 된 위치에 함수에 액세스하십시오. 또한 함수를 작성하는 방법 일 수 있습니다. 다른 함수를 반환하는 함수의 경우 이러한 종류의 선언이 의미가 있습니다 .ECMA6 이상에서는 화살표 함수에 할당 할 수 있습니다. 익명 함수를 호출하는 데 사용될 수 있으며, 이러한 선언 방법은 JavaScript에서 생성자 함수를 작성하는 더 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="7d6674bc9982ef481387f57cc83fdf356448f020" translate="yes" xml:space="preserve">
          <source>Availability (scope) of the function</source>
          <target state="translated">기능의 가용성 (범위)</target>
        </trans-unit>
        <trans-unit id="cb3c67b40dd1ec42a7ebb8e4fedcdde942976905" translate="yes" xml:space="preserve">
          <source>Basically, all function declarations and variable declarations are hoisted to the top of the &lt;em&gt;function&lt;/em&gt; in which the declaration occurs (this is why we say that JavaScript has &lt;em&gt;function scope&lt;/em&gt;).</source>
          <target state="translated">기본적으로 모든 함수 선언과 변수 선언은 선언이 발생하는 &lt;em&gt;함수&lt;/em&gt; 의 최상위 부분으로 들어갑니다 (JavaScript에 &lt;em&gt;함수 범위&lt;/em&gt; 가 있다고 말합니다).</target>
        </trans-unit>
        <trans-unit id="1c04286e0850fd4e09d7efcea4b60ed58c2b3685" translate="yes" xml:space="preserve">
          <source>Because it's processed before any step-by-step code in the same context, you can do things like this:</source>
          <target state="translated">동일한 컨텍스트에서 단계별 코드 전에 처리되기 때문에 다음과 같은 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13805085132e2a3520de22c522cbe8f65c7afc62" translate="yes" xml:space="preserve">
          <source>Because:</source>
          <target state="translated">Because:</target>
        </trans-unit>
        <trans-unit id="7aebd6867188b491049a61eb4878f8609a152162" translate="yes" xml:space="preserve">
          <source>Both are different ways of defining a function. The difference is how the browser interprets and loads them into an execution context.</source>
          <target state="translated">둘 다 함수를 정의하는 다른 방법입니다. 차이점은 브라우저가이를 해석하고 실행 컨텍스트로로드하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="c5ff3cd407987df1124c03fe7e85c5b0571cb3f8" translate="yes" xml:space="preserve">
          <source>But for the most part it's not worth stressing over.</source>
          <target state="translated">그러나 대부분 스트레스를받을 가치가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ecc7ba886c1a06ff3f510f80143a980ada742eea" translate="yes" xml:space="preserve">
          <source>By using the variable syntax, I can declare the variable (a function pointer essentially) in the shared code and either assign a trivial stub function, or set to null.</source>
          <target state="translated">변수 구문을 사용하여 공유 코드에서 변수 (기본적으로 함수 포인터)를 선언하고 사소한 스텁 함수를 할당하거나 null로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2fa0d12e3977b9cdaebbd95bbb5c680f6ef8533a" translate="yes" xml:space="preserve">
          <source>Chakra</source>
          <target state="translated">Chakra</target>
        </trans-unit>
        <trans-unit id="bec230d90facfd5f91e7a3f68902d847f6c654f2" translate="yes" xml:space="preserve">
          <source>Constructor and Method Declarations in &lt;code&gt;class&lt;/code&gt; (ES2015+)</source>
          <target state="translated">&lt;code&gt;class&lt;/code&gt; 생성자와 메소드 선언 (ES2015 +)</target>
        </trans-unit>
        <trans-unit id="2d08fdf2a8fb1f957e679f1a7a3412c536fd3dc4" translate="yes" xml:space="preserve">
          <source>Deep down, JavaScript treats both statements differently. This is a function declaration:</source>
          <target state="translated">자바 스크립트는 두 문장을 다르게 취급합니다. 이것은 함수 선언입니다.</target>
        </trans-unit>
        <trans-unit id="63a844213d874b8b245c742695b7941db276a173" translate="yes" xml:space="preserve">
          <source>Default return value of function is '&lt;a href=&quot;https://javascriptweblog.wordpress.com/2010/08/16/understanding-undefined-and-preventing-referenceerrors/&quot;&gt;undefined&lt;/a&gt;', &lt;a href=&quot;http://javascript.info/tutorial/variables-and-statements&quot;&gt;Variable&lt;/a&gt; declaration default value also 'undefined'</source>
          <target state="translated">함수의 기본 반환 값은 ' &lt;a href=&quot;https://javascriptweblog.wordpress.com/2010/08/16/understanding-undefined-and-preventing-referenceerrors/&quot;&gt;undefined&lt;/a&gt; ', &lt;a href=&quot;http://javascript.info/tutorial/variables-and-statements&quot;&gt;변수&lt;/a&gt; 선언 기본값은 'undefined'</target>
        </trans-unit>
        <trans-unit id="64b93c79b512c36d99999e6e34357c9f1c087aa9" translate="yes" xml:space="preserve">
          <source>ECMA 5 (13.0) defines the syntax as</source>
          <target state="translated">ECMA 5 (13.0)는 구문을 다음과 같이 정의합니다.</target>
        </trans-unit>
        <trans-unit id="c150af269e5f4c4642804ca24c299f530d6bf24b" translate="yes" xml:space="preserve">
          <source>ES2015 allows a shorter form of declaring a property that references a function called a &lt;em&gt;method definition&lt;/em&gt;; it looks like this:</source>
          <target state="translated">ES2015는 &lt;em&gt;메소드 정의&lt;/em&gt; 라는 함수를 참조하는 속성을 선언하는 짧은 형식을 허용합니다. 다음과 같이 보입니다 :</target>
        </trans-unit>
        <trans-unit id="b28d4620b46f9904b783e4bdca73dea8f4634eab" translate="yes" xml:space="preserve">
          <source>ES2015 brings us &lt;code&gt;class&lt;/code&gt; syntax, including declared constructors and methods:</source>
          <target state="translated">ES2015는 선언 된 생성자와 메소드를 포함하여 &lt;code&gt;class&lt;/code&gt; 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9d20a8f701915abdc4215ec73ca7a058aff15f27" translate="yes" xml:space="preserve">
          <source>ES2015 brings us the &lt;em&gt;arrow function&lt;/em&gt;. Here's one example:</source>
          <target state="translated">ES2015는 &lt;em&gt;화살표 기능을 제공&lt;/em&gt; 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ac6212e9887dd3f14ce21d75177f4b2bcc5e3df2" translate="yes" xml:space="preserve">
          <source>ES6 introduced &lt;strong&gt;Arrow function&lt;/strong&gt;: An arrow function expression has a shorter syntax, they are best suited for non-method functions, and they cannot be used as constructors.</source>
          <target state="translated">ES6 도입 &lt;strong&gt;화살표 함수&lt;/strong&gt; : 화살표 함수 표현식은 구문이 더 짧으며 메소드가 아닌 함수에 가장 적합하며 생성자로 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="49a81d8fe89a66107237159e2c32f647ebe45e02" translate="yes" xml:space="preserve">
          <source>Examples from the tutorial: recursive calls in &lt;code&gt;yell()&lt;/code&gt;:</source>
          <target state="translated">학습서의 예 : &lt;code&gt;yell()&lt;/code&gt; 재귀 호출 :</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="30e5c50747f8ddc02fafa95f11253e401b5d26e4" translate="yes" xml:space="preserve">
          <source>First I want to correct Greg: &lt;code&gt;function abc(){}&lt;/code&gt; is scoped too &amp;mdash; the name &lt;code&gt;abc&lt;/code&gt; is defined in the scope where this definition is encountered. Example:</source>
          <target state="translated">먼저 Greg를 수정하려고합니다. &lt;code&gt;function abc(){}&lt;/code&gt; 도 범위가 있습니다. 이름 &lt;code&gt;abc&lt;/code&gt; 는이 정의가있는 범위에서 정의됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="63aa696e0203f17e821cd16409f715c884085a35" translate="yes" xml:space="preserve">
          <source>For example, a function expression:</source>
          <target state="translated">예를 들어 함수 표현식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d83df8cc10813d6eb9d49ec11d81159959f3b35b" translate="yes" xml:space="preserve">
          <source>For more information on anonymous functions and lambda calculus, Wikipedia is a good start (&lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;http://en.wikipedia.org/wiki/Anonymous_function&lt;/a&gt;).</source>
          <target state="translated">익명 함수와 람다 미적분에 대한 자세한 내용은 Wikipedia를 시작하는 것이 좋습니다 ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;http://en.wikipedia.org/wiki/Anonymous_function&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="710381e12b95a3fe66706dfb40babc24d6b8e1bb" translate="yes" xml:space="preserve">
          <source>From people's comments above, I gather it may be possible to redefine a static function too, but I think the variable solution is nice and clear.</source>
          <target state="translated">위의 사람들의 의견에서 정적 함수도 재정의하는 것이 가능할 수도 있지만 변수 솔루션이 훌륭하고 명확하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="69181d045b415910120ca08053987e69c74ffe57" translate="yes" xml:space="preserve">
          <source>Fun fact:</source>
          <target state="translated">재미있는 사실:</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="79f7a2b842722c439a637899094a3e9b975d2161" translate="yes" xml:space="preserve">
          <source>Function Declaration</source>
          <target state="translated">함수 선언</target>
        </trans-unit>
        <trans-unit id="fea3337acc300eb0d59bb99072b521bda997c9a8" translate="yes" xml:space="preserve">
          <source>Function declaration vs. function expression is the real reason why there is a difference demonstrated by Greg.</source>
          <target state="translated">함수 선언과 함수 표현은 Greg가 보여준 차이점이있는 실제 이유입니다.</target>
        </trans-unit>
        <trans-unit id="2581d19bd1414397aab6c9d732c76b5beb72bc8d" translate="yes" xml:space="preserve">
          <source>Function declaration:</source>
          <target state="translated">함수 선언 :</target>
        </trans-unit>
        <trans-unit id="5d4b965bdff51520668a82710d188ad4c6d2847b" translate="yes" xml:space="preserve">
          <source>Function declarations and variable declarations are always moved (&lt;code&gt;hoisted&lt;/code&gt;) invisibly to the top of their containing scope by the JavaScript interpreter. Function parameters and language-defined names are, obviously, already there. &lt;a href=&quot;http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting&quot;&gt;ben cherry&lt;/a&gt;</source>
          <target state="translated">함수 선언과 변수 선언은 JavaScript 인터프리터에 의해 항상 포함 범위의 상단으로 이동 ( &lt;code&gt;hoisted&lt;/code&gt; )됩니다. 함수 매개 변수와 언어 정의 이름은 이미 존재합니다. &lt;a href=&quot;http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting&quot;&gt;벤 체리&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f30da0007535208b5211e526a05c262a2237a322" translate="yes" xml:space="preserve">
          <source>Function declarations take precedence over variable declarations, and the last function declaration &quot;sticks&quot;.</source>
          <target state="translated">함수 선언은 변수 선언과 마지막 함수 선언 &quot;sticks&quot;보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="9c2da209e9a31c47ddfe63c4563f794fa8b30376" translate="yes" xml:space="preserve">
          <source>Function expression &lt;a href=&quot;https://jsperf.com/fdeclaration-vs-fexpression&quot;&gt;appears to be faster&lt;/a&gt; now.</source>
          <target state="translated">함수 표현 &lt;a href=&quot;https://jsperf.com/fdeclaration-vs-fexpression&quot;&gt;이 더 빨라&lt;/a&gt; 졌습니다.</target>
        </trans-unit>
        <trans-unit id="b76f36a30041319319253d18b6823f5c3562c4aa" translate="yes" xml:space="preserve">
          <source>Function expression:</source>
          <target state="translated">함수 표현 :</target>
        </trans-unit>
        <trans-unit id="a1ac0ca8c05d1c35307dcd8c89a858da945ba8b7" translate="yes" xml:space="preserve">
          <source>Harness (&lt;a href=&quot;http://jsfiddle.net/us9dg6y8/&quot;&gt;Fiddle&lt;/a&gt;)</source>
          <target state="translated">하네스 ( &lt;a href=&quot;http://jsfiddle.net/us9dg6y8/&quot;&gt;피들&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a3e7d8a4d91ccb31d5aba99a1030f3258cd6aa3d" translate="yes" xml:space="preserve">
          <source>Here the function declaration is hoisted first, declaring and initializing variable &lt;code&gt;a&lt;/code&gt;. Next, this variable is assigned &lt;code&gt;10&lt;/code&gt;. In other words: the assignment does not assign to outer variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">여기서 함수 선언은 변수 &lt;code&gt;a&lt;/code&gt; 를 선언하고 초기화하면서 먼저 호이스트됩니다. 다음으로이 변수에 &lt;code&gt;10&lt;/code&gt; 이 할당됩니다. 즉, 대입이 외부 변수 &lt;code&gt;a&lt;/code&gt; 에 지정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4f1cbe2358cd472b9d4c788b3633f57ec1400c8" translate="yes" xml:space="preserve">
          <source>Here's the rundown on the standard forms that create functions: &lt;em&gt;(Originally written for another question, but adapted after being moved into the canonical question.)&lt;/em&gt;</source>
          <target state="translated">다음은 함수를 생성하는 표준 양식에 대한 요약입니다. &lt;em&gt;(원래 다른 질문을 위해 작성되었지만 정식 질문으로 이동 한 후 수정되었습니다.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9862412fbf3fc6c7bb7d8129f2f818be0d11455" translate="yes" xml:space="preserve">
          <source>Historically, anonymous functions appeared from the inability of JavaScript as a language to list members with named functions:</source>
          <target state="translated">역사적으로 익명 함수는 JavaScript가 언어로서 기능이없는 멤버를 나열 할 수없는 언어로 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="16c223be40fd7052aab965a0fd6c87c593532cd4" translate="yes" xml:space="preserve">
          <source>However, the difference in behaviour is that with the first variant (&lt;code&gt;var functionOne = function() {}&lt;/code&gt;), that function can only be called after that point in the code.</source>
          <target state="translated">그러나 동작의 차이점은 첫 번째 변형 ( &lt;code&gt;var functionOne = function() {}&lt;/code&gt; )을 사용하면 해당 함수는 코드에서 해당 지점 이후에만 호출 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="88718800ef1385d4eba64028d144aab14b067313" translate="yes" xml:space="preserve">
          <source>However, when we use the const-statement, the variable reference becomes immutable. This means that we cannot assign a new value to the variable. Please note, however, that this does not make the contents of the variable immutable: if you do &lt;code&gt;const arr = []&lt;/code&gt;, then you can still do &lt;code&gt;arr[10] = &quot;example&quot;&lt;/code&gt;. Only doing something like &lt;code&gt;arr = &quot;new value&quot;&lt;/code&gt; or &lt;code&gt;arr = []&lt;/code&gt; would throw an error as seen below.</source>
          <target state="translated">그러나 const 문을 사용하면 변수 참조가 변경되지 않습니다. 이는 변수에 새로운 값을 할당 할 수 없음을 의미합니다. 그러나 이렇게해도 변수의 내용을 변경할 수는 없습니다. &lt;code&gt;const arr = []&lt;/code&gt; 수행하면 &lt;code&gt;arr[10] = &quot;example&quot;&lt;/code&gt; 할 수 있습니다. &lt;code&gt;arr = &quot;new value&quot;&lt;/code&gt; 또는 &lt;code&gt;arr = []&lt;/code&gt; 와 같은 작업을 수행하면 아래와 같이 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="448a69f6cf1fb712be3c91a06ea26cc7b2a58c9d" translate="yes" xml:space="preserve">
          <source>I have code that I need to run with 160 independently-designed brandings. Most of the code is in shared files, but branding-specific stuff is in a separate file, one for each branding.</source>
          <target state="translated">160 개의 독립적으로 디자인 된 브랜딩으로 실행해야하는 코드가 있습니다. 대부분의 코드는 공유 파일에 있지만 브랜딩 관련 항목은 브랜딩마다 하나씩 별도의 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2caaf00ea49d3671a16112cd64e966f2b9b42f1" translate="yes" xml:space="preserve">
          <source>I know that I defined it globally providing that I didn't define &lt;code&gt;abc&lt;/code&gt; anywhere in the chain of scopes. This style of definition is resilient even when used inside &lt;code&gt;eval()&lt;/code&gt;. While the definition</source>
          <target state="translated">나는 범위 체인의 어느 곳에서나 &lt;code&gt;abc&lt;/code&gt; 를 정의하지 않았다는 것을 전 세계적으로 정의했음을 알고 있습니다. 이 스타일의 정의는 &lt;code&gt;eval()&lt;/code&gt; 내에서 사용될 때도 탄력적입니다. 정의하는 동안</target>
        </trans-unit>
        <trans-unit id="bc5e1bfae37a8f9624f4cf6c70c888ec885a6199" translate="yes" xml:space="preserve">
          <source>I know that I defined the function locally. When I define the function like</source>
          <target state="translated">함수를 로컬로 정의했음을 알고 있습니다. 내가 함수를 정의 할 때</target>
        </trans-unit>
        <trans-unit id="fc40ffc8273deb922d6a2d5a6d75d6a7f097e7f5" translate="yes" xml:space="preserve">
          <source>I often build JavaScript modules with a pattern like this:</source>
          <target state="translated">나는 종종 다음과 같은 패턴으로 JavaScript 모듈을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="52bb913d96e6cf1bb8f9c9868ed46fa2682d02e2" translate="yes" xml:space="preserve">
          <source>I suspect more PROS for named functions are follow. And what is listed as an advantage of named functions is a disadvantage for anonymous ones.</source>
          <target state="translated">명명 된 기능에 대한 더 많은 PROS가 따르는 것으로 생각됩니다. 그리고 명명 된 함수의 장점으로 나열된 것은 익명 함수의 단점입니다.</target>
        </trans-unit>
        <trans-unit id="48459bd949db4fd197340d3c07b4f6d46bda103c" translate="yes" xml:space="preserve">
          <source>I use the variable approach in my code for a very specific reason, the theory of which has been covered in an abstract way above, but an example might help some people like me, with limited JavaScript expertise.</source>
          <target state="translated">나는 매우 구체적인 이유로 내 코드에서 변수 접근 방식을 사용하는데, 그 이론은 위의 추상적 인 방식으로 다루어졌지만 예제는 제한된 JavaScript 전문 지식으로 나와 같은 일부 사람들을 도울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a720e3aa194c1f4744a62a098d3325669013f3cd" translate="yes" xml:space="preserve">
          <source>I'm adding my own answer just because everyone else has covered the hoisting part thoroughly.</source>
          <target state="translated">다른 모든 사람들이 호이 스팅 부분을 철저히 다루었 기 때문에 내 자신의 답변을 추가하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b65544a6391d547c18bfe600d2757c9ec324ddd" translate="yes" xml:space="preserve">
          <source>I'm listing out the differences below:</source>
          <target state="translated">아래 차이점을 나열하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b6cd598514917069a107f035013ef3785ac2a80" translate="yes" xml:space="preserve">
          <source>I've recently started maintaining someone else's JavaScript code. I'm fixing bugs, adding features and also trying to tidy up the code and make it more consistent.</source>
          <target state="translated">최근 다른 사람의 JavaScript 코드를 유지 관리하기 시작했습니다. 버그를 수정하고 기능을 추가하며 코드를 정리하고 일관성을 유지하려고합니다.</target>
        </trans-unit>
        <trans-unit id="bce5a0c9028577f292967e9b74591dfce14b4d0e" translate="yes" xml:space="preserve">
          <source>I've wondered about which way is better for a long while now, and thanks to &lt;a href=&quot;http://jsperf.com&quot;&gt;http://jsperf.com&lt;/a&gt; now I know :)</source>
          <target state="translated">나는 어느 방법이 오랫동안 더 나은지 궁금해했으며 지금 &lt;a href=&quot;http://jsperf.com&quot;&gt;http://jsperf.com&lt;/a&gt; 덕분에 나는 알고있다 :)</target>
        </trans-unit>
        <trans-unit id="7253bc4a6f9bb4a8d2e1a26b26041e3d0c929006" translate="yes" xml:space="preserve">
          <source>If in &lt;em&gt;strict&lt;/em&gt; mode (browser or not), the JavaScript engine is supposed to do yet another thing</source>
          <target state="translated">&lt;em&gt;엄격&lt;/em&gt; 모드 (브라우저 여부에 관계없이) 인 경우 JavaScript 엔진은 또 다른 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="47ba4d884a6eea36c2e8e1930047665437e35282" translate="yes" xml:space="preserve">
          <source>If in loose mode &lt;em&gt;not&lt;/em&gt; on a web browser, the JavaScript engine is supposed to do one thing</source>
          <target state="translated">웹 브라우저가 &lt;em&gt;아닌&lt;/em&gt; 느슨한 모드 인 경우 JavaScript 엔진은 한 가지 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c24a734bfa420e8662e5588c678c512ef41507c" translate="yes" xml:space="preserve">
          <source>If in loose mode on a web browser, the JavaScript engine is supposed to do something else</source>
          <target state="translated">웹 브라우저에서 느슨한 모드 인 경우 JavaScript 엔진은 다른 작업을 수행해야합니다</target>
        </trans-unit>
        <trans-unit id="c773779c693ffdb43c73b2a0c70b33f6e387fbfc" translate="yes" xml:space="preserve">
          <source>If there are no variables set to the function, then the functions name is the empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;).</source>
          <target state="translated">함수에 변수가 설정되어 있지 않으면 함수 이름은 빈 문자열 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="0ee8e8f5104dbf145e9fbcd03eca2e86caccca4f" translate="yes" xml:space="preserve">
          <source>If you really, really wanted your iterator and success callbacks to show up in the trace, you could name those too...</source>
          <target state="translated">정말로 반복자와 성공 콜백이 트레이스에 나타나기를 원한다면 이름도 지정할 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="be9589a95c8b69ed2b8236a7926adaebf7d55119" translate="yes" xml:space="preserve">
          <source>If you want to alias functions on all browsers, use this kind of declaration:</source>
          <target state="translated">모든 브라우저에서 함수의 별명을 지정하려면 다음과 같은 선언을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="99925e9ee05be0efa6950a0d1631c81f1977d083" translate="yes" xml:space="preserve">
          <source>If you would use those functions to create objects, you would get:</source>
          <target state="translated">이러한 함수를 사용하여 객체를 만들면 다음과 같은 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba22cd7a07e0cdf6f17ebe8dd72208ff7d3f75dc" translate="yes" xml:space="preserve">
          <source>If you're doing more than just a single expression, use &lt;code&gt;{}&lt;/code&gt; and an explicit &lt;code&gt;return&lt;/code&gt; (if you need to return a value), as normal:</source>
          <target state="translated">단일 표현식 이상을 수행하는 경우 평소와 같이 &lt;code&gt;{}&lt;/code&gt; 및 명시 적 &lt;code&gt;return&lt;/code&gt; (값을 리턴해야하는 경우)을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="18d78f8520de80f2c3d19326953d4afd2bce640f" translate="yes" xml:space="preserve">
          <source>In ES5, the function this creates has no name (it's anonymous). In ES2015, the function is assigned a name if possible by inferring it from context. In the example above, the name would be &lt;code&gt;y&lt;/code&gt;. Something similar is done when the function is the value of a property initializer. (For details on when this happens and the rules, search for &lt;code&gt;SetFunctionName&lt;/code&gt; in the &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;the specification&lt;/a&gt;&amp;nbsp;&amp;mdash; it appears &lt;em&gt;all over&lt;/em&gt; the place.)</source>
          <target state="translated">ES5에서이 함수는 이름이 없습니다 (익명). ES2015에서 가능하면 컨텍스트에서 유추하여 함수에 이름이 지정됩니다. 위의 예에서 이름은 &lt;code&gt;y&lt;/code&gt; 입니다. 함수가 속성 이니셜 라이저 값일 때 비슷한 작업이 수행됩니다. (이 상황과 규칙에 대한 자세한 내용 &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;은 사양&lt;/a&gt; 에서 &lt;code&gt;SetFunctionName&lt;/code&gt; 을 검색하십시오. &lt;em&gt;모든&lt;/em&gt; 곳에서 나타납니다.)</target>
        </trans-unit>
        <trans-unit id="4d0a437ff9ee930d494784b0a38eceebe7464cfb" translate="yes" xml:space="preserve">
          <source>In Google's V8 and Firefox's Spidermonkey there might be a few microsecond JIST compilation difference, but ultimately the result is the exact same. To prove this, let's examine the efficiency of JSPerf at microbenchmarks by comparing the speed of two blank code snippets. The &lt;a href=&quot;https://jsperf.com/microbenchmark-analysis/1&quot;&gt;JSPerf tests are found here&lt;/a&gt;. And, the &lt;a href=&quot;http://jsben.ch/Ov6eJ&quot;&gt;jsben.ch testsare  found here&lt;/a&gt;. As you can see, there is a noticable difference when there should be none. If you are really a performance freak like me, then it might be more worth your while trying to reduce the number of variables and functions in the scope and especially eliminating polymorphism (such as using the same variable to store two different types).</source>
          <target state="translated">Google의 V8과 Firefox의 Spidermonkey에는 약간의 마이크로 초 JIST 컴파일 차이가있을 수 있지만 결과는 동일합니다. 이를 증명하기 위해 두 개의 빈 코드 스 니펫의 속도를 비교하여 마이크로 벤치 마크에서 JSPerf의 효율성을 살펴 보겠습니다. &lt;a href=&quot;https://jsperf.com/microbenchmark-analysis/1&quot;&gt;JSPerf 테스트는 여기에서 찾을 수 있습니다&lt;/a&gt; . 그리고 &lt;a href=&quot;http://jsben.ch/Ov6eJ&quot;&gt;jsben.ch 테스트는 여기에 있습니다&lt;/a&gt; . 보시다시피, 아무것도 없어야 할 때 눈에 띄는 차이가 있습니다. 당신이 정말로 나 같은 퍼포먼스 괴물이라면, 스코프에서 변수와 함수의 수를 줄이고 특히 다형성을 제거하려고 시도하는 동안 (예를 들어 두 개의 다른 유형을 저장하기 위해 같은 변수를 사용하는) 더 가치가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77530f56c5b4887f097bf802c9364dfb9c6bf513" translate="yes" xml:space="preserve">
          <source>In JavaScript there are two ways to create functions:</source>
          <target state="translated">JavaScript에는 함수를 작성하는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="743fad7b9f2b3005515bc6a8b41cc5305db6d16c" translate="yes" xml:space="preserve">
          <source>In a debugger you will clearly see the function name on the call stack instead of an &quot;anonymous/evaluated&quot; function.</source>
          <target state="translated">디버거에서는 &quot;익명 / 평가 된&quot;함수 대신 호출 스택에 함수 이름이 명확하게 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="40ac26672752f4a573b68a025efd96f93c7cda1f" translate="yes" xml:space="preserve">
          <source>In above condition the function name is visible within its scope and the scope of its parent (otherwise it would be unreachable).</source>
          <target state="translated">위의 조건에서 함수 이름은 해당 범위와 상위 범위 내에 표시됩니다 (그렇지 않으면 도달 할 수 없음).</target>
        </trans-unit>
        <trans-unit id="1f5563a0832819a0b28ffe111ae45fd4c8971126" translate="yes" xml:space="preserve">
          <source>In both cases, the body of the function is just an expression; the function's return value will automatically be the result of that expression (you don't use an explicit &lt;code&gt;return&lt;/code&gt;).</source>
          <target state="translated">두 경우 모두 함수의 본문은 표현식 일뿐입니다. 함수의 반환 값은 자동으로 해당 표현식의 결과가됩니다 (명시적인 &lt;code&gt;return&lt;/code&gt; 사용하지 않음).</target>
        </trans-unit>
        <trans-unit id="d0c1580d80e84da99a8bb130ae769242b985147e" translate="yes" xml:space="preserve">
          <source>In computer science terms, we talk about anonymous functions and named functions. I think the most important difference is that an anonymous function is not bound to an name, hence the name anonymous function. In JavaScript it is a first class object dynamically declared at runtime.</source>
          <target state="translated">컴퓨터 과학 용어로 익명 함수와 명명 된 함수에 대해 이야기합니다. 가장 중요한 차이점은 익명 함수가 이름에 바인딩되지 않으므로 이름이 익명 함수라는 것입니다. JavaScript에서는 런타임에 동적으로 선언 된 첫 번째 클래스 객체입니다.</target>
        </trans-unit>
        <trans-unit id="9ad24effba4df71940268999b683a278696da2a5" translate="yes" xml:space="preserve">
          <source>In light of the &quot;named functions show up in stack traces&quot; argument, modern JavaScript engines are actually quite capable of representing anonymous functions.</source>
          <target state="translated">&quot;명명 된 함수는 스택 트레이스에 표시&quot;라는 주장에 비추어 현대 JavaScript 엔진은 실제로 익명 함수를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bada26db6ba62d3b37fbfb0f8797580b37b425d5" translate="yes" xml:space="preserve">
          <source>In terms of code maintenance cost, named functions are more preferable:</source>
          <target state="translated">코드 유지 관리 비용 측면에서 명명 된 함수가 더 바람직합니다.</target>
        </trans-unit>
        <trans-unit id="0ab56e8403de5abcd245a223331dd74301ac39fd" translate="yes" xml:space="preserve">
          <source>In the example above we can do the same with an external name, but it'll be too unwieldy (and slower).</source>
          <target state="translated">위의 예에서 외부 이름으로 동일한 작업을 수행 할 수 있지만 너무 다루기 힘들고 느립니다.</target>
        </trans-unit>
        <trans-unit id="99565775fc2dc3442ac3db8b854377a4e1535255" translate="yes" xml:space="preserve">
          <source>In this case, both &lt;code&gt;xyz&lt;/code&gt; and &lt;code&gt;abc&lt;/code&gt; are aliases of the same object:</source>
          <target state="translated">이 경우 &lt;code&gt;xyz&lt;/code&gt; 와 &lt;code&gt;abc&lt;/code&gt; 는 모두 동일한 객체의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="f34745ad4ce35316a6c1a3f69ce6b5aa657af5a5" translate="yes" xml:space="preserve">
          <source>In this example &lt;code&gt;a&lt;/code&gt; is initialized with the function object resulting from evaluating the second function declaration, and then is assigned &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">이 예제에서 &lt;code&gt;a&lt;/code&gt; 는 두 번째 함수 선언을 평가 한 결과 함수 객체로 초기화 된 다음 &lt;code&gt;4&lt;/code&gt; 가 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="a5a8ada85e0dd38f6230fbd0de001e929f7a5ccb" translate="yes" xml:space="preserve">
          <source>Independent from the place where they are declared (but still limited by scope).</source>
          <target state="translated">그들이 선언 된 장소와는 독립적입니다 (그러나 여전히 범위에 의해 제한됩니다).</target>
        </trans-unit>
        <trans-unit id="88d605e955dd6c957da2b10f658bd3437ef6a188" translate="yes" xml:space="preserve">
          <source>Interestingly, if we declare the variable as &lt;code&gt;function funcName(){}&lt;/code&gt;, then the immutability of the variable is the same as declaring it with &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">흥미롭게도, 변수를 &lt;code&gt;function funcName(){}&lt;/code&gt; 로 선언하면 변수의 불변성은 &lt;code&gt;var&lt;/code&gt; 로 선언하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7cd8788595c6099fbc89a56b7505fbb8d78f9944" translate="yes" xml:space="preserve">
          <source>It is not safe to write function declarations in non-function blocks like &lt;strong&gt;if&lt;/strong&gt; because they won't be accessible.</source>
          <target state="translated">함수 선언이 접근 할 수 없기 때문에 함수가 아닌 블록에 함수 선언을 작성하는 것은 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="66fbe41a46d13b3ec9ad6d15a6cbc7ebb0163825" translate="yes" xml:space="preserve">
          <source>JavaScript has first-class functions, that is, create a function and assign it to a variable just like you create a string or number and assign it to a variable. Here, the fn variable is assigned to a function. The reason for this concept is functions are objects in JavaScript; fn is pointing to the object instance of the above function. We have initialized a function and assigned it to a variable. It's not executing the function and assigning the result.</source>
          <target state="translated">JavaScript에는 일급 함수가 있습니다. 즉, 문자열이나 숫자를 만들어 변수에 할당하는 것처럼 함수를 만들어 변수에 할당합니다. 여기서 fn 변수는 함수에 할당됩니다. 이 개념의 이유는 함수가 JavaScript의 객체이기 때문입니다. fn은 위 함수의 객체 인스턴스를 가리 킵니다. 함수를 초기화하고 변수에 할당했습니다. 함수를 실행하지 않고 결과를 할당하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dc87314ad86194e07f204ed20a079cd40c0d7d92" translate="yes" xml:space="preserve">
          <source>JavaScript has three ways of defining functions.</source>
          <target state="translated">JavaScript에는 함수를 정의하는 세 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="386881110fbc49ba4e9cbf28d7d0d56af3d005b0" translate="yes" xml:space="preserve">
          <source>JavaScript treats functions as first-class objects, so being an object, you can assign properties to a function.</source>
          <target state="translated">JavaScript는 함수를 일급 객체로 취급하므로 객체이므로 속성을 함수에 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0771db0681dd1086ab043dd36cac9a035ed201d" translate="yes" xml:space="preserve">
          <source>Lastly, while the variable the function is assigned to initially sets the name, successive variables set to the function do not change the name.</source>
          <target state="translated">마지막으로 함수에 할당 된 변수는 처음에 이름을 설정하지만 함수에 설정된 연속 변수는 이름을 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="131c609e07fa46c90f8a914d0d9876618cb16ffa" translate="yes" xml:space="preserve">
          <source>Like all expressions, it's evaluated when it's reached in the step-by-step execution of the code.</source>
          <target state="translated">모든 표현식과 마찬가지로 단계별 코드 실행에서 도달하면 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="9047887da470d7120807196284dd5dbf0f775748" translate="yes" xml:space="preserve">
          <source>Method Declaration in Object Initializer (ES2015+)</source>
          <target state="translated">객체 이니셜 라이저에서 메소드 선언 (ES2015 +)</target>
        </trans-unit>
        <trans-unit id="f6e8c432ab6e69fb5b19460ea3141b5206869a18" translate="yes" xml:space="preserve">
          <source>More resistant to mistakes like conditional initialization (you are still able to override if wanted to).</source>
          <target state="translated">조건부 초기화와 같은 실수에 더 강합니다 (원하는 경우 여전히 재정의 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="f0128c3077ca982c05c67d537afe75962bbc772f" translate="yes" xml:space="preserve">
          <source>Named &lt;code&gt;function&lt;/code&gt; Expression</source>
          <target state="translated">명명 된 &lt;code&gt;function&lt;/code&gt; 식</target>
        </trans-unit>
        <trans-unit id="777148d87c109971486523e49744c67e7e30f167" translate="yes" xml:space="preserve">
          <source>Named function expression like the one below, may not work in Internet&amp;nbsp;Explorer browsers prior to version 9.</source>
          <target state="translated">아래와 같은 명명 된 함수 표현식은 버전 9 이전의 Internet Explorer 브라우저에서 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2af52c0ccfa8c408328b7c06cce7ab9ec1d62fa" translate="yes" xml:space="preserve">
          <source>Named function expressions demystified</source>
          <target state="translated">명명 된 함수 표현식</target>
        </trans-unit>
        <trans-unit id="dc9e3d6fd9e9ce94aab3c1ef25f88d46b96264d9" translate="yes" xml:space="preserve">
          <source>New versions of &lt;code&gt;V8&lt;/code&gt; introduced several under-the-hood optimizations and so did &lt;code&gt;SpiderMonkey&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;V8&lt;/code&gt; 의 새로운 버전에서는 여러 가지 최적화가 도입되었으며 &lt;code&gt;SpiderMonkey&lt;/code&gt; 도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="65bd7ea4a6bcc80835c2ec2b979fb00bb0f4c9ac" translate="yes" xml:space="preserve">
          <source>Nitro</source>
          <target state="translated">Nitro</target>
        </trans-unit>
        <trans-unit id="8110b79db7f83a1e8b4ca63a622ef7443e84ba94" translate="yes" xml:space="preserve">
          <source>Normal &lt;code&gt;function add(){}&lt;/code&gt;</source>
          <target state="translated">정상적인 &lt;code&gt;function add(){}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c5a68d9eef8721bfe6330530d6cdfda8dbcb430" translate="yes" xml:space="preserve">
          <source>Normal &lt;code&gt;var add=function(){}&lt;/code&gt;</source>
          <target state="translated">일반 &lt;code&gt;var add=function(){}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f50d4d872d6f1fc0198387a8cbf12922732ec09a" translate="yes" xml:space="preserve">
          <source>Note that NFEs have frequently been a source of bugs for JavaScript implementations. IE8 and earlier, for instance, handle NFEs &lt;a href=&quot;http://blog.niftysnippets.org/2010/09/double-take.html&quot;&gt;completely incorrectly&lt;/a&gt;, creating two different functions at two different times. Early versions of Safari had issues as well. The good news is that current versions of browsers (IE9 and up, current Safari) don't have those issues any more. (But as of this writing, sadly, IE8 remains in widespread use, and so using NFEs with code for the web in general is still problematic.)</source>
          <target state="translated">NFE는 종종 JavaScript 구현을위한 버그의 원인이되었습니다. 예를 들어 IE8 및 이전 버전에서는 NFE를 &lt;a href=&quot;http://blog.niftysnippets.org/2010/09/double-take.html&quot;&gt;완전히 잘못&lt;/a&gt; 처리하여 두 가지 다른 시간에 두 가지 다른 기능을 만듭니다. 초기 버전의 Safari에도 문제가있었습니다. 좋은 소식은 현재 버전의 브라우저 (IE9 이상, 현재 Safari)에는 더 이상 이러한 문제가 없다는 것입니다. 그러나이 글을 쓰는 시점에서 슬프게도 IE8은 널리 사용되므로 웹 코드를 사용하여 NFE를 사용하는 것은 여전히 ​​문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="46c934ebb5c49a0e1a45001cc099b679e5fc9cba" translate="yes" xml:space="preserve">
          <source>Note that when I used the function, I didn't use &lt;code&gt;()&lt;/code&gt;! That's because it's an &lt;em&gt;accessor function&lt;/em&gt; for a property. We get and set the property in the normal way, but behind the scenes, the function is called.</source>
          <target state="translated">함수를 사용할 때 &lt;code&gt;()&lt;/code&gt; 를 사용하지 않았습니다. 속성에 대한 &lt;em&gt;접근 자 기능&lt;/em&gt; 이기 때문입니다. 우리는 일반적인 방법으로 속성을 가져오고 설정하지만, 뒤에서 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="b0135a3fe9edd1aa747c5dc00ef86223a2fba31b" translate="yes" xml:space="preserve">
          <source>Notice that the assignment portion of the declarations were not hoisted. Only the name is hoisted.</source>
          <target state="translated">선언의 할당 부분은 게양되지 않았습니다. 이름 만 게양됩니다.</target>
        </trans-unit>
        <trans-unit id="bc114abbd8dd8a2cd0b954fda2e13a328089452b" translate="yes" xml:space="preserve">
          <source>On the second line we are assigning the reference of an anonymous function to functionOne.</source>
          <target state="translated">두 번째 줄에서는 익명 함수의 참조를 functionOne에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="8843a229a0f472ada31ba06061df9ac263f902f6" translate="yes" xml:space="preserve">
          <source>One compelling reason to use the combined style is the &quot;name&quot; attribute of function objects (&lt;strong&gt;not supported by Internet&amp;nbsp;Explorer&lt;/strong&gt;). Basically when you define a function like</source>
          <target state="translated">결합 된 스타일을 사용해야하는 강력한 이유 중 하나는 &lt;strong&gt;Internet Explorer에서 지원하지 않는&lt;/strong&gt; 함수 객체의 &quot;name&quot;속성입니다. 기본적으로 다음과 같은 함수를 정의 할 때</target>
        </trans-unit>
        <trans-unit id="dbe6fdfa55051d3eebbbe9fd39842bacd3d7cc72" translate="yes" xml:space="preserve">
          <source>Other commenters have already covered the semantic difference of the two variants above. I wanted to note a stylistic difference: Only the &quot;assignment&quot; variation can set a property of another object.</source>
          <target state="translated">다른 의견 제시 자들은 이미 위 두 변형의 의미 론적 차이를 다루었 다. 스타일 차이를 언급하고 싶었습니다. &quot;할당&quot;변형 만 다른 개체의 속성을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95fa44f122d0d2fde84daa10053c89ba105c1733" translate="yes" xml:space="preserve">
          <source>Otherwise, if a function is declared as &lt;code&gt;function(){}&lt;/code&gt;, the &lt;em&gt;function&lt;/em&gt;.name is the first variable used to store the function.</source>
          <target state="translated">그렇지 않으면 함수가 &lt;code&gt;function(){}&lt;/code&gt; 으로 선언되면 .name &lt;em&gt;함수&lt;/em&gt; 는 &lt;em&gt;함수&lt;/em&gt; 를 저장하는 데 사용되는 첫 번째 변수입니다.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="bcc6976fdb7b0bab8f43d0bd6a3d5c3f3f1f4418" translate="yes" xml:space="preserve">
          <source>Personally, I prefer the &quot;function expression&quot; declaration because this way I can control the visibility. When I define the function like</source>
          <target state="translated">개인적으로 저는 &quot;함수 표현&quot;선언을 선호합니다. 이런 식으로 가시성을 제어 할 수 있기 때문입니다. 내가 함수를 정의 할 때</target>
        </trans-unit>
        <trans-unit id="48e539471552b322b96b629b50e168373aab581d" translate="yes" xml:space="preserve">
          <source>Reference: &lt;em&gt;&lt;a href=&quot;http://jkoder.com/javascript-function-declaration-syntax-var-fn-function-vs-function-fn/&quot;&gt;JavaScript function declaration syntax: var fn = function() {} vs function fn() {}&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">참조 : &lt;em&gt;&lt;a href=&quot;http://jkoder.com/javascript-function-declaration-syntax-var-fn-function-vs-function-fn/&quot;&gt;JavaScript 함수 선언 구문 : var fn = function () {} vs function fn () {}&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2fa869913cd407b8374e8002710a8e37791c0a7c" translate="yes" xml:space="preserve">
          <source>Same function using function expressions:</source>
          <target state="translated">함수 표현식을 사용하는 동일한 함수 :</target>
        </trans-unit>
        <trans-unit id="a342ddf70636f32b76e4ff5a5d52c5eb4e44afd7" translate="yes" xml:space="preserve">
          <source>Secondly, it is possible to combine both styles:</source>
          <target state="translated">둘째, 두 스타일을 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f28d3ab65fed240b09f7deb679e37f9272d4792" translate="yes" xml:space="preserve">
          <source>See that &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; thing hiding in the &lt;code&gt;map()&lt;/code&gt; call? That's a function.</source>
          <target state="translated">&lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; 가 &lt;code&gt;map()&lt;/code&gt; 호출에 숨어있는 것을 보시겠습니까? 그것은 기능입니다.</target>
        </trans-unit>
        <trans-unit id="26c0ca793e8f7074d3f8c82877440040dbf9523b" translate="yes" xml:space="preserve">
          <source>So</source>
          <target state="translated">So</target>
        </trans-unit>
        <trans-unit id="46c47815b690569dbb7a656b8964b6c4a2aec3eb" translate="yes" xml:space="preserve">
          <source>Some brandings require specific functions, and some do not. Sometimes I have to add new functions to do new branding-specific things. I am happy to change the shared coded, but I don't want to have to change all 160 sets of branding files.</source>
          <target state="translated">일부 브랜드에는 특정 기능이 필요하지만 일부 브랜드에는 그렇지 않습니다. 때로는 새로운 브랜드 관련 일을하기 위해 새로운 기능을 추가해야합니다. 공유 코드를 변경해도 좋으나 160 개의 브랜딩 파일 세트를 모두 변경하고 싶지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f39892c489c20b210e85c99d0636ddca2f715ec" translate="yes" xml:space="preserve">
          <source>Some examples...</source>
          <target state="translated">몇 가지 예 ...</target>
        </trans-unit>
        <trans-unit id="48fe26184a1da0188c638e9837cd0348befd6fc9" translate="yes" xml:space="preserve">
          <source>Sometimes functions can sneak in largely unnoticed; that's the case with &lt;em&gt;accessor functions&lt;/em&gt;. Here's an example:</source>
          <target state="translated">때로는 기능이 크게 눈에 띄지 않게 몰래 들어갈 수 있습니다. &lt;em&gt;접근 자 함수&lt;/em&gt; 의 경우입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="387053ec024b111c7ef9f523fd9328f604a02b3d" translate="yes" xml:space="preserve">
          <source>Speaking about the global context, both, the &lt;code&gt;var&lt;/code&gt; statement and a &lt;code&gt;FunctionDeclaration&lt;/code&gt; at the end will create a &lt;em&gt;non-deleteable&lt;/em&gt; property on the global object, but the value of both &lt;em&gt;can be overwritten&lt;/em&gt;.</source>
          <target state="translated">전역 컨텍스트에 대해 말하면 &lt;code&gt;var&lt;/code&gt; 문과 마지막에 &lt;code&gt;FunctionDeclaration&lt;/code&gt; 이 전역 객체에 &lt;em&gt;삭제할 수없는&lt;/em&gt; 속성을 만들지 만 둘 다 값을 &lt;em&gt;덮어 쓸 수 있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f65122e6f32c2bcabdd432788ea598df5c48d617" translate="yes" xml:space="preserve">
          <source>SpiderMonkey</source>
          <target state="translated">SpiderMonkey</target>
        </trans-unit>
        <trans-unit id="c6651b9a96d11046277cfbcd116304f61f74227d" translate="yes" xml:space="preserve">
          <source>SpiderMonkey can figure out the name of an anonymous function returned from another function. The rest can't.</source>
          <target state="translated">SpiderMonkey는 다른 함수에서 반환 된 익명 함수의 이름을 알아낼 수 있습니다. 나머지는 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0ae1828118a1782dda8e1ea5ac856c97b23cc230" translate="yes" xml:space="preserve">
          <source>Statement (such as &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;finally&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;)</source>
          <target state="translated">문 (예 : &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; / &lt;code&gt;finally&lt;/code&gt; , &lt;code&gt;switch&lt;/code&gt; , &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bc07256662906a0b6337c96a56729c6ca11dc5d1" translate="yes" xml:space="preserve">
          <source>Take a look at the function below:</source>
          <target state="translated">아래 기능을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="ffdc12529405fd8a1fe177c00af6a4b1b34cbdf9" translate="yes" xml:space="preserve">
          <source>Terms:</source>
          <target state="translated">Terms:</target>
        </trans-unit>
        <trans-unit id="f63f70d99a4f81b8e70665fd22c3174d3eeca9cf" translate="yes" xml:space="preserve">
          <source>That also means that the method has a reference to the object it was defined on, so if that object is temporary (for instance, you're passing it into &lt;code&gt;Object.assign&lt;/code&gt; as one of the source objects), method syntax &lt;em&gt;could&lt;/em&gt; mean that the object is retained in memory when otherwise it could have been garbage collected (if the JavaScript engine doesn't detect that situation and handle it if none of the methods uses &lt;code&gt;super&lt;/code&gt;).</source>
          <target state="translated">즉, 메소드에 정의 된 오브젝트에 대한 참조가 메소드에 있음을 의미하므로 해당 오브젝트가 임시 인 경우 (예를 들어 소스 오브젝트 중 하나로 &lt;code&gt;Object.assign&lt;/code&gt; 에 전달하는 경우) 메소드 구문 &lt;em&gt;은&lt;/em&gt; 가비지 수집되었을 수있는 경우 객체가 메모리에 유지됩니다 (JavaScript 엔진이 해당 상황을 감지하지 못하고 &lt;code&gt;super&lt;/code&gt; 중 하나를 사용하는 메소드가없는 경우 처리).</target>
        </trans-unit>
        <trans-unit id="a48c26e1972ebb64b7dc5783e0fabcbb52b4ce7e" translate="yes" xml:space="preserve">
          <source>The &quot;nearest block&quot; is the nearest &quot;function,&quot; (including asynchronous functions, generator functions, and asynchronous generator functions). However, interestingly, a &lt;code&gt;function functionName() {}&lt;/code&gt; behaves like a &lt;code&gt;var functionName = function() {}&lt;/code&gt; when in a non-closure block to items outside said closure. Observe.</source>
          <target state="translated">&quot;가장 가까운 블록&quot;은 가장 가까운 &quot;기능&quot;입니다 (비동기 기능, 생성기 기능 및 비동기 생성기 기능 포함). 그러나 흥미롭게도 &lt;code&gt;function functionName() {}&lt;/code&gt; 폐쇄 (non-closure) 블록에있을 때 함수 functionName () {} 은 &lt;code&gt;var functionName = function() {}&lt;/code&gt; 처럼 동작합니다. 관찰하십시오.</target>
        </trans-unit>
        <trans-unit id="6a595334c53b5e54513ecbf67288a1b96ade59c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; example above is one form of them. If you have multiple arguments to pass the function, you use parens:</source>
          <target state="translated">위의 &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; 예제는 그중 하나입니다. 함수를 전달할 인수가 여러 개인 경우 parens를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ac4e1750314827abdcc2556f83c85b9fddef454c" translate="yes" xml:space="preserve">
          <source>The above actually defines &lt;code&gt;functionThree&lt;/code&gt; irrespective of &lt;code&gt;test&lt;/code&gt;'s value &amp;mdash; unless &lt;code&gt;use strict&lt;/code&gt; is in effect, in which case it simply raises an error.</source>
          <target state="translated">위의 내용은 실제로 &lt;code&gt;test&lt;/code&gt; 값에 관계없이 &lt;code&gt;functionThree&lt;/code&gt; 를 정의 합니다. &lt;code&gt;use strict&lt;/code&gt; 되지 않는 한 단순히 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b568b255152259a00f6cba0e87f3825e038239ef" translate="yes" xml:space="preserve">
          <source>The above code is identical in functionality to the code below. Note that explicitly assigning &lt;code&gt;add = undefined&lt;/code&gt; is superfluous because simply doing &lt;code&gt;var add;&lt;/code&gt; is the exact same as &lt;code&gt;var add=undefined&lt;/code&gt;.</source>
          <target state="translated">위 코드는 기능면에서 아래 코드와 동일합니다. &lt;code&gt;add = undefined&lt;/code&gt; 를 명시 적으로 할당하는 것은 단순히 &lt;code&gt;var add;&lt;/code&gt; 를 수행하기 때문에 불필요 합니다. &lt;code&gt;var add=undefined&lt;/code&gt; 와 정확히 같습니다.</target>
        </trans-unit>
        <trans-unit id="61810b104f2efcb0e3da5ee583a0202c43770fb2" translate="yes" xml:space="preserve">
          <source>The assignment of the &lt;code&gt;bar&lt;/code&gt;&lt;code&gt;FunctionExpression&lt;/code&gt; takes place until runtime.</source>
          <target state="translated">&lt;code&gt;FunctionExpression&lt;/code&gt; &lt;code&gt;bar&lt;/code&gt; 지정은 런타임까지 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="f5638e210194eb499ece9d9a4a930b2e74d062fc" translate="yes" xml:space="preserve">
          <source>The code becomes more readable by allocating local functions separately of scope functionality. Usually in the scope the functionality goes first, followed by declarations of local functions.</source>
          <target state="translated">범위 기능과 별도로 로컬 기능을 할당하여 코드를보다 쉽게 ​​읽을 수 있습니다. 일반적으로 범위 내에서 기능이 먼저 수행되고 그 다음에 로컬 함수가 선언됩니다.</target>
        </trans-unit>
        <trans-unit id="27d4da09d4c2ce032185baf978da0ab13a3001ed" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;functionOne&lt;/code&gt; is a function expression and so only defined when that line is reached, whereas &lt;code&gt;functionTwo&lt;/code&gt; is a function declaration and is defined as soon as its surrounding function or script is executed (due to &lt;a href=&quot;http://adripofjavascript.com/blog/drips/variable-and-function-hoisting.html&quot;&gt;hoisting&lt;/a&gt;).</source>
          <target state="translated">차이점은 &lt;code&gt;functionOne&lt;/code&gt; 은 함수 표현식이므로 해당 행에 도달 할 때만 정의되는 반면 &lt;code&gt;functionTwo&lt;/code&gt; 는 함수 선언이며 주변 함수 또는 스크립트가 실행 되 자마자 정의됩니다 ( &lt;a href=&quot;http://adripofjavascript.com/blog/drips/variable-and-function-hoisting.html&quot;&gt;호이 스팅&lt;/a&gt; 으로 인해).</target>
        </trans-unit>
        <trans-unit id="8f5ff0d27037b523b788758f94b98b0d9ae64dd6" translate="yes" xml:space="preserve">
          <source>The first case is of function expressions which loads only when the interpreter reaches that line of code. So if you do it like the following, you will get an error that the &lt;strong&gt;functionOne is not a function&lt;/strong&gt;.</source>
          <target state="translated">첫 번째 경우는 인터프리터가 해당 코드 줄에 도달 할 때만로드되는 함수 표현식입니다. 따라서 다음과 같이하면 &lt;strong&gt;functionOne이 함수가 아니라는&lt;/strong&gt; 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8c697eb723f616068919ff4ce595b6a84c5ced0b" translate="yes" xml:space="preserve">
          <source>The first example is a function declaration:</source>
          <target state="translated">첫 번째 예는 함수 선언입니다.</target>
        </trans-unit>
        <trans-unit id="43835d99e780763836c24b4200a3754c5e808b94" translate="yes" xml:space="preserve">
          <source>The first form is a &lt;em&gt;function declaration&lt;/em&gt;, which looks like this:</source>
          <target state="translated">첫 번째 형식은 다음과 같은 &lt;em&gt;함수 선언입니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="34f69ae86ca961522b085400da5ab180cee6f82c" translate="yes" xml:space="preserve">
          <source>The first one (function doSomething(x)) should be part of an object notation.</source>
          <target state="translated">첫 번째 것 (함수 doSomething (x))은 객체 표기법의 일부 여야합니다.</target>
        </trans-unit>
        <trans-unit id="528c8b3507437f286d5dcd35417b22aae81be689" translate="yes" xml:space="preserve">
          <source>The following does not work because the &lt;code&gt;var add=&lt;/code&gt; superseeds the &lt;code&gt;function add()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;var add=&lt;/code&gt; &lt;code&gt;function add()&lt;/code&gt; 대체하므로 다음은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d6593583ad3f05cea4dd2dbe710ed86ac6be34db" translate="yes" xml:space="preserve">
          <source>The following does not work because the variable is called before a function value is assigned to the variable &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">함수 값이 변수 &lt;code&gt;add&lt;/code&gt; 에 할당되기 전에 변수가 호출되므로 다음이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1c398e75b47d2fad865197a5e2b4b99f659ecf1b" translate="yes" xml:space="preserve">
          <source>The following works because &lt;code&gt;function add()&lt;/code&gt; is scoped to the nearest block:</source>
          <target state="translated">&lt;code&gt;function add()&lt;/code&gt; 범위가 가장 가까운 블록이기 때문에 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="12d135f5c480c68402b5ce8e6a0d8f062c40c5a2" translate="yes" xml:space="preserve">
          <source>The function statement is just a shorthand for &lt;code&gt;var&lt;/code&gt; statement with a &lt;code&gt;function&lt;/code&gt; value.</source>
          <target state="translated">함수 명령문은 &lt;code&gt;function&lt;/code&gt; 값이있는 &lt;code&gt;var&lt;/code&gt; 문의 축약 형입니다.</target>
        </trans-unit>
        <trans-unit id="aabbd15c1c1cbe57d1e6cc08682ca9493293312d" translate="yes" xml:space="preserve">
          <source>The function this creates has a proper name (&lt;code&gt;w&lt;/code&gt; in this case). Like all expressions, this is evaluated when it's reached in the step-by-step execution of the code. The name of the function is &lt;em&gt;not&lt;/em&gt; added to the scope in which the expression appears; the name &lt;em&gt;is&lt;/em&gt; in scope within the function itself:</source>
          <target state="translated">이 함수는 올바른 이름을 갖습니다 (이 경우 &lt;code&gt;w&lt;/code&gt; ). 모든 표현식과 마찬가지로 단계별 코드 실행에서 도달하면 평가됩니다. 함수 이름은 표현식이 나타나는 범위에 추가 &lt;em&gt;되지 않습니다&lt;/em&gt; . 이름 &lt;em&gt;은&lt;/em&gt; 함수 자체의 범위 내에 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea448a50cd82447995b1eb947a60438076954bb9" translate="yes" xml:space="preserve">
          <source>The main difference is how they are hoisted (lifted and declared). In the first example, the whole function declaration is hoisted. In the second example only the var 'abc' is hoisted, its value (the function) will be undefined, and the function itself remains at the position that it is declared.</source>
          <target state="translated">가장 큰 차이점은 어떻게 들어 올리는가입니다. 첫 번째 예에서 전체 함수 선언이 게양되었습니다. 두 번째 예에서는 var 'abc'만 게양되고 값 (함수)이 정의되지 않으며 함수 자체는 선언 된 위치에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="4d055f6c1671742f4deaadc6161c80dec3e0bd32" translate="yes" xml:space="preserve">
          <source>The name of a function &lt;code&gt;function thefuncname(){}&lt;/code&gt; is &lt;em&gt;thefuncname&lt;/em&gt; when it is declared this way.</source>
          <target state="translated">함수 &lt;code&gt;function thefuncname(){}&lt;/code&gt; 의 이름은 이런 식으로 선언 될 때의 &lt;em&gt;funcname&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="975e947bf74ec2c4a9220b91f85c32600f4c5554" translate="yes" xml:space="preserve">
          <source>The one or two brandings that need a specific implementation of the function can then define their version of the function and assign this to the variable if they want, and the rest do nothing. I can test for a null function before I execute it in the shared code.</source>
          <target state="translated">함수의 특정 구현이 필요한 하나 또는 두 개의 브랜딩은 함수의 버전을 정의하고 원하는 경우 변수에 할당 할 수 있으며 나머지는 아무 것도하지 않습니다. 공유 코드에서 null 함수를 실행하기 전에 null 함수를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="145b15615e2d9998da1e6798d5ad4a398382a9d4" translate="yes" xml:space="preserve">
          <source>The order of hoisting is also important: function declarations take precedence over variable declarations with the same name, and the last function declaration takes precedence over previous function declarations with the same name.</source>
          <target state="translated">리프팅 순서도 중요합니다. 함수 선언은 이름이 같은 변수 선언보다 우선하고 마지막 함수 선언은 이름이 같은 이전 함수 선언보다 우선합니다.</target>
        </trans-unit>
        <trans-unit id="9fbf6788e456c1009e4f21fffa2ea5165a3d9162" translate="yes" xml:space="preserve">
          <source>The previous developer used two ways of declaring functions and I can't work out if there is a reason behind it or not.</source>
          <target state="translated">이전 개발자는 함수를 선언하는 두 가지 방법을 사용했으며 그 뒤에 이유가 있는지 알아낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9be3cbbcb4a077923846e6cabf5be834c36c4efe" translate="yes" xml:space="preserve">
          <source>The quick list:</source>
          <target state="translated">빠른 목록 :</target>
        </trans-unit>
        <trans-unit id="691d638de255d3f4d5c26aade899596c1cb5d318" translate="yes" xml:space="preserve">
          <source>The reason is that on the first line no value is assigned to functionOne, and hence it is undefined. We are trying to call it as a function, and hence we are getting an error.</source>
          <target state="translated">그 이유는 첫 번째 행에서 functionOne에 값이 지정되지 않았으므로 정의되지 않기 때문입니다. 함수로 호출하려고하므로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="79805af7eecf09848f58c20a9be4bdd8d5d60b42" translate="yes" xml:space="preserve">
          <source>The rules for the loose modes are tricky, but in &lt;em&gt;strict&lt;/em&gt; mode, function declarations in blocks are easy: They're local to the block (they have &lt;em&gt;block scope&lt;/em&gt;, which is also new in ES2015), and they're hoisted to the top of the block. So:</source>
          <target state="translated">느슨한 모드에 대한 규칙은 까다 롭지 만 &lt;em&gt;엄격&lt;/em&gt; 모드에서는 블록의 함수 선언이 쉽습니다. 블록에 로컬이며 (ES2015에서 새로운 &lt;em&gt;블록 범위&lt;/em&gt; 를 가지며) 맨 위로 올라갑니다. 블록의. 그래서:</target>
        </trans-unit>
        <trans-unit id="662fa49d03ebc7b2aed8dd5f4b92c0902805a5f2" translate="yes" xml:space="preserve">
          <source>The second case is of function declarations that loads before any code is executed. So if you do like the following you won't get any error as the declaration loads before code execution.</source>
          <target state="translated">두 번째 경우는 코드가 실행되기 전에로드되는 함수 선언입니다. 따라서 다음을 좋아하면 코드 실행 전에 선언이로드 될 때 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="488c70a0cd0c42493330d0fb21f56a76d5245310" translate="yes" xml:space="preserve">
          <source>The second common form is called an &lt;em&gt;anonymous function expression&lt;/em&gt;:</source>
          <target state="translated">두 번째 일반적인 형식을 &lt;em&gt;익명 함수 표현식&lt;/em&gt; 이라고합니다.</target>
        </trans-unit>
        <trans-unit id="d485f7dbc6206bd93419673ad073a7290e1370dc" translate="yes" xml:space="preserve">
          <source>The second example is a function expression:</source>
          <target state="translated">두 번째 예는 함수 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="8bf7ed47a49f0740aa28a7a24a1570e0b0a27a46" translate="yes" xml:space="preserve">
          <source>The second one (&lt;code&gt;var doSomething = function(x){ alert(x);}&lt;/code&gt;) is simply creating an anonymous function and assigning it to a variable, &lt;code&gt;doSomething&lt;/code&gt;. So doSomething() will call the function.</source>
          <target state="translated">두 번째 ( &lt;code&gt;var doSomething = function(x){ alert(x);}&lt;/code&gt; )는 단순히 익명 함수를 만들어 변수 &lt;code&gt;doSomething&lt;/code&gt; 에 지정하는 것입니다. 따라서 doSomething ()은 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="bb65ff5a5394939f644979347352ffd342603413" translate="yes" xml:space="preserve">
          <source>The subtle difference between the two ways is that when the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-10.1.3&quot;&gt;Variable Instantiation&lt;/a&gt; process runs (before the actual code execution) all identifiers declared with &lt;code&gt;var&lt;/code&gt; will be initialized with &lt;code&gt;undefined&lt;/code&gt;, and the ones used by the &lt;code&gt;FunctionDeclaration&lt;/code&gt;'s will be available since that moment, for example:</source>
          <target state="translated">두 가지 방법 사이의 미묘한 차이점은 &lt;a href=&quot;http://bclary.com/2004/11/07/#a-10.1.3&quot;&gt;변수 인스턴스화&lt;/a&gt; 프로세스가 실행될 때 (실제 코드 실행 전에) &lt;code&gt;var&lt;/code&gt; 로 선언 된 모든 식별자는 &lt;code&gt;undefined&lt;/code&gt; 로 초기화되고, 그 순간부터 &lt;code&gt;FunctionDeclaration&lt;/code&gt; 에서 사용 된 식별자는 사용할 수 있다는 것입니다. 예:</target>
        </trans-unit>
        <trans-unit id="a07afd1ea9b12698990819eb8d76265cfe1ee004" translate="yes" xml:space="preserve">
          <source>The third form is a &lt;em&gt;named function expression&lt;/em&gt; (&quot;NFE&quot;):</source>
          <target state="translated">세 번째 형식은 &lt;em&gt;명명 된 함수 표현식&lt;/em&gt; ( &quot;NFE&quot;)입니다.</target>
        </trans-unit>
        <trans-unit id="f16969d6d2f696ede4918690b2fd4331ce87e1f7" translate="yes" xml:space="preserve">
          <source>The third way of defining a function is the &lt;strong&gt;&quot;Function()&quot; constructor&lt;/strong&gt;, which is not shown in your original post. It's not recommended to use this as it works the same way as &lt;code&gt;eval()&lt;/code&gt;, which has its problems.</source>
          <target state="translated">함수를 정의하는 세 번째 방법은 &lt;strong&gt;&quot;Function ()&quot;생성자&lt;/strong&gt; 이며 원래 게시물에는 표시되지 않습니다. 문제가있는 &lt;code&gt;eval()&lt;/code&gt; 과 동일한 방식으로 작동하므로 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b2aa94344341e29310102127f307a10790251ea2" translate="yes" xml:space="preserve">
          <source>The two code snippets you've posted there will, for almost all purposes, behave the same way.</source>
          <target state="translated">거기에 게시 한 두 개의 코드 스 니펫은 거의 모든 목적으로 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="745bcd9fd12a96b9a791e445c3c8811fc1192e62" translate="yes" xml:space="preserve">
          <source>The two ways are:</source>
          <target state="translated">두 가지 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="474bce94d0bbf46c085c74728e63fac02ca4d442" translate="yes" xml:space="preserve">
          <source>The version without &lt;code&gt;{ ... }&lt;/code&gt; is called an arrow function with an &lt;em&gt;expression body&lt;/em&gt; or &lt;em&gt;concise body&lt;/em&gt;. (Also: A &lt;em&gt;concise&lt;/em&gt; arrow function.) The one with &lt;code&gt;{ ... }&lt;/code&gt; defining the body is an arrow function with a &lt;em&gt;function body&lt;/em&gt;. (Also: A &lt;em&gt;verbose&lt;/em&gt; arrow function.)</source>
          <target state="translated">&lt;code&gt;{ ... }&lt;/code&gt; 이없는 버전을 &lt;em&gt;표현식 본문&lt;/em&gt; 또는 &lt;em&gt;간결한 본문이&lt;/em&gt; 있는 화살표 함수라고합니다. (또한 : &lt;em&gt;간결한&lt;/em&gt; 화살표 함수) 본문을 정의하는 &lt;code&gt;{ ... }&lt;/code&gt; 함수는 &lt;em&gt;함수 body&lt;/em&gt; 가있는 화살표 함수입니다. (또한 : &lt;em&gt;자세한&lt;/em&gt; 화살표 기능)</target>
        </trans-unit>
        <trans-unit id="5e2ac0591f86093c00434254dcdbb41884337a4a" translate="yes" xml:space="preserve">
          <source>There are four noteworthy comparisons between the two different declarations of functions as listed below.</source>
          <target state="translated">아래에 나열된 두 가지 함수 선언 간에는 네 가지 주목할만한 비교가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff3c75b5079b24e68e8e94930f5ee73dea969f6b" translate="yes" xml:space="preserve">
          <source>There are many techniques for namespacing. It's become more important with the plethora of JavaScript modules available.</source>
          <target state="translated">네임 스페이스 기술에는 여러 가지가 있습니다. 사용 가능한 많은 JavaScript 모듈이 점점 중요 해지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfb055384b731f9a401950a0d0ee5c9f80d9d7f9" translate="yes" xml:space="preserve">
          <source>There are two function declarations above: One for the constructor, which gets the name &lt;code&gt;Person&lt;/code&gt;, and one for &lt;code&gt;getFullName&lt;/code&gt;, which is a function assigned to &lt;code&gt;Person.prototype&lt;/code&gt;.</source>
          <target state="translated">위에는 두 개의 함수 선언이 있습니다. 하나는 &lt;code&gt;Person&lt;/code&gt; 을 가져 오는 생성자와 하나는 &lt;code&gt;Person.prototype&lt;/code&gt; 에 지정된 함수 인 &lt;code&gt;getFullName&lt;/code&gt; 을 위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="c21e5ae9b0dbaf5c8a3a97fe0a19730e14b6d355" translate="yes" xml:space="preserve">
          <source>There is a difference however at &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; the function object is actually associated with its variable. This difference is due to the mechanism called &lt;em&gt;variable hoisting&lt;/em&gt; in JavaScript.</source>
          <target state="translated">그러나 함수 객체가 실제로 변수와 연결되는 &lt;em&gt;방법&lt;/em&gt; 과 &lt;em&gt;시기&lt;/em&gt; 에는 차이가 있습니다. 이 차이점은 JavaScript에서 &lt;em&gt;변수 게양&lt;/em&gt; 이라는 메커니즘 때문입니다.</target>
        </trans-unit>
        <trans-unit id="06da7b97430b3e34f6c3267eaa4d35f03ac87eb2" translate="yes" xml:space="preserve">
          <source>There is almost no difference now between expression and declaration.</source>
          <target state="translated">표현과 선언 사이에는 거의 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f88a677f3e75a5ae4e3009a2066635b663011477" translate="yes" xml:space="preserve">
          <source>They are pretty similar with some small differences, first one is a variable which assigned to an anonymous function (Function Declaration) and second one is the normal way to create a function in JavaScript(Anonymous function Declaration), both has usage, cons and pros:</source>
          <target state="translated">그것들은 약간의 차이점과 매우 유사합니다. 첫 번째 변수는 익명 함수 (함수 선언)에 할당 된 변수이고 두 번째 변수는 JavaScript (익명 함수 선언)에서 함수를 만드는 일반적인 방법이며 사용법, 단점 및 장점이 있습니다 :</target>
        </trans-unit>
        <trans-unit id="12694bcfc3aa8628852e68a8a23a1b1ae5570a03" translate="yes" xml:space="preserve">
          <source>They don't have their own &lt;code&gt;this&lt;/code&gt;. Instead, they &lt;em&gt;close over&lt;/em&gt; the &lt;code&gt;this&lt;/code&gt; of the context where they're defined. (They also close over &lt;code&gt;arguments&lt;/code&gt; and, where relevant, &lt;code&gt;super&lt;/code&gt;.) This means that the &lt;code&gt;this&lt;/code&gt; within them is the same as the &lt;code&gt;this&lt;/code&gt; where they're created, and cannot be changed.</source>
          <target state="translated">그들은 자신의 &lt;code&gt;this&lt;/code&gt; 가지고 있지 않습니다. 대신에, 그들은 정의 된 맥락에서 &lt;code&gt;this&lt;/code&gt; 에 대해 다룹니다. (또한 &lt;code&gt;arguments&lt;/code&gt; 와 관련이있는 경우 &lt;code&gt;super&lt;/code&gt; 를 닫습니다.) 이는 그 안의 내용 &lt;code&gt;this&lt;/code&gt; 생성 된 곳과 동일하며 변경할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5d3eda8af03fd5bea6de534289810bbc9c0c9cc7" translate="yes" xml:space="preserve">
          <source>This also means you can't conditionally define functions using function declarations:</source>
          <target state="translated">이것은 또한 함수 선언을 사용하여 조건부로 함수를 정의 할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8c1789e53705ce3071d6843b82e294f18ddc1727" translate="yes" xml:space="preserve">
          <source>This is a function expression:</source>
          <target state="translated">이것은 함수 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="effa2ad61076e82c01e857bf9f7b8d602fd31fd4" translate="yes" xml:space="preserve">
          <source>This is because during execution, it looks like:</source>
          <target state="translated">실행하는 동안 다음과 같이 보이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d1fec805ab98a0513f9b9fad3d3fe8b531e695be" translate="yes" xml:space="preserve">
          <source>This is because with the first variant, the function is assigned to the variable &lt;code&gt;foo&lt;/code&gt; at run time. In the second, the function is assigned to that identifier, &lt;code&gt;foo&lt;/code&gt;, at parse time.</source>
          <target state="translated">첫 번째 변형에서는 함수가 런타임에 변수 &lt;code&gt;foo&lt;/code&gt; 에 할당되기 때문입니다. 두 번째로, 함수는 구문 분석시 해당 식별자 &lt;code&gt;foo&lt;/code&gt; 에 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="37da05445624fb3a9cad0979b5962a742fcfb61e" translate="yes" xml:space="preserve">
          <source>This is because, during execution, it looks like:-</source>
          <target state="translated">실행하는 동안 다음과 같이 보이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ac81e957d5a9edd9078b4cf183802d4b3a3c78b3" translate="yes" xml:space="preserve">
          <source>This is just two possible ways of declaring functions, and in the second way, you can use the function before declaration.</source>
          <target state="translated">이것은 함수를 선언하는 두 가지 가능한 방법이며 두 번째 방법으로 선언 전에 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8bf596e96383c7f8bf4dd936686e5dfce43757d" translate="yes" xml:space="preserve">
          <source>This is the normal way of calling a function in JavaScript, this function can be called before you even declare it as in JavaScript all functions get Hoisted, but if you have 'use strict' this won't Hoist as expected, it's a good way to call all normal functions which are not big in lines and neither are a  constructor function.</source>
          <target state="translated">이것은 JavaScript에서 함수를 호출하는 일반적인 방법입니다.이 함수는 JavaScript에서 모든 함수가 게양되는 것처럼 선언하기 전에 호출 할 수 있지만 '엄격한 사용'이 있으면 예상대로 호이스트하지 않습니다. 좋은 방법입니다. 줄이 크지 않고 생성자 함수가 아닌 모든 일반 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2b9c6d00ab6cdb468c41c536b9d5e12d359f8ad8" translate="yes" xml:space="preserve">
          <source>This is very basic, self-explanatory, used in many languages and standard across C family of languages. We declared a function defined it and executed it by calling it.</source>
          <target state="translated">이것은 매우 기본적이고 자명하며 C 언어 군에 걸쳐 많은 언어와 표준으로 사용됩니다. 정의 된 함수를 선언하고 호출하여 실행했습니다.</target>
        </trans-unit>
        <trans-unit id="f369bab590b1ff70e9147bf580834bbc48507735" translate="yes" xml:space="preserve">
          <source>This means that code like this:</source>
          <target state="translated">이것은 다음과 같은 코드를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a26f3ae40c34f7b11fe02427fe4fd04cac5639d4" translate="yes" xml:space="preserve">
          <source>To put it simply:</source>
          <target state="translated">간단히 말해 :</target>
        </trans-unit>
        <trans-unit id="f8459b728f80ead940599b3ae8ca162ea21af9e0" translate="yes" xml:space="preserve">
          <source>To study more about this topic I strongly recommend you this
&lt;a href=&quot;http://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/#comment-43792&quot;&gt;link&lt;/a&gt;</source>
          <target state="translated">이 주제에 대해 더 연구하려면이 &lt;a href=&quot;http://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/#comment-43792&quot;&gt;링크를&lt;/a&gt; 강력히 추천합니다</target>
        </trans-unit>
        <trans-unit id="408adc3e401c0d07ea40bc45f940121effd904fa" translate="yes" xml:space="preserve">
          <source>Until ES2015, the spec didn't cover what a JavaScript engine should do if you put a function declaration inside a control structure like &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc., like this:</source>
          <target state="translated">ES2015까지는 스펙이 &lt;code&gt;try&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;switch&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; 등의 제어 구조 내에 함수 선언을 넣는 경우 JavaScript 엔진이 수행해야 할 작업을 다루지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b8b097d0eea0934533ba237923021e6a341048fe" translate="yes" xml:space="preserve">
          <source>V8</source>
          <target state="translated">V8</target>
        </trans-unit>
        <trans-unit id="6fd7aa0d712bf58b6bad496b57c728877860d1e0" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;foo&lt;/code&gt; is hoisted to the top of the function, initialized to &lt;code&gt;undefined&lt;/code&gt;, so that &lt;code&gt;!foo&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, so &lt;code&gt;foo&lt;/code&gt; is assigned &lt;code&gt;10&lt;/code&gt;. The &lt;code&gt;foo&lt;/code&gt; outside of &lt;code&gt;bar&lt;/code&gt;'s scope plays no role and is untouched.</source>
          <target state="translated">변수 &lt;code&gt;foo&lt;/code&gt; 는 함수의 상단에 올라가고 &lt;code&gt;undefined&lt;/code&gt; 로 초기화되어 &lt;code&gt;!foo&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이므로 &lt;code&gt;foo&lt;/code&gt; 에 &lt;code&gt;10&lt;/code&gt; 이 할당됩니다. &lt;code&gt;bar&lt;/code&gt; 범위 밖의 &lt;code&gt;foo&lt;/code&gt; 는 아무런 역할을하지 않으며 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8532b2e0bf3f4150e5cd6a6e082f6757d298ae34" translate="yes" xml:space="preserve">
          <source>Variable Mutability</source>
          <target state="translated">가변 돌연변이 성</target>
        </trans-unit>
        <trans-unit id="6884273afe88a4cbfbe80c00ade910f535b8b76e" translate="yes" xml:space="preserve">
          <source>What Is The &quot;Nearest Block&quot;</source>
          <target state="translated">&quot;가장 가까운 블록&quot;이란 무엇입니까</target>
        </trans-unit>
        <trans-unit id="3487cb56b52e80f80380f6ee61e6d28c17778b0a" translate="yes" xml:space="preserve">
          <source>What are the reasons for using these two different methods and what are the pros and cons of each? Is there anything that can be done with one method that can't be done with the other?</source>
          <target state="translated">이 두 가지 방법을 사용하는 이유는 무엇이며 각각의 장단점은 무엇입니까? 다른 방법으로는 할 수없는 방법으로 할 수있는 것이 있습니까?</target>
        </trans-unit>
        <trans-unit id="9e5d9650d7c2bdb693414377b37154902a354c34" translate="yes" xml:space="preserve">
          <source>What you should be knowing is that functions are actually objects in JavaScript; internally we have created an object for above function and given it a name called fn or the reference to the object is stored in fn. Functions are objects in JavaScript; an instance of function is actually an object instance.</source>
          <target state="translated">알아야 할 것은 함수는 실제로 JavaScript의 객체라는 것입니다. 내부적으로 우리는 위의 함수에 대한 객체를 만들고 이름을 fn이라고 지정하거나 객체에 대한 참조가 fn에 저장됩니다. 함수는 JavaScript의 객체입니다. 함수의 인스턴스는 실제로 객체 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="cb3fb4dfbcf0fe94e2371e0b28eb0f6e2fcd530b" translate="yes" xml:space="preserve">
          <source>When a function declaration is hoisted, the function body &quot;follows&quot;
so when the function body is evaluated, the variable will immediately
be bound to a function object.</source>
          <target state="translated">함수 선언이 들어 올릴 때 함수 본문이 &quot;따라 오므로&quot;함수 본문이 평가 될 때 변수는 즉시 함수 객체에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="e9cfe61cf1adcd8f0102a36d2e0c4d12c9ca5726" translate="yes" xml:space="preserve">
          <source>When a variable declaration is hoisted, the initialization does &lt;em&gt;not&lt;/em&gt;
follow, but is &quot;left behind&quot;. The variable is initialized to
&lt;code&gt;undefined&lt;/code&gt; at the start of the function body, and will be &lt;em&gt;assigned&lt;/em&gt;
a value at its original location in the code. (Actually, it will be assigned a value at &lt;em&gt;every&lt;/em&gt; location where a declaration of a variable with the same name occurs.)</source>
          <target state="translated">변수 선언이 들어 올릴 때 초기화는 따르지 않지만 &quot;뒤에 남습니다&quot;. 변수는 함수 본문 시작시 &lt;code&gt;undefined&lt;/code&gt; 로 초기화되며 코드의 원래 위치에 값이 &lt;em&gt;할당됩니다&lt;/em&gt; . (실제로, 동일한 이름의 변수 선언이 발생하는 &lt;em&gt;모든&lt;/em&gt; 위치에 값이 할당됩니다.)</target>
        </trans-unit>
        <trans-unit id="bbe884a06b13281930a6b1c98f9d9d94e458c3b6" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;var&lt;/code&gt; keyword to declare a variable, you can then reassign a different value to the variable like so.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 키워드를 사용하여 변수를 선언하면 다른 값을 변수에 다시 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="958872366b05f9c9178f4030f046f9fcab17462f" translate="yes" xml:space="preserve">
          <source>Which expands further to:</source>
          <target state="translated">다음으로 확장</target>
        </trans-unit>
        <trans-unit id="d86a5675cc6478e7030415aaa83cd72801292548" translate="yes" xml:space="preserve">
          <source>While</source>
          <target state="translated">While</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="ac5e0452023b3c19655f17b544a743b6316fff94" translate="yes" xml:space="preserve">
          <source>With an assignment, without the &lt;code&gt;var&lt;/code&gt; statement, if the referenced identifier is not found in the scope chain, it will become a &lt;em&gt;deleteable&lt;/em&gt; property of the global object.</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 문이없는 할당을 사용하면 범위 체인에 참조 된 식별자가 없으면 전역 객체의 &lt;em&gt;삭제 가능한&lt;/em&gt; 속성이됩니다.</target>
        </trans-unit>
        <trans-unit id="2992a94652f880688ca1ececd6fbd9dc7fb7c4a7" translate="yes" xml:space="preserve">
          <source>With the second variant (&lt;code&gt;function functionTwo()&lt;/code&gt;), the function is available to code that runs above where the function is declared.</source>
          <target state="translated">두 번째 변형 ( &lt;code&gt;function functionTwo()&lt;/code&gt; )을 사용하면 함수가 선언 된 위치에서 실행되는 코드에 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0d2d3e4c919cb16a2327e829924bc496bf26df9" translate="yes" xml:space="preserve">
          <source>With this pattern, your public functions will all use assignment, while your private functions use declaration.</source>
          <target state="translated">이 패턴을 사용하면 공용 함수는 모두 할당을 사용하고 개인 함수는 선언을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2f69161f94ccc52eed8d88eea3c10a5ed51531e9" translate="yes" xml:space="preserve">
          <source>You can also create accessor functions with &lt;code&gt;Object.defineProperty&lt;/code&gt;, &lt;code&gt;Object.defineProperties&lt;/code&gt;, and the lesser-known second argument to &lt;code&gt;Object.create&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Object.defineProperty&lt;/code&gt; , &lt;code&gt;Object.defineProperties&lt;/code&gt; 및 &lt;code&gt;Object.create&lt;/code&gt; 에 대한 덜 알려진 두 번째 인수를 사용하여 접근 자 함수를 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a96fecb676cbe550b81abe5e501a476b1368603" translate="yes" xml:space="preserve">
          <source>You can check function declaration, expression test over different browser's using &lt;a href=&quot;http://jsperf.com/yashfunctions&quot;&gt;&lt;code&gt;jsperf Test Runner&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://jsperf.com/yashfunctions&quot;&gt; &lt;code&gt;jsperf Test Runner&lt;/code&gt; 를&lt;/a&gt; 사용하여 다른 브라우저에서 함수 선언, 표현식 테스트를 확인할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f3ac05813abe982cb2026b6587a9d2cd9ba582c6" translate="yes" xml:space="preserve">
          <source>You may want to know what a &lt;em&gt;function declaration&lt;/em&gt; and &lt;em&gt;function expression&lt;/em&gt; is.</source>
          <target state="translated">&lt;em&gt;함수 선언&lt;/em&gt; 과 &lt;em&gt;함수 표현식&lt;/em&gt; 이 무엇인지 알고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ec4b44222b42ad09c0dd93c4ce4013f9582d467" translate="yes" xml:space="preserve">
          <source>Your first snippet shows a &lt;strong&gt;function expression&lt;/strong&gt;. This involves using the &lt;em&gt;&quot;function&quot; operator&lt;/em&gt; to create a function - the result of that operator can be stored in any variable or object property. The function expression is powerful that way. The function expression is often called an &quot;anonymous function&quot;, because it does not have to have a name,</source>
          <target state="translated">첫 번째 스 니펫은 &lt;strong&gt;함수 표현식을&lt;/strong&gt; 보여줍니다. 여기에는 &lt;em&gt;&quot;함수&quot;연산자&lt;/em&gt; 를 사용하여 함수를 만드는 과정이 포함됩니다. 해당 연산자의 결과는 모든 변수 또는 객체 속성에 저장할 수 있습니다. 함수 표현식은 그렇게 강력합니다. 함수 표현식은 종종 이름을 가질 필요가 없기 때문에 &quot;익명 함수&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="266e022923f9faa5b3be37667e92ff1460681e19" translate="yes" xml:space="preserve">
          <source>Your second example is a &lt;strong&gt;function declaration&lt;/strong&gt;. This uses the &lt;em&gt;&quot;function&quot; statement&lt;/em&gt; to create a function. The function is made available at parse time and can be called anywhere in that scope. You can still store it in a variable or object property later.</source>
          <target state="translated">두 번째 예는 &lt;strong&gt;함수 선언&lt;/strong&gt; 입니다. 이것은 &lt;em&gt;&quot;function&quot;문&lt;/em&gt; 을 사용하여 함수를 만듭니다. 이 함수는 구문 분석시 사용 가능하며 해당 범위의 어느 곳에서나 호출 할 수 있습니다. 나중에 변수 또는 객체 속성에 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46e93c41a34284a718c071fa2d4c174a2bdd159c" translate="yes" xml:space="preserve">
          <source>and use that as a constructor as in</source>
          <target state="translated">에서와 같이 생성자로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="766f2b9d16f389f8448bfe19b9e12c43e3b610f1" translate="yes" xml:space="preserve">
          <source>depends on the context and may leave you guessing where it is actually defined, especially in the case of &lt;code&gt;eval()&lt;/code&gt; &amp;mdash; the answer is: It depends on the browser.</source>
          <target state="translated">상황에 따라 다르며 특히 &lt;code&gt;eval()&lt;/code&gt; 의 경우 실제로 정의 된 위치를 추측하게 할 수 있습니다. 대답은 다음과 같습니다. 브라우저에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9afe260f060bed6881cbee4dafbcfdde1b19a941" translate="yes" xml:space="preserve">
          <source>does the correct job of defining &lt;code&gt;myfunction&lt;/code&gt; only when &lt;code&gt;condition&lt;/code&gt; is met.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 이 충족 될 때만 내 기능을 정의하는 올바른 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="ad6a22cf9c1840cb2434e3d3948f70d3d82ff7a2" translate="yes" xml:space="preserve">
          <source>expands to</source>
          <target state="translated">~로 확장</target>
        </trans-unit>
        <trans-unit id="c9fa53e3d56127fa9a0278359df87eedc39694e4" translate="yes" xml:space="preserve">
          <source>function Identifier ( FormalParameterList&lt;sub&gt;opt&lt;/sub&gt; ) { FunctionBody }</source>
          <target state="translated">함수 식별자 (FormalParameterList &lt;sub&gt;opt&lt;/sub&gt; ) {FunctionBody}</target>
        </trans-unit>
        <trans-unit id="c80babbe10672f1522783d610020c168a8871b0f" translate="yes" xml:space="preserve">
          <source>function Identifier&lt;sub&gt;opt&lt;/sub&gt; ( FormalParameterList&lt;sub&gt;opt&lt;/sub&gt; ) { FunctionBody }</source>
          <target state="translated">함수 식별자 &lt;sub&gt;opt&lt;/sub&gt; (FormalParameterList &lt;sub&gt;opt&lt;/sub&gt; ) {FunctionBody}</target>
        </trans-unit>
        <trans-unit id="1a09252eb586133790cfd10a652a02b91c3d110e" translate="yes" xml:space="preserve">
          <source>functions declared inside the function-block are hoisted to top of the block.</source>
          <target state="translated">펑션 블록 내부에 선언 된 함수는 블록 상단에 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="ef76da7e287b143105e1345282bc04bcb536f6c4" translate="yes" xml:space="preserve">
          <source>functions declared inside the page are hoisted to top of the page having global access.</source>
          <target state="translated">페이지 내부에 선언 된 함수는 전역 액세스 권한이있는 페이지의 맨 위에 올립니다.</target>
        </trans-unit>
        <trans-unit id="564e3512cbd2ca189843edd610d4d195314e3263" translate="yes" xml:space="preserve">
          <source>it is possible to retrieve the name of the constructor as a string with &lt;code&gt;two.constructor.name&lt;/code&gt;.</source>
          <target state="translated">생성자의 이름을 &lt;code&gt;two.constructor.name&lt;/code&gt; 으로 문자열로 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2700ec2ba6fe2751639ff097bd8f8d2aacff7db5" translate="yes" xml:space="preserve">
          <source>its name is automatically assigned. But when you define it like</source>
          <target state="translated">이름이 자동으로 할당됩니다. 그러나 당신이 그것을 정의 할 때</target>
        </trans-unit>
        <trans-unit id="17daac7101b762bf7ee434b07c08b0a4c8d7ce16" translate="yes" xml:space="preserve">
          <source>its name is empty &amp;mdash; we created an anonymous function and assigned it to some variable.</source>
          <target state="translated">이름이 비어 있습니다. 익명 함수를 만들어 변수에 할당했습니다.</target>
        </trans-unit>
        <trans-unit id="c33715969df7ac0ddad9e0bddf3b744551593c8d" translate="yes" xml:space="preserve">
          <source>javascript interpreted as</source>
          <target state="translated">자바 스크립트로 해석</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="a878ab0cab33cf7bc7bc8ef10d60b74ea374cd22" translate="yes" xml:space="preserve">
          <source>the almost-equivalent in ES5 and earlier would be:</source>
          <target state="translated">ES5 및 그 이전 버전과 거의 동등한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f2ec344c7336412708c6074b118ba08228b6737" translate="yes" xml:space="preserve">
          <source>the difference (other than verbosity) is that a method can use &lt;code&gt;super&lt;/code&gt;, but a function cannot. So for instance, if you had an object that defined (say) &lt;code&gt;valueOf&lt;/code&gt; using method syntax, it could use &lt;code&gt;super.valueOf()&lt;/code&gt; to get the value &lt;code&gt;Object.prototype.valueOf&lt;/code&gt; would have returned (before presumably doing something else with it), whereas the ES5 version would have to do &lt;code&gt;Object.prototype.valueOf.call(this)&lt;/code&gt; instead.</source>
          <target state="translated">차이점 (상세도 제외)은 메소드가 &lt;code&gt;super&lt;/code&gt; 를 사용할 수 있지만 함수는 사용할 수 없다는 것입니다. 예를 들어, 메소드 구문을 사용하여 &lt;code&gt;valueOf&lt;/code&gt; 를 정의한 객체가있는 경우 &lt;code&gt;super.valueOf()&lt;/code&gt; 를 사용하여 &lt;code&gt;Object.prototype.valueOf&lt;/code&gt; 가 리턴 한 값을 얻을 수 있습니다 (아마도 다른 작업을 수행하기 전에). ES5 버전은 대신 &lt;code&gt;Object.prototype.valueOf.call(this)&lt;/code&gt; 을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="b130f4fa2fdb9f1a6204a2dcd0028ce60730d038" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;one.constructor.name&lt;/code&gt; will not be defined. &lt;code&gt;Function.name&lt;/code&gt; is non-standard but is supported by Firefox, Chrome, other Webkit-derived browsers and IE 9+.</source>
          <target state="translated">그러면 &lt;code&gt;one.constructor.name&lt;/code&gt; 이 정의되지 않습니다. &lt;code&gt;Function.name&lt;/code&gt; 은 비표준이지만 Firefox, Chrome, 기타 웹킷 파생 브라우저 및 IE 9 이상에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="db00dc47d2bcbaa5835214069da6b3a6be20e68a" translate="yes" xml:space="preserve">
          <source>var functionName = function() {} vs function functionName() {}</source>
          <target state="translated">var functionName = function () {} vs function functionName () {}</target>
        </trans-unit>
        <trans-unit id="855b18f663a06d0d7e20dd66c32870f4e2e7f8ff" translate="yes" xml:space="preserve">
          <source>variable's/Function's declared inside the page are global can access anywhere in that page.</source>
          <target state="translated">페이지 내에서 선언 된 변수 / 함수는 전역 적으로 해당 페이지의 모든 위치에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4bbf1fdfd223011ea728f2c0466d3a30c57347c" translate="yes" xml:space="preserve">
          <source>variable's/Functions declared inside the function are having local scope. means they are available/accessed inside the function body (scope), they are not available outside the function body.</source>
          <target state="translated">함수 내에서 선언 된 변수 / 함수에 로컬 범위가 있습니다. 기능 본체 (범위) 내에서 사용 가능 / 액세스 할 수 있으며 기능 본체 외부에서는 사용할 수 없습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
