<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/336859">
    <body>
      <group id="336859">
        <trans-unit id="759ade596a378339a3599da452aa422c31d07445" translate="yes" xml:space="preserve">
          <source>&quot;Anonymous&quot; &lt;code&gt;function&lt;/code&gt; Expression</source>
          <target state="translated">Expresi&amp;oacute;n de &lt;code&gt;function&lt;/code&gt; &quot;an&amp;oacute;nima&quot;</target>
        </trans-unit>
        <trans-unit id="c513b3ca88a099b3024dc76dce26a4fc3fd75194" translate="yes" xml:space="preserve">
          <source>&quot;Anonymous&quot; &lt;code&gt;function&lt;/code&gt; Expression &lt;em&gt;(which despite the term, sometimes create functions with names)&lt;/em&gt;</source>
          <target state="translated">Expresi&amp;oacute;n de &lt;code&gt;function&lt;/code&gt; &quot;an&amp;oacute;nima&quot; &lt;em&gt;(que a pesar del t&amp;eacute;rmino, a veces crea funciones con nombres)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5faf09af21e3ee207861762a8a8fc90fff45652" translate="yes" xml:space="preserve">
          <source>(Note also that assignment should require a semicolon after the statement, while declaration prohibits it.)</source>
          <target state="translated">(Obsérvese también que la cesión debe requerir un punto y coma después de la declaración,mientras que la declaración lo prohíbe).</target>
        </trans-unit>
        <trans-unit id="624606f5ae627bc4f6dabd67b23d018b1256e5ee" translate="yes" xml:space="preserve">
          <source>(Remember that &lt;code&gt;Array#map&lt;/code&gt; passes the entry as the first argument, and the index as the second.)</source>
          <target state="translated">(Recuerde que &lt;code&gt;Array#map&lt;/code&gt; pasa la entrada como el primer argumento y el &amp;iacute;ndice como el segundo).</target>
        </trans-unit>
        <trans-unit id="a6c2457af43114c5ee77f6c6836420d7fa86f67e" translate="yes" xml:space="preserve">
          <source>, this definition of &lt;code&gt;myfunction&lt;/code&gt; will override any previous definition, since it will be done at parse-time.</source>
          <target state="translated">, esta definici&amp;oacute;n de &lt;code&gt;myfunction&lt;/code&gt; anular&amp;aacute; cualquier definici&amp;oacute;n anterior, ya que se realizar&amp;aacute; en tiempo de an&amp;aacute;lisis.</target>
        </trans-unit>
        <trans-unit id="6ae78ea2e192017c2e6cecf189c9877327296eb4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://ejohn.org/apps/learn/#13&quot;&gt;Tests fail when the original ninja object is removed.&lt;/a&gt; (page 13)</source>
          <target state="translated">&lt;a href=&quot;http://ejohn.org/apps/learn/#13&quot;&gt;Las pruebas fallan cuando se elimina el objeto ninja original.&lt;/a&gt; (p&amp;aacute;gina 13)</target>
        </trans-unit>
        <trans-unit id="c9c4f8471c82ec45ea1185e07850a97d382be68f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://ejohn.org/apps/learn/#14&quot;&gt;If you name the function that will be called recursively, the tests will pass.&lt;/a&gt; (page 14)</source>
          <target state="translated">&lt;a href=&quot;http://ejohn.org/apps/learn/#14&quot;&gt;Si nombra la funci&amp;oacute;n que se llamar&amp;aacute; recursivamente, las pruebas pasar&amp;aacute;n.&lt;/a&gt; (p&amp;aacute;gina 14)</target>
        </trans-unit>
        <trans-unit id="976105ab4e318e4ac55a458be9a6999ab9810e70" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-arrow-function-definitions-static-semantics-early-errors&quot;&gt;&lt;code&gt;ArrowFunction : ArrowParameters =&amp;gt; ConciseBody&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-arrow-function-definitions-static-semantics-early-errors&quot;&gt; &lt;code&gt;ArrowFunction : ArrowParameters =&amp;gt; ConciseBody&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49d146068ed625d5d7328105f5e36bab6f733a04" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/336868/2730064&quot;&gt;Greg's Answer&lt;/a&gt; is good enough, but I still would like to add something to it that I learned just now watching &lt;a href=&quot;https://en.wikipedia.org/wiki/Douglas_Crockford&quot;&gt;Douglas Crockford's&lt;/a&gt; videos.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/336868/2730064&quot;&gt;La respuesta de Greg&lt;/a&gt; es lo suficientemente buena, pero todav&amp;iacute;a me gustar&amp;iacute;a agregarle algo que aprend&amp;iacute; justo ahora viendo &lt;a href=&quot;https://en.wikipedia.org/wiki/Douglas_Crockford&quot;&gt;los&lt;/a&gt; videos de Douglas Crockford .</target>
        </trans-unit>
        <trans-unit id="0c6835d261dfeeb9aa6c128ca4439678deec43ae" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/26394/eugene-lazutkin&quot;&gt;@EugeneLazutkin&lt;/a&gt; gives an example where he &lt;a href=&quot;https://stackoverflow.com/a/338053/&quot;&gt;names an assigned function to be able to use &lt;code&gt;shortcut()&lt;/code&gt;&lt;/a&gt; as an internal reference to itself. &lt;a href=&quot;http://ejohn.org/&quot;&gt;John Resig&lt;/a&gt; gives another example - &lt;em&gt;copying a recursive function assigned to another object&lt;/em&gt; in his &lt;a href=&quot;http://ejohn.org/apps/learn/&quot;&gt;Learning Advanced Javascript&lt;/a&gt; tutorial. While assigning functions to properties isn't strictly the question here, I recommend actively trying the tutorial out - run the code by clicking the button in the upper right corner, and double click the code to edit to your liking.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/26394/eugene-lazutkin&quot;&gt;@EugeneLazutkin&lt;/a&gt; da un ejemplo en el que &lt;a href=&quot;https://stackoverflow.com/a/338053/&quot;&gt;nombra una funci&amp;oacute;n asignada para poder usar el &lt;code&gt;shortcut()&lt;/code&gt; &lt;/a&gt; como referencia interna de s&amp;iacute; mismo. &lt;a href=&quot;http://ejohn.org/&quot;&gt;John Resig&lt;/a&gt; da otro ejemplo: &lt;em&gt;copiar una funci&amp;oacute;n recursiva asignada a otro objeto&lt;/em&gt; en su tutorial de &lt;a href=&quot;http://ejohn.org/apps/learn/&quot;&gt;Javascript avanzado de&lt;/a&gt; aprendizaje. Si bien la asignaci&amp;oacute;n de funciones a propiedades no es estrictamente la cuesti&amp;oacute;n aqu&amp;iacute;, recomiendo probar activamente el tutorial: ejecute el c&amp;oacute;digo haciendo clic en el bot&amp;oacute;n en la esquina superior derecha y haga doble clic en el c&amp;oacute;digo para editarlo a su gusto.</target>
        </trans-unit>
        <trans-unit id="7b0c22340550205afa033ace7d2728b4aad0f9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Anonymous&lt;/code&gt; function expressions &lt;a href=&quot;https://jsperf.com/named-vs-anonymous-expressions&quot;&gt;appear to have better performance&lt;/a&gt;
  against &lt;code&gt;Named&lt;/code&gt; function expression.</source>
          <target state="translated">&lt;code&gt;Anonymous&lt;/code&gt; expresiones de funciones an&amp;oacute;nimas &lt;a href=&quot;https://jsperf.com/named-vs-anonymous-expressions&quot;&gt;parecen tener un mejor rendimiento&lt;/a&gt; frente a las expresiones de funciones con &lt;code&gt;Named&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c96f22714847a8babc3882697bb6248bc8fde655" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abc&lt;/code&gt; here is defined everywhere in the current scope:</source>
          <target state="translated">&lt;code&gt;abc&lt;/code&gt; aqu&amp;iacute; se define en todas partes en el alcance actual:</target>
        </trans-unit>
        <trans-unit id="33da11fb99d15d78d5a520754cccc634c18cce28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new Function()&lt;/code&gt; can be used to pass the function's body in a string. And hence this can be used to create dynamic functions. Also passing the script without executing the script.</source>
          <target state="translated">&lt;code&gt;new Function()&lt;/code&gt; se puede utilizar para pasar el cuerpo de la funci&amp;oacute;n en una cadena. Y, por lo tanto, esto se puede usar para crear funciones din&amp;aacute;micas. Tambi&amp;eacute;n pasa el gui&amp;oacute;n sin ejecutar el gui&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d921a21481f849741d142fe29c5ea098ea13f130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xyz&lt;/code&gt; here is defined from the point of assignment:</source>
          <target state="translated">&lt;code&gt;xyz&lt;/code&gt; aqu&amp;iacute; se define desde el punto de asignaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="f861ab5b26e3b088b115db80714f64319137c837" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xyz&lt;/code&gt; is going to be defined as usual, &lt;code&gt;abc&lt;/code&gt; is undefined in all browsers but Internet&amp;nbsp;Explorer &amp;mdash; do not rely on it being defined. But it will be defined inside its body:</source>
          <target state="translated">&lt;code&gt;xyz&lt;/code&gt; se definir&amp;aacute; como de costumbre, &lt;code&gt;abc&lt;/code&gt; no est&amp;aacute; definido en todos los navegadores, pero Internet Explorer, no conf&amp;iacute;e en que se defina. Pero se definir&amp;aacute; dentro de su cuerpo:</target>
        </trans-unit>
        <trans-unit id="0996d262b069210bf614fbe919b57e1dcbed7423" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Another way to refer to itself is to use &lt;code&gt;arguments.callee&lt;/code&gt;, which is still relatively long, and not supported in the strict mode.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(Otra forma de referirse a s&amp;iacute; mismo es usar &lt;code&gt;arguments.callee&lt;/code&gt; , que todav&amp;iacute;a es relativamente largo y no es compatible en el modo estricto).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d089b89c261d900b8d8ac6af9b57fdc04eb3614b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(function)&lt;/em&gt;.name</source>
          <target state="translated">&lt;em&gt;(function)&lt;/em&gt;.name</target>
        </trans-unit>
        <trans-unit id="12f5dfe559b4186c923fded6e04fcd3ed6a3a0f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;But in the case with function declarations, the entire function body will be hoisted as well&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Pero en el caso de las declaraciones de funciones, tambi&amp;eacute;n se izar&amp;aacute; todo el cuerpo de la funci&amp;oacute;n&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="4bba3d17467d019bf50243da72010e06e9c2c779" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Function assigned to variable Example:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Funci&amp;oacute;n asignada a la variable Ejemplo:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="541cf619a3af25cde3b6df2217443cef1e854fc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;However, only the actual declarations are hoisted. by leaving assignments where they are.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Sin embargo, solo se levantan las declaraciones reales.&lt;/em&gt; &lt;em&gt;dejando las tareas donde est&amp;aacute;n.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77f992d8ae7a03a56428e18ae9187411b99ffeca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Javascript is called loosely typed language. Which means Javascript variables can hold value of any &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/7wkd9z69(v=vs.94).aspx&quot;&gt;Data-Type&lt;/a&gt;. Javascript automatically takes care of changing the variable-type based on the value/literal provided during runtime.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Javascript se llama lenguaje de escritura libre.&lt;/em&gt; &lt;em&gt;Lo que significa que las variables Javascript pueden contener valores de cualquier tipo de &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/7wkd9z69(v=vs.94).aspx&quot;&gt;datos&lt;/a&gt; .&lt;/em&gt; &lt;em&gt;Javascript se encarga autom&amp;aacute;ticamente de cambiar el tipo de variable en funci&amp;oacute;n del valor / literal proporcionado durante el tiempo de ejecuci&amp;oacute;n.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e30fdc640add63f2972505e1f77a336d70750ed6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Function Expression&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. Expresi&amp;oacute;n de funciones&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b2fd7065f9c16a465c2734b147eab3e80052db0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Function Declaration&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. Declaraci&amp;oacute;n de funciones&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1263cf84aad82d1a3af0dc6f1805903c828d3b71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://www.sitepoint.com/back-to-basics-javascript-hoisting/&quot;&gt;Hoisting&lt;/a&gt;&lt;/strong&gt;&lt;em&gt;is the JavaScript interpreter&amp;rsquo;s action of moving all variable and function declarations to the top of the current scope.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://www.sitepoint.com/back-to-basics-javascript-hoisting/&quot;&gt;La elevaci&amp;oacute;n&lt;/a&gt;&lt;/strong&gt; &lt;em&gt;es la acci&amp;oacute;n del int&amp;eacute;rprete de JavaScript de mover todas las declaraciones de variables y funciones a la parte superior del alcance actual.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f8747b2198f82905e46a1dbab75b4c9e9d7cdf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Variables&quot;&gt;Variable&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Variables&quot;&gt;Variable&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1335367051d267cd116cce2e6c150c50e7bd97ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/a/45759444/5081877&quot;&gt;ES5 Constructor Function Classes&lt;/a&gt;: Function objects created using Function.prototype.bind&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/a/45759444/5081877&quot;&gt;Clases de funciones del constructor ES5&lt;/a&gt; : objetos de funci&amp;oacute;n creados con Function.prototype.bind&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="370b180b017647cca99bd02f7e986cfc2b8fde8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;About performance:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Sobre el rendimiento:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0fe5a78a445808092f814ad102d2a04ac9fb2f93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Chrome 62.0.3202&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Chrome 62.0.3202&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dae75490d4f79450f13d95e95c5513055074b89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Chrome Canary 63.0.3225&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Chrome Canary 63.0.3225&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8466249d1be58422b099d51dfe0e1f8cc0d6448" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;FireFox 55&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;FireFox 55&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19552d8c7b704459a1b16248ad256dc0c0139741" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Firefox&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;Chrome Canary&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;Chrome&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Firefox&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;Chrome Canary&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;Chrome&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58c08f0bbcc6004dd7cb688f6907939c10e640b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES2015&lt;/strong&gt;: &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript 2015&lt;/a&gt; (also known as &quot;ES6&quot;)</source>
          <target state="translated">&lt;strong&gt;ES2015&lt;/strong&gt; : &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript 2015&lt;/a&gt; (tambi&amp;eacute;n conocido como &quot;ES6&quot;)</target>
        </trans-unit>
        <trans-unit id="eccd9ae887601fcaf5c02293700ed6d0c8b205db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES5&lt;/strong&gt;: &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript 5th edition&lt;/a&gt;, 2009</source>
          <target state="translated">&lt;strong&gt;ES5&lt;/strong&gt; : &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript 5ta edici&amp;oacute;n&lt;/a&gt; , 2009</target>
        </trans-unit>
        <trans-unit id="1ec7544bfadafd964172ff845f75d06fbafca512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function Declaration&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Declaraci&amp;oacute;n de funciones&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="469a2d465d6d3686feebc839c5b59f7f7284c5c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function Expression&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Expresi&amp;oacute;n de funciones&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1a6cbedbfde0d5779de0a3fcf412af63bdea4f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function declarations&lt;/strong&gt; are faster, and that's what really matters in web dev right? ;)</source>
          <target state="translated">&lt;strong&gt;Las declaraciones de funciones&lt;/strong&gt; son m&amp;aacute;s r&amp;aacute;pidas, y eso es lo que realmente importa en el desarrollo web, &amp;iquest;verdad? ;)</target>
        </trans-unit>
        <trans-unit id="f6569a24239dbe2b55280c9506730daaf0a33e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function expression:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Expresi&amp;oacute;n de funci&amp;oacute;n:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="586c2626c76ccfb4558d9e83014f345dd1382003" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function statement:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Declaraci&amp;oacute;n de funci&amp;oacute;n:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="936746e12db1da44d0d71d56ca5aafef2816cddd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Function&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b3af9f83ea8d3b337e7d7b746f4759ca51365d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More technical information&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;aacute;s informaci&amp;oacute;n t&amp;eacute;cnica&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="99755834340590f1e6358b23e87882e9a22abad2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This answer has been merged from &lt;a href=&quot;https://stackoverflow.com/questions/3435709/why-are-functions-in-javascript-set-to-global-variables-instead-of-plain-function&quot;&gt;another question&lt;/a&gt;, in which the major doubt and misconception from the OP was that identifiers declared with a &lt;code&gt;FunctionDeclaration&lt;/code&gt;, couldn't be overwritten which is not the case.</source>
          <target state="translated">&lt;strong&gt;Nota&lt;/strong&gt; : Esta respuesta se ha fusionado de &lt;a href=&quot;https://stackoverflow.com/questions/3435709/why-are-functions-in-javascript-set-to-global-variables-instead-of-plain-function&quot;&gt;otra pregunta&lt;/a&gt; , en la que la principal duda y el concepto err&amp;oacute;neo del OP fue que los identificadores declarados con una declaraci&amp;oacute;n de &lt;code&gt;FunctionDeclaration&lt;/code&gt; no pod&amp;iacute;an sobrescribirse, lo que no es el caso.</target>
        </trans-unit>
        <trans-unit id="6a630a0d47ae66e4b85b0b41819338abf93e312a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why no error? We were always taught that expressions are executed from top to bottom(??)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;iquest;Por qu&amp;eacute; no hay error?&lt;/strong&gt; &lt;strong&gt;Siempre nos ense&amp;ntilde;aron que las expresiones se ejecutan de arriba a abajo (??)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e98f3eda3b4182b03fb95ad990fb05e68273244" translate="yes" xml:space="preserve">
          <source>A Function Declaration defines a named function variable without
  requiring variable assignment. Function Declarations occur as
  standalone constructs and cannot be nested within non-function blocks.
  It&amp;rsquo;s helpful to think of them as siblings of Variable Declarations.
  Just as Variable Declarations must start with &amp;ldquo;var&amp;rdquo;, Function
  Declarations must begin with &amp;ldquo;function&amp;rdquo;.</source>
          <target state="translated">Una declaraci&amp;oacute;n de funci&amp;oacute;n define una variable de funci&amp;oacute;n nombrada sin requerir la asignaci&amp;oacute;n de variables. Las declaraciones de funci&amp;oacute;n se producen como construcciones independientes y no se pueden anidar dentro de bloques que no son de funci&amp;oacute;n. Es &amp;uacute;til pensar en ellos como hermanos de declaraciones variables. As&amp;iacute; como las declaraciones de variables deben comenzar con &quot;var&quot;, las declaraciones de funciones deben comenzar con &quot;function&quot;.</target>
        </trans-unit>
        <trans-unit id="e05d42878c1cb04c0e530b3d07925d7a26e19963" translate="yes" xml:space="preserve">
          <source>A Function Expression defines a function as a part of a larger
  expression syntax (typically a variable assignment ). Functions
  defined via Functions Expressions can be named or anonymous. Function
  Expressions must not start with &amp;ldquo;function&amp;rdquo; (hence the parentheses
  around the self invoking example below).</source>
          <target state="translated">Una expresi&amp;oacute;n de funci&amp;oacute;n define una funci&amp;oacute;n como parte de una sintaxis de expresi&amp;oacute;n m&amp;aacute;s grande (t&amp;iacute;picamente una asignaci&amp;oacute;n variable). Las funciones definidas a trav&amp;eacute;s de las expresiones de funciones pueden ser nombradas o an&amp;oacute;nimas. Las expresiones de funci&amp;oacute;n no deben comenzar con &quot;funci&amp;oacute;n&quot; (de ah&amp;iacute; los par&amp;eacute;ntesis alrededor del ejemplo de auto invocaci&amp;oacute;n a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="86c7d8de9fcbc249405893d86e8bf42e97cb3dc8" translate="yes" xml:space="preserve">
          <source>A better explanation to &lt;a href=&quot;https://stackoverflow.com/a/336868/2351696&quot;&gt;Greg's answer&lt;/a&gt;</source>
          <target state="translated">Una mejor explicaci&amp;oacute;n a &lt;a href=&quot;https://stackoverflow.com/a/336868/2351696&quot;&gt;la respuesta de Greg.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ca6b62f63765f6b37e6981c3fed49c39887418d" translate="yes" xml:space="preserve">
          <source>A couple of things about arrow functions:</source>
          <target state="translated">Un par de cosas sobre las funciones de las flechas:</target>
        </trans-unit>
        <trans-unit id="ba0bdb333e496781fbc28d1e1f11621acc2fdcab" translate="yes" xml:space="preserve">
          <source>A function declaration and a function expression assigned to a variable behave the same once the binding is established.</source>
          <target state="translated">Una declaración de función y una expresión de función asignada a una variable se comportan de la misma manera una vez que se establece la vinculación.</target>
        </trans-unit>
        <trans-unit id="586bbbe275e196b61f2bc269fbbcbefbe2f755d3" translate="yes" xml:space="preserve">
          <source>A function declaration can be placed anywhere in the code. Even if it is invoked before the definition appears in code, it gets executed as function declaration is committed to memory or in a way it is hoisted up, before any other code in the page starts execution.</source>
          <target state="translated">Una declaración de función puede ser colocada en cualquier lugar del código.Incluso si se invoca antes de que la definición aparezca en el código,se ejecuta a medida que la declaración de la función se compromete en la memoria o de alguna manera se eleva,antes de que cualquier otro código de la página comience la ejecución.</target>
        </trans-unit>
        <trans-unit id="fe52a62968b799ba8d3437f69fe7e179496e354b" translate="yes" xml:space="preserve">
          <source>A function declaration defines a named function variable without requiring variable assignment. Function declarations occur as standalone constructs and cannot be nested within non-function blocks.</source>
          <target state="translated">Una declaración de función define una variable de función nombrada sin requerir una asignación variable.Las declaraciones de función se producen como construcciones autónomas y no pueden anidarse dentro de bloques no funcionales.</target>
        </trans-unit>
        <trans-unit id="dffe6e21959b36399921690a083098ea3f43b751" translate="yes" xml:space="preserve">
          <source>A function declaration is a &lt;em&gt;declaration&lt;/em&gt;; it's not a statement or expression. As such, you don't follow it with a &lt;code&gt;;&lt;/code&gt; (although doing so is harmless).</source>
          <target state="translated">Una declaraci&amp;oacute;n de funci&amp;oacute;n es una &lt;em&gt;declaraci&amp;oacute;n&lt;/em&gt; ; No es una declaraci&amp;oacute;n o expresi&amp;oacute;n. Como tal, no lo sigues con un &lt;code&gt;;&lt;/code&gt; (aunque hacerlo es inofensivo).</target>
        </trans-unit>
        <trans-unit id="c4b8b821c2b59fa8045994d19ff4ed224c59880d" translate="yes" xml:space="preserve">
          <source>A function declaration is processed when execution enters the context in which it appears, &lt;strong&gt;before&lt;/strong&gt; any step-by-step code is executed. The function it creates is given a proper name (&lt;code&gt;x&lt;/code&gt; in the example above), and that name is put in the scope in which the declaration appears.</source>
          <target state="translated">Una declaraci&amp;oacute;n de funci&amp;oacute;n se procesa cuando la ejecuci&amp;oacute;n entra en el contexto en el que aparece, &lt;strong&gt;antes de que&lt;/strong&gt; se ejecute un c&amp;oacute;digo paso a paso. La funci&amp;oacute;n que crea recibe un nombre propio ( &lt;code&gt;x&lt;/code&gt; en el ejemplo anterior), y ese nombre se coloca en el &amp;aacute;mbito en el que aparece la declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6da90f6adb068378f7bee811147f83784b13cd26" translate="yes" xml:space="preserve">
          <source>A function expression defines a function as a part of a larger expression syntax (typically a variable assignment ). Functions defined via functions expressions can be named or anonymous. Function expressions should not start with &amp;ldquo;function&amp;rdquo;.</source>
          <target state="translated">Una expresi&amp;oacute;n de funci&amp;oacute;n define una funci&amp;oacute;n como parte de una sintaxis de expresi&amp;oacute;n m&amp;aacute;s grande (t&amp;iacute;picamente una asignaci&amp;oacute;n variable). Las funciones definidas mediante expresiones de funciones pueden ser nombradas o an&amp;oacute;nimas. Las expresiones de funci&amp;oacute;n no deben comenzar con &quot;funci&amp;oacute;n&quot;.</target>
        </trans-unit>
        <trans-unit id="d1a8159e77618cdd4843f0dd77192ef3cc619005" translate="yes" xml:space="preserve">
          <source>A function expression, if not defined before calling it, will result in an error. Also, here the function definition itself is not moved to the top or committed to memory like in the function declarations. But the variable to which we assign the function gets hoisted up and &lt;strong&gt;undefined&lt;/strong&gt; gets assigned to it.</source>
          <target state="translated">Una expresi&amp;oacute;n de funci&amp;oacute;n, si no se define antes de llamarla, dar&amp;aacute; como resultado un error. Adem&amp;aacute;s, aqu&amp;iacute; la definici&amp;oacute;n de la funci&amp;oacute;n en s&amp;iacute; no se mueve a la parte superior ni se guarda en la memoria, como en las declaraciones de funciones. Pero la variable a la que asignamos la funci&amp;oacute;n se eleva y se le asigna &lt;strong&gt;indefinida&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="1e474c78af8f1973b4e36a580194a43c560f1983" translate="yes" xml:space="preserve">
          <source>A global property created by a &lt;code&gt;FunctionDeclaration&lt;/code&gt; can be overwritten without any problems just like a variable value, e.g.:</source>
          <target state="translated">Una propiedad global creada por una &lt;code&gt;FunctionDeclaration&lt;/code&gt; puede sobrescribirse sin problemas, como un valor variable, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="16985658b3a31ca6aeffc5a5893a992a5e8008b3" translate="yes" xml:space="preserve">
          <source>A must read:</source>
          <target state="translated">Una lectura obligada:</target>
        </trans-unit>
        <trans-unit id="e868506d981fb5c0f6384bf8996fdae27caec377" translate="yes" xml:space="preserve">
          <source>About your edited first example (&lt;code&gt;foo = function() { alert('hello!'); };&lt;/code&gt;), it is an undeclared assignment, I would highly encourage you to always use the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">Acerca de su primer ejemplo editado ( &lt;code&gt;foo = function() { alert('hello!'); };&lt;/code&gt; ), Es una tarea no declarada, le animo a que siempre use la palabra clave &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eb314099eec1e9d7c9302b330fab0de04e4d5a0" translate="yes" xml:space="preserve">
          <source>Accessor Function Initializer (ES5+)</source>
          <target state="translated">Inicializador de la función del accesorio (ES5+)</target>
        </trans-unit>
        <trans-unit id="5e996e3eab307a7b71ac3432752e7fdfb923a820" translate="yes" xml:space="preserve">
          <source>Also see &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/881515/&quot;&gt;How do I declare a namespace in JavaScript?&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">Consulte tambi&amp;eacute;n &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/881515/&quot;&gt;&amp;iquest;C&amp;oacute;mo declaro un espacio de nombres en JavaScript?&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0da3dc3f13523455887513be16fc6b61206dd05d" translate="yes" xml:space="preserve">
          <source>Also, if you need more info about how hoisting works in JavaScript, visit the link below:</source>
          <target state="translated">Además,si necesita más información sobre cómo funciona la elevación en JavaScript,visite el siguiente enlace:</target>
        </trans-unit>
        <trans-unit id="14a4adf4af3f12e24e5839d70532eff9bbc83168" translate="yes" xml:space="preserve">
          <source>Also, it hoisted through a &lt;code&gt;return&lt;/code&gt; statement:</source>
          <target state="translated">Adem&amp;aacute;s, se iz&amp;oacute; a trav&amp;eacute;s de una declaraci&amp;oacute;n de &lt;code&gt;return&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="83c03304952acf14e910695cd06f40d8b9fbbec0" translate="yes" xml:space="preserve">
          <source>Also, undeclared assignments throw a &lt;code&gt;ReferenceError&lt;/code&gt; on ECMAScript 5 under &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/&quot;&gt;Strict Mode&lt;/a&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, las tareas no declaradas arrojan un &lt;code&gt;ReferenceError&lt;/code&gt; de referencia en ECMAScript 5 en &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/&quot;&gt;Modo estricto&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d69902d08f0a65094ca17202194440fc3b8aeba6" translate="yes" xml:space="preserve">
          <source>Although doing this wasn't &lt;em&gt;specified&lt;/em&gt; until ES2015, it was an &lt;em&gt;allowable extension&lt;/em&gt; to support function declarations in blocks. Unfortunately (and inevitably), different engines did different things.</source>
          <target state="translated">Aunque hacer esto no se &lt;em&gt;especific&amp;oacute;&lt;/em&gt; hasta ES2015, era una &lt;em&gt;extensi&amp;oacute;n permitida&lt;/em&gt; para admitir declaraciones de funciones en bloques. Desafortunadamente (e inevitablemente), diferentes motores hicieron cosas diferentes.</target>
        </trans-unit>
        <trans-unit id="711467f315de312047766526b3669d8afe66dbf2" translate="yes" xml:space="preserve">
          <source>An illustration of when to prefer the first method to the second one is when you need to avoid overriding a function's previous definitions.</source>
          <target state="translated">Un ejemplo de cuándo se debe preferir el primer método al segundo es cuando se debe evitar anular las definiciones anteriores de una función.</target>
        </trans-unit>
        <trans-unit id="76e9af881baea20b41dca7056be9ed2866b3110e" translate="yes" xml:space="preserve">
          <source>An important reason is to add one and only one variable as the &quot;Root&quot; of your namespace...</source>
          <target state="translated">Una razón importante es añadir una y sólo una variable como la &quot;Raíz&quot; de su espacio de nombres...</target>
        </trans-unit>
        <trans-unit id="22aee645613b4be0feeee7c7d21978392526a1f5" translate="yes" xml:space="preserve">
          <source>And in a function expression</source>
          <target state="translated">Y en una expresión de función</target>
        </trans-unit>
        <trans-unit id="72c0421ee623967b8daecf32d64a58d316428622" translate="yes" xml:space="preserve">
          <source>And since they're processed &lt;em&gt;before&lt;/em&gt; step-by-step code is run, it's tricky to know what to do when they're in a control structure.</source>
          <target state="translated">Y dado que se procesan &lt;em&gt;antes de&lt;/em&gt; ejecutar el c&amp;oacute;digo paso a paso, es dif&amp;iacute;cil saber qu&amp;eacute; hacer cuando est&amp;aacute;n en una estructura de control.</target>
        </trans-unit>
        <trans-unit id="721e0aa2d182321c9728514141b079a49fc8d164" translate="yes" xml:space="preserve">
          <source>And they are both hoisted to the top of the code.</source>
          <target state="translated">Y ambos son elevados a la cima del código.</target>
        </trans-unit>
        <trans-unit id="b8e93f2352a63f2f8ea04ce03020224e5e66bb84" translate="yes" xml:space="preserve">
          <source>And, a function declaration:</source>
          <target state="translated">Y,una declaración de función:</target>
        </trans-unit>
        <trans-unit id="4c5054856e4bbef19e96d760e5ea9c34ecb00648" translate="yes" xml:space="preserve">
          <source>Another difference that is not mentioned in the other answers is that if you use the anonymous function</source>
          <target state="translated">Otra diferencia que no se menciona en las otras respuestas es que si se utiliza la función anónima</target>
        </trans-unit>
        <trans-unit id="af3890af81c2b6252d1f34cfdef6f3003e49e4ce" translate="yes" xml:space="preserve">
          <source>Another good reason to use the combined style is to use a short internal name to refer to itself, while providing a long non-conflicting name for external users:</source>
          <target state="translated">Otra buena razón para utilizar el estilo combinado es utilizar un nombre interno corto para referirse a sí mismo,a la vez que se proporciona un nombre largo y no conflictivo para los usuarios externos:</target>
        </trans-unit>
        <trans-unit id="edcabfa9c012840526618d1e04748f8c28cb2838" translate="yes" xml:space="preserve">
          <source>Another obvious difference between your two examples is that the first function doesn't have a name, but the second has it, which can be really useful when debugging (i.e. inspecting a call stack).</source>
          <target state="translated">Otra diferencia obvia entre sus dos ejemplos es que la primera función no tiene nombre,pero la segunda sí,lo que puede ser muy útil para la depuración (es decir,la inspección de una pila de llamadas).</target>
        </trans-unit>
        <trans-unit id="78b91f70d93cc43865f21e88db633ffc080cd555" translate="yes" xml:space="preserve">
          <source>Arrow Function Expression (ES2015+)</source>
          <target state="translated">Expresión de la función de la flecha (ES2015+)</target>
        </trans-unit>
        <trans-unit id="95d9a52f48570a30b4afc03ec08d2692f827518e" translate="yes" xml:space="preserve">
          <source>Arrow Function Expression (ES2015+) &lt;em&gt;(which, like anonymous function expressions, don't involve an explicit name, and yet can create functions with names)&lt;/em&gt;</source>
          <target state="translated">Expresi&amp;oacute;n de funci&amp;oacute;n de flecha (ES2015 +) &lt;em&gt;(que, al igual que las expresiones de funci&amp;oacute;n an&amp;oacute;nimas, no implican un nombre expl&amp;iacute;cito y, sin embargo, puede crear funciones con nombres)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd53a48e43711dae9eac565fec3530c9b4ee1e47" translate="yes" xml:space="preserve">
          <source>Arrow Function With &lt;code&gt;function add()&lt;/code&gt;</source>
          <target state="translated">Funci&amp;oacute;n de flecha Con la &lt;code&gt;function add()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f99e80bb8fac409e2d6527343847643ed0c3e39" translate="yes" xml:space="preserve">
          <source>Arrow Function with &lt;code&gt;var add=function()&lt;/code&gt;</source>
          <target state="translated">Funci&amp;oacute;n de flecha con &lt;code&gt;var add=function()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f70eea3b7a6f694be6cb95f16c6f6793125caccc" translate="yes" xml:space="preserve">
          <source>As of ES2015, the specification says what to do. In fact, it gives three separate things to do:</source>
          <target state="translated">A partir de ES2015,la especificación dice qué hacer.De hecho,da tres cosas separadas para hacer:</target>
        </trans-unit>
        <trans-unit id="1d02938e3888244803072ebfb20246bbdc0d0b95" translate="yes" xml:space="preserve">
          <source>As of this writing, V8, SpiderMonkey, Chakra and Nitro always refer to named functions by their names. They almost always refer to an anonymous function by its identifier if it has one.</source>
          <target state="translated">En este momento,V8,SpiderMonkey,Chakra y Nitro siempre se refieren a las funciones nombradas por sus nombres.Casi siempre se refieren a una función anónima por su identificador si lo tiene.</target>
        </trans-unit>
        <trans-unit id="1b720c9c8412003b175b355c56b4ee5db0224dd0" translate="yes" xml:space="preserve">
          <source>As you'll have noticed with the above, you don't use the keyword &lt;code&gt;function&lt;/code&gt;; instead, you use &lt;code&gt;=&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Como habr&amp;aacute;s notado con lo anterior, no utilizas la &lt;code&gt;function&lt;/code&gt; palabra clave; en su lugar, usas &lt;code&gt;=&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4999f76b7eca3d345d9076570ce3eedb86bebb2" translate="yes" xml:space="preserve">
          <source>Assign a variable to a function, means no Hoisting, as we know functions in JavaScript can Hoist, means they can be called before they get declared, while variables need to be declared before getting access to them, so means in this case we can not access the function before where it's declared, also it could be a way that you write your functions, for the functions which return another function, this kind of declaration could make sense, also in ECMA6 &amp;amp; above you can assign this to an arrow function which can be used to call anonymous functions, also this way of declaring is a better way to create Constructor functions in JavaScript.</source>
          <target state="translated">Asignar una variable a una funci&amp;oacute;n, significa que no hay elevaci&amp;oacute;n, ya que sabemos que las funciones en JavaScript pueden elevar, significa que pueden llamarse antes de ser declaradas, mientras que las variables deben declararse antes de acceder a ellas, por lo que significa que en este caso no podemos acceda a la funci&amp;oacute;n antes de que se declare, tambi&amp;eacute;n podr&amp;iacute;a ser una forma de escribir sus funciones, para las funciones que devuelven otra funci&amp;oacute;n, este tipo de declaraci&amp;oacute;n podr&amp;iacute;a tener sentido, tambi&amp;eacute;n en ECMA6 y arriba puede asignar esto a una funci&amp;oacute;n de flecha que se puede usar para llamar a funciones an&amp;oacute;nimas, tambi&amp;eacute;n esta forma de declarar es una mejor manera de crear funciones de Constructor en JavaScript.</target>
        </trans-unit>
        <trans-unit id="7d6674bc9982ef481387f57cc83fdf356448f020" translate="yes" xml:space="preserve">
          <source>Availability (scope) of the function</source>
          <target state="translated">Disponibilidad (alcance)de la función</target>
        </trans-unit>
        <trans-unit id="cb3c67b40dd1ec42a7ebb8e4fedcdde942976905" translate="yes" xml:space="preserve">
          <source>Basically, all function declarations and variable declarations are hoisted to the top of the &lt;em&gt;function&lt;/em&gt; in which the declaration occurs (this is why we say that JavaScript has &lt;em&gt;function scope&lt;/em&gt;).</source>
          <target state="translated">B&amp;aacute;sicamente, todas las declaraciones de funciones y declaraciones de variables se elevan a la parte superior de la &lt;em&gt;funci&amp;oacute;n&lt;/em&gt; en la que se produce la declaraci&amp;oacute;n (es por eso que decimos que JavaScript tiene un &lt;em&gt;alcance de funci&amp;oacute;n&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c04286e0850fd4e09d7efcea4b60ed58c2b3685" translate="yes" xml:space="preserve">
          <source>Because it's processed before any step-by-step code in the same context, you can do things like this:</source>
          <target state="translated">Debido a que se procesa antes que cualquier código paso a paso en el mismo contexto,puedes hacer cosas como esta:</target>
        </trans-unit>
        <trans-unit id="13805085132e2a3520de22c522cbe8f65c7afc62" translate="yes" xml:space="preserve">
          <source>Because:</source>
          <target state="translated">Because:</target>
        </trans-unit>
        <trans-unit id="7aebd6867188b491049a61eb4878f8609a152162" translate="yes" xml:space="preserve">
          <source>Both are different ways of defining a function. The difference is how the browser interprets and loads them into an execution context.</source>
          <target state="translated">Ambas son formas diferentes de definir una función.La diferencia es la forma en que el navegador las interpreta y las carga en un contexto de ejecución.</target>
        </trans-unit>
        <trans-unit id="c5ff3cd407987df1124c03fe7e85c5b0571cb3f8" translate="yes" xml:space="preserve">
          <source>But for the most part it's not worth stressing over.</source>
          <target state="translated">Pero en su mayor parte no vale la pena estresarse por ello.</target>
        </trans-unit>
        <trans-unit id="ecc7ba886c1a06ff3f510f80143a980ada742eea" translate="yes" xml:space="preserve">
          <source>By using the variable syntax, I can declare the variable (a function pointer essentially) in the shared code and either assign a trivial stub function, or set to null.</source>
          <target state="translated">Utilizando la sintaxis de la variable,puedo declarar la variable (un puntero de función esencialmente)en el código compartido y asignar una función trivial de stub,o establecerla como nula.</target>
        </trans-unit>
        <trans-unit id="2fa0d12e3977b9cdaebbd95bbb5c680f6ef8533a" translate="yes" xml:space="preserve">
          <source>Chakra</source>
          <target state="translated">Chakra</target>
        </trans-unit>
        <trans-unit id="bec230d90facfd5f91e7a3f68902d847f6c654f2" translate="yes" xml:space="preserve">
          <source>Constructor and Method Declarations in &lt;code&gt;class&lt;/code&gt; (ES2015+)</source>
          <target state="translated">Declaraciones de constructor y m&amp;eacute;todo en &lt;code&gt;class&lt;/code&gt; (ES2015 +)</target>
        </trans-unit>
        <trans-unit id="2d08fdf2a8fb1f957e679f1a7a3412c536fd3dc4" translate="yes" xml:space="preserve">
          <source>Deep down, JavaScript treats both statements differently. This is a function declaration:</source>
          <target state="translated">En el fondo,JavaScript trata ambas declaraciones de manera diferente.Esta es una declaración de función:</target>
        </trans-unit>
        <trans-unit id="63a844213d874b8b245c742695b7941db276a173" translate="yes" xml:space="preserve">
          <source>Default return value of function is '&lt;a href=&quot;https://javascriptweblog.wordpress.com/2010/08/16/understanding-undefined-and-preventing-referenceerrors/&quot;&gt;undefined&lt;/a&gt;', &lt;a href=&quot;http://javascript.info/tutorial/variables-and-statements&quot;&gt;Variable&lt;/a&gt; declaration default value also 'undefined'</source>
          <target state="translated">El valor de retorno predeterminado de la funci&amp;oacute;n es ' &lt;a href=&quot;https://javascriptweblog.wordpress.com/2010/08/16/understanding-undefined-and-preventing-referenceerrors/&quot;&gt;undefined&lt;/a&gt; ', el valor predeterminado de la declaraci&amp;oacute;n de &lt;a href=&quot;http://javascript.info/tutorial/variables-and-statements&quot;&gt;variables&lt;/a&gt; tambi&amp;eacute;n 'undefined'</target>
        </trans-unit>
        <trans-unit id="64b93c79b512c36d99999e6e34357c9f1c087aa9" translate="yes" xml:space="preserve">
          <source>ECMA 5 (13.0) defines the syntax as</source>
          <target state="translated">El ECMA 5 (13.0)define la sintaxis como</target>
        </trans-unit>
        <trans-unit id="c150af269e5f4c4642804ca24c299f530d6bf24b" translate="yes" xml:space="preserve">
          <source>ES2015 allows a shorter form of declaring a property that references a function called a &lt;em&gt;method definition&lt;/em&gt;; it looks like this:</source>
          <target state="translated">ES2015 permite una forma m&amp;aacute;s corta de declarar una propiedad que hace referencia a una funci&amp;oacute;n llamada &lt;em&gt;definici&amp;oacute;n de m&amp;eacute;todo&lt;/em&gt; ; se parece a esto:</target>
        </trans-unit>
        <trans-unit id="b28d4620b46f9904b783e4bdca73dea8f4634eab" translate="yes" xml:space="preserve">
          <source>ES2015 brings us &lt;code&gt;class&lt;/code&gt; syntax, including declared constructors and methods:</source>
          <target state="translated">ES2015 nos trae &lt;code&gt;class&lt;/code&gt; sintaxis de clase , incluidos los constructores y m&amp;eacute;todos declarados:</target>
        </trans-unit>
        <trans-unit id="9d20a8f701915abdc4215ec73ca7a058aff15f27" translate="yes" xml:space="preserve">
          <source>ES2015 brings us the &lt;em&gt;arrow function&lt;/em&gt;. Here's one example:</source>
          <target state="translated">ES2015 nos trae la &lt;em&gt;funci&amp;oacute;n de flecha&lt;/em&gt; . Aqu&amp;iacute; hay un ejemplo:</target>
        </trans-unit>
        <trans-unit id="ac6212e9887dd3f14ce21d75177f4b2bcc5e3df2" translate="yes" xml:space="preserve">
          <source>ES6 introduced &lt;strong&gt;Arrow function&lt;/strong&gt;: An arrow function expression has a shorter syntax, they are best suited for non-method functions, and they cannot be used as constructors.</source>
          <target state="translated">ES6 introdujo la &lt;strong&gt;funci&amp;oacute;n de flecha&lt;/strong&gt; : una expresi&amp;oacute;n de funci&amp;oacute;n de flecha tiene una sintaxis m&amp;aacute;s corta, son m&amp;aacute;s adecuadas para funciones que no son de m&amp;eacute;todo y no pueden usarse como constructores.</target>
        </trans-unit>
        <trans-unit id="49a81d8fe89a66107237159e2c32f647ebe45e02" translate="yes" xml:space="preserve">
          <source>Examples from the tutorial: recursive calls in &lt;code&gt;yell()&lt;/code&gt;:</source>
          <target state="translated">Ejemplos del tutorial: llamadas recursivas en &lt;code&gt;yell()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="30e5c50747f8ddc02fafa95f11253e401b5d26e4" translate="yes" xml:space="preserve">
          <source>First I want to correct Greg: &lt;code&gt;function abc(){}&lt;/code&gt; is scoped too &amp;mdash; the name &lt;code&gt;abc&lt;/code&gt; is defined in the scope where this definition is encountered. Example:</source>
          <target state="translated">Primero quiero corregir Greg: la &lt;code&gt;function abc(){}&lt;/code&gt; tiene un alcance: el nombre &lt;code&gt;abc&lt;/code&gt; se define en el &amp;aacute;mbito donde se encuentra esta definici&amp;oacute;n. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="63aa696e0203f17e821cd16409f715c884085a35" translate="yes" xml:space="preserve">
          <source>For example, a function expression:</source>
          <target state="translated">Por ejemplo,una expresión de la función:</target>
        </trans-unit>
        <trans-unit id="d83df8cc10813d6eb9d49ec11d81159959f3b35b" translate="yes" xml:space="preserve">
          <source>For more information on anonymous functions and lambda calculus, Wikipedia is a good start (&lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;http://en.wikipedia.org/wiki/Anonymous_function&lt;/a&gt;).</source>
          <target state="translated">Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre funciones an&amp;oacute;nimas y c&amp;aacute;lculo lambda, Wikipedia es un buen comienzo ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;http://en.wikipedia.org/wiki/Anonymous_function&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="710381e12b95a3fe66706dfb40babc24d6b8e1bb" translate="yes" xml:space="preserve">
          <source>From people's comments above, I gather it may be possible to redefine a static function too, but I think the variable solution is nice and clear.</source>
          <target state="translated">De los comentarios de la gente de arriba,deduzco que puede ser posible redefinir una función estática también,pero creo que la solución variable es agradable y clara.</target>
        </trans-unit>
        <trans-unit id="69181d045b415910120ca08053987e69c74ffe57" translate="yes" xml:space="preserve">
          <source>Fun fact:</source>
          <target state="translated">Un dato curioso:</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="79f7a2b842722c439a637899094a3e9b975d2161" translate="yes" xml:space="preserve">
          <source>Function Declaration</source>
          <target state="translated">Declaración de la función</target>
        </trans-unit>
        <trans-unit id="fea3337acc300eb0d59bb99072b521bda997c9a8" translate="yes" xml:space="preserve">
          <source>Function declaration vs. function expression is the real reason why there is a difference demonstrated by Greg.</source>
          <target state="translated">La declaración de la función vs.la expresión de la función es la verdadera razón por la que hay una diferencia demostrada por Greg.</target>
        </trans-unit>
        <trans-unit id="2581d19bd1414397aab6c9d732c76b5beb72bc8d" translate="yes" xml:space="preserve">
          <source>Function declaration:</source>
          <target state="translated">Declaración de la función:</target>
        </trans-unit>
        <trans-unit id="5d4b965bdff51520668a82710d188ad4c6d2847b" translate="yes" xml:space="preserve">
          <source>Function declarations and variable declarations are always moved (&lt;code&gt;hoisted&lt;/code&gt;) invisibly to the top of their containing scope by the JavaScript interpreter. Function parameters and language-defined names are, obviously, already there. &lt;a href=&quot;http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting&quot;&gt;ben cherry&lt;/a&gt;</source>
          <target state="translated">El int&amp;eacute;rprete de JavaScript siempre mueve ( &lt;code&gt;hoisted&lt;/code&gt; ) invisiblemente las declaraciones de funciones y las declaraciones de variables a la parte superior de su &amp;aacute;mbito de contenci&amp;oacute;n. Los par&amp;aacute;metros de funci&amp;oacute;n y los nombres definidos por el idioma ya est&amp;aacute;n, obviamente, all&amp;iacute;. &lt;a href=&quot;http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting&quot;&gt;ben cherry&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f30da0007535208b5211e526a05c262a2237a322" translate="yes" xml:space="preserve">
          <source>Function declarations take precedence over variable declarations, and the last function declaration &quot;sticks&quot;.</source>
          <target state="translated">Las declaraciones de función tienen prioridad sobre las declaraciones variables,y la última declaración de función &quot;se pega&quot;.</target>
        </trans-unit>
        <trans-unit id="9c2da209e9a31c47ddfe63c4563f794fa8b30376" translate="yes" xml:space="preserve">
          <source>Function expression &lt;a href=&quot;https://jsperf.com/fdeclaration-vs-fexpression&quot;&gt;appears to be faster&lt;/a&gt; now.</source>
          <target state="translated">La expresi&amp;oacute;n de la funci&amp;oacute;n &lt;a href=&quot;https://jsperf.com/fdeclaration-vs-fexpression&quot;&gt;parece ser m&amp;aacute;s r&amp;aacute;pida&lt;/a&gt; ahora.</target>
        </trans-unit>
        <trans-unit id="b76f36a30041319319253d18b6823f5c3562c4aa" translate="yes" xml:space="preserve">
          <source>Function expression:</source>
          <target state="translated">Expresión de la función:</target>
        </trans-unit>
        <trans-unit id="a1ac0ca8c05d1c35307dcd8c89a858da945ba8b7" translate="yes" xml:space="preserve">
          <source>Harness (&lt;a href=&quot;http://jsfiddle.net/us9dg6y8/&quot;&gt;Fiddle&lt;/a&gt;)</source>
          <target state="translated">Arn&amp;eacute;s ( &lt;a href=&quot;http://jsfiddle.net/us9dg6y8/&quot;&gt;viol&amp;iacute;n&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a3e7d8a4d91ccb31d5aba99a1030f3258cd6aa3d" translate="yes" xml:space="preserve">
          <source>Here the function declaration is hoisted first, declaring and initializing variable &lt;code&gt;a&lt;/code&gt;. Next, this variable is assigned &lt;code&gt;10&lt;/code&gt;. In other words: the assignment does not assign to outer variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute; la declaraci&amp;oacute;n de funci&amp;oacute;n se iza primero, declarando e inicializando la variable &lt;code&gt;a&lt;/code&gt; . Luego, a esta variable se le asigna &lt;code&gt;10&lt;/code&gt; . En otras palabras: la asignaci&amp;oacute;n no se asigna a la variable externa &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f1cbe2358cd472b9d4c788b3633f57ec1400c8" translate="yes" xml:space="preserve">
          <source>Here's the rundown on the standard forms that create functions: &lt;em&gt;(Originally written for another question, but adapted after being moved into the canonical question.)&lt;/em&gt;</source>
          <target state="translated">Aqu&amp;iacute; est&amp;aacute; el resumen de los formularios est&amp;aacute;ndar que crean funciones: &lt;em&gt;(Originalmente escrito para otra pregunta, pero adaptado despu&amp;eacute;s de pasar a la pregunta can&amp;oacute;nica).&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9862412fbf3fc6c7bb7d8129f2f818be0d11455" translate="yes" xml:space="preserve">
          <source>Historically, anonymous functions appeared from the inability of JavaScript as a language to list members with named functions:</source>
          <target state="translated">Históricamente,las funciones anónimas aparecieron a partir de la incapacidad de JavaScript como lenguaje para listar a los miembros con funciones nombradas:</target>
        </trans-unit>
        <trans-unit id="16c223be40fd7052aab965a0fd6c87c593532cd4" translate="yes" xml:space="preserve">
          <source>However, the difference in behaviour is that with the first variant (&lt;code&gt;var functionOne = function() {}&lt;/code&gt;), that function can only be called after that point in the code.</source>
          <target state="translated">Sin embargo, la diferencia en el comportamiento es que con la primera variante ( &lt;code&gt;var functionOne = function() {}&lt;/code&gt; ), esa funci&amp;oacute;n solo se puede llamar despu&amp;eacute;s de ese punto en el c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="88718800ef1385d4eba64028d144aab14b067313" translate="yes" xml:space="preserve">
          <source>However, when we use the const-statement, the variable reference becomes immutable. This means that we cannot assign a new value to the variable. Please note, however, that this does not make the contents of the variable immutable: if you do &lt;code&gt;const arr = []&lt;/code&gt;, then you can still do &lt;code&gt;arr[10] = &quot;example&quot;&lt;/code&gt;. Only doing something like &lt;code&gt;arr = &quot;new value&quot;&lt;/code&gt; or &lt;code&gt;arr = []&lt;/code&gt; would throw an error as seen below.</source>
          <target state="translated">Sin embargo, cuando usamos la declaraci&amp;oacute;n const, la referencia variable se vuelve inmutable. Esto significa que no podemos asignar un nuevo valor a la variable. Sin embargo, tenga en cuenta que esto no hace que el contenido de la variable sea inmutable: si hace &lt;code&gt;const arr = []&lt;/code&gt; , a&amp;uacute;n puede hacer &lt;code&gt;arr[10] = &quot;example&quot;&lt;/code&gt; . Solo hacer algo como &lt;code&gt;arr = &quot;new value&quot;&lt;/code&gt; o &lt;code&gt;arr = []&lt;/code&gt; arrojar&amp;iacute;a un error como se ve a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="448a69f6cf1fb712be3c91a06ea26cc7b2a58c9d" translate="yes" xml:space="preserve">
          <source>I have code that I need to run with 160 independently-designed brandings. Most of the code is in shared files, but branding-specific stuff is in a separate file, one for each branding.</source>
          <target state="translated">Tengo un código que necesito para funcionar con 160 marcas de diseño independiente.La mayor parte del código está en archivos compartidos,pero el material específico de la marca está en un archivo separado,uno para cada marca.</target>
        </trans-unit>
        <trans-unit id="f2caaf00ea49d3671a16112cd64e966f2b9b42f1" translate="yes" xml:space="preserve">
          <source>I know that I defined it globally providing that I didn't define &lt;code&gt;abc&lt;/code&gt; anywhere in the chain of scopes. This style of definition is resilient even when used inside &lt;code&gt;eval()&lt;/code&gt;. While the definition</source>
          <target state="translated">S&amp;eacute; que lo defin&amp;iacute; globalmente, siempre que no defin&amp;iacute; &lt;code&gt;abc&lt;/code&gt; en ninguna parte de la cadena de &amp;aacute;mbitos. Este estilo de definici&amp;oacute;n es resistente incluso cuando se usa dentro de &lt;code&gt;eval()&lt;/code&gt; . Mientras que la definici&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="bc5e1bfae37a8f9624f4cf6c70c888ec885a6199" translate="yes" xml:space="preserve">
          <source>I know that I defined the function locally. When I define the function like</source>
          <target state="translated">Sé que he definido la función localmente.Cuando defino la función como</target>
        </trans-unit>
        <trans-unit id="fc40ffc8273deb922d6a2d5a6d75d6a7f097e7f5" translate="yes" xml:space="preserve">
          <source>I often build JavaScript modules with a pattern like this:</source>
          <target state="translated">A menudo construyo módulos de JavaScript con un patrón como este:</target>
        </trans-unit>
        <trans-unit id="52bb913d96e6cf1bb8f9c9868ed46fa2682d02e2" translate="yes" xml:space="preserve">
          <source>I suspect more PROS for named functions are follow. And what is listed as an advantage of named functions is a disadvantage for anonymous ones.</source>
          <target state="translated">Sospecho que le siguen más PROS para las funciones nombradas.Y lo que se enumera como una ventaja de las funciones nombradas es una desventaja para los anónimos.</target>
        </trans-unit>
        <trans-unit id="48459bd949db4fd197340d3c07b4f6d46bda103c" translate="yes" xml:space="preserve">
          <source>I use the variable approach in my code for a very specific reason, the theory of which has been covered in an abstract way above, but an example might help some people like me, with limited JavaScript expertise.</source>
          <target state="translated">Utilizo el enfoque de la variable en mi código por una razón muy específica,cuya teoría ha sido cubierta de manera abstracta anteriormente,pero un ejemplo podría ayudar a algunas personas como yo,con experiencia limitada en JavaScript.</target>
        </trans-unit>
        <trans-unit id="a720e3aa194c1f4744a62a098d3325669013f3cd" translate="yes" xml:space="preserve">
          <source>I'm adding my own answer just because everyone else has covered the hoisting part thoroughly.</source>
          <target state="translated">Añado mi propia respuesta sólo porque todos los demás han cubierto la parte de la elevación a fondo.</target>
        </trans-unit>
        <trans-unit id="6b65544a6391d547c18bfe600d2757c9ec324ddd" translate="yes" xml:space="preserve">
          <source>I'm listing out the differences below:</source>
          <target state="translated">Estoy enumerando las diferencias a continuación:</target>
        </trans-unit>
        <trans-unit id="7b6cd598514917069a107f035013ef3785ac2a80" translate="yes" xml:space="preserve">
          <source>I've recently started maintaining someone else's JavaScript code. I'm fixing bugs, adding features and also trying to tidy up the code and make it more consistent.</source>
          <target state="translated">Recientemente he empezado a mantener el código JavaScript de otra persona.Estoy arreglando errores,agregando características y también tratando de ordenar el código y hacerlo más consistente.</target>
        </trans-unit>
        <trans-unit id="bce5a0c9028577f292967e9b74591dfce14b4d0e" translate="yes" xml:space="preserve">
          <source>I've wondered about which way is better for a long while now, and thanks to &lt;a href=&quot;http://jsperf.com&quot;&gt;http://jsperf.com&lt;/a&gt; now I know :)</source>
          <target state="translated">Me he preguntado qu&amp;eacute; camino es mejor durante mucho tiempo, y gracias a &lt;a href=&quot;http://jsperf.com&quot;&gt;http://jsperf.com&lt;/a&gt; ahora lo s&amp;eacute; :)</target>
        </trans-unit>
        <trans-unit id="7253bc4a6f9bb4a8d2e1a26b26041e3d0c929006" translate="yes" xml:space="preserve">
          <source>If in &lt;em&gt;strict&lt;/em&gt; mode (browser or not), the JavaScript engine is supposed to do yet another thing</source>
          <target state="translated">Si est&amp;aacute; en modo &lt;em&gt;estricto&lt;/em&gt; (navegador o no), se supone que el motor de JavaScript debe hacer otra cosa</target>
        </trans-unit>
        <trans-unit id="47ba4d884a6eea36c2e8e1930047665437e35282" translate="yes" xml:space="preserve">
          <source>If in loose mode &lt;em&gt;not&lt;/em&gt; on a web browser, the JavaScript engine is supposed to do one thing</source>
          <target state="translated">Si en modo suelto &lt;em&gt;no est&amp;aacute;&lt;/em&gt; en un navegador web, se supone que el motor de JavaScript debe hacer una cosa</target>
        </trans-unit>
        <trans-unit id="9c24a734bfa420e8662e5588c678c512ef41507c" translate="yes" xml:space="preserve">
          <source>If in loose mode on a web browser, the JavaScript engine is supposed to do something else</source>
          <target state="translated">Si en modo suelto en un navegador web,el motor de JavaScript se supone que hace algo más</target>
        </trans-unit>
        <trans-unit id="c773779c693ffdb43c73b2a0c70b33f6e387fbfc" translate="yes" xml:space="preserve">
          <source>If there are no variables set to the function, then the functions name is the empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;).</source>
          <target state="translated">Si no hay variables establecidas para la funci&amp;oacute;n, entonces el nombre de las funciones es la cadena vac&amp;iacute;a ( &lt;code&gt;&quot;&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0ee8e8f5104dbf145e9fbcd03eca2e86caccca4f" translate="yes" xml:space="preserve">
          <source>If you really, really wanted your iterator and success callbacks to show up in the trace, you could name those too...</source>
          <target state="translated">Si realmente,realmente querías que tu iterador y las llamadas de éxito aparecieran en el rastro,podrías nombrarlas también...</target>
        </trans-unit>
        <trans-unit id="be9589a95c8b69ed2b8236a7926adaebf7d55119" translate="yes" xml:space="preserve">
          <source>If you want to alias functions on all browsers, use this kind of declaration:</source>
          <target state="translated">Si quieres alias funciones en todos los navegadores,usa este tipo de declaración:</target>
        </trans-unit>
        <trans-unit id="99925e9ee05be0efa6950a0d1631c81f1977d083" translate="yes" xml:space="preserve">
          <source>If you would use those functions to create objects, you would get:</source>
          <target state="translated">Si usaras esas funciones para crear objetos,obtendrías:</target>
        </trans-unit>
        <trans-unit id="ba22cd7a07e0cdf6f17ebe8dd72208ff7d3f75dc" translate="yes" xml:space="preserve">
          <source>If you're doing more than just a single expression, use &lt;code&gt;{}&lt;/code&gt; and an explicit &lt;code&gt;return&lt;/code&gt; (if you need to return a value), as normal:</source>
          <target state="translated">Si est&amp;aacute; haciendo m&amp;aacute;s que una sola expresi&amp;oacute;n, use &lt;code&gt;{}&lt;/code&gt; y un &lt;code&gt;return&lt;/code&gt; expl&amp;iacute;cito (si necesita devolver un valor), como es normal:</target>
        </trans-unit>
        <trans-unit id="18d78f8520de80f2c3d19326953d4afd2bce640f" translate="yes" xml:space="preserve">
          <source>In ES5, the function this creates has no name (it's anonymous). In ES2015, the function is assigned a name if possible by inferring it from context. In the example above, the name would be &lt;code&gt;y&lt;/code&gt;. Something similar is done when the function is the value of a property initializer. (For details on when this happens and the rules, search for &lt;code&gt;SetFunctionName&lt;/code&gt; in the &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;the specification&lt;/a&gt;&amp;nbsp;&amp;mdash; it appears &lt;em&gt;all over&lt;/em&gt; the place.)</source>
          <target state="translated">En ES5, la funci&amp;oacute;n que esto crea no tiene nombre (es an&amp;oacute;nima). En ES2015, a la funci&amp;oacute;n se le asigna un nombre si es posible deduci&amp;eacute;ndolo del contexto. En el ejemplo anterior, el nombre ser&amp;iacute;a &lt;code&gt;y&lt;/code&gt; . Algo similar se hace cuando la funci&amp;oacute;n es el valor de un inicializador de propiedad. (Para obtener detalles sobre cu&amp;aacute;ndo sucede esto y las reglas, busque &lt;code&gt;SetFunctionName&lt;/code&gt; en &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;la especificaci&amp;oacute;n&lt;/a&gt; ; aparece por &lt;em&gt;todas partes&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="4d0a437ff9ee930d494784b0a38eceebe7464cfb" translate="yes" xml:space="preserve">
          <source>In Google's V8 and Firefox's Spidermonkey there might be a few microsecond JIST compilation difference, but ultimately the result is the exact same. To prove this, let's examine the efficiency of JSPerf at microbenchmarks by comparing the speed of two blank code snippets. The &lt;a href=&quot;https://jsperf.com/microbenchmark-analysis/1&quot;&gt;JSPerf tests are found here&lt;/a&gt;. And, the &lt;a href=&quot;http://jsben.ch/Ov6eJ&quot;&gt;jsben.ch testsare  found here&lt;/a&gt;. As you can see, there is a noticable difference when there should be none. If you are really a performance freak like me, then it might be more worth your while trying to reduce the number of variables and functions in the scope and especially eliminating polymorphism (such as using the same variable to store two different types).</source>
          <target state="translated">En Google V8 y Firemon's Spidermonkey puede haber una diferencia de compilaci&amp;oacute;n JIST de microsegundos, pero en &amp;uacute;ltima instancia, el resultado es exactamente el mismo. Para probar esto, examinemos la eficiencia de JSPerf en microbenchmarks comparando la velocidad de dos fragmentos de c&amp;oacute;digo en blanco. Las &lt;a href=&quot;https://jsperf.com/microbenchmark-analysis/1&quot;&gt;pruebas JSPerf se encuentran aqu&amp;iacute;&lt;/a&gt; . Y, las &lt;a href=&quot;http://jsben.ch/Ov6eJ&quot;&gt;pruebas jsben.ch se encuentran aqu&amp;iacute;&lt;/a&gt; . Como puede ver, hay una diferencia notable cuando no deber&amp;iacute;a haber ninguna. Si realmente eres un fan&amp;aacute;tico del rendimiento como yo, entonces podr&amp;iacute;a valer m&amp;aacute;s la pena intentar reducir el n&amp;uacute;mero de variables y funciones en el alcance y, especialmente, eliminar el polimorfismo (como usar la misma variable para almacenar dos tipos diferentes).</target>
        </trans-unit>
        <trans-unit id="77530f56c5b4887f097bf802c9364dfb9c6bf513" translate="yes" xml:space="preserve">
          <source>In JavaScript there are two ways to create functions:</source>
          <target state="translated">En JavaScript hay dos maneras de crear funciones:</target>
        </trans-unit>
        <trans-unit id="743fad7b9f2b3005515bc6a8b41cc5305db6d16c" translate="yes" xml:space="preserve">
          <source>In a debugger you will clearly see the function name on the call stack instead of an &quot;anonymous/evaluated&quot; function.</source>
          <target state="translated">En un depurador verá claramente el nombre de la función en la pila de llamadas en lugar de una función &quot;evaluada anónimamente&quot;.</target>
        </trans-unit>
        <trans-unit id="40ac26672752f4a573b68a025efd96f93c7cda1f" translate="yes" xml:space="preserve">
          <source>In above condition the function name is visible within its scope and the scope of its parent (otherwise it would be unreachable).</source>
          <target state="translated">En la condición anterior,el nombre de la función es visible dentro de su alcance y del alcance de su progenitor (de lo contrario sería inalcanzable).</target>
        </trans-unit>
        <trans-unit id="1f5563a0832819a0b28ffe111ae45fd4c8971126" translate="yes" xml:space="preserve">
          <source>In both cases, the body of the function is just an expression; the function's return value will automatically be the result of that expression (you don't use an explicit &lt;code&gt;return&lt;/code&gt;).</source>
          <target state="translated">En ambos casos, el cuerpo de la funci&amp;oacute;n es solo una expresi&amp;oacute;n; El valor de retorno de la funci&amp;oacute;n ser&amp;aacute; autom&amp;aacute;ticamente el resultado de esa expresi&amp;oacute;n (no utiliza un &lt;code&gt;return&lt;/code&gt; expl&amp;iacute;cito).</target>
        </trans-unit>
        <trans-unit id="d0c1580d80e84da99a8bb130ae769242b985147e" translate="yes" xml:space="preserve">
          <source>In computer science terms, we talk about anonymous functions and named functions. I think the most important difference is that an anonymous function is not bound to an name, hence the name anonymous function. In JavaScript it is a first class object dynamically declared at runtime.</source>
          <target state="translated">En términos de informática,hablamos de funciones anónimas y funciones con nombre.Creo que la diferencia más importante es que una función anónima no está ligada a un nombre,de ahí el nombre de función anónima.En JavaScript es un objeto de primera clase declarado dinámicamente en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="9ad24effba4df71940268999b683a278696da2a5" translate="yes" xml:space="preserve">
          <source>In light of the &quot;named functions show up in stack traces&quot; argument, modern JavaScript engines are actually quite capable of representing anonymous functions.</source>
          <target state="translated">A la luz del argumento &quot;las funciones nombradas aparecen en los rastros de la pila&quot;,los modernos motores de JavaScript son en realidad bastante capaces de representar funciones anónimas.</target>
        </trans-unit>
        <trans-unit id="bada26db6ba62d3b37fbfb0f8797580b37b425d5" translate="yes" xml:space="preserve">
          <source>In terms of code maintenance cost, named functions are more preferable:</source>
          <target state="translated">En cuanto al costo de mantenimiento del código,las funciones nombradas son más preferibles:</target>
        </trans-unit>
        <trans-unit id="0ab56e8403de5abcd245a223331dd74301ac39fd" translate="yes" xml:space="preserve">
          <source>In the example above we can do the same with an external name, but it'll be too unwieldy (and slower).</source>
          <target state="translated">En el ejemplo anterior podemos hacer lo mismo con un nombre externo,pero será demasiado difícil de manejar (y más lento).</target>
        </trans-unit>
        <trans-unit id="99565775fc2dc3442ac3db8b854377a4e1535255" translate="yes" xml:space="preserve">
          <source>In this case, both &lt;code&gt;xyz&lt;/code&gt; and &lt;code&gt;abc&lt;/code&gt; are aliases of the same object:</source>
          <target state="translated">En este caso, tanto &lt;code&gt;xyz&lt;/code&gt; como &lt;code&gt;abc&lt;/code&gt; son alias del mismo objeto:</target>
        </trans-unit>
        <trans-unit id="f34745ad4ce35316a6c1a3f69ce6b5aa657af5a5" translate="yes" xml:space="preserve">
          <source>In this example &lt;code&gt;a&lt;/code&gt; is initialized with the function object resulting from evaluating the second function declaration, and then is assigned &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;a&lt;/code&gt; se inicializa con el objeto de funci&amp;oacute;n resultante de evaluar la segunda declaraci&amp;oacute;n de funci&amp;oacute;n, y luego se le asigna &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5a8ada85e0dd38f6230fbd0de001e929f7a5ccb" translate="yes" xml:space="preserve">
          <source>Independent from the place where they are declared (but still limited by scope).</source>
          <target state="translated">Independientemente del lugar en que se declaren (pero aún así limitado por su alcance).</target>
        </trans-unit>
        <trans-unit id="88d605e955dd6c957da2b10f658bd3437ef6a188" translate="yes" xml:space="preserve">
          <source>Interestingly, if we declare the variable as &lt;code&gt;function funcName(){}&lt;/code&gt;, then the immutability of the variable is the same as declaring it with &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">Curiosamente, si declaramos la variable como &lt;code&gt;function funcName(){}&lt;/code&gt; , entonces la inmutabilidad de la variable es la misma que declararla con &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cd8788595c6099fbc89a56b7505fbb8d78f9944" translate="yes" xml:space="preserve">
          <source>It is not safe to write function declarations in non-function blocks like &lt;strong&gt;if&lt;/strong&gt; because they won't be accessible.</source>
          <target state="translated">No es seguro escribir declaraciones de funciones en bloques que no son de funci&amp;oacute;n, como &lt;strong&gt;si fuera&lt;/strong&gt; porque no ser&amp;aacute;n accesibles.</target>
        </trans-unit>
        <trans-unit id="66fbe41a46d13b3ec9ad6d15a6cbc7ebb0163825" translate="yes" xml:space="preserve">
          <source>JavaScript has first-class functions, that is, create a function and assign it to a variable just like you create a string or number and assign it to a variable. Here, the fn variable is assigned to a function. The reason for this concept is functions are objects in JavaScript; fn is pointing to the object instance of the above function. We have initialized a function and assigned it to a variable. It's not executing the function and assigning the result.</source>
          <target state="translated">JavaScript tiene funciones de primera clase,es decir,crear una función y asignarla a una variable como se crea una cadena o un número y asignarlo a una variable.Aquí,la variable fn se asigna a una función.La razón de este concepto es que las funciones son objetos en JavaScript;fn está apuntando a la instancia de objeto de la función anterior.Hemos inicializado una función y la hemos asignado a una variable.No está ejecutando la función y asignando el resultado.</target>
        </trans-unit>
        <trans-unit id="dc87314ad86194e07f204ed20a079cd40c0d7d92" translate="yes" xml:space="preserve">
          <source>JavaScript has three ways of defining functions.</source>
          <target state="translated">JavaScript tiene tres formas de definir las funciones.</target>
        </trans-unit>
        <trans-unit id="386881110fbc49ba4e9cbf28d7d0d56af3d005b0" translate="yes" xml:space="preserve">
          <source>JavaScript treats functions as first-class objects, so being an object, you can assign properties to a function.</source>
          <target state="translated">JavaScript trata las funciones como objetos de primera clase,por lo que siendo un objeto,puede asignar propiedades a una función.</target>
        </trans-unit>
        <trans-unit id="b0771db0681dd1086ab043dd36cac9a035ed201d" translate="yes" xml:space="preserve">
          <source>Lastly, while the variable the function is assigned to initially sets the name, successive variables set to the function do not change the name.</source>
          <target state="translated">Por último,mientras que la variable a la que se asigna la función fija inicialmente el nombre,las variables sucesivas fijadas a la función no cambian el nombre.</target>
        </trans-unit>
        <trans-unit id="131c609e07fa46c90f8a914d0d9876618cb16ffa" translate="yes" xml:space="preserve">
          <source>Like all expressions, it's evaluated when it's reached in the step-by-step execution of the code.</source>
          <target state="translated">Como todas las expresiones,se evalúa cuando se alcanza en la ejecución paso a paso del código.</target>
        </trans-unit>
        <trans-unit id="9047887da470d7120807196284dd5dbf0f775748" translate="yes" xml:space="preserve">
          <source>Method Declaration in Object Initializer (ES2015+)</source>
          <target state="translated">Declaración del método en el Iniciador de Objetos (ES2015+)</target>
        </trans-unit>
        <trans-unit id="f6e8c432ab6e69fb5b19460ea3141b5206869a18" translate="yes" xml:space="preserve">
          <source>More resistant to mistakes like conditional initialization (you are still able to override if wanted to).</source>
          <target state="translated">Más resistente a errores como la inicialización condicional (aún se puede anular si se quiere).</target>
        </trans-unit>
        <trans-unit id="f0128c3077ca982c05c67d537afe75962bbc772f" translate="yes" xml:space="preserve">
          <source>Named &lt;code&gt;function&lt;/code&gt; Expression</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; nombrada Expresi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="777148d87c109971486523e49744c67e7e30f167" translate="yes" xml:space="preserve">
          <source>Named function expression like the one below, may not work in Internet&amp;nbsp;Explorer browsers prior to version 9.</source>
          <target state="translated">Es posible que una expresi&amp;oacute;n de funci&amp;oacute;n con nombre como la que se muestra a continuaci&amp;oacute;n no funcione en los navegadores Internet Explorer anteriores a la versi&amp;oacute;n 9.</target>
        </trans-unit>
        <trans-unit id="a2af52c0ccfa8c408328b7c06cce7ab9ec1d62fa" translate="yes" xml:space="preserve">
          <source>Named function expressions demystified</source>
          <target state="translated">Expresiones de funciones nombradas desmitificadas</target>
        </trans-unit>
        <trans-unit id="dc9e3d6fd9e9ce94aab3c1ef25f88d46b96264d9" translate="yes" xml:space="preserve">
          <source>New versions of &lt;code&gt;V8&lt;/code&gt; introduced several under-the-hood optimizations and so did &lt;code&gt;SpiderMonkey&lt;/code&gt;.</source>
          <target state="translated">Las nuevas versiones de &lt;code&gt;V8&lt;/code&gt; introdujeron varias optimizaciones bajo el cap&amp;oacute; y tambi&amp;eacute;n &lt;code&gt;SpiderMonkey&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65bd7ea4a6bcc80835c2ec2b979fb00bb0f4c9ac" translate="yes" xml:space="preserve">
          <source>Nitro</source>
          <target state="translated">Nitro</target>
        </trans-unit>
        <trans-unit id="8110b79db7f83a1e8b4ca63a622ef7443e84ba94" translate="yes" xml:space="preserve">
          <source>Normal &lt;code&gt;function add(){}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;function add(){}&lt;/code&gt; normal add () {}</target>
        </trans-unit>
        <trans-unit id="6c5a68d9eef8721bfe6330530d6cdfda8dbcb430" translate="yes" xml:space="preserve">
          <source>Normal &lt;code&gt;var add=function(){}&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;var add=function(){}&lt;/code&gt; normal add = function () {}</target>
        </trans-unit>
        <trans-unit id="f50d4d872d6f1fc0198387a8cbf12922732ec09a" translate="yes" xml:space="preserve">
          <source>Note that NFEs have frequently been a source of bugs for JavaScript implementations. IE8 and earlier, for instance, handle NFEs &lt;a href=&quot;http://blog.niftysnippets.org/2010/09/double-take.html&quot;&gt;completely incorrectly&lt;/a&gt;, creating two different functions at two different times. Early versions of Safari had issues as well. The good news is that current versions of browsers (IE9 and up, current Safari) don't have those issues any more. (But as of this writing, sadly, IE8 remains in widespread use, and so using NFEs with code for the web in general is still problematic.)</source>
          <target state="translated">Tenga en cuenta que los NFE han sido con frecuencia una fuente de errores para las implementaciones de JavaScript. IE8 y versiones anteriores, por ejemplo, manejan los NFE de forma &lt;a href=&quot;http://blog.niftysnippets.org/2010/09/double-take.html&quot;&gt;completamente incorrecta&lt;/a&gt; , creando dos funciones diferentes en dos momentos diferentes. Las primeras versiones de Safari tambi&amp;eacute;n ten&amp;iacute;an problemas. La buena noticia es que las versiones actuales de los navegadores (IE9 y superiores, Safari actual) ya no tienen esos problemas. (Pero a partir de este escrito, lamentablemente, IE8 sigue siendo de uso generalizado, por lo que el uso de NFE con c&amp;oacute;digo para la web en general sigue siendo problem&amp;aacute;tico).</target>
        </trans-unit>
        <trans-unit id="46c934ebb5c49a0e1a45001cc099b679e5fc9cba" translate="yes" xml:space="preserve">
          <source>Note that when I used the function, I didn't use &lt;code&gt;()&lt;/code&gt;! That's because it's an &lt;em&gt;accessor function&lt;/em&gt; for a property. We get and set the property in the normal way, but behind the scenes, the function is called.</source>
          <target state="translated">Tenga en cuenta que cuando us&amp;eacute; la funci&amp;oacute;n, &amp;iexcl;no us&amp;eacute; &lt;code&gt;()&lt;/code&gt; ! Eso es porque es una &lt;em&gt;funci&amp;oacute;n de acceso&lt;/em&gt; para una propiedad. Obtenemos y configuramos la propiedad de la manera normal, pero detr&amp;aacute;s de escena, se llama a la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b0135a3fe9edd1aa747c5dc00ef86223a2fba31b" translate="yes" xml:space="preserve">
          <source>Notice that the assignment portion of the declarations were not hoisted. Only the name is hoisted.</source>
          <target state="translated">Observe que la parte de la asignación de las declaraciones no fue levantada.Sólo el nombre se ha levantado.</target>
        </trans-unit>
        <trans-unit id="bc114abbd8dd8a2cd0b954fda2e13a328089452b" translate="yes" xml:space="preserve">
          <source>On the second line we are assigning the reference of an anonymous function to functionOne.</source>
          <target state="translated">En la segunda línea estamos asignando la referencia de una función anónima a functionOne.</target>
        </trans-unit>
        <trans-unit id="8843a229a0f472ada31ba06061df9ac263f902f6" translate="yes" xml:space="preserve">
          <source>One compelling reason to use the combined style is the &quot;name&quot; attribute of function objects (&lt;strong&gt;not supported by Internet&amp;nbsp;Explorer&lt;/strong&gt;). Basically when you define a function like</source>
          <target state="translated">Una raz&amp;oacute;n convincente para usar el estilo combinado es el atributo &quot;nombre&quot; de los objetos de funci&amp;oacute;n ( &lt;strong&gt;no es compatible con Internet Explorer&lt;/strong&gt; ). B&amp;aacute;sicamente cuando define una funci&amp;oacute;n como</target>
        </trans-unit>
        <trans-unit id="dbe6fdfa55051d3eebbbe9fd39842bacd3d7cc72" translate="yes" xml:space="preserve">
          <source>Other commenters have already covered the semantic difference of the two variants above. I wanted to note a stylistic difference: Only the &quot;assignment&quot; variation can set a property of another object.</source>
          <target state="translated">Otros comentaristas ya han cubierto la diferencia semántica de las dos variantes anteriores.Quería notar una diferencia estilística:Sólo la variación &quot;asignación&quot; puede establecer una propiedad de otro objeto.</target>
        </trans-unit>
        <trans-unit id="95fa44f122d0d2fde84daa10053c89ba105c1733" translate="yes" xml:space="preserve">
          <source>Otherwise, if a function is declared as &lt;code&gt;function(){}&lt;/code&gt;, the &lt;em&gt;function&lt;/em&gt;.name is the first variable used to store the function.</source>
          <target state="translated">De lo contrario, si una funci&amp;oacute;n se declara como &lt;code&gt;function(){}&lt;/code&gt; , la &lt;em&gt;funci&amp;oacute;n&lt;/em&gt; .name es la primera variable utilizada para almacenar la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="bcc6976fdb7b0bab8f43d0bd6a3d5c3f3f1f4418" translate="yes" xml:space="preserve">
          <source>Personally, I prefer the &quot;function expression&quot; declaration because this way I can control the visibility. When I define the function like</source>
          <target state="translated">Personalmente,prefiero la declaración de &quot;expresión de la función&quot; porque así puedo controlar la visibilidad.Cuando defino la función como</target>
        </trans-unit>
        <trans-unit id="48e539471552b322b96b629b50e168373aab581d" translate="yes" xml:space="preserve">
          <source>Reference: &lt;em&gt;&lt;a href=&quot;http://jkoder.com/javascript-function-declaration-syntax-var-fn-function-vs-function-fn/&quot;&gt;JavaScript function declaration syntax: var fn = function() {} vs function fn() {}&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">Referencia: &lt;em&gt;&lt;a href=&quot;http://jkoder.com/javascript-function-declaration-syntax-var-fn-function-vs-function-fn/&quot;&gt;sintaxis de declaraci&amp;oacute;n de funci&amp;oacute;n de JavaScript: var fn = function () {} vs function fn () {}&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2fa869913cd407b8374e8002710a8e37791c0a7c" translate="yes" xml:space="preserve">
          <source>Same function using function expressions:</source>
          <target state="translated">La misma función usando expresiones de función:</target>
        </trans-unit>
        <trans-unit id="a342ddf70636f32b76e4ff5a5d52c5eb4e44afd7" translate="yes" xml:space="preserve">
          <source>Secondly, it is possible to combine both styles:</source>
          <target state="translated">En segundo lugar,es posible combinar ambos estilos:</target>
        </trans-unit>
        <trans-unit id="8f28d3ab65fed240b09f7deb679e37f9272d4792" translate="yes" xml:space="preserve">
          <source>See that &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; thing hiding in the &lt;code&gt;map()&lt;/code&gt; call? That's a function.</source>
          <target state="translated">&amp;iquest;Ves que &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; cosa oculta en la llamada &lt;code&gt;map()&lt;/code&gt; ? Esa es una funcion.</target>
        </trans-unit>
        <trans-unit id="26c0ca793e8f7074d3f8c82877440040dbf9523b" translate="yes" xml:space="preserve">
          <source>So</source>
          <target state="translated">So</target>
        </trans-unit>
        <trans-unit id="46c47815b690569dbb7a656b8964b6c4a2aec3eb" translate="yes" xml:space="preserve">
          <source>Some brandings require specific functions, and some do not. Sometimes I have to add new functions to do new branding-specific things. I am happy to change the shared coded, but I don't want to have to change all 160 sets of branding files.</source>
          <target state="translated">Algunas marcas requieren funciones específicas,y otras no.A veces tengo que añadir nuevas funciones para hacer nuevas cosas específicas de la marca.Estoy feliz de cambiar el código compartido,pero no quiero tener que cambiar los 160 conjuntos de archivos de marca.</target>
        </trans-unit>
        <trans-unit id="5f39892c489c20b210e85c99d0636ddca2f715ec" translate="yes" xml:space="preserve">
          <source>Some examples...</source>
          <target state="translated">Algunos ejemplos...</target>
        </trans-unit>
        <trans-unit id="48fe26184a1da0188c638e9837cd0348befd6fc9" translate="yes" xml:space="preserve">
          <source>Sometimes functions can sneak in largely unnoticed; that's the case with &lt;em&gt;accessor functions&lt;/em&gt;. Here's an example:</source>
          <target state="translated">A veces las funciones pueden colarse en gran medida sin ser notadas; Ese es el caso de las &lt;em&gt;funciones de acceso&lt;/em&gt; . Aqu&amp;iacute; hay un ejemplo:</target>
        </trans-unit>
        <trans-unit id="387053ec024b111c7ef9f523fd9328f604a02b3d" translate="yes" xml:space="preserve">
          <source>Speaking about the global context, both, the &lt;code&gt;var&lt;/code&gt; statement and a &lt;code&gt;FunctionDeclaration&lt;/code&gt; at the end will create a &lt;em&gt;non-deleteable&lt;/em&gt; property on the global object, but the value of both &lt;em&gt;can be overwritten&lt;/em&gt;.</source>
          <target state="translated">Hablando sobre el contexto global, ambos, la declaraci&amp;oacute;n &lt;code&gt;var&lt;/code&gt; y una &lt;code&gt;FunctionDeclaration&lt;/code&gt; al final crear&amp;aacute;n una propiedad &lt;em&gt;no borrable&lt;/em&gt; en el objeto global, pero el valor de ambos &lt;em&gt;puede sobrescribirse&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f65122e6f32c2bcabdd432788ea598df5c48d617" translate="yes" xml:space="preserve">
          <source>SpiderMonkey</source>
          <target state="translated">SpiderMonkey</target>
        </trans-unit>
        <trans-unit id="c6651b9a96d11046277cfbcd116304f61f74227d" translate="yes" xml:space="preserve">
          <source>SpiderMonkey can figure out the name of an anonymous function returned from another function. The rest can't.</source>
          <target state="translated">SpiderMonkey puede averiguar el nombre de una función anónima devuelta de otra función.El resto no puede.</target>
        </trans-unit>
        <trans-unit id="0ae1828118a1782dda8e1ea5ac856c97b23cc230" translate="yes" xml:space="preserve">
          <source>Statement (such as &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;finally&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;)</source>
          <target state="translated">Declaraci&amp;oacute;n (como &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; / &lt;code&gt;finally&lt;/code&gt; , &lt;code&gt;switch&lt;/code&gt; , &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bc07256662906a0b6337c96a56729c6ca11dc5d1" translate="yes" xml:space="preserve">
          <source>Take a look at the function below:</source>
          <target state="translated">Echa un vistazo a la función de abajo:</target>
        </trans-unit>
        <trans-unit id="ffdc12529405fd8a1fe177c00af6a4b1b34cbdf9" translate="yes" xml:space="preserve">
          <source>Terms:</source>
          <target state="translated">Terms:</target>
        </trans-unit>
        <trans-unit id="f63f70d99a4f81b8e70665fd22c3174d3eeca9cf" translate="yes" xml:space="preserve">
          <source>That also means that the method has a reference to the object it was defined on, so if that object is temporary (for instance, you're passing it into &lt;code&gt;Object.assign&lt;/code&gt; as one of the source objects), method syntax &lt;em&gt;could&lt;/em&gt; mean that the object is retained in memory when otherwise it could have been garbage collected (if the JavaScript engine doesn't detect that situation and handle it if none of the methods uses &lt;code&gt;super&lt;/code&gt;).</source>
          <target state="translated">Eso tambi&amp;eacute;n significa que el m&amp;eacute;todo tiene una referencia al objeto en el que se defini&amp;oacute;, por lo que si ese objeto es temporal (por ejemplo, lo est&amp;aacute; pasando a &lt;code&gt;Object.assign&lt;/code&gt; como uno de los objetos de origen), la sintaxis del m&amp;eacute;todo &lt;em&gt;podr&amp;iacute;a&lt;/em&gt; significar que el objeto se retiene en la memoria cuando, de lo contrario, podr&amp;iacute;a haberse recolectado basura (si el motor de JavaScript no detecta esa situaci&amp;oacute;n y la maneja si ninguno de los m&amp;eacute;todos usa &lt;code&gt;super&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a48c26e1972ebb64b7dc5783e0fabcbb52b4ce7e" translate="yes" xml:space="preserve">
          <source>The &quot;nearest block&quot; is the nearest &quot;function,&quot; (including asynchronous functions, generator functions, and asynchronous generator functions). However, interestingly, a &lt;code&gt;function functionName() {}&lt;/code&gt; behaves like a &lt;code&gt;var functionName = function() {}&lt;/code&gt; when in a non-closure block to items outside said closure. Observe.</source>
          <target state="translated">El &quot;bloque m&amp;aacute;s cercano&quot; es la &quot;funci&amp;oacute;n&quot; m&amp;aacute;s cercana (incluidas las funciones as&amp;iacute;ncronas, las funciones generadoras y las funciones generadoras as&amp;iacute;ncronas). Sin embargo, curiosamente, una &lt;code&gt;function functionName() {}&lt;/code&gt; comporta como una &lt;code&gt;var functionName = function() {}&lt;/code&gt; cuando est&amp;aacute; en un bloque sin cierre para elementos fuera de dicho cierre. Observar.</target>
        </trans-unit>
        <trans-unit id="6a595334c53b5e54513ecbf67288a1b96ade59c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; example above is one form of them. If you have multiple arguments to pass the function, you use parens:</source>
          <target state="translated">El ejemplo &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; anterior es una forma de ellos. Si tiene m&amp;uacute;ltiples argumentos para pasar la funci&amp;oacute;n, usa parens:</target>
        </trans-unit>
        <trans-unit id="ac4e1750314827abdcc2556f83c85b9fddef454c" translate="yes" xml:space="preserve">
          <source>The above actually defines &lt;code&gt;functionThree&lt;/code&gt; irrespective of &lt;code&gt;test&lt;/code&gt;'s value &amp;mdash; unless &lt;code&gt;use strict&lt;/code&gt; is in effect, in which case it simply raises an error.</source>
          <target state="translated">Lo anterior define realmente &lt;code&gt;functionThree&lt;/code&gt; independientemente del valor de la &lt;code&gt;test&lt;/code&gt; , a menos que el &lt;code&gt;use strict&lt;/code&gt; est&amp;eacute; en vigor, en cuyo caso simplemente genera un error.</target>
        </trans-unit>
        <trans-unit id="b568b255152259a00f6cba0e87f3825e038239ef" translate="yes" xml:space="preserve">
          <source>The above code is identical in functionality to the code below. Note that explicitly assigning &lt;code&gt;add = undefined&lt;/code&gt; is superfluous because simply doing &lt;code&gt;var add;&lt;/code&gt; is the exact same as &lt;code&gt;var add=undefined&lt;/code&gt;.</source>
          <target state="translated">El c&amp;oacute;digo anterior es id&amp;eacute;ntico en funcionalidad al c&amp;oacute;digo siguiente. Tenga en cuenta que asignar expl&amp;iacute;citamente &lt;code&gt;add = undefined&lt;/code&gt; es superfluo porque simplemente haciendo &lt;code&gt;var add;&lt;/code&gt; es exactamente lo mismo que &lt;code&gt;var add=undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61810b104f2efcb0e3da5ee583a0202c43770fb2" translate="yes" xml:space="preserve">
          <source>The assignment of the &lt;code&gt;bar&lt;/code&gt;&lt;code&gt;FunctionExpression&lt;/code&gt; takes place until runtime.</source>
          <target state="translated">La asignaci&amp;oacute;n de la &lt;code&gt;bar&lt;/code&gt; ra &lt;code&gt;FunctionExpression&lt;/code&gt; tiene lugar hasta el tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f5638e210194eb499ece9d9a4a930b2e74d062fc" translate="yes" xml:space="preserve">
          <source>The code becomes more readable by allocating local functions separately of scope functionality. Usually in the scope the functionality goes first, followed by declarations of local functions.</source>
          <target state="translated">El código se hace más legible asignando funciones locales por separado de la funcionalidad del alcance.Normalmente en el scope la funcionalidad va primero,seguida de las declaraciones de las funciones locales.</target>
        </trans-unit>
        <trans-unit id="27d4da09d4c2ce032185baf978da0ab13a3001ed" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;functionOne&lt;/code&gt; is a function expression and so only defined when that line is reached, whereas &lt;code&gt;functionTwo&lt;/code&gt; is a function declaration and is defined as soon as its surrounding function or script is executed (due to &lt;a href=&quot;http://adripofjavascript.com/blog/drips/variable-and-function-hoisting.html&quot;&gt;hoisting&lt;/a&gt;).</source>
          <target state="translated">La diferencia es que &lt;code&gt;functionOne&lt;/code&gt; es una expresi&amp;oacute;n de funci&amp;oacute;n y, por lo tanto, solo se define cuando se alcanza esa l&amp;iacute;nea, mientras que &lt;code&gt;functionTwo&lt;/code&gt; es una declaraci&amp;oacute;n de funci&amp;oacute;n y se define tan pronto como se ejecuta su funci&amp;oacute;n o script circundante (debido a la &lt;a href=&quot;http://adripofjavascript.com/blog/drips/variable-and-function-hoisting.html&quot;&gt;elevaci&amp;oacute;n&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8f5ff0d27037b523b788758f94b98b0d9ae64dd6" translate="yes" xml:space="preserve">
          <source>The first case is of function expressions which loads only when the interpreter reaches that line of code. So if you do it like the following, you will get an error that the &lt;strong&gt;functionOne is not a function&lt;/strong&gt;.</source>
          <target state="translated">El primer caso es de expresiones de funci&amp;oacute;n que se cargan solo cuando el int&amp;eacute;rprete alcanza esa l&amp;iacute;nea de c&amp;oacute;digo. Entonces, si lo hace de la siguiente manera, obtendr&amp;aacute; un error de que &lt;strong&gt;functionOne no es una funci&amp;oacute;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8c697eb723f616068919ff4ce595b6a84c5ced0b" translate="yes" xml:space="preserve">
          <source>The first example is a function declaration:</source>
          <target state="translated">El primer ejemplo es una declaración de función:</target>
        </trans-unit>
        <trans-unit id="43835d99e780763836c24b4200a3754c5e808b94" translate="yes" xml:space="preserve">
          <source>The first form is a &lt;em&gt;function declaration&lt;/em&gt;, which looks like this:</source>
          <target state="translated">La primera forma es una &lt;em&gt;declaraci&amp;oacute;n de funci&amp;oacute;n&lt;/em&gt; , que se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="34f69ae86ca961522b085400da5ab180cee6f82c" translate="yes" xml:space="preserve">
          <source>The first one (function doSomething(x)) should be part of an object notation.</source>
          <target state="translated">La primera (función doSomething(x))debería formar parte de una notación de objeto.</target>
        </trans-unit>
        <trans-unit id="528c8b3507437f286d5dcd35417b22aae81be689" translate="yes" xml:space="preserve">
          <source>The following does not work because the &lt;code&gt;var add=&lt;/code&gt; superseeds the &lt;code&gt;function add()&lt;/code&gt;.</source>
          <target state="translated">Lo siguiente no funciona porque &lt;code&gt;var add=&lt;/code&gt; reemplaza a la &lt;code&gt;function add()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6593583ad3f05cea4dd2dbe710ed86ac6be34db" translate="yes" xml:space="preserve">
          <source>The following does not work because the variable is called before a function value is assigned to the variable &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">Lo siguiente no funciona porque se llama a la variable antes de asignar un valor de funci&amp;oacute;n a la variable &lt;code&gt;add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c398e75b47d2fad865197a5e2b4b99f659ecf1b" translate="yes" xml:space="preserve">
          <source>The following works because &lt;code&gt;function add()&lt;/code&gt; is scoped to the nearest block:</source>
          <target state="translated">Lo siguiente funciona porque la &lt;code&gt;function add()&lt;/code&gt; est&amp;aacute; limitada al bloque m&amp;aacute;s cercano:</target>
        </trans-unit>
        <trans-unit id="12d135f5c480c68402b5ce8e6a0d8f062c40c5a2" translate="yes" xml:space="preserve">
          <source>The function statement is just a shorthand for &lt;code&gt;var&lt;/code&gt; statement with a &lt;code&gt;function&lt;/code&gt; value.</source>
          <target state="translated">La declaraci&amp;oacute;n de funci&amp;oacute;n es solo una abreviatura de declaraci&amp;oacute;n de &lt;code&gt;var&lt;/code&gt; con un valor de &lt;code&gt;function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aabbd15c1c1cbe57d1e6cc08682ca9493293312d" translate="yes" xml:space="preserve">
          <source>The function this creates has a proper name (&lt;code&gt;w&lt;/code&gt; in this case). Like all expressions, this is evaluated when it's reached in the step-by-step execution of the code. The name of the function is &lt;em&gt;not&lt;/em&gt; added to the scope in which the expression appears; the name &lt;em&gt;is&lt;/em&gt; in scope within the function itself:</source>
          <target state="translated">La funci&amp;oacute;n que esto crea tiene un nombre propio ( &lt;code&gt;w&lt;/code&gt; en este caso). Al igual que todas las expresiones, esto se eval&amp;uacute;a cuando se alcanza en la ejecuci&amp;oacute;n paso a paso del c&amp;oacute;digo. El nombre de la funci&amp;oacute;n &lt;em&gt;no se&lt;/em&gt; agrega al &amp;aacute;mbito en el que aparece la expresi&amp;oacute;n; el nombre &lt;em&gt;est&amp;aacute;&lt;/em&gt; dentro del alcance de la funci&amp;oacute;n en s&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="ea448a50cd82447995b1eb947a60438076954bb9" translate="yes" xml:space="preserve">
          <source>The main difference is how they are hoisted (lifted and declared). In the first example, the whole function declaration is hoisted. In the second example only the var 'abc' is hoisted, its value (the function) will be undefined, and the function itself remains at the position that it is declared.</source>
          <target state="translated">La principal diferencia es la forma en que se izan (se levantan y se declaran).En el primer ejemplo,se eleva toda la declaración de la función.En el segundo ejemplo sólo se eleva la var &quot;abc&quot;,su valor (la función)no se define y la propia función permanece en la posición en que se declara.</target>
        </trans-unit>
        <trans-unit id="4d055f6c1671742f4deaadc6161c80dec3e0bd32" translate="yes" xml:space="preserve">
          <source>The name of a function &lt;code&gt;function thefuncname(){}&lt;/code&gt; is &lt;em&gt;thefuncname&lt;/em&gt; when it is declared this way.</source>
          <target state="translated">El nombre de una funci&amp;oacute;n &lt;code&gt;function thefuncname(){}&lt;/code&gt; es &lt;em&gt;thefuncname&lt;/em&gt; cuando se declara de esta manera.</target>
        </trans-unit>
        <trans-unit id="975e947bf74ec2c4a9220b91f85c32600f4c5554" translate="yes" xml:space="preserve">
          <source>The one or two brandings that need a specific implementation of the function can then define their version of the function and assign this to the variable if they want, and the rest do nothing. I can test for a null function before I execute it in the shared code.</source>
          <target state="translated">Los uno o dos brandings que necesitan una implementación específica de la función pueden entonces definir su versión de la función y asignarla a la variable si lo desean,y el resto no hace nada.Puedo probar una función nula antes de ejecutarla en el código compartido.</target>
        </trans-unit>
        <trans-unit id="145b15615e2d9998da1e6798d5ad4a398382a9d4" translate="yes" xml:space="preserve">
          <source>The order of hoisting is also important: function declarations take precedence over variable declarations with the same name, and the last function declaration takes precedence over previous function declarations with the same name.</source>
          <target state="translated">El orden de elevación también es importante:las declaraciones de función tienen prioridad sobre las declaraciones variables con el mismo nombre,y la última declaración de función tiene prioridad sobre las anteriores declaraciones de función con el mismo nombre.</target>
        </trans-unit>
        <trans-unit id="9fbf6788e456c1009e4f21fffa2ea5165a3d9162" translate="yes" xml:space="preserve">
          <source>The previous developer used two ways of declaring functions and I can't work out if there is a reason behind it or not.</source>
          <target state="translated">El desarrollador anterior usaba dos formas de declarar las funciones y no puedo saber si hay una razón detrás de ello o no.</target>
        </trans-unit>
        <trans-unit id="9be3cbbcb4a077923846e6cabf5be834c36c4efe" translate="yes" xml:space="preserve">
          <source>The quick list:</source>
          <target state="translated">La lista rápida:</target>
        </trans-unit>
        <trans-unit id="691d638de255d3f4d5c26aade899596c1cb5d318" translate="yes" xml:space="preserve">
          <source>The reason is that on the first line no value is assigned to functionOne, and hence it is undefined. We are trying to call it as a function, and hence we are getting an error.</source>
          <target state="translated">La razón es que en la primera línea no se asigna ningún valor a la función Uno,y por lo tanto no está definida.Estamos tratando de llamarla como una función,y por lo tanto estamos recibiendo un error.</target>
        </trans-unit>
        <trans-unit id="79805af7eecf09848f58c20a9be4bdd8d5d60b42" translate="yes" xml:space="preserve">
          <source>The rules for the loose modes are tricky, but in &lt;em&gt;strict&lt;/em&gt; mode, function declarations in blocks are easy: They're local to the block (they have &lt;em&gt;block scope&lt;/em&gt;, which is also new in ES2015), and they're hoisted to the top of the block. So:</source>
          <target state="translated">Las reglas para los modos sueltos son complicadas, pero en modo &lt;em&gt;estricto&lt;/em&gt; , las declaraciones de funciones en bloques son f&amp;aacute;ciles: son locales para el bloque (tienen &lt;em&gt;alcance de bloque&lt;/em&gt; , que tambi&amp;eacute;n es nuevo en ES2015), y se elevan a la parte superior de la cuadra. Entonces:</target>
        </trans-unit>
        <trans-unit id="662fa49d03ebc7b2aed8dd5f4b92c0902805a5f2" translate="yes" xml:space="preserve">
          <source>The second case is of function declarations that loads before any code is executed. So if you do like the following you won't get any error as the declaration loads before code execution.</source>
          <target state="translated">El segundo caso es el de las declaraciones de función que se cargan antes de que se ejecute cualquier código.Así que si haces lo siguiente no obtendrás ningún error ya que la declaración se carga antes de la ejecución del código.</target>
        </trans-unit>
        <trans-unit id="488c70a0cd0c42493330d0fb21f56a76d5245310" translate="yes" xml:space="preserve">
          <source>The second common form is called an &lt;em&gt;anonymous function expression&lt;/em&gt;:</source>
          <target state="translated">La segunda forma com&amp;uacute;n se llama &lt;em&gt;expresi&amp;oacute;n de funci&amp;oacute;n an&amp;oacute;nima&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="d485f7dbc6206bd93419673ad073a7290e1370dc" translate="yes" xml:space="preserve">
          <source>The second example is a function expression:</source>
          <target state="translated">El segundo ejemplo es una expresión de la función:</target>
        </trans-unit>
        <trans-unit id="8bf7ed47a49f0740aa28a7a24a1570e0b0a27a46" translate="yes" xml:space="preserve">
          <source>The second one (&lt;code&gt;var doSomething = function(x){ alert(x);}&lt;/code&gt;) is simply creating an anonymous function and assigning it to a variable, &lt;code&gt;doSomething&lt;/code&gt;. So doSomething() will call the function.</source>
          <target state="translated">El segundo ( &lt;code&gt;var doSomething = function(x){ alert(x);}&lt;/code&gt; ) es simplemente crear una funci&amp;oacute;n an&amp;oacute;nima y asignarla a una variable, &lt;code&gt;doSomething&lt;/code&gt; . Entonces doSomething () llamar&amp;aacute; a la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="bb65ff5a5394939f644979347352ffd342603413" translate="yes" xml:space="preserve">
          <source>The subtle difference between the two ways is that when the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-10.1.3&quot;&gt;Variable Instantiation&lt;/a&gt; process runs (before the actual code execution) all identifiers declared with &lt;code&gt;var&lt;/code&gt; will be initialized with &lt;code&gt;undefined&lt;/code&gt;, and the ones used by the &lt;code&gt;FunctionDeclaration&lt;/code&gt;'s will be available since that moment, for example:</source>
          <target state="translated">La sutil diferencia entre las dos formas es que cuando se ejecuta el proceso de &lt;a href=&quot;http://bclary.com/2004/11/07/#a-10.1.3&quot;&gt;instanciaci&amp;oacute;n variable&lt;/a&gt; (antes de la ejecuci&amp;oacute;n del c&amp;oacute;digo real), todos los identificadores declarados con &lt;code&gt;var&lt;/code&gt; se inicializar&amp;aacute;n con &lt;code&gt;undefined&lt;/code&gt; , y los utilizados por la declaraci&amp;oacute;n de &lt;code&gt;FunctionDeclaration&lt;/code&gt; estar&amp;aacute;n disponibles desde ese momento, para ejemplo:</target>
        </trans-unit>
        <trans-unit id="a07afd1ea9b12698990819eb8d76265cfe1ee004" translate="yes" xml:space="preserve">
          <source>The third form is a &lt;em&gt;named function expression&lt;/em&gt; (&quot;NFE&quot;):</source>
          <target state="translated">La tercera forma es una &lt;em&gt;expresi&amp;oacute;n de funci&amp;oacute;n con nombre&lt;/em&gt; (&quot;NFE&quot;):</target>
        </trans-unit>
        <trans-unit id="f16969d6d2f696ede4918690b2fd4331ce87e1f7" translate="yes" xml:space="preserve">
          <source>The third way of defining a function is the &lt;strong&gt;&quot;Function()&quot; constructor&lt;/strong&gt;, which is not shown in your original post. It's not recommended to use this as it works the same way as &lt;code&gt;eval()&lt;/code&gt;, which has its problems.</source>
          <target state="translated">La tercera forma de definir una funci&amp;oacute;n es el &lt;strong&gt;constructor &quot;Function ()&quot;&lt;/strong&gt; , que no se muestra en su publicaci&amp;oacute;n original. No se recomienda usar esto, ya que funciona de la misma manera que &lt;code&gt;eval()&lt;/code&gt; , que tiene sus problemas.</target>
        </trans-unit>
        <trans-unit id="b2aa94344341e29310102127f307a10790251ea2" translate="yes" xml:space="preserve">
          <source>The two code snippets you've posted there will, for almost all purposes, behave the same way.</source>
          <target state="translated">Los dos fragmentos de código que ha publicado allí se comportarán,a casi todos los efectos,de la misma manera.</target>
        </trans-unit>
        <trans-unit id="745bcd9fd12a96b9a791e445c3c8811fc1192e62" translate="yes" xml:space="preserve">
          <source>The two ways are:</source>
          <target state="translated">Las dos formas son:</target>
        </trans-unit>
        <trans-unit id="474bce94d0bbf46c085c74728e63fac02ca4d442" translate="yes" xml:space="preserve">
          <source>The version without &lt;code&gt;{ ... }&lt;/code&gt; is called an arrow function with an &lt;em&gt;expression body&lt;/em&gt; or &lt;em&gt;concise body&lt;/em&gt;. (Also: A &lt;em&gt;concise&lt;/em&gt; arrow function.) The one with &lt;code&gt;{ ... }&lt;/code&gt; defining the body is an arrow function with a &lt;em&gt;function body&lt;/em&gt;. (Also: A &lt;em&gt;verbose&lt;/em&gt; arrow function.)</source>
          <target state="translated">La versi&amp;oacute;n sin &lt;code&gt;{ ... }&lt;/code&gt; se llama funci&amp;oacute;n de flecha con un &lt;em&gt;cuerpo de expresi&amp;oacute;n&lt;/em&gt; o &lt;em&gt;cuerpo conciso&lt;/em&gt; . (Tambi&amp;eacute;n: una funci&amp;oacute;n de flecha &lt;em&gt;concisa&lt;/em&gt; .) La que tiene &lt;code&gt;{ ... }&lt;/code&gt; definiendo el cuerpo es una funci&amp;oacute;n de flecha con un &lt;em&gt;cuerpo de funci&amp;oacute;n&lt;/em&gt; . (Tambi&amp;eacute;n: una funci&amp;oacute;n de flecha &lt;em&gt;detallada&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="5e2ac0591f86093c00434254dcdbb41884337a4a" translate="yes" xml:space="preserve">
          <source>There are four noteworthy comparisons between the two different declarations of functions as listed below.</source>
          <target state="translated">Hay cuatro comparaciones dignas de mención entre las dos declaraciones de funciones diferentes que se enumeran a continuación.</target>
        </trans-unit>
        <trans-unit id="ff3c75b5079b24e68e8e94930f5ee73dea969f6b" translate="yes" xml:space="preserve">
          <source>There are many techniques for namespacing. It's become more important with the plethora of JavaScript modules available.</source>
          <target state="translated">Hay muchas técnicas de espaciado de nombres.Se ha vuelto más importante con la plétora de módulos de JavaScript disponibles.</target>
        </trans-unit>
        <trans-unit id="bfb055384b731f9a401950a0d0ee5c9f80d9d7f9" translate="yes" xml:space="preserve">
          <source>There are two function declarations above: One for the constructor, which gets the name &lt;code&gt;Person&lt;/code&gt;, and one for &lt;code&gt;getFullName&lt;/code&gt;, which is a function assigned to &lt;code&gt;Person.prototype&lt;/code&gt;.</source>
          <target state="translated">Hay dos declaraciones de funciones anteriores: una para el constructor, que obtiene el nombre &lt;code&gt;Person&lt;/code&gt; , y otra para &lt;code&gt;getFullName&lt;/code&gt; , que es una funci&amp;oacute;n asignada a &lt;code&gt;Person.prototype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c21e5ae9b0dbaf5c8a3a97fe0a19730e14b6d355" translate="yes" xml:space="preserve">
          <source>There is a difference however at &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; the function object is actually associated with its variable. This difference is due to the mechanism called &lt;em&gt;variable hoisting&lt;/em&gt; in JavaScript.</source>
          <target state="translated">Sin embargo, hay una diferencia en &lt;em&gt;c&amp;oacute;mo&lt;/em&gt; y &lt;em&gt;cu&amp;aacute;ndo&lt;/em&gt; el objeto de funci&amp;oacute;n est&amp;aacute; realmente asociado con su variable. Esta diferencia se debe al mecanismo llamado &lt;em&gt;elevaci&amp;oacute;n variable&lt;/em&gt; en JavaScript.</target>
        </trans-unit>
        <trans-unit id="06da7b97430b3e34f6c3267eaa4d35f03ac87eb2" translate="yes" xml:space="preserve">
          <source>There is almost no difference now between expression and declaration.</source>
          <target state="translated">Ya casi no hay diferencia entre expresión y declaración.</target>
        </trans-unit>
        <trans-unit id="f88a677f3e75a5ae4e3009a2066635b663011477" translate="yes" xml:space="preserve">
          <source>They are pretty similar with some small differences, first one is a variable which assigned to an anonymous function (Function Declaration) and second one is the normal way to create a function in JavaScript(Anonymous function Declaration), both has usage, cons and pros:</source>
          <target state="translated">Son bastante similares con algunas pequeñas diferencias,la primera es una variable que se asigna a una función anónima (Declaración de función)y la segunda es la forma normal de crear una función en JavaScript (Declaración de función anónima),ambas tienen usos,contras y pros:</target>
        </trans-unit>
        <trans-unit id="12694bcfc3aa8628852e68a8a23a1b1ae5570a03" translate="yes" xml:space="preserve">
          <source>They don't have their own &lt;code&gt;this&lt;/code&gt;. Instead, they &lt;em&gt;close over&lt;/em&gt; the &lt;code&gt;this&lt;/code&gt; of the context where they're defined. (They also close over &lt;code&gt;arguments&lt;/code&gt; and, where relevant, &lt;code&gt;super&lt;/code&gt;.) This means that the &lt;code&gt;this&lt;/code&gt; within them is the same as the &lt;code&gt;this&lt;/code&gt; where they're created, and cannot be changed.</source>
          <target state="translated">No tienen su propio &lt;code&gt;this&lt;/code&gt; . En cambio, se &lt;em&gt;cierran sobre&lt;/em&gt; &lt;code&gt;this&lt;/code&gt; del contexto donde est&amp;aacute;n definidos. (Tambi&amp;eacute;n cierran sobre &lt;code&gt;arguments&lt;/code&gt; y, cuando es relevante, &lt;code&gt;super&lt;/code&gt; .) Esto significa que &lt;code&gt;this&lt;/code&gt; dentro de ellos es lo mismo que &lt;code&gt;this&lt;/code&gt; donde se crean, y no se puede cambiar.</target>
        </trans-unit>
        <trans-unit id="5d3eda8af03fd5bea6de534289810bbc9c0c9cc7" translate="yes" xml:space="preserve">
          <source>This also means you can't conditionally define functions using function declarations:</source>
          <target state="translated">Esto también significa que no se pueden definir funciones de manera condicional utilizando declaraciones de función:</target>
        </trans-unit>
        <trans-unit id="8c1789e53705ce3071d6843b82e294f18ddc1727" translate="yes" xml:space="preserve">
          <source>This is a function expression:</source>
          <target state="translated">Esta es una expresión de la función:</target>
        </trans-unit>
        <trans-unit id="effa2ad61076e82c01e857bf9f7b8d602fd31fd4" translate="yes" xml:space="preserve">
          <source>This is because during execution, it looks like:</source>
          <target state="translated">Esto es porque durante la ejecución,parece que:</target>
        </trans-unit>
        <trans-unit id="d1fec805ab98a0513f9b9fad3d3fe8b531e695be" translate="yes" xml:space="preserve">
          <source>This is because with the first variant, the function is assigned to the variable &lt;code&gt;foo&lt;/code&gt; at run time. In the second, the function is assigned to that identifier, &lt;code&gt;foo&lt;/code&gt;, at parse time.</source>
          <target state="translated">Esto se debe a que con la primera variante, la funci&amp;oacute;n se asigna a la variable &lt;code&gt;foo&lt;/code&gt; en tiempo de ejecuci&amp;oacute;n. En el segundo, la funci&amp;oacute;n se asigna a ese identificador, &lt;code&gt;foo&lt;/code&gt; , en tiempo de an&amp;aacute;lisis.</target>
        </trans-unit>
        <trans-unit id="37da05445624fb3a9cad0979b5962a742fcfb61e" translate="yes" xml:space="preserve">
          <source>This is because, during execution, it looks like:-</source>
          <target state="translated">Esto se debe a que,durante la ejecución,parece que...</target>
        </trans-unit>
        <trans-unit id="ac81e957d5a9edd9078b4cf183802d4b3a3c78b3" translate="yes" xml:space="preserve">
          <source>This is just two possible ways of declaring functions, and in the second way, you can use the function before declaration.</source>
          <target state="translated">Esta es sólo una de las dos maneras posibles de declarar las funciones y,en la segunda,se puede utilizar la función antes de la declaración.</target>
        </trans-unit>
        <trans-unit id="c8bf596e96383c7f8bf4dd936686e5dfce43757d" translate="yes" xml:space="preserve">
          <source>This is the normal way of calling a function in JavaScript, this function can be called before you even declare it as in JavaScript all functions get Hoisted, but if you have 'use strict' this won't Hoist as expected, it's a good way to call all normal functions which are not big in lines and neither are a  constructor function.</source>
          <target state="translated">Esta es la forma normal de llamar a una función en JavaScript,esta función puede ser llamada incluso antes de declararla ya que en JavaScript todas las funciones se elevan,pero si tienes &quot;uso estricto&quot; esto no se elevará como se esperaba,es una buena forma de llamar a todas las funciones normales que no son grandes en líneas y tampoco son una función constructora.</target>
        </trans-unit>
        <trans-unit id="2b9c6d00ab6cdb468c41c536b9d5e12d359f8ad8" translate="yes" xml:space="preserve">
          <source>This is very basic, self-explanatory, used in many languages and standard across C family of languages. We declared a function defined it and executed it by calling it.</source>
          <target state="translated">Esto es muy básico,auto-explicativo,usado en muchos idiomas y estándar en toda la familia de idiomas C.Declaramos una función,la definimos y la ejecutamos llamándola.</target>
        </trans-unit>
        <trans-unit id="f369bab590b1ff70e9147bf580834bbc48507735" translate="yes" xml:space="preserve">
          <source>This means that code like this:</source>
          <target state="translated">Esto significa que un código como este:</target>
        </trans-unit>
        <trans-unit id="a26f3ae40c34f7b11fe02427fe4fd04cac5639d4" translate="yes" xml:space="preserve">
          <source>To put it simply:</source>
          <target state="translated">En pocas palabras:</target>
        </trans-unit>
        <trans-unit id="f8459b728f80ead940599b3ae8ca162ea21af9e0" translate="yes" xml:space="preserve">
          <source>To study more about this topic I strongly recommend you this
&lt;a href=&quot;http://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/#comment-43792&quot;&gt;link&lt;/a&gt;</source>
          <target state="translated">Para estudiar m&amp;aacute;s sobre este tema, le recomiendo este &lt;a href=&quot;http://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/#comment-43792&quot;&gt;enlace.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="408adc3e401c0d07ea40bc45f940121effd904fa" translate="yes" xml:space="preserve">
          <source>Until ES2015, the spec didn't cover what a JavaScript engine should do if you put a function declaration inside a control structure like &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc., like this:</source>
          <target state="translated">Hasta ES2015, la especificaci&amp;oacute;n no cubr&amp;iacute;a lo que deber&amp;iacute;a hacer un motor JavaScript si coloca una declaraci&amp;oacute;n de funci&amp;oacute;n dentro de una estructura de control como &lt;code&gt;try&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;switch&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; , etc., de esta manera:</target>
        </trans-unit>
        <trans-unit id="b8b097d0eea0934533ba237923021e6a341048fe" translate="yes" xml:space="preserve">
          <source>V8</source>
          <target state="translated">V8</target>
        </trans-unit>
        <trans-unit id="6fd7aa0d712bf58b6bad496b57c728877860d1e0" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;foo&lt;/code&gt; is hoisted to the top of the function, initialized to &lt;code&gt;undefined&lt;/code&gt;, so that &lt;code&gt;!foo&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, so &lt;code&gt;foo&lt;/code&gt; is assigned &lt;code&gt;10&lt;/code&gt;. The &lt;code&gt;foo&lt;/code&gt; outside of &lt;code&gt;bar&lt;/code&gt;'s scope plays no role and is untouched.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; variable se eleva a la parte superior de la funci&amp;oacute;n, inicializado a &lt;code&gt;undefined&lt;/code&gt; , de modo que &lt;code&gt;!foo&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , por lo que se le asigna &lt;code&gt;10&lt;/code&gt; . El &lt;code&gt;foo&lt;/code&gt; fuera del alcance del &lt;code&gt;bar&lt;/code&gt; no juega ning&amp;uacute;n papel y no ha sido tocado.</target>
        </trans-unit>
        <trans-unit id="8532b2e0bf3f4150e5cd6a6e082f6757d298ae34" translate="yes" xml:space="preserve">
          <source>Variable Mutability</source>
          <target state="translated">Mutabilidad variable</target>
        </trans-unit>
        <trans-unit id="6884273afe88a4cbfbe80c00ade910f535b8b76e" translate="yes" xml:space="preserve">
          <source>What Is The &quot;Nearest Block&quot;</source>
          <target state="translated">¿Cuál es el &quot;Bloque más cercano&quot;</target>
        </trans-unit>
        <trans-unit id="3487cb56b52e80f80380f6ee61e6d28c17778b0a" translate="yes" xml:space="preserve">
          <source>What are the reasons for using these two different methods and what are the pros and cons of each? Is there anything that can be done with one method that can't be done with the other?</source>
          <target state="translated">¿Cuáles son las razones para usar estos dos métodos diferentes y cuáles son los pros y los contras de cada uno? ¿Hay algo que se pueda hacer con un método que no se pueda hacer con el otro?</target>
        </trans-unit>
        <trans-unit id="9e5d9650d7c2bdb693414377b37154902a354c34" translate="yes" xml:space="preserve">
          <source>What you should be knowing is that functions are actually objects in JavaScript; internally we have created an object for above function and given it a name called fn or the reference to the object is stored in fn. Functions are objects in JavaScript; an instance of function is actually an object instance.</source>
          <target state="translated">Lo que debería saber es que las funciones son en realidad objetos en JavaScript;internamente hemos creado un objeto para la función anterior y le hemos dado un nombre llamado fn o la referencia al objeto está almacenada en fn.Las funciones son objetos en JavaScript;una instancia de función es en realidad una instancia de objeto.</target>
        </trans-unit>
        <trans-unit id="cb3fb4dfbcf0fe94e2371e0b28eb0f6e2fcd530b" translate="yes" xml:space="preserve">
          <source>When a function declaration is hoisted, the function body &quot;follows&quot;
so when the function body is evaluated, the variable will immediately
be bound to a function object.</source>
          <target state="translated">Cuando se eleva una declaración de función,el cuerpo de la función &quot;sigue&quot;,de modo que cuando se evalúe el cuerpo de la función,la variable quedará inmediatamente ligada a un objeto de la función.</target>
        </trans-unit>
        <trans-unit id="e9cfe61cf1adcd8f0102a36d2e0c4d12c9ca5726" translate="yes" xml:space="preserve">
          <source>When a variable declaration is hoisted, the initialization does &lt;em&gt;not&lt;/em&gt;
follow, but is &quot;left behind&quot;. The variable is initialized to
&lt;code&gt;undefined&lt;/code&gt; at the start of the function body, and will be &lt;em&gt;assigned&lt;/em&gt;
a value at its original location in the code. (Actually, it will be assigned a value at &lt;em&gt;every&lt;/em&gt; location where a declaration of a variable with the same name occurs.)</source>
          <target state="translated">Cuando se levanta una declaraci&amp;oacute;n de variable, la inicializaci&amp;oacute;n &lt;em&gt;no&lt;/em&gt; sigue, sino que se &quot;deja atr&amp;aacute;s&quot;. La variable se inicializa a &lt;code&gt;undefined&lt;/code&gt; al comienzo del cuerpo de la funci&amp;oacute;n y se le &lt;em&gt;asignar&amp;aacute;&lt;/em&gt; un valor en su ubicaci&amp;oacute;n original en el c&amp;oacute;digo. (En realidad, se le asignar&amp;aacute; un valor en &lt;em&gt;cada&lt;/em&gt; ubicaci&amp;oacute;n donde ocurra una declaraci&amp;oacute;n de una variable con el mismo nombre).</target>
        </trans-unit>
        <trans-unit id="bbe884a06b13281930a6b1c98f9d9d94e458c3b6" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;var&lt;/code&gt; keyword to declare a variable, you can then reassign a different value to the variable like so.</source>
          <target state="translated">Cuando utiliza la palabra clave &lt;code&gt;var&lt;/code&gt; para declarar una variable, puede reasignar un valor diferente a la variable de esta manera.</target>
        </trans-unit>
        <trans-unit id="958872366b05f9c9178f4030f046f9fcab17462f" translate="yes" xml:space="preserve">
          <source>Which expands further to:</source>
          <target state="translated">Lo cual se expande aún más:</target>
        </trans-unit>
        <trans-unit id="d86a5675cc6478e7030415aaa83cd72801292548" translate="yes" xml:space="preserve">
          <source>While</source>
          <target state="translated">While</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="ac5e0452023b3c19655f17b544a743b6316fff94" translate="yes" xml:space="preserve">
          <source>With an assignment, without the &lt;code&gt;var&lt;/code&gt; statement, if the referenced identifier is not found in the scope chain, it will become a &lt;em&gt;deleteable&lt;/em&gt; property of the global object.</source>
          <target state="translated">Con una asignaci&amp;oacute;n, sin la instrucci&amp;oacute;n &lt;code&gt;var&lt;/code&gt; , si el identificador referenciado no se encuentra en la cadena de alcance, se convertir&amp;aacute; en una propiedad &lt;em&gt;eliminable&lt;/em&gt; del objeto global.</target>
        </trans-unit>
        <trans-unit id="2992a94652f880688ca1ececd6fbd9dc7fb7c4a7" translate="yes" xml:space="preserve">
          <source>With the second variant (&lt;code&gt;function functionTwo()&lt;/code&gt;), the function is available to code that runs above where the function is declared.</source>
          <target state="translated">Con la segunda variante ( &lt;code&gt;function functionTwo()&lt;/code&gt; ), la funci&amp;oacute;n est&amp;aacute; disponible para el c&amp;oacute;digo que se ejecuta arriba donde se declara la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b0d2d3e4c919cb16a2327e829924bc496bf26df9" translate="yes" xml:space="preserve">
          <source>With this pattern, your public functions will all use assignment, while your private functions use declaration.</source>
          <target state="translated">Con este patrón,todas sus funciones públicas utilizarán la asignación,mientras que sus funciones privadas utilizarán la declaración.</target>
        </trans-unit>
        <trans-unit id="2f69161f94ccc52eed8d88eea3c10a5ed51531e9" translate="yes" xml:space="preserve">
          <source>You can also create accessor functions with &lt;code&gt;Object.defineProperty&lt;/code&gt;, &lt;code&gt;Object.defineProperties&lt;/code&gt;, and the lesser-known second argument to &lt;code&gt;Object.create&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n puede crear funciones de &lt;code&gt;Object.defineProperty&lt;/code&gt; con Object.defineProperty , &lt;code&gt;Object.defineProperties&lt;/code&gt; y el segundo argumento menos conocido de &lt;code&gt;Object.create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a96fecb676cbe550b81abe5e501a476b1368603" translate="yes" xml:space="preserve">
          <source>You can check function declaration, expression test over different browser's using &lt;a href=&quot;http://jsperf.com/yashfunctions&quot;&gt;&lt;code&gt;jsperf Test Runner&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Puede verificar la declaraci&amp;oacute;n de la funci&amp;oacute;n, la prueba de expresi&amp;oacute;n en diferentes navegadores utilizando &lt;a href=&quot;http://jsperf.com/yashfunctions&quot;&gt; &lt;code&gt;jsperf Test Runner&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3ac05813abe982cb2026b6587a9d2cd9ba582c6" translate="yes" xml:space="preserve">
          <source>You may want to know what a &lt;em&gt;function declaration&lt;/em&gt; and &lt;em&gt;function expression&lt;/em&gt; is.</source>
          <target state="translated">Es posible que desee saber qu&amp;eacute; es una &lt;em&gt;declaraci&amp;oacute;n de&lt;/em&gt; &lt;em&gt;funci&amp;oacute;n&lt;/em&gt; y &lt;em&gt;una expresi&amp;oacute;n de funci&amp;oacute;n&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2ec4b44222b42ad09c0dd93c4ce4013f9582d467" translate="yes" xml:space="preserve">
          <source>Your first snippet shows a &lt;strong&gt;function expression&lt;/strong&gt;. This involves using the &lt;em&gt;&quot;function&quot; operator&lt;/em&gt; to create a function - the result of that operator can be stored in any variable or object property. The function expression is powerful that way. The function expression is often called an &quot;anonymous function&quot;, because it does not have to have a name,</source>
          <target state="translated">Su primer fragmento muestra una &lt;strong&gt;expresi&amp;oacute;n de funci&amp;oacute;n&lt;/strong&gt; . Esto implica el uso del &lt;em&gt;operador &quot;funci&amp;oacute;n&quot;&lt;/em&gt; para crear una funci&amp;oacute;n; el resultado de ese operador se puede almacenar en cualquier variable u objeto. La expresi&amp;oacute;n de la funci&amp;oacute;n es poderosa de esa manera. La expresi&amp;oacute;n de funci&amp;oacute;n a menudo se denomina &quot;funci&amp;oacute;n an&amp;oacute;nima&quot;, ya que no tiene que tener un nombre,</target>
        </trans-unit>
        <trans-unit id="266e022923f9faa5b3be37667e92ff1460681e19" translate="yes" xml:space="preserve">
          <source>Your second example is a &lt;strong&gt;function declaration&lt;/strong&gt;. This uses the &lt;em&gt;&quot;function&quot; statement&lt;/em&gt; to create a function. The function is made available at parse time and can be called anywhere in that scope. You can still store it in a variable or object property later.</source>
          <target state="translated">Su segundo ejemplo es una &lt;strong&gt;declaraci&amp;oacute;n de funci&amp;oacute;n&lt;/strong&gt; . Esto usa la &lt;em&gt;instrucci&amp;oacute;n &quot;funci&amp;oacute;n&quot;&lt;/em&gt; para crear una funci&amp;oacute;n. La funci&amp;oacute;n est&amp;aacute; disponible en tiempo de an&amp;aacute;lisis y se puede llamar a cualquier parte de ese &amp;aacute;mbito. Todav&amp;iacute;a puede almacenarlo en una propiedad variable u objeto m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="46e93c41a34284a718c071fa2d4c174a2bdd159c" translate="yes" xml:space="preserve">
          <source>and use that as a constructor as in</source>
          <target state="translated">y usar eso como un constructor como en</target>
        </trans-unit>
        <trans-unit id="766f2b9d16f389f8448bfe19b9e12c43e3b610f1" translate="yes" xml:space="preserve">
          <source>depends on the context and may leave you guessing where it is actually defined, especially in the case of &lt;code&gt;eval()&lt;/code&gt; &amp;mdash; the answer is: It depends on the browser.</source>
          <target state="translated">depende del contexto y puede dejarlo adivinando d&amp;oacute;nde est&amp;aacute; realmente definido, especialmente en el caso de &lt;code&gt;eval()&lt;/code&gt; ; la respuesta es: depende del navegador.</target>
        </trans-unit>
        <trans-unit id="9afe260f060bed6881cbee4dafbcfdde1b19a941" translate="yes" xml:space="preserve">
          <source>does the correct job of defining &lt;code&gt;myfunction&lt;/code&gt; only when &lt;code&gt;condition&lt;/code&gt; is met.</source>
          <target state="translated">hace el trabajo correcto de definir &lt;code&gt;myfunction&lt;/code&gt; solo cuando se cumple la &lt;code&gt;condition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad6a22cf9c1840cb2434e3d3948f70d3d82ff7a2" translate="yes" xml:space="preserve">
          <source>expands to</source>
          <target state="translated">se expande a</target>
        </trans-unit>
        <trans-unit id="c9fa53e3d56127fa9a0278359df87eedc39694e4" translate="yes" xml:space="preserve">
          <source>function Identifier ( FormalParameterList&lt;sub&gt;opt&lt;/sub&gt; ) { FunctionBody }</source>
          <target state="translated">Identificador de funci&amp;oacute;n (FormalParameterList &lt;sub&gt;opt&lt;/sub&gt; ) {FunctionBody}</target>
        </trans-unit>
        <trans-unit id="c80babbe10672f1522783d610020c168a8871b0f" translate="yes" xml:space="preserve">
          <source>function Identifier&lt;sub&gt;opt&lt;/sub&gt; ( FormalParameterList&lt;sub&gt;opt&lt;/sub&gt; ) { FunctionBody }</source>
          <target state="translated">Identificador de funci&amp;oacute;n &lt;sub&gt;opt&lt;/sub&gt; (FormalParameterList &lt;sub&gt;opt&lt;/sub&gt; ) {FunctionBody}</target>
        </trans-unit>
        <trans-unit id="1a09252eb586133790cfd10a652a02b91c3d110e" translate="yes" xml:space="preserve">
          <source>functions declared inside the function-block are hoisted to top of the block.</source>
          <target state="translated">las funciones declaradas dentro del bloque de funciones se elevan a la parte superior del bloque.</target>
        </trans-unit>
        <trans-unit id="ef76da7e287b143105e1345282bc04bcb536f6c4" translate="yes" xml:space="preserve">
          <source>functions declared inside the page are hoisted to top of the page having global access.</source>
          <target state="translated">las funciones declaradas dentro de la página se elevan a la parte superior de la página que tiene acceso global.</target>
        </trans-unit>
        <trans-unit id="564e3512cbd2ca189843edd610d4d195314e3263" translate="yes" xml:space="preserve">
          <source>it is possible to retrieve the name of the constructor as a string with &lt;code&gt;two.constructor.name&lt;/code&gt;.</source>
          <target state="translated">Es posible recuperar el nombre del constructor como una cadena con &lt;code&gt;two.constructor.name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2700ec2ba6fe2751639ff097bd8f8d2aacff7db5" translate="yes" xml:space="preserve">
          <source>its name is automatically assigned. But when you define it like</source>
          <target state="translated">su nombre se asigna automáticamente.Pero cuando lo defines como</target>
        </trans-unit>
        <trans-unit id="17daac7101b762bf7ee434b07c08b0a4c8d7ce16" translate="yes" xml:space="preserve">
          <source>its name is empty &amp;mdash; we created an anonymous function and assigned it to some variable.</source>
          <target state="translated">su nombre est&amp;aacute; vac&amp;iacute;o: creamos una funci&amp;oacute;n an&amp;oacute;nima y la asignamos a alguna variable.</target>
        </trans-unit>
        <trans-unit id="c33715969df7ac0ddad9e0bddf3b744551593c8d" translate="yes" xml:space="preserve">
          <source>javascript interpreted as</source>
          <target state="translated">javascript interpretado como</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="a878ab0cab33cf7bc7bc8ef10d60b74ea374cd22" translate="yes" xml:space="preserve">
          <source>the almost-equivalent in ES5 and earlier would be:</source>
          <target state="translated">el casi equivalente en ES5 y anteriores sería:</target>
        </trans-unit>
        <trans-unit id="1f2ec344c7336412708c6074b118ba08228b6737" translate="yes" xml:space="preserve">
          <source>the difference (other than verbosity) is that a method can use &lt;code&gt;super&lt;/code&gt;, but a function cannot. So for instance, if you had an object that defined (say) &lt;code&gt;valueOf&lt;/code&gt; using method syntax, it could use &lt;code&gt;super.valueOf()&lt;/code&gt; to get the value &lt;code&gt;Object.prototype.valueOf&lt;/code&gt; would have returned (before presumably doing something else with it), whereas the ES5 version would have to do &lt;code&gt;Object.prototype.valueOf.call(this)&lt;/code&gt; instead.</source>
          <target state="translated">La diferencia (aparte de la verbosidad) es que un m&amp;eacute;todo puede usar &lt;code&gt;super&lt;/code&gt; , pero una funci&amp;oacute;n no. Entonces, por ejemplo, si tuviera un objeto que definiera (digamos) &lt;code&gt;valueOf&lt;/code&gt; usando la sintaxis del m&amp;eacute;todo, podr&amp;iacute;a usar &lt;code&gt;super.valueOf()&lt;/code&gt; para obtener el valor que &lt;code&gt;Object.prototype.valueOf&lt;/code&gt; habr&amp;iacute;a devuelto (antes de presumiblemente hacer algo m&amp;aacute;s con &amp;eacute;l), mientras que la versi&amp;oacute;n ES5 tendr&amp;iacute;a que hacer &lt;code&gt;Object.prototype.valueOf.call(this)&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="b130f4fa2fdb9f1a6204a2dcd0028ce60730d038" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;one.constructor.name&lt;/code&gt; will not be defined. &lt;code&gt;Function.name&lt;/code&gt; is non-standard but is supported by Firefox, Chrome, other Webkit-derived browsers and IE 9+.</source>
          <target state="translated">entonces &lt;code&gt;one.constructor.name&lt;/code&gt; no se definir&amp;aacute;. &lt;code&gt;Function.name&lt;/code&gt; no es est&amp;aacute;ndar, pero es compatible con Firefox, Chrome, otros navegadores derivados de Webkit e IE 9+.</target>
        </trans-unit>
        <trans-unit id="db00dc47d2bcbaa5835214069da6b3a6be20e68a" translate="yes" xml:space="preserve">
          <source>var functionName = function() {} vs function functionName() {}</source>
          <target state="translated">var functionName=function(){}vs function functionName(){}</target>
        </trans-unit>
        <trans-unit id="855b18f663a06d0d7e20dd66c32870f4e2e7f8ff" translate="yes" xml:space="preserve">
          <source>variable's/Function's declared inside the page are global can access anywhere in that page.</source>
          <target state="translated">Las funciones declaradas dentro de la página son globales y se puede acceder a ellas desde cualquier parte de la página.</target>
        </trans-unit>
        <trans-unit id="d4bbf1fdfd223011ea728f2c0466d3a30c57347c" translate="yes" xml:space="preserve">
          <source>variable's/Functions declared inside the function are having local scope. means they are available/accessed inside the function body (scope), they are not available outside the function body.</source>
          <target state="translated">Las funciones declaradas dentro de la función tienen un alcance local.significa que están disponibles dentro del cuerpo de la función (alcance),no están disponibles fuera del cuerpo de la función.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
