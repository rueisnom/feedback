<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/336859">
    <body>
      <group id="336859">
        <trans-unit id="759ade596a378339a3599da452aa422c31d07445" translate="yes" xml:space="preserve">
          <source>&quot;Anonymous&quot; &lt;code&gt;function&lt;/code&gt; Expression</source>
          <target state="translated">&amp;ldquo;匿名&amp;rdquo; &lt;code&gt;function&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="c513b3ca88a099b3024dc76dce26a4fc3fd75194" translate="yes" xml:space="preserve">
          <source>&quot;Anonymous&quot; &lt;code&gt;function&lt;/code&gt; Expression &lt;em&gt;(which despite the term, sometimes create functions with names)&lt;/em&gt;</source>
          <target state="translated">&amp;ldquo;匿名&amp;rdquo; &lt;code&gt;function&lt;/code&gt; 表达式&lt;em&gt;（尽管有术语，有时会创建带有名称的函数）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5faf09af21e3ee207861762a8a8fc90fff45652" translate="yes" xml:space="preserve">
          <source>(Note also that assignment should require a semicolon after the statement, while declaration prohibits it.)</source>
          <target state="translated">(还请注意,赋值应要求在语句后加分号,而声明禁止加分号)。</target>
        </trans-unit>
        <trans-unit id="624606f5ae627bc4f6dabd67b23d018b1256e5ee" translate="yes" xml:space="preserve">
          <source>(Remember that &lt;code&gt;Array#map&lt;/code&gt; passes the entry as the first argument, and the index as the second.)</source>
          <target state="translated">（请记住， &lt;code&gt;Array#map&lt;/code&gt; 将条目作为第一个参数传递，将索引作为第二个参数传递。）</target>
        </trans-unit>
        <trans-unit id="a6c2457af43114c5ee77f6c6836420d7fa86f67e" translate="yes" xml:space="preserve">
          <source>, this definition of &lt;code&gt;myfunction&lt;/code&gt; will override any previous definition, since it will be done at parse-time.</source>
          <target state="translated">，此 &lt;code&gt;myfunction&lt;/code&gt; 的定义将覆盖任何先前的定义，因为它将在解析时完成。</target>
        </trans-unit>
        <trans-unit id="6ae78ea2e192017c2e6cecf189c9877327296eb4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://ejohn.org/apps/learn/#13&quot;&gt;Tests fail when the original ninja object is removed.&lt;/a&gt; (page 13)</source>
          <target state="translated">&lt;a href=&quot;http://ejohn.org/apps/learn/#13&quot;&gt;删除原始忍者对象后，测试将失败。&lt;/a&gt; （第13页）</target>
        </trans-unit>
        <trans-unit id="c9c4f8471c82ec45ea1185e07850a97d382be68f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://ejohn.org/apps/learn/#14&quot;&gt;If you name the function that will be called recursively, the tests will pass.&lt;/a&gt; (page 14)</source>
          <target state="translated">&lt;a href=&quot;http://ejohn.org/apps/learn/#14&quot;&gt;如果您命名将被递归调用的函数，则测试将通过。&lt;/a&gt; （第14页）</target>
        </trans-unit>
        <trans-unit id="976105ab4e318e4ac55a458be9a6999ab9810e70" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-arrow-function-definitions-static-semantics-early-errors&quot;&gt;&lt;code&gt;ArrowFunction : ArrowParameters =&amp;gt; ConciseBody&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-arrow-function-definitions-static-semantics-early-errors&quot;&gt; &lt;code&gt;ArrowFunction : ArrowParameters =&amp;gt; ConciseBody&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="49d146068ed625d5d7328105f5e36bab6f733a04" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/336868/2730064&quot;&gt;Greg's Answer&lt;/a&gt; is good enough, but I still would like to add something to it that I learned just now watching &lt;a href=&quot;https://en.wikipedia.org/wiki/Douglas_Crockford&quot;&gt;Douglas Crockford's&lt;/a&gt; videos.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/336868/2730064&quot;&gt;Greg的Answer&lt;/a&gt;足够好，但是我仍然想在我刚刚看过&lt;a href=&quot;https://en.wikipedia.org/wiki/Douglas_Crockford&quot;&gt;Douglas Crockford的&lt;/a&gt;视频时学到一些东西。</target>
        </trans-unit>
        <trans-unit id="0c6835d261dfeeb9aa6c128ca4439678deec43ae" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/26394/eugene-lazutkin&quot;&gt;@EugeneLazutkin&lt;/a&gt; gives an example where he &lt;a href=&quot;https://stackoverflow.com/a/338053/&quot;&gt;names an assigned function to be able to use &lt;code&gt;shortcut()&lt;/code&gt;&lt;/a&gt; as an internal reference to itself. &lt;a href=&quot;http://ejohn.org/&quot;&gt;John Resig&lt;/a&gt; gives another example - &lt;em&gt;copying a recursive function assigned to another object&lt;/em&gt; in his &lt;a href=&quot;http://ejohn.org/apps/learn/&quot;&gt;Learning Advanced Javascript&lt;/a&gt; tutorial. While assigning functions to properties isn't strictly the question here, I recommend actively trying the tutorial out - run the code by clicking the button in the upper right corner, and double click the code to edit to your liking.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/26394/eugene-lazutkin&quot;&gt;@EugeneLazutkin&lt;/a&gt;给出了一个示例，其中他&lt;a href=&quot;https://stackoverflow.com/a/338053/&quot;&gt;命名了一个分配的函数，以便能够将 &lt;code&gt;shortcut()&lt;/code&gt; &lt;/a&gt;用作自身的内部引用。 &lt;a href=&quot;http://ejohn.org/&quot;&gt;John Resig&lt;/a&gt;给出了另一个示例-在他的&lt;a href=&quot;http://ejohn.org/apps/learn/&quot;&gt;Learning Advanced Javascript&lt;/a&gt;教程中&lt;em&gt;复制分配给另一个对象的递归函数&lt;/em&gt; 。 虽然在这里分配功能并不是严格的问题，但我还是建议您积极尝试使用本教程-单击右上角的按钮运行代码，然后双击该代码进行编辑。</target>
        </trans-unit>
        <trans-unit id="7b0c22340550205afa033ace7d2728b4aad0f9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Anonymous&lt;/code&gt; function expressions &lt;a href=&quot;https://jsperf.com/named-vs-anonymous-expressions&quot;&gt;appear to have better performance&lt;/a&gt;
  against &lt;code&gt;Named&lt;/code&gt; function expression.</source>
          <target state="translated">&lt;code&gt;Anonymous&lt;/code&gt; 函数表达式&lt;a href=&quot;https://jsperf.com/named-vs-anonymous-expressions&quot;&gt;似乎比&lt;/a&gt; &lt;code&gt;Named&lt;/code&gt; 函数表达式具有更好的性能 。</target>
        </trans-unit>
        <trans-unit id="c96f22714847a8babc3882697bb6248bc8fde655" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abc&lt;/code&gt; here is defined everywhere in the current scope:</source>
          <target state="translated">&lt;code&gt;abc&lt;/code&gt; 在当前范围的任何地方都定义了：</target>
        </trans-unit>
        <trans-unit id="33da11fb99d15d78d5a520754cccc634c18cce28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new Function()&lt;/code&gt; can be used to pass the function's body in a string. And hence this can be used to create dynamic functions. Also passing the script without executing the script.</source>
          <target state="translated">&lt;code&gt;new Function()&lt;/code&gt; 可用于在字符串中传递函数的主体。 因此，可以将其用于创建动态功能。 还传递脚本而不执行脚本。</target>
        </trans-unit>
        <trans-unit id="d921a21481f849741d142fe29c5ea098ea13f130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xyz&lt;/code&gt; here is defined from the point of assignment:</source>
          <target state="translated">&lt;code&gt;xyz&lt;/code&gt; 是从分配的角度定义的：</target>
        </trans-unit>
        <trans-unit id="f861ab5b26e3b088b115db80714f64319137c837" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xyz&lt;/code&gt; is going to be defined as usual, &lt;code&gt;abc&lt;/code&gt; is undefined in all browsers but Internet&amp;nbsp;Explorer &amp;mdash; do not rely on it being defined. But it will be defined inside its body:</source>
          <target state="translated">&lt;code&gt;xyz&lt;/code&gt; 将照常定义，在所有浏览器中 &lt;code&gt;abc&lt;/code&gt; 均未定义，但Internet Explorer －不依赖于已定义。 但它将在其内部定义：</target>
        </trans-unit>
        <trans-unit id="0996d262b069210bf614fbe919b57e1dcbed7423" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Another way to refer to itself is to use &lt;code&gt;arguments.callee&lt;/code&gt;, which is still relatively long, and not supported in the strict mode.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（引用自身的另一种方法是使用 &lt;code&gt;arguments.callee&lt;/code&gt; ，它仍然相对较长，并且在严格模式下不受支持。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d089b89c261d900b8d8ac6af9b57fdc04eb3614b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(function)&lt;/em&gt;.name</source>
          <target state="translated">&lt;em&gt;(function)&lt;/em&gt;.name</target>
        </trans-unit>
        <trans-unit id="12f5dfe559b4186c923fded6e04fcd3ed6a3a0f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;But in the case with function declarations, the entire function body will be hoisted as well&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;但是对于函数声明，整个函数体也将被提升&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="4bba3d17467d019bf50243da72010e06e9c2c779" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Function assigned to variable Example:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;分配给变量的函数示例：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="541cf619a3af25cde3b6df2217443cef1e854fc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;However, only the actual declarations are hoisted. by leaving assignments where they are.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;但是，仅悬挂实际的声明。&lt;/em&gt; &lt;em&gt;通过将作业留在原处。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77f992d8ae7a03a56428e18ae9187411b99ffeca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Javascript is called loosely typed language. Which means Javascript variables can hold value of any &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/7wkd9z69(v=vs.94).aspx&quot;&gt;Data-Type&lt;/a&gt;. Javascript automatically takes care of changing the variable-type based on the value/literal provided during runtime.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Javascript被称为松散类型语言。&lt;/em&gt; &lt;em&gt;这意味着Javascript变量可以保存任何&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/7wkd9z69(v=vs.94).aspx&quot;&gt;Data-Type的&lt;/a&gt;值。&lt;/em&gt; &lt;em&gt;Javascript自动根据运行时提供的值/文字来更改变量类型。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e30fdc640add63f2972505e1f77a336d70750ed6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Function Expression&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.函数表达式&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b2fd7065f9c16a465c2734b147eab3e80052db0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Function Declaration&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.功能声明&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1263cf84aad82d1a3af0dc6f1805903c828d3b71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://www.sitepoint.com/back-to-basics-javascript-hoisting/&quot;&gt;Hoisting&lt;/a&gt;&lt;/strong&gt;&lt;em&gt;is the JavaScript interpreter&amp;rsquo;s action of moving all variable and function declarations to the top of the current scope.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://www.sitepoint.com/back-to-basics-javascript-hoisting/&quot;&gt;提升&lt;/a&gt;&lt;/strong&gt; &lt;em&gt;是JavaScript解释器将所有变量和函数声明移到当前作用域顶部的操作。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f8747b2198f82905e46a1dbab75b4c9e9d7cdf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Variables&quot;&gt;Variable&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Variables&quot;&gt;Variable&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1335367051d267cd116cce2e6c150c50e7bd97ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/a/45759444/5081877&quot;&gt;ES5 Constructor Function Classes&lt;/a&gt;: Function objects created using Function.prototype.bind&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/a/45759444/5081877&quot;&gt;ES5构造函数类&lt;/a&gt; ：使用Function.prototype.bind创建的函数对象&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="370b180b017647cca99bd02f7e986cfc2b8fde8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;About performance:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;关于效果：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0fe5a78a445808092f814ad102d2a04ac9fb2f93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Chrome 62.0.3202&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;铬62.0.3202&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dae75490d4f79450f13d95e95c5513055074b89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Chrome Canary 63.0.3225&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;铬金丝雀63.0.3225&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8466249d1be58422b099d51dfe0e1f8cc0d6448" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;FireFox 55&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;火狐55&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19552d8c7b704459a1b16248ad256dc0c0139741" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Firefox&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;Chrome Canary&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;Chrome&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Firefox&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;浏览器Canary&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;Chrome&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58c08f0bbcc6004dd7cb688f6907939c10e640b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES2015&lt;/strong&gt;: &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript 2015&lt;/a&gt; (also known as &quot;ES6&quot;)</source>
          <target state="translated">&lt;strong&gt;ES2015&lt;/strong&gt; ： &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript 2015&lt;/a&gt; （也称为&amp;ldquo; ES6&amp;rdquo;）</target>
        </trans-unit>
        <trans-unit id="eccd9ae887601fcaf5c02293700ed6d0c8b205db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES5&lt;/strong&gt;: &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript 5th edition&lt;/a&gt;, 2009</source>
          <target state="translated">&lt;strong&gt;ES5&lt;/strong&gt; ： &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript第5版&lt;/a&gt; ，2009年</target>
        </trans-unit>
        <trans-unit id="1ec7544bfadafd964172ff845f75d06fbafca512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function Declaration&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;功能声明&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="469a2d465d6d3686feebc839c5b59f7f7284c5c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function Expression&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;函数表达式&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1a6cbedbfde0d5779de0a3fcf412af63bdea4f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function declarations&lt;/strong&gt; are faster, and that's what really matters in web dev right? ;)</source>
          <target state="translated">&lt;strong&gt;函数声明&lt;/strong&gt;更快，这就是Web开发人员真正重要的事情吧？ ;）</target>
        </trans-unit>
        <trans-unit id="f6569a24239dbe2b55280c9506730daaf0a33e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function expression:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;函数表达式：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="586c2626c76ccfb4558d9e83014f345dd1382003" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function statement:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;功能说明：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="936746e12db1da44d0d71d56ca5aafef2816cddd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Function&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b3af9f83ea8d3b337e7d7b746f4759ca51365d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More technical information&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;更多技术信息&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="99755834340590f1e6358b23e87882e9a22abad2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This answer has been merged from &lt;a href=&quot;https://stackoverflow.com/questions/3435709/why-are-functions-in-javascript-set-to-global-variables-instead-of-plain-function&quot;&gt;another question&lt;/a&gt;, in which the major doubt and misconception from the OP was that identifiers declared with a &lt;code&gt;FunctionDeclaration&lt;/code&gt;, couldn't be overwritten which is not the case.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：此答案已与&lt;a href=&quot;https://stackoverflow.com/questions/3435709/why-are-functions-in-javascript-set-to-global-variables-instead-of-plain-function&quot;&gt;另一个问题&lt;/a&gt;合并，其中来自OP的主要疑问和误解是用 &lt;code&gt;FunctionDeclaration&lt;/code&gt; 声明的标识符无法覆盖，事实并非如此。</target>
        </trans-unit>
        <trans-unit id="6a630a0d47ae66e4b85b0b41819338abf93e312a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why no error? We were always taught that expressions are executed from top to bottom(??)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;为什么没有错误？&lt;/strong&gt; &lt;strong&gt;我们总是被教导表达式从上到下执行（??）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e98f3eda3b4182b03fb95ad990fb05e68273244" translate="yes" xml:space="preserve">
          <source>A Function Declaration defines a named function variable without
  requiring variable assignment. Function Declarations occur as
  standalone constructs and cannot be nested within non-function blocks.
  It&amp;rsquo;s helpful to think of them as siblings of Variable Declarations.
  Just as Variable Declarations must start with &amp;ldquo;var&amp;rdquo;, Function
  Declarations must begin with &amp;ldquo;function&amp;rdquo;.</source>
          <target state="translated">函数声明定义了一个命名函数变量，而无需分配变量。 函数声明作为独立的构造出现，不能嵌套在非函数块中。 将它们视为变量声明的兄弟是很有帮助的。 就像变量声明必须以&amp;ldquo; var&amp;rdquo;开始一样，函数声明也必须以&amp;ldquo; function&amp;rdquo;开始。</target>
        </trans-unit>
        <trans-unit id="e05d42878c1cb04c0e530b3d07925d7a26e19963" translate="yes" xml:space="preserve">
          <source>A Function Expression defines a function as a part of a larger
  expression syntax (typically a variable assignment ). Functions
  defined via Functions Expressions can be named or anonymous. Function
  Expressions must not start with &amp;ldquo;function&amp;rdquo; (hence the parentheses
  around the self invoking example below).</source>
          <target state="translated">函数表达式将函数定义为更大的表达式语法（通常是变量赋值）的一部分。 通过函数表达式定义的函数可以命名或匿名。 函数表达式不能以&amp;ldquo;函数&amp;rdquo;开头（因此，下面的自调用示例周围带有括号）。</target>
        </trans-unit>
        <trans-unit id="86c7d8de9fcbc249405893d86e8bf42e97cb3dc8" translate="yes" xml:space="preserve">
          <source>A better explanation to &lt;a href=&quot;https://stackoverflow.com/a/336868/2351696&quot;&gt;Greg's answer&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/336868/2351696&quot;&gt;格雷格答案的&lt;/a&gt;更好解释</target>
        </trans-unit>
        <trans-unit id="6ca6b62f63765f6b37e6981c3fed49c39887418d" translate="yes" xml:space="preserve">
          <source>A couple of things about arrow functions:</source>
          <target state="translated">关于箭头功能的几件事。</target>
        </trans-unit>
        <trans-unit id="ba0bdb333e496781fbc28d1e1f11621acc2fdcab" translate="yes" xml:space="preserve">
          <source>A function declaration and a function expression assigned to a variable behave the same once the binding is established.</source>
          <target state="translated">一个函数声明和分配给一个变量的函数表达式一旦建立了绑定,其行为是一样的。</target>
        </trans-unit>
        <trans-unit id="586bbbe275e196b61f2bc269fbbcbefbe2f755d3" translate="yes" xml:space="preserve">
          <source>A function declaration can be placed anywhere in the code. Even if it is invoked before the definition appears in code, it gets executed as function declaration is committed to memory or in a way it is hoisted up, before any other code in the page starts execution.</source>
          <target state="translated">一个函数声明可以放在代码中的任何地方。即使它在定义出现在代码中之前被调用,它也会在函数声明被提交到内存中或以某种方式被挂起的方式被执行,在页面中的任何其他代码开始执行之前。</target>
        </trans-unit>
        <trans-unit id="fe52a62968b799ba8d3437f69fe7e179496e354b" translate="yes" xml:space="preserve">
          <source>A function declaration defines a named function variable without requiring variable assignment. Function declarations occur as standalone constructs and cannot be nested within non-function blocks.</source>
          <target state="translated">函数声明定义了一个命名的函数变量,不需要变量赋值。函数声明作为独立的构造出现,不能在非函数块中嵌套。</target>
        </trans-unit>
        <trans-unit id="dffe6e21959b36399921690a083098ea3f43b751" translate="yes" xml:space="preserve">
          <source>A function declaration is a &lt;em&gt;declaration&lt;/em&gt;; it's not a statement or expression. As such, you don't follow it with a &lt;code&gt;;&lt;/code&gt; (although doing so is harmless).</source>
          <target state="translated">函数声明是一个&lt;em&gt;声明&lt;/em&gt; ; 它不是语句或表达式。 因此，您不要在它后面加上 &lt;code&gt;;&lt;/code&gt; （尽管这样做是无害的）。</target>
        </trans-unit>
        <trans-unit id="c4b8b821c2b59fa8045994d19ff4ed224c59880d" translate="yes" xml:space="preserve">
          <source>A function declaration is processed when execution enters the context in which it appears, &lt;strong&gt;before&lt;/strong&gt; any step-by-step code is executed. The function it creates is given a proper name (&lt;code&gt;x&lt;/code&gt; in the example above), and that name is put in the scope in which the declaration appears.</source>
          <target state="translated">当执行进入任何分步代码&lt;strong&gt;之前&lt;/strong&gt; ，执行进入其出现的上下文时，将处理功能声明。 它创建的函数被赋予适当的名称（在上面的示例中为 &lt;code&gt;x&lt;/code&gt; ），并且该名称被放置在声明出现的范围内。</target>
        </trans-unit>
        <trans-unit id="6da90f6adb068378f7bee811147f83784b13cd26" translate="yes" xml:space="preserve">
          <source>A function expression defines a function as a part of a larger expression syntax (typically a variable assignment ). Functions defined via functions expressions can be named or anonymous. Function expressions should not start with &amp;ldquo;function&amp;rdquo;.</source>
          <target state="translated">函数表达式将函数定义为较大的表达式语法（通常是变量赋值）的一部分。 通过函数表达式定义的函数可以命名或匿名。 函数表达式不应以&amp;ldquo; function&amp;rdquo;开头。</target>
        </trans-unit>
        <trans-unit id="d1a8159e77618cdd4843f0dd77192ef3cc619005" translate="yes" xml:space="preserve">
          <source>A function expression, if not defined before calling it, will result in an error. Also, here the function definition itself is not moved to the top or committed to memory like in the function declarations. But the variable to which we assign the function gets hoisted up and &lt;strong&gt;undefined&lt;/strong&gt; gets assigned to it.</source>
          <target state="translated">如果在调用函数表达式之前未对其进行定义，则将导致错误。 同样，在这里，函数定义本身不会像函数声明中那样移到顶部或提交到内存中。 但是我们分配给函数的变量被提升，而&lt;strong&gt;未定义&lt;/strong&gt;的变量被赋给它。</target>
        </trans-unit>
        <trans-unit id="1e474c78af8f1973b4e36a580194a43c560f1983" translate="yes" xml:space="preserve">
          <source>A global property created by a &lt;code&gt;FunctionDeclaration&lt;/code&gt; can be overwritten without any problems just like a variable value, e.g.:</source>
          <target state="translated">由 &lt;code&gt;FunctionDeclaration&lt;/code&gt; 创建的全局属性可以被覆盖而没有任何问题，就像变量值一样，例如：</target>
        </trans-unit>
        <trans-unit id="16985658b3a31ca6aeffc5a5893a992a5e8008b3" translate="yes" xml:space="preserve">
          <source>A must read:</source>
          <target state="translated">必读的书。</target>
        </trans-unit>
        <trans-unit id="e868506d981fb5c0f6384bf8996fdae27caec377" translate="yes" xml:space="preserve">
          <source>About your edited first example (&lt;code&gt;foo = function() { alert('hello!'); };&lt;/code&gt;), it is an undeclared assignment, I would highly encourage you to always use the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">关于您编辑的第一个示例（ &lt;code&gt;foo = function() { alert('hello!'); };&lt;/code&gt; ），这是一个未声明的赋值，我强烈建议您始终使用 &lt;code&gt;var&lt;/code&gt; 关键字。</target>
        </trans-unit>
        <trans-unit id="3eb314099eec1e9d7c9302b330fab0de04e4d5a0" translate="yes" xml:space="preserve">
          <source>Accessor Function Initializer (ES5+)</source>
          <target state="translated">Accessor 函数初始化器 (ES5+)</target>
        </trans-unit>
        <trans-unit id="5e996e3eab307a7b71ac3432752e7fdfb923a820" translate="yes" xml:space="preserve">
          <source>Also see &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/881515/&quot;&gt;How do I declare a namespace in JavaScript?&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">另请参阅&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/881515/&quot;&gt;如何在JavaScript中声明名称空间？&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0da3dc3f13523455887513be16fc6b61206dd05d" translate="yes" xml:space="preserve">
          <source>Also, if you need more info about how hoisting works in JavaScript, visit the link below:</source>
          <target state="translated">此外,如果您需要更多关于JavaScript中的吊装工作原理的信息,请访问下面的链接。</target>
        </trans-unit>
        <trans-unit id="14a4adf4af3f12e24e5839d70532eff9bbc83168" translate="yes" xml:space="preserve">
          <source>Also, it hoisted through a &lt;code&gt;return&lt;/code&gt; statement:</source>
          <target state="translated">此外，它还通过 &lt;code&gt;return&lt;/code&gt; 语句进行了挂起：</target>
        </trans-unit>
        <trans-unit id="83c03304952acf14e910695cd06f40d8b9fbbec0" translate="yes" xml:space="preserve">
          <source>Also, undeclared assignments throw a &lt;code&gt;ReferenceError&lt;/code&gt; on ECMAScript 5 under &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/&quot;&gt;Strict Mode&lt;/a&gt;.</source>
          <target state="translated">另外，在&lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/&quot;&gt;严格模式&lt;/a&gt;下，未声明的分配会在ECMAScript 5上引发 &lt;code&gt;ReferenceError&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d69902d08f0a65094ca17202194440fc3b8aeba6" translate="yes" xml:space="preserve">
          <source>Although doing this wasn't &lt;em&gt;specified&lt;/em&gt; until ES2015, it was an &lt;em&gt;allowable extension&lt;/em&gt; to support function declarations in blocks. Unfortunately (and inevitably), different engines did different things.</source>
          <target state="translated">尽管直到ES2015才&lt;em&gt;指定&lt;/em&gt;执行此操作，但这是&lt;em&gt;允许的扩展，&lt;/em&gt;以支持块中的函数声明。 不幸的是（不可避免），不同的引擎做了不同的事情。</target>
        </trans-unit>
        <trans-unit id="711467f315de312047766526b3669d8afe66dbf2" translate="yes" xml:space="preserve">
          <source>An illustration of when to prefer the first method to the second one is when you need to avoid overriding a function's previous definitions.</source>
          <target state="translated">当你需要避免覆盖一个函数的前一个定义时,一个例子说明了什么时候应该选择第一种方法而不是第二种方法。</target>
        </trans-unit>
        <trans-unit id="76e9af881baea20b41dca7056be9ed2866b3110e" translate="yes" xml:space="preserve">
          <source>An important reason is to add one and only one variable as the &quot;Root&quot; of your namespace...</source>
          <target state="translated">一个重要的原因是在你的命名空间中添加一个也是唯一一个变量作为 &quot;根&quot;。</target>
        </trans-unit>
        <trans-unit id="22aee645613b4be0feeee7c7d21978392526a1f5" translate="yes" xml:space="preserve">
          <source>And in a function expression</source>
          <target state="translated">而在一个函数表达式中</target>
        </trans-unit>
        <trans-unit id="72c0421ee623967b8daecf32d64a58d316428622" translate="yes" xml:space="preserve">
          <source>And since they're processed &lt;em&gt;before&lt;/em&gt; step-by-step code is run, it's tricky to know what to do when they're in a control structure.</source>
          <target state="translated">而且由于它们是&lt;em&gt;在&lt;/em&gt;运行分步代码&lt;em&gt;之前进行&lt;/em&gt;处理的，因此要知道当它们处于控制结构中时该怎么做是很棘手的。</target>
        </trans-unit>
        <trans-unit id="721e0aa2d182321c9728514141b079a49fc8d164" translate="yes" xml:space="preserve">
          <source>And they are both hoisted to the top of the code.</source>
          <target state="translated">而且都是吊打到了法则的顶端。</target>
        </trans-unit>
        <trans-unit id="b8e93f2352a63f2f8ea04ce03020224e5e66bb84" translate="yes" xml:space="preserve">
          <source>And, a function declaration:</source>
          <target state="translated">还有,函数声明。</target>
        </trans-unit>
        <trans-unit id="4c5054856e4bbef19e96d760e5ea9c34ecb00648" translate="yes" xml:space="preserve">
          <source>Another difference that is not mentioned in the other answers is that if you use the anonymous function</source>
          <target state="translated">其他答案中没有提到的另一个不同之处是,如果你使用匿名函数</target>
        </trans-unit>
        <trans-unit id="af3890af81c2b6252d1f34cfdef6f3003e49e4ce" translate="yes" xml:space="preserve">
          <source>Another good reason to use the combined style is to use a short internal name to refer to itself, while providing a long non-conflicting name for external users:</source>
          <target state="translated">使用组合风格的另一个很好的理由是,使用简短的内部名称来指代自己,同时为外部用户提供了一个长长的不冲突的名称。</target>
        </trans-unit>
        <trans-unit id="edcabfa9c012840526618d1e04748f8c28cb2838" translate="yes" xml:space="preserve">
          <source>Another obvious difference between your two examples is that the first function doesn't have a name, but the second has it, which can be really useful when debugging (i.e. inspecting a call stack).</source>
          <target state="translated">你这两个例子之间的另一个明显的区别是,第一个函数没有名字,但第二个函数有名字,这在调试时(即检查调用堆栈)真的很有用。</target>
        </trans-unit>
        <trans-unit id="78b91f70d93cc43865f21e88db633ffc080cd555" translate="yes" xml:space="preserve">
          <source>Arrow Function Expression (ES2015+)</source>
          <target state="translated">箭头函数表达式(ES2015+)</target>
        </trans-unit>
        <trans-unit id="95d9a52f48570a30b4afc03ec08d2692f827518e" translate="yes" xml:space="preserve">
          <source>Arrow Function Expression (ES2015+) &lt;em&gt;(which, like anonymous function expressions, don't involve an explicit name, and yet can create functions with names)&lt;/em&gt;</source>
          <target state="translated">箭头函数表达式（ES2015 +） &lt;em&gt;（与匿名函数表达式一样，它不涉及显式名称，但可以使用名称创建函数）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd53a48e43711dae9eac565fec3530c9b4ee1e47" translate="yes" xml:space="preserve">
          <source>Arrow Function With &lt;code&gt;function add()&lt;/code&gt;</source>
          <target state="translated">带有 &lt;code&gt;function add()&lt;/code&gt; 箭头功能</target>
        </trans-unit>
        <trans-unit id="3f99e80bb8fac409e2d6527343847643ed0c3e39" translate="yes" xml:space="preserve">
          <source>Arrow Function with &lt;code&gt;var add=function()&lt;/code&gt;</source>
          <target state="translated">带有 &lt;code&gt;var add=function()&lt;/code&gt; 的箭头函数</target>
        </trans-unit>
        <trans-unit id="f70eea3b7a6f694be6cb95f16c6f6793125caccc" translate="yes" xml:space="preserve">
          <source>As of ES2015, the specification says what to do. In fact, it gives three separate things to do:</source>
          <target state="translated">从ES2015年开始,规范中说要做什么。事实上,它给出了三个单独的事情要做。</target>
        </trans-unit>
        <trans-unit id="1d02938e3888244803072ebfb20246bbdc0d0b95" translate="yes" xml:space="preserve">
          <source>As of this writing, V8, SpiderMonkey, Chakra and Nitro always refer to named functions by their names. They almost always refer to an anonymous function by its identifier if it has one.</source>
          <target state="translated">在写这篇文章的时候,V8、SpiderMonkey、Chakra和Nitro总是用它们的名字来引用命名的函数。如果匿名函数有标识符,它们几乎总是用它的标识符来指代一个匿名函数。</target>
        </trans-unit>
        <trans-unit id="1b720c9c8412003b175b355c56b4ee5db0224dd0" translate="yes" xml:space="preserve">
          <source>As you'll have noticed with the above, you don't use the keyword &lt;code&gt;function&lt;/code&gt;; instead, you use &lt;code&gt;=&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">正如您在上面已经注意到的那样，您没有使用关键字 &lt;code&gt;function&lt;/code&gt; ； 而是使用 &lt;code&gt;=&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4999f76b7eca3d345d9076570ce3eedb86bebb2" translate="yes" xml:space="preserve">
          <source>Assign a variable to a function, means no Hoisting, as we know functions in JavaScript can Hoist, means they can be called before they get declared, while variables need to be declared before getting access to them, so means in this case we can not access the function before where it's declared, also it could be a way that you write your functions, for the functions which return another function, this kind of declaration could make sense, also in ECMA6 &amp;amp; above you can assign this to an arrow function which can be used to call anonymous functions, also this way of declaring is a better way to create Constructor functions in JavaScript.</source>
          <target state="translated">为函数分配变量意味着没有提升，因为我们知道JavaScript中的函数可以提升，意味着可以在声明它们之前调用它们，而在访问它们之前需要先声明变量，因此在这种情况下，我们不能在声明函数之前访问函数，这也可能是您编写函数的一种方式，对于返回另一个函数的函数，这种声明很有意义，同样在ECMA6及更高版本中，您可以将其分配给箭头函数，可以用来调用匿名函数，这种声明方式也是在JavaScript中创建构造函数的更好方法。</target>
        </trans-unit>
        <trans-unit id="7d6674bc9982ef481387f57cc83fdf356448f020" translate="yes" xml:space="preserve">
          <source>Availability (scope) of the function</source>
          <target state="translated">职能的可用性(范围)</target>
        </trans-unit>
        <trans-unit id="cb3c67b40dd1ec42a7ebb8e4fedcdde942976905" translate="yes" xml:space="preserve">
          <source>Basically, all function declarations and variable declarations are hoisted to the top of the &lt;em&gt;function&lt;/em&gt; in which the declaration occurs (this is why we say that JavaScript has &lt;em&gt;function scope&lt;/em&gt;).</source>
          <target state="translated">基本上，所有函数声明和变量声明都被提升到声明所在&lt;em&gt;函数&lt;/em&gt;的顶部（这就是我们说JavaScript具有&lt;em&gt;函数作用域的原因&lt;/em&gt; ）。</target>
        </trans-unit>
        <trans-unit id="1c04286e0850fd4e09d7efcea4b60ed58c2b3685" translate="yes" xml:space="preserve">
          <source>Because it's processed before any step-by-step code in the same context, you can do things like this:</source>
          <target state="translated">因为它是在同一上下文中的任何步骤代码之前处理的,所以你可以做这样的事情。</target>
        </trans-unit>
        <trans-unit id="13805085132e2a3520de22c522cbe8f65c7afc62" translate="yes" xml:space="preserve">
          <source>Because:</source>
          <target state="translated">Because:</target>
        </trans-unit>
        <trans-unit id="7aebd6867188b491049a61eb4878f8609a152162" translate="yes" xml:space="preserve">
          <source>Both are different ways of defining a function. The difference is how the browser interprets and loads them into an execution context.</source>
          <target state="translated">两者都是定义函数的不同方式。区别在于浏览器如何解释并将其加载到执行上下文中。</target>
        </trans-unit>
        <trans-unit id="c5ff3cd407987df1124c03fe7e85c5b0571cb3f8" translate="yes" xml:space="preserve">
          <source>But for the most part it's not worth stressing over.</source>
          <target state="translated">但在大多数情况下,这并不值得强调。</target>
        </trans-unit>
        <trans-unit id="ecc7ba886c1a06ff3f510f80143a980ada742eea" translate="yes" xml:space="preserve">
          <source>By using the variable syntax, I can declare the variable (a function pointer essentially) in the shared code and either assign a trivial stub function, or set to null.</source>
          <target state="translated">通过使用变量语法,我可以在共享代码中声明该变量(本质上是一个函数指针),并指定一个琐碎的存根函数,或者设置为空。</target>
        </trans-unit>
        <trans-unit id="2fa0d12e3977b9cdaebbd95bbb5c680f6ef8533a" translate="yes" xml:space="preserve">
          <source>Chakra</source>
          <target state="translated">Chakra</target>
        </trans-unit>
        <trans-unit id="bec230d90facfd5f91e7a3f68902d847f6c654f2" translate="yes" xml:space="preserve">
          <source>Constructor and Method Declarations in &lt;code&gt;class&lt;/code&gt; (ES2015+)</source>
          <target state="translated">类中的构造方法和方法声明（ES2015 +）</target>
        </trans-unit>
        <trans-unit id="2d08fdf2a8fb1f957e679f1a7a3412c536fd3dc4" translate="yes" xml:space="preserve">
          <source>Deep down, JavaScript treats both statements differently. This is a function declaration:</source>
          <target state="translated">深究起来,JavaScript对这两个语句的处理方式是不同的。这是一个函数声明。</target>
        </trans-unit>
        <trans-unit id="63a844213d874b8b245c742695b7941db276a173" translate="yes" xml:space="preserve">
          <source>Default return value of function is '&lt;a href=&quot;https://javascriptweblog.wordpress.com/2010/08/16/understanding-undefined-and-preventing-referenceerrors/&quot;&gt;undefined&lt;/a&gt;', &lt;a href=&quot;http://javascript.info/tutorial/variables-and-statements&quot;&gt;Variable&lt;/a&gt; declaration default value also 'undefined'</source>
          <target state="translated">函数的默认返回值为&amp;ldquo; &lt;a href=&quot;https://javascriptweblog.wordpress.com/2010/08/16/understanding-undefined-and-preventing-referenceerrors/&quot;&gt;undefined&lt;/a&gt; &amp;rdquo;， &lt;a href=&quot;http://javascript.info/tutorial/variables-and-statements&quot;&gt;变量&lt;/a&gt;声明的默认值也为&amp;ldquo; undefined&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="64b93c79b512c36d99999e6e34357c9f1c087aa9" translate="yes" xml:space="preserve">
          <source>ECMA 5 (13.0) defines the syntax as</source>
          <target state="translated">ECMA 5(13.0)将语法定义为</target>
        </trans-unit>
        <trans-unit id="c150af269e5f4c4642804ca24c299f530d6bf24b" translate="yes" xml:space="preserve">
          <source>ES2015 allows a shorter form of declaring a property that references a function called a &lt;em&gt;method definition&lt;/em&gt;; it looks like this:</source>
          <target state="translated">ES2015允许使用一种简短形式来声明引用一个称为&lt;em&gt;方法定义&lt;/em&gt;的函数的属性； 它看起来像这样：</target>
        </trans-unit>
        <trans-unit id="b28d4620b46f9904b783e4bdca73dea8f4634eab" translate="yes" xml:space="preserve">
          <source>ES2015 brings us &lt;code&gt;class&lt;/code&gt; syntax, including declared constructors and methods:</source>
          <target state="translated">ES2015为我们带来了 &lt;code&gt;class&lt;/code&gt; 语法，包括声明的构造函数和方法：</target>
        </trans-unit>
        <trans-unit id="9d20a8f701915abdc4215ec73ca7a058aff15f27" translate="yes" xml:space="preserve">
          <source>ES2015 brings us the &lt;em&gt;arrow function&lt;/em&gt;. Here's one example:</source>
          <target state="translated">ES2015为我们带来了&lt;em&gt;箭头功能&lt;/em&gt; 。 这是一个例子：</target>
        </trans-unit>
        <trans-unit id="ac6212e9887dd3f14ce21d75177f4b2bcc5e3df2" translate="yes" xml:space="preserve">
          <source>ES6 introduced &lt;strong&gt;Arrow function&lt;/strong&gt;: An arrow function expression has a shorter syntax, they are best suited for non-method functions, and they cannot be used as constructors.</source>
          <target state="translated">ES6引入了&lt;strong&gt;Arrow函数&lt;/strong&gt; ：arrow函数表达式具有较短的语法，它们最适合于非方法函数，并且不能用作构造函数。</target>
        </trans-unit>
        <trans-unit id="49a81d8fe89a66107237159e2c32f647ebe45e02" translate="yes" xml:space="preserve">
          <source>Examples from the tutorial: recursive calls in &lt;code&gt;yell()&lt;/code&gt;:</source>
          <target state="translated">教程中的示例： &lt;code&gt;yell()&lt;/code&gt; 中的递归调用：</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="30e5c50747f8ddc02fafa95f11253e401b5d26e4" translate="yes" xml:space="preserve">
          <source>First I want to correct Greg: &lt;code&gt;function abc(){}&lt;/code&gt; is scoped too &amp;mdash; the name &lt;code&gt;abc&lt;/code&gt; is defined in the scope where this definition is encountered. Example:</source>
          <target state="translated">首先，我想更正Greg： &lt;code&gt;function abc(){}&lt;/code&gt; 的作用域也已确定范围-在遇到此定义的范围内定义了名称 &lt;code&gt;abc&lt;/code&gt; 。 例：</target>
        </trans-unit>
        <trans-unit id="63aa696e0203f17e821cd16409f715c884085a35" translate="yes" xml:space="preserve">
          <source>For example, a function expression:</source>
          <target state="translated">比如说函数表达式。</target>
        </trans-unit>
        <trans-unit id="d83df8cc10813d6eb9d49ec11d81159959f3b35b" translate="yes" xml:space="preserve">
          <source>For more information on anonymous functions and lambda calculus, Wikipedia is a good start (&lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;http://en.wikipedia.org/wiki/Anonymous_function&lt;/a&gt;).</source>
          <target state="translated">有关匿名函数和lambda演算的更多信息，Wikipedia是一个好的开始（ &lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;http://en.wikipedia.org/wiki/Anonymous_function&lt;/a&gt; ）。</target>
        </trans-unit>
        <trans-unit id="710381e12b95a3fe66706dfb40babc24d6b8e1bb" translate="yes" xml:space="preserve">
          <source>From people's comments above, I gather it may be possible to redefine a static function too, but I think the variable solution is nice and clear.</source>
          <target state="translated">从上面人们的评论中,我推测可能也可以重新定义一个静态函数,但我觉得变量的解决方案很好,也很清晰。</target>
        </trans-unit>
        <trans-unit id="69181d045b415910120ca08053987e69c74ffe57" translate="yes" xml:space="preserve">
          <source>Fun fact:</source>
          <target state="translated">有趣的事实。</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="79f7a2b842722c439a637899094a3e9b975d2161" translate="yes" xml:space="preserve">
          <source>Function Declaration</source>
          <target state="translated">函数声明</target>
        </trans-unit>
        <trans-unit id="fea3337acc300eb0d59bb99072b521bda997c9a8" translate="yes" xml:space="preserve">
          <source>Function declaration vs. function expression is the real reason why there is a difference demonstrated by Greg.</source>
          <target state="translated">函数声明与函数表达式的区别,真正的原因是Greg所表现出来的。</target>
        </trans-unit>
        <trans-unit id="2581d19bd1414397aab6c9d732c76b5beb72bc8d" translate="yes" xml:space="preserve">
          <source>Function declaration:</source>
          <target state="translated">函数声明。</target>
        </trans-unit>
        <trans-unit id="5d4b965bdff51520668a82710d188ad4c6d2847b" translate="yes" xml:space="preserve">
          <source>Function declarations and variable declarations are always moved (&lt;code&gt;hoisted&lt;/code&gt;) invisibly to the top of their containing scope by the JavaScript interpreter. Function parameters and language-defined names are, obviously, already there. &lt;a href=&quot;http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting&quot;&gt;ben cherry&lt;/a&gt;</source>
          <target state="translated">JavaScript解释器总是将函数声明和变量声明不可见地移动（ &lt;code&gt;hoisted&lt;/code&gt; ）到其包含范围的顶部。 函数参数和语言定义的名称显然已经存在。 &lt;a href=&quot;http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting&quot;&gt;本樱桃&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f30da0007535208b5211e526a05c262a2237a322" translate="yes" xml:space="preserve">
          <source>Function declarations take precedence over variable declarations, and the last function declaration &quot;sticks&quot;.</source>
          <target state="translated">函数声明优先于变量声明,最后一个函数声明 &quot;坚持&quot;。</target>
        </trans-unit>
        <trans-unit id="9c2da209e9a31c47ddfe63c4563f794fa8b30376" translate="yes" xml:space="preserve">
          <source>Function expression &lt;a href=&quot;https://jsperf.com/fdeclaration-vs-fexpression&quot;&gt;appears to be faster&lt;/a&gt; now.</source>
          <target state="translated">现在函数表达&lt;a href=&quot;https://jsperf.com/fdeclaration-vs-fexpression&quot;&gt;似乎更快&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="b76f36a30041319319253d18b6823f5c3562c4aa" translate="yes" xml:space="preserve">
          <source>Function expression:</source>
          <target state="translated">函数表达式。</target>
        </trans-unit>
        <trans-unit id="a1ac0ca8c05d1c35307dcd8c89a858da945ba8b7" translate="yes" xml:space="preserve">
          <source>Harness (&lt;a href=&quot;http://jsfiddle.net/us9dg6y8/&quot;&gt;Fiddle&lt;/a&gt;)</source>
          <target state="translated">线束（ &lt;a href=&quot;http://jsfiddle.net/us9dg6y8/&quot;&gt;小提琴&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="a3e7d8a4d91ccb31d5aba99a1030f3258cd6aa3d" translate="yes" xml:space="preserve">
          <source>Here the function declaration is hoisted first, declaring and initializing variable &lt;code&gt;a&lt;/code&gt;. Next, this variable is assigned &lt;code&gt;10&lt;/code&gt;. In other words: the assignment does not assign to outer variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">这里首先悬挂函数声明，声明并初始化变量 &lt;code&gt;a&lt;/code&gt; 。 接下来，将此变量分配给 &lt;code&gt;10&lt;/code&gt; 。 换句话说：分配没有分配给外部变量 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d4f1cbe2358cd472b9d4c788b3633f57ec1400c8" translate="yes" xml:space="preserve">
          <source>Here's the rundown on the standard forms that create functions: &lt;em&gt;(Originally written for another question, but adapted after being moved into the canonical question.)&lt;/em&gt;</source>
          <target state="translated">这是创建函数的标准表单的摘要：（ &lt;em&gt;本来是为另一个问题而写的，但是在移入规范问题后进行了修改。）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9862412fbf3fc6c7bb7d8129f2f818be0d11455" translate="yes" xml:space="preserve">
          <source>Historically, anonymous functions appeared from the inability of JavaScript as a language to list members with named functions:</source>
          <target state="translated">从历史上看,匿名函数的出现是由于JavaScript作为一种语言,无法用命名的函数来列出成员,所以匿名函数的出现。</target>
        </trans-unit>
        <trans-unit id="16c223be40fd7052aab965a0fd6c87c593532cd4" translate="yes" xml:space="preserve">
          <source>However, the difference in behaviour is that with the first variant (&lt;code&gt;var functionOne = function() {}&lt;/code&gt;), that function can only be called after that point in the code.</source>
          <target state="translated">但是，行为上的差异在于，对于第一个变量（ &lt;code&gt;var functionOne = function() {}&lt;/code&gt; ），只能在代码中的该点之后调用该函数。</target>
        </trans-unit>
        <trans-unit id="88718800ef1385d4eba64028d144aab14b067313" translate="yes" xml:space="preserve">
          <source>However, when we use the const-statement, the variable reference becomes immutable. This means that we cannot assign a new value to the variable. Please note, however, that this does not make the contents of the variable immutable: if you do &lt;code&gt;const arr = []&lt;/code&gt;, then you can still do &lt;code&gt;arr[10] = &quot;example&quot;&lt;/code&gt;. Only doing something like &lt;code&gt;arr = &quot;new value&quot;&lt;/code&gt; or &lt;code&gt;arr = []&lt;/code&gt; would throw an error as seen below.</source>
          <target state="translated">但是，当我们使用const语句时，变量引用变得不可变。 这意味着我们不能为变量分配新值。 但是请注意，这不会使变量的内容不可变：如果您执行 &lt;code&gt;const arr = []&lt;/code&gt; ，那么仍然可以执行 &lt;code&gt;arr[10] = &quot;example&quot;&lt;/code&gt; 。 仅执行类似 &lt;code&gt;arr = &quot;new value&quot;&lt;/code&gt; 或 &lt;code&gt;arr = []&lt;/code&gt; 会引发错误，如下所示。</target>
        </trans-unit>
        <trans-unit id="448a69f6cf1fb712be3c91a06ea26cc7b2a58c9d" translate="yes" xml:space="preserve">
          <source>I have code that I need to run with 160 independently-designed brandings. Most of the code is in shared files, but branding-specific stuff is in a separate file, one for each branding.</source>
          <target state="translated">我有一些代码,我需要运行160个独立设计的品牌的代码。大部分的代码都在共享文件中,但特定品牌的东西在一个单独的文件中,每个品牌都有一个。</target>
        </trans-unit>
        <trans-unit id="f2caaf00ea49d3671a16112cd64e966f2b9b42f1" translate="yes" xml:space="preserve">
          <source>I know that I defined it globally providing that I didn't define &lt;code&gt;abc&lt;/code&gt; anywhere in the chain of scopes. This style of definition is resilient even when used inside &lt;code&gt;eval()&lt;/code&gt;. While the definition</source>
          <target state="translated">我知道我是在全局范围内定义的，前提是我没有在范围链中的任何地方定义 &lt;code&gt;abc&lt;/code&gt; 。 即使在 &lt;code&gt;eval()&lt;/code&gt; 内使用时，这种定义方式也具有弹性。 而定义</target>
        </trans-unit>
        <trans-unit id="bc5e1bfae37a8f9624f4cf6c70c888ec885a6199" translate="yes" xml:space="preserve">
          <source>I know that I defined the function locally. When I define the function like</source>
          <target state="translated">我知道我在本地定义了这个函数。当我定义了这样的函数时</target>
        </trans-unit>
        <trans-unit id="fc40ffc8273deb922d6a2d5a6d75d6a7f097e7f5" translate="yes" xml:space="preserve">
          <source>I often build JavaScript modules with a pattern like this:</source>
          <target state="translated">我经常用这样的模式来构建JavaScript模块。</target>
        </trans-unit>
        <trans-unit id="52bb913d96e6cf1bb8f9c9868ed46fa2682d02e2" translate="yes" xml:space="preserve">
          <source>I suspect more PROS for named functions are follow. And what is listed as an advantage of named functions is a disadvantage for anonymous ones.</source>
          <target state="translated">我猜想,命名函数的更多的PROS都在后面。而被列为命名函数的优点,对于匿名函数来说,是一个缺点。</target>
        </trans-unit>
        <trans-unit id="48459bd949db4fd197340d3c07b4f6d46bda103c" translate="yes" xml:space="preserve">
          <source>I use the variable approach in my code for a very specific reason, the theory of which has been covered in an abstract way above, but an example might help some people like me, with limited JavaScript expertise.</source>
          <target state="translated">我在代码中使用变量方法是出于一个非常特殊的原因,其理论已经在上面抽象地讲过了,但是举个例子可能会对一些像我这样的人有帮助,因为我的JavaScript专业知识有限。</target>
        </trans-unit>
        <trans-unit id="a720e3aa194c1f4744a62a098d3325669013f3cd" translate="yes" xml:space="preserve">
          <source>I'm adding my own answer just because everyone else has covered the hoisting part thoroughly.</source>
          <target state="translated">因为别人都已经把吊装的部分讲得很透彻了,我就加了自己的答案。</target>
        </trans-unit>
        <trans-unit id="6b65544a6391d547c18bfe600d2757c9ec324ddd" translate="yes" xml:space="preserve">
          <source>I'm listing out the differences below:</source>
          <target state="translated">我在下面列举出不同之处。</target>
        </trans-unit>
        <trans-unit id="7b6cd598514917069a107f035013ef3785ac2a80" translate="yes" xml:space="preserve">
          <source>I've recently started maintaining someone else's JavaScript code. I'm fixing bugs, adding features and also trying to tidy up the code and make it more consistent.</source>
          <target state="translated">我最近开始维护别人的JavaScript代码。我在修复bug,增加功能,同时也在努力整理代码,使其更加一致。</target>
        </trans-unit>
        <trans-unit id="bce5a0c9028577f292967e9b74591dfce14b4d0e" translate="yes" xml:space="preserve">
          <source>I've wondered about which way is better for a long while now, and thanks to &lt;a href=&quot;http://jsperf.com&quot;&gt;http://jsperf.com&lt;/a&gt; now I know :)</source>
          <target state="translated">我想知道很长一段时间以来哪种方法更好，并且感谢&lt;a href=&quot;http://jsperf.com&quot;&gt;http://jsperf.com，&lt;/a&gt;现在我知道了:)</target>
        </trans-unit>
        <trans-unit id="7253bc4a6f9bb4a8d2e1a26b26041e3d0c929006" translate="yes" xml:space="preserve">
          <source>If in &lt;em&gt;strict&lt;/em&gt; mode (browser or not), the JavaScript engine is supposed to do yet another thing</source>
          <target state="translated">如果处于&lt;em&gt;严格&lt;/em&gt;模式（是否使用浏览器），则JavaScript引擎应该做另一件事</target>
        </trans-unit>
        <trans-unit id="47ba4d884a6eea36c2e8e1930047665437e35282" translate="yes" xml:space="preserve">
          <source>If in loose mode &lt;em&gt;not&lt;/em&gt; on a web browser, the JavaScript engine is supposed to do one thing</source>
          <target state="translated">如果在非宽松模式下&lt;em&gt;不在&lt;/em&gt; Web浏览器上，则JavaScript引擎应该做一件事</target>
        </trans-unit>
        <trans-unit id="9c24a734bfa420e8662e5588c678c512ef41507c" translate="yes" xml:space="preserve">
          <source>If in loose mode on a web browser, the JavaScript engine is supposed to do something else</source>
          <target state="translated">如果在Web浏览器上处于宽松模式,JavaScript引擎应该做一些其他事情</target>
        </trans-unit>
        <trans-unit id="c773779c693ffdb43c73b2a0c70b33f6e387fbfc" translate="yes" xml:space="preserve">
          <source>If there are no variables set to the function, then the functions name is the empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;).</source>
          <target state="translated">如果没有为函数设置变量，则函数名称为空字符串（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0ee8e8f5104dbf145e9fbcd03eca2e86caccca4f" translate="yes" xml:space="preserve">
          <source>If you really, really wanted your iterator and success callbacks to show up in the trace, you could name those too...</source>
          <target state="translated">如果你真的,真的想让你的迭代器和成功回调在跟踪中显示出来,你可以把这些也命名为.....</target>
        </trans-unit>
        <trans-unit id="be9589a95c8b69ed2b8236a7926adaebf7d55119" translate="yes" xml:space="preserve">
          <source>If you want to alias functions on all browsers, use this kind of declaration:</source>
          <target state="translated">如果你想在所有浏览器上使用别名函数,请使用这种声明。</target>
        </trans-unit>
        <trans-unit id="99925e9ee05be0efa6950a0d1631c81f1977d083" translate="yes" xml:space="preserve">
          <source>If you would use those functions to create objects, you would get:</source>
          <target state="translated">如果你会用这些函数来创建对象,你会得到。</target>
        </trans-unit>
        <trans-unit id="ba22cd7a07e0cdf6f17ebe8dd72208ff7d3f75dc" translate="yes" xml:space="preserve">
          <source>If you're doing more than just a single expression, use &lt;code&gt;{}&lt;/code&gt; and an explicit &lt;code&gt;return&lt;/code&gt; (if you need to return a value), as normal:</source>
          <target state="translated">如果您不仅要执行单个表达式，还可以像往常一样使用 &lt;code&gt;{}&lt;/code&gt; 和显式 &lt;code&gt;return&lt;/code&gt; （如果需要返回值）：</target>
        </trans-unit>
        <trans-unit id="18d78f8520de80f2c3d19326953d4afd2bce640f" translate="yes" xml:space="preserve">
          <source>In ES5, the function this creates has no name (it's anonymous). In ES2015, the function is assigned a name if possible by inferring it from context. In the example above, the name would be &lt;code&gt;y&lt;/code&gt;. Something similar is done when the function is the value of a property initializer. (For details on when this happens and the rules, search for &lt;code&gt;SetFunctionName&lt;/code&gt; in the &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;the specification&lt;/a&gt;&amp;nbsp;&amp;mdash; it appears &lt;em&gt;all over&lt;/em&gt; the place.)</source>
          <target state="translated">在ES5中，此函数创建的函数没有名称（匿名）。 在ES2015中，如果可能，可以通过从上下文推断功能来为其分配名称。 在上面的示例中，名称为 &lt;code&gt;y&lt;/code&gt; 。 当函数是属性初始值设定项的值时，将执行类似的操作。 （有关发生这种情况的时间和规则的详细信息，请在规范中搜索 &lt;code&gt;SetFunctionName&lt;/code&gt; -它出现在各处。）</target>
        </trans-unit>
        <trans-unit id="4d0a437ff9ee930d494784b0a38eceebe7464cfb" translate="yes" xml:space="preserve">
          <source>In Google's V8 and Firefox's Spidermonkey there might be a few microsecond JIST compilation difference, but ultimately the result is the exact same. To prove this, let's examine the efficiency of JSPerf at microbenchmarks by comparing the speed of two blank code snippets. The &lt;a href=&quot;https://jsperf.com/microbenchmark-analysis/1&quot;&gt;JSPerf tests are found here&lt;/a&gt;. And, the &lt;a href=&quot;http://jsben.ch/Ov6eJ&quot;&gt;jsben.ch testsare  found here&lt;/a&gt;. As you can see, there is a noticable difference when there should be none. If you are really a performance freak like me, then it might be more worth your while trying to reduce the number of variables and functions in the scope and especially eliminating polymorphism (such as using the same variable to store two different types).</source>
          <target state="translated">在Google的V8和Firefox的Spidermonkey中，可能会有几微秒的JIST编译差异，但最终结果是完全相同的。 为了证明这一点，让我们通过比较两个空白代码段的速度来检验JSPerf在微基准测试中的效率。 在&lt;a href=&quot;https://jsperf.com/microbenchmark-analysis/1&quot;&gt;此可以找到JSPerf测试&lt;/a&gt; 。 并且， &lt;a href=&quot;http://jsben.ch/Ov6eJ&quot;&gt;jsben.ch测试位于此处&lt;/a&gt; 。 如您所见，什么都不应该有明显的区别。 如果您确实像我一样是个性能怪胎，那么尝试减少范围中的变量和函数的数量，尤其是消除多态性（例如使用相同的变量存储两种不同的类型）时，可能更值得。</target>
        </trans-unit>
        <trans-unit id="77530f56c5b4887f097bf802c9364dfb9c6bf513" translate="yes" xml:space="preserve">
          <source>In JavaScript there are two ways to create functions:</source>
          <target state="translated">在JavaScript中,有两种方法来创建函数。</target>
        </trans-unit>
        <trans-unit id="743fad7b9f2b3005515bc6a8b41cc5305db6d16c" translate="yes" xml:space="preserve">
          <source>In a debugger you will clearly see the function name on the call stack instead of an &quot;anonymous/evaluated&quot; function.</source>
          <target state="translated">在调试器中,你会清楚地看到调用栈上的函数名称,而不是 &quot;匿名评估 &quot;函数。</target>
        </trans-unit>
        <trans-unit id="40ac26672752f4a573b68a025efd96f93c7cda1f" translate="yes" xml:space="preserve">
          <source>In above condition the function name is visible within its scope and the scope of its parent (otherwise it would be unreachable).</source>
          <target state="translated">在上述条件下,函数名称在其范围内和上级的范围内都是可见的(否则就无法到达)。</target>
        </trans-unit>
        <trans-unit id="1f5563a0832819a0b28ffe111ae45fd4c8971126" translate="yes" xml:space="preserve">
          <source>In both cases, the body of the function is just an expression; the function's return value will automatically be the result of that expression (you don't use an explicit &lt;code&gt;return&lt;/code&gt;).</source>
          <target state="translated">在这两种情况下，函数的主体都只是一个表达式； 该函数的返回值将自动是该表达式的结果（您无需使用显式的 &lt;code&gt;return&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d0c1580d80e84da99a8bb130ae769242b985147e" translate="yes" xml:space="preserve">
          <source>In computer science terms, we talk about anonymous functions and named functions. I think the most important difference is that an anonymous function is not bound to an name, hence the name anonymous function. In JavaScript it is a first class object dynamically declared at runtime.</source>
          <target state="translated">在计算机科学术语中,我们说的是匿名函数和命名函数。我认为最重要的区别在于匿名函数不绑定名称,因此有了匿名函数这个名字。在JavaScript中,它是一个在运行时动态声明的第一类对象。</target>
        </trans-unit>
        <trans-unit id="9ad24effba4df71940268999b683a278696da2a5" translate="yes" xml:space="preserve">
          <source>In light of the &quot;named functions show up in stack traces&quot; argument, modern JavaScript engines are actually quite capable of representing anonymous functions.</source>
          <target state="translated">鉴于 &quot;被命名的函数会在堆栈痕迹中出现 &quot;的说法,现代JavaScript引擎其实是相当有能力表示匿名函数的。</target>
        </trans-unit>
        <trans-unit id="bada26db6ba62d3b37fbfb0f8797580b37b425d5" translate="yes" xml:space="preserve">
          <source>In terms of code maintenance cost, named functions are more preferable:</source>
          <target state="translated">在代码维护成本方面,命名的功能更可取。</target>
        </trans-unit>
        <trans-unit id="0ab56e8403de5abcd245a223331dd74301ac39fd" translate="yes" xml:space="preserve">
          <source>In the example above we can do the same with an external name, but it'll be too unwieldy (and slower).</source>
          <target state="translated">在上面的例子中,我们可以用外部名称来做同样的事情,但是这样做会太不方便(而且速度会比较慢)。</target>
        </trans-unit>
        <trans-unit id="99565775fc2dc3442ac3db8b854377a4e1535255" translate="yes" xml:space="preserve">
          <source>In this case, both &lt;code&gt;xyz&lt;/code&gt; and &lt;code&gt;abc&lt;/code&gt; are aliases of the same object:</source>
          <target state="translated">在这种情况下， &lt;code&gt;xyz&lt;/code&gt; 和 &lt;code&gt;abc&lt;/code&gt; 都是同一对象的别名：</target>
        </trans-unit>
        <trans-unit id="f34745ad4ce35316a6c1a3f69ce6b5aa657af5a5" translate="yes" xml:space="preserve">
          <source>In this example &lt;code&gt;a&lt;/code&gt; is initialized with the function object resulting from evaluating the second function declaration, and then is assigned &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">在此示例中， &lt;code&gt;a&lt;/code&gt; 通过评估第二个函数声明得到的函数对象初始化a ，然后将其赋值为 &lt;code&gt;4&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="a5a8ada85e0dd38f6230fbd0de001e929f7a5ccb" translate="yes" xml:space="preserve">
          <source>Independent from the place where they are declared (but still limited by scope).</source>
          <target state="translated">独立于申报地(但仍受范围限制)。</target>
        </trans-unit>
        <trans-unit id="88d605e955dd6c957da2b10f658bd3437ef6a188" translate="yes" xml:space="preserve">
          <source>Interestingly, if we declare the variable as &lt;code&gt;function funcName(){}&lt;/code&gt;, then the immutability of the variable is the same as declaring it with &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">有趣的是，如果我们将变量声明为 &lt;code&gt;function funcName(){}&lt;/code&gt; ，则变量的不变性与使用 &lt;code&gt;var&lt;/code&gt; 声明变量相同。</target>
        </trans-unit>
        <trans-unit id="7cd8788595c6099fbc89a56b7505fbb8d78f9944" translate="yes" xml:space="preserve">
          <source>It is not safe to write function declarations in non-function blocks like &lt;strong&gt;if&lt;/strong&gt; because they won't be accessible.</source>
          <target state="translated">在非功能块中编写函数声明是不安全的，例如因为无法访问它们。</target>
        </trans-unit>
        <trans-unit id="66fbe41a46d13b3ec9ad6d15a6cbc7ebb0163825" translate="yes" xml:space="preserve">
          <source>JavaScript has first-class functions, that is, create a function and assign it to a variable just like you create a string or number and assign it to a variable. Here, the fn variable is assigned to a function. The reason for this concept is functions are objects in JavaScript; fn is pointing to the object instance of the above function. We have initialized a function and assigned it to a variable. It's not executing the function and assigning the result.</source>
          <target state="translated">JavaScript有一级函数,也就是说,创建一个函数并将其分配给一个变量,就像你创建一个字符串或数字并将其分配给一个变量一样。这里,fn变量被赋值给函数。之所以有这个概念,是因为函数是JavaScript中的对象;fn是指向上述函数的对象实例。我们已经初始化了一个函数,并将其赋值给了一个变量。它不是执行函数并分配结果。</target>
        </trans-unit>
        <trans-unit id="dc87314ad86194e07f204ed20a079cd40c0d7d92" translate="yes" xml:space="preserve">
          <source>JavaScript has three ways of defining functions.</source>
          <target state="translated">JavaScript有三种定义函数的方式。</target>
        </trans-unit>
        <trans-unit id="386881110fbc49ba4e9cbf28d7d0d56af3d005b0" translate="yes" xml:space="preserve">
          <source>JavaScript treats functions as first-class objects, so being an object, you can assign properties to a function.</source>
          <target state="translated">JavaScript将函数视为一阶对象,所以作为一个对象,可以给函数分配属性。</target>
        </trans-unit>
        <trans-unit id="b0771db0681dd1086ab043dd36cac9a035ed201d" translate="yes" xml:space="preserve">
          <source>Lastly, while the variable the function is assigned to initially sets the name, successive variables set to the function do not change the name.</source>
          <target state="translated">最后,虽然函数被分配到的变量最初设置了名称,但连续设置到该函数的变量不会改变名称。</target>
        </trans-unit>
        <trans-unit id="131c609e07fa46c90f8a914d0d9876618cb16ffa" translate="yes" xml:space="preserve">
          <source>Like all expressions, it's evaluated when it's reached in the step-by-step execution of the code.</source>
          <target state="translated">像所有的表达式一样,在代码的分步执行过程中,当它达到时,就会被评价。</target>
        </trans-unit>
        <trans-unit id="9047887da470d7120807196284dd5dbf0f775748" translate="yes" xml:space="preserve">
          <source>Method Declaration in Object Initializer (ES2015+)</source>
          <target state="translated">对象初始化器中的方法声明 (ES2015+)</target>
        </trans-unit>
        <trans-unit id="f6e8c432ab6e69fb5b19460ea3141b5206869a18" translate="yes" xml:space="preserve">
          <source>More resistant to mistakes like conditional initialization (you are still able to override if wanted to).</source>
          <target state="translated">更多的是抵制像条件初始化这样的错误(如果你想的话还是可以覆盖)。</target>
        </trans-unit>
        <trans-unit id="f0128c3077ca982c05c67d537afe75962bbc772f" translate="yes" xml:space="preserve">
          <source>Named &lt;code&gt;function&lt;/code&gt; Expression</source>
          <target state="translated">命名 &lt;code&gt;function&lt;/code&gt; 表达式</target>
        </trans-unit>
        <trans-unit id="777148d87c109971486523e49744c67e7e30f167" translate="yes" xml:space="preserve">
          <source>Named function expression like the one below, may not work in Internet&amp;nbsp;Explorer browsers prior to version 9.</source>
          <target state="translated">如下所示的命名函数表达式可能无法在版本9之前的Internet Explorer浏览器中工作。</target>
        </trans-unit>
        <trans-unit id="a2af52c0ccfa8c408328b7c06cce7ab9ec1d62fa" translate="yes" xml:space="preserve">
          <source>Named function expressions demystified</source>
          <target state="translated">命名函数表达式解密</target>
        </trans-unit>
        <trans-unit id="dc9e3d6fd9e9ce94aab3c1ef25f88d46b96264d9" translate="yes" xml:space="preserve">
          <source>New versions of &lt;code&gt;V8&lt;/code&gt; introduced several under-the-hood optimizations and so did &lt;code&gt;SpiderMonkey&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;V8&lt;/code&gt; 的新版本引入了一些 &lt;code&gt;SpiderMonkey&lt;/code&gt; 优化， SpiderMonkey也进行了优化。</target>
        </trans-unit>
        <trans-unit id="65bd7ea4a6bcc80835c2ec2b979fb00bb0f4c9ac" translate="yes" xml:space="preserve">
          <source>Nitro</source>
          <target state="translated">Nitro</target>
        </trans-unit>
        <trans-unit id="8110b79db7f83a1e8b4ca63a622ef7443e84ba94" translate="yes" xml:space="preserve">
          <source>Normal &lt;code&gt;function add(){}&lt;/code&gt;</source>
          <target state="translated">正常 &lt;code&gt;function add(){}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c5a68d9eef8721bfe6330530d6cdfda8dbcb430" translate="yes" xml:space="preserve">
          <source>Normal &lt;code&gt;var add=function(){}&lt;/code&gt;</source>
          <target state="translated">普通的 &lt;code&gt;var add=function(){}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f50d4d872d6f1fc0198387a8cbf12922732ec09a" translate="yes" xml:space="preserve">
          <source>Note that NFEs have frequently been a source of bugs for JavaScript implementations. IE8 and earlier, for instance, handle NFEs &lt;a href=&quot;http://blog.niftysnippets.org/2010/09/double-take.html&quot;&gt;completely incorrectly&lt;/a&gt;, creating two different functions at two different times. Early versions of Safari had issues as well. The good news is that current versions of browsers (IE9 and up, current Safari) don't have those issues any more. (But as of this writing, sadly, IE8 remains in widespread use, and so using NFEs with code for the web in general is still problematic.)</source>
          <target state="translated">请注意，NFE经常是JavaScript实现错误的来源。 例如，IE8和更早版本&lt;a href=&quot;http://blog.niftysnippets.org/2010/09/double-take.html&quot;&gt;完全&lt;/a&gt;无法正确处理NFE，从而在两个不同的时间创建了两个不同的功能。 Safari的早期版本也存在问题。 好消息是，当前版本的浏览器（IE9及更高版本，当前的Safari）不再存在这些问题。 （但是，在撰写本文时，令人遗憾的是，IE8仍在广泛使用，因此，将NFE与Web代码一起使用通常还是有问题的。）</target>
        </trans-unit>
        <trans-unit id="46c934ebb5c49a0e1a45001cc099b679e5fc9cba" translate="yes" xml:space="preserve">
          <source>Note that when I used the function, I didn't use &lt;code&gt;()&lt;/code&gt;! That's because it's an &lt;em&gt;accessor function&lt;/em&gt; for a property. We get and set the property in the normal way, but behind the scenes, the function is called.</source>
          <target state="translated">请注意，当我使用函数时，我没有使用 &lt;code&gt;()&lt;/code&gt; ！ 那是因为它是属性的&lt;em&gt;访问器函数&lt;/em&gt; 。 我们以常规方式获取并设置属性，但是在后台调用了该函数。</target>
        </trans-unit>
        <trans-unit id="b0135a3fe9edd1aa747c5dc00ef86223a2fba31b" translate="yes" xml:space="preserve">
          <source>Notice that the assignment portion of the declarations were not hoisted. Only the name is hoisted.</source>
          <target state="translated">注意到申报中的分配部分没有被挂起。只有名称被吊销了。</target>
        </trans-unit>
        <trans-unit id="bc114abbd8dd8a2cd0b954fda2e13a328089452b" translate="yes" xml:space="preserve">
          <source>On the second line we are assigning the reference of an anonymous function to functionOne.</source>
          <target state="translated">在第二行中,我们将一个匿名函数的引用分配给functionOne。</target>
        </trans-unit>
        <trans-unit id="8843a229a0f472ada31ba06061df9ac263f902f6" translate="yes" xml:space="preserve">
          <source>One compelling reason to use the combined style is the &quot;name&quot; attribute of function objects (&lt;strong&gt;not supported by Internet&amp;nbsp;Explorer&lt;/strong&gt;). Basically when you define a function like</source>
          <target state="translated">使用组合样式的一个令人信服的原因是功能对象的&amp;ldquo;名称&amp;rdquo;属性（ &lt;strong&gt;Internet Explorer不支持&lt;/strong&gt; ）。 基本上，当您定义类似</target>
        </trans-unit>
        <trans-unit id="dbe6fdfa55051d3eebbbe9fd39842bacd3d7cc72" translate="yes" xml:space="preserve">
          <source>Other commenters have already covered the semantic difference of the two variants above. I wanted to note a stylistic difference: Only the &quot;assignment&quot; variation can set a property of another object.</source>
          <target state="translated">其他评论者已经在上面讲到了这两种变体的语义差异。我想指出一个文体上的区别。只有 &quot;派生 &quot;变体才能设置另一个对象的属性。</target>
        </trans-unit>
        <trans-unit id="95fa44f122d0d2fde84daa10053c89ba105c1733" translate="yes" xml:space="preserve">
          <source>Otherwise, if a function is declared as &lt;code&gt;function(){}&lt;/code&gt;, the &lt;em&gt;function&lt;/em&gt;.name is the first variable used to store the function.</source>
          <target state="translated">否则，如果将一个函数声明为 &lt;code&gt;function(){}&lt;/code&gt; ，则&lt;em&gt;函数&lt;/em&gt; .name是用于存储该函数的第一个变量。</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="bcc6976fdb7b0bab8f43d0bd6a3d5c3f3f1f4418" translate="yes" xml:space="preserve">
          <source>Personally, I prefer the &quot;function expression&quot; declaration because this way I can control the visibility. When I define the function like</source>
          <target state="translated">就我个人而言,我更喜欢 &quot;函数表达式 &quot;声明,因为这样我可以控制可见性。当我定义函数的时候,比如</target>
        </trans-unit>
        <trans-unit id="48e539471552b322b96b629b50e168373aab581d" translate="yes" xml:space="preserve">
          <source>Reference: &lt;em&gt;&lt;a href=&quot;http://jkoder.com/javascript-function-declaration-syntax-var-fn-function-vs-function-fn/&quot;&gt;JavaScript function declaration syntax: var fn = function() {} vs function fn() {}&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">参考： &lt;em&gt;&lt;a href=&quot;http://jkoder.com/javascript-function-declaration-syntax-var-fn-function-vs-function-fn/&quot;&gt;JavaScript函数声明语法：var fn = function（）{} vs function fn（）{}&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2fa869913cd407b8374e8002710a8e37791c0a7c" translate="yes" xml:space="preserve">
          <source>Same function using function expressions:</source>
          <target state="translated">同样是使用函数表达式的函数。</target>
        </trans-unit>
        <trans-unit id="a342ddf70636f32b76e4ff5a5d52c5eb4e44afd7" translate="yes" xml:space="preserve">
          <source>Secondly, it is possible to combine both styles:</source>
          <target state="translated">其次,可以将这两种风格结合起来。</target>
        </trans-unit>
        <trans-unit id="8f28d3ab65fed240b09f7deb679e37f9272d4792" translate="yes" xml:space="preserve">
          <source>See that &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; thing hiding in the &lt;code&gt;map()&lt;/code&gt; call? That's a function.</source>
          <target state="translated">看到 &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; 隐藏在 &lt;code&gt;map()&lt;/code&gt; 调用中了吗？ 这是一个功能。</target>
        </trans-unit>
        <trans-unit id="26c0ca793e8f7074d3f8c82877440040dbf9523b" translate="yes" xml:space="preserve">
          <source>So</source>
          <target state="translated">So</target>
        </trans-unit>
        <trans-unit id="46c47815b690569dbb7a656b8964b6c4a2aec3eb" translate="yes" xml:space="preserve">
          <source>Some brandings require specific functions, and some do not. Sometimes I have to add new functions to do new branding-specific things. I am happy to change the shared coded, but I don't want to have to change all 160 sets of branding files.</source>
          <target state="translated">有的烙印需要特定的功能,有的则不需要。有时我必须添加新的功能来做新的烙印特定的事情。我很乐意改变共享代码,但我不想把160套烙印文件都改了。</target>
        </trans-unit>
        <trans-unit id="5f39892c489c20b210e85c99d0636ddca2f715ec" translate="yes" xml:space="preserve">
          <source>Some examples...</source>
          <target state="translated">一些例子.....</target>
        </trans-unit>
        <trans-unit id="48fe26184a1da0188c638e9837cd0348befd6fc9" translate="yes" xml:space="preserve">
          <source>Sometimes functions can sneak in largely unnoticed; that's the case with &lt;em&gt;accessor functions&lt;/em&gt;. Here's an example:</source>
          <target state="translated">有时，功能可能会在很大程度上被忽视。 &lt;em&gt;访问器函数&lt;/em&gt;就是这种情况。 这是一个例子：</target>
        </trans-unit>
        <trans-unit id="387053ec024b111c7ef9f523fd9328f604a02b3d" translate="yes" xml:space="preserve">
          <source>Speaking about the global context, both, the &lt;code&gt;var&lt;/code&gt; statement and a &lt;code&gt;FunctionDeclaration&lt;/code&gt; at the end will create a &lt;em&gt;non-deleteable&lt;/em&gt; property on the global object, but the value of both &lt;em&gt;can be overwritten&lt;/em&gt;.</source>
          <target state="translated">说到全局上下文，最后的 &lt;code&gt;var&lt;/code&gt; 语句和 &lt;code&gt;FunctionDeclaration&lt;/code&gt; 都会在全局对象上创建&lt;em&gt;不可删除的&lt;/em&gt;属性，但是两者的值都&lt;em&gt;可以被覆盖&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="f65122e6f32c2bcabdd432788ea598df5c48d617" translate="yes" xml:space="preserve">
          <source>SpiderMonkey</source>
          <target state="translated">SpiderMonkey</target>
        </trans-unit>
        <trans-unit id="c6651b9a96d11046277cfbcd116304f61f74227d" translate="yes" xml:space="preserve">
          <source>SpiderMonkey can figure out the name of an anonymous function returned from another function. The rest can't.</source>
          <target state="translated">SpiderMonkey可以算出从另一个函数返回的匿名函数的名字。其他的就不行了。</target>
        </trans-unit>
        <trans-unit id="0ae1828118a1782dda8e1ea5ac856c97b23cc230" translate="yes" xml:space="preserve">
          <source>Statement (such as &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;finally&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;)</source>
          <target state="translated">声明（例如， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;else&lt;/code&gt; ， &lt;code&gt;for&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; ， &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; / &lt;code&gt;finally&lt;/code&gt; ， &lt;code&gt;switch&lt;/code&gt; ， &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; ， &lt;code&gt;with&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="bc07256662906a0b6337c96a56729c6ca11dc5d1" translate="yes" xml:space="preserve">
          <source>Take a look at the function below:</source>
          <target state="translated">看一看下面的功能。</target>
        </trans-unit>
        <trans-unit id="ffdc12529405fd8a1fe177c00af6a4b1b34cbdf9" translate="yes" xml:space="preserve">
          <source>Terms:</source>
          <target state="translated">Terms:</target>
        </trans-unit>
        <trans-unit id="f63f70d99a4f81b8e70665fd22c3174d3eeca9cf" translate="yes" xml:space="preserve">
          <source>That also means that the method has a reference to the object it was defined on, so if that object is temporary (for instance, you're passing it into &lt;code&gt;Object.assign&lt;/code&gt; as one of the source objects), method syntax &lt;em&gt;could&lt;/em&gt; mean that the object is retained in memory when otherwise it could have been garbage collected (if the JavaScript engine doesn't detect that situation and handle it if none of the methods uses &lt;code&gt;super&lt;/code&gt;).</source>
          <target state="translated">这也意味着该方法引用了对其定义的对象，因此，如果该对象是临时的（例如，您将其作为源对象之一传递给 &lt;code&gt;Object.assign&lt;/code&gt; ），则方法语法&lt;em&gt;可能&lt;/em&gt;意味着否则可能会对其进行垃圾回收（如果JavaScript引擎未检测到这种情况并在没有方法使用 &lt;code&gt;super&lt;/code&gt; 的情况下进行处理），则将该对象保留在内存中。</target>
        </trans-unit>
        <trans-unit id="a48c26e1972ebb64b7dc5783e0fabcbb52b4ce7e" translate="yes" xml:space="preserve">
          <source>The &quot;nearest block&quot; is the nearest &quot;function,&quot; (including asynchronous functions, generator functions, and asynchronous generator functions). However, interestingly, a &lt;code&gt;function functionName() {}&lt;/code&gt; behaves like a &lt;code&gt;var functionName = function() {}&lt;/code&gt; when in a non-closure block to items outside said closure. Observe.</source>
          <target state="translated">&amp;ldquo;最近的块&amp;rdquo;是最接近的&amp;ldquo;函数&amp;rdquo;（包括异步函数，生成器函数和异步生成器函数）。 然而，有趣的是，当在非闭包块中， &lt;code&gt;function functionName() {}&lt;/code&gt; 行为类似于 &lt;code&gt;var functionName = function() {}&lt;/code&gt; 时，其行为类似于var 。 观察一下。</target>
        </trans-unit>
        <trans-unit id="6a595334c53b5e54513ecbf67288a1b96ade59c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; example above is one form of them. If you have multiple arguments to pass the function, you use parens:</source>
          <target state="translated">上面的 &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; 示例是它们的一种形式。 如果您有多个参数来传递函数，请使用parens：</target>
        </trans-unit>
        <trans-unit id="ac4e1750314827abdcc2556f83c85b9fddef454c" translate="yes" xml:space="preserve">
          <source>The above actually defines &lt;code&gt;functionThree&lt;/code&gt; irrespective of &lt;code&gt;test&lt;/code&gt;'s value &amp;mdash; unless &lt;code&gt;use strict&lt;/code&gt; is in effect, in which case it simply raises an error.</source>
          <target state="translated">上面实际上定义了 &lt;code&gt;functionThree&lt;/code&gt; ，与 &lt;code&gt;test&lt;/code&gt; 的值无关&amp;mdash;除非有效 &lt;code&gt;use strict&lt;/code&gt; ，否则在这种情况下，它只会引发错误。</target>
        </trans-unit>
        <trans-unit id="b568b255152259a00f6cba0e87f3825e038239ef" translate="yes" xml:space="preserve">
          <source>The above code is identical in functionality to the code below. Note that explicitly assigning &lt;code&gt;add = undefined&lt;/code&gt; is superfluous because simply doing &lt;code&gt;var add;&lt;/code&gt; is the exact same as &lt;code&gt;var add=undefined&lt;/code&gt;.</source>
          <target state="translated">上面的代码在功能上与下面的代码相同。 注意，显式分配 &lt;code&gt;add = undefined&lt;/code&gt; 是多余的，因为只需执行 &lt;code&gt;var add;&lt;/code&gt; 即可。 与 &lt;code&gt;var add=undefined&lt;/code&gt; 完全相同。</target>
        </trans-unit>
        <trans-unit id="61810b104f2efcb0e3da5ee583a0202c43770fb2" translate="yes" xml:space="preserve">
          <source>The assignment of the &lt;code&gt;bar&lt;/code&gt;&lt;code&gt;FunctionExpression&lt;/code&gt; takes place until runtime.</source>
          <target state="translated">&lt;code&gt;FunctionExpression&lt;/code&gt; 表达式 &lt;code&gt;bar&lt;/code&gt; 的分配一直进行到运行时。</target>
        </trans-unit>
        <trans-unit id="f5638e210194eb499ece9d9a4a930b2e74d062fc" translate="yes" xml:space="preserve">
          <source>The code becomes more readable by allocating local functions separately of scope functionality. Usually in the scope the functionality goes first, followed by declarations of local functions.</source>
          <target state="translated">通过将本地函数与作用域功能分开分配,代码变得更易读。通常情况下,在作用域中,首先是功能,其次是本地函数的声明。</target>
        </trans-unit>
        <trans-unit id="27d4da09d4c2ce032185baf978da0ab13a3001ed" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;functionOne&lt;/code&gt; is a function expression and so only defined when that line is reached, whereas &lt;code&gt;functionTwo&lt;/code&gt; is a function declaration and is defined as soon as its surrounding function or script is executed (due to &lt;a href=&quot;http://adripofjavascript.com/blog/drips/variable-and-function-hoisting.html&quot;&gt;hoisting&lt;/a&gt;).</source>
          <target state="translated">区别在于 &lt;code&gt;functionOne&lt;/code&gt; 是函数表达式，因此仅在到达该行时定义，而 &lt;code&gt;functionTwo&lt;/code&gt; 是函数声明，并在其周围的函数或脚本执行后（由于&lt;a href=&quot;http://adripofjavascript.com/blog/drips/variable-and-function-hoisting.html&quot;&gt;提升&lt;/a&gt; ）而定义。</target>
        </trans-unit>
        <trans-unit id="8f5ff0d27037b523b788758f94b98b0d9ae64dd6" translate="yes" xml:space="preserve">
          <source>The first case is of function expressions which loads only when the interpreter reaches that line of code. So if you do it like the following, you will get an error that the &lt;strong&gt;functionOne is not a function&lt;/strong&gt;.</source>
          <target state="translated">第一种情况是函数表达式，仅在解释器到达该行代码时才加载。 因此，如果您按照以下方式进行操作，则会收到错误消息，认为&lt;strong&gt;functionOne不是function&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="8c697eb723f616068919ff4ce595b6a84c5ced0b" translate="yes" xml:space="preserve">
          <source>The first example is a function declaration:</source>
          <target state="translated">第一个例子是一个函数声明。</target>
        </trans-unit>
        <trans-unit id="43835d99e780763836c24b4200a3754c5e808b94" translate="yes" xml:space="preserve">
          <source>The first form is a &lt;em&gt;function declaration&lt;/em&gt;, which looks like this:</source>
          <target state="translated">第一种形式是&lt;em&gt;函数声明&lt;/em&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="34f69ae86ca961522b085400da5ab180cee6f82c" translate="yes" xml:space="preserve">
          <source>The first one (function doSomething(x)) should be part of an object notation.</source>
          <target state="translated">第一个(函数doSomething(x))应该是对象符号的一部分。</target>
        </trans-unit>
        <trans-unit id="528c8b3507437f286d5dcd35417b22aae81be689" translate="yes" xml:space="preserve">
          <source>The following does not work because the &lt;code&gt;var add=&lt;/code&gt; superseeds the &lt;code&gt;function add()&lt;/code&gt;.</source>
          <target state="translated">由于 &lt;code&gt;var add=&lt;/code&gt; 取代了 &lt;code&gt;function add()&lt;/code&gt; 因此以下命令不起作用。</target>
        </trans-unit>
        <trans-unit id="d6593583ad3f05cea4dd2dbe710ed86ac6be34db" translate="yes" xml:space="preserve">
          <source>The following does not work because the variable is called before a function value is assigned to the variable &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">以下内容不起作用，因为在将函数值分配给变量 &lt;code&gt;add&lt;/code&gt; 之前调用了该变量。</target>
        </trans-unit>
        <trans-unit id="1c398e75b47d2fad865197a5e2b4b99f659ecf1b" translate="yes" xml:space="preserve">
          <source>The following works because &lt;code&gt;function add()&lt;/code&gt; is scoped to the nearest block:</source>
          <target state="translated">由于 &lt;code&gt;function add()&lt;/code&gt; 的作用域范围是最近的块，因此可以使用以下代码：</target>
        </trans-unit>
        <trans-unit id="12d135f5c480c68402b5ce8e6a0d8f062c40c5a2" translate="yes" xml:space="preserve">
          <source>The function statement is just a shorthand for &lt;code&gt;var&lt;/code&gt; statement with a &lt;code&gt;function&lt;/code&gt; value.</source>
          <target state="translated">函数语句只是带有 &lt;code&gt;function&lt;/code&gt; 值的 &lt;code&gt;var&lt;/code&gt; 语句的简写。</target>
        </trans-unit>
        <trans-unit id="aabbd15c1c1cbe57d1e6cc08682ca9493293312d" translate="yes" xml:space="preserve">
          <source>The function this creates has a proper name (&lt;code&gt;w&lt;/code&gt; in this case). Like all expressions, this is evaluated when it's reached in the step-by-step execution of the code. The name of the function is &lt;em&gt;not&lt;/em&gt; added to the scope in which the expression appears; the name &lt;em&gt;is&lt;/em&gt; in scope within the function itself:</source>
          <target state="translated">所创建的函数具有专有名称（在这种情况下为 &lt;code&gt;w&lt;/code&gt; ）。 像所有表达式一样，在逐步执行代码时会对其进行评估。 函数名称&lt;em&gt;不会&lt;/em&gt;添加到表达式出现的范围内； 名称在函数本身的范围内：</target>
        </trans-unit>
        <trans-unit id="ea448a50cd82447995b1eb947a60438076954bb9" translate="yes" xml:space="preserve">
          <source>The main difference is how they are hoisted (lifted and declared). In the first example, the whole function declaration is hoisted. In the second example only the var 'abc' is hoisted, its value (the function) will be undefined, and the function itself remains at the position that it is declared.</source>
          <target state="translated">主要区别在于它们是如何被提升(提升和声明)的。在第一个例子中,整个函数声明被提升。在第二个例子中,只有var 'abc'被举起,它的值(函数)将是未定义的,而函数本身则保持在它被声明的位置。</target>
        </trans-unit>
        <trans-unit id="4d055f6c1671742f4deaadc6161c80dec3e0bd32" translate="yes" xml:space="preserve">
          <source>The name of a function &lt;code&gt;function thefuncname(){}&lt;/code&gt; is &lt;em&gt;thefuncname&lt;/em&gt; when it is declared this way.</source>
          <target state="translated">以这种方式声明时，函数 &lt;code&gt;function thefuncname(){}&lt;/code&gt; 为&lt;em&gt;thefuncname&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="975e947bf74ec2c4a9220b91f85c32600f4c5554" translate="yes" xml:space="preserve">
          <source>The one or two brandings that need a specific implementation of the function can then define their version of the function and assign this to the variable if they want, and the rest do nothing. I can test for a null function before I execute it in the shared code.</source>
          <target state="translated">这时,需要特定函数实现的一两个烙印就可以定义自己版本的函数,如果他们愿意的话,可以把这个函数分配给变量,其他的人什么都不做。我可以在共享代码中执行函数之前,先测试一个空函数。</target>
        </trans-unit>
        <trans-unit id="145b15615e2d9998da1e6798d5ad4a398382a9d4" translate="yes" xml:space="preserve">
          <source>The order of hoisting is also important: function declarations take precedence over variable declarations with the same name, and the last function declaration takes precedence over previous function declarations with the same name.</source>
          <target state="translated">葫芦的顺序也很重要:函数声明优先于同名的变量声明,最后一个函数声明优先于前面同名的函数声明。</target>
        </trans-unit>
        <trans-unit id="9fbf6788e456c1009e4f21fffa2ea5165a3d9162" translate="yes" xml:space="preserve">
          <source>The previous developer used two ways of declaring functions and I can't work out if there is a reason behind it or not.</source>
          <target state="translated">之前的开发者用了两种方式来声明函数,我也搞不清楚背后是否有原因。</target>
        </trans-unit>
        <trans-unit id="9be3cbbcb4a077923846e6cabf5be834c36c4efe" translate="yes" xml:space="preserve">
          <source>The quick list:</source>
          <target state="translated">的快速清单。</target>
        </trans-unit>
        <trans-unit id="691d638de255d3f4d5c26aade899596c1cb5d318" translate="yes" xml:space="preserve">
          <source>The reason is that on the first line no value is assigned to functionOne, and hence it is undefined. We are trying to call it as a function, and hence we are getting an error.</source>
          <target state="translated">原因是在第一行中没有给functionOne赋值,因此它是未定义的。我们试图将其作为一个函数来调用,因此我们得到了一个错误。</target>
        </trans-unit>
        <trans-unit id="79805af7eecf09848f58c20a9be4bdd8d5d60b42" translate="yes" xml:space="preserve">
          <source>The rules for the loose modes are tricky, but in &lt;em&gt;strict&lt;/em&gt; mode, function declarations in blocks are easy: They're local to the block (they have &lt;em&gt;block scope&lt;/em&gt;, which is also new in ES2015), and they're hoisted to the top of the block. So:</source>
          <target state="translated">松散模式的规则很棘手，但是在&lt;em&gt;严格&lt;/em&gt;模式下，块中的函数声明很简单：它们在块中是本地的（它们具有&lt;em&gt;块作用域&lt;/em&gt; ，这在ES2015中也是新功能），并且被提升到顶部的块。 所以：</target>
        </trans-unit>
        <trans-unit id="662fa49d03ebc7b2aed8dd5f4b92c0902805a5f2" translate="yes" xml:space="preserve">
          <source>The second case is of function declarations that loads before any code is executed. So if you do like the following you won't get any error as the declaration loads before code execution.</source>
          <target state="translated">第二种情况是在执行任何代码之前加载的函数声明。因此,如果你做了下面这种情况,你不会得到任何错误,因为声明在代码执行前加载。</target>
        </trans-unit>
        <trans-unit id="488c70a0cd0c42493330d0fb21f56a76d5245310" translate="yes" xml:space="preserve">
          <source>The second common form is called an &lt;em&gt;anonymous function expression&lt;/em&gt;:</source>
          <target state="translated">第二种常见形式称为&lt;em&gt;匿名函数表达式&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="d485f7dbc6206bd93419673ad073a7290e1370dc" translate="yes" xml:space="preserve">
          <source>The second example is a function expression:</source>
          <target state="translated">第二个例子是一个函数表达式。</target>
        </trans-unit>
        <trans-unit id="8bf7ed47a49f0740aa28a7a24a1570e0b0a27a46" translate="yes" xml:space="preserve">
          <source>The second one (&lt;code&gt;var doSomething = function(x){ alert(x);}&lt;/code&gt;) is simply creating an anonymous function and assigning it to a variable, &lt;code&gt;doSomething&lt;/code&gt;. So doSomething() will call the function.</source>
          <target state="translated">第二个 &lt;code&gt;var doSomething = function(x){ alert(x);}&lt;/code&gt; （ var doSomething = function（x）{alert（x）;} ）只是创建一个匿名函数并将其分配给变量 &lt;code&gt;doSomething&lt;/code&gt; 。 因此doSomething（）将调用该函数。</target>
        </trans-unit>
        <trans-unit id="bb65ff5a5394939f644979347352ffd342603413" translate="yes" xml:space="preserve">
          <source>The subtle difference between the two ways is that when the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-10.1.3&quot;&gt;Variable Instantiation&lt;/a&gt; process runs (before the actual code execution) all identifiers declared with &lt;code&gt;var&lt;/code&gt; will be initialized with &lt;code&gt;undefined&lt;/code&gt;, and the ones used by the &lt;code&gt;FunctionDeclaration&lt;/code&gt;'s will be available since that moment, for example:</source>
          <target state="translated">两种方式之间的细微差别是，当&lt;a href=&quot;http://bclary.com/2004/11/07/#a-10.1.3&quot;&gt;变量实例化&lt;/a&gt;过程运行时（在实际代码执行之前），所有用 &lt;code&gt;var&lt;/code&gt; 声明的标识符都将使用 &lt;code&gt;undefined&lt;/code&gt; 初始化，并且从那一刻起， &lt;code&gt;FunctionDeclaration&lt;/code&gt; 所使用的标识符将可用，因为例：</target>
        </trans-unit>
        <trans-unit id="a07afd1ea9b12698990819eb8d76265cfe1ee004" translate="yes" xml:space="preserve">
          <source>The third form is a &lt;em&gt;named function expression&lt;/em&gt; (&quot;NFE&quot;):</source>
          <target state="translated">第三种形式是&lt;em&gt;命名函数表达式&lt;/em&gt; （&amp;ldquo; NFE&amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="f16969d6d2f696ede4918690b2fd4331ce87e1f7" translate="yes" xml:space="preserve">
          <source>The third way of defining a function is the &lt;strong&gt;&quot;Function()&quot; constructor&lt;/strong&gt;, which is not shown in your original post. It's not recommended to use this as it works the same way as &lt;code&gt;eval()&lt;/code&gt;, which has its problems.</source>
          <target state="translated">定义函数的第三种方法是&lt;strong&gt;&amp;ldquo; Function（）&amp;rdquo;构造函数&lt;/strong&gt; ，该函数未在原始文章中显示。 不建议使用此方法，因为它的工作方式与 &lt;code&gt;eval()&lt;/code&gt; 相同，但存在问题。</target>
        </trans-unit>
        <trans-unit id="b2aa94344341e29310102127f307a10790251ea2" translate="yes" xml:space="preserve">
          <source>The two code snippets you've posted there will, for almost all purposes, behave the same way.</source>
          <target state="translated">你在那里发布的两个代码片段,几乎所有的目的都是一样的。</target>
        </trans-unit>
        <trans-unit id="745bcd9fd12a96b9a791e445c3c8811fc1192e62" translate="yes" xml:space="preserve">
          <source>The two ways are:</source>
          <target state="translated">这两种方式是。</target>
        </trans-unit>
        <trans-unit id="474bce94d0bbf46c085c74728e63fac02ca4d442" translate="yes" xml:space="preserve">
          <source>The version without &lt;code&gt;{ ... }&lt;/code&gt; is called an arrow function with an &lt;em&gt;expression body&lt;/em&gt; or &lt;em&gt;concise body&lt;/em&gt;. (Also: A &lt;em&gt;concise&lt;/em&gt; arrow function.) The one with &lt;code&gt;{ ... }&lt;/code&gt; defining the body is an arrow function with a &lt;em&gt;function body&lt;/em&gt;. (Also: A &lt;em&gt;verbose&lt;/em&gt; arrow function.)</source>
          <target state="translated">没有 &lt;code&gt;{ ... }&lt;/code&gt; 的版本称为带有&lt;em&gt;表达式主体&lt;/em&gt;或&lt;em&gt;简洁主体&lt;/em&gt;的箭头函数。 （也： &lt;em&gt;简洁的&lt;/em&gt;箭头函数。）带有 &lt;code&gt;{ ... }&lt;/code&gt; 定义主体的函数是带有&lt;em&gt;函数body&lt;/em&gt;的箭头函数。 （还： &lt;em&gt;详细的&lt;/em&gt;箭头功能。）</target>
        </trans-unit>
        <trans-unit id="5e2ac0591f86093c00434254dcdbb41884337a4a" translate="yes" xml:space="preserve">
          <source>There are four noteworthy comparisons between the two different declarations of functions as listed below.</source>
          <target state="translated">在这两种不同的功能声明中,有以下四种值得注意的比较。</target>
        </trans-unit>
        <trans-unit id="ff3c75b5079b24e68e8e94930f5ee73dea969f6b" translate="yes" xml:space="preserve">
          <source>There are many techniques for namespacing. It's become more important with the plethora of JavaScript modules available.</source>
          <target state="translated">命名间距有很多技巧。随着大量的JavaScript模块的出现,它变得更加重要。</target>
        </trans-unit>
        <trans-unit id="bfb055384b731f9a401950a0d0ee5c9f80d9d7f9" translate="yes" xml:space="preserve">
          <source>There are two function declarations above: One for the constructor, which gets the name &lt;code&gt;Person&lt;/code&gt;, and one for &lt;code&gt;getFullName&lt;/code&gt;, which is a function assigned to &lt;code&gt;Person.prototype&lt;/code&gt;.</source>
          <target state="translated">上面有两个函数声明：一个用于构造函数，其名称为 &lt;code&gt;Person&lt;/code&gt; ，另一个用于 &lt;code&gt;getFullName&lt;/code&gt; ，其是分配给 &lt;code&gt;Person.prototype&lt;/code&gt; 的函数。</target>
        </trans-unit>
        <trans-unit id="c21e5ae9b0dbaf5c8a3a97fe0a19730e14b6d355" translate="yes" xml:space="preserve">
          <source>There is a difference however at &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; the function object is actually associated with its variable. This difference is due to the mechanism called &lt;em&gt;variable hoisting&lt;/em&gt; in JavaScript.</source>
          <target state="translated">但是，在功能对象实际与其变量相关联的&lt;em&gt;方式&lt;/em&gt;和&lt;em&gt;时间方面&lt;/em&gt;存在差异。 这种差异是由于JavaScript中称为&lt;em&gt;变量提升&lt;/em&gt;的机制引起的。</target>
        </trans-unit>
        <trans-unit id="06da7b97430b3e34f6c3267eaa4d35f03ac87eb2" translate="yes" xml:space="preserve">
          <source>There is almost no difference now between expression and declaration.</source>
          <target state="translated">现在表达和声明几乎没有什么区别了。</target>
        </trans-unit>
        <trans-unit id="f88a677f3e75a5ae4e3009a2066635b663011477" translate="yes" xml:space="preserve">
          <source>They are pretty similar with some small differences, first one is a variable which assigned to an anonymous function (Function Declaration) and second one is the normal way to create a function in JavaScript(Anonymous function Declaration), both has usage, cons and pros:</source>
          <target state="translated">两者有一些小的区别,前者是分配给匿名函数的变量(Function Declaration),后者是在JavaScript中创建函数的正常方式(匿名函数声明),两者都有用法、缺点和优点。</target>
        </trans-unit>
        <trans-unit id="12694bcfc3aa8628852e68a8a23a1b1ae5570a03" translate="yes" xml:space="preserve">
          <source>They don't have their own &lt;code&gt;this&lt;/code&gt;. Instead, they &lt;em&gt;close over&lt;/em&gt; the &lt;code&gt;this&lt;/code&gt; of the context where they're defined. (They also close over &lt;code&gt;arguments&lt;/code&gt; and, where relevant, &lt;code&gt;super&lt;/code&gt;.) This means that the &lt;code&gt;this&lt;/code&gt; within them is the same as the &lt;code&gt;this&lt;/code&gt; where they're created, and cannot be changed.</source>
          <target state="translated">他们没有自己的 &lt;code&gt;this&lt;/code&gt; 。 而是，它们在定义它们的上下文中&lt;em&gt;关闭&lt;/em&gt; 。 （它们还会关闭 &lt;code&gt;arguments&lt;/code&gt; 以及相关的 &lt;code&gt;super&lt;/code&gt; 。）这意味着它们中的 &lt;code&gt;this&lt;/code&gt; 与创建它们时的 &lt;code&gt;this&lt;/code&gt; 相同，并且无法更改。</target>
        </trans-unit>
        <trans-unit id="5d3eda8af03fd5bea6de534289810bbc9c0c9cc7" translate="yes" xml:space="preserve">
          <source>This also means you can't conditionally define functions using function declarations:</source>
          <target state="translated">这也意味着你不能有条件地使用函数声明定义函数。</target>
        </trans-unit>
        <trans-unit id="8c1789e53705ce3071d6843b82e294f18ddc1727" translate="yes" xml:space="preserve">
          <source>This is a function expression:</source>
          <target state="translated">这是一个函数表达式。</target>
        </trans-unit>
        <trans-unit id="effa2ad61076e82c01e857bf9f7b8d602fd31fd4" translate="yes" xml:space="preserve">
          <source>This is because during execution, it looks like:</source>
          <target state="translated">这是因为在执行过程中,看起来像。</target>
        </trans-unit>
        <trans-unit id="d1fec805ab98a0513f9b9fad3d3fe8b531e695be" translate="yes" xml:space="preserve">
          <source>This is because with the first variant, the function is assigned to the variable &lt;code&gt;foo&lt;/code&gt; at run time. In the second, the function is assigned to that identifier, &lt;code&gt;foo&lt;/code&gt;, at parse time.</source>
          <target state="translated">这是因为在第一个变量中，该函数在运行时分配给了变量 &lt;code&gt;foo&lt;/code&gt; 。 在第二个中，在解析时将函数分配给该标识符 &lt;code&gt;foo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="37da05445624fb3a9cad0979b5962a742fcfb61e" translate="yes" xml:space="preserve">
          <source>This is because, during execution, it looks like:-</source>
          <target state="translated">这是因为,在执行过程中,它看起来像:--。</target>
        </trans-unit>
        <trans-unit id="ac81e957d5a9edd9078b4cf183802d4b3a3c78b3" translate="yes" xml:space="preserve">
          <source>This is just two possible ways of declaring functions, and in the second way, you can use the function before declaration.</source>
          <target state="translated">这只是声明函数的两种可能方式,在第二种方式中,可以先用函数再声明。</target>
        </trans-unit>
        <trans-unit id="c8bf596e96383c7f8bf4dd936686e5dfce43757d" translate="yes" xml:space="preserve">
          <source>This is the normal way of calling a function in JavaScript, this function can be called before you even declare it as in JavaScript all functions get Hoisted, but if you have 'use strict' this won't Hoist as expected, it's a good way to call all normal functions which are not big in lines and neither are a  constructor function.</source>
          <target state="translated">这是JavaScript中调用函数的正常方式,这个函数可以在你还没有声明之前就被调用,因为在JavaScript中,所有的函数都会被Hoist,但如果你有'use strict',这就不会像预期的那样被Hoist,这是一个很好的方式,可以调用所有正常的函数,这些函数的行数不大,也不是构造函数。</target>
        </trans-unit>
        <trans-unit id="2b9c6d00ab6cdb468c41c536b9d5e12d359f8ad8" translate="yes" xml:space="preserve">
          <source>This is very basic, self-explanatory, used in many languages and standard across C family of languages. We declared a function defined it and executed it by calling it.</source>
          <target state="translated">这是非常基本的,不言自明,在很多语言中都有使用,也是整个C语言家族的标准。我们声明了一个函数,定义了它并通过调用它来执行。</target>
        </trans-unit>
        <trans-unit id="f369bab590b1ff70e9147bf580834bbc48507735" translate="yes" xml:space="preserve">
          <source>This means that code like this:</source>
          <target state="translated">这意味着,像这样的代码。</target>
        </trans-unit>
        <trans-unit id="a26f3ae40c34f7b11fe02427fe4fd04cac5639d4" translate="yes" xml:space="preserve">
          <source>To put it simply:</source>
          <target state="translated">简而言之。</target>
        </trans-unit>
        <trans-unit id="f8459b728f80ead940599b3ae8ca162ea21af9e0" translate="yes" xml:space="preserve">
          <source>To study more about this topic I strongly recommend you this
&lt;a href=&quot;http://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/#comment-43792&quot;&gt;link&lt;/a&gt;</source>
          <target state="translated">要研究有关此主题的更多信息，强烈建议您使用此&lt;a href=&quot;http://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/#comment-43792&quot;&gt;链接&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="408adc3e401c0d07ea40bc45f940121effd904fa" translate="yes" xml:space="preserve">
          <source>Until ES2015, the spec didn't cover what a JavaScript engine should do if you put a function declaration inside a control structure like &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc., like this:</source>
          <target state="translated">在ES2015之前，规范未涵盖将函数声明放入 &lt;code&gt;try&lt;/code&gt; ， &lt;code&gt;if&lt;/code&gt; ， &lt;code&gt;switch&lt;/code&gt; ， &lt;code&gt;while&lt;/code&gt; 等控件结构中时JavaScript引擎应该做什么，如下所示：</target>
        </trans-unit>
        <trans-unit id="b8b097d0eea0934533ba237923021e6a341048fe" translate="yes" xml:space="preserve">
          <source>V8</source>
          <target state="translated">V8</target>
        </trans-unit>
        <trans-unit id="6fd7aa0d712bf58b6bad496b57c728877860d1e0" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;foo&lt;/code&gt; is hoisted to the top of the function, initialized to &lt;code&gt;undefined&lt;/code&gt;, so that &lt;code&gt;!foo&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, so &lt;code&gt;foo&lt;/code&gt; is assigned &lt;code&gt;10&lt;/code&gt;. The &lt;code&gt;foo&lt;/code&gt; outside of &lt;code&gt;bar&lt;/code&gt;'s scope plays no role and is untouched.</source>
          <target state="translated">变量 &lt;code&gt;foo&lt;/code&gt; 提升到函数的顶部，初始化为 &lt;code&gt;undefined&lt;/code&gt; ，因此 &lt;code&gt;!foo&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，因此 &lt;code&gt;foo&lt;/code&gt; 分配为 &lt;code&gt;10&lt;/code&gt; 。 &lt;code&gt;bar&lt;/code&gt; 范围之外的 &lt;code&gt;foo&lt;/code&gt; 不起作用 ，并且未被更改。</target>
        </trans-unit>
        <trans-unit id="8532b2e0bf3f4150e5cd6a6e082f6757d298ae34" translate="yes" xml:space="preserve">
          <source>Variable Mutability</source>
          <target state="translated">可变突变性</target>
        </trans-unit>
        <trans-unit id="6884273afe88a4cbfbe80c00ade910f535b8b76e" translate="yes" xml:space="preserve">
          <source>What Is The &quot;Nearest Block&quot;</source>
          <target state="translated">什么是 &quot;最近的街区&quot;?</target>
        </trans-unit>
        <trans-unit id="3487cb56b52e80f80380f6ee61e6d28c17778b0a" translate="yes" xml:space="preserve">
          <source>What are the reasons for using these two different methods and what are the pros and cons of each? Is there anything that can be done with one method that can't be done with the other?</source>
          <target state="translated">使用这两种不同的方法有什么原因,各有什么优缺点?是否有一种方法可以做的事情是另一种方法做不到的?</target>
        </trans-unit>
        <trans-unit id="9e5d9650d7c2bdb693414377b37154902a354c34" translate="yes" xml:space="preserve">
          <source>What you should be knowing is that functions are actually objects in JavaScript; internally we have created an object for above function and given it a name called fn or the reference to the object is stored in fn. Functions are objects in JavaScript; an instance of function is actually an object instance.</source>
          <target state="translated">你应该知道的是,函数实际上是JavaScript中的对象;在内部我们为上面的函数创建了一个对象,并给它起了一个叫fn的名字,或者说这个对象的引用存储在fn中。函数是JavaScript中的对象,函数的实例实际上就是一个对象实例。</target>
        </trans-unit>
        <trans-unit id="cb3fb4dfbcf0fe94e2371e0b28eb0f6e2fcd530b" translate="yes" xml:space="preserve">
          <source>When a function declaration is hoisted, the function body &quot;follows&quot;
so when the function body is evaluated, the variable will immediately
be bound to a function object.</source>
          <target state="translated">当一个函数声明被吊起时,函数体 &quot;跟随&quot;,所以当函数体被评价时,变量将立即被绑定到函数对象上。</target>
        </trans-unit>
        <trans-unit id="e9cfe61cf1adcd8f0102a36d2e0c4d12c9ca5726" translate="yes" xml:space="preserve">
          <source>When a variable declaration is hoisted, the initialization does &lt;em&gt;not&lt;/em&gt;
follow, but is &quot;left behind&quot;. The variable is initialized to
&lt;code&gt;undefined&lt;/code&gt; at the start of the function body, and will be &lt;em&gt;assigned&lt;/em&gt;
a value at its original location in the code. (Actually, it will be assigned a value at &lt;em&gt;every&lt;/em&gt; location where a declaration of a variable with the same name occurs.)</source>
          <target state="translated">挂起变量声明后，初始化不会进行，而是&amp;ldquo;落后&amp;rdquo;。 该变量在函数体的开头被初始化为 &lt;code&gt;undefined&lt;/code&gt; ，并将在代码的原始位置被&lt;em&gt;分配&lt;/em&gt;一个值。 （实际上，将在&lt;em&gt;每个&lt;/em&gt;声明具有相同名称的变量的&lt;em&gt;每个&lt;/em&gt;位置分配一个值。）</target>
        </trans-unit>
        <trans-unit id="bbe884a06b13281930a6b1c98f9d9d94e458c3b6" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;var&lt;/code&gt; keyword to declare a variable, you can then reassign a different value to the variable like so.</source>
          <target state="translated">当使用 &lt;code&gt;var&lt;/code&gt; 关键字声明变量时，可以像这样将另一个值重新分配给该变量。</target>
        </trans-unit>
        <trans-unit id="958872366b05f9c9178f4030f046f9fcab17462f" translate="yes" xml:space="preserve">
          <source>Which expands further to:</source>
          <target state="translated">其中进一步扩大到:</target>
        </trans-unit>
        <trans-unit id="d86a5675cc6478e7030415aaa83cd72801292548" translate="yes" xml:space="preserve">
          <source>While</source>
          <target state="translated">While</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="ac5e0452023b3c19655f17b544a743b6316fff94" translate="yes" xml:space="preserve">
          <source>With an assignment, without the &lt;code&gt;var&lt;/code&gt; statement, if the referenced identifier is not found in the scope chain, it will become a &lt;em&gt;deleteable&lt;/em&gt; property of the global object.</source>
          <target state="translated">对于赋值，如果没有 &lt;code&gt;var&lt;/code&gt; 语句，如果在范围链中找不到引用的标识符，它将成为全局对象的&lt;em&gt;可删除&lt;/em&gt;属性。</target>
        </trans-unit>
        <trans-unit id="2992a94652f880688ca1ececd6fbd9dc7fb7c4a7" translate="yes" xml:space="preserve">
          <source>With the second variant (&lt;code&gt;function functionTwo()&lt;/code&gt;), the function is available to code that runs above where the function is declared.</source>
          <target state="translated">使用第二个变体（ &lt;code&gt;function functionTwo()&lt;/code&gt; ），该函数可用于在声明该函数上方运行的代码。</target>
        </trans-unit>
        <trans-unit id="b0d2d3e4c919cb16a2327e829924bc496bf26df9" translate="yes" xml:space="preserve">
          <source>With this pattern, your public functions will all use assignment, while your private functions use declaration.</source>
          <target state="translated">使用这种模式,你的公有函数将全部使用赋值,而私有函数使用声明。</target>
        </trans-unit>
        <trans-unit id="2f69161f94ccc52eed8d88eea3c10a5ed51531e9" translate="yes" xml:space="preserve">
          <source>You can also create accessor functions with &lt;code&gt;Object.defineProperty&lt;/code&gt;, &lt;code&gt;Object.defineProperties&lt;/code&gt;, and the lesser-known second argument to &lt;code&gt;Object.create&lt;/code&gt;.</source>
          <target state="translated">您还可以使用 &lt;code&gt;Object.defineProperty&lt;/code&gt; ， &lt;code&gt;Object.defineProperties&lt;/code&gt; 和鲜为人知的第二个 &lt;code&gt;Object.create&lt;/code&gt; 参数创建访问器函数。</target>
        </trans-unit>
        <trans-unit id="9a96fecb676cbe550b81abe5e501a476b1368603" translate="yes" xml:space="preserve">
          <source>You can check function declaration, expression test over different browser's using &lt;a href=&quot;http://jsperf.com/yashfunctions&quot;&gt;&lt;code&gt;jsperf Test Runner&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">您可以使用&lt;a href=&quot;http://jsperf.com/yashfunctions&quot;&gt; &lt;code&gt;jsperf Test Runner&lt;/code&gt; &lt;/a&gt;检查函数声明，通过不同浏览器的表达式测试</target>
        </trans-unit>
        <trans-unit id="f3ac05813abe982cb2026b6587a9d2cd9ba582c6" translate="yes" xml:space="preserve">
          <source>You may want to know what a &lt;em&gt;function declaration&lt;/em&gt; and &lt;em&gt;function expression&lt;/em&gt; is.</source>
          <target state="translated">您可能想知道什么是&lt;em&gt;函数声明&lt;/em&gt;和&lt;em&gt;函数表达式&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="2ec4b44222b42ad09c0dd93c4ce4013f9582d467" translate="yes" xml:space="preserve">
          <source>Your first snippet shows a &lt;strong&gt;function expression&lt;/strong&gt;. This involves using the &lt;em&gt;&quot;function&quot; operator&lt;/em&gt; to create a function - the result of that operator can be stored in any variable or object property. The function expression is powerful that way. The function expression is often called an &quot;anonymous function&quot;, because it does not have to have a name,</source>
          <target state="translated">您的第一个代码片段显示了一个&lt;strong&gt;函数表达式&lt;/strong&gt; 。 这涉及使用&lt;em&gt;&amp;ldquo;函数&amp;rdquo;运算符&lt;/em&gt;创建函数-该运算符的结果可以存储在任何变量或对象属性中。 这样函数表达式功能强大。 函数表达式通常称为&amp;ldquo;匿名函数&amp;rdquo;，因为它不必具有名称，</target>
        </trans-unit>
        <trans-unit id="266e022923f9faa5b3be37667e92ff1460681e19" translate="yes" xml:space="preserve">
          <source>Your second example is a &lt;strong&gt;function declaration&lt;/strong&gt;. This uses the &lt;em&gt;&quot;function&quot; statement&lt;/em&gt; to create a function. The function is made available at parse time and can be called anywhere in that scope. You can still store it in a variable or object property later.</source>
          <target state="translated">您的第二个示例是&lt;strong&gt;函数声明&lt;/strong&gt; 。 这使用&lt;em&gt;&amp;ldquo;功能&amp;rdquo;语句&lt;/em&gt;创建功能。 该函数在解析时可用，并且可以在该范围内的任何位置调用。 您以后仍然可以将其存储在变量或对象属性中。</target>
        </trans-unit>
        <trans-unit id="46e93c41a34284a718c071fa2d4c174a2bdd159c" translate="yes" xml:space="preserve">
          <source>and use that as a constructor as in</source>
          <target state="translated">并使用它作为构造函数,如</target>
        </trans-unit>
        <trans-unit id="766f2b9d16f389f8448bfe19b9e12c43e3b610f1" translate="yes" xml:space="preserve">
          <source>depends on the context and may leave you guessing where it is actually defined, especially in the case of &lt;code&gt;eval()&lt;/code&gt; &amp;mdash; the answer is: It depends on the browser.</source>
          <target state="translated">取决于上下文，并且可能让您猜测它的实际定义位置，尤其是在 &lt;code&gt;eval()&lt;/code&gt; 的情况下&amp;mdash;答案是：它取决于浏览器。</target>
        </trans-unit>
        <trans-unit id="9afe260f060bed6881cbee4dafbcfdde1b19a941" translate="yes" xml:space="preserve">
          <source>does the correct job of defining &lt;code&gt;myfunction&lt;/code&gt; only when &lt;code&gt;condition&lt;/code&gt; is met.</source>
          <target state="translated">仅在满足 &lt;code&gt;condition&lt;/code&gt; 时才能正确定义 &lt;code&gt;myfunction&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ad6a22cf9c1840cb2434e3d3948f70d3d82ff7a2" translate="yes" xml:space="preserve">
          <source>expands to</source>
          <target state="translated">扩大到</target>
        </trans-unit>
        <trans-unit id="c9fa53e3d56127fa9a0278359df87eedc39694e4" translate="yes" xml:space="preserve">
          <source>function Identifier ( FormalParameterList&lt;sub&gt;opt&lt;/sub&gt; ) { FunctionBody }</source>
          <target state="translated">函数标识符（FormalParameterList &lt;sub&gt;opt&lt;/sub&gt; ）{FunctionBody}</target>
        </trans-unit>
        <trans-unit id="c80babbe10672f1522783d610020c168a8871b0f" translate="yes" xml:space="preserve">
          <source>function Identifier&lt;sub&gt;opt&lt;/sub&gt; ( FormalParameterList&lt;sub&gt;opt&lt;/sub&gt; ) { FunctionBody }</source>
          <target state="translated">函数标识符&lt;sub&gt;opt&lt;/sub&gt; （FormalParameterList &lt;sub&gt;opt&lt;/sub&gt; ）{FunctionBody}</target>
        </trans-unit>
        <trans-unit id="1a09252eb586133790cfd10a652a02b91c3d110e" translate="yes" xml:space="preserve">
          <source>functions declared inside the function-block are hoisted to top of the block.</source>
          <target state="translated">在函数块中声明的函数被提升到块的顶部。</target>
        </trans-unit>
        <trans-unit id="ef76da7e287b143105e1345282bc04bcb536f6c4" translate="yes" xml:space="preserve">
          <source>functions declared inside the page are hoisted to top of the page having global access.</source>
          <target state="translated">页面内声明的函数被提升到全局访问的页面顶部。</target>
        </trans-unit>
        <trans-unit id="564e3512cbd2ca189843edd610d4d195314e3263" translate="yes" xml:space="preserve">
          <source>it is possible to retrieve the name of the constructor as a string with &lt;code&gt;two.constructor.name&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;two.constructor.name&lt;/code&gt; 作为字符串检索构造函数的名称。</target>
        </trans-unit>
        <trans-unit id="2700ec2ba6fe2751639ff097bd8f8d2aacff7db5" translate="yes" xml:space="preserve">
          <source>its name is automatically assigned. But when you define it like</source>
          <target state="translated">它的名字是自动分配的。但是,当你把它定义为</target>
        </trans-unit>
        <trans-unit id="17daac7101b762bf7ee434b07c08b0a4c8d7ce16" translate="yes" xml:space="preserve">
          <source>its name is empty &amp;mdash; we created an anonymous function and assigned it to some variable.</source>
          <target state="translated">它的名称为空-我们创建了一个匿名函数并将其分配给某个变量。</target>
        </trans-unit>
        <trans-unit id="c33715969df7ac0ddad9e0bddf3b744551593c8d" translate="yes" xml:space="preserve">
          <source>javascript interpreted as</source>
          <target state="translated">javascript解释为</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="a878ab0cab33cf7bc7bc8ef10d60b74ea374cd22" translate="yes" xml:space="preserve">
          <source>the almost-equivalent in ES5 and earlier would be:</source>
          <target state="translated">在ES5和更早的版本中几乎等同于:</target>
        </trans-unit>
        <trans-unit id="1f2ec344c7336412708c6074b118ba08228b6737" translate="yes" xml:space="preserve">
          <source>the difference (other than verbosity) is that a method can use &lt;code&gt;super&lt;/code&gt;, but a function cannot. So for instance, if you had an object that defined (say) &lt;code&gt;valueOf&lt;/code&gt; using method syntax, it could use &lt;code&gt;super.valueOf()&lt;/code&gt; to get the value &lt;code&gt;Object.prototype.valueOf&lt;/code&gt; would have returned (before presumably doing something else with it), whereas the ES5 version would have to do &lt;code&gt;Object.prototype.valueOf.call(this)&lt;/code&gt; instead.</source>
          <target state="translated">区别（除了冗长）是方法可以使用 &lt;code&gt;super&lt;/code&gt; ，而函数不能。 因此，举例来说，如果您有一个使用方法语法定义（例如） &lt;code&gt;valueOf&lt;/code&gt; 的对象，则它可以使用 &lt;code&gt;super.valueOf()&lt;/code&gt; 来获取值 &lt;code&gt;Object.prototype.valueOf&lt;/code&gt; 将返回（之前可能会对它进行其他操作），而ES5版本将不得不执行 &lt;code&gt;Object.prototype.valueOf.call(this)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b130f4fa2fdb9f1a6204a2dcd0028ce60730d038" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;one.constructor.name&lt;/code&gt; will not be defined. &lt;code&gt;Function.name&lt;/code&gt; is non-standard but is supported by Firefox, Chrome, other Webkit-derived browsers and IE 9+.</source>
          <target state="translated">那么将不会定义 &lt;code&gt;one.constructor.name&lt;/code&gt; 。 &lt;code&gt;Function.name&lt;/code&gt; 是非标准的，但受Firefox，Chrome，其他Webkit衍生的浏览器和IE 9+支持。</target>
        </trans-unit>
        <trans-unit id="db00dc47d2bcbaa5835214069da6b3a6be20e68a" translate="yes" xml:space="preserve">
          <source>var functionName = function() {} vs function functionName() {}</source>
          <target state="translated">var functionName=function(){}vs function functionName(){}</target>
        </trans-unit>
        <trans-unit id="855b18f663a06d0d7e20dd66c32870f4e2e7f8ff" translate="yes" xml:space="preserve">
          <source>variable's/Function's declared inside the page are global can access anywhere in that page.</source>
          <target state="translated">在页面内声明的变量的Function是全局的,可以在该页面的任何地方访问。</target>
        </trans-unit>
        <trans-unit id="d4bbf1fdfd223011ea728f2c0466d3a30c57347c" translate="yes" xml:space="preserve">
          <source>variable's/Functions declared inside the function are having local scope. means they are available/accessed inside the function body (scope), they are not available outside the function body.</source>
          <target state="translated">在函数内部声明的变量Functions具有本地范围,意味着它们在函数体(source)内可用,在函数体外不可用。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
