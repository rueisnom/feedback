<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/336859">
    <body>
      <group id="336859">
        <trans-unit id="759ade596a378339a3599da452aa422c31d07445" translate="yes" xml:space="preserve">
          <source>&quot;Anonymous&quot; &lt;code&gt;function&lt;/code&gt; Expression</source>
          <target state="translated">Выражение &amp;laquo;анонимная&amp;raquo; &lt;code&gt;function&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c513b3ca88a099b3024dc76dce26a4fc3fd75194" translate="yes" xml:space="preserve">
          <source>&quot;Anonymous&quot; &lt;code&gt;function&lt;/code&gt; Expression &lt;em&gt;(which despite the term, sometimes create functions with names)&lt;/em&gt;</source>
          <target state="translated">&amp;laquo;Анонимная&amp;raquo; &lt;code&gt;function&lt;/code&gt; Expression &lt;em&gt;(которая, несмотря на термин, иногда создает функции с именами)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a5faf09af21e3ee207861762a8a8fc90fff45652" translate="yes" xml:space="preserve">
          <source>(Note also that assignment should require a semicolon after the statement, while declaration prohibits it.)</source>
          <target state="translated">(Заметьте также,что присвоение должно требовать наличия точки с запятой после заявления,в то время как заявление запрещает это).</target>
        </trans-unit>
        <trans-unit id="624606f5ae627bc4f6dabd67b23d018b1256e5ee" translate="yes" xml:space="preserve">
          <source>(Remember that &lt;code&gt;Array#map&lt;/code&gt; passes the entry as the first argument, and the index as the second.)</source>
          <target state="translated">(Помните, что &lt;code&gt;Array#map&lt;/code&gt; передает запись в качестве первого аргумента, а индекс - в качестве второго.)</target>
        </trans-unit>
        <trans-unit id="a6c2457af43114c5ee77f6c6836420d7fa86f67e" translate="yes" xml:space="preserve">
          <source>, this definition of &lt;code&gt;myfunction&lt;/code&gt; will override any previous definition, since it will be done at parse-time.</source>
          <target state="translated">это определение &lt;code&gt;myfunction&lt;/code&gt; переопределит любое предыдущее определение, поскольку оно будет выполнено во время анализа.</target>
        </trans-unit>
        <trans-unit id="6ae78ea2e192017c2e6cecf189c9877327296eb4" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://ejohn.org/apps/learn/#13&quot;&gt;Tests fail when the original ninja object is removed.&lt;/a&gt; (page 13)</source>
          <target state="translated">&lt;a href=&quot;http://ejohn.org/apps/learn/#13&quot;&gt;Тесты не выполняются, когда оригинальный объект ниндзя удаляется.&lt;/a&gt; (страница 13)</target>
        </trans-unit>
        <trans-unit id="c9c4f8471c82ec45ea1185e07850a97d382be68f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://ejohn.org/apps/learn/#14&quot;&gt;If you name the function that will be called recursively, the tests will pass.&lt;/a&gt; (page 14)</source>
          <target state="translated">&lt;a href=&quot;http://ejohn.org/apps/learn/#14&quot;&gt;Если вы назовете функцию, которая будет вызываться рекурсивно, тесты пройдут.&lt;/a&gt; (страница 14)</target>
        </trans-unit>
        <trans-unit id="976105ab4e318e4ac55a458be9a6999ab9810e70" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-arrow-function-definitions-static-semantics-early-errors&quot;&gt;&lt;code&gt;ArrowFunction : ArrowParameters =&amp;gt; ConciseBody&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html#sec-arrow-function-definitions-static-semantics-early-errors&quot;&gt; &lt;code&gt;ArrowFunction : ArrowParameters =&amp;gt; ConciseBody&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49d146068ed625d5d7328105f5e36bab6f733a04" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/336868/2730064&quot;&gt;Greg's Answer&lt;/a&gt; is good enough, but I still would like to add something to it that I learned just now watching &lt;a href=&quot;https://en.wikipedia.org/wiki/Douglas_Crockford&quot;&gt;Douglas Crockford's&lt;/a&gt; videos.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/336868/2730064&quot;&gt;Ответ Грега&lt;/a&gt; достаточно хорош, но я все же хотел бы добавить к нему кое-что, чему научился только сейчас, просматривая видео &lt;a href=&quot;https://en.wikipedia.org/wiki/Douglas_Crockford&quot;&gt;Дугласа Крокфорда&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c6835d261dfeeb9aa6c128ca4439678deec43ae" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/26394/eugene-lazutkin&quot;&gt;@EugeneLazutkin&lt;/a&gt; gives an example where he &lt;a href=&quot;https://stackoverflow.com/a/338053/&quot;&gt;names an assigned function to be able to use &lt;code&gt;shortcut()&lt;/code&gt;&lt;/a&gt; as an internal reference to itself. &lt;a href=&quot;http://ejohn.org/&quot;&gt;John Resig&lt;/a&gt; gives another example - &lt;em&gt;copying a recursive function assigned to another object&lt;/em&gt; in his &lt;a href=&quot;http://ejohn.org/apps/learn/&quot;&gt;Learning Advanced Javascript&lt;/a&gt; tutorial. While assigning functions to properties isn't strictly the question here, I recommend actively trying the tutorial out - run the code by clicking the button in the upper right corner, and double click the code to edit to your liking.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/26394/eugene-lazutkin&quot;&gt;@EugeneLazutkin&lt;/a&gt; приводит пример, где он &lt;a href=&quot;https://stackoverflow.com/a/338053/&quot;&gt;называет назначенную функцию, чтобы иметь возможность использовать &lt;code&gt;shortcut()&lt;/code&gt; &lt;/a&gt; в качестве внутренней ссылки на себя. &lt;a href=&quot;http://ejohn.org/&quot;&gt;Джон Резиг&lt;/a&gt; приводит еще один пример - &lt;em&gt;копирование рекурсивной функции, назначенной другому объекту,&lt;/em&gt; в своем &lt;a href=&quot;http://ejohn.org/apps/learn/&quot;&gt;учебном&lt;/a&gt; пособии по Javascript для Learning Advanced . Хотя назначение функций свойствам здесь не является вопросом, я рекомендую активно попробовать учебник - запустите код, нажав кнопку в правом верхнем углу, и дважды щелкните код, чтобы изменить его по своему вкусу.</target>
        </trans-unit>
        <trans-unit id="7b0c22340550205afa033ace7d2728b4aad0f9f6" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Anonymous&lt;/code&gt; function expressions &lt;a href=&quot;https://jsperf.com/named-vs-anonymous-expressions&quot;&gt;appear to have better performance&lt;/a&gt;
  against &lt;code&gt;Named&lt;/code&gt; function expression.</source>
          <target state="translated">Выражения &lt;code&gt;Anonymous&lt;/code&gt; функций, &lt;a href=&quot;https://jsperf.com/named-vs-anonymous-expressions&quot;&gt;по-видимому, лучше&lt;/a&gt; работают с выражениями &lt;code&gt;Named&lt;/code&gt; функций.</target>
        </trans-unit>
        <trans-unit id="c96f22714847a8babc3882697bb6248bc8fde655" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;abc&lt;/code&gt; here is defined everywhere in the current scope:</source>
          <target state="translated">&lt;code&gt;abc&lt;/code&gt; здесь определяется везде в текущей области видимости:</target>
        </trans-unit>
        <trans-unit id="33da11fb99d15d78d5a520754cccc634c18cce28" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;new Function()&lt;/code&gt; can be used to pass the function's body in a string. And hence this can be used to create dynamic functions. Also passing the script without executing the script.</source>
          <target state="translated">&lt;code&gt;new Function()&lt;/code&gt; может использоваться для передачи тела функции в строку. И, следовательно, это может быть использовано для создания динамических функций. Также передача сценария без выполнения сценария.</target>
        </trans-unit>
        <trans-unit id="d921a21481f849741d142fe29c5ea098ea13f130" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xyz&lt;/code&gt; here is defined from the point of assignment:</source>
          <target state="translated">&lt;code&gt;xyz&lt;/code&gt; здесь определяется с точки назначения:</target>
        </trans-unit>
        <trans-unit id="f861ab5b26e3b088b115db80714f64319137c837" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;xyz&lt;/code&gt; is going to be defined as usual, &lt;code&gt;abc&lt;/code&gt; is undefined in all browsers but Internet&amp;nbsp;Explorer &amp;mdash; do not rely on it being defined. But it will be defined inside its body:</source>
          <target state="translated">&lt;code&gt;xyz&lt;/code&gt; будет определен как обычно, &lt;code&gt;abc&lt;/code&gt; не определен во всех браузерах, кроме Internet Explorer - не полагайтесь на его определение. Но это будет определено внутри его тела:</target>
        </trans-unit>
        <trans-unit id="0996d262b069210bf614fbe919b57e1dcbed7423" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(Another way to refer to itself is to use &lt;code&gt;arguments.callee&lt;/code&gt;, which is still relatively long, and not supported in the strict mode.)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;(Другой способ сослаться на себя - использовать &lt;code&gt;arguments.callee&lt;/code&gt; , который все еще относительно длинный и не поддерживается в строгом режиме.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d089b89c261d900b8d8ac6af9b57fdc04eb3614b" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(function)&lt;/em&gt;.name</source>
          <target state="translated">&lt;em&gt;(function)&lt;/em&gt;.name</target>
        </trans-unit>
        <trans-unit id="12f5dfe559b4186c923fded6e04fcd3ed6a3a0f6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;But in the case with function declarations, the entire function body will be hoisted as well&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;Но в случае с объявлениями функций также будет поднято все тело функции&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="4bba3d17467d019bf50243da72010e06e9c2c779" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Function assigned to variable Example:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Функция, назначенная переменной Пример:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="541cf619a3af25cde3b6df2217443cef1e854fc6" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;However, only the actual declarations are hoisted. by leaving assignments where they are.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Однако, только фактические декларации подняты.&lt;/em&gt; &lt;em&gt;оставляя задания там, где они есть.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="77f992d8ae7a03a56428e18ae9187411b99ffeca" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Javascript is called loosely typed language. Which means Javascript variables can hold value of any &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/7wkd9z69(v=vs.94).aspx&quot;&gt;Data-Type&lt;/a&gt;. Javascript automatically takes care of changing the variable-type based on the value/literal provided during runtime.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Javascript называется свободно типизированным языком.&lt;/em&gt; &lt;em&gt;Это означает, что переменные Javascript могут содержать значение любого типа &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/7wkd9z69(v=vs.94).aspx&quot;&gt;данных&lt;/a&gt; .&lt;/em&gt; &lt;em&gt;Javascript автоматически заботится об изменении типа переменной на основе значения / литерала, предоставленного во время выполнения.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e30fdc640add63f2972505e1f77a336d70750ed6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Function Expression&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. Выражение функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b2fd7065f9c16a465c2734b147eab3e80052db0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Function Declaration&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. Объявление функций&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1263cf84aad82d1a3af0dc6f1805903c828d3b71" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://www.sitepoint.com/back-to-basics-javascript-hoisting/&quot;&gt;Hoisting&lt;/a&gt;&lt;/strong&gt;&lt;em&gt;is the JavaScript interpreter&amp;rsquo;s action of moving all variable and function declarations to the top of the current scope.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://www.sitepoint.com/back-to-basics-javascript-hoisting/&quot;&gt;Подъем&lt;/a&gt;&lt;/strong&gt; &lt;em&gt;- это действие интерпретатора JavaScript по перемещению всех объявлений переменных и функций в начало текущей области видимости.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f8747b2198f82905e46a1dbab75b4c9e9d7cdf8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Variables&quot;&gt;Variable&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_types#Variables&quot;&gt;Variable&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1335367051d267cd116cce2e6c150c50e7bd97ce" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/a/45759444/5081877&quot;&gt;ES5 Constructor Function Classes&lt;/a&gt;: Function objects created using Function.prototype.bind&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/a/45759444/5081877&quot;&gt;Классы функций конструктора ES5&lt;/a&gt; : объекты функций, созданные с использованием Function.prototype.bind&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="370b180b017647cca99bd02f7e986cfc2b8fde8f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;About performance:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;О производительности:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0fe5a78a445808092f814ad102d2a04ac9fb2f93" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Chrome 62.0.3202&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Chrome 62.0.3202&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2dae75490d4f79450f13d95e95c5513055074b89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Chrome Canary 63.0.3225&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Хром Канарейка 63.0.3225&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f8466249d1be58422b099d51dfe0e1f8cc0d6448" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;FireFox 55&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;FireFox 55&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="19552d8c7b704459a1b16248ad256dc0c0139741" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Firefox&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;Chrome Canary&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;Chrome&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Firefox&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;Chrome Канарейка&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;Хром&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="58c08f0bbcc6004dd7cb688f6907939c10e640b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES2015&lt;/strong&gt;: &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript 2015&lt;/a&gt; (also known as &quot;ES6&quot;)</source>
          <target state="translated">&lt;strong&gt;ES2015&lt;/strong&gt; : &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/index.html&quot;&gt;ECMAScript 2015&lt;/a&gt; (также известный как &amp;laquo;ES6&amp;raquo;)</target>
        </trans-unit>
        <trans-unit id="eccd9ae887601fcaf5c02293700ed6d0c8b205db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES5&lt;/strong&gt;: &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript 5th edition&lt;/a&gt;, 2009</source>
          <target state="translated">&lt;strong&gt;ES5&lt;/strong&gt; : &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/&quot;&gt;ECMAScript 5-е издание&lt;/a&gt; , 2009</target>
        </trans-unit>
        <trans-unit id="1ec7544bfadafd964172ff845f75d06fbafca512" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function Declaration&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Объявление функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="469a2d465d6d3686feebc839c5b59f7f7284c5c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function Expression&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Выражение функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1a6cbedbfde0d5779de0a3fcf412af63bdea4f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function declarations&lt;/strong&gt; are faster, and that's what really matters in web dev right? ;)</source>
          <target state="translated">&lt;strong&gt;Объявления функций&lt;/strong&gt; быстрее, и вот что действительно имеет значение в Web Dev, верно? ;)</target>
        </trans-unit>
        <trans-unit id="f6569a24239dbe2b55280c9506730daaf0a33e79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function expression:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Функциональное выражение:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="586c2626c76ccfb4558d9e83014f345dd1382003" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function statement:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Функциональное утверждение:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="936746e12db1da44d0d71d56ca5aafef2816cddd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Function&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4b3af9f83ea8d3b337e7d7b746f4759ca51365d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More technical information&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Больше технической информации&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="99755834340590f1e6358b23e87882e9a22abad2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: This answer has been merged from &lt;a href=&quot;https://stackoverflow.com/questions/3435709/why-are-functions-in-javascript-set-to-global-variables-instead-of-plain-function&quot;&gt;another question&lt;/a&gt;, in which the major doubt and misconception from the OP was that identifiers declared with a &lt;code&gt;FunctionDeclaration&lt;/code&gt;, couldn't be overwritten which is not the case.</source>
          <target state="translated">&lt;strong&gt;Примечание&lt;/strong&gt; . Этот ответ был объединен с &lt;a href=&quot;https://stackoverflow.com/questions/3435709/why-are-functions-in-javascript-set-to-global-variables-instead-of-plain-function&quot;&gt;другим вопросом&lt;/a&gt; , в котором основным сомнением и неправильным представлением OP было то, что идентификаторы, объявленные с помощью &lt;code&gt;FunctionDeclaration&lt;/code&gt; , не могли быть перезаписаны, что не соответствует действительности.</target>
        </trans-unit>
        <trans-unit id="6a630a0d47ae66e4b85b0b41819338abf93e312a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why no error? We were always taught that expressions are executed from top to bottom(??)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Почему нет ошибки?&lt;/strong&gt; &lt;strong&gt;Нас всегда учили, что выражения выполняются сверху вниз (??)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e98f3eda3b4182b03fb95ad990fb05e68273244" translate="yes" xml:space="preserve">
          <source>A Function Declaration defines a named function variable without
  requiring variable assignment. Function Declarations occur as
  standalone constructs and cannot be nested within non-function blocks.
  It&amp;rsquo;s helpful to think of them as siblings of Variable Declarations.
  Just as Variable Declarations must start with &amp;ldquo;var&amp;rdquo;, Function
  Declarations must begin with &amp;ldquo;function&amp;rdquo;.</source>
          <target state="translated">Объявление функции определяет именованную переменную функции без необходимости назначения переменной. Объявления функций выполняются как отдельные конструкции и не могут быть вложены в нефункциональные блоки. Полезно думать о них как о родственных братьях объявлений переменных. Так же, как объявления переменных должны начинаться с &amp;laquo;var&amp;raquo;, объявления функций должны начинаться с &amp;laquo;function&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="e05d42878c1cb04c0e530b3d07925d7a26e19963" translate="yes" xml:space="preserve">
          <source>A Function Expression defines a function as a part of a larger
  expression syntax (typically a variable assignment ). Functions
  defined via Functions Expressions can be named or anonymous. Function
  Expressions must not start with &amp;ldquo;function&amp;rdquo; (hence the parentheses
  around the self invoking example below).</source>
          <target state="translated">Выражение функции определяет функцию как часть более крупного синтаксиса выражения (обычно присваивание переменной). Функции, определенные с помощью функций Выражения могут быть именованными или анонимными. Выражения функций не должны начинаться с &amp;laquo;function&amp;raquo; (отсюда круглые скобки вокруг примера самовывоза ниже).</target>
        </trans-unit>
        <trans-unit id="86c7d8de9fcbc249405893d86e8bf42e97cb3dc8" translate="yes" xml:space="preserve">
          <source>A better explanation to &lt;a href=&quot;https://stackoverflow.com/a/336868/2351696&quot;&gt;Greg's answer&lt;/a&gt;</source>
          <target state="translated">Лучшее объяснение &lt;a href=&quot;https://stackoverflow.com/a/336868/2351696&quot;&gt;ответа Грега&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6ca6b62f63765f6b37e6981c3fed49c39887418d" translate="yes" xml:space="preserve">
          <source>A couple of things about arrow functions:</source>
          <target state="translated">Пара вещей о функциях стрелок:</target>
        </trans-unit>
        <trans-unit id="ba0bdb333e496781fbc28d1e1f11621acc2fdcab" translate="yes" xml:space="preserve">
          <source>A function declaration and a function expression assigned to a variable behave the same once the binding is established.</source>
          <target state="translated">Объявление функции и выражение функции,присвоенное переменной,ведут себя одинаково после установления привязки.</target>
        </trans-unit>
        <trans-unit id="586bbbe275e196b61f2bc269fbbcbefbe2f755d3" translate="yes" xml:space="preserve">
          <source>A function declaration can be placed anywhere in the code. Even if it is invoked before the definition appears in code, it gets executed as function declaration is committed to memory or in a way it is hoisted up, before any other code in the page starts execution.</source>
          <target state="translated">Декларация функции может быть размещена в любом месте кода.Даже если она вызывается до того,как определение появится в коде,она будет выполнена,так как объявление функции зафиксировано в памяти или каким-то образом подсоединено,до того,как начнётся выполнение любого другого кода на странице.</target>
        </trans-unit>
        <trans-unit id="fe52a62968b799ba8d3437f69fe7e179496e354b" translate="yes" xml:space="preserve">
          <source>A function declaration defines a named function variable without requiring variable assignment. Function declarations occur as standalone constructs and cannot be nested within non-function blocks.</source>
          <target state="translated">Декларация функции определяет именованную переменную функции,не требуя ее присвоения.Декларации функций возникают как отдельные конструкции и не могут быть вложены в нефункциональные блоки.</target>
        </trans-unit>
        <trans-unit id="dffe6e21959b36399921690a083098ea3f43b751" translate="yes" xml:space="preserve">
          <source>A function declaration is a &lt;em&gt;declaration&lt;/em&gt;; it's not a statement or expression. As such, you don't follow it with a &lt;code&gt;;&lt;/code&gt; (although doing so is harmless).</source>
          <target state="translated">Объявление функции - это &lt;em&gt;объявление&lt;/em&gt; ; это не утверждение или выражение. Таким образом, вы не следуете за ним с &lt;code&gt;;&lt;/code&gt; (хотя это безвредно).</target>
        </trans-unit>
        <trans-unit id="c4b8b821c2b59fa8045994d19ff4ed224c59880d" translate="yes" xml:space="preserve">
          <source>A function declaration is processed when execution enters the context in which it appears, &lt;strong&gt;before&lt;/strong&gt; any step-by-step code is executed. The function it creates is given a proper name (&lt;code&gt;x&lt;/code&gt; in the example above), and that name is put in the scope in which the declaration appears.</source>
          <target state="translated">Объявление функции обрабатывается, когда выполнение входит в контекст, в котором оно появляется, &lt;strong&gt;перед выполнением&lt;/strong&gt; любого пошагового кода. Создаваемой ей функции присваивается собственное имя ( &lt;code&gt;x&lt;/code&gt; в приведенном выше примере), и это имя помещается в область, в которой появляется объявление.</target>
        </trans-unit>
        <trans-unit id="6da90f6adb068378f7bee811147f83784b13cd26" translate="yes" xml:space="preserve">
          <source>A function expression defines a function as a part of a larger expression syntax (typically a variable assignment ). Functions defined via functions expressions can be named or anonymous. Function expressions should not start with &amp;ldquo;function&amp;rdquo;.</source>
          <target state="translated">Выражение функции определяет функцию как часть более крупного синтаксиса выражения (обычно присваивание переменной). Функции, определенные через выражения функций, могут быть именованными или анонимными. Выражения функций не должны начинаться с &amp;laquo;function&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d1a8159e77618cdd4843f0dd77192ef3cc619005" translate="yes" xml:space="preserve">
          <source>A function expression, if not defined before calling it, will result in an error. Also, here the function definition itself is not moved to the top or committed to memory like in the function declarations. But the variable to which we assign the function gets hoisted up and &lt;strong&gt;undefined&lt;/strong&gt; gets assigned to it.</source>
          <target state="translated">Выражение функции, если оно не определено перед вызовом, приведет к ошибке. Кроме того, здесь само определение функции не перемещается наверх и не фиксируется в памяти, как в объявлениях функций. Но переменная, которой мы назначаем функцию, поднимается, и ей назначается &lt;strong&gt;неопределенная&lt;/strong&gt; функция.</target>
        </trans-unit>
        <trans-unit id="1e474c78af8f1973b4e36a580194a43c560f1983" translate="yes" xml:space="preserve">
          <source>A global property created by a &lt;code&gt;FunctionDeclaration&lt;/code&gt; can be overwritten without any problems just like a variable value, e.g.:</source>
          <target state="translated">Глобальное свойство, созданное &lt;code&gt;FunctionDeclaration&lt;/code&gt; , может быть без проблем перезаписано, как и значение переменной, например:</target>
        </trans-unit>
        <trans-unit id="16985658b3a31ca6aeffc5a5893a992a5e8008b3" translate="yes" xml:space="preserve">
          <source>A must read:</source>
          <target state="translated">А должен прочитать:</target>
        </trans-unit>
        <trans-unit id="e868506d981fb5c0f6384bf8996fdae27caec377" translate="yes" xml:space="preserve">
          <source>About your edited first example (&lt;code&gt;foo = function() { alert('hello!'); };&lt;/code&gt;), it is an undeclared assignment, I would highly encourage you to always use the &lt;code&gt;var&lt;/code&gt; keyword.</source>
          <target state="translated">Что касается вашего отредактированного первого примера ( &lt;code&gt;foo = function() { alert('hello!'); };&lt;/code&gt; ), Это необъявленное назначение, я настоятельно рекомендую вам всегда использовать ключевое слово &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3eb314099eec1e9d7c9302b330fab0de04e4d5a0" translate="yes" xml:space="preserve">
          <source>Accessor Function Initializer (ES5+)</source>
          <target state="translated">Инициализатор функции аксессуара (ES5+)</target>
        </trans-unit>
        <trans-unit id="5e996e3eab307a7b71ac3432752e7fdfb923a820" translate="yes" xml:space="preserve">
          <source>Also see &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/881515/&quot;&gt;How do I declare a namespace in JavaScript?&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">Также смотрите &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/881515/&quot;&gt;Как мне объявить пространство имен в JavaScript?&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0da3dc3f13523455887513be16fc6b61206dd05d" translate="yes" xml:space="preserve">
          <source>Also, if you need more info about how hoisting works in JavaScript, visit the link below:</source>
          <target state="translated">Также,если вам нужна дополнительная информация о том,как работает подъемник на JavaScript,перейдите по ссылке ниже:</target>
        </trans-unit>
        <trans-unit id="14a4adf4af3f12e24e5839d70532eff9bbc83168" translate="yes" xml:space="preserve">
          <source>Also, it hoisted through a &lt;code&gt;return&lt;/code&gt; statement:</source>
          <target state="translated">Кроме того, он поднял через выражение &lt;code&gt;return&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="83c03304952acf14e910695cd06f40d8b9fbbec0" translate="yes" xml:space="preserve">
          <source>Also, undeclared assignments throw a &lt;code&gt;ReferenceError&lt;/code&gt; on ECMAScript 5 under &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/&quot;&gt;Strict Mode&lt;/a&gt;.</source>
          <target state="translated">Кроме того, необъявленные назначения генерируют &lt;code&gt;ReferenceError&lt;/code&gt; в ECMAScript 5 в &lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es5-chapter-2-strict-mode/&quot;&gt;строгом режиме&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d69902d08f0a65094ca17202194440fc3b8aeba6" translate="yes" xml:space="preserve">
          <source>Although doing this wasn't &lt;em&gt;specified&lt;/em&gt; until ES2015, it was an &lt;em&gt;allowable extension&lt;/em&gt; to support function declarations in blocks. Unfortunately (and inevitably), different engines did different things.</source>
          <target state="translated">Хотя это не было &lt;em&gt;указано&lt;/em&gt; до ES2015, это было &lt;em&gt;допустимое расширение&lt;/em&gt; для поддержки объявлений функций в блоках. К сожалению (и неизбежно), разные двигатели делали разные вещи.</target>
        </trans-unit>
        <trans-unit id="711467f315de312047766526b3669d8afe66dbf2" translate="yes" xml:space="preserve">
          <source>An illustration of when to prefer the first method to the second one is when you need to avoid overriding a function's previous definitions.</source>
          <target state="translated">Иллюстрация того,когда следует отдавать предпочтение первому методу перед вторым,это когда необходимо избежать переопределения предыдущих определений функции.</target>
        </trans-unit>
        <trans-unit id="76e9af881baea20b41dca7056be9ed2866b3110e" translate="yes" xml:space="preserve">
          <source>An important reason is to add one and only one variable as the &quot;Root&quot; of your namespace...</source>
          <target state="translated">Важной причиной является добавление одной и только одной переменной в качестве &quot;корня&quot; вашего пространства имен...</target>
        </trans-unit>
        <trans-unit id="22aee645613b4be0feeee7c7d21978392526a1f5" translate="yes" xml:space="preserve">
          <source>And in a function expression</source>
          <target state="translated">И в выражении функции</target>
        </trans-unit>
        <trans-unit id="72c0421ee623967b8daecf32d64a58d316428622" translate="yes" xml:space="preserve">
          <source>And since they're processed &lt;em&gt;before&lt;/em&gt; step-by-step code is run, it's tricky to know what to do when they're in a control structure.</source>
          <target state="translated">И поскольку они обрабатываются &lt;em&gt;до&lt;/em&gt; запуска пошагового кода, сложно знать, что делать, когда они находятся в структуре управления.</target>
        </trans-unit>
        <trans-unit id="721e0aa2d182321c9728514141b079a49fc8d164" translate="yes" xml:space="preserve">
          <source>And they are both hoisted to the top of the code.</source>
          <target state="translated">И они оба подняты на вершину кода.</target>
        </trans-unit>
        <trans-unit id="b8e93f2352a63f2f8ea04ce03020224e5e66bb84" translate="yes" xml:space="preserve">
          <source>And, a function declaration:</source>
          <target state="translated">И,декларация функций:</target>
        </trans-unit>
        <trans-unit id="4c5054856e4bbef19e96d760e5ea9c34ecb00648" translate="yes" xml:space="preserve">
          <source>Another difference that is not mentioned in the other answers is that if you use the anonymous function</source>
          <target state="translated">Другое отличие,которое не упоминается в других ответах,заключается в том,что если вы используете анонимную функцию</target>
        </trans-unit>
        <trans-unit id="af3890af81c2b6252d1f34cfdef6f3003e49e4ce" translate="yes" xml:space="preserve">
          <source>Another good reason to use the combined style is to use a short internal name to refer to itself, while providing a long non-conflicting name for external users:</source>
          <target state="translated">Другой веской причиной использования комбинированного стиля является использование короткого внутреннего имени для обозначения себя,в то же время предоставляя длинное не противоречащее друг другу имя для внешних пользователей:</target>
        </trans-unit>
        <trans-unit id="edcabfa9c012840526618d1e04748f8c28cb2838" translate="yes" xml:space="preserve">
          <source>Another obvious difference between your two examples is that the first function doesn't have a name, but the second has it, which can be really useful when debugging (i.e. inspecting a call stack).</source>
          <target state="translated">Другое очевидное различие между двумя примерами заключается в том,что первая функция не имеет имени,а вторая имеет его,что может быть очень полезно при отладке (т.е.проверке стека вызовов).</target>
        </trans-unit>
        <trans-unit id="78b91f70d93cc43865f21e88db633ffc080cd555" translate="yes" xml:space="preserve">
          <source>Arrow Function Expression (ES2015+)</source>
          <target state="translated">Выражение функции стрелки (ES2015+)</target>
        </trans-unit>
        <trans-unit id="95d9a52f48570a30b4afc03ec08d2692f827518e" translate="yes" xml:space="preserve">
          <source>Arrow Function Expression (ES2015+) &lt;em&gt;(which, like anonymous function expressions, don't involve an explicit name, and yet can create functions with names)&lt;/em&gt;</source>
          <target state="translated">Выражение функции стрелки (ES2015 +) &lt;em&gt;(которое, как и выражения анонимной функции, не содержит явного имени и может создавать функции с именами)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd53a48e43711dae9eac565fec3530c9b4ee1e47" translate="yes" xml:space="preserve">
          <source>Arrow Function With &lt;code&gt;function add()&lt;/code&gt;</source>
          <target state="translated">Функция стрелки с &lt;code&gt;function add()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f99e80bb8fac409e2d6527343847643ed0c3e39" translate="yes" xml:space="preserve">
          <source>Arrow Function with &lt;code&gt;var add=function()&lt;/code&gt;</source>
          <target state="translated">Стрелка Функция с &lt;code&gt;var add=function()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f70eea3b7a6f694be6cb95f16c6f6793125caccc" translate="yes" xml:space="preserve">
          <source>As of ES2015, the specification says what to do. In fact, it gives three separate things to do:</source>
          <target state="translated">Начиная с ES2015,в спецификации указано,что делать.Фактически,она дает три отдельные вещи,которые необходимо сделать:</target>
        </trans-unit>
        <trans-unit id="1d02938e3888244803072ebfb20246bbdc0d0b95" translate="yes" xml:space="preserve">
          <source>As of this writing, V8, SpiderMonkey, Chakra and Nitro always refer to named functions by their names. They almost always refer to an anonymous function by its identifier if it has one.</source>
          <target state="translated">На момент написания этой статьи V8,SpiderMonkey,Chakra и Nitro всегда ссылаются на именованные функции по своим именам.Они почти всегда ссылаются на анонимную функцию по ее идентификатору,если у нее есть такая функция.</target>
        </trans-unit>
        <trans-unit id="1b720c9c8412003b175b355c56b4ee5db0224dd0" translate="yes" xml:space="preserve">
          <source>As you'll have noticed with the above, you don't use the keyword &lt;code&gt;function&lt;/code&gt;; instead, you use &lt;code&gt;=&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Как вы заметили выше, вы не используете &lt;code&gt;function&lt;/code&gt; ключевого слова; вместо этого вы используете &lt;code&gt;=&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4999f76b7eca3d345d9076570ce3eedb86bebb2" translate="yes" xml:space="preserve">
          <source>Assign a variable to a function, means no Hoisting, as we know functions in JavaScript can Hoist, means they can be called before they get declared, while variables need to be declared before getting access to them, so means in this case we can not access the function before where it's declared, also it could be a way that you write your functions, for the functions which return another function, this kind of declaration could make sense, also in ECMA6 &amp;amp; above you can assign this to an arrow function which can be used to call anonymous functions, also this way of declaring is a better way to create Constructor functions in JavaScript.</source>
          <target state="translated">Присвоение переменной функции означает, что никакой Hoisting, поскольку мы знаем, что функции в JavaScript могут Hoist, означает, что они могут быть вызваны до того, как они будут объявлены, в то время как переменные должны быть объявлены до получения доступа к ним, поэтому в этом случае мы не можем доступ к функции до того, как она объявлена, также это может быть способ написания ваших функций, для функций, которые возвращают другую функцию, такое объявление может иметь смысл, также в ECMA6 и выше вы можете назначить это функции стрелки, которая может использоваться для вызова анонимных функций, также этот способ объявления является лучшим способом создания функций конструктора в JavaScript.</target>
        </trans-unit>
        <trans-unit id="7d6674bc9982ef481387f57cc83fdf356448f020" translate="yes" xml:space="preserve">
          <source>Availability (scope) of the function</source>
          <target state="translated">Наличие (объем)функции</target>
        </trans-unit>
        <trans-unit id="cb3c67b40dd1ec42a7ebb8e4fedcdde942976905" translate="yes" xml:space="preserve">
          <source>Basically, all function declarations and variable declarations are hoisted to the top of the &lt;em&gt;function&lt;/em&gt; in which the declaration occurs (this is why we say that JavaScript has &lt;em&gt;function scope&lt;/em&gt;).</source>
          <target state="translated">По сути, все объявления функций и объявления переменных поднимаются на вершину &lt;em&gt;функции,&lt;/em&gt; в которой происходит объявление (именно поэтому мы говорим, что JavaScript имеет &lt;em&gt;область действия функции&lt;/em&gt; ).</target>
        </trans-unit>
        <trans-unit id="1c04286e0850fd4e09d7efcea4b60ed58c2b3685" translate="yes" xml:space="preserve">
          <source>Because it's processed before any step-by-step code in the same context, you can do things like this:</source>
          <target state="translated">Поскольку он обрабатывается перед любым пошаговым кодом в том же контексте,вы можете делать такие вещи:</target>
        </trans-unit>
        <trans-unit id="13805085132e2a3520de22c522cbe8f65c7afc62" translate="yes" xml:space="preserve">
          <source>Because:</source>
          <target state="translated">Because:</target>
        </trans-unit>
        <trans-unit id="7aebd6867188b491049a61eb4878f8609a152162" translate="yes" xml:space="preserve">
          <source>Both are different ways of defining a function. The difference is how the browser interprets and loads them into an execution context.</source>
          <target state="translated">Оба способа определения функции различны.Разница заключается в том,как браузер интерпретирует и загружает их в контекст исполнения.</target>
        </trans-unit>
        <trans-unit id="c5ff3cd407987df1124c03fe7e85c5b0571cb3f8" translate="yes" xml:space="preserve">
          <source>But for the most part it's not worth stressing over.</source>
          <target state="translated">Но по большей части не стоит напрягаться.</target>
        </trans-unit>
        <trans-unit id="ecc7ba886c1a06ff3f510f80143a980ada742eea" translate="yes" xml:space="preserve">
          <source>By using the variable syntax, I can declare the variable (a function pointer essentially) in the shared code and either assign a trivial stub function, or set to null.</source>
          <target state="translated">Используя синтаксис переменной,я могу объявить переменную (по сути,указатель функции)в общем коде и либо назначить тривиальную функцию заглушки,либо установить ее значение равным нулю.</target>
        </trans-unit>
        <trans-unit id="2fa0d12e3977b9cdaebbd95bbb5c680f6ef8533a" translate="yes" xml:space="preserve">
          <source>Chakra</source>
          <target state="translated">Chakra</target>
        </trans-unit>
        <trans-unit id="bec230d90facfd5f91e7a3f68902d847f6c654f2" translate="yes" xml:space="preserve">
          <source>Constructor and Method Declarations in &lt;code&gt;class&lt;/code&gt; (ES2015+)</source>
          <target state="translated">Объявления конструктора и метода в &lt;code&gt;class&lt;/code&gt; (ES2015 +)</target>
        </trans-unit>
        <trans-unit id="2d08fdf2a8fb1f957e679f1a7a3412c536fd3dc4" translate="yes" xml:space="preserve">
          <source>Deep down, JavaScript treats both statements differently. This is a function declaration:</source>
          <target state="translated">В глубине души JavaScript по-разному относится к обоим утверждениям.Это декларация функций:</target>
        </trans-unit>
        <trans-unit id="63a844213d874b8b245c742695b7941db276a173" translate="yes" xml:space="preserve">
          <source>Default return value of function is '&lt;a href=&quot;https://javascriptweblog.wordpress.com/2010/08/16/understanding-undefined-and-preventing-referenceerrors/&quot;&gt;undefined&lt;/a&gt;', &lt;a href=&quot;http://javascript.info/tutorial/variables-and-statements&quot;&gt;Variable&lt;/a&gt; declaration default value also 'undefined'</source>
          <target state="translated">Возвращаемое значение функции по умолчанию: &amp;laquo; &lt;a href=&quot;https://javascriptweblog.wordpress.com/2010/08/16/understanding-undefined-and-preventing-referenceerrors/&quot;&gt;undefined&lt;/a&gt; &amp;raquo;, значение объявления &lt;a href=&quot;http://javascript.info/tutorial/variables-and-statements&quot;&gt;переменной по&lt;/a&gt; умолчанию также &amp;laquo;undefined&amp;raquo;</target>
        </trans-unit>
        <trans-unit id="64b93c79b512c36d99999e6e34357c9f1c087aa9" translate="yes" xml:space="preserve">
          <source>ECMA 5 (13.0) defines the syntax as</source>
          <target state="translated">ECMA 5 (13.0)определяет синтаксис как</target>
        </trans-unit>
        <trans-unit id="c150af269e5f4c4642804ca24c299f530d6bf24b" translate="yes" xml:space="preserve">
          <source>ES2015 allows a shorter form of declaring a property that references a function called a &lt;em&gt;method definition&lt;/em&gt;; it looks like this:</source>
          <target state="translated">ES2015 допускает более короткую форму объявления свойства, которое ссылается на функцию, называемую &lt;em&gt;определением метода&lt;/em&gt; ; это выглядит так:</target>
        </trans-unit>
        <trans-unit id="b28d4620b46f9904b783e4bdca73dea8f4634eab" translate="yes" xml:space="preserve">
          <source>ES2015 brings us &lt;code&gt;class&lt;/code&gt; syntax, including declared constructors and methods:</source>
          <target state="translated">ES2015 предоставляет нам синтаксис &lt;code&gt;class&lt;/code&gt; , включая объявленные конструкторы и методы:</target>
        </trans-unit>
        <trans-unit id="9d20a8f701915abdc4215ec73ca7a058aff15f27" translate="yes" xml:space="preserve">
          <source>ES2015 brings us the &lt;em&gt;arrow function&lt;/em&gt;. Here's one example:</source>
          <target state="translated">ES2015 приносит нам &lt;em&gt;функцию стрелки&lt;/em&gt; . Вот один пример:</target>
        </trans-unit>
        <trans-unit id="ac6212e9887dd3f14ce21d75177f4b2bcc5e3df2" translate="yes" xml:space="preserve">
          <source>ES6 introduced &lt;strong&gt;Arrow function&lt;/strong&gt;: An arrow function expression has a shorter syntax, they are best suited for non-method functions, and they cannot be used as constructors.</source>
          <target state="translated">В ES6 появилась &lt;strong&gt;функция Arrow&lt;/strong&gt; : выражение функции стрелки имеет более короткий синтаксис, они лучше всего подходят для функций, не относящихся к методам, и их нельзя использовать в качестве конструкторов.</target>
        </trans-unit>
        <trans-unit id="49a81d8fe89a66107237159e2c32f647ebe45e02" translate="yes" xml:space="preserve">
          <source>Examples from the tutorial: recursive calls in &lt;code&gt;yell()&lt;/code&gt;:</source>
          <target state="translated">Примеры из учебника: рекурсивные вызовы в &lt;code&gt;yell()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="30e5c50747f8ddc02fafa95f11253e401b5d26e4" translate="yes" xml:space="preserve">
          <source>First I want to correct Greg: &lt;code&gt;function abc(){}&lt;/code&gt; is scoped too &amp;mdash; the name &lt;code&gt;abc&lt;/code&gt; is defined in the scope where this definition is encountered. Example:</source>
          <target state="translated">Сначала я хочу исправить Грег: &lt;code&gt;function abc(){}&lt;/code&gt; тоже ограничена - имя &lt;code&gt;abc&lt;/code&gt; определено в области, где встречается это определение. Пример:</target>
        </trans-unit>
        <trans-unit id="63aa696e0203f17e821cd16409f715c884085a35" translate="yes" xml:space="preserve">
          <source>For example, a function expression:</source>
          <target state="translated">Например,выражение функции:</target>
        </trans-unit>
        <trans-unit id="d83df8cc10813d6eb9d49ec11d81159959f3b35b" translate="yes" xml:space="preserve">
          <source>For more information on anonymous functions and lambda calculus, Wikipedia is a good start (&lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;http://en.wikipedia.org/wiki/Anonymous_function&lt;/a&gt;).</source>
          <target state="translated">Для получения дополнительной информации об анонимных функциях и лямбда-исчислении Википедия является хорошим началом ( &lt;a href=&quot;http://en.wikipedia.org/wiki/Anonymous_function&quot;&gt;http://en.wikipedia.org/wiki/Anonymous_function&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="710381e12b95a3fe66706dfb40babc24d6b8e1bb" translate="yes" xml:space="preserve">
          <source>From people's comments above, I gather it may be possible to redefine a static function too, but I think the variable solution is nice and clear.</source>
          <target state="translated">Из приведенных выше комментариев людей я понял,что статическую функцию тоже можно переопределить,но мне кажется,что решение переменной-это хорошо и понятно.</target>
        </trans-unit>
        <trans-unit id="69181d045b415910120ca08053987e69c74ffe57" translate="yes" xml:space="preserve">
          <source>Fun fact:</source>
          <target state="translated">Забавный факт:</target>
        </trans-unit>
        <trans-unit id="f1e410ad1472b42cb42cc98962428637290b6706" translate="yes" xml:space="preserve">
          <source>Function</source>
          <target state="translated">Function</target>
        </trans-unit>
        <trans-unit id="79f7a2b842722c439a637899094a3e9b975d2161" translate="yes" xml:space="preserve">
          <source>Function Declaration</source>
          <target state="translated">Декларация о функции</target>
        </trans-unit>
        <trans-unit id="fea3337acc300eb0d59bb99072b521bda997c9a8" translate="yes" xml:space="preserve">
          <source>Function declaration vs. function expression is the real reason why there is a difference demonstrated by Greg.</source>
          <target state="translated">Объявление функции в сравнении с выражением функции является реальной причиной,по которой Грэг продемонстрировал разницу.</target>
        </trans-unit>
        <trans-unit id="2581d19bd1414397aab6c9d732c76b5beb72bc8d" translate="yes" xml:space="preserve">
          <source>Function declaration:</source>
          <target state="translated">Декларация функций:</target>
        </trans-unit>
        <trans-unit id="5d4b965bdff51520668a82710d188ad4c6d2847b" translate="yes" xml:space="preserve">
          <source>Function declarations and variable declarations are always moved (&lt;code&gt;hoisted&lt;/code&gt;) invisibly to the top of their containing scope by the JavaScript interpreter. Function parameters and language-defined names are, obviously, already there. &lt;a href=&quot;http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting&quot;&gt;ben cherry&lt;/a&gt;</source>
          <target state="translated">Декларации функций и объявления переменных всегда незаметно перемещаются ( &lt;code&gt;hoisted&lt;/code&gt; ) в верхнюю часть их содержащей области действия интерпретатором JavaScript. Параметры функций и определяемые языком имена, очевидно, уже есть. &lt;a href=&quot;http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting&quot;&gt;Бен Черри&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f30da0007535208b5211e526a05c262a2237a322" translate="yes" xml:space="preserve">
          <source>Function declarations take precedence over variable declarations, and the last function declaration &quot;sticks&quot;.</source>
          <target state="translated">Декларации функций имеют приоритет над декларациями переменных,и последняя декларация функции &quot;падает&quot;.</target>
        </trans-unit>
        <trans-unit id="9c2da209e9a31c47ddfe63c4563f794fa8b30376" translate="yes" xml:space="preserve">
          <source>Function expression &lt;a href=&quot;https://jsperf.com/fdeclaration-vs-fexpression&quot;&gt;appears to be faster&lt;/a&gt; now.</source>
          <target state="translated">Выражение функции теперь &lt;a href=&quot;https://jsperf.com/fdeclaration-vs-fexpression&quot;&gt;выглядит быстрее&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b76f36a30041319319253d18b6823f5c3562c4aa" translate="yes" xml:space="preserve">
          <source>Function expression:</source>
          <target state="translated">Выражение функций:</target>
        </trans-unit>
        <trans-unit id="a1ac0ca8c05d1c35307dcd8c89a858da945ba8b7" translate="yes" xml:space="preserve">
          <source>Harness (&lt;a href=&quot;http://jsfiddle.net/us9dg6y8/&quot;&gt;Fiddle&lt;/a&gt;)</source>
          <target state="translated">Жгут ( &lt;a href=&quot;http://jsfiddle.net/us9dg6y8/&quot;&gt;Скрипка&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a3e7d8a4d91ccb31d5aba99a1030f3258cd6aa3d" translate="yes" xml:space="preserve">
          <source>Here the function declaration is hoisted first, declaring and initializing variable &lt;code&gt;a&lt;/code&gt;. Next, this variable is assigned &lt;code&gt;10&lt;/code&gt;. In other words: the assignment does not assign to outer variable &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Здесь объявление функции сначала поднимается, объявляя и инициализируя переменную &lt;code&gt;a&lt;/code&gt; . Далее этой переменной присваивается &lt;code&gt;10&lt;/code&gt; . Другими словами: присваивание не присваивается внешней переменной &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4f1cbe2358cd472b9d4c788b3633f57ec1400c8" translate="yes" xml:space="preserve">
          <source>Here's the rundown on the standard forms that create functions: &lt;em&gt;(Originally written for another question, but adapted after being moved into the canonical question.)&lt;/em&gt;</source>
          <target state="translated">Вот краткое изложение стандартных форм, которые создают функции: &lt;em&gt;(Первоначально написано для другого вопроса, но адаптировано после перемещения в канонический вопрос.)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a9862412fbf3fc6c7bb7d8129f2f818be0d11455" translate="yes" xml:space="preserve">
          <source>Historically, anonymous functions appeared from the inability of JavaScript as a language to list members with named functions:</source>
          <target state="translated">Исторически сложилось так,что анонимные функции появились из-за неспособности JavaScript как языка перечислять членов с именованными функциями:</target>
        </trans-unit>
        <trans-unit id="16c223be40fd7052aab965a0fd6c87c593532cd4" translate="yes" xml:space="preserve">
          <source>However, the difference in behaviour is that with the first variant (&lt;code&gt;var functionOne = function() {}&lt;/code&gt;), that function can only be called after that point in the code.</source>
          <target state="translated">Однако различие в поведении заключается в том, что в первом варианте ( &lt;code&gt;var functionOne = function() {}&lt;/code&gt; ) эта функция может вызываться только после этой точки в коде.</target>
        </trans-unit>
        <trans-unit id="88718800ef1385d4eba64028d144aab14b067313" translate="yes" xml:space="preserve">
          <source>However, when we use the const-statement, the variable reference becomes immutable. This means that we cannot assign a new value to the variable. Please note, however, that this does not make the contents of the variable immutable: if you do &lt;code&gt;const arr = []&lt;/code&gt;, then you can still do &lt;code&gt;arr[10] = &quot;example&quot;&lt;/code&gt;. Only doing something like &lt;code&gt;arr = &quot;new value&quot;&lt;/code&gt; or &lt;code&gt;arr = []&lt;/code&gt; would throw an error as seen below.</source>
          <target state="translated">Однако когда мы используем оператор const, ссылка на переменную становится неизменной. Это означает, что мы не можем присвоить новое значение переменной. Обратите внимание, однако, что это не делает содержимое переменной неизменным: если вы делаете &lt;code&gt;const arr = []&lt;/code&gt; , то вы все равно можете сделать &lt;code&gt;arr[10] = &quot;example&quot;&lt;/code&gt; . Только выполнение чего-то вроде &lt;code&gt;arr = &quot;new value&quot;&lt;/code&gt; или &lt;code&gt;arr = []&lt;/code&gt; приведет к ошибке, как показано ниже.</target>
        </trans-unit>
        <trans-unit id="448a69f6cf1fb712be3c91a06ea26cc7b2a58c9d" translate="yes" xml:space="preserve">
          <source>I have code that I need to run with 160 independently-designed brandings. Most of the code is in shared files, but branding-specific stuff is in a separate file, one for each branding.</source>
          <target state="translated">У меня есть код,который мне нужно запустить с 160 независимо разработанными брендами.Большая часть кода находится в общих файлах,но специфические для брендинга вещи находятся в отдельном файле,по одному для каждого брендинга.</target>
        </trans-unit>
        <trans-unit id="f2caaf00ea49d3671a16112cd64e966f2b9b42f1" translate="yes" xml:space="preserve">
          <source>I know that I defined it globally providing that I didn't define &lt;code&gt;abc&lt;/code&gt; anywhere in the chain of scopes. This style of definition is resilient even when used inside &lt;code&gt;eval()&lt;/code&gt;. While the definition</source>
          <target state="translated">Я знаю, что я определил это глобально, при условии, что я не определил &lt;code&gt;abc&lt;/code&gt; нигде в цепочке областей. Этот стиль определения устойчив, даже когда используется внутри &lt;code&gt;eval()&lt;/code&gt; . Хотя определение</target>
        </trans-unit>
        <trans-unit id="bc5e1bfae37a8f9624f4cf6c70c888ec885a6199" translate="yes" xml:space="preserve">
          <source>I know that I defined the function locally. When I define the function like</source>
          <target state="translated">Я знаю,что я определил функцию локально.Когда я определяю функцию как</target>
        </trans-unit>
        <trans-unit id="fc40ffc8273deb922d6a2d5a6d75d6a7f097e7f5" translate="yes" xml:space="preserve">
          <source>I often build JavaScript modules with a pattern like this:</source>
          <target state="translated">Я часто собираю JavaScript-модули с таким шаблоном:</target>
        </trans-unit>
        <trans-unit id="52bb913d96e6cf1bb8f9c9868ed46fa2682d02e2" translate="yes" xml:space="preserve">
          <source>I suspect more PROS for named functions are follow. And what is listed as an advantage of named functions is a disadvantage for anonymous ones.</source>
          <target state="translated">Я подозреваю,что больше PROS для именованных функций следуют.И то,что перечислено как преимущество именованных функций,является недостатком для анонимных.</target>
        </trans-unit>
        <trans-unit id="48459bd949db4fd197340d3c07b4f6d46bda103c" translate="yes" xml:space="preserve">
          <source>I use the variable approach in my code for a very specific reason, the theory of which has been covered in an abstract way above, but an example might help some people like me, with limited JavaScript expertise.</source>
          <target state="translated">Я использую переменный подход в своем коде по очень специфической причине,теория которой была рассмотрена абстрактно выше,но пример может помочь некоторым людям,таким как я,с ограниченным опытом работы с JavaScript.</target>
        </trans-unit>
        <trans-unit id="a720e3aa194c1f4744a62a098d3325669013f3cd" translate="yes" xml:space="preserve">
          <source>I'm adding my own answer just because everyone else has covered the hoisting part thoroughly.</source>
          <target state="translated">Я добавляю свой собственный ответ только потому,что все остальные тщательно покрыли подъемную часть.</target>
        </trans-unit>
        <trans-unit id="6b65544a6391d547c18bfe600d2757c9ec324ddd" translate="yes" xml:space="preserve">
          <source>I'm listing out the differences below:</source>
          <target state="translated">Я перечислю разницу ниже:</target>
        </trans-unit>
        <trans-unit id="7b6cd598514917069a107f035013ef3785ac2a80" translate="yes" xml:space="preserve">
          <source>I've recently started maintaining someone else's JavaScript code. I'm fixing bugs, adding features and also trying to tidy up the code and make it more consistent.</source>
          <target state="translated">Недавно я начал поддерживать чей-то JavaScript-код.Я исправляю ошибки,добавляю возможности,а также пытаюсь привести код в порядок и сделать его более последовательным.</target>
        </trans-unit>
        <trans-unit id="bce5a0c9028577f292967e9b74591dfce14b4d0e" translate="yes" xml:space="preserve">
          <source>I've wondered about which way is better for a long while now, and thanks to &lt;a href=&quot;http://jsperf.com&quot;&gt;http://jsperf.com&lt;/a&gt; now I know :)</source>
          <target state="translated">Я долго думал, какой путь лучше, и теперь я знаю, что благодаря &lt;a href=&quot;http://jsperf.com&quot;&gt;http://jsperf.com&lt;/a&gt; :)</target>
        </trans-unit>
        <trans-unit id="7253bc4a6f9bb4a8d2e1a26b26041e3d0c929006" translate="yes" xml:space="preserve">
          <source>If in &lt;em&gt;strict&lt;/em&gt; mode (browser or not), the JavaScript engine is supposed to do yet another thing</source>
          <target state="translated">Если в &lt;em&gt;строгом&lt;/em&gt; режиме (браузер или нет), движок JavaScript должен делать еще одну вещь</target>
        </trans-unit>
        <trans-unit id="47ba4d884a6eea36c2e8e1930047665437e35282" translate="yes" xml:space="preserve">
          <source>If in loose mode &lt;em&gt;not&lt;/em&gt; on a web browser, the JavaScript engine is supposed to do one thing</source>
          <target state="translated">Если в свободном режиме &lt;em&gt;нет&lt;/em&gt; в веб-браузере, движок JavaScript должен делать одно</target>
        </trans-unit>
        <trans-unit id="9c24a734bfa420e8662e5588c678c512ef41507c" translate="yes" xml:space="preserve">
          <source>If in loose mode on a web browser, the JavaScript engine is supposed to do something else</source>
          <target state="translated">Если в свободном режиме в веб-браузере,JavaScript-движок должен делать что-то другое.</target>
        </trans-unit>
        <trans-unit id="c773779c693ffdb43c73b2a0c70b33f6e387fbfc" translate="yes" xml:space="preserve">
          <source>If there are no variables set to the function, then the functions name is the empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;).</source>
          <target state="translated">Если для функции не заданы переменные, то именем функции является пустая строка ( &lt;code&gt;&quot;&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0ee8e8f5104dbf145e9fbcd03eca2e86caccca4f" translate="yes" xml:space="preserve">
          <source>If you really, really wanted your iterator and success callbacks to show up in the trace, you could name those too...</source>
          <target state="translated">Если бы вы очень,очень хотели,чтобы ваш итератор и обратные вызовы успеха появились в трассе,вы могли бы назвать и их тоже...</target>
        </trans-unit>
        <trans-unit id="be9589a95c8b69ed2b8236a7926adaebf7d55119" translate="yes" xml:space="preserve">
          <source>If you want to alias functions on all browsers, use this kind of declaration:</source>
          <target state="translated">Если вы хотите,чтобы псевдонимы функционировали во всех браузерах,используйте такое объявление:</target>
        </trans-unit>
        <trans-unit id="99925e9ee05be0efa6950a0d1631c81f1977d083" translate="yes" xml:space="preserve">
          <source>If you would use those functions to create objects, you would get:</source>
          <target state="translated">Если бы вы использовали эти функции для создания объектов,вы бы получили:</target>
        </trans-unit>
        <trans-unit id="ba22cd7a07e0cdf6f17ebe8dd72208ff7d3f75dc" translate="yes" xml:space="preserve">
          <source>If you're doing more than just a single expression, use &lt;code&gt;{}&lt;/code&gt; and an explicit &lt;code&gt;return&lt;/code&gt; (if you need to return a value), as normal:</source>
          <target state="translated">Если вы делаете больше, чем просто одно выражение, используйте &lt;code&gt;{}&lt;/code&gt; и явный &lt;code&gt;return&lt;/code&gt; (если вам нужно вернуть значение), как обычно:</target>
        </trans-unit>
        <trans-unit id="18d78f8520de80f2c3d19326953d4afd2bce640f" translate="yes" xml:space="preserve">
          <source>In ES5, the function this creates has no name (it's anonymous). In ES2015, the function is assigned a name if possible by inferring it from context. In the example above, the name would be &lt;code&gt;y&lt;/code&gt;. Something similar is done when the function is the value of a property initializer. (For details on when this happens and the rules, search for &lt;code&gt;SetFunctionName&lt;/code&gt; in the &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;the specification&lt;/a&gt;&amp;nbsp;&amp;mdash; it appears &lt;em&gt;all over&lt;/em&gt; the place.)</source>
          <target state="translated">В ES5 создаваемая функция не имеет имени (она анонимна). В ES2015, функции по возможности присваивается имя, выводя его из контекста. В приведенном выше примере имя будет &lt;code&gt;y&lt;/code&gt; . Нечто подобное происходит, когда функция является значением инициализатора свойства. (Для получения подробной информации о том, когда это происходит, и правилах, найдите &lt;code&gt;SetFunctionName&lt;/code&gt; в &lt;a href=&quot;https://tc39.github.io/ecma262/&quot;&gt;спецификации&lt;/a&gt; - он появляется &lt;em&gt;повсюду&lt;/em&gt; .)</target>
        </trans-unit>
        <trans-unit id="4d0a437ff9ee930d494784b0a38eceebe7464cfb" translate="yes" xml:space="preserve">
          <source>In Google's V8 and Firefox's Spidermonkey there might be a few microsecond JIST compilation difference, but ultimately the result is the exact same. To prove this, let's examine the efficiency of JSPerf at microbenchmarks by comparing the speed of two blank code snippets. The &lt;a href=&quot;https://jsperf.com/microbenchmark-analysis/1&quot;&gt;JSPerf tests are found here&lt;/a&gt;. And, the &lt;a href=&quot;http://jsben.ch/Ov6eJ&quot;&gt;jsben.ch testsare  found here&lt;/a&gt;. As you can see, there is a noticable difference when there should be none. If you are really a performance freak like me, then it might be more worth your while trying to reduce the number of variables and functions in the scope and especially eliminating polymorphism (such as using the same variable to store two different types).</source>
          <target state="translated">В Google V8 и Firefox Spidermonkey может быть небольшая разница в компиляции JIST на несколько микросекунд, но в конечном итоге результат будет точно таким же. Чтобы доказать это, давайте рассмотрим эффективность JSPerf в микробенчмарках, сравнив скорость двух пустых фрагментов кода. &lt;a href=&quot;https://jsperf.com/microbenchmark-analysis/1&quot;&gt;Тесты JSPerf находятся здесь&lt;/a&gt; . И &lt;a href=&quot;http://jsben.ch/Ov6eJ&quot;&gt;тесты jsben.ch находятся здесь&lt;/a&gt; . Как видите, есть заметная разница, когда их не должно быть. Если вы действительно такой же фанат производительности, как я, то, возможно, стоит попытаться уменьшить количество переменных и функций в области и, в частности, устранить полиморфизм (например, использовать одну и ту же переменную для хранения двух разных типов).</target>
        </trans-unit>
        <trans-unit id="77530f56c5b4887f097bf802c9364dfb9c6bf513" translate="yes" xml:space="preserve">
          <source>In JavaScript there are two ways to create functions:</source>
          <target state="translated">В JavaScript есть два способа создания функций:</target>
        </trans-unit>
        <trans-unit id="743fad7b9f2b3005515bc6a8b41cc5305db6d16c" translate="yes" xml:space="preserve">
          <source>In a debugger you will clearly see the function name on the call stack instead of an &quot;anonymous/evaluated&quot; function.</source>
          <target state="translated">В отладчике вы четко увидите имя функции на стеке вызовов вместо &quot;анонимно оцененной&quot;.</target>
        </trans-unit>
        <trans-unit id="40ac26672752f4a573b68a025efd96f93c7cda1f" translate="yes" xml:space="preserve">
          <source>In above condition the function name is visible within its scope and the scope of its parent (otherwise it would be unreachable).</source>
          <target state="translated">В вышеприведенном условии имя функции видно в пределах ее охвата и охвата ее родителя (в противном случае оно было бы недоступно).</target>
        </trans-unit>
        <trans-unit id="1f5563a0832819a0b28ffe111ae45fd4c8971126" translate="yes" xml:space="preserve">
          <source>In both cases, the body of the function is just an expression; the function's return value will automatically be the result of that expression (you don't use an explicit &lt;code&gt;return&lt;/code&gt;).</source>
          <target state="translated">В обоих случаях тело функции является просто выражением; возвращаемое значение функции будет автоматически результатом этого выражения (вы не используете явный &lt;code&gt;return&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d0c1580d80e84da99a8bb130ae769242b985147e" translate="yes" xml:space="preserve">
          <source>In computer science terms, we talk about anonymous functions and named functions. I think the most important difference is that an anonymous function is not bound to an name, hence the name anonymous function. In JavaScript it is a first class object dynamically declared at runtime.</source>
          <target state="translated">В терминах информатики мы говорим об анонимных функциях и именованных функциях.Я думаю,что самое главное различие заключается в том,что анонимная функция не привязана к имени,отсюда и анонимная функция с именем.В JavaScript это первоклассный объект,динамически объявляемый во время выполнения.</target>
        </trans-unit>
        <trans-unit id="9ad24effba4df71940268999b683a278696da2a5" translate="yes" xml:space="preserve">
          <source>In light of the &quot;named functions show up in stack traces&quot; argument, modern JavaScript engines are actually quite capable of representing anonymous functions.</source>
          <target state="translated">В свете аргумента &quot;именованные функции появляются в стековых трассах&quot;,современные JavaScript-движки на самом деле вполне способны представлять анонимные функции.</target>
        </trans-unit>
        <trans-unit id="bada26db6ba62d3b37fbfb0f8797580b37b425d5" translate="yes" xml:space="preserve">
          <source>In terms of code maintenance cost, named functions are more preferable:</source>
          <target state="translated">С точки зрения стоимости обслуживания кода,именованные функции являются более предпочтительными:</target>
        </trans-unit>
        <trans-unit id="0ab56e8403de5abcd245a223331dd74301ac39fd" translate="yes" xml:space="preserve">
          <source>In the example above we can do the same with an external name, but it'll be too unwieldy (and slower).</source>
          <target state="translated">В приведенном выше примере мы можем сделать то же самое с внешним именем,но оно будет слишком громоздким (и медленным).</target>
        </trans-unit>
        <trans-unit id="99565775fc2dc3442ac3db8b854377a4e1535255" translate="yes" xml:space="preserve">
          <source>In this case, both &lt;code&gt;xyz&lt;/code&gt; and &lt;code&gt;abc&lt;/code&gt; are aliases of the same object:</source>
          <target state="translated">В этом случае &lt;code&gt;xyz&lt;/code&gt; и &lt;code&gt;abc&lt;/code&gt; являются псевдонимами одного и того же объекта:</target>
        </trans-unit>
        <trans-unit id="f34745ad4ce35316a6c1a3f69ce6b5aa657af5a5" translate="yes" xml:space="preserve">
          <source>In this example &lt;code&gt;a&lt;/code&gt; is initialized with the function object resulting from evaluating the second function declaration, and then is assigned &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">В этом примере &lt;code&gt;a&lt;/code&gt; инициализируется объектом функции, полученным в результате вычисления второго объявления функции, а затем ему присваивается значение &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5a8ada85e0dd38f6230fbd0de001e929f7a5ccb" translate="yes" xml:space="preserve">
          <source>Independent from the place where they are declared (but still limited by scope).</source>
          <target state="translated">Независимо от места,где они декларируются (но все же ограничены по объему).</target>
        </trans-unit>
        <trans-unit id="88d605e955dd6c957da2b10f658bd3437ef6a188" translate="yes" xml:space="preserve">
          <source>Interestingly, if we declare the variable as &lt;code&gt;function funcName(){}&lt;/code&gt;, then the immutability of the variable is the same as declaring it with &lt;code&gt;var&lt;/code&gt;.</source>
          <target state="translated">Интересно, что если мы объявим переменную как &lt;code&gt;function funcName(){}&lt;/code&gt; , то неизменность переменной будет такой же, как и объявление ее с помощью &lt;code&gt;var&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7cd8788595c6099fbc89a56b7505fbb8d78f9944" translate="yes" xml:space="preserve">
          <source>It is not safe to write function declarations in non-function blocks like &lt;strong&gt;if&lt;/strong&gt; because they won't be accessible.</source>
          <target state="translated">Не безопасно писать объявления функций в нефункциональных блоках, как &lt;strong&gt;будто,&lt;/strong&gt; потому что они не будут доступны.</target>
        </trans-unit>
        <trans-unit id="66fbe41a46d13b3ec9ad6d15a6cbc7ebb0163825" translate="yes" xml:space="preserve">
          <source>JavaScript has first-class functions, that is, create a function and assign it to a variable just like you create a string or number and assign it to a variable. Here, the fn variable is assigned to a function. The reason for this concept is functions are objects in JavaScript; fn is pointing to the object instance of the above function. We have initialized a function and assigned it to a variable. It's not executing the function and assigning the result.</source>
          <target state="translated">JavaScript имеет первоклассные функции,то есть создает функцию и присваивает ее переменной так же,как вы создаете строку или число и присваиваете его переменной.Здесь переменной fn присваивается функция.Причина такого понятия в том,что функции в JavaScript являются объектами;fn указывает на объект-экземпляр вышеуказанной функции.Мы инициализировали функцию и присвоили ей переменную.Она не выполняет функцию и не присваивает результат.</target>
        </trans-unit>
        <trans-unit id="dc87314ad86194e07f204ed20a079cd40c0d7d92" translate="yes" xml:space="preserve">
          <source>JavaScript has three ways of defining functions.</source>
          <target state="translated">JavaScript имеет три способа определения функций.</target>
        </trans-unit>
        <trans-unit id="386881110fbc49ba4e9cbf28d7d0d56af3d005b0" translate="yes" xml:space="preserve">
          <source>JavaScript treats functions as first-class objects, so being an object, you can assign properties to a function.</source>
          <target state="translated">JavaScript рассматривает функции как первоклассные объекты,поэтому,будучи объектом,вы можете присвоить функции свойства.</target>
        </trans-unit>
        <trans-unit id="b0771db0681dd1086ab043dd36cac9a035ed201d" translate="yes" xml:space="preserve">
          <source>Lastly, while the variable the function is assigned to initially sets the name, successive variables set to the function do not change the name.</source>
          <target state="translated">Наконец,в то время как переменная,которой назначена функция,изначально устанавливает имя,последовательные переменные,установленные функции,не меняют имени.</target>
        </trans-unit>
        <trans-unit id="131c609e07fa46c90f8a914d0d9876618cb16ffa" translate="yes" xml:space="preserve">
          <source>Like all expressions, it's evaluated when it's reached in the step-by-step execution of the code.</source>
          <target state="translated">Как и все выражения,он вычисляется,когда достигается в пошаговом выполнении кода.</target>
        </trans-unit>
        <trans-unit id="9047887da470d7120807196284dd5dbf0f775748" translate="yes" xml:space="preserve">
          <source>Method Declaration in Object Initializer (ES2015+)</source>
          <target state="translated">Декларация метода в инициализаторе объектов (ES2015+)</target>
        </trans-unit>
        <trans-unit id="f6e8c432ab6e69fb5b19460ea3141b5206869a18" translate="yes" xml:space="preserve">
          <source>More resistant to mistakes like conditional initialization (you are still able to override if wanted to).</source>
          <target state="translated">Более устойчива к таким ошибкам,как условная инициализация (при желании вы все равно можете переопределить).</target>
        </trans-unit>
        <trans-unit id="f0128c3077ca982c05c67d537afe75962bbc772f" translate="yes" xml:space="preserve">
          <source>Named &lt;code&gt;function&lt;/code&gt; Expression</source>
          <target state="translated">Именованная &lt;code&gt;function&lt;/code&gt; Expression</target>
        </trans-unit>
        <trans-unit id="777148d87c109971486523e49744c67e7e30f167" translate="yes" xml:space="preserve">
          <source>Named function expression like the one below, may not work in Internet&amp;nbsp;Explorer browsers prior to version 9.</source>
          <target state="translated">Выражение именованной функции, подобное приведенному ниже, может не работать в браузерах Internet Explorer до версии 9.</target>
        </trans-unit>
        <trans-unit id="a2af52c0ccfa8c408328b7c06cce7ab9ec1d62fa" translate="yes" xml:space="preserve">
          <source>Named function expressions demystified</source>
          <target state="translated">Именованные выражения функций демистифицированы</target>
        </trans-unit>
        <trans-unit id="dc9e3d6fd9e9ce94aab3c1ef25f88d46b96264d9" translate="yes" xml:space="preserve">
          <source>New versions of &lt;code&gt;V8&lt;/code&gt; introduced several under-the-hood optimizations and so did &lt;code&gt;SpiderMonkey&lt;/code&gt;.</source>
          <target state="translated">Новые версии &lt;code&gt;V8&lt;/code&gt; представили несколько внутренних оптимизаций, как и &lt;code&gt;SpiderMonkey&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65bd7ea4a6bcc80835c2ec2b979fb00bb0f4c9ac" translate="yes" xml:space="preserve">
          <source>Nitro</source>
          <target state="translated">Nitro</target>
        </trans-unit>
        <trans-unit id="8110b79db7f83a1e8b4ca63a622ef7443e84ba94" translate="yes" xml:space="preserve">
          <source>Normal &lt;code&gt;function add(){}&lt;/code&gt;</source>
          <target state="translated">Нормальная &lt;code&gt;function add(){}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c5a68d9eef8721bfe6330530d6cdfda8dbcb430" translate="yes" xml:space="preserve">
          <source>Normal &lt;code&gt;var add=function(){}&lt;/code&gt;</source>
          <target state="translated">Нормальный &lt;code&gt;var add=function(){}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f50d4d872d6f1fc0198387a8cbf12922732ec09a" translate="yes" xml:space="preserve">
          <source>Note that NFEs have frequently been a source of bugs for JavaScript implementations. IE8 and earlier, for instance, handle NFEs &lt;a href=&quot;http://blog.niftysnippets.org/2010/09/double-take.html&quot;&gt;completely incorrectly&lt;/a&gt;, creating two different functions at two different times. Early versions of Safari had issues as well. The good news is that current versions of browsers (IE9 and up, current Safari) don't have those issues any more. (But as of this writing, sadly, IE8 remains in widespread use, and so using NFEs with code for the web in general is still problematic.)</source>
          <target state="translated">Обратите внимание, что NFE часто являются источником ошибок для реализаций JavaScript. Например, IE8 и более ранние версии обрабатывают NFE &lt;a href=&quot;http://blog.niftysnippets.org/2010/09/double-take.html&quot;&gt;совершенно неправильно&lt;/a&gt; , создавая две разные функции в два разных времени. Ранние версии Safari также имели проблемы. Хорошей новостью является то, что в текущих версиях браузеров (IE9 и выше, текущий Safari) таких проблем больше нет. (К сожалению, на момент написания статьи IE8 все еще широко используется, и поэтому использование NFE с кодом для Интернета в целом все еще проблематично.)</target>
        </trans-unit>
        <trans-unit id="46c934ebb5c49a0e1a45001cc099b679e5fc9cba" translate="yes" xml:space="preserve">
          <source>Note that when I used the function, I didn't use &lt;code&gt;()&lt;/code&gt;! That's because it's an &lt;em&gt;accessor function&lt;/em&gt; for a property. We get and set the property in the normal way, but behind the scenes, the function is called.</source>
          <target state="translated">Обратите внимание, что когда я использовал функцию, я не использовал &lt;code&gt;()&lt;/code&gt; ! Это потому, что это &lt;em&gt;функция доступа&lt;/em&gt; для свойства. Мы получаем и устанавливаем свойство обычным способом, но за кулисами вызывается функция.</target>
        </trans-unit>
        <trans-unit id="b0135a3fe9edd1aa747c5dc00ef86223a2fba31b" translate="yes" xml:space="preserve">
          <source>Notice that the assignment portion of the declarations were not hoisted. Only the name is hoisted.</source>
          <target state="translated">Обратите внимание,что часть деклараций,касающаяся назначения,не была поднята.Поднимается только название.</target>
        </trans-unit>
        <trans-unit id="bc114abbd8dd8a2cd0b954fda2e13a328089452b" translate="yes" xml:space="preserve">
          <source>On the second line we are assigning the reference of an anonymous function to functionOne.</source>
          <target state="translated">Во второй строке мы присваиваем functionOne ссылку на анонимную функцию.</target>
        </trans-unit>
        <trans-unit id="8843a229a0f472ada31ba06061df9ac263f902f6" translate="yes" xml:space="preserve">
          <source>One compelling reason to use the combined style is the &quot;name&quot; attribute of function objects (&lt;strong&gt;not supported by Internet&amp;nbsp;Explorer&lt;/strong&gt;). Basically when you define a function like</source>
          <target state="translated">Одной из веских причин для использования комбинированного стиля является атрибут &amp;laquo;имя&amp;raquo; функциональных объектов ( &lt;strong&gt;не поддерживается Internet Explorer&lt;/strong&gt; ). В основном, когда вы определяете функцию, как</target>
        </trans-unit>
        <trans-unit id="dbe6fdfa55051d3eebbbe9fd39842bacd3d7cc72" translate="yes" xml:space="preserve">
          <source>Other commenters have already covered the semantic difference of the two variants above. I wanted to note a stylistic difference: Only the &quot;assignment&quot; variation can set a property of another object.</source>
          <target state="translated">Другие комментаторы уже освещали семантическую разницу двух вариантов,описанных выше.Хотелось отметить стилистическую разницу:Только вариант &quot;присваивания&quot; может задавать свойство другого объекта.</target>
        </trans-unit>
        <trans-unit id="95fa44f122d0d2fde84daa10053c89ba105c1733" translate="yes" xml:space="preserve">
          <source>Otherwise, if a function is declared as &lt;code&gt;function(){}&lt;/code&gt;, the &lt;em&gt;function&lt;/em&gt;.name is the first variable used to store the function.</source>
          <target state="translated">В противном случае, если функция объявлена ​​как &lt;code&gt;function(){}&lt;/code&gt; , &lt;em&gt;функция&lt;/em&gt; .name является первой переменной, используемой для хранения функции.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="bcc6976fdb7b0bab8f43d0bd6a3d5c3f3f1f4418" translate="yes" xml:space="preserve">
          <source>Personally, I prefer the &quot;function expression&quot; declaration because this way I can control the visibility. When I define the function like</source>
          <target state="translated">Лично я предпочитаю декларацию &quot;выражение функции&quot;,потому что таким образом я могу контролировать видимость.Когда я определяю функцию как</target>
        </trans-unit>
        <trans-unit id="48e539471552b322b96b629b50e168373aab581d" translate="yes" xml:space="preserve">
          <source>Reference: &lt;em&gt;&lt;a href=&quot;http://jkoder.com/javascript-function-declaration-syntax-var-fn-function-vs-function-fn/&quot;&gt;JavaScript function declaration syntax: var fn = function() {} vs function fn() {}&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">Ссылка: &lt;em&gt;&lt;a href=&quot;http://jkoder.com/javascript-function-declaration-syntax-var-fn-function-vs-function-fn/&quot;&gt;Синтаксис объявления функции JavaScript: var fn = function () {} против функции fn () {}&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2fa869913cd407b8374e8002710a8e37791c0a7c" translate="yes" xml:space="preserve">
          <source>Same function using function expressions:</source>
          <target state="translated">Одна и та же функция с использованием выражений функций:</target>
        </trans-unit>
        <trans-unit id="a342ddf70636f32b76e4ff5a5d52c5eb4e44afd7" translate="yes" xml:space="preserve">
          <source>Secondly, it is possible to combine both styles:</source>
          <target state="translated">Во-вторых,можно сочетать оба стиля:</target>
        </trans-unit>
        <trans-unit id="8f28d3ab65fed240b09f7deb679e37f9272d4792" translate="yes" xml:space="preserve">
          <source>See that &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; thing hiding in the &lt;code&gt;map()&lt;/code&gt; call? That's a function.</source>
          <target state="translated">Видите, что &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; что скрывается в вызове &lt;code&gt;map()&lt;/code&gt; ? Это функция.</target>
        </trans-unit>
        <trans-unit id="26c0ca793e8f7074d3f8c82877440040dbf9523b" translate="yes" xml:space="preserve">
          <source>So</source>
          <target state="translated">So</target>
        </trans-unit>
        <trans-unit id="46c47815b690569dbb7a656b8964b6c4a2aec3eb" translate="yes" xml:space="preserve">
          <source>Some brandings require specific functions, and some do not. Sometimes I have to add new functions to do new branding-specific things. I am happy to change the shared coded, but I don't want to have to change all 160 sets of branding files.</source>
          <target state="translated">Некоторые бренды требуют определенных функций,а некоторые-нет.Иногда мне приходится добавлять новые функции,чтобы делать новые специфические для брендинга вещи.Я с удовольствием изменю общий код,но я не хочу менять все 160 наборов файлов брендинга.</target>
        </trans-unit>
        <trans-unit id="5f39892c489c20b210e85c99d0636ddca2f715ec" translate="yes" xml:space="preserve">
          <source>Some examples...</source>
          <target state="translated">Некоторые примеры...</target>
        </trans-unit>
        <trans-unit id="48fe26184a1da0188c638e9837cd0348befd6fc9" translate="yes" xml:space="preserve">
          <source>Sometimes functions can sneak in largely unnoticed; that's the case with &lt;em&gt;accessor functions&lt;/em&gt;. Here's an example:</source>
          <target state="translated">Иногда функции могут проникнуть в значительной степени незамеченными; это в случае с &lt;em&gt;функциями доступа&lt;/em&gt; . Вот пример:</target>
        </trans-unit>
        <trans-unit id="387053ec024b111c7ef9f523fd9328f604a02b3d" translate="yes" xml:space="preserve">
          <source>Speaking about the global context, both, the &lt;code&gt;var&lt;/code&gt; statement and a &lt;code&gt;FunctionDeclaration&lt;/code&gt; at the end will create a &lt;em&gt;non-deleteable&lt;/em&gt; property on the global object, but the value of both &lt;em&gt;can be overwritten&lt;/em&gt;.</source>
          <target state="translated">Говоря о глобальном контексте, оператор &lt;code&gt;var&lt;/code&gt; и &lt;code&gt;FunctionDeclaration&lt;/code&gt; в конце создадут &lt;em&gt;не удаляемое&lt;/em&gt; свойство глобального объекта, но значение обоих &lt;em&gt;может быть перезаписано&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f65122e6f32c2bcabdd432788ea598df5c48d617" translate="yes" xml:space="preserve">
          <source>SpiderMonkey</source>
          <target state="translated">SpiderMonkey</target>
        </trans-unit>
        <trans-unit id="c6651b9a96d11046277cfbcd116304f61f74227d" translate="yes" xml:space="preserve">
          <source>SpiderMonkey can figure out the name of an anonymous function returned from another function. The rest can't.</source>
          <target state="translated">SpiderMonkey может вычислить имя анонимной функции,возвращенной из другой функции.Остальные не могут.</target>
        </trans-unit>
        <trans-unit id="0ae1828118a1782dda8e1ea5ac856c97b23cc230" translate="yes" xml:space="preserve">
          <source>Statement (such as &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;else&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;finally&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt;)</source>
          <target state="translated">Оператор (например, &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;else&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;try&lt;/code&gt; / &lt;code&gt;catch&lt;/code&gt; / &lt;code&gt;finally&lt;/code&gt; , &lt;code&gt;switch&lt;/code&gt; , &lt;code&gt;do&lt;/code&gt; / &lt;code&gt;while&lt;/code&gt; , &lt;code&gt;with&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="bc07256662906a0b6337c96a56729c6ca11dc5d1" translate="yes" xml:space="preserve">
          <source>Take a look at the function below:</source>
          <target state="translated">Смотрите на функцию ниже:</target>
        </trans-unit>
        <trans-unit id="ffdc12529405fd8a1fe177c00af6a4b1b34cbdf9" translate="yes" xml:space="preserve">
          <source>Terms:</source>
          <target state="translated">Terms:</target>
        </trans-unit>
        <trans-unit id="f63f70d99a4f81b8e70665fd22c3174d3eeca9cf" translate="yes" xml:space="preserve">
          <source>That also means that the method has a reference to the object it was defined on, so if that object is temporary (for instance, you're passing it into &lt;code&gt;Object.assign&lt;/code&gt; as one of the source objects), method syntax &lt;em&gt;could&lt;/em&gt; mean that the object is retained in memory when otherwise it could have been garbage collected (if the JavaScript engine doesn't detect that situation and handle it if none of the methods uses &lt;code&gt;super&lt;/code&gt;).</source>
          <target state="translated">Это также означает, что метод имеет ссылку на объект, для которого он был определен, поэтому, если этот объект является временным (например, вы передаете его в &lt;code&gt;Object.assign&lt;/code&gt; как один из исходных объектов), синтаксис метода &lt;em&gt;может&lt;/em&gt; означать, что объект сохраняется в памяти, когда в противном случае он мог бы быть собран сборщиком мусора (если механизм JavaScript не обнаруживает эту ситуацию и не обрабатывает ее, если ни один из методов не использует &lt;code&gt;super&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a48c26e1972ebb64b7dc5783e0fabcbb52b4ce7e" translate="yes" xml:space="preserve">
          <source>The &quot;nearest block&quot; is the nearest &quot;function,&quot; (including asynchronous functions, generator functions, and asynchronous generator functions). However, interestingly, a &lt;code&gt;function functionName() {}&lt;/code&gt; behaves like a &lt;code&gt;var functionName = function() {}&lt;/code&gt; when in a non-closure block to items outside said closure. Observe.</source>
          <target state="translated">&amp;laquo;Ближайший блок&amp;raquo; является ближайшей &amp;laquo;функцией&amp;raquo; (включая асинхронные функции, функции генератора и асинхронные функции генератора). Однако, что интересно, &lt;code&gt;function functionName() {}&lt;/code&gt; ведет себя как &lt;code&gt;var functionName = function() {}&lt;/code&gt; когда находится в незамкнутом блоке для элементов вне указанного замыкания. Обратите внимание.</target>
        </trans-unit>
        <trans-unit id="6a595334c53b5e54513ecbf67288a1b96ade59c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; example above is one form of them. If you have multiple arguments to pass the function, you use parens:</source>
          <target state="translated">Приведенный выше пример &lt;code&gt;n =&amp;gt; n * 2&lt;/code&gt; является одной из них. Если у вас есть несколько аргументов для передачи функции, вы используете parens:</target>
        </trans-unit>
        <trans-unit id="ac4e1750314827abdcc2556f83c85b9fddef454c" translate="yes" xml:space="preserve">
          <source>The above actually defines &lt;code&gt;functionThree&lt;/code&gt; irrespective of &lt;code&gt;test&lt;/code&gt;'s value &amp;mdash; unless &lt;code&gt;use strict&lt;/code&gt; is in effect, in which case it simply raises an error.</source>
          <target state="translated">Вышеприведенное фактически определяет &lt;code&gt;functionThree&lt;/code&gt; независимо от значения &lt;code&gt;test&lt;/code&gt; - если только не &lt;code&gt;use strict&lt;/code&gt; значение, в этом случае просто возникает ошибка.</target>
        </trans-unit>
        <trans-unit id="b568b255152259a00f6cba0e87f3825e038239ef" translate="yes" xml:space="preserve">
          <source>The above code is identical in functionality to the code below. Note that explicitly assigning &lt;code&gt;add = undefined&lt;/code&gt; is superfluous because simply doing &lt;code&gt;var add;&lt;/code&gt; is the exact same as &lt;code&gt;var add=undefined&lt;/code&gt;.</source>
          <target state="translated">Приведенный выше код по функциональности идентичен приведенному ниже. Обратите внимание, что явное присвоение &lt;code&gt;add = undefined&lt;/code&gt; является излишним, потому что просто выполняется &lt;code&gt;var add;&lt;/code&gt; точно так же, как &lt;code&gt;var add=undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61810b104f2efcb0e3da5ee583a0202c43770fb2" translate="yes" xml:space="preserve">
          <source>The assignment of the &lt;code&gt;bar&lt;/code&gt;&lt;code&gt;FunctionExpression&lt;/code&gt; takes place until runtime.</source>
          <target state="translated">Назначение &lt;code&gt;bar&lt;/code&gt; &lt;code&gt;FunctionExpression&lt;/code&gt; происходит до времени выполнения.</target>
        </trans-unit>
        <trans-unit id="f5638e210194eb499ece9d9a4a930b2e74d062fc" translate="yes" xml:space="preserve">
          <source>The code becomes more readable by allocating local functions separately of scope functionality. Usually in the scope the functionality goes first, followed by declarations of local functions.</source>
          <target state="translated">Код становится более читабельным,выделяя локальные функции отдельно от функциональности диапазона.Обычно в области применения функциональность идет первой,за ней следуют объявления локальных функций.</target>
        </trans-unit>
        <trans-unit id="27d4da09d4c2ce032185baf978da0ab13a3001ed" translate="yes" xml:space="preserve">
          <source>The difference is that &lt;code&gt;functionOne&lt;/code&gt; is a function expression and so only defined when that line is reached, whereas &lt;code&gt;functionTwo&lt;/code&gt; is a function declaration and is defined as soon as its surrounding function or script is executed (due to &lt;a href=&quot;http://adripofjavascript.com/blog/drips/variable-and-function-hoisting.html&quot;&gt;hoisting&lt;/a&gt;).</source>
          <target state="translated">Различие состоит в том, что &lt;code&gt;functionOne&lt;/code&gt; является выражением функции и поэтому определяется только при достижении этой строки, тогда как &lt;code&gt;functionTwo&lt;/code&gt; является объявлением функции и определяется, как только его окружающая функция или скрипт выполняется (из-за &lt;a href=&quot;http://adripofjavascript.com/blog/drips/variable-and-function-hoisting.html&quot;&gt;подъема&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8f5ff0d27037b523b788758f94b98b0d9ae64dd6" translate="yes" xml:space="preserve">
          <source>The first case is of function expressions which loads only when the interpreter reaches that line of code. So if you do it like the following, you will get an error that the &lt;strong&gt;functionOne is not a function&lt;/strong&gt;.</source>
          <target state="translated">Первый случай - это выражения функций, которые загружаются только тогда, когда интерпретатор достигает этой строки кода. Поэтому, если вы сделаете это следующим образом, вы получите ошибку, что &lt;strong&gt;functionOne не является функцией&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8c697eb723f616068919ff4ce595b6a84c5ced0b" translate="yes" xml:space="preserve">
          <source>The first example is a function declaration:</source>
          <target state="translated">Первый пример-декларация функций:</target>
        </trans-unit>
        <trans-unit id="43835d99e780763836c24b4200a3754c5e808b94" translate="yes" xml:space="preserve">
          <source>The first form is a &lt;em&gt;function declaration&lt;/em&gt;, which looks like this:</source>
          <target state="translated">Первая форма - это &lt;em&gt;объявление функции&lt;/em&gt; , которое выглядит так:</target>
        </trans-unit>
        <trans-unit id="34f69ae86ca961522b085400da5ab180cee6f82c" translate="yes" xml:space="preserve">
          <source>The first one (function doSomething(x)) should be part of an object notation.</source>
          <target state="translated">Первая (функция doSomething(x))должна быть частью нотации объекта.</target>
        </trans-unit>
        <trans-unit id="528c8b3507437f286d5dcd35417b22aae81be689" translate="yes" xml:space="preserve">
          <source>The following does not work because the &lt;code&gt;var add=&lt;/code&gt; superseeds the &lt;code&gt;function add()&lt;/code&gt;.</source>
          <target state="translated">Следующее не работает, потому что &lt;code&gt;var add=&lt;/code&gt; заменяет &lt;code&gt;function add()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6593583ad3f05cea4dd2dbe710ed86ac6be34db" translate="yes" xml:space="preserve">
          <source>The following does not work because the variable is called before a function value is assigned to the variable &lt;code&gt;add&lt;/code&gt;.</source>
          <target state="translated">Следующее не работает, потому что переменная вызывается до назначения значения функции переменной &lt;code&gt;add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c398e75b47d2fad865197a5e2b4b99f659ecf1b" translate="yes" xml:space="preserve">
          <source>The following works because &lt;code&gt;function add()&lt;/code&gt; is scoped to the nearest block:</source>
          <target state="translated">Следующее работает, потому что &lt;code&gt;function add()&lt;/code&gt; находится в пределах ближайшего блока:</target>
        </trans-unit>
        <trans-unit id="12d135f5c480c68402b5ce8e6a0d8f062c40c5a2" translate="yes" xml:space="preserve">
          <source>The function statement is just a shorthand for &lt;code&gt;var&lt;/code&gt; statement with a &lt;code&gt;function&lt;/code&gt; value.</source>
          <target state="translated">Оператор function - это просто сокращение для оператора &lt;code&gt;var&lt;/code&gt; со значением &lt;code&gt;function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aabbd15c1c1cbe57d1e6cc08682ca9493293312d" translate="yes" xml:space="preserve">
          <source>The function this creates has a proper name (&lt;code&gt;w&lt;/code&gt; in this case). Like all expressions, this is evaluated when it's reached in the step-by-step execution of the code. The name of the function is &lt;em&gt;not&lt;/em&gt; added to the scope in which the expression appears; the name &lt;em&gt;is&lt;/em&gt; in scope within the function itself:</source>
          <target state="translated">Функция, которую она создает, имеет собственное имя (в данном случае &lt;code&gt;w&lt;/code&gt; ). Как и все выражения, это оценивается, когда оно достигается при пошаговом выполнении кода. Имя функции &lt;em&gt;не&lt;/em&gt; добавляется в область, в которой появляется выражение; имя &lt;em&gt;находится&lt;/em&gt; в области действия самой функции:</target>
        </trans-unit>
        <trans-unit id="ea448a50cd82447995b1eb947a60438076954bb9" translate="yes" xml:space="preserve">
          <source>The main difference is how they are hoisted (lifted and declared). In the first example, the whole function declaration is hoisted. In the second example only the var 'abc' is hoisted, its value (the function) will be undefined, and the function itself remains at the position that it is declared.</source>
          <target state="translated">Главная разница заключается в том,как их поднимают (поднимают и объявляют).В первом примере,все объявление функции поднимается.Во втором примере поднимается только var 'abc',его значение (функция)будет неопределенным,а сама функция останется в том положении,в котором она объявлена.</target>
        </trans-unit>
        <trans-unit id="4d055f6c1671742f4deaadc6161c80dec3e0bd32" translate="yes" xml:space="preserve">
          <source>The name of a function &lt;code&gt;function thefuncname(){}&lt;/code&gt; is &lt;em&gt;thefuncname&lt;/em&gt; when it is declared this way.</source>
          <target state="translated">Имя функции &lt;code&gt;function thefuncname(){}&lt;/code&gt; является &lt;em&gt;именем функции,&lt;/em&gt; когда оно объявлено таким образом.</target>
        </trans-unit>
        <trans-unit id="975e947bf74ec2c4a9220b91f85c32600f4c5554" translate="yes" xml:space="preserve">
          <source>The one or two brandings that need a specific implementation of the function can then define their version of the function and assign this to the variable if they want, and the rest do nothing. I can test for a null function before I execute it in the shared code.</source>
          <target state="translated">Одна или две маркировки,нуждающиеся в конкретной реализации функции,могут затем определить свою версию функции и при желании присвоить ее переменной,а остальные ничего не делают.Я могу проверить на наличие нулевой функции,прежде чем выполнить ее в общем коде.</target>
        </trans-unit>
        <trans-unit id="145b15615e2d9998da1e6798d5ad4a398382a9d4" translate="yes" xml:space="preserve">
          <source>The order of hoisting is also important: function declarations take precedence over variable declarations with the same name, and the last function declaration takes precedence over previous function declarations with the same name.</source>
          <target state="translated">Порядок подъема также важен:декларации функций имеют приоритет над декларациями переменных с тем же именем,а последние декларации функций имеют приоритет над предыдущими декларациями функций с тем же именем.</target>
        </trans-unit>
        <trans-unit id="9fbf6788e456c1009e4f21fffa2ea5165a3d9162" translate="yes" xml:space="preserve">
          <source>The previous developer used two ways of declaring functions and I can't work out if there is a reason behind it or not.</source>
          <target state="translated">Предыдущий разработчик использовал два способа декларирования функций,и я не могу понять,есть ли причина или нет.</target>
        </trans-unit>
        <trans-unit id="9be3cbbcb4a077923846e6cabf5be834c36c4efe" translate="yes" xml:space="preserve">
          <source>The quick list:</source>
          <target state="translated">Быстрый список:</target>
        </trans-unit>
        <trans-unit id="691d638de255d3f4d5c26aade899596c1cb5d318" translate="yes" xml:space="preserve">
          <source>The reason is that on the first line no value is assigned to functionOne, and hence it is undefined. We are trying to call it as a function, and hence we are getting an error.</source>
          <target state="translated">Причина в том,что в первой строке functionOne не имеет значения,а значит,не определено.Мы пытаемся вызвать ее как функцию,а значит,получаем ошибку.</target>
        </trans-unit>
        <trans-unit id="79805af7eecf09848f58c20a9be4bdd8d5d60b42" translate="yes" xml:space="preserve">
          <source>The rules for the loose modes are tricky, but in &lt;em&gt;strict&lt;/em&gt; mode, function declarations in blocks are easy: They're local to the block (they have &lt;em&gt;block scope&lt;/em&gt;, which is also new in ES2015), and they're hoisted to the top of the block. So:</source>
          <target state="translated">Правила для свободных режимов хитры, но в &lt;em&gt;строгом&lt;/em&gt; режиме объявления функций в блоках просты: они локальны для блока (у них есть &lt;em&gt;область видимости блока&lt;/em&gt; , которая также является новой в ES2015), и они поднимаются наверх блока. Так:</target>
        </trans-unit>
        <trans-unit id="662fa49d03ebc7b2aed8dd5f4b92c0902805a5f2" translate="yes" xml:space="preserve">
          <source>The second case is of function declarations that loads before any code is executed. So if you do like the following you won't get any error as the declaration loads before code execution.</source>
          <target state="translated">Второй случай-это объявления функций,которые загружаются перед выполнением любого кода.Таким образом,если вам понравится следующее,вы не получите никакой ошибки,так как декларации загружаются до выполнения кода.</target>
        </trans-unit>
        <trans-unit id="488c70a0cd0c42493330d0fb21f56a76d5245310" translate="yes" xml:space="preserve">
          <source>The second common form is called an &lt;em&gt;anonymous function expression&lt;/em&gt;:</source>
          <target state="translated">Вторая распространенная форма называется выражением &lt;em&gt;анонимной функции&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="d485f7dbc6206bd93419673ad073a7290e1370dc" translate="yes" xml:space="preserve">
          <source>The second example is a function expression:</source>
          <target state="translated">Второй пример-выражение функции:</target>
        </trans-unit>
        <trans-unit id="8bf7ed47a49f0740aa28a7a24a1570e0b0a27a46" translate="yes" xml:space="preserve">
          <source>The second one (&lt;code&gt;var doSomething = function(x){ alert(x);}&lt;/code&gt;) is simply creating an anonymous function and assigning it to a variable, &lt;code&gt;doSomething&lt;/code&gt;. So doSomething() will call the function.</source>
          <target state="translated">Второй ( &lt;code&gt;var doSomething = function(x){ alert(x);}&lt;/code&gt; ) просто создает анонимную функцию и присваивает ее переменной &lt;code&gt;doSomething&lt;/code&gt; . Так что doSomething () вызовет функцию.</target>
        </trans-unit>
        <trans-unit id="bb65ff5a5394939f644979347352ffd342603413" translate="yes" xml:space="preserve">
          <source>The subtle difference between the two ways is that when the &lt;a href=&quot;http://bclary.com/2004/11/07/#a-10.1.3&quot;&gt;Variable Instantiation&lt;/a&gt; process runs (before the actual code execution) all identifiers declared with &lt;code&gt;var&lt;/code&gt; will be initialized with &lt;code&gt;undefined&lt;/code&gt;, and the ones used by the &lt;code&gt;FunctionDeclaration&lt;/code&gt;'s will be available since that moment, for example:</source>
          <target state="translated">Тонкое различие между &lt;a href=&quot;http://bclary.com/2004/11/07/#a-10.1.3&quot;&gt;этими&lt;/a&gt; двумя способами заключается в том, что при запуске процесса создания переменной (до фактического выполнения кода) все идентификаторы, объявленные с помощью &lt;code&gt;var&lt;/code&gt; , будут инициализированы с &lt;code&gt;undefined&lt;/code&gt; , а те, которые используются в &lt;code&gt;FunctionDeclaration&lt;/code&gt; , будут доступны с этого момента, для пример:</target>
        </trans-unit>
        <trans-unit id="a07afd1ea9b12698990819eb8d76265cfe1ee004" translate="yes" xml:space="preserve">
          <source>The third form is a &lt;em&gt;named function expression&lt;/em&gt; (&quot;NFE&quot;):</source>
          <target state="translated">Третья форма является &lt;em&gt;выражением именованной функции&lt;/em&gt; (&amp;laquo;NFE&amp;raquo;):</target>
        </trans-unit>
        <trans-unit id="f16969d6d2f696ede4918690b2fd4331ce87e1f7" translate="yes" xml:space="preserve">
          <source>The third way of defining a function is the &lt;strong&gt;&quot;Function()&quot; constructor&lt;/strong&gt;, which is not shown in your original post. It's not recommended to use this as it works the same way as &lt;code&gt;eval()&lt;/code&gt;, which has its problems.</source>
          <target state="translated">Третий способ определения функции - это конструктор &lt;strong&gt;&amp;laquo;Function ()&amp;raquo;&lt;/strong&gt; , который не показан в исходном посте. Не рекомендуется использовать это, поскольку он работает так же, как &lt;code&gt;eval()&lt;/code&gt; , у которого есть свои проблемы.</target>
        </trans-unit>
        <trans-unit id="b2aa94344341e29310102127f307a10790251ea2" translate="yes" xml:space="preserve">
          <source>The two code snippets you've posted there will, for almost all purposes, behave the same way.</source>
          <target state="translated">Два фрагмента кода,которые вы там разместили,почти для всех целей будут вести себя одинаково.</target>
        </trans-unit>
        <trans-unit id="745bcd9fd12a96b9a791e445c3c8811fc1192e62" translate="yes" xml:space="preserve">
          <source>The two ways are:</source>
          <target state="translated">Двумя путями:</target>
        </trans-unit>
        <trans-unit id="474bce94d0bbf46c085c74728e63fac02ca4d442" translate="yes" xml:space="preserve">
          <source>The version without &lt;code&gt;{ ... }&lt;/code&gt; is called an arrow function with an &lt;em&gt;expression body&lt;/em&gt; or &lt;em&gt;concise body&lt;/em&gt;. (Also: A &lt;em&gt;concise&lt;/em&gt; arrow function.) The one with &lt;code&gt;{ ... }&lt;/code&gt; defining the body is an arrow function with a &lt;em&gt;function body&lt;/em&gt;. (Also: A &lt;em&gt;verbose&lt;/em&gt; arrow function.)</source>
          <target state="translated">Версия без &lt;code&gt;{ ... }&lt;/code&gt; называется функцией стрелки с &lt;em&gt;телом выражения&lt;/em&gt; или &lt;em&gt;кратким телом&lt;/em&gt; . (Также: &lt;em&gt;краткая&lt;/em&gt; функция стрелки.) Элемент с &lt;code&gt;{ ... }&lt;/code&gt; определяющим тело, является функцией стрелки с &lt;em&gt;телом функции&lt;/em&gt; . (Также: функция &lt;em&gt;многословной&lt;/em&gt; стрелки.)</target>
        </trans-unit>
        <trans-unit id="5e2ac0591f86093c00434254dcdbb41884337a4a" translate="yes" xml:space="preserve">
          <source>There are four noteworthy comparisons between the two different declarations of functions as listed below.</source>
          <target state="translated">Ниже приводятся четыре примечательных сравнения между двумя различными декларациями функций.</target>
        </trans-unit>
        <trans-unit id="ff3c75b5079b24e68e8e94930f5ee73dea969f6b" translate="yes" xml:space="preserve">
          <source>There are many techniques for namespacing. It's become more important with the plethora of JavaScript modules available.</source>
          <target state="translated">Существует множество техник для построения пространства имён.Это становится все более важным с большим количеством доступных модулей JavaScript.</target>
        </trans-unit>
        <trans-unit id="bfb055384b731f9a401950a0d0ee5c9f80d9d7f9" translate="yes" xml:space="preserve">
          <source>There are two function declarations above: One for the constructor, which gets the name &lt;code&gt;Person&lt;/code&gt;, and one for &lt;code&gt;getFullName&lt;/code&gt;, which is a function assigned to &lt;code&gt;Person.prototype&lt;/code&gt;.</source>
          <target state="translated">Выше приведены два объявления функций: одно для конструктора, который получает имя &lt;code&gt;Person&lt;/code&gt; , и одно для &lt;code&gt;getFullName&lt;/code&gt; , которое является функцией, назначенной для &lt;code&gt;Person.prototype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c21e5ae9b0dbaf5c8a3a97fe0a19730e14b6d355" translate="yes" xml:space="preserve">
          <source>There is a difference however at &lt;em&gt;how&lt;/em&gt; and &lt;em&gt;when&lt;/em&gt; the function object is actually associated with its variable. This difference is due to the mechanism called &lt;em&gt;variable hoisting&lt;/em&gt; in JavaScript.</source>
          <target state="translated">Однако есть разница в &lt;em&gt;том, как&lt;/em&gt; и &lt;em&gt;когда&lt;/em&gt; объект функции действительно связан с его переменной. Это различие связано с механизмом, называемым &lt;em&gt;переменным подъемом&lt;/em&gt; в JavaScript.</target>
        </trans-unit>
        <trans-unit id="06da7b97430b3e34f6c3267eaa4d35f03ac87eb2" translate="yes" xml:space="preserve">
          <source>There is almost no difference now between expression and declaration.</source>
          <target state="translated">Сейчас почти нет разницы между выражением и декларацией.</target>
        </trans-unit>
        <trans-unit id="f88a677f3e75a5ae4e3009a2066635b663011477" translate="yes" xml:space="preserve">
          <source>They are pretty similar with some small differences, first one is a variable which assigned to an anonymous function (Function Declaration) and second one is the normal way to create a function in JavaScript(Anonymous function Declaration), both has usage, cons and pros:</source>
          <target state="translated">Они довольно похожи с некоторыми небольшими отличиями,первое-это переменная,которая присваивается анонимной функции (Function Declaration),а второе-это обычный способ создания функции в JavaScript (Anonymous function Declaration),как с точки зрения использования,так и с точки зрения недостатков и плюсов:</target>
        </trans-unit>
        <trans-unit id="12694bcfc3aa8628852e68a8a23a1b1ae5570a03" translate="yes" xml:space="preserve">
          <source>They don't have their own &lt;code&gt;this&lt;/code&gt;. Instead, they &lt;em&gt;close over&lt;/em&gt; the &lt;code&gt;this&lt;/code&gt; of the context where they're defined. (They also close over &lt;code&gt;arguments&lt;/code&gt; and, where relevant, &lt;code&gt;super&lt;/code&gt;.) This means that the &lt;code&gt;this&lt;/code&gt; within them is the same as the &lt;code&gt;this&lt;/code&gt; where they're created, and cannot be changed.</source>
          <target state="translated">У них этого нет. Вместо этого они &lt;em&gt;закрывают над&lt;/em&gt; контекстом, в котором они определены. (Они также закрывают &lt;code&gt;arguments&lt;/code&gt; и, где это уместно, &lt;code&gt;super&lt;/code&gt; .) Это означает, что &lt;code&gt;this&lt;/code&gt; внутри них то же самое, что и то, где они созданы, и не может быть изменено.</target>
        </trans-unit>
        <trans-unit id="5d3eda8af03fd5bea6de534289810bbc9c0c9cc7" translate="yes" xml:space="preserve">
          <source>This also means you can't conditionally define functions using function declarations:</source>
          <target state="translated">Это также означает,что нельзя условно определять функции с помощью объявлений функций:</target>
        </trans-unit>
        <trans-unit id="8c1789e53705ce3071d6843b82e294f18ddc1727" translate="yes" xml:space="preserve">
          <source>This is a function expression:</source>
          <target state="translated">Это функциональное выражение:</target>
        </trans-unit>
        <trans-unit id="effa2ad61076e82c01e857bf9f7b8d602fd31fd4" translate="yes" xml:space="preserve">
          <source>This is because during execution, it looks like:</source>
          <target state="translated">Это потому,что во время казни,похоже:</target>
        </trans-unit>
        <trans-unit id="d1fec805ab98a0513f9b9fad3d3fe8b531e695be" translate="yes" xml:space="preserve">
          <source>This is because with the first variant, the function is assigned to the variable &lt;code&gt;foo&lt;/code&gt; at run time. In the second, the function is assigned to that identifier, &lt;code&gt;foo&lt;/code&gt;, at parse time.</source>
          <target state="translated">Это связано с тем, что в первом варианте функция присваивается переменной &lt;code&gt;foo&lt;/code&gt; во время выполнения. Во втором случае функция присваивается этому идентификатору, &lt;code&gt;foo&lt;/code&gt; , во время разбора.</target>
        </trans-unit>
        <trans-unit id="37da05445624fb3a9cad0979b5962a742fcfb61e" translate="yes" xml:space="preserve">
          <source>This is because, during execution, it looks like:-</source>
          <target state="translated">Это потому,что во время исполнения,это выглядит как:-</target>
        </trans-unit>
        <trans-unit id="ac81e957d5a9edd9078b4cf183802d4b3a3c78b3" translate="yes" xml:space="preserve">
          <source>This is just two possible ways of declaring functions, and in the second way, you can use the function before declaration.</source>
          <target state="translated">Это всего лишь два возможных способа объявления функций,а во втором способе можно использовать функцию перед объявлением.</target>
        </trans-unit>
        <trans-unit id="c8bf596e96383c7f8bf4dd936686e5dfce43757d" translate="yes" xml:space="preserve">
          <source>This is the normal way of calling a function in JavaScript, this function can be called before you even declare it as in JavaScript all functions get Hoisted, but if you have 'use strict' this won't Hoist as expected, it's a good way to call all normal functions which are not big in lines and neither are a  constructor function.</source>
          <target state="translated">Это нормальный способ вызова функции в JavaScript,эта функция может быть вызвана еще до того,как вы ее объявите,так как в JavaScript все функции получают Hoist,но если вы 'используете строгий',это не будет Hoist,как ожидалось,это хороший способ вызова всех нормальных функций,которые не имеют большого количества строк и не являются функциями конструктора.</target>
        </trans-unit>
        <trans-unit id="2b9c6d00ab6cdb468c41c536b9d5e12d359f8ad8" translate="yes" xml:space="preserve">
          <source>This is very basic, self-explanatory, used in many languages and standard across C family of languages. We declared a function defined it and executed it by calling it.</source>
          <target state="translated">Это очень простое,понятное дело,используется во многих языках и является стандартным для семейства языков С.Мы объявили функцию,которая ее определила и выполнила,вызвав ее.</target>
        </trans-unit>
        <trans-unit id="f369bab590b1ff70e9147bf580834bbc48507735" translate="yes" xml:space="preserve">
          <source>This means that code like this:</source>
          <target state="translated">Это значит,что такой код:</target>
        </trans-unit>
        <trans-unit id="a26f3ae40c34f7b11fe02427fe4fd04cac5639d4" translate="yes" xml:space="preserve">
          <source>To put it simply:</source>
          <target state="translated">Проще говоря:</target>
        </trans-unit>
        <trans-unit id="f8459b728f80ead940599b3ae8ca162ea21af9e0" translate="yes" xml:space="preserve">
          <source>To study more about this topic I strongly recommend you this
&lt;a href=&quot;http://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/#comment-43792&quot;&gt;link&lt;/a&gt;</source>
          <target state="translated">Чтобы узнать больше об этой теме, я настоятельно рекомендую вам эту &lt;a href=&quot;http://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/#comment-43792&quot;&gt;ссылку&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="408adc3e401c0d07ea40bc45f940121effd904fa" translate="yes" xml:space="preserve">
          <source>Until ES2015, the spec didn't cover what a JavaScript engine should do if you put a function declaration inside a control structure like &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, etc., like this:</source>
          <target state="translated">До ES2015 спецификация не охватывала то, что должен делать движок JavaScript, если вы поместили объявление функции внутри структуры управления, например, &lt;code&gt;try&lt;/code&gt; , &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;switch&lt;/code&gt; , &lt;code&gt;while&lt;/code&gt; и т. Д., Например:</target>
        </trans-unit>
        <trans-unit id="b8b097d0eea0934533ba237923021e6a341048fe" translate="yes" xml:space="preserve">
          <source>V8</source>
          <target state="translated">V8</target>
        </trans-unit>
        <trans-unit id="6fd7aa0d712bf58b6bad496b57c728877860d1e0" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;foo&lt;/code&gt; is hoisted to the top of the function, initialized to &lt;code&gt;undefined&lt;/code&gt;, so that &lt;code&gt;!foo&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, so &lt;code&gt;foo&lt;/code&gt; is assigned &lt;code&gt;10&lt;/code&gt;. The &lt;code&gt;foo&lt;/code&gt; outside of &lt;code&gt;bar&lt;/code&gt;'s scope plays no role and is untouched.</source>
          <target state="translated">Переменная &lt;code&gt;foo&lt;/code&gt; выводится в начало функции, инициализируется как &lt;code&gt;undefined&lt;/code&gt; , так что &lt;code&gt;!foo&lt;/code&gt; имеет значение &lt;code&gt;true&lt;/code&gt; , поэтому &lt;code&gt;foo&lt;/code&gt; назначается &lt;code&gt;10&lt;/code&gt; . &lt;code&gt;foo&lt;/code&gt; за пределами области видимости &lt;code&gt;bar&lt;/code&gt; не играет никакой роли и остается нетронутым.</target>
        </trans-unit>
        <trans-unit id="8532b2e0bf3f4150e5cd6a6e082f6757d298ae34" translate="yes" xml:space="preserve">
          <source>Variable Mutability</source>
          <target state="translated">Переменная подвижность</target>
        </trans-unit>
        <trans-unit id="6884273afe88a4cbfbe80c00ade910f535b8b76e" translate="yes" xml:space="preserve">
          <source>What Is The &quot;Nearest Block&quot;</source>
          <target state="translated">Что такое &quot;Ближайший блок&quot;?</target>
        </trans-unit>
        <trans-unit id="3487cb56b52e80f80380f6ee61e6d28c17778b0a" translate="yes" xml:space="preserve">
          <source>What are the reasons for using these two different methods and what are the pros and cons of each? Is there anything that can be done with one method that can't be done with the other?</source>
          <target state="translated">Каковы причины использования этих двух различных методов и каковы плюсы и минусы каждого из них? Есть ли что-нибудь,что можно сделать с помощью одного метода,что нельзя сделать с помощью другого?</target>
        </trans-unit>
        <trans-unit id="9e5d9650d7c2bdb693414377b37154902a354c34" translate="yes" xml:space="preserve">
          <source>What you should be knowing is that functions are actually objects in JavaScript; internally we have created an object for above function and given it a name called fn or the reference to the object is stored in fn. Functions are objects in JavaScript; an instance of function is actually an object instance.</source>
          <target state="translated">Что вы должны знать,так это то,что функции на самом деле являются объектами в JavaScript;внутри мы создали объект для вышестоящей функции и дали ему имя fn,или же ссылка на объект хранится в fn.Функции-это объекты в JavaScript;на самом деле экземпляр функции-это экземпляр объекта.</target>
        </trans-unit>
        <trans-unit id="cb3fb4dfbcf0fe94e2371e0b28eb0f6e2fcd530b" translate="yes" xml:space="preserve">
          <source>When a function declaration is hoisted, the function body &quot;follows&quot;
so when the function body is evaluated, the variable will immediately
be bound to a function object.</source>
          <target state="translated">Когда декларация функции поднимается,тело функции &quot;следует&quot;,поэтому,когда тело функции вычисляется,переменная сразу же привязывается к объекту функции.</target>
        </trans-unit>
        <trans-unit id="e9cfe61cf1adcd8f0102a36d2e0c4d12c9ca5726" translate="yes" xml:space="preserve">
          <source>When a variable declaration is hoisted, the initialization does &lt;em&gt;not&lt;/em&gt;
follow, but is &quot;left behind&quot;. The variable is initialized to
&lt;code&gt;undefined&lt;/code&gt; at the start of the function body, and will be &lt;em&gt;assigned&lt;/em&gt;
a value at its original location in the code. (Actually, it will be assigned a value at &lt;em&gt;every&lt;/em&gt; location where a declaration of a variable with the same name occurs.)</source>
          <target state="translated">Когда декларация переменной поднята, инициализация &lt;em&gt;не&lt;/em&gt; следует, но &quot;оставлена ​​позади&quot;. Переменная инициализируется как &lt;code&gt;undefined&lt;/code&gt; в начале тела функции, и ей будет &lt;em&gt;присвоено&lt;/em&gt; значение в исходном месте в коде. (На самом деле, ему будет присвоено значение в &lt;em&gt;каждом&lt;/em&gt; месте, где происходит объявление переменной с тем же именем.)</target>
        </trans-unit>
        <trans-unit id="bbe884a06b13281930a6b1c98f9d9d94e458c3b6" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;var&lt;/code&gt; keyword to declare a variable, you can then reassign a different value to the variable like so.</source>
          <target state="translated">Когда вы используете ключевое слово &lt;code&gt;var&lt;/code&gt; для объявления переменной, вы можете переназначить другое значение переменной, как показано ниже.</target>
        </trans-unit>
        <trans-unit id="958872366b05f9c9178f4030f046f9fcab17462f" translate="yes" xml:space="preserve">
          <source>Which expands further to:</source>
          <target state="translated">Что еще больше расширяется:</target>
        </trans-unit>
        <trans-unit id="d86a5675cc6478e7030415aaa83cd72801292548" translate="yes" xml:space="preserve">
          <source>While</source>
          <target state="translated">While</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="ac5e0452023b3c19655f17b544a743b6316fff94" translate="yes" xml:space="preserve">
          <source>With an assignment, without the &lt;code&gt;var&lt;/code&gt; statement, if the referenced identifier is not found in the scope chain, it will become a &lt;em&gt;deleteable&lt;/em&gt; property of the global object.</source>
          <target state="translated">При присваивании, без оператора &lt;code&gt;var&lt;/code&gt; , если указанный идентификатор не найден в цепочке областей действия, он станет &lt;em&gt;удаляемым&lt;/em&gt; свойством глобального объекта.</target>
        </trans-unit>
        <trans-unit id="2992a94652f880688ca1ececd6fbd9dc7fb7c4a7" translate="yes" xml:space="preserve">
          <source>With the second variant (&lt;code&gt;function functionTwo()&lt;/code&gt;), the function is available to code that runs above where the function is declared.</source>
          <target state="translated">Во втором варианте ( &lt;code&gt;function functionTwo()&lt;/code&gt; ) функция доступна для кода, который выполняется выше, где функция объявлена.</target>
        </trans-unit>
        <trans-unit id="b0d2d3e4c919cb16a2327e829924bc496bf26df9" translate="yes" xml:space="preserve">
          <source>With this pattern, your public functions will all use assignment, while your private functions use declaration.</source>
          <target state="translated">В этом случае все ваши публичные функции будут использовать назначение,в то время как ваши частные функции будут использовать объявление.</target>
        </trans-unit>
        <trans-unit id="2f69161f94ccc52eed8d88eea3c10a5ed51531e9" translate="yes" xml:space="preserve">
          <source>You can also create accessor functions with &lt;code&gt;Object.defineProperty&lt;/code&gt;, &lt;code&gt;Object.defineProperties&lt;/code&gt;, and the lesser-known second argument to &lt;code&gt;Object.create&lt;/code&gt;.</source>
          <target state="translated">Вы также можете создавать функции доступа с помощью &lt;code&gt;Object.defineProperty&lt;/code&gt; , &lt;code&gt;Object.defineProperties&lt;/code&gt; и менее известного второго аргумента &lt;code&gt;Object.create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a96fecb676cbe550b81abe5e501a476b1368603" translate="yes" xml:space="preserve">
          <source>You can check function declaration, expression test over different browser's using &lt;a href=&quot;http://jsperf.com/yashfunctions&quot;&gt;&lt;code&gt;jsperf Test Runner&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Вы можете проверить объявление функции, тестирование выражения в разных браузерах, используя &lt;a href=&quot;http://jsperf.com/yashfunctions&quot;&gt; &lt;code&gt;jsperf Test Runner&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f3ac05813abe982cb2026b6587a9d2cd9ba582c6" translate="yes" xml:space="preserve">
          <source>You may want to know what a &lt;em&gt;function declaration&lt;/em&gt; and &lt;em&gt;function expression&lt;/em&gt; is.</source>
          <target state="translated">Возможно, вы захотите узнать, что такое &lt;em&gt;объявление&lt;/em&gt; &lt;em&gt;функции и выражение функции&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2ec4b44222b42ad09c0dd93c4ce4013f9582d467" translate="yes" xml:space="preserve">
          <source>Your first snippet shows a &lt;strong&gt;function expression&lt;/strong&gt;. This involves using the &lt;em&gt;&quot;function&quot; operator&lt;/em&gt; to create a function - the result of that operator can be stored in any variable or object property. The function expression is powerful that way. The function expression is often called an &quot;anonymous function&quot;, because it does not have to have a name,</source>
          <target state="translated">Ваш первый фрагмент показывает &lt;strong&gt;выражение функции&lt;/strong&gt; . Это предполагает использование &lt;em&gt;оператора &amp;laquo;функция&amp;raquo;&lt;/em&gt; для создания функции - результат этого оператора может быть сохранен в любой переменной или свойстве объекта. Таким образом, выражение функции является мощным. Выражение функции часто называют &amp;laquo;анонимной функцией&amp;raquo;, потому что оно не обязательно должно иметь имя,</target>
        </trans-unit>
        <trans-unit id="266e022923f9faa5b3be37667e92ff1460681e19" translate="yes" xml:space="preserve">
          <source>Your second example is a &lt;strong&gt;function declaration&lt;/strong&gt;. This uses the &lt;em&gt;&quot;function&quot; statement&lt;/em&gt; to create a function. The function is made available at parse time and can be called anywhere in that scope. You can still store it in a variable or object property later.</source>
          <target state="translated">Ваш второй пример - &lt;strong&gt;объявление функции&lt;/strong&gt; . Это использует &lt;em&gt;оператор &quot;function&quot;&lt;/em&gt; для создания функции. Функция становится доступной во время анализа и может вызываться в любом месте этой области. Вы все еще можете сохранить его в переменной или свойстве объекта позже.</target>
        </trans-unit>
        <trans-unit id="46e93c41a34284a718c071fa2d4c174a2bdd159c" translate="yes" xml:space="preserve">
          <source>and use that as a constructor as in</source>
          <target state="translated">и использовать это как конструктор,как</target>
        </trans-unit>
        <trans-unit id="766f2b9d16f389f8448bfe19b9e12c43e3b610f1" translate="yes" xml:space="preserve">
          <source>depends on the context and may leave you guessing where it is actually defined, especially in the case of &lt;code&gt;eval()&lt;/code&gt; &amp;mdash; the answer is: It depends on the browser.</source>
          <target state="translated">зависит от контекста и может заставить вас угадать, где он определен, особенно в случае &lt;code&gt;eval()&lt;/code&gt; - ответ таков: это зависит от браузера.</target>
        </trans-unit>
        <trans-unit id="9afe260f060bed6881cbee4dafbcfdde1b19a941" translate="yes" xml:space="preserve">
          <source>does the correct job of defining &lt;code&gt;myfunction&lt;/code&gt; only when &lt;code&gt;condition&lt;/code&gt; is met.</source>
          <target state="translated">выполняет правильную работу по определению &lt;code&gt;myfunction&lt;/code&gt; только при выполнении &lt;code&gt;condition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad6a22cf9c1840cb2434e3d3948f70d3d82ff7a2" translate="yes" xml:space="preserve">
          <source>expands to</source>
          <target state="translated">распространиться до</target>
        </trans-unit>
        <trans-unit id="c9fa53e3d56127fa9a0278359df87eedc39694e4" translate="yes" xml:space="preserve">
          <source>function Identifier ( FormalParameterList&lt;sub&gt;opt&lt;/sub&gt; ) { FunctionBody }</source>
          <target state="translated">Идентификатор функции (FormalParameterList &lt;sub&gt;opt&lt;/sub&gt; ) {FunctionBody}</target>
        </trans-unit>
        <trans-unit id="c80babbe10672f1522783d610020c168a8871b0f" translate="yes" xml:space="preserve">
          <source>function Identifier&lt;sub&gt;opt&lt;/sub&gt; ( FormalParameterList&lt;sub&gt;opt&lt;/sub&gt; ) { FunctionBody }</source>
          <target state="translated">Идентификатор функции &lt;sub&gt;opt&lt;/sub&gt; (FormalParameterList &lt;sub&gt;opt&lt;/sub&gt; ) {FunctionBody}</target>
        </trans-unit>
        <trans-unit id="1a09252eb586133790cfd10a652a02b91c3d110e" translate="yes" xml:space="preserve">
          <source>functions declared inside the function-block are hoisted to top of the block.</source>
          <target state="translated">функции,объявленные внутри функционального блока,поднимаются в верхнюю часть блока.</target>
        </trans-unit>
        <trans-unit id="ef76da7e287b143105e1345282bc04bcb536f6c4" translate="yes" xml:space="preserve">
          <source>functions declared inside the page are hoisted to top of the page having global access.</source>
          <target state="translated">функции,объявленные внутри страницы,поднимаются вверх страницы,имеющей глобальный доступ.</target>
        </trans-unit>
        <trans-unit id="564e3512cbd2ca189843edd610d4d195314e3263" translate="yes" xml:space="preserve">
          <source>it is possible to retrieve the name of the constructor as a string with &lt;code&gt;two.constructor.name&lt;/code&gt;.</source>
          <target state="translated">можно получить имя конструктора в виде строки с &lt;code&gt;two.constructor.name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2700ec2ba6fe2751639ff097bd8f8d2aacff7db5" translate="yes" xml:space="preserve">
          <source>its name is automatically assigned. But when you define it like</source>
          <target state="translated">его имя присваивается автоматически.Но когда вы определяете его как</target>
        </trans-unit>
        <trans-unit id="17daac7101b762bf7ee434b07c08b0a4c8d7ce16" translate="yes" xml:space="preserve">
          <source>its name is empty &amp;mdash; we created an anonymous function and assigned it to some variable.</source>
          <target state="translated">его имя пустое - мы создали анонимную функцию и присвоили ее некоторой переменной.</target>
        </trans-unit>
        <trans-unit id="c33715969df7ac0ddad9e0bddf3b744551593c8d" translate="yes" xml:space="preserve">
          <source>javascript interpreted as</source>
          <target state="translated">яваскрипт интерпретируется как</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="a878ab0cab33cf7bc7bc8ef10d60b74ea374cd22" translate="yes" xml:space="preserve">
          <source>the almost-equivalent in ES5 and earlier would be:</source>
          <target state="translated">почти эквивалентный в ES5 и более ранних версиях:</target>
        </trans-unit>
        <trans-unit id="1f2ec344c7336412708c6074b118ba08228b6737" translate="yes" xml:space="preserve">
          <source>the difference (other than verbosity) is that a method can use &lt;code&gt;super&lt;/code&gt;, but a function cannot. So for instance, if you had an object that defined (say) &lt;code&gt;valueOf&lt;/code&gt; using method syntax, it could use &lt;code&gt;super.valueOf()&lt;/code&gt; to get the value &lt;code&gt;Object.prototype.valueOf&lt;/code&gt; would have returned (before presumably doing something else with it), whereas the ES5 version would have to do &lt;code&gt;Object.prototype.valueOf.call(this)&lt;/code&gt; instead.</source>
          <target state="translated">Разница (кроме многословия) в том, что метод может использовать &lt;code&gt;super&lt;/code&gt; , а функция - нет. Так, например, если бы у вас был объект, который определил (скажем) &lt;code&gt;valueOf&lt;/code&gt; с использованием синтаксиса метода, он мог бы использовать &lt;code&gt;super.valueOf()&lt;/code&gt; чтобы получить значение &lt;code&gt;Object.prototype.valueOf&lt;/code&gt; , которое должно быть возвращено (прежде чем предположительно делать что-то еще с ним), тогда как версия ES5 должна была бы сделать &lt;code&gt;Object.prototype.valueOf.call(this)&lt;/code&gt; вместо этого.</target>
        </trans-unit>
        <trans-unit id="b130f4fa2fdb9f1a6204a2dcd0028ce60730d038" translate="yes" xml:space="preserve">
          <source>then &lt;code&gt;one.constructor.name&lt;/code&gt; will not be defined. &lt;code&gt;Function.name&lt;/code&gt; is non-standard but is supported by Firefox, Chrome, other Webkit-derived browsers and IE 9+.</source>
          <target state="translated">тогда &lt;code&gt;one.constructor.name&lt;/code&gt; не будет определено. &lt;code&gt;Function.name&lt;/code&gt; не является стандартным, но поддерживается Firefox, Chrome, другими браузерами, производными от Webkit, и IE 9+.</target>
        </trans-unit>
        <trans-unit id="db00dc47d2bcbaa5835214069da6b3a6be20e68a" translate="yes" xml:space="preserve">
          <source>var functionName = function() {} vs function functionName() {}</source>
          <target state="translated">var functionName=function(){}vs function functionName(){}</target>
        </trans-unit>
        <trans-unit id="855b18f663a06d0d7e20dd66c32870f4e2e7f8ff" translate="yes" xml:space="preserve">
          <source>variable's/Function's declared inside the page are global can access anywhere in that page.</source>
          <target state="translated">переменная sFunction's,объявленная внутри страницы являются глобальными может получить доступ в любом месте этой страницы.</target>
        </trans-unit>
        <trans-unit id="d4bbf1fdfd223011ea728f2c0466d3a30c57347c" translate="yes" xml:space="preserve">
          <source>variable's/Functions declared inside the function are having local scope. means they are available/accessed inside the function body (scope), they are not available outside the function body.</source>
          <target state="translated">переменные sFunctions,объявленные внутри функции,имеют локальную область видимости.означает,что они доступны внутри тела функции (области видимости),они не доступны вне тела функции.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
