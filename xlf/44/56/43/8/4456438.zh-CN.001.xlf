<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/4456438">
    <body>
      <group id="4456438">
        <trans-unit id="6cac2a8923cad50dc4b6fa86c7f805e5d4428924" translate="yes" xml:space="preserve">
          <source>(I looked at Flex 4.5.1 SDK; line numbers may differ in other versions.)</source>
          <target state="translated">(我看了Flex 4.5.1 SDK;其他版本中的行号可能会有不同。)</target>
        </trans-unit>
        <trans-unit id="8ff6e962568098364f58d7c91b0955207ed8b001" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Web_Services_Description_Language&quot;&gt;WSDL&lt;/a&gt; (&lt;a href=&quot;http://en.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Web_Services_Description_Language&quot;&gt;WSDL&lt;/a&gt; （ &lt;a href=&quot;http://en.wikipedia.org/wiki/SOAP&quot;&gt;SOAP&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="2bb9cb996cb97333b57ef999e34e9e0a1d0874a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;11/16/2013 update&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;2013年11月16日更新&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="05fd1d8a238c98bd7809a8a2f3f4742e22c1d6c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;CDATA values are the most appropriate way to mutate an entire text value that would otherwise cause encoding/decoding problems.&lt;/strong&gt; Hex encoding, for instance, is meant for individual characters. CDATA values are preferred when you're escaping the entire text of an element. The biggest reason for this is that it maintains human readability.</source>
          <target state="translated">&lt;strong&gt;CDATA值是变异整个文本值的最合适方法，否则将导致编码/解码问题。&lt;/strong&gt; 例如，十六进制编码是针对单个字符的。 在转义元素的整个文本时，首选CDATA值。 这样做的最大原因是它保持了人类可读性。</target>
        </trans-unit>
        <trans-unit id="4a1d78f71f23b5449380ed2117df49c54f403d7e" translate="yes" xml:space="preserve">
          <source>@doc_180 had the right concept, except he is focused on numbers, whereas the original poster had issues with strings.</source>
          <target state="translated">@doc_180的概念是对的,只是他关注的是数字,而原发帖人对字符串有问题。</target>
        </trans-unit>
        <trans-unit id="d26c1bc98a73499555fd3bc490de9db0216946e1" translate="yes" xml:space="preserve">
          <source>According to commenter Justin Mclean on bug report &lt;a href=&quot;https://issues.apache.org/jira/browse/FLEX-33644&quot;&gt;FLEX-33664&lt;/a&gt;, the following is the culprit (see last two tests in my &lt;a href=&quot;http://wonderfl.net/c/dd23/read&quot;&gt;fiddle&lt;/a&gt; which verify this):</source>
          <target state="translated">根据关于bug报告&lt;a href=&quot;https://issues.apache.org/jira/browse/FLEX-33644&quot;&gt;FLEX-33664的&lt;/a&gt;评论员Justin Mclean 的介绍 ，以下是罪魁祸首（请参阅我的&lt;a href=&quot;http://wonderfl.net/c/dd23/read&quot;&gt;小提琴中的&lt;/a&gt;最后两个测试来验证这一点）：</target>
        </trans-unit>
        <trans-unit id="27678fe1efb1fa49b717efd64777e21dc1aeaf6a" translate="yes" xml:space="preserve">
          <source>ActionScript 3</source>
          <target state="translated">动作3</target>
        </trans-unit>
        <trans-unit id="74a81ee6778205d748feb8dfc2b136f4bdd1429f" translate="yes" xml:space="preserve">
          <source>As a hack, you could consider having a special handling on the client side, converting 'Null' string to something that will never occur, for example, XXNULLXX and converting back on the server.</source>
          <target state="translated">作为一个黑客,你可以考虑在客户端有一个特殊的处理方式,将 &quot;Null &quot;字符串转换为永远不会出现的东西,例如,XXNULLXX,然后在服务器上转换回来。</target>
        </trans-unit>
        <trans-unit id="a3c675a868e2dec5cd65501030e157606d7f53d8" translate="yes" xml:space="preserve">
          <source>At first I thought this was a coercion bug where &lt;code&gt;null&lt;/code&gt; was getting coerced to &lt;code&gt;&quot;null&quot;&lt;/code&gt; and a test of &lt;code&gt;&quot;null&quot; == null&lt;/code&gt; was passing. It's not. &lt;strong&gt;I was close, but so very, very wrong. Sorry about that!&lt;/strong&gt;</source>
          <target state="translated">起初，我认为这是一个强制错误，其中 &lt;code&gt;null&lt;/code&gt; 被强制转换为 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 并且测试 &lt;code&gt;&quot;null&quot; == null&lt;/code&gt; 通过。 不是。 &lt;strong&gt;我很近，但是非常非常错误。&lt;/strong&gt; &lt;strong&gt;对于那个很抱歉！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a8470b4f25cd6939251ceccd15af508c130c5ae2" translate="yes" xml:space="preserve">
          <source>Basically, the validation fails because 'content is null' and therefore your argument is not added to the outgoing SOAP Packet; thus causing the missing parameter error.</source>
          <target state="translated">基本上,验证失败的原因是 &quot;内容为空&quot;,因此你的参数没有被添加到传出的SOAP包中,从而导致参数缺失错误。</target>
        </trans-unit>
        <trans-unit id="08f98583c1ffe2e492a2510d98ff6f120d45719e" translate="yes" xml:space="preserve">
          <source>Cause</source>
          <target state="translated">Cause</target>
        </trans-unit>
        <trans-unit id="0cffe9dd062bb7ea6125a13cd0b3302f51a551a9" translate="yes" xml:space="preserve">
          <source>Check like this:</source>
          <target state="translated">像这样的检查。</target>
        </trans-unit>
        <trans-unit id="18d983553cee8a428a8b60fd7d5d1209322abf98" translate="yes" xml:space="preserve">
          <source>ColdFusion 8</source>
          <target state="translated">ColdFusion 8</target>
        </trans-unit>
        <trans-unit id="2342d91901e383edbcd869c83ecd65b9a6927d0e" translate="yes" xml:space="preserve">
          <source>Cute, huh?</source>
          <target state="translated">可爱吧?</target>
        </trans-unit>
        <trans-unit id="68a44c97554284cc327992b3e9b308ddb3fb9bf1" translate="yes" xml:space="preserve">
          <source>Edit 12/6/2013</source>
          <target state="translated">编辑1262013</target>
        </trans-unit>
        <trans-unit id="f5024430161386c6c120ac4dd97af27cc5c5df24" translate="yes" xml:space="preserve">
          <source>Flex 3.5</source>
          <target state="translated">Flex 3.5</target>
        </trans-unit>
        <trans-unit id="0b366dbd3b05ce6efa25c68180628b66e9afbb93" translate="yes" xml:space="preserve">
          <source>How to pass “Null” (a real surname!) to a SOAP web service in ActionScript 3</source>
          <target state="translated">如何在ActionScript 3中向SOAP Web服务传递 &quot;Null&quot;(一个真正的姓氏!)</target>
        </trans-unit>
        <trans-unit id="f2890105f6ac201b38f805c3c637e5bb95f9a91b" translate="yes" xml:space="preserve">
          <source>I am using:</source>
          <target state="translated">我正在使用。</target>
        </trans-unit>
        <trans-unit id="f887711dd0bd2bb0179c47ad24dd6334d01d3450" translate="yes" xml:space="preserve">
          <source>I guess getting this fixed in Apache Flex shouldn't be that hard to get done. I would recommend opening a Jira issue or to contact the guys of the apache-flex mailinglist. However this would only fix the client side. I can't say if ColdFusion will be able to work with null values encoded this way.</source>
          <target state="translated">我想,在Apache Flex中得到这个问题的修复应该不难完成。我会建议打开一个Jira问题或联系的apache-flex邮件列表的家伙。然而,这只能解决客户端的问题。我不能说,如果ColdFusion将能够工作与null值编码这种方式。</target>
        </trans-unit>
        <trans-unit id="e499efefe496fa4137c1893ca1d7acff3e02d988" translate="yes" xml:space="preserve">
          <source>I have one more recent addition to my last comment about RemoteObject/AMF. If you are using ColdFusion&amp;nbsp;10; then properties with a null value on an object are removed from the server-side object.  So, you have to check for the properties existence before accessing it or you will get a runtime error.</source>
          <target state="translated">我最近对RemoteObject / AMF的评论中还有一个新内容。 如果您使用的是ColdFusion 10； 然后将对象上具有空值的属性从服务器端对象中删除。 因此，您必须在访问属性之前检查属性是否存在，否则会遇到运行时错误。</target>
        </trans-unit>
        <trans-unit id="78de5fe306cec8b767a7e535af66f04834fac787" translate="yes" xml:space="preserve">
          <source>I spent a few hours on it, but I need to move on. It'll probably take a day or two.</source>
          <target state="translated">我花了几个小时,但我需要继续前进。可能需要一两天的时间。</target>
        </trans-unit>
        <trans-unit id="4939fdbb4371726272a03525f7ed94757131f5be" translate="yes" xml:space="preserve">
          <source>I'll also add that if you switch to using RemoteObject/AMF with ColdFusion, the null is passed without problems.</source>
          <target state="translated">我还要补充一下,如果你用ColdFusion切换到使用RemoteObjectAMF,传递null是没有问题的。</target>
        </trans-unit>
        <trans-unit id="923ca09a476e98b2656a0f7e60dc711e4c4bcd6e" translate="yes" xml:space="preserve">
          <source>I've since done lots of &lt;a href=&quot;http://wonderfl.net/c/dd23/read&quot;&gt;fiddling on wonderfl.net&lt;/a&gt; and tracing through the code in &lt;code&gt;mx.rpc.xml.*&lt;/code&gt;. At line 1795 of &lt;code&gt;XMLEncoder&lt;/code&gt; (in the 3.5 source), in &lt;code&gt;setValue&lt;/code&gt;, all of the XMLEncoding boils down to</source>
          <target state="translated">从那以后，我&lt;a href=&quot;http://wonderfl.net/c/dd23/read&quot;&gt;在wonderfl.net上&lt;/a&gt;做了很多摆弄，并在 &lt;code&gt;mx.rpc.xml.*&lt;/code&gt; 查找了代码。 在 &lt;code&gt;XMLEncoder&lt;/code&gt; 的第1795 行 （在3.5源代码中），在 &lt;code&gt;setValue&lt;/code&gt; 中 ，所有XMLEncoding都归结为</target>
        </trans-unit>
        <trans-unit id="459b9ea209a7494b8c92a2d1d31e84cb370230cb" translate="yes" xml:space="preserve">
          <source>It is not clear from the question that this is the source of the problem, and given the solution noted in a comment to the first answer (embedding the parameters in a structure) it seems likely that it was something else.</source>
          <target state="translated">从问题中不清楚这是问题的来源,鉴于第一个答案的注释中指出的解决方案(将参数嵌入到结构中),似乎很可能是其他的东西。</target>
        </trans-unit>
        <trans-unit id="ee4a52d6e3757ce3fd447feaf10944bce4b192c4" translate="yes" xml:space="preserve">
          <source>It is not pretty, but it may solve the issue for such a boundary case.</source>
          <target state="translated">虽然不漂亮,但对于这样的边界情况,可能会解决这个问题。</target>
        </trans-unit>
        <trans-unit id="193239475e3b806a6287a5e77abba8ea9bfa1720" translate="yes" xml:space="preserve">
          <source>It's a kludge, but assuming there's a minimum length for &lt;code&gt;SEARCHSTRING&lt;/code&gt;, for example 2 characters, &lt;code&gt;substring&lt;/code&gt; the &lt;code&gt;SEARCHSTRING&lt;/code&gt; parameter at the second character and pass it as two parameters instead: &lt;code&gt;SEARCHSTRING1 (&quot;Nu&quot;)&lt;/code&gt; and &lt;code&gt;SEARCHSTRING2 (&quot;ll&quot;).&lt;/code&gt;&lt;code&gt;Concatenate&lt;/code&gt; them back together when executing the query to the database.</source>
          <target state="translated">这是一个麻烦，但是假设 &lt;code&gt;SEARCHSTRING&lt;/code&gt; 的最小长度（例如2个字符），则将 &lt;code&gt;SEARCHSTRING&lt;/code&gt; 参数的第二个 &lt;code&gt;substring&lt;/code&gt; 化，然后将其作为两个参数传递： &lt;code&gt;SEARCHSTRING1 (&quot;Nu&quot;)&lt;/code&gt; 和 &lt;code&gt;SEARCHSTRING2 (&quot;ll&quot;).&lt;/code&gt; 对数据库执行查询时，将它们重新 &lt;code&gt;Concatenate&lt;/code&gt; 在一起。</target>
        </trans-unit>
        <trans-unit id="e04aa290a2622809c682b07c373883d187c07cfb" translate="yes" xml:space="preserve">
          <source>My guess is, it's passed as &lt;a href=&quot;http://en.wikipedia.org/wiki/NaN&quot;&gt;NaN&lt;/a&gt; (Not a Number). This will mess up the SOAP message unmarshalling process sometime (most notably in the &lt;a href=&quot;http://en.wikipedia.org/wiki/JBoss&quot;&gt;JBoss&lt;/a&gt; 5 server...). I remember extending the SOAP encoder and performing an explicit check on how NaN is handled.</source>
          <target state="translated">我的猜测是，它以&lt;a href=&quot;http://en.wikipedia.org/wiki/NaN&quot;&gt;NaN&lt;/a&gt; （不是数字）的形式传递。 这有时会弄乱SOAP消息的解组过程（最值得注意的是在&lt;a href=&quot;http://en.wikipedia.org/wiki/JBoss&quot;&gt;JBoss&lt;/a&gt; 5服务器中&amp;hellip;&amp;hellip;）。 我记得扩展了SOAP编码器，并对NaN的处理方式进行了明确的检查。</target>
        </trans-unit>
        <trans-unit id="406dc4db4b5708b0b40d3f692c5df3c98db2004d" translate="yes" xml:space="preserve">
          <source>Note that the error &lt;strong&gt;does not&lt;/strong&gt; occur when calling the webservice as an object from a ColdFusion page.</source>
          <target state="translated">请注意，从ColdFusion页面将Webservice作为对象调用时&lt;strong&gt;，不会&lt;/strong&gt;发生该错误。</target>
        </trans-unit>
        <trans-unit id="9a9eddbc3e121e428541aaa5054e27c42799aa6e" translate="yes" xml:space="preserve">
          <source>On the &lt;a href=&quot;http://xkcd.com/327/&quot;&gt;xkcd note&lt;/a&gt;, the &lt;a href=&quot;http://bobby-tables.com/&quot;&gt;Bobby Tables website&lt;/a&gt; has good advice for avoiding the improper interpretation of user data (in this case, the string &quot;Null&quot;) in SQL queries in various languages, including &lt;a href=&quot;http://en.wikipedia.org/wiki/Adobe_ColdFusion&quot;&gt;ColdFusion&lt;/a&gt;.</source>
          <target state="translated">在&lt;a href=&quot;http://xkcd.com/327/&quot;&gt;xkcd注释上&lt;/a&gt; ， &lt;a href=&quot;http://bobby-tables.com/&quot;&gt;Bobby Tables网站&lt;/a&gt;提供了很好的建议，以避免在各种语言（包括&lt;a href=&quot;http://en.wikipedia.org/wiki/Adobe_ColdFusion&quot;&gt;ColdFusion&lt;/a&gt; ）的SQL查询中避免对用户数据（在这种情况下为字符串&amp;ldquo; Null&amp;rdquo;）进行不正确的解释。</target>
        </trans-unit>
        <trans-unit id="29298d202cafc2e9cbd7bf061777d059150224b1" translate="yes" xml:space="preserve">
          <source>See also Radu Cotescu's blog post &lt;em&gt;&lt;a href=&quot;http://radu.cotescu.com/how-to-send-null-values-in-soapui-requests/&quot;&gt;How to send null values in soapUI requests&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">另请参见Radu Cotescu的博客文章&lt;em&gt;&lt;a href=&quot;http://radu.cotescu.com/how-to-send-null-values-in-soapui-requests/&quot;&gt;如何在soapUI请求中发送空值&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="2f900df805c38b70bf61dcf6d47cbf68f828d45e" translate="yes" xml:space="preserve">
          <source>Since there was a question about how nulls are treated, here is a quick sample application to demonstrate how a string &quot;null&quot; will relate to the reserved word null.</source>
          <target state="translated">因为有一个关于空位如何处理的问题,下面是一个快速的示例应用,展示一个字符串 &quot;null &quot;与保留字null的关系。</target>
        </trans-unit>
        <trans-unit id="b4377ea37d839e24c2b395131b8a88aabc051919" translate="yes" xml:space="preserve">
          <source>So the value of &quot;Null&quot; would be nothing else than a valid string, which is exactly what you are looking for.</source>
          <target state="translated">所以,&quot;Null &quot;的值除了一个有效的字符串之外,就没有别的了,这正是你要找的。</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="64918013817af7b320f2fbb9088501138b854d35" translate="yes" xml:space="preserve">
          <source>Stringifying a &lt;code&gt;null&lt;/code&gt; value in &lt;a href=&quot;http://en.wikipedia.org/wiki/ActionScript&quot;&gt;ActionScript&lt;/a&gt; will give the string &lt;code&gt;&quot;NULL&quot;&lt;/code&gt;. My suspicion is that someone has decided that it is, therefore, a good idea to decode the string &lt;code&gt;&quot;NULL&quot;&lt;/code&gt; as &lt;code&gt;null&lt;/code&gt;, causing the breakage you see here -- probably because they were passing in &lt;code&gt;null&lt;/code&gt; objects and getting strings in the database, when they didn't want that (so be sure to check for that kind of bug, too).</source>
          <target state="translated">在&lt;a href=&quot;http://en.wikipedia.org/wiki/ActionScript&quot;&gt;ActionScript中&lt;/a&gt;对 &lt;code&gt;null&lt;/code&gt; 值进行字符串化将得到字符串 &lt;code&gt;&quot;NULL&quot;&lt;/code&gt; 。 我的怀疑是，有人认为将字符串 &lt;code&gt;&quot;NULL&quot;&lt;/code&gt; 解码为 &lt;code&gt;null&lt;/code&gt; 是一个好主意，从而导致您在此处看到损坏&amp;mdash;可能是因为当它们传递 &lt;code&gt;null&lt;/code&gt; 对象并在数据库中获取字符串时，他们不想要那样（因此也请务必检查这种错误）。</target>
        </trans-unit>
        <trans-unit id="40cc33374cf7887c1c959c3df228a5f8a4b57eba" translate="yes" xml:space="preserve">
          <source>The only reasonable workaround I can think of, short of fixing this bug in every damn version of ActionScript, is to test fields for &quot;null&quot; and &lt;strong&gt;escape them as &lt;a href=&quot;https://stackoverflow.com/q/1239466/203705&quot;&gt;CDATA values&lt;/a&gt;.&lt;/strong&gt;</source>
          <target state="translated">除了在每个可恶的ActionScript版本中修复此错误之外，我能想到的唯一合理的解决方法是测试字段是否为&amp;ldquo; null&amp;rdquo;并将&lt;strong&gt;其作为&lt;a href=&quot;https://stackoverflow.com/q/1239466/203705&quot;&gt;CDATA值进行&lt;/a&gt;转义。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="96a8767d639dfeaacb6c5e2c25cd191c3aa44f4b" translate="yes" xml:space="preserve">
          <source>The parameter type is &lt;code&gt;string&lt;/code&gt;.</source>
          <target state="translated">参数类型为 &lt;code&gt;string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ed6408b62ce617a2949536d36fd02090daeaf2b1" translate="yes" xml:space="preserve">
          <source>The problem could be in Flex's SOAP encoder. Try extending the SOAP encoder in your Flex application and debug the program to see how the null value is handled.</source>
          <target state="translated">问题可能是在Flex的SOAP编码器中。尝试在你的Flex应用程序中扩展SOAP编码器,并调试程序,看看空值是如何处理的。</target>
        </trans-unit>
        <trans-unit id="5c33891f4670754851f4c2504e15d0c2345bb5e9" translate="yes" xml:space="preserve">
          <source>The solution is to change the &lt;code&gt;mx.rpc.xml.XMLEncoder&lt;/code&gt; file. This is line 121:</source>
          <target state="translated">解决方案是更改 &lt;code&gt;mx.rpc.xml.XMLEncoder&lt;/code&gt; 文件。 这是第121行：</target>
        </trans-unit>
        <trans-unit id="de3d905c386aff3e6afe979f4b889a3e6f2b4ae5" translate="yes" xml:space="preserve">
          <source>The trace output is:</source>
          <target state="translated">跟踪输出是。</target>
        </trans-unit>
        <trans-unit id="c097412282e2a65a24036f4f1ba00d085c44c3c3" translate="yes" xml:space="preserve">
          <source>This code, according to my original fiddle, returns an empty XML element. But why?</source>
          <target state="translated">这个代码,根据我原来的fiddle,返回一个空的XML元素。但是,为什么呢?</target>
        </trans-unit>
        <trans-unit id="773a00fdf7d4bdf7ceb62579e80b63e6c1c3c71d" translate="yes" xml:space="preserve">
          <source>This is a change in behavior from ColdFusion&amp;nbsp;9; where the null properties would turn into empty strings.</source>
          <target state="translated">与ColdFusion 9相比，这是行为上的变化； null属性将变成空字符串。</target>
        </trans-unit>
        <trans-unit id="aa2029e27a48117d867c828563c3db0e4d59dce5" translate="yes" xml:space="preserve">
          <source>Tracking it down</source>
          <target state="translated">追踪它</target>
        </trans-unit>
        <trans-unit id="c2e57ef74d83eec884d8e558a640aaa52275a45a" translate="yes" xml:space="preserve">
          <source>Translate all characters into their hex-entity equivalents. In this case, &lt;code&gt;Null&lt;/code&gt; would be converted into &lt;code&gt;&amp;amp;#4E;&amp;amp;#75;&amp;amp;#6C;&amp;amp;#6C;&lt;/code&gt;</source>
          <target state="translated">将所有字符转换为其等效的十六进制实体。 在这种情况下， &lt;code&gt;Null&lt;/code&gt; 将转换为 &lt;code&gt;&amp;amp;#4E;&amp;amp;#75;&amp;amp;#6C;&amp;amp;#6C;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7cd4ebda0886a79f5011fb387c1a02284a7365b4" translate="yes" xml:space="preserve">
          <source>We have an employee whose surname is Null. Our employee lookup application is killed when that last name is used as the search term (which happens to be quite often now). The error received (thanks Fiddler!) is:</source>
          <target state="translated">我们有一个员工的姓氏是Null。我们的员工查询程序在使用该姓氏作为搜索词时被杀死(现在这种情况经常发生)。收到的错误是:(感谢Fiddler!)。</target>
        </trans-unit>
        <trans-unit id="308c89d30ee6db7b9ecb19b794091a75d123f307" translate="yes" xml:space="preserve">
          <source>Well, I guess that Flex' implementation of the SOAP Encoder seems to serialize null values incorrectly. Serializing them as a String Null doesn't seem to be a good solution. The formally correct version seems to be to pass a null value as:</source>
          <target state="translated">好吧,我想Flex的SOAP编码器的实现似乎不正确地串行化空值。将它们序列化为字符串Null似乎不是一个好的解决方案。正式的正确版本似乎是传递一个null值作为。</target>
        </trans-unit>
        <trans-unit id="c3a1f37a4e99f4ebffebe16b84941a43e3f41db2" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;currentChild.appendChild&lt;/code&gt; is passed the string &lt;code&gt;&quot;null&quot;&lt;/code&gt;, it first converts it to a root XML element with text &lt;code&gt;null&lt;/code&gt;, and then tests that element against the null literal. This is a weak equality test, so either the XML containing null is coerced to the null type, or the null type is coerced to a root xml element containing the string &quot;null&quot;, and the test passes where it arguably should fail. One fix might be to always use &lt;a href=&quot;http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/operators.html#strict_equality&quot;&gt;strict equality&lt;/a&gt; tests when checking XML (or anything, really) for &quot;nullness.&quot;</source>
          <target state="translated">当将字符串 &lt;code&gt;&quot;null&quot;&lt;/code&gt; 传递给 &lt;code&gt;currentChild.appendChild&lt;/code&gt; 时 ，它将首先将其转换为文本为 &lt;code&gt;null&lt;/code&gt; 的根XML元素，然后针对该null文字测试该元素。 这是一个弱等式测试，因此将包含null的XML强制转换为null类型，或者将null类型强制转换为包含字符串&amp;ldquo; null&amp;rdquo;的根xml元素，并且该测试通过了可能会失败的地方。 一种解决方法是在检查XML（或其他任何东西）是否为&amp;ldquo;空&amp;rdquo;时始终使用&lt;a href=&quot;http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/operators.html#strict_equality&quot;&gt;严格的相等性&lt;/a&gt;测试。</target>
        </trans-unit>
        <trans-unit id="877e7dcd369777017e172aa27033ac212b6f56e0" translate="yes" xml:space="preserve">
          <source>You have to extend this class to remove the validation.  Then there is a big snowball up the chain, modifying SOAPEncoder to use your modified XMLEncoder, and then modifying Operation to use your modified SOAPEncoder, and then moidfying WebService to use your alternate Operation class.</source>
          <target state="translated">你必须要扩展这个类来删除验证。然后还有一个大雪球往上滚,修改SOAPEncoder使用你修改过的XMLEncoder,再修改Operation使用你修改过的SOAPEncoder,然后moidfying WebService使用你的备用Operation类。</target>
        </trans-unit>
        <trans-unit id="3926523f25dc8876bc153f0713c91eb61a5a7e46" translate="yes" xml:space="preserve">
          <source>You may be able to just fix the XMLEncoder line and do some &lt;a href=&quot;https://en.wikipedia.org/wiki/Monkey_patch&quot;&gt;monkey patching&lt;/a&gt; to use your own class.</source>
          <target state="translated">您也许可以修复XMLEncoder行，并进行一些&lt;a href=&quot;https://en.wikipedia.org/wiki/Monkey_patch&quot;&gt;猴子修补程序&lt;/a&gt;以使用您自己的类。</target>
        </trans-unit>
        <trans-unit id="c153947527842c1d4665c2d9e89c221f1fb7cde6" translate="yes" xml:space="preserve">
          <source>null string is not equal to null reserved word using the != condition</source>
          <target state="translated">null字符串不等于null的保留字,使用 !=条件</target>
        </trans-unit>
        <trans-unit id="d8e72b2c5ece5bbfd6ef420a56b1a98be5cf82da" translate="yes" xml:space="preserve">
          <source>null string is not equal to null reserved word using the == condition</source>
          <target state="translated">空的字符串不等于空的保留词,使用==条件</target>
        </trans-unit>
        <trans-unit id="0e4d2e42ac5d9802583f1484a8d99ea986417b60" translate="yes" xml:space="preserve">
          <source>null string is not equal to null reserved word using the === condition</source>
          <target state="translated">null字符串不等于null保留词,使用====条件</target>
        </trans-unit>
        <trans-unit id="71fd2f675fdcd0012800f85123513f89ff946960" translate="yes" xml:space="preserve">
          <source>which is essentially the same as:</source>
          <target state="translated">其本质上与:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
