<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/444798">
    <body>
      <group id="444798">
        <trans-unit id="d7ea84681048f2e929f81db989aa59a2d8ac1865" translate="yes" xml:space="preserve">
          <source>.NET Core 2.0+ only (as of now)</source>
          <target state="translated">.NET Core 2.0+のみ(現在のところ</target>
        </trans-unit>
        <trans-unit id="e79cd3893ef8c8f2fc330336ec327468a27795fd" translate="yes" xml:space="preserve">
          <source>.NET Core has had a pair of methods to deal with this since version 2.0 :</source>
          <target state="translated">.NET Coreはバージョン2.0以降、これに対処するためのメソッドのペアを持っていました。</target>
        </trans-unit>
        <trans-unit id="5959f410f2fcf8089d275b4318ded842f4ee7d45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/15464440/11333&quot;&gt;This&lt;/a&gt; answer however brings up the inherent problem that we can't compare text case insensitive until we know both texts are the same culture and we know  what that culture is. This is maybe a less popular answer, but I think it is more correct and that's why I marked it as such.</source>
          <target state="translated">ただし、 &lt;a href=&quot;https://stackoverflow.com/a/15464440/11333&quot;&gt;この&lt;/a&gt;答えは、両方のテキストが同じ文化であり、その文化が何であるかがわかるまで、大文字と小文字を区別せずにテキストを比較できないという固有の問題を引き起こします。 これはあまり人気のない答えかもしれませんが、私はそれがより正しいと思うので、そのようにマークしました。</target>
        </trans-unit>
        <trans-unit id="40306d1509e9fd7bd3a5d6cbb13ffda8f178a5aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OrdinalIgnoreCase, CurrentCultureIgnoreCase or InvariantCultureIgnoreCase?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OrdinalIgnoreCase、CurrentCultureIgnoreCase、またはInvariantCultureIgnoreCase？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5277a2241002c732d5300dfd06502b2f34ae7c6d" translate="yes" xml:space="preserve">
          <source>Alternative solution using Regex:</source>
          <target state="translated">Regexを使った代替案。</target>
        </trans-unit>
        <trans-unit id="9e3766b02a05d2f1ada682ac5e26ebea5d5f19b6" translate="yes" xml:space="preserve">
          <source>And usage is something like:</source>
          <target state="translated">そして、使い方はこんな感じです。</target>
        </trans-unit>
        <trans-unit id="c288b5abcecab19e933b03180fcfaf006fd7af32" translate="yes" xml:space="preserve">
          <source>As simple and works</source>
          <target state="translated">シンプルで機能性に優れた</target>
        </trans-unit>
        <trans-unit id="0d549f6f0822b73386eb38f4384956dcf11326a8" translate="yes" xml:space="preserve">
          <source>Based on these rules you should use:</source>
          <target state="translated">これらのルールに基づいて、あなたは使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="2530fe7143247da7480d306772712622a1d387ef" translate="yes" xml:space="preserve">
          <source>By Changing case</source>
          <target state="translated">ケースを変更することで</target>
        </trans-unit>
        <trans-unit id="90b359080b18ce270e92120971a7ba6aae84c35e" translate="yes" xml:space="preserve">
          <source>By Index of</source>
          <target state="translated">インデックス別</target>
        </trans-unit>
        <trans-unit id="b6606f6c51c5f53c6c7ceb23c3923db4da97c5b4" translate="yes" xml:space="preserve">
          <source>By Regex</source>
          <target state="translated">正規表現による</target>
        </trans-unit>
        <trans-unit id="e52050ce0344d953fc86419915270f188583c9e2" translate="yes" xml:space="preserve">
          <source>C# variant:</source>
          <target state="translated">C#のバリアント。</target>
        </trans-unit>
        <trans-unit id="afd9fd14fb905ebc6d557e5dcd06b1313aa19903" translate="yes" xml:space="preserve">
          <source>Case insensitive 'Contains(string)'</source>
          <target state="translated">大文字小文字を区別しない 'Contains(string)'</target>
        </trans-unit>
        <trans-unit id="093743f90c366f3346a4626e0147ea26113350c4" translate="yes" xml:space="preserve">
          <source>Don'ts</source>
          <target state="translated">Don'ts</target>
        </trans-unit>
        <trans-unit id="586c15c6fd8448116ae5a0f2e995d41e36f153b8" translate="yes" xml:space="preserve">
          <source>Dos</source>
          <target state="translated">Dos</target>
        </trans-unit>
        <trans-unit id="77ca9b61a054b706c8eb86d834d0c6e69a47ecb4" translate="yes" xml:space="preserve">
          <source>Even better is defining a new extension method for string:</source>
          <target state="translated">さらに良いのは、文字列のための新しい拡張メソッドを定義していることです。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="9a2cbc34d065fb65656b2063bb3f5a7d121fbc6b" translate="yes" xml:space="preserve">
          <source>For most cases, in mono-lingual, English code bases &lt;a href=&quot;https://stackoverflow.com/a/444818/11333&quot;&gt;this&lt;/a&gt; answer will suffice. I'm suspecting because most people coming here fall in this category this is the most popular answer.</source>
          <target state="translated">ほとんどの場合、単一言語の英語のコードベースでは、 &lt;a href=&quot;https://stackoverflow.com/a/444818/11333&quot;&gt;この&lt;/a&gt;答えで十分です。 ここに来るほとんどの人がこのカテゴリーに該当するので、これが最も人気のある答えだと思います。</target>
        </trans-unit>
        <trans-unit id="01e8855afa40286aaf1698d3bc206c8973138e21" translate="yes" xml:space="preserve">
          <source>I know that this is not the C#, but in the framework (VB.NET) there is already such a function</source>
          <target state="translated">私は、これはC#ではないことを知っているが、フレームワーク(VB.NET)では、すでにこのような関数があります</target>
        </trans-unit>
        <trans-unit id="ab4e3c8a22f2080a468115a52cba5d38079a4f3b" translate="yes" xml:space="preserve">
          <source>In time, they will probably make their way into the .NET Standard and, from there, into all the other implementations of the Base Class Library.</source>
          <target state="translated">やがて、それらはおそらく.NET標準に組み込まれ、そこからベースクラスライブラリの他のすべての実装に組み込まれることになるでしょう。</target>
        </trans-unit>
        <trans-unit id="c1275a34e98253fcfa85a71fc078124d0348f597" translate="yes" xml:space="preserve">
          <source>Is there a way to make the following return true?</source>
          <target state="translated">以下のような戻り値を真にする方法はありますか?</target>
        </trans-unit>
        <trans-unit id="41eb1876c1792272999607eb5a18213c23b3ab72" translate="yes" xml:space="preserve">
          <source>Just like this:</source>
          <target state="translated">こんな感じで。</target>
        </trans-unit>
        <trans-unit id="283fa1715023367e46e06ce59e987fa93484c298" translate="yes" xml:space="preserve">
          <source>Just to build on the answer here, you can create a string extension method to make this a little more user-friendly:</source>
          <target state="translated">ここでの答えを元に、文字列の拡張メソッドを作成するだけで、もう少し使いやすくなります。</target>
        </trans-unit>
        <trans-unit id="ab564241d56d2a6d9b704ecfba0866b810008b1e" translate="yes" xml:space="preserve">
          <source>MSDN</source>
          <target state="translated">MSDN</target>
        </trans-unit>
        <trans-unit id="29d2ccae572a132867e7a45afe192e33bf572950" translate="yes" xml:space="preserve">
          <source>Note, that &lt;a href=&quot;https://stackoverflow.com/questions/25666993/c-sharp-null-propagating-operator-conditional-access-expression-if-blocks&quot;&gt;null propagation&lt;/a&gt;&lt;code&gt;?.&lt;/code&gt; is available since C# 6.0 (VS 2015), for older versions use</source>
          <target state="translated">その&lt;a href=&quot;https://stackoverflow.com/questions/25666993/c-sharp-null-propagating-operator-conditional-access-expression-if-blocks&quot;&gt;ヌル伝播&lt;/a&gt; &lt;code&gt;?.&lt;/code&gt; C＃6.0（VS 2015）以降で使用可能、古いバージョンでは</target>
        </trans-unit>
        <trans-unit id="f9acc8aac4b87c892398798714d689d423a38e96" translate="yes" xml:space="preserve">
          <source>One issue with the answer is that it will throw an exception if a string is null. You can add that as a check so it won't:</source>
          <target state="translated">この答えの問題点は、文字列がnullの場合に例外が発生することです。これをチェックとして追加することで、そうならないようにすることができます。</target>
        </trans-unit>
        <trans-unit id="09f0e5b8a233db5605df7cad750be353d6a2df66" translate="yes" xml:space="preserve">
          <source>Oops, just saw that last bit.  A case insensitive compare would &lt;code&gt;*&lt;/code&gt;probably&lt;code&gt;*&lt;/code&gt; do the same anyway, and if performance is not an issue, I don't see a problem with creating uppercase copies and comparing those.  I could have sworn that I once saw a case-insensitive compare once...</source>
          <target state="translated">おっと、ちょうど最後のビットを見た。 大文字と小文字を区別しない比較は &lt;code&gt;*&lt;/code&gt; おそらく &lt;code&gt;*&lt;/code&gt; とにかく同じことを行い、パフォーマンスに問題がない場合は、大文字のコピーを作成して比較することで問題は発生しません。 大文字小文字を区別しない比較を一度見たと誓ったかもしれない...</target>
        </trans-unit>
        <trans-unit id="8344d4583e02839d89cd5cd3190cece1b97ea0da" translate="yes" xml:space="preserve">
          <source>Output is &quot;Reset&quot;</source>
          <target state="translated">出力は &quot;リセット&quot;</target>
        </trans-unit>
        <trans-unit id="9b736be42f251c03b231b521716afd93b4579efc" translate="yes" xml:space="preserve">
          <source>Simple way for newbie:</source>
          <target state="translated">初心者のための簡単な方法。</target>
        </trans-unit>
        <trans-unit id="8ca47e1c50c81d11f5377c183b4af7bb23a0fa73" translate="yes" xml:space="preserve">
          <source>Since 0 (zero) can be an index, you check against -1.</source>
          <target state="translated">0(ゼロ)はインデックスになり得るので、-1をチェックします。</target>
        </trans-unit>
        <trans-unit id="908ce872d5835df04c4218de13a48ddd13cfef76" translate="yes" xml:space="preserve">
          <source>Since this is missing, here are some recommendations about when to use which one:</source>
          <target state="translated">これがないので、どのタイミングで使うのがいいのか、おすすめのものをご紹介します。</target>
        </trans-unit>
        <trans-unit id="973ae5a1f7eb4392ed569b92c044d098c24c7ac3" translate="yes" xml:space="preserve">
          <source>String.Contains(Char, &lt;strong&gt;StringComparison&lt;/strong&gt;)</source>
          <target state="translated">String.Contains（Char、 &lt;strong&gt;StringComparison&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="42fa4f7244bf67da66f04a8d91ad3293b1122c56" translate="yes" xml:space="preserve">
          <source>String.Contains(String, &lt;strong&gt;StringComparison&lt;/strong&gt;)</source>
          <target state="translated">String.Contains（String、 &lt;strong&gt;StringComparison&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="0a3e4cb8fd87ecc07781972118a1324cf8d461ac" translate="yes" xml:space="preserve">
          <source>StringExtension class is the way forward, I've combined a couple of the posts above to give a complete code example:</source>
          <target state="translated">StringExtensionクラスは前進する方法です、私は完全なコード例を与えるために、上記の投稿のカップルを組み合わせました。</target>
        </trans-unit>
        <trans-unit id="dedf58a19811d520c755e343463be870b381e0ec" translate="yes" xml:space="preserve">
          <source>Switch current use of string operations based on the invariant
culture to use the non-linguistic &lt;code&gt;StringComparison.Ordinal&lt;/code&gt; or      &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; when the comparison is</source>
          <target state="translated">インバリアントカルチャに基づく文字列操作の現在の使用を切り替えて、比較が非言語的である場合は &lt;code&gt;StringComparison.Ordinal&lt;/code&gt; または &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; を使用します</target>
        </trans-unit>
        <trans-unit id="d9aec165d49c48375c24b25789d75b19f527d8e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InStr&lt;/code&gt; method from the VisualBasic assembly is the best if you have a concern about internationalization (or you could reimplement it).  Looking at in it dotNeetPeek shows that not only does it account for caps and lowercase, but also for kana type and full- vs. half-width characters (mostly relevant for Asian languages, although there are full-width versions of the Roman alphabet too).  I'm skipping over some details, but check out the private method &lt;code&gt;InternalInStrText&lt;/code&gt;:</source>
          <target state="translated">VisualBasicアセンブリの &lt;code&gt;InStr&lt;/code&gt; メソッドは、国際化について懸念がある場合（または再実装できる場合）に最適です。 中を見ると、dotNeetPeekは、大文字と小文字だけでなく、カナ文字と全角文字と半角文字も考慮していることを示しています（ローマ字の全角バージョンもありますが、主にアジア言語に関連しています）。 ）。 詳細は省略していますが、プライベートメソッド &lt;code&gt;InternalInStrText&lt;/code&gt; を確認してください。</target>
        </trans-unit>
        <trans-unit id="e9dbd47e2db3d1cbd7f8ca59b8f530d35bed55c5" translate="yes" xml:space="preserve">
          <source>The trick here is to look for the string, ignoring case, but to keep it exactly the same (with the same case).</source>
          <target state="translated">ここでのコツは、大文字小文字を無視して文字列を探すことですが、全く同じ(同じ大文字小文字で)にすることです。</target>
        </trans-unit>
        <trans-unit id="b11e43b9475f18146d88230e0041f4769ce86cde" translate="yes" xml:space="preserve">
          <source>The zero-based index position of value if that string is found, or -1
  if it is not. If value is String.Empty, the return value is 0.</source>
          <target state="translated">その文字列が見つかった場合は値のゼロベースのインデックス位置、見つからなかった場合は-1を返します。値が String.Empty の場合、戻り値は 0 です。</target>
        </trans-unit>
        <trans-unit id="a3781a4c88588206e742c11daec5fd820dcdd522" translate="yes" xml:space="preserve">
          <source>There doesn't seem to be an overload that allows me to set the case sensitivity.. Currently I UPPERCASE them both, but that's just silly (by which I am referring to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalization_and_localization&quot;&gt;i18n&lt;/a&gt; issues that come with up- and down casing).</source>
          <target state="translated">大文字と小文字の区別を設定するための過負荷はないようです。現在は両方を大文字にしていますが、それはばかげています（大文字と小文字の大文字と小文字に関連する&lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalization_and_localization&quot;&gt;i18nの&lt;/a&gt;問題を参照しています）。</target>
        </trans-unit>
        <trans-unit id="594fbdf5a86b028e3f69b71cb9dc6548868e4e34" translate="yes" xml:space="preserve">
          <source>These are the easiest solutions.</source>
          <target state="translated">これらが一番簡単な解決策です。</target>
        </trans-unit>
        <trans-unit id="0168b460ba5582e831c090d1f16681f2925554e0" translate="yes" xml:space="preserve">
          <source>This boolean value will return if the string is contained or not</source>
          <target state="translated">このブール値は、文字列が含まれているかどうかを返します。</target>
        </trans-unit>
        <trans-unit id="e1fad424e6c221bbe3e33e1de38882e31617e66b" translate="yes" xml:space="preserve">
          <source>This is clean and simple.</source>
          <target state="translated">すっきりとしていてシンプルです。</target>
        </trans-unit>
        <trans-unit id="e3bd071b41a0a3fc32fa7194b0cdc2ff9792aa0d" translate="yes" xml:space="preserve">
          <source>This is quite similar to other example here, but I've decided to simplify enum to bool, primary because other alternatives are normally not needed. Here is my example:</source>
          <target state="translated">これは他の例とよく似ていますが、通常は他の選択肢は必要ないので、enumをbool,primaryに単純化することにしました。これが私の例です。</target>
        </trans-unit>
        <trans-unit id="c56aed9a15a609ecc15c26704f8b7560d3a31731" translate="yes" xml:space="preserve">
          <source>This question is ancient and since then I have realized I asked for a simple answer for a really vast and difficult topic if you care to investigate it fully.</source>
          <target state="translated">この質問は古代のもので、それ以来、私はあなたがそれを完全に調査するために気にしている場合は、本当に広大で難しいトピックのための簡単な答えを求めていることに気付いた。</target>
        </trans-unit>
        <trans-unit id="6b01723bd3f30ff9351f1469f7dd15a3b31b2c55" translate="yes" xml:space="preserve">
          <source>This solution is transparent about &lt;strong&gt;the definition of case-insensitivity, which is language dependent&lt;/strong&gt;. For example, the English language uses the characters &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt; for the upper and lower case versions of the ninth letter, whereas the Turkish language uses these characters for the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dotted_and_dotless_I&quot;&gt;eleventh and twelfth letters&lt;/a&gt; of its 29 letter-long alphabet. The Turkish upper case version of 'i' is the unfamiliar character 'İ'.</source>
          <target state="translated">このソリューションは&lt;strong&gt;、言語に依存する大文字と小文字を区別しない定義&lt;/strong&gt;については透過&lt;strong&gt;的&lt;/strong&gt;です。 たとえば、英語では9番目の文字の大文字と小文字のバージョンに &lt;code&gt;I&lt;/code&gt; と &lt;code&gt;i&lt;/code&gt; の文字が使用されているのに対し、トルコ語では29文字のアルファベットの&lt;a href=&quot;http://en.wikipedia.org/wiki/Dotted_and_dotless_I&quot;&gt;11番目と12番目の文字&lt;/a&gt;にこれらの文字が使用されています。 トルコ語の大文字バージョンの「i」は、なじみのない文字「İ」です。</target>
        </trans-unit>
        <trans-unit id="564d8ed126483751019d127c88e08af1831914ad" translate="yes" xml:space="preserve">
          <source>Thus the strings &lt;code&gt;tin&lt;/code&gt; and &lt;code&gt;TIN&lt;/code&gt; are the same word &lt;em&gt;in English&lt;/em&gt;, but different words &lt;em&gt;in Turkish&lt;/em&gt;. As I understand, one means 'spirit' and the other is an onomatopoeia word. (Turks, please correct me if I'm wrong, or suggest a better example)</source>
          <target state="translated">したがって、文字列 &lt;code&gt;tin&lt;/code&gt; と &lt;code&gt;TIN&lt;/code&gt; は&lt;em&gt;英語&lt;/em&gt;では同じ単語&lt;em&gt;です&lt;/em&gt;が&lt;em&gt;、トルコ&lt;/em&gt;語&lt;em&gt;では&lt;/em&gt;別の単語です。 私が理解しているように、1つは「精神」を意味し、もう1つは擬音語です。 （タークス、私が間違っている場合は修正してください。またはより良い例を提案してください）</target>
        </trans-unit>
        <trans-unit id="86f61e72bf5195cb3e5c74a9cc4fe790bc1207d0" translate="yes" xml:space="preserve">
          <source>To summarise, you can only answer the question 'are these two strings the same but in different cases' &lt;em&gt;if you know what language the text is in&lt;/em&gt;. If you don't know, you'll have to take a punt. Given English's hegemony in software, you should probably resort to &lt;a href=&quot;https://stackoverflow.com/questions/9760237/what-does-cultureinfo-invariantculture-mean&quot;&gt;&lt;code&gt;CultureInfo.InvariantCulture&lt;/code&gt;&lt;/a&gt;, because it'll be wrong in familiar ways.</source>
          <target state="translated">要約すると&lt;em&gt;、テキストの言語がわかっている場合に&lt;/em&gt;のみ、「これらの2つの文字列は同じですが、異なる場合」という質問に答えることができ&lt;em&gt;ます&lt;/em&gt; 。 あなたが知らなければ、パントを取る必要があります。 ソフトウェアにおける英語の覇権を考えると、慣れ親しんだ方法で間違っているため、おそらく&lt;a href=&quot;https://stackoverflow.com/questions/9760237/what-does-cultureinfo-invariantculture-mean&quot;&gt; &lt;code&gt;CultureInfo.InvariantCulture&lt;/code&gt; &lt;/a&gt;に頼る必要があります。</target>
        </trans-unit>
        <trans-unit id="2dc0eef1bd33b4bf153b1382a1160b7f556e66b2" translate="yes" xml:space="preserve">
          <source>To test if the string &lt;code&gt;paragraph&lt;/code&gt; contains the string &lt;code&gt;word&lt;/code&gt; (thanks @QuarterMeister)</source>
          <target state="translated">文字列の &lt;code&gt;paragraph&lt;/code&gt; に文字列の &lt;code&gt;word&lt;/code&gt; が含まれているかどうかをテストするには（@QuarterMeisterに感謝）</target>
        </trans-unit>
        <trans-unit id="526e17802d5e428ad056a5fb1638e0d3f633a4c9" translate="yes" xml:space="preserve">
          <source>USAGE:</source>
          <target state="translated">USAGE:</target>
        </trans-unit>
        <trans-unit id="3628d3e49b147a61ac95fb89dc0071077bb7b9bf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.CurrentCulture-based&lt;/code&gt; string operations
when displaying the output to the user.</source>
          <target state="translated">ユーザーに出力を表示するときは、 &lt;code&gt;StringComparison.CurrentCulture-based&lt;/code&gt; 文字列操作を使用します。</target>
        </trans-unit>
        <trans-unit id="741e1769499106b278e73532a4f20495a038f9b9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.InvariantCulture&lt;/code&gt; -based string</source>
          <target state="translated">&lt;code&gt;StringComparison.InvariantCulture&lt;/code&gt; ベースの文字列を使用する</target>
        </trans-unit>
        <trans-unit id="60d07819b7d6d2c55c3743937911c498333b2ba4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; comparisons
for increased speed.</source>
          <target state="translated">速度を上げるには、 &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; 比較を使用します 。</target>
        </trans-unit>
        <trans-unit id="055796aaa0333b8c896aed37393fbefec18e1f97" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; for comparisons
as your safe default for culture-agnostic string matching.</source>
          <target state="translated">比較に &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; を使用して、カルチャに依存しない文字列マッチングの安全なデフォルトとして使用します。</target>
        </trans-unit>
        <trans-unit id="bf1ddf204de3c9fd9654c376db6fd25d4685c804" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ToUpperInvariant&lt;/code&gt; rather than &lt;code&gt;ToLowerInvariant&lt;/code&gt; when
normalizing strings for comparison.</source>
          <target state="translated">比較のために文字列を正規化するときは、 &lt;code&gt;ToLowerInvariant&lt;/code&gt; ではなく &lt;code&gt;ToUpperInvariant&lt;/code&gt; を使用してください。</target>
        </trans-unit>
        <trans-unit id="ef5e2a756503d5c24a1765c050f3cba85951e6b7" translate="yes" xml:space="preserve">
          <source>Use overloads for string operations that don't explicitly
or implicitly specify the string comparison mechanism.</source>
          <target state="translated">文字列比較メカニズムを明示的または暗黙的に指定しない文字列操作にはオーバーロードを使用します。</target>
        </trans-unit>
        <trans-unit id="b543720e8daabc3733964f244cca2d14e58df202" translate="yes" xml:space="preserve">
          <source>Use this:</source>
          <target state="translated">これを使って</target>
        </trans-unit>
        <trans-unit id="10433c64049da93d83b924b0e08556f34f63e73c" translate="yes" xml:space="preserve">
          <source>Using a RegEx is a straight way to do this:</source>
          <target state="translated">RegExを使うのがストレートな方法です。</target>
        </trans-unit>
        <trans-unit id="d8f096569d8c3619e1403f4894636d27a8f7f554" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;culture&lt;/code&gt; is the instance of &lt;a href=&quot;http://msdn.microsoft.com/en-gb/library/system.globalization.cultureinfo(v=vs.110).aspx&quot;&gt;&lt;code&gt;CultureInfo&lt;/code&gt;&lt;/a&gt; describing the language that the text is written in.</source>
          <target state="translated">ここで、 &lt;code&gt;culture&lt;/code&gt; は、テキストが記述されている言語を記述する&lt;a href=&quot;http://msdn.microsoft.com/en-gb/library/system.globalization.cultureinfo(v=vs.110).aspx&quot;&gt; &lt;code&gt;CultureInfo&lt;/code&gt; &lt;/a&gt;のインスタンスです。</target>
        </trans-unit>
        <trans-unit id="dc5e2f77d71a8417bcacdaae9a291d9d19125884" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;IndexOf()&lt;/code&gt; like this:</source>
          <target state="translated">次のように &lt;code&gt;IndexOf()&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="89cb9c90e272c35c2c2976cd923fc22093ef0bf6" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;string.indexof ()&lt;/code&gt; function. This will be case insensitive</source>
          <target state="translated">&lt;code&gt;string.indexof ()&lt;/code&gt; 関数を使用できます。 これは大文字と小文字を区別しません</target>
        </trans-unit>
        <trans-unit id="a0e653c56062f605ed8ed7f366dc6698b3ab7dfc" translate="yes" xml:space="preserve">
          <source>You could always just up or downcase the strings first.</source>
          <target state="translated">最初に弦を上げたり下げたりすることもできます。</target>
        </trans-unit>
        <trans-unit id="6a7495925f7fecd82ebaf985f15d1b4af6f79c8c" translate="yes" xml:space="preserve">
          <source>You could use the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms224425(v=vs.110).aspx&quot;&gt;String.IndexOf Method&lt;/a&gt; and pass &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.stringcomparer.ordinalignorecase(v=vs.110).aspx&quot;&gt;&lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt;&lt;/a&gt; as the type of search to use:</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms224425(v=vs.110).aspx&quot;&gt;String.IndexOfメソッド&lt;/a&gt;を使用して、使用する検索のタイプ​​として&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.stringcomparer.ordinalignorecase(v=vs.110).aspx&quot;&gt; &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; &lt;/a&gt;を渡すことができます。</target>
        </trans-unit>
        <trans-unit id="261a9015da8e88b5ddc35de053f3967f876f9ae2" translate="yes" xml:space="preserve">
          <source>if you want to check if your passed string is in string then there is a simple method for that.</source>
          <target state="translated">もし、渡された文字列が文字列内にあるかどうかをチェックしたい場合は、そのためのシンプルなメソッドがあります。</target>
        </trans-unit>
        <trans-unit id="94ebeda004ca6e860b085fd09428620706e6f011" translate="yes" xml:space="preserve">
          <source>linguistically irrelevant (symbolic, for example).</source>
          <target state="translated">言語的には無関係</target>
        </trans-unit>
        <trans-unit id="33c9b2fd854ed6a2cfcad916c56e0bd0b221cf15" translate="yes" xml:space="preserve">
          <source>link of source: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms973919.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/ms973919.aspx&lt;/a&gt;</source>
          <target state="translated">ソースのリンク： &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms973919.aspx&quot;&gt;http&lt;/a&gt; : //msdn.microsoft.com/en-us/library/ms973919.aspx</target>
        </trans-unit>
        <trans-unit id="1400ca9eaeea1ab863726d5a0fbf1e57821fbe6d" translate="yes" xml:space="preserve">
          <source>operations in most cases; one of the few exceptions would be</source>
          <target state="translated">演算子はほとんどの場合で使用されます。</target>
        </trans-unit>
        <trans-unit id="e01a272525fbe487f38b023d20e84a2ce53eb650" translate="yes" xml:space="preserve">
          <source>persisting linguistically meaningful but culturally-agnostic data.</source>
          <target state="translated">言語的には意味のある、しかし文化的には不可解なデータを持続させること。</target>
        </trans-unit>
        <trans-unit id="2a94a6a5f47292f5baa30ae4fd816ce5360d3d70" translate="yes" xml:space="preserve">
          <source>whereas [YourDecision] depends on the recommendations from above.</source>
          <target state="translated">一方、[YourDecision]は上からの推薦に依存しています。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
