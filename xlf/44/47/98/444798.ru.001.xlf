<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/444798">
    <body>
      <group id="444798">
        <trans-unit id="d7ea84681048f2e929f81db989aa59a2d8ac1865" translate="yes" xml:space="preserve">
          <source>.NET Core 2.0+ only (as of now)</source>
          <target state="translated">только .NET Core 2.0+(на данный момент).</target>
        </trans-unit>
        <trans-unit id="e79cd3893ef8c8f2fc330336ec327468a27795fd" translate="yes" xml:space="preserve">
          <source>.NET Core has had a pair of methods to deal with this since version 2.0 :</source>
          <target state="translated">.NET Core имеет пару методов для решения этой проблемы с версии 2.0 :</target>
        </trans-unit>
        <trans-unit id="5959f410f2fcf8089d275b4318ded842f4ee7d45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/15464440/11333&quot;&gt;This&lt;/a&gt; answer however brings up the inherent problem that we can't compare text case insensitive until we know both texts are the same culture and we know  what that culture is. This is maybe a less popular answer, but I think it is more correct and that's why I marked it as such.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/15464440/11333&quot;&gt;Этот&lt;/a&gt; ответ, однако, поднимает внутреннюю проблему, заключающуюся в том, что мы не можем сравнивать текст без учета регистра, пока мы не знаем, что оба текста - это одна и та же культура, и мы не знаем, что это за культура. Возможно, это менее популярный ответ, но я думаю, что он более правильный, и поэтому я отметил его как таковой.</target>
        </trans-unit>
        <trans-unit id="40306d1509e9fd7bd3a5d6cbb13ffda8f178a5aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OrdinalIgnoreCase, CurrentCultureIgnoreCase or InvariantCultureIgnoreCase?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OrdinalIgnoreCase, CurrentCultureIgnoreCase или InvariantCultureIgnoreCase?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5277a2241002c732d5300dfd06502b2f34ae7c6d" translate="yes" xml:space="preserve">
          <source>Alternative solution using Regex:</source>
          <target state="translated">Альтернативное решение с использованием Регекса:</target>
        </trans-unit>
        <trans-unit id="9e3766b02a05d2f1ada682ac5e26ebea5d5f19b6" translate="yes" xml:space="preserve">
          <source>And usage is something like:</source>
          <target state="translated">А использование-это что-то вроде:</target>
        </trans-unit>
        <trans-unit id="c288b5abcecab19e933b03180fcfaf006fd7af32" translate="yes" xml:space="preserve">
          <source>As simple and works</source>
          <target state="translated">Как просто и работает</target>
        </trans-unit>
        <trans-unit id="0d549f6f0822b73386eb38f4384956dcf11326a8" translate="yes" xml:space="preserve">
          <source>Based on these rules you should use:</source>
          <target state="translated">Основываясь на этих правилах,вы должны их использовать:</target>
        </trans-unit>
        <trans-unit id="2530fe7143247da7480d306772712622a1d387ef" translate="yes" xml:space="preserve">
          <source>By Changing case</source>
          <target state="translated">Изменяя случай</target>
        </trans-unit>
        <trans-unit id="90b359080b18ce270e92120971a7ba6aae84c35e" translate="yes" xml:space="preserve">
          <source>By Index of</source>
          <target state="translated">По индексу</target>
        </trans-unit>
        <trans-unit id="b6606f6c51c5f53c6c7ceb23c3923db4da97c5b4" translate="yes" xml:space="preserve">
          <source>By Regex</source>
          <target state="translated">Регекс</target>
        </trans-unit>
        <trans-unit id="e52050ce0344d953fc86419915270f188583c9e2" translate="yes" xml:space="preserve">
          <source>C# variant:</source>
          <target state="translated">Вариант C#:</target>
        </trans-unit>
        <trans-unit id="afd9fd14fb905ebc6d557e5dcd06b1313aa19903" translate="yes" xml:space="preserve">
          <source>Case insensitive 'Contains(string)'</source>
          <target state="translated">Чувствительный к регистру 'Содержит(строка)'</target>
        </trans-unit>
        <trans-unit id="093743f90c366f3346a4626e0147ea26113350c4" translate="yes" xml:space="preserve">
          <source>Don'ts</source>
          <target state="translated">Don'ts</target>
        </trans-unit>
        <trans-unit id="586c15c6fd8448116ae5a0f2e995d41e36f153b8" translate="yes" xml:space="preserve">
          <source>Dos</source>
          <target state="translated">Dos</target>
        </trans-unit>
        <trans-unit id="77ca9b61a054b706c8eb86d834d0c6e69a47ecb4" translate="yes" xml:space="preserve">
          <source>Even better is defining a new extension method for string:</source>
          <target state="translated">Еще лучше определить новый метод расширения для строки:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="9a2cbc34d065fb65656b2063bb3f5a7d121fbc6b" translate="yes" xml:space="preserve">
          <source>For most cases, in mono-lingual, English code bases &lt;a href=&quot;https://stackoverflow.com/a/444818/11333&quot;&gt;this&lt;/a&gt; answer will suffice. I'm suspecting because most people coming here fall in this category this is the most popular answer.</source>
          <target state="translated">В большинстве случаев в одноязычных, английских кодовых базах &lt;a href=&quot;https://stackoverflow.com/a/444818/11333&quot;&gt;этого&lt;/a&gt; ответа будет достаточно. Я подозреваю, потому что большинство людей, приходящих сюда, попадают в эту категорию, это самый популярный ответ.</target>
        </trans-unit>
        <trans-unit id="01e8855afa40286aaf1698d3bc206c8973138e21" translate="yes" xml:space="preserve">
          <source>I know that this is not the C#, but in the framework (VB.NET) there is already such a function</source>
          <target state="translated">Я знаю,что это не C#,но в фреймворке (VB.NET)уже есть такая функция</target>
        </trans-unit>
        <trans-unit id="ab4e3c8a22f2080a468115a52cba5d38079a4f3b" translate="yes" xml:space="preserve">
          <source>In time, they will probably make their way into the .NET Standard and, from there, into all the other implementations of the Base Class Library.</source>
          <target state="translated">Со временем они,вероятно,войдут в .NET-стандарт,а оттуда-во все остальные реализации Библиотеки базовых классов.</target>
        </trans-unit>
        <trans-unit id="c1275a34e98253fcfa85a71fc078124d0348f597" translate="yes" xml:space="preserve">
          <source>Is there a way to make the following return true?</source>
          <target state="translated">Есть ли способ сделать следующее возвращение правдой?</target>
        </trans-unit>
        <trans-unit id="41eb1876c1792272999607eb5a18213c23b3ab72" translate="yes" xml:space="preserve">
          <source>Just like this:</source>
          <target state="translated">Вот так:</target>
        </trans-unit>
        <trans-unit id="283fa1715023367e46e06ce59e987fa93484c298" translate="yes" xml:space="preserve">
          <source>Just to build on the answer here, you can create a string extension method to make this a little more user-friendly:</source>
          <target state="translated">Просто чтобы построить ответ здесь,вы можете создать метод расширения строки,чтобы сделать его немного более удобным для пользователя:</target>
        </trans-unit>
        <trans-unit id="ab564241d56d2a6d9b704ecfba0866b810008b1e" translate="yes" xml:space="preserve">
          <source>MSDN</source>
          <target state="translated">MSDN</target>
        </trans-unit>
        <trans-unit id="29d2ccae572a132867e7a45afe192e33bf572950" translate="yes" xml:space="preserve">
          <source>Note, that &lt;a href=&quot;https://stackoverflow.com/questions/25666993/c-sharp-null-propagating-operator-conditional-access-expression-if-blocks&quot;&gt;null propagation&lt;/a&gt;&lt;code&gt;?.&lt;/code&gt; is available since C# 6.0 (VS 2015), for older versions use</source>
          <target state="translated">Обратите внимание, что &lt;a href=&quot;https://stackoverflow.com/questions/25666993/c-sharp-null-propagating-operator-conditional-access-expression-if-blocks&quot;&gt;нулевое распространение&lt;/a&gt; &lt;code&gt;?.&lt;/code&gt; доступно с C # 6.0 (VS 2015), для более старых версий</target>
        </trans-unit>
        <trans-unit id="f9acc8aac4b87c892398798714d689d423a38e96" translate="yes" xml:space="preserve">
          <source>One issue with the answer is that it will throw an exception if a string is null. You can add that as a check so it won't:</source>
          <target state="translated">Одна из проблем с ответом заключается в том,что он будет бросать исключение,если строка является нулевой.Вы можете добавить это в качестве проверки,чтобы это не произошло:</target>
        </trans-unit>
        <trans-unit id="09f0e5b8a233db5605df7cad750be353d6a2df66" translate="yes" xml:space="preserve">
          <source>Oops, just saw that last bit.  A case insensitive compare would &lt;code&gt;*&lt;/code&gt;probably&lt;code&gt;*&lt;/code&gt; do the same anyway, and if performance is not an issue, I don't see a problem with creating uppercase copies and comparing those.  I could have sworn that I once saw a case-insensitive compare once...</source>
          <target state="translated">Ой, только что видел это последнее. Сравнение без учета регистра будет &lt;code&gt;*&lt;/code&gt; вероятно &lt;code&gt;*&lt;/code&gt; делать то же самое, и если производительность не является проблемой, я не вижу проблем с созданием копий в верхнем регистре и их сравнением. Я мог бы поклясться, что однажды видел сравнение без учета регистра ...</target>
        </trans-unit>
        <trans-unit id="8344d4583e02839d89cd5cd3190cece1b97ea0da" translate="yes" xml:space="preserve">
          <source>Output is &quot;Reset&quot;</source>
          <target state="translated">Выход &quot;Сброс&quot;</target>
        </trans-unit>
        <trans-unit id="9b736be42f251c03b231b521716afd93b4579efc" translate="yes" xml:space="preserve">
          <source>Simple way for newbie:</source>
          <target state="translated">Простой способ для новичка:</target>
        </trans-unit>
        <trans-unit id="8ca47e1c50c81d11f5377c183b4af7bb23a0fa73" translate="yes" xml:space="preserve">
          <source>Since 0 (zero) can be an index, you check against -1.</source>
          <target state="translated">Так как 0 (ноль)может быть индексом,вы сравниваете с -1.</target>
        </trans-unit>
        <trans-unit id="908ce872d5835df04c4218de13a48ddd13cfef76" translate="yes" xml:space="preserve">
          <source>Since this is missing, here are some recommendations about when to use which one:</source>
          <target state="translated">Поскольку этого не хватает,вот некоторые рекомендации о том,когда их использовать:</target>
        </trans-unit>
        <trans-unit id="973ae5a1f7eb4392ed569b92c044d098c24c7ac3" translate="yes" xml:space="preserve">
          <source>String.Contains(Char, &lt;strong&gt;StringComparison&lt;/strong&gt;)</source>
          <target state="translated">String.Contains (Char, &lt;strong&gt;StringComparison&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="42fa4f7244bf67da66f04a8d91ad3293b1122c56" translate="yes" xml:space="preserve">
          <source>String.Contains(String, &lt;strong&gt;StringComparison&lt;/strong&gt;)</source>
          <target state="translated">String.Contains (String, &lt;strong&gt;StringComparison&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="0a3e4cb8fd87ecc07781972118a1324cf8d461ac" translate="yes" xml:space="preserve">
          <source>StringExtension class is the way forward, I've combined a couple of the posts above to give a complete code example:</source>
          <target state="translated">Класс StringExtension-это путь вперёд,я объединил пару постов выше,чтобы привести полный пример кода:</target>
        </trans-unit>
        <trans-unit id="dedf58a19811d520c755e343463be870b381e0ec" translate="yes" xml:space="preserve">
          <source>Switch current use of string operations based on the invariant
culture to use the non-linguistic &lt;code&gt;StringComparison.Ordinal&lt;/code&gt; or      &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; when the comparison is</source>
          <target state="translated">Переключите текущее использование строковых операций на основе инвариантной культуры, чтобы использовать нелингвистические &lt;code&gt;StringComparison.Ordinal&lt;/code&gt; или &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; , когда сравнение выполняется</target>
        </trans-unit>
        <trans-unit id="d9aec165d49c48375c24b25789d75b19f527d8e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InStr&lt;/code&gt; method from the VisualBasic assembly is the best if you have a concern about internationalization (or you could reimplement it).  Looking at in it dotNeetPeek shows that not only does it account for caps and lowercase, but also for kana type and full- vs. half-width characters (mostly relevant for Asian languages, although there are full-width versions of the Roman alphabet too).  I'm skipping over some details, but check out the private method &lt;code&gt;InternalInStrText&lt;/code&gt;:</source>
          <target state="translated">Метод &lt;code&gt;InStr&lt;/code&gt; из сборки VisualBasic является лучшим, если у вас есть проблемы с интернационализацией (или вы можете переопределить ее). Если посмотреть на это, dotNeetPeek показывает, что он учитывает не только заглавные и строчные буквы, но также и символы типа кана и символы полной ширины и полуширины (в основном это актуально для азиатских языков, хотя существуют и версии полной ширины латинского алфавита). ). Я пропускаю некоторые детали, но проверь закрытый метод &lt;code&gt;InternalInStrText&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e9dbd47e2db3d1cbd7f8ca59b8f530d35bed55c5" translate="yes" xml:space="preserve">
          <source>The trick here is to look for the string, ignoring case, but to keep it exactly the same (with the same case).</source>
          <target state="translated">Хитрость здесь в том,чтобы искать строку,игнорируя регистр,но оставляя его точно таким же (с тем же регистром).</target>
        </trans-unit>
        <trans-unit id="b11e43b9475f18146d88230e0041f4769ce86cde" translate="yes" xml:space="preserve">
          <source>The zero-based index position of value if that string is found, or -1
  if it is not. If value is String.Empty, the return value is 0.</source>
          <target state="translated">Нулевая позиция индекса значения,если эта строка найдена,или -1,если нет.Если значение String.Empty,то возвращаемое значение равно 0.</target>
        </trans-unit>
        <trans-unit id="a3781a4c88588206e742c11daec5fd820dcdd522" translate="yes" xml:space="preserve">
          <source>There doesn't seem to be an overload that allows me to set the case sensitivity.. Currently I UPPERCASE them both, but that's just silly (by which I am referring to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalization_and_localization&quot;&gt;i18n&lt;/a&gt; issues that come with up- and down casing).</source>
          <target state="translated">Кажется, что нет перегрузки, которая позволяет мне устанавливать чувствительность к регистру. В настоящее время я ОБОСНОВАЛ их обоих, но это просто глупо (под этим я имею в виду проблемы &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalization_and_localization&quot;&gt;i18n,&lt;/a&gt; которые идут с кожухами вверх и вниз).</target>
        </trans-unit>
        <trans-unit id="594fbdf5a86b028e3f69b71cb9dc6548868e4e34" translate="yes" xml:space="preserve">
          <source>These are the easiest solutions.</source>
          <target state="translated">Это самые простые решения.</target>
        </trans-unit>
        <trans-unit id="0168b460ba5582e831c090d1f16681f2925554e0" translate="yes" xml:space="preserve">
          <source>This boolean value will return if the string is contained or not</source>
          <target state="translated">Это булевое значение будет возвращаться,если строка содержится или нет</target>
        </trans-unit>
        <trans-unit id="e1fad424e6c221bbe3e33e1de38882e31617e66b" translate="yes" xml:space="preserve">
          <source>This is clean and simple.</source>
          <target state="translated">Это чисто и просто.</target>
        </trans-unit>
        <trans-unit id="e3bd071b41a0a3fc32fa7194b0cdc2ff9792aa0d" translate="yes" xml:space="preserve">
          <source>This is quite similar to other example here, but I've decided to simplify enum to bool, primary because other alternatives are normally not needed. Here is my example:</source>
          <target state="translated">Это довольно похоже на другой пример здесь,но я решил упростить enum to bool,primary,потому что другие альтернативы обычно не нужны.Вот мой пример:</target>
        </trans-unit>
        <trans-unit id="c56aed9a15a609ecc15c26704f8b7560d3a31731" translate="yes" xml:space="preserve">
          <source>This question is ancient and since then I have realized I asked for a simple answer for a really vast and difficult topic if you care to investigate it fully.</source>
          <target state="translated">Этот вопрос древний,и с тех пор я понял,что попросил простого ответа на действительно обширную и сложную тему,если вы хотите исследовать ее полностью.</target>
        </trans-unit>
        <trans-unit id="6b01723bd3f30ff9351f1469f7dd15a3b31b2c55" translate="yes" xml:space="preserve">
          <source>This solution is transparent about &lt;strong&gt;the definition of case-insensitivity, which is language dependent&lt;/strong&gt;. For example, the English language uses the characters &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt; for the upper and lower case versions of the ninth letter, whereas the Turkish language uses these characters for the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dotted_and_dotless_I&quot;&gt;eleventh and twelfth letters&lt;/a&gt; of its 29 letter-long alphabet. The Turkish upper case version of 'i' is the unfamiliar character 'İ'.</source>
          <target state="translated">Это решение прозрачно &lt;strong&gt;в отношении определения чувствительности к регистру, которое зависит от языка&lt;/strong&gt; . Например, английский язык использует символы &lt;code&gt;I&lt;/code&gt; и &lt;code&gt;i&lt;/code&gt; для версий девятой буквы в верхнем и нижнем регистре, тогда как турецкий язык использует эти символы для &lt;a href=&quot;http://en.wikipedia.org/wiki/Dotted_and_dotless_I&quot;&gt;одиннадцатой и двенадцатой букв&lt;/a&gt; своего алфавита длиной 29 букв. Турецкая версия &amp;laquo;i&amp;raquo; в верхнем регистре - это незнакомый символ &amp;laquo;İ&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="564d8ed126483751019d127c88e08af1831914ad" translate="yes" xml:space="preserve">
          <source>Thus the strings &lt;code&gt;tin&lt;/code&gt; and &lt;code&gt;TIN&lt;/code&gt; are the same word &lt;em&gt;in English&lt;/em&gt;, but different words &lt;em&gt;in Turkish&lt;/em&gt;. As I understand, one means 'spirit' and the other is an onomatopoeia word. (Turks, please correct me if I'm wrong, or suggest a better example)</source>
          <target state="translated">Таким образом, строки &lt;code&gt;tin&lt;/code&gt; и &lt;code&gt;TIN&lt;/code&gt; - это одно и то же слово &lt;em&gt;в английском&lt;/em&gt; , но разные слова &lt;em&gt;в турецком&lt;/em&gt; . Как я понимаю, один означает &amp;laquo;дух&amp;raquo;, а другой - слово звукоподражания. (Турки, поправьте меня, если я ошибаюсь, или предложите лучший пример)</target>
        </trans-unit>
        <trans-unit id="86f61e72bf5195cb3e5c74a9cc4fe790bc1207d0" translate="yes" xml:space="preserve">
          <source>To summarise, you can only answer the question 'are these two strings the same but in different cases' &lt;em&gt;if you know what language the text is in&lt;/em&gt;. If you don't know, you'll have to take a punt. Given English's hegemony in software, you should probably resort to &lt;a href=&quot;https://stackoverflow.com/questions/9760237/what-does-cultureinfo-invariantculture-mean&quot;&gt;&lt;code&gt;CultureInfo.InvariantCulture&lt;/code&gt;&lt;/a&gt;, because it'll be wrong in familiar ways.</source>
          <target state="translated">Подводя итог, вы можете ответить только на вопрос &amp;laquo;являются ли эти две строки одинаковыми, но в разных случаях&amp;raquo;, &lt;em&gt;если вы знаете, на каком языке находится текст&lt;/em&gt; . Если вы не знаете, вам придется взять с собой пунт. Учитывая гегемонию английского языка в программном обеспечении, вам, вероятно, следует прибегнуть к &lt;a href=&quot;https://stackoverflow.com/questions/9760237/what-does-cultureinfo-invariantculture-mean&quot;&gt; &lt;code&gt;CultureInfo.InvariantCulture&lt;/code&gt; &lt;/a&gt; , потому что это будет неправильно знакомыми способами.</target>
        </trans-unit>
        <trans-unit id="2dc0eef1bd33b4bf153b1382a1160b7f556e66b2" translate="yes" xml:space="preserve">
          <source>To test if the string &lt;code&gt;paragraph&lt;/code&gt; contains the string &lt;code&gt;word&lt;/code&gt; (thanks @QuarterMeister)</source>
          <target state="translated">Чтобы проверить, содержит ли строковый &lt;code&gt;paragraph&lt;/code&gt; строковое &lt;code&gt;word&lt;/code&gt; (спасибо @QuarterMeister)</target>
        </trans-unit>
        <trans-unit id="526e17802d5e428ad056a5fb1638e0d3f633a4c9" translate="yes" xml:space="preserve">
          <source>USAGE:</source>
          <target state="translated">USAGE:</target>
        </trans-unit>
        <trans-unit id="3628d3e49b147a61ac95fb89dc0071077bb7b9bf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.CurrentCulture-based&lt;/code&gt; string operations
when displaying the output to the user.</source>
          <target state="translated">Используйте строковые операции на &lt;code&gt;StringComparison.CurrentCulture-based&lt;/code&gt; при отображении вывода для пользователя.</target>
        </trans-unit>
        <trans-unit id="741e1769499106b278e73532a4f20495a038f9b9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.InvariantCulture&lt;/code&gt; -based string</source>
          <target state="translated">Использовать строку на основе &lt;code&gt;StringComparison.InvariantCulture&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60d07819b7d6d2c55c3743937911c498333b2ba4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; comparisons
for increased speed.</source>
          <target state="translated">Используйте сравнения &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; для увеличения скорости.</target>
        </trans-unit>
        <trans-unit id="055796aaa0333b8c896aed37393fbefec18e1f97" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; for comparisons
as your safe default for culture-agnostic string matching.</source>
          <target state="translated">Используйте &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; для сравнения в качестве безопасного значения по умолчанию для сопоставления строк, не зависящего от культуры.</target>
        </trans-unit>
        <trans-unit id="bf1ddf204de3c9fd9654c376db6fd25d4685c804" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ToUpperInvariant&lt;/code&gt; rather than &lt;code&gt;ToLowerInvariant&lt;/code&gt; when
normalizing strings for comparison.</source>
          <target state="translated">Используйте &lt;code&gt;ToUpperInvariant&lt;/code&gt; вместо &lt;code&gt;ToLowerInvariant&lt;/code&gt; при нормализации строк для сравнения.</target>
        </trans-unit>
        <trans-unit id="ef5e2a756503d5c24a1765c050f3cba85951e6b7" translate="yes" xml:space="preserve">
          <source>Use overloads for string operations that don't explicitly
or implicitly specify the string comparison mechanism.</source>
          <target state="translated">Использовать перегрузки для операций со строками,которые явно или неявно не указывают механизм сравнения строк.</target>
        </trans-unit>
        <trans-unit id="b543720e8daabc3733964f244cca2d14e58df202" translate="yes" xml:space="preserve">
          <source>Use this:</source>
          <target state="translated">Используй это:</target>
        </trans-unit>
        <trans-unit id="10433c64049da93d83b924b0e08556f34f63e73c" translate="yes" xml:space="preserve">
          <source>Using a RegEx is a straight way to do this:</source>
          <target state="translated">Использование RegEx-это прямой способ сделать это:</target>
        </trans-unit>
        <trans-unit id="d8f096569d8c3619e1403f4894636d27a8f7f554" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;culture&lt;/code&gt; is the instance of &lt;a href=&quot;http://msdn.microsoft.com/en-gb/library/system.globalization.cultureinfo(v=vs.110).aspx&quot;&gt;&lt;code&gt;CultureInfo&lt;/code&gt;&lt;/a&gt; describing the language that the text is written in.</source>
          <target state="translated">Где &lt;code&gt;culture&lt;/code&gt; - это экземпляр &lt;a href=&quot;http://msdn.microsoft.com/en-gb/library/system.globalization.cultureinfo(v=vs.110).aspx&quot;&gt; &lt;code&gt;CultureInfo&lt;/code&gt; ,&lt;/a&gt; описывающий язык, на котором написан текст.</target>
        </trans-unit>
        <trans-unit id="dc5e2f77d71a8417bcacdaae9a291d9d19125884" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;IndexOf()&lt;/code&gt; like this:</source>
          <target state="translated">Вы можете использовать &lt;code&gt;IndexOf()&lt;/code&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="89cb9c90e272c35c2c2976cd923fc22093ef0bf6" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;string.indexof ()&lt;/code&gt; function. This will be case insensitive</source>
          <target state="translated">Вы можете использовать &lt;code&gt;string.indexof ()&lt;/code&gt; . Это будет без учета регистра</target>
        </trans-unit>
        <trans-unit id="a0e653c56062f605ed8ed7f366dc6698b3ab7dfc" translate="yes" xml:space="preserve">
          <source>You could always just up or downcase the strings first.</source>
          <target state="translated">Ты всегда можешь сначала просто поднять или опустить струны.</target>
        </trans-unit>
        <trans-unit id="6a7495925f7fecd82ebaf985f15d1b4af6f79c8c" translate="yes" xml:space="preserve">
          <source>You could use the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms224425(v=vs.110).aspx&quot;&gt;String.IndexOf Method&lt;/a&gt; and pass &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.stringcomparer.ordinalignorecase(v=vs.110).aspx&quot;&gt;&lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt;&lt;/a&gt; as the type of search to use:</source>
          <target state="translated">Вы можете использовать &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms224425(v=vs.110).aspx&quot;&gt;метод String.IndexOf&lt;/a&gt; и передать &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.stringcomparer.ordinalignorecase(v=vs.110).aspx&quot;&gt; &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; &lt;/a&gt; в качестве типа поиска:</target>
        </trans-unit>
        <trans-unit id="261a9015da8e88b5ddc35de053f3967f876f9ae2" translate="yes" xml:space="preserve">
          <source>if you want to check if your passed string is in string then there is a simple method for that.</source>
          <target state="translated">если вы хотите проверить,не находится ли переданная строка в строке,то для этого есть простой метод.</target>
        </trans-unit>
        <trans-unit id="94ebeda004ca6e860b085fd09428620706e6f011" translate="yes" xml:space="preserve">
          <source>linguistically irrelevant (symbolic, for example).</source>
          <target state="translated">лингвистически неуместно (символически,например).</target>
        </trans-unit>
        <trans-unit id="33c9b2fd854ed6a2cfcad916c56e0bd0b221cf15" translate="yes" xml:space="preserve">
          <source>link of source: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms973919.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/ms973919.aspx&lt;/a&gt;</source>
          <target state="translated">ссылка на источник: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms973919.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/ms973919.aspx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1400ca9eaeea1ab863726d5a0fbf1e57821fbe6d" translate="yes" xml:space="preserve">
          <source>operations in most cases; one of the few exceptions would be</source>
          <target state="translated">операции в большинстве случаев;одним из немногих исключений было бы следующее</target>
        </trans-unit>
        <trans-unit id="e01a272525fbe487f38b023d20e84a2ce53eb650" translate="yes" xml:space="preserve">
          <source>persisting linguistically meaningful but culturally-agnostic data.</source>
          <target state="translated">сохраняющиеся лингвистически значимые,но культурно-диагностические данные.</target>
        </trans-unit>
        <trans-unit id="2a94a6a5f47292f5baa30ae4fd816ce5360d3d70" translate="yes" xml:space="preserve">
          <source>whereas [YourDecision] depends on the recommendations from above.</source>
          <target state="translated">в то время как [YourDecision]зависит от рекомендаций,изложенных выше.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
