<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/444798">
    <body>
      <group id="444798">
        <trans-unit id="d7ea84681048f2e929f81db989aa59a2d8ac1865" translate="yes" xml:space="preserve">
          <source>.NET Core 2.0+ only (as of now)</source>
          <target state="translated">仅限.NET Core 2.0+(截至目前)</target>
        </trans-unit>
        <trans-unit id="e79cd3893ef8c8f2fc330336ec327468a27795fd" translate="yes" xml:space="preserve">
          <source>.NET Core has had a pair of methods to deal with this since version 2.0 :</source>
          <target state="translated">自.NET Core 2.0版本以来,.NET Core已经有了一对方法来处理这个问题。</target>
        </trans-unit>
        <trans-unit id="5959f410f2fcf8089d275b4318ded842f4ee7d45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/15464440/11333&quot;&gt;This&lt;/a&gt; answer however brings up the inherent problem that we can't compare text case insensitive until we know both texts are the same culture and we know  what that culture is. This is maybe a less popular answer, but I think it is more correct and that's why I marked it as such.</source>
          <target state="translated">但是， &lt;a href=&quot;https://stackoverflow.com/a/15464440/11333&quot;&gt;这个&lt;/a&gt;答案提出了一个固有的问题，即我们无法区分不区分大小写的文本，直到我们知道两个文本是同一文化并且我们知道该文化是什么。 这可能是一个不太受欢迎的答案，但我认为它更正确，这就是为什么我将其标记为这样。</target>
        </trans-unit>
        <trans-unit id="40306d1509e9fd7bd3a5d6cbb13ffda8f178a5aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OrdinalIgnoreCase, CurrentCultureIgnoreCase or InvariantCultureIgnoreCase?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;顺序忽略情况，当前文化忽略情况还是不变文化忽略情况？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5277a2241002c732d5300dfd06502b2f34ae7c6d" translate="yes" xml:space="preserve">
          <source>Alternative solution using Regex:</source>
          <target state="translated">使用Regex的替代方案。</target>
        </trans-unit>
        <trans-unit id="9e3766b02a05d2f1ada682ac5e26ebea5d5f19b6" translate="yes" xml:space="preserve">
          <source>And usage is something like:</source>
          <target state="translated">而用法是这样的。</target>
        </trans-unit>
        <trans-unit id="c288b5abcecab19e933b03180fcfaf006fd7af32" translate="yes" xml:space="preserve">
          <source>As simple and works</source>
          <target state="translated">简单而有效</target>
        </trans-unit>
        <trans-unit id="0d549f6f0822b73386eb38f4384956dcf11326a8" translate="yes" xml:space="preserve">
          <source>Based on these rules you should use:</source>
          <target state="translated">根据这些规则,你应该使用。</target>
        </trans-unit>
        <trans-unit id="2530fe7143247da7480d306772712622a1d387ef" translate="yes" xml:space="preserve">
          <source>By Changing case</source>
          <target state="translated">通过改变案例</target>
        </trans-unit>
        <trans-unit id="90b359080b18ce270e92120971a7ba6aae84c35e" translate="yes" xml:space="preserve">
          <source>By Index of</source>
          <target state="translated">按索引</target>
        </trans-unit>
        <trans-unit id="b6606f6c51c5f53c6c7ceb23c3923db4da97c5b4" translate="yes" xml:space="preserve">
          <source>By Regex</source>
          <target state="translated">通过Regex</target>
        </trans-unit>
        <trans-unit id="e52050ce0344d953fc86419915270f188583c9e2" translate="yes" xml:space="preserve">
          <source>C# variant:</source>
          <target state="translated">C#的变体。</target>
        </trans-unit>
        <trans-unit id="afd9fd14fb905ebc6d557e5dcd06b1313aa19903" translate="yes" xml:space="preserve">
          <source>Case insensitive 'Contains(string)'</source>
          <target state="translated">不区分大小写的'包含(string)'</target>
        </trans-unit>
        <trans-unit id="093743f90c366f3346a4626e0147ea26113350c4" translate="yes" xml:space="preserve">
          <source>Don'ts</source>
          <target state="translated">Don'ts</target>
        </trans-unit>
        <trans-unit id="586c15c6fd8448116ae5a0f2e995d41e36f153b8" translate="yes" xml:space="preserve">
          <source>Dos</source>
          <target state="translated">Dos</target>
        </trans-unit>
        <trans-unit id="77ca9b61a054b706c8eb86d834d0c6e69a47ecb4" translate="yes" xml:space="preserve">
          <source>Even better is defining a new extension method for string:</source>
          <target state="translated">更棒的是为字符串定义了一种新的扩展方法。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="9a2cbc34d065fb65656b2063bb3f5a7d121fbc6b" translate="yes" xml:space="preserve">
          <source>For most cases, in mono-lingual, English code bases &lt;a href=&quot;https://stackoverflow.com/a/444818/11333&quot;&gt;this&lt;/a&gt; answer will suffice. I'm suspecting because most people coming here fall in this category this is the most popular answer.</source>
          <target state="translated">在大多数情况下，在单语的英语代码库中， &lt;a href=&quot;https://stackoverflow.com/a/444818/11333&quot;&gt;此&lt;/a&gt;答案就足够了。 我很怀疑，因为大多数来这里的人都属于这一类，这是最受欢迎的答案。</target>
        </trans-unit>
        <trans-unit id="01e8855afa40286aaf1698d3bc206c8973138e21" translate="yes" xml:space="preserve">
          <source>I know that this is not the C#, but in the framework (VB.NET) there is already such a function</source>
          <target state="translated">我知道这不是C#,但在框架(VB.NET)中已经有了这样一个函数</target>
        </trans-unit>
        <trans-unit id="ab4e3c8a22f2080a468115a52cba5d38079a4f3b" translate="yes" xml:space="preserve">
          <source>In time, they will probably make their way into the .NET Standard and, from there, into all the other implementations of the Base Class Library.</source>
          <target state="translated">假以时日,它们可能会进入.NET标准,并从那里开始,进入基础类库的所有其他实现。</target>
        </trans-unit>
        <trans-unit id="c1275a34e98253fcfa85a71fc078124d0348f597" translate="yes" xml:space="preserve">
          <source>Is there a way to make the following return true?</source>
          <target state="translated">有没有一种方法可以让下面的回报是真的?</target>
        </trans-unit>
        <trans-unit id="41eb1876c1792272999607eb5a18213c23b3ab72" translate="yes" xml:space="preserve">
          <source>Just like this:</source>
          <target state="translated">就像这样。</target>
        </trans-unit>
        <trans-unit id="283fa1715023367e46e06ce59e987fa93484c298" translate="yes" xml:space="preserve">
          <source>Just to build on the answer here, you can create a string extension method to make this a little more user-friendly:</source>
          <target state="translated">只是为了在这里的答案基础上,你可以创建一个字符串扩展方法,使之更加人性化一点。</target>
        </trans-unit>
        <trans-unit id="ab564241d56d2a6d9b704ecfba0866b810008b1e" translate="yes" xml:space="preserve">
          <source>MSDN</source>
          <target state="translated">MSDN</target>
        </trans-unit>
        <trans-unit id="29d2ccae572a132867e7a45afe192e33bf572950" translate="yes" xml:space="preserve">
          <source>Note, that &lt;a href=&quot;https://stackoverflow.com/questions/25666993/c-sharp-null-propagating-operator-conditional-access-expression-if-blocks&quot;&gt;null propagation&lt;/a&gt;&lt;code&gt;?.&lt;/code&gt; is available since C# 6.0 (VS 2015), for older versions use</source>
          <target state="translated">注意， &lt;a href=&quot;https://stackoverflow.com/questions/25666993/c-sharp-null-propagating-operator-conditional-access-expression-if-blocks&quot;&gt;零传播&lt;/a&gt; &lt;code&gt;?.&lt;/code&gt; 自C＃6.0（VS 2015）开始可用，供较旧版本使用</target>
        </trans-unit>
        <trans-unit id="f9acc8aac4b87c892398798714d689d423a38e96" translate="yes" xml:space="preserve">
          <source>One issue with the answer is that it will throw an exception if a string is null. You can add that as a check so it won't:</source>
          <target state="translated">这个答案的一个问题是,如果字符串为空,它将抛出一个异常。你可以将其添加为校验,这样就不会抛出异常。</target>
        </trans-unit>
        <trans-unit id="09f0e5b8a233db5605df7cad750be353d6a2df66" translate="yes" xml:space="preserve">
          <source>Oops, just saw that last bit.  A case insensitive compare would &lt;code&gt;*&lt;/code&gt;probably&lt;code&gt;*&lt;/code&gt; do the same anyway, and if performance is not an issue, I don't see a problem with creating uppercase copies and comparing those.  I could have sworn that I once saw a case-insensitive compare once...</source>
          <target state="translated">糟糕，刚刚看到了最后一点。 不区分大小写的比较无论如何都可能会做同样的事情，并且如果性能不是问题，那么创建大写副本并进行比较不会出现问题。 我本该发誓我曾经看到过一个不区分大小写的比较...</target>
        </trans-unit>
        <trans-unit id="8344d4583e02839d89cd5cd3190cece1b97ea0da" translate="yes" xml:space="preserve">
          <source>Output is &quot;Reset&quot;</source>
          <target state="translated">输出为 &quot;重置&quot;</target>
        </trans-unit>
        <trans-unit id="9b736be42f251c03b231b521716afd93b4579efc" translate="yes" xml:space="preserve">
          <source>Simple way for newbie:</source>
          <target state="translated">新手的简单方法。</target>
        </trans-unit>
        <trans-unit id="8ca47e1c50c81d11f5377c183b4af7bb23a0fa73" translate="yes" xml:space="preserve">
          <source>Since 0 (zero) can be an index, you check against -1.</source>
          <target state="translated">因为0(0)可以是一个指数,所以你对照-1进行检查。</target>
        </trans-unit>
        <trans-unit id="908ce872d5835df04c4218de13a48ddd13cfef76" translate="yes" xml:space="preserve">
          <source>Since this is missing, here are some recommendations about when to use which one:</source>
          <target state="translated">既然缺了这个,这里就给大家推荐一下什么时候用哪个好。</target>
        </trans-unit>
        <trans-unit id="973ae5a1f7eb4392ed569b92c044d098c24c7ac3" translate="yes" xml:space="preserve">
          <source>String.Contains(Char, &lt;strong&gt;StringComparison&lt;/strong&gt;)</source>
          <target state="translated">String.Contains（Char， &lt;strong&gt;StringComparison&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="42fa4f7244bf67da66f04a8d91ad3293b1122c56" translate="yes" xml:space="preserve">
          <source>String.Contains(String, &lt;strong&gt;StringComparison&lt;/strong&gt;)</source>
          <target state="translated">String.Contains（String， &lt;strong&gt;StringComparison&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="0a3e4cb8fd87ecc07781972118a1324cf8d461ac" translate="yes" xml:space="preserve">
          <source>StringExtension class is the way forward, I've combined a couple of the posts above to give a complete code example:</source>
          <target state="translated">StringExtension类是未来的发展方向,我结合上面的几个帖子给出了一个完整的代码示例。</target>
        </trans-unit>
        <trans-unit id="dedf58a19811d520c755e343463be870b381e0ec" translate="yes" xml:space="preserve">
          <source>Switch current use of string operations based on the invariant
culture to use the non-linguistic &lt;code&gt;StringComparison.Ordinal&lt;/code&gt; or      &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; when the comparison is</source>
          <target state="translated">在比较为</target>
        </trans-unit>
        <trans-unit id="d9aec165d49c48375c24b25789d75b19f527d8e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InStr&lt;/code&gt; method from the VisualBasic assembly is the best if you have a concern about internationalization (or you could reimplement it).  Looking at in it dotNeetPeek shows that not only does it account for caps and lowercase, but also for kana type and full- vs. half-width characters (mostly relevant for Asian languages, although there are full-width versions of the Roman alphabet too).  I'm skipping over some details, but check out the private method &lt;code&gt;InternalInStrText&lt;/code&gt;:</source>
          <target state="translated">如果您担心国际化（或者可以重新实现），则VisualBasic程序集的 &lt;code&gt;InStr&lt;/code&gt; 方法是最好的。 查看其中的dotNeetPeek不仅显示了大写和小写字母，还显示了假名类型以及全角和半角字符（大多数情况下适用于亚洲语言，尽管也有罗马字母的全角版本） ）。 我跳过了一些细节，但是请查看私有方法 &lt;code&gt;InternalInStrText&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="e9dbd47e2db3d1cbd7f8ca59b8f530d35bed55c5" translate="yes" xml:space="preserve">
          <source>The trick here is to look for the string, ignoring case, but to keep it exactly the same (with the same case).</source>
          <target state="translated">这里的诀窍是寻找字符串,忽略大小写,但要保持完全相同(用相同的大小写)。</target>
        </trans-unit>
        <trans-unit id="b11e43b9475f18146d88230e0041f4769ce86cde" translate="yes" xml:space="preserve">
          <source>The zero-based index position of value if that string is found, or -1
  if it is not. If value is String.Empty, the return value is 0.</source>
          <target state="translated">如果找到了该字符串,则返回值的基于零的索引位置,如果没有找到,则返回-1。如果值为String.Empty,则返回值为0。</target>
        </trans-unit>
        <trans-unit id="a3781a4c88588206e742c11daec5fd820dcdd522" translate="yes" xml:space="preserve">
          <source>There doesn't seem to be an overload that allows me to set the case sensitivity.. Currently I UPPERCASE them both, but that's just silly (by which I am referring to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalization_and_localization&quot;&gt;i18n&lt;/a&gt; issues that come with up- and down casing).</source>
          <target state="translated">似乎没有允许我设置大小写敏感度的重载。.目前，我都将它们都大写，但这只是愚蠢的（我指的是上下壳体附带的&lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalization_and_localization&quot;&gt;i18n&lt;/a&gt;问题）。</target>
        </trans-unit>
        <trans-unit id="594fbdf5a86b028e3f69b71cb9dc6548868e4e34" translate="yes" xml:space="preserve">
          <source>These are the easiest solutions.</source>
          <target state="translated">这些都是最简单的解决办法。</target>
        </trans-unit>
        <trans-unit id="0168b460ba5582e831c090d1f16681f2925554e0" translate="yes" xml:space="preserve">
          <source>This boolean value will return if the string is contained or not</source>
          <target state="translated">这个布尔值将返回是否包含字符串的值</target>
        </trans-unit>
        <trans-unit id="e1fad424e6c221bbe3e33e1de38882e31617e66b" translate="yes" xml:space="preserve">
          <source>This is clean and simple.</source>
          <target state="translated">这样做很干净,也很简单。</target>
        </trans-unit>
        <trans-unit id="e3bd071b41a0a3fc32fa7194b0cdc2ff9792aa0d" translate="yes" xml:space="preserve">
          <source>This is quite similar to other example here, but I've decided to simplify enum to bool, primary because other alternatives are normally not needed. Here is my example:</source>
          <target state="translated">这和这里的其他例子很相似,但我决定将 enum 简化为 bool,主要是因为一般情况下不需要其他的替代方案。下面是我的例子。</target>
        </trans-unit>
        <trans-unit id="c56aed9a15a609ecc15c26704f8b7560d3a31731" translate="yes" xml:space="preserve">
          <source>This question is ancient and since then I have realized I asked for a simple answer for a really vast and difficult topic if you care to investigate it fully.</source>
          <target state="translated">这个问题是很古老的,从那时起,我就意识到,如果你愿意充分调查的话,我要求对一个真正的庞然大物和难点的题目做一个简单的回答。</target>
        </trans-unit>
        <trans-unit id="6b01723bd3f30ff9351f1469f7dd15a3b31b2c55" translate="yes" xml:space="preserve">
          <source>This solution is transparent about &lt;strong&gt;the definition of case-insensitivity, which is language dependent&lt;/strong&gt;. For example, the English language uses the characters &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt; for the upper and lower case versions of the ninth letter, whereas the Turkish language uses these characters for the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dotted_and_dotless_I&quot;&gt;eleventh and twelfth letters&lt;/a&gt; of its 29 letter-long alphabet. The Turkish upper case version of 'i' is the unfamiliar character 'İ'.</source>
          <target state="translated">该解决方案对于&lt;strong&gt;不区分大小写的定义&lt;/strong&gt;是透明的， &lt;strong&gt;该定义取决于语言&lt;/strong&gt; 。 例如，英语使用第九个字母的大写和小写形式的字符 &lt;code&gt;I&lt;/code&gt; 和 &lt;code&gt;i&lt;/code&gt; ，而土耳其语使用29个字母长的字母表中的&lt;a href=&quot;http://en.wikipedia.org/wiki/Dotted_and_dotless_I&quot;&gt;第11和第12个字母&lt;/a&gt;的字符。 土耳其语的大写版本&amp;ldquo; i&amp;rdquo;是一个陌生的字符&amp;ldquo;İ&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="564d8ed126483751019d127c88e08af1831914ad" translate="yes" xml:space="preserve">
          <source>Thus the strings &lt;code&gt;tin&lt;/code&gt; and &lt;code&gt;TIN&lt;/code&gt; are the same word &lt;em&gt;in English&lt;/em&gt;, but different words &lt;em&gt;in Turkish&lt;/em&gt;. As I understand, one means 'spirit' and the other is an onomatopoeia word. (Turks, please correct me if I'm wrong, or suggest a better example)</source>
          <target state="translated">因此，字符串 &lt;code&gt;tin&lt;/code&gt; 和 &lt;code&gt;TIN&lt;/code&gt; &lt;em&gt;在英语&lt;/em&gt;中是相同的词，但是&lt;em&gt;在土耳其语中是&lt;/em&gt;不同的词。 据我了解，一种是&amp;ldquo;精神&amp;rdquo;，另一种是拟声词。 （特克斯，如果我错了，请纠正我，或者提出一个更好的例子）</target>
        </trans-unit>
        <trans-unit id="86f61e72bf5195cb3e5c74a9cc4fe790bc1207d0" translate="yes" xml:space="preserve">
          <source>To summarise, you can only answer the question 'are these two strings the same but in different cases' &lt;em&gt;if you know what language the text is in&lt;/em&gt;. If you don't know, you'll have to take a punt. Given English's hegemony in software, you should probably resort to &lt;a href=&quot;https://stackoverflow.com/questions/9760237/what-does-cultureinfo-invariantculture-mean&quot;&gt;&lt;code&gt;CultureInfo.InvariantCulture&lt;/code&gt;&lt;/a&gt;, because it'll be wrong in familiar ways.</source>
          <target state="translated">总而言之， &lt;em&gt;如果您知道文本所用的语言&lt;/em&gt; ，则只能回答&amp;ldquo;这两个字符串相同但在不同情况下&amp;rdquo; &lt;em&gt;的问题&lt;/em&gt; 。 如果您不知道，则必须平底锅。 考虑到英语在软件方面的霸权地位，您可能应该诉诸&lt;a href=&quot;https://stackoverflow.com/questions/9760237/what-does-cultureinfo-invariantculture-mean&quot;&gt; &lt;code&gt;CultureInfo.InvariantCulture&lt;/code&gt; &lt;/a&gt; ，因为用熟悉的方式会出错。</target>
        </trans-unit>
        <trans-unit id="2dc0eef1bd33b4bf153b1382a1160b7f556e66b2" translate="yes" xml:space="preserve">
          <source>To test if the string &lt;code&gt;paragraph&lt;/code&gt; contains the string &lt;code&gt;word&lt;/code&gt; (thanks @QuarterMeister)</source>
          <target state="translated">测试字符串 &lt;code&gt;paragraph&lt;/code&gt; 包含字符串 &lt;code&gt;word&lt;/code&gt; （感谢@QuarterMeister）</target>
        </trans-unit>
        <trans-unit id="526e17802d5e428ad056a5fb1638e0d3f633a4c9" translate="yes" xml:space="preserve">
          <source>USAGE:</source>
          <target state="translated">USAGE:</target>
        </trans-unit>
        <trans-unit id="3628d3e49b147a61ac95fb89dc0071077bb7b9bf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.CurrentCulture-based&lt;/code&gt; string operations
when displaying the output to the user.</source>
          <target state="translated">在向用户显示输出时，请使用 &lt;code&gt;StringComparison.CurrentCulture-based&lt;/code&gt; 字符串操作。</target>
        </trans-unit>
        <trans-unit id="741e1769499106b278e73532a4f20495a038f9b9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.InvariantCulture&lt;/code&gt; -based string</source>
          <target state="translated">使用基于 &lt;code&gt;StringComparison.InvariantCulture&lt;/code&gt; 的字符串</target>
        </trans-unit>
        <trans-unit id="60d07819b7d6d2c55c3743937911c498333b2ba4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; comparisons
for increased speed.</source>
          <target state="translated">使用 &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; 比较可以提高速度。</target>
        </trans-unit>
        <trans-unit id="055796aaa0333b8c896aed37393fbefec18e1f97" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; for comparisons
as your safe default for culture-agnostic string matching.</source>
          <target state="translated">使用 &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; 进行比较，作为与区域性无关的字符串匹配的安全默认值。</target>
        </trans-unit>
        <trans-unit id="bf1ddf204de3c9fd9654c376db6fd25d4685c804" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ToUpperInvariant&lt;/code&gt; rather than &lt;code&gt;ToLowerInvariant&lt;/code&gt; when
normalizing strings for comparison.</source>
          <target state="translated">标准化字符串进行比较时，请使用 &lt;code&gt;ToUpperInvariant&lt;/code&gt; 而不是 &lt;code&gt;ToLowerInvariant&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="ef5e2a756503d5c24a1765c050f3cba85951e6b7" translate="yes" xml:space="preserve">
          <source>Use overloads for string operations that don't explicitly
or implicitly specify the string comparison mechanism.</source>
          <target state="translated">对于不显式或隐式指定字符串比较机制的字符串操作,使用重载。</target>
        </trans-unit>
        <trans-unit id="b543720e8daabc3733964f244cca2d14e58df202" translate="yes" xml:space="preserve">
          <source>Use this:</source>
          <target state="translated">用这个。</target>
        </trans-unit>
        <trans-unit id="10433c64049da93d83b924b0e08556f34f63e73c" translate="yes" xml:space="preserve">
          <source>Using a RegEx is a straight way to do this:</source>
          <target state="translated">使用RegEx是一个直接的方法。</target>
        </trans-unit>
        <trans-unit id="d8f096569d8c3619e1403f4894636d27a8f7f554" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;culture&lt;/code&gt; is the instance of &lt;a href=&quot;http://msdn.microsoft.com/en-gb/library/system.globalization.cultureinfo(v=vs.110).aspx&quot;&gt;&lt;code&gt;CultureInfo&lt;/code&gt;&lt;/a&gt; describing the language that the text is written in.</source>
          <target state="translated">其中 &lt;code&gt;culture&lt;/code&gt; 是&lt;a href=&quot;http://msdn.microsoft.com/en-gb/library/system.globalization.cultureinfo(v=vs.110).aspx&quot;&gt; &lt;code&gt;CultureInfo&lt;/code&gt; &lt;/a&gt;的实例，用于描述文本所用的语言。</target>
        </trans-unit>
        <trans-unit id="dc5e2f77d71a8417bcacdaae9a291d9d19125884" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;IndexOf()&lt;/code&gt; like this:</source>
          <target state="translated">您可以像这样使用 &lt;code&gt;IndexOf()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="89cb9c90e272c35c2c2976cd923fc22093ef0bf6" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;string.indexof ()&lt;/code&gt; function. This will be case insensitive</source>
          <target state="translated">您可以使用 &lt;code&gt;string.indexof ()&lt;/code&gt; 函数。 这将不区分大小写</target>
        </trans-unit>
        <trans-unit id="a0e653c56062f605ed8ed7f366dc6698b3ab7dfc" translate="yes" xml:space="preserve">
          <source>You could always just up or downcase the strings first.</source>
          <target state="translated">你总是可以先把琴弦上调或下调。</target>
        </trans-unit>
        <trans-unit id="6a7495925f7fecd82ebaf985f15d1b4af6f79c8c" translate="yes" xml:space="preserve">
          <source>You could use the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms224425(v=vs.110).aspx&quot;&gt;String.IndexOf Method&lt;/a&gt; and pass &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.stringcomparer.ordinalignorecase(v=vs.110).aspx&quot;&gt;&lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt;&lt;/a&gt; as the type of search to use:</source>
          <target state="translated">您可以使用&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms224425(v=vs.110).aspx&quot;&gt;String.IndexOf方法&lt;/a&gt;并传递&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.stringcomparer.ordinalignorecase(v=vs.110).aspx&quot;&gt; &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; &lt;/a&gt;作为要使用的搜索类型：</target>
        </trans-unit>
        <trans-unit id="261a9015da8e88b5ddc35de053f3967f876f9ae2" translate="yes" xml:space="preserve">
          <source>if you want to check if your passed string is in string then there is a simple method for that.</source>
          <target state="translated">如果你想检查你传递的字符串是否在字符串中,那么有一个简单的方法。</target>
        </trans-unit>
        <trans-unit id="94ebeda004ca6e860b085fd09428620706e6f011" translate="yes" xml:space="preserve">
          <source>linguistically irrelevant (symbolic, for example).</source>
          <target state="translated">在语言上无关紧要(例如,象征性)。</target>
        </trans-unit>
        <trans-unit id="33c9b2fd854ed6a2cfcad916c56e0bd0b221cf15" translate="yes" xml:space="preserve">
          <source>link of source: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms973919.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/ms973919.aspx&lt;/a&gt;</source>
          <target state="translated">来源链接： &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms973919.aspx&quot;&gt;http&lt;/a&gt; : //msdn.microsoft.com/zh-cn/library/ms973919.aspx</target>
        </trans-unit>
        <trans-unit id="1400ca9eaeea1ab863726d5a0fbf1e57821fbe6d" translate="yes" xml:space="preserve">
          <source>operations in most cases; one of the few exceptions would be</source>
          <target state="translated">在大多数情况下,在大多数情况下都是这样的;少数例外情况之一是</target>
        </trans-unit>
        <trans-unit id="e01a272525fbe487f38b023d20e84a2ce53eb650" translate="yes" xml:space="preserve">
          <source>persisting linguistically meaningful but culturally-agnostic data.</source>
          <target state="translated">(a)持续存在的语言上有意义但文化上有差异的数据;</target>
        </trans-unit>
        <trans-unit id="2a94a6a5f47292f5baa30ae4fd816ce5360d3d70" translate="yes" xml:space="preserve">
          <source>whereas [YourDecision] depends on the recommendations from above.</source>
          <target state="translated">而[YourDecision]取决于上面的建议。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
