<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/444798">
    <body>
      <group id="444798">
        <trans-unit id="d7ea84681048f2e929f81db989aa59a2d8ac1865" translate="yes" xml:space="preserve">
          <source>.NET Core 2.0+ only (as of now)</source>
          <target state="translated">...NET Core 2.0+solamente (a partir de ahora)</target>
        </trans-unit>
        <trans-unit id="e79cd3893ef8c8f2fc330336ec327468a27795fd" translate="yes" xml:space="preserve">
          <source>.NET Core has had a pair of methods to deal with this since version 2.0 :</source>
          <target state="translated">...NET Core ha tenido un par de métodos para lidiar con esto desde la versión 2.0 :</target>
        </trans-unit>
        <trans-unit id="5959f410f2fcf8089d275b4318ded842f4ee7d45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/15464440/11333&quot;&gt;This&lt;/a&gt; answer however brings up the inherent problem that we can't compare text case insensitive until we know both texts are the same culture and we know  what that culture is. This is maybe a less popular answer, but I think it is more correct and that's why I marked it as such.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/15464440/11333&quot;&gt;Sin&lt;/a&gt; embargo, esta respuesta plantea el problema inherente de que no podemos comparar las may&amp;uacute;sculas y min&amp;uacute;sculas del texto hasta que sepamos que ambos textos son de la misma cultura y sabemos cu&amp;aacute;l es esa cultura. Esta es quiz&amp;aacute;s una respuesta menos popular, pero creo que es m&amp;aacute;s correcta y es por eso que la marqu&amp;eacute; como tal.</target>
        </trans-unit>
        <trans-unit id="40306d1509e9fd7bd3a5d6cbb13ffda8f178a5aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OrdinalIgnoreCase, CurrentCultureIgnoreCase or InvariantCultureIgnoreCase?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;OrdinalIgnoreCase, CurrentCultureIgnoreCase o InvariantCultureIgnoreCase?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5277a2241002c732d5300dfd06502b2f34ae7c6d" translate="yes" xml:space="preserve">
          <source>Alternative solution using Regex:</source>
          <target state="translated">Solución alternativa usando Regex:</target>
        </trans-unit>
        <trans-unit id="9e3766b02a05d2f1ada682ac5e26ebea5d5f19b6" translate="yes" xml:space="preserve">
          <source>And usage is something like:</source>
          <target state="translated">Y el uso es algo así como:</target>
        </trans-unit>
        <trans-unit id="c288b5abcecab19e933b03180fcfaf006fd7af32" translate="yes" xml:space="preserve">
          <source>As simple and works</source>
          <target state="translated">Como simple y funciona</target>
        </trans-unit>
        <trans-unit id="0d549f6f0822b73386eb38f4384956dcf11326a8" translate="yes" xml:space="preserve">
          <source>Based on these rules you should use:</source>
          <target state="translated">Basado en estas reglas que debes usar:</target>
        </trans-unit>
        <trans-unit id="2530fe7143247da7480d306772712622a1d387ef" translate="yes" xml:space="preserve">
          <source>By Changing case</source>
          <target state="translated">Cambiando el caso</target>
        </trans-unit>
        <trans-unit id="90b359080b18ce270e92120971a7ba6aae84c35e" translate="yes" xml:space="preserve">
          <source>By Index of</source>
          <target state="translated">Por el índice de</target>
        </trans-unit>
        <trans-unit id="b6606f6c51c5f53c6c7ceb23c3923db4da97c5b4" translate="yes" xml:space="preserve">
          <source>By Regex</source>
          <target state="translated">Por Regex</target>
        </trans-unit>
        <trans-unit id="e52050ce0344d953fc86419915270f188583c9e2" translate="yes" xml:space="preserve">
          <source>C# variant:</source>
          <target state="translated">Variante C#:</target>
        </trans-unit>
        <trans-unit id="afd9fd14fb905ebc6d557e5dcd06b1313aa19903" translate="yes" xml:space="preserve">
          <source>Case insensitive 'Contains(string)'</source>
          <target state="translated">Insensible a las mayúsculas y minúsculas &quot;Contiene&quot;.</target>
        </trans-unit>
        <trans-unit id="093743f90c366f3346a4626e0147ea26113350c4" translate="yes" xml:space="preserve">
          <source>Don'ts</source>
          <target state="translated">Don'ts</target>
        </trans-unit>
        <trans-unit id="586c15c6fd8448116ae5a0f2e995d41e36f153b8" translate="yes" xml:space="preserve">
          <source>Dos</source>
          <target state="translated">Dos</target>
        </trans-unit>
        <trans-unit id="77ca9b61a054b706c8eb86d834d0c6e69a47ecb4" translate="yes" xml:space="preserve">
          <source>Even better is defining a new extension method for string:</source>
          <target state="translated">Aún mejor es definir un nuevo método de extensión para la cadena:</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="9a2cbc34d065fb65656b2063bb3f5a7d121fbc6b" translate="yes" xml:space="preserve">
          <source>For most cases, in mono-lingual, English code bases &lt;a href=&quot;https://stackoverflow.com/a/444818/11333&quot;&gt;this&lt;/a&gt; answer will suffice. I'm suspecting because most people coming here fall in this category this is the most popular answer.</source>
          <target state="translated">Para la mayor&amp;iacute;a de los casos, en bases de c&amp;oacute;digo en ingl&amp;eacute;s monofinguales, &lt;a href=&quot;https://stackoverflow.com/a/444818/11333&quot;&gt;esta&lt;/a&gt; respuesta ser&amp;aacute; suficiente. Sospecho que porque la mayor&amp;iacute;a de las personas que vienen aqu&amp;iacute; caen en esta categor&amp;iacute;a, esta es la respuesta m&amp;aacute;s popular.</target>
        </trans-unit>
        <trans-unit id="01e8855afa40286aaf1698d3bc206c8973138e21" translate="yes" xml:space="preserve">
          <source>I know that this is not the C#, but in the framework (VB.NET) there is already such a function</source>
          <target state="translated">Sé que esto no es el C#,pero en el marco (VB.NET)ya existe tal función</target>
        </trans-unit>
        <trans-unit id="ab4e3c8a22f2080a468115a52cba5d38079a4f3b" translate="yes" xml:space="preserve">
          <source>In time, they will probably make their way into the .NET Standard and, from there, into all the other implementations of the Base Class Library.</source>
          <target state="translated">Con el tiempo,probablemente se abrirán camino en el Estándar .NET y,desde allí,en todas las demás implementaciones de la Biblioteca de Clases Base.</target>
        </trans-unit>
        <trans-unit id="c1275a34e98253fcfa85a71fc078124d0348f597" translate="yes" xml:space="preserve">
          <source>Is there a way to make the following return true?</source>
          <target state="translated">¿Hay alguna manera de hacer realidad el siguiente retorno?</target>
        </trans-unit>
        <trans-unit id="41eb1876c1792272999607eb5a18213c23b3ab72" translate="yes" xml:space="preserve">
          <source>Just like this:</source>
          <target state="translated">Justo como esto:</target>
        </trans-unit>
        <trans-unit id="283fa1715023367e46e06ce59e987fa93484c298" translate="yes" xml:space="preserve">
          <source>Just to build on the answer here, you can create a string extension method to make this a little more user-friendly:</source>
          <target state="translated">Sólo para construir sobre la respuesta aquí,puedes crear un método de extensión de la cadena para hacer esto un poco más fácil de usar:</target>
        </trans-unit>
        <trans-unit id="ab564241d56d2a6d9b704ecfba0866b810008b1e" translate="yes" xml:space="preserve">
          <source>MSDN</source>
          <target state="translated">MSDN</target>
        </trans-unit>
        <trans-unit id="29d2ccae572a132867e7a45afe192e33bf572950" translate="yes" xml:space="preserve">
          <source>Note, that &lt;a href=&quot;https://stackoverflow.com/questions/25666993/c-sharp-null-propagating-operator-conditional-access-expression-if-blocks&quot;&gt;null propagation&lt;/a&gt;&lt;code&gt;?.&lt;/code&gt; is available since C# 6.0 (VS 2015), for older versions use</source>
          <target state="translated">Tenga en cuenta que la &lt;a href=&quot;https://stackoverflow.com/questions/25666993/c-sharp-null-propagating-operator-conditional-access-expression-if-blocks&quot;&gt;propagaci&amp;oacute;n nula&lt;/a&gt; &lt;code&gt;?.&lt;/code&gt; est&amp;aacute; disponible desde C # 6.0 (VS 2015), para versiones anteriores use</target>
        </trans-unit>
        <trans-unit id="f9acc8aac4b87c892398798714d689d423a38e96" translate="yes" xml:space="preserve">
          <source>One issue with the answer is that it will throw an exception if a string is null. You can add that as a check so it won't:</source>
          <target state="translated">Un problema con la respuesta es que hará una excepción si una cuerda es nula.Puedes añadir eso como un cheque para que no lo haga:</target>
        </trans-unit>
        <trans-unit id="09f0e5b8a233db5605df7cad750be353d6a2df66" translate="yes" xml:space="preserve">
          <source>Oops, just saw that last bit.  A case insensitive compare would &lt;code&gt;*&lt;/code&gt;probably&lt;code&gt;*&lt;/code&gt; do the same anyway, and if performance is not an issue, I don't see a problem with creating uppercase copies and comparing those.  I could have sworn that I once saw a case-insensitive compare once...</source>
          <target state="translated">Vaya, acabo de ver eso &amp;uacute;ltimo. Una comparaci&amp;oacute;n que no distinga entre may&amp;uacute;sculas y min&amp;uacute;sculas &lt;code&gt;*&lt;/code&gt; probablemente &lt;code&gt;*&lt;/code&gt; har&amp;iacute;a lo mismo de todos modos, y si el rendimiento no es un problema, no veo un problema al crear copias en may&amp;uacute;sculas y compararlas. Podr&amp;iacute;a haber jurado que una vez vi una comparaci&amp;oacute;n entre may&amp;uacute;sculas y min&amp;uacute;sculas una vez ...</target>
        </trans-unit>
        <trans-unit id="8344d4583e02839d89cd5cd3190cece1b97ea0da" translate="yes" xml:space="preserve">
          <source>Output is &quot;Reset&quot;</source>
          <target state="translated">La salida es &quot;Reset&quot;</target>
        </trans-unit>
        <trans-unit id="9b736be42f251c03b231b521716afd93b4579efc" translate="yes" xml:space="preserve">
          <source>Simple way for newbie:</source>
          <target state="translated">Una manera simple para el novato:</target>
        </trans-unit>
        <trans-unit id="8ca47e1c50c81d11f5377c183b4af7bb23a0fa73" translate="yes" xml:space="preserve">
          <source>Since 0 (zero) can be an index, you check against -1.</source>
          <target state="translated">Como el 0 (cero)puede ser un índice,se comprueba contra el -1.</target>
        </trans-unit>
        <trans-unit id="908ce872d5835df04c4218de13a48ddd13cfef76" translate="yes" xml:space="preserve">
          <source>Since this is missing, here are some recommendations about when to use which one:</source>
          <target state="translated">Ya que esto falta,aquí hay algunas recomendaciones sobre cuándo usar cuál:</target>
        </trans-unit>
        <trans-unit id="973ae5a1f7eb4392ed569b92c044d098c24c7ac3" translate="yes" xml:space="preserve">
          <source>String.Contains(Char, &lt;strong&gt;StringComparison&lt;/strong&gt;)</source>
          <target state="translated">String.Contains (Char, &lt;strong&gt;StringComparison&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="42fa4f7244bf67da66f04a8d91ad3293b1122c56" translate="yes" xml:space="preserve">
          <source>String.Contains(String, &lt;strong&gt;StringComparison&lt;/strong&gt;)</source>
          <target state="translated">String.Contains (String, &lt;strong&gt;StringComparison&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="0a3e4cb8fd87ecc07781972118a1324cf8d461ac" translate="yes" xml:space="preserve">
          <source>StringExtension class is the way forward, I've combined a couple of the posts above to give a complete code example:</source>
          <target state="translated">La clase StringExtension es el camino a seguir,he combinado un par de los posts anteriores para dar un ejemplo de código completo:</target>
        </trans-unit>
        <trans-unit id="dedf58a19811d520c755e343463be870b381e0ec" translate="yes" xml:space="preserve">
          <source>Switch current use of string operations based on the invariant
culture to use the non-linguistic &lt;code&gt;StringComparison.Ordinal&lt;/code&gt; or      &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; when the comparison is</source>
          <target state="translated">Cambie el uso actual de las operaciones de cadenas basadas en la cultura invariante para usar &lt;code&gt;StringComparison.Ordinal&lt;/code&gt; o &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; no ling&amp;uuml;&amp;iacute;stico cuando la comparaci&amp;oacute;n sea</target>
        </trans-unit>
        <trans-unit id="d9aec165d49c48375c24b25789d75b19f527d8e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InStr&lt;/code&gt; method from the VisualBasic assembly is the best if you have a concern about internationalization (or you could reimplement it).  Looking at in it dotNeetPeek shows that not only does it account for caps and lowercase, but also for kana type and full- vs. half-width characters (mostly relevant for Asian languages, although there are full-width versions of the Roman alphabet too).  I'm skipping over some details, but check out the private method &lt;code&gt;InternalInStrText&lt;/code&gt;:</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;InStr&lt;/code&gt; del ensamblado VisualBasic es el mejor si le preocupa la internacionalizaci&amp;oacute;n (o podr&amp;iacute;a volver a implementarla). Al observarlo, dotNeetPeek muestra que no solo tiene en cuenta may&amp;uacute;sculas y min&amp;uacute;sculas, sino tambi&amp;eacute;n el tipo kana y los caracteres de ancho completo y medio (principalmente relevantes para los idiomas asi&amp;aacute;ticos, aunque tambi&amp;eacute;n hay versiones de ancho completo del alfabeto romano) ) Me estoy saltando algunos detalles, pero echa un vistazo al m&amp;eacute;todo privado &lt;code&gt;InternalInStrText&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e9dbd47e2db3d1cbd7f8ca59b8f530d35bed55c5" translate="yes" xml:space="preserve">
          <source>The trick here is to look for the string, ignoring case, but to keep it exactly the same (with the same case).</source>
          <target state="translated">El truco aquí es buscar la cuerda,ignorando el caso,pero manteniéndola exactamente igual (con el mismo caso).</target>
        </trans-unit>
        <trans-unit id="b11e43b9475f18146d88230e0041f4769ce86cde" translate="yes" xml:space="preserve">
          <source>The zero-based index position of value if that string is found, or -1
  if it is not. If value is String.Empty, the return value is 0.</source>
          <target state="translated">La posición de índice cero del valor si se encuentra esa cadena,o -1 si no lo es.Si el valor es String.Empty,el valor de retorno es 0.</target>
        </trans-unit>
        <trans-unit id="a3781a4c88588206e742c11daec5fd820dcdd522" translate="yes" xml:space="preserve">
          <source>There doesn't seem to be an overload that allows me to set the case sensitivity.. Currently I UPPERCASE them both, but that's just silly (by which I am referring to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalization_and_localization&quot;&gt;i18n&lt;/a&gt; issues that come with up- and down casing).</source>
          <target state="translated">No parece haber una sobrecarga que me permita establecer la sensibilidad a may&amp;uacute;sculas y min&amp;uacute;sculas. Actualmente, MAY&amp;Uacute;SCULAS a ambos, pero eso es una tonter&amp;iacute;a (por lo que me refiero a los problemas de &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalization_and_localization&quot;&gt;i18n&lt;/a&gt; que vienen con may&amp;uacute;sculas y min&amp;uacute;sculas).</target>
        </trans-unit>
        <trans-unit id="594fbdf5a86b028e3f69b71cb9dc6548868e4e34" translate="yes" xml:space="preserve">
          <source>These are the easiest solutions.</source>
          <target state="translated">Estas son las soluciones más fáciles.</target>
        </trans-unit>
        <trans-unit id="0168b460ba5582e831c090d1f16681f2925554e0" translate="yes" xml:space="preserve">
          <source>This boolean value will return if the string is contained or not</source>
          <target state="translated">Este valor booleano regresará si la cadena está contenida o no</target>
        </trans-unit>
        <trans-unit id="e1fad424e6c221bbe3e33e1de38882e31617e66b" translate="yes" xml:space="preserve">
          <source>This is clean and simple.</source>
          <target state="translated">Esto es limpio y simple.</target>
        </trans-unit>
        <trans-unit id="e3bd071b41a0a3fc32fa7194b0cdc2ff9792aa0d" translate="yes" xml:space="preserve">
          <source>This is quite similar to other example here, but I've decided to simplify enum to bool, primary because other alternatives are normally not needed. Here is my example:</source>
          <target state="translated">Esto es bastante similar a otro ejemplo aquí,pero he decidido simplificar enum to bool,primario porque normalmente no se necesitan otras alternativas.Este es mi ejemplo:</target>
        </trans-unit>
        <trans-unit id="c56aed9a15a609ecc15c26704f8b7560d3a31731" translate="yes" xml:space="preserve">
          <source>This question is ancient and since then I have realized I asked for a simple answer for a really vast and difficult topic if you care to investigate it fully.</source>
          <target state="translated">Esta pregunta es antigua y desde entonces me he dado cuenta de que pedí una respuesta simple para un tema realmente vasto y difícil si se quiere investigarlo a fondo.</target>
        </trans-unit>
        <trans-unit id="6b01723bd3f30ff9351f1469f7dd15a3b31b2c55" translate="yes" xml:space="preserve">
          <source>This solution is transparent about &lt;strong&gt;the definition of case-insensitivity, which is language dependent&lt;/strong&gt;. For example, the English language uses the characters &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt; for the upper and lower case versions of the ninth letter, whereas the Turkish language uses these characters for the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dotted_and_dotless_I&quot;&gt;eleventh and twelfth letters&lt;/a&gt; of its 29 letter-long alphabet. The Turkish upper case version of 'i' is the unfamiliar character 'İ'.</source>
          <target state="translated">Esta soluci&amp;oacute;n es transparente sobre &lt;strong&gt;la definici&amp;oacute;n de may&amp;uacute;sculas y min&amp;uacute;sculas, que depende del idioma&lt;/strong&gt; . Por ejemplo, el idioma ingl&amp;eacute;s usa los caracteres &lt;code&gt;I&lt;/code&gt; e &lt;code&gt;i&lt;/code&gt; para las versiones en may&amp;uacute;sculas y min&amp;uacute;sculas de la novena letra, mientras que el idioma turco usa estos caracteres para las &lt;a href=&quot;http://en.wikipedia.org/wiki/Dotted_and_dotless_I&quot;&gt;letras und&amp;eacute;cima y duod&amp;eacute;cima&lt;/a&gt; de su alfabeto de 29 letras. La versi&amp;oacute;n may&amp;uacute;scula turca de 'i' es el car&amp;aacute;cter desconocido 'İ'.</target>
        </trans-unit>
        <trans-unit id="564d8ed126483751019d127c88e08af1831914ad" translate="yes" xml:space="preserve">
          <source>Thus the strings &lt;code&gt;tin&lt;/code&gt; and &lt;code&gt;TIN&lt;/code&gt; are the same word &lt;em&gt;in English&lt;/em&gt;, but different words &lt;em&gt;in Turkish&lt;/em&gt;. As I understand, one means 'spirit' and the other is an onomatopoeia word. (Turks, please correct me if I'm wrong, or suggest a better example)</source>
          <target state="translated">Por lo tanto, las cadenas &lt;code&gt;tin&lt;/code&gt; y &lt;code&gt;TIN&lt;/code&gt; son la misma palabra &lt;em&gt;en ingl&amp;eacute;s&lt;/em&gt; , pero diferentes palabras &lt;em&gt;en turco&lt;/em&gt; . Seg&amp;uacute;n tengo entendido, uno significa &quot;esp&amp;iacute;ritu&quot; y el otro es una palabra onomatopeya. (Turcos, corr&amp;iacute;janme si me equivoco o sugieran un mejor ejemplo)</target>
        </trans-unit>
        <trans-unit id="86f61e72bf5195cb3e5c74a9cc4fe790bc1207d0" translate="yes" xml:space="preserve">
          <source>To summarise, you can only answer the question 'are these two strings the same but in different cases' &lt;em&gt;if you know what language the text is in&lt;/em&gt;. If you don't know, you'll have to take a punt. Given English's hegemony in software, you should probably resort to &lt;a href=&quot;https://stackoverflow.com/questions/9760237/what-does-cultureinfo-invariantculture-mean&quot;&gt;&lt;code&gt;CultureInfo.InvariantCulture&lt;/code&gt;&lt;/a&gt;, because it'll be wrong in familiar ways.</source>
          <target state="translated">Para resumir, solo puede responder la pregunta 'si estas dos cadenas son iguales pero en diferentes casos' &lt;em&gt;si sabe en qu&amp;eacute; idioma est&amp;aacute; el texto&lt;/em&gt; . Si no lo sabe, tendr&amp;aacute; que tomar un despeje. Dada la hegemon&amp;iacute;a del ingl&amp;eacute;s en el software, probablemente deber&amp;iacute;a recurrir a &lt;a href=&quot;https://stackoverflow.com/questions/9760237/what-does-cultureinfo-invariantculture-mean&quot;&gt; &lt;code&gt;CultureInfo.InvariantCulture&lt;/code&gt; &lt;/a&gt; , porque estar&amp;aacute; mal de maneras familiares.</target>
        </trans-unit>
        <trans-unit id="2dc0eef1bd33b4bf153b1382a1160b7f556e66b2" translate="yes" xml:space="preserve">
          <source>To test if the string &lt;code&gt;paragraph&lt;/code&gt; contains the string &lt;code&gt;word&lt;/code&gt; (thanks @QuarterMeister)</source>
          <target state="translated">Para probar si el &lt;code&gt;paragraph&lt;/code&gt; cadena contiene la &lt;code&gt;word&lt;/code&gt; cadena (gracias @QuarterMeister)</target>
        </trans-unit>
        <trans-unit id="526e17802d5e428ad056a5fb1638e0d3f633a4c9" translate="yes" xml:space="preserve">
          <source>USAGE:</source>
          <target state="translated">USAGE:</target>
        </trans-unit>
        <trans-unit id="3628d3e49b147a61ac95fb89dc0071077bb7b9bf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.CurrentCulture-based&lt;/code&gt; string operations
when displaying the output to the user.</source>
          <target state="translated">Utilice las operaciones de cadena &lt;code&gt;StringComparison.CurrentCulture-based&lt;/code&gt; al mostrar la salida al usuario.</target>
        </trans-unit>
        <trans-unit id="741e1769499106b278e73532a4f20495a038f9b9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.InvariantCulture&lt;/code&gt; -based string</source>
          <target state="translated">Utilice &lt;code&gt;StringComparison.InvariantCulture&lt;/code&gt; -based string</target>
        </trans-unit>
        <trans-unit id="60d07819b7d6d2c55c3743937911c498333b2ba4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; comparisons
for increased speed.</source>
          <target state="translated">Utilice &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; comparaciones StringComparison.OrdinalIgnoreCase para aumentar la velocidad.</target>
        </trans-unit>
        <trans-unit id="055796aaa0333b8c896aed37393fbefec18e1f97" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; for comparisons
as your safe default for culture-agnostic string matching.</source>
          <target state="translated">Use &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; para las comparaciones como su valor predeterminado seguro para la coincidencia de cadenas independiente de la cultura.</target>
        </trans-unit>
        <trans-unit id="bf1ddf204de3c9fd9654c376db6fd25d4685c804" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ToUpperInvariant&lt;/code&gt; rather than &lt;code&gt;ToLowerInvariant&lt;/code&gt; when
normalizing strings for comparison.</source>
          <target state="translated">Use &lt;code&gt;ToUpperInvariant&lt;/code&gt; en lugar de &lt;code&gt;ToLowerInvariant&lt;/code&gt; al normalizar cadenas para la comparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ef5e2a756503d5c24a1765c050f3cba85951e6b7" translate="yes" xml:space="preserve">
          <source>Use overloads for string operations that don't explicitly
or implicitly specify the string comparison mechanism.</source>
          <target state="translated">Utilice las sobrecargas para las operaciones de cadenas que no especifiquen explícita o implícitamente el mecanismo de comparación de cadenas.</target>
        </trans-unit>
        <trans-unit id="b543720e8daabc3733964f244cca2d14e58df202" translate="yes" xml:space="preserve">
          <source>Use this:</source>
          <target state="translated">Usa esto:</target>
        </trans-unit>
        <trans-unit id="10433c64049da93d83b924b0e08556f34f63e73c" translate="yes" xml:space="preserve">
          <source>Using a RegEx is a straight way to do this:</source>
          <target state="translated">Usar un RegEx es una forma directa de hacerlo:</target>
        </trans-unit>
        <trans-unit id="d8f096569d8c3619e1403f4894636d27a8f7f554" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;culture&lt;/code&gt; is the instance of &lt;a href=&quot;http://msdn.microsoft.com/en-gb/library/system.globalization.cultureinfo(v=vs.110).aspx&quot;&gt;&lt;code&gt;CultureInfo&lt;/code&gt;&lt;/a&gt; describing the language that the text is written in.</source>
          <target state="translated">Donde &lt;code&gt;culture&lt;/code&gt; es la instancia de &lt;a href=&quot;http://msdn.microsoft.com/en-gb/library/system.globalization.cultureinfo(v=vs.110).aspx&quot;&gt; &lt;code&gt;CultureInfo&lt;/code&gt; que&lt;/a&gt; describe el idioma en el que se escribe el texto.</target>
        </trans-unit>
        <trans-unit id="dc5e2f77d71a8417bcacdaae9a291d9d19125884" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;IndexOf()&lt;/code&gt; like this:</source>
          <target state="translated">Puede usar &lt;code&gt;IndexOf()&lt;/code&gt; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="89cb9c90e272c35c2c2976cd923fc22093ef0bf6" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;string.indexof ()&lt;/code&gt; function. This will be case insensitive</source>
          <target state="translated">Puede usar la funci&amp;oacute;n &lt;code&gt;string.indexof ()&lt;/code&gt; . Esto ser&amp;aacute; insensible a may&amp;uacute;sculas y min&amp;uacute;sculas</target>
        </trans-unit>
        <trans-unit id="a0e653c56062f605ed8ed7f366dc6698b3ab7dfc" translate="yes" xml:space="preserve">
          <source>You could always just up or downcase the strings first.</source>
          <target state="translated">Siempre puedes subir o bajar las cuerdas primero.</target>
        </trans-unit>
        <trans-unit id="6a7495925f7fecd82ebaf985f15d1b4af6f79c8c" translate="yes" xml:space="preserve">
          <source>You could use the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms224425(v=vs.110).aspx&quot;&gt;String.IndexOf Method&lt;/a&gt; and pass &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.stringcomparer.ordinalignorecase(v=vs.110).aspx&quot;&gt;&lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt;&lt;/a&gt; as the type of search to use:</source>
          <target state="translated">Puede usar el &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms224425(v=vs.110).aspx&quot;&gt;m&amp;eacute;todo String.IndexOf&lt;/a&gt; y pasar &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.stringcomparer.ordinalignorecase(v=vs.110).aspx&quot;&gt; &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; &lt;/a&gt; como el tipo de b&amp;uacute;squeda a usar:</target>
        </trans-unit>
        <trans-unit id="261a9015da8e88b5ddc35de053f3967f876f9ae2" translate="yes" xml:space="preserve">
          <source>if you want to check if your passed string is in string then there is a simple method for that.</source>
          <target state="translated">si quieres comprobar si la cadena que has pasado está en cadena,entonces hay un método simple para eso.</target>
        </trans-unit>
        <trans-unit id="94ebeda004ca6e860b085fd09428620706e6f011" translate="yes" xml:space="preserve">
          <source>linguistically irrelevant (symbolic, for example).</source>
          <target state="translated">lingüísticamente irrelevante (simbólico,por ejemplo).</target>
        </trans-unit>
        <trans-unit id="33c9b2fd854ed6a2cfcad916c56e0bd0b221cf15" translate="yes" xml:space="preserve">
          <source>link of source: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms973919.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/ms973919.aspx&lt;/a&gt;</source>
          <target state="translated">enlace de origen: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms973919.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/ms973919.aspx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1400ca9eaeea1ab863726d5a0fbf1e57821fbe6d" translate="yes" xml:space="preserve">
          <source>operations in most cases; one of the few exceptions would be</source>
          <target state="translated">operaciones en la mayoría de los casos;una de las pocas excepciones sería</target>
        </trans-unit>
        <trans-unit id="e01a272525fbe487f38b023d20e84a2ce53eb650" translate="yes" xml:space="preserve">
          <source>persisting linguistically meaningful but culturally-agnostic data.</source>
          <target state="translated">persistiendo datos lingüísticamente significativos pero culturalmente agnósticos.</target>
        </trans-unit>
        <trans-unit id="2a94a6a5f47292f5baa30ae4fd816ce5360d3d70" translate="yes" xml:space="preserve">
          <source>whereas [YourDecision] depends on the recommendations from above.</source>
          <target state="translated">mientras que [su decisión]depende de las recomendaciones de arriba.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
