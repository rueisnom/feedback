<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/444798">
    <body>
      <group id="444798">
        <trans-unit id="d7ea84681048f2e929f81db989aa59a2d8ac1865" translate="yes" xml:space="preserve">
          <source>.NET Core 2.0+ only (as of now)</source>
          <target state="translated">.NET Core 2.0 이상 (현재)</target>
        </trans-unit>
        <trans-unit id="e79cd3893ef8c8f2fc330336ec327468a27795fd" translate="yes" xml:space="preserve">
          <source>.NET Core has had a pair of methods to deal with this since version 2.0 :</source>
          <target state="translated">.NET Core는 버전 2.0 이후에이를 처리하는 한 쌍의 메소드를 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="5959f410f2fcf8089d275b4318ded842f4ee7d45" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/15464440/11333&quot;&gt;This&lt;/a&gt; answer however brings up the inherent problem that we can't compare text case insensitive until we know both texts are the same culture and we know  what that culture is. This is maybe a less popular answer, but I think it is more correct and that's why I marked it as such.</source>
          <target state="translated">그러나이 답변은 두 텍스트가 동일한 문화이고 문화가 무엇인지 알 때까지 대소 문자를 구분하지 않는 고유 한 문제를 일으 킵니다. 이것은 덜 인기있는 대답 일 수도 있지만 더 정확하다고 생각하므로 그렇게 표시했습니다.</target>
        </trans-unit>
        <trans-unit id="40306d1509e9fd7bd3a5d6cbb13ffda8f178a5aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;OrdinalIgnoreCase, CurrentCultureIgnoreCase or InvariantCultureIgnoreCase?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;서수 IgnoreCase, CurrentCultureIgnoreCase 또는 InvariantCultureIgnoreCase?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5277a2241002c732d5300dfd06502b2f34ae7c6d" translate="yes" xml:space="preserve">
          <source>Alternative solution using Regex:</source>
          <target state="translated">정규식을 사용하는 대체 솔루션 :</target>
        </trans-unit>
        <trans-unit id="9e3766b02a05d2f1ada682ac5e26ebea5d5f19b6" translate="yes" xml:space="preserve">
          <source>And usage is something like:</source>
          <target state="translated">사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c288b5abcecab19e933b03180fcfaf006fd7af32" translate="yes" xml:space="preserve">
          <source>As simple and works</source>
          <target state="translated">간단하고 작동</target>
        </trans-unit>
        <trans-unit id="0d549f6f0822b73386eb38f4384956dcf11326a8" translate="yes" xml:space="preserve">
          <source>Based on these rules you should use:</source>
          <target state="translated">이러한 규칙에 따라 다음을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="2530fe7143247da7480d306772712622a1d387ef" translate="yes" xml:space="preserve">
          <source>By Changing case</source>
          <target state="translated">대소 문자 변경</target>
        </trans-unit>
        <trans-unit id="90b359080b18ce270e92120971a7ba6aae84c35e" translate="yes" xml:space="preserve">
          <source>By Index of</source>
          <target state="translated">의 색인으로</target>
        </trans-unit>
        <trans-unit id="b6606f6c51c5f53c6c7ceb23c3923db4da97c5b4" translate="yes" xml:space="preserve">
          <source>By Regex</source>
          <target state="translated">정규식으로</target>
        </trans-unit>
        <trans-unit id="e52050ce0344d953fc86419915270f188583c9e2" translate="yes" xml:space="preserve">
          <source>C# variant:</source>
          <target state="translated">C # 변형 :</target>
        </trans-unit>
        <trans-unit id="afd9fd14fb905ebc6d557e5dcd06b1313aa19903" translate="yes" xml:space="preserve">
          <source>Case insensitive 'Contains(string)'</source>
          <target state="translated">대소 문자를 구분하지 않는 '(문자열) 포함'</target>
        </trans-unit>
        <trans-unit id="093743f90c366f3346a4626e0147ea26113350c4" translate="yes" xml:space="preserve">
          <source>Don'ts</source>
          <target state="translated">Don'ts</target>
        </trans-unit>
        <trans-unit id="586c15c6fd8448116ae5a0f2e995d41e36f153b8" translate="yes" xml:space="preserve">
          <source>Dos</source>
          <target state="translated">Dos</target>
        </trans-unit>
        <trans-unit id="77ca9b61a054b706c8eb86d834d0c6e69a47ecb4" translate="yes" xml:space="preserve">
          <source>Even better is defining a new extension method for string:</source>
          <target state="translated">문자열에 대한 새로운 확장 방법을 정의하는 것이 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="9a2cbc34d065fb65656b2063bb3f5a7d121fbc6b" translate="yes" xml:space="preserve">
          <source>For most cases, in mono-lingual, English code bases &lt;a href=&quot;https://stackoverflow.com/a/444818/11333&quot;&gt;this&lt;/a&gt; answer will suffice. I'm suspecting because most people coming here fall in this category this is the most popular answer.</source>
          <target state="translated">대부분의 경우, 단일 언어, 영어 코드 기반에서는 &lt;a href=&quot;https://stackoverflow.com/a/444818/11333&quot;&gt;이&lt;/a&gt; 답변으로 충분합니다. 여기에 오는 대부분의 사람들이이 카테고리에 속하기 때문에 이것이 가장 인기있는 답변이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="01e8855afa40286aaf1698d3bc206c8973138e21" translate="yes" xml:space="preserve">
          <source>I know that this is not the C#, but in the framework (VB.NET) there is already such a function</source>
          <target state="translated">나는 이것이 C #이 아니라는 것을 알고 있지만 프레임 워크 (VB.NET)에는 이미 그러한 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab4e3c8a22f2080a468115a52cba5d38079a4f3b" translate="yes" xml:space="preserve">
          <source>In time, they will probably make their way into the .NET Standard and, from there, into all the other implementations of the Base Class Library.</source>
          <target state="translated">시간이 지남에 따라 아마도 .NET 표준으로, 거기에서 기본 클래스 라이브러리의 다른 모든 구현으로 갈 것입니다.</target>
        </trans-unit>
        <trans-unit id="c1275a34e98253fcfa85a71fc078124d0348f597" translate="yes" xml:space="preserve">
          <source>Is there a way to make the following return true?</source>
          <target state="translated">다음과 같은 결과를 얻을 수있는 방법이 있습니까?</target>
        </trans-unit>
        <trans-unit id="41eb1876c1792272999607eb5a18213c23b3ab72" translate="yes" xml:space="preserve">
          <source>Just like this:</source>
          <target state="translated">이처럼 :</target>
        </trans-unit>
        <trans-unit id="283fa1715023367e46e06ce59e987fa93484c298" translate="yes" xml:space="preserve">
          <source>Just to build on the answer here, you can create a string extension method to make this a little more user-friendly:</source>
          <target state="translated">여기에 대한 답변을 작성하기 위해 문자열 확장 방법을 만들어 좀 더 사용자 친화적으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab564241d56d2a6d9b704ecfba0866b810008b1e" translate="yes" xml:space="preserve">
          <source>MSDN</source>
          <target state="translated">MSDN</target>
        </trans-unit>
        <trans-unit id="29d2ccae572a132867e7a45afe192e33bf572950" translate="yes" xml:space="preserve">
          <source>Note, that &lt;a href=&quot;https://stackoverflow.com/questions/25666993/c-sharp-null-propagating-operator-conditional-access-expression-if-blocks&quot;&gt;null propagation&lt;/a&gt;&lt;code&gt;?.&lt;/code&gt; is available since C# 6.0 (VS 2015), for older versions use</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/25666993/c-sharp-null-propagating-operator-conditional-access-expression-if-blocks&quot;&gt;널 전파는&lt;/a&gt; &lt;code&gt;?.&lt;/code&gt; 이전 버전의 경우 C # 6.0 (VS 2015)부터 사용 가능</target>
        </trans-unit>
        <trans-unit id="f9acc8aac4b87c892398798714d689d423a38e96" translate="yes" xml:space="preserve">
          <source>One issue with the answer is that it will throw an exception if a string is null. You can add that as a check so it won't:</source>
          <target state="translated">대답의 한 가지 문제는 문자열이 null 인 경우 예외가 발생한다는 것입니다. 이를 확인으로 추가하여 다음을 수행 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="09f0e5b8a233db5605df7cad750be353d6a2df66" translate="yes" xml:space="preserve">
          <source>Oops, just saw that last bit.  A case insensitive compare would &lt;code&gt;*&lt;/code&gt;probably&lt;code&gt;*&lt;/code&gt; do the same anyway, and if performance is not an issue, I don't see a problem with creating uppercase copies and comparing those.  I could have sworn that I once saw a case-insensitive compare once...</source>
          <target state="translated">죄송합니다. 마지막 부분을 보았습니다. 대소 문자를 구분하지 않는 비교는 어쨌든 똑같이 할 것입니다. 성능이 문제가되지 않으면 대문자 사본을 만들고 비교하는 데 아무런 문제가 없습니다. 나는 한 번 대소 문자를 구분하지 않는 것을 한 번 봤다고 맹세 할 수 있었다 ...</target>
        </trans-unit>
        <trans-unit id="8344d4583e02839d89cd5cd3190cece1b97ea0da" translate="yes" xml:space="preserve">
          <source>Output is &quot;Reset&quot;</source>
          <target state="translated">출력은 &quot;재설정&quot;입니다</target>
        </trans-unit>
        <trans-unit id="9b736be42f251c03b231b521716afd93b4579efc" translate="yes" xml:space="preserve">
          <source>Simple way for newbie:</source>
          <target state="translated">초보자를위한 간단한 방법 :</target>
        </trans-unit>
        <trans-unit id="8ca47e1c50c81d11f5377c183b4af7bb23a0fa73" translate="yes" xml:space="preserve">
          <source>Since 0 (zero) can be an index, you check against -1.</source>
          <target state="translated">0은 인덱스가 될 수 있으므로 -1과 비교하여 확인합니다.</target>
        </trans-unit>
        <trans-unit id="908ce872d5835df04c4218de13a48ddd13cfef76" translate="yes" xml:space="preserve">
          <source>Since this is missing, here are some recommendations about when to use which one:</source>
          <target state="translated">이것이 누락되었으므로 다음 중 어느 것을 사용해야하는지에 대한 권장 사항이 있습니다.</target>
        </trans-unit>
        <trans-unit id="973ae5a1f7eb4392ed569b92c044d098c24c7ac3" translate="yes" xml:space="preserve">
          <source>String.Contains(Char, &lt;strong&gt;StringComparison&lt;/strong&gt;)</source>
          <target state="translated">String. 포함 (Char, &lt;strong&gt;StringComparison&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="42fa4f7244bf67da66f04a8d91ad3293b1122c56" translate="yes" xml:space="preserve">
          <source>String.Contains(String, &lt;strong&gt;StringComparison&lt;/strong&gt;)</source>
          <target state="translated">String.Contains (String, &lt;strong&gt;StringComparison&lt;/strong&gt; )을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="0a3e4cb8fd87ecc07781972118a1324cf8d461ac" translate="yes" xml:space="preserve">
          <source>StringExtension class is the way forward, I've combined a couple of the posts above to give a complete code example:</source>
          <target state="translated">StringExtension 클래스는 앞으로 나아갈 것입니다. 위의 두 게시물을 결합하여 완전한 코드 예제를 제공했습니다.</target>
        </trans-unit>
        <trans-unit id="dedf58a19811d520c755e343463be870b381e0ec" translate="yes" xml:space="preserve">
          <source>Switch current use of string operations based on the invariant
culture to use the non-linguistic &lt;code&gt;StringComparison.Ordinal&lt;/code&gt; or      &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; when the comparison is</source>
          <target state="translated">비교가 아닌 경우 &lt;code&gt;StringComparison.Ordinal&lt;/code&gt; 또는 &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; 를 사용하도록 고정 문화권 기반 문자열 조작의 현재 사용을 전환하십시오.</target>
        </trans-unit>
        <trans-unit id="d9aec165d49c48375c24b25789d75b19f527d8e0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;InStr&lt;/code&gt; method from the VisualBasic assembly is the best if you have a concern about internationalization (or you could reimplement it).  Looking at in it dotNeetPeek shows that not only does it account for caps and lowercase, but also for kana type and full- vs. half-width characters (mostly relevant for Asian languages, although there are full-width versions of the Roman alphabet too).  I'm skipping over some details, but check out the private method &lt;code&gt;InternalInStrText&lt;/code&gt;:</source>
          <target state="translated">국제화에 관심이 있거나 다시 구현할 수있는 경우 VisualBasic 어셈블리의 &lt;code&gt;InStr&lt;/code&gt; 방법이 가장 좋습니다. 그 점을 살펴보면 dotNeetPeek는 대문자와 소문자뿐만 아니라 가나 유형 및 전체 대 반각 문자 (대부분 아시아 언어와 관련이 있지만 로마 알파벳의 전체 너비 버전도 있음)를 설명합니다 ). 세부 정보를 건너 뛰지 만 PrivateInternalInStrText 개인 메서드를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="e9dbd47e2db3d1cbd7f8ca59b8f530d35bed55c5" translate="yes" xml:space="preserve">
          <source>The trick here is to look for the string, ignoring case, but to keep it exactly the same (with the same case).</source>
          <target state="translated">여기서의 트릭은 대소 문자를 무시하고 문자열을 찾는 것이지만 정확히 동일한 대소 문자를 유지하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b11e43b9475f18146d88230e0041f4769ce86cde" translate="yes" xml:space="preserve">
          <source>The zero-based index position of value if that string is found, or -1
  if it is not. If value is String.Empty, the return value is 0.</source>
          <target state="translated">해당 문자열이 발견되면 0부터 시작하는 인덱스 위치 (값이 없으면 -1)입니다. value가 String.Empty이면 리턴 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="a3781a4c88588206e742c11daec5fd820dcdd522" translate="yes" xml:space="preserve">
          <source>There doesn't seem to be an overload that allows me to set the case sensitivity.. Currently I UPPERCASE them both, but that's just silly (by which I am referring to the &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalization_and_localization&quot;&gt;i18n&lt;/a&gt; issues that come with up- and down casing).</source>
          <target state="translated">케이스 감도를 설정할 수있는 과부하가없는 것 같습니다. 현재 두 가지 모두 대문자입니다. 그러나 그것은 바보입니다 (위로 및 아래로 케이스와 함께 제공되는 &lt;a href=&quot;http://en.wikipedia.org/wiki/Internationalization_and_localization&quot;&gt;i18n&lt;/a&gt; 문제 참조).</target>
        </trans-unit>
        <trans-unit id="594fbdf5a86b028e3f69b71cb9dc6548868e4e34" translate="yes" xml:space="preserve">
          <source>These are the easiest solutions.</source>
          <target state="translated">이것이 가장 쉬운 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="0168b460ba5582e831c090d1f16681f2925554e0" translate="yes" xml:space="preserve">
          <source>This boolean value will return if the string is contained or not</source>
          <target state="translated">이 부울 값은 문자열이 포함되어 있는지 여부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e1fad424e6c221bbe3e33e1de38882e31617e66b" translate="yes" xml:space="preserve">
          <source>This is clean and simple.</source>
          <target state="translated">이것은 깨끗하고 간단합니다.</target>
        </trans-unit>
        <trans-unit id="e3bd071b41a0a3fc32fa7194b0cdc2ff9792aa0d" translate="yes" xml:space="preserve">
          <source>This is quite similar to other example here, but I've decided to simplify enum to bool, primary because other alternatives are normally not needed. Here is my example:</source>
          <target state="translated">이것은 다른 예제와 매우 유사하지만 일반적으로 다른 대안이 필요하지 않기 때문에 enum을 bool로 단순화하기로 결정했습니다. 내 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c56aed9a15a609ecc15c26704f8b7560d3a31731" translate="yes" xml:space="preserve">
          <source>This question is ancient and since then I have realized I asked for a simple answer for a really vast and difficult topic if you care to investigate it fully.</source>
          <target state="translated">이 질문은 고대 적이며 그 이후로 당신이 그것을 완전히 조사하려고한다면 정말로 광대하고 어려운 주제에 대한 간단한 대답을 요구한다는 것을 깨달았습니다.</target>
        </trans-unit>
        <trans-unit id="6b01723bd3f30ff9351f1469f7dd15a3b31b2c55" translate="yes" xml:space="preserve">
          <source>This solution is transparent about &lt;strong&gt;the definition of case-insensitivity, which is language dependent&lt;/strong&gt;. For example, the English language uses the characters &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;i&lt;/code&gt; for the upper and lower case versions of the ninth letter, whereas the Turkish language uses these characters for the &lt;a href=&quot;http://en.wikipedia.org/wiki/Dotted_and_dotless_I&quot;&gt;eleventh and twelfth letters&lt;/a&gt; of its 29 letter-long alphabet. The Turkish upper case version of 'i' is the unfamiliar character 'İ'.</source>
          <target state="translated">이 솔루션은 &lt;strong&gt;언어에 따라 대소 문자를 구분하지 않는 정의에&lt;/strong&gt; 대해 투명 &lt;strong&gt;합니다&lt;/strong&gt; . 예를 들어 영어에서는 9 번째 문자의 대문자 및 소문자 버전에 문자 &lt;code&gt;I&lt;/code&gt; 및 &lt;code&gt;i&lt;/code&gt; 를 사용하는 반면 터키어는 29 자 길이의 알파벳 중 &lt;a href=&quot;http://en.wikipedia.org/wiki/Dotted_and_dotless_I&quot;&gt;11 번째 및 12 번째 문자&lt;/a&gt; 에 이러한 문자를 사용합니다. 'i'의 터키어 대문자 버전은 익숙하지 않은 문자 'İ'입니다.</target>
        </trans-unit>
        <trans-unit id="564d8ed126483751019d127c88e08af1831914ad" translate="yes" xml:space="preserve">
          <source>Thus the strings &lt;code&gt;tin&lt;/code&gt; and &lt;code&gt;TIN&lt;/code&gt; are the same word &lt;em&gt;in English&lt;/em&gt;, but different words &lt;em&gt;in Turkish&lt;/em&gt;. As I understand, one means 'spirit' and the other is an onomatopoeia word. (Turks, please correct me if I'm wrong, or suggest a better example)</source>
          <target state="translated">따라서 문자열 &lt;code&gt;tin&lt;/code&gt; 과 &lt;code&gt;TIN&lt;/code&gt; 은 &lt;em&gt;영어&lt;/em&gt; 에서는 같은 단어이지만 &lt;em&gt;터키어&lt;/em&gt; 에서는 다른 단어 &lt;em&gt;입니다&lt;/em&gt; . 내가 이해하는 것처럼, 하나는 '정신'을 의미하고 다른 하나는 의성어입니다. (터크, 내가 틀렸다면 정정하거나 더 좋은 예를 제안하십시오)</target>
        </trans-unit>
        <trans-unit id="86f61e72bf5195cb3e5c74a9cc4fe790bc1207d0" translate="yes" xml:space="preserve">
          <source>To summarise, you can only answer the question 'are these two strings the same but in different cases' &lt;em&gt;if you know what language the text is in&lt;/em&gt;. If you don't know, you'll have to take a punt. Given English's hegemony in software, you should probably resort to &lt;a href=&quot;https://stackoverflow.com/questions/9760237/what-does-cultureinfo-invariantculture-mean&quot;&gt;&lt;code&gt;CultureInfo.InvariantCulture&lt;/code&gt;&lt;/a&gt;, because it'll be wrong in familiar ways.</source>
          <target state="translated">요약 &lt;em&gt;하면 텍스트가 어떤 언어인지 아는&lt;/em&gt; 경우 '이 두 문자열이 동일하지만 다른 경우에있는'질문에만 대답 할 수 있습니다. 당신이 모른다면, 당신은 펀트를해야합니다. 소프트웨어에서 영어의 헤게모니가 주어지면 &lt;a href=&quot;https://stackoverflow.com/questions/9760237/what-does-cultureinfo-invariantculture-mean&quot;&gt; &lt;code&gt;CultureInfo.InvariantCulture&lt;/code&gt; &lt;/a&gt; 를 사용해야 할 것입니다. 익숙한 방식으로 잘못되었을 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2dc0eef1bd33b4bf153b1382a1160b7f556e66b2" translate="yes" xml:space="preserve">
          <source>To test if the string &lt;code&gt;paragraph&lt;/code&gt; contains the string &lt;code&gt;word&lt;/code&gt; (thanks @QuarterMeister)</source>
          <target state="translated">문자열 &lt;code&gt;paragraph&lt;/code&gt; 에 문자열 &lt;code&gt;word&lt;/code&gt; 가 포함되어 있는지 테스트하려면 (@QuarterMeister 덕분에)</target>
        </trans-unit>
        <trans-unit id="526e17802d5e428ad056a5fb1638e0d3f633a4c9" translate="yes" xml:space="preserve">
          <source>USAGE:</source>
          <target state="translated">USAGE:</target>
        </trans-unit>
        <trans-unit id="3628d3e49b147a61ac95fb89dc0071077bb7b9bf" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.CurrentCulture-based&lt;/code&gt; string operations
when displaying the output to the user.</source>
          <target state="translated">출력을 사용자에게 표시 할 때 &lt;code&gt;StringComparison.CurrentCulture-based&lt;/code&gt; 문자열 조작을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="741e1769499106b278e73532a4f20495a038f9b9" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.InvariantCulture&lt;/code&gt; -based string</source>
          <target state="translated">&lt;code&gt;StringComparison.InvariantCulture&lt;/code&gt; 기반 문자열 사용</target>
        </trans-unit>
        <trans-unit id="60d07819b7d6d2c55c3743937911c498333b2ba4" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; comparisons
for increased speed.</source>
          <target state="translated">속도를 높이 &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; 비교를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="055796aaa0333b8c896aed37393fbefec18e1f97" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; for comparisons
as your safe default for culture-agnostic string matching.</source>
          <target state="translated">문화권에 구애받지 않는 문자열 일치의 안전한 기본값으로 비교하려면 &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="bf1ddf204de3c9fd9654c376db6fd25d4685c804" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;ToUpperInvariant&lt;/code&gt; rather than &lt;code&gt;ToLowerInvariant&lt;/code&gt; when
normalizing strings for comparison.</source>
          <target state="translated">비교를 위해 문자열을 정규화 할 때 &lt;code&gt;ToLowerInvariant&lt;/code&gt; 대신 &lt;code&gt;ToUpperInvariant&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ef5e2a756503d5c24a1765c050f3cba85951e6b7" translate="yes" xml:space="preserve">
          <source>Use overloads for string operations that don't explicitly
or implicitly specify the string comparison mechanism.</source>
          <target state="translated">문자열 비교 메커니즘을 명시 적 또는 암시 적으로 지정하지 않는 문자열 작업에는 오버로드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b543720e8daabc3733964f244cca2d14e58df202" translate="yes" xml:space="preserve">
          <source>Use this:</source>
          <target state="translated">이것을 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="10433c64049da93d83b924b0e08556f34f63e73c" translate="yes" xml:space="preserve">
          <source>Using a RegEx is a straight way to do this:</source>
          <target state="translated">RegEx를 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d8f096569d8c3619e1403f4894636d27a8f7f554" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;culture&lt;/code&gt; is the instance of &lt;a href=&quot;http://msdn.microsoft.com/en-gb/library/system.globalization.cultureinfo(v=vs.110).aspx&quot;&gt;&lt;code&gt;CultureInfo&lt;/code&gt;&lt;/a&gt; describing the language that the text is written in.</source>
          <target state="translated">여기서 &lt;code&gt;culture&lt;/code&gt; 는 텍스트가 쓰여지는 언어를 설명하는 &lt;a href=&quot;http://msdn.microsoft.com/en-gb/library/system.globalization.cultureinfo(v=vs.110).aspx&quot;&gt; &lt;code&gt;CultureInfo&lt;/code&gt; &lt;/a&gt; 의 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="dc5e2f77d71a8417bcacdaae9a291d9d19125884" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;IndexOf()&lt;/code&gt; like this:</source>
          <target state="translated">다음과 같이 &lt;code&gt;IndexOf()&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89cb9c90e272c35c2c2976cd923fc22093ef0bf6" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;string.indexof ()&lt;/code&gt; function. This will be case insensitive</source>
          <target state="translated">&lt;code&gt;string.indexof ()&lt;/code&gt; 함수를 사용할 수 있습니다. 대소 문자를 구분하지 않습니다</target>
        </trans-unit>
        <trans-unit id="a0e653c56062f605ed8ed7f366dc6698b3ab7dfc" translate="yes" xml:space="preserve">
          <source>You could always just up or downcase the strings first.</source>
          <target state="translated">항상 문자열을 먼저 대문자 또는 소문자로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a7495925f7fecd82ebaf985f15d1b4af6f79c8c" translate="yes" xml:space="preserve">
          <source>You could use the &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms224425(v=vs.110).aspx&quot;&gt;String.IndexOf Method&lt;/a&gt; and pass &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.stringcomparer.ordinalignorecase(v=vs.110).aspx&quot;&gt;&lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt;&lt;/a&gt; as the type of search to use:</source>
          <target state="translated">&lt;a href=&quot;https://msdn.microsoft.com/en-us/library/ms224425(v=vs.110).aspx&quot;&gt;String.IndexOf 메소드&lt;/a&gt; 를 사용하고 사용할 검색 유형으로 &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.stringcomparer.ordinalignorecase(v=vs.110).aspx&quot;&gt; &lt;code&gt;StringComparison.OrdinalIgnoreCase&lt;/code&gt; &lt;/a&gt; 를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="261a9015da8e88b5ddc35de053f3967f876f9ae2" translate="yes" xml:space="preserve">
          <source>if you want to check if your passed string is in string then there is a simple method for that.</source>
          <target state="translated">전달 된 문자열이 문자열인지 확인하려면 간단한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="94ebeda004ca6e860b085fd09428620706e6f011" translate="yes" xml:space="preserve">
          <source>linguistically irrelevant (symbolic, for example).</source>
          <target state="translated">언어 적으로 관련이 없습니다 (예 : 상징적).</target>
        </trans-unit>
        <trans-unit id="33c9b2fd854ed6a2cfcad916c56e0bd0b221cf15" translate="yes" xml:space="preserve">
          <source>link of source: &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms973919.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/ms973919.aspx&lt;/a&gt;</source>
          <target state="translated">소스 링크 : &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms973919.aspx&quot;&gt;http://msdn.microsoft.com/en-us/library/ms973919.aspx&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1400ca9eaeea1ab863726d5a0fbf1e57821fbe6d" translate="yes" xml:space="preserve">
          <source>operations in most cases; one of the few exceptions would be</source>
          <target state="translated">대부분의 경우 작업; 몇 가지 예외 중 하나는</target>
        </trans-unit>
        <trans-unit id="e01a272525fbe487f38b023d20e84a2ce53eb650" translate="yes" xml:space="preserve">
          <source>persisting linguistically meaningful but culturally-agnostic data.</source>
          <target state="translated">언어 적으로 의미가 있지만 문화적으로 독립적 인 데이터를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="2a94a6a5f47292f5baa30ae4fd816ce5360d3d70" translate="yes" xml:space="preserve">
          <source>whereas [YourDecision] depends on the recommendations from above.</source>
          <target state="translated">[YourDecision]은 위의 권장 사항에 따라 다릅니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
