<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/4421706">
    <body>
      <group id="4421706">
        <trans-unit id="ebdeccffb9c593d5235ca8b75391edfe495210fe" translate="yes" xml:space="preserve">
          <source>(However, &lt;em&gt;if&lt;/em&gt; you make an exception, do not forget the issue of &lt;code&gt;const&lt;/code&gt;-ness for the operand that, for member functions, becomes the implicit &lt;code&gt;this&lt;/code&gt; argument. If the operator as a non-member function would take its left-most argument as a &lt;code&gt;const&lt;/code&gt; reference, the same operator as a member function needs to have a &lt;code&gt;const&lt;/code&gt; at the end to make &lt;code&gt;*this&lt;/code&gt; a &lt;code&gt;const&lt;/code&gt; reference.)</source>
          <target state="translated">（但是， &lt;em&gt;如果&lt;/em&gt;您例外，请不要忘记操作数的 &lt;code&gt;const&lt;/code&gt; -ness问题，对于成员函数，该操作数将成 &lt;code&gt;this&lt;/code&gt; 参数的隐式参数。如果运算符作为非成员函数，则将其最左端的参数用作 &lt;code&gt;const&lt;/code&gt; 引用，与成员函数相同的运算符需要在末尾具有 &lt;code&gt;const&lt;/code&gt; 才能使 &lt;code&gt;*this&lt;/code&gt; 成为 &lt;code&gt;const&lt;/code&gt; 引用。）</target>
        </trans-unit>
        <trans-unit id="a932915cc63f83451fad890ba330a2fe5b0e1013" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator+=&lt;/code&gt; returns its result per reference, while &lt;code&gt;operator+&lt;/code&gt; returns a copy of its result. Of course, returning a reference is usually more efficient than returning a copy, but in the case of &lt;code&gt;operator+&lt;/code&gt;, there is no way around the copying. When you write &lt;code&gt;a + b&lt;/code&gt;, you expect the result to be a new value, which is why &lt;code&gt;operator+&lt;/code&gt; has to return a new value.&lt;sup&gt;3&lt;/sup&gt;
Also note that &lt;code&gt;operator+&lt;/code&gt; takes its left operand &lt;strong&gt;&lt;em&gt;by copy&lt;/em&gt;&lt;/strong&gt; rather than by const reference. The reason for this is the same as the reason giving for &lt;code&gt;operator=&lt;/code&gt; taking its argument per copy.</source>
          <target state="translated">&lt;code&gt;operator+=&lt;/code&gt; 返回每个引用的结果，而 &lt;code&gt;operator+&lt;/code&gt; 返回其结果的副本。 当然，返回引用通常比返回副本更有效，但是在 &lt;code&gt;operator+&lt;/code&gt; 的情况下，无法解决复制问题。 当编写 &lt;code&gt;a + b&lt;/code&gt; ，您期望结果是一个新值，这就是为什么 &lt;code&gt;operator+&lt;/code&gt; 必须返回新值的原因。 &lt;sup&gt;3&lt;/sup&gt;还请注意， &lt;code&gt;operator+&lt;/code&gt; &lt;strong&gt;&lt;em&gt;通过复制&lt;/em&gt;&lt;/strong&gt;而不是通过const引用获取其左操作数。 其原因与给 &lt;code&gt;operator=&lt;/code&gt; 每个副本取其参数的原因相同。</target>
        </trans-unit>
        <trans-unit id="338efc32f9cb83e0dd8331e45788ecc57787ef85" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Operators are related to each other&lt;/em&gt; and to other operations. If your type supports &lt;code&gt;a + b&lt;/code&gt;, users will expect to be able to call &lt;code&gt;a += b&lt;/code&gt;, too. If it supports prefix increment &lt;code&gt;++a&lt;/code&gt;, they will expect &lt;code&gt;a++&lt;/code&gt; to work as well. If they can check whether &lt;code&gt;a &amp;lt; b&lt;/code&gt;, they will most certainly expect to also to be able to check whether &lt;code&gt;a &amp;gt; b&lt;/code&gt;. If they can copy-construct your type, they expect assignment to work as well.</source>
          <target state="translated">&lt;em&gt;运算符彼此相关，&lt;/em&gt;并且与其他操作相关。 如果您的类型支持 &lt;code&gt;a + b&lt;/code&gt; ，则用户也希望能够调用 &lt;code&gt;a += b&lt;/code&gt; 。 如果它支持前缀增量 &lt;code&gt;++a&lt;/code&gt; ，他们将期望 &lt;code&gt;a++&lt;/code&gt; 能正常工作。 如果他们可以检查 &lt;code&gt;a &amp;lt; b&lt;/code&gt; ，那么他们当然也希望能够检查 &lt;code&gt;a &amp;gt; b&lt;/code&gt; 。 如果他们可以复制构造您的类型，则希望分配也能正常工作。</target>
        </trans-unit>
        <trans-unit id="aa5bd5f45a48b221e418619d95cdcc6b6c6e44a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Always provide all out of a set of related operations.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;始终提供一组相关操作中的所有内容。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9489b9f4b1bac05ddb2354a51560ad5b088a8f70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Always stick to the operator&amp;rsquo;s well-known semantics.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;始终遵守操作员的众所周知的语义。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09e12a464818e248f8bb9ed843a88d4b181a6616" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Whenever the meaning of an operator is not obviously clear and undisputed, it should not be overloaded.&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;Instead, provide a function with a well-chosen name.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;只要运算符的含义不明显且无可争辩，就不应重载。&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;而是为函数提供一个精心选择的名称。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="620ae72342c6c376f4c4a1a08f78905e1878296d" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;em&gt;(Note: This is meant to be an entry to &lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;Stack Overflow's C++ FAQ&lt;/a&gt;. If you want to critique the idea of providing an FAQ in this form, then &lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;the posting on meta that started all this&lt;/a&gt; would be the place to do that. Answers to that question are monitored in the &lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;C++ chatroom&lt;/a&gt;, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)&lt;/em&gt;
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;（注意：这本来是&lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;Stack Overflow的C ++ FAQ&lt;/a&gt;的条目。如果您想批评以这种形式提供FAQ的想法，那么&lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;在所有这些&lt;/a&gt;都开始的meta上的张贴将是这样做的地方。该问题在&lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;C ++聊天室&lt;/a&gt;中进行监控，该问题最初是从FAQ想法开始的，所以提出这个想法的人很可能会读懂您的答案。）&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="14f3efc38fad533ae15f4148f1a61fdd2dd11ee7" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Note the &lt;code&gt;const&lt;/code&gt; at the end.)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;（请注意最后的 &lt;code&gt;const&lt;/code&gt; 。）&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="c0ca582ae5768203060cbf81ae5d446fdbadce13" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;As with all rules of thumb, sometimes there might be reasons to break this one, too. If so, do not forget that the left-hand operand of the binary comparison operators, which for member functions will be &lt;code&gt;*this&lt;/code&gt;, needs to be &lt;code&gt;const&lt;/code&gt;, too. So a comparison operator implemented as a member function would have to have this signature:&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; &lt;sub&gt;与所有经验法则一样，有时也可能有理由打破这一原则。&lt;/sub&gt; &lt;sub&gt;如果是这样，请不要忘记二进制比较运算符的左操作数（对于成员函数而言，它是 &lt;code&gt;*this&lt;/code&gt; ）也必须是 &lt;code&gt;const&lt;/code&gt; 。&lt;/sub&gt; &lt;sub&gt;因此，实现为成员函数的比较运算符必须具有以下签名：&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9a7c0de90272aa0b4c0f2ec37dbe7d8ba11b179a" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;The term &amp;ldquo;user-defined&amp;rdquo; might be slightly misleading. C++ makes the distinction between built-in types and user-defined types. To the former belong for example int, char, and double; to the latter belong all struct, class, union, and enum types, including those from the standard library, even though they are not, as such, defined by users.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; &lt;sub&gt;&amp;ldquo;用户定义&amp;rdquo;一词可能会引起误解。&lt;/sub&gt; &lt;sub&gt;C ++区分内置类型和用户定义类型。&lt;/sub&gt; &lt;sub&gt;前者属于int，char和double；&lt;/sub&gt; &lt;sub&gt;后者属于所有struct，class，union和enum类型，包括标准库中的类型，即使它们不是由用户定义的。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="4d522b0d5a3ee143d4b55a7eefa9657f18b4f0ea" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;Also note that the postfix variant does more work and is therefore less efficient to use than the prefix variant. This is a good reason to generally prefer prefix increment over postfix increment. While compilers can usually optimize away the additional work of postfix increment for built-in types, they might not be able to do the same for user-defined types (which could be something as innocently looking as a list iterator). Once you got used to do &lt;code&gt;i++&lt;/code&gt;, it becomes very hard to remember to do &lt;code&gt;++i&lt;/code&gt; instead when &lt;code&gt;i&lt;/code&gt; is not of a built-in type (plus you'd have to change code when changing a type), so it is better to make a habit of always using prefix increment, unless postfix is explicitly needed.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;还请注意，postfix变体比前缀变体执行更多的工作，因此使用效率较低。&lt;/sub&gt; &lt;sub&gt;这是一个很好的理由，通常优先选择前缀增量而不是后缀增量。&lt;/sub&gt; &lt;sub&gt;尽管编译器通常可以优化内置类型的后缀增量的其他工作，但对于用户定义的类型，它们可能无法执行相同的工作（这可能像列表迭代器一样无辜）。&lt;/sub&gt; &lt;sub&gt;一旦您习惯使用 &lt;code&gt;i++&lt;/code&gt; ，当 &lt;code&gt;i&lt;/code&gt; 不是内置类型（加上更改类型时必须更改代码）时，就很难记住要执行 &lt;code&gt;++i&lt;/code&gt; 了。养成始终使用前缀增量的习惯，除非明确需要后缀。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="3f5b8f85cc67312e85c8eb294398952de5c9070e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;It should be noted that the built-in version of &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; use shortcut semantics. While the user defined ones (because they are syntactic sugar for method calls) do not use shortcut semantics. User will expect these operators to have shortcut semantics, and their code may depend on it, Therefore it is highly advised NEVER to define them.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;应该注意的是 &lt;code&gt;||&lt;/code&gt; 的内置版本&lt;/sub&gt; &lt;sub&gt;和 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 使用快捷方式语义。&lt;/sub&gt; &lt;sub&gt;尽管用户定义的语法（因为它们是方法调用的语法糖），却不使用快捷方式语义。&lt;/sub&gt; &lt;sub&gt;用户将期望这些运算符具有快捷方式语义，并且它们的代码可能依赖于此，因此，强烈建议不要定义它们。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e3c92f172f9d6a21e1edbee610bd748896095eab" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;This is covered in &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/4421729#4421729&quot;&gt;a later part&lt;/a&gt; of this FAQ.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;此常见问题&lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/4421729#4421729&quot;&gt;的后面部分&lt;/a&gt;对此进行了介绍。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2d81bca5cf7dc6ada15492470100c9698c01c407" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3&lt;/sup&gt;&lt;sub&gt;Again, the lesson to be taken from this is that &lt;code&gt;a += b&lt;/code&gt; is, in general, more efficient than &lt;code&gt;a + b&lt;/code&gt; and should be preferred if possible.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;3&lt;/sup&gt; &lt;sub&gt;再次，从中可以得出的教训是， &lt;code&gt;a += b&lt;/code&gt; 通常比 &lt;code&gt;a + b&lt;/code&gt; 更有效，并且如果可能的话应该首选。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5cca32e7a575b9db399f83cf13cfe08fee093572" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3&lt;/sup&gt;&lt;sub&gt;The &lt;code&gt;@&lt;/code&gt; is not a valid operator in C++ which is why I use it as a placeholder.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;3&lt;/sup&gt; &lt;sub&gt; &lt;code&gt;@&lt;/code&gt; 在C ++中不是有效的运算符，这就是为什么我将其用作占位符。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="fb4e0ac4049821674fc6813ec9ef8cfd305f5ca1" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;4&lt;/sup&gt;&lt;sub&gt;The only ternary operator in C++ cannot be overloaded and the only n-ary operator must always be implemented as a member function.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;4&lt;/sup&gt; &lt;sub&gt;C ++中唯一的三元运算符不能重载，并且唯一的n元运算符必须始终作为成员函数实现。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="276a8f6944c21a071705fa227dcf9ba993594a29" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;strong&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/strong&gt; This only deals with the &lt;strong&gt;&lt;em&gt;syntax&lt;/em&gt;&lt;/strong&gt; of overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, not with the &lt;strong&gt;&lt;em&gt;implementation&lt;/em&gt;&lt;/strong&gt; of such overloaded operators. I think that the semantics of overloading &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7149461/&quot;&gt;&lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; deserve their own FAQ&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;, within the topic of operator overloading I can never do it justice.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;strong&gt;&lt;em&gt;注意：&lt;/em&gt;&lt;/strong&gt;这仅处理重载 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 的&lt;strong&gt;&lt;em&gt;语法&lt;/em&gt;&lt;/strong&gt; ，而不处理此类重载运算符的&lt;strong&gt;&lt;em&gt;实现&lt;/em&gt;&lt;/strong&gt; 。&lt;/sup&gt; &lt;sup&gt;我认为重载&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7149461/&quot;&gt; &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;的语义&lt;strong&gt;&lt;em&gt;应该得到他们自己的FAQ&lt;/em&gt;&lt;/strong&gt; ，在运算符重载的主题内，我永远无法做到这一点。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="421a43341da00165d391cdef2aecb500589bd6e0" translate="yes" xml:space="preserve">
          <source>According to our rules of thumb, &lt;code&gt;+&lt;/code&gt; and its companions should be non-members, while their compound assignment counterparts (&lt;code&gt;+=&lt;/code&gt; etc.), changing their left argument, should be a member. Here is the exemplary code for &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt;; the other binary arithmetic operators should be implemented in the same way:</source>
          <target state="translated">根据我们的经验法则， &lt;code&gt;+&lt;/code&gt; 及其同伴应为非成员，而其复合赋值对应对象（ &lt;code&gt;+=&lt;/code&gt; 等）（更改其左参数）应为成员。 这是 &lt;code&gt;+=&lt;/code&gt; 和 &lt;code&gt;+&lt;/code&gt; 的示例代码； 其他二进制算术运算符应以相同的方式实现：</target>
        </trans-unit>
        <trans-unit id="f3952c5c15a5c4f059ce1db8233deaaeda4f28a8" translate="yes" xml:space="preserve">
          <source>Among the operators that can be overloaded in C++ are these:</source>
          <target state="translated">在C++中可以超载的运算符有以下几种。</target>
        </trans-unit>
        <trans-unit id="be759ec493e1844e284eba0ba8febc88ff79e21f" translate="yes" xml:space="preserve">
          <source>An implicit conversion operator allows the compiler to implicitly convert (like the conversion between &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;) the value of a user-defined type to some other type.</source>
          <target state="translated">隐式转换运算符允许编译器将用户定义类型的值隐式转换（例如 &lt;code&gt;int&lt;/code&gt; 和 &lt;code&gt;long&lt;/code&gt; 之间的转换）为其他类型。</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">算术运算器</target>
        </trans-unit>
        <trans-unit id="aecc43fc2fe547cd50965b231d35b4682af12f07" translate="yes" xml:space="preserve">
          <source>Array Subscripting</source>
          <target state="translated">阵列订阅</target>
        </trans-unit>
        <trans-unit id="67c1b1f3ed026dea13ed68968e94e0a7d893d152" translate="yes" xml:space="preserve">
          <source>Assignment Operator</source>
          <target state="translated">分配操作员</target>
        </trans-unit>
        <trans-unit id="93070e8acd1b2a07488cdde5f031a65133a6cf12" translate="yes" xml:space="preserve">
          <source>At first this seems very helpful, but the problem with this is that the implicit conversion even kicks in when it isn&amp;rsquo;t expected to. In the following code, &lt;code&gt;void f(const char*)&lt;/code&gt; will be called because &lt;code&gt;my_string()&lt;/code&gt; is not an &lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;lvalue&lt;/a&gt;, so the first does not match:</source>
          <target state="translated">乍一看，这似乎很有帮助，但是问题是隐式转换甚至会在预期不到的时候启动。 在以下代码中，将调用 &lt;code&gt;void f(const char*)&lt;/code&gt; 因为 &lt;code&gt;my_string()&lt;/code&gt; 不是&lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;左值&lt;/a&gt; ，因此第一个不匹配：</target>
        </trans-unit>
        <trans-unit id="0ee8de3eebacd7c638e4729172a904422deca61b" translate="yes" xml:space="preserve">
          <source>Basically, the first and foremost rule for overloading operators, at its very heart, says: &lt;em&gt;Don&amp;rsquo;t do it&lt;/em&gt;. That might seem strange, because there is a lot to be known about operator overloading and so a lot of articles, book chapters, and other texts deal with all this. But despite this seemingly obvious evidence, &lt;em&gt;there are only a surprisingly few cases where operator overloading is appropriate&lt;/em&gt;. The reason is that actually it is hard to understand the semantics behind the application of an operator unless the use of the operator in the application domain is well known and undisputed. Contrary to popular belief, this is hardly ever the case.</source>
          <target state="translated">基本上，重载运算符的首要原则就是说： &lt;em&gt;不要这样做&lt;/em&gt; 。 这似乎很奇怪，因为关于运算符重载有很多已知的知识，因此许多文章，书籍章节和其他文本都涉及到这一切。 尽管有这些看似显而易见的证据， &lt;em&gt;但只有极少数情况下适合使用运算符重载&lt;/em&gt; 。 原因是实际上很难理解运算符应用程序背后的语义，除非在应用程序域中对运算符的使用是众所周知的且无可争议。 与普遍的看法相反，情况并非如此。</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4d0acd385943a19aff1dd079c0d333f73eeda130" translate="yes" xml:space="preserve">
          <source>Because the compiler will not cast &quot;past&quot; &lt;code&gt;bool&lt;/code&gt;, explicit conversion operators now remove the need for the &lt;a href=&quot;http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool&quot;&gt;Safe Bool idiom&lt;/a&gt;.   For example, smart pointers before C++11 used the Safe Bool idiom to prevent conversions to integral types.  In C++11, the smart pointers use an explicit operator instead because the compiler is not allowed to implicitly convert to an integral type after it explicitly converted a type to bool.</source>
          <target state="translated">因为编译器不会 &lt;code&gt;bool&lt;/code&gt; 转换过去，所以显式转换运算符现在无需使用&lt;a href=&quot;http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool&quot;&gt;Safe Bool习惯用法&lt;/a&gt; 。 例如，C ++ 11之前的智能指针使用Safe Bool习惯用法来防止转换为整数类型。 在C ++ 11中，智能指针使用显式运算符代替，因为在将类型显式转换为bool之后，不允许编译器隐式转换为整数。</target>
        </trans-unit>
        <trans-unit id="71c42caac2d9ddf4204de8698243a11cfa04f910" translate="yes" xml:space="preserve">
          <source>Beginners easily get this wrong and even experienced C++ programmers are sometimes surprised because the compiler picks an overload they didn&amp;rsquo;t suspect.  These problems can be mitigated by explicit conversion operators.</source>
          <target state="translated">初学者容易犯错，甚至经验丰富的C ++程序员有时也会感到惊讶，因为编译器会选择他们不怀疑的重载。 这些问题可以通过显式转换运算符缓解。</target>
        </trans-unit>
        <trans-unit id="91150bd6516ac5f77628d936130ba9cf5ec13ae6" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operators</source>
          <target state="translated">二进制算术运算符</target>
        </trans-unit>
        <trans-unit id="ae37c4e20a55a6ef0b50c1ce0e0f71802dbf0111" translate="yes" xml:space="preserve">
          <source>Bitshift Operators (used for Stream I/O)</source>
          <target state="translated">位移操作器(用于流 IO</target>
        </trans-unit>
        <trans-unit id="db69b09b584ceff2f01a827a244f4ddf0bcc8bfa" translate="yes" xml:space="preserve">
          <source>C++ allows new and delete operators to take additional arguments.</source>
          <target state="translated">C++允许新操作符和删除操作符采取额外的参数。</target>
        </trans-unit>
        <trans-unit id="cea3dbd2ef365f97b36a9803e63877ab2a2dcd07" translate="yes" xml:space="preserve">
          <source>C++ allows you to tune both of these operations: memory management and the construction/destruction of the object at the allocated memory. The latter is done by writing constructors and destructors for a class. Fine-tuning memory management is done by writing your own &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt;.</source>
          <target state="translated">C ++允许您调整以下两个操作：内存管理和分配的内存中对象的构造/销毁。 后者是通过为类编写构造函数和析构函数来完成的。 通过编写自己的 &lt;code&gt;operator new&lt;/code&gt; 和 &lt;code&gt;operator delete&lt;/code&gt; 可以对内存管理进行微调。</target>
        </trans-unit>
        <trans-unit id="53e1ae4928af9f305e18ff9d9d702bea83c43afc" translate="yes" xml:space="preserve">
          <source>C++ poses no limitations on the semantics of overloaded operators. Your compiler will happily accept code that implements the binary &lt;code&gt;+&lt;/code&gt; operator to subtract from its right operand. However, the users of such an operator would never suspect the expression &lt;code&gt;a + b&lt;/code&gt; to subtract &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;b&lt;/code&gt;. Of course, this supposes that the semantics of the operator in the application domain is undisputed.</source>
          <target state="translated">C ++对重载运算符的语义没有任何限制。 您的编译器将很乐意接受实现二进制 &lt;code&gt;+&lt;/code&gt; 运算符的代码，以从其右操作数中减去。 但是，这种运算符的用户永远不会怀疑表达式 &lt;code&gt;a + b&lt;/code&gt; 从 &lt;code&gt;b&lt;/code&gt; 中减去a 。 当然，这假定在应用程序域中运算符的语义是无可争议的。</target>
        </trans-unit>
        <trans-unit id="7c17731e50f62eea89cf01a119386ba15a466c77" translate="yes" xml:space="preserve">
          <source>Class-specific new and delete</source>
          <target state="translated">特定类别的新增和删除</target>
        </trans-unit>
        <trans-unit id="7266bf079b182acba7043970de462e41b2663d92" translate="yes" xml:space="preserve">
          <source>Common operators to overload</source>
          <target state="translated">常见的运算器过载</target>
        </trans-unit>
        <trans-unit id="9461d4c9f916ad7df5538225ed552fb6e7e3284b" translate="yes" xml:space="preserve">
          <source>Comparison operators</source>
          <target state="translated">比较操作者</target>
        </trans-unit>
        <trans-unit id="d8ddbec0b26e694dbe2e4392c23c80e62413f2d4" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708&quot;&gt;The Three Basic Rules of Operator Overloading in C++&lt;/a&gt;.</source>
          <target state="translated">继续&lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708&quot;&gt;遵循C ++中运算符重载的三个基本规则&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="9a650afcae173aef7cbc03df980e79ab8dcfc031" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719#4421719&quot;&gt;Common operators to overload&lt;/a&gt;.</source>
          <target state="translated">继续让&lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719#4421719&quot;&gt;Common运算符超载&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="49e07535d312dbe3a4fc30e2d414ba6a141b3abe" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729&quot;&gt;The Decision between Member and Non-member&lt;/a&gt;.</source>
          <target state="translated">继续进行&lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729&quot;&gt;成员与非成员之间的决定&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="390e8f97087fe4c33287f0dec7d962032d84d2b0" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791#4421791&quot;&gt;Overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">继续&lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791#4421791&quot;&gt;重载 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="0c4829881d2b9099fb960d607315a36454fc1c0d" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725&quot;&gt;Conversion Operators&lt;/a&gt;</source>
          <target state="translated">继续向&lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725&quot;&gt;转换运算符&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cce1bda201abe07a87309c10681fbc4836893a50" translate="yes" xml:space="preserve">
          <source>Conversion Operators</source>
          <target state="translated">转换操作人员</target>
        </trans-unit>
        <trans-unit id="97921336d267bc620b6817f8d0fbd3946c8e1724" translate="yes" xml:space="preserve">
          <source>Conversion Operators (also known as User Defined Conversions)</source>
          <target state="translated">转换操作器(也称为用户定义的转换操作器</target>
        </trans-unit>
        <trans-unit id="06916bcd529378cd7be8d494e6a076cdff280dfb" translate="yes" xml:space="preserve">
          <source>Explicit Conversion Operators (C++11)</source>
          <target state="translated">显式转换运算符(C++11)</target>
        </trans-unit>
        <trans-unit id="bb0bf432160bebf9e28e99e45037098df491690e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;operator-&amp;gt;*()&lt;/code&gt; see &lt;a href=&quot;https://stackoverflow.com/q/8777845/140719&quot;&gt;this question&lt;/a&gt;. It's rarely used and thus rarely ever overloaded. In fact, even iterators do not overload it.</source>
          <target state="translated">对于 &lt;code&gt;operator-&amp;gt;*()&lt;/code&gt; ,请参阅&lt;a href=&quot;https://stackoverflow.com/q/8777845/140719&quot;&gt;此问题&lt;/a&gt; 。 它很少使用，因此也很少过载。 实际上，即使迭代器也不会使它过载。</target>
        </trans-unit>
        <trans-unit id="f6ea334ff6ce5f1423f350e93f69641ce7406130" translate="yes" xml:space="preserve">
          <source>For all operators where you have to choose to either implement them as a member function or a non-member function, &lt;strong&gt;&lt;em&gt;use the following rules of thumb&lt;/em&gt;&lt;/strong&gt; to decide:</source>
          <target state="translated">对于必须选择将其实现为成员函数或非成员函数的所有运算符，请&lt;strong&gt;&lt;em&gt;使用以下经验法则&lt;/em&gt;&lt;/strong&gt;来确定：</target>
        </trans-unit>
        <trans-unit id="d69d65276d05cacbd13652fa039509c5c7448719" translate="yes" xml:space="preserve">
          <source>For defining your own iterators or smart pointers, you have to overload the unary prefix dereference operator &lt;code&gt;*&lt;/code&gt; and the binary infix pointer member access operator &lt;code&gt;-&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">要定义自己的迭代器或智能指针，您必须重载一元前缀取消引用运算符 &lt;code&gt;*&lt;/code&gt; 和二进制中缀指针成员访问运算符 &lt;code&gt;-&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="1587e1394f773c588778fbe18bdd8ed62ff6821b" translate="yes" xml:space="preserve">
          <source>For the binary arithmetic operators, do not forget to obey the third basic rule operator overloading: If you provide &lt;code&gt;+&lt;/code&gt;, also provide &lt;code&gt;+=&lt;/code&gt;, if you provide &lt;code&gt;-&lt;/code&gt;, do not omit &lt;code&gt;-=&lt;/code&gt;, etc. Andrew Koenig is said to have been the first to observe that the compound assignment operators can be used as a base for their non-compound counterparts. That is, operator &lt;code&gt;+&lt;/code&gt; is implemented in terms of &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; is implemented in terms of &lt;code&gt;-=&lt;/code&gt; etc.</source>
          <target state="translated">对于二进制算术运算符，请不要忘记遵守第三个基本规则运算符重载：如果提供 &lt;code&gt;+&lt;/code&gt; ，还提供 &lt;code&gt;+=&lt;/code&gt; ，如果提供 &lt;code&gt;-&lt;/code&gt; ，请不要省略 &lt;code&gt;-=&lt;/code&gt; ，等等。据说安德鲁&amp;middot;科尼希（Andrew Koenig）是第一个观察到化合物赋值运算符可以用作其非化合物对应物的基础。 也就是说，运算符 &lt;code&gt;+&lt;/code&gt; 是根据 &lt;code&gt;+=&lt;/code&gt; 实现的， &lt;code&gt;-&lt;/code&gt; 是依据 &lt;code&gt;-=&lt;/code&gt; 实现的等。</target>
        </trans-unit>
        <trans-unit id="25056cd4f19ab3cf2ddbe426ca4f88659c9ecb1f" translate="yes" xml:space="preserve">
          <source>Function call operator</source>
          <target state="translated">函数调用操作员</target>
        </trans-unit>
        <trans-unit id="266781763563b15feb1a51bb6a9014424ae1126a" translate="yes" xml:space="preserve">
          <source>Given that, you cannot use:</source>
          <target state="translated">鉴于此,你不能使用。</target>
        </trans-unit>
        <trans-unit id="90be49000bdd6cb11fcaf3b36883081fc56eaccc" translate="yes" xml:space="preserve">
          <source>Global new and delete</source>
          <target state="translated">全局新增和删除</target>
        </trans-unit>
        <trans-unit id="40ccf2f37dd214c6d5991f8f2094c0e81dc4e65d" translate="yes" xml:space="preserve">
          <source>Here's an example of the syntax:</source>
          <target state="translated">下面是一个语法的例子。</target>
        </trans-unit>
        <trans-unit id="2f19bc6ee55c37f3c7803fde5dc79430596476a8" translate="yes" xml:space="preserve">
          <source>However, the fact that you &lt;em&gt;can&lt;/em&gt; overload all of these does not mean you &lt;em&gt;should&lt;/em&gt; do so. See the basic rules of operator overloading.</source>
          <target state="translated">但是，您&lt;em&gt;可以&lt;/em&gt;重载所有这些事实并不意味着您&lt;em&gt;应该&lt;/em&gt;这样做。 请参阅运算符重载的基本规则。</target>
        </trans-unit>
        <trans-unit id="d1df6c2555df05f2e2d7b30909ceaba1a04419ac" translate="yes" xml:space="preserve">
          <source>However, there is one exception to this:  The compiler is allowed to implicitly convert to &lt;code&gt;bool&lt;/code&gt;.  In addition, the compiler is not allowed to do another implicit conversion after it converts to &lt;code&gt;bool&lt;/code&gt; (a compiler is allowed to do 2 implicit conversions at a time, but only 1 user-defined conversion at max).</source>
          <target state="translated">但是，有一个例外：允许编译器隐式转换为 &lt;code&gt;bool&lt;/code&gt; 。 另外，编译器在转换为 &lt;code&gt;bool&lt;/code&gt; 后，不允许进行其他隐式转换（编译器一次只能进行2次隐式转换，但最多只能进行1个用户定义的转换）。</target>
        </trans-unit>
        <trans-unit id="52ab79f2235a5be84cd7d66fe9e8c1206c27da29" translate="yes" xml:space="preserve">
          <source>If a binary operator does &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; treat both of its operands &lt;strong&gt;&lt;em&gt;equally&lt;/em&gt;&lt;/strong&gt; (usually it will change its left operand), it might be useful to make it a &lt;strong&gt;&lt;em&gt;member&lt;/em&gt;&lt;/strong&gt; function of its left operand&amp;rsquo;s type, if it has to access the operand's private parts.</source>
          <target state="translated">如果二进制运算符&lt;strong&gt;&lt;em&gt;不能&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;平等地&lt;/em&gt;&lt;/strong&gt;对待其两个操作数（通常会更改其左操作数），则在必须访问该操作数的私有部分的情况下，使其成为其左操作数类型的&lt;strong&gt;&lt;em&gt;成员&lt;/em&gt;&lt;/strong&gt;函数可能会很有用。</target>
        </trans-unit>
        <trans-unit id="9dbf7e58fa487fdde1f10120a1e361214ac8d248" translate="yes" xml:space="preserve">
          <source>If a binary operator treats &lt;strong&gt;&lt;em&gt;both operands equally&lt;/em&gt;&lt;/strong&gt; (it leaves them unchanged), implement this operator as a &lt;strong&gt;&lt;em&gt;non-member&lt;/em&gt;&lt;/strong&gt; function.</source>
          <target state="translated">如果二进制运算符将&lt;strong&gt;&lt;em&gt;两个操作数均等地&lt;/em&gt;&lt;/strong&gt;对待（使它们不变），则将该运算符实现&lt;strong&gt;&lt;em&gt;为非成员&lt;/em&gt;&lt;/strong&gt;函数。</target>
        </trans-unit>
        <trans-unit id="ed6a13f07242d7d741efc0c6314f4777012e50e3" translate="yes" xml:space="preserve">
          <source>If it is a &lt;strong&gt;&lt;em&gt;unary operator&lt;/em&gt;&lt;/strong&gt;, implement it as a &lt;strong&gt;&lt;em&gt;member&lt;/em&gt;&lt;/strong&gt; function.</source>
          <target state="translated">如果它是一&lt;strong&gt;&lt;em&gt;元运算符&lt;/em&gt;&lt;/strong&gt; ，则将其实现为&lt;strong&gt;&lt;em&gt;成员&lt;/em&gt;&lt;/strong&gt;函数。</target>
        </trans-unit>
        <trans-unit id="262c7f3eacf6b4b4a482e67f29ed9ce4d067684f" translate="yes" xml:space="preserve">
          <source>If value_type is known to refer to a built-in type, the const variant of the operator should better return a copy instead of a const reference:</source>
          <target state="translated">如果已知value_type是指一个内置类型,那么操作符的const变体最好返回一个副本而不是const引用。</target>
        </trans-unit>
        <trans-unit id="f4c82304b319df56b3a1e32bbe46b626dd2db4cf" translate="yes" xml:space="preserve">
          <source>If you define it as a non-member function,</source>
          <target state="translated">如果你把它定义为非会员功能。</target>
        </trans-unit>
        <trans-unit id="c3222f784f51643651a73e25ba26b59a34a1a97e" translate="yes" xml:space="preserve">
          <source>If you overload &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, you should consider overloading the array variants, too.</source>
          <target state="translated">如果重载 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; ，则也应考虑重载数组变量。</target>
        </trans-unit>
        <trans-unit id="f13af45755f6d4b1682363cc396a98d01a7f9a22" translate="yes" xml:space="preserve">
          <source>If you overload &lt;code&gt;operator new&lt;/code&gt;, you should always also overload the matching &lt;code&gt;operator delete&lt;/code&gt;, even if you never intend to call it. The reason is that, if a constructor throws during the evaluation of a new expression, the run-time system will return the memory to the &lt;code&gt;operator delete&lt;/code&gt; matching the &lt;code&gt;operator new&lt;/code&gt; that was called to allocate the memory to create the object in. If you do not provide a matching &lt;code&gt;operator delete&lt;/code&gt;, the default one is called, which is almost always wrong.</source>
          <target state="translated">如果您重载了 &lt;code&gt;operator new&lt;/code&gt; ，那么即使您从未打算调用它，也应该始终重载匹配的 &lt;code&gt;operator delete&lt;/code&gt; 。 原因是，如果构造函数在对新表达式求值时抛出异常，则运行时系统会将内存返回给 &lt;code&gt;operator delete&lt;/code&gt; 将其与匹配的 &lt;code&gt;operator new&lt;/code&gt; 运算符相匹配，后者被调用以分配内存以创建对象。不提供匹配的 &lt;code&gt;operator delete&lt;/code&gt; ，则调用默认的运算符 ，这几乎总是错误的。</target>
        </trans-unit>
        <trans-unit id="826dbaa31e10b50624ed6f5bcb81e5a26a59de5f" translate="yes" xml:space="preserve">
          <source>Implicit Conversion Operators (C++98/C++03 and C++11)</source>
          <target state="translated">隐式转换运算符(C++98C++03和C++11)</target>
        </trans-unit>
        <trans-unit id="64b3307a85f7de1505aa3f37db4699689e2030a6" translate="yes" xml:space="preserve">
          <source>Implicit conversion operators, like one-argument constructors, are user-defined conversions. Compilers will grant one user-defined conversion when trying to match a call to an overloaded function.</source>
          <target state="translated">隐式转换操作符,就像单参数构造函数一样,是用户定义的转换。编译器在尝试匹配调用重载函数时,会授予一个用户定义的转换操作符。</target>
        </trans-unit>
        <trans-unit id="40caa674c8cd189d440009873823c8ee2f813b8c" translate="yes" xml:space="preserve">
          <source>In C++ you can create conversion operators, operators that allow the compiler to convert between your types and other defined types.  There are two types of conversion operators, implicit and explicit ones.</source>
          <target state="translated">在C++中,你可以创建转换操作符,即允许编译器在你的类型和其他定义的类型之间进行转换的操作符。转换操作符有两种类型,隐式和显式转换操作符。</target>
        </trans-unit>
        <trans-unit id="49ef7e77ad3309f43ce0a0c931ad5b00264bdae6" translate="yes" xml:space="preserve">
          <source>In C++, operators are overloaded in the form of &lt;strong&gt;&lt;em&gt;functions with special names&lt;/em&gt;&lt;/strong&gt;. As with other functions, overloaded operators can generally be implemented either as a &lt;strong&gt;&lt;em&gt;member function of their left operand's type&lt;/em&gt;&lt;/strong&gt; or as &lt;strong&gt;&lt;em&gt;non-member functions&lt;/em&gt;&lt;/strong&gt;. Whether you are free to choose or bound to use either one depends on several criteria.&lt;sup&gt;2&lt;/sup&gt; A unary operator &lt;code&gt;@&lt;/code&gt;&lt;sup&gt;3&lt;/sup&gt;, applied to an object x, is invoked either as &lt;code&gt;operator@(x)&lt;/code&gt; or as &lt;code&gt;x.operator@()&lt;/code&gt;. A binary infix operator &lt;code&gt;@&lt;/code&gt;, applied to the objects &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, is called either as &lt;code&gt;operator@(x,y)&lt;/code&gt; or as &lt;code&gt;x.operator@(y)&lt;/code&gt;.&lt;sup&gt;4&lt;/sup&gt;</source>
          <target state="translated">在C ++中，运算符以&lt;strong&gt;&lt;em&gt;具有特殊名称&lt;/em&gt;&lt;/strong&gt;的&lt;strong&gt;&lt;em&gt;函数&lt;/em&gt;&lt;/strong&gt;的形式被重载。 与其他函数一样，重载运算符通常可以实现&lt;strong&gt;&lt;em&gt;为其左操作数类型&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;的成员函数&lt;/em&gt;&lt;/strong&gt;或实现&lt;strong&gt;&lt;em&gt;为非成员函数&lt;/em&gt;&lt;/strong&gt; 。 您是否可以自由选择还是必须使用其中之一取决于多个条件。 &lt;sup&gt;2&lt;/sup&gt;应用于对象x的一元运算符 &lt;code&gt;@&lt;/code&gt; &lt;sup&gt;3&lt;/sup&gt;可以作为 &lt;code&gt;operator@(x)&lt;/code&gt; 或 &lt;code&gt;x.operator@()&lt;/code&gt; 调用。 应用于对象 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的二进制中缀运算符 &lt;code&gt;@&lt;/code&gt; 被称为 &lt;code&gt;operator@(x,y)&lt;/code&gt; 或 &lt;code&gt;x.operator@(y)&lt;/code&gt; 。 &lt;sup&gt;4&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7bc8481881e8590c8face179b924af1ea4a5fe0a" translate="yes" xml:space="preserve">
          <source>In C++, when you write a &lt;strong&gt;&lt;em&gt;new expression&lt;/em&gt;&lt;/strong&gt; like &lt;code&gt;new T(arg)&lt;/code&gt; two things happen when this expression is evaluated: First &lt;strong&gt;&lt;em&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt; is invoked to obtain raw memory, and then the appropriate constructor of &lt;code&gt;T&lt;/code&gt; is invoked to turn this raw memory into a valid object. Likewise, when you delete an object, first its destructor is called, and then the memory is returned to &lt;code&gt;operator delete&lt;/code&gt;.</source>
          <target state="translated">在C ++中，当您编写一个类似于 &lt;code&gt;new T(arg)&lt;/code&gt; 的&lt;strong&gt;&lt;em&gt;新表达式&lt;/em&gt;&lt;/strong&gt;时，对该表达式求值时会发生两件事：首先调用&lt;strong&gt;&lt;em&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt;以获取原始内存，然后调用 &lt;code&gt;T&lt;/code&gt; 的适当构造函数以将该原始内存转换为a有效对象。 同样，删除对象时，首先将调用其析构函数，然后将内存返回给 &lt;code&gt;operator delete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="9d9a856b351238fc8815cf318816c5839249dbd0" translate="yes" xml:space="preserve">
          <source>Input and Output Operators</source>
          <target state="translated">输入和输出运算器</target>
        </trans-unit>
        <trans-unit id="aff987919c1c656b540f21e98fcd457a77a08632" translate="yes" xml:space="preserve">
          <source>Let's say you have:</source>
          <target state="translated">假设你有。</target>
        </trans-unit>
        <trans-unit id="1da0a13b5d45735843a1a97b7d80a3c4e94a7d15" translate="yes" xml:space="preserve">
          <source>Most commonly you will want to fine-tune memory management because measurement has shown that instances of a specific class, or of a group of related classes, are created and destroyed often and that the default memory management of the run-time system, tuned for general performance, deals inefficiently in this specific case. To improve this, you can overload new and delete for a specific class:</source>
          <target state="translated">大多数情况下,你会希望对内存管理进行微调,因为测量表明,一个特定类或一组相关类的实例经常会被创建和销毁,而运行时系统的默认内存管理,在这种特殊情况下,为了一般的性能而调整的内存管理效率很低。为了改善这种情况,可以对特定类的新建和删除进行超载。</target>
        </trans-unit>
        <trans-unit id="7bc4f7a69868fbbebd9b1aa75e004a5d424231ae" translate="yes" xml:space="preserve">
          <source>Most of the work in overloading operators is boiler-plate code. That is little wonder, since operators are merely syntactic sugar, their actual work could be done by (and often is forwarded to) plain functions. But it is important that you get this boiler-plate code right. If you fail, either your operator&amp;rsquo;s code won&amp;rsquo;t compile or your users&amp;rsquo; code won&amp;rsquo;t compile or your users&amp;rsquo; code will behave surprisingly.</source>
          <target state="translated">重载操作员中的大部分工作是样板代码。 这也就不足为奇了，由于运算符仅仅是语法糖，它们的实际工作可以通过（通常转发给）普通函数来完成。 但是，重要的是要正确编写此样板代码。 如果失败，则操作员的代码将无法编译，或者用户的代码将无法编译，或者用户的代码将表现出惊人的性能。</target>
        </trans-unit>
        <trans-unit id="308ac793bd96cffbd3257f710242d8d6baa8c5f9" translate="yes" xml:space="preserve">
          <source>Not all operators can be overloaded in C++. Among the operators that cannot be overloaded are: &lt;code&gt;.&lt;/code&gt;&lt;code&gt;::&lt;/code&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt; and the only ternary operator in C++, &lt;code&gt;?:&lt;/code&gt;</source>
          <target state="translated">并非所有运算符都可以在C ++中重载。 不能重载的运算符包括： &lt;code&gt;.&lt;/code&gt; &lt;code&gt;::&lt;/code&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; 和C ++中唯一的三元运算符 &lt;code&gt;?:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba5b304e147804bebb9771281e8f850c466d01fa" translate="yes" xml:space="preserve">
          <source>Note that the postfix variant is implemented in terms of prefix. Also note that postfix does an extra copy.&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">请注意，后缀变体是根据前缀实现的。 另请注意，后缀会额外复制。 &lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a98223f6637a4998c4f367f083b8d38397dc9316" translate="yes" xml:space="preserve">
          <source>Note that these, too, will almost always need both a const and a non-const version.
For the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator, if &lt;code&gt;value_type&lt;/code&gt; is of &lt;code&gt;class&lt;/code&gt; (or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt;) type, another &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; is called recursively, until an &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; returns a value of non-class type.</source>
          <target state="translated">注意，这些也几乎总是需要const和非const版本。 对于 &lt;code&gt;-&amp;gt;&lt;/code&gt; 运算符，如果 &lt;code&gt;value_type&lt;/code&gt; 是 &lt;code&gt;class&lt;/code&gt; （或 &lt;code&gt;struct&lt;/code&gt; 或 &lt;code&gt;union&lt;/code&gt; ）类型，则递归调用另一个 &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; ，直到 &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; 返回非类类型的值。</target>
        </trans-unit>
        <trans-unit id="2b329ad0d568d6f8e12b0e15d54437e0b250ccda" translate="yes" xml:space="preserve">
          <source>Note that, in the example code for placement new given above, &lt;code&gt;operator delete&lt;/code&gt; is never called, unless the constructor of X throws an exception.</source>
          <target state="translated">请注意，在上面给出的用于放置新位置的示例代码中，除非X的构造函数抛出异常，否则永远不会调用 &lt;code&gt;operator delete&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="e34f82c929e61f88c2610287d88fb521a0cf8bf6" translate="yes" xml:space="preserve">
          <source>Note: The answers were given in &lt;em&gt;a specific order&lt;/em&gt;, but since many users sort answers according to votes, rather than the time they were given, here's an &lt;strong&gt;&lt;em&gt;index of the answers&lt;/em&gt;&lt;/strong&gt; in the order in which they make most sense:</source>
          <target state="translated">注意：答案是按照&lt;em&gt;特定顺序&lt;/em&gt;给出的，但是由于许多用户是根据投票而不是给出时间&lt;strong&gt;&lt;em&gt;来对答案&lt;/em&gt;&lt;/strong&gt;进行排序的，因此以下是最有意义的顺序的&lt;strong&gt;&lt;em&gt;索引&lt;/em&gt;&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="88ae2678453b7004e74233094e1cdf9026fbf332" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;explicit&lt;/code&gt;.  Now when you try to execute the unexpected code from the implicit conversion operators, you get a compiler error:</source>
          <target state="translated">注意 &lt;code&gt;explicit&lt;/code&gt; 。 现在，当您尝试从隐式转换运算符执行意外的代码时，会出现编译器错误：</target>
        </trans-unit>
        <trans-unit id="5ed5a83cf4720e09bb656ff2ed60cc35eca54b74" translate="yes" xml:space="preserve">
          <source>Of course, as with all rules of thumb, there are exceptions. If you have a type</source>
          <target state="translated">当然,与所有的经验法则一样,也有例外。如果你有一个类型</target>
        </trans-unit>
        <trans-unit id="71635eee6d0e7a43c1616fdd99b28d55662b9781" translate="yes" xml:space="preserve">
          <source>Operators for Pointer-like Types</source>
          <target state="translated">类似指针类型的运算符</target>
        </trans-unit>
        <trans-unit id="232c32ffd9745850f7cd1967b4a1a159748cf1ff" translate="yes" xml:space="preserve">
          <source>Operators that are implemented as non-member functions are sometimes friend of their operand&amp;rsquo;s type.</source>
          <target state="translated">实现为非成员函数的运算符有时是其操作数类型的朋友。</target>
        </trans-unit>
        <trans-unit id="fbf47cfe86efefa771f3ac5016a6dee10f74b19c" translate="yes" xml:space="preserve">
          <source>Other operators can be implemented either as members or as non-members. Some of them, however, usually have to be implemented as non-member functions, because their left operand cannot be modified by you. The most prominent of these are the input and output operators &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, whose left operands are stream classes from the standard library which you cannot change.</source>
          <target state="translated">其他运算符可以实现为成员或非成员。 但是，其中一些通常必须实现为非成员函数，因为您无法修改其左操作数。 其中最突出的是输入和输出运算符 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; ，其左操作数是标准库中的流类，您不能更改它们。</target>
        </trans-unit>
        <trans-unit id="61c0c26e0870099af93b41d7ed973fe4422b7163" translate="yes" xml:space="preserve">
          <source>Overloaded thus, new and delete behave like static member functions. For objects of &lt;code&gt;my_class&lt;/code&gt;, the &lt;code&gt;std::size_t&lt;/code&gt; argument will always be &lt;code&gt;sizeof(my_class)&lt;/code&gt;. However, these operators are also called for dynamically allocated objects of &lt;strong&gt;&lt;em&gt;derived classes&lt;/em&gt;&lt;/strong&gt;, in which case it might be greater than that.</source>
          <target state="translated">因此，new和delete重载时的行为类似于静态成员函数。 对于 &lt;code&gt;my_class&lt;/code&gt; 的对象， &lt;code&gt;std::size_t&lt;/code&gt; 参数始终为 &lt;code&gt;sizeof(my_class)&lt;/code&gt; 。 但是，也需要为&lt;strong&gt;&lt;em&gt;派生类的&lt;/em&gt;&lt;/strong&gt;动态分配的对象调用这些运算符，在这种情况下，它可能会更大。</target>
        </trans-unit>
        <trans-unit id="387a1adda403a18b38d6933171fc8f31a2cbd62c" translate="yes" xml:space="preserve">
          <source>Overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">重载 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="918f907f18107b5038a28b4f7a181b670ec203fa" translate="yes" xml:space="preserve">
          <source>Overloading new and delete</source>
          <target state="translated">超载新增和删除</target>
        </trans-unit>
        <trans-unit id="6c74c5e2cff52e6b3146c3c1bffab6eeaab7158c" translate="yes" xml:space="preserve">
          <source>Overloading unary minus and plus is not very common and probably best avoided. If needed, they should probably be overloaded as member functions.</source>
          <target state="translated">过载单数减法和加法不是很常见,可能最好避免。如果需要的话,大概应该把它们作为成员函数超载。</target>
        </trans-unit>
        <trans-unit id="aef51910b519e257f69e8e603e5cc6e63bd7c663" translate="yes" xml:space="preserve">
          <source>Placement &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 刊登位置</target>
        </trans-unit>
        <trans-unit id="2f35e5b7132ff39e177d6482815cbd394c998601" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is overloaded as a member function of &lt;code&gt;Foo&lt;/code&gt;, the LHS of the operator must be a &lt;code&gt;Foo&lt;/code&gt; object. Which means, you will be required to use:</source>
          <target state="translated">由于 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 作为 &lt;code&gt;Foo&lt;/code&gt; 的成员函数被重载，因此该operator的LHS必须是 &lt;code&gt;Foo&lt;/code&gt; 对象。 这意味着，您将需要使用：</target>
        </trans-unit>
        <trans-unit id="48b7d95d9adba62275ebb23b2739fe7185d38c3e" translate="yes" xml:space="preserve">
          <source>So-called placement new allows you to create an object at a certain address which is passed to:</source>
          <target state="translated">所谓的置换新允许你在某个地址创建一个对象,这个对象会被传给。</target>
        </trans-unit>
        <trans-unit id="410499869878cd2bd1c723022f7e89e241865fba" translate="yes" xml:space="preserve">
          <source>The C++ standard library comes with a set of predefined &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; operators. The most important ones are these:</source>
          <target state="translated">C ++标准库附带了一组预定义的 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 运算符。 最重要的是：</target>
        </trans-unit>
        <trans-unit id="c5b39f9cfeee4e22210663bbd7c842296748cdf0" translate="yes" xml:space="preserve">
          <source>The Decision between Member and Non-member</source>
          <target state="translated">成员和非成员之间的决定</target>
        </trans-unit>
        <trans-unit id="2cdaded69a5ba8bbbc434264bc52e9dff47315be" translate="yes" xml:space="preserve">
          <source>The General Syntax of operator overloading in C++</source>
          <target state="translated">C++中算子重载的通用语法</target>
        </trans-unit>
        <trans-unit id="daa94d71b00e6fe8d0332493c4413afa5cc89105" translate="yes" xml:space="preserve">
          <source>The Three Basic Rules of Operator Overloading in C++</source>
          <target state="translated">C++中操作者超载的三大基本规则</target>
        </trans-unit>
        <trans-unit id="1ed425865c7b999b506d3bd64bd342aef7d971fa" translate="yes" xml:space="preserve">
          <source>The array subscript operator is a binary operator which must be implemented as a class member. It is used for container-like types that allow access to their data elements by a key.
The canonical form of providing these is this:</source>
          <target state="translated">数组下标操作符是一个二进制操作符,必须作为类成员来实现。它用于类似于容器的类型,允许通过一个键来访问它们的数据元素。提供这些类型的典型形式是这样的。</target>
        </trans-unit>
        <trans-unit id="5071b272c7cacc200a739ff1600233700cde5f39" translate="yes" xml:space="preserve">
          <source>The binary infix comparison operators should, according to the rules of thumb, be implemented as non-member functions&lt;sup&gt;1&lt;/sup&gt;. The unary prefix negation &lt;code&gt;!&lt;/code&gt; should (according to the same rules) be implemented as a member function. (but it is usually not a good idea to overload it.)</source>
          <target state="translated">根据经验法则，二进制中缀比较运算符应实现为非成员函数&lt;sup&gt;1&lt;/sup&gt; 。 一元前缀否定 &lt;code&gt;!&lt;/code&gt; 应该（按照相同的规则）实现为成员函数。 （但通常不建议重载它。）</target>
        </trans-unit>
        <trans-unit id="1f4eebeeaa95cd1e3a1f5148b3b1cf80c882d651" translate="yes" xml:space="preserve">
          <source>The binary operators &lt;code&gt;=&lt;/code&gt; (assignment), &lt;code&gt;[]&lt;/code&gt; (array subscription), &lt;code&gt;-&amp;gt;&lt;/code&gt; (member access), as well as the n-ary &lt;code&gt;()&lt;/code&gt; (function call) operator, must always be implemented as &lt;strong&gt;&lt;em&gt;member functions&lt;/em&gt;&lt;/strong&gt;, because the syntax of the language requires them to.</source>
          <target state="translated">二进制运算符 &lt;code&gt;=&lt;/code&gt; （赋值）， &lt;code&gt;[]&lt;/code&gt; （数组订阅）， &lt;code&gt;-&amp;gt;&lt;/code&gt; （成员访问）以及n-ary &lt;code&gt;()&lt;/code&gt; （函数调用）运算符必须始终作为&lt;strong&gt;&lt;em&gt;成员函数&lt;/em&gt;&lt;/strong&gt;实现，因为语言要求他们这样做。</target>
        </trans-unit>
        <trans-unit id="e752b73d2516a901950b1881135e09ba982f3610" translate="yes" xml:space="preserve">
          <source>The bit manipulation operators &lt;code&gt;~&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; should be implemented in the same way as the arithmetic operators. However, (except for overloading &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; for output and input) there are very few reasonable use cases for overloading these.</source>
          <target state="translated">位操作运算符 &lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 应该以与算术运算符相同的方式实现。 但是，（除了重载 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 用于输出和输入），很少有合理的用例来重载它们。</target>
        </trans-unit>
        <trans-unit id="945991f17734d3341c52c64409c763fa696537b0" translate="yes" xml:space="preserve">
          <source>The bitshift operators &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, although still used in hardware interfacing for the bit-manipulation functions they inherit from C, have become more prevalent as overloaded stream input and output operators in most applications.  For guidance overloading as bit-manipulation operators, see the section below on Binary Arithmetic Operators.  For implementing your own custom format and parsing logic when your object is used with iostreams, continue.</source>
          <target state="translated">尽管移位移位运算符 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 仍用于它们从C继承的位处理函数的硬件接口中，但在大多数应用程序中，它们已作为重载流输入和输出运算符而变得越来越普遍。 有关作为位操作运算符的指导重载，请参见下面有关二进制算术运算符的部分。 当对象与iostream一起使用时，要实现自己的自定义格式和解析逻辑，请继续。</target>
        </trans-unit>
        <trans-unit id="fff84f3d926b7bdd40f1cf1bda8210cabce8f711" translate="yes" xml:space="preserve">
          <source>The first of the basic rules of operator overloading &amp;ndash; &lt;em&gt;don&amp;rsquo;t do it&lt;/em&gt; &amp;ndash; applies especially to overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;. Almost the only reasons to overload these operators are &lt;strong&gt;&lt;em&gt;performance problems&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;memory constraints&lt;/em&gt;&lt;/strong&gt;, and in many cases, other actions, like &lt;em&gt;changes to the algorithms&lt;/em&gt; used, will provide a much &lt;strong&gt;&lt;em&gt;higher cost/gain ratio&lt;/em&gt;&lt;/strong&gt; than attempting to tweak memory management.</source>
          <target state="translated">运算符重载的第一条基本规则（ &lt;em&gt;不要这样做）&lt;/em&gt;尤其适用于重载 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 。 使这些运算符过载的几乎唯一原因是&lt;strong&gt;&lt;em&gt;性能问题&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;内存限制&lt;/em&gt;&lt;/strong&gt; ，并且在许多情况下，其他操作（如&lt;em&gt;更改所&lt;/em&gt;使用&lt;em&gt;的算法&lt;/em&gt; ）将提供比尝试调整内存管理&lt;strong&gt;&lt;em&gt;更高的成本/收益比&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="d34b042bc12c1d81ad05fa8ab3868d83da8eb700" translate="yes" xml:space="preserve">
          <source>The first two allocate/deallocate memory for an object, the latter two for an array of objects. If you provide your own versions of these, they will &lt;strong&gt;&lt;em&gt;not overload, but replace&lt;/em&gt;&lt;/strong&gt; the ones from the standard library.</source>
          <target state="translated">前两个为对象分配/释放内存，后两个为对象数组分配/释放内存。 如果您提供自己的版本，则它们&lt;strong&gt;&lt;em&gt;不会过载，但会替换&lt;/em&gt;&lt;/strong&gt;标准库中的版本。</target>
        </trans-unit>
        <trans-unit id="3913d839e0e0cdca08e79893f8e7739eb1267dab" translate="yes" xml:space="preserve">
          <source>The following is a simple class with an implicit conversion operator:</source>
          <target state="translated">下面是一个简单的类,里面有一个隐式转换算子。</target>
        </trans-unit>
        <trans-unit id="633d4c2f5c9eede69578ed2b0fb1b8a6678e93f3" translate="yes" xml:space="preserve">
          <source>The function call operator, used to create function objects, also known as functors, must be defined as a &lt;strong&gt;&lt;em&gt;member&lt;/em&gt;&lt;/strong&gt; function, so it always has the implicit &lt;code&gt;this&lt;/code&gt; argument of member functions. Other than this, it can be overloaded to take any number of additional arguments, including zero.</source>
          <target state="translated">必须将用于创建函数对象（也称为函子）的函数调用运算符定义为&lt;strong&gt;&lt;em&gt;成员&lt;/em&gt;&lt;/strong&gt;函数，因此它始终具有成员函数的隐式 &lt;code&gt;this&lt;/code&gt; 参数。 除此之外，可以重载任何数量的附加参数，包括零。</target>
        </trans-unit>
        <trans-unit id="f09b5b0acfb377a7aa0dcf24a9a4828f0e1de877" translate="yes" xml:space="preserve">
          <source>The important thing to note here is that only two of these operators actually do anything, the others are just forwarding their arguments to either of these two to do the actual work.</source>
          <target state="translated">这里需要注意的是,这些操作者中只有两个人实际做了什么,其他的人只是把他们的论点转给这两个人中的任何一个来做实际工作。</target>
        </trans-unit>
        <trans-unit id="c8a7556a69847cd86a1a393d720af19a6fe22b5a" translate="yes" xml:space="preserve">
          <source>The standard library comes with the appropriate overloads of the new and delete operators for this:</source>
          <target state="translated">标准库自带了相应的new和delete操作符的重载。</target>
        </trans-unit>
        <trans-unit id="6c83c7c063a1665405b1d98712a057d5666d471e" translate="yes" xml:space="preserve">
          <source>The standard library&amp;rsquo;s algorithms (e.g. &lt;code&gt;std::sort()&lt;/code&gt;) and types (e.g. &lt;code&gt;std::map&lt;/code&gt;) will always only expect &lt;code&gt;operator&amp;lt;&lt;/code&gt; to be present. However, the &lt;em&gt;users of your type will expect all the other operators to be present&lt;/em&gt;, too, so if you define &lt;code&gt;operator&amp;lt;&lt;/code&gt;, be sure to follow the third fundamental rule of operator overloading and also define all the other boolean comparison operators. The canonical way to implement them is this:</source>
          <target state="translated">标准库的算法（例如 &lt;code&gt;std::sort()&lt;/code&gt; ）和类型（例如 &lt;code&gt;std::map&lt;/code&gt; ）将始终仅期望 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 存在。 但是， &lt;em&gt;您的类型&lt;/em&gt;的&lt;em&gt;用户也希望所有其他运算符也都出现&lt;/em&gt; ，因此，如果您定义 &lt;code&gt;operator&amp;lt;&lt;/code&gt; ，请确保遵循运算符重载的第三条基本规则，并且还要定义所有其他布尔比较运算符。 实施它们的规范方法是：</target>
        </trans-unit>
        <trans-unit id="7b0324536b2aff8b5056489442124903baa2f6fb" translate="yes" xml:space="preserve">
          <source>The stream operators, among the most commonly overloaded operators, are binary infix operators for which the syntax specifies no restriction on whether they should be members or non-members.
Since they change their left argument (they alter the stream&amp;rsquo;s state), they should, according to the rules of thumb, be implemented as members of their left operand&amp;rsquo;s type. However, their left operands are streams from the standard library, and while most of the stream output and input operators defined by the standard library are indeed defined as members of the stream classes, when you implement output and input operations for your own types, you cannot change the standard library&amp;rsquo;s stream types. That&amp;rsquo;s why you need to implement these operators for your own types as non-member functions.
The canonical forms of the two are these:</source>
          <target state="translated">在最常见的重载运算符中，流运算符是二进制中缀运算符，其语法对它们应为成员还是非成员不加限制。 由于它们更改了左参数（它们更改了流的状态），因此应根据经验法则将其实现为左操作数类型的成员。 但是，它们的左操作数是标准库中的流，尽管标准库定义的大多数流输出和输入运算符的确定义为流类的成员，但是当您为自己的类型实现输出和输入操作时，无法更改标准库的流类型。 这就是为什么您需要将自己的类型的这些运算符实现为非成员函数。 两者的规范形式如下：</target>
        </trans-unit>
        <trans-unit id="e742cb5d317ff843e4d40ebac2e6b8a129167116" translate="yes" xml:space="preserve">
          <source>The syntax for overloading the remaining binary boolean operators (&lt;code&gt;||&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) follows the rules of the comparison operators. However, it is &lt;em&gt;very&lt;/em&gt; unlikely that you would find a reasonable use case for these&lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">重载其余二进制布尔运算符（ &lt;code&gt;||&lt;/code&gt; ， &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ）的语法遵循比较运算符的规则。 但是，您不太可能为这些&lt;sup&gt;2&lt;/sup&gt;找到合理的用例。</target>
        </trans-unit>
        <trans-unit id="43b92ed49085008f088b6b20f2dff39e47616f03" translate="yes" xml:space="preserve">
          <source>The unary address-of operator should never be overloaded.</source>
          <target state="translated">单一地址-of操作符绝对不应该过载。</target>
        </trans-unit>
        <trans-unit id="4e69702ccb56e46c30152ff70d54bcafe1d3b79d" translate="yes" xml:space="preserve">
          <source>The unary increment and decrement operators come in both prefix and postfix flavor. To tell one from the other, the postfix variants take an additional dummy int argument. If you overload increment or decrement, be sure to always implement both prefix and postfix versions.
Here is the canonical implementation of increment, decrement follows the same rules:</source>
          <target state="translated">单项增量和减量运算符有前缀和后缀两种类型。为了区分前缀和后缀操作符,后缀变体需要一个额外的虚值int参数。如果你超载了 increment 或 decrement,一定要确保同时实现前缀和后缀版本。下面是增量的常规实现,decrement遵循同样的规则。</target>
        </trans-unit>
        <trans-unit id="fafebafed54733670be4bdb8f0f077c58939e2eb" translate="yes" xml:space="preserve">
          <source>There's a lot to be said about assignment. However, most of it has already been said in &lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;GMan's famous Copy-And-Swap FAQ&lt;/a&gt;, so I'll skip most of it here, only listing the perfect assignment operator for reference:</source>
          <target state="translated">关于任务有很多要说的。 但是，大多数内容已经在&lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;GMan著名的复制和交换FAQ中进行了介绍&lt;/a&gt; ，因此在此我将跳过大部分内容，仅列出完美的赋值运算符以供参考：</target>
        </trans-unit>
        <trans-unit id="7d5a6745e57fd584e32c48350df5cf7b6c97a053" translate="yes" xml:space="preserve">
          <source>Throughout the C++ standard library, function objects are always copied. Your own function objects should therefore be cheap to copy. If a function object absolutely needs to use data which is expensive to copy, it is better to store that data elsewhere and have the function object refer to it.</source>
          <target state="translated">在整个C++标准库中,函数对象总是被复制。因此,你自己的函数对象应该是廉价的复制对象。如果一个函数对象绝对需要使用数据,而这个数据的复制成本很高,那么最好把这个数据存储在其他地方,让函数对象引用它。</target>
        </trans-unit>
        <trans-unit id="d096ebff9a794e9192a29686de4113ddeb056fa5" translate="yes" xml:space="preserve">
          <source>To invoke the explicit cast operator, you have to use &lt;code&gt;static_cast&lt;/code&gt;, a C-style cast, or a constructor style cast ( i.e. &lt;code&gt;T(value)&lt;/code&gt; ).</source>
          <target state="translated">要调用显式 &lt;code&gt;static_cast&lt;/code&gt; 运算符，必​​须使用static_cast ，C样式强制转换或构造函数样式强制转换 （即 &lt;code&gt;T(value)&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d8020d5538e9765d456a055193c573dc6171a136" translate="yes" xml:space="preserve">
          <source>To overload the global new and delete, simply replace the pre-defined operators of the standard library with our own. However, this rarely ever needs to be done.</source>
          <target state="translated">要使全局的new和delete过载,只需将标准库中的预设操作符替换成我们自己的操作符即可。然而,很少有必要这样做。</target>
        </trans-unit>
        <trans-unit id="f5a792933066b9a9e2ac32f6f06b8c7c9b9c310a" translate="yes" xml:space="preserve">
          <source>Unary arithmetic operators</source>
          <target state="translated">单元算术运算符</target>
        </trans-unit>
        <trans-unit id="97ec28a8a9251fa1cb37b5b5d4e4408efdf02f8b" translate="yes" xml:space="preserve">
          <source>Unless you do not want users of your class to be able to change data elements returned by &lt;code&gt;operator[]&lt;/code&gt; (in which case you can omit the non-const variant), you should always provide both variants of the operator.</source>
          <target state="translated">除非您不希望您的类的用户能够更改 &lt;code&gt;operator[]&lt;/code&gt; 返回的数据元素（在这种情况下，您可以忽略non-const变体），否则应始终提供两种运算符变体。</target>
        </trans-unit>
        <trans-unit id="4f28b9e24ebd784a9282ef8b29671b29756db1ae" translate="yes" xml:space="preserve">
          <source>Unlike implicit conversion operators, explicit conversion operators will never kick in when you don't expect them to.  The following is a simple class with an explicit conversion operator:</source>
          <target state="translated">与隐式转换操作符不同,显式转换操作符永远不会在你不期望它们出现的时候出现。下面是一个带有显式转换操作符的简单类。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="7a38cdb12264364efc9478d485dd17ef42cde482" translate="yes" xml:space="preserve">
          <source>What are the basic rules and idioms for operator overloading</source>
          <target state="translated">操作员超载的基本规则和成语有哪些?</target>
        </trans-unit>
        <trans-unit id="919377897e90c6bc8567a475cc62dd42597b7240" translate="yes" xml:space="preserve">
          <source>When implementing &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, manually setting the stream&amp;rsquo;s state is only necessary when the reading itself succeeded, but the result is not what would be expected.</source>
          <target state="translated">当实现 &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; ，仅当读取本身成功时才需要手动设置流的状态，但是结果不是预期的。</target>
        </trans-unit>
        <trans-unit id="f20d7d9e25980a2df4f9c97a919afac20cc35de6" translate="yes" xml:space="preserve">
          <source>When it comes to operator overloading in C++, there are &lt;strong&gt;&lt;em&gt;three basic rules you should follow&lt;/em&gt;&lt;/strong&gt;. As with all such rules, there are indeed exceptions. Sometimes people have deviated from them and the outcome was not bad code, but such positive deviations are few and far between. At the very least, 99 out of 100 such deviations I have seen were unjustified. However, it might just as well have been 999 out of 1000. So you&amp;rsquo;d better stick to the following rules.</source>
          <target state="translated">对于C ++中的运算符重载， &lt;strong&gt;&lt;em&gt;应遵循三个基本规则&lt;/em&gt;&lt;/strong&gt; 。 与所有此类规则一样，确实存在例外。 有时人们偏离了他们，结果不是不好的代码，但是这种积极的偏差很少而且相差甚远。 至少在我看到的100个此类偏差中，有99个是不合理的。 但是，也可能是千分之九千。因此，您最好遵循以下规则。</target>
        </trans-unit>
        <trans-unit id="37f76d33dcd336dfa74e1a497620ddd35c0ff0ac" translate="yes" xml:space="preserve">
          <source>Why can't &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; function for streaming objects to &lt;code&gt;std::cout&lt;/code&gt; or to a file be a member function?</source>
          <target state="translated">为什么 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 函数无法将对象流式传输到 &lt;code&gt;std::cout&lt;/code&gt; 或文件中，成为成员函数？</target>
        </trans-unit>
        <trans-unit id="39d720caae827c7c0b9c7f668fcb211ea7a7c1d0" translate="yes" xml:space="preserve">
          <source>You can also overload &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; with other arguments. As with the additional argument for placement new, these arguments are also listed within parentheses after the keyword &lt;code&gt;new&lt;/code&gt;. Merely for historical reasons, such variants are often also called placement new, even if their arguments are not for placing an object at a specific address.</source>
          <target state="translated">您还可以重载 &lt;code&gt;new&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 以及其他参数。 与用于放置new的其他参数一样，这些参数也在关键字 &lt;code&gt;new&lt;/code&gt; 后面的括号内列出。 仅出于历史原因，此类变体通常也称为&amp;ldquo;新放置&amp;rdquo;，即使它们的参数不是要在特定地址放置对象。</target>
        </trans-unit>
        <trans-unit id="7528cb53fda223cd367475e992221703ed9fdc71" translate="yes" xml:space="preserve">
          <source>You cannot change the meaning of operators for built-in types in C++, operators can only be overloaded for user-defined types&lt;sup&gt;1&lt;/sup&gt;. That is, at least one of the operands has to be of a user-defined type. As with other overloaded functions, operators can be overloaded for a certain set of parameters only once.</source>
          <target state="translated">您不能更改C ++中内置类型的运算符的含义，只能对用户定义的类型&lt;sup&gt;1&lt;/sup&gt;重载运算符。 即，至少一个操作数必须是用户定义的类型。 与其他重载函数一样，运算符只能对一组特定参数重载一次。</target>
        </trans-unit>
        <trans-unit id="9e8e2f1d8db91fd84d40e7c67b7a78f2b63f8119" translate="yes" xml:space="preserve">
          <source>You will be able to use:</source>
          <target state="translated">你将能够使用。</target>
        </trans-unit>
        <trans-unit id="216956e088f4509625dab4a52801ab781c0e31b0" translate="yes" xml:space="preserve">
          <source>and you want to overload the increment and decrement operators for it, you cannot do this as a member functions, since in C++, enum types cannot have member functions. So you have to overload it as a free function. And &lt;code&gt;operator&amp;lt;()&lt;/code&gt; for a class template nested within a class template is much easier to write and read when done as a member function inline in the class definition. But these are indeed rare exceptions.</source>
          <target state="translated">并且您想为其重载递增和递减运算符，则不能作为成员函数来执行此操作，因为在C ++中，枚举类型不能具有成员函数。 因此，您必须将其作为自由函数进行重载。 当在类定义中作为成员函数内联完成时，嵌套在类模板中的类模板的 &lt;code&gt;operator&amp;lt;()&lt;/code&gt; 易于编写和读取。 但是这些确实是罕见的例外。</target>
        </trans-unit>
        <trans-unit id="a8876728833443b597fddaff948d8ef7d8b6d6fb" translate="yes" xml:space="preserve">
          <source>arithmetic operators: &lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt; and &lt;code&gt;+=&lt;/code&gt;&lt;code&gt;-=&lt;/code&gt;&lt;code&gt;*=&lt;/code&gt;&lt;code&gt;/=&lt;/code&gt;&lt;code&gt;%=&lt;/code&gt; (all binary infix); &lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt; (unary prefix); &lt;code&gt;++&lt;/code&gt;&lt;code&gt;--&lt;/code&gt; (unary prefix and postfix)</source>
          <target state="translated">算术运算符： &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; 和 &lt;code&gt;+=&lt;/code&gt; &lt;code&gt;-=&lt;/code&gt; &lt;code&gt;*=&lt;/code&gt; &lt;code&gt;/=&lt;/code&gt; &lt;code&gt;%=&lt;/code&gt; （所有二进制中缀）； &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; （一元前缀）； &lt;code&gt;++&lt;/code&gt; &lt;code&gt;--&lt;/code&gt; （一元前缀和后缀）</target>
        </trans-unit>
        <trans-unit id="5a5099434f36ef0494a734223946a9f17c108f31" translate="yes" xml:space="preserve">
          <source>bit manipulation: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;amp;=&lt;/code&gt;&lt;code&gt;|=&lt;/code&gt;&lt;code&gt;^=&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; (all binary infix); &lt;code&gt;~&lt;/code&gt; (unary prefix)</source>
          <target state="translated">位操作： &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;amp;=&lt;/code&gt; &lt;code&gt;|=&lt;/code&gt; &lt;code&gt;^=&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; （所有二进制中缀）； &lt;code&gt;~&lt;/code&gt; （一元前缀）</target>
        </trans-unit>
        <trans-unit id="f93156b243321d1cbdfc482620959e7bf4ed1bf9" translate="yes" xml:space="preserve">
          <source>boolean algebra: &lt;code&gt;==&lt;/code&gt;&lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (all binary infix); &lt;code&gt;!&lt;/code&gt; (unary prefix)</source>
          <target state="translated">布尔代数： &lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;||&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; || &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; （所有二进制中缀）； &lt;code&gt;!&lt;/code&gt; （一元前缀）</target>
        </trans-unit>
        <trans-unit id="dfc056418cb491e7998e6f590c77a4dc4c43f3cf" translate="yes" xml:space="preserve">
          <source>implicit conversion operators</source>
          <target state="translated">隐含转换运算符</target>
        </trans-unit>
        <trans-unit id="5a8540091878a4d7ea3c96c572645994df60c30a" translate="yes" xml:space="preserve">
          <source>memory management: &lt;code&gt;new&lt;/code&gt;&lt;code&gt;new[]&lt;/code&gt;&lt;code&gt;delete&lt;/code&gt;&lt;code&gt;delete[]&lt;/code&gt;</source>
          <target state="translated">内存管理： &lt;code&gt;new&lt;/code&gt; &lt;code&gt;new[]&lt;/code&gt; &lt;code&gt;delete&lt;/code&gt; &lt;code&gt;delete[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81b2763337b529b56fc828c4327b362d3740d4ac" translate="yes" xml:space="preserve">
          <source>miscellany: &lt;code&gt;=&lt;/code&gt;&lt;code&gt;[]&lt;/code&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;code&gt;-&amp;gt;*&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;  (all binary infix); &lt;code&gt;*&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; (all unary prefix) &lt;code&gt;()&lt;/code&gt; (function call, n-ary infix)</source>
          <target state="translated">其他： &lt;code&gt;=&lt;/code&gt; &lt;code&gt;[]&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;code&gt;-&amp;gt;*&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; （所有二进制中缀）; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; （所有一元前缀） &lt;code&gt;()&lt;/code&gt; （函数调用，n元中缀）</target>
        </trans-unit>
        <trans-unit id="c824aa9ad53891d9b5e9c118b4ffd5c133b27edd" translate="yes" xml:space="preserve">
          <source>which is very intuitive.</source>
          <target state="translated">这是很直观的。</target>
        </trans-unit>
        <trans-unit id="0b24478dfb20b5a8671b13a521b4573226f340db" translate="yes" xml:space="preserve">
          <source>which is very non-intuitive.</source>
          <target state="translated">这是很不直观的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
