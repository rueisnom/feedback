<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/4421706">
    <body>
      <group id="4421706">
        <trans-unit id="ebdeccffb9c593d5235ca8b75391edfe495210fe" translate="yes" xml:space="preserve">
          <source>(However, &lt;em&gt;if&lt;/em&gt; you make an exception, do not forget the issue of &lt;code&gt;const&lt;/code&gt;-ness for the operand that, for member functions, becomes the implicit &lt;code&gt;this&lt;/code&gt; argument. If the operator as a non-member function would take its left-most argument as a &lt;code&gt;const&lt;/code&gt; reference, the same operator as a member function needs to have a &lt;code&gt;const&lt;/code&gt; at the end to make &lt;code&gt;*this&lt;/code&gt; a &lt;code&gt;const&lt;/code&gt; reference.)</source>
          <target state="translated">(그러나 예외를 만드는 &lt;em&gt;경우&lt;/em&gt; 멤버 함수의 경우 피연산자에 대한 &lt;code&gt;const&lt;/code&gt; -ness 문제를 잊지 마십시오. &lt;code&gt;this&lt;/code&gt; 함수는 암시 적 으로이 인수가됩니다. 비 멤버 함수로서의 연산자는 가장 왼쪽 인수를 &lt;code&gt;const&lt;/code&gt; 참조, 멤버 함수와 동일한 연산자에는 &lt;code&gt;*this&lt;/code&gt; 를 &lt;code&gt;const&lt;/code&gt; 참조로 만들려면 끝에 &lt;code&gt;const&lt;/code&gt; 가 있어야합니다.)</target>
        </trans-unit>
        <trans-unit id="a932915cc63f83451fad890ba330a2fe5b0e1013" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator+=&lt;/code&gt; returns its result per reference, while &lt;code&gt;operator+&lt;/code&gt; returns a copy of its result. Of course, returning a reference is usually more efficient than returning a copy, but in the case of &lt;code&gt;operator+&lt;/code&gt;, there is no way around the copying. When you write &lt;code&gt;a + b&lt;/code&gt;, you expect the result to be a new value, which is why &lt;code&gt;operator+&lt;/code&gt; has to return a new value.&lt;sup&gt;3&lt;/sup&gt;
Also note that &lt;code&gt;operator+&lt;/code&gt; takes its left operand &lt;strong&gt;&lt;em&gt;by copy&lt;/em&gt;&lt;/strong&gt; rather than by const reference. The reason for this is the same as the reason giving for &lt;code&gt;operator=&lt;/code&gt; taking its argument per copy.</source>
          <target state="translated">&lt;code&gt;operator+=&lt;/code&gt; 는 참조 당 결과를 반환하고 &lt;code&gt;operator+&lt;/code&gt; 는 결과의 복사본을 반환합니다. 물론 참조를 반환하는 것이 일반적으로 복사본을 반환하는 것보다 더 효율적이지만 &lt;code&gt;operator+&lt;/code&gt; 의 경우 복사 주위에 방법이 없습니다. &lt;code&gt;a + b&lt;/code&gt; 를 쓰면 결과가 새로운 값이 될 것으로 예상되므로 &lt;code&gt;operator+&lt;/code&gt; 는 새로운 값을 반환해야합니다. &lt;sup&gt;3&lt;/sup&gt; &lt;code&gt;operator+&lt;/code&gt; 는 const 참조가 아니라 &lt;strong&gt;&lt;em&gt;복사로&lt;/em&gt;&lt;/strong&gt; 왼쪽 피연산자 &lt;strong&gt;&lt;em&gt;를&lt;/em&gt;&lt;/strong&gt; 가져옵니다. 그 이유는 &lt;code&gt;operator=&lt;/code&gt; 연산자 가 인수 당 인수를 취하는 이유와 같습니다.</target>
        </trans-unit>
        <trans-unit id="338efc32f9cb83e0dd8331e45788ecc57787ef85" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Operators are related to each other&lt;/em&gt; and to other operations. If your type supports &lt;code&gt;a + b&lt;/code&gt;, users will expect to be able to call &lt;code&gt;a += b&lt;/code&gt;, too. If it supports prefix increment &lt;code&gt;++a&lt;/code&gt;, they will expect &lt;code&gt;a++&lt;/code&gt; to work as well. If they can check whether &lt;code&gt;a &amp;lt; b&lt;/code&gt;, they will most certainly expect to also to be able to check whether &lt;code&gt;a &amp;gt; b&lt;/code&gt;. If they can copy-construct your type, they expect assignment to work as well.</source>
          <target state="translated">&lt;em&gt;운영자는 서로&lt;/em&gt; 및 다른 작업과 &lt;em&gt;관련이&lt;/em&gt; 있습니다. 유형이 &lt;code&gt;a + b&lt;/code&gt; 지원 하는 경우 사용자는 &lt;code&gt;a += b&lt;/code&gt; 도 호출 할 수있을 것으로 기대합니다. 접두사 증가 &lt;code&gt;++a&lt;/code&gt; 를 지원하면 &lt;code&gt;a++&lt;/code&gt; 도 작동 할 것으로 예상 합니다 . 그들이 &lt;code&gt;a &amp;lt; b&lt;/code&gt; 인지 여부를 확인할 수 있다면, &lt;code&gt;a &amp;gt; b&lt;/code&gt; 인지 여부도 확인할 수있을 것입니다. 그들이 당신의 유형을 복사 구성 할 수 있다면, 그들은 또한 과제가 잘 작동 할 것으로 기대합니다.</target>
        </trans-unit>
        <trans-unit id="aa5bd5f45a48b221e418619d95cdcc6b6c6e44a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Always provide all out of a set of related operations.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;항상 관련 작업 세트를 모두 제공하십시오.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9489b9f4b1bac05ddb2354a51560ad5b088a8f70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Always stick to the operator&amp;rsquo;s well-known semantics.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;항상 운영자의 잘 알려진 의미를 고수하십시오.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09e12a464818e248f8bb9ed843a88d4b181a6616" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Whenever the meaning of an operator is not obviously clear and undisputed, it should not be overloaded.&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;Instead, provide a function with a well-chosen name.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;운영자의 의미가 명백하고 명확하지 않을 때마다 과부하되지 않아야합니다.&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;대신, 잘 선택된 이름의 함수를 제공하십시오.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="620ae72342c6c376f4c4a1a08f78905e1878296d" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;em&gt;(Note: This is meant to be an entry to &lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;Stack Overflow's C++ FAQ&lt;/a&gt;. If you want to critique the idea of providing an FAQ in this form, then &lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;the posting on meta that started all this&lt;/a&gt; would be the place to do that. Answers to that question are monitored in the &lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;C++ chatroom&lt;/a&gt;, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)&lt;/em&gt;
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;(참고 : 이것은 &lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;Stack Overflow의 C ++ FAQ에&lt;/a&gt; 대한 항목입니다.이 양식으로 FAQ를 제공한다는 아이디어를 비판하려면이 &lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;모든 것을 시작한 메타에 게시&lt;/a&gt; 하면됩니다. 이 질문은 &lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;C ++ 대화방&lt;/a&gt; 에서 모니터링되며 여기서 FAQ 아이디어는 처음부터 시작되었으므로 아이디어를 얻은 사람들이 귀하의 답변을 읽을 가능성이 큽니다.)&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="14f3efc38fad533ae15f4148f1a61fdd2dd11ee7" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Note the &lt;code&gt;const&lt;/code&gt; at the end.)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;(끝의 &lt;code&gt;const&lt;/code&gt; 에 유의하십시오.)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="c0ca582ae5768203060cbf81ae5d446fdbadce13" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;As with all rules of thumb, sometimes there might be reasons to break this one, too. If so, do not forget that the left-hand operand of the binary comparison operators, which for member functions will be &lt;code&gt;*this&lt;/code&gt;, needs to be &lt;code&gt;const&lt;/code&gt;, too. So a comparison operator implemented as a member function would have to have this signature:&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; &lt;sub&gt;모든 경험 법칙과 마찬가지로 때때로이 규칙을 어기는 이유가있을 수 있습니다.&lt;/sub&gt; &lt;sub&gt;그렇다면 멤버 함수의 &lt;code&gt;*this&lt;/code&gt; 인 이진 비교 연산자의 왼쪽 피연산자도 &lt;code&gt;const&lt;/code&gt; 이어야한다는 것을 잊지 마십시오.&lt;/sub&gt; &lt;sub&gt;따라서 멤버 함수로 구현 된 비교 연산자에는 다음과 같은 서명이 있어야합니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9a7c0de90272aa0b4c0f2ec37dbe7d8ba11b179a" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;The term &amp;ldquo;user-defined&amp;rdquo; might be slightly misleading. C++ makes the distinction between built-in types and user-defined types. To the former belong for example int, char, and double; to the latter belong all struct, class, union, and enum types, including those from the standard library, even though they are not, as such, defined by users.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; &lt;sub&gt;&quot;사용자 정의&quot;라는 용어는 약간 잘못 될 수 있습니다.&lt;/sub&gt; &lt;sub&gt;C ++은 내장 타입과 사용자 정의 타입을 구별합니다.&lt;/sub&gt; &lt;sub&gt;전자는 예를 들어 int, char 및 double에 속합니다.&lt;/sub&gt; &lt;sub&gt;후자는 표준 라이브러리의 타입을 포함하여 모든 구조체, 클래스, 공용체 및 열거 형에 속하지만 사용자가 정의하지는 않습니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="4d522b0d5a3ee143d4b55a7eefa9657f18b4f0ea" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;Also note that the postfix variant does more work and is therefore less efficient to use than the prefix variant. This is a good reason to generally prefer prefix increment over postfix increment. While compilers can usually optimize away the additional work of postfix increment for built-in types, they might not be able to do the same for user-defined types (which could be something as innocently looking as a list iterator). Once you got used to do &lt;code&gt;i++&lt;/code&gt;, it becomes very hard to remember to do &lt;code&gt;++i&lt;/code&gt; instead when &lt;code&gt;i&lt;/code&gt; is not of a built-in type (plus you'd have to change code when changing a type), so it is better to make a habit of always using prefix increment, unless postfix is explicitly needed.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;접미사 변형이 더 많은 작업을 수행하므로 접두사 변형보다 사용 효율이 떨어집니다.&lt;/sub&gt; &lt;sub&gt;이것이 일반적으로 접두사 증가보다 접두사 증가를 선호하는 좋은 이유입니다.&lt;/sub&gt; &lt;sub&gt;컴파일러는 일반적으로 내장 유형에 대한 추가 접미사 증가 작업을 최적화 할 수 있지만 사용자 정의 유형 (목록 반복자처럼 순진하게 보일 수 있음)에 대해서도 동일한 작업을 수행하지 못할 수 있습니다.&lt;/sub&gt; &lt;sub&gt; &lt;code&gt;i++&lt;/code&gt; 사용하는 데 익숙해지면 내장 유형이 아닌 경우 ( &lt;code&gt;++i&lt;/code&gt; 유형을 변경할 때 코드를 변경해야 함) 대신 ++ i 를 수행하는 것을 기억하기가 매우 어려워 지므로 더 좋습니다. postfix가 명시 적으로 필요하지 않으면 접두사 증가를 항상 사용하는 습관을들이십시오.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="3f5b8f85cc67312e85c8eb294398952de5c9070e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;It should be noted that the built-in version of &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; use shortcut semantics. While the user defined ones (because they are syntactic sugar for method calls) do not use shortcut semantics. User will expect these operators to have shortcut semantics, and their code may depend on it, Therefore it is highly advised NEVER to define them.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;내장 버전의 &lt;code&gt;||&lt;/code&gt; &lt;/sub&gt; &lt;sub&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 단축키 사용을 사용합니다.&lt;/sub&gt; &lt;sub&gt;사용자가 정의한 것 (메소드 호출의 구문 설탕이기 때문에)은 바로 가기 시맨틱을 사용하지 않습니다.&lt;/sub&gt; &lt;sub&gt;사용자는 이러한 연산자에 바로 가기 의미가있을 것으로 예상되며 코드에 따라 달라질 수 있으므로 절대로 정의하지 않는 것이 좋습니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e3c92f172f9d6a21e1edbee610bd748896095eab" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;This is covered in &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/4421729#4421729&quot;&gt;a later part&lt;/a&gt; of this FAQ.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;이 내용은이 FAQ &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/4421729#4421729&quot;&gt;의 뒷부분&lt;/a&gt; 에서 다룹니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2d81bca5cf7dc6ada15492470100c9698c01c407" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3&lt;/sup&gt;&lt;sub&gt;Again, the lesson to be taken from this is that &lt;code&gt;a += b&lt;/code&gt; is, in general, more efficient than &lt;code&gt;a + b&lt;/code&gt; and should be preferred if possible.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;다시 한번, 이것으로부터 얻은 교훈은 &lt;code&gt;a += b&lt;/code&gt; 가 일반적으로 &lt;code&gt;a + b&lt;/code&gt; 보다 효율적이며 가능하다면 선호되어야한다는 것입니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5cca32e7a575b9db399f83cf13cfe08fee093572" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3&lt;/sup&gt;&lt;sub&gt;The &lt;code&gt;@&lt;/code&gt; is not a valid operator in C++ which is why I use it as a placeholder.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;3&lt;/sup&gt; &lt;sub&gt; &lt;code&gt;@&lt;/code&gt; 는 C ++에서 유효한 연산자가 아니기 때문에 자리 표시 자로 사용합니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="fb4e0ac4049821674fc6813ec9ef8cfd305f5ca1" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;4&lt;/sup&gt;&lt;sub&gt;The only ternary operator in C++ cannot be overloaded and the only n-ary operator must always be implemented as a member function.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;4&lt;/sup&gt; &lt;sub&gt;C ++의 유일한 삼항 연산자는 오버로드 될 수 없으며 유일한 n- 항 연산자는 항상 멤버 함수로 구현되어야합니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="276a8f6944c21a071705fa227dcf9ba993594a29" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;strong&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/strong&gt; This only deals with the &lt;strong&gt;&lt;em&gt;syntax&lt;/em&gt;&lt;/strong&gt; of overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, not with the &lt;strong&gt;&lt;em&gt;implementation&lt;/em&gt;&lt;/strong&gt; of such overloaded operators. I think that the semantics of overloading &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7149461/&quot;&gt;&lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; deserve their own FAQ&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;, within the topic of operator overloading I can never do it justice.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;strong&gt;&lt;em&gt;참고 :&lt;/em&gt;&lt;/strong&gt; 이것은 과부하 된 연산자의 &lt;strong&gt;&lt;em&gt;구현&lt;/em&gt;&lt;/strong&gt; 이 아니라 &lt;code&gt;new&lt;/code&gt; 및 &lt;code&gt;delete&lt;/code&gt; 오버로드 &lt;strong&gt;&lt;em&gt;구문&lt;/em&gt;&lt;/strong&gt; 만 처리 &lt;strong&gt;&lt;em&gt;합니다&lt;/em&gt;&lt;/strong&gt; .&lt;/sup&gt; &lt;sup&gt;나는 &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7149461/&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; 과부하 &lt;strong&gt;&lt;em&gt;및 &lt;code&gt;delete&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt; 의 의미가 운영자 과부하의 주제 내에서 &lt;strong&gt;&lt;em&gt;자체 FAQ를받을 가치가&lt;/em&gt;&lt;/strong&gt; 있다고 생각합니다. 나는 결코 그것을 정의 할 수 없습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="421a43341da00165d391cdef2aecb500589bd6e0" translate="yes" xml:space="preserve">
          <source>According to our rules of thumb, &lt;code&gt;+&lt;/code&gt; and its companions should be non-members, while their compound assignment counterparts (&lt;code&gt;+=&lt;/code&gt; etc.), changing their left argument, should be a member. Here is the exemplary code for &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt;; the other binary arithmetic operators should be implemented in the same way:</source>
          <target state="translated">경험 법칙에 따르면 &lt;code&gt;+&lt;/code&gt; 와 그 동반자는 비회원이어야하며, 왼쪽 인수를 변경하는 복합 할당 상대 ( &lt;code&gt;+=&lt;/code&gt; 등)는 회원이어야합니다. 다음은 &lt;code&gt;+=&lt;/code&gt; 및 &lt;code&gt;+&lt;/code&gt; 의 예제 코드입니다. 다른 이진 산술 연산자는 같은 방식으로 구현되어야합니다.</target>
        </trans-unit>
        <trans-unit id="f3952c5c15a5c4f059ce1db8233deaaeda4f28a8" translate="yes" xml:space="preserve">
          <source>Among the operators that can be overloaded in C++ are these:</source>
          <target state="translated">C ++에서 오버로드 될 수있는 연산자는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="be759ec493e1844e284eba0ba8febc88ff79e21f" translate="yes" xml:space="preserve">
          <source>An implicit conversion operator allows the compiler to implicitly convert (like the conversion between &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;) the value of a user-defined type to some other type.</source>
          <target state="translated">암시 적 변환 연산자를 사용하면 컴파일러에서 사용자 정의 형식의 값을 다른 형식으로 암시 적으로 변환 할 수 있습니다 ( &lt;code&gt;int&lt;/code&gt; 와 &lt;code&gt;long&lt;/code&gt; 간의 변환과 같은).</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">산술 연산자</target>
        </trans-unit>
        <trans-unit id="aecc43fc2fe547cd50965b231d35b4682af12f07" translate="yes" xml:space="preserve">
          <source>Array Subscripting</source>
          <target state="translated">배열 첨자</target>
        </trans-unit>
        <trans-unit id="67c1b1f3ed026dea13ed68968e94e0a7d893d152" translate="yes" xml:space="preserve">
          <source>Assignment Operator</source>
          <target state="translated">할당 연산자</target>
        </trans-unit>
        <trans-unit id="93070e8acd1b2a07488cdde5f031a65133a6cf12" translate="yes" xml:space="preserve">
          <source>At first this seems very helpful, but the problem with this is that the implicit conversion even kicks in when it isn&amp;rsquo;t expected to. In the following code, &lt;code&gt;void f(const char*)&lt;/code&gt; will be called because &lt;code&gt;my_string()&lt;/code&gt; is not an &lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;lvalue&lt;/a&gt;, so the first does not match:</source>
          <target state="translated">처음에는 이것이 매우 도움이되는 것처럼 보이지만, 이것의 문제점은 암시 적 변환이 예상되지 않은 경우에도 시작된다는 것입니다. 다음 코드에서는 &lt;code&gt;my_string()&lt;/code&gt; 이 &lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;lvalue&lt;/a&gt; 가 아니기 때문에 &lt;code&gt;void f(const char*)&lt;/code&gt; 가 호출되므로 첫 번째가 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0ee8de3eebacd7c638e4729172a904422deca61b" translate="yes" xml:space="preserve">
          <source>Basically, the first and foremost rule for overloading operators, at its very heart, says: &lt;em&gt;Don&amp;rsquo;t do it&lt;/em&gt;. That might seem strange, because there is a lot to be known about operator overloading and so a lot of articles, book chapters, and other texts deal with all this. But despite this seemingly obvious evidence, &lt;em&gt;there are only a surprisingly few cases where operator overloading is appropriate&lt;/em&gt;. The reason is that actually it is hard to understand the semantics behind the application of an operator unless the use of the operator in the application domain is well known and undisputed. Contrary to popular belief, this is hardly ever the case.</source>
          <target state="translated">기본적으로 과부하 연산자의 가장 중요한 규칙은 다음과 같이 말합니다. &lt;em&gt;하지 마십시오&lt;/em&gt; . 연산자 오버로드에 대해 알려진 것이 많고 많은 기사, 서적 장 및 기타 텍스트가이 모든 것을 다루기 때문에 이상하게 보일 수 있습니다. 그러나이 명백한 증거에도 불구하고 &lt;em&gt;운영자 과부하가 적절한 경우는 놀랍게도 거의 없습니다&lt;/em&gt; . 그 이유는 애플리케이션 도메인에서 운영자의 사용이 잘 알려져 있고 논쟁의 여지가 없다면 운영자의 애플리케이션 뒤에 의미를 이해하기 어렵 기 때문입니다. 대중의 신념과는 달리 이것은 거의 사실이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4d0acd385943a19aff1dd079c0d333f73eeda130" translate="yes" xml:space="preserve">
          <source>Because the compiler will not cast &quot;past&quot; &lt;code&gt;bool&lt;/code&gt;, explicit conversion operators now remove the need for the &lt;a href=&quot;http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool&quot;&gt;Safe Bool idiom&lt;/a&gt;.   For example, smart pointers before C++11 used the Safe Bool idiom to prevent conversions to integral types.  In C++11, the smart pointers use an explicit operator instead because the compiler is not allowed to implicitly convert to an integral type after it explicitly converted a type to bool.</source>
          <target state="translated">컴파일러는 &quot;과거&quot; &lt;code&gt;bool&lt;/code&gt; 을 캐스팅하지 않기 때문에 이제 명시 적 변환 연산자는 &lt;a href=&quot;http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool&quot;&gt;Safe Bool 관용구&lt;/a&gt; 가 필요하지 않습니다. 예를 들어 C ++ 11 이전의 스마트 포인터는 Safe Bool 관용구를 사용하여 정수 유형으로 변환하지 못했습니다. C ++ 11에서 스마트 포인터는 대신 명시 적 연산자를 사용합니다. 컴파일러가 명시 적으로 형식을 bool로 변환 한 후 컴파일러가 암시 적으로 정수 형식으로 변환 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="71c42caac2d9ddf4204de8698243a11cfa04f910" translate="yes" xml:space="preserve">
          <source>Beginners easily get this wrong and even experienced C++ programmers are sometimes surprised because the compiler picks an overload they didn&amp;rsquo;t suspect.  These problems can be mitigated by explicit conversion operators.</source>
          <target state="translated">초보자도 쉽게이 문제를 경험할 수 있으며 심지어 숙련 된 C ++ 프로그래머도 컴파일러가 의심하지 않는 과부하를 선택하기 때문에 놀라게됩니다. 이러한 문제는 명시 적 변환 연산자로 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91150bd6516ac5f77628d936130ba9cf5ec13ae6" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operators</source>
          <target state="translated">이진 산술 연산자</target>
        </trans-unit>
        <trans-unit id="ae37c4e20a55a6ef0b50c1ce0e0f71802dbf0111" translate="yes" xml:space="preserve">
          <source>Bitshift Operators (used for Stream I/O)</source>
          <target state="translated">비트 시프트 연산자 (스트림 I / O에 사용)</target>
        </trans-unit>
        <trans-unit id="db69b09b584ceff2f01a827a244f4ddf0bcc8bfa" translate="yes" xml:space="preserve">
          <source>C++ allows new and delete operators to take additional arguments.</source>
          <target state="translated">C ++를 사용하면 new 및 delete 연산자가 추가 인수를 취할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cea3dbd2ef365f97b36a9803e63877ab2a2dcd07" translate="yes" xml:space="preserve">
          <source>C++ allows you to tune both of these operations: memory management and the construction/destruction of the object at the allocated memory. The latter is done by writing constructors and destructors for a class. Fine-tuning memory management is done by writing your own &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt;.</source>
          <target state="translated">C ++를 사용하면 메모리 관리 및 할당 된 메모리에서 객체의 구성 / 파괴와 같은 두 가지 작업을 모두 조정할 수 있습니다. 후자는 클래스의 생성자와 소멸자를 작성하여 수행됩니다. 미세 조정 메모리 관리는 사용자 고유의 &lt;code&gt;operator new&lt;/code&gt; 및 &lt;code&gt;operator delete&lt;/code&gt; 를 작성하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="53e1ae4928af9f305e18ff9d9d702bea83c43afc" translate="yes" xml:space="preserve">
          <source>C++ poses no limitations on the semantics of overloaded operators. Your compiler will happily accept code that implements the binary &lt;code&gt;+&lt;/code&gt; operator to subtract from its right operand. However, the users of such an operator would never suspect the expression &lt;code&gt;a + b&lt;/code&gt; to subtract &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;b&lt;/code&gt;. Of course, this supposes that the semantics of the operator in the application domain is undisputed.</source>
          <target state="translated">C ++는 오버로드 된 연산자의 의미에 제한이 없습니다. 컴파일러는 바이너리 &lt;code&gt;+&lt;/code&gt; 연산자를 구현하여 올바른 피연산자를 빼는 코드를 기꺼이 받아들입니다. 그러나 이러한 연산자를 사용하는 사용자는 &lt;code&gt;a + b&lt;/code&gt; 식을 의심하여 a 를 b 에서 빼지 않습니다. 물론 이것은 응용 프로그램 도메인에서 연산자의 의미론이 논란의 여지가 없다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="7c17731e50f62eea89cf01a119386ba15a466c77" translate="yes" xml:space="preserve">
          <source>Class-specific new and delete</source>
          <target state="translated">클래스 별 신규 및 삭제</target>
        </trans-unit>
        <trans-unit id="7266bf079b182acba7043970de462e41b2663d92" translate="yes" xml:space="preserve">
          <source>Common operators to overload</source>
          <target state="translated">과부하를 일으키는 일반적인 연산자</target>
        </trans-unit>
        <trans-unit id="9461d4c9f916ad7df5538225ed552fb6e7e3284b" translate="yes" xml:space="preserve">
          <source>Comparison operators</source>
          <target state="translated">비교 연산자</target>
        </trans-unit>
        <trans-unit id="d8ddbec0b26e694dbe2e4392c23c80e62413f2d4" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708&quot;&gt;The Three Basic Rules of Operator Overloading in C++&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708&quot;&gt;C ++에서 연산자 오버로드의 3 가지 기본 규칙을&lt;/a&gt; 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="9a650afcae173aef7cbc03df980e79ab8dcfc031" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719#4421719&quot;&gt;Common operators to overload&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719#4421719&quot;&gt;오버로드&lt;/a&gt; 하려면 일반 연산자를 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="49e07535d312dbe3a4fc30e2d414ba6a141b3abe" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729&quot;&gt;The Decision between Member and Non-member&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729&quot;&gt;멤버와 비 멤버 사이의 결정으로&lt;/a&gt; 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="390e8f97087fe4c33287f0dec7d962032d84d2b0" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791#4421791&quot;&gt;Overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">계속 &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791#4421791&quot;&gt; &lt;code&gt;new&lt;/code&gt; &lt;/a&gt; 을 로드하고 &lt;code&gt;delete&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="0c4829881d2b9099fb960d607315a36454fc1c0d" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725&quot;&gt;Conversion Operators&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725&quot;&gt;전환 연산자&lt;/a&gt; 계속</target>
        </trans-unit>
        <trans-unit id="cce1bda201abe07a87309c10681fbc4836893a50" translate="yes" xml:space="preserve">
          <source>Conversion Operators</source>
          <target state="translated">변환 연산자</target>
        </trans-unit>
        <trans-unit id="97921336d267bc620b6817f8d0fbd3946c8e1724" translate="yes" xml:space="preserve">
          <source>Conversion Operators (also known as User Defined Conversions)</source>
          <target state="translated">전환 연산자 (사용자 정의 전환이라고도 함)</target>
        </trans-unit>
        <trans-unit id="06916bcd529378cd7be8d494e6a076cdff280dfb" translate="yes" xml:space="preserve">
          <source>Explicit Conversion Operators (C++11)</source>
          <target state="translated">명시 적 변환 연산자 (C ++ 11)</target>
        </trans-unit>
        <trans-unit id="bb0bf432160bebf9e28e99e45037098df491690e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;operator-&amp;gt;*()&lt;/code&gt; see &lt;a href=&quot;https://stackoverflow.com/q/8777845/140719&quot;&gt;this question&lt;/a&gt;. It's rarely used and thus rarely ever overloaded. In fact, even iterators do not overload it.</source>
          <target state="translated">&lt;code&gt;operator-&amp;gt;*()&lt;/code&gt; &lt;a href=&quot;https://stackoverflow.com/q/8777845/140719&quot;&gt;이 질문을&lt;/a&gt; 참조하십시오. 거의 사용되지 않으므로 과부하가 걸리지 않습니다. 실제로 반복자조차도 과부하되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6ea334ff6ce5f1423f350e93f69641ce7406130" translate="yes" xml:space="preserve">
          <source>For all operators where you have to choose to either implement them as a member function or a non-member function, &lt;strong&gt;&lt;em&gt;use the following rules of thumb&lt;/em&gt;&lt;/strong&gt; to decide:</source>
          <target state="translated">멤버 함수 또는 비 멤버 함수로 구현하도록 선택해야하는 모든 연산자에 &lt;strong&gt;&lt;em&gt;대해 다음 경험 규칙을 사용하여&lt;/em&gt;&lt;/strong&gt; 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="d69d65276d05cacbd13652fa039509c5c7448719" translate="yes" xml:space="preserve">
          <source>For defining your own iterators or smart pointers, you have to overload the unary prefix dereference operator &lt;code&gt;*&lt;/code&gt; and the binary infix pointer member access operator &lt;code&gt;-&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">자체 반복자 또는 스마트 포인터를 정의하려면 단항 접두사 역 참조 연산자 &lt;code&gt;*&lt;/code&gt; 및 이진 접두사 포인터 멤버 액세스 연산자 &lt;code&gt;-&amp;gt;&lt;/code&gt; 를 오버로드해야합니다.</target>
        </trans-unit>
        <trans-unit id="1587e1394f773c588778fbe18bdd8ed62ff6821b" translate="yes" xml:space="preserve">
          <source>For the binary arithmetic operators, do not forget to obey the third basic rule operator overloading: If you provide &lt;code&gt;+&lt;/code&gt;, also provide &lt;code&gt;+=&lt;/code&gt;, if you provide &lt;code&gt;-&lt;/code&gt;, do not omit &lt;code&gt;-=&lt;/code&gt;, etc. Andrew Koenig is said to have been the first to observe that the compound assignment operators can be used as a base for their non-compound counterparts. That is, operator &lt;code&gt;+&lt;/code&gt; is implemented in terms of &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; is implemented in terms of &lt;code&gt;-=&lt;/code&gt; etc.</source>
          <target state="translated">이진 산술 연산자의 경우 세 번째 기본 규칙 연산자 오버로드를 준수하는 것을 잊지 마십시오. &lt;code&gt;+&lt;/code&gt; 를 제공하는 경우 &lt;code&gt;+=&lt;/code&gt; 를 제공하고 &lt;code&gt;-&lt;/code&gt; 를 제공하면 &lt;code&gt;-=&lt;/code&gt; 등을 생략하지 마십시오. Andrew Koenig는 처음으로 알려져 있습니다 화합물 할당 연산자를 비화합물 대응의 기반으로 사용할 수 있습니다. 즉, 연산자 &lt;code&gt;+&lt;/code&gt; 는 &lt;code&gt;+=&lt;/code&gt; 의 관점에서 구현되고, &lt;code&gt;-&lt;/code&gt; 는 &lt;code&gt;-=&lt;/code&gt; 등의 관점에서 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="25056cd4f19ab3cf2ddbe426ca4f88659c9ecb1f" translate="yes" xml:space="preserve">
          <source>Function call operator</source>
          <target state="translated">함수 호출 연산자</target>
        </trans-unit>
        <trans-unit id="266781763563b15feb1a51bb6a9014424ae1126a" translate="yes" xml:space="preserve">
          <source>Given that, you cannot use:</source>
          <target state="translated">주어진 경우 다음을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="90be49000bdd6cb11fcaf3b36883081fc56eaccc" translate="yes" xml:space="preserve">
          <source>Global new and delete</source>
          <target state="translated">글로벌 신규 및 삭제</target>
        </trans-unit>
        <trans-unit id="40ccf2f37dd214c6d5991f8f2094c0e81dc4e65d" translate="yes" xml:space="preserve">
          <source>Here's an example of the syntax:</source>
          <target state="translated">구문의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f19bc6ee55c37f3c7803fde5dc79430596476a8" translate="yes" xml:space="preserve">
          <source>However, the fact that you &lt;em&gt;can&lt;/em&gt; overload all of these does not mean you &lt;em&gt;should&lt;/em&gt; do so. See the basic rules of operator overloading.</source>
          <target state="translated">그러나 이러한 모든 항목을 오버로드 할 &lt;em&gt;수&lt;/em&gt; 있다고해서 그렇게 &lt;em&gt;해야하는&lt;/em&gt; 것은 아닙니다. 운영자 과부하의 기본 규칙을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d1df6c2555df05f2e2d7b30909ceaba1a04419ac" translate="yes" xml:space="preserve">
          <source>However, there is one exception to this:  The compiler is allowed to implicitly convert to &lt;code&gt;bool&lt;/code&gt;.  In addition, the compiler is not allowed to do another implicit conversion after it converts to &lt;code&gt;bool&lt;/code&gt; (a compiler is allowed to do 2 implicit conversions at a time, but only 1 user-defined conversion at max).</source>
          <target state="translated">그러나 이에 대한 한 가지 예외가 있습니다. 컴파일러는 암시 적으로 &lt;code&gt;bool&lt;/code&gt; 로 변환 할 수 있습니다. 또한 컴파일러는 &lt;code&gt;bool&lt;/code&gt; 로 변환 한 후 다른 암시 적 변환을 수행 할 수 없습니다 (컴파일러는 한 번에 2 개의 암시 적 변환을 수행 할 수 있지만 최대 1 개의 사용자 정의 변환 만 수행 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="52ab79f2235a5be84cd7d66fe9e8c1206c27da29" translate="yes" xml:space="preserve">
          <source>If a binary operator does &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; treat both of its operands &lt;strong&gt;&lt;em&gt;equally&lt;/em&gt;&lt;/strong&gt; (usually it will change its left operand), it might be useful to make it a &lt;strong&gt;&lt;em&gt;member&lt;/em&gt;&lt;/strong&gt; function of its left operand&amp;rsquo;s type, if it has to access the operand's private parts.</source>
          <target state="translated">이항 연산자가 두 피연산자 모두를 &lt;strong&gt;&lt;em&gt;동일하게&lt;/em&gt;&lt;/strong&gt; 취급하지 &lt;strong&gt;&lt;em&gt;않으면&lt;/em&gt;&lt;/strong&gt; (보통 왼쪽 피연산자가 변경됨) 피연산자의 개인 부분에 액세스해야하는 경우 왼쪽 피연산자 유형의 &lt;strong&gt;&lt;em&gt;멤버&lt;/em&gt;&lt;/strong&gt; 함수로 만드는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dbf7e58fa487fdde1f10120a1e361214ac8d248" translate="yes" xml:space="preserve">
          <source>If a binary operator treats &lt;strong&gt;&lt;em&gt;both operands equally&lt;/em&gt;&lt;/strong&gt; (it leaves them unchanged), implement this operator as a &lt;strong&gt;&lt;em&gt;non-member&lt;/em&gt;&lt;/strong&gt; function.</source>
          <target state="translated">이항 연산자가 &lt;strong&gt;&lt;em&gt;두 피연산자를 모두 동일하게&lt;/em&gt;&lt;/strong&gt; 취급하는 경우 (이를 변경하지 않은 채로 두는 경우)이 연산자를 &lt;strong&gt;&lt;em&gt;멤버&lt;/em&gt;&lt;/strong&gt; 가 &lt;strong&gt;&lt;em&gt;아닌&lt;/em&gt;&lt;/strong&gt; 함수로 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="ed6a13f07242d7d741efc0c6314f4777012e50e3" translate="yes" xml:space="preserve">
          <source>If it is a &lt;strong&gt;&lt;em&gt;unary operator&lt;/em&gt;&lt;/strong&gt;, implement it as a &lt;strong&gt;&lt;em&gt;member&lt;/em&gt;&lt;/strong&gt; function.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;단항 연산자&lt;/em&gt;&lt;/strong&gt; 인 경우이를 &lt;strong&gt;&lt;em&gt;멤버&lt;/em&gt;&lt;/strong&gt; 함수로 구현하십시오.</target>
        </trans-unit>
        <trans-unit id="262c7f3eacf6b4b4a482e67f29ed9ce4d067684f" translate="yes" xml:space="preserve">
          <source>If value_type is known to refer to a built-in type, the const variant of the operator should better return a copy instead of a const reference:</source>
          <target state="translated">value_type이 내장 유형을 참조하는 것으로 알려진 경우 연산자의 const 변형은 const 참조 대신 복사본을 반환하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f4c82304b319df56b3a1e32bbe46b626dd2db4cf" translate="yes" xml:space="preserve">
          <source>If you define it as a non-member function,</source>
          <target state="translated">비 멤버 함수로 정의하면</target>
        </trans-unit>
        <trans-unit id="c3222f784f51643651a73e25ba26b59a34a1a97e" translate="yes" xml:space="preserve">
          <source>If you overload &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, you should consider overloading the array variants, too.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 및 &lt;code&gt;delete&lt;/code&gt; 를 오버로드하면 배열 변형도 오버로드하는 것을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="f13af45755f6d4b1682363cc396a98d01a7f9a22" translate="yes" xml:space="preserve">
          <source>If you overload &lt;code&gt;operator new&lt;/code&gt;, you should always also overload the matching &lt;code&gt;operator delete&lt;/code&gt;, even if you never intend to call it. The reason is that, if a constructor throws during the evaluation of a new expression, the run-time system will return the memory to the &lt;code&gt;operator delete&lt;/code&gt; matching the &lt;code&gt;operator new&lt;/code&gt; that was called to allocate the memory to create the object in. If you do not provide a matching &lt;code&gt;operator delete&lt;/code&gt;, the default one is called, which is almost always wrong.</source>
          <target state="translated">&lt;code&gt;operator new&lt;/code&gt; 를 오버로드하는 경우 호출하지 않으려는 경우에도 항상 일치하는 &lt;code&gt;operator delete&lt;/code&gt; 오버로드해야합니다. 그 이유는 새 표현식을 평가하는 동안 생성자가 throw되면 런타임 시스템이 메모리를 &lt;code&gt;operator delete&lt;/code&gt; 에게 반환하여 객체를 만들기 위해 메모리를 할당하기 위해 호출 된 &lt;code&gt;operator new&lt;/code&gt; 일치하는 것을 삭제 하기 때문입니다. 일치하는 &lt;code&gt;operator delete&lt;/code&gt; 제공하지 않으면 기본 연산자 가 호출되며 거의 항상 잘못됩니다.</target>
        </trans-unit>
        <trans-unit id="826dbaa31e10b50624ed6f5bcb81e5a26a59de5f" translate="yes" xml:space="preserve">
          <source>Implicit Conversion Operators (C++98/C++03 and C++11)</source>
          <target state="translated">암시 적 변환 연산자 (C ++ 98 / C ++ 03 및 C ++ 11)</target>
        </trans-unit>
        <trans-unit id="64b3307a85f7de1505aa3f37db4699689e2030a6" translate="yes" xml:space="preserve">
          <source>Implicit conversion operators, like one-argument constructors, are user-defined conversions. Compilers will grant one user-defined conversion when trying to match a call to an overloaded function.</source>
          <target state="translated">하나의 인수 생성자와 같은 암시 적 변환 연산자는 사용자 정의 변환입니다. 컴파일러는 오버로드 된 함수에 대한 호출을 일치 시키려고 할 때 하나의 사용자 정의 변환을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="40caa674c8cd189d440009873823c8ee2f813b8c" translate="yes" xml:space="preserve">
          <source>In C++ you can create conversion operators, operators that allow the compiler to convert between your types and other defined types.  There are two types of conversion operators, implicit and explicit ones.</source>
          <target state="translated">C ++에서는 컴파일러가 형식과 다른 정의 된 형식 사이에서 변환 할 수 있도록하는 연산자 인 변환 연산자를 만들 수 있습니다. 암시 적 연산자와 명시 적 연산자의 두 가지 유형의 변환 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="49ef7e77ad3309f43ce0a0c931ad5b00264bdae6" translate="yes" xml:space="preserve">
          <source>In C++, operators are overloaded in the form of &lt;strong&gt;&lt;em&gt;functions with special names&lt;/em&gt;&lt;/strong&gt;. As with other functions, overloaded operators can generally be implemented either as a &lt;strong&gt;&lt;em&gt;member function of their left operand's type&lt;/em&gt;&lt;/strong&gt; or as &lt;strong&gt;&lt;em&gt;non-member functions&lt;/em&gt;&lt;/strong&gt;. Whether you are free to choose or bound to use either one depends on several criteria.&lt;sup&gt;2&lt;/sup&gt; A unary operator &lt;code&gt;@&lt;/code&gt;&lt;sup&gt;3&lt;/sup&gt;, applied to an object x, is invoked either as &lt;code&gt;operator@(x)&lt;/code&gt; or as &lt;code&gt;x.operator@()&lt;/code&gt;. A binary infix operator &lt;code&gt;@&lt;/code&gt;, applied to the objects &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, is called either as &lt;code&gt;operator@(x,y)&lt;/code&gt; or as &lt;code&gt;x.operator@(y)&lt;/code&gt;.&lt;sup&gt;4&lt;/sup&gt;</source>
          <target state="translated">C ++에서 연산자는 &lt;strong&gt;&lt;em&gt;특수한 이름을 가진 함수&lt;/em&gt;&lt;/strong&gt; 형태로 오버로드됩니다. 다른 함수와 마찬가지로 오버로드 된 연산자는 일반적으로 &lt;strong&gt;&lt;em&gt;왼쪽 피연산자 유형의&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;멤버 함수&lt;/em&gt;&lt;/strong&gt; 또는 &lt;strong&gt;&lt;em&gt;비&lt;/em&gt;&lt;/strong&gt; &lt;strong&gt;&lt;em&gt;멤버 함수&lt;/em&gt;&lt;/strong&gt; 로 구현 될 수 있습니다. 어느 쪽이든 자유롭게 사용할 수 있는지 여부는 몇 가지 기준에 따라 다릅니다. &lt;sup&gt;2&lt;/sup&gt; 객체 x에 적용된 단항 연산자 &lt;code&gt;@&lt;/code&gt; &lt;sup&gt;3&lt;/sup&gt; 은 &lt;code&gt;operator@(x)&lt;/code&gt; 또는 &lt;code&gt;x.operator@()&lt;/code&gt; 로 호출됩니다. 객체 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 에 적용되는 이진 &lt;code&gt;x.operator@(y)&lt;/code&gt; &lt;code&gt;operator@(x,y)&lt;/code&gt; 는 operator @ (x, y) 또는 x.operator @ (y) 로 불립니다 . &lt;sup&gt;4&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7bc8481881e8590c8face179b924af1ea4a5fe0a" translate="yes" xml:space="preserve">
          <source>In C++, when you write a &lt;strong&gt;&lt;em&gt;new expression&lt;/em&gt;&lt;/strong&gt; like &lt;code&gt;new T(arg)&lt;/code&gt; two things happen when this expression is evaluated: First &lt;strong&gt;&lt;em&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt; is invoked to obtain raw memory, and then the appropriate constructor of &lt;code&gt;T&lt;/code&gt; is invoked to turn this raw memory into a valid object. Likewise, when you delete an object, first its destructor is called, and then the memory is returned to &lt;code&gt;operator delete&lt;/code&gt;.</source>
          <target state="translated">C ++에서 &lt;code&gt;new T(arg)&lt;/code&gt; 와 같은 &lt;strong&gt;&lt;em&gt;새 표현식&lt;/em&gt;&lt;/strong&gt; 을 작성할 때이 표현식이 평가 될 때 두 가지 상황이 발생합니다. 첫 번째 &lt;strong&gt;&lt;em&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt; 는 원시 메모리를 얻기 위해 호출 된 다음 적절한 원시 생성자를 호출하여이 원시 메모리를 a로 변환합니다. 유효한 객체. 마찬가지로 객체를 삭제하면 먼저 소멸자가 호출 된 다음 메모리가 &lt;code&gt;operator delete&lt;/code&gt; 로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9d9a856b351238fc8815cf318816c5839249dbd0" translate="yes" xml:space="preserve">
          <source>Input and Output Operators</source>
          <target state="translated">입력 및 출력 연산자</target>
        </trans-unit>
        <trans-unit id="aff987919c1c656b540f21e98fcd457a77a08632" translate="yes" xml:space="preserve">
          <source>Let's say you have:</source>
          <target state="translated">가지고 있다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="1da0a13b5d45735843a1a97b7d80a3c4e94a7d15" translate="yes" xml:space="preserve">
          <source>Most commonly you will want to fine-tune memory management because measurement has shown that instances of a specific class, or of a group of related classes, are created and destroyed often and that the default memory management of the run-time system, tuned for general performance, deals inefficiently in this specific case. To improve this, you can overload new and delete for a specific class:</source>
          <target state="translated">측정 결과 특정 클래스 또는 관련 클래스 그룹의 인스턴스가 자주 생성 및 소멸되고 런타임 시스템의 기본 메모리 관리가 조정되었음을 보여 주므로 메모리 관리를 세부적으로 조정하려고합니다. 일반적인 성능은이 특정 사례에서 비효율적으로 처리됩니다. 이를 개선하기 위해 특정 클래스에 대해 새로운 과부하 및 삭제를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc4f7a69868fbbebd9b1aa75e004a5d424231ae" translate="yes" xml:space="preserve">
          <source>Most of the work in overloading operators is boiler-plate code. That is little wonder, since operators are merely syntactic sugar, their actual work could be done by (and often is forwarded to) plain functions. But it is important that you get this boiler-plate code right. If you fail, either your operator&amp;rsquo;s code won&amp;rsquo;t compile or your users&amp;rsquo; code won&amp;rsquo;t compile or your users&amp;rsquo; code will behave surprisingly.</source>
          <target state="translated">과부하 연산자의 대부분의 작업은 보일러 플레이트 코드입니다. 연산자가 단순히 구문 설탕이기 때문에 실제 작업이 일반 기능으로 수행 될 수 있으며 종종 전달됩니다. 그러나이 보일러 플레이트 코드를 올바르게 얻는 것이 중요합니다. 실패하면 운영자 코드가 컴파일되지 않거나 사용자 코드가 컴파일되지 않거나 사용자 코드가 놀랍게 동작합니다.</target>
        </trans-unit>
        <trans-unit id="308ac793bd96cffbd3257f710242d8d6baa8c5f9" translate="yes" xml:space="preserve">
          <source>Not all operators can be overloaded in C++. Among the operators that cannot be overloaded are: &lt;code&gt;.&lt;/code&gt;&lt;code&gt;::&lt;/code&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt; and the only ternary operator in C++, &lt;code&gt;?:&lt;/code&gt;</source>
          <target state="translated">모든 연산자가 C ++에서 오버로드 될 수있는 것은 아닙니다. 오버로드 할 수없는 연산자는 다음과 같습니다 &lt;code&gt;.&lt;/code&gt; &lt;code&gt;::&lt;/code&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; 및 C ++의 유일한 삼항 연산자 &lt;code&gt;?:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba5b304e147804bebb9771281e8f850c466d01fa" translate="yes" xml:space="preserve">
          <source>Note that the postfix variant is implemented in terms of prefix. Also note that postfix does an extra copy.&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">접미사 변형은 접두사 측면에서 구현됩니다. 또한 postfix는 추가 사본을 수행합니다. &lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a98223f6637a4998c4f367f083b8d38397dc9316" translate="yes" xml:space="preserve">
          <source>Note that these, too, will almost always need both a const and a non-const version.
For the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator, if &lt;code&gt;value_type&lt;/code&gt; is of &lt;code&gt;class&lt;/code&gt; (or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt;) type, another &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; is called recursively, until an &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; returns a value of non-class type.</source>
          <target state="translated">이것들도 거의 항상 const와 non-const 버전을 필요로합니다. &lt;code&gt;-&amp;gt;&lt;/code&gt; 연산자의 경우 &lt;code&gt;value_type&lt;/code&gt; 이 &lt;code&gt;class&lt;/code&gt; (또는 &lt;code&gt;struct&lt;/code&gt; 또는 &lt;code&gt;union&lt;/code&gt; ) 유형 인 경우 &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; 가 비 클래스 유형의 값을 리턴 할 때까지 다른 &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; 가 재귀 적으로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="2b329ad0d568d6f8e12b0e15d54437e0b250ccda" translate="yes" xml:space="preserve">
          <source>Note that, in the example code for placement new given above, &lt;code&gt;operator delete&lt;/code&gt; is never called, unless the constructor of X throws an exception.</source>
          <target state="translated">위에 주어진 new 배치에 대한 예제 코드에서 X 생성자가 예외를 throw하지 않는 한 &lt;code&gt;operator delete&lt;/code&gt; 는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e34f82c929e61f88c2610287d88fb521a0cf8bf6" translate="yes" xml:space="preserve">
          <source>Note: The answers were given in &lt;em&gt;a specific order&lt;/em&gt;, but since many users sort answers according to votes, rather than the time they were given, here's an &lt;strong&gt;&lt;em&gt;index of the answers&lt;/em&gt;&lt;/strong&gt; in the order in which they make most sense:</source>
          <target state="translated">참고 : 답변은 &lt;em&gt;특정 순서대로 제공&lt;/em&gt; 되었지만 많은 사용자가 답변을받은 시간이 아니라 투표에 따라 답변을 정렬하므로 가장 적합한 순서대로 &lt;strong&gt;&lt;em&gt;답변 색인을 제공합니다&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="88ae2678453b7004e74233094e1cdf9026fbf332" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;explicit&lt;/code&gt;.  Now when you try to execute the unexpected code from the implicit conversion operators, you get a compiler error:</source>
          <target state="translated">&lt;code&gt;explicit&lt;/code&gt; 주목하십시오. 이제 암시 적 변환 연산자에서 예기치 않은 코드를 실행하려고하면 컴파일러 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5ed5a83cf4720e09bb656ff2ed60cc35eca54b74" translate="yes" xml:space="preserve">
          <source>Of course, as with all rules of thumb, there are exceptions. If you have a type</source>
          <target state="translated">물론 모든 경험 규칙과 마찬가지로 예외가 있습니다. 유형이 있다면</target>
        </trans-unit>
        <trans-unit id="71635eee6d0e7a43c1616fdd99b28d55662b9781" translate="yes" xml:space="preserve">
          <source>Operators for Pointer-like Types</source>
          <target state="translated">포인터 형 타입을위한 연산자</target>
        </trans-unit>
        <trans-unit id="232c32ffd9745850f7cd1967b4a1a159748cf1ff" translate="yes" xml:space="preserve">
          <source>Operators that are implemented as non-member functions are sometimes friend of their operand&amp;rsquo;s type.</source>
          <target state="translated">비 멤버 함수로 구현 된 연산자는 때때로 피연산자 유형의 친구입니다.</target>
        </trans-unit>
        <trans-unit id="fbf47cfe86efefa771f3ac5016a6dee10f74b19c" translate="yes" xml:space="preserve">
          <source>Other operators can be implemented either as members or as non-members. Some of them, however, usually have to be implemented as non-member functions, because their left operand cannot be modified by you. The most prominent of these are the input and output operators &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, whose left operands are stream classes from the standard library which you cannot change.</source>
          <target state="translated">다른 연산자는 멤버 또는 비 멤버로 구현할 수 있습니다. 그러나 일부는 왼쪽 피연산자를 수정할 수 없으므로 일반적으로 비 멤버 함수로 구현해야합니다. 이들 중 가장 눈에 띄는 것은 입력 및 출력 연산자 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 로 , 왼쪽 피연산자는 표준 라이브러리의 스트림 클래스이며 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="61c0c26e0870099af93b41d7ed973fe4422b7163" translate="yes" xml:space="preserve">
          <source>Overloaded thus, new and delete behave like static member functions. For objects of &lt;code&gt;my_class&lt;/code&gt;, the &lt;code&gt;std::size_t&lt;/code&gt; argument will always be &lt;code&gt;sizeof(my_class)&lt;/code&gt;. However, these operators are also called for dynamically allocated objects of &lt;strong&gt;&lt;em&gt;derived classes&lt;/em&gt;&lt;/strong&gt;, in which case it might be greater than that.</source>
          <target state="translated">따라서 오버로드되면 new 및 delete는 정적 멤버 함수처럼 작동합니다. &lt;code&gt;my_class&lt;/code&gt; 의 오브젝트의 경우 &lt;code&gt;std::size_t&lt;/code&gt; 인수는 항상 &lt;code&gt;sizeof(my_class)&lt;/code&gt; 입니다. 그러나 이러한 연산자는 &lt;strong&gt;&lt;em&gt;파생 클래스&lt;/em&gt;&lt;/strong&gt; 의 동적으로 할당 된 객체에 대해서도 호출되며,이 경우 이보다 클 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="387a1adda403a18b38d6933171fc8f31a2cbd62c" translate="yes" xml:space="preserve">
          <source>Overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 과부하 및 &lt;code&gt;delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="918f907f18107b5038a28b4f7a181b670ec203fa" translate="yes" xml:space="preserve">
          <source>Overloading new and delete</source>
          <target state="translated">새로운 과부하 및 삭제</target>
        </trans-unit>
        <trans-unit id="6c74c5e2cff52e6b3146c3c1bffab6eeaab7158c" translate="yes" xml:space="preserve">
          <source>Overloading unary minus and plus is not very common and probably best avoided. If needed, they should probably be overloaded as member functions.</source>
          <target state="translated">단항 빼기 및 더하기 과부하는 흔하지 않으며 피하는 것이 가장 좋습니다. 필요한 경우 멤버 함수로 오버로드되어야합니다.</target>
        </trans-unit>
        <trans-unit id="aef51910b519e257f69e8e603e5cc6e63bd7c663" translate="yes" xml:space="preserve">
          <source>Placement &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">게재 위치 &lt;code&gt;new&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f35e5b7132ff39e177d6482815cbd394c998601" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is overloaded as a member function of &lt;code&gt;Foo&lt;/code&gt;, the LHS of the operator must be a &lt;code&gt;Foo&lt;/code&gt; object. Which means, you will be required to use:</source>
          <target state="translated">&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 는 &lt;code&gt;Foo&lt;/code&gt; 의 멤버 함수로 오버로드되므로 연산자 의 LHS는 &lt;code&gt;Foo&lt;/code&gt; 객체 여야합니다. 즉, 다음을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="48b7d95d9adba62275ebb23b2739fe7185d38c3e" translate="yes" xml:space="preserve">
          <source>So-called placement new allows you to create an object at a certain address which is passed to:</source>
          <target state="translated">소위 게재 위치 신규를 사용하면 다음 주소로 전달되는 특정 주소에서 객체를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="410499869878cd2bd1c723022f7e89e241865fba" translate="yes" xml:space="preserve">
          <source>The C++ standard library comes with a set of predefined &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; operators. The most important ones are these:</source>
          <target state="translated">C ++ 표준 라이브러리에는 사전 정의 된 &lt;code&gt;new&lt;/code&gt; 및 &lt;code&gt;delete&lt;/code&gt; 연산자 세트가 제공됩니다. 가장 중요한 것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5b39f9cfeee4e22210663bbd7c842296748cdf0" translate="yes" xml:space="preserve">
          <source>The Decision between Member and Non-member</source>
          <target state="translated">회원과 비회원의 결정</target>
        </trans-unit>
        <trans-unit id="2cdaded69a5ba8bbbc434264bc52e9dff47315be" translate="yes" xml:space="preserve">
          <source>The General Syntax of operator overloading in C++</source>
          <target state="translated">C ++에서 연산자 오버로드의 일반적인 구문</target>
        </trans-unit>
        <trans-unit id="daa94d71b00e6fe8d0332493c4413afa5cc89105" translate="yes" xml:space="preserve">
          <source>The Three Basic Rules of Operator Overloading in C++</source>
          <target state="translated">C ++에서 연산자 오버로드의 3 가지 기본 규칙</target>
        </trans-unit>
        <trans-unit id="1ed425865c7b999b506d3bd64bd342aef7d971fa" translate="yes" xml:space="preserve">
          <source>The array subscript operator is a binary operator which must be implemented as a class member. It is used for container-like types that allow access to their data elements by a key.
The canonical form of providing these is this:</source>
          <target state="translated">배열 첨자 연산자는 이진 연산자이며 클래스 멤버로 구현되어야합니다. 키로 데이터 요소에 액세스 할 수있는 컨테이너와 같은 유형에 사용됩니다. 이를 제공하는 정식 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5071b272c7cacc200a739ff1600233700cde5f39" translate="yes" xml:space="preserve">
          <source>The binary infix comparison operators should, according to the rules of thumb, be implemented as non-member functions&lt;sup&gt;1&lt;/sup&gt;. The unary prefix negation &lt;code&gt;!&lt;/code&gt; should (according to the same rules) be implemented as a member function. (but it is usually not a good idea to overload it.)</source>
          <target state="translated">이진 접두사 비교 연산자는 경험 법칙에 따라 비 멤버 함수 &lt;sup&gt;1&lt;/sup&gt; 로 구현해야합니다. 단항 접두사 부정 &lt;code&gt;!&lt;/code&gt; (같은 규칙에 따라) 멤버 함수로 구현해야합니다. (그러나 일반적으로 과부하는 좋지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="1f4eebeeaa95cd1e3a1f5148b3b1cf80c882d651" translate="yes" xml:space="preserve">
          <source>The binary operators &lt;code&gt;=&lt;/code&gt; (assignment), &lt;code&gt;[]&lt;/code&gt; (array subscription), &lt;code&gt;-&amp;gt;&lt;/code&gt; (member access), as well as the n-ary &lt;code&gt;()&lt;/code&gt; (function call) operator, must always be implemented as &lt;strong&gt;&lt;em&gt;member functions&lt;/em&gt;&lt;/strong&gt;, because the syntax of the language requires them to.</source>
          <target state="translated">이진 연산자 &lt;code&gt;=&lt;/code&gt; (할당), &lt;code&gt;[]&lt;/code&gt; (배열 구독), &lt;code&gt;-&amp;gt;&lt;/code&gt; (회원 액세스) 및 n-ary &lt;code&gt;()&lt;/code&gt; (함수 호출) 연산자는 항상 &lt;strong&gt;&lt;em&gt;멤버 함수&lt;/em&gt;&lt;/strong&gt; 로 구현되어야합니다. 언어는 그들에게 요구합니다.</target>
        </trans-unit>
        <trans-unit id="e752b73d2516a901950b1881135e09ba982f3610" translate="yes" xml:space="preserve">
          <source>The bit manipulation operators &lt;code&gt;~&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; should be implemented in the same way as the arithmetic operators. However, (except for overloading &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; for output and input) there are very few reasonable use cases for overloading these.</source>
          <target state="translated">비트 조작 연산자 &lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 는 산술 연산자와 같은 방식으로 구현되어야합니다. 그러나 (출력 및 입력에 대한 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 의 오버로드를 제외하고) 이들을 오버로드하기위한 합리적인 사용 사례는 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="945991f17734d3341c52c64409c763fa696537b0" translate="yes" xml:space="preserve">
          <source>The bitshift operators &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, although still used in hardware interfacing for the bit-manipulation functions they inherit from C, have become more prevalent as overloaded stream input and output operators in most applications.  For guidance overloading as bit-manipulation operators, see the section below on Binary Arithmetic Operators.  For implementing your own custom format and parsing logic when your object is used with iostreams, continue.</source>
          <target state="translated">비트 시프트 연산자 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 및 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 는 C에서 상속 한 비트 조작 함수를위한 하드웨어 인터페이스에서 여전히 사용되지만 대부분의 응용 프로그램에서 오버로드 된 스트림 입력 및 출력 연산자로 널리 퍼져 있습니다. 비트 조작 연산자로서 오버로드에 대한 지침은 이진 산술 연산자에 대한 아래 섹션을 참조하십시오. 객체가 iostream과 함께 사용될 때 사용자 지정 형식 및 구문 분석 논리를 구현하려면 계속하십시오.</target>
        </trans-unit>
        <trans-unit id="fff84f3d926b7bdd40f1cf1bda8210cabce8f711" translate="yes" xml:space="preserve">
          <source>The first of the basic rules of operator overloading &amp;ndash; &lt;em&gt;don&amp;rsquo;t do it&lt;/em&gt; &amp;ndash; applies especially to overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;. Almost the only reasons to overload these operators are &lt;strong&gt;&lt;em&gt;performance problems&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;memory constraints&lt;/em&gt;&lt;/strong&gt;, and in many cases, other actions, like &lt;em&gt;changes to the algorithms&lt;/em&gt; used, will provide a much &lt;strong&gt;&lt;em&gt;higher cost/gain ratio&lt;/em&gt;&lt;/strong&gt; than attempting to tweak memory management.</source>
          <target state="translated">연산자 오버로딩의 첫 번째 기본 규칙 ( &lt;em&gt;그렇지 않음)은&lt;/em&gt; 특히 &lt;code&gt;new&lt;/code&gt; 및 &lt;code&gt;delete&lt;/code&gt; 오버로드에 적용됩니다. 이러한 연산자에 과부하를 발생시키는 거의 유일한 이유는 &lt;strong&gt;&lt;em&gt;성능 문제&lt;/em&gt;&lt;/strong&gt; 및 &lt;strong&gt;&lt;em&gt;메모리 제약&lt;/em&gt;&lt;/strong&gt; 이며, 많은 경우에 사용되는 &lt;em&gt;알고리즘 변경&lt;/em&gt; 과 같은 다른 작업은 메모리 관리를 조정하는 것 &lt;strong&gt;&lt;em&gt;보다&lt;/em&gt;&lt;/strong&gt; 훨씬 &lt;strong&gt;&lt;em&gt;높은 비용 / 이득 비율을&lt;/em&gt;&lt;/strong&gt; 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d34b042bc12c1d81ad05fa8ab3868d83da8eb700" translate="yes" xml:space="preserve">
          <source>The first two allocate/deallocate memory for an object, the latter two for an array of objects. If you provide your own versions of these, they will &lt;strong&gt;&lt;em&gt;not overload, but replace&lt;/em&gt;&lt;/strong&gt; the ones from the standard library.</source>
          <target state="translated">처음 2 개는 객체에 대한 메모리를 할당 / 할당 해제하고, 2 개는 객체의 배열에 할당합니다. 이러한 버전을 제공하면 &lt;strong&gt;&lt;em&gt;과부하되지 않지만&lt;/em&gt;&lt;/strong&gt; 표준 라이브러리의 버전을 &lt;strong&gt;&lt;em&gt;대체&lt;/em&gt;&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3913d839e0e0cdca08e79893f8e7739eb1267dab" translate="yes" xml:space="preserve">
          <source>The following is a simple class with an implicit conversion operator:</source>
          <target state="translated">다음은 암시 적 변환 연산자가있는 간단한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="633d4c2f5c9eede69578ed2b0fb1b8a6678e93f3" translate="yes" xml:space="preserve">
          <source>The function call operator, used to create function objects, also known as functors, must be defined as a &lt;strong&gt;&lt;em&gt;member&lt;/em&gt;&lt;/strong&gt; function, so it always has the implicit &lt;code&gt;this&lt;/code&gt; argument of member functions. Other than this, it can be overloaded to take any number of additional arguments, including zero.</source>
          <target state="translated">함수 함수라고도하는 함수 객체를 만드는 데 사용되는 함수 호출 연산자는 &lt;strong&gt;&lt;em&gt;멤버&lt;/em&gt;&lt;/strong&gt; 함수로 정의되어야하므로 항상 &lt;strong&gt;&lt;em&gt;멤버&lt;/em&gt;&lt;/strong&gt; 함수의 암시 적 인수를 갖습니다. 이 외에는 0을 포함하여 여러 개의 추가 인수를 사용하도록 오버로드 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f09b5b0acfb377a7aa0dcf24a9a4828f0e1de877" translate="yes" xml:space="preserve">
          <source>The important thing to note here is that only two of these operators actually do anything, the others are just forwarding their arguments to either of these two to do the actual work.</source>
          <target state="translated">여기서 주목해야 할 중요한 것은이 연산자 중 두 개만 실제로 어떤 작업을 수행하고 다른 작업자는 실제 작업을 수행하기 위해이 두 가지 중 하나에 인수를 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c8a7556a69847cd86a1a393d720af19a6fe22b5a" translate="yes" xml:space="preserve">
          <source>The standard library comes with the appropriate overloads of the new and delete operators for this:</source>
          <target state="translated">표준 라이브러리는이를 위해 new 및 delete 연산자의 적절한 과부하가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6c83c7c063a1665405b1d98712a057d5666d471e" translate="yes" xml:space="preserve">
          <source>The standard library&amp;rsquo;s algorithms (e.g. &lt;code&gt;std::sort()&lt;/code&gt;) and types (e.g. &lt;code&gt;std::map&lt;/code&gt;) will always only expect &lt;code&gt;operator&amp;lt;&lt;/code&gt; to be present. However, the &lt;em&gt;users of your type will expect all the other operators to be present&lt;/em&gt;, too, so if you define &lt;code&gt;operator&amp;lt;&lt;/code&gt;, be sure to follow the third fundamental rule of operator overloading and also define all the other boolean comparison operators. The canonical way to implement them is this:</source>
          <target state="translated">표준 라이브러리의 알고리즘 (예 : &lt;code&gt;std::sort()&lt;/code&gt; ) 및 유형 (예 : &lt;code&gt;std::map&lt;/code&gt; )은 항상 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 만있을 것으로 예상합니다. 그러나 &lt;em&gt;유형&lt;/em&gt; 의 &lt;em&gt;사용자는 다른 모든 연산자도 존재할 것으로 예상&lt;/em&gt; 하므로 &lt;code&gt;operator&amp;lt;&lt;/code&gt; 를 정의하면 연산자 오버로드의 세 번째 기본 규칙을 따르고 다른 모든 부울 비교 연산자도 정의해야합니다. 그것들을 구현하는 정식 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b0324536b2aff8b5056489442124903baa2f6fb" translate="yes" xml:space="preserve">
          <source>The stream operators, among the most commonly overloaded operators, are binary infix operators for which the syntax specifies no restriction on whether they should be members or non-members.
Since they change their left argument (they alter the stream&amp;rsquo;s state), they should, according to the rules of thumb, be implemented as members of their left operand&amp;rsquo;s type. However, their left operands are streams from the standard library, and while most of the stream output and input operators defined by the standard library are indeed defined as members of the stream classes, when you implement output and input operations for your own types, you cannot change the standard library&amp;rsquo;s stream types. That&amp;rsquo;s why you need to implement these operators for your own types as non-member functions.
The canonical forms of the two are these:</source>
          <target state="translated">가장 일반적으로 오버로드 된 연산자 중 스트림 연산자는 이진 삽입 연산자이며 구문은 멤버인지 멤버가 아닌지에 대한 제한을 지정하지 않습니다. 왼쪽 인수를 변경하기 때문에 (스트림의 상태를 변경 함) 경험 법칙에 따라 왼쪽 피연산자 유형의 멤버로 구현해야합니다. 그러나 왼쪽 피연산자는 표준 라이브러리의 스트림이며 표준 라이브러리에 의해 정의 된 대부분의 스트림 출력 및 입력 연산자는 실제로 자신의 유형에 대한 출력 및 입력 조작을 구현할 때 스트림 클래스의 멤버로 정의됩니다. 표준 라이브러리의 스트림 유형을 변경할 수 없습니다. 따라서 멤버가 아닌 함수로 자신의 유형에 대해 이러한 연산자를 구현해야합니다. 두 가지의 정식 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e742cb5d317ff843e4d40ebac2e6b8a129167116" translate="yes" xml:space="preserve">
          <source>The syntax for overloading the remaining binary boolean operators (&lt;code&gt;||&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) follows the rules of the comparison operators. However, it is &lt;em&gt;very&lt;/em&gt; unlikely that you would find a reasonable use case for these&lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">나머지 이진 부울 연산자 ( &lt;code&gt;||&lt;/code&gt; , &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; )를 오버로드하는 구문은 비교 연산자의 규칙을 따릅니다. 그러나이 &lt;sup&gt;2에&lt;/sup&gt; 대한 합리적인 사용 사례를 찾을 가능성은 &lt;em&gt;거의&lt;/em&gt; 없습니다.</target>
        </trans-unit>
        <trans-unit id="43b92ed49085008f088b6b20f2dff39e47616f03" translate="yes" xml:space="preserve">
          <source>The unary address-of operator should never be overloaded.</source>
          <target state="translated">단항 주소 연산자에 과부하가 걸리지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="4e69702ccb56e46c30152ff70d54bcafe1d3b79d" translate="yes" xml:space="preserve">
          <source>The unary increment and decrement operators come in both prefix and postfix flavor. To tell one from the other, the postfix variants take an additional dummy int argument. If you overload increment or decrement, be sure to always implement both prefix and postfix versions.
Here is the canonical implementation of increment, decrement follows the same rules:</source>
          <target state="translated">단항 증가 및 감소 연산자는 접두사와 접미사 형식으로 제공됩니다. 다른 것을 구별하기 위해 접미사 변형은 추가 더미 int 인수를 사용합니다. 증분 또는 감소에 과부하가 걸리면 항상 접두사와 접미사 버전을 모두 구현해야합니다. 다음은 증가의 표준 구현입니다. 감소는 동일한 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="fafebafed54733670be4bdb8f0f077c58939e2eb" translate="yes" xml:space="preserve">
          <source>There's a lot to be said about assignment. However, most of it has already been said in &lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;GMan's famous Copy-And-Swap FAQ&lt;/a&gt;, so I'll skip most of it here, only listing the perfect assignment operator for reference:</source>
          <target state="translated">과제에 대해 할 말이 많습니다. 그러나 대부분은 이미 &lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;GMan의 유명한 Copy-And-Swap FAQ&lt;/a&gt; 에서 언급되었으므로 참조를 위해 완벽한 할당 연산자 만 나열하면 여기서 대부분 생략합니다.</target>
        </trans-unit>
        <trans-unit id="7d5a6745e57fd584e32c48350df5cf7b6c97a053" translate="yes" xml:space="preserve">
          <source>Throughout the C++ standard library, function objects are always copied. Your own function objects should therefore be cheap to copy. If a function object absolutely needs to use data which is expensive to copy, it is better to store that data elsewhere and have the function object refer to it.</source>
          <target state="translated">C ++ 표준 라이브러리 전체에서 함수 객체는 항상 복사됩니다. 따라서 자신의 함수 객체는 복사하기에 저렴해야합니다. 함수 객체가 복사하는 데 비용이 많이 드는 데이터를 절대적으로 사용해야하는 경우 해당 데이터를 다른 곳에 저장하고 함수 객체가 참조하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d096ebff9a794e9192a29686de4113ddeb056fa5" translate="yes" xml:space="preserve">
          <source>To invoke the explicit cast operator, you have to use &lt;code&gt;static_cast&lt;/code&gt;, a C-style cast, or a constructor style cast ( i.e. &lt;code&gt;T(value)&lt;/code&gt; ).</source>
          <target state="translated">명시 적 캐스트 연산자를 호출하려면 &lt;code&gt;static_cast&lt;/code&gt; , C 스타일 캐스트 또는 생성자 스타일 캐스트 (예 : &lt;code&gt;T(value)&lt;/code&gt; )를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="d8020d5538e9765d456a055193c573dc6171a136" translate="yes" xml:space="preserve">
          <source>To overload the global new and delete, simply replace the pre-defined operators of the standard library with our own. However, this rarely ever needs to be done.</source>
          <target state="translated">전역 새 항목을 오버로드하고 삭제하려면 표준 라이브러리의 사전 정의 된 연산자를 자체 연산자로 바꾸십시오. 그러나 이것은 거의 수행 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f5a792933066b9a9e2ac32f6f06b8c7c9b9c310a" translate="yes" xml:space="preserve">
          <source>Unary arithmetic operators</source>
          <target state="translated">단항 산술 연산자</target>
        </trans-unit>
        <trans-unit id="97ec28a8a9251fa1cb37b5b5d4e4408efdf02f8b" translate="yes" xml:space="preserve">
          <source>Unless you do not want users of your class to be able to change data elements returned by &lt;code&gt;operator[]&lt;/code&gt; (in which case you can omit the non-const variant), you should always provide both variants of the operator.</source>
          <target state="translated">클래스 사용자가 &lt;code&gt;operator[]&lt;/code&gt; 의해 리턴 된 데이터 요소를 변경하지 못하게하려면 (이 경우 비 const 변형을 생략 할 수 있음) 항상 연산자의 두 변형을 모두 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f28b9e24ebd784a9282ef8b29671b29756db1ae" translate="yes" xml:space="preserve">
          <source>Unlike implicit conversion operators, explicit conversion operators will never kick in when you don't expect them to.  The following is a simple class with an explicit conversion operator:</source>
          <target state="translated">암시 적 변환 연산자와 달리 명시 적 변환 연산자는 사용자가 원하지 않을 때 시작되지 않습니다. 다음은 명시 적 변환 연산자가있는 간단한 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="7a38cdb12264364efc9478d485dd17ef42cde482" translate="yes" xml:space="preserve">
          <source>What are the basic rules and idioms for operator overloading</source>
          <target state="translated">운영자 과부하에 대한 기본 규칙 및 관용구는 무엇입니까</target>
        </trans-unit>
        <trans-unit id="919377897e90c6bc8567a475cc62dd42597b7240" translate="yes" xml:space="preserve">
          <source>When implementing &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, manually setting the stream&amp;rsquo;s state is only necessary when the reading itself succeeded, but the result is not what would be expected.</source>
          <target state="translated">&lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; 구현할 때 스트림 상태를 수동으로 설정하는 것은 읽기 자체가 성공한 경우에만 필요하지만 결과는 예상과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f20d7d9e25980a2df4f9c97a919afac20cc35de6" translate="yes" xml:space="preserve">
          <source>When it comes to operator overloading in C++, there are &lt;strong&gt;&lt;em&gt;three basic rules you should follow&lt;/em&gt;&lt;/strong&gt;. As with all such rules, there are indeed exceptions. Sometimes people have deviated from them and the outcome was not bad code, but such positive deviations are few and far between. At the very least, 99 out of 100 such deviations I have seen were unjustified. However, it might just as well have been 999 out of 1000. So you&amp;rsquo;d better stick to the following rules.</source>
          <target state="translated">C ++에서 연산자 오버로드와 관련하여 &lt;strong&gt;&lt;em&gt;따라야 할 세 가지 기본 규칙이 있습니다&lt;/em&gt;&lt;/strong&gt; . 이러한 모든 규칙과 마찬가지로 실제로 예외가 있습니다. 때때로 사람들은 그들로부터 벗어 났고 결과는 나쁜 코드가 아니었지만 그러한 긍정적 인 편차는 거의 없습니다. 적어도 내가 본 100 가지의 99 개 중 99 개가 정당화되지 않았습니다. 그러나 1000 개 중 999 개일 수도 있습니다. 따라서 다음 규칙을 따르는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="37f76d33dcd336dfa74e1a497620ddd35c0ff0ac" translate="yes" xml:space="preserve">
          <source>Why can't &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; function for streaming objects to &lt;code&gt;std::cout&lt;/code&gt; or to a file be a member function?</source>
          <target state="translated">&lt;code&gt;std::cout&lt;/code&gt; 또는 파일로 객체를 스트리밍하는 &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; 함수를 멤버 함수로 사용할 수없는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="39d720caae827c7c0b9c7f668fcb211ea7a7c1d0" translate="yes" xml:space="preserve">
          <source>You can also overload &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; with other arguments. As with the additional argument for placement new, these arguments are also listed within parentheses after the keyword &lt;code&gt;new&lt;/code&gt;. Merely for historical reasons, such variants are often also called placement new, even if their arguments are not for placing an object at a specific address.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 를 오버로드하고 다른 인수로 &lt;code&gt;delete&lt;/code&gt; 수도 있습니다. new 배치에 대한 추가 인수와 마찬가지로 이러한 인수는 &lt;code&gt;new&lt;/code&gt; 키워드 뒤에 괄호 안에 나열됩니다. 역사적 이유로, 이러한 변형은 인수가 특정 주소에 객체를 배치하기위한 것이 아니더라도 종종 새로운 배치라고도합니다.</target>
        </trans-unit>
        <trans-unit id="7528cb53fda223cd367475e992221703ed9fdc71" translate="yes" xml:space="preserve">
          <source>You cannot change the meaning of operators for built-in types in C++, operators can only be overloaded for user-defined types&lt;sup&gt;1&lt;/sup&gt;. That is, at least one of the operands has to be of a user-defined type. As with other overloaded functions, operators can be overloaded for a certain set of parameters only once.</source>
          <target state="translated">C ++에서 내장 유형에 대한 연산자의 의미를 변경할 수 없으며 연산자는 사용자 정의 유형 &lt;sup&gt;1에&lt;/sup&gt; 대해서만 오버로드 될 수 있습니다. 즉, 피연산자 중 적어도 하나는 사용자 정의 유형이어야합니다. 다른 오버로드 된 기능과 마찬가지로 특정 매개 변수 집합에 대해 연산자를 한 번만 오버로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e8e2f1d8db91fd84d40e7c67b7a78f2b63f8119" translate="yes" xml:space="preserve">
          <source>You will be able to use:</source>
          <target state="translated">다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="216956e088f4509625dab4a52801ab781c0e31b0" translate="yes" xml:space="preserve">
          <source>and you want to overload the increment and decrement operators for it, you cannot do this as a member functions, since in C++, enum types cannot have member functions. So you have to overload it as a free function. And &lt;code&gt;operator&amp;lt;()&lt;/code&gt; for a class template nested within a class template is much easier to write and read when done as a member function inline in the class definition. But these are indeed rare exceptions.</source>
          <target state="translated">그리고 증가 및 감소 연산자를 오버로드하려면 C ++에서 열거 형 유형에 멤버 함수를 사용할 수 없으므로 멤버 함수 로이 작업을 수행 할 수 없습니다. 따라서 무료 기능으로 과부하해야합니다. 클래스 템플릿 내에 중첩 된 클래스 템플릿에 대한 &lt;code&gt;operator&amp;lt;()&lt;/code&gt; 는 클래스 정의에서 인라인 멤버 함수로 수행 할 때 훨씬 쉽게 읽고 쓸 수 있습니다. 그러나 이들은 실제로 드문 예외입니다.</target>
        </trans-unit>
        <trans-unit id="a8876728833443b597fddaff948d8ef7d8b6d6fb" translate="yes" xml:space="preserve">
          <source>arithmetic operators: &lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt; and &lt;code&gt;+=&lt;/code&gt;&lt;code&gt;-=&lt;/code&gt;&lt;code&gt;*=&lt;/code&gt;&lt;code&gt;/=&lt;/code&gt;&lt;code&gt;%=&lt;/code&gt; (all binary infix); &lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt; (unary prefix); &lt;code&gt;++&lt;/code&gt;&lt;code&gt;--&lt;/code&gt; (unary prefix and postfix)</source>
          <target state="translated">산술 연산자 : &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; 및 &lt;code&gt;+=&lt;/code&gt; &lt;code&gt;-=&lt;/code&gt; &lt;code&gt;*=&lt;/code&gt; &lt;code&gt;/=&lt;/code&gt; &lt;code&gt;%=&lt;/code&gt; (모든 이진 접두사); &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; (단일 접두사); &lt;code&gt;++&lt;/code&gt; &lt;code&gt;--&lt;/code&gt; (단일 접두사 및 접미사)</target>
        </trans-unit>
        <trans-unit id="5a5099434f36ef0494a734223946a9f17c108f31" translate="yes" xml:space="preserve">
          <source>bit manipulation: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;amp;=&lt;/code&gt;&lt;code&gt;|=&lt;/code&gt;&lt;code&gt;^=&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; (all binary infix); &lt;code&gt;~&lt;/code&gt; (unary prefix)</source>
          <target state="translated">비트 조작 : &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;amp;=&lt;/code&gt; &lt;code&gt;|=&lt;/code&gt; &lt;code&gt;^=&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; (모든 이진 접두사); &lt;code&gt;~&lt;/code&gt; (단일 접두사)</target>
        </trans-unit>
        <trans-unit id="f93156b243321d1cbdfc482620959e7bf4ed1bf9" translate="yes" xml:space="preserve">
          <source>boolean algebra: &lt;code&gt;==&lt;/code&gt;&lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (all binary infix); &lt;code&gt;!&lt;/code&gt; (unary prefix)</source>
          <target state="translated">부울 대수 : &lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;||&lt;/code&gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; || &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (모든 이진 접두사); &lt;code&gt;!&lt;/code&gt; (단항 접두사)</target>
        </trans-unit>
        <trans-unit id="dfc056418cb491e7998e6f590c77a4dc4c43f3cf" translate="yes" xml:space="preserve">
          <source>implicit conversion operators</source>
          <target state="translated">암시 적 변환 연산자</target>
        </trans-unit>
        <trans-unit id="5a8540091878a4d7ea3c96c572645994df60c30a" translate="yes" xml:space="preserve">
          <source>memory management: &lt;code&gt;new&lt;/code&gt;&lt;code&gt;new[]&lt;/code&gt;&lt;code&gt;delete&lt;/code&gt;&lt;code&gt;delete[]&lt;/code&gt;</source>
          <target state="translated">메모리 관리 : &lt;code&gt;new&lt;/code&gt; &lt;code&gt;new[]&lt;/code&gt; &lt;code&gt;delete&lt;/code&gt; &lt;code&gt;delete[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81b2763337b529b56fc828c4327b362d3740d4ac" translate="yes" xml:space="preserve">
          <source>miscellany: &lt;code&gt;=&lt;/code&gt;&lt;code&gt;[]&lt;/code&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;code&gt;-&amp;gt;*&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;  (all binary infix); &lt;code&gt;*&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; (all unary prefix) &lt;code&gt;()&lt;/code&gt; (function call, n-ary infix)</source>
          <target state="translated">miscellany : &lt;code&gt;=&lt;/code&gt; &lt;code&gt;[]&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;code&gt;-&amp;gt;*&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; (모든 이진 접두사); &lt;code&gt;*&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; (모든 단항 접두사) &lt;code&gt;()&lt;/code&gt; (함수 호출, n- 항 접두사)</target>
        </trans-unit>
        <trans-unit id="c824aa9ad53891d9b5e9c118b4ffd5c133b27edd" translate="yes" xml:space="preserve">
          <source>which is very intuitive.</source>
          <target state="translated">매우 직관적입니다.</target>
        </trans-unit>
        <trans-unit id="0b24478dfb20b5a8671b13a521b4573226f340db" translate="yes" xml:space="preserve">
          <source>which is very non-intuitive.</source>
          <target state="translated">매우 직관적이지 않습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
