<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/4421706">
    <body>
      <group id="4421706">
        <trans-unit id="ebdeccffb9c593d5235ca8b75391edfe495210fe" translate="yes" xml:space="preserve">
          <source>(However, &lt;em&gt;if&lt;/em&gt; you make an exception, do not forget the issue of &lt;code&gt;const&lt;/code&gt;-ness for the operand that, for member functions, becomes the implicit &lt;code&gt;this&lt;/code&gt; argument. If the operator as a non-member function would take its left-most argument as a &lt;code&gt;const&lt;/code&gt; reference, the same operator as a member function needs to have a &lt;code&gt;const&lt;/code&gt; at the end to make &lt;code&gt;*this&lt;/code&gt; a &lt;code&gt;const&lt;/code&gt; reference.)</source>
          <target state="translated">(Sin embargo, &lt;em&gt;si&lt;/em&gt; hace una excepci&amp;oacute;n, no olvide el problema de &lt;code&gt;const&lt;/code&gt; -ness para el operando que, para las funciones miembro, se convierte en impl&amp;iacute;cito &lt;code&gt;this&lt;/code&gt; argumento. Si el operador como una funci&amp;oacute;n no miembro tomar&amp;iacute;a su argumento m&amp;aacute;s a la izquierda como una referencia &lt;code&gt;const&lt;/code&gt; ante , el mismo operador que una funci&amp;oacute;n miembro necesita tener una &lt;code&gt;const&lt;/code&gt; ante al final para que &lt;code&gt;*this&lt;/code&gt; una referencia &lt;code&gt;const&lt;/code&gt; ante ).</target>
        </trans-unit>
        <trans-unit id="a932915cc63f83451fad890ba330a2fe5b0e1013" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator+=&lt;/code&gt; returns its result per reference, while &lt;code&gt;operator+&lt;/code&gt; returns a copy of its result. Of course, returning a reference is usually more efficient than returning a copy, but in the case of &lt;code&gt;operator+&lt;/code&gt;, there is no way around the copying. When you write &lt;code&gt;a + b&lt;/code&gt;, you expect the result to be a new value, which is why &lt;code&gt;operator+&lt;/code&gt; has to return a new value.&lt;sup&gt;3&lt;/sup&gt;
Also note that &lt;code&gt;operator+&lt;/code&gt; takes its left operand &lt;strong&gt;&lt;em&gt;by copy&lt;/em&gt;&lt;/strong&gt; rather than by const reference. The reason for this is the same as the reason giving for &lt;code&gt;operator=&lt;/code&gt; taking its argument per copy.</source>
          <target state="translated">&lt;code&gt;operator+=&lt;/code&gt; devuelve su resultado por referencia, mientras que &lt;code&gt;operator+&lt;/code&gt; devuelve una copia de su resultado. Por supuesto, devolver una referencia suele ser m&amp;aacute;s eficiente que devolver una copia, pero en el caso del &lt;code&gt;operator+&lt;/code&gt; , no hay forma de evitar la copia. Cuando escribe &lt;code&gt;a + b&lt;/code&gt; , espera que el resultado sea un nuevo valor, raz&amp;oacute;n por la cual el &lt;code&gt;operator+&lt;/code&gt; tiene que devolver un nuevo valor. &lt;sup&gt;3&lt;/sup&gt; Tambi&amp;eacute;n tenga en cuenta que el &lt;code&gt;operator+&lt;/code&gt; toma su operando izquierdo &lt;strong&gt;&lt;em&gt;por copia en&lt;/em&gt;&lt;/strong&gt; lugar de por referencia constante. La raz&amp;oacute;n de esto es la misma que la raz&amp;oacute;n que da para &lt;code&gt;operator=&lt;/code&gt; tomar su argumento por copia.</target>
        </trans-unit>
        <trans-unit id="338efc32f9cb83e0dd8331e45788ecc57787ef85" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Operators are related to each other&lt;/em&gt; and to other operations. If your type supports &lt;code&gt;a + b&lt;/code&gt;, users will expect to be able to call &lt;code&gt;a += b&lt;/code&gt;, too. If it supports prefix increment &lt;code&gt;++a&lt;/code&gt;, they will expect &lt;code&gt;a++&lt;/code&gt; to work as well. If they can check whether &lt;code&gt;a &amp;lt; b&lt;/code&gt;, they will most certainly expect to also to be able to check whether &lt;code&gt;a &amp;gt; b&lt;/code&gt;. If they can copy-construct your type, they expect assignment to work as well.</source>
          <target state="translated">&lt;em&gt;Los operadores est&amp;aacute;n relacionados entre s&amp;iacute;&lt;/em&gt; y con otras operaciones. Si su tipo admite &lt;code&gt;a + b&lt;/code&gt; , los usuarios tambi&amp;eacute;n podr&amp;aacute;n llamar &lt;code&gt;a += b&lt;/code&gt; . Si admite el incremento de prefijo &lt;code&gt;++a&lt;/code&gt; , esperar&amp;aacute;n que &lt;code&gt;a++&lt;/code&gt; funcione tambi&amp;eacute;n. Si pueden verificar si &lt;code&gt;a &amp;lt; b&lt;/code&gt; , seguramente tambi&amp;eacute;n esperar&amp;aacute;n poder verificar si &lt;code&gt;a &amp;gt; b&lt;/code&gt; . Si pueden copiar y construir su tipo, esperan que la asignaci&amp;oacute;n funcione tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="aa5bd5f45a48b221e418619d95cdcc6b6c6e44a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Always provide all out of a set of related operations.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Proporcione siempre todo de un conjunto de operaciones relacionadas.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9489b9f4b1bac05ddb2354a51560ad5b088a8f70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Always stick to the operator&amp;rsquo;s well-known semantics.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Siempre respete la conocida sem&amp;aacute;ntica del operador.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09e12a464818e248f8bb9ed843a88d4b181a6616" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Whenever the meaning of an operator is not obviously clear and undisputed, it should not be overloaded.&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;Instead, provide a function with a well-chosen name.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Siempre que el significado de un operador no sea obviamente claro e indiscutible, no debe sobrecargarse.&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;En su lugar, proporcione una funci&amp;oacute;n con un nombre bien elegido.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="620ae72342c6c376f4c4a1a08f78905e1878296d" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;em&gt;(Note: This is meant to be an entry to &lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;Stack Overflow's C++ FAQ&lt;/a&gt;. If you want to critique the idea of providing an FAQ in this form, then &lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;the posting on meta that started all this&lt;/a&gt; would be the place to do that. Answers to that question are monitored in the &lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;C++ chatroom&lt;/a&gt;, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)&lt;/em&gt;
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;(Nota: Esto est&amp;aacute; destinado a ser una entrada a &lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;las preguntas frecuentes de C ++ de Stack Overflow&lt;/a&gt; . Si desea criticar la idea de proporcionar una pregunta frecuente en este formulario, entonces &lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;la publicaci&amp;oacute;n en meta que comenz&amp;oacute; todo esto&lt;/a&gt; ser&amp;iacute;a el lugar para hacerlo. Respuestas a esa pregunta se monitorea en la &lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;sala de chat de C ++&lt;/a&gt; , donde la idea de preguntas frecuentes comenz&amp;oacute; en primer lugar, por lo que es muy probable que su respuesta sea le&amp;iacute;da por aquellos a quienes se les ocurri&amp;oacute; la idea).&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="14f3efc38fad533ae15f4148f1a61fdd2dd11ee7" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Note the &lt;code&gt;const&lt;/code&gt; at the end.)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;(Tenga en cuenta la &lt;code&gt;const&lt;/code&gt; ante al final.)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="c0ca582ae5768203060cbf81ae5d446fdbadce13" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;As with all rules of thumb, sometimes there might be reasons to break this one, too. If so, do not forget that the left-hand operand of the binary comparison operators, which for member functions will be &lt;code&gt;*this&lt;/code&gt;, needs to be &lt;code&gt;const&lt;/code&gt;, too. So a comparison operator implemented as a member function would have to have this signature:&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; &lt;sub&gt;Como con todas las reglas generales, a veces puede haber razones para romper esta tambi&amp;eacute;n.&lt;/sub&gt; &lt;sub&gt;Si es as&amp;iacute;, no olvide que el operando de la izquierda de los operadores de comparaci&amp;oacute;n binarios, que para funciones miembro ser&amp;aacute; &lt;code&gt;*this&lt;/code&gt; , tambi&amp;eacute;n debe ser &lt;code&gt;const&lt;/code&gt; ante .&lt;/sub&gt; &lt;sub&gt;Por lo tanto, un operador de comparaci&amp;oacute;n implementado como una funci&amp;oacute;n miembro deber&amp;iacute;a tener esta firma:&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9a7c0de90272aa0b4c0f2ec37dbe7d8ba11b179a" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;The term &amp;ldquo;user-defined&amp;rdquo; might be slightly misleading. C++ makes the distinction between built-in types and user-defined types. To the former belong for example int, char, and double; to the latter belong all struct, class, union, and enum types, including those from the standard library, even though they are not, as such, defined by users.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; &lt;sub&gt;El t&amp;eacute;rmino &quot;definido por el usuario&quot; puede ser ligeramente enga&amp;ntilde;oso.&lt;/sub&gt; &lt;sub&gt;C ++ hace la distinci&amp;oacute;n entre los tipos integrados y los tipos definidos por el usuario.&lt;/sub&gt; &lt;sub&gt;A los primeros pertenecen, por ejemplo, int, char y double;&lt;/sub&gt; &lt;sub&gt;a este &amp;uacute;ltimo pertenecen todos los tipos de estructura, clase, uni&amp;oacute;n y enumeraci&amp;oacute;n, incluidos los de la biblioteca est&amp;aacute;ndar, aunque no est&amp;eacute;n definidos como tales por los usuarios.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="4d522b0d5a3ee143d4b55a7eefa9657f18b4f0ea" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;Also note that the postfix variant does more work and is therefore less efficient to use than the prefix variant. This is a good reason to generally prefer prefix increment over postfix increment. While compilers can usually optimize away the additional work of postfix increment for built-in types, they might not be able to do the same for user-defined types (which could be something as innocently looking as a list iterator). Once you got used to do &lt;code&gt;i++&lt;/code&gt;, it becomes very hard to remember to do &lt;code&gt;++i&lt;/code&gt; instead when &lt;code&gt;i&lt;/code&gt; is not of a built-in type (plus you'd have to change code when changing a type), so it is better to make a habit of always using prefix increment, unless postfix is explicitly needed.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;Tambi&amp;eacute;n tenga en cuenta que la variante de postfix hace m&amp;aacute;s trabajo y, por lo tanto, es menos eficiente de usar que la variante de prefijo.&lt;/sub&gt; &lt;sub&gt;Esta es una buena raz&amp;oacute;n para preferir generalmente el incremento de prefijo sobre el incremento de postfix.&lt;/sub&gt; &lt;sub&gt;Si bien los compiladores generalmente pueden optimizar el trabajo adicional del incremento de postfix para los tipos incorporados, es posible que no puedan hacer lo mismo para los tipos definidos por el usuario (que podr&amp;iacute;a ser algo tan inocentemente como un iterador de lista).&lt;/sub&gt; &lt;sub&gt;Una vez que se haya acostumbrado a hacer &lt;code&gt;i++&lt;/code&gt; , se hace muy dif&amp;iacute;cil recordar hacer &lt;code&gt;++i&lt;/code&gt; cuando no soy de tipo incorporado (adem&amp;aacute;s, tendr&amp;iacute;a que cambiar el c&amp;oacute;digo al cambiar un tipo), por lo que es mejor Acost&amp;uacute;mbrese a utilizar siempre el incremento de prefijo, a menos que se necesite expl&amp;iacute;citamente postfix.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="3f5b8f85cc67312e85c8eb294398952de5c9070e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;It should be noted that the built-in version of &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; use shortcut semantics. While the user defined ones (because they are syntactic sugar for method calls) do not use shortcut semantics. User will expect these operators to have shortcut semantics, and their code may depend on it, Therefore it is highly advised NEVER to define them.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;Cabe se&amp;ntilde;alar que la versi&amp;oacute;n incorporada de &lt;code&gt;||&lt;/code&gt; &lt;/sub&gt; &lt;sub&gt;y &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; use la sem&amp;aacute;ntica de atajos.&lt;/sub&gt; &lt;sub&gt;Mientras que los definidos por el usuario (porque son az&amp;uacute;car sint&amp;aacute;ctica para las llamadas a m&amp;eacute;todos) no use la sem&amp;aacute;ntica de atajos.&lt;/sub&gt; &lt;sub&gt;El usuario esperar&amp;aacute; que estos operadores tengan sem&amp;aacute;ntica de acceso directo, y su c&amp;oacute;digo puede depender de ello, por lo tanto, se recomienda NUNCA definirlos.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e3c92f172f9d6a21e1edbee610bd748896095eab" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;This is covered in &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/4421729#4421729&quot;&gt;a later part&lt;/a&gt; of this FAQ.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;Esto est&amp;aacute; cubierto en &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/4421729#4421729&quot;&gt;una parte posterior&lt;/a&gt; de estas preguntas frecuentes.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2d81bca5cf7dc6ada15492470100c9698c01c407" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3&lt;/sup&gt;&lt;sub&gt;Again, the lesson to be taken from this is that &lt;code&gt;a += b&lt;/code&gt; is, in general, more efficient than &lt;code&gt;a + b&lt;/code&gt; and should be preferred if possible.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;3&lt;/sup&gt; &lt;sub&gt;Nuevamente, la lecci&amp;oacute;n que se debe extraer de esto es que &lt;code&gt;a += b&lt;/code&gt; es, en general, m&amp;aacute;s eficiente que &lt;code&gt;a + b&lt;/code&gt; y se deber&amp;iacute;a preferir si es posible.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5cca32e7a575b9db399f83cf13cfe08fee093572" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3&lt;/sup&gt;&lt;sub&gt;The &lt;code&gt;@&lt;/code&gt; is not a valid operator in C++ which is why I use it as a placeholder.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;3&lt;/sup&gt; &lt;sub&gt; &lt;code&gt;@&lt;/code&gt; no es un operador v&amp;aacute;lido en C ++, por eso lo uso como marcador de posici&amp;oacute;n.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="fb4e0ac4049821674fc6813ec9ef8cfd305f5ca1" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;4&lt;/sup&gt;&lt;sub&gt;The only ternary operator in C++ cannot be overloaded and the only n-ary operator must always be implemented as a member function.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;4&lt;/sup&gt; &lt;sub&gt;El &amp;uacute;nico operador ternario en C ++ no se puede sobrecargar y el &amp;uacute;nico operador n-ary siempre debe implementarse como una funci&amp;oacute;n miembro.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="276a8f6944c21a071705fa227dcf9ba993594a29" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;strong&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/strong&gt; This only deals with the &lt;strong&gt;&lt;em&gt;syntax&lt;/em&gt;&lt;/strong&gt; of overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, not with the &lt;strong&gt;&lt;em&gt;implementation&lt;/em&gt;&lt;/strong&gt; of such overloaded operators. I think that the semantics of overloading &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7149461/&quot;&gt;&lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; deserve their own FAQ&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;, within the topic of operator overloading I can never do it justice.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;strong&gt;&lt;em&gt;Nota:&lt;/em&gt;&lt;/strong&gt; Esto solo trata con la &lt;strong&gt;&lt;em&gt;sintaxis&lt;/em&gt;&lt;/strong&gt; de sobrecargar &lt;code&gt;new&lt;/code&gt; y &lt;code&gt;delete&lt;/code&gt; , no con la &lt;strong&gt;&lt;em&gt;implementaci&amp;oacute;n&lt;/em&gt;&lt;/strong&gt; de dichos operadores sobrecargados.&lt;/sup&gt; &lt;sup&gt;Creo que la sem&amp;aacute;ntica de sobrecargar &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7149461/&quot;&gt; &lt;code&gt;new&lt;/code&gt; y &lt;code&gt;delete&lt;/code&gt; merecen sus propias preguntas frecuentes&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; , en el tema de la sobrecarga de operadores nunca puedo hacerle justicia.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="421a43341da00165d391cdef2aecb500589bd6e0" translate="yes" xml:space="preserve">
          <source>According to our rules of thumb, &lt;code&gt;+&lt;/code&gt; and its companions should be non-members, while their compound assignment counterparts (&lt;code&gt;+=&lt;/code&gt; etc.), changing their left argument, should be a member. Here is the exemplary code for &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt;; the other binary arithmetic operators should be implemented in the same way:</source>
          <target state="translated">De acuerdo con nuestras reglas generales, &lt;code&gt;+&lt;/code&gt; y sus compa&amp;ntilde;eros deber&amp;iacute;an ser no miembros, mientras que sus contrapartes de asignaci&amp;oacute;n compuesta ( &lt;code&gt;+=&lt;/code&gt; etc.), que cambien su argumento izquierdo, deber&amp;iacute;an ser miembros. Aqu&amp;iacute; est&amp;aacute; el c&amp;oacute;digo ejemplar para &lt;code&gt;+=&lt;/code&gt; y &lt;code&gt;+&lt;/code&gt; ; los otros operadores aritm&amp;eacute;ticos binarios deben implementarse de la misma manera:</target>
        </trans-unit>
        <trans-unit id="f3952c5c15a5c4f059ce1db8233deaaeda4f28a8" translate="yes" xml:space="preserve">
          <source>Among the operators that can be overloaded in C++ are these:</source>
          <target state="translated">Entre los operadores que pueden ser sobrecargados en C++están estos:</target>
        </trans-unit>
        <trans-unit id="be759ec493e1844e284eba0ba8febc88ff79e21f" translate="yes" xml:space="preserve">
          <source>An implicit conversion operator allows the compiler to implicitly convert (like the conversion between &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;) the value of a user-defined type to some other type.</source>
          <target state="translated">Un operador de conversi&amp;oacute;n impl&amp;iacute;cita permite que el compilador convierta impl&amp;iacute;citamente (como la conversi&amp;oacute;n entre &lt;code&gt;int&lt;/code&gt; y &lt;code&gt;long&lt;/code&gt; ) el valor de un tipo definido por el usuario a otro tipo.</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">Operadores aritméticos</target>
        </trans-unit>
        <trans-unit id="aecc43fc2fe547cd50965b231d35b4682af12f07" translate="yes" xml:space="preserve">
          <source>Array Subscripting</source>
          <target state="translated">Suscripción de matrices</target>
        </trans-unit>
        <trans-unit id="67c1b1f3ed026dea13ed68968e94e0a7d893d152" translate="yes" xml:space="preserve">
          <source>Assignment Operator</source>
          <target state="translated">Operador de asignación</target>
        </trans-unit>
        <trans-unit id="93070e8acd1b2a07488cdde5f031a65133a6cf12" translate="yes" xml:space="preserve">
          <source>At first this seems very helpful, but the problem with this is that the implicit conversion even kicks in when it isn&amp;rsquo;t expected to. In the following code, &lt;code&gt;void f(const char*)&lt;/code&gt; will be called because &lt;code&gt;my_string()&lt;/code&gt; is not an &lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;lvalue&lt;/a&gt;, so the first does not match:</source>
          <target state="translated">Al principio esto parece muy &amp;uacute;til, pero el problema con esto es que la conversi&amp;oacute;n impl&amp;iacute;cita incluso se activa cuando no se espera que lo haga. En el siguiente c&amp;oacute;digo, se llamar&amp;aacute; a &lt;code&gt;void f(const char*)&lt;/code&gt; porque &lt;code&gt;my_string()&lt;/code&gt; no es un valor &lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;l&lt;/a&gt; , por lo que el primero no coincide:</target>
        </trans-unit>
        <trans-unit id="0ee8de3eebacd7c638e4729172a904422deca61b" translate="yes" xml:space="preserve">
          <source>Basically, the first and foremost rule for overloading operators, at its very heart, says: &lt;em&gt;Don&amp;rsquo;t do it&lt;/em&gt;. That might seem strange, because there is a lot to be known about operator overloading and so a lot of articles, book chapters, and other texts deal with all this. But despite this seemingly obvious evidence, &lt;em&gt;there are only a surprisingly few cases where operator overloading is appropriate&lt;/em&gt;. The reason is that actually it is hard to understand the semantics behind the application of an operator unless the use of the operator in the application domain is well known and undisputed. Contrary to popular belief, this is hardly ever the case.</source>
          <target state="translated">B&amp;aacute;sicamente, la primera y m&amp;aacute;s importante regla para sobrecargar a los operadores, en esencia, dice: &lt;em&gt;no lo hagas&lt;/em&gt; . Puede parecer extra&amp;ntilde;o, porque hay mucho que saber sobre la sobrecarga del operador y muchos art&amp;iacute;culos, cap&amp;iacute;tulos de libros y otros textos tratan de todo esto. Pero a pesar de esta evidencia aparentemente obvia, &lt;em&gt;solo hay unos pocos casos sorprendentemente donde la sobrecarga del operador es apropiada&lt;/em&gt; . La raz&amp;oacute;n es que en realidad es dif&amp;iacute;cil entender la sem&amp;aacute;ntica detr&amp;aacute;s de la aplicaci&amp;oacute;n de un operador a menos que el uso del operador en el dominio de la aplicaci&amp;oacute;n sea bien conocido e indiscutible. Contrariamente a la creencia popular, este casi nunca es el caso.</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4d0acd385943a19aff1dd079c0d333f73eeda130" translate="yes" xml:space="preserve">
          <source>Because the compiler will not cast &quot;past&quot; &lt;code&gt;bool&lt;/code&gt;, explicit conversion operators now remove the need for the &lt;a href=&quot;http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool&quot;&gt;Safe Bool idiom&lt;/a&gt;.   For example, smart pointers before C++11 used the Safe Bool idiom to prevent conversions to integral types.  In C++11, the smart pointers use an explicit operator instead because the compiler is not allowed to implicitly convert to an integral type after it explicitly converted a type to bool.</source>
          <target state="translated">Debido a que el compilador no lanzar&amp;aacute; &lt;code&gt;bool&lt;/code&gt; &quot;pasado&quot;, los operadores de conversi&amp;oacute;n expl&amp;iacute;citos ahora eliminan la necesidad del &lt;a href=&quot;http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool&quot;&gt;lenguaje Safe Bool&lt;/a&gt; . Por ejemplo, los punteros inteligentes anteriores a C ++ 11 utilizaron el idioma Safe Bool para evitar conversiones a tipos integrales. En C ++ 11, los punteros inteligentes utilizan un operador expl&amp;iacute;cito porque el compilador no puede convertir impl&amp;iacute;citamente a un tipo integral despu&amp;eacute;s de convertir expl&amp;iacute;citamente un tipo a bool.</target>
        </trans-unit>
        <trans-unit id="71c42caac2d9ddf4204de8698243a11cfa04f910" translate="yes" xml:space="preserve">
          <source>Beginners easily get this wrong and even experienced C++ programmers are sometimes surprised because the compiler picks an overload they didn&amp;rsquo;t suspect.  These problems can be mitigated by explicit conversion operators.</source>
          <target state="translated">Los principiantes se equivocan f&amp;aacute;cilmente e incluso los programadores experimentados de C ++ a veces se sorprenden porque el compilador elige una sobrecarga que no sospechaban. Estos problemas pueden ser mitigados por operadores de conversi&amp;oacute;n expl&amp;iacute;citos.</target>
        </trans-unit>
        <trans-unit id="91150bd6516ac5f77628d936130ba9cf5ec13ae6" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operators</source>
          <target state="translated">Operadores de aritmética binaria</target>
        </trans-unit>
        <trans-unit id="ae37c4e20a55a6ef0b50c1ce0e0f71802dbf0111" translate="yes" xml:space="preserve">
          <source>Bitshift Operators (used for Stream I/O)</source>
          <target state="translated">Operadores de cambio de bits (usado para Stream IO)</target>
        </trans-unit>
        <trans-unit id="db69b09b584ceff2f01a827a244f4ddf0bcc8bfa" translate="yes" xml:space="preserve">
          <source>C++ allows new and delete operators to take additional arguments.</source>
          <target state="translated">C++permite que los operadores nuevos y los borradores tomen argumentos adicionales.</target>
        </trans-unit>
        <trans-unit id="cea3dbd2ef365f97b36a9803e63877ab2a2dcd07" translate="yes" xml:space="preserve">
          <source>C++ allows you to tune both of these operations: memory management and the construction/destruction of the object at the allocated memory. The latter is done by writing constructors and destructors for a class. Fine-tuning memory management is done by writing your own &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt;.</source>
          <target state="translated">C ++ le permite ajustar ambas operaciones: administraci&amp;oacute;n de memoria y construcci&amp;oacute;n / destrucci&amp;oacute;n del objeto en la memoria asignada. Esto &amp;uacute;ltimo se hace escribiendo constructores y destructores para una clase. El ajuste fino de la gesti&amp;oacute;n de memoria se realiza escribiendo su propio &lt;code&gt;operator new&lt;/code&gt; y el &lt;code&gt;operator delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53e1ae4928af9f305e18ff9d9d702bea83c43afc" translate="yes" xml:space="preserve">
          <source>C++ poses no limitations on the semantics of overloaded operators. Your compiler will happily accept code that implements the binary &lt;code&gt;+&lt;/code&gt; operator to subtract from its right operand. However, the users of such an operator would never suspect the expression &lt;code&gt;a + b&lt;/code&gt; to subtract &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;b&lt;/code&gt;. Of course, this supposes that the semantics of the operator in the application domain is undisputed.</source>
          <target state="translated">C ++ no plantea limitaciones en la sem&amp;aacute;ntica de los operadores sobrecargados. Su compilador aceptar&amp;aacute; felizmente el c&amp;oacute;digo que implementa el operador binario &lt;code&gt;+&lt;/code&gt; para restar de su operando correcto. Sin embargo, los usuarios de dicho operador nunca sospechar&amp;iacute;an que la expresi&amp;oacute;n &lt;code&gt;a + b&lt;/code&gt; reste &lt;code&gt;a&lt;/code&gt; de &lt;code&gt;b&lt;/code&gt; . Por supuesto, esto supone que la sem&amp;aacute;ntica del operador en el dominio de la aplicaci&amp;oacute;n es indiscutible.</target>
        </trans-unit>
        <trans-unit id="7c17731e50f62eea89cf01a119386ba15a466c77" translate="yes" xml:space="preserve">
          <source>Class-specific new and delete</source>
          <target state="translated">Específico de la clase nuevo y eliminar</target>
        </trans-unit>
        <trans-unit id="7266bf079b182acba7043970de462e41b2663d92" translate="yes" xml:space="preserve">
          <source>Common operators to overload</source>
          <target state="translated">Los operadores comunes para sobrecargar</target>
        </trans-unit>
        <trans-unit id="9461d4c9f916ad7df5538225ed552fb6e7e3284b" translate="yes" xml:space="preserve">
          <source>Comparison operators</source>
          <target state="translated">Operadores de comparación</target>
        </trans-unit>
        <trans-unit id="d8ddbec0b26e694dbe2e4392c23c80e62413f2d4" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708&quot;&gt;The Three Basic Rules of Operator Overloading in C++&lt;/a&gt;.</source>
          <target state="translated">Contin&amp;uacute;e con &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708&quot;&gt;Las tres reglas b&amp;aacute;sicas de sobrecarga del operador en C ++&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a650afcae173aef7cbc03df980e79ab8dcfc031" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719#4421719&quot;&gt;Common operators to overload&lt;/a&gt;.</source>
          <target state="translated">Continuar a &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719#4421719&quot;&gt;operadores comunes para sobrecargar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49e07535d312dbe3a4fc30e2d414ba6a141b3abe" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729&quot;&gt;The Decision between Member and Non-member&lt;/a&gt;.</source>
          <target state="translated">Contin&amp;uacute;e con &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729&quot;&gt;la Decisi&amp;oacute;n entre miembro y no miembro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="390e8f97087fe4c33287f0dec7d962032d84d2b0" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791#4421791&quot;&gt;Overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Continuar a &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791#4421791&quot;&gt;Sobrecargando &lt;code&gt;new&lt;/code&gt; y &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c4829881d2b9099fb960d607315a36454fc1c0d" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725&quot;&gt;Conversion Operators&lt;/a&gt;</source>
          <target state="translated">Continuar a los &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725&quot;&gt;operadores de conversi&amp;oacute;n&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cce1bda201abe07a87309c10681fbc4836893a50" translate="yes" xml:space="preserve">
          <source>Conversion Operators</source>
          <target state="translated">Operadores de conversión</target>
        </trans-unit>
        <trans-unit id="97921336d267bc620b6817f8d0fbd3946c8e1724" translate="yes" xml:space="preserve">
          <source>Conversion Operators (also known as User Defined Conversions)</source>
          <target state="translated">Operadores de conversión (también conocidos como conversiones definidas por el usuario)</target>
        </trans-unit>
        <trans-unit id="06916bcd529378cd7be8d494e6a076cdff280dfb" translate="yes" xml:space="preserve">
          <source>Explicit Conversion Operators (C++11)</source>
          <target state="translated">Operadores de conversión explícita (C++11)</target>
        </trans-unit>
        <trans-unit id="bb0bf432160bebf9e28e99e45037098df491690e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;operator-&amp;gt;*()&lt;/code&gt; see &lt;a href=&quot;https://stackoverflow.com/q/8777845/140719&quot;&gt;this question&lt;/a&gt;. It's rarely used and thus rarely ever overloaded. In fact, even iterators do not overload it.</source>
          <target state="translated">Para el &lt;code&gt;operator-&amp;gt;*()&lt;/code&gt; vea &lt;a href=&quot;https://stackoverflow.com/q/8777845/140719&quot;&gt;esta pregunta&lt;/a&gt; . Raramente se usa y, por lo tanto, rara vez se sobrecarga. De hecho, incluso los iteradores no lo sobrecargan.</target>
        </trans-unit>
        <trans-unit id="f6ea334ff6ce5f1423f350e93f69641ce7406130" translate="yes" xml:space="preserve">
          <source>For all operators where you have to choose to either implement them as a member function or a non-member function, &lt;strong&gt;&lt;em&gt;use the following rules of thumb&lt;/em&gt;&lt;/strong&gt; to decide:</source>
          <target state="translated">Para todos los operadores en los que tiene que elegir implementarlos como una funci&amp;oacute;n miembro o una funci&amp;oacute;n no miembro, &lt;strong&gt;&lt;em&gt;use las siguientes reglas generales&lt;/em&gt;&lt;/strong&gt; para decidir:</target>
        </trans-unit>
        <trans-unit id="d69d65276d05cacbd13652fa039509c5c7448719" translate="yes" xml:space="preserve">
          <source>For defining your own iterators or smart pointers, you have to overload the unary prefix dereference operator &lt;code&gt;*&lt;/code&gt; and the binary infix pointer member access operator &lt;code&gt;-&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Para definir sus propios iteradores o punteros inteligentes, debe sobrecargar el operador de desreferencia de prefijo unario &lt;code&gt;*&lt;/code&gt; y el operador de acceso de miembro de puntero infijo binario &lt;code&gt;-&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1587e1394f773c588778fbe18bdd8ed62ff6821b" translate="yes" xml:space="preserve">
          <source>For the binary arithmetic operators, do not forget to obey the third basic rule operator overloading: If you provide &lt;code&gt;+&lt;/code&gt;, also provide &lt;code&gt;+=&lt;/code&gt;, if you provide &lt;code&gt;-&lt;/code&gt;, do not omit &lt;code&gt;-=&lt;/code&gt;, etc. Andrew Koenig is said to have been the first to observe that the compound assignment operators can be used as a base for their non-compound counterparts. That is, operator &lt;code&gt;+&lt;/code&gt; is implemented in terms of &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; is implemented in terms of &lt;code&gt;-=&lt;/code&gt; etc.</source>
          <target state="translated">Para los operadores aritm&amp;eacute;ticos binarios, no olvide obedecer la tercera sobrecarga del operador de la regla b&amp;aacute;sica: si proporciona &lt;code&gt;+&lt;/code&gt; , tambi&amp;eacute;n proporciona &lt;code&gt;+=&lt;/code&gt; , si proporciona &lt;code&gt;-&lt;/code&gt; , no omita &lt;code&gt;-=&lt;/code&gt; , etc. Se dice que Andrew Koenig fue el primero para observar que los operadores de asignaci&amp;oacute;n compuesta pueden usarse como base para sus contrapartes no compuestas. Es decir, el operador &lt;code&gt;+&lt;/code&gt; se implementa en t&amp;eacute;rminos de &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; se implementa en t&amp;eacute;rminos de &lt;code&gt;-=&lt;/code&gt; etc.</target>
        </trans-unit>
        <trans-unit id="25056cd4f19ab3cf2ddbe426ca4f88659c9ecb1f" translate="yes" xml:space="preserve">
          <source>Function call operator</source>
          <target state="translated">Función llamar al operador</target>
        </trans-unit>
        <trans-unit id="266781763563b15feb1a51bb6a9014424ae1126a" translate="yes" xml:space="preserve">
          <source>Given that, you cannot use:</source>
          <target state="translated">Dado eso,no puedes usar:</target>
        </trans-unit>
        <trans-unit id="90be49000bdd6cb11fcaf3b36883081fc56eaccc" translate="yes" xml:space="preserve">
          <source>Global new and delete</source>
          <target state="translated">Global nuevo y eliminar</target>
        </trans-unit>
        <trans-unit id="40ccf2f37dd214c6d5991f8f2094c0e81dc4e65d" translate="yes" xml:space="preserve">
          <source>Here's an example of the syntax:</source>
          <target state="translated">Aquí hay un ejemplo de la sintaxis:</target>
        </trans-unit>
        <trans-unit id="2f19bc6ee55c37f3c7803fde5dc79430596476a8" translate="yes" xml:space="preserve">
          <source>However, the fact that you &lt;em&gt;can&lt;/em&gt; overload all of these does not mean you &lt;em&gt;should&lt;/em&gt; do so. See the basic rules of operator overloading.</source>
          <target state="translated">Sin embargo, el hecho de que &lt;em&gt;pueda&lt;/em&gt; sobrecargar todo esto no significa que &lt;em&gt;deba&lt;/em&gt; hacerlo. Consulte las reglas b&amp;aacute;sicas de sobrecarga del operador.</target>
        </trans-unit>
        <trans-unit id="d1df6c2555df05f2e2d7b30909ceaba1a04419ac" translate="yes" xml:space="preserve">
          <source>However, there is one exception to this:  The compiler is allowed to implicitly convert to &lt;code&gt;bool&lt;/code&gt;.  In addition, the compiler is not allowed to do another implicit conversion after it converts to &lt;code&gt;bool&lt;/code&gt; (a compiler is allowed to do 2 implicit conversions at a time, but only 1 user-defined conversion at max).</source>
          <target state="translated">Sin embargo, hay una excepci&amp;oacute;n a esto: el compilador puede convertir impl&amp;iacute;citamente a &lt;code&gt;bool&lt;/code&gt; . Adem&amp;aacute;s, el compilador no puede realizar otra conversi&amp;oacute;n impl&amp;iacute;cita despu&amp;eacute;s de convertir a &lt;code&gt;bool&lt;/code&gt; (un compilador puede realizar 2 conversiones impl&amp;iacute;citas a la vez, pero solo 1 conversi&amp;oacute;n definida por el usuario como m&amp;aacute;ximo).</target>
        </trans-unit>
        <trans-unit id="52ab79f2235a5be84cd7d66fe9e8c1206c27da29" translate="yes" xml:space="preserve">
          <source>If a binary operator does &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; treat both of its operands &lt;strong&gt;&lt;em&gt;equally&lt;/em&gt;&lt;/strong&gt; (usually it will change its left operand), it might be useful to make it a &lt;strong&gt;&lt;em&gt;member&lt;/em&gt;&lt;/strong&gt; function of its left operand&amp;rsquo;s type, if it has to access the operand's private parts.</source>
          <target state="translated">Si un operador binario &lt;strong&gt;&lt;em&gt;no&lt;/em&gt;&lt;/strong&gt; trata ambos operandos por &lt;strong&gt;&lt;em&gt;igual&lt;/em&gt;&lt;/strong&gt; (por lo general, cambiar&amp;aacute; su operando izquierdo), podr&amp;iacute;a ser &amp;uacute;til convertirlo en una funci&amp;oacute;n &lt;strong&gt;&lt;em&gt;miembro&lt;/em&gt;&lt;/strong&gt; del tipo de su operando izquierdo, si tiene que acceder a las partes privadas del operando.</target>
        </trans-unit>
        <trans-unit id="9dbf7e58fa487fdde1f10120a1e361214ac8d248" translate="yes" xml:space="preserve">
          <source>If a binary operator treats &lt;strong&gt;&lt;em&gt;both operands equally&lt;/em&gt;&lt;/strong&gt; (it leaves them unchanged), implement this operator as a &lt;strong&gt;&lt;em&gt;non-member&lt;/em&gt;&lt;/strong&gt; function.</source>
          <target state="translated">Si un operador binario trata &lt;strong&gt;&lt;em&gt;ambos operandos por igual&lt;/em&gt;&lt;/strong&gt; (los deja sin cambios), implemente este operador como una funci&amp;oacute;n &lt;strong&gt;&lt;em&gt;no miembro&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ed6a13f07242d7d741efc0c6314f4777012e50e3" translate="yes" xml:space="preserve">
          <source>If it is a &lt;strong&gt;&lt;em&gt;unary operator&lt;/em&gt;&lt;/strong&gt;, implement it as a &lt;strong&gt;&lt;em&gt;member&lt;/em&gt;&lt;/strong&gt; function.</source>
          <target state="translated">Si es un &lt;strong&gt;&lt;em&gt;operador unario&lt;/em&gt;&lt;/strong&gt; , implem&amp;eacute;ntelo como una funci&amp;oacute;n &lt;strong&gt;&lt;em&gt;miembro&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="262c7f3eacf6b4b4a482e67f29ed9ce4d067684f" translate="yes" xml:space="preserve">
          <source>If value_type is known to refer to a built-in type, the const variant of the operator should better return a copy instead of a const reference:</source>
          <target state="translated">Si se sabe que value_type se refiere a un tipo incorporado,la variante const del operador debería devolver mejor una copia en lugar de una referencia const:</target>
        </trans-unit>
        <trans-unit id="f4c82304b319df56b3a1e32bbe46b626dd2db4cf" translate="yes" xml:space="preserve">
          <source>If you define it as a non-member function,</source>
          <target state="translated">Si se define como una función no miembro,</target>
        </trans-unit>
        <trans-unit id="c3222f784f51643651a73e25ba26b59a34a1a97e" translate="yes" xml:space="preserve">
          <source>If you overload &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, you should consider overloading the array variants, too.</source>
          <target state="translated">Si sobrecarga &lt;code&gt;new&lt;/code&gt; y &lt;code&gt;delete&lt;/code&gt; , tambi&amp;eacute;n debe considerar sobrecargar las variantes de matriz.</target>
        </trans-unit>
        <trans-unit id="f13af45755f6d4b1682363cc396a98d01a7f9a22" translate="yes" xml:space="preserve">
          <source>If you overload &lt;code&gt;operator new&lt;/code&gt;, you should always also overload the matching &lt;code&gt;operator delete&lt;/code&gt;, even if you never intend to call it. The reason is that, if a constructor throws during the evaluation of a new expression, the run-time system will return the memory to the &lt;code&gt;operator delete&lt;/code&gt; matching the &lt;code&gt;operator new&lt;/code&gt; that was called to allocate the memory to create the object in. If you do not provide a matching &lt;code&gt;operator delete&lt;/code&gt;, the default one is called, which is almost always wrong.</source>
          <target state="translated">Si sobrecarga al &lt;code&gt;operator new&lt;/code&gt; , siempre debe sobrecargar tambi&amp;eacute;n el &lt;code&gt;operator delete&lt;/code&gt; coincidente eliminar , incluso si nunca tiene la intenci&amp;oacute;n de llamarlo. La raz&amp;oacute;n es que, si un constructor lanza durante la evaluaci&amp;oacute;n de una nueva expresi&amp;oacute;n, el sistema de tiempo de ejecuci&amp;oacute;n devolver&amp;aacute; la memoria al &lt;code&gt;operator delete&lt;/code&gt; coincidencia con el &lt;code&gt;operator new&lt;/code&gt; que se llam&amp;oacute; para asignar la memoria para crear el objeto. Si lo hace no proporciona una &lt;code&gt;operator delete&lt;/code&gt; coincidente, se llama al predeterminado, que casi siempre es incorrecto.</target>
        </trans-unit>
        <trans-unit id="826dbaa31e10b50624ed6f5bcb81e5a26a59de5f" translate="yes" xml:space="preserve">
          <source>Implicit Conversion Operators (C++98/C++03 and C++11)</source>
          <target state="translated">Operadores de conversión implícita (C++98C++03 y C++11)</target>
        </trans-unit>
        <trans-unit id="64b3307a85f7de1505aa3f37db4699689e2030a6" translate="yes" xml:space="preserve">
          <source>Implicit conversion operators, like one-argument constructors, are user-defined conversions. Compilers will grant one user-defined conversion when trying to match a call to an overloaded function.</source>
          <target state="translated">Los operadores de conversión implícita,como los constructores de un solo argumento,son conversiones definidas por el usuario.Los compiladores concederán una conversión definida por el usuario cuando traten de hacer coincidir una llamada con una función sobrecargada.</target>
        </trans-unit>
        <trans-unit id="40caa674c8cd189d440009873823c8ee2f813b8c" translate="yes" xml:space="preserve">
          <source>In C++ you can create conversion operators, operators that allow the compiler to convert between your types and other defined types.  There are two types of conversion operators, implicit and explicit ones.</source>
          <target state="translated">En C++se pueden crear operadores de conversión,operadores que permiten al compilador convertir entre sus tipos y otros tipos definidos.Hay dos tipos de operadores de conversión,implícitos y explícitos.</target>
        </trans-unit>
        <trans-unit id="49ef7e77ad3309f43ce0a0c931ad5b00264bdae6" translate="yes" xml:space="preserve">
          <source>In C++, operators are overloaded in the form of &lt;strong&gt;&lt;em&gt;functions with special names&lt;/em&gt;&lt;/strong&gt;. As with other functions, overloaded operators can generally be implemented either as a &lt;strong&gt;&lt;em&gt;member function of their left operand's type&lt;/em&gt;&lt;/strong&gt; or as &lt;strong&gt;&lt;em&gt;non-member functions&lt;/em&gt;&lt;/strong&gt;. Whether you are free to choose or bound to use either one depends on several criteria.&lt;sup&gt;2&lt;/sup&gt; A unary operator &lt;code&gt;@&lt;/code&gt;&lt;sup&gt;3&lt;/sup&gt;, applied to an object x, is invoked either as &lt;code&gt;operator@(x)&lt;/code&gt; or as &lt;code&gt;x.operator@()&lt;/code&gt;. A binary infix operator &lt;code&gt;@&lt;/code&gt;, applied to the objects &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, is called either as &lt;code&gt;operator@(x,y)&lt;/code&gt; or as &lt;code&gt;x.operator@(y)&lt;/code&gt;.&lt;sup&gt;4&lt;/sup&gt;</source>
          <target state="translated">En C ++, los operadores est&amp;aacute;n sobrecargados en forma de &lt;strong&gt;&lt;em&gt;funciones con nombres especiales&lt;/em&gt;&lt;/strong&gt; . Al igual que con otras funciones, los operadores sobrecargados generalmente se pueden implementar como una &lt;strong&gt;&lt;em&gt;funci&amp;oacute;n miembro del tipo de su operando izquierdo&lt;/em&gt;&lt;/strong&gt; o como &lt;strong&gt;&lt;em&gt;funciones no miembros&lt;/em&gt;&lt;/strong&gt; . Si es libre de elegir o est&amp;aacute; obligado a usar cualquiera de ellos depende de varios criterios. &lt;sup&gt;2&lt;/sup&gt; Un operador unario &lt;code&gt;@&lt;/code&gt; &lt;sup&gt;3&lt;/sup&gt; , aplicado a un objeto x, se invoca como &lt;code&gt;operator@(x)&lt;/code&gt; o como &lt;code&gt;x.operator@()&lt;/code&gt; . Un operador infijo binario &lt;code&gt;@&lt;/code&gt; , aplicado a los objetos &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; , se denomina &lt;code&gt;operator@(x,y)&lt;/code&gt; o como &lt;code&gt;x.operator@(y)&lt;/code&gt; . &lt;sup&gt;4 4&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7bc8481881e8590c8face179b924af1ea4a5fe0a" translate="yes" xml:space="preserve">
          <source>In C++, when you write a &lt;strong&gt;&lt;em&gt;new expression&lt;/em&gt;&lt;/strong&gt; like &lt;code&gt;new T(arg)&lt;/code&gt; two things happen when this expression is evaluated: First &lt;strong&gt;&lt;em&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt; is invoked to obtain raw memory, and then the appropriate constructor of &lt;code&gt;T&lt;/code&gt; is invoked to turn this raw memory into a valid object. Likewise, when you delete an object, first its destructor is called, and then the memory is returned to &lt;code&gt;operator delete&lt;/code&gt;.</source>
          <target state="translated">En C ++, cuando escribe una &lt;strong&gt;&lt;em&gt;nueva expresi&amp;oacute;n&lt;/em&gt;&lt;/strong&gt; como &lt;code&gt;new T(arg)&lt;/code&gt; , suceden dos cosas cuando se eval&amp;uacute;a esta expresi&amp;oacute;n: primero se invoca el &lt;strong&gt;&lt;em&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt; para obtener memoria sin formato, y luego se invoca el constructor apropiado de &lt;code&gt;T&lt;/code&gt; para convertir esta memoria sin formato en un objeto v&amp;aacute;lido Del mismo modo, cuando elimina un objeto, primero se llama a su destructor, y luego la memoria vuelve a la &lt;code&gt;operator delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d9a856b351238fc8815cf318816c5839249dbd0" translate="yes" xml:space="preserve">
          <source>Input and Output Operators</source>
          <target state="translated">Operadores de entrada y salida</target>
        </trans-unit>
        <trans-unit id="aff987919c1c656b540f21e98fcd457a77a08632" translate="yes" xml:space="preserve">
          <source>Let's say you have:</source>
          <target state="translated">Digamos que sí:</target>
        </trans-unit>
        <trans-unit id="1da0a13b5d45735843a1a97b7d80a3c4e94a7d15" translate="yes" xml:space="preserve">
          <source>Most commonly you will want to fine-tune memory management because measurement has shown that instances of a specific class, or of a group of related classes, are created and destroyed often and that the default memory management of the run-time system, tuned for general performance, deals inefficiently in this specific case. To improve this, you can overload new and delete for a specific class:</source>
          <target state="translated">Lo más común es que se quiera afinar la gestión de la memoria porque las mediciones han demostrado que a menudo se crean y destruyen instancias de una clase específica,o de un grupo de clases relacionadas,y que la gestión de la memoria por defecto del sistema en tiempo de ejecución,afinada para el rendimiento general,se ocupa de manera ineficiente en este caso específico.Para mejorar esto,se puede sobrecargar la nueva y eliminar para una clase específica:</target>
        </trans-unit>
        <trans-unit id="7bc4f7a69868fbbebd9b1aa75e004a5d424231ae" translate="yes" xml:space="preserve">
          <source>Most of the work in overloading operators is boiler-plate code. That is little wonder, since operators are merely syntactic sugar, their actual work could be done by (and often is forwarded to) plain functions. But it is important that you get this boiler-plate code right. If you fail, either your operator&amp;rsquo;s code won&amp;rsquo;t compile or your users&amp;rsquo; code won&amp;rsquo;t compile or your users&amp;rsquo; code will behave surprisingly.</source>
          <target state="translated">La mayor parte del trabajo en los operadores de sobrecarga es el c&amp;oacute;digo de placa de caldera. No es de extra&amp;ntilde;ar, ya que los operadores son simplemente az&amp;uacute;car sint&amp;aacute;ctica, su trabajo real podr&amp;iacute;a realizarse (y a menudo se reenv&amp;iacute;a a) funciones simples. Pero es importante que obtenga este c&amp;oacute;digo correcto de placa de caldera. Si falla, el c&amp;oacute;digo de su operador no se compilar&amp;aacute; o el c&amp;oacute;digo de sus usuarios no se compilar&amp;aacute; o el c&amp;oacute;digo de sus usuarios se comportar&amp;aacute; sorprendentemente.</target>
        </trans-unit>
        <trans-unit id="308ac793bd96cffbd3257f710242d8d6baa8c5f9" translate="yes" xml:space="preserve">
          <source>Not all operators can be overloaded in C++. Among the operators that cannot be overloaded are: &lt;code&gt;.&lt;/code&gt;&lt;code&gt;::&lt;/code&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt; and the only ternary operator in C++, &lt;code&gt;?:&lt;/code&gt;</source>
          <target state="translated">No todos los operadores pueden sobrecargarse en C ++. Entre los operadores que no se pueden sobrecargar est&amp;aacute;n:. &lt;code&gt;::&lt;/code&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; y el &amp;uacute;nico operador ternario en C ++, &lt;code&gt;?:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba5b304e147804bebb9771281e8f850c466d01fa" translate="yes" xml:space="preserve">
          <source>Note that the postfix variant is implemented in terms of prefix. Also note that postfix does an extra copy.&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">Tenga en cuenta que la variante postfix se implementa en t&amp;eacute;rminos de prefijo. Tambi&amp;eacute;n tenga en cuenta que postfix hace una copia adicional. &lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a98223f6637a4998c4f367f083b8d38397dc9316" translate="yes" xml:space="preserve">
          <source>Note that these, too, will almost always need both a const and a non-const version.
For the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator, if &lt;code&gt;value_type&lt;/code&gt; is of &lt;code&gt;class&lt;/code&gt; (or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt;) type, another &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; is called recursively, until an &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; returns a value of non-class type.</source>
          <target state="translated">Tenga en cuenta que estos tambi&amp;eacute;n necesitar&amp;aacute;n casi siempre una versi&amp;oacute;n const y una versi&amp;oacute;n sin const. Para el operador &lt;code&gt;-&amp;gt;&lt;/code&gt; , si &lt;code&gt;value_type&lt;/code&gt; es de tipo de &lt;code&gt;class&lt;/code&gt; (o &lt;code&gt;struct&lt;/code&gt; o &lt;code&gt;union&lt;/code&gt; ), se llama a otro &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; forma recursiva, hasta que un &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; devuelve un valor de tipo que no es de clase.</target>
        </trans-unit>
        <trans-unit id="2b329ad0d568d6f8e12b0e15d54437e0b250ccda" translate="yes" xml:space="preserve">
          <source>Note that, in the example code for placement new given above, &lt;code&gt;operator delete&lt;/code&gt; is never called, unless the constructor of X throws an exception.</source>
          <target state="translated">Tenga en cuenta que, en el c&amp;oacute;digo de ejemplo para la ubicaci&amp;oacute;n nueva dada anteriormente, nunca se llama a la &lt;code&gt;operator delete&lt;/code&gt; , a menos que el constructor de X arroje una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e34f82c929e61f88c2610287d88fb521a0cf8bf6" translate="yes" xml:space="preserve">
          <source>Note: The answers were given in &lt;em&gt;a specific order&lt;/em&gt;, but since many users sort answers according to votes, rather than the time they were given, here's an &lt;strong&gt;&lt;em&gt;index of the answers&lt;/em&gt;&lt;/strong&gt; in the order in which they make most sense:</source>
          <target state="translated">Nota: Las respuestas se dieron en &lt;em&gt;un orden espec&amp;iacute;fico&lt;/em&gt; , pero dado que muchos usuarios clasifican las respuestas de acuerdo con los votos, en lugar del tiempo en que se dieron, aqu&amp;iacute; hay un &lt;strong&gt;&lt;em&gt;&amp;iacute;ndice de las respuestas&lt;/em&gt;&lt;/strong&gt; en el orden en que tienen m&amp;aacute;s sentido:</target>
        </trans-unit>
        <trans-unit id="88ae2678453b7004e74233094e1cdf9026fbf332" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;explicit&lt;/code&gt;.  Now when you try to execute the unexpected code from the implicit conversion operators, you get a compiler error:</source>
          <target state="translated">Observe lo &lt;code&gt;explicit&lt;/code&gt; . Ahora, cuando intenta ejecutar el c&amp;oacute;digo inesperado de los operadores de conversi&amp;oacute;n impl&amp;iacute;citos, obtiene un error del compilador:</target>
        </trans-unit>
        <trans-unit id="5ed5a83cf4720e09bb656ff2ed60cc35eca54b74" translate="yes" xml:space="preserve">
          <source>Of course, as with all rules of thumb, there are exceptions. If you have a type</source>
          <target state="translated">Por supuesto,como en todas las reglas generales,hay excepciones.Si tienes un tipo</target>
        </trans-unit>
        <trans-unit id="71635eee6d0e7a43c1616fdd99b28d55662b9781" translate="yes" xml:space="preserve">
          <source>Operators for Pointer-like Types</source>
          <target state="translated">Operadores para los tipos de puntero</target>
        </trans-unit>
        <trans-unit id="232c32ffd9745850f7cd1967b4a1a159748cf1ff" translate="yes" xml:space="preserve">
          <source>Operators that are implemented as non-member functions are sometimes friend of their operand&amp;rsquo;s type.</source>
          <target state="translated">Los operadores que se implementan como funciones que no son miembros a veces son amigos del tipo de su operando.</target>
        </trans-unit>
        <trans-unit id="fbf47cfe86efefa771f3ac5016a6dee10f74b19c" translate="yes" xml:space="preserve">
          <source>Other operators can be implemented either as members or as non-members. Some of them, however, usually have to be implemented as non-member functions, because their left operand cannot be modified by you. The most prominent of these are the input and output operators &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, whose left operands are stream classes from the standard library which you cannot change.</source>
          <target state="translated">Otros operadores pueden implementarse como miembros o no miembros. Algunos de ellos, sin embargo, generalmente tienen que implementarse como funciones que no son miembros, porque su operando izquierdo no puede ser modificado por usted. Los m&amp;aacute;s destacados son los operadores de entrada y salida &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; y &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , cuyos operandos izquierdos son clases de flujo de la biblioteca est&amp;aacute;ndar que no puede cambiar.</target>
        </trans-unit>
        <trans-unit id="61c0c26e0870099af93b41d7ed973fe4422b7163" translate="yes" xml:space="preserve">
          <source>Overloaded thus, new and delete behave like static member functions. For objects of &lt;code&gt;my_class&lt;/code&gt;, the &lt;code&gt;std::size_t&lt;/code&gt; argument will always be &lt;code&gt;sizeof(my_class)&lt;/code&gt;. However, these operators are also called for dynamically allocated objects of &lt;strong&gt;&lt;em&gt;derived classes&lt;/em&gt;&lt;/strong&gt;, in which case it might be greater than that.</source>
          <target state="translated">Sobrecargado as&amp;iacute;, new y delete se comportan como funciones miembro est&amp;aacute;ticas. Para los objetos de &lt;code&gt;my_class&lt;/code&gt; , el argumento &lt;code&gt;std::size_t&lt;/code&gt; siempre ser&amp;aacute; &lt;code&gt;sizeof(my_class)&lt;/code&gt; . Sin embargo, estos operadores tambi&amp;eacute;n son llamados para objetos asignados din&amp;aacute;micamente de &lt;strong&gt;&lt;em&gt;clases derivadas&lt;/em&gt;&lt;/strong&gt; , en cuyo caso podr&amp;iacute;a ser mayor que eso.</target>
        </trans-unit>
        <trans-unit id="387a1adda403a18b38d6933171fc8f31a2cbd62c" translate="yes" xml:space="preserve">
          <source>Overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">Sobrecargando &lt;code&gt;new&lt;/code&gt; y &lt;code&gt;delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="918f907f18107b5038a28b4f7a181b670ec203fa" translate="yes" xml:space="preserve">
          <source>Overloading new and delete</source>
          <target state="translated">Sobrecargar nuevo y eliminar</target>
        </trans-unit>
        <trans-unit id="6c74c5e2cff52e6b3146c3c1bffab6eeaab7158c" translate="yes" xml:space="preserve">
          <source>Overloading unary minus and plus is not very common and probably best avoided. If needed, they should probably be overloaded as member functions.</source>
          <target state="translated">La sobrecarga de unario menos y más no es muy común y probablemente sea mejor evitarla.Si es necesario,probablemente deberían ser sobrecargados como funciones de los miembros.</target>
        </trans-unit>
        <trans-unit id="aef51910b519e257f69e8e603e5cc6e63bd7c663" translate="yes" xml:space="preserve">
          <source>Placement &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">Colocaci&amp;oacute;n &lt;code&gt;new&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f35e5b7132ff39e177d6482815cbd394c998601" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is overloaded as a member function of &lt;code&gt;Foo&lt;/code&gt;, the LHS of the operator must be a &lt;code&gt;Foo&lt;/code&gt; object. Which means, you will be required to use:</source>
          <target state="translated">Como el &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; est&amp;aacute; sobrecargado como una funci&amp;oacute;n miembro de &lt;code&gt;Foo&lt;/code&gt; , el LHS del operador debe ser un objeto &lt;code&gt;Foo&lt;/code&gt; . Lo que significa que se le pedir&amp;aacute; que use:</target>
        </trans-unit>
        <trans-unit id="48b7d95d9adba62275ebb23b2739fe7185d38c3e" translate="yes" xml:space="preserve">
          <source>So-called placement new allows you to create an object at a certain address which is passed to:</source>
          <target state="translated">La llamada colocación nueva permite crear un objeto en una cierta dirección a la que se pasa:</target>
        </trans-unit>
        <trans-unit id="410499869878cd2bd1c723022f7e89e241865fba" translate="yes" xml:space="preserve">
          <source>The C++ standard library comes with a set of predefined &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; operators. The most important ones are these:</source>
          <target state="translated">La biblioteca est&amp;aacute;ndar de C ++ viene con un conjunto de operadores predefinidos &lt;code&gt;new&lt;/code&gt; y de &lt;code&gt;delete&lt;/code&gt; . Los m&amp;aacute;s importantes son estos:</target>
        </trans-unit>
        <trans-unit id="c5b39f9cfeee4e22210663bbd7c842296748cdf0" translate="yes" xml:space="preserve">
          <source>The Decision between Member and Non-member</source>
          <target state="translated">La decisión entre los miembros y los no miembros</target>
        </trans-unit>
        <trans-unit id="2cdaded69a5ba8bbbc434264bc52e9dff47315be" translate="yes" xml:space="preserve">
          <source>The General Syntax of operator overloading in C++</source>
          <target state="translated">La sintaxis general de la sobrecarga del operador en C++</target>
        </trans-unit>
        <trans-unit id="daa94d71b00e6fe8d0332493c4413afa5cc89105" translate="yes" xml:space="preserve">
          <source>The Three Basic Rules of Operator Overloading in C++</source>
          <target state="translated">Las tres reglas básicas de la sobrecarga del operador en C++</target>
        </trans-unit>
        <trans-unit id="1ed425865c7b999b506d3bd64bd342aef7d971fa" translate="yes" xml:space="preserve">
          <source>The array subscript operator is a binary operator which must be implemented as a class member. It is used for container-like types that allow access to their data elements by a key.
The canonical form of providing these is this:</source>
          <target state="translated">El operador de subíndice de la matriz es un operador binario que debe implementarse como un miembro de la clase.Se utiliza para tipos tipo contenedores que permiten el acceso a sus elementos de datos mediante una clave.La forma canónica de proporcionarlos es ésta:</target>
        </trans-unit>
        <trans-unit id="5071b272c7cacc200a739ff1600233700cde5f39" translate="yes" xml:space="preserve">
          <source>The binary infix comparison operators should, according to the rules of thumb, be implemented as non-member functions&lt;sup&gt;1&lt;/sup&gt;. The unary prefix negation &lt;code&gt;!&lt;/code&gt; should (according to the same rules) be implemented as a member function. (but it is usually not a good idea to overload it.)</source>
          <target state="translated">Los operadores de comparaci&amp;oacute;n de infijo binario deben, de acuerdo con las reglas generales, implementarse como funciones no miembros &lt;sup&gt;1&lt;/sup&gt; . &amp;iexcl;La negaci&amp;oacute;n del prefijo unario &lt;code&gt;!&lt;/code&gt; deber&amp;iacute;a (de acuerdo con las mismas reglas) implementarse como una funci&amp;oacute;n miembro. (pero generalmente no es una buena idea sobrecargarlo).</target>
        </trans-unit>
        <trans-unit id="1f4eebeeaa95cd1e3a1f5148b3b1cf80c882d651" translate="yes" xml:space="preserve">
          <source>The binary operators &lt;code&gt;=&lt;/code&gt; (assignment), &lt;code&gt;[]&lt;/code&gt; (array subscription), &lt;code&gt;-&amp;gt;&lt;/code&gt; (member access), as well as the n-ary &lt;code&gt;()&lt;/code&gt; (function call) operator, must always be implemented as &lt;strong&gt;&lt;em&gt;member functions&lt;/em&gt;&lt;/strong&gt;, because the syntax of the language requires them to.</source>
          <target state="translated">Los operadores binarios &lt;code&gt;=&lt;/code&gt; (asignaci&amp;oacute;n), &lt;code&gt;[]&lt;/code&gt; (suscripci&amp;oacute;n de matriz), &lt;code&gt;-&amp;gt;&lt;/code&gt; (acceso de miembro), as&amp;iacute; como el operador n-ary &lt;code&gt;()&lt;/code&gt; (llamada a funci&amp;oacute;n), siempre deben implementarse como &lt;strong&gt;&lt;em&gt;funciones miembro&lt;/em&gt;&lt;/strong&gt; , porque la sintaxis de el lenguaje lo requiere.</target>
        </trans-unit>
        <trans-unit id="e752b73d2516a901950b1881135e09ba982f3610" translate="yes" xml:space="preserve">
          <source>The bit manipulation operators &lt;code&gt;~&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; should be implemented in the same way as the arithmetic operators. However, (except for overloading &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; for output and input) there are very few reasonable use cases for overloading these.</source>
          <target state="translated">Los operadores de manipulaci&amp;oacute;n de bits &lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; debe implementarse de la misma manera que los operadores aritm&amp;eacute;ticos. Sin embargo, (a excepci&amp;oacute;n de la sobrecarga &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; y &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; para salida y entrada) hay muy pocos casos de uso razonables para sobrecargarlos.</target>
        </trans-unit>
        <trans-unit id="945991f17734d3341c52c64409c763fa696537b0" translate="yes" xml:space="preserve">
          <source>The bitshift operators &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, although still used in hardware interfacing for the bit-manipulation functions they inherit from C, have become more prevalent as overloaded stream input and output operators in most applications.  For guidance overloading as bit-manipulation operators, see the section below on Binary Arithmetic Operators.  For implementing your own custom format and parsing logic when your object is used with iostreams, continue.</source>
          <target state="translated">Los operadores de desplazamiento de bits &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; y &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , aunque todav&amp;iacute;a se usan en la interfaz de hardware para las funciones de manipulaci&amp;oacute;n de bits que heredan de C, se han vuelto m&amp;aacute;s frecuentes como operadores de entrada y salida de flujo sobrecargados en la mayor&amp;iacute;a de las aplicaciones. Para la sobrecarga de orientaci&amp;oacute;n como operadores de manipulaci&amp;oacute;n de bits, consulte la siguiente secci&amp;oacute;n sobre Operadores aritm&amp;eacute;ticos binarios. Para implementar su propio formato personalizado y l&amp;oacute;gica de an&amp;aacute;lisis cuando su objeto se usa con iostreams, contin&amp;uacute;e.</target>
        </trans-unit>
        <trans-unit id="fff84f3d926b7bdd40f1cf1bda8210cabce8f711" translate="yes" xml:space="preserve">
          <source>The first of the basic rules of operator overloading &amp;ndash; &lt;em&gt;don&amp;rsquo;t do it&lt;/em&gt; &amp;ndash; applies especially to overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;. Almost the only reasons to overload these operators are &lt;strong&gt;&lt;em&gt;performance problems&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;memory constraints&lt;/em&gt;&lt;/strong&gt;, and in many cases, other actions, like &lt;em&gt;changes to the algorithms&lt;/em&gt; used, will provide a much &lt;strong&gt;&lt;em&gt;higher cost/gain ratio&lt;/em&gt;&lt;/strong&gt; than attempting to tweak memory management.</source>
          <target state="translated">La primera de las reglas b&amp;aacute;sicas de sobrecarga del operador, &lt;em&gt;no lo haga, se&lt;/em&gt; aplica especialmente a la sobrecarga de &lt;code&gt;new&lt;/code&gt; y &lt;code&gt;delete&lt;/code&gt; . Casi las &amp;uacute;nicas razones para sobrecargar estos operadores son los &lt;strong&gt;&lt;em&gt;problemas de rendimiento&lt;/em&gt;&lt;/strong&gt; y las &lt;strong&gt;&lt;em&gt;limitaciones de memoria&lt;/em&gt;&lt;/strong&gt; , y en muchos casos, otras acciones, como los &lt;em&gt;cambios en los algoritmos&lt;/em&gt; utilizados, proporcionar&amp;aacute;n una &lt;strong&gt;&lt;em&gt;relaci&amp;oacute;n costo / ganancia&lt;/em&gt;&lt;/strong&gt; mucho &lt;strong&gt;&lt;em&gt;mayor&lt;/em&gt;&lt;/strong&gt; que intentar modificar la administraci&amp;oacute;n de memoria.</target>
        </trans-unit>
        <trans-unit id="d34b042bc12c1d81ad05fa8ab3868d83da8eb700" translate="yes" xml:space="preserve">
          <source>The first two allocate/deallocate memory for an object, the latter two for an array of objects. If you provide your own versions of these, they will &lt;strong&gt;&lt;em&gt;not overload, but replace&lt;/em&gt;&lt;/strong&gt; the ones from the standard library.</source>
          <target state="translated">Los dos primeros asignan / desasignan memoria para un objeto, los dos &amp;uacute;ltimos para una matriz de objetos. Si proporciona sus propias versiones de estas, no se &lt;strong&gt;&lt;em&gt;sobrecargar&amp;aacute;n, sino que reemplazar&amp;aacute;n&lt;/em&gt;&lt;/strong&gt; las de la biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="3913d839e0e0cdca08e79893f8e7739eb1267dab" translate="yes" xml:space="preserve">
          <source>The following is a simple class with an implicit conversion operator:</source>
          <target state="translated">La siguiente es una clase simple con un operador de conversión implícito:</target>
        </trans-unit>
        <trans-unit id="633d4c2f5c9eede69578ed2b0fb1b8a6678e93f3" translate="yes" xml:space="preserve">
          <source>The function call operator, used to create function objects, also known as functors, must be defined as a &lt;strong&gt;&lt;em&gt;member&lt;/em&gt;&lt;/strong&gt; function, so it always has the implicit &lt;code&gt;this&lt;/code&gt; argument of member functions. Other than this, it can be overloaded to take any number of additional arguments, including zero.</source>
          <target state="translated">El operador de llamada a funci&amp;oacute;n, usado para crear objetos de funci&amp;oacute;n, tambi&amp;eacute;n conocidos como functores, debe definirse como una funci&amp;oacute;n &lt;strong&gt;&lt;em&gt;miembro&lt;/em&gt;&lt;/strong&gt; , por lo que siempre tiene impl&amp;iacute;cito &lt;code&gt;this&lt;/code&gt; argumento de funciones miembro. Aparte de esto, se puede sobrecargar para tomar cualquier n&amp;uacute;mero de argumentos adicionales, incluido cero.</target>
        </trans-unit>
        <trans-unit id="f09b5b0acfb377a7aa0dcf24a9a4828f0e1de877" translate="yes" xml:space="preserve">
          <source>The important thing to note here is that only two of these operators actually do anything, the others are just forwarding their arguments to either of these two to do the actual work.</source>
          <target state="translated">Lo importante es que sólo dos de estos operadores hacen algo,los otros sólo transmiten sus argumentos a cualquiera de estos dos para hacer el trabajo.</target>
        </trans-unit>
        <trans-unit id="c8a7556a69847cd86a1a393d720af19a6fe22b5a" translate="yes" xml:space="preserve">
          <source>The standard library comes with the appropriate overloads of the new and delete operators for this:</source>
          <target state="translated">La biblioteca estándar viene con las sobrecargas apropiadas de los operadores nuevos y de los borradores para esto:</target>
        </trans-unit>
        <trans-unit id="6c83c7c063a1665405b1d98712a057d5666d471e" translate="yes" xml:space="preserve">
          <source>The standard library&amp;rsquo;s algorithms (e.g. &lt;code&gt;std::sort()&lt;/code&gt;) and types (e.g. &lt;code&gt;std::map&lt;/code&gt;) will always only expect &lt;code&gt;operator&amp;lt;&lt;/code&gt; to be present. However, the &lt;em&gt;users of your type will expect all the other operators to be present&lt;/em&gt;, too, so if you define &lt;code&gt;operator&amp;lt;&lt;/code&gt;, be sure to follow the third fundamental rule of operator overloading and also define all the other boolean comparison operators. The canonical way to implement them is this:</source>
          <target state="translated">Los algoritmos de la biblioteca est&amp;aacute;ndar (p. Ej., &lt;code&gt;std::sort()&lt;/code&gt; ) y los tipos (p. Ej., &lt;code&gt;std::map&lt;/code&gt; ) siempre esperar&amp;aacute;n que el &lt;code&gt;operator&amp;lt;&lt;/code&gt; est&amp;eacute; presente. Sin embargo, los &lt;em&gt;usuarios de su tipo esperar&amp;aacute;n que todos los dem&amp;aacute;s operadores tambi&amp;eacute;n est&amp;eacute;n presentes&lt;/em&gt; , por lo que si define el &lt;code&gt;operator&amp;lt;&lt;/code&gt; , aseg&amp;uacute;rese de seguir la tercera regla fundamental de sobrecarga del operador y tambi&amp;eacute;n definir todos los dem&amp;aacute;s operadores de comparaci&amp;oacute;n booleanos. La forma can&amp;oacute;nica de implementarlos es esta:</target>
        </trans-unit>
        <trans-unit id="7b0324536b2aff8b5056489442124903baa2f6fb" translate="yes" xml:space="preserve">
          <source>The stream operators, among the most commonly overloaded operators, are binary infix operators for which the syntax specifies no restriction on whether they should be members or non-members.
Since they change their left argument (they alter the stream&amp;rsquo;s state), they should, according to the rules of thumb, be implemented as members of their left operand&amp;rsquo;s type. However, their left operands are streams from the standard library, and while most of the stream output and input operators defined by the standard library are indeed defined as members of the stream classes, when you implement output and input operations for your own types, you cannot change the standard library&amp;rsquo;s stream types. That&amp;rsquo;s why you need to implement these operators for your own types as non-member functions.
The canonical forms of the two are these:</source>
          <target state="translated">Los operadores de flujo, entre los operadores sobrecargados m&amp;aacute;s com&amp;uacute;nmente, son operadores infix binarios para los cuales la sintaxis no especifica ninguna restricci&amp;oacute;n sobre si deben ser miembros o no miembros. Dado que cambian su argumento izquierdo (alteran el estado de la secuencia), deber&amp;iacute;an, de acuerdo con las reglas generales, implementarse como miembros del tipo de operando izquierdo. Sin embargo, sus operandos izquierdos son flujos de la biblioteca est&amp;aacute;ndar, y aunque la mayor&amp;iacute;a de los operadores de salida y entrada de flujo definidos por la biblioteca est&amp;aacute;ndar se definen como miembros de las clases de flujo, cuando implementa operaciones de salida y entrada para sus propios tipos, no puede cambiar los tipos de flujo de la biblioteca est&amp;aacute;ndar. Es por eso que necesita implementar estos operadores para sus propios tipos como funciones que no son miembros. Las formas can&amp;oacute;nicas de los dos son estas:</target>
        </trans-unit>
        <trans-unit id="e742cb5d317ff843e4d40ebac2e6b8a129167116" translate="yes" xml:space="preserve">
          <source>The syntax for overloading the remaining binary boolean operators (&lt;code&gt;||&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) follows the rules of the comparison operators. However, it is &lt;em&gt;very&lt;/em&gt; unlikely that you would find a reasonable use case for these&lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">La sintaxis para sobrecargar los operadores booleanos binarios restantes ( &lt;code&gt;||&lt;/code&gt; , &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ) sigue las reglas de los operadores de comparaci&amp;oacute;n. Sin embargo, es &lt;em&gt;muy&lt;/em&gt; poco probable que encuentre un caso de uso razonable para estos &lt;sup&gt;2&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="43b92ed49085008f088b6b20f2dff39e47616f03" translate="yes" xml:space="preserve">
          <source>The unary address-of operator should never be overloaded.</source>
          <target state="translated">La dirección unaria del operador nunca debe ser sobrecargada.</target>
        </trans-unit>
        <trans-unit id="4e69702ccb56e46c30152ff70d54bcafe1d3b79d" translate="yes" xml:space="preserve">
          <source>The unary increment and decrement operators come in both prefix and postfix flavor. To tell one from the other, the postfix variants take an additional dummy int argument. If you overload increment or decrement, be sure to always implement both prefix and postfix versions.
Here is the canonical implementation of increment, decrement follows the same rules:</source>
          <target state="translated">Los operadores de incremento y decremento unario vienen en sabor de prefijo y postfijo.Para distinguir uno del otro,las variantes de postfix toman un argumento adicional de int ficticio.Si sobrecargas el incremento o el decremento,asegúrate de implementar siempre ambas versiones de prefijo y postfijo.Aquí está la implementación canónica de incrementos,decrementos sigue las mismas reglas:</target>
        </trans-unit>
        <trans-unit id="fafebafed54733670be4bdb8f0f077c58939e2eb" translate="yes" xml:space="preserve">
          <source>There's a lot to be said about assignment. However, most of it has already been said in &lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;GMan's famous Copy-And-Swap FAQ&lt;/a&gt;, so I'll skip most of it here, only listing the perfect assignment operator for reference:</source>
          <target state="translated">Hay mucho que decir sobre la asignaci&amp;oacute;n. Sin embargo, la mayor parte ya se ha dicho en &lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;las famosas preguntas frecuentes de Copiar e intercambiar de GMan, por lo que omitir&amp;eacute; la&lt;/a&gt; mayor parte aqu&amp;iacute;, solo enumerando el operador de asignaci&amp;oacute;n perfecto para referencia:</target>
        </trans-unit>
        <trans-unit id="7d5a6745e57fd584e32c48350df5cf7b6c97a053" translate="yes" xml:space="preserve">
          <source>Throughout the C++ standard library, function objects are always copied. Your own function objects should therefore be cheap to copy. If a function object absolutely needs to use data which is expensive to copy, it is better to store that data elsewhere and have the function object refer to it.</source>
          <target state="translated">En toda la biblioteca estándar de C++,los objetos de función siempre se copian.Por lo tanto,los objetos de función propios deberían ser baratos de copiar.Si un objeto de función necesita absolutamente utilizar datos que son caros de copiar,es mejor almacenar esos datos en otro lugar y hacer que el objeto de función se refiera a él.</target>
        </trans-unit>
        <trans-unit id="d096ebff9a794e9192a29686de4113ddeb056fa5" translate="yes" xml:space="preserve">
          <source>To invoke the explicit cast operator, you have to use &lt;code&gt;static_cast&lt;/code&gt;, a C-style cast, or a constructor style cast ( i.e. &lt;code&gt;T(value)&lt;/code&gt; ).</source>
          <target state="translated">Para invocar el operador de &lt;code&gt;static_cast&lt;/code&gt; expl&amp;iacute;cito, debe usar static_cast , una conversi&amp;oacute;n de estilo C o una conversi&amp;oacute;n de estilo de constructor (es decir, &lt;code&gt;T(value)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d8020d5538e9765d456a055193c573dc6171a136" translate="yes" xml:space="preserve">
          <source>To overload the global new and delete, simply replace the pre-defined operators of the standard library with our own. However, this rarely ever needs to be done.</source>
          <target state="translated">Para sobrecargar el nuevo global y eliminarlo,simplemente reemplace los operadores predefinidos de la biblioteca estándar por los nuestros.Sin embargo,esto raramente necesita hacerse.</target>
        </trans-unit>
        <trans-unit id="f5a792933066b9a9e2ac32f6f06b8c7c9b9c310a" translate="yes" xml:space="preserve">
          <source>Unary arithmetic operators</source>
          <target state="translated">Operadores aritméticos unitarios</target>
        </trans-unit>
        <trans-unit id="97ec28a8a9251fa1cb37b5b5d4e4408efdf02f8b" translate="yes" xml:space="preserve">
          <source>Unless you do not want users of your class to be able to change data elements returned by &lt;code&gt;operator[]&lt;/code&gt; (in which case you can omit the non-const variant), you should always provide both variants of the operator.</source>
          <target state="translated">A menos que no desee que los usuarios de su clase puedan cambiar los elementos de datos devueltos por el &lt;code&gt;operator[]&lt;/code&gt; (en cuyo caso puede omitir la variante no constante), siempre debe proporcionar ambas variantes del operador.</target>
        </trans-unit>
        <trans-unit id="4f28b9e24ebd784a9282ef8b29671b29756db1ae" translate="yes" xml:space="preserve">
          <source>Unlike implicit conversion operators, explicit conversion operators will never kick in when you don't expect them to.  The following is a simple class with an explicit conversion operator:</source>
          <target state="translated">A diferencia de los operadores de conversión implícitos,los operadores de conversión explícitos nunca se activarán cuando no se espera que lo hagan.La siguiente es una clase simple con un operador de conversión explícito:</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="7a38cdb12264364efc9478d485dd17ef42cde482" translate="yes" xml:space="preserve">
          <source>What are the basic rules and idioms for operator overloading</source>
          <target state="translated">¿Cuáles son las reglas básicas y los modismos para la sobrecarga del operador</target>
        </trans-unit>
        <trans-unit id="919377897e90c6bc8567a475cc62dd42597b7240" translate="yes" xml:space="preserve">
          <source>When implementing &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, manually setting the stream&amp;rsquo;s state is only necessary when the reading itself succeeded, but the result is not what would be expected.</source>
          <target state="translated">Al implementar el &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; , establecer manualmente el estado de la secuencia solo es necesario cuando la lectura en s&amp;iacute; misma tuvo &amp;eacute;xito, pero el resultado no es lo que se esperar&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="f20d7d9e25980a2df4f9c97a919afac20cc35de6" translate="yes" xml:space="preserve">
          <source>When it comes to operator overloading in C++, there are &lt;strong&gt;&lt;em&gt;three basic rules you should follow&lt;/em&gt;&lt;/strong&gt;. As with all such rules, there are indeed exceptions. Sometimes people have deviated from them and the outcome was not bad code, but such positive deviations are few and far between. At the very least, 99 out of 100 such deviations I have seen were unjustified. However, it might just as well have been 999 out of 1000. So you&amp;rsquo;d better stick to the following rules.</source>
          <target state="translated">Cuando se trata de la sobrecarga del operador en C ++, hay &lt;strong&gt;&lt;em&gt;tres reglas b&amp;aacute;sicas que debe seguir&lt;/em&gt;&lt;/strong&gt; . Al igual que con todas esas reglas, de hecho hay excepciones. A veces las personas se han desviado de ellos y el resultado no fue un mal c&amp;oacute;digo, pero tales desviaciones positivas son pocas y distantes. Como m&amp;iacute;nimo, 99 de cada 100 desviaciones que he visto no estaban justificadas. Sin embargo, bien podr&amp;iacute;a haber sido 999 de 1000. Por lo tanto, es mejor que cumpla con las siguientes reglas.</target>
        </trans-unit>
        <trans-unit id="37f76d33dcd336dfa74e1a497620ddd35c0ff0ac" translate="yes" xml:space="preserve">
          <source>Why can't &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; function for streaming objects to &lt;code&gt;std::cout&lt;/code&gt; or to a file be a member function?</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; la funci&amp;oacute;n &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; para transmitir objetos a &lt;code&gt;std::cout&lt;/code&gt; o un archivo no puede ser una funci&amp;oacute;n miembro?</target>
        </trans-unit>
        <trans-unit id="39d720caae827c7c0b9c7f668fcb211ea7a7c1d0" translate="yes" xml:space="preserve">
          <source>You can also overload &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; with other arguments. As with the additional argument for placement new, these arguments are also listed within parentheses after the keyword &lt;code&gt;new&lt;/code&gt;. Merely for historical reasons, such variants are often also called placement new, even if their arguments are not for placing an object at a specific address.</source>
          <target state="translated">Tambi&amp;eacute;n puede sobrecargar &lt;code&gt;new&lt;/code&gt; y &lt;code&gt;delete&lt;/code&gt; con otros argumentos. Al igual que con el argumento adicional para la colocaci&amp;oacute;n de nuevos, estos argumentos tambi&amp;eacute;n se enumeran entre par&amp;eacute;ntesis despu&amp;eacute;s de la palabra clave &lt;code&gt;new&lt;/code&gt; . Simplemente por razones hist&amp;oacute;ricas, tales variantes a menudo tambi&amp;eacute;n se llaman colocaci&amp;oacute;n nueva, incluso si sus argumentos no son para colocar un objeto en una direcci&amp;oacute;n espec&amp;iacute;fica.</target>
        </trans-unit>
        <trans-unit id="7528cb53fda223cd367475e992221703ed9fdc71" translate="yes" xml:space="preserve">
          <source>You cannot change the meaning of operators for built-in types in C++, operators can only be overloaded for user-defined types&lt;sup&gt;1&lt;/sup&gt;. That is, at least one of the operands has to be of a user-defined type. As with other overloaded functions, operators can be overloaded for a certain set of parameters only once.</source>
          <target state="translated">No puede cambiar el significado de los operadores para los tipos integrados en C ++, los operadores solo se pueden sobrecargar para los tipos &lt;sup&gt;1&lt;/sup&gt; definidos por el usuario. Es decir, al menos uno de los operandos debe ser de un tipo definido por el usuario. Al igual que con otras funciones sobrecargadas, los operadores pueden sobrecargarse para un determinado conjunto de par&amp;aacute;metros solo una vez.</target>
        </trans-unit>
        <trans-unit id="9e8e2f1d8db91fd84d40e7c67b7a78f2b63f8119" translate="yes" xml:space="preserve">
          <source>You will be able to use:</source>
          <target state="translated">Usted será capaz de usar:</target>
        </trans-unit>
        <trans-unit id="216956e088f4509625dab4a52801ab781c0e31b0" translate="yes" xml:space="preserve">
          <source>and you want to overload the increment and decrement operators for it, you cannot do this as a member functions, since in C++, enum types cannot have member functions. So you have to overload it as a free function. And &lt;code&gt;operator&amp;lt;()&lt;/code&gt; for a class template nested within a class template is much easier to write and read when done as a member function inline in the class definition. But these are indeed rare exceptions.</source>
          <target state="translated">y desea sobrecargar los operadores de incremento y decremento, no puede hacer esto como funciones miembro, ya que en C ++, los tipos de enumeraci&amp;oacute;n no pueden tener funciones miembro. Por lo tanto, debe sobrecargarlo como una funci&amp;oacute;n gratuita. Y el &lt;code&gt;operator&amp;lt;()&lt;/code&gt; para una plantilla de clase anidada dentro de una plantilla de clase es mucho m&amp;aacute;s f&amp;aacute;cil de escribir y leer cuando se hace como una funci&amp;oacute;n miembro en l&amp;iacute;nea en la definici&amp;oacute;n de clase. Pero estas son, de hecho, raras excepciones.</target>
        </trans-unit>
        <trans-unit id="a8876728833443b597fddaff948d8ef7d8b6d6fb" translate="yes" xml:space="preserve">
          <source>arithmetic operators: &lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt; and &lt;code&gt;+=&lt;/code&gt;&lt;code&gt;-=&lt;/code&gt;&lt;code&gt;*=&lt;/code&gt;&lt;code&gt;/=&lt;/code&gt;&lt;code&gt;%=&lt;/code&gt; (all binary infix); &lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt; (unary prefix); &lt;code&gt;++&lt;/code&gt;&lt;code&gt;--&lt;/code&gt; (unary prefix and postfix)</source>
          <target state="translated">operadores aritm&amp;eacute;ticos: &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; y &lt;code&gt;+=&lt;/code&gt; &lt;code&gt;-=&lt;/code&gt; &lt;code&gt;*=&lt;/code&gt; &lt;code&gt;/=&lt;/code&gt; &lt;code&gt;%=&lt;/code&gt; (todos los infijos binarios); &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; (prefijo unario); &lt;code&gt;++&lt;/code&gt; &lt;code&gt;--&lt;/code&gt; (prefijo unario y postfix)</target>
        </trans-unit>
        <trans-unit id="5a5099434f36ef0494a734223946a9f17c108f31" translate="yes" xml:space="preserve">
          <source>bit manipulation: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;amp;=&lt;/code&gt;&lt;code&gt;|=&lt;/code&gt;&lt;code&gt;^=&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; (all binary infix); &lt;code&gt;~&lt;/code&gt; (unary prefix)</source>
          <target state="translated">manipulaci&amp;oacute;n de bits: &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;amp;=&lt;/code&gt; &lt;code&gt;|=&lt;/code&gt; &lt;code&gt;^=&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; (todo infijo binario); &lt;code&gt;~&lt;/code&gt; (prefijo unario)</target>
        </trans-unit>
        <trans-unit id="f93156b243321d1cbdfc482620959e7bf4ed1bf9" translate="yes" xml:space="preserve">
          <source>boolean algebra: &lt;code&gt;==&lt;/code&gt;&lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (all binary infix); &lt;code&gt;!&lt;/code&gt; (unary prefix)</source>
          <target state="translated">&amp;aacute;lgebra booleana: &lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &amp;gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;||&lt;/code&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (todo infijo binario); &lt;code&gt;!&lt;/code&gt; (prefijo unario)</target>
        </trans-unit>
        <trans-unit id="dfc056418cb491e7998e6f590c77a4dc4c43f3cf" translate="yes" xml:space="preserve">
          <source>implicit conversion operators</source>
          <target state="translated">operadores de conversión implícitos</target>
        </trans-unit>
        <trans-unit id="5a8540091878a4d7ea3c96c572645994df60c30a" translate="yes" xml:space="preserve">
          <source>memory management: &lt;code&gt;new&lt;/code&gt;&lt;code&gt;new[]&lt;/code&gt;&lt;code&gt;delete&lt;/code&gt;&lt;code&gt;delete[]&lt;/code&gt;</source>
          <target state="translated">gesti&amp;oacute;n de memoria: &lt;code&gt;new&lt;/code&gt; &lt;code&gt;new[]&lt;/code&gt; &lt;code&gt;delete&lt;/code&gt; &lt;code&gt;delete[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81b2763337b529b56fc828c4327b362d3740d4ac" translate="yes" xml:space="preserve">
          <source>miscellany: &lt;code&gt;=&lt;/code&gt;&lt;code&gt;[]&lt;/code&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;code&gt;-&amp;gt;*&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;  (all binary infix); &lt;code&gt;*&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; (all unary prefix) &lt;code&gt;()&lt;/code&gt; (function call, n-ary infix)</source>
          <target state="translated">miscel&amp;aacute;nea: &lt;code&gt;=&lt;/code&gt; &lt;code&gt;[]&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;code&gt;-&amp;gt;*&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; (todos los infijos binarios); &lt;code&gt;*&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; (todos los prefijos unarios) &lt;code&gt;()&lt;/code&gt; (llamada a funci&amp;oacute;n, infijo n-ario)</target>
        </trans-unit>
        <trans-unit id="c824aa9ad53891d9b5e9c118b4ffd5c133b27edd" translate="yes" xml:space="preserve">
          <source>which is very intuitive.</source>
          <target state="translated">que es muy intuitivo.</target>
        </trans-unit>
        <trans-unit id="0b24478dfb20b5a8671b13a521b4573226f340db" translate="yes" xml:space="preserve">
          <source>which is very non-intuitive.</source>
          <target state="translated">lo cual es muy poco intuitivo.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
