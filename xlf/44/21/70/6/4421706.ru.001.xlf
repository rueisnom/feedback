<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/4421706">
    <body>
      <group id="4421706">
        <trans-unit id="ebdeccffb9c593d5235ca8b75391edfe495210fe" translate="yes" xml:space="preserve">
          <source>(However, &lt;em&gt;if&lt;/em&gt; you make an exception, do not forget the issue of &lt;code&gt;const&lt;/code&gt;-ness for the operand that, for member functions, becomes the implicit &lt;code&gt;this&lt;/code&gt; argument. If the operator as a non-member function would take its left-most argument as a &lt;code&gt;const&lt;/code&gt; reference, the same operator as a member function needs to have a &lt;code&gt;const&lt;/code&gt; at the end to make &lt;code&gt;*this&lt;/code&gt; a &lt;code&gt;const&lt;/code&gt; reference.)</source>
          <target state="translated">(Однако, &lt;em&gt;если&lt;/em&gt; вы сделаете исключение, не забудьте проблему константности для операнда, который для функций-членов становится неявным аргументом &lt;code&gt;this&lt;/code&gt; . Если оператор в качестве функции, не являющейся членом, будет принимать свой самый левый аргумент как &lt;code&gt;const&lt;/code&gt; ссылка, тот же оператор, что и у функции-члена, должен иметь &lt;code&gt;const&lt;/code&gt; в конце, чтобы сделать &lt;code&gt;*this&lt;/code&gt; &lt;code&gt;const&lt;/code&gt; ссылку.)</target>
        </trans-unit>
        <trans-unit id="a932915cc63f83451fad890ba330a2fe5b0e1013" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;operator+=&lt;/code&gt; returns its result per reference, while &lt;code&gt;operator+&lt;/code&gt; returns a copy of its result. Of course, returning a reference is usually more efficient than returning a copy, but in the case of &lt;code&gt;operator+&lt;/code&gt;, there is no way around the copying. When you write &lt;code&gt;a + b&lt;/code&gt;, you expect the result to be a new value, which is why &lt;code&gt;operator+&lt;/code&gt; has to return a new value.&lt;sup&gt;3&lt;/sup&gt;
Also note that &lt;code&gt;operator+&lt;/code&gt; takes its left operand &lt;strong&gt;&lt;em&gt;by copy&lt;/em&gt;&lt;/strong&gt; rather than by const reference. The reason for this is the same as the reason giving for &lt;code&gt;operator=&lt;/code&gt; taking its argument per copy.</source>
          <target state="translated">&lt;code&gt;operator+=&lt;/code&gt; возвращает свой результат по ссылке, а &lt;code&gt;operator+&lt;/code&gt; возвращает копию своего результата. Конечно, возврат ссылки обычно более эффективен, чем возврат копии, но в случае &lt;code&gt;operator+&lt;/code&gt; нет способа обойти копирование. Когда вы пишете &lt;code&gt;a + b&lt;/code&gt; , вы ожидаете, что результатом будет новое значение, поэтому &lt;code&gt;operator+&lt;/code&gt; должен возвращать новое значение. &lt;sup&gt;3&lt;/sup&gt; Также обратите внимание, что &lt;code&gt;operator+&lt;/code&gt; берет свой левый операнд &lt;strong&gt;&lt;em&gt;по копии,&lt;/em&gt;&lt;/strong&gt; а не по константной ссылке. Причина этого та же, что и для &lt;code&gt;operator=&lt;/code&gt; принимающего аргумент за копию.</target>
        </trans-unit>
        <trans-unit id="338efc32f9cb83e0dd8331e45788ecc57787ef85" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Operators are related to each other&lt;/em&gt; and to other operations. If your type supports &lt;code&gt;a + b&lt;/code&gt;, users will expect to be able to call &lt;code&gt;a += b&lt;/code&gt;, too. If it supports prefix increment &lt;code&gt;++a&lt;/code&gt;, they will expect &lt;code&gt;a++&lt;/code&gt; to work as well. If they can check whether &lt;code&gt;a &amp;lt; b&lt;/code&gt;, they will most certainly expect to also to be able to check whether &lt;code&gt;a &amp;gt; b&lt;/code&gt;. If they can copy-construct your type, they expect assignment to work as well.</source>
          <target state="translated">&lt;em&gt;Операторы связаны друг с другом&lt;/em&gt; и с другими операциями. Если ваш тип поддерживает &lt;code&gt;a + b&lt;/code&gt; , пользователи ожидают, что смогут также вызвать &lt;code&gt;a += b&lt;/code&gt; . Если он поддерживает префикс приращения &lt;code&gt;++a&lt;/code&gt; , они ожидают, что &lt;code&gt;a++&lt;/code&gt; будет работать. Если они смогут проверить, &lt;code&gt;a &amp;lt; b&lt;/code&gt; ли a &amp;lt;b , они наверняка также ожидают, что они смогут проверить, &lt;code&gt;a &amp;gt; b&lt;/code&gt; ли a&amp;gt; b . Если они могут копировать-конструировать ваш тип, они ожидают, что назначение также будет работать.</target>
        </trans-unit>
        <trans-unit id="aa5bd5f45a48b221e418619d95cdcc6b6c6e44a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Always provide all out of a set of related operations.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Всегда предоставляйте все из набора связанных операций.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9489b9f4b1bac05ddb2354a51560ad5b088a8f70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Always stick to the operator&amp;rsquo;s well-known semantics.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Всегда придерживайтесь известной семантики оператора.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="09e12a464818e248f8bb9ed843a88d4b181a6616" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Whenever the meaning of an operator is not obviously clear and undisputed, it should not be overloaded.&lt;/em&gt;&lt;/strong&gt;&lt;em&gt;Instead, provide a function with a well-chosen name.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Всякий раз, когда значение оператора не является явно ясным и бесспорным, его не следует перегружать.&lt;/em&gt;&lt;/strong&gt; &lt;em&gt;Вместо этого предоставьте функцию с правильно выбранным именем.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="620ae72342c6c376f4c4a1a08f78905e1878296d" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;
&lt;em&gt;(Note: This is meant to be an entry to &lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;Stack Overflow's C++ FAQ&lt;/a&gt;. If you want to critique the idea of providing an FAQ in this form, then &lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;the posting on meta that started all this&lt;/a&gt; would be the place to do that. Answers to that question are monitored in the &lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;C++ chatroom&lt;/a&gt;, where the FAQ idea started out in the first place, so your answer is very likely to get read by those who came up with the idea.)&lt;/em&gt;
&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;em&gt;(Примечание. Предполагается, что это будет вход в &lt;a href=&quot;https://stackoverflow.com/questions/tagged/c++-faq&quot;&gt;FAQ по C ++&lt;/a&gt; в Stack Overflow . Если вы хотите критиковать идею предоставления FAQ в этой форме, то &lt;a href=&quot;https://meta.stackexchange.com/questions/68647/setting-up-a-faq-for-the-c-tag&quot;&gt;публикация в meta, с которой все это началось,&lt;/a&gt; будет местом, где это можно сделать. Ответы на Этот вопрос отслеживается в &lt;a href=&quot;http://chat.stackoverflow.com/rooms/10/c-lounge&quot;&gt;чате C ++&lt;/a&gt; , где идея FAQ возникла в первую очередь, поэтому ваш ответ, скорее всего, будет прочитан теми, кто придумал эту идею.)&lt;/em&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="14f3efc38fad533ae15f4148f1a61fdd2dd11ee7" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Note the &lt;code&gt;const&lt;/code&gt; at the end.)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;(Обратите внимание на &lt;code&gt;const&lt;/code&gt; в конце.)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="c0ca582ae5768203060cbf81ae5d446fdbadce13" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;As with all rules of thumb, sometimes there might be reasons to break this one, too. If so, do not forget that the left-hand operand of the binary comparison operators, which for member functions will be &lt;code&gt;*this&lt;/code&gt;, needs to be &lt;code&gt;const&lt;/code&gt;, too. So a comparison operator implemented as a member function would have to have this signature:&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; &lt;sub&gt;Как и все эмпирические правила, иногда могут быть и причины нарушать это правило.&lt;/sub&gt; &lt;sub&gt;Если это так, не забывайте, что левый операнд бинарных операторов сравнения, который для функций-членов будет &lt;code&gt;*this&lt;/code&gt; , также должен быть &lt;code&gt;const&lt;/code&gt; .&lt;/sub&gt; &lt;sub&gt;Таким образом, оператор сравнения, реализованный как функция-член, должен иметь эту сигнатуру:&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="9a7c0de90272aa0b4c0f2ec37dbe7d8ba11b179a" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;1&lt;/sup&gt;&lt;sub&gt;The term &amp;ldquo;user-defined&amp;rdquo; might be slightly misleading. C++ makes the distinction between built-in types and user-defined types. To the former belong for example int, char, and double; to the latter belong all struct, class, union, and enum types, including those from the standard library, even though they are not, as such, defined by users.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;1&lt;/sup&gt; &lt;sub&gt;Термин &amp;laquo;пользовательский&amp;raquo; может вводить в заблуждение.&lt;/sub&gt; &lt;sub&gt;C ++ делает различие между встроенными типами и пользовательскими типами.&lt;/sub&gt; &lt;sub&gt;К первым относятся, например, int, char и double;&lt;/sub&gt; &lt;sub&gt;к последним относятся все типы struct, class, union и enum, в том числе из стандартной библиотеки, даже если они не определены пользователями.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="4d522b0d5a3ee143d4b55a7eefa9657f18b4f0ea" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;Also note that the postfix variant does more work and is therefore less efficient to use than the prefix variant. This is a good reason to generally prefer prefix increment over postfix increment. While compilers can usually optimize away the additional work of postfix increment for built-in types, they might not be able to do the same for user-defined types (which could be something as innocently looking as a list iterator). Once you got used to do &lt;code&gt;i++&lt;/code&gt;, it becomes very hard to remember to do &lt;code&gt;++i&lt;/code&gt; instead when &lt;code&gt;i&lt;/code&gt; is not of a built-in type (plus you'd have to change code when changing a type), so it is better to make a habit of always using prefix increment, unless postfix is explicitly needed.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;Также обратите внимание, что постфиксный вариант выполняет больше работы и поэтому менее эффективен в использовании, чем префиксный вариант.&lt;/sub&gt; &lt;sub&gt;Это хорошая причина, как правило, предпочитать увеличение префикса над увеличением постфикса.&lt;/sub&gt; &lt;sub&gt;Хотя компиляторы обычно могут оптимизировать дополнительную работу приращения постфикса для встроенных типов, они могут быть не в состоянии сделать то же самое для пользовательских типов (которые могут выглядеть невинно, как итератор списка).&lt;/sub&gt; &lt;sub&gt;Как только вы привыкли делать &lt;code&gt;i++&lt;/code&gt; , становится очень трудно запомнить &lt;code&gt;++i&lt;/code&gt; вместо встроенного типа (плюс вам придется менять код при смене типа), поэтому лучше Возьмите за правило всегда использовать приращение префикса, если только постфикс не требуется явно.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="3f5b8f85cc67312e85c8eb294398952de5c9070e" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;It should be noted that the built-in version of &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; use shortcut semantics. While the user defined ones (because they are syntactic sugar for method calls) do not use shortcut semantics. User will expect these operators to have shortcut semantics, and their code may depend on it, Therefore it is highly advised NEVER to define them.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;Следует отметить, что встроенная версия &lt;code&gt;||&lt;/code&gt; &lt;/sub&gt; &lt;sub&gt;и &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; использовать семантику ярлыков.&lt;/sub&gt; &lt;sub&gt;В то время как пользовательские (потому что они являются синтаксическим сахаром для вызовов методов), не используют сокращенную семантику.&lt;/sub&gt; &lt;sub&gt;Пользователь будет ожидать, что эти операторы будут иметь семантику ярлыков, и их код может зависеть от этого, поэтому настоятельно рекомендуется НИКОГДА не определять их.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="e3c92f172f9d6a21e1edbee610bd748896095eab" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;2&lt;/sup&gt;&lt;sub&gt;This is covered in &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/4421729#4421729&quot;&gt;a later part&lt;/a&gt; of this FAQ.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;2&lt;/sup&gt; &lt;sub&gt;Это рассматривается в &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/4421729#4421729&quot;&gt;более поздней части&lt;/a&gt; этого FAQ.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2d81bca5cf7dc6ada15492470100c9698c01c407" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3&lt;/sup&gt;&lt;sub&gt;Again, the lesson to be taken from this is that &lt;code&gt;a += b&lt;/code&gt; is, in general, more efficient than &lt;code&gt;a + b&lt;/code&gt; and should be preferred if possible.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;3&lt;/sup&gt; &lt;sub&gt;Опять же, урок, который следует извлечь из этого, заключается в том, что &lt;code&gt;a += b&lt;/code&gt; , в целом, более эффективен, чем &lt;code&gt;a + b&lt;/code&gt; и его следует по возможности использовать предпочтительнее.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="5cca32e7a575b9db399f83cf13cfe08fee093572" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;3&lt;/sup&gt;&lt;sub&gt;The &lt;code&gt;@&lt;/code&gt; is not a valid operator in C++ which is why I use it as a placeholder.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;3&lt;/sup&gt; &lt;sub&gt; &lt;code&gt;@&lt;/code&gt; не является допустимым оператором в C ++, поэтому я использую его как заполнитель.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="fb4e0ac4049821674fc6813ec9ef8cfd305f5ca1" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;4&lt;/sup&gt;&lt;sub&gt;The only ternary operator in C++ cannot be overloaded and the only n-ary operator must always be implemented as a member function.&lt;/sub&gt;</source>
          <target state="translated">&lt;sup&gt;4&lt;/sup&gt; &lt;sub&gt;Единственный троичный оператор в C ++ не может быть перегружен, и единственный n-арный оператор всегда должен быть реализован как функция-член.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="276a8f6944c21a071705fa227dcf9ba993594a29" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;strong&gt;&lt;em&gt;Note:&lt;/em&gt;&lt;/strong&gt; This only deals with the &lt;strong&gt;&lt;em&gt;syntax&lt;/em&gt;&lt;/strong&gt; of overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, not with the &lt;strong&gt;&lt;em&gt;implementation&lt;/em&gt;&lt;/strong&gt; of such overloaded operators. I think that the semantics of overloading &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7149461/&quot;&gt;&lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; deserve their own FAQ&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;, within the topic of operator overloading I can never do it justice.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;strong&gt;&lt;em&gt;Примечание.&lt;/em&gt;&lt;/strong&gt; Это касается только &lt;strong&gt;&lt;em&gt;синтаксиса&lt;/em&gt;&lt;/strong&gt; перегрузки &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;delete&lt;/code&gt; , а не &lt;strong&gt;&lt;em&gt;реализации&lt;/em&gt;&lt;/strong&gt; таких перегруженных операторов.&lt;/sup&gt; &lt;sup&gt;Я думаю, что семантика перегрузки &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/7149461/&quot;&gt; &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;delete&lt;/code&gt; заслуживает отдельного FAQ&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; , в рамках темы перегрузки операторов я никогда не смогу отдать должное.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="421a43341da00165d391cdef2aecb500589bd6e0" translate="yes" xml:space="preserve">
          <source>According to our rules of thumb, &lt;code&gt;+&lt;/code&gt; and its companions should be non-members, while their compound assignment counterparts (&lt;code&gt;+=&lt;/code&gt; etc.), changing their left argument, should be a member. Here is the exemplary code for &lt;code&gt;+=&lt;/code&gt; and &lt;code&gt;+&lt;/code&gt;; the other binary arithmetic operators should be implemented in the same way:</source>
          <target state="translated">Согласно нашим практическим правилам, &lt;code&gt;+&lt;/code&gt; и его компаньоны не должны быть членами, в то время как их составные аналоги присваивания ( &lt;code&gt;+=&lt;/code&gt; и т. Д.), Изменяя свой левый аргумент, должны быть членами. Вот примерный код для &lt;code&gt;+=&lt;/code&gt; и &lt;code&gt;+&lt;/code&gt; ; другие двоичные арифметические операторы должны быть реализованы таким же образом:</target>
        </trans-unit>
        <trans-unit id="f3952c5c15a5c4f059ce1db8233deaaeda4f28a8" translate="yes" xml:space="preserve">
          <source>Among the operators that can be overloaded in C++ are these:</source>
          <target state="translated">Среди операторов,которые могут быть перегружены в C++,можно назвать следующие:</target>
        </trans-unit>
        <trans-unit id="be759ec493e1844e284eba0ba8febc88ff79e21f" translate="yes" xml:space="preserve">
          <source>An implicit conversion operator allows the compiler to implicitly convert (like the conversion between &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;long&lt;/code&gt;) the value of a user-defined type to some other type.</source>
          <target state="translated">Оператор неявного преобразования позволяет компилятору неявно преобразовывать (например, преобразование между &lt;code&gt;int&lt;/code&gt; и &lt;code&gt;long&lt;/code&gt; ) значение определенного пользователем типа в некоторый другой тип.</target>
        </trans-unit>
        <trans-unit id="6104f39ed22a2cd32e98536a3447a01c4b9f4781" translate="yes" xml:space="preserve">
          <source>Arithmetic Operators</source>
          <target state="translated">арифметические операторы</target>
        </trans-unit>
        <trans-unit id="aecc43fc2fe547cd50965b231d35b4682af12f07" translate="yes" xml:space="preserve">
          <source>Array Subscripting</source>
          <target state="translated">Подписка на массив</target>
        </trans-unit>
        <trans-unit id="67c1b1f3ed026dea13ed68968e94e0a7d893d152" translate="yes" xml:space="preserve">
          <source>Assignment Operator</source>
          <target state="translated">Назначение оператора</target>
        </trans-unit>
        <trans-unit id="93070e8acd1b2a07488cdde5f031a65133a6cf12" translate="yes" xml:space="preserve">
          <source>At first this seems very helpful, but the problem with this is that the implicit conversion even kicks in when it isn&amp;rsquo;t expected to. In the following code, &lt;code&gt;void f(const char*)&lt;/code&gt; will be called because &lt;code&gt;my_string()&lt;/code&gt; is not an &lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;lvalue&lt;/a&gt;, so the first does not match:</source>
          <target state="translated">Поначалу это кажется очень полезным, но проблема в том, что неявное преобразование включается даже тогда, когда оно не ожидается. В следующем коде &lt;code&gt;void f(const char*)&lt;/code&gt; будет вызван, потому что &lt;code&gt;my_string()&lt;/code&gt; не является &lt;a href=&quot;https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues&quot;&gt;lvalue&lt;/a&gt; , поэтому первое не совпадает:</target>
        </trans-unit>
        <trans-unit id="0ee8de3eebacd7c638e4729172a904422deca61b" translate="yes" xml:space="preserve">
          <source>Basically, the first and foremost rule for overloading operators, at its very heart, says: &lt;em&gt;Don&amp;rsquo;t do it&lt;/em&gt;. That might seem strange, because there is a lot to be known about operator overloading and so a lot of articles, book chapters, and other texts deal with all this. But despite this seemingly obvious evidence, &lt;em&gt;there are only a surprisingly few cases where operator overloading is appropriate&lt;/em&gt;. The reason is that actually it is hard to understand the semantics behind the application of an operator unless the use of the operator in the application domain is well known and undisputed. Contrary to popular belief, this is hardly ever the case.</source>
          <target state="translated">По сути, первое и главное правило перегрузки операторов в самом его сердце гласит: &lt;em&gt;не делайте этого&lt;/em&gt; . Это может показаться странным, потому что многое известно о перегрузке операторов, и поэтому многие статьи, главы книг и другие тексты имеют дело со всем этим. Но, несмотря на это, казалось бы, очевидное свидетельство, &lt;em&gt;есть только удивительно немного случаев, когда перегрузка оператора является уместной&lt;/em&gt; . Причина в том, что на самом деле трудно понять семантику, лежащую в основе применения оператора, если использование оператора в области приложения хорошо известно и неоспоримо. Вопреки распространенному мнению, это вряд ли когда-либо.</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4d0acd385943a19aff1dd079c0d333f73eeda130" translate="yes" xml:space="preserve">
          <source>Because the compiler will not cast &quot;past&quot; &lt;code&gt;bool&lt;/code&gt;, explicit conversion operators now remove the need for the &lt;a href=&quot;http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool&quot;&gt;Safe Bool idiom&lt;/a&gt;.   For example, smart pointers before C++11 used the Safe Bool idiom to prevent conversions to integral types.  In C++11, the smart pointers use an explicit operator instead because the compiler is not allowed to implicitly convert to an integral type after it explicitly converted a type to bool.</source>
          <target state="translated">Поскольку компилятор не будет приводить &amp;laquo;прошлые&amp;raquo; &lt;code&gt;bool&lt;/code&gt; , операторы явного преобразования теперь устраняют необходимость в &lt;a href=&quot;http://en.wikibooks.org/wiki/More_C%2B%2B_Idioms/Safe_bool&quot;&gt;идиоме Safe Bool&lt;/a&gt; . Например, умные указатели до C ++ 11 использовали идиому Safe Bool для предотвращения преобразований в целочисленные типы. В C ++ 11 интеллектуальные указатели вместо этого используют явный оператор, потому что компилятору не разрешается неявно преобразовывать в целочисленный тип после того, как он явно преобразовал тип в bool.</target>
        </trans-unit>
        <trans-unit id="71c42caac2d9ddf4204de8698243a11cfa04f910" translate="yes" xml:space="preserve">
          <source>Beginners easily get this wrong and even experienced C++ programmers are sometimes surprised because the compiler picks an overload they didn&amp;rsquo;t suspect.  These problems can be mitigated by explicit conversion operators.</source>
          <target state="translated">Начинающие легко ошибаются, и даже опытные программисты на C ++ иногда удивляются, потому что компилятор выбирает перегрузку, которую они не подозревали. Эти проблемы могут быть смягчены явными операторами преобразования.</target>
        </trans-unit>
        <trans-unit id="91150bd6516ac5f77628d936130ba9cf5ec13ae6" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operators</source>
          <target state="translated">двоичные арифметические операторы</target>
        </trans-unit>
        <trans-unit id="ae37c4e20a55a6ef0b50c1ce0e0f71802dbf0111" translate="yes" xml:space="preserve">
          <source>Bitshift Operators (used for Stream I/O)</source>
          <target state="translated">Операторы битсдвига (используются для входа в поток ввода-вывода)</target>
        </trans-unit>
        <trans-unit id="db69b09b584ceff2f01a827a244f4ddf0bcc8bfa" translate="yes" xml:space="preserve">
          <source>C++ allows new and delete operators to take additional arguments.</source>
          <target state="translated">C++позволяет операторам new и delete принимать дополнительные аргументы.</target>
        </trans-unit>
        <trans-unit id="cea3dbd2ef365f97b36a9803e63877ab2a2dcd07" translate="yes" xml:space="preserve">
          <source>C++ allows you to tune both of these operations: memory management and the construction/destruction of the object at the allocated memory. The latter is done by writing constructors and destructors for a class. Fine-tuning memory management is done by writing your own &lt;code&gt;operator new&lt;/code&gt; and &lt;code&gt;operator delete&lt;/code&gt;.</source>
          <target state="translated">C ++ позволяет настраивать обе эти операции: управление памятью и построение / уничтожение объекта в выделенной памяти. Последнее делается путем написания конструкторов и деструкторов для класса. Точная настройка управления памятью выполняется путем написания &lt;code&gt;operator new&lt;/code&gt; &lt;code&gt;operator delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53e1ae4928af9f305e18ff9d9d702bea83c43afc" translate="yes" xml:space="preserve">
          <source>C++ poses no limitations on the semantics of overloaded operators. Your compiler will happily accept code that implements the binary &lt;code&gt;+&lt;/code&gt; operator to subtract from its right operand. However, the users of such an operator would never suspect the expression &lt;code&gt;a + b&lt;/code&gt; to subtract &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;b&lt;/code&gt;. Of course, this supposes that the semantics of the operator in the application domain is undisputed.</source>
          <target state="translated">C ++ не накладывает ограничений на семантику перегруженных операторов. Ваш компилятор с радостью примет код, который реализует двоичный оператор &lt;code&gt;+&lt;/code&gt; , чтобы вычесть его из своего правого операнда. Однако пользователи такого оператора никогда не будут подозревать, что выражение &lt;code&gt;a + b&lt;/code&gt; вычитает &lt;code&gt;a&lt;/code&gt; из &lt;code&gt;b&lt;/code&gt; . Конечно, это предполагает, что семантика оператора в области приложения неоспорима.</target>
        </trans-unit>
        <trans-unit id="7c17731e50f62eea89cf01a119386ba15a466c77" translate="yes" xml:space="preserve">
          <source>Class-specific new and delete</source>
          <target state="translated">Новое и удалить по конкретному классу</target>
        </trans-unit>
        <trans-unit id="7266bf079b182acba7043970de462e41b2663d92" translate="yes" xml:space="preserve">
          <source>Common operators to overload</source>
          <target state="translated">Общие операторы для перегрузки</target>
        </trans-unit>
        <trans-unit id="9461d4c9f916ad7df5538225ed552fb6e7e3284b" translate="yes" xml:space="preserve">
          <source>Comparison operators</source>
          <target state="translated">Операторы сравнения</target>
        </trans-unit>
        <trans-unit id="d8ddbec0b26e694dbe2e4392c23c80e62413f2d4" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708&quot;&gt;The Three Basic Rules of Operator Overloading in C++&lt;/a&gt;.</source>
          <target state="translated">Перейдите к &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421708#4421708&quot;&gt;трем основным правилам перегрузки операторов в C ++&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a650afcae173aef7cbc03df980e79ab8dcfc031" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719#4421719&quot;&gt;Common operators to overload&lt;/a&gt;.</source>
          <target state="translated">Перейдите к &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421719#4421719&quot;&gt;общим операторам для перегрузки&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49e07535d312dbe3a4fc30e2d414ba6a141b3abe" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729&quot;&gt;The Decision between Member and Non-member&lt;/a&gt;.</source>
          <target state="translated">Перейдите к &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421729#4421729&quot;&gt;решению между членом и не членом&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="390e8f97087fe4c33287f0dec7d962032d84d2b0" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791#4421791&quot;&gt;Overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Продолжить &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading-in-c/4421791#4421791&quot;&gt;перегрузку &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0c4829881d2b9099fb960d607315a36454fc1c0d" translate="yes" xml:space="preserve">
          <source>Continue to &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725&quot;&gt;Conversion Operators&lt;/a&gt;</source>
          <target state="translated">Перейти к &lt;a href=&quot;https://stackoverflow.com/questions/4421706/operator-overloading/16615725#16615725&quot;&gt;операторам преобразования&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cce1bda201abe07a87309c10681fbc4836893a50" translate="yes" xml:space="preserve">
          <source>Conversion Operators</source>
          <target state="translated">Операторы преобразования</target>
        </trans-unit>
        <trans-unit id="97921336d267bc620b6817f8d0fbd3946c8e1724" translate="yes" xml:space="preserve">
          <source>Conversion Operators (also known as User Defined Conversions)</source>
          <target state="translated">Операторы преобразования (также известные как пользовательские преобразования)</target>
        </trans-unit>
        <trans-unit id="06916bcd529378cd7be8d494e6a076cdff280dfb" translate="yes" xml:space="preserve">
          <source>Explicit Conversion Operators (C++11)</source>
          <target state="translated">Операторы явного преобразования (C++11)</target>
        </trans-unit>
        <trans-unit id="bb0bf432160bebf9e28e99e45037098df491690e" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;operator-&amp;gt;*()&lt;/code&gt; see &lt;a href=&quot;https://stackoverflow.com/q/8777845/140719&quot;&gt;this question&lt;/a&gt;. It's rarely used and thus rarely ever overloaded. In fact, even iterators do not overload it.</source>
          <target state="translated">Для &lt;code&gt;operator-&amp;gt;*()&lt;/code&gt; см. &lt;a href=&quot;https://stackoverflow.com/q/8777845/140719&quot;&gt;Этот вопрос&lt;/a&gt; . Он редко используется и, следовательно, редко перегружается. На самом деле, даже итераторы не перегружают его.</target>
        </trans-unit>
        <trans-unit id="f6ea334ff6ce5f1423f350e93f69641ce7406130" translate="yes" xml:space="preserve">
          <source>For all operators where you have to choose to either implement them as a member function or a non-member function, &lt;strong&gt;&lt;em&gt;use the following rules of thumb&lt;/em&gt;&lt;/strong&gt; to decide:</source>
          <target state="translated">Для всех операторов, для которых вам необходимо выбрать их реализацию в качестве функции-члена или функции, не являющейся членом, &lt;strong&gt;&lt;em&gt;используйте следующие практические правила,&lt;/em&gt;&lt;/strong&gt; чтобы принять решение:</target>
        </trans-unit>
        <trans-unit id="d69d65276d05cacbd13652fa039509c5c7448719" translate="yes" xml:space="preserve">
          <source>For defining your own iterators or smart pointers, you have to overload the unary prefix dereference operator &lt;code&gt;*&lt;/code&gt; and the binary infix pointer member access operator &lt;code&gt;-&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Для определения ваших собственных итераторов или умных указателей вы должны перегрузить оператор разыменования унарного префикса &lt;code&gt;*&lt;/code&gt; и оператор доступа к двоичному инфиксному указателю &lt;code&gt;-&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1587e1394f773c588778fbe18bdd8ed62ff6821b" translate="yes" xml:space="preserve">
          <source>For the binary arithmetic operators, do not forget to obey the third basic rule operator overloading: If you provide &lt;code&gt;+&lt;/code&gt;, also provide &lt;code&gt;+=&lt;/code&gt;, if you provide &lt;code&gt;-&lt;/code&gt;, do not omit &lt;code&gt;-=&lt;/code&gt;, etc. Andrew Koenig is said to have been the first to observe that the compound assignment operators can be used as a base for their non-compound counterparts. That is, operator &lt;code&gt;+&lt;/code&gt; is implemented in terms of &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt; is implemented in terms of &lt;code&gt;-=&lt;/code&gt; etc.</source>
          <target state="translated">Для бинарных арифметических операторов не забывайте подчиняться перегрузке третьего оператора основного правила: если вы предоставляете &lt;code&gt;+&lt;/code&gt; , также предоставляете &lt;code&gt;+=&lt;/code&gt; , если вы предоставляете &lt;code&gt;-&lt;/code&gt; , не опускайте &lt;code&gt;-=&lt;/code&gt; и т. Д. Эндрю Кениг, как говорят, был первым заметить, что составные операторы присваивания могут использоваться в качестве основы для их несоставных аналогов. То есть оператор &lt;code&gt;+&lt;/code&gt; реализован в терминах &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; реализован в терминах &lt;code&gt;-=&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="25056cd4f19ab3cf2ddbe426ca4f88659c9ecb1f" translate="yes" xml:space="preserve">
          <source>Function call operator</source>
          <target state="translated">Оператор вызова функций</target>
        </trans-unit>
        <trans-unit id="266781763563b15feb1a51bb6a9014424ae1126a" translate="yes" xml:space="preserve">
          <source>Given that, you cannot use:</source>
          <target state="translated">Учитывая это,ты не можешь использовать:</target>
        </trans-unit>
        <trans-unit id="90be49000bdd6cb11fcaf3b36883081fc56eaccc" translate="yes" xml:space="preserve">
          <source>Global new and delete</source>
          <target state="translated">Глобальные новые и удалить</target>
        </trans-unit>
        <trans-unit id="40ccf2f37dd214c6d5991f8f2094c0e81dc4e65d" translate="yes" xml:space="preserve">
          <source>Here's an example of the syntax:</source>
          <target state="translated">Вот пример синтаксиса:</target>
        </trans-unit>
        <trans-unit id="2f19bc6ee55c37f3c7803fde5dc79430596476a8" translate="yes" xml:space="preserve">
          <source>However, the fact that you &lt;em&gt;can&lt;/em&gt; overload all of these does not mean you &lt;em&gt;should&lt;/em&gt; do so. See the basic rules of operator overloading.</source>
          <target state="translated">Однако тот факт, что вы &lt;em&gt;можете&lt;/em&gt; перегружать все это, не означает, что вы &lt;em&gt;должны&lt;/em&gt; это делать. Смотрите основные правила перегрузки операторов.</target>
        </trans-unit>
        <trans-unit id="d1df6c2555df05f2e2d7b30909ceaba1a04419ac" translate="yes" xml:space="preserve">
          <source>However, there is one exception to this:  The compiler is allowed to implicitly convert to &lt;code&gt;bool&lt;/code&gt;.  In addition, the compiler is not allowed to do another implicit conversion after it converts to &lt;code&gt;bool&lt;/code&gt; (a compiler is allowed to do 2 implicit conversions at a time, but only 1 user-defined conversion at max).</source>
          <target state="translated">Однако есть одно исключение: компилятору разрешено неявно преобразовывать в &lt;code&gt;bool&lt;/code&gt; . Кроме того, компилятору не разрешается делать другое неявное преобразование после его преобразования в &lt;code&gt;bool&lt;/code&gt; (компилятору разрешено делать 2 неявных преобразования за раз, но только 1 пользовательское преобразование при максимуме).</target>
        </trans-unit>
        <trans-unit id="52ab79f2235a5be84cd7d66fe9e8c1206c27da29" translate="yes" xml:space="preserve">
          <source>If a binary operator does &lt;strong&gt;&lt;em&gt;not&lt;/em&gt;&lt;/strong&gt; treat both of its operands &lt;strong&gt;&lt;em&gt;equally&lt;/em&gt;&lt;/strong&gt; (usually it will change its left operand), it might be useful to make it a &lt;strong&gt;&lt;em&gt;member&lt;/em&gt;&lt;/strong&gt; function of its left operand&amp;rsquo;s type, if it has to access the operand's private parts.</source>
          <target state="translated">Если бинарный оператор &lt;strong&gt;&lt;em&gt;не&lt;/em&gt;&lt;/strong&gt; обрабатывает оба своих операнда &lt;strong&gt;&lt;em&gt;одинаково&lt;/em&gt;&lt;/strong&gt; (обычно он меняет свой левый операнд), может быть полезно сделать его функцией- &lt;strong&gt;&lt;em&gt;членом&lt;/em&gt;&lt;/strong&gt; типа своего левого операнда, если он должен получить доступ к закрытым частям операнда.</target>
        </trans-unit>
        <trans-unit id="9dbf7e58fa487fdde1f10120a1e361214ac8d248" translate="yes" xml:space="preserve">
          <source>If a binary operator treats &lt;strong&gt;&lt;em&gt;both operands equally&lt;/em&gt;&lt;/strong&gt; (it leaves them unchanged), implement this operator as a &lt;strong&gt;&lt;em&gt;non-member&lt;/em&gt;&lt;/strong&gt; function.</source>
          <target state="translated">Если бинарный оператор обрабатывает &lt;strong&gt;&lt;em&gt;оба операнда одинаково&lt;/em&gt;&lt;/strong&gt; (он оставляет их без изменений), реализуйте этот оператор как функцию, &lt;strong&gt;&lt;em&gt;не являющуюся членом&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="ed6a13f07242d7d741efc0c6314f4777012e50e3" translate="yes" xml:space="preserve">
          <source>If it is a &lt;strong&gt;&lt;em&gt;unary operator&lt;/em&gt;&lt;/strong&gt;, implement it as a &lt;strong&gt;&lt;em&gt;member&lt;/em&gt;&lt;/strong&gt; function.</source>
          <target state="translated">Если это &lt;strong&gt;&lt;em&gt;унарный оператор&lt;/em&gt;&lt;/strong&gt; , реализуйте его как функцию- &lt;strong&gt;&lt;em&gt;член&lt;/em&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="262c7f3eacf6b4b4a482e67f29ed9ce4d067684f" translate="yes" xml:space="preserve">
          <source>If value_type is known to refer to a built-in type, the const variant of the operator should better return a copy instead of a const reference:</source>
          <target state="translated">Если известно,что тип value_относится к встроенному типу,то вариант const оператора лучше возвращать копию,а не const ссылку:</target>
        </trans-unit>
        <trans-unit id="f4c82304b319df56b3a1e32bbe46b626dd2db4cf" translate="yes" xml:space="preserve">
          <source>If you define it as a non-member function,</source>
          <target state="translated">Если вы определите ее как функцию,не являющуюся членом,</target>
        </trans-unit>
        <trans-unit id="c3222f784f51643651a73e25ba26b59a34a1a97e" translate="yes" xml:space="preserve">
          <source>If you overload &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;, you should consider overloading the array variants, too.</source>
          <target state="translated">Если вы перегружаете &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;delete&lt;/code&gt; , вы должны также рассмотреть возможность перегрузки вариантов массива.</target>
        </trans-unit>
        <trans-unit id="f13af45755f6d4b1682363cc396a98d01a7f9a22" translate="yes" xml:space="preserve">
          <source>If you overload &lt;code&gt;operator new&lt;/code&gt;, you should always also overload the matching &lt;code&gt;operator delete&lt;/code&gt;, even if you never intend to call it. The reason is that, if a constructor throws during the evaluation of a new expression, the run-time system will return the memory to the &lt;code&gt;operator delete&lt;/code&gt; matching the &lt;code&gt;operator new&lt;/code&gt; that was called to allocate the memory to create the object in. If you do not provide a matching &lt;code&gt;operator delete&lt;/code&gt;, the default one is called, which is almost always wrong.</source>
          <target state="translated">Если вы перегружаете &lt;code&gt;operator new&lt;/code&gt; , вы также должны всегда перегружать соответствующий &lt;code&gt;operator delete&lt;/code&gt; , даже если вы никогда не намеревались его вызывать. Причина в том, что, если конструктор выдает во время вычисления нового выражения, система времени выполнения вернет память &lt;code&gt;operator delete&lt;/code&gt; совпадающему с &lt;code&gt;operator new&lt;/code&gt; который был вызван для выделения памяти для создания объекта. Если вы это делаете не предоставлять соответствующий &lt;code&gt;operator delete&lt;/code&gt; , вызывается оператор по умолчанию, что почти всегда неверно.</target>
        </trans-unit>
        <trans-unit id="826dbaa31e10b50624ed6f5bcb81e5a26a59de5f" translate="yes" xml:space="preserve">
          <source>Implicit Conversion Operators (C++98/C++03 and C++11)</source>
          <target state="translated">Неявные операторы преобразования (C++98C++03 и C++11)</target>
        </trans-unit>
        <trans-unit id="64b3307a85f7de1505aa3f37db4699689e2030a6" translate="yes" xml:space="preserve">
          <source>Implicit conversion operators, like one-argument constructors, are user-defined conversions. Compilers will grant one user-defined conversion when trying to match a call to an overloaded function.</source>
          <target state="translated">Неявные операторы преобразования,как и однопараметрические конструкторы,являются определяемыми пользователем преобразованиями.Компиляторы выдают одно пользовательское преобразование при попытке сопоставить вызов перегруженной функции.</target>
        </trans-unit>
        <trans-unit id="40caa674c8cd189d440009873823c8ee2f813b8c" translate="yes" xml:space="preserve">
          <source>In C++ you can create conversion operators, operators that allow the compiler to convert between your types and other defined types.  There are two types of conversion operators, implicit and explicit ones.</source>
          <target state="translated">В C++можно создавать операторы преобразования,операторы,которые позволяют компилятору преобразовывать между вашими типами и другими заданными типами.Существует два типа операторов преобразования-неявные и явные.</target>
        </trans-unit>
        <trans-unit id="49ef7e77ad3309f43ce0a0c931ad5b00264bdae6" translate="yes" xml:space="preserve">
          <source>In C++, operators are overloaded in the form of &lt;strong&gt;&lt;em&gt;functions with special names&lt;/em&gt;&lt;/strong&gt;. As with other functions, overloaded operators can generally be implemented either as a &lt;strong&gt;&lt;em&gt;member function of their left operand's type&lt;/em&gt;&lt;/strong&gt; or as &lt;strong&gt;&lt;em&gt;non-member functions&lt;/em&gt;&lt;/strong&gt;. Whether you are free to choose or bound to use either one depends on several criteria.&lt;sup&gt;2&lt;/sup&gt; A unary operator &lt;code&gt;@&lt;/code&gt;&lt;sup&gt;3&lt;/sup&gt;, applied to an object x, is invoked either as &lt;code&gt;operator@(x)&lt;/code&gt; or as &lt;code&gt;x.operator@()&lt;/code&gt;. A binary infix operator &lt;code&gt;@&lt;/code&gt;, applied to the objects &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, is called either as &lt;code&gt;operator@(x,y)&lt;/code&gt; or as &lt;code&gt;x.operator@(y)&lt;/code&gt;.&lt;sup&gt;4&lt;/sup&gt;</source>
          <target state="translated">В C ++ операторы перегружены в виде &lt;strong&gt;&lt;em&gt;функций со специальными именами&lt;/em&gt;&lt;/strong&gt; . Как и в случае с другими функциями, перегруженные операторы обычно могут быть реализованы либо как &lt;strong&gt;&lt;em&gt;функции-члены типа их левого операнда,&lt;/em&gt;&lt;/strong&gt; либо как функции, &lt;strong&gt;&lt;em&gt;не являющиеся членами&lt;/em&gt;&lt;/strong&gt; . Вольны ли вы выбирать или обязаны использовать один из них, зависит от нескольких критериев. &lt;sup&gt;2&lt;/sup&gt; Унарный оператор &lt;code&gt;@&lt;/code&gt; &lt;sup&gt;3&lt;/sup&gt; , примененный к объекту x, вызывается либо как &lt;code&gt;operator@(x)&lt;/code&gt; либо как &lt;code&gt;x.operator@()&lt;/code&gt; . Двоичный инфиксный оператор &lt;code&gt;@&lt;/code&gt; , применяемый к объектам &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , называется либо &lt;code&gt;operator@(x,y)&lt;/code&gt; либо как &lt;code&gt;x.operator@(y)&lt;/code&gt; . &lt;sup&gt;4&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7bc8481881e8590c8face179b924af1ea4a5fe0a" translate="yes" xml:space="preserve">
          <source>In C++, when you write a &lt;strong&gt;&lt;em&gt;new expression&lt;/em&gt;&lt;/strong&gt; like &lt;code&gt;new T(arg)&lt;/code&gt; two things happen when this expression is evaluated: First &lt;strong&gt;&lt;em&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/em&gt;&lt;/strong&gt; is invoked to obtain raw memory, and then the appropriate constructor of &lt;code&gt;T&lt;/code&gt; is invoked to turn this raw memory into a valid object. Likewise, when you delete an object, first its destructor is called, and then the memory is returned to &lt;code&gt;operator delete&lt;/code&gt;.</source>
          <target state="translated">В C ++, когда вы пишете &lt;strong&gt;&lt;em&gt;новое выражение,&lt;/em&gt;&lt;/strong&gt; такое как &lt;code&gt;new T(arg)&lt;/code&gt; , при вычислении этого выражения происходят две вещи: сначала вызывается &lt;strong&gt;&lt;em&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt; для получения необработанной памяти, а затем вызывается соответствующий конструктор &lt;code&gt;T&lt;/code&gt; , чтобы превратить эту необработанную память в действительный объект. Аналогично, когда вы удаляете объект, сначала вызывается его деструктор, а затем память возвращается &lt;code&gt;operator delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d9a856b351238fc8815cf318816c5839249dbd0" translate="yes" xml:space="preserve">
          <source>Input and Output Operators</source>
          <target state="translated">Входные и выходные операторы</target>
        </trans-unit>
        <trans-unit id="aff987919c1c656b540f21e98fcd457a77a08632" translate="yes" xml:space="preserve">
          <source>Let's say you have:</source>
          <target state="translated">Скажем так:</target>
        </trans-unit>
        <trans-unit id="1da0a13b5d45735843a1a97b7d80a3c4e94a7d15" translate="yes" xml:space="preserve">
          <source>Most commonly you will want to fine-tune memory management because measurement has shown that instances of a specific class, or of a group of related classes, are created and destroyed often and that the default memory management of the run-time system, tuned for general performance, deals inefficiently in this specific case. To improve this, you can overload new and delete for a specific class:</source>
          <target state="translated">Чаще всего вам захочется тонко настроить управление памятью,так как измерения показали,что экземпляры определенного класса или группы связанных классов часто создаются и уничтожаются,и что управление памятью по умолчанию системы исполнения,настроенное на общую производительность,в данном конкретном случае работает неэффективно.Для улучшения этого можно перегрузить новый и удалить для конкретного класса:</target>
        </trans-unit>
        <trans-unit id="7bc4f7a69868fbbebd9b1aa75e004a5d424231ae" translate="yes" xml:space="preserve">
          <source>Most of the work in overloading operators is boiler-plate code. That is little wonder, since operators are merely syntactic sugar, their actual work could be done by (and often is forwarded to) plain functions. But it is important that you get this boiler-plate code right. If you fail, either your operator&amp;rsquo;s code won&amp;rsquo;t compile or your users&amp;rsquo; code won&amp;rsquo;t compile or your users&amp;rsquo; code will behave surprisingly.</source>
          <target state="translated">Большая часть работы операторов по перегрузке - это код котельной плиты. Это неудивительно, поскольку операторы являются просто синтаксическим сахаром, их фактическая работа может выполняться (и часто направляется) простыми функциями. Но важно, чтобы вы правильно поняли этот код. Если вы потерпите неудачу, либо код вашего оператора не скомпилируется, либо код вашего пользователя не скомпилируется, либо код вашего пользователя будет вести себя на удивление.</target>
        </trans-unit>
        <trans-unit id="308ac793bd96cffbd3257f710242d8d6baa8c5f9" translate="yes" xml:space="preserve">
          <source>Not all operators can be overloaded in C++. Among the operators that cannot be overloaded are: &lt;code&gt;.&lt;/code&gt;&lt;code&gt;::&lt;/code&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;code&gt;.*&lt;/code&gt; and the only ternary operator in C++, &lt;code&gt;?:&lt;/code&gt;</source>
          <target state="translated">Не все операторы могут быть перегружены в C ++. Среди операторов, которые не могут быть перегружены: &lt;code&gt;::&lt;/code&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;code&gt;.*&lt;/code&gt; и единственный троичный оператор в C ++, &lt;code&gt;?:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ba5b304e147804bebb9771281e8f850c466d01fa" translate="yes" xml:space="preserve">
          <source>Note that the postfix variant is implemented in terms of prefix. Also note that postfix does an extra copy.&lt;sup&gt;2&lt;/sup&gt;</source>
          <target state="translated">Обратите внимание, что постфиксный вариант реализован в терминах префикса. Также обратите внимание, что postfix делает дополнительную копию. &lt;sup&gt;2&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a98223f6637a4998c4f367f083b8d38397dc9316" translate="yes" xml:space="preserve">
          <source>Note that these, too, will almost always need both a const and a non-const version.
For the &lt;code&gt;-&amp;gt;&lt;/code&gt; operator, if &lt;code&gt;value_type&lt;/code&gt; is of &lt;code&gt;class&lt;/code&gt; (or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt;) type, another &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; is called recursively, until an &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; returns a value of non-class type.</source>
          <target state="translated">Обратите внимание, что они также почти всегда нуждаются как в const, так и в неконстантной версии. Для оператора &lt;code&gt;-&amp;gt;&lt;/code&gt; , если &lt;code&gt;value_type&lt;/code&gt; имеет &lt;code&gt;class&lt;/code&gt; (или &lt;code&gt;struct&lt;/code&gt; или &lt;code&gt;union&lt;/code&gt; ), другой &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; вызывается рекурсивно, пока &lt;code&gt;operator-&amp;gt;()&lt;/code&gt; вернет значение не-классового типа.</target>
        </trans-unit>
        <trans-unit id="2b329ad0d568d6f8e12b0e15d54437e0b250ccda" translate="yes" xml:space="preserve">
          <source>Note that, in the example code for placement new given above, &lt;code&gt;operator delete&lt;/code&gt; is never called, unless the constructor of X throws an exception.</source>
          <target state="translated">Обратите внимание, что в приведенном выше примере кода для размещения нового &lt;code&gt;operator delete&lt;/code&gt; никогда не вызывается, если только конструктор X не выдает исключение.</target>
        </trans-unit>
        <trans-unit id="e34f82c929e61f88c2610287d88fb521a0cf8bf6" translate="yes" xml:space="preserve">
          <source>Note: The answers were given in &lt;em&gt;a specific order&lt;/em&gt;, but since many users sort answers according to votes, rather than the time they were given, here's an &lt;strong&gt;&lt;em&gt;index of the answers&lt;/em&gt;&lt;/strong&gt; in the order in which they make most sense:</source>
          <target state="translated">Примечание. Ответы были даны в &lt;em&gt;определенном порядке&lt;/em&gt; , но поскольку многие пользователи сортируют ответы по голосам, а не по времени, в которое они были даны, вот &lt;strong&gt;&lt;em&gt;индекс ответов&lt;/em&gt;&lt;/strong&gt; в том порядке, в котором они имеют наибольшее значение:</target>
        </trans-unit>
        <trans-unit id="88ae2678453b7004e74233094e1cdf9026fbf332" translate="yes" xml:space="preserve">
          <source>Notice the &lt;code&gt;explicit&lt;/code&gt;.  Now when you try to execute the unexpected code from the implicit conversion operators, you get a compiler error:</source>
          <target state="translated">Обратите внимание на &lt;code&gt;explicit&lt;/code&gt; . Теперь, когда вы пытаетесь выполнить неожиданный код из операторов неявного преобразования, вы получаете ошибку компилятора:</target>
        </trans-unit>
        <trans-unit id="5ed5a83cf4720e09bb656ff2ed60cc35eca54b74" translate="yes" xml:space="preserve">
          <source>Of course, as with all rules of thumb, there are exceptions. If you have a type</source>
          <target state="translated">Конечно,как и во всех правилах,есть исключения.Если у вас есть тип</target>
        </trans-unit>
        <trans-unit id="71635eee6d0e7a43c1616fdd99b28d55662b9781" translate="yes" xml:space="preserve">
          <source>Operators for Pointer-like Types</source>
          <target state="translated">Операторы для указательных типов</target>
        </trans-unit>
        <trans-unit id="232c32ffd9745850f7cd1967b4a1a159748cf1ff" translate="yes" xml:space="preserve">
          <source>Operators that are implemented as non-member functions are sometimes friend of their operand&amp;rsquo;s type.</source>
          <target state="translated">Операторы, которые реализованы как функции, не являющиеся членами, иногда являются друзьями типа своего операнда.</target>
        </trans-unit>
        <trans-unit id="fbf47cfe86efefa771f3ac5016a6dee10f74b19c" translate="yes" xml:space="preserve">
          <source>Other operators can be implemented either as members or as non-members. Some of them, however, usually have to be implemented as non-member functions, because their left operand cannot be modified by you. The most prominent of these are the input and output operators &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, whose left operands are stream classes from the standard library which you cannot change.</source>
          <target state="translated">Другие операторы могут быть реализованы как члены или не члены. Однако некоторые из них обычно должны быть реализованы как функции, не являющиеся членами, поскольку их левый операнд не может быть изменен вами. Наиболее заметными из них являются операторы ввода и вывода &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , левые операнды которых являются потоковыми классами из стандартной библиотеки, которые нельзя изменить.</target>
        </trans-unit>
        <trans-unit id="61c0c26e0870099af93b41d7ed973fe4422b7163" translate="yes" xml:space="preserve">
          <source>Overloaded thus, new and delete behave like static member functions. For objects of &lt;code&gt;my_class&lt;/code&gt;, the &lt;code&gt;std::size_t&lt;/code&gt; argument will always be &lt;code&gt;sizeof(my_class)&lt;/code&gt;. However, these operators are also called for dynamically allocated objects of &lt;strong&gt;&lt;em&gt;derived classes&lt;/em&gt;&lt;/strong&gt;, in which case it might be greater than that.</source>
          <target state="translated">Перегруженные таким образом, new и delete ведут себя как статические функции-члены. Для объектов &lt;code&gt;my_class&lt;/code&gt; аргумент &lt;code&gt;std::size_t&lt;/code&gt; всегда будет &lt;code&gt;sizeof(my_class)&lt;/code&gt; . Однако эти операторы также вызываются для динамически размещаемых объектов &lt;strong&gt;&lt;em&gt;производных классов&lt;/em&gt;&lt;/strong&gt; , и в этом случае они могут быть больше, чем это.</target>
        </trans-unit>
        <trans-unit id="387a1adda403a18b38d6933171fc8f31a2cbd62c" translate="yes" xml:space="preserve">
          <source>Overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;</source>
          <target state="translated">Перегрузка &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;delete&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="918f907f18107b5038a28b4f7a181b670ec203fa" translate="yes" xml:space="preserve">
          <source>Overloading new and delete</source>
          <target state="translated">Перегрузка новых и удаление</target>
        </trans-unit>
        <trans-unit id="6c74c5e2cff52e6b3146c3c1bffab6eeaab7158c" translate="yes" xml:space="preserve">
          <source>Overloading unary minus and plus is not very common and probably best avoided. If needed, they should probably be overloaded as member functions.</source>
          <target state="translated">Перегрузка без учета минусов и плюсов не очень распространена и,возможно,ее лучше всего избегать.При необходимости,они,вероятно,должны быть перегружены как функции члена.</target>
        </trans-unit>
        <trans-unit id="aef51910b519e257f69e8e603e5cc6e63bd7c663" translate="yes" xml:space="preserve">
          <source>Placement &lt;code&gt;new&lt;/code&gt;</source>
          <target state="translated">Размещение &lt;code&gt;new&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f35e5b7132ff39e177d6482815cbd394c998601" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is overloaded as a member function of &lt;code&gt;Foo&lt;/code&gt;, the LHS of the operator must be a &lt;code&gt;Foo&lt;/code&gt; object. Which means, you will be required to use:</source>
          <target state="translated">Так как &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; перегружен как функция-член &lt;code&gt;Foo&lt;/code&gt; , LHS оператора должен быть объектом &lt;code&gt;Foo&lt;/code&gt; . Это означает, что вы должны будете использовать:</target>
        </trans-unit>
        <trans-unit id="48b7d95d9adba62275ebb23b2739fe7185d38c3e" translate="yes" xml:space="preserve">
          <source>So-called placement new allows you to create an object at a certain address which is passed to:</source>
          <target state="translated">Так называемое размещение new позволяет создать объект по определенному адресу,который передается:</target>
        </trans-unit>
        <trans-unit id="410499869878cd2bd1c723022f7e89e241865fba" translate="yes" xml:space="preserve">
          <source>The C++ standard library comes with a set of predefined &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; operators. The most important ones are these:</source>
          <target state="translated">Стандартная библиотека C ++ поставляется с набором предопределенных операторов &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;delete&lt;/code&gt; . Самые важные из них:</target>
        </trans-unit>
        <trans-unit id="c5b39f9cfeee4e22210663bbd7c842296748cdf0" translate="yes" xml:space="preserve">
          <source>The Decision between Member and Non-member</source>
          <target state="translated">Решение между членом и не членом</target>
        </trans-unit>
        <trans-unit id="2cdaded69a5ba8bbbc434264bc52e9dff47315be" translate="yes" xml:space="preserve">
          <source>The General Syntax of operator overloading in C++</source>
          <target state="translated">Общий синтаксис перегрузки операторов в C++</target>
        </trans-unit>
        <trans-unit id="daa94d71b00e6fe8d0332493c4413afa5cc89105" translate="yes" xml:space="preserve">
          <source>The Three Basic Rules of Operator Overloading in C++</source>
          <target state="translated">Три основных правила перегрузки оператора на C++</target>
        </trans-unit>
        <trans-unit id="1ed425865c7b999b506d3bd64bd342aef7d971fa" translate="yes" xml:space="preserve">
          <source>The array subscript operator is a binary operator which must be implemented as a class member. It is used for container-like types that allow access to their data elements by a key.
The canonical form of providing these is this:</source>
          <target state="translated">Оператор subscript массива-двоичный оператор,который должен быть реализован в виде члена класса.Он используется для контейнероподобных типов,которые обеспечивают доступ к своим элементам данных по ключу.Каноническая форма их предоставления такова:</target>
        </trans-unit>
        <trans-unit id="5071b272c7cacc200a739ff1600233700cde5f39" translate="yes" xml:space="preserve">
          <source>The binary infix comparison operators should, according to the rules of thumb, be implemented as non-member functions&lt;sup&gt;1&lt;/sup&gt;. The unary prefix negation &lt;code&gt;!&lt;/code&gt; should (according to the same rules) be implemented as a member function. (but it is usually not a good idea to overload it.)</source>
          <target state="translated">Операторы сравнения двоичного инфикса должны, согласно практическим правилам, быть реализованы как функции, не являющиеся членами &lt;sup&gt;1&lt;/sup&gt; . Одинарный префикс отрицания &lt;code&gt;!&lt;/code&gt; должен (согласно тем же правилам) быть реализован как функция-член. (но обычно не стоит перегружать его.)</target>
        </trans-unit>
        <trans-unit id="1f4eebeeaa95cd1e3a1f5148b3b1cf80c882d651" translate="yes" xml:space="preserve">
          <source>The binary operators &lt;code&gt;=&lt;/code&gt; (assignment), &lt;code&gt;[]&lt;/code&gt; (array subscription), &lt;code&gt;-&amp;gt;&lt;/code&gt; (member access), as well as the n-ary &lt;code&gt;()&lt;/code&gt; (function call) operator, must always be implemented as &lt;strong&gt;&lt;em&gt;member functions&lt;/em&gt;&lt;/strong&gt;, because the syntax of the language requires them to.</source>
          <target state="translated">Бинарные операторы &lt;code&gt;=&lt;/code&gt; (присваивание), &lt;code&gt;[]&lt;/code&gt; (подписка на массив), &lt;code&gt;-&amp;gt;&lt;/code&gt; (доступ к элементу), а также оператор n-ary &lt;code&gt;()&lt;/code&gt; (вызов функции) всегда должны быть реализованы как &lt;strong&gt;&lt;em&gt;функции-члены&lt;/em&gt;&lt;/strong&gt; , поскольку синтаксис язык требует от них</target>
        </trans-unit>
        <trans-unit id="e752b73d2516a901950b1881135e09ba982f3610" translate="yes" xml:space="preserve">
          <source>The bit manipulation operators &lt;code&gt;~&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; should be implemented in the same way as the arithmetic operators. However, (except for overloading &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; for output and input) there are very few reasonable use cases for overloading these.</source>
          <target state="translated">Операторы битовых манипуляций &lt;code&gt;~&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; должно быть реализовано так же, как арифметические операторы. Однако (за исключением перегрузки &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; для вывода и ввода) существует очень мало разумных вариантов их использования.</target>
        </trans-unit>
        <trans-unit id="945991f17734d3341c52c64409c763fa696537b0" translate="yes" xml:space="preserve">
          <source>The bitshift operators &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, although still used in hardware interfacing for the bit-manipulation functions they inherit from C, have become more prevalent as overloaded stream input and output operators in most applications.  For guidance overloading as bit-manipulation operators, see the section below on Binary Arithmetic Operators.  For implementing your own custom format and parsing logic when your object is used with iostreams, continue.</source>
          <target state="translated">Операторы битового сдвига &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; и &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , хотя они все еще используются в аппаратном интерфейсе для функций управления битами, которые они наследуют от C, стали более распространенными в качестве перегруженных операторов ввода и вывода потока в большинстве приложений. Для перегрузки руководства в качестве операторов управления битами см. Раздел ниже о двоичных арифметических операторах. Для реализации собственного формата и логики разбора, когда ваш объект используется с iostreams, продолжайте.</target>
        </trans-unit>
        <trans-unit id="fff84f3d926b7bdd40f1cf1bda8210cabce8f711" translate="yes" xml:space="preserve">
          <source>The first of the basic rules of operator overloading &amp;ndash; &lt;em&gt;don&amp;rsquo;t do it&lt;/em&gt; &amp;ndash; applies especially to overloading &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt;. Almost the only reasons to overload these operators are &lt;strong&gt;&lt;em&gt;performance problems&lt;/em&gt;&lt;/strong&gt; and &lt;strong&gt;&lt;em&gt;memory constraints&lt;/em&gt;&lt;/strong&gt;, and in many cases, other actions, like &lt;em&gt;changes to the algorithms&lt;/em&gt; used, will provide a much &lt;strong&gt;&lt;em&gt;higher cost/gain ratio&lt;/em&gt;&lt;/strong&gt; than attempting to tweak memory management.</source>
          <target state="translated">Первое из основных правил перегрузки операторов - &lt;em&gt;не делайте этого&lt;/em&gt; - особенно относится к перегрузке &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;delete&lt;/code&gt; . Почти единственными причинами перегрузки этих операторов являются &lt;strong&gt;&lt;em&gt;проблемы с производительностью&lt;/em&gt;&lt;/strong&gt; и &lt;strong&gt;&lt;em&gt;нехватка памяти&lt;/em&gt;&lt;/strong&gt; , и во многих случаях другие действия, такие как &lt;em&gt;изменение используемых алгоритмов&lt;/em&gt; , обеспечат гораздо &lt;strong&gt;&lt;em&gt;более высокое соотношение цена / выигрыш,&lt;/em&gt;&lt;/strong&gt; чем попытка настроить управление памятью.</target>
        </trans-unit>
        <trans-unit id="d34b042bc12c1d81ad05fa8ab3868d83da8eb700" translate="yes" xml:space="preserve">
          <source>The first two allocate/deallocate memory for an object, the latter two for an array of objects. If you provide your own versions of these, they will &lt;strong&gt;&lt;em&gt;not overload, but replace&lt;/em&gt;&lt;/strong&gt; the ones from the standard library.</source>
          <target state="translated">Первые два выделяют / освобождают память для объекта, последние два - для массива объектов. Если вы предоставите свои собственные версии, они &lt;strong&gt;&lt;em&gt;не&lt;/em&gt;&lt;/strong&gt; будут &lt;strong&gt;&lt;em&gt;перегружены, а заменят&lt;/em&gt;&lt;/strong&gt; версии из стандартной библиотеки.</target>
        </trans-unit>
        <trans-unit id="3913d839e0e0cdca08e79893f8e7739eb1267dab" translate="yes" xml:space="preserve">
          <source>The following is a simple class with an implicit conversion operator:</source>
          <target state="translated">Ниже приведен простой класс с неявным оператором преобразования:</target>
        </trans-unit>
        <trans-unit id="633d4c2f5c9eede69578ed2b0fb1b8a6678e93f3" translate="yes" xml:space="preserve">
          <source>The function call operator, used to create function objects, also known as functors, must be defined as a &lt;strong&gt;&lt;em&gt;member&lt;/em&gt;&lt;/strong&gt; function, so it always has the implicit &lt;code&gt;this&lt;/code&gt; argument of member functions. Other than this, it can be overloaded to take any number of additional arguments, including zero.</source>
          <target state="translated">Оператор вызова функции, используемый для создания объектов функций, также известных как функторы, должен быть определен как функция- &lt;strong&gt;&lt;em&gt;член&lt;/em&gt;&lt;/strong&gt; , поэтому он всегда имеет неявный аргумент функции-члена. Кроме этого, он может быть перегружен, чтобы принимать любое количество дополнительных аргументов, включая ноль.</target>
        </trans-unit>
        <trans-unit id="f09b5b0acfb377a7aa0dcf24a9a4828f0e1de877" translate="yes" xml:space="preserve">
          <source>The important thing to note here is that only two of these operators actually do anything, the others are just forwarding their arguments to either of these two to do the actual work.</source>
          <target state="translated">Здесь важно отметить,что только два из этих операторов на самом деле что-то делают,остальные просто передают свои аргументы любому из этих двух,чтобы сделать реальную работу.</target>
        </trans-unit>
        <trans-unit id="c8a7556a69847cd86a1a393d720af19a6fe22b5a" translate="yes" xml:space="preserve">
          <source>The standard library comes with the appropriate overloads of the new and delete operators for this:</source>
          <target state="translated">Стандартная библиотека поставляется с соответствующими перегрузками операторов new и delete для этого:</target>
        </trans-unit>
        <trans-unit id="6c83c7c063a1665405b1d98712a057d5666d471e" translate="yes" xml:space="preserve">
          <source>The standard library&amp;rsquo;s algorithms (e.g. &lt;code&gt;std::sort()&lt;/code&gt;) and types (e.g. &lt;code&gt;std::map&lt;/code&gt;) will always only expect &lt;code&gt;operator&amp;lt;&lt;/code&gt; to be present. However, the &lt;em&gt;users of your type will expect all the other operators to be present&lt;/em&gt;, too, so if you define &lt;code&gt;operator&amp;lt;&lt;/code&gt;, be sure to follow the third fundamental rule of operator overloading and also define all the other boolean comparison operators. The canonical way to implement them is this:</source>
          <target state="translated">Алгоритмы стандартной библиотеки (например, &lt;code&gt;std::sort()&lt;/code&gt; ) и типы (например, &lt;code&gt;std::map&lt;/code&gt; ) всегда будут ожидать только наличия &lt;code&gt;operator&amp;lt;&lt;/code&gt; . Однако &lt;em&gt;пользователи вашего типа будут ожидать, что будут присутствовать все другие операторы&lt;/em&gt; , поэтому, если вы определите &lt;code&gt;operator&amp;lt;&lt;/code&gt; , обязательно следуйте третьему фундаментальному правилу перегрузки операторов, а также определите все другие логические операторы сравнения. Канонический способ их реализации заключается в следующем:</target>
        </trans-unit>
        <trans-unit id="7b0324536b2aff8b5056489442124903baa2f6fb" translate="yes" xml:space="preserve">
          <source>The stream operators, among the most commonly overloaded operators, are binary infix operators for which the syntax specifies no restriction on whether they should be members or non-members.
Since they change their left argument (they alter the stream&amp;rsquo;s state), they should, according to the rules of thumb, be implemented as members of their left operand&amp;rsquo;s type. However, their left operands are streams from the standard library, and while most of the stream output and input operators defined by the standard library are indeed defined as members of the stream classes, when you implement output and input operations for your own types, you cannot change the standard library&amp;rsquo;s stream types. That&amp;rsquo;s why you need to implement these operators for your own types as non-member functions.
The canonical forms of the two are these:</source>
          <target state="translated">Операторы потока, среди наиболее часто перегруженных операторов, являются бинарными инфиксными операторами, для которых синтаксис не устанавливает никаких ограничений относительно того, должны ли они быть членами или не членами. Поскольку они изменяют свой левый аргумент (они изменяют состояние потока), они должны, согласно практическим правилам, быть реализованы как члены типа их левого операнда. Однако их левые операнды являются потоками из стандартной библиотеки, и хотя большинство операторов вывода и ввода потока, определенных стандартной библиотекой, действительно определены как члены классов потоков, при реализации операций вывода и ввода для ваших собственных типов вы не может изменить типы потоков стандартной библиотеки. Вот почему вам нужно реализовать эти операторы для ваших собственных типов как функции, не являющиеся членами. Канонические формы этих двух:</target>
        </trans-unit>
        <trans-unit id="e742cb5d317ff843e4d40ebac2e6b8a129167116" translate="yes" xml:space="preserve">
          <source>The syntax for overloading the remaining binary boolean operators (&lt;code&gt;||&lt;/code&gt;, &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;) follows the rules of the comparison operators. However, it is &lt;em&gt;very&lt;/em&gt; unlikely that you would find a reasonable use case for these&lt;sup&gt;2&lt;/sup&gt;.</source>
          <target state="translated">Синтаксис для перегрузки оставшихся двоичных логических операторов ( &lt;code&gt;||&lt;/code&gt; , &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ) соответствует правилам операторов сравнения. Тем не менее, &lt;em&gt;очень&lt;/em&gt; маловероятно, что вы найдете разумный вариант использования этих &lt;sup&gt;2&lt;/sup&gt; .</target>
        </trans-unit>
        <trans-unit id="43b92ed49085008f088b6b20f2dff39e47616f03" translate="yes" xml:space="preserve">
          <source>The unary address-of operator should never be overloaded.</source>
          <target state="translated">Унарный адрес оператора никогда не должен быть перегружен.</target>
        </trans-unit>
        <trans-unit id="4e69702ccb56e46c30152ff70d54bcafe1d3b79d" translate="yes" xml:space="preserve">
          <source>The unary increment and decrement operators come in both prefix and postfix flavor. To tell one from the other, the postfix variants take an additional dummy int argument. If you overload increment or decrement, be sure to always implement both prefix and postfix versions.
Here is the canonical implementation of increment, decrement follows the same rules:</source>
          <target state="translated">Унарные операторы инкремента и декремента приходят как в префиксном,так и постфиксном вкусе.Чтобы отличить один от другого,постфиксные варианты принимают дополнительный фиктивный int аргумент.Если вы перегружаете инкремент или декремент,убедитесь,что всегда реализуете и префиксный,и постфиксный варианты.Вот каноническая реализация инкремента,декремент следует тем же правилам:</target>
        </trans-unit>
        <trans-unit id="fafebafed54733670be4bdb8f0f077c58939e2eb" translate="yes" xml:space="preserve">
          <source>There's a lot to be said about assignment. However, most of it has already been said in &lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;GMan's famous Copy-And-Swap FAQ&lt;/a&gt;, so I'll skip most of it here, only listing the perfect assignment operator for reference:</source>
          <target state="translated">Многое можно сказать о назначении. Тем не менее, большинство из них уже было сказано в &lt;a href=&quot;https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom&quot;&gt;известном FAQ по копированию и замене GMan&lt;/a&gt; , поэтому я пропущу большую часть здесь, перечисляя только идеальный оператор присваивания для справки:</target>
        </trans-unit>
        <trans-unit id="7d5a6745e57fd584e32c48350df5cf7b6c97a053" translate="yes" xml:space="preserve">
          <source>Throughout the C++ standard library, function objects are always copied. Your own function objects should therefore be cheap to copy. If a function object absolutely needs to use data which is expensive to copy, it is better to store that data elsewhere and have the function object refer to it.</source>
          <target state="translated">Во всей стандартной библиотеке C++объекты функций всегда копируются.Поэтому копирование собственных объектов функций должно быть дешевым.Если объекту функции абсолютно необходимо использовать данные,копирование которых стоит дорого,то лучше хранить эти данные в другом месте и иметь на них ссылку в объекте функции.</target>
        </trans-unit>
        <trans-unit id="d096ebff9a794e9192a29686de4113ddeb056fa5" translate="yes" xml:space="preserve">
          <source>To invoke the explicit cast operator, you have to use &lt;code&gt;static_cast&lt;/code&gt;, a C-style cast, or a constructor style cast ( i.e. &lt;code&gt;T(value)&lt;/code&gt; ).</source>
          <target state="translated">Чтобы вызвать явный оператор приведения, вы должны использовать &lt;code&gt;static_cast&lt;/code&gt; , приведение в стиле C или приведение в стиле конструктора (т. Е. &lt;code&gt;T(value)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d8020d5538e9765d456a055193c573dc6171a136" translate="yes" xml:space="preserve">
          <source>To overload the global new and delete, simply replace the pre-defined operators of the standard library with our own. However, this rarely ever needs to be done.</source>
          <target state="translated">Чтобы перегрузить глобальную новинку и удалить,просто замените предопределенные операторы стандартной библиотеки на наши собственные.Однако это редко бывает необходимо сделать.</target>
        </trans-unit>
        <trans-unit id="f5a792933066b9a9e2ac32f6f06b8c7c9b9c310a" translate="yes" xml:space="preserve">
          <source>Unary arithmetic operators</source>
          <target state="translated">Унарные арифметические операторы</target>
        </trans-unit>
        <trans-unit id="97ec28a8a9251fa1cb37b5b5d4e4408efdf02f8b" translate="yes" xml:space="preserve">
          <source>Unless you do not want users of your class to be able to change data elements returned by &lt;code&gt;operator[]&lt;/code&gt; (in which case you can omit the non-const variant), you should always provide both variants of the operator.</source>
          <target state="translated">Если вы не хотите, чтобы пользователи вашего класса могли изменять элементы данных, возвращаемые &lt;code&gt;operator[]&lt;/code&gt; (в этом случае вы можете опустить неконстантный вариант), вы всегда должны предоставлять оба варианта оператора.</target>
        </trans-unit>
        <trans-unit id="4f28b9e24ebd784a9282ef8b29671b29756db1ae" translate="yes" xml:space="preserve">
          <source>Unlike implicit conversion operators, explicit conversion operators will never kick in when you don't expect them to.  The following is a simple class with an explicit conversion operator:</source>
          <target state="translated">В отличие от операторов неявного преобразования,операторы явного преобразования никогда не будут запускаться,когда вы этого не ожидаете.Ниже приведен простой класс с оператором явного преобразования:</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="7a38cdb12264364efc9478d485dd17ef42cde482" translate="yes" xml:space="preserve">
          <source>What are the basic rules and idioms for operator overloading</source>
          <target state="translated">Каковы основные правила и идиомы перегрузки оператора.</target>
        </trans-unit>
        <trans-unit id="919377897e90c6bc8567a475cc62dd42597b7240" translate="yes" xml:space="preserve">
          <source>When implementing &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, manually setting the stream&amp;rsquo;s state is only necessary when the reading itself succeeded, but the result is not what would be expected.</source>
          <target state="translated">При реализации &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; ручная установка состояния потока необходима только тогда, когда само чтение завершилось успешно, но результат не соответствует ожидаемому.</target>
        </trans-unit>
        <trans-unit id="f20d7d9e25980a2df4f9c97a919afac20cc35de6" translate="yes" xml:space="preserve">
          <source>When it comes to operator overloading in C++, there are &lt;strong&gt;&lt;em&gt;three basic rules you should follow&lt;/em&gt;&lt;/strong&gt;. As with all such rules, there are indeed exceptions. Sometimes people have deviated from them and the outcome was not bad code, but such positive deviations are few and far between. At the very least, 99 out of 100 such deviations I have seen were unjustified. However, it might just as well have been 999 out of 1000. So you&amp;rsquo;d better stick to the following rules.</source>
          <target state="translated">Когда дело доходит до перегрузки операторов в C ++, &lt;strong&gt;&lt;em&gt;следует соблюдать три основных правила&lt;/em&gt;&lt;/strong&gt; . Как и во всех таких правилах, действительно есть исключения. Иногда люди отклонялись от них, и в результате получился неплохой код, но таких положительных отклонений мало, и они далеко друг от друга. По крайней мере, 99 из 100 таких отклонений, которые я видел, были неоправданными. Тем не менее, это может быть и 999 из 1000. Так что вам лучше придерживаться следующих правил.</target>
        </trans-unit>
        <trans-unit id="37f76d33dcd336dfa74e1a497620ddd35c0ff0ac" translate="yes" xml:space="preserve">
          <source>Why can't &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; function for streaming objects to &lt;code&gt;std::cout&lt;/code&gt; or to a file be a member function?</source>
          <target state="translated">Почему &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; функция для потоковой передачи объектов в &lt;code&gt;std::cout&lt;/code&gt; или в файл не может быть функцией-членом?</target>
        </trans-unit>
        <trans-unit id="39d720caae827c7c0b9c7f668fcb211ea7a7c1d0" translate="yes" xml:space="preserve">
          <source>You can also overload &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;delete&lt;/code&gt; with other arguments. As with the additional argument for placement new, these arguments are also listed within parentheses after the keyword &lt;code&gt;new&lt;/code&gt;. Merely for historical reasons, such variants are often also called placement new, even if their arguments are not for placing an object at a specific address.</source>
          <target state="translated">Вы также можете перегрузить &lt;code&gt;new&lt;/code&gt; и &lt;code&gt;delete&lt;/code&gt; с другими аргументами. Как и в случае с дополнительным аргументом для размещения new, эти аргументы также перечислены в скобках после ключевого слова &lt;code&gt;new&lt;/code&gt; . По историческим причинам такие варианты часто также называют размещением нового, даже если их аргументы не для размещения объекта по определенному адресу.</target>
        </trans-unit>
        <trans-unit id="7528cb53fda223cd367475e992221703ed9fdc71" translate="yes" xml:space="preserve">
          <source>You cannot change the meaning of operators for built-in types in C++, operators can only be overloaded for user-defined types&lt;sup&gt;1&lt;/sup&gt;. That is, at least one of the operands has to be of a user-defined type. As with other overloaded functions, operators can be overloaded for a certain set of parameters only once.</source>
          <target state="translated">Вы не можете изменить значение операторов для встроенных типов в C ++, операторы могут быть перегружены только для пользовательских типов &lt;sup&gt;1&lt;/sup&gt; . То есть, по крайней мере, один из операндов должен быть пользовательского типа. Как и в случае с другими перегруженными функциями, операторы могут быть перегружены для определенного набора параметров только один раз.</target>
        </trans-unit>
        <trans-unit id="9e8e2f1d8db91fd84d40e7c67b7a78f2b63f8119" translate="yes" xml:space="preserve">
          <source>You will be able to use:</source>
          <target state="translated">Ты сможешь использовать:</target>
        </trans-unit>
        <trans-unit id="216956e088f4509625dab4a52801ab781c0e31b0" translate="yes" xml:space="preserve">
          <source>and you want to overload the increment and decrement operators for it, you cannot do this as a member functions, since in C++, enum types cannot have member functions. So you have to overload it as a free function. And &lt;code&gt;operator&amp;lt;()&lt;/code&gt; for a class template nested within a class template is much easier to write and read when done as a member function inline in the class definition. But these are indeed rare exceptions.</source>
          <target state="translated">и вы хотите перегрузить операторы инкремента и декремента для него, вы не можете сделать это как функции-члены, так как в C ++ типы enum не могут иметь функции-члены. Таким образом, вы должны перегрузить его как бесплатную функцию. И &lt;code&gt;operator&amp;lt;()&lt;/code&gt; для шаблона класса, вложенного в шаблон класса, гораздо проще писать и читать, когда он выполняется как функция-член, встроенная в определение класса. Но это действительно редкие исключения.</target>
        </trans-unit>
        <trans-unit id="a8876728833443b597fddaff948d8ef7d8b6d6fb" translate="yes" xml:space="preserve">
          <source>arithmetic operators: &lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt;&lt;code&gt;*&lt;/code&gt;&lt;code&gt;/&lt;/code&gt;&lt;code&gt;%&lt;/code&gt; and &lt;code&gt;+=&lt;/code&gt;&lt;code&gt;-=&lt;/code&gt;&lt;code&gt;*=&lt;/code&gt;&lt;code&gt;/=&lt;/code&gt;&lt;code&gt;%=&lt;/code&gt; (all binary infix); &lt;code&gt;+&lt;/code&gt;&lt;code&gt;-&lt;/code&gt; (unary prefix); &lt;code&gt;++&lt;/code&gt;&lt;code&gt;--&lt;/code&gt; (unary prefix and postfix)</source>
          <target state="translated">арифметические операторы: &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; &lt;code&gt;*&lt;/code&gt; &lt;code&gt;/&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; и &lt;code&gt;+=&lt;/code&gt; &lt;code&gt;-=&lt;/code&gt; &lt;code&gt;*=&lt;/code&gt; &lt;code&gt;/=&lt;/code&gt; &lt;code&gt;%=&lt;/code&gt; (все двоичные инфиксы); &lt;code&gt;+&lt;/code&gt; &lt;code&gt;-&lt;/code&gt; (одинарный префикс); &lt;code&gt;++&lt;/code&gt; &lt;code&gt;--&lt;/code&gt; (унарный префикс и постфикс)</target>
        </trans-unit>
        <trans-unit id="5a5099434f36ef0494a734223946a9f17c108f31" translate="yes" xml:space="preserve">
          <source>bit manipulation: &lt;code&gt;&amp;amp;&lt;/code&gt;&lt;code&gt;|&lt;/code&gt;&lt;code&gt;^&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;amp;=&lt;/code&gt;&lt;code&gt;|=&lt;/code&gt;&lt;code&gt;^=&lt;/code&gt;&lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; (all binary infix); &lt;code&gt;~&lt;/code&gt; (unary prefix)</source>
          <target state="translated">битовые манипуляции: &lt;code&gt;&amp;amp;&lt;/code&gt; &lt;code&gt;|&lt;/code&gt; &lt;code&gt;^&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;amp;=&lt;/code&gt; &lt;code&gt;|=&lt;/code&gt; &lt;code&gt;^=&lt;/code&gt; &lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt; (все двоичные инфиксы); &lt;code&gt;~&lt;/code&gt; (одинарный префикс)</target>
        </trans-unit>
        <trans-unit id="f93156b243321d1cbdfc482620959e7bf4ed1bf9" translate="yes" xml:space="preserve">
          <source>boolean algebra: &lt;code&gt;==&lt;/code&gt;&lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;code&gt;||&lt;/code&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (all binary infix); &lt;code&gt;!&lt;/code&gt; (unary prefix)</source>
          <target state="translated">булева алгебра: &lt;code&gt;==&lt;/code&gt; &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; &lt;code&gt;&amp;lt;=&lt;/code&gt; &amp;gt; &lt;code&gt;&amp;gt;=&lt;/code&gt; &lt;code&gt;||&lt;/code&gt; &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; (весь двоичный инфикс); &lt;code&gt;!&lt;/code&gt; (одинарный префикс)</target>
        </trans-unit>
        <trans-unit id="dfc056418cb491e7998e6f590c77a4dc4c43f3cf" translate="yes" xml:space="preserve">
          <source>implicit conversion operators</source>
          <target state="translated">операторы неявной конверсии</target>
        </trans-unit>
        <trans-unit id="5a8540091878a4d7ea3c96c572645994df60c30a" translate="yes" xml:space="preserve">
          <source>memory management: &lt;code&gt;new&lt;/code&gt;&lt;code&gt;new[]&lt;/code&gt;&lt;code&gt;delete&lt;/code&gt;&lt;code&gt;delete[]&lt;/code&gt;</source>
          <target state="translated">управление памятью: &lt;code&gt;new&lt;/code&gt; &lt;code&gt;new[]&lt;/code&gt; &lt;code&gt;delete&lt;/code&gt; &lt;code&gt;delete[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="81b2763337b529b56fc828c4327b362d3740d4ac" translate="yes" xml:space="preserve">
          <source>miscellany: &lt;code&gt;=&lt;/code&gt;&lt;code&gt;[]&lt;/code&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt;&lt;code&gt;-&amp;gt;*&lt;/code&gt;&lt;code&gt;,&lt;/code&gt;  (all binary infix); &lt;code&gt;*&lt;/code&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; (all unary prefix) &lt;code&gt;()&lt;/code&gt; (function call, n-ary infix)</source>
          <target state="translated">разное: &lt;code&gt;=&lt;/code&gt; &lt;code&gt;[]&lt;/code&gt; &lt;code&gt;-&amp;gt;&lt;/code&gt; &lt;code&gt;-&amp;gt;*&lt;/code&gt; &lt;code&gt;,&lt;/code&gt; (все двоичные инфиксы); &lt;code&gt;*&lt;/code&gt; &lt;code&gt;&amp;amp;&lt;/code&gt; (все унарные префиксы) &lt;code&gt;()&lt;/code&gt; (вызов функции, n-арный инфикс)</target>
        </trans-unit>
        <trans-unit id="c824aa9ad53891d9b5e9c118b4ffd5c133b27edd" translate="yes" xml:space="preserve">
          <source>which is very intuitive.</source>
          <target state="translated">что очень интуитивно понятно.</target>
        </trans-unit>
        <trans-unit id="0b24478dfb20b5a8671b13a521b4573226f340db" translate="yes" xml:space="preserve">
          <source>which is very non-intuitive.</source>
          <target state="translated">что очень неинтуитивно.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
