<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3010840">
    <body>
      <group id="3010840">
        <trans-unit id="71a94b16709bbf4aa3c32acb86f39f9864156150" translate="yes" xml:space="preserve">
          <source>(Directly answering your question: now you can!)</source>
          <target state="translated">(직접 질문에 대답 : 지금 할 수 있습니다!)</target>
        </trans-unit>
        <trans-unit id="ec51a3dc7ea6a2a72bde5feaa9c8672035a07a39" translate="yes" xml:space="preserve">
          <source>(The variable &lt;code&gt;s&lt;/code&gt; is different on each iteration, but can still be declared &lt;code&gt;const&lt;/code&gt; inside the loop body as long as it isn't modified there.)</source>
          <target state="translated">변수 &lt;code&gt;s&lt;/code&gt; 는 각 반복마다 다르지만 루프 본문 내에서 &lt;code&gt;const&lt;/code&gt; 를 선언 할 수 있습니다 (변수가 수정되지 않는 한).</target>
        </trans-unit>
        <trans-unit id="244801924519c2f465f969ec90a3aa5fd9d346b3" translate="yes" xml:space="preserve">
          <source>... with the added benefit of also knowing about the current index inside the loop</source>
          <target state="translated">... 루프 내부의 현재 색인에 대해 알고 있다는 추가 이점</target>
        </trans-unit>
        <trans-unit id="ec1bc5f8b9989f3244f9ead64e5db9328413aaec" translate="yes" xml:space="preserve">
          <source>...or this one...</source>
          <target state="translated">... 또는 이건 ...</target>
        </trans-unit>
        <trans-unit id="8d2614ef79acce87f4e8df94e0a87325e712b550" translate="yes" xml:space="preserve">
          <source>...or this one:</source>
          <target state="translated">... 또는 이것 :</target>
        </trans-unit>
        <trans-unit id="346ff56be0af3dfc4cf74b13b4f1a9723c7e753b" translate="yes" xml:space="preserve">
          <source>1. Just loop through an array</source>
          <target state="translated">1. 그냥 배열을 반복</target>
        </trans-unit>
        <trans-unit id="555d744b1f77d61c7e32ae7f1a90aff8db853562" translate="yes" xml:space="preserve">
          <source>1. Sequential &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">1. 순차 &lt;code&gt;for&lt;/code&gt; 루프 :</target>
        </trans-unit>
        <trans-unit id="fa1164fabc473c60d9122565248be869d4644b2f" translate="yes" xml:space="preserve">
          <source>2. Array.prototype.forEach</source>
          <target state="translated">2. Array.prototype.forEach</target>
        </trans-unit>
        <trans-unit id="6e8d1647574b4505b85422943502e4260626b5e9" translate="yes" xml:space="preserve">
          <source>2. Check if any of the elements in an array pass a test</source>
          <target state="translated">2. 배열의 요소 중 하나라도 테스트를 통과했는지 확인</target>
        </trans-unit>
        <trans-unit id="c6f4890b5c42211a8b71fa93fd4dc466a147e440" translate="yes" xml:space="preserve">
          <source>3. ES6 &lt;code&gt;for-of&lt;/code&gt; statement</source>
          <target state="translated">3. ES6 진술서</target>
        </trans-unit>
        <trans-unit id="170ca03f86983ae059350f3d39d8357d3c86d88a" translate="yes" xml:space="preserve">
          <source>3. Transform to a new array</source>
          <target state="translated">3. 새로운 배열로 변환</target>
        </trans-unit>
        <trans-unit id="29c50fb048ccffde9b75eeb5c873696dc6fad375" translate="yes" xml:space="preserve">
          <source>4. Sum up a particular property, and calculate its average</source>
          <target state="translated">4. 특정 재산을 요약하고 평균을 계산</target>
        </trans-unit>
        <trans-unit id="2dee4a4a056e6ed1617861aec6829069d797515e" translate="yes" xml:space="preserve">
          <source>5. Create a new array based on the original but without modifying it</source>
          <target state="translated">5. 원본을 기반으로하지만 수정하지 않고 새 어레이를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="60379d930daa877950b8a02d7df63a9f9158547b" translate="yes" xml:space="preserve">
          <source>6. Count the number of each category</source>
          <target state="translated">6. 각 카테고리의 수를 센다</target>
        </trans-unit>
        <trans-unit id="97078bd3f052e4a50a879e4f327d30b3bb437cb1" translate="yes" xml:space="preserve">
          <source>7. Retrieve a subset of an array based on particular criteria</source>
          <target state="translated">7. 특정 기준에 따라 어레이의 서브 세트 검색</target>
        </trans-unit>
        <trans-unit id="40b895b551e1a8bf16b710f73aad346b0750062e" translate="yes" xml:space="preserve">
          <source>8. Sort an array</source>
          <target state="translated">8. 배열 정렬</target>
        </trans-unit>
        <trans-unit id="944b4287e667dd3dc76140f392ce6f74b5e943d8" translate="yes" xml:space="preserve">
          <source>9. Find an element in an array</source>
          <target state="translated">9. 배열에서 요소 찾기</target>
        </trans-unit>
        <trans-unit id="f0b6e9ad3ee35377fad2b98e91e4addf653f72fa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://api.jquery.com/jquery.each/&quot;&gt;&lt;strong&gt;&lt;code&gt;jQuery.each()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, in &lt;a href=&quot;https://jquery.com/&quot;&gt;&lt;strong&gt;jQuery&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://jquery.com/&quot;&gt;&lt;strong&gt;jQuery의&lt;/strong&gt;&lt;/a&gt; &lt;a href=&quot;http://api.jquery.com/jquery.each/&quot;&gt;&lt;strong&gt; &lt;code&gt;jQuery.each()&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b261c82cdd26f431b814a6f9436b4fd59a1deb22" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://underscorejs.org/#each&quot;&gt;&lt;strong&gt;&lt;code&gt;_.each()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, in &lt;a href=&quot;http://underscorejs.org/&quot;&gt;&lt;strong&gt;Underscore.js&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://underscorejs.org/#each&quot;&gt;&lt;strong&gt; &lt;code&gt;_.each()&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c58511caaca6df233bc2182e3ec4036cfee42ef7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://lodash.com/docs#forEach&quot;&gt;&lt;strong&gt;&lt;code&gt;_.forEach()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, in &lt;a href=&quot;https://lodash.com/&quot;&gt;&lt;strong&gt;Lodash.js&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://lodash.com/docs#forEach&quot;&gt;&lt;strong&gt; &lt;code&gt;_.forEach()&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="52ca60a94f206d4eac02b402c38bb25a86fa23d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array.prototype.forEach()&lt;/code&gt; is supported by all modern browsers, as well as Internet&amp;nbsp;Explorer&amp;nbsp;9 and later.</source>
          <target state="translated">&lt;code&gt;Array.prototype.forEach()&lt;/code&gt; 는 모든 최신 브라우저와 Internet Explorer 9 이상에서 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="d3bfa9adc07d603c481ef7db3fa023766d732441" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;For...in&lt;/code&gt; and &lt;code&gt;for...of&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;For...in&lt;/code&gt; &lt;code&gt;for...of&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a54271474b32241db54533f0e2686f548830428" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt; doesn't give you the index associated with each object, but as long as the object you're iterating over is actually an &lt;code&gt;Array&lt;/code&gt; (&lt;code&gt;for&lt;/code&gt;..&lt;code&gt;of&lt;/code&gt; works for other iterable types which may not have this method), you can use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries&quot;&gt;Array#entries&lt;/a&gt; method to change it to an array of [index, item] pairs, and then iterate over that:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ... &lt;code&gt;of&lt;/code&gt; 는 각 객체와 관련된 인덱스를 제공하지 않지만 반복하는 객체가 실제로 &lt;code&gt;Array&lt;/code&gt; 인 경우 (이 방법이 없을 수있는 다른 반복 가능한 유형에 대한 작업) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries&quot;&gt;Array # entries&lt;/a&gt; 메소드를 사용하여 [index, item] 쌍의 배열로 변경 한 다음 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bb38035ceb1c396d3e7996795df8bf4c249f876" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(example extracted from &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&lt;/a&gt;)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&lt;/a&gt; 에서 추출한 예)&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf37ae0f080f8d39b2aaaf060b6cdeb79a3c67db" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;Array.prototype.forEach()&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;Array.prototype.forEach()&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="26e2ad632edf81fb7e89bc1c9c05201ffd6e306d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Compatibility table:&lt;/em&gt;&lt;a href=&quot;http://kangax.github.io/es5-compat-table/es6/&quot;&gt;http://kangax.github.io/es5-compat-table/es6/#For..of loops&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;호환성 테이블 :&lt;/em&gt; &lt;a href=&quot;http://kangax.github.io/es5-compat-table/es6/&quot;&gt;http://kangax.github.io/es5-compat-table/es6/#For..of 루프&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee6ae84753dccfa00cebeada5ae7c3e21d1273a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Spec:&lt;/em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:iterators&quot;&gt;http://wiki.ecmascript.org/doku.php?id=harmony:iterators&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;Spec:&lt;/em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:iterators&quot;&gt;http://wiki.ecmascript.org/doku.php?id=harmony:iterators&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="064b427011b9e17b9e8c52d0c2639ac7a841e64e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) For loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1) For 루프&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b51f60a16cebef810392106138bdb5ad294a4367" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) While loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2) While 루프&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a4c5db10da9d3be2f8b682db7a9e9d2f7183bdc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Do while&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3) 잠시 동안&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eef54d6b0a77c28db0f845a27fb46e78a54e93ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;jQuery.each( collection, callback(indexInArray, valueOfElement) )&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;jQuery.each( collection, callback(indexInArray, valueOfElement) )&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="daf1d3da9a9639317a8275f5459ed1e0ddfaa92a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Anti-pattern:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Anti-pattern:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="caf1f7a722c982dbd57c57da6fb19a30c4de09b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="704e3b0291568ed9b2c317a548493efb74047033" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Description:&lt;/strong&gt;&lt;em&gt;A generic iterator function, which can be used to
  seamlessly iterate over both objects and arrays. Arrays and array-like
  objects with a length property (such as a function's arguments object)
  are iterated by numeric index, from 0 to length-1. Other objects are
  iterated via their named properties.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;설명 :&lt;/strong&gt; &lt;em&gt;일반 반복자 함수로, 객체와 배열을 완벽하게 반복하는 데 사용할 수 있습니다.&lt;/em&gt; &lt;em&gt;length 속성 (예 : 함수의 arguments 객체)이있는 배열 및 배열 유사 객체는 0에서 길이 -1까지의 숫자 인덱스로 반복됩니다.&lt;/em&gt; &lt;em&gt;다른 객체는 명명 된 속성을 통해 반복됩니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="048e1c2143e4ceda5b814a601b1c670466d18b12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES5's forEach:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES5의 각 기능 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54f593ac46043f8cd9b8b5cf07af22c51c808d96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Generic loop:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;일반 루프 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f79071ea203b44120a777b7df731ac7eeaca3df3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterating a generator:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;생성기 반복 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="45c6df2e8979bcdde42829f806f00107ff130204" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterating an array of objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;객체 배열 반복&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee4457fb819a5b4a1c45f33c6d9277e095252e99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterating an array&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;배열 반복&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d0724a44cc225daaa925fdc5f4076cd6a8e137b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preparation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Preparation:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4679141d2baf9da770b2677b4605d0925bd20b32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Proper use case of &lt;em&gt;map&lt;/em&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;지도의&lt;/em&gt; 적절한 사용 사례 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83a9ba38fb48160c9afd7eb56731a2e28460dc89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Proper use of &lt;em&gt;reduce&lt;/em&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Reduce의&lt;/em&gt; 적절한 사용 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="364d4fdee3e0bca52971cff9ce11bfd5c1cd8d29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c74addec8c64f7706a870355eb69d171e4ffada" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returns:&lt;/strong&gt;&lt;em&gt;Object&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Returns:&lt;/strong&gt;&lt;em&gt;Object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9e855f63e3c1e56f1a45077526fe3d067eab2a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tests:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Tests:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a921ab2d2c8f22b4e62a469b18c3138401c9585" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The afterthought:&lt;/strong&gt; performed every time after the loop block is executed</source>
          <target state="translated">&lt;strong&gt;추후 :&lt;/strong&gt; 루프 블록이 실행될 때마다 수행</target>
        </trans-unit>
        <trans-unit id="0841879c44f870229f18babbbb28a4ed0218e63d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The condition:&lt;/strong&gt; checks a condition every time before the loop block is executed, and quits the loop if false</source>
          <target state="translated">&lt;strong&gt;조건 :&lt;/strong&gt; 루프 블록이 실행될 때마다 조건을 확인하고 false이면 루프를 종료합니다.</target>
        </trans-unit>
        <trans-unit id="ef6b1bf0d5160d7392a2ec56a57142f8de0324e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The initialization:&lt;/strong&gt; executed before the look block is executed the first time</source>
          <target state="translated">&lt;strong&gt;초기화 :&lt;/strong&gt; look 블록이 처음 실행되기 전에 실행</target>
        </trans-unit>
        <trans-unit id="83b0f4ed7f0a0bdf74518f2b95d2dc1099b984c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes&lt;/strong&gt;, you can do the same in JavaScript using a loop, but &lt;strong&gt;not limited&lt;/strong&gt; to that, there are many ways to do a loop over arrays in JavaScript. Imagine you have this array below, and you'd like to do a loop over it:</source>
          <target state="translated">&lt;strong&gt;예&lt;/strong&gt; , 루프를 사용하여 JavaScript에서 동일한 작업을 수행 할 수 있지만 &lt;strong&gt;이에 국한되지는 않지만&lt;/strong&gt; JavaScript에서 배열을 반복하는 방법에는 여러 가지가 있습니다. 이 배열이 아래에 있고 그 위에 루프를 만들고 싶다고 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="f841e3cc81531c69c584f7487ed89ea2ccac79f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;every&lt;/strong&gt; returns true if every array member passes the test.</source>
          <target state="translated">&lt;strong&gt;every&lt;/strong&gt; 는 모든 배열 구성원이 테스트를 통과하면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ae5396154ba12f2cbc9b6fb60697228d099a6bfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;filter&lt;/strong&gt; returns an array of items that satisfy some condition or test.</source>
          <target state="translated">&lt;strong&gt;필터&lt;/strong&gt; 는 일부 조건 또는 테스트를 만족하는 항목 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bdef08e47d03473e002381b0b85e4c365db03f3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;forEach&lt;/strong&gt; runs a function on each array member and doesn't return anything.</source>
          <target state="translated">&lt;strong&gt;forEach&lt;/strong&gt; 는 각 배열 멤버에서 함수를 실행하며 아무 것도 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4e0ee97333a8174d8fa7c7379cd31d5d7b455eb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;indexOf&lt;/strong&gt; and &lt;strong&gt;lastIndexOf&lt;/strong&gt; find the appropriate position of the first or last element that matches its argument exactly.</source>
          <target state="translated">&lt;strong&gt;indexOf&lt;/strong&gt; 및 &lt;strong&gt;lastIndexOf&lt;/strong&gt; 는 해당 인수와 정확히 일치하는 첫 번째 또는 마지막 요소의 적절한 위치를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="89bb2ea399853abc85cd80df1635dcb485fff8de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery.each:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery.each:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a7285fa826c294da33df813b34b34a49e92f76c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;map&lt;/strong&gt; is like forEach, but it returns an array of the results of the operation for each element.</source>
          <target state="translated">&lt;strong&gt;map&lt;/strong&gt; 은 forEach와 유사하지만 각 요소에 대한 연산 결과의 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="05b320d00a006bb181f7dc73f11bce756fd386ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;some&lt;/strong&gt; returns true if any pass the test.</source>
          <target state="translated">&lt;strong&gt;일부&lt;/strong&gt; 는 테스트를 통과하면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3b932bd9e58e3f9ce0d4b89f0f0f9034a0636581" translate="yes" xml:space="preserve">
          <source>@zipcodeman suggests the use of the &lt;code&gt;for...in&lt;/code&gt; statement, but for iterating arrays &lt;code&gt;for-in&lt;/code&gt; should be avoided, that statement is meant to &lt;strong&gt;enumerate&lt;/strong&gt; object properties.</source>
          <target state="translated">@zipcodeman은 &lt;code&gt;for...in&lt;/code&gt; 문 사용을 제안하지만 &lt;code&gt;for-in&lt;/code&gt; 배열 을 반복하지 않으려면 해당 문은 객체 속성을 &lt;strong&gt;열거&lt;/strong&gt; 하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="cc59d14dbd8a74031257140af343c1de66fa1c7e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do while&lt;/code&gt; is doing the same thing as &lt;code&gt;while&lt;/code&gt; with some syntax difference as below:</source>
          <target state="translated">&lt;code&gt;do while&lt;/code&gt; 아래와 같은 구문 차이가있을 &lt;code&gt;while&lt;/code&gt; 와 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="7ba0e7db2ec388ee16e982710586d5dcd4505fa1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop is a common way looping through arrays in JavaScript, but no considered as the fastest solutions for large arrays:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프는 JavaScript에서 배열을 반복하는 일반적인 방법이지만 큰 배열을위한 가장 빠른 솔루션으로 간주되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2e0ff643ee538083545089d13416135913cd236" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; loop</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 루프</target>
        </trans-unit>
        <trans-unit id="8138b8bf38e6eb381685855e53355dab4069f576" translate="yes" xml:space="preserve">
          <source>A lot cleaner...</source>
          <target state="translated">훨씬 더 깨끗한 ...</target>
        </trans-unit>
        <trans-unit id="208b5e319042638896984a55881d0d0b48f1809f" translate="yes" xml:space="preserve">
          <source>A note on sparse arrays: an array in JavaScript may not actually store as many items as reported by its &lt;code&gt;length&lt;/code&gt;; that reported number is simply one greater than the highest index at which a value is stored. If the array holds fewer elements than indicated by its length, its said to be &lt;em&gt;sparse&lt;/em&gt;. For example, it's perfectly legitimate to have an array with items only at indexes 3, 12, and 247; the &lt;code&gt;length&lt;/code&gt; of such an array is reported as 248, though it is only actually storing 3 values.  If you try to access an item at any other index, the array will appear to have the &lt;code&gt;undefined&lt;/code&gt; value there. So when you want to &quot;loop through&quot; an array, you have a question to answer: do you want to loop over the full range indicated by its length and process &lt;code&gt;undefined&lt;/code&gt;s for any missing elements, or do you only want to process the elements actually present? There are plenty of applications for both approaches; it just depends on what you're using the array for.</source>
          <target state="translated">희소 배열에 대한 참고 사항 : JavaScript의 배열은 실제로 &lt;code&gt;length&lt;/code&gt; 로보고 된만큼의 항목을 저장할 수 없습니다. 그보고 된 숫자는 단순히 값이 저장되는 가장 높은 인덱스보다 하나 더 큽니다. 배열이 길이로 표시된 것보다 적은 수의 요소를 보유하면 &lt;em&gt;희소&lt;/em&gt; 하다고합니다. 예를 들어, 인덱스 3, 12 및 247에만 항목이있는 배열을 갖는 것이 합법적입니다. 이러한 배열의 &lt;code&gt;length&lt;/code&gt; 는 실제로 3 개의 값만 저장하지만 248로보고됩니다. 다른 인덱스에서 항목에 액세스하려고하면 배열에 &lt;code&gt;undefined&lt;/code&gt; 값이있는 것처럼 보입니다. 따라서 배열을 &quot;루프 스루&quot;하려는 경우 대답해야 할 질문이 있습니다. 길이로 표시된 전체 범위를 반복하고 누락 된 요소에 대해 &lt;code&gt;undefined&lt;/code&gt; s를 처리 하시겠습니까, 아니면 요소 만 처리 하시겠습니까? 실제로 선물? 두 가지 접근 방식에 대한 많은 응용 프로그램이 있습니다. 배열을 사용하는 대상에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="1c8bc2da7ace60c25491e4b45d72527b6904edf7" translate="yes" xml:space="preserve">
          <source>A traditional &lt;code&gt;for&lt;/code&gt; loop has three components:</source>
          <target state="translated">전통적인 &lt;code&gt;for&lt;/code&gt; 루프에는 세 가지 구성 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="93369b398d50b7aaab7d717bce714a497353f9a1" translate="yes" xml:space="preserve">
          <source>A traditional &lt;code&gt;for&lt;/code&gt;-loop</source>
          <target state="translated">전통적인 &lt;code&gt;for&lt;/code&gt; - loop</target>
        </trans-unit>
        <trans-unit id="96d8cabd7458880b5703e2b2959e3cbf91d9b07e" translate="yes" xml:space="preserve">
          <source>A while loop is considered as the fastest way to loop through long arrays, but it is usually less used in the JavaScript code:</source>
          <target state="translated">while 루프는 긴 배열을 반복하는 가장 빠른 방법으로 간주되지만 일반적으로 JavaScript 코드에서 덜 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1bab4365e2766b395817dc81f2821118ea4e8b6d" translate="yes" xml:space="preserve">
          <source>A working jsFiddle example:
&lt;a href=&quot;https://jsfiddle.net/workingClassHacker/pxpv2dh5/7/&quot;&gt;https://jsfiddle.net/workingClassHacker/pxpv2dh5/7/&lt;/a&gt;</source>
          <target state="translated">작동하는 jsFiddle 예제 : &lt;a href=&quot;https://jsfiddle.net/workingClassHacker/pxpv2dh5/7/&quot;&gt;https://jsfiddle.net/workingClassHacker/pxpv2dh5/7/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87989326732077c33a82222d4512a023029ffac3" translate="yes" xml:space="preserve">
          <source>Additionally, you need to consider that no version of Internet Explorer supports &lt;code&gt;for...of&lt;/code&gt; (&lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;&lt;strong&gt;Edge 12+&lt;/strong&gt;&lt;/a&gt; does) and that &lt;code&gt;for...in&lt;/code&gt; requires at least Internet&amp;nbsp;Explorer&amp;nbsp;10.</source>
          <target state="translated">또한 ( &lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;&lt;strong&gt;Edge 12+&lt;/strong&gt;&lt;/a&gt; 가 지원 &lt;code&gt;for...of&lt;/code&gt; Internet Explorer 버전은 지원하지 않으며 Internet Explorer 10 이상이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7bdea304f3832a9d1bee7adfb3ce1b3900b31457" translate="yes" xml:space="preserve">
          <source>Also look at the &lt;code&gt;map()&lt;/code&gt;, &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;reduce()&lt;/code&gt;, etc. functions on an Array in JavaScript. They may do things much faster and better than using &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt;.</source>
          <target state="translated">JavaScript의 배열에서 &lt;code&gt;map()&lt;/code&gt; , &lt;code&gt;filter()&lt;/code&gt; , &lt;code&gt;reduce()&lt;/code&gt; 등 함수를 살펴보십시오. 그들은 &lt;code&gt;while&lt;/code&gt; 과 &lt;code&gt;for&lt;/code&gt; 를 사용 하는 것보다 훨씬 빠르고 더 좋은 일을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d7962bb439dccc6fd05184547a30773438f73c3" translate="yes" xml:space="preserve">
          <source>Also we use a &lt;code&gt;for in&lt;/code&gt; loop for looping over objects in JavaScript.</source>
          <target state="translated">또한 JavaScript에서 객체를 반복하기 &lt;code&gt;for in&lt;/code&gt; 루프를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="41378cebb50d920582b6d22c47f75d416ff10194" translate="yes" xml:space="preserve">
          <source>Also, as CMS mentions in a comment below, you can only use this on arrays that don't contain any falsish values. The array of strings from the example works, but if you have empty strings, or numbers that are 0 or NaN, etc. the loop will break off prematurely. Again in practice this is hardly ever a problem for me, but it is something to keep in mind, which makes this a loop to think about before you use it... That may disqualify it for some people :)</source>
          <target state="translated">또한 CMS가 아래 주석에서 언급했듯이 허위 값이 포함되지 않은 배열에서만 사용할 수 있습니다. 예제의 문자열 배열은 작동하지만 빈 문자열이나 0 또는 NaN 등의 숫자가 있으면 루프가 조기에 끊어집니다. 다시 말하지만 실제로 이것은 결코 문제가되지 않지만 명심해야 할 것이 있습니다.이를 사용하기 전에이 루프를 생각해보십시오 ... 일부 사람들에게는 실격 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="ee77eebe99af67ab08f84860fed6f896852d7c5f" translate="yes" xml:space="preserve">
          <source>Also, if you are trying to &lt;em&gt;reduce&lt;/em&gt; the array to a value, for example, you want to sum an array of numbers, you should use the &lt;em&gt;reduce&lt;/em&gt; method.</source>
          <target state="translated">또한 배열을 값으로 &lt;em&gt;줄이려고&lt;/em&gt; 하는 경우 (예를 들어 숫자 배열을 합하려는 경우) &lt;em&gt;reduce&lt;/em&gt; 메소드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="14295abe04b6e2a7de39a9d704b37a8979113366" translate="yes" xml:space="preserve">
          <source>Also, note that every while loop can be rewritten as a &lt;code&gt;for&lt;/code&gt; loop. For example, the &lt;code&gt;while&lt;/code&gt; loop hereabove behaves the exact same way as this &lt;code&gt;for&lt;/code&gt;-loop:</source>
          <target state="translated">또한 모든 while 루프를 &lt;code&gt;for&lt;/code&gt; 루프로 다시 작성할 수 있습니다. 예를 들어, 위의 &lt;code&gt;while&lt;/code&gt; 루프 &lt;code&gt;for&lt;/code&gt; -loop의 경우와 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d4c7b480881659d668d6e1c838c1bbd6f2357af6" translate="yes" xml:space="preserve">
          <source>An alternative to &lt;code&gt;for&lt;/code&gt;-loops is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;strong&gt;&lt;code&gt;Array.prototype.forEach()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, which uses the following syntax:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; -loops의 대안은 다음 구문을 사용하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;strong&gt; &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7608e4a05c083f0749c3b00ef49e63f9bb0d59f7" translate="yes" xml:space="preserve">
          <source>And for the reverse order, an even more efficient loop</source>
          <target state="translated">역순의 경우 훨씬 효율적인 루프</target>
        </trans-unit>
        <trans-unit id="ea3c12f54f03b3157d901d7ecb01d0c6e8c6314b" translate="yes" xml:space="preserve">
          <source>And now x is &lt;code&gt;[10,20,30,40]&lt;/code&gt;.</source>
          <target state="translated">이제 x는 &lt;code&gt;[10,20,30,40]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b16c84749f0eea7f146f4aab53c2350db832cc15" translate="yes" xml:space="preserve">
          <source>And with the ES6 arrow function syntax, it's even more succinct:</source>
          <target state="translated">그리고 ES6 화살표 함수 구문을 사용하면 훨씬 간결합니다.</target>
        </trans-unit>
        <trans-unit id="9aee1dfe4cd64107cde999301ba98e4228ffd0ba" translate="yes" xml:space="preserve">
          <source>Array loop:</source>
          <target state="translated">배열 루프 :</target>
        </trans-unit>
        <trans-unit id="59df7171edff63098689b1d4cbcde62b62c5c672" translate="yes" xml:space="preserve">
          <source>Array objects are by definition built-in iterables in ES6, so you can use this statement on them:</source>
          <target state="translated">ES6에는 배열 객체가 정의 된 내장 이터 러블이므로이 명령문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b48533ed470f313be2a50e6f04cca823d741861" translate="yes" xml:space="preserve">
          <source>Array.prototype.filter()</source>
          <target state="translated">Array.prototype.filter()</target>
        </trans-unit>
        <trans-unit id="a71dca401c8bb6c1ba8a6a85b489323db0aded15" translate="yes" xml:space="preserve">
          <source>Array.prototype.find()</source>
          <target state="translated">Array.prototype.find()</target>
        </trans-unit>
        <trans-unit id="4cb3cae1053ce2bb98a5b83b932f46c25e31ba9b" translate="yes" xml:space="preserve">
          <source>Array.prototype.forEach()</source>
          <target state="translated">Array.prototype.forEach()</target>
        </trans-unit>
        <trans-unit id="119e13f09e922be9e6bae1b2eb26f44372c5447b" translate="yes" xml:space="preserve">
          <source>Array.prototype.map()</source>
          <target state="translated">Array.prototype.map()</target>
        </trans-unit>
        <trans-unit id="4e64033432afb4813d9f7c316c2ce7cc3e7a8ccd" translate="yes" xml:space="preserve">
          <source>Array.prototype.some()</source>
          <target state="translated">Array.prototype.some()</target>
        </trans-unit>
        <trans-unit id="7038dcb1eaea94f778a783fcd9d69b9aa89101f4" translate="yes" xml:space="preserve">
          <source>Array.prototype.sort()</source>
          <target state="translated">Array.prototype.sort()</target>
        </trans-unit>
        <trans-unit id="a34e33465f051a1d48b1d51dd13cef09aa81c0c5" translate="yes" xml:space="preserve">
          <source>Arrow functions are also widely implemented unless you plan to support ancient platforms (e.g., IE11); you are also safe to go.</source>
          <target state="translated">화살표 기능은 고대 플랫폼 (예 : IE11)을 지원할 계획이 아니라면 널리 구현됩니다. 당신은 또한 안전합니다.</target>
        </trans-unit>
        <trans-unit id="966cddcbaa10c67096f934e4803322a1c2ad7ec2" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;strong&gt;&lt;code&gt;for...in&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, there's now also for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;strong&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;. The following example shows the difference between a &lt;code&gt;for...of&lt;/code&gt; loop and a &lt;code&gt;for...in&lt;/code&gt; loop:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;strong&gt; &lt;code&gt;for...in&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; 의 대안으로, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;strong&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; 있습니다. 다음 예제는 &lt;code&gt;for...of&lt;/code&gt; 루프와 &lt;code&gt;for...in&lt;/code&gt; 루프의 차이점을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="47221220436db2e97d5585cd374547abd2cdc928" translate="yes" xml:space="preserve">
          <source>As long as your JavaScript implementation is compliant with the &lt;em&gt;previous&lt;/em&gt; edition of the ECMAScript specification (which rules out, for example, versions of Internet Explorer before 9), then you can use the &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.foreach&quot;&gt;&lt;code&gt;Array#forEach&lt;/code&gt;&lt;/a&gt; iterator method instead of a loop. In that case, you pass a function to be called on each item in the array:</source>
          <target state="translated">JavaScript 구현이 ECMAScript 사양의 &lt;em&gt;이전&lt;/em&gt; 버전 (예 : 9 이전의 Internet Explorer 버전을 배제)을 준수하는 경우 루프 대신 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.foreach&quot;&gt; &lt;code&gt;Array#forEach&lt;/code&gt; &lt;/a&gt; 반복자 메소드를 사용할 수 있습니다. 이 경우 배열의 각 항목에서 호출 할 함수를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="cc57a09cc87a254c6e7c0cd906743181aa3a7326" translate="yes" xml:space="preserve">
          <source>Assigning the length value to the local variable (as opposed to including the full &lt;code&gt;myStringArray.length&lt;/code&gt; expression in the loop condition) can make a significant difference in performance since it skips a property lookup each time through; using Rhino on my machine, the speedup is 43%.</source>
          <target state="translated">루프 조건에 전체 &lt;code&gt;myStringArray.length&lt;/code&gt; 식을 포함하는 것과 달리 로컬 변수에 길이 값을 할당하면 매번 속성 조회를 건너 뛰기 때문에 성능이 크게 달라질 수 있습니다. 내 컴퓨터에서 Rhino를 사용하면 속도가 43 % 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="f3274f27a722ba9623d1b3c45014647813c3ad0d" translate="yes" xml:space="preserve">
          <source>Being almost ten years as the time of writing that the ES5 specification was released (Dec. 2009), it has been implemented by nearly all modern engines in the desktop, server, and mobile environments, so it's safe to use them.</source>
          <target state="translated">ES5 사양이 발표 된 시점 (2009 년 12 월)이 작성된 시점에서 거의 10 년이 지난 지금, 데스크탑, 서버 및 모바일 환경의 거의 모든 최신 엔진에 의해 구현되었으므로 안전하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2dd3bc0add58e1c1a3bae79831bd75535ddcea2a" translate="yes" xml:space="preserve">
          <source>Can use normal flow control statements (&lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt;).</source>
          <target state="translated">일반적인 흐름 제어문을 사용할 수 있습니다 ( &lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="738f7a02d196b0ea75cd3e9615801f4654f464c6" translate="yes" xml:space="preserve">
          <source>Can you do the same in JavaScript?</source>
          <target state="translated">JavaScript에서도 같은 작업을 수행 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="bb89c713f3058705a62ca86f844888cbdaec51e9" translate="yes" xml:space="preserve">
          <source>Cannot use &lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt; 사용할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="b36f8d07e1ebb98db02a451f012dc4e52c8f57bf" translate="yes" xml:space="preserve">
          <source>Combines very naturally with array.push and array.splice to use arrays like lists/stacks</source>
          <target state="translated">리스트 / 스택과 같은 배열을 사용하기 위해 array.push 및 array.splice와 매우 자연스럽게 결합</target>
        </trans-unit>
        <trans-unit id="0867c816fed31b5dc07fa208e04fcb8489f13b48" translate="yes" xml:space="preserve">
          <source>Comparing methods for looping through an array of 100000 items and do a minimal operation with the new value each time.</source>
          <target state="translated">100000 개 항목의 배열을 반복하는 방법을 비교하고 매번 새로운 값으로 최소한의 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3484c6fcb53ac09a3fead481f71e452bc3f9e097" translate="yes" xml:space="preserve">
          <source>Declarative</source>
          <target state="translated">Declarative</target>
        </trans-unit>
        <trans-unit id="4effb93b81a160f681429d60f84b0435de4c8948" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;for...in&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; 사용하지 마십시오</target>
        </trans-unit>
        <trans-unit id="7a327a1024dd4bfffdf3d3e9c43606dd74e3c14b" translate="yes" xml:space="preserve">
          <source>Easy to have &lt;a href=&quot;https://en.wikipedia.org/wiki/Off-by-one_error#Looping_over_arrays&quot;&gt;off-by-one errors&lt;/a&gt; (sometimes also called a &lt;em&gt;fence post error&lt;/em&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Off-by-one_error#Looping_over_arrays&quot;&gt;일대일 오류가 발생&lt;/a&gt; 하기 쉽습니다 (때때로 &lt;em&gt;펜스 포스트 오류&lt;/em&gt; 라고도 함)</target>
        </trans-unit>
        <trans-unit id="792e26d9ee80b19650012b8e1685b5090c7185da" translate="yes" xml:space="preserve">
          <source>Edited (because I was wrong)</source>
          <target state="translated">내가 잘못했기 때문에 수정 됨</target>
        </trans-unit>
        <trans-unit id="a69fa90f2006d689445d656a40e7e8de54b4823e" translate="yes" xml:space="preserve">
          <source>Enumeration VS Iteration</source>
          <target state="translated">열거 VS 반복</target>
        </trans-unit>
        <trans-unit id="2e71f7108ada8318088ac69ef4919973105c6a36" translate="yes" xml:space="preserve">
          <source>Except you don't get the &lt;code&gt;new_list&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;new_list&lt;/code&gt; 를 얻지 않는 한.</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="5952055811aee2e799c8aba3a69449f3348a23fc" translate="yes" xml:space="preserve">
          <source>Finally, many utility libraries also have their own &lt;code&gt;foreach&lt;/code&gt; variation. AFAIK, the three most popular ones are these:</source>
          <target state="translated">마지막으로, 많은 유틸리티 라이브러리에는 고유 한 &lt;code&gt;foreach&lt;/code&gt; 변형이 있습니다. 가장 인기있는 세 가지 AFAIK는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="69464752c7da492f7d32ce20b9cb8b32ed093960" translate="yes" xml:space="preserve">
          <source>For example, I used in a Firefox console:</source>
          <target state="translated">예를 들어 Firefox 콘솔에서 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">예를 들어 :</target>
        </trans-unit>
        <trans-unit id="4b130c10bf2374ee6a7bc0052bacfac69fa72cc6" translate="yes" xml:space="preserve">
          <source>For me, this construct most closely emulates the Java 5 syntax that I love:</source>
          <target state="translated">나 에게이 구조는 내가 좋아하는 Java 5 구문을 가장 가깝게 모방합니다.</target>
        </trans-unit>
        <trans-unit id="332ea3a31e79d47a90b9a3ccec9c1cdfdbaa5829" translate="yes" xml:space="preserve">
          <source>From the documentation:</source>
          <target state="translated">설명서에서 :</target>
        </trans-unit>
        <trans-unit id="d8f88d3b1d0ba856a7a6feeeff6fceeb8172f54f" translate="yes" xml:space="preserve">
          <source>Functional programming has been making quite a splash in the
  development world these days. And for good reason: Functional
  techniques can help you write more declarative code that is easier to
  understand at a glance, refactor, and test.</source>
          <target state="translated">함수형 프로그래밍은 오늘날 개발 도상국에서 상당히 시작되었습니다. 그리고 정당한 이유 : 기능적 기술을 사용하면 한눈에 이해하고 리팩토링하고 테스트 할 수있는보다 선언적인 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1dd7c2693b617aa4bf3153d763983796bfb81010" translate="yes" xml:space="preserve">
          <source>Given an array:</source>
          <target state="translated">주어진 배열 :</target>
        </trans-unit>
        <trans-unit id="71f5b35dbf42c10acd92d892d5a9a39d98b97a52" translate="yes" xml:space="preserve">
          <source>Have a look &lt;a href=&quot;https://stackoverflow.com/questions/3943494/how-to-loop-through-array-in-jquery&quot;&gt;this&lt;/a&gt; for detailed information or you can also check &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;MDN&lt;/a&gt; for looping through an array in JavaScript &amp;amp; using jQuery check &lt;a href=&quot;http://api.jquery.com/jquery.each/&quot;&gt;jQuery for each&lt;/a&gt;.</source>
          <target state="translated">자세한 정보를 보려면 &lt;a href=&quot;https://stackoverflow.com/questions/3943494/how-to-loop-through-array-in-jquery&quot;&gt;이것을&lt;/a&gt; 보거나 JavaScript에서 배열을 반복 &lt;a href=&quot;http://api.jquery.com/jquery.each/&quot;&gt;하고 각 jQuery jQuery jQuery를&lt;/a&gt; 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;MDN&lt;/a&gt; 을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a275f06b64b792994a2bea49ec5edd99e73a997" translate="yes" xml:space="preserve">
          <source>Hence:</source>
          <target state="translated">Hence:</target>
        </trans-unit>
        <trans-unit id="36fb22ec3194ab597f2415160001e28b55136fda" translate="yes" xml:space="preserve">
          <source>I did not yet see this variation, which I personally like the best:</source>
          <target state="translated">나는 개인적으로 가장 좋아하는이 변형을 보지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="bc84262abb174c9f0e38f36c626a6768b31337c7" translate="yes" xml:space="preserve">
          <source>I would recommend you to read the following article:</source>
          <target state="translated">다음 기사를 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="eaec00891170c602b86758588121582f9cc77f86" translate="yes" xml:space="preserve">
          <source>I would thoroughly recommend making use of the &lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;underscore.js&lt;/a&gt; library. It provides you with various functions that you can use to iterate over arrays/collections.</source>
          <target state="translated">&lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;underscore.js&lt;/a&gt; 라이브러리를 사용하는 것이 좋습니다. 배열 / 컬렉션을 반복하는 데 사용할 수있는 다양한 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="680e5f2fe4669cc64fca6d0dce2445fc1aba9665" translate="yes" xml:space="preserve">
          <source>If anybody is interested in the performance side of the multiple mechanisms available for Array iterations, I've prepared the following JSPerf tests:</source>
          <target state="translated">배열 반복에 사용 가능한 여러 메커니즘의 성능 측면에 관심이있는 사람은 다음 JSPerf 테스트를 준비했습니다.</target>
        </trans-unit>
        <trans-unit id="fb3e18a35d3138a4789c20ff08015dcd8a81b50b" translate="yes" xml:space="preserve">
          <source>If one wants to iterate over sparsed array, &lt;code&gt;for (var i = 0; i &amp;lt; array.length; i++) if (i in array)&lt;/code&gt; or &lt;code&gt;array.forEach&lt;/code&gt; with &lt;code&gt;es5shim&lt;/code&gt; should be used.</source>
          <target state="translated">희소 배열을 반복하고 싶다면 &lt;code&gt;for (var i = 0; i &amp;lt; array.length; i++) if (i in array)&lt;/code&gt; 또는 &lt;code&gt;array.forEach&lt;/code&gt; with &lt;code&gt;es5shim&lt;/code&gt; 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e7c24db9c43e39fc71182c2e8052375e6c248727" translate="yes" xml:space="preserve">
          <source>If order of iteration does not matter than you should try reversed loop, it is fastest as it reduce overhead condition testing and decrement is in one statement:</source>
          <target state="translated">반복 루프를 시도하는 것보다 반복 순서가 중요하지 않은 경우 오버 헤드 조건 테스트를 줄이고 하나의 명령문으로 감소하므로 가장 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="02757283e37586df6bb23c4f4ba9f10dab95d8e4" translate="yes" xml:space="preserve">
          <source>If you are targeting older browsers, the transpiled output &lt;a href=&quot;https://babeljs.io/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=GYewTgBAFAxiB2BnALhOAbcETDSTYiAlAN4BQEeS-ApgHSYDms-4RA3GQL5A&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=true&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=false&amp;amp;presets=es2015&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.4&amp;amp;externalPlugins=&quot;&gt;might surprise you&lt;/a&gt;.</source>
          <target state="translated">이전 브라우저를 대상으로하는 경우 변환 된 출력 결과 &lt;a href=&quot;https://babeljs.io/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=GYewTgBAFAxiB2BnALhOAbcETDSTYiAlAN4BQEeS-ApgHSYDms-4RA3GQL5A&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=true&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=false&amp;amp;presets=es2015&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.4&amp;amp;externalPlugins=&quot;&gt;가 놀라 울 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f829a0689ccf713644890b1c3b1a4cfc8ad34e87" translate="yes" xml:space="preserve">
          <source>If you iterate over an array with &lt;code&gt;for&lt;/code&gt;..&lt;code&gt;of&lt;/code&gt;, the body of the loop is executed &lt;code&gt;length&lt;/code&gt; times, and the loop control variable is set to &lt;code&gt;undefined&lt;/code&gt; for any items not actually present in the array. Depending on the details of your &quot;do something with&quot; code, that behavior may be what you want, but if not, you should use a different approach.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; .. &lt;code&gt;of&lt;/code&gt; 를 사용하여 배열을 반복하면 루프 본문이 &lt;code&gt;length&lt;/code&gt; 시간 동안 실행되고 배열에 실제로 존재하지 않는 항목에 대해 루프 제어 변수가 &lt;code&gt;undefined&lt;/code&gt; 것으로 설정됩니다. &quot;함께하는 것&quot;코드의 세부 사항에 따라 해당 동작이 원하는 것일 수 있지만 그렇지 않은 경우 다른 방법을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6b16cc5e544f97e4c2c7404c40a6b88137b3439b" translate="yes" xml:space="preserve">
          <source>If you want a terse way to write a fast loop &lt;em&gt;and&lt;/em&gt; you can iterate in reverse:</source>
          <target state="translated">빠른 루프를 작성하는 간결한 방법을 원하고 반대로 반복 할 수있는 경우 :</target>
        </trans-unit>
        <trans-unit id="436e7053c19b3557bdfbc7e2a4a3f788195af7aa" translate="yes" xml:space="preserve">
          <source>If you want to use jQuery, it has a nice example in its documentation:</source>
          <target state="translated">jQuery를 사용하려면 설명서에 좋은 예가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc55dbfa6cee82874054cf5092582433ac1060f8" translate="yes" xml:space="preserve">
          <source>If you're using the jQuery library, consider using 
&lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt;http://api.jquery.com/jQuery.each/&lt;/a&gt;</source>
          <target state="translated">jQuery 라이브러리를 사용하는 경우 &lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt;http://api.jquery.com/jQuery.each/&lt;/a&gt; 사용을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e36ebcd66de4bbd012f26e5f05e31de1189ca804" translate="yes" xml:space="preserve">
          <source>Ignore it until you need it.</source>
          <target state="translated">필요할 때까지 무시하십시오.</target>
        </trans-unit>
        <trans-unit id="810e4fa4821d4188cefc7672710f24bed2a3c1d5" translate="yes" xml:space="preserve">
          <source>Imperative</source>
          <target state="translated">Imperative</target>
        </trans-unit>
        <trans-unit id="583ae6d68b9b829162aa0ace11f35929d9bb4712" translate="yes" xml:space="preserve">
          <source>In Java you can use a &lt;code&gt;for&lt;/code&gt; loop to traverse objects in an array as follows:</source>
          <target state="translated">Java에서는 &lt;code&gt;for&lt;/code&gt; 루프를 사용하여 다음과 같이 배열의 객체를 순회 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6d0674a47d5e4c6ee7188e8d56862dcbd6ae33a" translate="yes" xml:space="preserve">
          <source>In JavaScript any custom property could be assigned to any object, including an array.</source>
          <target state="translated">JavaScript에서는 배열을 포함하여 모든 사용자 지정 속성을 모든 개체에 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee17c9f5432f037f208458ad5d51fc6145640287" translate="yes" xml:space="preserve">
          <source>In JavaScript it's not advisable to loop through an Array with a for-in loop, but it's better to use a &lt;code&gt;for&lt;/code&gt; loop such as:</source>
          <target state="translated">JavaScript에서는 for-in 루프를 사용하여 Array를 반복하는 것이 좋지 않지만 다음과 같은 &lt;code&gt;for&lt;/code&gt; 루프를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1affd76d51cbc1ab4da5924b815463734ac0f427" translate="yes" xml:space="preserve">
          <source>In JavaScript, there are so many solutions to loop an array.</source>
          <target state="translated">JavaScript에는 배열을 반복하는 솔루션이 너무 많습니다.</target>
        </trans-unit>
        <trans-unit id="509626629442545fa142bc6b90e393ef90bfd1d2" translate="yes" xml:space="preserve">
          <source>In JavaScript, you can also do this:</source>
          <target state="translated">JavaScript에서 다음을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc5977a0c215f5a97db26f12ccd984993cb76e07" translate="yes" xml:space="preserve">
          <source>In a browser console, you can see something like &quot;element1&quot;, &quot;element2&quot;, etc., printed.</source>
          <target state="translated">브라우저 콘솔에서 &quot;element1&quot;, &quot;element2&quot;등과 같은 인쇄 된 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8cdbcc1ec9b2f241eea1c7f52b02c03840b2a13" translate="yes" xml:space="preserve">
          <source>In general &lt;code&gt;func&lt;/code&gt; would take one parameter, which is an item of the array. But in the case of JavaScript, it can take a second parameter which is the item's index, and a third parameter which is the array itself.</source>
          <target state="translated">일반적으로 &lt;code&gt;func&lt;/code&gt; 은 배열의 항목 인 하나의 매개 변수를 사용합니다. 그러나 JavaScript의 경우 항목의 인덱스 인 두 번째 매개 변수와 배열 자체 인 세 번째 매개 변수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd0e1873da03f1238cdcd8d46e69b571337886d4" translate="yes" xml:space="preserve">
          <source>In the above example, the &lt;code&gt;hasOwnProperty&lt;/code&gt; method allows you to enumerate only &lt;em&gt;own properties&lt;/em&gt;, that's it, only the properties that the object physically has, no inherited properties.</source>
          <target state="translated">위의 예제에서 &lt;code&gt;hasOwnProperty&lt;/code&gt; 메서드를 사용하면 &lt;em&gt;자신의 속성&lt;/em&gt; , 즉 객체에 물리적으로있는 속성 만 상속 된 속성 만 열거 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="731f9b52cf3864b4e845afc26f5823a015b6f718" translate="yes" xml:space="preserve">
          <source>Inherited properties are also enumerated.</source>
          <target state="translated">상속 된 속성도 열거됩니다.</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="6371b79462d66a07f6e9b72523ff8fb46bd76993" translate="yes" xml:space="preserve">
          <source>It also means you'll never have to write a for loop again.</source>
          <target state="translated">또한 for 루프를 다시 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4d5482c75593dd4638959de0178a2d6ee6f654e4" translate="yes" xml:space="preserve">
          <source>It also works on Node (I tested it on version 0.12.0).</source>
          <target state="translated">노드에서도 작동합니다 (버전 0.12.0에서 테스트했습니다).</target>
        </trans-unit>
        <trans-unit id="c7afdd2fab1fe4c50035aa8b7a97f2ca3d7a8fe9" translate="yes" xml:space="preserve">
          <source>It can iterate over a large variety of objects.</source>
          <target state="translated">다양한 객체를 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5e0298a8f63b40bf1dbd95d72b4565988c2bb43" translate="yes" xml:space="preserve">
          <source>It currently works with Firefox 13+, Chrome 37+ and it does not natively work with other browsers (see browser compatibility below). Luckily we have JS compilers (such as &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;) that allow us to use next-generation features today.</source>
          <target state="translated">현재 Firefox 13 이상, Chrome 37 이상에서 작동하며 다른 브라우저에서는 기본적으로 작동하지 않습니다 (아래 브라우저 호환성 참조). 운 좋게도 오늘날 차세대 기능을 사용할 수있는 JS 컴파일러 (예 : &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; )가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7f1e474a3cbb522e7737b4c41a0e6c6aa40d314" translate="yes" xml:space="preserve">
          <source>It shouldn't be used for array-like objects because:</source>
          <target state="translated">다음과 같은 이유로 배열과 같은 객체에 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="618aee3ec871071cafa5f2c415e6c3ad428f6c63" translate="yes" xml:space="preserve">
          <source>It works like this:</source>
          <target state="translated">다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="729fd72bc10f5b53441cfd34a43c99d234bed82b" translate="yes" xml:space="preserve">
          <source>It's not 100% identical, but similar:</source>
          <target state="translated">100 % 동일하지는 않지만 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="d2c98a7efcec06920db9cb117bd433708798538f" translate="yes" xml:space="preserve">
          <source>It's optimized as well (&quot;caching&quot; the array length). If you'd like to learn more, &lt;a href=&quot;http://blog.sebarmeli.com/2010/12/06/best-way-to-loop-through-an-array-in-javascript/&quot;&gt;read my post on the subject&lt;/a&gt;.</source>
          <target state="translated">또한 배열 길이를 &quot;캐싱&quot;합니다. 자세한 내용을 보려면 &lt;a href=&quot;http://blog.sebarmeli.com/2010/12/06/best-way-to-loop-through-an-array-in-javascript/&quot;&gt;주제에 대한 내 게시물을 읽으십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="46a98fc5f1adbc9ced665ed928468799beb685aa" translate="yes" xml:space="preserve">
          <source>It's short to write</source>
          <target state="translated">쓰기가 짧다</target>
        </trans-unit>
        <trans-unit id="b67411757f4baa65933449ae3c433b43e33a3bec" translate="yes" xml:space="preserve">
          <source>Keep in mind if you are iterating an array &lt;em&gt;to build another array from it&lt;/em&gt;, you should use &lt;code&gt;map&lt;/code&gt;, I've seen this anti-pattern so many times.</source>
          <target state="translated">배열 &lt;em&gt;을&lt;/em&gt; 반복하여 &lt;em&gt;다른 배열을 작성하는&lt;/em&gt; 경우 &lt;code&gt;map&lt;/code&gt; 을 사용해야합니다.이 안티 패턴을 여러 번 보았습니다.</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="a3c5490fc48c1e07b7f4efa147aa56f508ce53b0" translate="yes" xml:space="preserve">
          <source>Like traditional &lt;code&gt;for&lt;/code&gt; loops, &lt;code&gt;while&lt;/code&gt; loops are supported by even the oldest of browsers.</source>
          <target state="translated">전통적인 &lt;code&gt;for&lt;/code&gt; 루프와 마찬가지로 루프는 가장 오래된 브라우저에서도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="cead623be3ff7a811535895bde64a1c14f83edd4" translate="yes" xml:space="preserve">
          <source>Loop through an array in JavaScript</source>
          <target state="translated">JavaScript에서 배열을 반복</target>
        </trans-unit>
        <trans-unit id="43395e0915b2f80810ff1d9bf284e72478f3a7d9" translate="yes" xml:space="preserve">
          <source>Modern browsers all support iterator methods &lt;code&gt;forEach&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt; and a host of other methods on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array?redirectlocale=en-US&amp;amp;redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray&quot;&gt;Array prototype&lt;/a&gt;.</source>
          <target state="translated">최신 브라우저는 모두 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array?redirectlocale=en-US&amp;amp;redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray&quot;&gt;Array 프로토 타입&lt;/a&gt; 에서 각, &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;reduce&lt;/code&gt; , &lt;code&gt;filter&lt;/code&gt; 및 기타 여러 메소드에 대한 반복기 메소드를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="413b0f0902d335e117f52bb6f630c916500b39e6" translate="yes" xml:space="preserve">
          <source>Most other answers are right, but they do not mention (as of this writing) that &lt;strong&gt;&lt;em&gt;ECMA Script &lt;strike&gt;&amp;nbsp;6&amp;nbsp;&lt;/strike&gt; 2015&lt;/em&gt;&lt;/strong&gt; is bringing a new mechanism for doing iteration, the &lt;strong&gt;&lt;code&gt;for..of&lt;/code&gt;&lt;/strong&gt; loop.</source>
          <target state="translated">대부분의 다른 대답은 옳지 만 &lt;strong&gt;&lt;em&gt;ECMA Script &lt;strike&gt;6&lt;/strike&gt; 2015&lt;/em&gt;&lt;/strong&gt; 가 &lt;strong&gt; &lt;code&gt;for..of&lt;/code&gt; &lt;/strong&gt; 루프를 반복하는 새로운 메커니즘을 도입하고 있다고 언급하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="5aa5faa92650187f67128950cd34998418f5d033" translate="yes" xml:space="preserve">
          <source>Mozilla Labs published the algorithms they and &lt;a href=&quot;http://en.wikipedia.org/wiki/WebKit&quot;&gt;WebKit&lt;/a&gt; both use, so that you can add them yourself.</source>
          <target state="translated">Mozilla Labs는 자신과 &lt;a href=&quot;http://en.wikipedia.org/wiki/WebKit&quot;&gt;WebKit이&lt;/a&gt; 모두 사용하는 알고리즘을 공개하여 직접 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bbeedb096ad8a164494e42f681d03f151eee20a" translate="yes" xml:space="preserve">
          <source>No need to access (let alone cache) the length property</source>
          <target state="translated">길이 속성에 액세스 할 필요가 없습니다 (캐시 만 허용).</target>
        </trans-unit>
        <trans-unit id="b43994d34a5fafb7a2888982d67dca097a47a6e9" translate="yes" xml:space="preserve">
          <source>Normally, you can replace the need to &lt;code&gt;break&lt;/code&gt; out of imperative loops by filtering the array elements before iterating them, for example:</source>
          <target state="translated">일반적으로 배열 요소를 반복하기 전에 필터링하여 명령형 루프에서 &lt;code&gt;break&lt;/code&gt; 필요를 대체 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2db2fe69d40d3ac34eb0e35f52345d0c2815a956" translate="yes" xml:space="preserve">
          <source>Note that each of these variations is supported by all browsers, including very very old ones!</source>
          <target state="translated">이러한 각 변형은 매우 오래된 브라우저를 포함하여 모든 브라우저에서 지원됩니다!</target>
        </trans-unit>
        <trans-unit id="6c66070e97cce40670c4441191c44bf18838f842" translate="yes" xml:space="preserve">
          <source>Note: Array.prototype.forEach() is not a functional way strictly speaking, as the function it takes as the input parameter is not supposed to return a value, which thus cannot be regarded as a pure function.</source>
          <target state="translated">참고 : Array.prototype.forEach ()는 입력 매개 변수로받는 함수가 값을 리턴하지 않으므로 순수한 함수로 간주 될 수 없으므로 엄밀히 말하면 기능적인 방식은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="48c966f09aa17b29b9fe064c727a02146da0e40e" translate="yes" xml:space="preserve">
          <source>Note: The filter() method creates a new array with all elements that pass the test implemented by the provided function.</source>
          <target state="translated">참고 : filter () 메서드는 제공된 함수로 구현 된 테스트를 통과하는 모든 요소를 ​​사용하여 새 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f1ea81216c8103826ec20066099e66d7123126d6" translate="yes" xml:space="preserve">
          <source>Note: The map() method creates a new array with the results of calling a provided function on every element in the calling array.</source>
          <target state="translated">참고 : map () 메서드는 호출 배열의 모든 요소에서 제공된 함수를 호출 한 결과로 새 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8bd4bead091ec61c5177a79b36d340f39f2358e7" translate="yes" xml:space="preserve">
          <source>Object loop:</source>
          <target state="translated">객체 루프 :</target>
        </trans-unit>
        <trans-unit id="56974c9d7b50d25064ed413fbfe2b4b0f72cd469" translate="yes" xml:space="preserve">
          <source>Of course, some developers have no choice but to use a different approach anyway, because for whatever reason they're targeting a version of JavaScript that doesn't yet support &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt;.</source>
          <target state="translated">물론 어떤 개발자는 다른 방법을 사용하는 것 외에는 선택의 여지가 없습니다. 왜냐하면 어떤 이유로 든 아직 지원하지 않는 JavaScript 버전을 대상으로하기 때문 &lt;code&gt;of&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f7be3080abd7fd806f8e09c93803d1cd5f9c625" translate="yes" xml:space="preserve">
          <source>Of course, you will need to include an &lt;code&gt;if(condition === true) { break; }&lt;/code&gt;  or an &lt;code&gt;if(condition === true) { return; }&lt;/code&gt; somewhere inside that &lt;code&gt;for&lt;/code&gt;-loop to get it to stop running.</source>
          <target state="translated">물론 &lt;code&gt;if(condition === true) { break; }&lt;/code&gt; } 또는 &lt;code&gt;if(condition === true) { return; }&lt;/code&gt; } &lt;code&gt;for&lt;/code&gt; 루프 내부의 어딘가에서 실행을 중지합니다.</target>
        </trans-unit>
        <trans-unit id="f2fe9d42eb2f2a746517eaff1ec734422f1cc4c5" translate="yes" xml:space="preserve">
          <source>One advantage of this approach is that you can choose how to handle sparse arrays; the above code will run the body of the loop the full &lt;code&gt;length&lt;/code&gt; times, with &lt;code&gt;s&lt;/code&gt; set to &lt;code&gt;undefined&lt;/code&gt; for any missing elements, just like &lt;code&gt;for&lt;/code&gt;..&lt;code&gt;of&lt;/code&gt;. If you instead want to handle only the actually-present elements of a sparse array, like &lt;code&gt;.forEach&lt;/code&gt;, you can add a simple &lt;code&gt;in&lt;/code&gt; test on the index:</source>
          <target state="translated">이 방법의 장점 중 하나는 희소 배열을 처리하는 방법을 선택할 수 있다는 것입니다. 위의 코드는 루프 본문을 전체 &lt;code&gt;length&lt;/code&gt; 실행하며 .. &lt;code&gt;of&lt;/code&gt; 와 같이 누락 된 요소에 대해서는 &lt;code&gt;s&lt;/code&gt; 를 &lt;code&gt;undefined&lt;/code&gt; 로 설정합니다. 대신 &lt;code&gt;.forEach&lt;/code&gt; 와 같이 실제로 존재하는 희소 배열의 요소 만 처리하려는 경우 인덱스 &lt;code&gt;in&lt;/code&gt; 간단한 테스트를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53e75cdb29c5599821ebe5805040c469e93077fc" translate="yes" xml:space="preserve">
          <source>One alternative to a &lt;code&gt;for&lt;/code&gt; loop is a &lt;code&gt;while&lt;/code&gt; loop. To loop through an array, you could do this:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 루프의 대안은 &lt;code&gt;while&lt;/code&gt; 루프입니다. 배열을 반복하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4b514468264056e4b37a5ab372a4a7f951732f97" translate="yes" xml:space="preserve">
          <source>One of the cornerstones of functional programming is its special use
  of lists and list operations. And those things are exactly what the
  sound like they are: arrays of things, and the stuff you do to them.
  But the functional mindset treats them a bit differently than you
  might expect.</source>
          <target state="translated">함수형 프로그래밍의 초석 중 하나는 목록 및 목록 작업의 특수한 사용입니다. 그리고 그 것들은 정확히 소리와 같습니다 : 일의 배열, 그리고 당신이하는 일. 그러나 기능적 사고 방식은 예상과 약간 다르게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="d921e30036a4651e6d150723a2bd7418fc2d461a" translate="yes" xml:space="preserve">
          <source>Opera, Safari, Firefox and Chrome now all share a set of enhanced Array methods for optimizing many common loops.</source>
          <target state="translated">Opera, Safari, Firefox 및 Chrome은 이제 많은 공통 루프를 최적화하기 위해 일련의 향상된 배열 방법을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="ca8a7183a1dbcea77d8631814b5189f7eab564fd" translate="yes" xml:space="preserve">
          <source>Or &lt;code&gt;Array.prototype.map(...)&lt;/code&gt;:</source>
          <target state="translated">또는 &lt;code&gt;Array.prototype.map(...)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="005deeedccad31f3cb0e80bfb7abb31fa65ed57a" translate="yes" xml:space="preserve">
          <source>Or better yet, since ECMAScript 2015 also provides block-scoped variables:</source>
          <target state="translated">ECMAScript 2015는 블록 범위 변수도 제공하므로 더 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3b1a4912a2f639abf4e7d8c472de81016ac92f24" translate="yes" xml:space="preserve">
          <source>Or if you really want to get the id and have a really classical &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">또는 실제로 ID를 얻고 정말로 고전적인 &lt;code&gt;for&lt;/code&gt; 루프를 원한다면 :</target>
        </trans-unit>
        <trans-unit id="79c19d1215e0ee61dae1d54feb9eb528038ad845" translate="yes" xml:space="preserve">
          <source>Or the classical &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">아니면 고전적인 &lt;code&gt;for&lt;/code&gt; 루프</target>
        </trans-unit>
        <trans-unit id="32ccf4631124f74fd174f7f90959d3e3a755fb56" translate="yes" xml:space="preserve">
          <source>Or the jquery or for loop ways previously mentioned.</source>
          <target state="translated">또는 이전에 언급 한 jquery 또는 for 루프 방식.</target>
        </trans-unit>
        <trans-unit id="6adbea7e0ac9ed37ed0deb0bb73dcd3e28cf819b" translate="yes" xml:space="preserve">
          <source>Or, if you prefer to loop backwards, you do this:</source>
          <target state="translated">또는 뒤로 루프하는 것을 선호하는 경우 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ae203c504aa70b4f28a5fcf1b9fe9229ed76072b" translate="yes" xml:space="preserve">
          <source>Read more&amp;gt;&amp;gt; &lt;a href=&quot;https://code.tutsplus.com/tutorials/how-to-use-map-filter-reduce-in-javascript--cms-26209&quot;&gt;here&lt;/a&gt;:</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://code.tutsplus.com/tutorials/how-to-use-map-filter-reduce-in-javascript--cms-26209&quot;&gt;여기&lt;/a&gt; &amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e609697c319d4d3a9d1b473f48e1e2bd07f35c6e" translate="yes" xml:space="preserve">
          <source>Reference:
&lt;a href=&quot;http://www.sitepoint.com/google-closure-how-not-to-write-javascript/&quot;&gt;http://www.sitepoint.com/google-closure-how-not-to-write-javascript/&lt;/a&gt;</source>
          <target state="translated">Reference:
&lt;a href=&quot;http://www.sitepoint.com/google-closure-how-not-to-write-javascript/&quot;&gt;http://www.sitepoint.com/google-closure-how-not-to-write-javascript/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="335e1e090424cc3a93596596d66cb2973f851a68" translate="yes" xml:space="preserve">
          <source>See this JsFiddle demonstrating that: &lt;a href=&quot;http://jsfiddle.net/prvzk/&quot;&gt;http://jsfiddle.net/prvzk/&lt;/a&gt;</source>
          <target state="translated">이것을 보여주는 JsFiddle을 참조하십시오 : &lt;a href=&quot;http://jsfiddle.net/prvzk/&quot;&gt;http://jsfiddle.net/prvzk/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a5dda3b31ff4955adf83bd52382ef45bc3ffb11e" translate="yes" xml:space="preserve">
          <source>Short answer: yes. You can do with this:</source>
          <target state="translated">짧은 대답 : 예. 당신은 이것을 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="548e1e621f5c9ad33722194d1a9b4a9c024a7f02" translate="yes" xml:space="preserve">
          <source>Since my time in college, I've programmed in Java, JavaScript, Pascal, &lt;a href=&quot;https://en.wikipedia.org/wiki/ABAP&quot;&gt;ABAP&lt;/a&gt;, PHP, Progress 4GL, C/C++ and possibly a few other languages I can't think of right now.</source>
          <target state="translated">대학 시절부터 Java, JavaScript, Pascal, &lt;a href=&quot;https://en.wikipedia.org/wiki/ABAP&quot;&gt;ABAP&lt;/a&gt; , PHP, Progress 4GL, C / C ++ 및 아마도 내가 생각할 수없는 다른 언어로 프로그래밍했습니다.</target>
        </trans-unit>
        <trans-unit id="b22093b0b2c9e3acc2f551744f9b589053dde63a" translate="yes" xml:space="preserve">
          <source>So as others has suggested, this is almost always what you want:</source>
          <target state="translated">따라서 다른 사람들이 제안했듯이 이것은 거의 항상 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="47218d7f66b567477c470edc472c6fd416fbed47" translate="yes" xml:space="preserve">
          <source>Some use cases of looping through an array in &lt;strong&gt;the functional programming way&lt;/strong&gt; in JavaScript:</source>
          <target state="translated">JavaScript에서 &lt;strong&gt;함수형 프로그래밍 방식으로&lt;/strong&gt; 배열을 반복하는 일부 사용 사례 :</target>
        </trans-unit>
        <trans-unit id="432979a6e491e22397882fad2d457b66217225b1" translate="yes" xml:space="preserve">
          <source>Spread syntax</source>
          <target state="translated">확산 구문</target>
        </trans-unit>
        <trans-unit id="df9af125634fddcfa421be704540115f6f1acfd0" translate="yes" xml:space="preserve">
          <source>That be particularly a problem if you use some library that relies heavily on native prototypes augmentation (such as MooTools, for example).</source>
          <target state="translated">네이티브 프로토 타입 기능 보강 (예 : MooTools)에 크게 의존하는 라이브러리를 사용하는 경우 특히 문제가됩니다.</target>
        </trans-unit>
        <trans-unit id="54be33a5edebe447d19ad8769464cdbc36772505" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.each()&lt;/code&gt; function is not the same as &lt;code&gt;$(selector).each()&lt;/code&gt;, which is
  used to iterate, exclusively, over a jQuery object. The &lt;code&gt;$.each()&lt;/code&gt;
  function can be used to iterate over any collection, whether it is a
  map (JavaScript object) or an array. In the case of an array, the
  callback is passed an array index and a corresponding array value each
  time. (The value can also be accessed through the &lt;code&gt;this&lt;/code&gt; keyword, but
  Javascript will always wrap the &lt;code&gt;this&lt;/code&gt; value as an &lt;code&gt;Object&lt;/code&gt; even if it is
  a simple string or number value.) The method returns its first
  argument, the object that was iterated.</source>
          <target state="translated">&lt;code&gt;$.each()&lt;/code&gt; 함수는 &lt;code&gt;$(selector).each()&lt;/code&gt; 와 동일하지 않으며, 이는 jQuery 객체를 독점적으로 반복하는 데 사용됩니다. &lt;code&gt;$.each()&lt;/code&gt; 함수는 맵 (JavaScript 객체)이든 배열이든 모든 컬렉션을 반복하는 데 사용할 수 있습니다. 배열의 경우 콜백은 매번 배열 인덱스와 해당 배열 값을 전달받습니다. ( &lt;code&gt;this&lt;/code&gt; 키워드를 통해 값에 액세스 할 수도 있지만 Javascript는 &lt;code&gt;this&lt;/code&gt; 값을 단순한 문자열 또는 숫자 값인 경우에도 항상 이 값을 &lt;code&gt;Object&lt;/code&gt; 로 래핑합니다.)이 메소드는 반복 된 오브젝트의 첫 번째 인수를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8ea2d26897d80b2a11e7991048566fdf9f71aa64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; and the &lt;code&gt;Array.prototype.map()&lt;/code&gt; methods are the slowest approximations, probably as a consequence of the &lt;strong&gt;function call overhead&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;Array.prototype.forEach()&lt;/code&gt; 및 &lt;code&gt;Array.prototype.map()&lt;/code&gt; 메소드는 아마도 &lt;strong&gt;함수 호출 오버 헤드&lt;/strong&gt; 의 결과로 가장 느린 근사치입니다.</target>
        </trans-unit>
        <trans-unit id="fda48303e825923d88d3e1a5954e2f9a8d32ffe0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-in&lt;/code&gt; statement as I said before is there to &lt;em&gt;enumerate&lt;/em&gt; object properties, for example:</source>
          <target state="translated">앞에서 언급 한 &lt;code&gt;for-in&lt;/code&gt; 문은 다음과 같이 객체 속성을 &lt;em&gt;열거&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="152a30a782355db0c98586aa6609e918220ba9f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; syntax mentioned by others is for looping over an object's properties; since an Array in JavaScript is just an object with numeric property names (and an automatically-updated &lt;code&gt;length&lt;/code&gt; property), you can theoretically loop over an Array with it.  But the problem is that it doesn't restrict itself to the numeric property values (remember that even methods are actually just properties whose value is a closure), nor is it guaranteed to iterate over those in numeric order. Therefore, the &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; syntax should &lt;em&gt;not&lt;/em&gt; be used for looping through Arrays.</source>
          <target state="translated">다른 사람들이 언급 한 &lt;code&gt;for&lt;/code&gt; ... 구문은 객체의 속성을 반복하는 것입니다. JavaScript의 Array는 숫자 속성 이름 (및 자동으로 업데이트 된 &lt;code&gt;length&lt;/code&gt; 속성)을 가진 객체이므로 이론적으로 Array를 반복 할 수 있습니다. 그러나 문제는 자체가 숫자 속성 값으로 제한되지 않는다는 것입니다 (메소드는 심지어 값이 클로저 인 속성 일뿐입니다). 따라서 &lt;code&gt;for&lt;/code&gt; ... 구문은 배열을 반복하는 데 사용해서는 &lt;em&gt;안됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="a23f5eb2e341872f8d38000e5c4b5bc2354d1e00" translate="yes" xml:space="preserve">
          <source>The Array.prototype.find() method returns the value of the first element in the array that satisfies the provided testing function.</source>
          <target state="translated">Array.prototype.find () 메서드는 제공된 테스트 함수를 만족하는 배열의 첫 번째 요소 값을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9449fcbdbeae06e7e3bf08650fe52c6575a5e23e" translate="yes" xml:space="preserve">
          <source>The ES5 specification introduced a lot of beneficial array methods, one of them, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;Array.prototype.forEach&lt;/code&gt;&lt;/a&gt; and it gives us a concise way to iterate over an array:</source>
          <target state="translated">ES5 사양에는 많은 유용한 배열 메서드 중 하나 인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;Array.prototype.forEach&lt;/code&gt; 가&lt;/a&gt; 도입되었으며 배열을 반복하는 간결한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="7a8e9910c4deb87c8767f0cacf582f5a16708e6e" translate="yes" xml:space="preserve">
          <source>The ES6 standard introduces the concept of iterable objects and defines a new construct for traversing data, the &lt;code&gt;for...of&lt;/code&gt; statement.</source>
          <target state="translated">ES6 표준은 반복 가능한 객체의 개념을 소개하고 데이터를 순회하기위한 새로운 구문 인 &lt;code&gt;for...of&lt;/code&gt; 문을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1460f02e0a3102d7e55e91533998fc51f18928be" translate="yes" xml:space="preserve">
          <source>The above code will console log &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, and &quot;foo!&quot;.</source>
          <target state="translated">위의 코드는 콘솔 로그 &quot;a&quot;, &quot;b&quot;, &quot;c&quot;및 &quot;foo!&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="20e7432fb4c054b1e1c467a38410fe6525f14155" translate="yes" xml:space="preserve">
          <source>The best way in my opinion is to use the Array.forEach function. If you cannot use that I would suggest to get the polyfill from MDN. To make it available, it is certainly the safest way to iterate over an array in JavaScript.</source>
          <target state="translated">제 생각에는 가장 좋은 방법은 Array.forEach 함수를 사용하는 것입니다. 당신이 그것을 사용할 수 없다면 MDN에서 polyfill을 얻는 것이 좋습니다. 사용 가능하게하려면 JavaScript에서 배열을 반복하는 가장 안전한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="e56ca3c4eed21e096e43d29badb2c6a655f1f880" translate="yes" xml:space="preserve">
          <source>The code below are popular ones</source>
          <target state="translated">아래 코드는 인기있는 코드입니다</target>
        </trans-unit>
        <trans-unit id="120e5e39e34ca15870d8e9947bbcca2f43399e04" translate="yes" xml:space="preserve">
          <source>The explicit counting loop also means you have access to the index of each value, should you want it. The index is also passed as an extra parameter to the function you pass to &lt;code&gt;forEach&lt;/code&gt;, so you can access it that way as well:</source>
          <target state="translated">명시 적 카운팅 루프는 또한 원하는 경우 각 값의 인덱스에 액세스 할 수 있음을 의미합니다. 인덱스는 또한 &lt;code&gt;forEach&lt;/code&gt; 에 전달하는 함수에 추가 매개 변수로 전달되므로 다음과 같이 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0926024be90fc3c5c58f79ca38b539c92713c68c" translate="yes" xml:space="preserve">
          <source>The final option, which works in &lt;em&gt;all&lt;/em&gt; versions of JavaScript, is &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-for-statement&quot;&gt;an explicit counting loop&lt;/a&gt;. You simply count from 0 up to one less than the length and use the counter as an index. The basic loop looks like this:</source>
          <target state="translated">&lt;em&gt;모든&lt;/em&gt; 버전의 JavaScript에서 작동하는 마지막 옵션 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-for-statement&quot;&gt;은 명시적인 계산 루프&lt;/a&gt; 입니다. 당신은 단순히 0에서 길이보다 1에서 1까지 세고 카운터를 인덱스로 사용합니다. 기본 루프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60de89b60699f6e1c50c9980fe4030ebfed381c1" translate="yes" xml:space="preserve">
          <source>The general syntax is:</source>
          <target state="translated">일반적인 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="17c0c8958009504035837eb96e313e38d6db28cb" translate="yes" xml:space="preserve">
          <source>The item to access is automatically defined within the loop
body under the name you pick.</source>
          <target state="translated">액세스 할 항목은 선택한 이름으로 루프 본문 내에서 자동으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="cc1a1ebcb7c44366d847d9e53142c469f5d9c912" translate="yes" xml:space="preserve">
          <source>The most elegant and fast way</source>
          <target state="translated">가장 우아하고 빠른 방법</target>
        </trans-unit>
        <trans-unit id="92bc9c3030690e8975c93e43b9783b47f78cf220" translate="yes" xml:space="preserve">
          <source>The optimized approach is to cache the length of array and using single var pattern initializing all variables with single var keyword.</source>
          <target state="translated">최적화 된 접근 방식은 배열 길이를 캐시하고 단일 var 키워드로 모든 변수를 초기화하는 단일 var 패턴을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2c0c58f394bd4d6864165f51bcf38373ab49434a" translate="yes" xml:space="preserve">
          <source>The order of iteration is not guaranteed; the array indexes may not be visited in numeric order.</source>
          <target state="translated">반복 순서는 보장되지 않습니다. 배열 인덱스는 숫자 순서대로 방문 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="012e8483413b382c220340edf31b6450777efdd6" translate="yes" xml:space="preserve">
          <source>The reason this works is that the array specification mandates that when you read an item from an index &amp;gt;= the array's length, it will return undefined. When you write to such a location it will actually update the length.</source>
          <target state="translated">이것이 작동하는 이유는 배열 사양이 인덱스&amp;gt; = 배열의 길이에서 항목을 읽을 때 정의되지 않은 값을 반환해야하기 때문입니다. 이러한 위치에 쓰면 실제로 길이가 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="ef3a7c0b59ad4734159dbd0581cc34ca59a58ff9" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;array.map&lt;/code&gt; is another array, so you can use it like this:</source>
          <target state="translated">&lt;code&gt;array.map&lt;/code&gt; 의 반환 값은 또 다른 배열이므로 다음과 같이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b97bcfaafee942ef6523ce737efbb4b975437cc7" translate="yes" xml:space="preserve">
          <source>The second point is that it can give you a lot of problems, for example, if you extend the &lt;code&gt;Array.prototype&lt;/code&gt; object to include a method there, that property will also be enumerated.</source>
          <target state="translated">두 번째 요점은 많은 문제를 야기 할 수 있다는 것입니다. 예를 들어, 메소드를 포함하도록 &lt;code&gt;Array.prototype&lt;/code&gt; 객체를 확장하면 해당 속성도 열거됩니다.</target>
        </trans-unit>
        <trans-unit id="2f3b6cf1d6f0a6bbd74a70887a856a51c87bff3f" translate="yes" xml:space="preserve">
          <source>The traditional &lt;code&gt;for()&lt;/code&gt; iterator, is by far the fastest method, especially when used with the &lt;strong&gt;array length cached&lt;/strong&gt;.</source>
          <target state="translated">전통적인 &lt;code&gt;for()&lt;/code&gt; 반복자는 &lt;strong&gt;배열 길이 캐시&lt;/strong&gt; 와 함께 사용될 때 특히 가장 빠른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="50fbe4e2839ad6f44353c11db5662956a1245813" translate="yes" xml:space="preserve">
          <source>The traditional way to loop through an array, is this:</source>
          <target state="translated">배열을 반복하는 전통적인 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb52b2247ddc21d02d48c2330829d7a1e4b3b066" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to do it in JavaScript. The first two examples are JavaScript samples. The third one makes use of a JavaScript library, that is, jQuery making use of the &lt;code&gt;.each()&lt;/code&gt; function.</source>
          <target state="translated">JavaScript로 몇 가지 방법이 있습니다. 처음 두 예제는 JavaScript 샘플입니다. 세 번째는 JavaScript 라이브러리, 즉 &lt;code&gt;.each()&lt;/code&gt; 함수를 사용하는 jQuery를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="821b43d0758dd02be5cc2c03df6009934ba6b2d6" translate="yes" xml:space="preserve">
          <source>There are even some times when you ought to iterate in reverse, such as when iterating over a &lt;a href=&quot;https://developer.mozilla.org/En/DOM/NodeList#A_.22live.22_collection&quot;&gt;live NodeList&lt;/a&gt; where you plan on removing items from the DOM during iteration.</source>
          <target state="translated">반복하는 동안 DOM에서 항목을 제거 할 계획 인 &lt;a href=&quot;https://developer.mozilla.org/En/DOM/NodeList#A_.22live.22_collection&quot;&gt;라이브 NodeList를&lt;/a&gt; 반복하는 경우와 같이 역순으로 반복해야하는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="42b051646813473214bb6d4ec6b04940890f97b1" translate="yes" xml:space="preserve">
          <source>There are various way to loop through array in JavaScript.</source>
          <target state="translated">JavaScript에서 배열을 반복하는 다양한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a2a3b9ff7b68f4ca1407027573f3d1e36d2a264" translate="yes" xml:space="preserve">
          <source>There are, however, many variations possible, like for example this one:</source>
          <target state="translated">그러나 예를 들어 다음과 같은 많은 변형이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3b17947ce13f291d24a94bf37cd447dbd1a3770b" translate="yes" xml:space="preserve">
          <source>There is a way to do it where you have very little implicit scope in your loop and do away with extra variables.</source>
          <target state="translated">루프에 암시 적 범위가 거의 없으며 추가 변수를 제거하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a66ce7f5fe432814094ad577cba1eca94e88388" translate="yes" xml:space="preserve">
          <source>There's a method to iterate over only own object properties, not including prototype's ones:</source>
          <target state="translated">프로토 타입을 포함하지 않고 자체 객체 속성 만 반복하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d2f0aa297c7272c064273bd7ad8226e3a64443e" translate="yes" xml:space="preserve">
          <source>These are the main ways to do JavaScript loops, but there are a few more ways to do that.</source>
          <target state="translated">이것이 JavaScript 루프를 수행하는 주요 방법이지만이를 수행하는 몇 가지 방법이 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="a685720d851d92a20d19c2df920471064cf168c9" translate="yes" xml:space="preserve">
          <source>These are the solutions:</source>
          <target state="translated">솔루션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71b65affe9fa82e82de8abd8e0d75c26d06af598" translate="yes" xml:space="preserve">
          <source>These methods all take a function for their first argument and have an optional second argument, which is an object whose scope you want to impose on the array members as they loop through the function.</source>
          <target state="translated">이 메소드는 모두 첫 번째 인수에 대한 함수를 취하고 선택적인 두 번째 인수를 갖습니다.이 인수는 함수를 반복 할 때 배열 멤버에 범위를 적용하려는 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="80ad30aab31c43f396831f915032145053204ac5" translate="yes" xml:space="preserve">
          <source>These three components are separated from each other by a &lt;code&gt;;&lt;/code&gt; symbol. Content for each of these three components is optional, which means that the following is the most minimal &lt;code&gt;for&lt;/code&gt; loop possible:</source>
          <target state="translated">이 세 가지 구성 요소는 서로 &lt;code&gt;;&lt;/code&gt; 상징. 이 세 가지 구성 요소 각각에 대한 내용은 선택 사항이므로 다음은 가능한 가장 적은 &lt;code&gt;for&lt;/code&gt; 루프입니다.</target>
        </trans-unit>
        <trans-unit id="f566944d88f81152109f1bbf9e52d01bb54137da" translate="yes" xml:space="preserve">
          <source>This article will take a close look at what I like to call the &quot;big
  three&quot; list operations: map, filter, and reduce. Wrapping your head
  around these three functions is an important step towards being able
  to write clean functional code, and opens the doors to the vastly
  powerful techniques of functional and reactive programming.</source>
          <target state="translated">이 기사에서는 내가지도, 필터링 및 축소와 같은 &quot;큰 세 가지&quot;목록 작업이라고 부르는 것을 자세히 살펴볼 것입니다. 이 세 가지 기능을 머리에 감는 것은 깨끗한 기능 코드를 작성할 수있는 중요한 단계이며 기능성 및 반응 형 프로그래밍의 강력한 기술에 대한 문을 열어줍니다.</target>
        </trans-unit>
        <trans-unit id="6a07602d0b647fe22e2fcaac7f41bf7fd5c06746" translate="yes" xml:space="preserve">
          <source>This ensures that anything you need in the scope of processing the array stays within that scope, and that you are only processing the values of the array, not the object properties and other members, which is what &lt;code&gt;for ..&lt;/code&gt; in does.</source>
          <target state="translated">이렇게하면 배열 처리 범위에 필요한 모든 항목이 해당 범위 내에서 유지되며 객체 속성 및 기타 멤버가 아닌 배열의 값만 처리하게됩니다.</target>
        </trans-unit>
        <trans-unit id="858c7fa76e864ce71e5b610d49e037963d073b9e" translate="yes" xml:space="preserve">
          <source>This has the benefit of caching the length (similar to &lt;code&gt;for (var i=0, len=myArray.length; i&amp;lt;len; ++i)&lt;/code&gt; and unlike &lt;code&gt;for (var i=0; i&amp;lt;myArray.length; ++i)&lt;/code&gt;) while being fewer characters to type.</source>
          <target state="translated">이것은 길이를 캐싱 &lt;code&gt;for (var i=0, len=myArray.length; i&amp;lt;len; ++i)&lt;/code&gt; 와 유사 ) 하고 &lt;code&gt;for (var i=0; i&amp;lt;myArray.length; ++i)&lt;/code&gt; 와 유사) 이점을 갖습니다 . ) ) 입력하는 문자 수가 적습니다.</target>
        </trans-unit>
        <trans-unit id="190958324e44a9b320dec6a0655dbfd941bed1b5" translate="yes" xml:space="preserve">
          <source>This is a good article if you like to learn more about the asynchronous functions over arrays in JavaScript.</source>
          <target state="translated">JavaScript의 배열에 대한 비동기 함수에 대해 더 배우고 싶다면 좋은 기사입니다.</target>
        </trans-unit>
        <trans-unit id="147518e25e35d186bb4ca7645b5e7a356fd8dd30" translate="yes" xml:space="preserve">
          <source>This new syntax is the most elegant way to iterate an array in javascript (as long you don't need the iteration index), but it is not yet widely supported by the browsers.</source>
          <target state="translated">이 새로운 구문은 자바 스크립트에서 배열을 반복하는 가장 우아한 방법이지만 (반복 색인이 필요하지 않는 한) 아직 브라우저에서 널리 지원되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="c7b121c2303f93e6b2a2d7db925a526f50850ae3" translate="yes" xml:space="preserve">
          <source>This only works for arrays that are &lt;em&gt;not&lt;/em&gt; sparse. Meaning that there actually is a value at each index in the array. However, I found that in practice I hardly ever use sparse arrays in JavaScript... In such cases it's usually a lot easier to use an object as a map/hashtable. If you do have a sparse array, and want to loop over 0 .. length-1, you need the for (var i=0; i&amp;lt;someArray.length; ++i) construct, but you still need an &lt;code&gt;if&lt;/code&gt; inside the loop to check whether the element at the current index is actually defined.</source>
          <target state="translated">이것은 드문 드문 배열에 대해서만 작동합니다. 실제로 배열의 각 인덱스에 값이 있음을 의미합니다. 그러나 실제로는 JavaScript에서 스파 스 배열을 거의 사용하지 않는다는 것을 알았습니다 ...이 경우 일반적으로 객체를 맵 / 해시 테이블로 사용하는 것이 훨씬 쉽습니다. 희소 배열이 있고 0 .. length-1을 반복하려면 for (var i = 0; i &amp;lt;someArray.length; ++ i) 구문이 필요하지만 여전히 내부에 &lt;code&gt;if&lt;/code&gt; 가 필요합니다. 루프하여 현재 인덱스의 요소가 실제로 정의되어 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0d1a92190b4273c4dedb4a6ff5c33b8b8e248e48" translate="yes" xml:space="preserve">
          <source>This should be used with care, however, as it doesn't behave the same as a traditional &lt;code&gt;for&lt;/code&gt; loop in all cases, and there are potential side-effects that need to be considered. See &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea&quot;&gt;Why is using &quot;for...in&quot; with array iteration a bad idea?&lt;/a&gt;&lt;/strong&gt; for more details.</source>
          <target state="translated">그러나 모든 경우에 전통적인 &lt;code&gt;for&lt;/code&gt; 루프와 동일하게 작동하지 않으므로 고려해야 할 잠재적 인 부작용이 있으므로주의해서 사용해야합니다. &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea&quot;&gt;배열 반복과 함께 &quot;for ... in&quot;을 사용하는 것이 좋지 않은 이유를&lt;/a&gt;&lt;/strong&gt; 참조하십시오 &lt;strong&gt;.&lt;/strong&gt; 상세 사항은.</target>
        </trans-unit>
        <trans-unit id="472b9cc884c8efe330967ffcc40284ca272d82d6" translate="yes" xml:space="preserve">
          <source>This statement works for any kind of iterable object and also for generators (any object that has a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator&quot;&gt;&lt;code&gt;[Symbol.iterator]&lt;/code&gt;&lt;/a&gt; property).</source>
          <target state="translated">이 문장은 모든 종류의 반복 가능한 객체와 생성기 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator&quot;&gt; &lt;code&gt;[Symbol.iterator]&lt;/code&gt; &lt;/a&gt; 속성이있는 객체)에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="ac9bb5e0ca9aef826594b177b1c57b42d63efd12" translate="yes" xml:space="preserve">
          <source>Too verbose</source>
          <target state="translated">너무 자세한</target>
        </trans-unit>
        <trans-unit id="0e44efea277e112b800b020b7f1ce9f2e1b5bdd7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt;, &lt;code&gt;.forEach&lt;/code&gt; only calls the function for elements that are actually present in the array. If passed our hypothetical array with three elements and a length of 248, it will only call the function three times, not 248 times. It also distinguishes between missing elements and elements that are actually set to &lt;code&gt;undefined&lt;/code&gt;; for the latter, it will still call the function, passing &lt;code&gt;undefined&lt;/code&gt; as the argument. If this is how you want to handle sparse arrays, &lt;code&gt;.forEach&lt;/code&gt; may be the way to go even if your interpreter supports &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt;.</source>
          <target state="translated">... &lt;code&gt;of&lt;/code&gt; 와 달리 &lt;code&gt;.forEach&lt;/code&gt; 는 실제로 배열에 존재하는 요소에 대해서만 함수를 호출합니다. 세 개의 요소와 길이가 248 인 가상 배열을 전달하면 248 번이 아니라 함수를 세 번만 호출합니다. 또한 누락 된 요소와 실제로 &lt;code&gt;undefined&lt;/code&gt; 요소를 구분합니다. 후자의 경우 여전히 함수로 호출되어 &lt;code&gt;undefined&lt;/code&gt; 를 인수로 전달합니다. 이것이 희소 배열을 처리하는 방법이라면, 인터프리터가 ... &lt;code&gt;of&lt;/code&gt; 를 지원하더라도 &lt;code&gt;.forEach&lt;/code&gt; 가 갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb5ad6ba3a246c28f628695455346d1d1358b358" translate="yes" xml:space="preserve">
          <source>Use the while loop...</source>
          <target state="translated">while 루프를 사용하십시오 ...</target>
        </trans-unit>
        <trans-unit id="acf02fdaa5e1a7884f09bb5330b18f85aa765a24" translate="yes" xml:space="preserve">
          <source>Useful to iterate serially asynchronous values.</source>
          <target state="translated">직렬 비동기 값을 반복하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="11f8f11632acf347b589a3d67d8c21511e0c9bf6" translate="yes" xml:space="preserve">
          <source>Using a regular C-style &lt;code&gt;for&lt;/code&gt; loop works in most cases. It is just important to remember that everything within the loop shares its scope with the rest of your program, the { } does not create a new scope.</source>
          <target state="translated">대부분의 경우 일반 C 스타일 &lt;code&gt;for&lt;/code&gt; 루프를 사용하면됩니다. 루프 내의 모든 것이 범위를 나머지 프로그램과 공유한다는 점을 기억하는 것이 중요합니다. {}은 새 범위를 만들지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e8369a5a266e94f593d9eeea846e02aa77149e0" translate="yes" xml:space="preserve">
          <source>Using a traditional &lt;code&gt;for&lt;/code&gt; loop to loop through an array</source>
          <target state="translated">전통적인 &lt;code&gt;for&lt;/code&gt; 루프를 사용하여 배열을 반복</target>
        </trans-unit>
        <trans-unit id="85df58774c5491ec2a1dff116625289a4b51fe96" translate="yes" xml:space="preserve">
          <source>Usually, though, the initialization is used to declare an index, the condition is used to compare that index with a minimum or maximum value, and the afterthought is used to increment the index:</source>
          <target state="translated">그러나 일반적으로 초기화는 인덱스를 선언하는 데 사용되며 조건을 사용하여 해당 인덱스를 최소 또는 최대 값과 비교하고 이후에 인덱스를 증가시키는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="38a3899f8605deb1a119719c4e634478608e868c" translate="yes" xml:space="preserve">
          <source>Very short and succinct.</source>
          <target state="translated">매우 짧고 간결합니다.</target>
        </trans-unit>
        <trans-unit id="c2806e463dca64608139609ed71eec7bf1af0fcd" translate="yes" xml:space="preserve">
          <source>What I like about this loop is:</source>
          <target state="translated">이 루프에서 내가 좋아하는 것은 :</target>
        </trans-unit>
        <trans-unit id="16ce81c4539b95557096d4ee3982368acb60bb76" translate="yes" xml:space="preserve">
          <source>Whichever works best is largely a matter of both personal taste and the specific use case you're implementing.</source>
          <target state="translated">가장 잘 작동하는 것은 주로 개인적인 취향과 구현중인 특정 사용 사례의 문제입니다.</target>
        </trans-unit>
        <trans-unit id="3eaca1cb6c3a5c7b0653cdc5c205c5570f3bcd75" translate="yes" xml:space="preserve">
          <source>While they all have their own linguistic idiosyncrasies, each of these languages share many of the same basic concepts. Such concepts include procedures / functions, &lt;code&gt;IF&lt;/code&gt;-statements, &lt;code&gt;FOR&lt;/code&gt;-loops, and &lt;code&gt;WHILE&lt;/code&gt;-loops.</source>
          <target state="translated">모두 고유 한 언어 특성이 있지만 이러한 각 언어는 동일한 기본 개념을 많이 공유합니다. 이러한 개념에는 프로 시저 / 함수, &lt;code&gt;IF&lt;/code&gt; 문, &lt;code&gt;FOR&lt;/code&gt; 루프 및 &lt;code&gt;WHILE&lt;/code&gt; 루프가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8244adf2c17ba7cc3bdea8eada041642ab1c86cf" translate="yes" xml:space="preserve">
          <source>Works on every environment</source>
          <target state="translated">모든 환경에서 작동</target>
        </trans-unit>
        <trans-unit id="a1b7a89f3b73a87140f7d4b8e01a03ed839c9203" translate="yes" xml:space="preserve">
          <source>Yes, assuming your implementation includes the &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements&quot;&gt;&lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt;&lt;/a&gt; feature introduced in &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt; (the &quot;Harmony&quot; release)... which is a pretty safe assumption these days.</source>
          <target state="translated">예, 구현에 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015에&lt;/a&gt; 도입 된 기능 ( &quot;하모니&quot;릴리스)이 포함되어 있다고 가정하면 요즘 꽤 안전한 가정입니다.</target>
        </trans-unit>
        <trans-unit id="65c39770604a63372cf38469a45e9aad0b608cfa" translate="yes" xml:space="preserve">
          <source>You can either use &lt;code&gt;Array.prototype.forEach(...)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Array.prototype.forEach(...)&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55d53dbec6820aa52a0e39445d08dc7a9bac4eb5" translate="yes" xml:space="preserve">
          <source>You can loop over it without ever accessing the length property:</source>
          <target state="translated">length 속성에 액세스하지 않고도 루프를 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3f6f0955f94bb72fe3f0ae7cac303e447b46c4f" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; flow control statements</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 및 &lt;code&gt;continue&lt;/code&gt; 흐름 제어문을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="667729f11316fb106cabbaf8f7679345003c82dc" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;map&lt;/code&gt;, which is a functional programming technique that's also available in other languages like &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;Python&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;Python&lt;/a&gt; 및 &lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt; 과 같은 다른 언어로도 제공되는 기능 프로그래밍 기술인 &lt;code&gt;map&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a4b18372164e1ad74d80e376ae54cd4abd6e783" translate="yes" xml:space="preserve">
          <source>You don't have to write the function inline. It could be a separate function.</source>
          <target state="translated">함수를 인라인으로 작성할 필요는 없습니다. 별도의 기능 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04e20c98a9f172e8338b0b1b84b15442bffed6db" translate="yes" xml:space="preserve">
          <source>You have several options:</source>
          <target state="translated">몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c18eca76acfa486b5f4dcface2dd20167b170206" translate="yes" xml:space="preserve">
          <source>You may not need all of them, but they can be very useful, or would be if every browser supported them.</source>
          <target state="translated">모두 필요하지는 않지만 매우 유용하거나 모든 브라우저에서 지원하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d0197dfcf1833d20eadc2e44df6cf7b17edfb6e7" translate="yes" xml:space="preserve">
          <source>You may see the length caching done in the loop initialization clause, like this:</source>
          <target state="translated">다음과 같이 루프 초기화 절에서 수행 된 길이 캐싱을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b04966caa69c26f8b04bd68edaf4ae602d48951" translate="yes" xml:space="preserve">
          <source>but it still will iterate over custom-defined properties.</source>
          <target state="translated">그러나 여전히 사용자 정의 속성을 반복합니다.</target>
        </trans-unit>
        <trans-unit id="0f1caa03a8a9833b96860b4c667bbe37793f5874" translate="yes" xml:space="preserve">
          <source>for (var s of myStringArray) {</source>
          <target state="translated">for (var의 myStringArray) {</target>
        </trans-unit>
        <trans-unit id="8c120f4720ec425aef81f42a20fa2bc703fd8e57" translate="yes" xml:space="preserve">
          <source>logs: 'one','two','three'</source>
          <target state="translated">로그 : '1', 'two', 'three'</target>
        </trans-unit>
        <trans-unit id="3601240b074c10fa007af1eff93ad808fd4ff1ab" translate="yes" xml:space="preserve">
          <source>logs: 'three','two','one'</source>
          <target state="translated">로그 : 'three', 'two', 'one'</target>
        </trans-unit>
        <trans-unit id="cf8d12fbc60f1b20dd0631d9a744f6b45587b6be" translate="yes" xml:space="preserve">
          <source>or better and cleaner to use while loop:</source>
          <target state="translated">while 루프를 사용하는 것이 더 좋고 깨끗합니다.</target>
        </trans-unit>
        <trans-unit id="50b545a5758f3ce6da5a104b5dfa5a80cee70094" translate="yes" xml:space="preserve">
          <source>which would be sort-of equivalent to:</source>
          <target state="translated">이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="afb20d799b4203b1e14e9210429f20b6ff061fc3" translate="yes" xml:space="preserve">
          <source>will output &quot;11&quot; - which may or may not be what you want.</source>
          <target state="translated">&quot;11&quot;을 출력합니다-원하는 것이거나 아닐 수도 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
