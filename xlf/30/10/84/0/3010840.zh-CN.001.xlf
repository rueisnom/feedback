<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3010840">
    <body>
      <group id="3010840">
        <trans-unit id="71a94b16709bbf4aa3c32acb86f39f9864156150" translate="yes" xml:space="preserve">
          <source>(Directly answering your question: now you can!)</source>
          <target state="translated">(直接回答你的问题:现在你可以了!)</target>
        </trans-unit>
        <trans-unit id="ec51a3dc7ea6a2a72bde5feaa9c8672035a07a39" translate="yes" xml:space="preserve">
          <source>(The variable &lt;code&gt;s&lt;/code&gt; is different on each iteration, but can still be declared &lt;code&gt;const&lt;/code&gt; inside the loop body as long as it isn't modified there.)</source>
          <target state="translated">（变量 &lt;code&gt;s&lt;/code&gt; 在每次迭代中都不同，但是只要不在循环体内对其进行修改，仍可以在循环体内将其声明为 &lt;code&gt;const&lt;/code&gt; 。）</target>
        </trans-unit>
        <trans-unit id="244801924519c2f465f969ec90a3aa5fd9d346b3" translate="yes" xml:space="preserve">
          <source>... with the added benefit of also knowing about the current index inside the loop</source>
          <target state="translated">..............还有一个额外的好处,那就是还能知道循环内的当前指数</target>
        </trans-unit>
        <trans-unit id="ec1bc5f8b9989f3244f9ead64e5db9328413aaec" translate="yes" xml:space="preserve">
          <source>...or this one...</source>
          <target state="translated">或者这个.....</target>
        </trans-unit>
        <trans-unit id="8d2614ef79acce87f4e8df94e0a87325e712b550" translate="yes" xml:space="preserve">
          <source>...or this one:</source>
          <target state="translated">...或者这个</target>
        </trans-unit>
        <trans-unit id="346ff56be0af3dfc4cf74b13b4f1a9723c7e753b" translate="yes" xml:space="preserve">
          <source>1. Just loop through an array</source>
          <target state="translated">1.只需通过一个数组进行循环</target>
        </trans-unit>
        <trans-unit id="555d744b1f77d61c7e32ae7f1a90aff8db853562" translate="yes" xml:space="preserve">
          <source>1. Sequential &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">1.顺序循环：</target>
        </trans-unit>
        <trans-unit id="fa1164fabc473c60d9122565248be869d4644b2f" translate="yes" xml:space="preserve">
          <source>2. Array.prototype.forEach</source>
          <target state="translated">2.Array.prototype.forEach</target>
        </trans-unit>
        <trans-unit id="6e8d1647574b4505b85422943502e4260626b5e9" translate="yes" xml:space="preserve">
          <source>2. Check if any of the elements in an array pass a test</source>
          <target state="translated">2.检查数组中是否有元素通过测试。</target>
        </trans-unit>
        <trans-unit id="c6f4890b5c42211a8b71fa93fd4dc466a147e440" translate="yes" xml:space="preserve">
          <source>3. ES6 &lt;code&gt;for-of&lt;/code&gt; statement</source>
          <target state="translated">3. ES6 &lt;code&gt;for-of&lt;/code&gt; 声明</target>
        </trans-unit>
        <trans-unit id="170ca03f86983ae059350f3d39d8357d3c86d88a" translate="yes" xml:space="preserve">
          <source>3. Transform to a new array</source>
          <target state="translated">3.转换为一个新的数组</target>
        </trans-unit>
        <trans-unit id="29c50fb048ccffde9b75eeb5c873696dc6fad375" translate="yes" xml:space="preserve">
          <source>4. Sum up a particular property, and calculate its average</source>
          <target state="translated">4.总结出某项财产,并计算出其平均数。</target>
        </trans-unit>
        <trans-unit id="2dee4a4a056e6ed1617861aec6829069d797515e" translate="yes" xml:space="preserve">
          <source>5. Create a new array based on the original but without modifying it</source>
          <target state="translated">5.5.在原数组的基础上创建一个新的数组,但不做修改</target>
        </trans-unit>
        <trans-unit id="60379d930daa877950b8a02d7df63a9f9158547b" translate="yes" xml:space="preserve">
          <source>6. Count the number of each category</source>
          <target state="translated">6.6.数出每一类的数量</target>
        </trans-unit>
        <trans-unit id="97078bd3f052e4a50a879e4f327d30b3bb437cb1" translate="yes" xml:space="preserve">
          <source>7. Retrieve a subset of an array based on particular criteria</source>
          <target state="translated">7.根据特定标准检索数组的一个子集。</target>
        </trans-unit>
        <trans-unit id="40b895b551e1a8bf16b710f73aad346b0750062e" translate="yes" xml:space="preserve">
          <source>8. Sort an array</source>
          <target state="translated">8.排序一个数组</target>
        </trans-unit>
        <trans-unit id="944b4287e667dd3dc76140f392ce6f74b5e943d8" translate="yes" xml:space="preserve">
          <source>9. Find an element in an array</source>
          <target state="translated">9.在数组中找到一个元素</target>
        </trans-unit>
        <trans-unit id="f0b6e9ad3ee35377fad2b98e91e4addf653f72fa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://api.jquery.com/jquery.each/&quot;&gt;&lt;strong&gt;&lt;code&gt;jQuery.each()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, in &lt;a href=&quot;https://jquery.com/&quot;&gt;&lt;strong&gt;jQuery&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/jquery.each/&quot;&gt;&lt;strong&gt; &lt;code&gt;jQuery.each()&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;在&lt;a href=&quot;https://jquery.com/&quot;&gt;&lt;strong&gt;jQuery中&lt;/strong&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="b261c82cdd26f431b814a6f9436b4fd59a1deb22" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://underscorejs.org/#each&quot;&gt;&lt;strong&gt;&lt;code&gt;_.each()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, in &lt;a href=&quot;http://underscorejs.org/&quot;&gt;&lt;strong&gt;Underscore.js&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://underscorejs.org/#each&quot;&gt;&lt;strong&gt; &lt;code&gt;_.each()&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;在&lt;strong&gt;Underscore.js&lt;/strong&gt;中：</target>
        </trans-unit>
        <trans-unit id="c58511caaca6df233bc2182e3ec4036cfee42ef7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://lodash.com/docs#forEach&quot;&gt;&lt;strong&gt;&lt;code&gt;_.forEach()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, in &lt;a href=&quot;https://lodash.com/&quot;&gt;&lt;strong&gt;Lodash.js&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://lodash.com/docs#forEach&quot;&gt;&lt;strong&gt; &lt;code&gt;_.forEach()&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; ，在&lt;a href=&quot;https://lodash.com/&quot;&gt;&lt;strong&gt;Lodash.js中&lt;/strong&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="52ca60a94f206d4eac02b402c38bb25a86fa23d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array.prototype.forEach()&lt;/code&gt; is supported by all modern browsers, as well as Internet&amp;nbsp;Explorer&amp;nbsp;9 and later.</source>
          <target state="translated">所有现代浏览器以及Internet Explorer 9和更高版本均支持 &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d3bfa9adc07d603c481ef7db3fa023766d732441" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;For...in&lt;/code&gt; and &lt;code&gt;for...of&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;For...in&lt;/code&gt; &lt;code&gt;for...of&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a54271474b32241db54533f0e2686f548830428" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt; doesn't give you the index associated with each object, but as long as the object you're iterating over is actually an &lt;code&gt;Array&lt;/code&gt; (&lt;code&gt;for&lt;/code&gt;..&lt;code&gt;of&lt;/code&gt; works for other iterable types which may not have this method), you can use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries&quot;&gt;Array#entries&lt;/a&gt; method to change it to an array of [index, item] pairs, and then iterate over that:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ... &lt;code&gt;of&lt;/code&gt; 不会为您提供与每个对象相关联的索引，但是只要您要迭代的对象实际上是一个 &lt;code&gt;Array&lt;/code&gt; （ &lt;code&gt;for&lt;/code&gt; .. for其他可能没有此方法的可迭代类型 &lt;code&gt;of&lt;/code&gt; 作品），您可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries&quot;&gt;Array＃entries&lt;/a&gt;方法将其更改为[index，item]对数组，然后对其进行迭代：</target>
        </trans-unit>
        <trans-unit id="7bb38035ceb1c396d3e7996795df8bf4c249f876" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(example extracted from &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&lt;/a&gt;)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（示例摘自&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&lt;/a&gt; ）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf37ae0f080f8d39b2aaaf060b6cdeb79a3c67db" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;Array.prototype.forEach()&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;Array.prototype.forEach()&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="26e2ad632edf81fb7e89bc1c9c05201ffd6e306d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Compatibility table:&lt;/em&gt;&lt;a href=&quot;http://kangax.github.io/es5-compat-table/es6/&quot;&gt;http://kangax.github.io/es5-compat-table/es6/#For..of loops&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;兼容性表：&lt;/em&gt; &lt;a href=&quot;http://kangax.github.io/es5-compat-table/es6/&quot;&gt;http&lt;/a&gt; &lt;em&gt;:&lt;/em&gt; //kangax.github.io/es5-compat-table/es6/#For..of循环</target>
        </trans-unit>
        <trans-unit id="ee6ae84753dccfa00cebeada5ae7c3e21d1273a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Spec:&lt;/em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:iterators&quot;&gt;http://wiki.ecmascript.org/doku.php?id=harmony:iterators&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;Spec:&lt;/em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:iterators&quot;&gt;http://wiki.ecmascript.org/doku.php?id=harmony:iterators&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="064b427011b9e17b9e8c52d0c2639ac7a841e64e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) For loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1）循环&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b51f60a16cebef810392106138bdb5ad294a4367" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) While loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2）While循环&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a4c5db10da9d3be2f8b682db7a9e9d2f7183bdc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Do while&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3）做一会儿&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eef54d6b0a77c28db0f845a27fb46e78a54e93ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;jQuery.each( collection, callback(indexInArray, valueOfElement) )&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;jQuery.each( collection, callback(indexInArray, valueOfElement) )&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="daf1d3da9a9639317a8275f5459ed1e0ddfaa92a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Anti-pattern:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Anti-pattern:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="caf1f7a722c982dbd57c57da6fb19a30c4de09b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="704e3b0291568ed9b2c317a548493efb74047033" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Description:&lt;/strong&gt;&lt;em&gt;A generic iterator function, which can be used to
  seamlessly iterate over both objects and arrays. Arrays and array-like
  objects with a length property (such as a function's arguments object)
  are iterated by numeric index, from 0 to length-1. Other objects are
  iterated via their named properties.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;说明：&lt;/strong&gt; &lt;em&gt;通用迭代器函数，可用于无缝迭代对象和数组。&lt;/em&gt; &lt;em&gt;具有长度属性的数组和类似数组的对象（例如函数的arguments对象）通过从0到length-1的数字索引进行迭代。&lt;/em&gt; &lt;em&gt;其他对象通过其命名属性进行迭代。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="048e1c2143e4ceda5b814a601b1c670466d18b12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES5's forEach:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES5的forEach：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54f593ac46043f8cd9b8b5cf07af22c51c808d96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Generic loop:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;通用循环：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f79071ea203b44120a777b7df731ac7eeaca3df3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterating a generator:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;迭代生成器：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="45c6df2e8979bcdde42829f806f00107ff130204" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterating an array of objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;迭代对象数组&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee4457fb819a5b4a1c45f33c6d9277e095252e99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterating an array&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;迭代数组&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d0724a44cc225daaa925fdc5f4076cd6a8e137b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preparation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Preparation:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4679141d2baf9da770b2677b4605d0925bd20b32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Proper use case of &lt;em&gt;map&lt;/em&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;map的&lt;/em&gt;正确用例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83a9ba38fb48160c9afd7eb56731a2e28460dc89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Proper use of &lt;em&gt;reduce&lt;/em&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;正确使用&lt;em&gt;reduce&lt;/em&gt; ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="364d4fdee3e0bca52971cff9ce11bfd5c1cd8d29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c74addec8c64f7706a870355eb69d171e4ffada" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returns:&lt;/strong&gt;&lt;em&gt;Object&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Returns:&lt;/strong&gt;&lt;em&gt;Object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9e855f63e3c1e56f1a45077526fe3d067eab2a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tests:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Tests:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a921ab2d2c8f22b4e62a469b18c3138401c9585" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The afterthought:&lt;/strong&gt; performed every time after the loop block is executed</source>
          <target state="translated">&lt;strong&gt;事后思考：&lt;/strong&gt;循环块执行后每次执行</target>
        </trans-unit>
        <trans-unit id="0841879c44f870229f18babbbb28a4ed0218e63d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The condition:&lt;/strong&gt; checks a condition every time before the loop block is executed, and quits the loop if false</source>
          <target state="translated">&lt;strong&gt;条件：&lt;/strong&gt;每次在执行循环块之前都要检查条件，如果为false则退出循环</target>
        </trans-unit>
        <trans-unit id="ef6b1bf0d5160d7392a2ec56a57142f8de0324e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The initialization:&lt;/strong&gt; executed before the look block is executed the first time</source>
          <target state="translated">&lt;strong&gt;初始化：&lt;/strong&gt;在第一次执行look块之前执行</target>
        </trans-unit>
        <trans-unit id="83b0f4ed7f0a0bdf74518f2b95d2dc1099b984c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes&lt;/strong&gt;, you can do the same in JavaScript using a loop, but &lt;strong&gt;not limited&lt;/strong&gt; to that, there are many ways to do a loop over arrays in JavaScript. Imagine you have this array below, and you'd like to do a loop over it:</source>
          <target state="translated">&lt;strong&gt;是的&lt;/strong&gt; ，您可以使用循环在JavaScript中进行相同的操作，但&lt;strong&gt;不仅限于&lt;/strong&gt;此，有很多方法可以对JavaScript中的数组进行循环。 假设您在下面有这个数组，并且想对其进行循环：</target>
        </trans-unit>
        <trans-unit id="f841e3cc81531c69c584f7487ed89ea2ccac79f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;every&lt;/strong&gt; returns true if every array member passes the test.</source>
          <target state="translated">如果每个数组成员通过测试，则&lt;strong&gt;每个&lt;/strong&gt;返回true。</target>
        </trans-unit>
        <trans-unit id="ae5396154ba12f2cbc9b6fb60697228d099a6bfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;filter&lt;/strong&gt; returns an array of items that satisfy some condition or test.</source>
          <target state="translated">&lt;strong&gt;filter&lt;/strong&gt;返回满足某些条件或测试的项目数组。</target>
        </trans-unit>
        <trans-unit id="bdef08e47d03473e002381b0b85e4c365db03f3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;forEach&lt;/strong&gt; runs a function on each array member and doesn't return anything.</source>
          <target state="translated">&lt;strong&gt;forEach&lt;/strong&gt;在每个数组成员上运行一个函数，并且不返回任何内容。</target>
        </trans-unit>
        <trans-unit id="4e0ee97333a8174d8fa7c7379cd31d5d7b455eb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;indexOf&lt;/strong&gt; and &lt;strong&gt;lastIndexOf&lt;/strong&gt; find the appropriate position of the first or last element that matches its argument exactly.</source>
          <target state="translated">&lt;strong&gt;indexOf&lt;/strong&gt;和&lt;strong&gt;lastIndexOf&lt;/strong&gt;可以找到与其参数完全匹配的第一个或最后一个元素的适当位置。</target>
        </trans-unit>
        <trans-unit id="89bb2ea399853abc85cd80df1635dcb485fff8de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery.each:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery.each:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a7285fa826c294da33df813b34b34a49e92f76c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;map&lt;/strong&gt; is like forEach, but it returns an array of the results of the operation for each element.</source>
          <target state="translated">&lt;strong&gt;map&lt;/strong&gt;类似于forEach，但是它返回每个元素的操作结果数组。</target>
        </trans-unit>
        <trans-unit id="05b320d00a006bb181f7dc73f11bce756fd386ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;some&lt;/strong&gt; returns true if any pass the test.</source>
          <target state="translated">如果通过测试，则&lt;strong&gt;某些&lt;/strong&gt;返回true。</target>
        </trans-unit>
        <trans-unit id="3b932bd9e58e3f9ce0d4b89f0f0f9034a0636581" translate="yes" xml:space="preserve">
          <source>@zipcodeman suggests the use of the &lt;code&gt;for...in&lt;/code&gt; statement, but for iterating arrays &lt;code&gt;for-in&lt;/code&gt; should be avoided, that statement is meant to &lt;strong&gt;enumerate&lt;/strong&gt; object properties.</source>
          <target state="translated">@zipcodeman建议使用 &lt;code&gt;for...in&lt;/code&gt; 语句，但是要避免迭代数组 &lt;code&gt;for-in&lt;/code&gt; ，该语句旨在&lt;strong&gt;枚举&lt;/strong&gt;对象属性。</target>
        </trans-unit>
        <trans-unit id="cc59d14dbd8a74031257140af343c1de66fa1c7e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do while&lt;/code&gt; is doing the same thing as &lt;code&gt;while&lt;/code&gt; with some syntax difference as below:</source>
          <target state="translated">&lt;code&gt;do while&lt;/code&gt; 与while做相同的事情， &lt;code&gt;while&lt;/code&gt; 语法有所不同，如下所示：</target>
        </trans-unit>
        <trans-unit id="7ba0e7db2ec388ee16e982710586d5dcd4505fa1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop is a common way looping through arrays in JavaScript, but no considered as the fastest solutions for large arrays:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 循环是在JavaScript中循环遍历数组的一种常用方法，但不被认为是大型数组的最快解决方案：</target>
        </trans-unit>
        <trans-unit id="a2e0ff643ee538083545089d13416135913cd236" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; loop</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; 循环</target>
        </trans-unit>
        <trans-unit id="8138b8bf38e6eb381685855e53355dab4069f576" translate="yes" xml:space="preserve">
          <source>A lot cleaner...</source>
          <target state="translated">更加干净.....</target>
        </trans-unit>
        <trans-unit id="208b5e319042638896984a55881d0d0b48f1809f" translate="yes" xml:space="preserve">
          <source>A note on sparse arrays: an array in JavaScript may not actually store as many items as reported by its &lt;code&gt;length&lt;/code&gt;; that reported number is simply one greater than the highest index at which a value is stored. If the array holds fewer elements than indicated by its length, its said to be &lt;em&gt;sparse&lt;/em&gt;. For example, it's perfectly legitimate to have an array with items only at indexes 3, 12, and 247; the &lt;code&gt;length&lt;/code&gt; of such an array is reported as 248, though it is only actually storing 3 values.  If you try to access an item at any other index, the array will appear to have the &lt;code&gt;undefined&lt;/code&gt; value there. So when you want to &quot;loop through&quot; an array, you have a question to answer: do you want to loop over the full range indicated by its length and process &lt;code&gt;undefined&lt;/code&gt;s for any missing elements, or do you only want to process the elements actually present? There are plenty of applications for both approaches; it just depends on what you're using the array for.</source>
          <target state="translated">关于稀疏数组的注释：JavaScript中的数组实际存储的项目可能不如其 &lt;code&gt;length&lt;/code&gt; 所报告的那么多； 该报告的数字仅比存储值的最高索引大一个。 如果数组中的元素少于其长度所指示的元素，则称其为&lt;em&gt;稀疏&lt;/em&gt; 。 例如，拥有仅在索引3、12和247处有项的数组是完全合法的； 尽管实际上仅存储3个值，但该数组的 &lt;code&gt;length&lt;/code&gt; 报告为248。 如果您尝试访问任何其他索引处的项目，则该数组似乎在其中具有 &lt;code&gt;undefined&lt;/code&gt; 值。 因此，当您要&amp;ldquo;遍历&amp;rdquo;数组时，您需要回答一个问题：要遍历其长度所指示的整个范围，并为所有丢失的元素处理 &lt;code&gt;undefined&lt;/code&gt; s，还是只想处理这些元素实际存在吗？ 两种方法都有很多应用。 这仅取决于您使用数组的目的。</target>
        </trans-unit>
        <trans-unit id="1c8bc2da7ace60c25491e4b45d72527b6904edf7" translate="yes" xml:space="preserve">
          <source>A traditional &lt;code&gt;for&lt;/code&gt; loop has three components:</source>
          <target state="translated">传统的 &lt;code&gt;for&lt;/code&gt; 循环包含三个组成部分：</target>
        </trans-unit>
        <trans-unit id="93369b398d50b7aaab7d717bce714a497353f9a1" translate="yes" xml:space="preserve">
          <source>A traditional &lt;code&gt;for&lt;/code&gt;-loop</source>
          <target state="translated">传统的 &lt;code&gt;for&lt;/code&gt; 循环</target>
        </trans-unit>
        <trans-unit id="96d8cabd7458880b5703e2b2959e3cbf91d9b07e" translate="yes" xml:space="preserve">
          <source>A while loop is considered as the fastest way to loop through long arrays, but it is usually less used in the JavaScript code:</source>
          <target state="translated">while循环被认为是通过长数组循环最快的方法,但通常在JavaScript代码中较少使用。</target>
        </trans-unit>
        <trans-unit id="1bab4365e2766b395817dc81f2821118ea4e8b6d" translate="yes" xml:space="preserve">
          <source>A working jsFiddle example:
&lt;a href=&quot;https://jsfiddle.net/workingClassHacker/pxpv2dh5/7/&quot;&gt;https://jsfiddle.net/workingClassHacker/pxpv2dh5/7/&lt;/a&gt;</source>
          <target state="translated">一个有效的jsFiddle示例： &lt;a href=&quot;https://jsfiddle.net/workingClassHacker/pxpv2dh5/7/&quot;&gt;https&lt;/a&gt; ://jsfiddle.net/workingClassHacker/pxpv2dh5/7/</target>
        </trans-unit>
        <trans-unit id="87989326732077c33a82222d4512a023029ffac3" translate="yes" xml:space="preserve">
          <source>Additionally, you need to consider that no version of Internet Explorer supports &lt;code&gt;for...of&lt;/code&gt; (&lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;&lt;strong&gt;Edge 12+&lt;/strong&gt;&lt;/a&gt; does) and that &lt;code&gt;for...in&lt;/code&gt; requires at least Internet&amp;nbsp;Explorer&amp;nbsp;10.</source>
          <target state="translated">此外，您需要考虑到 &lt;code&gt;for...of&lt;/code&gt; 的Internet Explorer版本不支持（of &lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;&lt;strong&gt;Edge 12+&lt;/strong&gt;&lt;/a&gt;支持）， &lt;code&gt;for...in&lt;/code&gt; 至少需要Internet Explorer 10支持。</target>
        </trans-unit>
        <trans-unit id="7bdea304f3832a9d1bee7adfb3ce1b3900b31457" translate="yes" xml:space="preserve">
          <source>Also look at the &lt;code&gt;map()&lt;/code&gt;, &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;reduce()&lt;/code&gt;, etc. functions on an Array in JavaScript. They may do things much faster and better than using &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt;.</source>
          <target state="translated">还要看一下JavaScript中数组上的 &lt;code&gt;map()&lt;/code&gt; ， &lt;code&gt;filter()&lt;/code&gt; ， &lt;code&gt;reduce()&lt;/code&gt; 等函数。 他们做事的速度和时间可能比暂时的要好得多。</target>
        </trans-unit>
        <trans-unit id="9d7962bb439dccc6fd05184547a30773438f73c3" translate="yes" xml:space="preserve">
          <source>Also we use a &lt;code&gt;for in&lt;/code&gt; loop for looping over objects in JavaScript.</source>
          <target state="translated">另外，我们使用 &lt;code&gt;for in&lt;/code&gt; 循环来遍历JavaScript中的对象。</target>
        </trans-unit>
        <trans-unit id="41378cebb50d920582b6d22c47f75d416ff10194" translate="yes" xml:space="preserve">
          <source>Also, as CMS mentions in a comment below, you can only use this on arrays that don't contain any falsish values. The array of strings from the example works, but if you have empty strings, or numbers that are 0 or NaN, etc. the loop will break off prematurely. Again in practice this is hardly ever a problem for me, but it is something to keep in mind, which makes this a loop to think about before you use it... That may disqualify it for some people :)</source>
          <target state="translated">另外,正如CMS在下面的一个评论中提到的,你只能在不包含任何虚假值的数组上使用这个方法。这个例子中的字符串数组可以使用,但如果你有空字符串,或者是0或NaN等数字,循环就会提前中断。在实际操作中,这对我来说几乎没有什么问题,但这是个需要注意的问题,所以在使用这个循环之前需要考虑一下。这可能会让一些人失去了使用资格 :)</target>
        </trans-unit>
        <trans-unit id="ee77eebe99af67ab08f84860fed6f896852d7c5f" translate="yes" xml:space="preserve">
          <source>Also, if you are trying to &lt;em&gt;reduce&lt;/em&gt; the array to a value, for example, you want to sum an array of numbers, you should use the &lt;em&gt;reduce&lt;/em&gt; method.</source>
          <target state="translated">同样，例如，如果您尝试将数组&lt;em&gt;缩小&lt;/em&gt;为一个值，则想对数字数组求和，则应使用&lt;em&gt;reduce&lt;/em&gt;方法。</target>
        </trans-unit>
        <trans-unit id="14295abe04b6e2a7de39a9d704b37a8979113366" translate="yes" xml:space="preserve">
          <source>Also, note that every while loop can be rewritten as a &lt;code&gt;for&lt;/code&gt; loop. For example, the &lt;code&gt;while&lt;/code&gt; loop hereabove behaves the exact same way as this &lt;code&gt;for&lt;/code&gt;-loop:</source>
          <target state="translated">另外，请注意，每个while循环都可以重写为 &lt;code&gt;for&lt;/code&gt; 循环。 例如，上述 &lt;code&gt;while&lt;/code&gt; 循环的行为与-loop完全相同：</target>
        </trans-unit>
        <trans-unit id="d4c7b480881659d668d6e1c838c1bbd6f2357af6" translate="yes" xml:space="preserve">
          <source>An alternative to &lt;code&gt;for&lt;/code&gt;-loops is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;strong&gt;&lt;code&gt;Array.prototype.forEach()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, which uses the following syntax:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; -loops的替代方法是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;strong&gt; &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; ，它使用以下语法：</target>
        </trans-unit>
        <trans-unit id="7608e4a05c083f0749c3b00ef49e63f9bb0d59f7" translate="yes" xml:space="preserve">
          <source>And for the reverse order, an even more efficient loop</source>
          <target state="translated">而对于逆序,则是一个更有效的循环。</target>
        </trans-unit>
        <trans-unit id="ea3c12f54f03b3157d901d7ecb01d0c6e8c6314b" translate="yes" xml:space="preserve">
          <source>And now x is &lt;code&gt;[10,20,30,40]&lt;/code&gt;.</source>
          <target state="translated">现在x是 &lt;code&gt;[10,20,30,40]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b16c84749f0eea7f146f4aab53c2350db832cc15" translate="yes" xml:space="preserve">
          <source>And with the ES6 arrow function syntax, it's even more succinct:</source>
          <target state="translated">而用ES6的箭头函数语法,就更简洁了。</target>
        </trans-unit>
        <trans-unit id="9aee1dfe4cd64107cde999301ba98e4228ffd0ba" translate="yes" xml:space="preserve">
          <source>Array loop:</source>
          <target state="translated">阵列循环。</target>
        </trans-unit>
        <trans-unit id="59df7171edff63098689b1d4cbcde62b62c5c672" translate="yes" xml:space="preserve">
          <source>Array objects are by definition built-in iterables in ES6, so you can use this statement on them:</source>
          <target state="translated">根据定义,数组对象在ES6中是内置的迭代对象,所以你可以对它们使用这条语句。</target>
        </trans-unit>
        <trans-unit id="9b48533ed470f313be2a50e6f04cca823d741861" translate="yes" xml:space="preserve">
          <source>Array.prototype.filter()</source>
          <target state="translated">Array.prototype.filter()</target>
        </trans-unit>
        <trans-unit id="a71dca401c8bb6c1ba8a6a85b489323db0aded15" translate="yes" xml:space="preserve">
          <source>Array.prototype.find()</source>
          <target state="translated">Array.prototype.find()</target>
        </trans-unit>
        <trans-unit id="4cb3cae1053ce2bb98a5b83b932f46c25e31ba9b" translate="yes" xml:space="preserve">
          <source>Array.prototype.forEach()</source>
          <target state="translated">Array.prototype.forEach()</target>
        </trans-unit>
        <trans-unit id="119e13f09e922be9e6bae1b2eb26f44372c5447b" translate="yes" xml:space="preserve">
          <source>Array.prototype.map()</source>
          <target state="translated">Array.prototype.map()</target>
        </trans-unit>
        <trans-unit id="4e64033432afb4813d9f7c316c2ce7cc3e7a8ccd" translate="yes" xml:space="preserve">
          <source>Array.prototype.some()</source>
          <target state="translated">Array.prototype.some()</target>
        </trans-unit>
        <trans-unit id="7038dcb1eaea94f778a783fcd9d69b9aa89101f4" translate="yes" xml:space="preserve">
          <source>Array.prototype.sort()</source>
          <target state="translated">Array.prototype.sort()</target>
        </trans-unit>
        <trans-unit id="a34e33465f051a1d48b1d51dd13cef09aa81c0c5" translate="yes" xml:space="preserve">
          <source>Arrow functions are also widely implemented unless you plan to support ancient platforms (e.g., IE11); you are also safe to go.</source>
          <target state="translated">除非你打算支持古代平台(如IE11),否则箭头功能也会被广泛使用;你也可以放心使用。</target>
        </trans-unit>
        <trans-unit id="966cddcbaa10c67096f934e4803322a1c2ad7ec2" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;strong&gt;&lt;code&gt;for...in&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, there's now also for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;strong&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;. The following example shows the difference between a &lt;code&gt;for...of&lt;/code&gt; loop and a &lt;code&gt;for...in&lt;/code&gt; loop:</source>
          <target state="translated">作为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;strong&gt; &lt;code&gt;for...in&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;的替代，现在也有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;strong&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; 。 以下示例显示了 &lt;code&gt;for...of&lt;/code&gt; 循环和 &lt;code&gt;for...in&lt;/code&gt; 循环之间的区别：</target>
        </trans-unit>
        <trans-unit id="47221220436db2e97d5585cd374547abd2cdc928" translate="yes" xml:space="preserve">
          <source>As long as your JavaScript implementation is compliant with the &lt;em&gt;previous&lt;/em&gt; edition of the ECMAScript specification (which rules out, for example, versions of Internet Explorer before 9), then you can use the &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.foreach&quot;&gt;&lt;code&gt;Array#forEach&lt;/code&gt;&lt;/a&gt; iterator method instead of a loop. In that case, you pass a function to be called on each item in the array:</source>
          <target state="translated">只要您的JavaScript实现与早期版本的ECMAScript规范（例如，排除Internet Explorer 9之前的版本）兼容，您就可以使用&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.foreach&quot;&gt; &lt;code&gt;Array#forEach&lt;/code&gt; &lt;/a&gt;迭代器方法代替循环。 在这种情况下，您传递一个要在数组中每个项目上调用的函数：</target>
        </trans-unit>
        <trans-unit id="cc57a09cc87a254c6e7c0cd906743181aa3a7326" translate="yes" xml:space="preserve">
          <source>Assigning the length value to the local variable (as opposed to including the full &lt;code&gt;myStringArray.length&lt;/code&gt; expression in the loop condition) can make a significant difference in performance since it skips a property lookup each time through; using Rhino on my machine, the speedup is 43%.</source>
          <target state="translated">将长度值分配给局部变量（与在循环条件中包括完整的 &lt;code&gt;myStringArray.length&lt;/code&gt; 表达式相反）会在性能上产生重大差异，因为它每次都会跳过属性查找。 在我的机器上使用Rhino，速度提高了43％。</target>
        </trans-unit>
        <trans-unit id="f3274f27a722ba9623d1b3c45014647813c3ad0d" translate="yes" xml:space="preserve">
          <source>Being almost ten years as the time of writing that the ES5 specification was released (Dec. 2009), it has been implemented by nearly all modern engines in the desktop, server, and mobile environments, so it's safe to use them.</source>
          <target state="translated">从编写ES5规范发布到现在已经快十年了(2009年12月),几乎所有的现代引擎都已经在桌面、服务器和移动环境中实现了ES5规范,所以使用起来很安全。</target>
        </trans-unit>
        <trans-unit id="2dd3bc0add58e1c1a3bae79831bd75535ddcea2a" translate="yes" xml:space="preserve">
          <source>Can use normal flow control statements (&lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt;).</source>
          <target state="translated">可以使用普通的流控制语句（ &lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="738f7a02d196b0ea75cd3e9615801f4654f464c6" translate="yes" xml:space="preserve">
          <source>Can you do the same in JavaScript?</source>
          <target state="translated">你能用JavaScript做同样的事情吗?</target>
        </trans-unit>
        <trans-unit id="bb89c713f3058705a62ca86f844888cbdaec51e9" translate="yes" xml:space="preserve">
          <source>Cannot use &lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt;</source>
          <target state="translated">无法使用 &lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b36f8d07e1ebb98db02a451f012dc4e52c8f57bf" translate="yes" xml:space="preserve">
          <source>Combines very naturally with array.push and array.splice to use arrays like lists/stacks</source>
          <target state="translated">与array.push和array.splice非常自然地结合,可以使用像liststacks这样的数组。</target>
        </trans-unit>
        <trans-unit id="0867c816fed31b5dc07fa208e04fcb8489f13b48" translate="yes" xml:space="preserve">
          <source>Comparing methods for looping through an array of 100000 items and do a minimal operation with the new value each time.</source>
          <target state="translated">比较的方法是在一个100000的数组中循环运行,每次用新的值做一个最小的操作。</target>
        </trans-unit>
        <trans-unit id="3484c6fcb53ac09a3fead481f71e452bc3f9e097" translate="yes" xml:space="preserve">
          <source>Declarative</source>
          <target state="translated">Declarative</target>
        </trans-unit>
        <trans-unit id="4effb93b81a160f681429d60f84b0435de4c8948" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;for...in&lt;/code&gt;</source>
          <target state="translated">请勿 &lt;code&gt;for...in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a327a1024dd4bfffdf3d3e9c43606dd74e3c14b" translate="yes" xml:space="preserve">
          <source>Easy to have &lt;a href=&quot;https://en.wikipedia.org/wiki/Off-by-one_error#Looping_over_arrays&quot;&gt;off-by-one errors&lt;/a&gt; (sometimes also called a &lt;em&gt;fence post error&lt;/em&gt;)</source>
          <target state="translated">容易出现&lt;a href=&quot;https://en.wikipedia.org/wiki/Off-by-one_error#Looping_over_arrays&quot;&gt;一对一的错误&lt;/a&gt; （有时也称为&lt;em&gt;栅栏错误&lt;/em&gt; ）</target>
        </trans-unit>
        <trans-unit id="792e26d9ee80b19650012b8e1685b5090c7185da" translate="yes" xml:space="preserve">
          <source>Edited (because I was wrong)</source>
          <target state="translated">编辑了(因为我错了</target>
        </trans-unit>
        <trans-unit id="a69fa90f2006d689445d656a40e7e8de54b4823e" translate="yes" xml:space="preserve">
          <source>Enumeration VS Iteration</source>
          <target state="translated">枚举VS迭代</target>
        </trans-unit>
        <trans-unit id="2e71f7108ada8318088ac69ef4919973105c6a36" translate="yes" xml:space="preserve">
          <source>Except you don't get the &lt;code&gt;new_list&lt;/code&gt;.</source>
          <target state="translated">除非您没有得到 &lt;code&gt;new_list&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="5952055811aee2e799c8aba3a69449f3348a23fc" translate="yes" xml:space="preserve">
          <source>Finally, many utility libraries also have their own &lt;code&gt;foreach&lt;/code&gt; variation. AFAIK, the three most popular ones are these:</source>
          <target state="translated">最后，许多实用程序库也有自己的 &lt;code&gt;foreach&lt;/code&gt; 变体。 AFAIK，三种最受欢迎​​的是：</target>
        </trans-unit>
        <trans-unit id="69464752c7da492f7d32ce20b9cb8b32ed093960" translate="yes" xml:space="preserve">
          <source>For example, I used in a Firefox console:</source>
          <target state="translated">例如,我在Firefox控制台中使用。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">比如说:</target>
        </trans-unit>
        <trans-unit id="4b130c10bf2374ee6a7bc0052bacfac69fa72cc6" translate="yes" xml:space="preserve">
          <source>For me, this construct most closely emulates the Java 5 syntax that I love:</source>
          <target state="translated">对我来说,这个构造最接近于我喜欢的Java 5语法。</target>
        </trans-unit>
        <trans-unit id="332ea3a31e79d47a90b9a3ccec9c1cdfdbaa5829" translate="yes" xml:space="preserve">
          <source>From the documentation:</source>
          <target state="translated">从文件中可以看出:</target>
        </trans-unit>
        <trans-unit id="d8f88d3b1d0ba856a7a6feeeff6fceeb8172f54f" translate="yes" xml:space="preserve">
          <source>Functional programming has been making quite a splash in the
  development world these days. And for good reason: Functional
  techniques can help you write more declarative code that is easier to
  understand at a glance, refactor, and test.</source>
          <target state="translated">最近,功能编程在开发界引起了很大的轰动。这也是有原因的。功能化技术可以帮助你写出更多的声明性代码,让你更容易理解,更容易重构和测试。</target>
        </trans-unit>
        <trans-unit id="1dd7c2693b617aa4bf3153d763983796bfb81010" translate="yes" xml:space="preserve">
          <source>Given an array:</source>
          <target state="translated">鉴于一个数组:</target>
        </trans-unit>
        <trans-unit id="71f5b35dbf42c10acd92d892d5a9a39d98b97a52" translate="yes" xml:space="preserve">
          <source>Have a look &lt;a href=&quot;https://stackoverflow.com/questions/3943494/how-to-loop-through-array-in-jquery&quot;&gt;this&lt;/a&gt; for detailed information or you can also check &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;MDN&lt;/a&gt; for looping through an array in JavaScript &amp;amp; using jQuery check &lt;a href=&quot;http://api.jquery.com/jquery.each/&quot;&gt;jQuery for each&lt;/a&gt;.</source>
          <target state="translated">请查看&lt;a href=&quot;https://stackoverflow.com/questions/3943494/how-to-loop-through-array-in-jquery&quot;&gt;此&lt;/a&gt;以获取详细信息，或者您也可以检查&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;MDN&lt;/a&gt;以遍历JavaScript中的数组，并使用jQuery检查&lt;a href=&quot;http://api.jquery.com/jquery.each/&quot;&gt;每个的jQuery&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a275f06b64b792994a2bea49ec5edd99e73a997" translate="yes" xml:space="preserve">
          <source>Hence:</source>
          <target state="translated">Hence:</target>
        </trans-unit>
        <trans-unit id="36fb22ec3194ab597f2415160001e28b55136fda" translate="yes" xml:space="preserve">
          <source>I did not yet see this variation, which I personally like the best:</source>
          <target state="translated">我还没有看到这个变体,这是我个人最喜欢的。</target>
        </trans-unit>
        <trans-unit id="bc84262abb174c9f0e38f36c626a6768b31337c7" translate="yes" xml:space="preserve">
          <source>I would recommend you to read the following article:</source>
          <target state="translated">推荐你看下面这篇文章。</target>
        </trans-unit>
        <trans-unit id="eaec00891170c602b86758588121582f9cc77f86" translate="yes" xml:space="preserve">
          <source>I would thoroughly recommend making use of the &lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;underscore.js&lt;/a&gt; library. It provides you with various functions that you can use to iterate over arrays/collections.</source>
          <target state="translated">我会彻底建议您使用&lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;underscore.js&lt;/a&gt;库。 它为您提供了各种功能，可用于遍历数组/集合。</target>
        </trans-unit>
        <trans-unit id="680e5f2fe4669cc64fca6d0dce2445fc1aba9665" translate="yes" xml:space="preserve">
          <source>If anybody is interested in the performance side of the multiple mechanisms available for Array iterations, I've prepared the following JSPerf tests:</source>
          <target state="translated">如果有人对Array迭代的多种机制的性能方面感兴趣,我准备了以下JSPerf测试。</target>
        </trans-unit>
        <trans-unit id="fb3e18a35d3138a4789c20ff08015dcd8a81b50b" translate="yes" xml:space="preserve">
          <source>If one wants to iterate over sparsed array, &lt;code&gt;for (var i = 0; i &amp;lt; array.length; i++) if (i in array)&lt;/code&gt; or &lt;code&gt;array.forEach&lt;/code&gt; with &lt;code&gt;es5shim&lt;/code&gt; should be used.</source>
          <target state="translated">如果要遍历稀疏数组， &lt;code&gt;for (var i = 0; i &amp;lt; array.length; i++) if (i in array)&lt;/code&gt; 应该使用（ &lt;code&gt;array.forEach&lt;/code&gt; in array）或带有 &lt;code&gt;es5shim&lt;/code&gt; 的array.forEach 。</target>
        </trans-unit>
        <trans-unit id="e7c24db9c43e39fc71182c2e8052375e6c248727" translate="yes" xml:space="preserve">
          <source>If order of iteration does not matter than you should try reversed loop, it is fastest as it reduce overhead condition testing and decrement is in one statement:</source>
          <target state="translated">如果迭代顺序并不重要,那么你应该尝试反向循环,它是最快的,因为它可以减少条件测试的开销,并且在一条语句中进行递减。</target>
        </trans-unit>
        <trans-unit id="02757283e37586df6bb23c4f4ba9f10dab95d8e4" translate="yes" xml:space="preserve">
          <source>If you are targeting older browsers, the transpiled output &lt;a href=&quot;https://babeljs.io/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=GYewTgBAFAxiB2BnALhOAbcETDSTYiAlAN4BQEeS-ApgHSYDms-4RA3GQL5A&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=true&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=false&amp;amp;presets=es2015&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.4&amp;amp;externalPlugins=&quot;&gt;might surprise you&lt;/a&gt;.</source>
          <target state="translated">如果您以较旧的浏览器为目标，则转换后的输出&lt;a href=&quot;https://babeljs.io/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=GYewTgBAFAxiB2BnALhOAbcETDSTYiAlAN4BQEeS-ApgHSYDms-4RA3GQL5A&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=true&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=false&amp;amp;presets=es2015&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.4&amp;amp;externalPlugins=&quot;&gt;可能会让您感到惊讶&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f829a0689ccf713644890b1c3b1a4cfc8ad34e87" translate="yes" xml:space="preserve">
          <source>If you iterate over an array with &lt;code&gt;for&lt;/code&gt;..&lt;code&gt;of&lt;/code&gt;, the body of the loop is executed &lt;code&gt;length&lt;/code&gt; times, and the loop control variable is set to &lt;code&gt;undefined&lt;/code&gt; for any items not actually present in the array. Depending on the details of your &quot;do something with&quot; code, that behavior may be what you want, but if not, you should use a different approach.</source>
          <target state="translated">如果使用 &lt;code&gt;for&lt;/code&gt; .. &lt;code&gt;of&lt;/code&gt; 遍历一个数组，则循环的主体将执行一定的时间，并且对于数组中实际不存在的任何项，将循环控制变量设置为 &lt;code&gt;undefined&lt;/code&gt; 。 根据您的&amp;ldquo;执行某项操作&amp;rdquo;代码的详细信息，该行为可能是您想要的，但如果不是，则应使用其他方法。</target>
        </trans-unit>
        <trans-unit id="6b16cc5e544f97e4c2c7404c40a6b88137b3439b" translate="yes" xml:space="preserve">
          <source>If you want a terse way to write a fast loop &lt;em&gt;and&lt;/em&gt; you can iterate in reverse:</source>
          <target state="translated">如果您想用一种简洁的方式编写一个快速循环&lt;em&gt;，&lt;/em&gt;可以反向进行迭代：</target>
        </trans-unit>
        <trans-unit id="436e7053c19b3557bdfbc7e2a4a3f788195af7aa" translate="yes" xml:space="preserve">
          <source>If you want to use jQuery, it has a nice example in its documentation:</source>
          <target state="translated">如果你想用jQuery,它的文档里有一个很好的例子。</target>
        </trans-unit>
        <trans-unit id="bc55dbfa6cee82874054cf5092582433ac1060f8" translate="yes" xml:space="preserve">
          <source>If you're using the jQuery library, consider using 
&lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt;http://api.jquery.com/jQuery.each/&lt;/a&gt;</source>
          <target state="translated">如果您使用的是jQuery库，请考虑使用&lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt;http://api.jquery.com/jQuery.each/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e36ebcd66de4bbd012f26e5f05e31de1189ca804" translate="yes" xml:space="preserve">
          <source>Ignore it until you need it.</source>
          <target state="translated">忽略它,直到你需要它为止。</target>
        </trans-unit>
        <trans-unit id="810e4fa4821d4188cefc7672710f24bed2a3c1d5" translate="yes" xml:space="preserve">
          <source>Imperative</source>
          <target state="translated">Imperative</target>
        </trans-unit>
        <trans-unit id="583ae6d68b9b829162aa0ace11f35929d9bb4712" translate="yes" xml:space="preserve">
          <source>In Java you can use a &lt;code&gt;for&lt;/code&gt; loop to traverse objects in an array as follows:</source>
          <target state="translated">在Java中，可以使用 &lt;code&gt;for&lt;/code&gt; 循环遍历数组中的对象，如下所示：</target>
        </trans-unit>
        <trans-unit id="f6d0674a47d5e4c6ee7188e8d56862dcbd6ae33a" translate="yes" xml:space="preserve">
          <source>In JavaScript any custom property could be assigned to any object, including an array.</source>
          <target state="translated">在JavaScript中,任何自定义属性都可以被分配给任何对象,包括数组。</target>
        </trans-unit>
        <trans-unit id="ee17c9f5432f037f208458ad5d51fc6145640287" translate="yes" xml:space="preserve">
          <source>In JavaScript it's not advisable to loop through an Array with a for-in loop, but it's better to use a &lt;code&gt;for&lt;/code&gt; loop such as:</source>
          <target state="translated">在JavaScript中，不建议使用for-in循环遍历数组，但最好使用 &lt;code&gt;for&lt;/code&gt; 循环，例如：</target>
        </trans-unit>
        <trans-unit id="1affd76d51cbc1ab4da5924b815463734ac0f427" translate="yes" xml:space="preserve">
          <source>In JavaScript, there are so many solutions to loop an array.</source>
          <target state="translated">在JavaScript中,有那么多的解决方案可以循环数组。</target>
        </trans-unit>
        <trans-unit id="509626629442545fa142bc6b90e393ef90bfd1d2" translate="yes" xml:space="preserve">
          <source>In JavaScript, you can also do this:</source>
          <target state="translated">在JavaScript中,你也可以这样做。</target>
        </trans-unit>
        <trans-unit id="bc5977a0c215f5a97db26f12ccd984993cb76e07" translate="yes" xml:space="preserve">
          <source>In a browser console, you can see something like &quot;element1&quot;, &quot;element2&quot;, etc., printed.</source>
          <target state="translated">在浏览器的控制台中,可以看到打印出类似 &quot;元素1&quot;、&quot;元素2 &quot;等内容。</target>
        </trans-unit>
        <trans-unit id="f8cdbcc1ec9b2f241eea1c7f52b02c03840b2a13" translate="yes" xml:space="preserve">
          <source>In general &lt;code&gt;func&lt;/code&gt; would take one parameter, which is an item of the array. But in the case of JavaScript, it can take a second parameter which is the item's index, and a third parameter which is the array itself.</source>
          <target state="translated">通常， &lt;code&gt;func&lt;/code&gt; 将采用一个参数，该参数是数组的一项。 但是对于JavaScript，它可以采用第二个参数（即项目的索引）和第三个参数（即数组本身）。</target>
        </trans-unit>
        <trans-unit id="fd0e1873da03f1238cdcd8d46e69b571337886d4" translate="yes" xml:space="preserve">
          <source>In the above example, the &lt;code&gt;hasOwnProperty&lt;/code&gt; method allows you to enumerate only &lt;em&gt;own properties&lt;/em&gt;, that's it, only the properties that the object physically has, no inherited properties.</source>
          <target state="translated">在上面的示例中， &lt;code&gt;hasOwnProperty&lt;/code&gt; 方法允许您仅枚举&lt;em&gt;自己的属性&lt;/em&gt; ，仅枚举对象物理上具有&lt;em&gt;的属性&lt;/em&gt; ，而不能枚举任何继承的属性。</target>
        </trans-unit>
        <trans-unit id="731f9b52cf3864b4e845afc26f5823a015b6f718" translate="yes" xml:space="preserve">
          <source>Inherited properties are also enumerated.</source>
          <target state="translated">继承属性也被列举了出来。</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="6371b79462d66a07f6e9b72523ff8fb46bd76993" translate="yes" xml:space="preserve">
          <source>It also means you'll never have to write a for loop again.</source>
          <target state="translated">这也意味着你再也不用写一个for循环了。</target>
        </trans-unit>
        <trans-unit id="4d5482c75593dd4638959de0178a2d6ee6f654e4" translate="yes" xml:space="preserve">
          <source>It also works on Node (I tested it on version 0.12.0).</source>
          <target state="translated">它也可以在Node上工作(我在0.12.0版本上测试过)。</target>
        </trans-unit>
        <trans-unit id="c7afdd2fab1fe4c50035aa8b7a97f2ca3d7a8fe9" translate="yes" xml:space="preserve">
          <source>It can iterate over a large variety of objects.</source>
          <target state="translated">它可以对大量的对象进行迭代。</target>
        </trans-unit>
        <trans-unit id="f5e0298a8f63b40bf1dbd95d72b4565988c2bb43" translate="yes" xml:space="preserve">
          <source>It currently works with Firefox 13+, Chrome 37+ and it does not natively work with other browsers (see browser compatibility below). Luckily we have JS compilers (such as &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;) that allow us to use next-generation features today.</source>
          <target state="translated">目前，它可与Firefox 13 +，Chrome 37+一起使用，并且本身无法与其他浏览器一起使用（请参阅下面的浏览器兼容性）。 幸运的是，我们拥有JS编译器（例如&lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt; ），它们使我们今天可以使用下一代功能。</target>
        </trans-unit>
        <trans-unit id="b7f1e474a3cbb522e7737b4c41a0e6c6aa40d314" translate="yes" xml:space="preserve">
          <source>It shouldn't be used for array-like objects because:</source>
          <target state="translated">它不应该被用于类似数组的对象,因为。</target>
        </trans-unit>
        <trans-unit id="618aee3ec871071cafa5f2c415e6c3ad428f6c63" translate="yes" xml:space="preserve">
          <source>It works like this:</source>
          <target state="translated">它的工作原理是这样的。</target>
        </trans-unit>
        <trans-unit id="729fd72bc10f5b53441cfd34a43c99d234bed82b" translate="yes" xml:space="preserve">
          <source>It's not 100% identical, but similar:</source>
          <target state="translated">虽然不是百分百相同,但也差不多。</target>
        </trans-unit>
        <trans-unit id="d2c98a7efcec06920db9cb117bd433708798538f" translate="yes" xml:space="preserve">
          <source>It's optimized as well (&quot;caching&quot; the array length). If you'd like to learn more, &lt;a href=&quot;http://blog.sebarmeli.com/2010/12/06/best-way-to-loop-through-an-array-in-javascript/&quot;&gt;read my post on the subject&lt;/a&gt;.</source>
          <target state="translated">它还进行了优化（&amp;ldquo;缓存&amp;rdquo;阵列长度）。 如果您想了解更多信息，请&lt;a href=&quot;http://blog.sebarmeli.com/2010/12/06/best-way-to-loop-through-an-array-in-javascript/&quot;&gt;阅读我关于该主题的文章&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="46a98fc5f1adbc9ced665ed928468799beb685aa" translate="yes" xml:space="preserve">
          <source>It's short to write</source>
          <target state="translated">写的时候很短</target>
        </trans-unit>
        <trans-unit id="b67411757f4baa65933449ae3c433b43e33a3bec" translate="yes" xml:space="preserve">
          <source>Keep in mind if you are iterating an array &lt;em&gt;to build another array from it&lt;/em&gt;, you should use &lt;code&gt;map&lt;/code&gt;, I've seen this anti-pattern so many times.</source>
          <target state="translated">请记住，如果要迭代一个数组&lt;em&gt;以从中构建另一个数组&lt;/em&gt; ，则应使用 &lt;code&gt;map&lt;/code&gt; ，我已经看过很多次了这种反模式。</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="a3c5490fc48c1e07b7f4efa147aa56f508ce53b0" translate="yes" xml:space="preserve">
          <source>Like traditional &lt;code&gt;for&lt;/code&gt; loops, &lt;code&gt;while&lt;/code&gt; loops are supported by even the oldest of browsers.</source>
          <target state="translated">像传统的 &lt;code&gt;for&lt;/code&gt; 循环一样，即使最旧的浏览器也支持 &lt;code&gt;while&lt;/code&gt; 循环。</target>
        </trans-unit>
        <trans-unit id="cead623be3ff7a811535895bde64a1c14f83edd4" translate="yes" xml:space="preserve">
          <source>Loop through an array in JavaScript</source>
          <target state="translated">在JavaScript中循环浏览一个数组</target>
        </trans-unit>
        <trans-unit id="43395e0915b2f80810ff1d9bf284e72478f3a7d9" translate="yes" xml:space="preserve">
          <source>Modern browsers all support iterator methods &lt;code&gt;forEach&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt; and a host of other methods on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array?redirectlocale=en-US&amp;amp;redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray&quot;&gt;Array prototype&lt;/a&gt;.</source>
          <target state="translated">现代浏览器均支持&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array?redirectlocale=en-US&amp;amp;redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray&quot;&gt;Array原型&lt;/a&gt;上的迭代器方法，分别用于迭代， &lt;code&gt;map&lt;/code&gt; ，化 &lt;code&gt;forEach&lt;/code&gt; ， &lt;code&gt;filter&lt;/code&gt; 和其他许多方法。</target>
        </trans-unit>
        <trans-unit id="413b0f0902d335e117f52bb6f630c916500b39e6" translate="yes" xml:space="preserve">
          <source>Most other answers are right, but they do not mention (as of this writing) that &lt;strong&gt;&lt;em&gt;ECMA Script &lt;strike&gt;&amp;nbsp;6&amp;nbsp;&lt;/strike&gt; 2015&lt;/em&gt;&lt;/strong&gt; is bringing a new mechanism for doing iteration, the &lt;strong&gt;&lt;code&gt;for..of&lt;/code&gt;&lt;/strong&gt; loop.</source>
          <target state="translated">大多数其他答案都是正确的，但是（在撰写本文时）它们并未提到&lt;strong&gt;&lt;em&gt;ECMA Script &lt;strike&gt;6&lt;/strike&gt; 2015&lt;/em&gt;&lt;/strong&gt;带来了一种进行迭代的新机制，即&lt;strong&gt; &lt;code&gt;for..of&lt;/code&gt; &lt;/strong&gt;循环。</target>
        </trans-unit>
        <trans-unit id="5aa5faa92650187f67128950cd34998418f5d033" translate="yes" xml:space="preserve">
          <source>Mozilla Labs published the algorithms they and &lt;a href=&quot;http://en.wikipedia.org/wiki/WebKit&quot;&gt;WebKit&lt;/a&gt; both use, so that you can add them yourself.</source>
          <target state="translated">Mozilla Labs发布了它们和&lt;a href=&quot;http://en.wikipedia.org/wiki/WebKit&quot;&gt;WebKit&lt;/a&gt;都使用的算法，因此您可以自己添加它们。</target>
        </trans-unit>
        <trans-unit id="6bbeedb096ad8a164494e42f681d03f151eee20a" translate="yes" xml:space="preserve">
          <source>No need to access (let alone cache) the length property</source>
          <target state="translated">不需要访问(更不用说缓存)长度属性了</target>
        </trans-unit>
        <trans-unit id="b43994d34a5fafb7a2888982d67dca097a47a6e9" translate="yes" xml:space="preserve">
          <source>Normally, you can replace the need to &lt;code&gt;break&lt;/code&gt; out of imperative loops by filtering the array elements before iterating them, for example:</source>
          <target state="translated">通常，您可以通过在迭代数组元素之前对其进行过滤来替换 &lt;code&gt;break&lt;/code&gt; 命令式循环的需要，例如：</target>
        </trans-unit>
        <trans-unit id="2db2fe69d40d3ac34eb0e35f52345d0c2815a956" translate="yes" xml:space="preserve">
          <source>Note that each of these variations is supported by all browsers, including very very old ones!</source>
          <target state="translated">请注意,所有的浏览器都支持这些变化,包括非常老的浏览器!</target>
        </trans-unit>
        <trans-unit id="6c66070e97cce40670c4441191c44bf18838f842" translate="yes" xml:space="preserve">
          <source>Note: Array.prototype.forEach() is not a functional way strictly speaking, as the function it takes as the input parameter is not supposed to return a value, which thus cannot be regarded as a pure function.</source>
          <target state="translated">注意:Array.prototype.forEach()严格来说并不是一种函数的方式,因为它作为输入参数的函数不应该是返回一个值,因此不能被视为纯函数。</target>
        </trans-unit>
        <trans-unit id="48c966f09aa17b29b9fe064c727a02146da0e40e" translate="yes" xml:space="preserve">
          <source>Note: The filter() method creates a new array with all elements that pass the test implemented by the provided function.</source>
          <target state="translated">注意:filter()方法创建一个新的数组,其中包含所有通过所提供函数实现的测试的元素。</target>
        </trans-unit>
        <trans-unit id="f1ea81216c8103826ec20066099e66d7123126d6" translate="yes" xml:space="preserve">
          <source>Note: The map() method creates a new array with the results of calling a provided function on every element in the calling array.</source>
          <target state="translated">注意:map()方法创建了一个新的数组,在调用数组中的每一个元素上调用提供的函数的结果。</target>
        </trans-unit>
        <trans-unit id="8bd4bead091ec61c5177a79b36d340f39f2358e7" translate="yes" xml:space="preserve">
          <source>Object loop:</source>
          <target state="translated">对象循环。</target>
        </trans-unit>
        <trans-unit id="56974c9d7b50d25064ed413fbfe2b4b0f72cd469" translate="yes" xml:space="preserve">
          <source>Of course, some developers have no choice but to use a different approach anyway, because for whatever reason they're targeting a version of JavaScript that doesn't yet support &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt;.</source>
          <target state="translated">当然，有些开发人员别无选择，只能使用其他方法，因为无论出于何种原因，他们都针对的是尚不支持... &lt;code&gt;of&lt;/code&gt; 的JavaScript版本。</target>
        </trans-unit>
        <trans-unit id="6f7be3080abd7fd806f8e09c93803d1cd5f9c625" translate="yes" xml:space="preserve">
          <source>Of course, you will need to include an &lt;code&gt;if(condition === true) { break; }&lt;/code&gt;  or an &lt;code&gt;if(condition === true) { return; }&lt;/code&gt; somewhere inside that &lt;code&gt;for&lt;/code&gt;-loop to get it to stop running.</source>
          <target state="translated">当然，您将需要包含 &lt;code&gt;if(condition === true) { break; }&lt;/code&gt; }或 &lt;code&gt;if(condition === true) { return; }&lt;/code&gt; 在-loop内的某个地方使其停止运行。</target>
        </trans-unit>
        <trans-unit id="f2fe9d42eb2f2a746517eaff1ec734422f1cc4c5" translate="yes" xml:space="preserve">
          <source>One advantage of this approach is that you can choose how to handle sparse arrays; the above code will run the body of the loop the full &lt;code&gt;length&lt;/code&gt; times, with &lt;code&gt;s&lt;/code&gt; set to &lt;code&gt;undefined&lt;/code&gt; for any missing elements, just like &lt;code&gt;for&lt;/code&gt;..&lt;code&gt;of&lt;/code&gt;. If you instead want to handle only the actually-present elements of a sparse array, like &lt;code&gt;.forEach&lt;/code&gt;, you can add a simple &lt;code&gt;in&lt;/code&gt; test on the index:</source>
          <target state="translated">这种方法的一个优点是您可以选择如何处理稀疏数组。 上面的代码将在循环主体中运行整个时间，对于所有缺少的元素，将 &lt;code&gt;s&lt;/code&gt; 设置为 &lt;code&gt;undefined&lt;/code&gt; ，就像.. &lt;code&gt;of&lt;/code&gt; 一样 。 如果您只想处理稀疏数组的实际存在的元素（如 &lt;code&gt;.forEach&lt;/code&gt; ) ，则可以在索引上添加一个简单 &lt;code&gt;in&lt;/code&gt; test：</target>
        </trans-unit>
        <trans-unit id="53e75cdb29c5599821ebe5805040c469e93077fc" translate="yes" xml:space="preserve">
          <source>One alternative to a &lt;code&gt;for&lt;/code&gt; loop is a &lt;code&gt;while&lt;/code&gt; loop. To loop through an array, you could do this:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; 循环的一种替代方法是 &lt;code&gt;while&lt;/code&gt; 循环。 要遍历数组，可以执行以下操作：</target>
        </trans-unit>
        <trans-unit id="4b514468264056e4b37a5ab372a4a7f951732f97" translate="yes" xml:space="preserve">
          <source>One of the cornerstones of functional programming is its special use
  of lists and list operations. And those things are exactly what the
  sound like they are: arrays of things, and the stuff you do to them.
  But the functional mindset treats them a bit differently than you
  might expect.</source>
          <target state="translated">函数式编程的基石之一就是它对列表和列表操作的特殊使用。而这些东西听起来就像它们是什么:事物的数组,以及你对它们所做的事情。但是功能思维对待它们的方式和你想象中的有点不同。</target>
        </trans-unit>
        <trans-unit id="d921e30036a4651e6d150723a2bd7418fc2d461a" translate="yes" xml:space="preserve">
          <source>Opera, Safari, Firefox and Chrome now all share a set of enhanced Array methods for optimizing many common loops.</source>
          <target state="translated">Opera、Safari、Firefox和Chrome现在都共享一套增强的Array方法,用于优化许多常见的循环。</target>
        </trans-unit>
        <trans-unit id="ca8a7183a1dbcea77d8631814b5189f7eab564fd" translate="yes" xml:space="preserve">
          <source>Or &lt;code&gt;Array.prototype.map(...)&lt;/code&gt;:</source>
          <target state="translated">或 &lt;code&gt;Array.prototype.map(...)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="005deeedccad31f3cb0e80bfb7abb31fa65ed57a" translate="yes" xml:space="preserve">
          <source>Or better yet, since ECMAScript 2015 also provides block-scoped variables:</source>
          <target state="translated">或者更好的是,因为ECMAScript 2015还提供了块状变量。</target>
        </trans-unit>
        <trans-unit id="3b1a4912a2f639abf4e7d8c472de81016ac92f24" translate="yes" xml:space="preserve">
          <source>Or if you really want to get the id and have a really classical &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">或者，如果您真的想获取ID并具有一个经典的 &lt;code&gt;for&lt;/code&gt; 循环，请执行以下操作：</target>
        </trans-unit>
        <trans-unit id="79c19d1215e0ee61dae1d54feb9eb528038ad845" translate="yes" xml:space="preserve">
          <source>Or the classical &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">或经典的 &lt;code&gt;for&lt;/code&gt; 循环</target>
        </trans-unit>
        <trans-unit id="32ccf4631124f74fd174f7f90959d3e3a755fb56" translate="yes" xml:space="preserve">
          <source>Or the jquery or for loop ways previously mentioned.</source>
          <target state="translated">或者前面提到的jquery或者for循环的方式。</target>
        </trans-unit>
        <trans-unit id="6adbea7e0ac9ed37ed0deb0bb73dcd3e28cf819b" translate="yes" xml:space="preserve">
          <source>Or, if you prefer to loop backwards, you do this:</source>
          <target state="translated">或者,如果你喜欢倒着来,你可以这样做。</target>
        </trans-unit>
        <trans-unit id="ae203c504aa70b4f28a5fcf1b9fe9229ed76072b" translate="yes" xml:space="preserve">
          <source>Read more&amp;gt;&amp;gt; &lt;a href=&quot;https://code.tutsplus.com/tutorials/how-to-use-map-filter-reduce-in-javascript--cms-26209&quot;&gt;here&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://code.tutsplus.com/tutorials/how-to-use-map-filter-reduce-in-javascript--cms-26209&quot;&gt;在这里&lt;/a&gt;阅读更多&amp;gt;&amp;gt;：</target>
        </trans-unit>
        <trans-unit id="e609697c319d4d3a9d1b473f48e1e2bd07f35c6e" translate="yes" xml:space="preserve">
          <source>Reference:
&lt;a href=&quot;http://www.sitepoint.com/google-closure-how-not-to-write-javascript/&quot;&gt;http://www.sitepoint.com/google-closure-how-not-to-write-javascript/&lt;/a&gt;</source>
          <target state="translated">Reference:
&lt;a href=&quot;http://www.sitepoint.com/google-closure-how-not-to-write-javascript/&quot;&gt;http://www.sitepoint.com/google-closure-how-not-to-write-javascript/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="335e1e090424cc3a93596596d66cb2973f851a68" translate="yes" xml:space="preserve">
          <source>See this JsFiddle demonstrating that: &lt;a href=&quot;http://jsfiddle.net/prvzk/&quot;&gt;http://jsfiddle.net/prvzk/&lt;/a&gt;</source>
          <target state="translated">请参阅此JsFiddle演示： &lt;a href=&quot;http://jsfiddle.net/prvzk/&quot;&gt;http&lt;/a&gt; : //jsfiddle.net/prvzk/</target>
        </trans-unit>
        <trans-unit id="a5dda3b31ff4955adf83bd52382ef45bc3ffb11e" translate="yes" xml:space="preserve">
          <source>Short answer: yes. You can do with this:</source>
          <target state="translated">简答:是的。你可以用这个做。</target>
        </trans-unit>
        <trans-unit id="548e1e621f5c9ad33722194d1a9b4a9c024a7f02" translate="yes" xml:space="preserve">
          <source>Since my time in college, I've programmed in Java, JavaScript, Pascal, &lt;a href=&quot;https://en.wikipedia.org/wiki/ABAP&quot;&gt;ABAP&lt;/a&gt;, PHP, Progress 4GL, C/C++ and possibly a few other languages I can't think of right now.</source>
          <target state="translated">自从我上大学以来，我就使用Java，JavaScript，Pascal， &lt;a href=&quot;https://en.wikipedia.org/wiki/ABAP&quot;&gt;ABAP&lt;/a&gt; ，PHP，Progress 4GL，C / C ++以及其他一些我现在无法想到的语言进行编程。</target>
        </trans-unit>
        <trans-unit id="b22093b0b2c9e3acc2f551744f9b589053dde63a" translate="yes" xml:space="preserve">
          <source>So as others has suggested, this is almost always what you want:</source>
          <target state="translated">所以,正如其他人建议的那样,这几乎都是你想要的。</target>
        </trans-unit>
        <trans-unit id="47218d7f66b567477c470edc472c6fd416fbed47" translate="yes" xml:space="preserve">
          <source>Some use cases of looping through an array in &lt;strong&gt;the functional programming way&lt;/strong&gt; in JavaScript:</source>
          <target state="translated">在JavaScript中&lt;strong&gt;以函数式编程方式&lt;/strong&gt;遍历数组的一些用例：</target>
        </trans-unit>
        <trans-unit id="432979a6e491e22397882fad2d457b66217225b1" translate="yes" xml:space="preserve">
          <source>Spread syntax</source>
          <target state="translated">传播语法</target>
        </trans-unit>
        <trans-unit id="df9af125634fddcfa421be704540115f6f1acfd0" translate="yes" xml:space="preserve">
          <source>That be particularly a problem if you use some library that relies heavily on native prototypes augmentation (such as MooTools, for example).</source>
          <target state="translated">如果你使用一些严重依赖原生原型增强的库(例如MooTools),这将是一个特别的问题。</target>
        </trans-unit>
        <trans-unit id="54be33a5edebe447d19ad8769464cdbc36772505" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.each()&lt;/code&gt; function is not the same as &lt;code&gt;$(selector).each()&lt;/code&gt;, which is
  used to iterate, exclusively, over a jQuery object. The &lt;code&gt;$.each()&lt;/code&gt;
  function can be used to iterate over any collection, whether it is a
  map (JavaScript object) or an array. In the case of an array, the
  callback is passed an array index and a corresponding array value each
  time. (The value can also be accessed through the &lt;code&gt;this&lt;/code&gt; keyword, but
  Javascript will always wrap the &lt;code&gt;this&lt;/code&gt; value as an &lt;code&gt;Object&lt;/code&gt; even if it is
  a simple string or number value.) The method returns its first
  argument, the object that was iterated.</source>
          <target state="translated">&lt;code&gt;$.each()&lt;/code&gt; 函数与 &lt;code&gt;$(selector).each()&lt;/code&gt; 不同 ，后者仅用于遍历jQuery对象。 &lt;code&gt;$.each()&lt;/code&gt; 函数可用于遍历任何集合，无论它是映射（JavaScript对象）还是数组。 对于数组，每次回调都会传递一个数组索引和一个对应的数组值。 （也可以通过 &lt;code&gt;this&lt;/code&gt; 关键字访问该值，但是Javascript总是将 &lt;code&gt;this&lt;/code&gt; 值包装为 &lt;code&gt;Object&lt;/code&gt; ,即使它是简单的字符串或数字值也是如此。）该方法返回其第一个参数，即被迭代的对象。</target>
        </trans-unit>
        <trans-unit id="8ea2d26897d80b2a11e7991048566fdf9f71aa64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; and the &lt;code&gt;Array.prototype.map()&lt;/code&gt; methods are the slowest approximations, probably as a consequence of the &lt;strong&gt;function call overhead&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;Array.prototype.forEach()&lt;/code&gt; 和 &lt;code&gt;Array.prototype.map()&lt;/code&gt; 方法是最慢的近似值，可能是由于&lt;strong&gt;函数调用的开销&lt;/strong&gt;造成的。</target>
        </trans-unit>
        <trans-unit id="fda48303e825923d88d3e1a5954e2f9a8d32ffe0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-in&lt;/code&gt; statement as I said before is there to &lt;em&gt;enumerate&lt;/em&gt; object properties, for example:</source>
          <target state="translated">我之前说过的 &lt;code&gt;for-in&lt;/code&gt; 语句用于&lt;em&gt;枚举&lt;/em&gt;对象属性，例如：</target>
        </trans-unit>
        <trans-unit id="152a30a782355db0c98586aa6609e918220ba9f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; syntax mentioned by others is for looping over an object's properties; since an Array in JavaScript is just an object with numeric property names (and an automatically-updated &lt;code&gt;length&lt;/code&gt; property), you can theoretically loop over an Array with it.  But the problem is that it doesn't restrict itself to the numeric property values (remember that even methods are actually just properties whose value is a closure), nor is it guaranteed to iterate over those in numeric order. Therefore, the &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; syntax should &lt;em&gt;not&lt;/em&gt; be used for looping through Arrays.</source>
          <target state="translated">其他人提到的 &lt;code&gt;for&lt;/code&gt; ... &lt;code&gt;in&lt;/code&gt; 语法用于循环对象的属性； 由于JavaScript中的Array只是具有数字属性名称（和自动更新的 &lt;code&gt;length&lt;/code&gt; 属性）的对象，因此理论上可以使用它遍历Array。 但是问题在于，它不会将自身限制为数字属性值（请记住，即使方法实际上只是其值是闭包的属性），也不能保证以数字顺序遍历那些属性。 因此， &lt;code&gt;for&lt;/code&gt; ... &lt;code&gt;in&lt;/code&gt; 语法&lt;em&gt;不&lt;/em&gt;应用于遍历数组。</target>
        </trans-unit>
        <trans-unit id="a23f5eb2e341872f8d38000e5c4b5bc2354d1e00" translate="yes" xml:space="preserve">
          <source>The Array.prototype.find() method returns the value of the first element in the array that satisfies the provided testing function.</source>
          <target state="translated">Array.prototype.find()方法返回数组中满足所提供的测试函数的第一个元素的值。</target>
        </trans-unit>
        <trans-unit id="9449fcbdbeae06e7e3bf08650fe52c6575a5e23e" translate="yes" xml:space="preserve">
          <source>The ES5 specification introduced a lot of beneficial array methods, one of them, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;Array.prototype.forEach&lt;/code&gt;&lt;/a&gt; and it gives us a concise way to iterate over an array:</source>
          <target state="translated">ES5规范引入了许多有益的数组方法，其中之一是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;Array.prototype.forEach&lt;/code&gt; &lt;/a&gt; ，它为我们提供了一种遍历数组的简洁方法：</target>
        </trans-unit>
        <trans-unit id="7a8e9910c4deb87c8767f0cacf582f5a16708e6e" translate="yes" xml:space="preserve">
          <source>The ES6 standard introduces the concept of iterable objects and defines a new construct for traversing data, the &lt;code&gt;for...of&lt;/code&gt; statement.</source>
          <target state="translated">ES6标准引入了可迭代对象的概念，并定义了用于遍历数据的新构造，即 &lt;code&gt;for...of&lt;/code&gt; 语句。</target>
        </trans-unit>
        <trans-unit id="1460f02e0a3102d7e55e91533998fc51f18928be" translate="yes" xml:space="preserve">
          <source>The above code will console log &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, and &quot;foo!&quot;.</source>
          <target state="translated">上面的代码将控制台记录 &quot;a&quot;、&quot;b&quot;、&quot;c &quot;和 &quot;foo!&quot;。</target>
        </trans-unit>
        <trans-unit id="20e7432fb4c054b1e1c467a38410fe6525f14155" translate="yes" xml:space="preserve">
          <source>The best way in my opinion is to use the Array.forEach function. If you cannot use that I would suggest to get the polyfill from MDN. To make it available, it is certainly the safest way to iterate over an array in JavaScript.</source>
          <target state="translated">在我看来最好的方法是使用Array.forEach函数。如果你不能使用,我建议你从MDN中获取polyfill。要让它可用,这无疑是在JavaScript中迭代数组的最安全的方法。</target>
        </trans-unit>
        <trans-unit id="e56ca3c4eed21e096e43d29badb2c6a655f1f880" translate="yes" xml:space="preserve">
          <source>The code below are popular ones</source>
          <target state="translated">下面的代码是常用的</target>
        </trans-unit>
        <trans-unit id="120e5e39e34ca15870d8e9947bbcca2f43399e04" translate="yes" xml:space="preserve">
          <source>The explicit counting loop also means you have access to the index of each value, should you want it. The index is also passed as an extra parameter to the function you pass to &lt;code&gt;forEach&lt;/code&gt;, so you can access it that way as well:</source>
          <target state="translated">显式计数循环还意味着您可以访问每个值的索引（如果需要）。 索引也作为附加参数传递给传递给 &lt;code&gt;forEach&lt;/code&gt; 的函数，因此您也可以通过以下方式访问它：</target>
        </trans-unit>
        <trans-unit id="0926024be90fc3c5c58f79ca38b539c92713c68c" translate="yes" xml:space="preserve">
          <source>The final option, which works in &lt;em&gt;all&lt;/em&gt; versions of JavaScript, is &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-for-statement&quot;&gt;an explicit counting loop&lt;/a&gt;. You simply count from 0 up to one less than the length and use the counter as an index. The basic loop looks like this:</source>
          <target state="translated">在&lt;em&gt;所有&lt;/em&gt; JavaScript版本中&lt;em&gt;都&lt;/em&gt;可以使用的最后一个选项是&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-for-statement&quot;&gt;显式计数循环&lt;/a&gt; 。 您只需从0到小于长度的1进行计数，然后将计数器用作索引。 基本循环如下所示：</target>
        </trans-unit>
        <trans-unit id="60de89b60699f6e1c50c9980fe4030ebfed381c1" translate="yes" xml:space="preserve">
          <source>The general syntax is:</source>
          <target state="translated">一般的语法是:</target>
        </trans-unit>
        <trans-unit id="17c0c8958009504035837eb96e313e38d6db28cb" translate="yes" xml:space="preserve">
          <source>The item to access is automatically defined within the loop
body under the name you pick.</source>
          <target state="translated">要访问的项目会在你选择的名称下的循环体中自动定义。</target>
        </trans-unit>
        <trans-unit id="cc1a1ebcb7c44366d847d9e53142c469f5d9c912" translate="yes" xml:space="preserve">
          <source>The most elegant and fast way</source>
          <target state="translated">最优雅、最快捷的方式</target>
        </trans-unit>
        <trans-unit id="92bc9c3030690e8975c93e43b9783b47f78cf220" translate="yes" xml:space="preserve">
          <source>The optimized approach is to cache the length of array and using single var pattern initializing all variables with single var keyword.</source>
          <target state="translated">优化的方法是缓存数组的长度,用单变量模式初始化所有的变量,用单变量关键字初始化。</target>
        </trans-unit>
        <trans-unit id="2c0c58f394bd4d6864165f51bcf38373ab49434a" translate="yes" xml:space="preserve">
          <source>The order of iteration is not guaranteed; the array indexes may not be visited in numeric order.</source>
          <target state="translated">迭代的顺序不能保证;数组索引可能不会按数字顺序访问。</target>
        </trans-unit>
        <trans-unit id="012e8483413b382c220340edf31b6450777efdd6" translate="yes" xml:space="preserve">
          <source>The reason this works is that the array specification mandates that when you read an item from an index &amp;gt;= the array's length, it will return undefined. When you write to such a location it will actually update the length.</source>
          <target state="translated">之所以起作用，是因为数组规范要求当您从索引&amp;gt; =数组长度读取项目时，它将返回未定义。 当您写入此类位置时，它实际上会更新长度。</target>
        </trans-unit>
        <trans-unit id="ef3a7c0b59ad4734159dbd0581cc34ca59a58ff9" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;array.map&lt;/code&gt; is another array, so you can use it like this:</source>
          <target state="translated">&lt;code&gt;array.map&lt;/code&gt; 的返回值是另一个数组，因此您可以像这样使用它：</target>
        </trans-unit>
        <trans-unit id="b97bcfaafee942ef6523ce737efbb4b975437cc7" translate="yes" xml:space="preserve">
          <source>The second point is that it can give you a lot of problems, for example, if you extend the &lt;code&gt;Array.prototype&lt;/code&gt; object to include a method there, that property will also be enumerated.</source>
          <target state="translated">第二点是它会给您带来很多问题，例如，如果您扩展 &lt;code&gt;Array.prototype&lt;/code&gt; 对象以在其中包含一个方法，那么该属性也会被枚举。</target>
        </trans-unit>
        <trans-unit id="2f3b6cf1d6f0a6bbd74a70887a856a51c87bff3f" translate="yes" xml:space="preserve">
          <source>The traditional &lt;code&gt;for()&lt;/code&gt; iterator, is by far the fastest method, especially when used with the &lt;strong&gt;array length cached&lt;/strong&gt;.</source>
          <target state="translated">到目前为止，传统的 &lt;code&gt;for()&lt;/code&gt; 迭代器是最快的方法，尤其是与&lt;strong&gt;数组长度cached一起使用时&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="50fbe4e2839ad6f44353c11db5662956a1245813" translate="yes" xml:space="preserve">
          <source>The traditional way to loop through an array, is this:</source>
          <target state="translated">传统的循环通过数组的方法是这样的。</target>
        </trans-unit>
        <trans-unit id="bb52b2247ddc21d02d48c2330829d7a1e4b3b066" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to do it in JavaScript. The first two examples are JavaScript samples. The third one makes use of a JavaScript library, that is, jQuery making use of the &lt;code&gt;.each()&lt;/code&gt; function.</source>
          <target state="translated">在JavaScript中有两种方法可以做到这一点。 前两个示例是JavaScript示例。 第三个使用JavaScript库，即jQuery使用 &lt;code&gt;.each()&lt;/code&gt; 函数。</target>
        </trans-unit>
        <trans-unit id="821b43d0758dd02be5cc2c03df6009934ba6b2d6" translate="yes" xml:space="preserve">
          <source>There are even some times when you ought to iterate in reverse, such as when iterating over a &lt;a href=&quot;https://developer.mozilla.org/En/DOM/NodeList#A_.22live.22_collection&quot;&gt;live NodeList&lt;/a&gt; where you plan on removing items from the DOM during iteration.</source>
          <target state="translated">有时甚至需要反向迭代，例如在&lt;a href=&quot;https://developer.mozilla.org/En/DOM/NodeList#A_.22live.22_collection&quot;&gt;活动的NodeList&lt;/a&gt;上迭代时，您计划在迭代过程中从DOM中删除项目。</target>
        </trans-unit>
        <trans-unit id="42b051646813473214bb6d4ec6b04940890f97b1" translate="yes" xml:space="preserve">
          <source>There are various way to loop through array in JavaScript.</source>
          <target state="translated">在JavaScript中,有多种方法可以通过数组循环。</target>
        </trans-unit>
        <trans-unit id="9a2a3b9ff7b68f4ca1407027573f3d1e36d2a264" translate="yes" xml:space="preserve">
          <source>There are, however, many variations possible, like for example this one:</source>
          <target state="translated">不过,可能有很多变化,比如说像这样的变化。</target>
        </trans-unit>
        <trans-unit id="3b17947ce13f291d24a94bf37cd447dbd1a3770b" translate="yes" xml:space="preserve">
          <source>There is a way to do it where you have very little implicit scope in your loop and do away with extra variables.</source>
          <target state="translated">有一种方法可以做到这一点,在你的循环中,你的隐含范围很小,可以去掉额外的变量。</target>
        </trans-unit>
        <trans-unit id="9a66ce7f5fe432814094ad577cba1eca94e88388" translate="yes" xml:space="preserve">
          <source>There's a method to iterate over only own object properties, not including prototype's ones:</source>
          <target state="translated">有一个方法可以只迭代自己的对象属性,不包括prototype的属性。</target>
        </trans-unit>
        <trans-unit id="3d2f0aa297c7272c064273bd7ad8226e3a64443e" translate="yes" xml:space="preserve">
          <source>These are the main ways to do JavaScript loops, but there are a few more ways to do that.</source>
          <target state="translated">这些是做JavaScript循环的主要方法,但还有一些其他的方法。</target>
        </trans-unit>
        <trans-unit id="a685720d851d92a20d19c2df920471064cf168c9" translate="yes" xml:space="preserve">
          <source>These are the solutions:</source>
          <target state="translated">这些都是解决办法。</target>
        </trans-unit>
        <trans-unit id="71b65affe9fa82e82de8abd8e0d75c26d06af598" translate="yes" xml:space="preserve">
          <source>These methods all take a function for their first argument and have an optional second argument, which is an object whose scope you want to impose on the array members as they loop through the function.</source>
          <target state="translated">这些方法的第一个参数都是一个函数,并有一个可选的第二个参数,这个参数是一个对象,当数组成员在函数中循环时,你想把它的作用域强加到数组成员上。</target>
        </trans-unit>
        <trans-unit id="80ad30aab31c43f396831f915032145053204ac5" translate="yes" xml:space="preserve">
          <source>These three components are separated from each other by a &lt;code&gt;;&lt;/code&gt; symbol. Content for each of these three components is optional, which means that the following is the most minimal &lt;code&gt;for&lt;/code&gt; loop possible:</source>
          <target state="translated">这三个组成部分用分隔 &lt;code&gt;;&lt;/code&gt; 符号。 这三个组件中的每个组件的内容都是可选的，这意味着以下内容是可能的最少的 &lt;code&gt;for&lt;/code&gt; 循环：</target>
        </trans-unit>
        <trans-unit id="f566944d88f81152109f1bbf9e52d01bb54137da" translate="yes" xml:space="preserve">
          <source>This article will take a close look at what I like to call the &quot;big
  three&quot; list operations: map, filter, and reduce. Wrapping your head
  around these three functions is an important step towards being able
  to write clean functional code, and opens the doors to the vastly
  powerful techniques of functional and reactive programming.</source>
          <target state="translated">这篇文章将仔细研究一下我所喜欢的 &quot;三大 &quot;列表操作:map、filter和reduce。围绕着这三个函数,你的头脑中就会有一个重要的步骤,那就是能够写出干净的函数代码,并为你打开了通往功能型和响应式编程的巨大的技术大门。</target>
        </trans-unit>
        <trans-unit id="6a07602d0b647fe22e2fcaac7f41bf7fd5c06746" translate="yes" xml:space="preserve">
          <source>This ensures that anything you need in the scope of processing the array stays within that scope, and that you are only processing the values of the array, not the object properties and other members, which is what &lt;code&gt;for ..&lt;/code&gt; in does.</source>
          <target state="translated">这样可以确保在处理数组范围内需要的所有内容都在该范围内，并且仅在处理数组的值时，而不在处理对象属性和其他成员，这就是 &lt;code&gt;for ..&lt;/code&gt; in的作用。</target>
        </trans-unit>
        <trans-unit id="858c7fa76e864ce71e5b610d49e037963d073b9e" translate="yes" xml:space="preserve">
          <source>This has the benefit of caching the length (similar to &lt;code&gt;for (var i=0, len=myArray.length; i&amp;lt;len; ++i)&lt;/code&gt; and unlike &lt;code&gt;for (var i=0; i&amp;lt;myArray.length; ++i)&lt;/code&gt;) while being fewer characters to type.</source>
          <target state="translated">这具有缓存长度的好处（类似于 &lt;code&gt;for (var i=0, len=myArray.length; i&amp;lt;len; ++i)&lt;/code&gt; 而不同于 &lt;code&gt;for (var i=0; i&amp;lt;myArray.length; ++i)&lt;/code&gt; ），同时输入的字符较少。</target>
        </trans-unit>
        <trans-unit id="190958324e44a9b320dec6a0655dbfd941bed1b5" translate="yes" xml:space="preserve">
          <source>This is a good article if you like to learn more about the asynchronous functions over arrays in JavaScript.</source>
          <target state="translated">如果你喜欢了解更多关于JavaScript中的数组上的异步函数,这是一篇不错的文章。</target>
        </trans-unit>
        <trans-unit id="147518e25e35d186bb4ca7645b5e7a356fd8dd30" translate="yes" xml:space="preserve">
          <source>This new syntax is the most elegant way to iterate an array in javascript (as long you don't need the iteration index), but it is not yet widely supported by the browsers.</source>
          <target state="translated">这种新的语法是javascript中迭代数组的最优雅的方式(只要你不需要迭代索引),但目前还没有被浏览器广泛支持。</target>
        </trans-unit>
        <trans-unit id="c7b121c2303f93e6b2a2d7db925a526f50850ae3" translate="yes" xml:space="preserve">
          <source>This only works for arrays that are &lt;em&gt;not&lt;/em&gt; sparse. Meaning that there actually is a value at each index in the array. However, I found that in practice I hardly ever use sparse arrays in JavaScript... In such cases it's usually a lot easier to use an object as a map/hashtable. If you do have a sparse array, and want to loop over 0 .. length-1, you need the for (var i=0; i&amp;lt;someArray.length; ++i) construct, but you still need an &lt;code&gt;if&lt;/code&gt; inside the loop to check whether the element at the current index is actually defined.</source>
          <target state="translated">这仅适用于&lt;em&gt;非&lt;/em&gt;稀疏数组。 这意味着在数组中的每个索引处实际上都有一个值。 但是，我发现在实践中我几乎从未在JavaScript中使用稀疏数组...在这种情况下，将对象用作地图/哈希表通常要容易得多。 如果您确实有一个稀疏数组，并且想循环遍历0 .. length-1，则需要for（var i = 0; i &amp;lt;someArray.length; ++ i）构造，但是您仍然需要在 &lt;code&gt;if&lt;/code&gt; 内部循环检查当前索引处的元素是否实际定义。</target>
        </trans-unit>
        <trans-unit id="0d1a92190b4273c4dedb4a6ff5c33b8b8e248e48" translate="yes" xml:space="preserve">
          <source>This should be used with care, however, as it doesn't behave the same as a traditional &lt;code&gt;for&lt;/code&gt; loop in all cases, and there are potential side-effects that need to be considered. See &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea&quot;&gt;Why is using &quot;for...in&quot; with array iteration a bad idea?&lt;/a&gt;&lt;/strong&gt; for more details.</source>
          <target state="translated">但是，应谨慎使用它，因为在所有情况下它的行为都与传统的 &lt;code&gt;for&lt;/code&gt; 循环不同，并且需要考虑潜在的副作用。 请参阅&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea&quot;&gt;为什么在数组迭代中使用&amp;ldquo; for ... in&amp;rdquo;是个坏主意？&lt;/a&gt;&lt;/strong&gt; 更多细节。</target>
        </trans-unit>
        <trans-unit id="472b9cc884c8efe330967ffcc40284ca272d82d6" translate="yes" xml:space="preserve">
          <source>This statement works for any kind of iterable object and also for generators (any object that has a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator&quot;&gt;&lt;code&gt;[Symbol.iterator]&lt;/code&gt;&lt;/a&gt; property).</source>
          <target state="translated">此语句适用于任何类型的可迭代对象，也适用于生成器（具有&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator&quot;&gt; &lt;code&gt;[Symbol.iterator]&lt;/code&gt; &lt;/a&gt;属性的任何对象）。</target>
        </trans-unit>
        <trans-unit id="ac9bb5e0ca9aef826594b177b1c57b42d63efd12" translate="yes" xml:space="preserve">
          <source>Too verbose</source>
          <target state="translated">太啰嗦了</target>
        </trans-unit>
        <trans-unit id="0e44efea277e112b800b020b7f1ce9f2e1b5bdd7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt;, &lt;code&gt;.forEach&lt;/code&gt; only calls the function for elements that are actually present in the array. If passed our hypothetical array with three elements and a length of 248, it will only call the function three times, not 248 times. It also distinguishes between missing elements and elements that are actually set to &lt;code&gt;undefined&lt;/code&gt;; for the latter, it will still call the function, passing &lt;code&gt;undefined&lt;/code&gt; as the argument. If this is how you want to handle sparse arrays, &lt;code&gt;.forEach&lt;/code&gt; may be the way to go even if your interpreter supports &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt;.</source>
          <target state="translated">与 &lt;code&gt;for&lt;/code&gt; ... &lt;code&gt;of&lt;/code&gt; 不同， &lt;code&gt;.forEach&lt;/code&gt; 仅调用数组中实际存在的元素的函数。 如果传递带有三个元素且长度为248的假设数组，它将仅调用该函数三次，而不是248次。 它还可以区分丢失的元素和实际上设置为 &lt;code&gt;undefined&lt;/code&gt; 的元素； 对于后者，它将仍然调用该函数，并传递 &lt;code&gt;undefined&lt;/code&gt; 作为参数。 如果这是您要处理稀疏数组的方式，那么即使您的解释器支持... &lt;code&gt;of&lt;/code&gt; 也可以使用 &lt;code&gt;.forEach&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fb5ad6ba3a246c28f628695455346d1d1358b358" translate="yes" xml:space="preserve">
          <source>Use the while loop...</source>
          <target state="translated">使用while循环.....</target>
        </trans-unit>
        <trans-unit id="acf02fdaa5e1a7884f09bb5330b18f85aa765a24" translate="yes" xml:space="preserve">
          <source>Useful to iterate serially asynchronous values.</source>
          <target state="translated">有助于异步串行迭代值的迭代。</target>
        </trans-unit>
        <trans-unit id="11f8f11632acf347b589a3d67d8c21511e0c9bf6" translate="yes" xml:space="preserve">
          <source>Using a regular C-style &lt;code&gt;for&lt;/code&gt; loop works in most cases. It is just important to remember that everything within the loop shares its scope with the rest of your program, the { } does not create a new scope.</source>
          <target state="translated">在大多数情况下，使用常规C样式 &lt;code&gt;for&lt;/code&gt; 循环是可行的。 重要的是要记住，循环中的所有内容都与程序的其余部分共享其作用域，{}不会创建新的作用域。</target>
        </trans-unit>
        <trans-unit id="6e8369a5a266e94f593d9eeea846e02aa77149e0" translate="yes" xml:space="preserve">
          <source>Using a traditional &lt;code&gt;for&lt;/code&gt; loop to loop through an array</source>
          <target state="translated">使用传统的 &lt;code&gt;for&lt;/code&gt; 循环遍历数组</target>
        </trans-unit>
        <trans-unit id="85df58774c5491ec2a1dff116625289a4b51fe96" translate="yes" xml:space="preserve">
          <source>Usually, though, the initialization is used to declare an index, the condition is used to compare that index with a minimum or maximum value, and the afterthought is used to increment the index:</source>
          <target state="translated">不过通常情况下,初始化是用来声明一个索引,条件是用来将该索引与最小值或最大值进行比较,而事后的作用是用来增加索引。</target>
        </trans-unit>
        <trans-unit id="38a3899f8605deb1a119719c4e634478608e868c" translate="yes" xml:space="preserve">
          <source>Very short and succinct.</source>
          <target state="translated">非常简短而简明扼要。</target>
        </trans-unit>
        <trans-unit id="c2806e463dca64608139609ed71eec7bf1af0fcd" translate="yes" xml:space="preserve">
          <source>What I like about this loop is:</source>
          <target state="translated">我喜欢的是:</target>
        </trans-unit>
        <trans-unit id="16ce81c4539b95557096d4ee3982368acb60bb76" translate="yes" xml:space="preserve">
          <source>Whichever works best is largely a matter of both personal taste and the specific use case you're implementing.</source>
          <target state="translated">无论哪种方法最有效,主要取决于个人品味和你所实施的具体用例。</target>
        </trans-unit>
        <trans-unit id="3eaca1cb6c3a5c7b0653cdc5c205c5570f3bcd75" translate="yes" xml:space="preserve">
          <source>While they all have their own linguistic idiosyncrasies, each of these languages share many of the same basic concepts. Such concepts include procedures / functions, &lt;code&gt;IF&lt;/code&gt;-statements, &lt;code&gt;FOR&lt;/code&gt;-loops, and &lt;code&gt;WHILE&lt;/code&gt;-loops.</source>
          <target state="translated">尽管它们都有自己的语言特质，但每种语言都具有许多相同的基本概念。 这样的概念包括过程/函数， &lt;code&gt;IF&lt;/code&gt; 语句， &lt;code&gt;FOR&lt;/code&gt; 循环和 &lt;code&gt;WHILE&lt;/code&gt; 循环。</target>
        </trans-unit>
        <trans-unit id="8244adf2c17ba7cc3bdea8eada041642ab1c86cf" translate="yes" xml:space="preserve">
          <source>Works on every environment</source>
          <target state="translated">适用于各种环境</target>
        </trans-unit>
        <trans-unit id="a1b7a89f3b73a87140f7d4b8e01a03ed839c9203" translate="yes" xml:space="preserve">
          <source>Yes, assuming your implementation includes the &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements&quot;&gt;&lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt;&lt;/a&gt; feature introduced in &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt; (the &quot;Harmony&quot; release)... which is a pretty safe assumption these days.</source>
          <target state="translated">是的，假设您的实现包括&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt; （&amp;ldquo; Harmony&amp;rdquo;版本）中引入的&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements&quot;&gt; &lt;code&gt;for&lt;/code&gt; ...&lt;/a&gt;功能...这是一个非常安全的假设。</target>
        </trans-unit>
        <trans-unit id="65c39770604a63372cf38469a45e9aad0b608cfa" translate="yes" xml:space="preserve">
          <source>You can either use &lt;code&gt;Array.prototype.forEach(...)&lt;/code&gt;:</source>
          <target state="translated">您可以使用 &lt;code&gt;Array.prototype.forEach(...)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="55d53dbec6820aa52a0e39445d08dc7a9bac4eb5" translate="yes" xml:space="preserve">
          <source>You can loop over it without ever accessing the length property:</source>
          <target state="translated">你可以在不访问长度属性的情况下循环使用它。</target>
        </trans-unit>
        <trans-unit id="b3f6f0955f94bb72fe3f0ae7cac303e447b46c4f" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; flow control statements</source>
          <target state="translated">您可以使用 &lt;code&gt;break&lt;/code&gt; 和 &lt;code&gt;continue&lt;/code&gt; 流控制语句</target>
        </trans-unit>
        <trans-unit id="667729f11316fb106cabbaf8f7679345003c82dc" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;map&lt;/code&gt;, which is a functional programming technique that's also available in other languages like &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;Python&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt;.</source>
          <target state="translated">您可以使用 &lt;code&gt;map&lt;/code&gt; ，这是一种功能编程技术，在其他语言（如&lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;Python&lt;/a&gt;和&lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell）中&lt;/a&gt;也可以使用。</target>
        </trans-unit>
        <trans-unit id="7a4b18372164e1ad74d80e376ae54cd4abd6e783" translate="yes" xml:space="preserve">
          <source>You don't have to write the function inline. It could be a separate function.</source>
          <target state="translated">你不一定要写这个函数的内联。它可以是一个独立的函数。</target>
        </trans-unit>
        <trans-unit id="04e20c98a9f172e8338b0b1b84b15442bffed6db" translate="yes" xml:space="preserve">
          <source>You have several options:</source>
          <target state="translated">你有几个选择。</target>
        </trans-unit>
        <trans-unit id="c18eca76acfa486b5f4dcface2dd20167b170206" translate="yes" xml:space="preserve">
          <source>You may not need all of them, but they can be very useful, or would be if every browser supported them.</source>
          <target state="translated">你可能不需要所有这些,但它们可能非常有用,或者说,如果每个浏览器都支持它们,就会非常有用。</target>
        </trans-unit>
        <trans-unit id="d0197dfcf1833d20eadc2e44df6cf7b17edfb6e7" translate="yes" xml:space="preserve">
          <source>You may see the length caching done in the loop initialization clause, like this:</source>
          <target state="translated">你可能会看到在循环初始化子句中完成的长度缓存,就像这样。</target>
        </trans-unit>
        <trans-unit id="8b04966caa69c26f8b04bd68edaf4ae602d48951" translate="yes" xml:space="preserve">
          <source>but it still will iterate over custom-defined properties.</source>
          <target state="translated">但它仍然会对自定义属性进行迭代。</target>
        </trans-unit>
        <trans-unit id="0f1caa03a8a9833b96860b4c667bbe37793f5874" translate="yes" xml:space="preserve">
          <source>for (var s of myStringArray) {</source>
          <target state="translated">for (var s of myStringArray){</target>
        </trans-unit>
        <trans-unit id="8c120f4720ec425aef81f42a20fa2bc703fd8e57" translate="yes" xml:space="preserve">
          <source>logs: 'one','two','three'</source>
          <target state="translated">木头:'一','二','三'</target>
        </trans-unit>
        <trans-unit id="3601240b074c10fa007af1eff93ad808fd4ff1ab" translate="yes" xml:space="preserve">
          <source>logs: 'three','two','one'</source>
          <target state="translated">木头:'三','二','一'。'3','2','1'</target>
        </trans-unit>
        <trans-unit id="cf8d12fbc60f1b20dd0631d9a744f6b45587b6be" translate="yes" xml:space="preserve">
          <source>or better and cleaner to use while loop:</source>
          <target state="translated">或更好、更干净地使用同时循环。</target>
        </trans-unit>
        <trans-unit id="50b545a5758f3ce6da5a104b5dfa5a80cee70094" translate="yes" xml:space="preserve">
          <source>which would be sort-of equivalent to:</source>
          <target state="translated">这将是有点等同于:</target>
        </trans-unit>
        <trans-unit id="afb20d799b4203b1e14e9210429f20b6ff061fc3" translate="yes" xml:space="preserve">
          <source>will output &quot;11&quot; - which may or may not be what you want.</source>
          <target state="translated">将输出 &quot;11&quot;-这可能是你想要的,也可能不是你想要的。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
