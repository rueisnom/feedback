<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/3010840">
    <body>
      <group id="3010840">
        <trans-unit id="71a94b16709bbf4aa3c32acb86f39f9864156150" translate="yes" xml:space="preserve">
          <source>(Directly answering your question: now you can!)</source>
          <target state="translated">(あなたの質問に直接答える:今ならできる!)</target>
        </trans-unit>
        <trans-unit id="ec51a3dc7ea6a2a72bde5feaa9c8672035a07a39" translate="yes" xml:space="preserve">
          <source>(The variable &lt;code&gt;s&lt;/code&gt; is different on each iteration, but can still be declared &lt;code&gt;const&lt;/code&gt; inside the loop body as long as it isn't modified there.)</source>
          <target state="translated">（変数 &lt;code&gt;s&lt;/code&gt; は反復ごとに異なりますが、ループ本体内で変更されない限り、ループ本体内で &lt;code&gt;const&lt;/code&gt; と宣言できます。）</target>
        </trans-unit>
        <trans-unit id="244801924519c2f465f969ec90a3aa5fd9d346b3" translate="yes" xml:space="preserve">
          <source>... with the added benefit of also knowing about the current index inside the loop</source>
          <target state="translated">...ループ内の現在のインデックスを知ることができるという利点もあります。</target>
        </trans-unit>
        <trans-unit id="ec1bc5f8b9989f3244f9ead64e5db9328413aaec" translate="yes" xml:space="preserve">
          <source>...or this one...</source>
          <target state="translated">...それかこれか...</target>
        </trans-unit>
        <trans-unit id="8d2614ef79acce87f4e8df94e0a87325e712b550" translate="yes" xml:space="preserve">
          <source>...or this one:</source>
          <target state="translated">...またはこれ</target>
        </trans-unit>
        <trans-unit id="346ff56be0af3dfc4cf74b13b4f1a9723c7e753b" translate="yes" xml:space="preserve">
          <source>1. Just loop through an array</source>
          <target state="translated">1.配列をループするだけ</target>
        </trans-unit>
        <trans-unit id="555d744b1f77d61c7e32ae7f1a90aff8db853562" translate="yes" xml:space="preserve">
          <source>1. Sequential &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">1.順次 &lt;code&gt;for&lt;/code&gt; ループ：</target>
        </trans-unit>
        <trans-unit id="fa1164fabc473c60d9122565248be869d4644b2f" translate="yes" xml:space="preserve">
          <source>2. Array.prototype.forEach</source>
          <target state="translated">2.2.Array.prototype.forEach</target>
        </trans-unit>
        <trans-unit id="6e8d1647574b4505b85422943502e4260626b5e9" translate="yes" xml:space="preserve">
          <source>2. Check if any of the elements in an array pass a test</source>
          <target state="translated">2.配列の要素の中にテストに合格するものがあるかどうかをチェックする</target>
        </trans-unit>
        <trans-unit id="c6f4890b5c42211a8b71fa93fd4dc466a147e440" translate="yes" xml:space="preserve">
          <source>3. ES6 &lt;code&gt;for-of&lt;/code&gt; statement</source>
          <target state="translated">3. ES6 &lt;code&gt;for-of&lt;/code&gt; ステートメント</target>
        </trans-unit>
        <trans-unit id="170ca03f86983ae059350f3d39d8357d3c86d88a" translate="yes" xml:space="preserve">
          <source>3. Transform to a new array</source>
          <target state="translated">3.新しい配列に変換する</target>
        </trans-unit>
        <trans-unit id="29c50fb048ccffde9b75eeb5c873696dc6fad375" translate="yes" xml:space="preserve">
          <source>4. Sum up a particular property, and calculate its average</source>
          <target state="translated">4.特定のプロパティを合計し、その平均値を計算する</target>
        </trans-unit>
        <trans-unit id="2dee4a4a056e6ed1617861aec6829069d797515e" translate="yes" xml:space="preserve">
          <source>5. Create a new array based on the original but without modifying it</source>
          <target state="translated">5.5.元の配列をもとに、変更せずに新しい配列を作成します。</target>
        </trans-unit>
        <trans-unit id="60379d930daa877950b8a02d7df63a9f9158547b" translate="yes" xml:space="preserve">
          <source>6. Count the number of each category</source>
          <target state="translated">6.各カテゴリーの数を数える</target>
        </trans-unit>
        <trans-unit id="97078bd3f052e4a50a879e4f327d30b3bb437cb1" translate="yes" xml:space="preserve">
          <source>7. Retrieve a subset of an array based on particular criteria</source>
          <target state="translated">7.特定の条件に基づいて配列のサブセットを取得する</target>
        </trans-unit>
        <trans-unit id="40b895b551e1a8bf16b710f73aad346b0750062e" translate="yes" xml:space="preserve">
          <source>8. Sort an array</source>
          <target state="translated">8.配列を並べ替える</target>
        </trans-unit>
        <trans-unit id="944b4287e667dd3dc76140f392ce6f74b5e943d8" translate="yes" xml:space="preserve">
          <source>9. Find an element in an array</source>
          <target state="translated">9.配列の要素を見つける</target>
        </trans-unit>
        <trans-unit id="f0b6e9ad3ee35377fad2b98e91e4addf653f72fa" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://api.jquery.com/jquery.each/&quot;&gt;&lt;strong&gt;&lt;code&gt;jQuery.each()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, in &lt;a href=&quot;https://jquery.com/&quot;&gt;&lt;strong&gt;jQuery&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://api.jquery.com/jquery.each/&quot;&gt;&lt;strong&gt; &lt;code&gt;jQuery.each()&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; 、 &lt;a href=&quot;https://jquery.com/&quot;&gt;&lt;strong&gt;jQuery内&lt;/strong&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="b261c82cdd26f431b814a6f9436b4fd59a1deb22" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://underscorejs.org/#each&quot;&gt;&lt;strong&gt;&lt;code&gt;_.each()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, in &lt;a href=&quot;http://underscorejs.org/&quot;&gt;&lt;strong&gt;Underscore.js&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://underscorejs.org/#each&quot;&gt;&lt;strong&gt; &lt;code&gt;_.each()&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; 、 &lt;a href=&quot;http://underscorejs.org/&quot;&gt;&lt;strong&gt;Underscore.js内&lt;/strong&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="c58511caaca6df233bc2182e3ec4036cfee42ef7" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://lodash.com/docs#forEach&quot;&gt;&lt;strong&gt;&lt;code&gt;_.forEach()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, in &lt;a href=&quot;https://lodash.com/&quot;&gt;&lt;strong&gt;Lodash.js&lt;/strong&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://lodash.com/docs#forEach&quot;&gt;&lt;strong&gt; &lt;code&gt;_.forEach()&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt; 、 &lt;a href=&quot;https://lodash.com/&quot;&gt;&lt;strong&gt;Lodash.js内&lt;/strong&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="52ca60a94f206d4eac02b402c38bb25a86fa23d5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Array.prototype.forEach()&lt;/code&gt; is supported by all modern browsers, as well as Internet&amp;nbsp;Explorer&amp;nbsp;9 and later.</source>
          <target state="translated">&lt;code&gt;Array.prototype.forEach()&lt;/code&gt; は、すべての最新のブラウザとInternet Explorer 9以降でサポートされています。</target>
        </trans-unit>
        <trans-unit id="d3bfa9adc07d603c481ef7db3fa023766d732441" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;For...in&lt;/code&gt; and &lt;code&gt;for...of&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;For...in&lt;/code&gt; および &lt;code&gt;for...of&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a54271474b32241db54533f0e2686f548830428" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt; doesn't give you the index associated with each object, but as long as the object you're iterating over is actually an &lt;code&gt;Array&lt;/code&gt; (&lt;code&gt;for&lt;/code&gt;..&lt;code&gt;of&lt;/code&gt; works for other iterable types which may not have this method), you can use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries&quot;&gt;Array#entries&lt;/a&gt; method to change it to an array of [index, item] pairs, and then iterate over that:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ... &lt;code&gt;of&lt;/code&gt; は、各オブジェクトに関連付けられたインデックスを提供しませんが、反復しているオブジェクトが実際には &lt;code&gt;Array&lt;/code&gt; 限り（このメソッドを持たない他の反復可能なタイプの.. &lt;code&gt;of&lt;/code&gt; 動作）、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries&quot;&gt;Array＃entries&lt;/a&gt;メソッドを使用して、[index、item]のペアの配列に変更し、それを繰り返します。</target>
        </trans-unit>
        <trans-unit id="7bb38035ceb1c396d3e7996795df8bf4c249f876" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(example extracted from &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&lt;/a&gt;)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;（ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&lt;/a&gt;から抽出された例）&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bf37ae0f080f8d39b2aaaf060b6cdeb79a3c67db" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;Array.prototype.forEach()&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;Array.prototype.forEach()&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="26e2ad632edf81fb7e89bc1c9c05201ffd6e306d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Compatibility table:&lt;/em&gt;&lt;a href=&quot;http://kangax.github.io/es5-compat-table/es6/&quot;&gt;http://kangax.github.io/es5-compat-table/es6/#For..of loops&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;互換性テーブル：&lt;/em&gt; &lt;a href=&quot;http://kangax.github.io/es5-compat-table/es6/&quot;&gt;http&lt;/a&gt; &lt;em&gt;:&lt;/em&gt; //kangax.github.io/es5-compat-table/es6/#For..of loops</target>
        </trans-unit>
        <trans-unit id="ee6ae84753dccfa00cebeada5ae7c3e21d1273a3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Spec:&lt;/em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:iterators&quot;&gt;http://wiki.ecmascript.org/doku.php?id=harmony:iterators&lt;/a&gt;</source>
          <target state="translated">&lt;em&gt;Spec:&lt;/em&gt;&lt;a href=&quot;http://wiki.ecmascript.org/doku.php?id=harmony:iterators&quot;&gt;http://wiki.ecmascript.org/doku.php?id=harmony:iterators&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="064b427011b9e17b9e8c52d0c2639ac7a841e64e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1) For loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1）forループ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b51f60a16cebef810392106138bdb5ad294a4367" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2) While loop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2）whileループ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a4c5db10da9d3be2f8b682db7a9e9d2f7183bdc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3) Do while&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3）しばらくする&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eef54d6b0a77c28db0f845a27fb46e78a54e93ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;jQuery.each( collection, callback(indexInArray, valueOfElement) )&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;jQuery.each( collection, callback(indexInArray, valueOfElement) )&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="daf1d3da9a9639317a8275f5459ed1e0ddfaa92a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Anti-pattern:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Anti-pattern:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="caf1f7a722c982dbd57c57da6fb19a30c4de09b0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Cons&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Cons&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="704e3b0291568ed9b2c317a548493efb74047033" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Description:&lt;/strong&gt;&lt;em&gt;A generic iterator function, which can be used to
  seamlessly iterate over both objects and arrays. Arrays and array-like
  objects with a length property (such as a function's arguments object)
  are iterated by numeric index, from 0 to length-1. Other objects are
  iterated via their named properties.&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;説明：&lt;/strong&gt; &lt;em&gt;オブジェクトと配列の両方をシームレスに反復するために使用できる汎用の反復関数。&lt;/em&gt; &lt;em&gt;長さプロパティを持つ配列や配列のようなオブジェクト（関数の引数オブ​​ジェクトなど）は、0から長さ-1までの数値インデックスによって反復されます。&lt;/em&gt; &lt;em&gt;他のオブジェクトは、それらの名前付きプロパティを介して反復されます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="048e1c2143e4ceda5b814a601b1c670466d18b12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ES5's forEach:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ES5のforEach：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54f593ac46043f8cd9b8b5cf07af22c51c808d96" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Generic loop:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;一般的なループ：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f79071ea203b44120a777b7df731ac7eeaca3df3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterating a generator:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ジェネレーターを繰り返す：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="45c6df2e8979bcdde42829f806f00107ff130204" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterating an array of objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;オブジェクトの配列を反復する&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee4457fb819a5b4a1c45f33c6d9277e095252e99" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Iterating an array&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;配列の反復&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d0724a44cc225daaa925fdc5f4076cd6a8e137b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preparation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Preparation:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4679141d2baf9da770b2677b4605d0925bd20b32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Proper use case of &lt;em&gt;map&lt;/em&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;マップの&lt;/em&gt;適切な使用例：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="83a9ba38fb48160c9afd7eb56731a2e28460dc89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Proper use of &lt;em&gt;reduce&lt;/em&gt;:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;reduceの&lt;/em&gt;適切な使用：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="364d4fdee3e0bca52971cff9ce11bfd5c1cd8d29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Pros&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Pros&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c74addec8c64f7706a870355eb69d171e4ffada" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returns:&lt;/strong&gt;&lt;em&gt;Object&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;Returns:&lt;/strong&gt;&lt;em&gt;Object&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9e855f63e3c1e56f1a45077526fe3d067eab2a5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Tests:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Tests:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a921ab2d2c8f22b4e62a469b18c3138401c9585" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The afterthought:&lt;/strong&gt; performed every time after the loop block is executed</source>
          <target state="translated">&lt;strong&gt;後から：&lt;/strong&gt;ループブロックが実行された後に毎回実行されます</target>
        </trans-unit>
        <trans-unit id="0841879c44f870229f18babbbb28a4ed0218e63d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The condition:&lt;/strong&gt; checks a condition every time before the loop block is executed, and quits the loop if false</source>
          <target state="translated">&lt;strong&gt;条件：&lt;/strong&gt;ループブロックが実行される前に毎回条件をチェックし、falseの場合はループを終了します</target>
        </trans-unit>
        <trans-unit id="ef6b1bf0d5160d7392a2ec56a57142f8de0324e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The initialization:&lt;/strong&gt; executed before the look block is executed the first time</source>
          <target state="translated">&lt;strong&gt;初期化：&lt;/strong&gt; Lookブロックが最初に実行される前に実行されます</target>
        </trans-unit>
        <trans-unit id="83b0f4ed7f0a0bdf74518f2b95d2dc1099b984c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Yes&lt;/strong&gt;, you can do the same in JavaScript using a loop, but &lt;strong&gt;not limited&lt;/strong&gt; to that, there are many ways to do a loop over arrays in JavaScript. Imagine you have this array below, and you'd like to do a loop over it:</source>
          <target state="translated">&lt;strong&gt;はい&lt;/strong&gt; 、JavaScriptでもループを使用して同じことができますが、これに&lt;strong&gt;限定さ&lt;/strong&gt;れ&lt;strong&gt;ません&lt;/strong&gt; 。JavaScriptで配列をループする方法はたくさんあります。 以下にこの配列があり、それに対してループを実行したいとします。</target>
        </trans-unit>
        <trans-unit id="f841e3cc81531c69c584f7487ed89ea2ccac79f1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;every&lt;/strong&gt; returns true if every array member passes the test.</source>
          <target state="translated">&lt;strong&gt;すべての&lt;/strong&gt;配列メンバーがテストに合格すると、 &lt;strong&gt;every&lt;/strong&gt;はtrueを返します。</target>
        </trans-unit>
        <trans-unit id="ae5396154ba12f2cbc9b6fb60697228d099a6bfb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;filter&lt;/strong&gt; returns an array of items that satisfy some condition or test.</source>
          <target state="translated">&lt;strong&gt;filter&lt;/strong&gt;は、何らかの条件またはテストを満たすアイテムの配列を返します。</target>
        </trans-unit>
        <trans-unit id="bdef08e47d03473e002381b0b85e4c365db03f3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;forEach&lt;/strong&gt; runs a function on each array member and doesn't return anything.</source>
          <target state="translated">&lt;strong&gt;forEach&lt;/strong&gt;は、各配列メンバーで関数を実行し、何も返しません。</target>
        </trans-unit>
        <trans-unit id="4e0ee97333a8174d8fa7c7379cd31d5d7b455eb1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;indexOf&lt;/strong&gt; and &lt;strong&gt;lastIndexOf&lt;/strong&gt; find the appropriate position of the first or last element that matches its argument exactly.</source>
          <target state="translated">&lt;strong&gt;indexOf&lt;/strong&gt;と&lt;strong&gt;lastIndexOf&lt;/strong&gt;は、引数と&lt;strong&gt;完全に&lt;/strong&gt;一致する最初または最後の要素の適切な位置を見つけます。</target>
        </trans-unit>
        <trans-unit id="89bb2ea399853abc85cd80df1635dcb485fff8de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;jQuery.each:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;jQuery.each:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a7285fa826c294da33df813b34b34a49e92f76c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;map&lt;/strong&gt; is like forEach, but it returns an array of the results of the operation for each element.</source>
          <target state="translated">&lt;strong&gt;map&lt;/strong&gt;はforEachに似ていますが、各要素の操作の結果の配列を返します。</target>
        </trans-unit>
        <trans-unit id="05b320d00a006bb181f7dc73f11bce756fd386ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;some&lt;/strong&gt; returns true if any pass the test.</source>
          <target state="translated">テストに合格した場合にtrueを返す&lt;strong&gt;ものもあり&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="3b932bd9e58e3f9ce0d4b89f0f0f9034a0636581" translate="yes" xml:space="preserve">
          <source>@zipcodeman suggests the use of the &lt;code&gt;for...in&lt;/code&gt; statement, but for iterating arrays &lt;code&gt;for-in&lt;/code&gt; should be avoided, that statement is meant to &lt;strong&gt;enumerate&lt;/strong&gt; object properties.</source>
          <target state="translated">@zipcodemanは &lt;code&gt;for...in&lt;/code&gt; ステートメントの使用を提案しますが、配列 &lt;code&gt;for-in&lt;/code&gt; 反復するためにfor-inは避けてください。このステートメントはオブジェクトのプロパティを&lt;strong&gt;列挙&lt;/strong&gt;することを目的としています。</target>
        </trans-unit>
        <trans-unit id="cc59d14dbd8a74031257140af343c1de66fa1c7e" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;do while&lt;/code&gt; is doing the same thing as &lt;code&gt;while&lt;/code&gt; with some syntax difference as below:</source>
          <target state="translated">&lt;code&gt;do while&lt;/code&gt; は &lt;code&gt;while&lt;/code&gt; と同じことをしますが、以下のような構文の違いがあります。</target>
        </trans-unit>
        <trans-unit id="7ba0e7db2ec388ee16e982710586d5dcd4505fa1" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;for&lt;/code&gt; loop is a common way looping through arrays in JavaScript, but no considered as the fastest solutions for large arrays:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループは、JavaScriptで配列をループする一般的な方法ですが、大規模な配列の最速のソリューションとは見なされていません。</target>
        </trans-unit>
        <trans-unit id="a2e0ff643ee538083545089d13416135913cd236" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;while&lt;/code&gt; loop</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; ループ</target>
        </trans-unit>
        <trans-unit id="8138b8bf38e6eb381685855e53355dab4069f576" translate="yes" xml:space="preserve">
          <source>A lot cleaner...</source>
          <target state="translated">綺麗になった...</target>
        </trans-unit>
        <trans-unit id="208b5e319042638896984a55881d0d0b48f1809f" translate="yes" xml:space="preserve">
          <source>A note on sparse arrays: an array in JavaScript may not actually store as many items as reported by its &lt;code&gt;length&lt;/code&gt;; that reported number is simply one greater than the highest index at which a value is stored. If the array holds fewer elements than indicated by its length, its said to be &lt;em&gt;sparse&lt;/em&gt;. For example, it's perfectly legitimate to have an array with items only at indexes 3, 12, and 247; the &lt;code&gt;length&lt;/code&gt; of such an array is reported as 248, though it is only actually storing 3 values.  If you try to access an item at any other index, the array will appear to have the &lt;code&gt;undefined&lt;/code&gt; value there. So when you want to &quot;loop through&quot; an array, you have a question to answer: do you want to loop over the full range indicated by its length and process &lt;code&gt;undefined&lt;/code&gt;s for any missing elements, or do you only want to process the elements actually present? There are plenty of applications for both approaches; it just depends on what you're using the array for.</source>
          <target state="translated">スパース配列に関する注意：JavaScriptの配列は、実際には &lt;code&gt;length&lt;/code&gt; 報告された数のアイテムを格納しない場合があります。 その報告された数は、値が格納される最高のインデックスよりも1つ大きいだけです。 配列が保持する要素がその長さで示されるよりも少ない場合、その要素は&lt;em&gt;sparse&lt;/em&gt;と呼ばれます。 たとえば、インデックスが3、12、および247のアイテムのみを含む配列を持つことは完全に正当です。 このような配列の &lt;code&gt;length&lt;/code&gt; は248と報告されますが、実際には3つの値しか格納されません。 他のインデックスにあるアイテムにアクセスしようとすると、配列には &lt;code&gt;undefined&lt;/code&gt; 値があるように見えます。 したがって、配列を「ループスルー」する場合、答える必要がある質問があります。その長さで示される全範囲をループして、不足している要素の &lt;code&gt;undefined&lt;/code&gt; のsを処理しますか、それとも要素のみを処理しますか？実際に存在しますか？ どちらのアプローチにも多くのアプリケーションがあります。 配列を何に使用するかによります。</target>
        </trans-unit>
        <trans-unit id="1c8bc2da7ace60c25491e4b45d72527b6904edf7" translate="yes" xml:space="preserve">
          <source>A traditional &lt;code&gt;for&lt;/code&gt; loop has three components:</source>
          <target state="translated">従来の &lt;code&gt;for&lt;/code&gt; ループには3つのコンポーネントがあります。</target>
        </trans-unit>
        <trans-unit id="93369b398d50b7aaab7d717bce714a497353f9a1" translate="yes" xml:space="preserve">
          <source>A traditional &lt;code&gt;for&lt;/code&gt;-loop</source>
          <target state="translated">従来の &lt;code&gt;for&lt;/code&gt; ループ</target>
        </trans-unit>
        <trans-unit id="96d8cabd7458880b5703e2b2959e3cbf91d9b07e" translate="yes" xml:space="preserve">
          <source>A while loop is considered as the fastest way to loop through long arrays, but it is usually less used in the JavaScript code:</source>
          <target state="translated">whileループは長い配列をループする最速の方法と考えられていますが、通常JavaScriptのコードではあまり使われていません。</target>
        </trans-unit>
        <trans-unit id="1bab4365e2766b395817dc81f2821118ea4e8b6d" translate="yes" xml:space="preserve">
          <source>A working jsFiddle example:
&lt;a href=&quot;https://jsfiddle.net/workingClassHacker/pxpv2dh5/7/&quot;&gt;https://jsfiddle.net/workingClassHacker/pxpv2dh5/7/&lt;/a&gt;</source>
          <target state="translated">動作するjsFiddleの例： &lt;a href=&quot;https://jsfiddle.net/workingClassHacker/pxpv2dh5/7/&quot;&gt;https&lt;/a&gt; ://jsfiddle.net/workingClassHacker/pxpv2dh5/7/</target>
        </trans-unit>
        <trans-unit id="87989326732077c33a82222d4512a023029ffac3" translate="yes" xml:space="preserve">
          <source>Additionally, you need to consider that no version of Internet Explorer supports &lt;code&gt;for...of&lt;/code&gt; (&lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;&lt;strong&gt;Edge 12+&lt;/strong&gt;&lt;/a&gt; does) and that &lt;code&gt;for...in&lt;/code&gt; requires at least Internet&amp;nbsp;Explorer&amp;nbsp;10.</source>
          <target state="translated">さらに、Internet Explorer &lt;a href=&quot;https://www.microsoft.com/en-us/windows/microsoft-edge&quot;&gt;&lt;strong&gt;のど&lt;/strong&gt;&lt;/a&gt;のバージョンでもサポートされていないことを考慮する必要があります（ &lt;code&gt;for...of&lt;/code&gt; &lt;strong&gt;エッジ12+&lt;/strong&gt;はサポートしています ）。</target>
        </trans-unit>
        <trans-unit id="7bdea304f3832a9d1bee7adfb3ce1b3900b31457" translate="yes" xml:space="preserve">
          <source>Also look at the &lt;code&gt;map()&lt;/code&gt;, &lt;code&gt;filter()&lt;/code&gt;, &lt;code&gt;reduce()&lt;/code&gt;, etc. functions on an Array in JavaScript. They may do things much faster and better than using &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;for&lt;/code&gt;.</source>
          <target state="translated">JavaScriptの配列の &lt;code&gt;map()&lt;/code&gt; 、 &lt;code&gt;filter()&lt;/code&gt; 、 &lt;code&gt;reduce()&lt;/code&gt; などの関数も見てください。 彼らは &lt;code&gt;while&lt;/code&gt; と &lt;code&gt;for&lt;/code&gt; を使用するよりもはるかに速く、より良いことをするかもしれません。</target>
        </trans-unit>
        <trans-unit id="9d7962bb439dccc6fd05184547a30773438f73c3" translate="yes" xml:space="preserve">
          <source>Also we use a &lt;code&gt;for in&lt;/code&gt; loop for looping over objects in JavaScript.</source>
          <target state="translated">また、JavaScriptでオブジェクトをループする &lt;code&gt;for in&lt;/code&gt; ループを使用します。</target>
        </trans-unit>
        <trans-unit id="41378cebb50d920582b6d22c47f75d416ff10194" translate="yes" xml:space="preserve">
          <source>Also, as CMS mentions in a comment below, you can only use this on arrays that don't contain any falsish values. The array of strings from the example works, but if you have empty strings, or numbers that are 0 or NaN, etc. the loop will break off prematurely. Again in practice this is hardly ever a problem for me, but it is something to keep in mind, which makes this a loop to think about before you use it... That may disqualify it for some people :)</source>
          <target state="translated">また、CMSが下のコメントで言及しているように、これは偽の値を含まない配列にしか使えません。例の文字列の配列は動作しますが、空の文字列や0やNaNなどの数値がある場合、ループは早々に途切れてしまいます。実際にはほとんど問題になることはありませんが、これは心に留めておくべきことであり、これを使う前に考えておくべきループです...それは何人かの人にとっては不適格かもしれません。)</target>
        </trans-unit>
        <trans-unit id="ee77eebe99af67ab08f84860fed6f896852d7c5f" translate="yes" xml:space="preserve">
          <source>Also, if you are trying to &lt;em&gt;reduce&lt;/em&gt; the array to a value, for example, you want to sum an array of numbers, you should use the &lt;em&gt;reduce&lt;/em&gt; method.</source>
          <target state="translated">また、配列を値に&lt;em&gt;縮小&lt;/em&gt;しようとしている場合、たとえば、数値の配列を合計したい場合は、 &lt;em&gt;reduce&lt;/em&gt;メソッドを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="14295abe04b6e2a7de39a9d704b37a8979113366" translate="yes" xml:space="preserve">
          <source>Also, note that every while loop can be rewritten as a &lt;code&gt;for&lt;/code&gt; loop. For example, the &lt;code&gt;while&lt;/code&gt; loop hereabove behaves the exact same way as this &lt;code&gt;for&lt;/code&gt;-loop:</source>
          <target state="translated">また、すべてのwhileループは &lt;code&gt;for&lt;/code&gt; ループとして書き直すことができることに注意してください。 たとえば、上記の &lt;code&gt;while&lt;/code&gt; ループは、この &lt;code&gt;for&lt;/code&gt; ループとまったく同じように動作します。</target>
        </trans-unit>
        <trans-unit id="d4c7b480881659d668d6e1c838c1bbd6f2357af6" translate="yes" xml:space="preserve">
          <source>An alternative to &lt;code&gt;for&lt;/code&gt;-loops is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;strong&gt;&lt;code&gt;Array.prototype.forEach()&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, which uses the following syntax:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; -loopsの代替は、次の構文を使用する&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;strong&gt; &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="7608e4a05c083f0749c3b00ef49e63f9bb0d59f7" translate="yes" xml:space="preserve">
          <source>And for the reverse order, an even more efficient loop</source>
          <target state="translated">そして、逆の順序のために、さらに効率的なループ</target>
        </trans-unit>
        <trans-unit id="ea3c12f54f03b3157d901d7ecb01d0c6e8c6314b" translate="yes" xml:space="preserve">
          <source>And now x is &lt;code&gt;[10,20,30,40]&lt;/code&gt;.</source>
          <target state="translated">そしてxは &lt;code&gt;[10,20,30,40]&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="b16c84749f0eea7f146f4aab53c2350db832cc15" translate="yes" xml:space="preserve">
          <source>And with the ES6 arrow function syntax, it's even more succinct:</source>
          <target state="translated">しかもES6の矢印関数の構文を使えば、さらに簡潔になります。</target>
        </trans-unit>
        <trans-unit id="9aee1dfe4cd64107cde999301ba98e4228ffd0ba" translate="yes" xml:space="preserve">
          <source>Array loop:</source>
          <target state="translated">配列ループ。</target>
        </trans-unit>
        <trans-unit id="59df7171edff63098689b1d4cbcde62b62c5c672" translate="yes" xml:space="preserve">
          <source>Array objects are by definition built-in iterables in ES6, so you can use this statement on them:</source>
          <target state="translated">配列オブジェクトは、ES6では定義上、組み込みのイテレータブルであるため、このステートメントを使用することができます。</target>
        </trans-unit>
        <trans-unit id="9b48533ed470f313be2a50e6f04cca823d741861" translate="yes" xml:space="preserve">
          <source>Array.prototype.filter()</source>
          <target state="translated">Array.prototype.filter()</target>
        </trans-unit>
        <trans-unit id="a71dca401c8bb6c1ba8a6a85b489323db0aded15" translate="yes" xml:space="preserve">
          <source>Array.prototype.find()</source>
          <target state="translated">Array.prototype.find()</target>
        </trans-unit>
        <trans-unit id="4cb3cae1053ce2bb98a5b83b932f46c25e31ba9b" translate="yes" xml:space="preserve">
          <source>Array.prototype.forEach()</source>
          <target state="translated">Array.prototype.forEach()</target>
        </trans-unit>
        <trans-unit id="119e13f09e922be9e6bae1b2eb26f44372c5447b" translate="yes" xml:space="preserve">
          <source>Array.prototype.map()</source>
          <target state="translated">Array.prototype.map()</target>
        </trans-unit>
        <trans-unit id="4e64033432afb4813d9f7c316c2ce7cc3e7a8ccd" translate="yes" xml:space="preserve">
          <source>Array.prototype.some()</source>
          <target state="translated">Array.prototype.some()</target>
        </trans-unit>
        <trans-unit id="7038dcb1eaea94f778a783fcd9d69b9aa89101f4" translate="yes" xml:space="preserve">
          <source>Array.prototype.sort()</source>
          <target state="translated">Array.prototype.sort()</target>
        </trans-unit>
        <trans-unit id="a34e33465f051a1d48b1d51dd13cef09aa81c0c5" translate="yes" xml:space="preserve">
          <source>Arrow functions are also widely implemented unless you plan to support ancient platforms (e.g., IE11); you are also safe to go.</source>
          <target state="translated">古いプラットフォーム (IE11 など)をサポートする予定がない限り、矢印関数も広く実装されています。</target>
        </trans-unit>
        <trans-unit id="966cddcbaa10c67096f934e4803322a1c2ad7ec2" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;strong&gt;&lt;code&gt;for...in&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;, there's now also for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;strong&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/strong&gt;&lt;/a&gt;. The following example shows the difference between a &lt;code&gt;for...of&lt;/code&gt; loop and a &lt;code&gt;for...in&lt;/code&gt; loop:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;strong&gt; &lt;code&gt;for...in&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;代わりに、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;strong&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/strong&gt;&lt;/a&gt;も追加され&lt;strong&gt;ました&lt;/strong&gt; 。 次の例は、 &lt;code&gt;for...of&lt;/code&gt; ループと &lt;code&gt;for...in&lt;/code&gt; ループの違いを示しています。</target>
        </trans-unit>
        <trans-unit id="47221220436db2e97d5585cd374547abd2cdc928" translate="yes" xml:space="preserve">
          <source>As long as your JavaScript implementation is compliant with the &lt;em&gt;previous&lt;/em&gt; edition of the ECMAScript specification (which rules out, for example, versions of Internet Explorer before 9), then you can use the &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.foreach&quot;&gt;&lt;code&gt;Array#forEach&lt;/code&gt;&lt;/a&gt; iterator method instead of a loop. In that case, you pass a function to be called on each item in the array:</source>
          <target state="translated">JavaScriptの実装がECMAScript仕様の&lt;em&gt;以前の&lt;/em&gt;エディション（たとえば、Internet Explorerのバージョンが9より前のバージョンなど）に準拠している限り、ループの代わりに&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.foreach&quot;&gt; &lt;code&gt;Array#forEach&lt;/code&gt; &lt;/a&gt;イテレーターメソッドを使用できます。 その場合、配列の各項目で呼び出される関数を渡します。</target>
        </trans-unit>
        <trans-unit id="cc57a09cc87a254c6e7c0cd906743181aa3a7326" translate="yes" xml:space="preserve">
          <source>Assigning the length value to the local variable (as opposed to including the full &lt;code&gt;myStringArray.length&lt;/code&gt; expression in the loop condition) can make a significant difference in performance since it skips a property lookup each time through; using Rhino on my machine, the speedup is 43%.</source>
          <target state="translated">（ループ条件に完全な &lt;code&gt;myStringArray.length&lt;/code&gt; 式を含めるのではなく）ローカル変数に長さの値を割り当てると、毎回プロパティルックアップがスキップされるため、パフォーマンスに大きな違いが生じます。 私のマシンでRhinoを使用すると、速度は43％向上します。</target>
        </trans-unit>
        <trans-unit id="f3274f27a722ba9623d1b3c45014647813c3ad0d" translate="yes" xml:space="preserve">
          <source>Being almost ten years as the time of writing that the ES5 specification was released (Dec. 2009), it has been implemented by nearly all modern engines in the desktop, server, and mobile environments, so it's safe to use them.</source>
          <target state="translated">ES5仕様が公開されたと書いた時点(2009年12月)で10年近く経っているので、デスクトップ、サーバ、モバイル環境のほぼ全ての最新エンジンで実装されているので、安心して使えると思います。</target>
        </trans-unit>
        <trans-unit id="2dd3bc0add58e1c1a3bae79831bd75535ddcea2a" translate="yes" xml:space="preserve">
          <source>Can use normal flow control statements (&lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt;).</source>
          <target state="translated">通常のフロー制御ステートメントを使用できます（ &lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="738f7a02d196b0ea75cd3e9615801f4654f464c6" translate="yes" xml:space="preserve">
          <source>Can you do the same in JavaScript?</source>
          <target state="translated">JavaScriptでも同じことができるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="bb89c713f3058705a62ca86f844888cbdaec51e9" translate="yes" xml:space="preserve">
          <source>Cannot use &lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; / &lt;code&gt;continue&lt;/code&gt; 使用できません</target>
        </trans-unit>
        <trans-unit id="b36f8d07e1ebb98db02a451f012dc4e52c8f57bf" translate="yes" xml:space="preserve">
          <source>Combines very naturally with array.push and array.splice to use arrays like lists/stacks</source>
          <target state="translated">array.push や array.splice と自然に結合して listsstacks のような配列を使うことができます。</target>
        </trans-unit>
        <trans-unit id="0867c816fed31b5dc07fa208e04fcb8489f13b48" translate="yes" xml:space="preserve">
          <source>Comparing methods for looping through an array of 100000 items and do a minimal operation with the new value each time.</source>
          <target state="translated">100000項目の配列をループして、毎回新しい値でミニマム演算を行う方法を比較しています。</target>
        </trans-unit>
        <trans-unit id="3484c6fcb53ac09a3fead481f71e452bc3f9e097" translate="yes" xml:space="preserve">
          <source>Declarative</source>
          <target state="translated">Declarative</target>
        </trans-unit>
        <trans-unit id="4effb93b81a160f681429d60f84b0435de4c8948" translate="yes" xml:space="preserve">
          <source>Do not use &lt;code&gt;for...in&lt;/code&gt;</source>
          <target state="translated">使用しない &lt;code&gt;for...in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a327a1024dd4bfffdf3d3e9c43606dd74e3c14b" translate="yes" xml:space="preserve">
          <source>Easy to have &lt;a href=&quot;https://en.wikipedia.org/wiki/Off-by-one_error#Looping_over_arrays&quot;&gt;off-by-one errors&lt;/a&gt; (sometimes also called a &lt;em&gt;fence post error&lt;/em&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Off-by-one_error#Looping_over_arrays&quot;&gt;1つずれたエラーが発生し&lt;/a&gt;やすい（ &lt;em&gt;フェンスポストエラー&lt;/em&gt;とも呼ばれる）</target>
        </trans-unit>
        <trans-unit id="792e26d9ee80b19650012b8e1685b5090c7185da" translate="yes" xml:space="preserve">
          <source>Edited (because I was wrong)</source>
          <target state="translated">編集しました(間違っていたので</target>
        </trans-unit>
        <trans-unit id="a69fa90f2006d689445d656a40e7e8de54b4823e" translate="yes" xml:space="preserve">
          <source>Enumeration VS Iteration</source>
          <target state="translated">列挙VS反復</target>
        </trans-unit>
        <trans-unit id="2e71f7108ada8318088ac69ef4919973105c6a36" translate="yes" xml:space="preserve">
          <source>Except you don't get the &lt;code&gt;new_list&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;new_list&lt;/code&gt; は取得できません。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="5952055811aee2e799c8aba3a69449f3348a23fc" translate="yes" xml:space="preserve">
          <source>Finally, many utility libraries also have their own &lt;code&gt;foreach&lt;/code&gt; variation. AFAIK, the three most popular ones are these:</source>
          <target state="translated">最後に、多くのユーティリティライブラリにも独自の &lt;code&gt;foreach&lt;/code&gt; バリエーションがあります。 AFAIK、最も人気のある3つは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="69464752c7da492f7d32ce20b9cb8b32ed093960" translate="yes" xml:space="preserve">
          <source>For example, I used in a Firefox console:</source>
          <target state="translated">例えば、Firefoxのコンソールで使ってみました。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="abc897209b2f98b7966665fa36a5eddbbc44f66d" translate="yes" xml:space="preserve">
          <source>For instance:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="4b130c10bf2374ee6a7bc0052bacfac69fa72cc6" translate="yes" xml:space="preserve">
          <source>For me, this construct most closely emulates the Java 5 syntax that I love:</source>
          <target state="translated">私にとって、この構文は私の大好きなJava 5の構文に最も近いものです。</target>
        </trans-unit>
        <trans-unit id="332ea3a31e79d47a90b9a3ccec9c1cdfdbaa5829" translate="yes" xml:space="preserve">
          <source>From the documentation:</source>
          <target state="translated">ドキュメントから。</target>
        </trans-unit>
        <trans-unit id="d8f88d3b1d0ba856a7a6feeeff6fceeb8172f54f" translate="yes" xml:space="preserve">
          <source>Functional programming has been making quite a splash in the
  development world these days. And for good reason: Functional
  techniques can help you write more declarative code that is easier to
  understand at a glance, refactor, and test.</source>
          <target state="translated">最近、関数型プログラミングは開発の世界で大きな話題を呼んでいます。それには正当な理由があります。関数型のテクニックは、一目で理解しやすい宣言的なコードを書くのに役立ち、リファクタリングやテストも容易になります。</target>
        </trans-unit>
        <trans-unit id="1dd7c2693b617aa4bf3153d763983796bfb81010" translate="yes" xml:space="preserve">
          <source>Given an array:</source>
          <target state="translated">配列が与えられます。</target>
        </trans-unit>
        <trans-unit id="71f5b35dbf42c10acd92d892d5a9a39d98b97a52" translate="yes" xml:space="preserve">
          <source>Have a look &lt;a href=&quot;https://stackoverflow.com/questions/3943494/how-to-loop-through-array-in-jquery&quot;&gt;this&lt;/a&gt; for detailed information or you can also check &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;MDN&lt;/a&gt; for looping through an array in JavaScript &amp;amp; using jQuery check &lt;a href=&quot;http://api.jquery.com/jquery.each/&quot;&gt;jQuery for each&lt;/a&gt;.</source>
          <target state="translated">詳細情報については、 &lt;a href=&quot;https://stackoverflow.com/questions/3943494/how-to-loop-through-array-in-jquery&quot;&gt;こちら&lt;/a&gt;をご覧ください。または、JavaScriptで配列をループし、 &lt;a href=&quot;http://api.jquery.com/jquery.each/&quot;&gt;jQueryを&lt;/a&gt;使用して&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in&quot;&gt;MDN&lt;/a&gt;をチェックすることもできます。</target>
        </trans-unit>
        <trans-unit id="8a275f06b64b792994a2bea49ec5edd99e73a997" translate="yes" xml:space="preserve">
          <source>Hence:</source>
          <target state="translated">Hence:</target>
        </trans-unit>
        <trans-unit id="36fb22ec3194ab597f2415160001e28b55136fda" translate="yes" xml:space="preserve">
          <source>I did not yet see this variation, which I personally like the best:</source>
          <target state="translated">このバリエーションはまだ見ていませんが、個人的には一番好きです。</target>
        </trans-unit>
        <trans-unit id="bc84262abb174c9f0e38f36c626a6768b31337c7" translate="yes" xml:space="preserve">
          <source>I would recommend you to read the following article:</source>
          <target state="translated">次の記事を読むことをおすすめします。</target>
        </trans-unit>
        <trans-unit id="eaec00891170c602b86758588121582f9cc77f86" translate="yes" xml:space="preserve">
          <source>I would thoroughly recommend making use of the &lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;underscore.js&lt;/a&gt; library. It provides you with various functions that you can use to iterate over arrays/collections.</source>
          <target state="translated">&lt;a href=&quot;http://documentcloud.github.com/underscore&quot;&gt;underscore.js&lt;/a&gt;ライブラリを使用することを徹底的にお勧めします。 配列/コレクションを反復処理するために使用できるさまざまな関数を提供します。</target>
        </trans-unit>
        <trans-unit id="680e5f2fe4669cc64fca6d0dce2445fc1aba9665" translate="yes" xml:space="preserve">
          <source>If anybody is interested in the performance side of the multiple mechanisms available for Array iterations, I've prepared the following JSPerf tests:</source>
          <target state="translated">もし誰かがArrayの反復で利用できる複数のメカニズムの性能面に興味があるならば、以下のJSPerfのテストを用意しました。</target>
        </trans-unit>
        <trans-unit id="fb3e18a35d3138a4789c20ff08015dcd8a81b50b" translate="yes" xml:space="preserve">
          <source>If one wants to iterate over sparsed array, &lt;code&gt;for (var i = 0; i &amp;lt; array.length; i++) if (i in array)&lt;/code&gt; or &lt;code&gt;array.forEach&lt;/code&gt; with &lt;code&gt;es5shim&lt;/code&gt; should be used.</source>
          <target state="translated">スパース配列を反復処理したい場合は &lt;code&gt;for (var i = 0; i &amp;lt; array.length; i++) if (i in array)&lt;/code&gt; または &lt;code&gt;array.forEach&lt;/code&gt; with &lt;code&gt;es5shim&lt;/code&gt; を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="e7c24db9c43e39fc71182c2e8052375e6c248727" translate="yes" xml:space="preserve">
          <source>If order of iteration does not matter than you should try reversed loop, it is fastest as it reduce overhead condition testing and decrement is in one statement:</source>
          <target state="translated">反復の順序が重要でない場合は、逆ループを試してみるとよいでしょう。</target>
        </trans-unit>
        <trans-unit id="02757283e37586df6bb23c4f4ba9f10dab95d8e4" translate="yes" xml:space="preserve">
          <source>If you are targeting older browsers, the transpiled output &lt;a href=&quot;https://babeljs.io/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=GYewTgBAFAxiB2BnALhOAbcETDSTYiAlAN4BQEeS-ApgHSYDms-4RA3GQL5A&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=true&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=false&amp;amp;presets=es2015&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.4&amp;amp;externalPlugins=&quot;&gt;might surprise you&lt;/a&gt;.</source>
          <target state="translated">古いブラウザをターゲットにしている場合、変換された出力&lt;a href=&quot;https://babeljs.io/repl#?babili=false&amp;amp;browsers=&amp;amp;build=&amp;amp;builtIns=false&amp;amp;spec=false&amp;amp;loose=false&amp;amp;code_lz=GYewTgBAFAxiB2BnALhOAbcETDSTYiAlAN4BQEeS-ApgHSYDms-4RA3GQL5A&amp;amp;debug=false&amp;amp;forceAllTransforms=false&amp;amp;shippedProposals=false&amp;amp;circleciRepo=&amp;amp;evaluate=true&amp;amp;fileSize=false&amp;amp;timeTravel=false&amp;amp;sourceType=module&amp;amp;lineWrap=false&amp;amp;presets=es2015&amp;amp;prettier=false&amp;amp;targets=&amp;amp;version=7.4.4&amp;amp;externalPlugins=&quot;&gt;は驚くかもしれません&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="f829a0689ccf713644890b1c3b1a4cfc8ad34e87" translate="yes" xml:space="preserve">
          <source>If you iterate over an array with &lt;code&gt;for&lt;/code&gt;..&lt;code&gt;of&lt;/code&gt;, the body of the loop is executed &lt;code&gt;length&lt;/code&gt; times, and the loop control variable is set to &lt;code&gt;undefined&lt;/code&gt; for any items not actually present in the array. Depending on the details of your &quot;do something with&quot; code, that behavior may be what you want, but if not, you should use a different approach.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; .. &lt;code&gt;of&lt;/code&gt; を使用して配列を反復処理すると、ループの本体が &lt;code&gt;length&lt;/code&gt; 回実行され、ループ制御変数は、配列に実際に存在しない項目に対して &lt;code&gt;undefined&lt;/code&gt; に設定されます。 「何かをする」コードの詳細によっては、その振る舞いはあなたが望むものかもしれませんが、そうでない場合は、別のアプローチを使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="6b16cc5e544f97e4c2c7404c40a6b88137b3439b" translate="yes" xml:space="preserve">
          <source>If you want a terse way to write a fast loop &lt;em&gt;and&lt;/em&gt; you can iterate in reverse:</source>
          <target state="translated">高速ループを作成する簡潔な方法が必要で、逆に反復できる場合：</target>
        </trans-unit>
        <trans-unit id="436e7053c19b3557bdfbc7e2a4a3f788195af7aa" translate="yes" xml:space="preserve">
          <source>If you want to use jQuery, it has a nice example in its documentation:</source>
          <target state="translated">jQueryを使いたい場合は、ドキュメントに素敵な例が載っています。</target>
        </trans-unit>
        <trans-unit id="bc55dbfa6cee82874054cf5092582433ac1060f8" translate="yes" xml:space="preserve">
          <source>If you're using the jQuery library, consider using 
&lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt;http://api.jquery.com/jQuery.each/&lt;/a&gt;</source>
          <target state="translated">jQueryライブラリを使用している場合は、 &lt;a href=&quot;http://api.jquery.com/jQuery.each/&quot;&gt;http：//api.jquery.com/jQuery.each/の&lt;/a&gt;使用を検討してください</target>
        </trans-unit>
        <trans-unit id="e36ebcd66de4bbd012f26e5f05e31de1189ca804" translate="yes" xml:space="preserve">
          <source>Ignore it until you need it.</source>
          <target state="translated">必要になるまで無視してください。</target>
        </trans-unit>
        <trans-unit id="810e4fa4821d4188cefc7672710f24bed2a3c1d5" translate="yes" xml:space="preserve">
          <source>Imperative</source>
          <target state="translated">Imperative</target>
        </trans-unit>
        <trans-unit id="583ae6d68b9b829162aa0ace11f35929d9bb4712" translate="yes" xml:space="preserve">
          <source>In Java you can use a &lt;code&gt;for&lt;/code&gt; loop to traverse objects in an array as follows:</source>
          <target state="translated">Javaでは、 &lt;code&gt;for&lt;/code&gt; ループを使用して、次のように配列内のオブジェクトをトラバースできます。</target>
        </trans-unit>
        <trans-unit id="f6d0674a47d5e4c6ee7188e8d56862dcbd6ae33a" translate="yes" xml:space="preserve">
          <source>In JavaScript any custom property could be assigned to any object, including an array.</source>
          <target state="translated">JavaScriptでは、任意のカスタムプロパティを配列を含む任意のオブジェクトに割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="ee17c9f5432f037f208458ad5d51fc6145640287" translate="yes" xml:space="preserve">
          <source>In JavaScript it's not advisable to loop through an Array with a for-in loop, but it's better to use a &lt;code&gt;for&lt;/code&gt; loop such as:</source>
          <target state="translated">JavaScriptでは、for-inループで配列をループすることはお勧めできませんが、次のような &lt;code&gt;for&lt;/code&gt; ループを使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="1affd76d51cbc1ab4da5924b815463734ac0f427" translate="yes" xml:space="preserve">
          <source>In JavaScript, there are so many solutions to loop an array.</source>
          <target state="translated">JavaScriptでは、配列をループさせるための解決策が非常に多くあります。</target>
        </trans-unit>
        <trans-unit id="509626629442545fa142bc6b90e393ef90bfd1d2" translate="yes" xml:space="preserve">
          <source>In JavaScript, you can also do this:</source>
          <target state="translated">JavaScriptでは、こんなこともできます。</target>
        </trans-unit>
        <trans-unit id="bc5977a0c215f5a97db26f12ccd984993cb76e07" translate="yes" xml:space="preserve">
          <source>In a browser console, you can see something like &quot;element1&quot;, &quot;element2&quot;, etc., printed.</source>
          <target state="translated">ブラウザのコンソールでは、「element1」「element2」などのようなものが印刷されています。</target>
        </trans-unit>
        <trans-unit id="f8cdbcc1ec9b2f241eea1c7f52b02c03840b2a13" translate="yes" xml:space="preserve">
          <source>In general &lt;code&gt;func&lt;/code&gt; would take one parameter, which is an item of the array. But in the case of JavaScript, it can take a second parameter which is the item's index, and a third parameter which is the array itself.</source>
          <target state="translated">一般に、 &lt;code&gt;func&lt;/code&gt; は1つのパラメーター（配列の項目）を取ります。 ただし、JavaScriptの場合は、アイテムのインデックスである2番目のパラメーターと、配列自体である3番目のパラメーターを使用できます。</target>
        </trans-unit>
        <trans-unit id="fd0e1873da03f1238cdcd8d46e69b571337886d4" translate="yes" xml:space="preserve">
          <source>In the above example, the &lt;code&gt;hasOwnProperty&lt;/code&gt; method allows you to enumerate only &lt;em&gt;own properties&lt;/em&gt;, that's it, only the properties that the object physically has, no inherited properties.</source>
          <target state="translated">上記の例では、 &lt;code&gt;hasOwnProperty&lt;/code&gt; メソッドを使用すると、 &lt;em&gt;自身のプロパティ&lt;/em&gt;のみを列挙できます。つまり、オブジェクトが物理的に持っている&lt;em&gt;プロパティ&lt;/em&gt;のみを列挙でき、継承されたプロパティはありません。</target>
        </trans-unit>
        <trans-unit id="731f9b52cf3864b4e845afc26f5823a015b6f718" translate="yes" xml:space="preserve">
          <source>Inherited properties are also enumerated.</source>
          <target state="translated">継承されたプロパティも列挙されます。</target>
        </trans-unit>
        <trans-unit id="b4e6a310890f62289340d7802703b8c2586c6d86" translate="yes" xml:space="preserve">
          <source>Intro</source>
          <target state="translated">Intro</target>
        </trans-unit>
        <trans-unit id="6371b79462d66a07f6e9b72523ff8fb46bd76993" translate="yes" xml:space="preserve">
          <source>It also means you'll never have to write a for loop again.</source>
          <target state="translated">また、二度とforループを書く必要がないことも意味しています。</target>
        </trans-unit>
        <trans-unit id="4d5482c75593dd4638959de0178a2d6ee6f654e4" translate="yes" xml:space="preserve">
          <source>It also works on Node (I tested it on version 0.12.0).</source>
          <target state="translated">Nodeでも動作します(バージョン0.12.0でテストしました)。</target>
        </trans-unit>
        <trans-unit id="c7afdd2fab1fe4c50035aa8b7a97f2ca3d7a8fe9" translate="yes" xml:space="preserve">
          <source>It can iterate over a large variety of objects.</source>
          <target state="translated">多種多様なオブジェクトを反復処理することができます。</target>
        </trans-unit>
        <trans-unit id="f5e0298a8f63b40bf1dbd95d72b4565988c2bb43" translate="yes" xml:space="preserve">
          <source>It currently works with Firefox 13+, Chrome 37+ and it does not natively work with other browsers (see browser compatibility below). Luckily we have JS compilers (such as &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;) that allow us to use next-generation features today.</source>
          <target state="translated">現在、Firefox 13以降、Chrome 37以降で動作し、他のブラウザーではネイティブで動作しません（以下のブラウザーの互換性を参照）。 幸いなことに、今日の次世代機能を使用できるJSコンパイラー（ &lt;a href=&quot;https://babeljs.io/&quot;&gt;Babel&lt;/a&gt;など）があります。</target>
        </trans-unit>
        <trans-unit id="b7f1e474a3cbb522e7737b4c41a0e6c6aa40d314" translate="yes" xml:space="preserve">
          <source>It shouldn't be used for array-like objects because:</source>
          <target state="translated">配列的なものには使うべきではないからです。</target>
        </trans-unit>
        <trans-unit id="618aee3ec871071cafa5f2c415e6c3ad428f6c63" translate="yes" xml:space="preserve">
          <source>It works like this:</source>
          <target state="translated">このように動作します。</target>
        </trans-unit>
        <trans-unit id="729fd72bc10f5b53441cfd34a43c99d234bed82b" translate="yes" xml:space="preserve">
          <source>It's not 100% identical, but similar:</source>
          <target state="translated">100%同じではないが、似ている。</target>
        </trans-unit>
        <trans-unit id="d2c98a7efcec06920db9cb117bd433708798538f" translate="yes" xml:space="preserve">
          <source>It's optimized as well (&quot;caching&quot; the array length). If you'd like to learn more, &lt;a href=&quot;http://blog.sebarmeli.com/2010/12/06/best-way-to-loop-through-an-array-in-javascript/&quot;&gt;read my post on the subject&lt;/a&gt;.</source>
          <target state="translated">それも最適化されています（配列の長さを「キャッシュ」）。 詳細&lt;a href=&quot;http://blog.sebarmeli.com/2010/12/06/best-way-to-loop-through-an-array-in-javascript/&quot;&gt;については、件名に関する私の投稿を&lt;/a&gt;ご覧ください 。</target>
        </trans-unit>
        <trans-unit id="46a98fc5f1adbc9ced665ed928468799beb685aa" translate="yes" xml:space="preserve">
          <source>It's short to write</source>
          <target state="translated">書くには短い</target>
        </trans-unit>
        <trans-unit id="b67411757f4baa65933449ae3c433b43e33a3bec" translate="yes" xml:space="preserve">
          <source>Keep in mind if you are iterating an array &lt;em&gt;to build another array from it&lt;/em&gt;, you should use &lt;code&gt;map&lt;/code&gt;, I've seen this anti-pattern so many times.</source>
          <target state="translated">配列&lt;em&gt;を&lt;/em&gt;繰り返して&lt;em&gt;別の&lt;/em&gt;配列&lt;em&gt;を作成する&lt;/em&gt;場合は、 &lt;code&gt;map&lt;/code&gt; を使用する必要があることに注意してください。このアンチパターンは何度も見たことがあります。</target>
        </trans-unit>
        <trans-unit id="27c968e6692b41bf6e1a241b870dc41ff1a51b17" translate="yes" xml:space="preserve">
          <source>Libraries</source>
          <target state="translated">Libraries</target>
        </trans-unit>
        <trans-unit id="a3c5490fc48c1e07b7f4efa147aa56f508ce53b0" translate="yes" xml:space="preserve">
          <source>Like traditional &lt;code&gt;for&lt;/code&gt; loops, &lt;code&gt;while&lt;/code&gt; loops are supported by even the oldest of browsers.</source>
          <target state="translated">従来の &lt;code&gt;for&lt;/code&gt; ループのように &lt;code&gt;while&lt;/code&gt; ループは最も古いブラウザーでもサポートされています。</target>
        </trans-unit>
        <trans-unit id="cead623be3ff7a811535895bde64a1c14f83edd4" translate="yes" xml:space="preserve">
          <source>Loop through an array in JavaScript</source>
          <target state="translated">JavaScriptで配列をループする</target>
        </trans-unit>
        <trans-unit id="43395e0915b2f80810ff1d9bf284e72478f3a7d9" translate="yes" xml:space="preserve">
          <source>Modern browsers all support iterator methods &lt;code&gt;forEach&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt; and a host of other methods on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array?redirectlocale=en-US&amp;amp;redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray&quot;&gt;Array prototype&lt;/a&gt;.</source>
          <target state="translated">最新のブラウザはすべて、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array?redirectlocale=en-US&amp;amp;redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FArray&quot;&gt;Arrayプロトタイプ&lt;/a&gt;で、 &lt;code&gt;forEach&lt;/code&gt; 、 &lt;code&gt;map&lt;/code&gt; 、 &lt;code&gt;reduce&lt;/code&gt; 、 &lt;code&gt;filter&lt;/code&gt; 、およびその他のホストのイテレータメソッドをサポートしています。</target>
        </trans-unit>
        <trans-unit id="413b0f0902d335e117f52bb6f630c916500b39e6" translate="yes" xml:space="preserve">
          <source>Most other answers are right, but they do not mention (as of this writing) that &lt;strong&gt;&lt;em&gt;ECMA Script &lt;strike&gt;&amp;nbsp;6&amp;nbsp;&lt;/strike&gt; 2015&lt;/em&gt;&lt;/strong&gt; is bringing a new mechanism for doing iteration, the &lt;strong&gt;&lt;code&gt;for..of&lt;/code&gt;&lt;/strong&gt; loop.</source>
          <target state="translated">他のほとんどの答えは正しいですが、 &lt;strong&gt;&lt;em&gt;ECMA Script &lt;strike&gt;6&lt;/strike&gt; 2015&lt;/em&gt;&lt;/strong&gt;が反復を実行するための新しいメカニズムである&lt;strong&gt; &lt;code&gt;for..of&lt;/code&gt; &lt;/strong&gt;ループをもたらすことについては（この記事の執筆時点では）言及されていません。</target>
        </trans-unit>
        <trans-unit id="5aa5faa92650187f67128950cd34998418f5d033" translate="yes" xml:space="preserve">
          <source>Mozilla Labs published the algorithms they and &lt;a href=&quot;http://en.wikipedia.org/wiki/WebKit&quot;&gt;WebKit&lt;/a&gt; both use, so that you can add them yourself.</source>
          <target state="translated">Mozilla Labsは、彼らと&lt;a href=&quot;http://en.wikipedia.org/wiki/WebKit&quot;&gt;WebKitの&lt;/a&gt;両方が使用するアルゴリズムを公開したので、自分で追加できます。</target>
        </trans-unit>
        <trans-unit id="6bbeedb096ad8a164494e42f681d03f151eee20a" translate="yes" xml:space="preserve">
          <source>No need to access (let alone cache) the length property</source>
          <target state="translated">長さのプロパティにアクセスする必要がない(キャッシュする必要もない)。</target>
        </trans-unit>
        <trans-unit id="b43994d34a5fafb7a2888982d67dca097a47a6e9" translate="yes" xml:space="preserve">
          <source>Normally, you can replace the need to &lt;code&gt;break&lt;/code&gt; out of imperative loops by filtering the array elements before iterating them, for example:</source>
          <target state="translated">通常は、配列要素を反復する前にフィルター処理することにより、命令ループから抜け出す必要性を置き換えることができます。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="2db2fe69d40d3ac34eb0e35f52345d0c2815a956" translate="yes" xml:space="preserve">
          <source>Note that each of these variations is supported by all browsers, including very very old ones!</source>
          <target state="translated">これらのバリエーションは、非常に古いものも含めて、すべてのブラウザでサポートされていることに注意してください!</target>
        </trans-unit>
        <trans-unit id="6c66070e97cce40670c4441191c44bf18838f842" translate="yes" xml:space="preserve">
          <source>Note: Array.prototype.forEach() is not a functional way strictly speaking, as the function it takes as the input parameter is not supposed to return a value, which thus cannot be regarded as a pure function.</source>
          <target state="translated">注意:Array.prototype.forEach()は、厳密には関数的な方法ではありません。</target>
        </trans-unit>
        <trans-unit id="48c966f09aa17b29b9fe064c727a02146da0e40e" translate="yes" xml:space="preserve">
          <source>Note: The filter() method creates a new array with all elements that pass the test implemented by the provided function.</source>
          <target state="translated">注意:filter()メソッドは、指定された関数で実装されたテストに合格したすべての要素を含む新しい配列を作成します。</target>
        </trans-unit>
        <trans-unit id="f1ea81216c8103826ec20066099e66d7123126d6" translate="yes" xml:space="preserve">
          <source>Note: The map() method creates a new array with the results of calling a provided function on every element in the calling array.</source>
          <target state="translated">注意:map()メソッドは、呼び出した配列の各要素に対して指定された関数を呼び出した結果を含む新しい配列を作成します。</target>
        </trans-unit>
        <trans-unit id="8bd4bead091ec61c5177a79b36d340f39f2358e7" translate="yes" xml:space="preserve">
          <source>Object loop:</source>
          <target state="translated">オブジェクトループ。</target>
        </trans-unit>
        <trans-unit id="56974c9d7b50d25064ed413fbfe2b4b0f72cd469" translate="yes" xml:space="preserve">
          <source>Of course, some developers have no choice but to use a different approach anyway, because for whatever reason they're targeting a version of JavaScript that doesn't yet support &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt;.</source>
          <target state="translated">もちろん、一部の開発者はとにかく別のアプローチを使用せざるを得ません。理由は何であれ、彼らは... &lt;code&gt;of&lt;/code&gt; まだサポート &lt;code&gt;for&lt;/code&gt; ていないJavaScriptのバージョンをターゲットにしているからです。</target>
        </trans-unit>
        <trans-unit id="6f7be3080abd7fd806f8e09c93803d1cd5f9c625" translate="yes" xml:space="preserve">
          <source>Of course, you will need to include an &lt;code&gt;if(condition === true) { break; }&lt;/code&gt;  or an &lt;code&gt;if(condition === true) { return; }&lt;/code&gt; somewhere inside that &lt;code&gt;for&lt;/code&gt;-loop to get it to stop running.</source>
          <target state="translated">もちろん、 &lt;code&gt;if(condition === true) { break; }&lt;/code&gt; を含める必要があります。 }または &lt;code&gt;if(condition === true) { return; }&lt;/code&gt; } &lt;code&gt;for&lt;/code&gt; ループ内のどこかで、実行を停止します。</target>
        </trans-unit>
        <trans-unit id="f2fe9d42eb2f2a746517eaff1ec734422f1cc4c5" translate="yes" xml:space="preserve">
          <source>One advantage of this approach is that you can choose how to handle sparse arrays; the above code will run the body of the loop the full &lt;code&gt;length&lt;/code&gt; times, with &lt;code&gt;s&lt;/code&gt; set to &lt;code&gt;undefined&lt;/code&gt; for any missing elements, just like &lt;code&gt;for&lt;/code&gt;..&lt;code&gt;of&lt;/code&gt;. If you instead want to handle only the actually-present elements of a sparse array, like &lt;code&gt;.forEach&lt;/code&gt;, you can add a simple &lt;code&gt;in&lt;/code&gt; test on the index:</source>
          <target state="translated">このアプローチの利点の1つは、スパース配列の処理方法を選択できることです。 上記のコードは、ループの本体を &lt;code&gt;length&lt;/code&gt; にわたって実行し、.. &lt;code&gt;of&lt;/code&gt; の場合と同様 &lt;code&gt;for&lt;/code&gt; 、不足している要素に対して &lt;code&gt;s&lt;/code&gt; を &lt;code&gt;undefined&lt;/code&gt; に設定します。 代わりに、 &lt;code&gt;.forEach&lt;/code&gt; のように疎な配列の実際に存在する要素のみを処理したい場合は、インデックスに簡単なテストを追加できます。</target>
        </trans-unit>
        <trans-unit id="53e75cdb29c5599821ebe5805040c469e93077fc" translate="yes" xml:space="preserve">
          <source>One alternative to a &lt;code&gt;for&lt;/code&gt; loop is a &lt;code&gt;while&lt;/code&gt; loop. To loop through an array, you could do this:</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ループの代わりの1つは、 &lt;code&gt;while&lt;/code&gt; ループです。 配列をループするには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="4b514468264056e4b37a5ab372a4a7f951732f97" translate="yes" xml:space="preserve">
          <source>One of the cornerstones of functional programming is its special use
  of lists and list operations. And those things are exactly what the
  sound like they are: arrays of things, and the stuff you do to them.
  But the functional mindset treats them a bit differently than you
  might expect.</source>
          <target state="translated">関数型プログラミングの基礎の一つは、リストとリスト操作を特別に使うことです。リストとはその名の通り、物の配列であり、それらに何かをするというものです。しかし、関数型マインドセットでは、あなたが予想しているよりも少し違った扱い方をします。</target>
        </trans-unit>
        <trans-unit id="d921e30036a4651e6d150723a2bd7418fc2d461a" translate="yes" xml:space="preserve">
          <source>Opera, Safari, Firefox and Chrome now all share a set of enhanced Array methods for optimizing many common loops.</source>
          <target state="translated">Opera、Safari、Firefox、Chromeでは、多くの共通ループを最適化するための強化された配列メソッドのセットを共有するようになりました。</target>
        </trans-unit>
        <trans-unit id="ca8a7183a1dbcea77d8631814b5189f7eab564fd" translate="yes" xml:space="preserve">
          <source>Or &lt;code&gt;Array.prototype.map(...)&lt;/code&gt;:</source>
          <target state="translated">または &lt;code&gt;Array.prototype.map(...)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="005deeedccad31f3cb0e80bfb7abb31fa65ed57a" translate="yes" xml:space="preserve">
          <source>Or better yet, since ECMAScript 2015 also provides block-scoped variables:</source>
          <target state="translated">あるいは、ECMAScript 2015でもブロック指定された変数を提供しているので、もっといいかもしれません。</target>
        </trans-unit>
        <trans-unit id="3b1a4912a2f639abf4e7d8c472de81016ac92f24" translate="yes" xml:space="preserve">
          <source>Or if you really want to get the id and have a really classical &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">または、本当にidを取得して、本当に古典的な &lt;code&gt;for&lt;/code&gt; ループが欲しい場合：</target>
        </trans-unit>
        <trans-unit id="79c19d1215e0ee61dae1d54feb9eb528038ad845" translate="yes" xml:space="preserve">
          <source>Or the classical &lt;code&gt;for&lt;/code&gt; loop</source>
          <target state="translated">または古典的な &lt;code&gt;for&lt;/code&gt; ループ</target>
        </trans-unit>
        <trans-unit id="32ccf4631124f74fd174f7f90959d3e3a755fb56" translate="yes" xml:space="preserve">
          <source>Or the jquery or for loop ways previously mentioned.</source>
          <target state="translated">または以前に述べたjqueryやfor loopの方法。</target>
        </trans-unit>
        <trans-unit id="6adbea7e0ac9ed37ed0deb0bb73dcd3e28cf819b" translate="yes" xml:space="preserve">
          <source>Or, if you prefer to loop backwards, you do this:</source>
          <target state="translated">あるいは、逆にループするのが好きなら、こうする。</target>
        </trans-unit>
        <trans-unit id="ae203c504aa70b4f28a5fcf1b9fe9229ed76072b" translate="yes" xml:space="preserve">
          <source>Read more&amp;gt;&amp;gt; &lt;a href=&quot;https://code.tutsplus.com/tutorials/how-to-use-map-filter-reduce-in-javascript--cms-26209&quot;&gt;here&lt;/a&gt;:</source>
          <target state="translated">詳細はこちら&amp;gt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e609697c319d4d3a9d1b473f48e1e2bd07f35c6e" translate="yes" xml:space="preserve">
          <source>Reference:
&lt;a href=&quot;http://www.sitepoint.com/google-closure-how-not-to-write-javascript/&quot;&gt;http://www.sitepoint.com/google-closure-how-not-to-write-javascript/&lt;/a&gt;</source>
          <target state="translated">Reference:
&lt;a href=&quot;http://www.sitepoint.com/google-closure-how-not-to-write-javascript/&quot;&gt;http://www.sitepoint.com/google-closure-how-not-to-write-javascript/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="335e1e090424cc3a93596596d66cb2973f851a68" translate="yes" xml:space="preserve">
          <source>See this JsFiddle demonstrating that: &lt;a href=&quot;http://jsfiddle.net/prvzk/&quot;&gt;http://jsfiddle.net/prvzk/&lt;/a&gt;</source>
          <target state="translated">次のJsFiddleのデモを参照してください。http：//jsfiddle.net/prvzk/</target>
        </trans-unit>
        <trans-unit id="a5dda3b31ff4955adf83bd52382ef45bc3ffb11e" translate="yes" xml:space="preserve">
          <source>Short answer: yes. You can do with this:</source>
          <target state="translated">簡潔に言うと、そうです。これがあれば大丈夫です。</target>
        </trans-unit>
        <trans-unit id="548e1e621f5c9ad33722194d1a9b4a9c024a7f02" translate="yes" xml:space="preserve">
          <source>Since my time in college, I've programmed in Java, JavaScript, Pascal, &lt;a href=&quot;https://en.wikipedia.org/wiki/ABAP&quot;&gt;ABAP&lt;/a&gt;, PHP, Progress 4GL, C/C++ and possibly a few other languages I can't think of right now.</source>
          <target state="translated">大学時代から、Java、JavaScript、Pascal、 &lt;a href=&quot;https://en.wikipedia.org/wiki/ABAP&quot;&gt;ABAP&lt;/a&gt; 、PHP、Progress 4GL、C / C ++、そして今は考えられない他のいくつかの言語でプログラミングを行ってきました。</target>
        </trans-unit>
        <trans-unit id="b22093b0b2c9e3acc2f551744f9b589053dde63a" translate="yes" xml:space="preserve">
          <source>So as others has suggested, this is almost always what you want:</source>
          <target state="translated">だから、他の人が提案しているように、これはほとんどの場合、あなたが望むものです。</target>
        </trans-unit>
        <trans-unit id="47218d7f66b567477c470edc472c6fd416fbed47" translate="yes" xml:space="preserve">
          <source>Some use cases of looping through an array in &lt;strong&gt;the functional programming way&lt;/strong&gt; in JavaScript:</source>
          <target state="translated">JavaScriptの&lt;strong&gt;関数型プログラミングの方法&lt;/strong&gt;で配列をループするいくつかの使用例：</target>
        </trans-unit>
        <trans-unit id="432979a6e491e22397882fad2d457b66217225b1" translate="yes" xml:space="preserve">
          <source>Spread syntax</source>
          <target state="translated">スプレッド構文</target>
        </trans-unit>
        <trans-unit id="df9af125634fddcfa421be704540115f6f1acfd0" translate="yes" xml:space="preserve">
          <source>That be particularly a problem if you use some library that relies heavily on native prototypes augmentation (such as MooTools, for example).</source>
          <target state="translated">特に、ネイティブ・プロトタイプの拡張に大きく依存しているライブラリ(例えば、MooToolsなど)を使用している場合には、問題となります。</target>
        </trans-unit>
        <trans-unit id="54be33a5edebe447d19ad8769464cdbc36772505" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$.each()&lt;/code&gt; function is not the same as &lt;code&gt;$(selector).each()&lt;/code&gt;, which is
  used to iterate, exclusively, over a jQuery object. The &lt;code&gt;$.each()&lt;/code&gt;
  function can be used to iterate over any collection, whether it is a
  map (JavaScript object) or an array. In the case of an array, the
  callback is passed an array index and a corresponding array value each
  time. (The value can also be accessed through the &lt;code&gt;this&lt;/code&gt; keyword, but
  Javascript will always wrap the &lt;code&gt;this&lt;/code&gt; value as an &lt;code&gt;Object&lt;/code&gt; even if it is
  a simple string or number value.) The method returns its first
  argument, the object that was iterated.</source>
          <target state="translated">&lt;code&gt;$.each()&lt;/code&gt; 関数は、jQueryオブジェクトに対して排他的に反復するために使用される &lt;code&gt;$(selector).each()&lt;/code&gt; と同じではありません。 &lt;code&gt;$.each()&lt;/code&gt; 関数を使用して、マップ（JavaScriptオブジェクト）でも配列でも、コレクションを反復処理できます。 配列の場合、コールバックには配列インデックスと対応する配列値が毎回渡されます。 （値には &lt;code&gt;this&lt;/code&gt; キーワードを介してアクセスすることもできますが、JavaScriptは単純な文字列または数値の値であっても、常に &lt;code&gt;this&lt;/code&gt; 値を &lt;code&gt;Object&lt;/code&gt; としてラップします。）メソッドは最初の引数、反復されたオブジェクトを返します。</target>
        </trans-unit>
        <trans-unit id="8ea2d26897d80b2a11e7991048566fdf9f71aa64" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Array.prototype.forEach()&lt;/code&gt; and the &lt;code&gt;Array.prototype.map()&lt;/code&gt; methods are the slowest approximations, probably as a consequence of the &lt;strong&gt;function call overhead&lt;/strong&gt;.</source>
          <target state="translated">&lt;code&gt;Array.prototype.forEach()&lt;/code&gt; および &lt;code&gt;Array.prototype.map()&lt;/code&gt; メソッドは、おそらく&lt;strong&gt;関数呼び出しのオーバーヘッドの&lt;/strong&gt;結果として、最も遅い近似です。</target>
        </trans-unit>
        <trans-unit id="fda48303e825923d88d3e1a5954e2f9a8d32ffe0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for-in&lt;/code&gt; statement as I said before is there to &lt;em&gt;enumerate&lt;/em&gt; object properties, for example:</source>
          <target state="translated">前に言った &lt;code&gt;for-in&lt;/code&gt; ステートメントは、オブジェクトのプロパティを&lt;em&gt;列挙&lt;/em&gt;するためのものです。たとえば、次のようになります。</target>
        </trans-unit>
        <trans-unit id="152a30a782355db0c98586aa6609e918220ba9f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; syntax mentioned by others is for looping over an object's properties; since an Array in JavaScript is just an object with numeric property names (and an automatically-updated &lt;code&gt;length&lt;/code&gt; property), you can theoretically loop over an Array with it.  But the problem is that it doesn't restrict itself to the numeric property values (remember that even methods are actually just properties whose value is a closure), nor is it guaranteed to iterate over those in numeric order. Therefore, the &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;in&lt;/code&gt; syntax should &lt;em&gt;not&lt;/em&gt; be used for looping through Arrays.</source>
          <target state="translated">他の人が言及し &lt;code&gt;in&lt;/code&gt; 構文の &lt;code&gt;for&lt;/code&gt; ... は 、オブジェクトのプロパティをループするためのものです。 JavaScriptの配列は、数値のプロパティ名（および自動的に更新 &lt;code&gt;length&lt;/code&gt; れる長さのプロパティ）を持つ単なるオブジェクトなので、理論的には配列でループできます。 しかし、問題はそれ自体が数値のプロパティ値に制限されないことです（メソッドでさえ、実際には値がクロージャであるプロパティにすぎないことに注意してください）。また、数値順にそれらを反復することが保証されていません。 したがって、 &lt;code&gt;for&lt;/code&gt; ...構文を配列のループに使用し&lt;em&gt;ない&lt;/em&gt;でください。</target>
        </trans-unit>
        <trans-unit id="a23f5eb2e341872f8d38000e5c4b5bc2354d1e00" translate="yes" xml:space="preserve">
          <source>The Array.prototype.find() method returns the value of the first element in the array that satisfies the provided testing function.</source>
          <target state="translated">Array.prototype.find()メソッドは、与えられたテスト関数を満たす配列の最初の要素の値を返す。</target>
        </trans-unit>
        <trans-unit id="9449fcbdbeae06e7e3bf08650fe52c6575a5e23e" translate="yes" xml:space="preserve">
          <source>The ES5 specification introduced a lot of beneficial array methods, one of them, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;Array.prototype.forEach&lt;/code&gt;&lt;/a&gt; and it gives us a concise way to iterate over an array:</source>
          <target state="translated">ES5仕様では、多くの有益な配列メソッドが導入されました。そのうちの1つである&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;Array.prototype.forEach&lt;/code&gt; &lt;/a&gt;は、配列を反復する簡潔な方法を提供します。</target>
        </trans-unit>
        <trans-unit id="7a8e9910c4deb87c8767f0cacf582f5a16708e6e" translate="yes" xml:space="preserve">
          <source>The ES6 standard introduces the concept of iterable objects and defines a new construct for traversing data, the &lt;code&gt;for...of&lt;/code&gt; statement.</source>
          <target state="translated">ES6標準では、反復可能なオブジェクトの概念が導入され、データをトラバースするための新しい構成である &lt;code&gt;for...of&lt;/code&gt; ステートメントが定義されています 。</target>
        </trans-unit>
        <trans-unit id="1460f02e0a3102d7e55e91533998fc51f18928be" translate="yes" xml:space="preserve">
          <source>The above code will console log &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, and &quot;foo!&quot;.</source>
          <target state="translated">上記のコードでは、コンソールで &quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;foo!</target>
        </trans-unit>
        <trans-unit id="20e7432fb4c054b1e1c467a38410fe6525f14155" translate="yes" xml:space="preserve">
          <source>The best way in my opinion is to use the Array.forEach function. If you cannot use that I would suggest to get the polyfill from MDN. To make it available, it is certainly the safest way to iterate over an array in JavaScript.</source>
          <target state="translated">私の考えでは、Array.forEach関数を使うのが一番良い方法だと思います。もしそれが使えない場合は、MDNからポリフィルを入手することをお勧めします。それを利用できるようにするには、JavaScriptで配列を反復処理するのが最も安全な方法であることは間違いありません。</target>
        </trans-unit>
        <trans-unit id="e56ca3c4eed21e096e43d29badb2c6a655f1f880" translate="yes" xml:space="preserve">
          <source>The code below are popular ones</source>
          <target state="translated">以下のコードは人気のあるものです。</target>
        </trans-unit>
        <trans-unit id="120e5e39e34ca15870d8e9947bbcca2f43399e04" translate="yes" xml:space="preserve">
          <source>The explicit counting loop also means you have access to the index of each value, should you want it. The index is also passed as an extra parameter to the function you pass to &lt;code&gt;forEach&lt;/code&gt;, so you can access it that way as well:</source>
          <target state="translated">明示的なカウントループは、必要に応じて各値のインデックスにアクセスできることも意味します。 インデックスは、 &lt;code&gt;forEach&lt;/code&gt; に渡す関数に追加のパラメーターとしても渡されるため、そのようにアクセスすることもできます。</target>
        </trans-unit>
        <trans-unit id="0926024be90fc3c5c58f79ca38b539c92713c68c" translate="yes" xml:space="preserve">
          <source>The final option, which works in &lt;em&gt;all&lt;/em&gt; versions of JavaScript, is &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-for-statement&quot;&gt;an explicit counting loop&lt;/a&gt;. You simply count from 0 up to one less than the length and use the counter as an index. The basic loop looks like this:</source>
          <target state="translated">JavaScriptの&lt;em&gt;すべての&lt;/em&gt;バージョンで機能する最後のオプションは&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-for-statement&quot;&gt;、明示的なカウントループ&lt;/a&gt;です。 単純に0から長さより1少ない数までカウントし、カウンターをインデックスとして使用します。 基本的なループは次のようになります。</target>
        </trans-unit>
        <trans-unit id="60de89b60699f6e1c50c9980fe4030ebfed381c1" translate="yes" xml:space="preserve">
          <source>The general syntax is:</source>
          <target state="translated">一般的な構文は</target>
        </trans-unit>
        <trans-unit id="17c0c8958009504035837eb96e313e38d6db28cb" translate="yes" xml:space="preserve">
          <source>The item to access is automatically defined within the loop
body under the name you pick.</source>
          <target state="translated">アクセスする項目は、ループボディ内で選択した名前で自動的に定義されます。</target>
        </trans-unit>
        <trans-unit id="cc1a1ebcb7c44366d847d9e53142c469f5d9c912" translate="yes" xml:space="preserve">
          <source>The most elegant and fast way</source>
          <target state="translated">最もエレガントで早い方法</target>
        </trans-unit>
        <trans-unit id="92bc9c3030690e8975c93e43b9783b47f78cf220" translate="yes" xml:space="preserve">
          <source>The optimized approach is to cache the length of array and using single var pattern initializing all variables with single var keyword.</source>
          <target state="translated">最適化されたアプローチは、配列の長さをキャッシュし、単一の var パターンを使用して単一の var キーワードですべての変数を初期化することです。</target>
        </trans-unit>
        <trans-unit id="2c0c58f394bd4d6864165f51bcf38373ab49434a" translate="yes" xml:space="preserve">
          <source>The order of iteration is not guaranteed; the array indexes may not be visited in numeric order.</source>
          <target state="translated">反復の順序は保証されていません.配列のインデックスは数値順ではないかもしれません.</target>
        </trans-unit>
        <trans-unit id="012e8483413b382c220340edf31b6450777efdd6" translate="yes" xml:space="preserve">
          <source>The reason this works is that the array specification mandates that when you read an item from an index &amp;gt;= the array's length, it will return undefined. When you write to such a location it will actually update the length.</source>
          <target state="translated">これが機能する理由は、配列の仕様により、インデックスから項目を読み取ったときに、配列の長さが&amp;gt; =未定義を返すことが義務付けられているためです。 このような場所に書き込むと、実際には長さが更新されます。</target>
        </trans-unit>
        <trans-unit id="ef3a7c0b59ad4734159dbd0581cc34ca59a58ff9" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;array.map&lt;/code&gt; is another array, so you can use it like this:</source>
          <target state="translated">&lt;code&gt;array.map&lt;/code&gt; の戻り値は別の配列なので、次のように使用できます。</target>
        </trans-unit>
        <trans-unit id="b97bcfaafee942ef6523ce737efbb4b975437cc7" translate="yes" xml:space="preserve">
          <source>The second point is that it can give you a lot of problems, for example, if you extend the &lt;code&gt;Array.prototype&lt;/code&gt; object to include a method there, that property will also be enumerated.</source>
          <target state="translated">2つ目のポイントは、多くの問題が発生する可能性があることです。たとえば、 &lt;code&gt;Array.prototype&lt;/code&gt; オブジェクトを拡張してそこにメソッドを含めると、そのプロパティも列挙されます。</target>
        </trans-unit>
        <trans-unit id="2f3b6cf1d6f0a6bbd74a70887a856a51c87bff3f" translate="yes" xml:space="preserve">
          <source>The traditional &lt;code&gt;for()&lt;/code&gt; iterator, is by far the fastest method, especially when used with the &lt;strong&gt;array length cached&lt;/strong&gt;.</source>
          <target state="translated">従来の &lt;code&gt;for()&lt;/code&gt; イテレータは、特に&lt;strong&gt;配列の長さをcachedで&lt;/strong&gt;使用した場合、断然最速の方法です。</target>
        </trans-unit>
        <trans-unit id="50fbe4e2839ad6f44353c11db5662956a1245813" translate="yes" xml:space="preserve">
          <source>The traditional way to loop through an array, is this:</source>
          <target state="translated">配列をループする伝統的な方法は、これです。</target>
        </trans-unit>
        <trans-unit id="bb52b2247ddc21d02d48c2330829d7a1e4b3b066" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to do it in JavaScript. The first two examples are JavaScript samples. The third one makes use of a JavaScript library, that is, jQuery making use of the &lt;code&gt;.each()&lt;/code&gt; function.</source>
          <target state="translated">JavaScriptでこれを行うにはいくつかの方法があります。 最初の2つの例はJavaScriptサンプルです。 3つ目は、JavaScriptライブラリを使用します。 &lt;code&gt;.each()&lt;/code&gt; 、 jeachは.each（）関数を使用します。</target>
        </trans-unit>
        <trans-unit id="821b43d0758dd02be5cc2c03df6009934ba6b2d6" translate="yes" xml:space="preserve">
          <source>There are even some times when you ought to iterate in reverse, such as when iterating over a &lt;a href=&quot;https://developer.mozilla.org/En/DOM/NodeList#A_.22live.22_collection&quot;&gt;live NodeList&lt;/a&gt; where you plan on removing items from the DOM during iteration.</source>
          <target state="translated">イテレーション中にDOMからアイテムを削除することを計画している&lt;a href=&quot;https://developer.mozilla.org/En/DOM/NodeList#A_.22live.22_collection&quot;&gt;ライブNodeListを&lt;/a&gt;反復する場合など、逆方向に反復する必要がある場合もあります。</target>
        </trans-unit>
        <trans-unit id="42b051646813473214bb6d4ec6b04940890f97b1" translate="yes" xml:space="preserve">
          <source>There are various way to loop through array in JavaScript.</source>
          <target state="translated">JavaScriptで配列をループさせる方法はいろいろあります。</target>
        </trans-unit>
        <trans-unit id="9a2a3b9ff7b68f4ca1407027573f3d1e36d2a264" translate="yes" xml:space="preserve">
          <source>There are, however, many variations possible, like for example this one:</source>
          <target state="translated">しかし、このように多くのバリエーションが考えられます。</target>
        </trans-unit>
        <trans-unit id="3b17947ce13f291d24a94bf37cd447dbd1a3770b" translate="yes" xml:space="preserve">
          <source>There is a way to do it where you have very little implicit scope in your loop and do away with extra variables.</source>
          <target state="translated">ループ内の暗黙のスコープをほとんど持たず、余分な変数を使わずに済む方法があります。</target>
        </trans-unit>
        <trans-unit id="9a66ce7f5fe432814094ad577cba1eca94e88388" translate="yes" xml:space="preserve">
          <source>There's a method to iterate over only own object properties, not including prototype's ones:</source>
          <target state="translated">プロトタイプのプロパティを含めずに、自分のオブジェクトのプロパティだけを反復処理する方法があります。</target>
        </trans-unit>
        <trans-unit id="3d2f0aa297c7272c064273bd7ad8226e3a64443e" translate="yes" xml:space="preserve">
          <source>These are the main ways to do JavaScript loops, but there are a few more ways to do that.</source>
          <target state="translated">以上がJavaScriptのループを行う主な方法ですが、他にもいくつかの方法があります。</target>
        </trans-unit>
        <trans-unit id="a685720d851d92a20d19c2df920471064cf168c9" translate="yes" xml:space="preserve">
          <source>These are the solutions:</source>
          <target state="translated">これらが解決策です。</target>
        </trans-unit>
        <trans-unit id="71b65affe9fa82e82de8abd8e0d75c26d06af598" translate="yes" xml:space="preserve">
          <source>These methods all take a function for their first argument and have an optional second argument, which is an object whose scope you want to impose on the array members as they loop through the function.</source>
          <target state="translated">これらのメソッドはすべて第一引数に関数を取り、オプションの第二引数を持ちます。</target>
        </trans-unit>
        <trans-unit id="80ad30aab31c43f396831f915032145053204ac5" translate="yes" xml:space="preserve">
          <source>These three components are separated from each other by a &lt;code&gt;;&lt;/code&gt; symbol. Content for each of these three components is optional, which means that the following is the most minimal &lt;code&gt;for&lt;/code&gt; loop possible:</source>
          <target state="translated">これらの3つのコンポーネントは、 &lt;code&gt;;&lt;/code&gt; によって互いに分離されています。 シンボル。 これら3つの各コンポーネントのコンテンツはオプションです。つまり、以下は可能な限り最小の &lt;code&gt;for&lt;/code&gt; ループです。</target>
        </trans-unit>
        <trans-unit id="f566944d88f81152109f1bbf9e52d01bb54137da" translate="yes" xml:space="preserve">
          <source>This article will take a close look at what I like to call the &quot;big
  three&quot; list operations: map, filter, and reduce. Wrapping your head
  around these three functions is an important step towards being able
  to write clean functional code, and opens the doors to the vastly
  powerful techniques of functional and reactive programming.</source>
          <target state="translated">この記事では、私が「ビッグスリー」と呼んでいるリスト操作、マップ、フィルタ、リデュースについて詳しく見ていきます。これらの3つの関数を理解することは、クリーンな関数型コードを書けるようになるための重要なステップであり、関数型プログラミングやリアクティブ・プログラミングの非常に強力なテクニックへの扉を開くことになります。</target>
        </trans-unit>
        <trans-unit id="6a07602d0b647fe22e2fcaac7f41bf7fd5c06746" translate="yes" xml:space="preserve">
          <source>This ensures that anything you need in the scope of processing the array stays within that scope, and that you are only processing the values of the array, not the object properties and other members, which is what &lt;code&gt;for ..&lt;/code&gt; in does.</source>
          <target state="translated">これにより、配列の処理のスコープで必要なものはすべてそのスコープ内にとどまり、配列の値のみが処理され、オブジェクトのプロパティやその他のメンバーは処理されないことが保証されます。</target>
        </trans-unit>
        <trans-unit id="858c7fa76e864ce71e5b610d49e037963d073b9e" translate="yes" xml:space="preserve">
          <source>This has the benefit of caching the length (similar to &lt;code&gt;for (var i=0, len=myArray.length; i&amp;lt;len; ++i)&lt;/code&gt; and unlike &lt;code&gt;for (var i=0; i&amp;lt;myArray.length; ++i)&lt;/code&gt;) while being fewer characters to type.</source>
          <target state="translated">これには、長さをキャッシュする利点があります（ &lt;code&gt;for (var i=0, len=myArray.length; i&amp;lt;len; ++i)&lt;/code&gt; と同様）。 &lt;code&gt;for (var i=0; i&amp;lt;myArray.length; ++i)&lt;/code&gt; ）入力する文字が少なくなります。</target>
        </trans-unit>
        <trans-unit id="190958324e44a9b320dec6a0655dbfd941bed1b5" translate="yes" xml:space="preserve">
          <source>This is a good article if you like to learn more about the asynchronous functions over arrays in JavaScript.</source>
          <target state="translated">JavaScriptの配列を超える非同期関数についてもっと知りたい方には良い記事だと思います。</target>
        </trans-unit>
        <trans-unit id="147518e25e35d186bb4ca7645b5e7a356fd8dd30" translate="yes" xml:space="preserve">
          <source>This new syntax is the most elegant way to iterate an array in javascript (as long you don't need the iteration index), but it is not yet widely supported by the browsers.</source>
          <target state="translated">この新しい構文はjavascriptで配列を反復する最もエレガントな方法ですが(反復インデックスを必要としない限り)、ブラウザではまだ広くサポートされていません。</target>
        </trans-unit>
        <trans-unit id="c7b121c2303f93e6b2a2d7db925a526f50850ae3" translate="yes" xml:space="preserve">
          <source>This only works for arrays that are &lt;em&gt;not&lt;/em&gt; sparse. Meaning that there actually is a value at each index in the array. However, I found that in practice I hardly ever use sparse arrays in JavaScript... In such cases it's usually a lot easier to use an object as a map/hashtable. If you do have a sparse array, and want to loop over 0 .. length-1, you need the for (var i=0; i&amp;lt;someArray.length; ++i) construct, but you still need an &lt;code&gt;if&lt;/code&gt; inside the loop to check whether the element at the current index is actually defined.</source>
          <target state="translated">これは&lt;em&gt;、&lt;/em&gt;スパースで&lt;em&gt;ない&lt;/em&gt;配列でのみ機能します。 配列の各インデックスに実際に値があることを意味します。 ただし、実際にはJavaScriptでスパース配列を使用することはほとんどないことがわかりました。そのような場合、通常、オブジェクトをマップ/ハッシュテーブルとして使用する方がはるかに簡単です。 スパース配列があり、0 .. length-1でループしたい場合は、for（var i = 0; i &amp;lt;someArray.length; ++ i）構成が必要ですが、それでも &lt;code&gt;if&lt;/code&gt; が必要ですループして、現在のインデックスの要素が実際に定義されているかどうかを確認します。</target>
        </trans-unit>
        <trans-unit id="0d1a92190b4273c4dedb4a6ff5c33b8b8e248e48" translate="yes" xml:space="preserve">
          <source>This should be used with care, however, as it doesn't behave the same as a traditional &lt;code&gt;for&lt;/code&gt; loop in all cases, and there are potential side-effects that need to be considered. See &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea&quot;&gt;Why is using &quot;for...in&quot; with array iteration a bad idea?&lt;/a&gt;&lt;/strong&gt; for more details.</source>
          <target state="translated">ただし、これはすべての場合において従来の &lt;code&gt;for&lt;/code&gt; ループと同じように動作するわけではなく、考慮する必要のある潜在的な副作用があるため、注意して使用する必要があります。 &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/questions/500504/why-is-using-for-in-with-array-iteration-such-a-bad-idea&quot;&gt;配列の反復で「for ... in」を使用することが悪い考えである理由を&lt;/a&gt;&lt;/strong&gt;参照してください&lt;strong&gt;。&lt;/strong&gt; 詳細については。</target>
        </trans-unit>
        <trans-unit id="472b9cc884c8efe330967ffcc40284ca272d82d6" translate="yes" xml:space="preserve">
          <source>This statement works for any kind of iterable object and also for generators (any object that has a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator&quot;&gt;&lt;code&gt;[Symbol.iterator]&lt;/code&gt;&lt;/a&gt; property).</source>
          <target state="translated">このステートメントは、あらゆる種類の反復可能なオブジェクトおよびジェネレーター（ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator&quot;&gt; &lt;code&gt;[Symbol.iterator]&lt;/code&gt; &lt;/a&gt;プロパティを持つすべてのオブジェクト）に対して機能します。</target>
        </trans-unit>
        <trans-unit id="ac9bb5e0ca9aef826594b177b1c57b42d63efd12" translate="yes" xml:space="preserve">
          <source>Too verbose</source>
          <target state="translated">冗長すぎる</target>
        </trans-unit>
        <trans-unit id="0e44efea277e112b800b020b7f1ce9f2e1b5bdd7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt;, &lt;code&gt;.forEach&lt;/code&gt; only calls the function for elements that are actually present in the array. If passed our hypothetical array with three elements and a length of 248, it will only call the function three times, not 248 times. It also distinguishes between missing elements and elements that are actually set to &lt;code&gt;undefined&lt;/code&gt;; for the latter, it will still call the function, passing &lt;code&gt;undefined&lt;/code&gt; as the argument. If this is how you want to handle sparse arrays, &lt;code&gt;.forEach&lt;/code&gt; may be the way to go even if your interpreter supports &lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;for&lt;/code&gt; ... &lt;code&gt;of&lt;/code&gt; とは異なり、 &lt;code&gt;.forEach&lt;/code&gt; は、配列に実際に存在する要素の関数のみを呼び出します。 3つの要素と長さ248の架空の配列を渡すと、関数は248回ではなく3回しか呼び出されません。 また、不足している要素と実際に &lt;code&gt;undefined&lt;/code&gt; に設定されている要素を区別します。 後者の場合は、関数を呼び出し、 &lt;code&gt;undefined&lt;/code&gt; を引数として渡します。 これがスパース配列を処理する方法である場合、インタプリタ &lt;code&gt;for&lt;/code&gt; ... &lt;code&gt;of&lt;/code&gt; をサポートしている場合でも、 &lt;code&gt;.forEach&lt;/code&gt; が適しています。</target>
        </trans-unit>
        <trans-unit id="fb5ad6ba3a246c28f628695455346d1d1358b358" translate="yes" xml:space="preserve">
          <source>Use the while loop...</source>
          <target state="translated">whileループを使って...</target>
        </trans-unit>
        <trans-unit id="acf02fdaa5e1a7884f09bb5330b18f85aa765a24" translate="yes" xml:space="preserve">
          <source>Useful to iterate serially asynchronous values.</source>
          <target state="translated">非同期の値を連続的に反復処理するのに便利です。</target>
        </trans-unit>
        <trans-unit id="11f8f11632acf347b589a3d67d8c21511e0c9bf6" translate="yes" xml:space="preserve">
          <source>Using a regular C-style &lt;code&gt;for&lt;/code&gt; loop works in most cases. It is just important to remember that everything within the loop shares its scope with the rest of your program, the { } does not create a new scope.</source>
          <target state="translated">通常のCスタイルの &lt;code&gt;for&lt;/code&gt; ループを使用すると、ほとんどの場合に機能します。 ループ内のすべてがプログラムの残りの部分とスコープを共有することを覚えておくことは重要です。{}は新しいスコープを作成しません。</target>
        </trans-unit>
        <trans-unit id="6e8369a5a266e94f593d9eeea846e02aa77149e0" translate="yes" xml:space="preserve">
          <source>Using a traditional &lt;code&gt;for&lt;/code&gt; loop to loop through an array</source>
          <target state="translated">従来の &lt;code&gt;for&lt;/code&gt; ループを使用して配列をループする</target>
        </trans-unit>
        <trans-unit id="85df58774c5491ec2a1dff116625289a4b51fe96" translate="yes" xml:space="preserve">
          <source>Usually, though, the initialization is used to declare an index, the condition is used to compare that index with a minimum or maximum value, and the afterthought is used to increment the index:</source>
          <target state="translated">通常、初期化はインデックスを宣言するために使用され、条件はそのインデックスを最小値または最大値と比較するために使用され、その後にインデックスをインクリメントするために使用されます。</target>
        </trans-unit>
        <trans-unit id="38a3899f8605deb1a119719c4e634478608e868c" translate="yes" xml:space="preserve">
          <source>Very short and succinct.</source>
          <target state="translated">非常に短くて簡潔。</target>
        </trans-unit>
        <trans-unit id="c2806e463dca64608139609ed71eec7bf1af0fcd" translate="yes" xml:space="preserve">
          <source>What I like about this loop is:</source>
          <target state="translated">このループで気に入っているのは</target>
        </trans-unit>
        <trans-unit id="16ce81c4539b95557096d4ee3982368acb60bb76" translate="yes" xml:space="preserve">
          <source>Whichever works best is largely a matter of both personal taste and the specific use case you're implementing.</source>
          <target state="translated">どちらが最も効果的かは、個人の好みと実装している特定のユースケースの両方の問題です。</target>
        </trans-unit>
        <trans-unit id="3eaca1cb6c3a5c7b0653cdc5c205c5570f3bcd75" translate="yes" xml:space="preserve">
          <source>While they all have their own linguistic idiosyncrasies, each of these languages share many of the same basic concepts. Such concepts include procedures / functions, &lt;code&gt;IF&lt;/code&gt;-statements, &lt;code&gt;FOR&lt;/code&gt;-loops, and &lt;code&gt;WHILE&lt;/code&gt;-loops.</source>
          <target state="translated">それらはすべて独自の言語的特異性を持っていますが、これらの各言語は同じ基本概念の多くを共有しています。 このような概念には、プロシージャ/関数、 &lt;code&gt;IF&lt;/code&gt; ステートメント、 &lt;code&gt;FOR&lt;/code&gt; ループ、および &lt;code&gt;WHILE&lt;/code&gt; ループが含まれます。</target>
        </trans-unit>
        <trans-unit id="8244adf2c17ba7cc3bdea8eada041642ab1c86cf" translate="yes" xml:space="preserve">
          <source>Works on every environment</source>
          <target state="translated">あらゆる環境に対応</target>
        </trans-unit>
        <trans-unit id="a1b7a89f3b73a87140f7d4b8e01a03ed839c9203" translate="yes" xml:space="preserve">
          <source>Yes, assuming your implementation includes the &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements&quot;&gt;&lt;code&gt;for&lt;/code&gt;...&lt;code&gt;of&lt;/code&gt;&lt;/a&gt; feature introduced in &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt; (the &quot;Harmony&quot; release)... which is a pretty safe assumption these days.</source>
          <target state="translated">はい、 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/&quot;&gt;ECMAScript 2015&lt;/a&gt; （「ハーモニー」リリース）で導入された&lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-for-in-and-for-of-statements&quot;&gt; &lt;code&gt;for&lt;/code&gt; ... &lt;code&gt;of&lt;/code&gt; &lt;/a&gt;機能が実装に含まれていると想定すると、これは最近ではかなり安全な想定です。</target>
        </trans-unit>
        <trans-unit id="65c39770604a63372cf38469a45e9aad0b608cfa" translate="yes" xml:space="preserve">
          <source>You can either use &lt;code&gt;Array.prototype.forEach(...)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;Array.prototype.forEach(...)&lt;/code&gt; を使用することもできます。</target>
        </trans-unit>
        <trans-unit id="55d53dbec6820aa52a0e39445d08dc7a9bac4eb5" translate="yes" xml:space="preserve">
          <source>You can loop over it without ever accessing the length property:</source>
          <target state="translated">lengthプロパティにアクセスすることなくループオーバーすることができます。</target>
        </trans-unit>
        <trans-unit id="b3f6f0955f94bb72fe3f0ae7cac303e447b46c4f" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; flow control statements</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; および &lt;code&gt;continue&lt;/code&gt; フロー制御ステートメントを使用できます</target>
        </trans-unit>
        <trans-unit id="667729f11316fb106cabbaf8f7679345003c82dc" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;map&lt;/code&gt;, which is a functional programming technique that's also available in other languages like &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;Python&lt;/a&gt; and &lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;map&lt;/code&gt; を使用できます。これは、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Python_%28programming_language%29&quot;&gt;Python&lt;/a&gt;や&lt;a href=&quot;http://en.wikipedia.org/wiki/Haskell_%28programming_language%29&quot;&gt;Haskell&lt;/a&gt;などの他の言語でも利用できる関数型プログラミング手法です。</target>
        </trans-unit>
        <trans-unit id="7a4b18372164e1ad74d80e376ae54cd4abd6e783" translate="yes" xml:space="preserve">
          <source>You don't have to write the function inline. It could be a separate function.</source>
          <target state="translated">関数をインラインで書く必要はありません。別の関数でも良いのです。</target>
        </trans-unit>
        <trans-unit id="04e20c98a9f172e8338b0b1b84b15442bffed6db" translate="yes" xml:space="preserve">
          <source>You have several options:</source>
          <target state="translated">いくつかの選択肢があります。</target>
        </trans-unit>
        <trans-unit id="c18eca76acfa486b5f4dcface2dd20167b170206" translate="yes" xml:space="preserve">
          <source>You may not need all of them, but they can be very useful, or would be if every browser supported them.</source>
          <target state="translated">すべてを必要としないかもしれませんが、それらは非常に便利であるかもしれませんし、すべてのブラウザがそれらをサポートしていればそうなるでしょう。</target>
        </trans-unit>
        <trans-unit id="d0197dfcf1833d20eadc2e44df6cf7b17edfb6e7" translate="yes" xml:space="preserve">
          <source>You may see the length caching done in the loop initialization clause, like this:</source>
          <target state="translated">このようにループの初期化句の中で長さのキャッシュが行われているのを見ることがあります。</target>
        </trans-unit>
        <trans-unit id="8b04966caa69c26f8b04bd68edaf4ae602d48951" translate="yes" xml:space="preserve">
          <source>but it still will iterate over custom-defined properties.</source>
          <target state="translated">が、それでもカスタム定義されたプロパティを繰り返し処理します。</target>
        </trans-unit>
        <trans-unit id="0f1caa03a8a9833b96860b4c667bbe37793f5874" translate="yes" xml:space="preserve">
          <source>for (var s of myStringArray) {</source>
          <target state="translated">for (myStringArrayのvar s){</target>
        </trans-unit>
        <trans-unit id="8c120f4720ec425aef81f42a20fa2bc703fd8e57" translate="yes" xml:space="preserve">
          <source>logs: 'one','two','three'</source>
          <target state="translated">ログを見てみましょう '1','2','3'</target>
        </trans-unit>
        <trans-unit id="3601240b074c10fa007af1eff93ad808fd4ff1ab" translate="yes" xml:space="preserve">
          <source>logs: 'three','two','one'</source>
          <target state="translated">ログを見てみましょう '3','2','1'</target>
        </trans-unit>
        <trans-unit id="cf8d12fbc60f1b20dd0631d9a744f6b45587b6be" translate="yes" xml:space="preserve">
          <source>or better and cleaner to use while loop:</source>
          <target state="translated">または、ループ中に使用する方がより良く、よりクリーンになります。</target>
        </trans-unit>
        <trans-unit id="50b545a5758f3ce6da5a104b5dfa5a80cee70094" translate="yes" xml:space="preserve">
          <source>which would be sort-of equivalent to:</source>
          <target state="translated">と同じようなものだと思います</target>
        </trans-unit>
        <trans-unit id="afb20d799b4203b1e14e9210429f20b6ff061fc3" translate="yes" xml:space="preserve">
          <source>will output &quot;11&quot; - which may or may not be what you want.</source>
          <target state="translated">は &quot;11&quot; を出力します-これはあなたが望むものではないかもしれませんし、そうでないかもしれません。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
