<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3040833">
    <body>
      <group id="3040833">
        <trans-unit id="89148dbe59b34da66c1eb22e0d118dd41ed03ed4" translate="yes" xml:space="preserve">
          <source>(Actually, &lt;a href=&quot;https://stackoverflow.com/users/578435/eleotlecram&quot;&gt;eleotlecram&lt;/a&gt; proposes an &lt;a href=&quot;https://stackoverflow.com/a/7569847/6309&quot;&gt;interesting alternative&lt;/a&gt;)</source>
          <target state="translated">（实际上， &lt;a href=&quot;https://stackoverflow.com/users/578435/eleotlecram&quot;&gt;eleotlecram&lt;/a&gt;提出了一个&lt;a href=&quot;https://stackoverflow.com/a/7569847/6309&quot;&gt;有趣的替代方法&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="20a9adeb2b6d74ebcf730bdd20995a0829bcf0dd" translate="yes" xml:space="preserve">
          <source>(Original answer June 2010: manual stash)</source>
          <target state="translated">(2010年6月的原始答案:手动储存)</target>
        </trans-unit>
        <trans-unit id="5f60f5106b4849950d36c4efb0ad4381c782666e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/git/git/blob/44c3f09fa501ccd83e3362080a99ad4b46cda127/t/t3903-stash.sh#L815-L827&quot;&gt;The test case&lt;/a&gt; for this feature shows a few more options off:</source>
          <target state="translated">此功能&lt;a href=&quot;https://github.com/git/git/blob/44c3f09fa501ccd83e3362080a99ad4b46cda127/t/t3903-stash.sh#L815-L827&quot;&gt;的测试案例&lt;/a&gt;显示了更多选项：</target>
        </trans-unit>
        <trans-unit id="76c767b2fab7f99ecfcd0cbfc6916cb7bdfa6dee" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/42916031/1239774&quot;&gt;&lt;strong&gt;I wrote a simple script for this procedure in an answer to another question&lt;/strong&gt;&lt;/a&gt;, and there are &lt;a href=&quot;https://stackoverflow.com/a/34729706/1239774&quot;&gt;steps for performing the procedure in SourceTree here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/42916031/1239774&quot;&gt;&lt;strong&gt;我在回答另一个问题时为此过程编写了一个简单的脚本，&lt;/strong&gt;&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/34729706/1239774&quot;&gt;在此处的SourceTree中&lt;/a&gt;有执行该过程的步骤 。</target>
        </trans-unit>
        <trans-unit id="087300bf1b1fd91d561d8cf968b24748a0239424" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/146821/bukzor&quot;&gt;bukzor&lt;/a&gt;'s &lt;a href=&quot;https://stackoverflow.com/a/8333163/6309&quot;&gt;answer&lt;/a&gt; (upvoted, November 2011) suggests a more practical solution, based on</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/146821/bukzor&quot;&gt;bukzor&lt;/a&gt;的&lt;a href=&quot;https://stackoverflow.com/a/8333163/6309&quot;&gt;答案&lt;/a&gt; （于2011年11月更新）提出了一个更实际的解决方案，该解决方案基于</target>
        </trans-unit>
        <trans-unit id="73cd9c959b9f90966b65ce838d3a100b265e9c51" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;Casebash&lt;/a&gt; comments:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;Casebash&lt;/a&gt;评论：</target>
        </trans-unit>
        <trans-unit id="255100b0d00461c247051847a83be01d858d6f9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git checkout -- afile&lt;/code&gt; # reset the file to the HEAD content, before any local modifications</source>
          <target state="translated">&lt;code&gt;git checkout -- afile&lt;/code&gt; ＃在进行任何本地修改之前将文件重置为HEAD内容</target>
        </trans-unit>
        <trans-unit id="eb1f892ddd2ae0e38b9664059f662edf5d4d2f4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git stash -k (--keep-index)&lt;/code&gt;: stash all tracked/untracked files and keep them in the working directory</source>
          <target state="translated">&lt;code&gt;git stash -k (--keep-index)&lt;/code&gt; ：存放所有跟踪/未跟踪的文件，并将其保存在工作目录中</target>
        </trans-unit>
        <trans-unit id="3f2575ea7b9240acf9ac32e49686d380911d02fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git stash -p (--patch) -u (--include-untracked)&lt;/code&gt;: invalid command</source>
          <target state="translated">&lt;code&gt;git stash -p (--patch) -u (--include-untracked)&lt;/code&gt; ：无效的命令</target>
        </trans-unit>
        <trans-unit id="06c5d541e61ffe5d17c6b23040f2ae30cc5238c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git stash -p (--patch)&lt;/code&gt;: select hunks manually, excluding untracked files</source>
          <target state="translated">&lt;code&gt;git stash -p (--patch)&lt;/code&gt; ：手动选择大块，不包括未跟踪的文件</target>
        </trans-unit>
        <trans-unit id="08b1fe84c30105f80c9361712089da29eb8e49aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git stash -u (--include-untracked)&lt;/code&gt;: stash all tracked/untracked files</source>
          <target state="translated">&lt;code&gt;git stash -u (--include-untracked)&lt;/code&gt; ：存放所有跟踪/未跟踪的文件</target>
        </trans-unit>
        <trans-unit id="2d516a4b00257d508ee719c6db4abb525fae6301" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git stash pop stash@{1}&lt;/code&gt; # re-apply all your files modifications</source>
          <target state="translated">&lt;code&gt;git stash pop stash@{1}&lt;/code&gt; ＃重新应用所有文件修改</target>
        </trans-unit>
        <trans-unit id="33b08da727b5c08e727304e4801c26bf1d717544" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git stash&lt;/code&gt; # this time, only the files you want are stashed</source>
          <target state="translated">&lt;code&gt;git stash&lt;/code&gt; ＃这次，仅隐藏了您想要的文件</target>
        </trans-unit>
        <trans-unit id="444c210188335bba7a6108cb8d223287334eed29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This is available since Git 2.13, released in spring 2017.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;自2017年春季发布的Git 2.13开始可用。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55dff0ffb36c9b3c2837ca50e4bd255d516950b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git add&lt;/code&gt; + &lt;code&gt;git stash --keep-index&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git add&lt;/code&gt; + &lt;code&gt;git stash --keep-index&lt;/code&gt; &lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="21b17deb492d2eee9a27c583217c28aa32c758cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt;: the following answer is for git before git 2.13. For git 2.13 and over, check out &lt;a href=&quot;https://stackoverflow.com/a/3041055&quot;&gt;another answer further down&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;免责声明&lt;/strong&gt; ：以下答案适用于git 2.13之前的git。 对于git 2.13及更高版本，请&lt;a href=&quot;https://stackoverflow.com/a/3041055&quot;&gt;进一步&lt;/a&gt;查看另一个答案 。</target>
        </trans-unit>
        <trans-unit id="2756abf1eaa19230be9bb95e04f5d2e16307d6dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ed8358472f6327211184f4c2f5aa889636d4e8b" translate="yes" xml:space="preserve">
          <source>A find it easier to use tar (similar tools will probably do) instead of copy:</source>
          <target state="translated">A发现使用焦油(类似的工具大概也可以)而不是复制。</target>
        </trans-unit>
        <trans-unit id="aafe8c729e0765199a4e41fdf310a6b9e43a64ec" translate="yes" xml:space="preserve">
          <source>About that option, &lt;a href=&quot;https://stackoverflow.com/users/88814/chhh&quot;&gt;chhh&lt;/a&gt; points out an alternative workflow in the comments:</source>
          <target state="translated">关于该选项， &lt;a href=&quot;https://stackoverflow.com/users/88814/chhh&quot;&gt;chhh&lt;/a&gt;在注释中指出了另一种工作流程：</target>
        </trans-unit>
        <trans-unit id="bb4474ba2d22fe6318f4eec43e35850507f38145" translate="yes" xml:space="preserve">
          <source>Actually, since Git 2.13 (Q2 2017), you can stash individual files, with &lt;a href=&quot;https://git-scm.com/docs/git-stash#git-stash-push-p--patch-k--no-keep-index-u--include-untracked-a--all-q--quiet-m--messageltmessagegt--ltpathspecgt82308203&quot;&gt;&lt;code&gt;git stash push&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">实际上，从Git 2.13（2017年第二季度）开始，您可以使用&lt;a href=&quot;https://git-scm.com/docs/git-stash#git-stash-push-p--patch-k--no-keep-index-u--include-untracked-a--all-q--quiet-m--messageltmessagegt--ltpathspecgt82308203&quot;&gt; &lt;code&gt;git stash push&lt;/code&gt; &lt;/a&gt;存储单个文件：</target>
        </trans-unit>
        <trans-unit id="7135bd9db653d9b6077d88b7250ff16db6d251c1" translate="yes" xml:space="preserve">
          <source>Add and stash</source>
          <target state="translated">添加和储存</target>
        </trans-unit>
        <trans-unit id="743b72fe73bcbefbf229a33018b9eb8173ba5d66" translate="yes" xml:space="preserve">
          <source>Add the files you don't want to stash, in &lt;strong&gt;Stage&lt;/strong&gt;, Then execute &lt;code&gt;git stash save --keep-index&lt;/code&gt;</source>
          <target state="translated">在&lt;strong&gt;Stage中&lt;/strong&gt;添加您不想 &lt;code&gt;git stash save --keep-index&lt;/code&gt; 的文件，然后执行git stash save --keep-index</target>
        </trans-unit>
        <trans-unit id="c7d8b720b7c0f6c21b7130953972935feb2f5e24" translate="yes" xml:space="preserve">
          <source>And you are done!
HTH.</source>
          <target state="translated">而你已经完成了!HTH。</target>
        </trans-unit>
        <trans-unit id="4136e4007e2c8d131948d98078cb665d8a8d26f9" translate="yes" xml:space="preserve">
          <source>Another way to do this:</source>
          <target state="translated">另一种方法是:</target>
        </trans-unit>
        <trans-unit id="ce496ab90d279274fb97c7bfa3a55ceeadd485b8" translate="yes" xml:space="preserve">
          <source>As noted in the comments, this puts everything into the stash, both staged and unstaged. The --keep-index just leaves the index alone after the stash is done. This can cause merge conflicts when you later pop the stash.</source>
          <target state="translated">正如评论中提到的那样,这就把所有的东西都放到了缓存中,包括阶段性的和非阶段性的。而---keep-index只是在缓存完成后将索引单独留下。这可能会在你以后弹出缓存时造成合并冲突。</target>
        </trans-unit>
        <trans-unit id="862361b4bda865f168bcc4b92823a0735ce6fdeb" translate="yes" xml:space="preserve">
          <source>At the end of that rather cumbersome process, you will have only one or several files stashed.</source>
          <target state="translated">在这个相当繁琐的过程结束时,你将只有一个或几个文件被保存下来。</target>
        </trans-unit>
        <trans-unit id="1a3ba4e6b31c9bea16e353c7203ba33786bf7baa" translate="yes" xml:space="preserve">
          <source>Based on the answers this helped me.</source>
          <target state="translated">根据答案,这对我有帮助。</target>
        </trans-unit>
        <trans-unit id="22fff67c767d0516b5e846a55dd470e2e86d67bd" translate="yes" xml:space="preserve">
          <source>Cleanup by saving the committed content in your file system while resetting back to the original commit:</source>
          <target state="translated">通过在文件系统中保存已提交的内容进行清理,同时恢复到原始提交。</target>
        </trans-unit>
        <trans-unit id="c080cd50e87ddd8cdcf5b528cbfb79e38ed2a3ea" translate="yes" xml:space="preserve">
          <source>Code to copy into the file:</source>
          <target state="translated">代码复制到文件中。</target>
        </trans-unit>
        <trans-unit id="3cb8a78fd388f1e0a369b14e984fcb8f1d595a12" translate="yes" xml:space="preserve">
          <source>Create a stash using &quot;Keep staged changes&quot;.</source>
          <target state="translated">用 &quot;保持阶段性的变化 &quot;建立起一个储存库。</target>
        </trans-unit>
        <trans-unit id="a8d9c85454bdcadad51329b124b5f4cb151710f2" translate="yes" xml:space="preserve">
          <source>Currently, the most reasonable method to be able to stash any specific tracked/untracked files is to:</source>
          <target state="translated">目前,最合理的方法是,能够将任何特定的跟踪文件进行归档。</target>
        </trans-unit>
        <trans-unit id="55823efb45056acba11210535a57d8bf0bf96db0" translate="yes" xml:space="preserve">
          <source>Done!</source>
          <target state="translated">Done!</target>
        </trans-unit>
        <trans-unit id="e2bcda84facb3954e32539ae66300758b6d834b2" translate="yes" xml:space="preserve">
          <source>Done.</source>
          <target state="translated">Done.</target>
        </trans-unit>
        <trans-unit id="df4dcc9c3ae831ad0fdd280485c8eea4e47475af" translate="yes" xml:space="preserve">
          <source>Every answer here is so complicated...</source>
          <target state="translated">这里的每一个答案都是如此复杂.....</target>
        </trans-unit>
        <trans-unit id="e49ffff402ab9325665083150168c99e9a6478e7" translate="yes" xml:space="preserve">
          <source>Exact same behavior as stashing one file and popping it back in.</source>
          <target state="translated">完全一样的行为,就像存储一个文件,然后再把它弹回来。</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="1fe5228407ffb05904c59cac1306d84e2daa2894" translate="yes" xml:space="preserve">
          <source>Fix things up as necessary. Don't forget to &lt;code&gt;git add&lt;/code&gt; any changes.</source>
          <target state="translated">根据需要进行修复。 不要忘了 &lt;code&gt;git add&lt;/code&gt; 任何更改。</target>
        </trans-unit>
        <trans-unit id="aa7f63d4e6066b4a78cedb7e833a23d64d3d2181" translate="yes" xml:space="preserve">
          <source>For example, if you want to split an old commit into more than one changeset, you can use this procedure:</source>
          <target state="translated">例如,如果你想把一个旧提交拆分成多个更改集,你可以使用这个过程。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="3a03c42dd1f4f0035d3b34419cb7d2fba57c36ae" translate="yes" xml:space="preserve">
          <source>For one or several files, an intermediate solution would be to:</source>
          <target state="translated">对于一个或几个文件,中间的解决办法是:</target>
        </trans-unit>
        <trans-unit id="15cdb6601dca3ddf7d51fb421f5e3bd57d9aade5" translate="yes" xml:space="preserve">
          <source>For revert a specific changed file in git, you can do the following line:</source>
          <target state="translated">如果要在git中恢复一个特定的修改过的文件,可以做下面这一行。</target>
        </trans-unit>
        <trans-unit id="e73f5afae9f7a8ff03b45ea0827caf0b2e1b8080" translate="yes" xml:space="preserve">
          <source>Git add everything else, then stash it.</source>
          <target state="translated">把其他的东西都加进去,然后存起来。</target>
        </trans-unit>
        <trans-unit id="27c0ca1334b2dcf4316e2b9fc6927373e3cde37a" translate="yes" xml:space="preserve">
          <source>Go see and upvote his answer, which should be the official one (instead of mine).</source>
          <target state="translated">去看看,然后给他的答案投上一票,这应该是官方的(而不是我的)。</target>
        </trans-unit>
        <trans-unit id="2a229dd742ca3148fc0ba6f401048b2322d84262" translate="yes" xml:space="preserve">
          <source>Here is an actual example:</source>
          <target state="translated">下面是一个实际的例子。</target>
        </trans-unit>
        <trans-unit id="25d857c2b45e8ab70a18c51f3f8b8598ec32329f" translate="yes" xml:space="preserve">
          <source>How can I stash only one of multiple changed files on my branch?</source>
          <target state="translated">如何在我的分支上只存放多个已更改的文件中的一个?</target>
        </trans-unit>
        <trans-unit id="f0d9150f5a4e0e0ba5645c3b28be5cfb5c9bd1bd" translate="yes" xml:space="preserve">
          <source>However that will save the full index (which may not be what you want since it might include other files already indexed),  and a partial worktree (which could look like the one you want to stash).</source>
          <target state="translated">但是,这将保存完整的索引(这可能不是你想要的,因为它可能包括其他已经被索引的文件),和一个部分工作树(可能看起来像你想存储的那样)。</target>
        </trans-unit>
        <trans-unit id="075d0881bf26e12d6fb6ac7e405799e5a9b3e3a2" translate="yes" xml:space="preserve">
          <source>I came up with this after I (once again) came to this page and didn't like the first two answers (the first answer just doesn't answer the question and I didn't quite like working with the &lt;code&gt;-p&lt;/code&gt; interactive mode).</source>
          <target state="translated">在我（再次）进入此页面后，我想到了这个，并且不喜欢前两个答案（第一个答案只是不回答问题，而且我不太喜欢使用 &lt;code&gt;-p&lt;/code&gt; 交互模式） 。</target>
        </trans-unit>
        <trans-unit id="d5d2bd8013db9a47e96e58c6b9ec9f5a29589eb2" translate="yes" xml:space="preserve">
          <source>I don't know how to do it on command line, only using SourceTree. Lets say you have changed file A, and have two change hunks in file B. If you want to stash only the second hunk in file B and leave everything else untouched, do this:</source>
          <target state="translated">我不知道如何在命令行上做,只知道使用SourceTree。假设你改变了文件A,并在文件B里有两个改变的Hunk。</target>
        </trans-unit>
        <trans-unit id="a874d2d0992e3860b88ab2f12dd9245fdbba44fe" translate="yes" xml:space="preserve">
          <source>I found no answer to be what I needed and that is as easy as:</source>
          <target state="translated">我发现没有找到我需要的答案,这就像我需要的一样简单。</target>
        </trans-unit>
        <trans-unit id="5a82939b366793acad2955758e0cd6337cab2689" translate="yes" xml:space="preserve">
          <source>I often find it more intuitive to do the inverse of @bukzor's approach. That is, to stage some changes, and then stash only those staged changes.</source>
          <target state="translated">我经常发现,做@bukzor的反面教材更直观。也就是说,将一些改动进行阶段性的改动,然后只将这些阶段性的改动进行存储。</target>
        </trans-unit>
        <trans-unit id="e5b35353e4a7a5ca0571a992cc79f4afec128dda" translate="yes" xml:space="preserve">
          <source>I would use &lt;code&gt;git stash save --patch&lt;/code&gt;. I don't find the interactivity to be annoying because there are options during it to apply the desired operation to entire files.</source>
          <target state="translated">我会用 &lt;code&gt;git stash save --patch&lt;/code&gt; 。 我认为交互性并不令人讨厌，因为在此过程中有一些选项可以将所需的操作应用于整个文件。</target>
        </trans-unit>
        <trans-unit id="5ff0ea383f4df4f090df0d3b676b12d0909672fd" translate="yes" xml:space="preserve">
          <source>I've reviewed answers and comments for this and a number of similar threads. Be aware that none of the following commands are correct for the purpose of being able to stash &lt;strong&gt;any specific tracked/untracked files&lt;/strong&gt;:</source>
          <target state="translated">我已经审查了有关此问题以及许多类似主题的答案和评论。 请注意，以下命令均不正确，无法存储&lt;strong&gt;任何特定的已跟踪/未跟踪文件&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="14d6fb15d5cbd4a735f2e73d5009e400fa37e045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--patch&lt;/code&gt; doesn't work, a manual process might:</source>
          <target state="translated">如果 &lt;code&gt;--patch&lt;/code&gt; 不起作用，则手动过程可能会：</target>
        </trans-unit>
        <trans-unit id="8eefc863db3fefe1a9b1f1194d93e01a3fc2adae" translate="yes" xml:space="preserve">
          <source>If it's an untracked/new file, you will have to stage it first.</source>
          <target state="translated">如果是未被跟踪的新文件,你要先把它进行阶段化。</target>
        </trans-unit>
        <trans-unit id="eca9740c1b0db36ac8f1d8d9f3e9d69f5ff495ee" translate="yes" xml:space="preserve">
          <source>If you do not want to specify a message with your stashed changes, pass the filename after a double-dash.</source>
          <target state="translated">如果你不想用你隐藏的更改来指定一个消息,请在双破折号后传递文件名。</target>
        </trans-unit>
        <trans-unit id="2c7c7cae7facf5ea33cb51f35863da797eefc92b" translate="yes" xml:space="preserve">
          <source>If you want to stash some changed files, simply just</source>
          <target state="translated">如果你想存储一些更改后的文件,只需</target>
        </trans-unit>
        <trans-unit id="15af41659cfa5d06093bbbc486f953fc5a0fa87e" translate="yes" xml:space="preserve">
          <source>In order to get to the original state - which is a clear staging area and with only some select un-staged modifications, one could softly reset the index to get (without committing anything like you - bukzor - did).</source>
          <target state="translated">为了获得原始状态--这是一个明显的分期区域,只需进行一些有选择的未分期的修改,就可以软性地重置索引来获得(不需要像你--bukzor--做了什么承诺)。</target>
        </trans-unit>
        <trans-unit id="c072c90a2a489efdf9fac9db52a6e83337be0917" translate="yes" xml:space="preserve">
          <source>In some cases, the working tree changes may depend on the index changes, so when you stash the index changes, the working tree changes have a conflict. In this case, you'll get the usual unmerged conflicts that you can resolve with git merge/git mergetool/etc.</source>
          <target state="translated">在某些情况下,工作树的变化可能依赖于索引的变化,所以当你把索引的变化存起来的时候,工作树的变化会有冲突。这种情况下,你会得到通常的未合并冲突,你可以用git mergegit mergetooletc来解决。</target>
        </trans-unit>
        <trans-unit id="90fbb6d41a6712057db4f1a0763c63f4bb631a5e" translate="yes" xml:space="preserve">
          <source>In this situation I &lt;code&gt;git add -p&lt;/code&gt; (interactive), &lt;code&gt;git commit -m blah&lt;/code&gt; and then stash what's left if necessary.</source>
          <target state="translated">在这种情况下，我 &lt;code&gt;git add -p&lt;/code&gt; （交互式）， &lt;code&gt;git commit -m blah&lt;/code&gt; ，然后根据需要存储剩下的内容。</target>
        </trans-unit>
        <trans-unit id="3a5637f855b7a41327dd2df48cbc48080b08a548" translate="yes" xml:space="preserve">
          <source>It will stash all &lt;strong&gt;unstaged&lt;/strong&gt; changed files</source>
          <target state="translated">它将存储所有未&lt;strong&gt;暂存的已&lt;/strong&gt;更改文件</target>
        </trans-unit>
        <trans-unit id="4422e44c20075e809127521eb898c42edd5b6a20" translate="yes" xml:space="preserve">
          <source>Just in case you actually mean &lt;strong&gt;discard changes&lt;/strong&gt; whenever you use &lt;code&gt;git stash&lt;/code&gt; (and don't really use git stash to stash it temporarily), in that case you can use</source>
          <target state="translated">以防万一您实际上意味着每次使用 &lt;code&gt;git stash&lt;/code&gt; 时都&lt;strong&gt;放弃更改&lt;/strong&gt; （并且不要真正使用git stash来临时存储它），在这种情况下，您可以使用</target>
        </trans-unit>
        <trans-unit id="32935b36a5f5e26c4444b624627b0c855eb8a9fa" translate="yes" xml:space="preserve">
          <source>Later execute this line</source>
          <target state="translated">稍后执行此行</target>
        </trans-unit>
        <trans-unit id="fd2d9b2d43239fad04643eaa4637132d00d10763" translate="yes" xml:space="preserve">
          <source>Let's say you have 3 files</source>
          <target state="translated">假设你有3个文件</target>
        </trans-unit>
        <trans-unit id="eb4fdcc3d6368bf7ee124a151165fa1fc9e815b8" translate="yes" xml:space="preserve">
          <source>Local changes:</source>
          <target state="translated">地方上的变化。</target>
        </trans-unit>
        <trans-unit id="aa53219349a4a345586fdbdd1d95e61564b71a38" translate="yes" xml:space="preserve">
          <source>Make file B look as if only second change is applied to it. (e.g. launch external diff tool and undo first change.)</source>
          <target state="translated">使B文件看起来好像只对其进行了第二次修改。(例如:启动外部差异工具,撤销第一次更改。)</target>
        </trans-unit>
        <trans-unit id="eec11f76d2dcd7598c060fe166e8ff8e72bd78e5" translate="yes" xml:space="preserve">
          <source>Mark some changes as &lt;code&gt;edit&lt;/code&gt;.</source>
          <target state="translated">将一些更改标记为&amp;ldquo; &lt;code&gt;edit&lt;/code&gt; &amp;rdquo; 。</target>
        </trans-unit>
        <trans-unit id="650f1f8b5dec5c314b37986f4d2ac0ea890449e4" translate="yes" xml:space="preserve">
          <source>Note the first &lt;code&gt;stash&lt;/code&gt; &amp;amp; &lt;code&gt;stash pop&lt;/code&gt; can be eliminated, you can carry all of your changes over to the &lt;code&gt;master&lt;/code&gt; branch when you checkout, but only if there are no conflicts. Also if you are creating a new branch for the partial changes you will need the stash.</source>
          <target state="translated">请注意，可以取消第一个 &lt;code&gt;stash&lt;/code&gt; 和 &lt;code&gt;stash pop&lt;/code&gt; ，您可以在结帐时将所有更改带到 &lt;code&gt;master&lt;/code&gt; 分支，但前提是不存在冲突。 同样，如果要为部分更改创建新分支，则将需要存储。</target>
        </trans-unit>
        <trans-unit id="c5c78d206c05e6e663215cafbb492dfa59435728" translate="yes" xml:space="preserve">
          <source>Now the stash contains a new entry that only contains the changes you had staged, and your working tree still contains any unstaged changes.</source>
          <target state="translated">现在,存储库包含了一个新的条目,该条目只包含了你已定格的更改,而你的工作树仍然包含任何未定格的更改。</target>
        </trans-unit>
        <trans-unit id="076012f2d09b0d7fc9c437a1349284e4523e3d40" translate="yes" xml:space="preserve">
          <source>Now you can stash the_one_file:</source>
          <target state="translated">现在你可以把_one_file藏起来了。</target>
        </trans-unit>
        <trans-unit id="08df69accdc04cd6ba6ca9515ef459e8fefd885d" translate="yes" xml:space="preserve">
          <source>One complicated way would be to first commit everything:</source>
          <target state="translated">一个复杂的方法是,先把所有的事情都做了。</target>
        </trans-unit>
        <trans-unit id="94c79a63ac0ac10d57150f7afeb04ec46930ec9e" translate="yes" xml:space="preserve">
          <source>Perform changes to your working copy that undo all the changes in file A. (e.g. launch external diff tool and make files match.)</source>
          <target state="translated">对你的工作副本执行更改,撤销文件A中的所有更改(例如,启动外部差异工具并使文件匹配)。</target>
        </trans-unit>
        <trans-unit id="4af916bfc4422becf22a0ea7b854897de4ffc3cb" translate="yes" xml:space="preserve">
          <source>Pop the temporary commit</source>
          <target state="translated">弹出临时提交</target>
        </trans-unit>
        <trans-unit id="b0b275dcbe41dc7499721ad2f066d4e42f379f51" translate="yes" xml:space="preserve">
          <source>Pop your temporary commit by running git reset, targetting the commit before your temporary one.</source>
          <target state="translated">通过运行git reset来弹出你的临时提交,将目标锁定在临时提交之前。</target>
        </trans-unit>
        <trans-unit id="c2673194f77c9e861c1429d63f16ebfe8513aac8" translate="yes" xml:space="preserve">
          <source>Quick Answer</source>
          <target state="translated">快速回答</target>
        </trans-unit>
        <trans-unit id="e66cee3c1d17dbeffaeb43aeb14fcf5685e6bb3e" translate="yes" xml:space="preserve">
          <source>Repeat, from #5, as necessary.</source>
          <target state="translated">必要时,从5号开始,重复一遍。</target>
        </trans-unit>
        <trans-unit id="8c5c5c108b84db3c117f913cf3ad3b98e03c39d6" translate="yes" xml:space="preserve">
          <source>Reset back to the original commit but checkout the_one_file from the new commit:</source>
          <target state="translated">重置回原来的提交,但从新提交中查看_one_file。</target>
        </trans-unit>
        <trans-unit id="30c928951de70841b96aa1dacfbf864c127130a7" translate="yes" xml:space="preserve">
          <source>Save the following code to a file, for example, named &lt;code&gt;stash&lt;/code&gt;. Usage is &lt;code&gt;stash &amp;lt;filename_regex&amp;gt;&lt;/code&gt;. The argument is the regular expression for the full path of the file. For example, to stash a/b/c.txt, &lt;code&gt;stash a/b/c.txt&lt;/code&gt; or &lt;code&gt;stash .*/c.txt&lt;/code&gt;, etc.</source>
          <target state="translated">将以下代码保存到名为 &lt;code&gt;stash&lt;/code&gt; 的文件中。 用法是 &lt;code&gt;stash &amp;lt;filename_regex&amp;gt;&lt;/code&gt; 。 参数是文件完整路径的正则表达式。 例如，要存储a / b / c.txt，请 &lt;code&gt;stash a/b/c.txt&lt;/code&gt; 或 &lt;code&gt;stash .*/c.txt&lt;/code&gt; 等。</target>
        </trans-unit>
        <trans-unit id="cf3cd7fd50c4dd733be93409a6d379d65aa9f1ad" translate="yes" xml:space="preserve">
          <source>Similar situation. Did commit and realized it's not ok.</source>
          <target state="translated">类似的情况。做了承诺,发现不妥。</target>
        </trans-unit>
        <trans-unit id="2dd070f208e2d644f96b6009c86ccb5c995b1410" translate="yes" xml:space="preserve">
          <source>Simplified example:</source>
          <target state="translated">简化的例子。</target>
        </trans-unit>
        <trans-unit id="eab82bb11b720442295ac6e7c9bb18c084481e89" translate="yes" xml:space="preserve">
          <source>Since creating branches in Git is trivial you could just create a temporary branch and check the individual files into it.</source>
          <target state="translated">由于在Git中创建分支很简单,你可以直接创建一个临时分支,然后将单个文件检查到其中。</target>
        </trans-unit>
        <trans-unit id="6bf3d1ea47cad19c42b20b38c81ea910e93f7e29" translate="yes" xml:space="preserve">
          <source>Since git is fundamentally about managing a all repository &lt;em&gt;content&lt;/em&gt; and index (and not one or several files), &lt;code&gt;git stash&lt;/code&gt; deals, not surprisingly, &lt;del&gt;with the all working directory&lt;/del&gt;.</source>
          <target state="translated">由于git从根本上来说是关于管理所有存储库&lt;em&gt;内容&lt;/em&gt;和索引（而不是一个或多个文件）的，因此 &lt;code&gt;git stash&lt;/code&gt; 交易并不奇怪， &lt;del&gt; 与所有工作目录 &lt;/del&gt; 。</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="7c825660c31a5a9b357c40643e0bc10564cc5e13" translate="yes" xml:space="preserve">
          <source>Sometimes I've made an unrelated change on my branch before I've committed it, and I want to move it to another branch and commit it separately (like master). I do this:</source>
          <target state="translated">有时候,我在我的分支上做了一个不相关的修改,还没提交之前,我想把它移到另一个分支上单独提交(比如master)。我是这样做的。</target>
        </trans-unit>
        <trans-unit id="420fa87618d4fef2b5b1df2e2cdb0e0f12b6cfa4" translate="yes" xml:space="preserve">
          <source>Stage everything</source>
          <target state="translated">舞台上的一切</target>
        </trans-unit>
        <trans-unit id="6b9df5b64eecf55a53bf93609897fd58b05a7ff6" translate="yes" xml:space="preserve">
          <source>Stash not even needed...</source>
          <target state="translated">储藏室都不需要.....</target>
        </trans-unit>
        <trans-unit id="edd8c461a5ed1179cb6ab0bac4a7febfaf34cd27" translate="yes" xml:space="preserve">
          <source>Stash only one file out of multiple files that have changed with Git</source>
          <target state="translated">在多个文件中只保存一个文件,而这些文件都是用Git更改过的。</target>
        </trans-unit>
        <trans-unit id="4b27096bc706b7059e20d1706b82f7d99e893100" translate="yes" xml:space="preserve">
          <source>Temporarily commit everything you don't want stashed.</source>
          <target state="translated">暂时把你不想要的东西都藏起来。</target>
        </trans-unit>
        <trans-unit id="84a8ba53964df2606edc2fe627ecb0d6689a435d" translate="yes" xml:space="preserve">
          <source>Temporarily commit the files you don't want to stash</source>
          <target state="translated">暂时提交你不想存储的文件</target>
        </trans-unit>
        <trans-unit id="7be7048344d356766cd655be245dc6da4cb5d4b8" translate="yes" xml:space="preserve">
          <source>That &lt;code&gt;git stash&lt;/code&gt; is just a quicker and simple alternative to branching and doing stuff.</source>
          <target state="translated">&lt;code&gt;git stash&lt;/code&gt; 只是分支和执行操作的一种更快，更简单的替代方法。</target>
        </trans-unit>
        <trans-unit id="8ee8f8fb36616c01d080498785710e3bf447e74f" translate="yes" xml:space="preserve">
          <source>The idea is the same as what @VonC suggested using files outside the repository, you save the changes you want somewhere, remove the changes you don't want in your stash, and then re-apply the changes you moved out of the way. However, I used the git stash as the &quot;somewhere&quot; (and as a result, there's one extra step at the end: removing the cahnges you put in the stash, because you moved these out of the way as well).</source>
          <target state="translated">这个想法和@VonC建议的使用版本库外的文件是一样的,你把你想要的修改保存到某个地方,然后删除你不想要的修改,然后重新应用你移出的修改。但是,我用git stash作为 &quot;某个地方&quot;(结果,最后还有一个额外的步骤:删除你放在stash中的cahnges,因为你也把这些移出了)。</target>
        </trans-unit>
        <trans-unit id="0d22e22331af7daef04e4225975a160cdf709da5" translate="yes" xml:space="preserve">
          <source>The original answer (below, June 2010) was about manually selecting what you want to stash.</source>
          <target state="translated">最初的答案(下图,2010年6月)是关于手动选择你想储存的东西。</target>
        </trans-unit>
        <trans-unit id="5d345b6974d59d52ad9260ee17f4883e5949ed94" translate="yes" xml:space="preserve">
          <source>The problem with VonC's `intermediate' solution of copying files to outside the Git repo is that you lose path information, which makes copying a bunch of files back later on somewhat of a hassle.</source>
          <target state="translated">VonC 把文件复制到Git repo之外的 &quot;中间 &quot;解决方案的问题是,你会丢失路径信息,这让你以后复制一堆文件回来有点麻烦。</target>
        </trans-unit>
        <trans-unit id="2ccb766e9519824c270d8b3830a503b2f19527b8" translate="yes" xml:space="preserve">
          <source>The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree.</source>
          <target state="translated">缓存条目的构造是使其索引状态与你的存储库的索引状态相同,其工作树只包含你交互式选择的更改。然后,所选择的更改会从工作树中回滚。</target>
        </trans-unit>
        <trans-unit id="3a220b4812842986a6738a397e029485deb28100" translate="yes" xml:space="preserve">
          <source>Then afterwards</source>
          <target state="translated">之后</target>
        </trans-unit>
        <trans-unit id="9ea5143f8a20ae87159a02e90007453bda4b3045" translate="yes" xml:space="preserve">
          <source>This (the &lt;code&gt;stash --patch&lt;/code&gt; original solution) is nice, but often I've modified a lot of files so using patch is annoying</source>
          <target state="translated">这个（ &lt;code&gt;stash --patch&lt;/code&gt; 原始解决方案）很好，但是我经常修改了很多文件，所以使用patch很烦人</target>
        </trans-unit>
        <trans-unit id="17e5217c603c6f78e62cd64885f6311492cce07f" translate="yes" xml:space="preserve">
          <source>This can all be done in a matter of seconds in SourceTree, where you can just click on the files (or even individual lines) you want to add.  Once added, just commit them to a temporary commit.  Next, click the checkbox to add all changes, then click stash to stash everything.  With the stashed changes out of the way, glance over at your commit list and note the hash for the commit before your temporary commit, then run 'git reset hash_b4_temp_commit', which is basically like &quot;popping&quot; the commit by resetting your branch to the commit right before it.   Now, you're left with just the stuff you didn't want stashed.</source>
          <target state="translated">这一切都可以在几秒钟内在SourceTree中完成,你只需点击你想添加的文件(甚至是单个行)。添加完毕后,只需将其提交到临时提交中即可。接下来,点击复选框添加所有的更改,然后点击隐藏来隐藏所有的更改。把隐藏的修改都处理掉后,看一下你的提交列表,注意到临时提交之前的提交的哈希,然后运行'git reset hash_b4_temp_commit',这基本上就像 &quot;弹出 &quot;提交一样,将你的分支重置到提交之前的提交。现在,你只剩下了你不想要的东西了。</target>
        </trans-unit>
        <trans-unit id="7117598aceda9c135c89ce2e4abeefc17347acfc" translate="yes" xml:space="preserve">
          <source>This can be done easily in 3 steps using SourceTree.</source>
          <target state="translated">使用SourceTree可以通过3个步骤轻松完成。</target>
        </trans-unit>
        <trans-unit id="b800e1bd5fd0f0ad42e9a5619dc1577a5b072a89" translate="yes" xml:space="preserve">
          <source>This is going to prompt: &lt;code&gt;Stash this hunk [y,n,q,a,d,j,J,g,/,e,?]? ?&lt;/code&gt;. Just type &lt;code&gt;a&lt;/code&gt; (stash this hunk and all later hunks in the file) and you're fine.</source>
          <target state="translated">这将提示： &lt;code&gt;Stash this hunk [y,n,q,a,d,j,J,g,/,e,?]? ?&lt;/code&gt; ？ 。 只需键入 &lt;code&gt;a&lt;/code&gt; （将这个大块以及以后的所有大块存储在文件中）就可以了。</target>
        </trans-unit>
        <trans-unit id="a19324c0067c138256242ccb3a75f73850b46299" translate="yes" xml:space="preserve">
          <source>This method works in git versions 2.13+</source>
          <target state="translated">这个方法在git 2.13以上的版本中可以使用</target>
        </trans-unit>
        <trans-unit id="62eeb479cbfd7377bc460bb179f52f97bde85fbc" translate="yes" xml:space="preserve">
          <source>This stashes exactly one file.</source>
          <target state="translated">这样一来,恰好可以存放一个文件。</target>
        </trans-unit>
        <trans-unit id="50799cda9a68deb4560e323345e578a4b1005de1" translate="yes" xml:space="preserve">
          <source>This to pop the file change back:</source>
          <target state="translated">这要弹出文件更改回来。</target>
        </trans-unit>
        <trans-unit id="691ac3501be3980e3c931957ea90bd9b59815ede" translate="yes" xml:space="preserve">
          <source>This will stash everything that you haven't previously added. Just &lt;code&gt;git add&lt;/code&gt; the things you want to keep, then run it.</source>
          <target state="translated">这将存储您以前未添加的所有内容。 只需 &lt;code&gt;git add&lt;/code&gt; 要保留的内容，然后运行它。</target>
        </trans-unit>
        <trans-unit id="6a0aec42528d84f6c57c24635469b696aa26bdfa" translate="yes" xml:space="preserve">
          <source>To &quot;stash&quot; a particular file/dir only:</source>
          <target state="translated">仅仅是为了 &quot;藏匿 &quot;一个特定的锉刀。</target>
        </trans-unit>
        <trans-unit id="86d9d505be38e876d178a0da76d193b877f5c668" translate="yes" xml:space="preserve">
          <source>To create a stash &quot;my_stash&quot; with only the changes on &lt;strong&gt;file_C&lt;/strong&gt;:</source>
          <target state="translated">要创建仅在&lt;strong&gt;file_C&lt;/strong&gt;上进行更改的存储&amp;ldquo; my_stash&amp;rdquo;：</target>
        </trans-unit>
        <trans-unit id="e6425ba1dc11119c05f1ea66f10e97616263106b" translate="yes" xml:space="preserve">
          <source>To stash a single file use &lt;code&gt;git stash --patch [file]&lt;/code&gt;.</source>
          <target state="translated">要存储单个文件，请使用 &lt;code&gt;git stash --patch [file]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="49c77d7ef2e46ac894583e1fbb20721b5ede6e8f" translate="yes" xml:space="preserve">
          <source>Try to add the files using  &quot;&lt;code&gt;git add filepath&lt;/code&gt;&quot;.</source>
          <target state="translated">尝试使用&amp;ldquo; &lt;code&gt;git add filepath&lt;/code&gt; &amp;rdquo;添加文件。</target>
        </trans-unit>
        <trans-unit id="aea2cdabf3d10902b67a033c2abfd3bb2aac8e6b" translate="yes" xml:space="preserve">
          <source>Unfortunately, git doesn't offer a git stash --only-index or similar, so I whipped up a script to do this.</source>
          <target state="translated">不幸的是,git没有提供一个git stash --only-index或类似的东西,所以我编了一个脚本来做这个。</target>
        </trans-unit>
        <trans-unit id="f1b9488a2385748295ea36f4273710d79af0d34f" translate="yes" xml:space="preserve">
          <source>Unstage everything</source>
          <target state="translated">拆除所有的东西</target>
        </trans-unit>
        <trans-unit id="a46b1cbd80ccc50bd881e024bbbe5b5d13d6bac3" translate="yes" xml:space="preserve">
          <source>Update (2/14/2015) - I've rewritten the script a bit, to better handle the case of conflicts, which should now be presented as unmerged conflicts rather than .rej files.</source>
          <target state="translated">更新 (2142015)-我重写了一下脚本,以更好地处理冲突的情况,现在应该以未合并的冲突而不是.rej文件的形式呈现。</target>
        </trans-unit>
        <trans-unit id="baab9726ea3df64ea0852a76e09cb208af29343e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stash push&lt;/code&gt;, like this:</source>
          <target state="translated">使用 &lt;code&gt;git stash push&lt;/code&gt; ，如下所示：</target>
        </trans-unit>
        <trans-unit id="5b8ef5eac7c82ff1543f1bd46bdab36501959d3c" translate="yes" xml:space="preserve">
          <source>What about this to &quot;stash&quot;:</source>
          <target state="translated">这个要 &quot;藏起来 &quot;怎么办。</target>
        </trans-unit>
        <trans-unit id="ab7a2d5695e40ac3768aebbb0094b4455f5b7ea9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git stash -p&lt;/code&gt; (or &lt;code&gt;git add -p&lt;/code&gt; with &lt;code&gt;stash --keep-index&lt;/code&gt;) would be too cumbersome, I found it easier to use &lt;code&gt;diff&lt;/code&gt;, &lt;code&gt;checkout&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;:</source>
          <target state="translated">当 &lt;code&gt;git stash -p&lt;/code&gt; （或带有 &lt;code&gt;stash --keep-index&lt;/code&gt; 的 &lt;code&gt;git add -p&lt;/code&gt; ）太麻烦时，我发现使用 &lt;code&gt;diff&lt;/code&gt; ， &lt;code&gt;checkout&lt;/code&gt; 和 &lt;code&gt;apply&lt;/code&gt; 更容易：</target>
        </trans-unit>
        <trans-unit id="9d172c009b80d14e34e33f98fd159d98f4072718" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pathspec&lt;/code&gt; is given to '&lt;code&gt;git stash push&lt;/code&gt;', the new stash records the modified states only for the files that match the pathspec
  See &quot;&lt;a href=&quot;https://stackoverflow.com/a/42963606/6309&quot;&gt;Stash changes to specific files&lt;/a&gt;&quot; for more.</source>
          <target state="translated">当为&amp;ldquo; &lt;code&gt;git stash push&lt;/code&gt; &amp;rdquo;提供 &lt;code&gt;pathspec&lt;/code&gt; 时 ，新的stash仅记录与pathspec匹配的文件的修改状态。有关更多信息，请参见&amp;ldquo;将&lt;a href=&quot;https://stackoverflow.com/a/42963606/6309&quot;&gt;更改存储到特定文件&lt;/a&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="87971133a5333cd55e42a26806d4eaec0c3f1e60" translate="yes" xml:space="preserve">
          <source>When you try to switch between two branches, this situation occurs.</source>
          <target state="translated">当你尝试在两个分支之间切换时,会出现这种情况。</target>
        </trans-unit>
        <trans-unit id="d649b75edf837b6306017bb83719947ad693f78e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--patch&lt;/code&gt;, you can interactively select hunks from in the diff between HEAD and the working tree to be stashed.</source>
          <target state="translated">使用 &lt;code&gt;--patch&lt;/code&gt; ，您可以从HEAD与要隐藏的工作树之间的差异中交互选择块。</target>
        </trans-unit>
        <trans-unit id="aa1c3abc8084be098568844f6996896558134eea" translate="yes" xml:space="preserve">
          <source>Yeah, somewhat awkward...</source>
          <target state="translated">是啊,有点尴尬........</target>
        </trans-unit>
        <trans-unit id="c9f2eb360a15ad6ed722e9d8555407417d90f97c" translate="yes" xml:space="preserve">
          <source>Yet, &lt;code&gt;git stash save --patch&lt;/code&gt; could allows you to achieve the partial stashing you are after:</source>
          <target state="translated">但是， &lt;code&gt;git stash save --patch&lt;/code&gt; 可以使您实现部分隐藏 ：</target>
        </trans-unit>
        <trans-unit id="3f1be61500355488e493333982003f539132d24b" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git stash save -p &quot;my commit message&quot;&lt;/code&gt;. This way you can select which hunks should be added to stash, whole files can be selected as well.</source>
          <target state="translated">您还可以使用 &lt;code&gt;git stash save -p &quot;my commit message&quot;&lt;/code&gt; 。 这样，您可以选择应将哪些块添加到存储中，也可以选择整个文件。</target>
        </trans-unit>
        <trans-unit id="ad4e76b5c8d7ff2da88debfc6b480fc39bdb5abc" translate="yes" xml:space="preserve">
          <source>You can save the above script as &lt;code&gt;git-stash-index&lt;/code&gt; somewhere on your path, and can then invoke it as git stash-index</source>
          <target state="translated">您可以将上述脚本另存为路径上的 &lt;code&gt;git-stash-index&lt;/code&gt; ，然后可以将其作为git stash-index调用</target>
        </trans-unit>
        <trans-unit id="380ad06d71407fd61c34f44b21511840d455dfd7" translate="yes" xml:space="preserve">
          <source>You can simplify it assuming no conflicts and no new branch:</source>
          <target state="translated">假设没有冲突,没有新的分支,你可以把它简单化。</target>
        </trans-unit>
        <trans-unit id="043b8e3d4be0404b821150e0c77829eeafce2208" translate="yes" xml:space="preserve">
          <source>You can simply do this:</source>
          <target state="translated">你可以简单地这样做。</target>
        </trans-unit>
        <trans-unit id="a749b7909f59e7698cf699c682b1654f1ee84d24" translate="yes" xml:space="preserve">
          <source>You can use &lt;em&gt;git status&lt;/em&gt; between the steps to see what is going on.</source>
          <target state="translated">您可以在步骤之间使用&lt;em&gt;git status&lt;/em&gt;来查看发生了什么。</target>
        </trans-unit>
        <trans-unit id="63759cabbe2219f599293c31908dcd6721451bee" translate="yes" xml:space="preserve">
          <source>You'll be prompted with a few actions for each hunk:</source>
          <target state="translated">每个大块头都会有几个动作提示你。</target>
        </trans-unit>
        <trans-unit id="c5d604e1d8950a1e28a32da7927813a33436c01a" translate="yes" xml:space="preserve">
          <source>[&lt;strong&gt;NOTE&lt;/strong&gt;]</source>
          <target state="translated">[&lt;strong&gt;NOTE&lt;/strong&gt;]</target>
        </trans-unit>
        <trans-unit id="7e87627c92eefc978614db7f9336cf8b74ca03c5" translate="yes" xml:space="preserve">
          <source>add &lt;em&gt;file_C&lt;/em&gt; to the staging area</source>
          <target state="translated">将&lt;em&gt;file_C&lt;/em&gt;添加到暂存区</target>
        </trans-unit>
        <trans-unit id="dc5955241919bf574c188eaa7de743d4a25f52a6" translate="yes" xml:space="preserve">
          <source>and you want to stash only b.rb and c.rb but not a.rb</source>
          <target state="translated">而你只想藏B.rb和c.rb,而不想藏a.rb</target>
        </trans-unit>
        <trans-unit id="53e1f3406388b2a79d1e005eb5e4331e673ce087" translate="yes" xml:space="preserve">
          <source>apply the changes in &quot;temp_stash&quot; (file_A and file_B) on your local code and delete the stash</source>
          <target state="translated">应用本地代码上的 &quot;temp_stash&quot;(file_A和file_B)中的更改,并删除存储空间</target>
        </trans-unit>
        <trans-unit id="876e40895666aff4f765839a07672655db12e71d" translate="yes" xml:space="preserve">
          <source>copy them back</source>
          <target state="translated">抄回</target>
        </trans-unit>
        <trans-unit id="15c125b10ac674cd8657f770e10cd1ff240511f0" translate="yes" xml:space="preserve">
          <source>copy them outside the Git repo</source>
          <target state="translated">将它们复制到Git repo之外</target>
        </trans-unit>
        <trans-unit id="390624993351e6fc81dbe108314b3847bdcbb7da" translate="yes" xml:space="preserve">
          <source>create a temporary stash named &quot;temp_stash&quot; and keep the changes on file_C</source>
          <target state="translated">创建一个名为 &quot;temp_stash &quot;的临时存储区,并将更改的内容保存在file_C上。</target>
        </trans-unit>
        <trans-unit id="ab823066c632468444e4dbe99a2cd07b70c36d86" translate="yes" xml:space="preserve">
          <source>create the wanted stash (&quot;my_stash&quot;) with only the changes on file_C</source>
          <target state="translated">创建想要的存储区(&quot;my_stash&quot;),只在file_C上做了修改。</target>
        </trans-unit>
        <trans-unit id="d8d73423bc6e0268beaa3cd949a40a52d998d1b1" translate="yes" xml:space="preserve">
          <source>etc. (see VonC's `intermediate' suggestion)</source>
          <target state="translated">等。(见VonC的 &quot;中级 &quot;建议)</target>
        </trans-unit>
        <trans-unit id="4228d495d714e89bd7d60589077fd1998a387166" translate="yes" xml:space="preserve">
          <source>file_A (modified) not staged</source>
          <target state="translated">file_A(修改过的)不在舞台上</target>
        </trans-unit>
        <trans-unit id="19ce18b4e0ed171b7f49aa2e46065100c897d3e9" translate="yes" xml:space="preserve">
          <source>file_B (modified) not staged</source>
          <target state="translated">file_B(修改过的)不属于阶段性的</target>
        </trans-unit>
        <trans-unit id="b5e64d481edf4a5825fdbc868b5e472e1c711cfc" translate="yes" xml:space="preserve">
          <source>file_C (modified) not staged</source>
          <target state="translated">file_C(修改过的)不属于阶段性的</target>
        </trans-unit>
        <trans-unit id="b96b2a7150dfde3f0cad72b90e383b05bfe50a00" translate="yes" xml:space="preserve">
          <source>git checkout path/to/some/file path/to/some/other/file</source>
          <target state="translated">git checkout pathtosomefile pathtosomeotherfile</target>
        </trans-unit>
        <trans-unit id="48990e38fbc991cfecd7555a4a3686c57c77f6e8" translate="yes" xml:space="preserve">
          <source>git stash</source>
          <target state="translated">git藏匿</target>
        </trans-unit>
        <trans-unit id="481bdc59a90b18e88cf45a0637a8ba4fbed5122b" translate="yes" xml:space="preserve">
          <source>might be a better fit.</source>
          <target state="translated">可能是更合适的。</target>
        </trans-unit>
        <trans-unit id="4ed4d8085c2c68fd5f785c4e99bb65ac8184221b" translate="yes" xml:space="preserve">
          <source>or with an optional message</source>
          <target state="translated">或附带一个可选的信息</target>
        </trans-unit>
        <trans-unit id="a816c8162eaac6ecf2c9e85cb8880704e0705547" translate="yes" xml:space="preserve">
          <source>tar cvf /tmp/stash.tar path/to/some/file path/to/some/other/file  (... etc.)</source>
          <target state="translated">tar cvf tmpstash.tar pathtosomefile pathtosomeotherfile (...等)</target>
        </trans-unit>
        <trans-unit id="755c3eb88bdacd1ca047b75217567729d005d74e" translate="yes" xml:space="preserve">
          <source>tar xvf /tmp/stash.tar</source>
          <target state="translated">tar xvf tmpstash.tar</target>
        </trans-unit>
        <trans-unit id="0d51416870ddb2d8f98d3c216a97ebaf94344ff3" translate="yes" xml:space="preserve">
          <source>you can do something like this</source>
          <target state="translated">你可以这样做</target>
        </trans-unit>
        <trans-unit id="252f4f3aa6128e48acca70b06bba6179259d685d" translate="yes" xml:space="preserve">
          <source>you should &quot;&lt;code&gt;git reset --soft&lt;/code&gt;&quot; after such a stash to get your clear staging back:</source>
          <target state="translated">您应该在这样的 &lt;code&gt;git reset --soft&lt;/code&gt; 之后执行&amp;ldquo; git reset --soft &amp;rdquo;，以使您清楚地恢复工作：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
