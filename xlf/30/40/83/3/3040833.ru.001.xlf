<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/3040833">
    <body>
      <group id="3040833">
        <trans-unit id="89148dbe59b34da66c1eb22e0d118dd41ed03ed4" translate="yes" xml:space="preserve">
          <source>(Actually, &lt;a href=&quot;https://stackoverflow.com/users/578435/eleotlecram&quot;&gt;eleotlecram&lt;/a&gt; proposes an &lt;a href=&quot;https://stackoverflow.com/a/7569847/6309&quot;&gt;interesting alternative&lt;/a&gt;)</source>
          <target state="translated">(На самом деле, &lt;a href=&quot;https://stackoverflow.com/users/578435/eleotlecram&quot;&gt;eleotlecram&lt;/a&gt; предлагает &lt;a href=&quot;https://stackoverflow.com/a/7569847/6309&quot;&gt;интересную альтернативу&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="20a9adeb2b6d74ebcf730bdd20995a0829bcf0dd" translate="yes" xml:space="preserve">
          <source>(Original answer June 2010: manual stash)</source>
          <target state="translated">(оригинал ответа июнь 2010 года:ручной тайник)</target>
        </trans-unit>
        <trans-unit id="5f60f5106b4849950d36c4efb0ad4381c782666e" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/git/git/blob/44c3f09fa501ccd83e3362080a99ad4b46cda127/t/t3903-stash.sh#L815-L827&quot;&gt;The test case&lt;/a&gt; for this feature shows a few more options off:</source>
          <target state="translated">&lt;a href=&quot;https://github.com/git/git/blob/44c3f09fa501ccd83e3362080a99ad4b46cda127/t/t3903-stash.sh#L815-L827&quot;&gt;Тестовый пример&lt;/a&gt; для этой функции показывает еще несколько опций:</target>
        </trans-unit>
        <trans-unit id="76c767b2fab7f99ecfcd0cbfc6916cb7bdfa6dee" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/42916031/1239774&quot;&gt;&lt;strong&gt;I wrote a simple script for this procedure in an answer to another question&lt;/strong&gt;&lt;/a&gt;, and there are &lt;a href=&quot;https://stackoverflow.com/a/34729706/1239774&quot;&gt;steps for performing the procedure in SourceTree here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/42916031/1239774&quot;&gt;&lt;strong&gt;Я написал простой сценарий для этой процедуры в ответ на другой вопрос&lt;/strong&gt;&lt;/a&gt; , и здесь есть &lt;a href=&quot;https://stackoverflow.com/a/34729706/1239774&quot;&gt;шаги для выполнения процедуры в SourceTree&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="087300bf1b1fd91d561d8cf968b24748a0239424" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/146821/bukzor&quot;&gt;bukzor&lt;/a&gt;'s &lt;a href=&quot;https://stackoverflow.com/a/8333163/6309&quot;&gt;answer&lt;/a&gt; (upvoted, November 2011) suggests a more practical solution, based on</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/8333163/6309&quot;&gt;Ответ&lt;/a&gt; Букзора (поднял, ноябрь 2011) предлагает более практичное решение, основанное на</target>
        </trans-unit>
        <trans-unit id="73cd9c959b9f90966b65ce838d3a100b265e9c51" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;Casebash&lt;/a&gt; comments:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/165495/casebash&quot;&gt;Casebash&lt;/a&gt; комментарии:</target>
        </trans-unit>
        <trans-unit id="255100b0d00461c247051847a83be01d858d6f9a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git checkout -- afile&lt;/code&gt; # reset the file to the HEAD content, before any local modifications</source>
          <target state="translated">&lt;code&gt;git checkout -- afile&lt;/code&gt; # сбросить файл до содержимого HEAD перед любыми локальными изменениями</target>
        </trans-unit>
        <trans-unit id="eb1f892ddd2ae0e38b9664059f662edf5d4d2f4c" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git stash -k (--keep-index)&lt;/code&gt;: stash all tracked/untracked files and keep them in the working directory</source>
          <target state="translated">&lt;code&gt;git stash -k (--keep-index)&lt;/code&gt; : хранить все отслеживаемые / неотслеживаемые файлы и хранить их в рабочем каталоге.</target>
        </trans-unit>
        <trans-unit id="3f2575ea7b9240acf9ac32e49686d380911d02fc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git stash -p (--patch) -u (--include-untracked)&lt;/code&gt;: invalid command</source>
          <target state="translated">&lt;code&gt;git stash -p (--patch) -u (--include-untracked)&lt;/code&gt; : недопустимая команда</target>
        </trans-unit>
        <trans-unit id="06c5d541e61ffe5d17c6b23040f2ae30cc5238c0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git stash -p (--patch)&lt;/code&gt;: select hunks manually, excluding untracked files</source>
          <target state="translated">&lt;code&gt;git stash -p (--patch)&lt;/code&gt; : выберите ханки вручную, за исключением неотслеживаемых файлов</target>
        </trans-unit>
        <trans-unit id="08b1fe84c30105f80c9361712089da29eb8e49aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git stash -u (--include-untracked)&lt;/code&gt;: stash all tracked/untracked files</source>
          <target state="translated">&lt;code&gt;git stash -u (--include-untracked)&lt;/code&gt; : спрятать все отслеженные / неотслеживаемые файлы</target>
        </trans-unit>
        <trans-unit id="2d516a4b00257d508ee719c6db4abb525fae6301" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git stash pop stash@{1}&lt;/code&gt; # re-apply all your files modifications</source>
          <target state="translated">&lt;code&gt;git stash pop stash@{1}&lt;/code&gt; # повторно применить все ваши модификации файлов</target>
        </trans-unit>
        <trans-unit id="33b08da727b5c08e727304e4801c26bf1d717544" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git stash&lt;/code&gt; # this time, only the files you want are stashed</source>
          <target state="translated">&lt;code&gt;git stash&lt;/code&gt; # на этот раз спрятаны только те файлы, которые вы хотите</target>
        </trans-unit>
        <trans-unit id="444c210188335bba7a6108cb8d223287334eed29" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This is available since Git 2.13, released in spring 2017.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Это доступно с Git 2.13, выпущенной весной 2017 года.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="55dff0ffb36c9b3c2837ca50e4bd255d516950b4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git add&lt;/code&gt; + &lt;code&gt;git stash --keep-index&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git add&lt;/code&gt; + &lt;code&gt;git stash --keep-index&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="21b17deb492d2eee9a27c583217c28aa32c758cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Disclaimer&lt;/strong&gt;: the following answer is for git before git 2.13. For git 2.13 and over, check out &lt;a href=&quot;https://stackoverflow.com/a/3041055&quot;&gt;another answer further down&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;Отказ от ответственности&lt;/strong&gt; : следующий ответ для git перед git 2.13. Для git 2.13 и выше, проверьте &lt;a href=&quot;https://stackoverflow.com/a/3041055&quot;&gt;другой ответ ниже&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2756abf1eaa19230be9bb95e04f5d2e16307d6dd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Warning&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ed8358472f6327211184f4c2f5aa889636d4e8b" translate="yes" xml:space="preserve">
          <source>A find it easier to use tar (similar tools will probably do) instead of copy:</source>
          <target state="translated">Проще использовать tar (вероятно,это сделают аналогичные инструменты)вместо копирования:</target>
        </trans-unit>
        <trans-unit id="aafe8c729e0765199a4e41fdf310a6b9e43a64ec" translate="yes" xml:space="preserve">
          <source>About that option, &lt;a href=&quot;https://stackoverflow.com/users/88814/chhh&quot;&gt;chhh&lt;/a&gt; points out an alternative workflow in the comments:</source>
          <target state="translated">Об этой опции &lt;a href=&quot;https://stackoverflow.com/users/88814/chhh&quot;&gt;chhh&lt;/a&gt; указывает альтернативный рабочий процесс в комментариях:</target>
        </trans-unit>
        <trans-unit id="bb4474ba2d22fe6318f4eec43e35850507f38145" translate="yes" xml:space="preserve">
          <source>Actually, since Git 2.13 (Q2 2017), you can stash individual files, with &lt;a href=&quot;https://git-scm.com/docs/git-stash#git-stash-push-p--patch-k--no-keep-index-u--include-untracked-a--all-q--quiet-m--messageltmessagegt--ltpathspecgt82308203&quot;&gt;&lt;code&gt;git stash push&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">На самом деле, начиная с Git 2.13 (Q2 2017), вы можете хранить отдельные файлы с помощью &lt;a href=&quot;https://git-scm.com/docs/git-stash#git-stash-push-p--patch-k--no-keep-index-u--include-untracked-a--all-q--quiet-m--messageltmessagegt--ltpathspecgt82308203&quot;&gt; &lt;code&gt;git stash push&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7135bd9db653d9b6077d88b7250ff16db6d251c1" translate="yes" xml:space="preserve">
          <source>Add and stash</source>
          <target state="translated">Добавить и спрятать</target>
        </trans-unit>
        <trans-unit id="743b72fe73bcbefbf229a33018b9eb8173ba5d66" translate="yes" xml:space="preserve">
          <source>Add the files you don't want to stash, in &lt;strong&gt;Stage&lt;/strong&gt;, Then execute &lt;code&gt;git stash save --keep-index&lt;/code&gt;</source>
          <target state="translated">Добавьте файлы, которые вы не хотите хранить, в &lt;strong&gt;Stage&lt;/strong&gt; , затем выполните &lt;code&gt;git stash save --keep-index&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c7d8b720b7c0f6c21b7130953972935feb2f5e24" translate="yes" xml:space="preserve">
          <source>And you are done!
HTH.</source>
          <target state="translated">И тебе конец! HTH.</target>
        </trans-unit>
        <trans-unit id="4136e4007e2c8d131948d98078cb665d8a8d26f9" translate="yes" xml:space="preserve">
          <source>Another way to do this:</source>
          <target state="translated">Другой способ сделать это:</target>
        </trans-unit>
        <trans-unit id="ce496ab90d279274fb97c7bfa3a55ceeadd485b8" translate="yes" xml:space="preserve">
          <source>As noted in the comments, this puts everything into the stash, both staged and unstaged. The --keep-index just leaves the index alone after the stash is done. This can cause merge conflicts when you later pop the stash.</source>
          <target state="translated">Как отмечается в комментариях,это ставит все в тайник,как инсценированное,так и не инсценированное.Индекс --keep-index просто оставляет индекс в покое после того,как тайник закончен.Это может привести к конфликтам слияния,когда вы позже попадёте в тайник.</target>
        </trans-unit>
        <trans-unit id="862361b4bda865f168bcc4b92823a0735ce6fdeb" translate="yes" xml:space="preserve">
          <source>At the end of that rather cumbersome process, you will have only one or several files stashed.</source>
          <target state="translated">В конце этого довольно громоздкого процесса у вас будет спрятан только один или несколько файлов.</target>
        </trans-unit>
        <trans-unit id="1a3ba4e6b31c9bea16e353c7203ba33786bf7baa" translate="yes" xml:space="preserve">
          <source>Based on the answers this helped me.</source>
          <target state="translated">Основываясь на ответах,которые мне помогли.</target>
        </trans-unit>
        <trans-unit id="22fff67c767d0516b5e846a55dd470e2e86d67bd" translate="yes" xml:space="preserve">
          <source>Cleanup by saving the committed content in your file system while resetting back to the original commit:</source>
          <target state="translated">Очистка выполняется путем сохранения содержимого фиксации в файловой системе при возврате к исходному фиксации:</target>
        </trans-unit>
        <trans-unit id="c080cd50e87ddd8cdcf5b528cbfb79e38ed2a3ea" translate="yes" xml:space="preserve">
          <source>Code to copy into the file:</source>
          <target state="translated">Код для копирования в файл:</target>
        </trans-unit>
        <trans-unit id="3cb8a78fd388f1e0a369b14e984fcb8f1d595a12" translate="yes" xml:space="preserve">
          <source>Create a stash using &quot;Keep staged changes&quot;.</source>
          <target state="translated">Создайте заначку,используя функцию &quot;Сохранить инсценированные изменения&quot;.</target>
        </trans-unit>
        <trans-unit id="a8d9c85454bdcadad51329b124b5f4cb151710f2" translate="yes" xml:space="preserve">
          <source>Currently, the most reasonable method to be able to stash any specific tracked/untracked files is to:</source>
          <target state="translated">В настоящее время наиболее разумным методом,чтобы иметь возможность хранить любые конкретные отслеживаемые файлы,является:</target>
        </trans-unit>
        <trans-unit id="55823efb45056acba11210535a57d8bf0bf96db0" translate="yes" xml:space="preserve">
          <source>Done!</source>
          <target state="translated">Done!</target>
        </trans-unit>
        <trans-unit id="e2bcda84facb3954e32539ae66300758b6d834b2" translate="yes" xml:space="preserve">
          <source>Done.</source>
          <target state="translated">Done.</target>
        </trans-unit>
        <trans-unit id="df4dcc9c3ae831ad0fdd280485c8eea4e47475af" translate="yes" xml:space="preserve">
          <source>Every answer here is so complicated...</source>
          <target state="translated">Каждый ответ здесь такой сложный...</target>
        </trans-unit>
        <trans-unit id="e49ffff402ab9325665083150168c99e9a6478e7" translate="yes" xml:space="preserve">
          <source>Exact same behavior as stashing one file and popping it back in.</source>
          <target state="translated">Точно такое же поведение,как и при попытке спрятать один файл и вернуть его обратно.</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="1fe5228407ffb05904c59cac1306d84e2daa2894" translate="yes" xml:space="preserve">
          <source>Fix things up as necessary. Don't forget to &lt;code&gt;git add&lt;/code&gt; any changes.</source>
          <target state="translated">Исправьте вещи по мере необходимости. Не забудьте &lt;code&gt;git add&lt;/code&gt; изменения.</target>
        </trans-unit>
        <trans-unit id="aa7f63d4e6066b4a78cedb7e833a23d64d3d2181" translate="yes" xml:space="preserve">
          <source>For example, if you want to split an old commit into more than one changeset, you can use this procedure:</source>
          <target state="translated">Например,если вы хотите разделить старый коммит на более чем один changeset,вы можете использовать эту процедуру:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="3a03c42dd1f4f0035d3b34419cb7d2fba57c36ae" translate="yes" xml:space="preserve">
          <source>For one or several files, an intermediate solution would be to:</source>
          <target state="translated">Для одного или нескольких файлов промежуточным решением будет:</target>
        </trans-unit>
        <trans-unit id="15cdb6601dca3ddf7d51fb421f5e3bd57d9aade5" translate="yes" xml:space="preserve">
          <source>For revert a specific changed file in git, you can do the following line:</source>
          <target state="translated">Для возврата конкретного изменённого файла в git'е можно сделать следующую строку:</target>
        </trans-unit>
        <trans-unit id="e73f5afae9f7a8ff03b45ea0827caf0b2e1b8080" translate="yes" xml:space="preserve">
          <source>Git add everything else, then stash it.</source>
          <target state="translated">Добавь все остальное,а потом спрячь.</target>
        </trans-unit>
        <trans-unit id="27c0ca1334b2dcf4316e2b9fc6927373e3cde37a" translate="yes" xml:space="preserve">
          <source>Go see and upvote his answer, which should be the official one (instead of mine).</source>
          <target state="translated">Идите и проголосуйте за его ответ,который должен быть официальным (а не моим).</target>
        </trans-unit>
        <trans-unit id="2a229dd742ca3148fc0ba6f401048b2322d84262" translate="yes" xml:space="preserve">
          <source>Here is an actual example:</source>
          <target state="translated">Вот реальный пример:</target>
        </trans-unit>
        <trans-unit id="25d857c2b45e8ab70a18c51f3f8b8598ec32329f" translate="yes" xml:space="preserve">
          <source>How can I stash only one of multiple changed files on my branch?</source>
          <target state="translated">Как я могу спрятать только один из нескольких измененных файлов в своей ветке?</target>
        </trans-unit>
        <trans-unit id="f0d9150f5a4e0e0ba5645c3b28be5cfb5c9bd1bd" translate="yes" xml:space="preserve">
          <source>However that will save the full index (which may not be what you want since it might include other files already indexed),  and a partial worktree (which could look like the one you want to stash).</source>
          <target state="translated">Однако это сохранит полный индекс (который может быть не тем,что вы хотите,так как он может включать другие файлы,уже проиндексированные),и частичное рабочее дерево (которое может выглядеть как то,что вы хотите спрятать).</target>
        </trans-unit>
        <trans-unit id="075d0881bf26e12d6fb6ac7e405799e5a9b3e3a2" translate="yes" xml:space="preserve">
          <source>I came up with this after I (once again) came to this page and didn't like the first two answers (the first answer just doesn't answer the question and I didn't quite like working with the &lt;code&gt;-p&lt;/code&gt; interactive mode).</source>
          <target state="translated">Я придумал это после того, как я (еще раз) зашел на эту страницу, и мне не понравились первые два ответа (первый ответ просто не отвечает на вопрос, и мне не очень понравилась работа с интерактивным режимом &lt;code&gt;-p&lt;/code&gt; ) ,</target>
        </trans-unit>
        <trans-unit id="d5d2bd8013db9a47e96e58c6b9ec9f5a29589eb2" translate="yes" xml:space="preserve">
          <source>I don't know how to do it on command line, only using SourceTree. Lets say you have changed file A, and have two change hunks in file B. If you want to stash only the second hunk in file B and leave everything else untouched, do this:</source>
          <target state="translated">Я не знаю,как это сделать в командной строке,только с помощью SourceTree.Допустим,вы изменили файл A,и у вас есть две измененные ветки в файле B.Если вы хотите спрятать только вторую ветку в файле B и оставить все остальное нетронутым,сделайте это:</target>
        </trans-unit>
        <trans-unit id="a874d2d0992e3860b88ab2f12dd9245fdbba44fe" translate="yes" xml:space="preserve">
          <source>I found no answer to be what I needed and that is as easy as:</source>
          <target state="translated">Я не нашел ответа,который был бы тем,что мне нужно,и это так же просто:</target>
        </trans-unit>
        <trans-unit id="5a82939b366793acad2955758e0cd6337cab2689" translate="yes" xml:space="preserve">
          <source>I often find it more intuitive to do the inverse of @bukzor's approach. That is, to stage some changes, and then stash only those staged changes.</source>
          <target state="translated">Я часто нахожу более интуитивным делать обратный подход @bukzor.То есть инсценировать какие-то изменения,а потом прятать только эти инсценированные изменения.</target>
        </trans-unit>
        <trans-unit id="e5b35353e4a7a5ca0571a992cc79f4afec128dda" translate="yes" xml:space="preserve">
          <source>I would use &lt;code&gt;git stash save --patch&lt;/code&gt;. I don't find the interactivity to be annoying because there are options during it to apply the desired operation to entire files.</source>
          <target state="translated">Я бы использовал &lt;code&gt;git stash save --patch&lt;/code&gt; . Я не считаю, что интерактивность раздражает, потому что во время нее есть опции для применения желаемой операции ко всем файлам.</target>
        </trans-unit>
        <trans-unit id="5ff0ea383f4df4f090df0d3b676b12d0909672fd" translate="yes" xml:space="preserve">
          <source>I've reviewed answers and comments for this and a number of similar threads. Be aware that none of the following commands are correct for the purpose of being able to stash &lt;strong&gt;any specific tracked/untracked files&lt;/strong&gt;:</source>
          <target state="translated">Я просмотрел ответы и комментарии для этой и нескольких похожих тем. Имейте в виду, что ни одна из следующих команд не подходит для того, чтобы иметь возможность &lt;strong&gt;хранить какие-либо конкретные отслеживаемые / неотслеживаемые файлы&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="14d6fb15d5cbd4a735f2e73d5009e400fa37e045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;--patch&lt;/code&gt; doesn't work, a manual process might:</source>
          <target state="translated">Если &lt;code&gt;--patch&lt;/code&gt; не работает, ручной процесс может:</target>
        </trans-unit>
        <trans-unit id="8eefc863db3fefe1a9b1f1194d93e01a3fc2adae" translate="yes" xml:space="preserve">
          <source>If it's an untracked/new file, you will have to stage it first.</source>
          <target state="translated">Если это неопознанный файл,то сначала нужно его запустить.</target>
        </trans-unit>
        <trans-unit id="eca9740c1b0db36ac8f1d8d9f3e9d69f5ff495ee" translate="yes" xml:space="preserve">
          <source>If you do not want to specify a message with your stashed changes, pass the filename after a double-dash.</source>
          <target state="translated">Если вы не хотите указывать сообщение с припрятанными изменениями,передайте имя файла после двойного тире.</target>
        </trans-unit>
        <trans-unit id="2c7c7cae7facf5ea33cb51f35863da797eefc92b" translate="yes" xml:space="preserve">
          <source>If you want to stash some changed files, simply just</source>
          <target state="translated">Если вы хотите спрятать несколько изменённых файлов,то просто</target>
        </trans-unit>
        <trans-unit id="15af41659cfa5d06093bbbc486f953fc5a0fa87e" translate="yes" xml:space="preserve">
          <source>In order to get to the original state - which is a clear staging area and with only some select un-staged modifications, one could softly reset the index to get (without committing anything like you - bukzor - did).</source>
          <target state="translated">Для того,чтобы перейти в исходное состояние-которое является четкой сценической областью и только с некоторыми выбранными нестадийными модификациями,можно было мягко сбросить индекс,чтобы получить (без фиксации чего-либо подобного-bukzor-сделал).</target>
        </trans-unit>
        <trans-unit id="c072c90a2a489efdf9fac9db52a6e83337be0917" translate="yes" xml:space="preserve">
          <source>In some cases, the working tree changes may depend on the index changes, so when you stash the index changes, the working tree changes have a conflict. In this case, you'll get the usual unmerged conflicts that you can resolve with git merge/git mergetool/etc.</source>
          <target state="translated">В некоторых случаях изменение рабочего дерева может зависеть от изменения индекса,поэтому при хранении изменений индекса,изменения рабочего дерева имеют конфликт.В этом случае вы получите обычные конфликты,которые можно разрешить с помощью git'а mergegit mergetooletc.</target>
        </trans-unit>
        <trans-unit id="90fbb6d41a6712057db4f1a0763c63f4bb631a5e" translate="yes" xml:space="preserve">
          <source>In this situation I &lt;code&gt;git add -p&lt;/code&gt; (interactive), &lt;code&gt;git commit -m blah&lt;/code&gt; and then stash what's left if necessary.</source>
          <target state="translated">В этой ситуации я &lt;code&gt;git add -p&lt;/code&gt; (интерактивно), &lt;code&gt;git commit -m blah&lt;/code&gt; , а затем прячу то, что осталось, если необходимо.</target>
        </trans-unit>
        <trans-unit id="3a5637f855b7a41327dd2df48cbc48080b08a548" translate="yes" xml:space="preserve">
          <source>It will stash all &lt;strong&gt;unstaged&lt;/strong&gt; changed files</source>
          <target state="translated">Это сохранит все &lt;strong&gt;неустановленные&lt;/strong&gt; измененные файлы</target>
        </trans-unit>
        <trans-unit id="4422e44c20075e809127521eb898c42edd5b6a20" translate="yes" xml:space="preserve">
          <source>Just in case you actually mean &lt;strong&gt;discard changes&lt;/strong&gt; whenever you use &lt;code&gt;git stash&lt;/code&gt; (and don't really use git stash to stash it temporarily), in that case you can use</source>
          <target state="translated">На тот случай, если вы на самом деле имеете в виду &lt;strong&gt;отменить изменения&lt;/strong&gt; всякий раз, когда вы используете &lt;code&gt;git stash&lt;/code&gt; (и на самом деле не используете git stash для его временного хранения), в этом случае вы можете использовать</target>
        </trans-unit>
        <trans-unit id="32935b36a5f5e26c4444b624627b0c855eb8a9fa" translate="yes" xml:space="preserve">
          <source>Later execute this line</source>
          <target state="translated">Позже выполнить эту строку</target>
        </trans-unit>
        <trans-unit id="fd2d9b2d43239fad04643eaa4637132d00d10763" translate="yes" xml:space="preserve">
          <source>Let's say you have 3 files</source>
          <target state="translated">Допустим,у вас есть 3 файла</target>
        </trans-unit>
        <trans-unit id="eb4fdcc3d6368bf7ee124a151165fa1fc9e815b8" translate="yes" xml:space="preserve">
          <source>Local changes:</source>
          <target state="translated">Локальные изменения:</target>
        </trans-unit>
        <trans-unit id="aa53219349a4a345586fdbdd1d95e61564b71a38" translate="yes" xml:space="preserve">
          <source>Make file B look as if only second change is applied to it. (e.g. launch external diff tool and undo first change.)</source>
          <target state="translated">Сделайте так,чтобы файл B выглядел так,как будто к нему применено только второе изменение.(например,запустить внешний инструмент сравнения и отменить первое изменение).</target>
        </trans-unit>
        <trans-unit id="eec11f76d2dcd7598c060fe166e8ff8e72bd78e5" translate="yes" xml:space="preserve">
          <source>Mark some changes as &lt;code&gt;edit&lt;/code&gt;.</source>
          <target state="translated">Отметить некоторые изменения как &lt;code&gt;edit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="650f1f8b5dec5c314b37986f4d2ac0ea890449e4" translate="yes" xml:space="preserve">
          <source>Note the first &lt;code&gt;stash&lt;/code&gt; &amp;amp; &lt;code&gt;stash pop&lt;/code&gt; can be eliminated, you can carry all of your changes over to the &lt;code&gt;master&lt;/code&gt; branch when you checkout, but only if there are no conflicts. Also if you are creating a new branch for the partial changes you will need the stash.</source>
          <target state="translated">Обратите внимание, что первый &lt;code&gt;stash&lt;/code&gt; &amp;amp; &lt;code&gt;stash pop&lt;/code&gt; может быть исключен, вы можете перенести все свои изменения в &lt;code&gt;master&lt;/code&gt; ветку при оформлении заказа, но только в случае отсутствия конфликтов. Также, если вы создаете новую ветку для частичных изменений, вам понадобится тайник.</target>
        </trans-unit>
        <trans-unit id="c5c78d206c05e6e663215cafbb492dfa59435728" translate="yes" xml:space="preserve">
          <source>Now the stash contains a new entry that only contains the changes you had staged, and your working tree still contains any unstaged changes.</source>
          <target state="translated">Теперь тайник содержит новую запись,которая содержит только те изменения,которые вы инсценировали,а ваше рабочее дерево по-прежнему содержит любые нестационарные изменения.</target>
        </trans-unit>
        <trans-unit id="076012f2d09b0d7fc9c437a1349284e4523e3d40" translate="yes" xml:space="preserve">
          <source>Now you can stash the_one_file:</source>
          <target state="translated">Теперь вы можете спрятать файл_one_file:</target>
        </trans-unit>
        <trans-unit id="08df69accdc04cd6ba6ca9515ef459e8fefd885d" translate="yes" xml:space="preserve">
          <source>One complicated way would be to first commit everything:</source>
          <target state="translated">Одним из сложных способов было бы сначала все совершить:</target>
        </trans-unit>
        <trans-unit id="94c79a63ac0ac10d57150f7afeb04ec46930ec9e" translate="yes" xml:space="preserve">
          <source>Perform changes to your working copy that undo all the changes in file A. (e.g. launch external diff tool and make files match.)</source>
          <target state="translated">Выполните изменения в рабочей копии,которые отменяют все изменения в файле A.(например,запустите внешнюю утилиту сравнения и сделайте файлы соответствующими).</target>
        </trans-unit>
        <trans-unit id="4af916bfc4422becf22a0ea7b854897de4ffc3cb" translate="yes" xml:space="preserve">
          <source>Pop the temporary commit</source>
          <target state="translated">Pop временное обязательство</target>
        </trans-unit>
        <trans-unit id="b0b275dcbe41dc7499721ad2f066d4e42f379f51" translate="yes" xml:space="preserve">
          <source>Pop your temporary commit by running git reset, targetting the commit before your temporary one.</source>
          <target state="translated">Pop ваш временный коммит,запустив git сбросить,нацелившись на коммит перед вашим временным.</target>
        </trans-unit>
        <trans-unit id="c2673194f77c9e861c1429d63f16ebfe8513aac8" translate="yes" xml:space="preserve">
          <source>Quick Answer</source>
          <target state="translated">Быстрый ответ</target>
        </trans-unit>
        <trans-unit id="e66cee3c1d17dbeffaeb43aeb14fcf5685e6bb3e" translate="yes" xml:space="preserve">
          <source>Repeat, from #5, as necessary.</source>
          <target state="translated">Повторяю,с №5,по мере необходимости.</target>
        </trans-unit>
        <trans-unit id="8c5c5c108b84db3c117f913cf3ad3b98e03c39d6" translate="yes" xml:space="preserve">
          <source>Reset back to the original commit but checkout the_one_file from the new commit:</source>
          <target state="translated">Возврат к первоначальному коммиту,но извлечение файла_one_из нового коммита:</target>
        </trans-unit>
        <trans-unit id="30c928951de70841b96aa1dacfbf864c127130a7" translate="yes" xml:space="preserve">
          <source>Save the following code to a file, for example, named &lt;code&gt;stash&lt;/code&gt;. Usage is &lt;code&gt;stash &amp;lt;filename_regex&amp;gt;&lt;/code&gt;. The argument is the regular expression for the full path of the file. For example, to stash a/b/c.txt, &lt;code&gt;stash a/b/c.txt&lt;/code&gt; or &lt;code&gt;stash .*/c.txt&lt;/code&gt;, etc.</source>
          <target state="translated">Сохраните следующий код в файл, например, с именем &lt;code&gt;stash&lt;/code&gt; . Использование &lt;code&gt;stash &amp;lt;filename_regex&amp;gt;&lt;/code&gt; . Аргумент - это регулярное выражение для полного пути к файлу. Например, чтобы спрятать a / b / c.txt, &lt;code&gt;stash a/b/c.txt&lt;/code&gt; или &lt;code&gt;stash .*/c.txt&lt;/code&gt; и т. Д.</target>
        </trans-unit>
        <trans-unit id="cf3cd7fd50c4dd733be93409a6d379d65aa9f1ad" translate="yes" xml:space="preserve">
          <source>Similar situation. Did commit and realized it's not ok.</source>
          <target state="translated">Похожая ситуация.Совершил преступление и понял,что это не нормально.</target>
        </trans-unit>
        <trans-unit id="2dd070f208e2d644f96b6009c86ccb5c995b1410" translate="yes" xml:space="preserve">
          <source>Simplified example:</source>
          <target state="translated">Упрощенный пример:</target>
        </trans-unit>
        <trans-unit id="eab82bb11b720442295ac6e7c9bb18c084481e89" translate="yes" xml:space="preserve">
          <source>Since creating branches in Git is trivial you could just create a temporary branch and check the individual files into it.</source>
          <target state="translated">Поскольку создание веток в Git'е тривиально,вы можете просто создать временную ветку и проверить отдельные файлы в ней.</target>
        </trans-unit>
        <trans-unit id="6bf3d1ea47cad19c42b20b38c81ea910e93f7e29" translate="yes" xml:space="preserve">
          <source>Since git is fundamentally about managing a all repository &lt;em&gt;content&lt;/em&gt; and index (and not one or several files), &lt;code&gt;git stash&lt;/code&gt; deals, not surprisingly, &lt;del&gt;with the all working directory&lt;/del&gt;.</source>
          <target state="translated">Поскольку git по сути своей относится к управлению всем &lt;em&gt;содержимым&lt;/em&gt; и индексом репозитория (а не одним или несколькими файлами), не удивительно, что &lt;code&gt;git stash&lt;/code&gt; предлагает &lt;del&gt; со всем рабочим каталогом &lt;/del&gt; ,</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="7c825660c31a5a9b357c40643e0bc10564cc5e13" translate="yes" xml:space="preserve">
          <source>Sometimes I've made an unrelated change on my branch before I've committed it, and I want to move it to another branch and commit it separately (like master). I do this:</source>
          <target state="translated">Иногда я вносил несвязанные изменения в своё ответвление до того,как я зафиксировал его,и я хочу переместить его в другое ответвление и зафиксировать его отдельно (как хозяин).Я делаю это:</target>
        </trans-unit>
        <trans-unit id="420fa87618d4fef2b5b1df2e2cdb0e0f12b6cfa4" translate="yes" xml:space="preserve">
          <source>Stage everything</source>
          <target state="translated">Сценарий все</target>
        </trans-unit>
        <trans-unit id="6b9df5b64eecf55a53bf93609897fd58b05a7ff6" translate="yes" xml:space="preserve">
          <source>Stash not even needed...</source>
          <target state="translated">Тайник даже не нужен...</target>
        </trans-unit>
        <trans-unit id="edd8c461a5ed1179cb6ab0bac4a7febfaf34cd27" translate="yes" xml:space="preserve">
          <source>Stash only one file out of multiple files that have changed with Git</source>
          <target state="translated">Хранить только один файл из нескольких файлов,которые изменились с помощью Git'а.</target>
        </trans-unit>
        <trans-unit id="4b27096bc706b7059e20d1706b82f7d99e893100" translate="yes" xml:space="preserve">
          <source>Temporarily commit everything you don't want stashed.</source>
          <target state="translated">Временно совершать все,что ты не хочешь припрятать.</target>
        </trans-unit>
        <trans-unit id="84a8ba53964df2606edc2fe627ecb0d6689a435d" translate="yes" xml:space="preserve">
          <source>Temporarily commit the files you don't want to stash</source>
          <target state="translated">Временно фиксируйте файлы,которые вы не хотите спрятать.</target>
        </trans-unit>
        <trans-unit id="7be7048344d356766cd655be245dc6da4cb5d4b8" translate="yes" xml:space="preserve">
          <source>That &lt;code&gt;git stash&lt;/code&gt; is just a quicker and simple alternative to branching and doing stuff.</source>
          <target state="translated">Этот &lt;code&gt;git stash&lt;/code&gt; - просто более быстрая и простая альтернатива ветвлению и тому подобному.</target>
        </trans-unit>
        <trans-unit id="8ee8f8fb36616c01d080498785710e3bf447e74f" translate="yes" xml:space="preserve">
          <source>The idea is the same as what @VonC suggested using files outside the repository, you save the changes you want somewhere, remove the changes you don't want in your stash, and then re-apply the changes you moved out of the way. However, I used the git stash as the &quot;somewhere&quot; (and as a result, there's one extra step at the end: removing the cahnges you put in the stash, because you moved these out of the way as well).</source>
          <target state="translated">Идея та же,что @VonC предложил использовать файлы вне репозитория,вы сохраняете нужные вам изменения где-то,удаляете ненужные изменения в своей заначке,а затем заново применяете изменения,которые вы перенесли с дороги.Тем не менее,я использовал git-запрятки как &quot;где-то&quot; (и в результате в конце есть ещё один дополнительный шаг:удаление кангеев,которые вы положили в заначку,потому что вы их тоже сдвинули с места).</target>
        </trans-unit>
        <trans-unit id="0d22e22331af7daef04e4225975a160cdf709da5" translate="yes" xml:space="preserve">
          <source>The original answer (below, June 2010) was about manually selecting what you want to stash.</source>
          <target state="translated">Оригинальный ответ (ниже,июнь 2010 г.)был о ручном выборе того,что вы хотите спрятать.</target>
        </trans-unit>
        <trans-unit id="5d345b6974d59d52ad9260ee17f4883e5949ed94" translate="yes" xml:space="preserve">
          <source>The problem with VonC's `intermediate' solution of copying files to outside the Git repo is that you lose path information, which makes copying a bunch of files back later on somewhat of a hassle.</source>
          <target state="translated">Проблема с &quot;промежуточным&quot; решением VonC по копированию файлов за пределы Git-репо заключается в том,что вы теряете информацию о путях,что делает копирование кучи файлов позже несколько хлопотным.</target>
        </trans-unit>
        <trans-unit id="2ccb766e9519824c270d8b3830a503b2f19527b8" translate="yes" xml:space="preserve">
          <source>The stash entry is constructed such that its index state is the same as the index state of your repository, and its worktree contains only the changes you selected interactively. The selected changes are then rolled back from your worktree.</source>
          <target state="translated">Запись тайника построена таким образом,что ее индексное состояние совпадает с индексным состоянием вашего репозитория,а ее рабочее дерево содержит только те изменения,которые вы выбрали интерактивно.Выбранные изменения затем откатываются из вашего рабочего дерева.</target>
        </trans-unit>
        <trans-unit id="3a220b4812842986a6738a397e029485deb28100" translate="yes" xml:space="preserve">
          <source>Then afterwards</source>
          <target state="translated">Затем после этого</target>
        </trans-unit>
        <trans-unit id="9ea5143f8a20ae87159a02e90007453bda4b3045" translate="yes" xml:space="preserve">
          <source>This (the &lt;code&gt;stash --patch&lt;/code&gt; original solution) is nice, but often I've modified a lot of files so using patch is annoying</source>
          <target state="translated">Это (оригинальное решение &lt;code&gt;stash --patch&lt;/code&gt; ) хорошо, но часто я модифицировал много файлов, поэтому использование патча раздражает</target>
        </trans-unit>
        <trans-unit id="17e5217c603c6f78e62cd64885f6311492cce07f" translate="yes" xml:space="preserve">
          <source>This can all be done in a matter of seconds in SourceTree, where you can just click on the files (or even individual lines) you want to add.  Once added, just commit them to a temporary commit.  Next, click the checkbox to add all changes, then click stash to stash everything.  With the stashed changes out of the way, glance over at your commit list and note the hash for the commit before your temporary commit, then run 'git reset hash_b4_temp_commit', which is basically like &quot;popping&quot; the commit by resetting your branch to the commit right before it.   Now, you're left with just the stuff you didn't want stashed.</source>
          <target state="translated">Все это можно сделать за считанные секунды в SourceTree,где вы можете просто нажать на файлы (или даже на отдельные строки),которые вы хотите добавить.После добавления просто зафиксируйте их во временной фиксации.Затем щелкните по флажку,чтобы добавить все изменения,затем щелкните по тайнику,чтобы спрятать все.Когда спрятанные изменения окажутся вне пути,посмотрите на свой список коммитов и заметьте хэш для коммита перед вашим временным коммитом,затем запустите 'git сбросит хэш_b4_temp_commit',что в основном похоже на &quot;выскакивание&quot; коммита,сбросив ветку в коммит прямо перед ним.Теперь у вас остались только те вещи,которые вы не хотели прятать.</target>
        </trans-unit>
        <trans-unit id="7117598aceda9c135c89ce2e4abeefc17347acfc" translate="yes" xml:space="preserve">
          <source>This can be done easily in 3 steps using SourceTree.</source>
          <target state="translated">Это можно легко сделать в 3 этапа с помощью SourceTree.</target>
        </trans-unit>
        <trans-unit id="b800e1bd5fd0f0ad42e9a5619dc1577a5b072a89" translate="yes" xml:space="preserve">
          <source>This is going to prompt: &lt;code&gt;Stash this hunk [y,n,q,a,d,j,J,g,/,e,?]? ?&lt;/code&gt;. Just type &lt;code&gt;a&lt;/code&gt; (stash this hunk and all later hunks in the file) and you're fine.</source>
          <target state="translated">Это будет подсказывать: &lt;code&gt;Stash this hunk [y,n,q,a,d,j,J,g,/,e,?]? ?&lt;/code&gt; ? , Просто введите (спрятать этот кусок и все последующие фрагменты в файле), и все в порядке.</target>
        </trans-unit>
        <trans-unit id="a19324c0067c138256242ccb3a75f73850b46299" translate="yes" xml:space="preserve">
          <source>This method works in git versions 2.13+</source>
          <target state="translated">Этот метод работает в git-версиях 2.13+.</target>
        </trans-unit>
        <trans-unit id="62eeb479cbfd7377bc460bb179f52f97bde85fbc" translate="yes" xml:space="preserve">
          <source>This stashes exactly one file.</source>
          <target state="translated">Здесь спрятан ровно один файл.</target>
        </trans-unit>
        <trans-unit id="50799cda9a68deb4560e323345e578a4b1005de1" translate="yes" xml:space="preserve">
          <source>This to pop the file change back:</source>
          <target state="translated">Это,чтобы всплыло обратно изменение файла:</target>
        </trans-unit>
        <trans-unit id="691ac3501be3980e3c931957ea90bd9b59815ede" translate="yes" xml:space="preserve">
          <source>This will stash everything that you haven't previously added. Just &lt;code&gt;git add&lt;/code&gt; the things you want to keep, then run it.</source>
          <target state="translated">Это сохранит все, что вы еще не добавили. Просто &lt;code&gt;git add&lt;/code&gt; то, что вы хотите сохранить, и запустите.</target>
        </trans-unit>
        <trans-unit id="6a0aec42528d84f6c57c24635469b696aa26bdfa" translate="yes" xml:space="preserve">
          <source>To &quot;stash&quot; a particular file/dir only:</source>
          <target state="translated">Только для того,чтобы &quot;спрятать&quot; конкретного заявителя:</target>
        </trans-unit>
        <trans-unit id="86d9d505be38e876d178a0da76d193b877f5c668" translate="yes" xml:space="preserve">
          <source>To create a stash &quot;my_stash&quot; with only the changes on &lt;strong&gt;file_C&lt;/strong&gt;:</source>
          <target state="translated">Чтобы создать тайник &quot;my_stash&quot; только с изменениями в &lt;strong&gt;file_C&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="e6425ba1dc11119c05f1ea66f10e97616263106b" translate="yes" xml:space="preserve">
          <source>To stash a single file use &lt;code&gt;git stash --patch [file]&lt;/code&gt;.</source>
          <target state="translated">Чтобы сохранить один файл, используйте &lt;code&gt;git stash --patch [file]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49c77d7ef2e46ac894583e1fbb20721b5ede6e8f" translate="yes" xml:space="preserve">
          <source>Try to add the files using  &quot;&lt;code&gt;git add filepath&lt;/code&gt;&quot;.</source>
          <target state="translated">Попробуйте добавить файлы, используя &quot; &lt;code&gt;git add filepath&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="aea2cdabf3d10902b67a033c2abfd3bb2aac8e6b" translate="yes" xml:space="preserve">
          <source>Unfortunately, git doesn't offer a git stash --only-index or similar, so I whipped up a script to do this.</source>
          <target state="translated">К сожалению,git не предлагает git-заначку --only-index или что-то в этом роде,так что я взбил скрипт,чтобы сделать это.</target>
        </trans-unit>
        <trans-unit id="f1b9488a2385748295ea36f4273710d79af0d34f" translate="yes" xml:space="preserve">
          <source>Unstage everything</source>
          <target state="translated">Разобрать все на сцене</target>
        </trans-unit>
        <trans-unit id="a46b1cbd80ccc50bd881e024bbbe5b5d13d6bac3" translate="yes" xml:space="preserve">
          <source>Update (2/14/2015) - I've rewritten the script a bit, to better handle the case of conflicts, which should now be presented as unmerged conflicts rather than .rej files.</source>
          <target state="translated">Обновление (2142015)-Я немного переписал скрипт,чтобы лучше справляться со случаями конфликтов,которые теперь должны быть представлены как неуправляемые конфликты,а не как .rej-файлы.</target>
        </trans-unit>
        <trans-unit id="baab9726ea3df64ea0852a76e09cb208af29343e" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git stash push&lt;/code&gt;, like this:</source>
          <target state="translated">Используйте &lt;code&gt;git stash push&lt;/code&gt; , как это:</target>
        </trans-unit>
        <trans-unit id="5b8ef5eac7c82ff1543f1bd46bdab36501959d3c" translate="yes" xml:space="preserve">
          <source>What about this to &quot;stash&quot;:</source>
          <target state="translated">А как насчет этого,чтобы &quot;спрятать&quot;:</target>
        </trans-unit>
        <trans-unit id="ab7a2d5695e40ac3768aebbb0094b4455f5b7ea9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;git stash -p&lt;/code&gt; (or &lt;code&gt;git add -p&lt;/code&gt; with &lt;code&gt;stash --keep-index&lt;/code&gt;) would be too cumbersome, I found it easier to use &lt;code&gt;diff&lt;/code&gt;, &lt;code&gt;checkout&lt;/code&gt; and &lt;code&gt;apply&lt;/code&gt;:</source>
          <target state="translated">Когда &lt;code&gt;git stash -p&lt;/code&gt; (или &lt;code&gt;git add -p&lt;/code&gt; с &lt;code&gt;stash --keep-index&lt;/code&gt; ) будет слишком громоздким, я обнаружил, что проще использовать &lt;code&gt;diff&lt;/code&gt; , &lt;code&gt;checkout&lt;/code&gt; и &lt;code&gt;apply&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9d172c009b80d14e34e33f98fd159d98f4072718" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;pathspec&lt;/code&gt; is given to '&lt;code&gt;git stash push&lt;/code&gt;', the new stash records the modified states only for the files that match the pathspec
  See &quot;&lt;a href=&quot;https://stackoverflow.com/a/42963606/6309&quot;&gt;Stash changes to specific files&lt;/a&gt;&quot; for more.</source>
          <target state="translated">Когда для &lt;code&gt;pathspec&lt;/code&gt; задано ' &lt;code&gt;git stash push&lt;/code&gt; ', новый stash записывает измененные состояния только для файлов, которые соответствуют pathspec. Дополнительные сведения см. В разделе &amp;laquo; &lt;a href=&quot;https://stackoverflow.com/a/42963606/6309&quot;&gt;Stash изменения в конкретных файлах&lt;/a&gt; &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="87971133a5333cd55e42a26806d4eaec0c3f1e60" translate="yes" xml:space="preserve">
          <source>When you try to switch between two branches, this situation occurs.</source>
          <target state="translated">При попытке переключения между двумя ветвями возникает ситуация.</target>
        </trans-unit>
        <trans-unit id="d649b75edf837b6306017bb83719947ad693f78e" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;--patch&lt;/code&gt;, you can interactively select hunks from in the diff between HEAD and the working tree to be stashed.</source>
          <target state="translated">С помощью &lt;code&gt;--patch&lt;/code&gt; вы можете интерактивно выбирать фрагменты в разнице между HEAD и рабочим деревом, которое нужно спрятать.</target>
        </trans-unit>
        <trans-unit id="aa1c3abc8084be098568844f6996896558134eea" translate="yes" xml:space="preserve">
          <source>Yeah, somewhat awkward...</source>
          <target state="translated">Да,немного неловко...</target>
        </trans-unit>
        <trans-unit id="c9f2eb360a15ad6ed722e9d8555407417d90f97c" translate="yes" xml:space="preserve">
          <source>Yet, &lt;code&gt;git stash save --patch&lt;/code&gt; could allows you to achieve the partial stashing you are after:</source>
          <target state="translated">Тем не менее, &lt;code&gt;git stash save --patch&lt;/code&gt; может позволить вам получить частичное копирование, после которого вы:</target>
        </trans-unit>
        <trans-unit id="3f1be61500355488e493333982003f539132d24b" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;git stash save -p &quot;my commit message&quot;&lt;/code&gt;. This way you can select which hunks should be added to stash, whole files can be selected as well.</source>
          <target state="translated">Вы также можете использовать &lt;code&gt;git stash save -p &quot;my commit message&quot;&lt;/code&gt; . Таким образом, вы можете выбрать, какие блоки должны быть добавлены в тайник, а также целые файлы.</target>
        </trans-unit>
        <trans-unit id="ad4e76b5c8d7ff2da88debfc6b480fc39bdb5abc" translate="yes" xml:space="preserve">
          <source>You can save the above script as &lt;code&gt;git-stash-index&lt;/code&gt; somewhere on your path, and can then invoke it as git stash-index</source>
          <target state="translated">Вы можете сохранить вышеприведенный скрипт как &lt;code&gt;git-stash-index&lt;/code&gt; где - нибудь на вашем пути, а затем вызвать его как git stash-index</target>
        </trans-unit>
        <trans-unit id="380ad06d71407fd61c34f44b21511840d455dfd7" translate="yes" xml:space="preserve">
          <source>You can simplify it assuming no conflicts and no new branch:</source>
          <target state="translated">Вы можете упростить его,если не будет конфликтов и не будет новой ветки:</target>
        </trans-unit>
        <trans-unit id="043b8e3d4be0404b821150e0c77829eeafce2208" translate="yes" xml:space="preserve">
          <source>You can simply do this:</source>
          <target state="translated">Ты можешь просто сделать это:</target>
        </trans-unit>
        <trans-unit id="a749b7909f59e7698cf699c682b1654f1ee84d24" translate="yes" xml:space="preserve">
          <source>You can use &lt;em&gt;git status&lt;/em&gt; between the steps to see what is going on.</source>
          <target state="translated">Вы можете использовать &lt;em&gt;git status&lt;/em&gt; между шагами, чтобы увидеть, что происходит.</target>
        </trans-unit>
        <trans-unit id="63759cabbe2219f599293c31908dcd6721451bee" translate="yes" xml:space="preserve">
          <source>You'll be prompted with a few actions for each hunk:</source>
          <target state="translated">Вам будут предложены несколько действий для каждого кусочка:</target>
        </trans-unit>
        <trans-unit id="c5d604e1d8950a1e28a32da7927813a33436c01a" translate="yes" xml:space="preserve">
          <source>[&lt;strong&gt;NOTE&lt;/strong&gt;]</source>
          <target state="translated">[&lt;strong&gt;NOTE&lt;/strong&gt;]</target>
        </trans-unit>
        <trans-unit id="7e87627c92eefc978614db7f9336cf8b74ca03c5" translate="yes" xml:space="preserve">
          <source>add &lt;em&gt;file_C&lt;/em&gt; to the staging area</source>
          <target state="translated">добавить &lt;em&gt;file_C&lt;/em&gt; в область подготовки</target>
        </trans-unit>
        <trans-unit id="dc5955241919bf574c188eaa7de743d4a25f52a6" translate="yes" xml:space="preserve">
          <source>and you want to stash only b.rb and c.rb but not a.rb</source>
          <target state="translated">и ты хочешь спрятать только b.rb и c.rb,но не a.rb.</target>
        </trans-unit>
        <trans-unit id="53e1f3406388b2a79d1e005eb5e4331e673ce087" translate="yes" xml:space="preserve">
          <source>apply the changes in &quot;temp_stash&quot; (file_A and file_B) on your local code and delete the stash</source>
          <target state="translated">применить изменения в &quot;temp_stash&quot; (файл_A и файл_B)к вашему локальному коду и удалить заначку</target>
        </trans-unit>
        <trans-unit id="876e40895666aff4f765839a07672655db12e71d" translate="yes" xml:space="preserve">
          <source>copy them back</source>
          <target state="translated">переписывать их обратно</target>
        </trans-unit>
        <trans-unit id="15c125b10ac674cd8657f770e10cd1ff240511f0" translate="yes" xml:space="preserve">
          <source>copy them outside the Git repo</source>
          <target state="translated">скопировать их за пределами Git repo</target>
        </trans-unit>
        <trans-unit id="390624993351e6fc81dbe108314b3847bdcbb7da" translate="yes" xml:space="preserve">
          <source>create a temporary stash named &quot;temp_stash&quot; and keep the changes on file_C</source>
          <target state="translated">создать временный тайник с именем &quot;temp_stash&quot; и сохранить изменения в файле_C</target>
        </trans-unit>
        <trans-unit id="ab823066c632468444e4dbe99a2cd07b70c36d86" translate="yes" xml:space="preserve">
          <source>create the wanted stash (&quot;my_stash&quot;) with only the changes on file_C</source>
          <target state="translated">создать разыскиваемый тайник (&quot;my_stash&quot;)с изменениями только на file_C</target>
        </trans-unit>
        <trans-unit id="d8d73423bc6e0268beaa3cd949a40a52d998d1b1" translate="yes" xml:space="preserve">
          <source>etc. (see VonC's `intermediate' suggestion)</source>
          <target state="translated">и всё такое (см.&quot;промежуточное&quot; предложение VonC).</target>
        </trans-unit>
        <trans-unit id="4228d495d714e89bd7d60589077fd1998a387166" translate="yes" xml:space="preserve">
          <source>file_A (modified) not staged</source>
          <target state="translated">файл_A (модифицированный)не инсценированный</target>
        </trans-unit>
        <trans-unit id="19ce18b4e0ed171b7f49aa2e46065100c897d3e9" translate="yes" xml:space="preserve">
          <source>file_B (modified) not staged</source>
          <target state="translated">файл_B (модифицированный)не инсценированный</target>
        </trans-unit>
        <trans-unit id="b5e64d481edf4a5825fdbc868b5e472e1c711cfc" translate="yes" xml:space="preserve">
          <source>file_C (modified) not staged</source>
          <target state="translated">файл_C (модифицированный)не инсценированный</target>
        </trans-unit>
        <trans-unit id="b96b2a7150dfde3f0cad72b90e383b05bfe50a00" translate="yes" xml:space="preserve">
          <source>git checkout path/to/some/file path/to/some/other/file</source>
          <target state="translated">контрольно-кассовый паттосомфельный паттосомфельный файл</target>
        </trans-unit>
        <trans-unit id="48990e38fbc991cfecd7555a4a3686c57c77f6e8" translate="yes" xml:space="preserve">
          <source>git stash</source>
          <target state="translated">гит-тайник</target>
        </trans-unit>
        <trans-unit id="481bdc59a90b18e88cf45a0637a8ba4fbed5122b" translate="yes" xml:space="preserve">
          <source>might be a better fit.</source>
          <target state="translated">может быть лучше подойдет.</target>
        </trans-unit>
        <trans-unit id="4ed4d8085c2c68fd5f785c4e99bb65ac8184221b" translate="yes" xml:space="preserve">
          <source>or with an optional message</source>
          <target state="translated">или с дополнительным сообщением</target>
        </trans-unit>
        <trans-unit id="a816c8162eaac6ecf2c9e85cb8880704e0705547" translate="yes" xml:space="preserve">
          <source>tar cvf /tmp/stash.tar path/to/some/file path/to/some/other/file  (... etc.)</source>
          <target state="translated">tar cvf tmpstash.tar pathtosomefile pathtosomefile pathtosomeotherfile (...и т.д.)</target>
        </trans-unit>
        <trans-unit id="755c3eb88bdacd1ca047b75217567729d005d74e" translate="yes" xml:space="preserve">
          <source>tar xvf /tmp/stash.tar</source>
          <target state="translated">tar xvf tmpstash.tar</target>
        </trans-unit>
        <trans-unit id="0d51416870ddb2d8f98d3c216a97ebaf94344ff3" translate="yes" xml:space="preserve">
          <source>you can do something like this</source>
          <target state="translated">ты можешь сделать что-нибудь подобное</target>
        </trans-unit>
        <trans-unit id="252f4f3aa6128e48acca70b06bba6179259d685d" translate="yes" xml:space="preserve">
          <source>you should &quot;&lt;code&gt;git reset --soft&lt;/code&gt;&quot; after such a stash to get your clear staging back:</source>
          <target state="translated">Вы должны &quot; &lt;code&gt;git reset --soft&lt;/code&gt; &quot; после такого тайника , чтобы получить чистую постановку:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
