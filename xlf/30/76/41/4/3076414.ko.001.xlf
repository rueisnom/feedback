<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3076414">
    <body>
      <group id="3076414">
        <trans-unit id="b7833e2a423077d8f5e6c590b2a45f83ae467e2f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.w3.org/TR/access-control/&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt; (CORS) is a W3C Working Draft that defines how the browser and server must communicate when accessing sources across origins. The basic idea behind CORS is to use custom HTTP headers to allow both the browser and the server to know enough about each other to determine if the request or response should succeed or fail.</source>
          <target state="translated">CORS ( &lt;a href=&quot;http://www.w3.org/TR/access-control/&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt; )는 여러 출처에서 소스에 액세스 할 때 브라우저와 서버가 통신해야하는 방법을 정의하는 W3C 실무 초안입니다. CORS의 기본 개념은 사용자 정의 HTTP 헤더를 사용하여 브라우저와 서버가 서로에 대해 충분히 알도록하여 요청 또는 응답의 성공 또는 실패 여부를 판별하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6c1949e65910c6d04b0c0a03a3c9483687d13f8f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ripper234/Whatever-Origin&quot;&gt;Code on github&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ripper234/Whatever-Origin&quot;&gt;github의 코드입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee0a89efee82cede3b7d0ed3c2e7c50b576c1f04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window.postMessage&lt;/code&gt;, when called, causes a &lt;code&gt;MessageEvent&lt;/code&gt; to be dispatched at the target window when any pending script that must be executed completes (e.g. remaining event handlers if &lt;code&gt;window.postMessage&lt;/code&gt; is called from an event handler, previously-set pending timeouts, etc.). The &lt;code&gt;MessageEvent&lt;/code&gt; has the type message, a &lt;code&gt;data&lt;/code&gt; property which is set to the string value of the first argument provided to &lt;code&gt;window.postMessage&lt;/code&gt;, an &lt;code&gt;origin&lt;/code&gt; property corresponding to the origin of the main document in the window calling &lt;code&gt;window.postMessage&lt;/code&gt; at the time &lt;code&gt;window.postMessage&lt;/code&gt; was called, and a &lt;code&gt;source&lt;/code&gt; property which is the window from which &lt;code&gt;window.postMessage&lt;/code&gt; is called.</source>
          <target state="translated">&lt;code&gt;window.postMessage&lt;/code&gt; 를 호출하면 실행해야하는 보류중인 스크립트가 완료 될 때 대상 창에서 &lt;code&gt;MessageEvent&lt;/code&gt; 가 전달됩니다 (예 : &lt;code&gt;window.postMessage&lt;/code&gt; 가 이벤트 핸들러에서 호출 된 경우 나머지 이벤트 핸들러, 이전에 설정된 보류 시간 초과 등). ). &lt;code&gt;MessageEvent&lt;/code&gt; 에는 시간 &lt;code&gt;window.postMessage&lt;/code&gt; 에서 &lt;code&gt;window.postMessage&lt;/code&gt; 를 호출하는 창에서 기본 문서의 원점에 해당하는 &lt;code&gt;origin&lt;/code&gt; 속성 인 &lt;code&gt;window.postMessage&lt;/code&gt; 에 제공된 첫 번째 인수의 문자열 값으로 설정되는 &lt;code&gt;data&lt;/code&gt; 속성 인 message 유형이 있습니다. postMessage 가 호출되었고 &lt;code&gt;window.postMessage&lt;/code&gt; 가 호출되는 창인 &lt;code&gt;source&lt;/code&gt; 특성입니다.</target>
        </trans-unit>
        <trans-unit id="a7ad2378548934906f4054b49078fa539f244659" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Reverse Proxy method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;리버스 프록시 방법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="852da2d726c809645e72eb48229d39be07b8fae6" translate="yes" xml:space="preserve">
          <source>After that statement executes, the page would pass the origin check with &lt;code&gt;http://company.com/dir/page.html&lt;/code&gt;. However, by the same reasoning, company.com could not set &lt;code&gt;document.domain&lt;/code&gt;  to &lt;code&gt;othercompany.com&lt;/code&gt;.</source>
          <target state="translated">해당 명령문이 실행 된 후 페이지는 &lt;code&gt;http://company.com/dir/page.html&lt;/code&gt; 을 사용 하여 원본 확인을 통과합니다. 그러나 같은 이유로 company.com은 &lt;code&gt;document.domain&lt;/code&gt; 을 &lt;code&gt;othercompany.com&lt;/code&gt; 으로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f2aa3cd77cfc29f75dd036615866f4750568d3ef" translate="yes" xml:space="preserve">
          <source>And a &lt;code&gt;receiveMessage&lt;/code&gt; function must be declared:</source>
          <target state="translated">그리고 &lt;code&gt;receiveMessage&lt;/code&gt; 함수가 선언되어야합니다 :</target>
        </trans-unit>
        <trans-unit id="a140c5ee37bfe6b024477d0131a34026e855fe06" translate="yes" xml:space="preserve">
          <source>Any window may access this method on any other window, at any time, regardless of the location of the document in the window, to send it a message. Consequently, any event listener used to receive messages must  first check the identity of the sender of the message, using the origin  and possibly source properties. This cannot be understated: &lt;strong&gt;Failure to check the &lt;code&gt;origin&lt;/code&gt; and possibly &lt;code&gt;source&lt;/code&gt; properties enables cross-site scripting attacks.&lt;/strong&gt;</source>
          <target state="translated">모든 윈도우는 윈도우에서 문서의 위치에 관계없이 언제든지 다른 윈도우에서이 메소드에 액세스하여 메시지를 보낼 수 있습니다. 결과적으로, 메시지를 수신하는 데 사용되는 이벤트 리스너는 먼저 출처 및 가능하면 소스 특성을 사용하여 메시지 송신자의 신원을 확인해야합니다. 이것은 과소 평가 될 수 없습니다 &lt;strong&gt;. &lt;code&gt;origin&lt;/code&gt; 및 &lt;code&gt;source&lt;/code&gt; 속성을 확인하지 못하면 교차 사이트 스크립팅 공격이 가능합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10a4c9065bf6e4b334fe844fd761eb45017a9a23" translate="yes" xml:space="preserve">
          <source>AnyOrigin didn't function well with some https sites, so I just wrote an open source alternative called &lt;a href=&quot;http://whateverorigin.org&quot;&gt;whateverorigin.org&lt;/a&gt; that seems to work well with https.</source>
          <target state="translated">AnyOrigin은 일부 https 사이트에서 제대로 작동하지 않으므로 https와 잘 작동하는 &lt;a href=&quot;http://whateverorigin.org&quot;&gt;whateverorigin.org&lt;/a&gt; 라는 오픈 소스 대안을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="5cfb29d97319e1c11297db533a66383b0cf24be8" translate="yes" xml:space="preserve">
          <source>Basically, you add</source>
          <target state="translated">기본적으로</target>
        </trans-unit>
        <trans-unit id="c925158355cef0b501627fc58bee773199306382" translate="yes" xml:space="preserve">
          <source>For a simple request, one that uses either &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt; with no custom headers and whose body is &lt;code&gt;text/plain&lt;/code&gt;, the request is sent with an extra header called &lt;code&gt;Origin&lt;/code&gt;. The Origin  header contains the origin (protocol, domain name, and port) of the requesting page so that the server can easily determine whether or not it should serve a response. An example &lt;code&gt;Origin&lt;/code&gt; header might look like this:</source>
          <target state="translated">사용자 정의 헤더없이 &lt;code&gt;GET&lt;/code&gt; 또는 &lt;code&gt;POST&lt;/code&gt; 를 사용하고 본문이 &lt;code&gt;text/plain&lt;/code&gt; 인 간단한 요청의 경우 요청은 &lt;code&gt;Origin&lt;/code&gt; 이라는 추가 헤더와 함께 전송됩니다. Origin 헤더에는 요청 페이지의 출처 (프로토콜, 도메인 이름 및 포트)가 포함되어 있으므로 서버가 응답을 제공해야하는지 여부를 쉽게 결정할 수 있습니다. &lt;code&gt;Origin&lt;/code&gt; 헤더의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3b1e301acde443e6a3529e0987def0e7f264ce09" translate="yes" xml:space="preserve">
          <source>For postMessage solution take a look to:</source>
          <target state="translated">postMessage 솔루션의 경우 다음을 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="53e8475662e93dba88421445f46ad6c63933d3ec" translate="yes" xml:space="preserve">
          <source>Here are some workarounds and explanation of same-origin-policy:</source>
          <target state="translated">다음은 동일 출처 정책에 대한 해결 방법과 설명입니다.</target>
        </trans-unit>
        <trans-unit id="3e6b094c0445f22c160924768c1e7ab7f2ab31f7" translate="yes" xml:space="preserve">
          <source>Here is the javascript that makes the call to the PHP file</source>
          <target state="translated">다음은 PHP 파일을 호출하는 자바 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="537caecf2ec6ad1c68d699677791ce8433c9fb7a" translate="yes" xml:space="preserve">
          <source>Here's some example javascript code from anyorigin:</source>
          <target state="translated">다음은 anyorigin의 일부 자바 스크립트 코드입니다.</target>
        </trans-unit>
        <trans-unit id="3278a912757a0d6e80e30697203ac1e8cafe560f" translate="yes" xml:space="preserve">
          <source>I can't claim credit for this image, but it matches everything I know on this subject and offers a bit of humor at the same time.</source>
          <target state="translated">이 이미지에 대한 크레딧을 청구 할 수는 없지만이 주제에 대해 알고있는 모든 내용과 일치하며 동시에 약간의 유머를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="74c377ed5d488a0f2fa67627324bdc55383950d3" translate="yes" xml:space="preserve">
          <source>I use JSONP.</source>
          <target state="translated">JSONP를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="aedea270bebebbb6df92ec87e80f61f22f17c4a8" translate="yes" xml:space="preserve">
          <source>I wanted to make a community wiki regarding HTML/JS &lt;strong&gt;same-origin policies&lt;/strong&gt; to hopefully help anyone searching for this topic. This is one of the most searched-for topics on SO and there is no consolidated wiki for it so here I go :)</source>
          <target state="translated">HTML / JS &lt;strong&gt;동일 출처 정책&lt;/strong&gt; 에 관한 커뮤니티 위키를 만들고 싶었습니다. 이것은 SO에서 가장 많이 검색되는 주제 중 하나이며 통합 위키는 없으므로 여기로 이동하십시오.)</target>
        </trans-unit>
        <trans-unit id="22c5475470c98c78fca56cdbe0c4a8fe32dc678d" translate="yes" xml:space="preserve">
          <source>I've found it pretty useful :)</source>
          <target state="translated">나는 그것이 매우 유용하다는 것을 알았다 :)</target>
        </trans-unit>
        <trans-unit id="ec716be49a189dc96ebedce425b2a3743464479e" translate="yes" xml:space="preserve">
          <source>If the server decides that the request should be allowed, it sends a &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header echoing back the same origin that was sent or &lt;code&gt;*&lt;/code&gt; if it&amp;rsquo;s a public resource. For example:</source>
          <target state="translated">서버가 요청이 허용되어야한다고 결정하면, 전송 된 것과 동일한 출발지 또는 공개 자원 인 경우 &lt;code&gt;*&lt;/code&gt; 를 반환하는 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더를 보냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84dc7308e5f2df5426df8cd061732eb7a35d1815" translate="yes" xml:space="preserve">
          <source>If this header is missing, or the origins don&amp;rsquo;t match, then the browser disallows the request. If all is well, then the browser processes the request. Note that neither the requests nor responses include cookie information.</source>
          <target state="translated">이 헤더가 없거나 출처가 일치하지 않으면 브라우저가 요청을 허용하지 않습니다. 모두 정상이면 브라우저가 요청을 처리합니다. 요청이나 응답에는 쿠키 정보가 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0893afbcb9175e0c3093ac7ce7fbcc9d22c724f2" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;http://httpd.apache.org/docs/2.0/mod/mod_proxy.html&quot;&gt;mod_proxy&lt;/a&gt; in Apache, the fundamental configuration directive to set up a reverse proxy is the &lt;code&gt;ProxyPass&lt;/code&gt;. It is typically used as follows:</source>
          <target state="translated">Apache에서 &lt;a href=&quot;http://httpd.apache.org/docs/2.0/mod/mod_proxy.html&quot;&gt;mod_proxy&lt;/a&gt; 를 사용하는 경우 리버스 프록시를 설정하기위한 기본 구성 지시문은 &lt;code&gt;ProxyPass&lt;/code&gt; 입니다. 일반적으로 다음과 같이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4d0b0e596e666c3682ea6ce8c5834cb97678e6a8" translate="yes" xml:space="preserve">
          <source>In this case, the browser would be able to request &lt;code&gt;/ajax/web_service.xml&lt;/code&gt; as a relative URL, but the server would serve this by acting as a proxy to &lt;code&gt;http://other-domain.com/ajax/web_service.xml&lt;/code&gt;.</source>
          <target state="translated">이 경우 브라우저는 &lt;code&gt;/ajax/web_service.xml&lt;/code&gt; 을 상대 URL로 요청할 수 있지만 서버는 &lt;code&gt;http://other-domain.com/ajax/web_service.xml&lt;/code&gt; 의 프록시 역할을하여이를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1cf0c7a6464ec5af7080886da26a725c3bebd7d2" translate="yes" xml:space="preserve">
          <source>JSONP or &quot;JSON with padding&quot; is a
  complement to the base JSON data
  format, a usage pattern that allows a
  page to request and more meaningfully
  use JSON from a server other than the
  primary server. JSONP is an
  alternative to a more recent method
  called Cross-Origin Resource Sharing.</source>
          <target state="translated">JSONP 또는 &quot;패딩이있는 JSON&quot;은 기본 JSON 데이터 형식을 보완하는 것으로, 기본 서버 이외의 서버에서 페이지가 JSON을 요청하고보다 의미있게 사용할 수 있도록하는 사용 패턴입니다. JSONP는 Cross-Origin Resource Sharing이라는 최신 방법의 대안입니다.</target>
        </trans-unit>
        <trans-unit id="09dccb5e5a575215454d5f9da06e105c43ecfdbb" translate="yes" xml:space="preserve">
          <source>Method type: &lt;strong&gt;AJAX&lt;/strong&gt;.</source>
          <target state="translated">메소드 유형 : &lt;strong&gt;AJAX&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="907f7c116f69ced23985092a5b2e3d22c7acb042" translate="yes" xml:space="preserve">
          <source>Method type: &lt;strong&gt;Ajax&lt;/strong&gt;</source>
          <target state="translated">메소드 유형 : &lt;strong&gt;Ajax&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4fbf1ad12572390549ddc5c26f71f279ddda6d0f" translate="yes" xml:space="preserve">
          <source>Method type: &lt;strong&gt;iframe&lt;/strong&gt;.</source>
          <target state="translated">메소드 유형 : &lt;strong&gt;iframe&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b3b0f762f88c92e5b3b5ca264c31491540c1a12" translate="yes" xml:space="preserve">
          <source>My HTML runs on WAMP in port 80. So there we go, same origin policy has been circumvented :-)</source>
          <target state="translated">내 HTML은 포트 80의 WAMP에서 실행됩니다. 이제 동일한 원산지 정책이 우회되었습니다 :-)</target>
        </trans-unit>
        <trans-unit id="5c37d34677892604750e43403dd242ddcda9e50a" translate="yes" xml:space="preserve">
          <source>Note that for the CORS method to work, you need to have access to any type of server header mechanic and can't simply access any third-party resource.</source>
          <target state="translated">CORS 방법이 작동하려면 모든 유형의 서버 헤더 메커니즘에 액세스해야하며 타사 리소스에만 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="297330829250decdea3becdfca147b5237d622b4" translate="yes" xml:space="preserve">
          <source>Note that this is an iframe method that sets the value of document.domain to a suffix of the current domain. If it does so, the shorter domain is used for subsequent origin checks. For example, assume a script in the document at &lt;code&gt;http://store.company.com/dir/other.html&lt;/code&gt; executes the following statement:</source>
          <target state="translated">이것은 document.domain의 값을 현재 도메인의 접미사로 설정하는 iframe 방법입니다. 그렇게하면 더 짧은 도메인이 후속 원점 확인에 사용됩니다. 예를 들어 &lt;code&gt;http://store.company.com/dir/other.html&lt;/code&gt; 의 문서에있는 스크립트가 다음 명령문을 실행한다고 가정 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f5bfd284b16b8d3f023263d127e61641d6ec0dc" translate="yes" xml:space="preserve">
          <source>One interesting feature of the this method is that the reverse proxy can easily distribute requests towards multiple back-ends, thus acting as a &lt;a href=&quot;http://en.wikipedia.org/wiki/Load_balancer&quot;&gt;load balancer&lt;/a&gt;.</source>
          <target state="translated">이 방법의 흥미로운 특징 중 하나는 리버스 프록시가 여러 백엔드로 요청을 쉽게 분배하여 &lt;a href=&quot;http://en.wikipedia.org/wiki/Load_balancer&quot;&gt;로드 밸런서&lt;/a&gt; 역할을한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="869f0a4f9fce0fe0b3af59add061945aec7fb4f1" translate="yes" xml:space="preserve">
          <source>Personally, &lt;code&gt;window.postMessage&lt;/code&gt; is the most reliable way that I've found for modern browsers. You do have to do a slight bit more work to make sure you're not leaving yourself open to XSS attacks, but it's a reasonable tradeoff.</source>
          <target state="translated">개인적으로 &lt;code&gt;window.postMessage&lt;/code&gt; 는 최신 브라우저에서 찾은 가장 안정적인 방법입니다. XSS 공격에 자신을 노출시키지 않으려면 약간 더 많은 작업을 수행해야하지만 합리적인 균형을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="f4e6f4d41791e659c854c6249a7b09790ac689a0" translate="yes" xml:space="preserve">
          <source>Please keep examples verbose and preferably also link your sources.</source>
          <target state="translated">예제를 자세하게 유지하고 소스를 연결하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8736c3943f7bf4b7da63a83f3f7c60afb357b61b" translate="yes" xml:space="preserve">
          <source>Setting up a simple &lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_proxy&quot;&gt;reverse proxy&lt;/a&gt; on the server, will allow the browser to use relative paths for the Ajax requests, while the server would be acting as a proxy to any remote location.</source>
          <target state="translated">서버에서 간단한 &lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_proxy&quot;&gt;리버스 프록시&lt;/a&gt; 를 설정하면 브라우저가 Ajax 요청에 상대 경로를 사용할 수 있지만 서버는 원격 위치에 대한 프록시 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="b46f66f80cab9ee3b4442b834d73077fbe37f2a8" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;http://www.nczonline.net/blog/2010/05/25/cross-domain-ajax-with-cross-origin-resource-sharing/&quot;&gt;http://www.nczonline.net/blog/2010/05/25/cross-domain-ajax-with-cross-origin-resource-sharing/&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;http://www.nczonline.net/blog/2010/05/25/cross-domain-ajax-with-cross-origin-resource-sharing/&quot;&gt;http://www.nczonline.net/blog/2010/05/25/cross-domain-ajax-with-cross-origin-resource-sharing/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc483353f3db4b944ba18bd3f21809c0cfacb7d8" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://developer.mozilla.org/en/DOM/window.postMessage&quot;&gt;https://developer.mozilla.org/en/DOM/window.postMessage&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;https://developer.mozilla.org/en/DOM/window.postMessage&quot;&gt;https://developer.mozilla.org/en/DOM/window.postMessage&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="979ea5480a63480709b36bc4edd879419602f3a5" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://developer.mozilla.org/en/Same_origin_policy_for_JavaScript&quot;&gt;https://developer.mozilla.org/en/Same_origin_policy_for_JavaScript&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;https://developer.mozilla.org/en/Same_origin_policy_for_JavaScript&quot;&gt;https://developer.mozilla.org/en/Same_origin_policy_for_JavaScript&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="74286614b143e09d028a4e766f86db1b08364ea4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON#JSONP&quot;&gt;JSONP&lt;/a&gt; comes to mind:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON#JSONP&quot;&gt;JSONP&lt;/a&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14a41185d93ce77e80328ae9d8965fee99bf9b62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;document.domain&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;document.domain&lt;/code&gt; 메소드</target>
        </trans-unit>
        <trans-unit id="d68a25f0367e3c7ffe299c9f97c6a07bba80c8d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;window.postMessage&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;window.postMessage&lt;/code&gt; 메소드</target>
        </trans-unit>
        <trans-unit id="1508350d43cb22e9a9282cfae9df46c0cac493e9" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing method</source>
          <target state="translated">Cross-Origin 리소스 공유 방법</target>
        </trans-unit>
        <trans-unit id="a153aec24165ab6f16cd35e9fb9410a9ca407ef6" translate="yes" xml:space="preserve">
          <source>The Mozilla team suggests in &lt;a href=&quot;http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/&quot;&gt;their post about CORS&lt;/a&gt; that you should check for the existence of the &lt;code&gt;withCredentials&lt;/code&gt;  property to determine if the browser supports CORS via XHR. You can then couple with the existence of the &lt;code&gt;XDomainRequest&lt;/code&gt; object to cover all browsers:</source>
          <target state="translated">Mozilla 팀은 &lt;a href=&quot;http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/&quot;&gt;CORS 관련 게시물&lt;/a&gt; 에서 브라우저가 XHR을 통해 CORS를 지원하는지 여부를 판별하기 위해 &lt;code&gt;withCredentials&lt;/code&gt; 특성이 있는지 확인해야한다고 제안합니다. 그런 다음 &lt;code&gt;XDomainRequest&lt;/code&gt; 객체의 존재와 결합하여 모든 브라우저를 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="120d0116d0ed894a0af16411bd0ada6a659dd1d6" translate="yes" xml:space="preserve">
          <source>The most recent way of overcoming the same-origin policy that I've found is &lt;a href=&quot;http://anyorigin.com/&quot;&gt;http://anyorigin.com/&lt;/a&gt;</source>
          <target state="translated">내가 찾은 동일한 출처 정책을 극복하는 가장 최근의 방법은 &lt;a href=&quot;http://anyorigin.com/&quot;&gt;http://anyorigin.com/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06d8513c2bc78d391624461ec6c5778704342b09" translate="yes" xml:space="preserve">
          <source>The off-site iframe must also send events properly via &lt;code&gt;postMessage&lt;/code&gt;:</source>
          <target state="translated">오프 사이트 iframe은 &lt;code&gt;postMessage&lt;/code&gt; 를 통해 이벤트를 올바르게 보내야합니다.</target>
        </trans-unit>
        <trans-unit id="4174bdccc2aef6dfeda65a9a1fb9e2fdeddde0a2" translate="yes" xml:space="preserve">
          <source>The same origin policy</source>
          <target state="translated">동일한 원산지 정책</target>
        </trans-unit>
        <trans-unit id="0e59c06659312e32500fac955df844aceb0808bc" translate="yes" xml:space="preserve">
          <source>The same origin policy prevents a
  document or script loaded from one
  origin from getting or setting
  properties of a document from another
  origin. This policy dates all the way
  back to Netscape Navigator 2.0.</source>
          <target state="translated">동일한 원본 정책은 한 원본에서로드 된 문서 또는 스크립트가 다른 원본에서 문서의 속성을 가져 오거나 설정하지 못하게합니다. 이 정책은 Netscape Navigator 2.0으로 거슬러 올라갑니다.</target>
        </trans-unit>
        <trans-unit id="d66d1e4aa6d0d0ba8fa6587d7fafeb3d7278c581" translate="yes" xml:space="preserve">
          <source>The site's made so that you just give it any url and it generates javascript/jquery code for you that lets you get the html/data, regardless of it's origin.  In other words, it makes any url or webpage a JSONP request.</source>
          <target state="translated">이 사이트는 URL을 제공하기 위해 만들어졌으며, 출처에 관계없이 html / data를 가져올 수있는 javascript / jquery 코드를 생성합니다. 즉, URL 또는 웹 페이지를 JSONP 요청으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="89fadbd32a13cd64dd32536d6240abcb8dc752cc" translate="yes" xml:space="preserve">
          <source>There are also several plugins for the popular Javascript toolkits out there that wrap &lt;code&gt;window.postMessage&lt;/code&gt; that provide similar functionality to older browsers using the other methods discussed above.</source>
          <target state="translated">위에서 언급 한 다른 방법을 사용하여 이전 브라우저와 유사한 기능을 제공하는 &lt;code&gt;window.postMessage&lt;/code&gt; 를 래핑하는 인기있는 Javascript 툴킷 용 플러그인도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea48f87a2f0787ebb1b20c6926a34bcce3956552" translate="yes" xml:space="preserve">
          <source>Thiru's Blog - Browser same origin policy workaround</source>
          <target state="translated">Thiru 's Blog-브라우저와 동일한 출처 정책 해결 방법</target>
        </trans-unit>
        <trans-unit id="23825bcf186dd918555cf7fad89c855273b38ca8" translate="yes" xml:space="preserve">
          <source>This analyze pretty much what is available out there: &lt;a href=&quot;http://www.slideshare.net/SlexAxton/breaking-the-cross-domain-barrier&quot;&gt;http://www.slideshare.net/SlexAxton/breaking-the-cross-domain-barrier&lt;/a&gt;</source>
          <target state="translated">이것은 &lt;a href=&quot;http://www.slideshare.net/SlexAxton/breaking-the-cross-domain-barrier&quot;&gt;http://www.slideshare.net/SlexAxton/breaking-the-cross-domain-barrier에서&lt;/a&gt; 사용할 수있는 것을 거의 분석합니다 .</target>
        </trans-unit>
        <trans-unit id="97c06c41f0555296935972082306d95bdec710d8" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;window.postMessage&lt;/code&gt;, an event listener must be attached:</source>
          <target state="translated">&lt;code&gt;window.postMessage&lt;/code&gt; 를 사용하려면 이벤트 리스너를 첨부해야합니다.</target>
        </trans-unit>
        <trans-unit id="2ea9e25e4f9caa440958ade6c97afad1ef7244fa" translate="yes" xml:space="preserve">
          <source>Ways to circumvent the same-origin policy</source>
          <target state="translated">동일 출처 정책을 우회하는 방법</target>
        </trans-unit>
        <trans-unit id="e782f78ff917519b1ee00c58e7456816e424de14" translate="yes" xml:space="preserve">
          <source>Well, I used curl in PHP to circumvent this. I have a webservice running in port 82.</source>
          <target state="translated">글쎄, 나는 이것을 우회하기 위해 PHP에서 curl을 사용했다. 포트 82에서 실행되는 웹 서비스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="81f16516207f35245225c6f2b7a7ff6c0b72408c" translate="yes" xml:space="preserve">
          <source>What are some of your favorite ways to go around same-origin policies?</source>
          <target state="translated">동일 출처 정책을 둘러 보는 가장 좋아하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="f703e067a689e111c816ae1d14c37c3ff704cf24" translate="yes" xml:space="preserve">
          <source>With this method, you would be allowed to exectue javascript from an iframe sourced on a subdomain on a page sourced on the main domain. This method is not suited for cross-domain resources as browsers like Firefox will not allow you to change the &lt;code&gt;document.domain&lt;/code&gt; to a completely alien domain.</source>
          <target state="translated">이 방법을 사용하면 기본 도메인에서 소싱 된 페이지의 하위 도메인에서 소싱 된 iframe에서 자바 스크립트를 예상 할 수 있습니다. Firefox와 같은 브라우저에서는 &lt;code&gt;document.domain&lt;/code&gt; 을 완전히 외계인 도메인으로 변경할 수 없으므로이 방법은 도메인 간 리소스에 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="273fa724fa9acf407f810131ac63b502220c802f" translate="yes" xml:space="preserve">
          <source>and a slightly different version:</source>
          <target state="translated">약간 다른 버전 :</target>
        </trans-unit>
        <trans-unit id="5f335f1bf645229c5ab9c000fc4d135eda85b8f2" translate="yes" xml:space="preserve">
          <source>on your page.</source>
          <target state="translated">귀하의 페이지에.</target>
        </trans-unit>
        <trans-unit id="12d8a79280fc4b634bf500ecfa6d1fb7c6122ddc" translate="yes" xml:space="preserve">
          <source>some_func() should get called so that you are notified that the data is in.</source>
          <target state="translated">some_func ()가 호출되어 데이터가 있음을 알립니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
