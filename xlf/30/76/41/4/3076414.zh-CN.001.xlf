<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3076414">
    <body>
      <group id="3076414">
        <trans-unit id="b7833e2a423077d8f5e6c590b2a45f83ae467e2f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.w3.org/TR/access-control/&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt; (CORS) is a W3C Working Draft that defines how the browser and server must communicate when accessing sources across origins. The basic idea behind CORS is to use custom HTTP headers to allow both the browser and the server to know enough about each other to determine if the request or response should succeed or fail.</source>
          <target state="translated">&lt;a href=&quot;http://www.w3.org/TR/access-control/&quot;&gt;跨域资源共享&lt;/a&gt; （CORS）是W3C工作草案，它定义了跨源访问源时浏览器和服务器必须如何通信。 CORS背后的基本思想是使用自定义HTTP标头，以允许浏览器和服务器之间相互了解足够多，以确定请求或响应是成功还是失败。</target>
        </trans-unit>
        <trans-unit id="6c1949e65910c6d04b0c0a03a3c9483687d13f8f" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/ripper234/Whatever-Origin&quot;&gt;Code on github&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/ripper234/Whatever-Origin&quot;&gt;github上的代码&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee0a89efee82cede3b7d0ed3c2e7c50b576c1f04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;window.postMessage&lt;/code&gt;, when called, causes a &lt;code&gt;MessageEvent&lt;/code&gt; to be dispatched at the target window when any pending script that must be executed completes (e.g. remaining event handlers if &lt;code&gt;window.postMessage&lt;/code&gt; is called from an event handler, previously-set pending timeouts, etc.). The &lt;code&gt;MessageEvent&lt;/code&gt; has the type message, a &lt;code&gt;data&lt;/code&gt; property which is set to the string value of the first argument provided to &lt;code&gt;window.postMessage&lt;/code&gt;, an &lt;code&gt;origin&lt;/code&gt; property corresponding to the origin of the main document in the window calling &lt;code&gt;window.postMessage&lt;/code&gt; at the time &lt;code&gt;window.postMessage&lt;/code&gt; was called, and a &lt;code&gt;source&lt;/code&gt; property which is the window from which &lt;code&gt;window.postMessage&lt;/code&gt; is called.</source>
          <target state="translated">当调用 &lt;code&gt;window.postMessage&lt;/code&gt; 时 ，当必须执行的任何待执行脚本完成时（例如，从事件处理程序调用 &lt;code&gt;window.postMessage&lt;/code&gt; 时剩余的事件处理程序，先前设置的等待超时等），导致在目标窗口上调度 &lt;code&gt;MessageEvent&lt;/code&gt; 。 ）。 &lt;code&gt;MessageEvent&lt;/code&gt; 具有消息类型，其 &lt;code&gt;data&lt;/code&gt; 属性设置为提供给 &lt;code&gt;window.postMessage&lt;/code&gt; 的第一个参数的字符串值，该属性对应于在时间 &lt;code&gt;window.postMessage&lt;/code&gt; 调用 &lt;code&gt;window.postMessage&lt;/code&gt; 的窗口中主文档的原点。 postMessage被调用，并且 &lt;code&gt;source&lt;/code&gt; 属性是从中调用 &lt;code&gt;window.postMessage&lt;/code&gt; 的窗口。</target>
        </trans-unit>
        <trans-unit id="a7ad2378548934906f4054b49078fa539f244659" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Reverse Proxy method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;反向代理方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="852da2d726c809645e72eb48229d39be07b8fae6" translate="yes" xml:space="preserve">
          <source>After that statement executes, the page would pass the origin check with &lt;code&gt;http://company.com/dir/page.html&lt;/code&gt;. However, by the same reasoning, company.com could not set &lt;code&gt;document.domain&lt;/code&gt;  to &lt;code&gt;othercompany.com&lt;/code&gt;.</source>
          <target state="translated">该语句执行后，页面将通过 &lt;code&gt;http://company.com/dir/page.html&lt;/code&gt; 通过原点检查。 但是，出于相同的原因，company.com无法将 &lt;code&gt;document.domain&lt;/code&gt; 设置为 &lt;code&gt;othercompany.com&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f2aa3cd77cfc29f75dd036615866f4750568d3ef" translate="yes" xml:space="preserve">
          <source>And a &lt;code&gt;receiveMessage&lt;/code&gt; function must be declared:</source>
          <target state="translated">并且必须声明 &lt;code&gt;receiveMessage&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="a140c5ee37bfe6b024477d0131a34026e855fe06" translate="yes" xml:space="preserve">
          <source>Any window may access this method on any other window, at any time, regardless of the location of the document in the window, to send it a message. Consequently, any event listener used to receive messages must  first check the identity of the sender of the message, using the origin  and possibly source properties. This cannot be understated: &lt;strong&gt;Failure to check the &lt;code&gt;origin&lt;/code&gt; and possibly &lt;code&gt;source&lt;/code&gt; properties enables cross-site scripting attacks.&lt;/strong&gt;</source>
          <target state="translated">无论文档在窗口中的位置如何，任何窗口都可以随时在任何其他窗口上访问此方法，以向其发送消息。 因此，用于接收消息的任何事件侦听器都必须首先使用原始属性和可能的​​源属性检查消息发送者的身份。 这一点不能低估： &lt;strong&gt;无法检查 &lt;code&gt;origin&lt;/code&gt; 和可能的 &lt;code&gt;source&lt;/code&gt; 属性会启用跨站点脚本攻击。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="10a4c9065bf6e4b334fe844fd761eb45017a9a23" translate="yes" xml:space="preserve">
          <source>AnyOrigin didn't function well with some https sites, so I just wrote an open source alternative called &lt;a href=&quot;http://whateverorigin.org&quot;&gt;whateverorigin.org&lt;/a&gt; that seems to work well with https.</source>
          <target state="translated">AnyOrigin在某些https站点上无法正常运行，因此我只写了一个开源替代文件，名为whatorigin.org，它似乎可以很好地与https一起使用。</target>
        </trans-unit>
        <trans-unit id="5cfb29d97319e1c11297db533a66383b0cf24be8" translate="yes" xml:space="preserve">
          <source>Basically, you add</source>
          <target state="translated">基本上,你加</target>
        </trans-unit>
        <trans-unit id="c925158355cef0b501627fc58bee773199306382" translate="yes" xml:space="preserve">
          <source>For a simple request, one that uses either &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt; with no custom headers and whose body is &lt;code&gt;text/plain&lt;/code&gt;, the request is sent with an extra header called &lt;code&gt;Origin&lt;/code&gt;. The Origin  header contains the origin (protocol, domain name, and port) of the requesting page so that the server can easily determine whether or not it should serve a response. An example &lt;code&gt;Origin&lt;/code&gt; header might look like this:</source>
          <target state="translated">对于一个简单的请求（使用没有自定义标头的 &lt;code&gt;GET&lt;/code&gt; 或 &lt;code&gt;POST&lt;/code&gt; 且主体为 &lt;code&gt;text/plain&lt;/code&gt; 的请求），将使用一个额外的标头（称为 &lt;code&gt;Origin&lt;/code&gt; ）发送请求。 Origin头包含请求页面的来源（协议，域名和端口），以便服务器可以轻松确定是否应提供响应。 一个示例 &lt;code&gt;Origin&lt;/code&gt; 标头可能看起来像这样：</target>
        </trans-unit>
        <trans-unit id="3b1e301acde443e6a3529e0987def0e7f264ce09" translate="yes" xml:space="preserve">
          <source>For postMessage solution take a look to:</source>
          <target state="translated">对于postMessage解决方案,请看一下。</target>
        </trans-unit>
        <trans-unit id="53e8475662e93dba88421445f46ad6c63933d3ec" translate="yes" xml:space="preserve">
          <source>Here are some workarounds and explanation of same-origin-policy:</source>
          <target state="translated">以下是同源政策的一些变通方法和解释。</target>
        </trans-unit>
        <trans-unit id="3e6b094c0445f22c160924768c1e7ab7f2ab31f7" translate="yes" xml:space="preserve">
          <source>Here is the javascript that makes the call to the PHP file</source>
          <target state="translated">以下是调用PHP文件的javascript脚本</target>
        </trans-unit>
        <trans-unit id="537caecf2ec6ad1c68d699677791ce8433c9fb7a" translate="yes" xml:space="preserve">
          <source>Here's some example javascript code from anyorigin:</source>
          <target state="translated">下面是一些来自anyorigin的javascript代码示例。</target>
        </trans-unit>
        <trans-unit id="3278a912757a0d6e80e30697203ac1e8cafe560f" translate="yes" xml:space="preserve">
          <source>I can't claim credit for this image, but it matches everything I know on this subject and offers a bit of humor at the same time.</source>
          <target state="translated">我不能为这张图邀功,但它符合我对这一主题的所有认识,同时也提供了一点幽默感。</target>
        </trans-unit>
        <trans-unit id="74c377ed5d488a0f2fa67627324bdc55383950d3" translate="yes" xml:space="preserve">
          <source>I use JSONP.</source>
          <target state="translated">我用的是JSONP。</target>
        </trans-unit>
        <trans-unit id="aedea270bebebbb6df92ec87e80f61f22f17c4a8" translate="yes" xml:space="preserve">
          <source>I wanted to make a community wiki regarding HTML/JS &lt;strong&gt;same-origin policies&lt;/strong&gt; to hopefully help anyone searching for this topic. This is one of the most searched-for topics on SO and there is no consolidated wiki for it so here I go :)</source>
          <target state="translated">我想制作一个有关HTML / JS &lt;strong&gt;同源策略&lt;/strong&gt;的社区Wiki，以希望能帮助搜索此主题的任何人。 这是关于SO的最热门搜索主题之一，并且没有统一的Wiki，所以我在这里:)</target>
        </trans-unit>
        <trans-unit id="22c5475470c98c78fca56cdbe0c4a8fe32dc678d" translate="yes" xml:space="preserve">
          <source>I've found it pretty useful :)</source>
          <target state="translated">我发现它很有用:)</target>
        </trans-unit>
        <trans-unit id="ec716be49a189dc96ebedce425b2a3743464479e" translate="yes" xml:space="preserve">
          <source>If the server decides that the request should be allowed, it sends a &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header echoing back the same origin that was sent or &lt;code&gt;*&lt;/code&gt; if it&amp;rsquo;s a public resource. For example:</source>
          <target state="translated">如果服务器决定应允许该请求，则它将发送 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 标头，以回显已发送的相同来源；如果是公共资源，则返回 &lt;code&gt;*&lt;/code&gt; 。 例如：</target>
        </trans-unit>
        <trans-unit id="84dc7308e5f2df5426df8cd061732eb7a35d1815" translate="yes" xml:space="preserve">
          <source>If this header is missing, or the origins don&amp;rsquo;t match, then the browser disallows the request. If all is well, then the browser processes the request. Note that neither the requests nor responses include cookie information.</source>
          <target state="translated">如果缺少此标头，或者起源不匹配，则浏览器将拒绝该请求。 如果一切顺利，则浏览器将处理请求。 请注意，请求和响应均不包含Cookie信息。</target>
        </trans-unit>
        <trans-unit id="0893afbcb9175e0c3093ac7ce7fbcc9d22c724f2" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;http://httpd.apache.org/docs/2.0/mod/mod_proxy.html&quot;&gt;mod_proxy&lt;/a&gt; in Apache, the fundamental configuration directive to set up a reverse proxy is the &lt;code&gt;ProxyPass&lt;/code&gt;. It is typically used as follows:</source>
          <target state="translated">如果在Apache中使用&lt;a href=&quot;http://httpd.apache.org/docs/2.0/mod/mod_proxy.html&quot;&gt;mod_proxy&lt;/a&gt; ，则设置反向代理的基本配置指令是 &lt;code&gt;ProxyPass&lt;/code&gt; 。 通常按以下方式使用：</target>
        </trans-unit>
        <trans-unit id="4d0b0e596e666c3682ea6ce8c5834cb97678e6a8" translate="yes" xml:space="preserve">
          <source>In this case, the browser would be able to request &lt;code&gt;/ajax/web_service.xml&lt;/code&gt; as a relative URL, but the server would serve this by acting as a proxy to &lt;code&gt;http://other-domain.com/ajax/web_service.xml&lt;/code&gt;.</source>
          <target state="translated">在这种情况下，浏览器将能够请求 &lt;code&gt;/ajax/web_service.xml&lt;/code&gt; 作为相对URL，但是服务器将通过充当 &lt;code&gt;http://other-domain.com/ajax/web_service.xml&lt;/code&gt; 的代理来提供服务。</target>
        </trans-unit>
        <trans-unit id="1cf0c7a6464ec5af7080886da26a725c3bebd7d2" translate="yes" xml:space="preserve">
          <source>JSONP or &quot;JSON with padding&quot; is a
  complement to the base JSON data
  format, a usage pattern that allows a
  page to request and more meaningfully
  use JSON from a server other than the
  primary server. JSONP is an
  alternative to a more recent method
  called Cross-Origin Resource Sharing.</source>
          <target state="translated">JSONP或 &quot;带填充的JSON &quot;是对基本JSON数据格式的一种补充,这种使用模式允许页面从主服务器以外的服务器请求并更有意义地使用JSON。JSONP是一种较新的方法,即跨源资源共享的替代方法。</target>
        </trans-unit>
        <trans-unit id="09dccb5e5a575215454d5f9da06e105c43ecfdbb" translate="yes" xml:space="preserve">
          <source>Method type: &lt;strong&gt;AJAX&lt;/strong&gt;.</source>
          <target state="translated">方法类型： &lt;strong&gt;AJAX&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="907f7c116f69ced23985092a5b2e3d22c7acb042" translate="yes" xml:space="preserve">
          <source>Method type: &lt;strong&gt;Ajax&lt;/strong&gt;</source>
          <target state="translated">方法类型： &lt;strong&gt;Ajax&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4fbf1ad12572390549ddc5c26f71f279ddda6d0f" translate="yes" xml:space="preserve">
          <source>Method type: &lt;strong&gt;iframe&lt;/strong&gt;.</source>
          <target state="translated">方法类型： &lt;strong&gt;iframe&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b3b0f762f88c92e5b3b5ca264c31491540c1a12" translate="yes" xml:space="preserve">
          <source>My HTML runs on WAMP in port 80. So there we go, same origin policy has been circumvented :-)</source>
          <target state="translated">我的HTML运行在WAMP的80端口。于是,我们就这样,同源政策被规避了:-)</target>
        </trans-unit>
        <trans-unit id="5c37d34677892604750e43403dd242ddcda9e50a" translate="yes" xml:space="preserve">
          <source>Note that for the CORS method to work, you need to have access to any type of server header mechanic and can't simply access any third-party resource.</source>
          <target state="translated">需要注意的是,要想让CORS方法起作用,你需要访问任何类型的服务器头机,不能简单地访问任何第三方资源。</target>
        </trans-unit>
        <trans-unit id="297330829250decdea3becdfca147b5237d622b4" translate="yes" xml:space="preserve">
          <source>Note that this is an iframe method that sets the value of document.domain to a suffix of the current domain. If it does so, the shorter domain is used for subsequent origin checks. For example, assume a script in the document at &lt;code&gt;http://store.company.com/dir/other.html&lt;/code&gt; executes the following statement:</source>
          <target state="translated">请注意，这是一个iframe方法，用于将document.domain的值设置为当前域的后缀。 如果这样做，则将较短的域用于后续的来源检查。 例如，假设位于 &lt;code&gt;http://store.company.com/dir/other.html&lt;/code&gt; 的文档中的脚本执行以下语句：</target>
        </trans-unit>
        <trans-unit id="7f5bfd284b16b8d3f023263d127e61641d6ec0dc" translate="yes" xml:space="preserve">
          <source>One interesting feature of the this method is that the reverse proxy can easily distribute requests towards multiple back-ends, thus acting as a &lt;a href=&quot;http://en.wikipedia.org/wiki/Load_balancer&quot;&gt;load balancer&lt;/a&gt;.</source>
          <target state="translated">此方法的一个有趣特征是，反向代理可以轻松地将请求分配到多个后端，从而充当&lt;a href=&quot;http://en.wikipedia.org/wiki/Load_balancer&quot;&gt;负载平衡器&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="869f0a4f9fce0fe0b3af59add061945aec7fb4f1" translate="yes" xml:space="preserve">
          <source>Personally, &lt;code&gt;window.postMessage&lt;/code&gt; is the most reliable way that I've found for modern browsers. You do have to do a slight bit more work to make sure you're not leaving yourself open to XSS attacks, but it's a reasonable tradeoff.</source>
          <target state="translated">就个人而言， &lt;code&gt;window.postMessage&lt;/code&gt; 是我为现代浏览器找到的最可靠的方法。 您确实需要做更多的工作，以确保您不会对XSS攻击开放，但这是一个合理的权衡。</target>
        </trans-unit>
        <trans-unit id="f4e6f4d41791e659c854c6249a7b09790ac689a0" translate="yes" xml:space="preserve">
          <source>Please keep examples verbose and preferably also link your sources.</source>
          <target state="translated">请举例说明,最好还能链接出处。</target>
        </trans-unit>
        <trans-unit id="8736c3943f7bf4b7da63a83f3f7c60afb357b61b" translate="yes" xml:space="preserve">
          <source>Setting up a simple &lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_proxy&quot;&gt;reverse proxy&lt;/a&gt; on the server, will allow the browser to use relative paths for the Ajax requests, while the server would be acting as a proxy to any remote location.</source>
          <target state="translated">在服务器上设置一个简单的&lt;a href=&quot;http://en.wikipedia.org/wiki/Reverse_proxy&quot;&gt;反向代理&lt;/a&gt; ，将允许浏览器将相对路径用于Ajax请求，而服务器将充当任何远程位置的代理。</target>
        </trans-unit>
        <trans-unit id="b46f66f80cab9ee3b4442b834d73077fbe37f2a8" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;http://www.nczonline.net/blog/2010/05/25/cross-domain-ajax-with-cross-origin-resource-sharing/&quot;&gt;http://www.nczonline.net/blog/2010/05/25/cross-domain-ajax-with-cross-origin-resource-sharing/&lt;/a&gt;</source>
          <target state="translated">来源： &lt;a href=&quot;http://www.nczonline.net/blog/2010/05/25/cross-domain-ajax-with-cross-origin-resource-sharing/&quot;&gt;http&lt;/a&gt; ： //www.nczonline.net/blog/2010/05/25/cross-domain-ajax-with-cross-origin-resource-sharing/</target>
        </trans-unit>
        <trans-unit id="fc483353f3db4b944ba18bd3f21809c0cfacb7d8" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://developer.mozilla.org/en/DOM/window.postMessage&quot;&gt;https://developer.mozilla.org/en/DOM/window.postMessage&lt;/a&gt;</source>
          <target state="translated">来源： &lt;a href=&quot;https://developer.mozilla.org/en/DOM/window.postMessage&quot;&gt;https&lt;/a&gt; : //developer.mozilla.org/en/DOM/window.postMessage</target>
        </trans-unit>
        <trans-unit id="979ea5480a63480709b36bc4edd879419602f3a5" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://developer.mozilla.org/en/Same_origin_policy_for_JavaScript&quot;&gt;https://developer.mozilla.org/en/Same_origin_policy_for_JavaScript&lt;/a&gt;</source>
          <target state="translated">来源： &lt;a href=&quot;https://developer.mozilla.org/en/Same_origin_policy_for_JavaScript&quot;&gt;https&lt;/a&gt; : //developer.mozilla.org/en/Same_origin_policy_for_JavaScript</target>
        </trans-unit>
        <trans-unit id="74286614b143e09d028a4e766f86db1b08364ea4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/JSON#JSONP&quot;&gt;JSONP&lt;/a&gt; comes to mind:</source>
          <target state="translated">想到了&lt;a href=&quot;http://en.wikipedia.org/wiki/JSON#JSONP&quot;&gt;JSONP&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="14a41185d93ce77e80328ae9d8965fee99bf9b62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;document.domain&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;document.domain&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="d68a25f0367e3c7ffe299c9f97c6a07bba80c8d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;window.postMessage&lt;/code&gt; method</source>
          <target state="translated">&lt;code&gt;window.postMessage&lt;/code&gt; 方法</target>
        </trans-unit>
        <trans-unit id="1508350d43cb22e9a9282cfae9df46c0cac493e9" translate="yes" xml:space="preserve">
          <source>The Cross-Origin Resource Sharing method</source>
          <target state="translated">跨产地资源共享法</target>
        </trans-unit>
        <trans-unit id="a153aec24165ab6f16cd35e9fb9410a9ca407ef6" translate="yes" xml:space="preserve">
          <source>The Mozilla team suggests in &lt;a href=&quot;http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/&quot;&gt;their post about CORS&lt;/a&gt; that you should check for the existence of the &lt;code&gt;withCredentials&lt;/code&gt;  property to determine if the browser supports CORS via XHR. You can then couple with the existence of the &lt;code&gt;XDomainRequest&lt;/code&gt; object to cover all browsers:</source>
          <target state="translated">Mozilla团队在&lt;a href=&quot;http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/&quot;&gt;有关CORS的帖子中&lt;/a&gt;建议您应检查 &lt;code&gt;withCredentials&lt;/code&gt; 属性的存在，以确定浏览器是否通过XHR支持CORS。 然后，您可以结合使用 &lt;code&gt;XDomainRequest&lt;/code&gt; 对象来覆盖所有浏览器：</target>
        </trans-unit>
        <trans-unit id="120d0116d0ed894a0af16411bd0ada6a659dd1d6" translate="yes" xml:space="preserve">
          <source>The most recent way of overcoming the same-origin policy that I've found is &lt;a href=&quot;http://anyorigin.com/&quot;&gt;http://anyorigin.com/&lt;/a&gt;</source>
          <target state="translated">克服我发现的同源策略的最新方法是&lt;a href=&quot;http://anyorigin.com/&quot;&gt;http://anyorigin.com/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06d8513c2bc78d391624461ec6c5778704342b09" translate="yes" xml:space="preserve">
          <source>The off-site iframe must also send events properly via &lt;code&gt;postMessage&lt;/code&gt;:</source>
          <target state="translated">异地iframe还必须通过 &lt;code&gt;postMessage&lt;/code&gt; 正确发送事件：</target>
        </trans-unit>
        <trans-unit id="4174bdccc2aef6dfeda65a9a1fb9e2fdeddde0a2" translate="yes" xml:space="preserve">
          <source>The same origin policy</source>
          <target state="translated">同样的原产地政策</target>
        </trans-unit>
        <trans-unit id="0e59c06659312e32500fac955df844aceb0808bc" translate="yes" xml:space="preserve">
          <source>The same origin policy prevents a
  document or script loaded from one
  origin from getting or setting
  properties of a document from another
  origin. This policy dates all the way
  back to Netscape Navigator 2.0.</source>
          <target state="translated">同一源码策略可以防止从一个源码中加载的文档或脚本从另一个源码中获取或设置文档的属性。这个策略可以追溯到Netscape Navigator 2.0。</target>
        </trans-unit>
        <trans-unit id="d66d1e4aa6d0d0ba8fa6587d7fafeb3d7278c581" translate="yes" xml:space="preserve">
          <source>The site's made so that you just give it any url and it generates javascript/jquery code for you that lets you get the html/data, regardless of it's origin.  In other words, it makes any url or webpage a JSONP request.</source>
          <target state="translated">该网站是这样做的,你只需给它任何URL,它就会为你生成javascriptjquery代码,让你获得htmldata,不管它的来源是什么。换句话说,它可以让任何URL或网页成为JSONP请求。</target>
        </trans-unit>
        <trans-unit id="89fadbd32a13cd64dd32536d6240abcb8dc752cc" translate="yes" xml:space="preserve">
          <source>There are also several plugins for the popular Javascript toolkits out there that wrap &lt;code&gt;window.postMessage&lt;/code&gt; that provide similar functionality to older browsers using the other methods discussed above.</source>
          <target state="translated">还有一些流行的Javascript工具包的插件，其中包装了 &lt;code&gt;window.postMessage&lt;/code&gt; ，这些插件使用上述其他方法为旧版浏览器提供了类似的功能。</target>
        </trans-unit>
        <trans-unit id="ea48f87a2f0787ebb1b20c6926a34bcce3956552" translate="yes" xml:space="preserve">
          <source>Thiru's Blog - Browser same origin policy workaround</source>
          <target state="translated">Thiru的博客-浏览器同源策略的解决方法</target>
        </trans-unit>
        <trans-unit id="23825bcf186dd918555cf7fad89c855273b38ca8" translate="yes" xml:space="preserve">
          <source>This analyze pretty much what is available out there: &lt;a href=&quot;http://www.slideshare.net/SlexAxton/breaking-the-cross-domain-barrier&quot;&gt;http://www.slideshare.net/SlexAxton/breaking-the-cross-domain-barrier&lt;/a&gt;</source>
          <target state="translated">这几乎分析了可用的内容： &lt;a href=&quot;http://www.slideshare.net/SlexAxton/breaking-the-cross-domain-barrier&quot;&gt;http&lt;/a&gt; : //www.slideshare.net/SlexAxton/breaking-the-cross-domain-barrier</target>
        </trans-unit>
        <trans-unit id="97c06c41f0555296935972082306d95bdec710d8" translate="yes" xml:space="preserve">
          <source>To use &lt;code&gt;window.postMessage&lt;/code&gt;, an event listener must be attached:</source>
          <target state="translated">要使用 &lt;code&gt;window.postMessage&lt;/code&gt; ，必须附加事件侦听器：</target>
        </trans-unit>
        <trans-unit id="2ea9e25e4f9caa440958ade6c97afad1ef7244fa" translate="yes" xml:space="preserve">
          <source>Ways to circumvent the same-origin policy</source>
          <target state="translated">如何规避同产地政策的方法</target>
        </trans-unit>
        <trans-unit id="e782f78ff917519b1ee00c58e7456816e424de14" translate="yes" xml:space="preserve">
          <source>Well, I used curl in PHP to circumvent this. I have a webservice running in port 82.</source>
          <target state="translated">嗯,我在 PHP 中使用 curl 来规避这个问题。我有一个web服务在82端口运行。</target>
        </trans-unit>
        <trans-unit id="81f16516207f35245225c6f2b7a7ff6c0b72408c" translate="yes" xml:space="preserve">
          <source>What are some of your favorite ways to go around same-origin policies?</source>
          <target state="translated">你最喜欢用什么方法来绕过同城政策?</target>
        </trans-unit>
        <trans-unit id="f703e067a689e111c816ae1d14c37c3ff704cf24" translate="yes" xml:space="preserve">
          <source>With this method, you would be allowed to exectue javascript from an iframe sourced on a subdomain on a page sourced on the main domain. This method is not suited for cross-domain resources as browsers like Firefox will not allow you to change the &lt;code&gt;document.domain&lt;/code&gt; to a completely alien domain.</source>
          <target state="translated">使用此方法，您可以从源于主域的页面上的子域的iframe中提取javascript。 此方法不适用于跨域资源，因为Firefox之类的浏览器不允许您将 &lt;code&gt;document.domain&lt;/code&gt; 更改为完全异类的域。</target>
        </trans-unit>
        <trans-unit id="273fa724fa9acf407f810131ac63b502220c802f" translate="yes" xml:space="preserve">
          <source>and a slightly different version:</source>
          <target state="translated">和稍有不同的版本。</target>
        </trans-unit>
        <trans-unit id="5f335f1bf645229c5ab9c000fc4d135eda85b8f2" translate="yes" xml:space="preserve">
          <source>on your page.</source>
          <target state="translated">在你的页面上。</target>
        </trans-unit>
        <trans-unit id="12d8a79280fc4b634bf500ecfa6d1fb7c6122ddc" translate="yes" xml:space="preserve">
          <source>some_func() should get called so that you are notified that the data is in.</source>
          <target state="translated">some_func()应该被调用,这样你就会被通知数据已进入。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
