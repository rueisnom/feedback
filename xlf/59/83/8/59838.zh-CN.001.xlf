<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/59838">
    <body>
      <group id="59838">
        <trans-unit id="fa993ec66455570012e9013cf1463ed955c29d2b" translate="yes" xml:space="preserve">
          <source>$ [[ &lt;code&gt;ls -ld SAMPLE_DIR| grep ^d | wc -l&lt;/code&gt; -eq 1 ]] &amp;amp;&amp;amp; echo exists || not exists
-ksh: not: not found [No such file or directory]</source>
          <target state="translated">$ [[ &lt;code&gt;ls -ld SAMPLE_DIR| grep ^d | wc -l&lt;/code&gt; grep ^ d | wc -l -eq 1]] &amp;amp;&amp;amp; echo存在|| 不存在-ksh：找不到：找不到[没有这样的文件或目录]</target>
        </trans-unit>
        <trans-unit id="207f52d501fccd0c1a03258f9a4ba170a5a42466" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/59871/26510&quot;&gt;This answer&lt;/a&gt; wrapped up as a shell script</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/59871/26510&quot;&gt;这个答案&lt;/a&gt;包装成一个shell脚本</target>
        </trans-unit>
        <trans-unit id="9e0e12dfd443e81b936e303737feb7e5b54bce54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$?&lt;/code&gt;  if the last command sucess it returns &quot;0&quot; else non zero value.
suppose &lt;code&gt;tempdir&lt;/code&gt; is already present then &lt;code&gt;mkdir tempdir&lt;/code&gt; will give error like below:</source>
          <target state="translated">&lt;code&gt;$?&lt;/code&gt; 如果最后一个命令成功，则返回&amp;ldquo; 0&amp;rdquo;，否则返回非零值。 假设 &lt;code&gt;tempdir&lt;/code&gt; 已经存在，则 &lt;code&gt;mkdir tempdir&lt;/code&gt; 将给出如下错误：</target>
        </trans-unit>
        <trans-unit id="feda4164b3c0a2676771fde73bb174bd7ed6f917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-d file&lt;/code&gt;       True if file exists and is a directory.</source>
          <target state="translated">&lt;code&gt;-d file&lt;/code&gt; 如果文件存在且为目录，则为true。</target>
        </trans-unit>
        <trans-unit id="434bb26fe4597d2630646259bd5f58901fd76397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&lt;/code&gt; - This is a synonym for the &lt;code&gt;test&lt;/code&gt; builtin, but the last argument must, be a literal &lt;code&gt;]&lt;/code&gt;, to match the opening &lt;code&gt;[&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; -这是内置 &lt;code&gt;test&lt;/code&gt; 的同义词，但最后一个参数必须为原义 &lt;code&gt;]&lt;/code&gt; ，以匹配开头 &lt;code&gt;[&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="eb1e3608bea738f684006334bf1064168d620141" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cd&lt;/code&gt; will give me a standard one line message to stderr already.  It will also give more information than I will be able to provide. By performing the &lt;code&gt;cd&lt;/code&gt; inside a subshell &lt;code&gt;( ... )&lt;/code&gt;, the command does not affect the current directory of the caller.  If the directory exists, this subshell and the function are just a no-op.</source>
          <target state="translated">&lt;code&gt;cd&lt;/code&gt; 会给我一条标准的一行消息给stderr。 它还将提供比我所能提供的更多的信息。 通过在子外壳程序 &lt;code&gt;( ... )&lt;/code&gt; 执行 &lt;code&gt;cd&lt;/code&gt; ，该命令不会影响调用者的当前目录。 如果目录存在，则此子外壳程序和该函数仅是no-op。</target>
        </trans-unit>
        <trans-unit id="027520a48b909e71c33dda807972513e35b92e3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;man test&lt;/code&gt; or &lt;code&gt;man [&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;man test&lt;/code&gt; 或 &lt;code&gt;man [&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bece6e4aec1b0d3891d5ef560eeef888ec945439" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://code.labstack.com/7GMFlEaC&quot;&gt;Try online&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://code.labstack.com/7GMFlEaC&quot;&gt;在线尝试&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="163253848062881e0d2329cc2527145d49820c0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Be careful, leave empty spaces on either side of both opening and closing braces.</source>
          <target state="translated">&lt;strong&gt;注意&lt;/strong&gt; ：请小心，在打开和关闭支架的两侧都留有空白。</target>
        </trans-unit>
        <trans-unit id="3997fed95faa341282cd437483c5c670e8b1844c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;&lt;code&gt;bluh: directory&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;bluh: directory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfb619c9b31d43d856e2c9622e21fcd9cbf45233" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;&lt;code&gt;cannot open 'blah' (No such file or directory)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;输出：&lt;/strong&gt; &lt;code&gt;cannot open 'blah' (No such file or directory)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b4185a6d1d73515d38f626b4858d6fd8bf83ab7" translate="yes" xml:space="preserve">
          <source>A philosphical note:
The shell is not an object oriented language, so the message says &lt;code&gt;pathname&lt;/code&gt;, not &lt;code&gt;directory&lt;/code&gt;.  At this level, I'd rather keep it simple - the arguments to a function are just strings.</source>
          <target state="translated">一个哲学注释：shell不是一种面向对象的语言，因此该消息显示 &lt;code&gt;pathname&lt;/code&gt; ，而不是 &lt;code&gt;directory&lt;/code&gt; 。 在这个级别上，我宁愿保持简单-函数的参数只是字符串。</target>
        </trans-unit>
        <trans-unit id="0a45f6aedea833628df36f248058fcab8f52a9d6" translate="yes" xml:space="preserve">
          <source>A simple script to check whether the directory is present or not:</source>
          <target state="translated">一个简单的脚本来检查目录是否存在。</target>
        </trans-unit>
        <trans-unit id="a3c1d22947265563d45fd4e652519b22a668c349" translate="yes" xml:space="preserve">
          <source>A simple script to test if dir or file is present or not:</source>
          <target state="translated">一个简单的脚本来测试是否存在dir或文件。</target>
        </trans-unit>
        <trans-unit id="fd6e80065208ac7351071006ecfe52b4d309e9e5" translate="yes" xml:space="preserve">
          <source>Actually, you should use several tools to get a bulletproof approach:</source>
          <target state="translated">其实,要想获得防弹的方法,应该使用几个工具。</target>
        </trans-unit>
        <trans-unit id="464055c0f8481e3a474e0ca37383e37b458ec20a" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;https://stackoverflow.com/users/15168/jonathan-leffler&quot;&gt;Jonathan&lt;/a&gt; comment:</source>
          <target state="translated">根据&lt;a href=&quot;https://stackoverflow.com/users/15168/jonathan-leffler&quot;&gt;乔纳森&lt;/a&gt;评论：</target>
        </trans-unit>
        <trans-unit id="c5e4fba4b777f62c1a98acce6699a3a59b7781e3" translate="yes" xml:space="preserve">
          <source>Both combinations. In the following example, it checks the existence of the folder in the current directory:</source>
          <target state="translated">这两种组合。在下面的例子中,它检查当前目录中的文件夹是否存在。</target>
        </trans-unit>
        <trans-unit id="b0a39235449c9b80afd08f03ea6648737facd108" translate="yes" xml:space="preserve">
          <source>Check existence of one or several folders based on a pattern within the current directory:</source>
          <target state="translated">根据当前目录中的模式检查一个或多个文件夹的存在。</target>
        </trans-unit>
        <trans-unit id="221be94517340b5d7edd17ba6f1747d346cae247" translate="yes" xml:space="preserve">
          <source>Check existence of the folder within sub-directories:</source>
          <target state="translated">检查子目录中的文件夹是否存在。</target>
        </trans-unit>
        <trans-unit id="f41aa9b9ef657005fb51d75b158b17ed6563060c" translate="yes" xml:space="preserve">
          <source>Check if directory exists, else make one</source>
          <target state="translated">检查目录是否存在,否则创建一个</target>
        </trans-unit>
        <trans-unit id="8817dabaf58544f10e9e8044e576b691d9909f99" translate="yes" xml:space="preserve">
          <source>Checking existing directory: &lt;code&gt;file bluh&lt;/code&gt;</source>
          <target state="translated">检查现有目录： &lt;code&gt;file bluh&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e7b8e871985e69d583f6865533432144019e169" translate="yes" xml:space="preserve">
          <source>Checking nonexistent file: &lt;code&gt;file blah&lt;/code&gt;</source>
          <target state="translated">正在检查不存在的文件： &lt;code&gt;file blah&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="d3f89fd4db9124590507d0a77795675385a13a81" translate="yes" xml:space="preserve">
          <source>Explanation: The &quot;ls&quot; command gives an error &quot;ls: /x: No such file or directory&quot; if the directory or symlink does not exist, and also sets the return code, which you can retrieve via &quot;$?&quot;, to non-null (normally &quot;1&quot;).
Be sure that you check the return code directly after calling &quot;ls&quot;.</source>
          <target state="translated">说明:&quot;ls &quot;命令给出的错误是 &quot;ls:x:x&quot;。&quot;ls&quot; 命令会给出一个错误 &quot;ls:x:如果目录或symlink不存在,则会给出 &quot;no such file or directory &quot;的错误,同时也会将返回的代码(你可以通过&quot;$? &quot;来获取)设置为非空(通常为 &quot;1&quot;)。一定要确保在调用 &quot;ls &quot;后直接检查返回码。</target>
        </trans-unit>
        <trans-unit id="1b1eea7be5fe905e80303ca40514b1db06d2f422" translate="yes" xml:space="preserve">
          <source>File under: &quot;When is a directory not a directory?&quot;  The answer: &quot;When it's a symlink to a directory.&quot;  A slightly more thorough test:</source>
          <target state="translated">文件下。&quot;目录何时不是目录?&quot; 答案是:&quot;当它是目录的symlink to a directory &quot;当它是指向目录的symlink时。&quot; 一个稍微彻底一点的测试。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="5809133b5d742fa3d011e67ffed4584ce187906c" translate="yes" xml:space="preserve">
          <source>For possible options or further help, check:</source>
          <target state="translated">对于可能的选择或进一步的帮助,请检查。</target>
        </trans-unit>
        <trans-unit id="0e50a574ae5c5907245152793f0a5b1ec421b157" translate="yes" xml:space="preserve">
          <source>Great solutions out there, but ultimately every script will fail if you're not in the right directory. So code like this:</source>
          <target state="translated">外面有很好的解决方案,但最终每个脚本如果你的目录不对,都会失败。所以像这样的代码。</target>
        </trans-unit>
        <trans-unit id="583aed4873fd41e41427b6bc1d64cb3bd468fd28" translate="yes" xml:space="preserve">
          <source>Have you considered just doing whatever you want to do in the &lt;code&gt;if&lt;/code&gt; rather than looking before you leap?</source>
          <target state="translated">您是否考虑过在 &lt;code&gt;if&lt;/code&gt; 中做任何您想做的事情，而不是在飞跃之前先看一下？</target>
        </trans-unit>
        <trans-unit id="082b4e4b43eda6f1643255fe64e1a3ad94266d3b" translate="yes" xml:space="preserve">
          <source>Here's a very pragmatic idiom:</source>
          <target state="translated">这里有一个很务实的成语。</target>
        </trans-unit>
        <trans-unit id="a2fc766f174dc35f89cacdbd9b843d7518a58574" translate="yes" xml:space="preserve">
          <source>How about &lt;code&gt;file&lt;/code&gt; program.
Considering all directories are also files in linux, issuing following command would suffice:</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 程序如何。 考虑到所有目录也是linux中的文件，发出以下命令就足够了：</target>
        </trans-unit>
        <trans-unit id="dd106d637fc8e15919d6f826690e723d312a6366" translate="yes" xml:space="preserve">
          <source>How to check if a directory exists in a Bash shell script</source>
          <target state="translated">如何检查Bash shell脚本中的目录是否存在?</target>
        </trans-unit>
        <trans-unit id="bd085a6bf0566c0ec2d66c9e634591d684f558b5" translate="yes" xml:space="preserve">
          <source>However, as &lt;a href=&quot;https://stackoverflow.com/users/1438/jon-ericson&quot;&gt;Jon Ericson&lt;/a&gt; points out, subsequent commands may not work as intended if you do not take into account that a symbolic link to a directory will also pass this check.
E.g. running this:</source>
          <target state="translated">但是，正如&lt;a href=&quot;https://stackoverflow.com/users/1438/jon-ericson&quot;&gt;乔恩&amp;middot;埃里克森&lt;/a&gt; （ Jon Ericson）所指出的，如果您不考虑到目录的符号链接也将通过此检查，则后续命令可能无法按预期运行。 例如运行此：</target>
        </trans-unit>
        <trans-unit id="1387051c9062c34eca949313dbc4255c45cc0e5c" translate="yes" xml:space="preserve">
          <source>I find the &lt;a href=&quot;http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS&quot;&gt;double-bracket&lt;/a&gt; version of &lt;code&gt;test&lt;/code&gt; makes writing logic tests more natural:</source>
          <target state="translated">我发现 &lt;code&gt;test&lt;/code&gt; 的&lt;a href=&quot;http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS&quot;&gt;双括号&lt;/a&gt;版本使编写逻辑测试更加自然：</target>
        </trans-unit>
        <trans-unit id="8353f3f0e57f21586871e79884cb6c9a83d64eba" translate="yes" xml:space="preserve">
          <source>I typically wrap it in a function:</source>
          <target state="translated">我一般都是用功能包起来的。</target>
        </trans-unit>
        <trans-unit id="efdcc2153210f84be1577c66bcb97d8702d15893" translate="yes" xml:space="preserve">
          <source>I understand the initial question like this: to verify if a directory exists irrespective of the user's position in the file system. So using the command 'find' might do the trick:</source>
          <target state="translated">我理解最初的问题是这样的:无论用户在文件系统中的位置如何,都要验证一个目录是否存在。因此,使用 &quot;find &quot;命令可能就能解决这个问题。</target>
        </trans-unit>
        <trans-unit id="fa3207379d74a302595b72eb870d61ed50dccb53" translate="yes" xml:space="preserve">
          <source>IE, if you want to check for the existence of a directory before you enter it, try just doing this:</source>
          <target state="translated">IE,如果你想在输入前检查目录是否存在,可以试试这样做。</target>
        </trans-unit>
        <trans-unit id="fc67cf90106128a01a6735a9988d697f72e14a92" translate="yes" xml:space="preserve">
          <source>If  &lt;code&gt;parameter&lt;/code&gt;  is set and is non-null then substitute its value;
  otherwise, print &lt;code&gt;word&lt;/code&gt; and exit from the shell (if not interactive).
  If &lt;code&gt;word&lt;/code&gt; is omitted then a standard message is printed.</source>
          <target state="translated">如果 &lt;code&gt;parameter&lt;/code&gt; 被设置并且非空，则替换其值； 否则，打印 &lt;code&gt;word&lt;/code&gt; 并退出外壳（如果不是交互式的话）。 如果省略 &lt;code&gt;word&lt;/code&gt; 则打印标准消息。</target>
        </trans-unit>
        <trans-unit id="ca3ea3c8e3ff2d502ef573236e726959efe6c697" translate="yes" xml:space="preserve">
          <source>If found an issue with one of the approach provided above.</source>
          <target state="translated">如果发现上述方法中的一个问题。</target>
        </trans-unit>
        <trans-unit id="72e0bb78fdbb09923c00f4535e3239d5e262ed41" translate="yes" xml:space="preserve">
          <source>If the colon &lt;code&gt;:&lt;/code&gt; is omitted from  the  above  expressions,  then  the
  shell only checks whether parameter is set or not.</source>
          <target state="translated">如果上述表达式中省略了冒号 &lt;code&gt;:&lt;/code&gt; ，则shell仅检查是否设置了参数。</target>
        </trans-unit>
        <trans-unit id="bc37d17c42c135c01de8905e3a768eed998ad34d" translate="yes" xml:space="preserve">
          <source>If the path you give to &lt;code&gt;pushd&lt;/code&gt; exists, you'll enter it and it'll exit with &lt;code&gt;0&lt;/code&gt;, which means the &lt;code&gt;then&lt;/code&gt; portion of the statement will execute. If it doesn't exist, nothing will happen (other than some output saying the directory doesn't exist, which is probably a helpful side-effect anyways for debugging).</source>
          <target state="translated">如果提供给 &lt;code&gt;pushd&lt;/code&gt; 的路径存在，则将其输入并以 &lt;code&gt;0&lt;/code&gt; 退出，这意味着语句的 &lt;code&gt;then&lt;/code&gt; 部分将执行。 如果它不存在，则将不会发生任何事情（除了一些输出表明该目录不存在之外，这可能仍然是调试的有益副作用）。</target>
        </trans-unit>
        <trans-unit id="f690d196f425c6ceb50cc80a0925ad78b2612059" translate="yes" xml:space="preserve">
          <source>If the variables contain spaces or other unusual characters it will probably cause the script to fail.</source>
          <target state="translated">如果变量中含有空格或其他异常字符,很可能会导致脚本失败。</target>
        </trans-unit>
        <trans-unit id="c82c35a47e04d88fab353b51ea0305db297bde13" translate="yes" xml:space="preserve">
          <source>If you want to check if a directory exists, regardless if it's a real directory or a symlink, use this:</source>
          <target state="translated">如果你想检查一个目录是否存在,不管它是真正的目录还是symlink,都可以使用这个。</target>
        </trans-unit>
        <trans-unit id="5c153979d81d7d2a89cdb85179b75fe6e7aa8795" translate="yes" xml:space="preserve">
          <source>If you want to create the directory and it does not exist yet, then the simplest technique is to use &lt;code&gt;mkdir -p&lt;/code&gt; which creates the directory &amp;mdash; and any missing directories up the path &amp;mdash; and does not fail if the directory already exists, so you can do it all at once with:</source>
          <target state="translated">如果您要创建目录并且目录尚不存在，那么最简单的方法是使用 &lt;code&gt;mkdir -p&lt;/code&gt; 创建目录-以及路径中所有丢失的目录-并且如果目录已经存在也不会失败，因此您可以一次完成所有操作：</target>
        </trans-unit>
        <trans-unit id="15a13483c2ccc2b13cbca99b29ccad30f351751d" translate="yes" xml:space="preserve">
          <source>In particular the first character of &lt;code&gt;ls -l&lt;/code&gt; output it is usually a &lt;code&gt;d&lt;/code&gt; or a &lt;code&gt;-&lt;/code&gt; (dash). In case of a &lt;code&gt;d&lt;/code&gt; the one listed is a directory for sure.</source>
          <target state="translated">特别是 &lt;code&gt;ls -l&lt;/code&gt; 输出的第一个字符通常是 &lt;code&gt;d&lt;/code&gt; 或 &lt;code&gt;-&lt;/code&gt; （破折号）。 如果是 &lt;code&gt;d&lt;/code&gt; ，那么列出的肯定是一个目录。</target>
        </trans-unit>
        <trans-unit id="de07f0a507d444c78f5085adf9b2b0f87e0ae5ee" translate="yes" xml:space="preserve">
          <source>In this particular case, I know that the standard error message &lt;code&gt;1: parameter not set&lt;/code&gt; is not sufficient, so I zoom in on the type of value that we expect here - the &lt;code&gt;pathname&lt;/code&gt; of a directory.</source>
          <target state="translated">在这种特殊情况下，我知道标准错误消息 &lt;code&gt;1: parameter not set&lt;/code&gt; 是不够的，因此，我放大了我们在这里期望的值的类型-目录的 &lt;code&gt;pathname&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f7ccbb87c4a04b9404a5241410a0d1ca886d88cb" translate="yes" xml:space="preserve">
          <source>More features using &lt;code&gt;find&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;find&lt;/code&gt; 更多功能</target>
        </trans-unit>
        <trans-unit id="cb392062133006c3db8c8bcb383ef8b91e072e3b" translate="yes" xml:space="preserve">
          <source>N.B: Quoting variables is a good practice.</source>
          <target state="translated">注:引用变量是一个好的做法。</target>
        </trans-unit>
        <trans-unit id="0330d279c4eebfca7100bb37d2f1ea052f999c4f" translate="yes" xml:space="preserve">
          <source>Next is the argument that we pass to &lt;code&gt;cd&lt;/code&gt;: &lt;code&gt;${1:?pathname expected}&lt;/code&gt;.  This is a more elaborate form of parameter substitution which is explained in more detail below.</source>
          <target state="translated">接下来是我们传递给 &lt;code&gt;cd&lt;/code&gt; 的参数： &lt;code&gt;${1:?pathname expected}&lt;/code&gt; 。 这是参数替换的一种更精细的形式，下面将对其进行详细说明。</target>
        </trans-unit>
        <trans-unit id="e25c6c68f4a63c4d7bdbcd321d57eae9df656d02" translate="yes" xml:space="preserve">
          <source>No need to worry about spaces and special characters as long as you use &lt;code&gt;&quot;${}&quot;&lt;/code&gt;.</source>
          <target state="translated">只要使用 &lt;code&gt;&quot;${}&quot;&lt;/code&gt; 就不必担心空格和特殊字符。</target>
        </trans-unit>
        <trans-unit id="f7ea6e69a66e33c59a0a6581f2e96b4fc098a5fd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;[[]]&lt;/code&gt; is not as portable as &lt;code&gt;[]&lt;/code&gt;, but since most people work with modern versions of Bash (since after all, most people don't even work with command line :-p), the benefit is greater than the trouble.</source>
          <target state="translated">请注意， &lt;code&gt;[[]]&lt;/code&gt; 不如 &lt;code&gt;[]&lt;/code&gt; 轻便，但由于大多数人都使用现代版本的Bash（毕竟，大多数人甚至不使用命令行:-p），因此所获得的收益大于麻烦。</target>
        </trans-unit>
        <trans-unit id="d82e02f8a6073887c99c6f0c542a5b98b3c168bd" translate="yes" xml:space="preserve">
          <source>Note the &lt;strong&gt;-d&lt;/strong&gt; test can produce some surprising results:</source>
          <target state="translated">注意&lt;strong&gt;-d&lt;/strong&gt;测试可以产生一些令人惊讶的结果：</target>
        </trans-unit>
        <trans-unit id="e76756c97ce0ef44bc99a6e5d26266916cf69147" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;test&lt;/code&gt; command is same as conditional expression &lt;code&gt;[&lt;/code&gt; (see: &lt;code&gt;man [&lt;/code&gt;), so it's portable across shell scripts.</source>
          <target state="translated">注意： &lt;code&gt;test&lt;/code&gt; 命令与条件表达式 &lt;code&gt;[&lt;/code&gt; （请参阅： &lt;code&gt;man [&lt;/code&gt; ），因此它可以在shell脚本之间移植。</target>
        </trans-unit>
        <trans-unit id="89f71a9ccda28ce7ef564f54962121174107e090" translate="yes" xml:space="preserve">
          <source>One day, one of those kids will run your script with &lt;code&gt;$DIRECTORY&lt;/code&gt; set to &lt;code&gt;&quot;My M0viez&quot;&lt;/code&gt; and your script will blow up. You don't want that. So use this.</source>
          <target state="translated">有一天，其中一个孩子将在 &lt;code&gt;$DIRECTORY&lt;/code&gt; 设置为 &lt;code&gt;&quot;My M0viez&quot;&lt;/code&gt; 运行您的脚本，并且脚本会崩溃 。 你不要那样 所以用这个。</target>
        </trans-unit>
        <trans-unit id="d6d97a835b350f1c82be7882f32f984062d4ecba" translate="yes" xml:space="preserve">
          <source>Or for something completely useless:</source>
          <target state="translated">或者是为了一些完全无用的东西。</target>
        </trans-unit>
        <trans-unit id="88c9d56e5a74f7cdef89e4ed75b2aebab124a280" translate="yes" xml:space="preserve">
          <source>Or to check if a directory doesn't exist:</source>
          <target state="translated">或者检查一个目录是否不存在。</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="ffd8320e26b919ccdb8d76fe053cfe0c83aced0c" translate="yes" xml:space="preserve">
          <source>Practical usage:</source>
          <target state="translated">实际使用。</target>
        </trans-unit>
        <trans-unit id="37042ae73af0e62806e3959b848d75deaedd39b2" translate="yes" xml:space="preserve">
          <source>Quoting from the &lt;code&gt;ksh93&lt;/code&gt; man page:</source>
          <target state="translated">引用 &lt;code&gt;ksh93&lt;/code&gt; 手册页：</target>
        </trans-unit>
        <trans-unit id="a190dbfd317271efc07f048f624324161c2ee0aa" translate="yes" xml:space="preserve">
          <source>Remember to always wrap variables in double quotes when referencing them in
a bash script. Kids these days grow up with the idea that they can have spaces and lots of other funny characters in their directory names. (Spaces! Back in my days, we didn't have no fancy spaces! ;))</source>
          <target state="translated">记住,在bash脚本中引用变量时,一定要用双引号包起来。现在的孩子们长大了,他们的目录名中可以有空格和很多其他有趣的字符。(空格!在我的年代,我们没有花哨的空格!)。</target>
        </trans-unit>
        <trans-unit id="99dd89c6ad7ae5fa50a90061d830f433ea145732" translate="yes" xml:space="preserve">
          <source>Same thing works with &lt;code&gt;cd&lt;/code&gt;, &lt;code&gt;mv&lt;/code&gt;, &lt;code&gt;rm&lt;/code&gt;, etc... if you try them on files that don't exist, they'll exit with an error and print a message saying it doesn't exist, and your &lt;code&gt;then&lt;/code&gt; block will be skipped. If you try them on files that do exist, the command will execute and exit with a status of &lt;code&gt;0&lt;/code&gt;, allowing your &lt;code&gt;then&lt;/code&gt; block to execute.</source>
          <target state="translated">&lt;code&gt;cd&lt;/code&gt; ， &lt;code&gt;mv&lt;/code&gt; ， &lt;code&gt;rm&lt;/code&gt; 等也可以使用同样的方法...如果您在不存在的文件上尝试使用它们，它们将退出并显示错误消息，提示该文件不存在， &lt;code&gt;then&lt;/code&gt; 您的then块将是跳过了。 如果在存在的文件上尝试使用它们，该命令将执行并以 &lt;code&gt;0&lt;/code&gt; 状态退出，从而允许您的 &lt;code&gt;then&lt;/code&gt; 块执行。</target>
        </trans-unit>
        <trans-unit id="77117ff227ef719bef67b8606ba58dd8f6506d59" translate="yes" xml:space="preserve">
          <source>Seems better than this, which requires repeating yourself:</source>
          <target state="translated">似乎比这个要好,这就需要你自己重复一遍。</target>
        </trans-unit>
        <trans-unit id="78b725c3ff0067391adcd4f7f423fc5cf6d6c9a8" translate="yes" xml:space="preserve">
          <source>Shorter form:</source>
          <target state="translated">较短的形式。</target>
        </trans-unit>
        <trans-unit id="d85d4ecbed8d7b05375047512f2620d088dcf47c" translate="yes" xml:space="preserve">
          <source>So symbolic links may have to be treated differently, if subsequent commands expect directories:</source>
          <target state="translated">所以,如果后续命令期待目录的话,符号链接可能要区别对待。</target>
        </trans-unit>
        <trans-unit id="d54c7b9353a65c8a7007a94eff2a6a97846f6e33" translate="yes" xml:space="preserve">
          <source>Take particular note of the double-quotes used to wrap the variables, the reason for this is explained by 8jean &lt;a href=&quot;https://stackoverflow.com/a/67458/102401&quot;&gt;in another answer&lt;/a&gt;.</source>
          <target state="translated">请特别注意用于包装变量的双引号，其原因由8jean &lt;a href=&quot;https://stackoverflow.com/a/67458/102401&quot;&gt;在另一个答案中&lt;/a&gt;解释。</target>
        </trans-unit>
        <trans-unit id="6b0972881542543df05bda34f966804f87040adc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ls&lt;/code&gt; command in conjunction with &lt;code&gt;-l&lt;/code&gt; (long listing) option returns attributes information about files and directories.</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 命令与 &lt;code&gt;-l&lt;/code&gt; （长清单）选项结合使用可返回有关文件和目录的属性信息。</target>
        </trans-unit>
        <trans-unit id="26263b6ab5b67672c58848402031941f2f826c70" translate="yes" xml:space="preserve">
          <source>The above code checks if the directory exists and if it is writable.</source>
          <target state="translated">上面的代码检查目录是否存在,是否可写。</target>
        </trans-unit>
        <trans-unit id="9444564a739b6515c85e62593d0592ac9756241d" translate="yes" xml:space="preserve">
          <source>The above scripts will check the dir is present or not</source>
          <target state="translated">上述脚本将检查dir是否存在。</target>
        </trans-unit>
        <trans-unit id="dc196b87266de4a756303b455624b49413a5ddb0" translate="yes" xml:space="preserve">
          <source>The following command in just one line will tell you if the given &lt;strong&gt;&lt;code&gt;ISDIR&lt;/code&gt;&lt;/strong&gt; variable contains a path to a directory or not:</source>
          <target state="translated">仅以下一行的以下命令将告诉您给定的&lt;strong&gt; &lt;code&gt;ISDIR&lt;/code&gt; &lt;/strong&gt;变量是否包含目录的路径：</target>
        </trans-unit>
        <trans-unit id="bfaa3c1354e38e455c54027b1c313020a774ff25" translate="yes" xml:space="preserve">
          <source>The nice thing about this approach is that I do not have to think of a good error message.</source>
          <target state="translated">这种方法的好处是,我不需要想出好的错误信息。</target>
        </trans-unit>
        <trans-unit id="2be4bb090752f296f27105f0e0a563e7270b26ad" translate="yes" xml:space="preserve">
          <source>The phrasing here is peculiar to the shell documentation, as &lt;code&gt;word&lt;/code&gt; may refer
to any reasonable string, including whitespace.</source>
          <target state="translated">措词在shell文档中是特有的，因为 &lt;code&gt;word&lt;/code&gt; 可以指代任何合理的字符串，包括空格。</target>
        </trans-unit>
        <trans-unit id="dbc556904c8dc3d6be6a97575f40c1c8d1bcc47e" translate="yes" xml:space="preserve">
          <source>Therfore:</source>
          <target state="translated">Therfore:</target>
        </trans-unit>
        <trans-unit id="f2281eea998213be04a800c65064d230e9644281" translate="yes" xml:space="preserve">
          <source>This is not completely true... 
If you want to go to that directory, you also needs to have the execute rights on the directory. Maybe you need to have write rights as well.</source>
          <target state="translated">这不是完全正确的.....如果你想去那个目录,你也需要有目录上的执行权限。也许你也需要有写权限。</target>
        </trans-unit>
        <trans-unit id="90a19dc5ecf99a9009a2dbb16da022cb214198d9" translate="yes" xml:space="preserve">
          <source>This solution is good because it allows the use of wildcards, a useful feature when searching for files/directories. The only problem is that, if the searched directory doesn't exist, the 'find' command will print nothing to stdout (not an elegant solution for my taste) and will have nonetheless a zero exit. Maybe someone could improve on this.</source>
          <target state="translated">这个解决方案很好,因为它允许使用通配符,这在搜索文件目录时很有用。唯一的问题是,如果搜索到的目录不存在,'find'命令将不会向stdout打印任何东西(对我来说,这不是一个优雅的解决方案),但是会有一个零退出。也许有人可以改进一下。</target>
        </trans-unit>
        <trans-unit id="96ee4c12a5566d81da281af7463d45f0e001f26a" translate="yes" xml:space="preserve">
          <source>Tl;dr: If the string passed into this function is empty, we again exit from the subshell &lt;code&gt;( ... )&lt;/code&gt; and return from the function with the given error message.</source>
          <target state="translated">Tl; dr：如果传递给此函数的字符串为空，则再次退出子shell &lt;code&gt;( ... )&lt;/code&gt; 并从函数返回给定的错误消息。</target>
        </trans-unit>
        <trans-unit id="e0cada1eb567b078a41eed7ed73c167b0cd643b3" translate="yes" xml:space="preserve">
          <source>To check if a directory exists in a shell script you can use the following:</source>
          <target state="translated">要检查一个目录是否存在于shell脚本中,你可以使用以下方法。</target>
        </trans-unit>
        <trans-unit id="802e0a0ff420cf1ac339d116f389f9b6010f5f78" translate="yes" xml:space="preserve">
          <source>To check if a directory exists you can use simple if structure like this:</source>
          <target state="translated">要检查一个目录是否存在,你可以使用简单的if结构来检查。</target>
        </trans-unit>
        <trans-unit id="6a2685bb57c01af38dce3160aeb3734d48d99955" translate="yes" xml:space="preserve">
          <source>To check more than one directory use this code:</source>
          <target state="translated">要检查不止一个目录,请使用此代码。</target>
        </trans-unit>
        <trans-unit id="82eeb370eca1bd5552ecc5064f727f173c31e84f" translate="yes" xml:space="preserve">
          <source>Type this code on the bash promt</source>
          <target state="translated">在bash promt上键入此代码</target>
        </trans-unit>
        <trans-unit id="c2cae6fb5a700400b2df4fae9c1d3e02062afac5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;-e&lt;/code&gt; check will check for files and this includes directories.</source>
          <target state="translated">使用 &lt;code&gt;-e&lt;/code&gt; 检查将检查文件，其中包括目录。</target>
        </trans-unit>
        <trans-unit id="9f6d0c65af1fa450ed17190f7a6eed36470ef3e8" translate="yes" xml:space="preserve">
          <source>What command can be used to check if a directory exists or not, within a Bash shell script?</source>
          <target state="translated">在Bash shell脚本中,可以用什么命令来检查目录是否存在?</target>
        </trans-unit>
        <trans-unit id="d8c2db3639ae549ace8e1c73af03174495471d04" translate="yes" xml:space="preserve">
          <source>Will produce the error message:</source>
          <target state="translated">将产生错误信息。</target>
        </trans-unit>
        <trans-unit id="0ae3f045c178d1d4b1fa641c1b902280e5044725" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ls&lt;/code&gt; command; the cases when directory does not exists - an error message is shown</source>
          <target state="translated">使用 &lt;code&gt;ls&lt;/code&gt; 命令； 目录不存在的情况-显示错误消息</target>
        </trans-unit>
        <trans-unit id="90fab5420ee387ae94bf6e4438b0845086481f73" translate="yes" xml:space="preserve">
          <source>With the same syntax you can use:</source>
          <target state="translated">用同样的语法,你可以使用。</target>
        </trans-unit>
        <trans-unit id="d14720b4c847ece5ac99caaf9efca53424143435" translate="yes" xml:space="preserve">
          <source>You can do it also in negative</source>
          <target state="translated">你也可以用负数来做</target>
        </trans-unit>
        <trans-unit id="7bc690d39c6601d38641eeeee9a206157ad110a2" translate="yes" xml:space="preserve">
          <source>You can find more information in the Bash manual on &lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#Bash-Conditional-Expressions&quot;&gt;Bash conditional expressions&lt;/a&gt; and the &lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#index-_005b&quot;&gt;&lt;code&gt;[&lt;/code&gt; builtin command&lt;/a&gt; and the &lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#index-_005b_005b&quot;&gt;&lt;code&gt;[[&lt;/code&gt; compound commmand&lt;/a&gt;.</source>
          <target state="translated">您可以在Bash手册中找到有关&lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#Bash-Conditional-Expressions&quot;&gt;Bash条件表达式&lt;/a&gt;以及&lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#index-_005b&quot;&gt; &lt;code&gt;[&lt;/code&gt; 内置命令&lt;/a&gt;和&lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#index-_005b_005b&quot;&gt; &lt;code&gt;[[&lt;/code&gt; 复合&lt;/a&gt; 命令 。</target>
        </trans-unit>
        <trans-unit id="5077e78ced4e1bda6bdbc6746f48e6fd0c1de9b4" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;test -d&lt;/code&gt; (see &lt;code&gt;man test&lt;/code&gt;).</source>
          <target state="translated">您可以使用 &lt;code&gt;test -d&lt;/code&gt; （请参阅 &lt;code&gt;man test&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="d5ffe1efe416a48c794b4c339c9db23d31d92d85" translate="yes" xml:space="preserve">
          <source>is_dir</source>
          <target state="translated">is_dir</target>
        </trans-unit>
        <trans-unit id="7bc2760823ac0e7182b3addd6b65a069153fc276" translate="yes" xml:space="preserve">
          <source>mkdir: cannot create directory &amp;lsquo;tempdir&amp;rsquo;: File exists</source>
          <target state="translated">mkdir：无法创建目录&amp;ldquo; tempdir&amp;rdquo;：文件存在</target>
        </trans-unit>
        <trans-unit id="f78dc2b020a65866379a93acbea09bede07fb206" translate="yes" xml:space="preserve">
          <source>will execute successfully only if at the moment of execution you're in a directory that has a subdirectory that you happen to check for.</source>
          <target state="translated">只有当你在执行的时候,你所在的目录有一个子目录,而这个子目录恰好是你检查到的,那么它才会成功执行。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
