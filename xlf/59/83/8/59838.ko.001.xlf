<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/59838">
    <body>
      <group id="59838">
        <trans-unit id="fa993ec66455570012e9013cf1463ed955c29d2b" translate="yes" xml:space="preserve">
          <source>$ [[ &lt;code&gt;ls -ld SAMPLE_DIR| grep ^d | wc -l&lt;/code&gt; -eq 1 ]] &amp;amp;&amp;amp; echo exists || not exists
-ksh: not: not found [No such file or directory]</source>
          <target state="translated">$ [[ &lt;code&gt;ls -ld SAMPLE_DIR| grep ^d | wc -l&lt;/code&gt; grep ^ d | wc -l -eq 1]] &amp;amp;&amp;amp; echo 존재 || 존재하지 않음 -ksh : not : 찾을 수 없음 [해당 파일 또는 디렉토리가 없습니다]</target>
        </trans-unit>
        <trans-unit id="207f52d501fccd0c1a03258f9a4ba170a5a42466" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/59871/26510&quot;&gt;This answer&lt;/a&gt; wrapped up as a shell script</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/59871/26510&quot;&gt;이 답변&lt;/a&gt; 은 쉘 스크립트로 싸여 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e0e12dfd443e81b936e303737feb7e5b54bce54" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$?&lt;/code&gt;  if the last command sucess it returns &quot;0&quot; else non zero value.
suppose &lt;code&gt;tempdir&lt;/code&gt; is already present then &lt;code&gt;mkdir tempdir&lt;/code&gt; will give error like below:</source>
          <target state="translated">&lt;code&gt;$?&lt;/code&gt; 마지막 명령이 성공하면 &quot;0&quot;을 반환하고 그렇지 않으면 0이 아닌 값을 반환합니다. &lt;code&gt;tempdir&lt;/code&gt; 이 이미 있다고 가정하면 &lt;code&gt;mkdir tempdir&lt;/code&gt; 은 다음과 같은 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="feda4164b3c0a2676771fde73bb174bd7ed6f917" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;-d file&lt;/code&gt;       True if file exists and is a directory.</source>
          <target state="translated">&lt;code&gt;-d file&lt;/code&gt; 파일이 존재하고 디렉토리 인 경우에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="434bb26fe4597d2630646259bd5f58901fd76397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[&lt;/code&gt; - This is a synonym for the &lt;code&gt;test&lt;/code&gt; builtin, but the last argument must, be a literal &lt;code&gt;]&lt;/code&gt;, to match the opening &lt;code&gt;[&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;[&lt;/code&gt; - &lt;code&gt;test&lt;/code&gt; 내장의 동의어이지만 마지막 인수는 리터럴이어야합니다.</target>
        </trans-unit>
        <trans-unit id="eb1e3608bea738f684006334bf1064168d620141" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cd&lt;/code&gt; will give me a standard one line message to stderr already.  It will also give more information than I will be able to provide. By performing the &lt;code&gt;cd&lt;/code&gt; inside a subshell &lt;code&gt;( ... )&lt;/code&gt;, the command does not affect the current directory of the caller.  If the directory exists, this subshell and the function are just a no-op.</source>
          <target state="translated">&lt;code&gt;cd&lt;/code&gt; 는 이미 stderr에게 표준 한 줄 메시지를 줄 것입니다. 또한 내가 제공 할 수있는 것보다 더 많은 정보를 제공 할 것입니다. 서브 쉘 &lt;code&gt;( ... )&lt;/code&gt; 내에서 &lt;code&gt;cd&lt;/code&gt; 를 수행하면 명령은 호출자의 현재 디렉토리에 영향을 미치지 않습니다. 디렉토리가 존재하면이 서브 쉘과 기능은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="027520a48b909e71c33dda807972513e35b92e3d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;man test&lt;/code&gt; or &lt;code&gt;man [&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;man test&lt;/code&gt; 또는 &lt;code&gt;man [&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bece6e4aec1b0d3891d5ef560eeef888ec945439" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;https://code.labstack.com/7GMFlEaC&quot;&gt;Try online&lt;/a&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://code.labstack.com/7GMFlEaC&quot;&gt;온라인으로 시도&lt;/a&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="163253848062881e0d2329cc2527145d49820c0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Be careful, leave empty spaces on either side of both opening and closing braces.</source>
          <target state="translated">&lt;strong&gt;참고&lt;/strong&gt; : 개폐 용 버팀대 양쪽에 빈 공간을 두십시오.</target>
        </trans-unit>
        <trans-unit id="3997fed95faa341282cd437483c5c670e8b1844c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;&lt;code&gt;bluh: directory&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;출력 :&lt;/strong&gt; &lt;code&gt;bluh: directory&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfb619c9b31d43d856e2c9622e21fcd9cbf45233" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;&lt;code&gt;cannot open 'blah' (No such file or directory)&lt;/code&gt;</source>
          <target state="translated">&lt;strong&gt;출력 :&lt;/strong&gt; &lt;code&gt;cannot open 'blah' (No such file or directory)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b4185a6d1d73515d38f626b4858d6fd8bf83ab7" translate="yes" xml:space="preserve">
          <source>A philosphical note:
The shell is not an object oriented language, so the message says &lt;code&gt;pathname&lt;/code&gt;, not &lt;code&gt;directory&lt;/code&gt;.  At this level, I'd rather keep it simple - the arguments to a function are just strings.</source>
          <target state="translated">철학 참고 사항 : 쉘은 객체 지향 언어가 아니므로 메시지는 &lt;code&gt;directory&lt;/code&gt; 가 아니라 &lt;code&gt;pathname&lt;/code&gt; 이라고 표시됩니다. 이 수준에서는 간단하게 유지하고 싶습니다. 함수에 대한 인수는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="0a45f6aedea833628df36f248058fcab8f52a9d6" translate="yes" xml:space="preserve">
          <source>A simple script to check whether the directory is present or not:</source>
          <target state="translated">디렉토리가 있는지 여부를 확인하는 간단한 스크립트 :</target>
        </trans-unit>
        <trans-unit id="a3c1d22947265563d45fd4e652519b22a668c349" translate="yes" xml:space="preserve">
          <source>A simple script to test if dir or file is present or not:</source>
          <target state="translated">dir 또는 파일이 있는지 여부를 테스트하는 간단한 스크립트 :</target>
        </trans-unit>
        <trans-unit id="fd6e80065208ac7351071006ecfe52b4d309e9e5" translate="yes" xml:space="preserve">
          <source>Actually, you should use several tools to get a bulletproof approach:</source>
          <target state="translated">실제로 몇 가지 도구를 사용하여 방탄 방법을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="464055c0f8481e3a474e0ca37383e37b458ec20a" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;https://stackoverflow.com/users/15168/jonathan-leffler&quot;&gt;Jonathan&lt;/a&gt; comment:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/15168/jonathan-leffler&quot;&gt;Jonathan의&lt;/a&gt; 의견에 따르면 :</target>
        </trans-unit>
        <trans-unit id="c5e4fba4b777f62c1a98acce6699a3a59b7781e3" translate="yes" xml:space="preserve">
          <source>Both combinations. In the following example, it checks the existence of the folder in the current directory:</source>
          <target state="translated">두 가지 조합. 다음 예제에서는 현재 디렉토리에 폴더가 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b0a39235449c9b80afd08f03ea6648737facd108" translate="yes" xml:space="preserve">
          <source>Check existence of one or several folders based on a pattern within the current directory:</source>
          <target state="translated">현재 디렉토리 내의 패턴에 따라 하나 이상의 폴더가 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="221be94517340b5d7edd17ba6f1747d346cae247" translate="yes" xml:space="preserve">
          <source>Check existence of the folder within sub-directories:</source>
          <target state="translated">하위 디렉토리 내에 폴더가 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f41aa9b9ef657005fb51d75b158b17ed6563060c" translate="yes" xml:space="preserve">
          <source>Check if directory exists, else make one</source>
          <target state="translated">디렉토리가 존재하는지 확인하십시오. 그렇지 않으면 디렉토리를 만드십시오.</target>
        </trans-unit>
        <trans-unit id="8817dabaf58544f10e9e8044e576b691d9909f99" translate="yes" xml:space="preserve">
          <source>Checking existing directory: &lt;code&gt;file bluh&lt;/code&gt;</source>
          <target state="translated">기존 디렉토리 확인 : &lt;code&gt;file bluh&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e7b8e871985e69d583f6865533432144019e169" translate="yes" xml:space="preserve">
          <source>Checking nonexistent file: &lt;code&gt;file blah&lt;/code&gt;</source>
          <target state="translated">존재하지 않는 파일 확인 : &lt;code&gt;file blah&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="d3f89fd4db9124590507d0a77795675385a13a81" translate="yes" xml:space="preserve">
          <source>Explanation: The &quot;ls&quot; command gives an error &quot;ls: /x: No such file or directory&quot; if the directory or symlink does not exist, and also sets the return code, which you can retrieve via &quot;$?&quot;, to non-null (normally &quot;1&quot;).
Be sure that you check the return code directly after calling &quot;ls&quot;.</source>
          <target state="translated">설명 : &quot;ls&quot;명령은 디렉토리 또는 심볼릭 링크가 존재하지 않으면 &quot;ls : / x : 해당 파일 또는 디렉토리가 없습니다&quot;라는 오류를 표시하고 &quot;$?&quot;를 통해 검색 할 수있는 리턴 코드를 비로 설정합니다. -null (일반적으로 &quot;1&quot;). &quot;ls&quot;를 호출 한 후 리턴 코드를 직접 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="1b1eea7be5fe905e80303ca40514b1db06d2f422" translate="yes" xml:space="preserve">
          <source>File under: &quot;When is a directory not a directory?&quot;  The answer: &quot;When it's a symlink to a directory.&quot;  A slightly more thorough test:</source>
          <target state="translated">&quot;디렉토리가 디렉토리가 아닌 경우&quot;아래의 파일 대답 : &quot;디렉토리에 대한 심볼릭 링크 인 경우&quot; 약간 더 철저한 테스트 :</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5809133b5d742fa3d011e67ffed4584ce187906c" translate="yes" xml:space="preserve">
          <source>For possible options or further help, check:</source>
          <target state="translated">가능한 옵션 또는 추가 도움이 필요하면 다음을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0e50a574ae5c5907245152793f0a5b1ec421b157" translate="yes" xml:space="preserve">
          <source>Great solutions out there, but ultimately every script will fail if you're not in the right directory. So code like this:</source>
          <target state="translated">훌륭한 해결책이 있지만 올바른 디렉토리에 있지 않으면 모든 스크립트가 실패합니다. 따라서 다음과 같은 코드를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="583aed4873fd41e41427b6bc1d64cb3bd468fd28" translate="yes" xml:space="preserve">
          <source>Have you considered just doing whatever you want to do in the &lt;code&gt;if&lt;/code&gt; rather than looking before you leap?</source>
          <target state="translated">당신은 당신이 도약하기 전에 보는 대신 &lt;code&gt;if&lt;/code&gt; 에서하고 싶은 일을하는 것을 고려 했습니까?</target>
        </trans-unit>
        <trans-unit id="082b4e4b43eda6f1643255fe64e1a3ad94266d3b" translate="yes" xml:space="preserve">
          <source>Here's a very pragmatic idiom:</source>
          <target state="translated">다음은 매우 실용적인 관용구입니다.</target>
        </trans-unit>
        <trans-unit id="a2fc766f174dc35f89cacdbd9b843d7518a58574" translate="yes" xml:space="preserve">
          <source>How about &lt;code&gt;file&lt;/code&gt; program.
Considering all directories are also files in linux, issuing following command would suffice:</source>
          <target state="translated">&lt;code&gt;file&lt;/code&gt; 프로그램은 어떻습니까. 모든 디렉토리가 리눅스에서도 파일이라는 것을 고려하면 다음 명령을 실행하면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="dd106d637fc8e15919d6f826690e723d312a6366" translate="yes" xml:space="preserve">
          <source>How to check if a directory exists in a Bash shell script</source>
          <target state="translated">Bash 쉘 스크립트에 디렉토리가 있는지 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="bd085a6bf0566c0ec2d66c9e634591d684f558b5" translate="yes" xml:space="preserve">
          <source>However, as &lt;a href=&quot;https://stackoverflow.com/users/1438/jon-ericson&quot;&gt;Jon Ericson&lt;/a&gt; points out, subsequent commands may not work as intended if you do not take into account that a symbolic link to a directory will also pass this check.
E.g. running this:</source>
          <target state="translated">그러나 &lt;a href=&quot;https://stackoverflow.com/users/1438/jon-ericson&quot;&gt;Jon Ericson이&lt;/a&gt; 지적했듯이 디렉토리에 대한 심볼릭 링크도이 검사를 통과하지 않으면 후속 명령이 의도 한대로 작동하지 않을 수 있습니다. 예를 들어 이것을 실행 :</target>
        </trans-unit>
        <trans-unit id="1387051c9062c34eca949313dbc4255c45cc0e5c" translate="yes" xml:space="preserve">
          <source>I find the &lt;a href=&quot;http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS&quot;&gt;double-bracket&lt;/a&gt; version of &lt;code&gt;test&lt;/code&gt; makes writing logic tests more natural:</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 의 &lt;a href=&quot;http://tldp.org/LDP/abs/html/testconstructs.html#DBLBRACKETS&quot;&gt;이중 브래킷&lt;/a&gt; 버전이 논리 테스트 작성을보다 자연스럽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8353f3f0e57f21586871e79884cb6c9a83d64eba" translate="yes" xml:space="preserve">
          <source>I typically wrap it in a function:</source>
          <target state="translated">나는 일반적으로 그것을 함수로 포장 :</target>
        </trans-unit>
        <trans-unit id="efdcc2153210f84be1577c66bcb97d8702d15893" translate="yes" xml:space="preserve">
          <source>I understand the initial question like this: to verify if a directory exists irrespective of the user's position in the file system. So using the command 'find' might do the trick:</source>
          <target state="translated">파일 시스템에서의 사용자 위치와 상관없이 디렉토리가 존재하는지 확인하기 위해 다음과 같은 초기 질문을 이해합니다. 따라서 'find'명령을 사용하면 트릭을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa3207379d74a302595b72eb870d61ed50dccb53" translate="yes" xml:space="preserve">
          <source>IE, if you want to check for the existence of a directory before you enter it, try just doing this:</source>
          <target state="translated">IE, 디렉토리에 들어가기 전에 디렉토리가 있는지 확인하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="fc67cf90106128a01a6735a9988d697f72e14a92" translate="yes" xml:space="preserve">
          <source>If  &lt;code&gt;parameter&lt;/code&gt;  is set and is non-null then substitute its value;
  otherwise, print &lt;code&gt;word&lt;/code&gt; and exit from the shell (if not interactive).
  If &lt;code&gt;word&lt;/code&gt; is omitted then a standard message is printed.</source>
          <target state="translated">&lt;code&gt;parameter&lt;/code&gt; 가 설정되고 널이 아닌 경우 해당 값을 대체하십시오. 그렇지 않으면, &lt;code&gt;word&lt;/code&gt; 인쇄하고 쉘에서 종료하십시오 (대화식이 아닌 경우). &lt;code&gt;word&lt;/code&gt; 를 생략하면 표준 메시지가 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ca3ea3c8e3ff2d502ef573236e726959efe6c697" translate="yes" xml:space="preserve">
          <source>If found an issue with one of the approach provided above.</source>
          <target state="translated">위에 제공된 방법 중 하나에 문제가있는 경우</target>
        </trans-unit>
        <trans-unit id="72e0bb78fdbb09923c00f4535e3239d5e262ed41" translate="yes" xml:space="preserve">
          <source>If the colon &lt;code&gt;:&lt;/code&gt; is omitted from  the  above  expressions,  then  the
  shell only checks whether parameter is set or not.</source>
          <target state="translated">콜론 &lt;code&gt;:&lt;/code&gt; 이 위의 표현식에서 생략되면, 쉘은 매개 변수 설정 여부 만 확인합니다.</target>
        </trans-unit>
        <trans-unit id="bc37d17c42c135c01de8905e3a768eed998ad34d" translate="yes" xml:space="preserve">
          <source>If the path you give to &lt;code&gt;pushd&lt;/code&gt; exists, you'll enter it and it'll exit with &lt;code&gt;0&lt;/code&gt;, which means the &lt;code&gt;then&lt;/code&gt; portion of the statement will execute. If it doesn't exist, nothing will happen (other than some output saying the directory doesn't exist, which is probably a helpful side-effect anyways for debugging).</source>
          <target state="translated">&lt;code&gt;pushd&lt;/code&gt; 한 경로가 존재하면 경로를 입력하고 &lt;code&gt;0&lt;/code&gt; 으로 종료되므로 명령문의 &lt;code&gt;then&lt;/code&gt; 부분이 실행됩니다. 디렉토리가 존재하지 않으면 아무 것도 발생하지 않습니다 (디렉토리가 존재하지 않는다는 일부 출력 이외의 것으로 디버깅에 유용한 부작용 일 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="f690d196f425c6ceb50cc80a0925ad78b2612059" translate="yes" xml:space="preserve">
          <source>If the variables contain spaces or other unusual characters it will probably cause the script to fail.</source>
          <target state="translated">변수에 공백이나 다른 특수 문자가 포함되어 있으면 스크립트가 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c82c35a47e04d88fab353b51ea0305db297bde13" translate="yes" xml:space="preserve">
          <source>If you want to check if a directory exists, regardless if it's a real directory or a symlink, use this:</source>
          <target state="translated">실제 디렉토리인지 또는 심볼릭 링크인지에 관계없이 디렉토리가 존재하는지 확인하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5c153979d81d7d2a89cdb85179b75fe6e7aa8795" translate="yes" xml:space="preserve">
          <source>If you want to create the directory and it does not exist yet, then the simplest technique is to use &lt;code&gt;mkdir -p&lt;/code&gt; which creates the directory &amp;mdash; and any missing directories up the path &amp;mdash; and does not fail if the directory already exists, so you can do it all at once with:</source>
          <target state="translated">디렉토리를 만들고 싶지만 아직 존재하지 않는 경우 가장 간단한 방법은 &lt;code&gt;mkdir -p&lt;/code&gt; 를 사용하여 디렉토리를 만들고 디렉토리가없는 경우 실패하지 않고 디렉토리가 이미 존재하더라도 실패하지 않는 것입니다. 한 번에 모두 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="15a13483c2ccc2b13cbca99b29ccad30f351751d" translate="yes" xml:space="preserve">
          <source>In particular the first character of &lt;code&gt;ls -l&lt;/code&gt; output it is usually a &lt;code&gt;d&lt;/code&gt; or a &lt;code&gt;-&lt;/code&gt; (dash). In case of a &lt;code&gt;d&lt;/code&gt; the one listed is a directory for sure.</source>
          <target state="translated">특히 &lt;code&gt;ls -l&lt;/code&gt; 출력의 첫 번째 문자는 일반적으로 &lt;code&gt;d&lt;/code&gt; 또는 a-(대시)입니다. &lt;code&gt;d&lt;/code&gt; 의 경우 나열된 디렉토리는 반드시 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="de07f0a507d444c78f5085adf9b2b0f87e0ae5ee" translate="yes" xml:space="preserve">
          <source>In this particular case, I know that the standard error message &lt;code&gt;1: parameter not set&lt;/code&gt; is not sufficient, so I zoom in on the type of value that we expect here - the &lt;code&gt;pathname&lt;/code&gt; of a directory.</source>
          <target state="translated">이 특별한 경우, 나는 표준 오류 메시지 &lt;code&gt;1: parameter not set&lt;/code&gt; 가 충분하지 않다는 것을 알고 있으므로 여기서 예상되는 값 유형-디렉토리의 &lt;code&gt;pathname&lt;/code&gt; 을 확대합니다.</target>
        </trans-unit>
        <trans-unit id="f7ccbb87c4a04b9404a5241410a0d1ca886d88cb" translate="yes" xml:space="preserve">
          <source>More features using &lt;code&gt;find&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; 사용하는 더 많은 기능</target>
        </trans-unit>
        <trans-unit id="cb392062133006c3db8c8bcb383ef8b91e072e3b" translate="yes" xml:space="preserve">
          <source>N.B: Quoting variables is a good practice.</source>
          <target state="translated">주의 : 변수를 인용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0330d279c4eebfca7100bb37d2f1ea052f999c4f" translate="yes" xml:space="preserve">
          <source>Next is the argument that we pass to &lt;code&gt;cd&lt;/code&gt;: &lt;code&gt;${1:?pathname expected}&lt;/code&gt;.  This is a more elaborate form of parameter substitution which is explained in more detail below.</source>
          <target state="translated">다음은 &lt;code&gt;cd&lt;/code&gt; 로 전달하는 인수입니다 : &lt;code&gt;${1:?pathname expected}&lt;/code&gt; . 이는보다 정교한 매개 변수 대체 형식으로 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e25c6c68f4a63c4d7bdbcd321d57eae9df656d02" translate="yes" xml:space="preserve">
          <source>No need to worry about spaces and special characters as long as you use &lt;code&gt;&quot;${}&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;${}&quot;&lt;/code&gt; 을 사용하는 한 공백과 특수 문자에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f7ea6e69a66e33c59a0a6581f2e96b4fc098a5fd" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;[[]]&lt;/code&gt; is not as portable as &lt;code&gt;[]&lt;/code&gt;, but since most people work with modern versions of Bash (since after all, most people don't even work with command line :-p), the benefit is greater than the trouble.</source>
          <target state="translated">&lt;code&gt;[[]]&lt;/code&gt; 는 [] 만큼 이식성이 없지만 대부분의 사람들은 최신 버전의 Bash를 사용하므로 (대부분의 사람들은 명령 줄을 사용하지 않기 때문에 :-p) 이점은 수고.</target>
        </trans-unit>
        <trans-unit id="d82e02f8a6073887c99c6f0c542a5b98b3c168bd" translate="yes" xml:space="preserve">
          <source>Note the &lt;strong&gt;-d&lt;/strong&gt; test can produce some surprising results:</source>
          <target state="translated">&lt;strong&gt;-d&lt;/strong&gt; 테스트는 놀라운 결과를 낳을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e76756c97ce0ef44bc99a6e5d26266916cf69147" translate="yes" xml:space="preserve">
          <source>Note: The &lt;code&gt;test&lt;/code&gt; command is same as conditional expression &lt;code&gt;[&lt;/code&gt; (see: &lt;code&gt;man [&lt;/code&gt;), so it's portable across shell scripts.</source>
          <target state="translated">참고 : &lt;code&gt;test&lt;/code&gt; 명령은 조건식 &lt;code&gt;[&lt;/code&gt; ( &lt;code&gt;man [&lt;/code&gt; ) 참조)과 동일하므로 쉘 스크립트간에 이식 가능합니다.</target>
        </trans-unit>
        <trans-unit id="89f71a9ccda28ce7ef564f54962121174107e090" translate="yes" xml:space="preserve">
          <source>One day, one of those kids will run your script with &lt;code&gt;$DIRECTORY&lt;/code&gt; set to &lt;code&gt;&quot;My M0viez&quot;&lt;/code&gt; and your script will blow up. You don't want that. So use this.</source>
          <target state="translated">어느 날, 그 아이들 중 한 명이 &lt;code&gt;$DIRECTORY&lt;/code&gt; 를 &lt;code&gt;&quot;My M0viez&quot;&lt;/code&gt; 로 설정하고 스크립트를 실행하면 스크립트가 폭발합니다. 당신은 그것을 원하지 않습니다. 이것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d6d97a835b350f1c82be7882f32f984062d4ecba" translate="yes" xml:space="preserve">
          <source>Or for something completely useless:</source>
          <target state="translated">또는 완전히 쓸모없는 것을 위해 :</target>
        </trans-unit>
        <trans-unit id="88c9d56e5a74f7cdef89e4ed75b2aebab124a280" translate="yes" xml:space="preserve">
          <source>Or to check if a directory doesn't exist:</source>
          <target state="translated">또는 디렉토리가 존재하지 않는지 확인하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="ffd8320e26b919ccdb8d76fe053cfe0c83aced0c" translate="yes" xml:space="preserve">
          <source>Practical usage:</source>
          <target state="translated">실제 사용법 :</target>
        </trans-unit>
        <trans-unit id="37042ae73af0e62806e3959b848d75deaedd39b2" translate="yes" xml:space="preserve">
          <source>Quoting from the &lt;code&gt;ksh93&lt;/code&gt; man page:</source>
          <target state="translated">&lt;code&gt;ksh93&lt;/code&gt; 매뉴얼 페이지에서 인용 :</target>
        </trans-unit>
        <trans-unit id="a190dbfd317271efc07f048f624324161c2ee0aa" translate="yes" xml:space="preserve">
          <source>Remember to always wrap variables in double quotes when referencing them in
a bash script. Kids these days grow up with the idea that they can have spaces and lots of other funny characters in their directory names. (Spaces! Back in my days, we didn't have no fancy spaces! ;))</source>
          <target state="translated">bash 스크립트에서 변수를 참조 할 때는 항상 큰 따옴표로 묶어야합니다. 요즘 아이들은 디렉토리 이름에 공백과 다른 많은 재미있는 캐릭터를 가질 수 있다는 생각으로 자랍니다. (공백! 나의 시대에, 우리는 공상 공간이 없었습니다!;))</target>
        </trans-unit>
        <trans-unit id="99dd89c6ad7ae5fa50a90061d830f433ea145732" translate="yes" xml:space="preserve">
          <source>Same thing works with &lt;code&gt;cd&lt;/code&gt;, &lt;code&gt;mv&lt;/code&gt;, &lt;code&gt;rm&lt;/code&gt;, etc... if you try them on files that don't exist, they'll exit with an error and print a message saying it doesn't exist, and your &lt;code&gt;then&lt;/code&gt; block will be skipped. If you try them on files that do exist, the command will execute and exit with a status of &lt;code&gt;0&lt;/code&gt;, allowing your &lt;code&gt;then&lt;/code&gt; block to execute.</source>
          <target state="translated">존재하지 않는 파일에서 시도하면 &lt;code&gt;cd&lt;/code&gt; , &lt;code&gt;mv&lt;/code&gt; , &lt;code&gt;rm&lt;/code&gt; 등에서 작동합니다. 오류와 함께 종료되고 존재하지 않는다는 메시지를 인쇄하면 &lt;code&gt;then&lt;/code&gt; 블록이 건너 ped. 존재하는 파일에서 시도하면 명령이 &lt;code&gt;0&lt;/code&gt; 상태로 실행 및 종료되어 &lt;code&gt;then&lt;/code&gt; 블록을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77117ff227ef719bef67b8606ba58dd8f6506d59" translate="yes" xml:space="preserve">
          <source>Seems better than this, which requires repeating yourself:</source>
          <target state="translated">이보다 나은 것 같아서 반복해야합니다.</target>
        </trans-unit>
        <trans-unit id="78b725c3ff0067391adcd4f7f423fc5cf6d6c9a8" translate="yes" xml:space="preserve">
          <source>Shorter form:</source>
          <target state="translated">더 짧은 형태 :</target>
        </trans-unit>
        <trans-unit id="d85d4ecbed8d7b05375047512f2620d088dcf47c" translate="yes" xml:space="preserve">
          <source>So symbolic links may have to be treated differently, if subsequent commands expect directories:</source>
          <target state="translated">따라서 후속 명령에서 디렉토리가 필요한 경우 기호 링크를 다르게 처리해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d54c7b9353a65c8a7007a94eff2a6a97846f6e33" translate="yes" xml:space="preserve">
          <source>Take particular note of the double-quotes used to wrap the variables, the reason for this is explained by 8jean &lt;a href=&quot;https://stackoverflow.com/a/67458/102401&quot;&gt;in another answer&lt;/a&gt;.</source>
          <target state="translated">변수를 감싸는 데 사용되는 큰 따옴표를 특히 주목하십시오. 이에 대한 이유 &lt;a href=&quot;https://stackoverflow.com/a/67458/102401&quot;&gt;는 다른 답변에서&lt;/a&gt; 8jean 에 의해 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="6b0972881542543df05bda34f966804f87040adc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ls&lt;/code&gt; command in conjunction with &lt;code&gt;-l&lt;/code&gt; (long listing) option returns attributes information about files and directories.</source>
          <target state="translated">&lt;code&gt;-l&lt;/code&gt; (긴 목록) 옵션과 함께 &lt;code&gt;ls&lt;/code&gt; 명령은 파일 및 디렉토리에 대한 속성 정보를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="26263b6ab5b67672c58848402031941f2f826c70" translate="yes" xml:space="preserve">
          <source>The above code checks if the directory exists and if it is writable.</source>
          <target state="translated">위의 코드는 디렉토리가 존재하고 쓰기 가능한지 검사합니다.</target>
        </trans-unit>
        <trans-unit id="9444564a739b6515c85e62593d0592ac9756241d" translate="yes" xml:space="preserve">
          <source>The above scripts will check the dir is present or not</source>
          <target state="translated">위의 스크립트는 dir이 있는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="dc196b87266de4a756303b455624b49413a5ddb0" translate="yes" xml:space="preserve">
          <source>The following command in just one line will tell you if the given &lt;strong&gt;&lt;code&gt;ISDIR&lt;/code&gt;&lt;/strong&gt; variable contains a path to a directory or not:</source>
          <target state="translated">주어진 &lt;strong&gt; &lt;code&gt;ISDIR&lt;/code&gt; &lt;/strong&gt; 변수에 디렉토리 경로가 포함되어 있는지 아닌지를 한 줄로 나타내는 다음 명령이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="bfaa3c1354e38e455c54027b1c313020a774ff25" translate="yes" xml:space="preserve">
          <source>The nice thing about this approach is that I do not have to think of a good error message.</source>
          <target state="translated">이 방법의 좋은 점은 좋은 오류 메시지를 생각할 필요가 없다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2be4bb090752f296f27105f0e0a563e7270b26ad" translate="yes" xml:space="preserve">
          <source>The phrasing here is peculiar to the shell documentation, as &lt;code&gt;word&lt;/code&gt; may refer
to any reasonable string, including whitespace.</source>
          <target state="translated">&lt;code&gt;word&lt;/code&gt; 는 공백을 포함한 모든 합리적인 문자열을 나타낼 수 있으므로 여기에서 문구는 쉘 설명서에 고유합니다.</target>
        </trans-unit>
        <trans-unit id="dbc556904c8dc3d6be6a97575f40c1c8d1bcc47e" translate="yes" xml:space="preserve">
          <source>Therfore:</source>
          <target state="translated">Therfore:</target>
        </trans-unit>
        <trans-unit id="f2281eea998213be04a800c65064d230e9644281" translate="yes" xml:space="preserve">
          <source>This is not completely true... 
If you want to go to that directory, you also needs to have the execute rights on the directory. Maybe you need to have write rights as well.</source>
          <target state="translated">이것은 사실이 아닙니다 ... 해당 디렉토리로 이동하려면 디렉토리에 대한 실행 권한도 있어야합니다. 쓰기 권한이 필요할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="90a19dc5ecf99a9009a2dbb16da022cb214198d9" translate="yes" xml:space="preserve">
          <source>This solution is good because it allows the use of wildcards, a useful feature when searching for files/directories. The only problem is that, if the searched directory doesn't exist, the 'find' command will print nothing to stdout (not an elegant solution for my taste) and will have nonetheless a zero exit. Maybe someone could improve on this.</source>
          <target state="translated">이 솔루션은 파일 / 디렉토리를 검색 할 때 유용한 기능인 와일드 카드를 사용할 수 있기 때문에 좋습니다. 유일한 문제는 검색 된 디렉토리가 존재하지 않으면 'find'명령은 stdout (아무것도 내 취향에 대한 우아한 해결책은 아님)에 아무것도 인쇄하지 않고 그럼에도 불구하고 종료가 없다는 것입니다. 누군가가 이것을 개선 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96ee4c12a5566d81da281af7463d45f0e001f26a" translate="yes" xml:space="preserve">
          <source>Tl;dr: If the string passed into this function is empty, we again exit from the subshell &lt;code&gt;( ... )&lt;/code&gt; and return from the function with the given error message.</source>
          <target state="translated">Tl; dr :이 함수에 전달 된 문자열이 비어 있으면 다시 서브 쉘 &lt;code&gt;( ... )&lt;/code&gt; 종료하고 주어진 오류 메시지와 함께 함수에서 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="e0cada1eb567b078a41eed7ed73c167b0cd643b3" translate="yes" xml:space="preserve">
          <source>To check if a directory exists in a shell script you can use the following:</source>
          <target state="translated">쉘 스크립트에 디렉토리가 있는지 확인하려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="802e0a0ff420cf1ac339d116f389f9b6010f5f78" translate="yes" xml:space="preserve">
          <source>To check if a directory exists you can use simple if structure like this:</source>
          <target state="translated">디렉토리가 존재하는지 확인하려면 다음과 같은 간단한 if 구조를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a2685bb57c01af38dce3160aeb3734d48d99955" translate="yes" xml:space="preserve">
          <source>To check more than one directory use this code:</source>
          <target state="translated">둘 이상의 디렉토리를 확인하려면이 코드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="82eeb370eca1bd5552ecc5064f727f173c31e84f" translate="yes" xml:space="preserve">
          <source>Type this code on the bash promt</source>
          <target state="translated">bash promt 에이 코드를 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="c2cae6fb5a700400b2df4fae9c1d3e02062afac5" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;-e&lt;/code&gt; check will check for files and this includes directories.</source>
          <target state="translated">&lt;code&gt;-e&lt;/code&gt; check를 사용하면 파일을 검사하며 여기에는 디렉토리가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9f6d0c65af1fa450ed17190f7a6eed36470ef3e8" translate="yes" xml:space="preserve">
          <source>What command can be used to check if a directory exists or not, within a Bash shell script?</source>
          <target state="translated">Bash 쉘 스크립트 내에 디렉토리가 존재하는지 여부를 확인하는 데 사용할 수있는 명령은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="d8c2db3639ae549ace8e1c73af03174495471d04" translate="yes" xml:space="preserve">
          <source>Will produce the error message:</source>
          <target state="translated">오류 메시지가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0ae3f045c178d1d4b1fa641c1b902280e5044725" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;ls&lt;/code&gt; command; the cases when directory does not exists - an error message is shown</source>
          <target state="translated">&lt;code&gt;ls&lt;/code&gt; 명령으로; 디렉토리가 존재하지 않는 경우-오류 메시지가 표시됩니다</target>
        </trans-unit>
        <trans-unit id="90fab5420ee387ae94bf6e4438b0845086481f73" translate="yes" xml:space="preserve">
          <source>With the same syntax you can use:</source>
          <target state="translated">동일한 구문으로 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d14720b4c847ece5ac99caaf9efca53424143435" translate="yes" xml:space="preserve">
          <source>You can do it also in negative</source>
          <target state="translated">당신은 또한 부정적인 일을 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="7bc690d39c6601d38641eeeee9a206157ad110a2" translate="yes" xml:space="preserve">
          <source>You can find more information in the Bash manual on &lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#Bash-Conditional-Expressions&quot;&gt;Bash conditional expressions&lt;/a&gt; and the &lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#index-_005b&quot;&gt;&lt;code&gt;[&lt;/code&gt; builtin command&lt;/a&gt; and the &lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#index-_005b_005b&quot;&gt;&lt;code&gt;[[&lt;/code&gt; compound commmand&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#Bash-Conditional-Expressions&quot;&gt;Bash 조건식&lt;/a&gt; 과 &lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#index-_005b&quot;&gt; &lt;code&gt;[&lt;/code&gt; builtin 명령&lt;/a&gt; 및 &lt;a href=&quot;https://www.gnu.org/software/bash/manual/bash.html#index-_005b_005b&quot;&gt; &lt;code&gt;[[&lt;/code&gt; compound commmand&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5077e78ced4e1bda6bdbc6746f48e6fd0c1de9b4" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;test -d&lt;/code&gt; (see &lt;code&gt;man test&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;test -d&lt;/code&gt; 를 사용할 수 있습니다 ( &lt;code&gt;man test&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="d5ffe1efe416a48c794b4c339c9db23d31d92d85" translate="yes" xml:space="preserve">
          <source>is_dir</source>
          <target state="translated">is_dir</target>
        </trans-unit>
        <trans-unit id="7bc2760823ac0e7182b3addd6b65a069153fc276" translate="yes" xml:space="preserve">
          <source>mkdir: cannot create directory &amp;lsquo;tempdir&amp;rsquo;: File exists</source>
          <target state="translated">mkdir : 'tempdir'디렉토리를 작성할 수 없습니다 : 파일이 존재합니다</target>
        </trans-unit>
        <trans-unit id="f78dc2b020a65866379a93acbea09bede07fb206" translate="yes" xml:space="preserve">
          <source>will execute successfully only if at the moment of execution you're in a directory that has a subdirectory that you happen to check for.</source>
          <target state="translated">실행 시점에 확인하려는 하위 디렉토리가있는 디렉토리에있는 경우에만 성공적으로 실행됩니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
