<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/590747">
    <body>
      <group id="590747">
        <trans-unit id="4395cc0fae915253eae0065f85a71e65b4bc7e3b" translate="yes" xml:space="preserve">
          <source>&quot;It depends&quot; though. It's true that regexes don't and can't parse HTML with true accuracy, for all the reasons given here. If, however, the consequences of getting it wrong (such as not handling nested tags) are minor, and if regexes are super-convenient in your environment (such as when you're hacking Perl), go ahead.</source>
          <target state="translated">&quot;这要看情况&quot;,不过。诚然,由于这里给出的所有原因,regexes不能也不能真正准确地解析HTML。但是,如果错误的后果(比如不处理嵌套标签)是小事一桩,而且如果在你的环境中使用regexes是超级方便的(比如你在黑Perl的时候),那就去吧。</target>
        </trans-unit>
        <trans-unit id="af85082f69ad5769d9f74610896fd6eed4b86142" translate="yes" xml:space="preserve">
          <source>(From &lt;a href=&quot;http://htmlparsing.com/regexes&quot;&gt;http://htmlparsing.com/regexes&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（来自&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://htmlparsing.com/regexes&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://htmlparsing.com/regexes&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="27800ad87d413ad5716af658035696ad3e026ff9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://regex101.com/r/wRD0zq/1&quot;&gt;Check it out&lt;/a&gt;. It works better with the &quot;gisx&quot; flags, as in the demo.</source>
          <target state="translated">&lt;a href=&quot;https://regex101.com/r/wRD0zq/1&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;检查一下&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如演示中所示，它与&amp;ldquo; gisx&amp;rdquo;标志一起使用效果更好。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cb1c6dc3d2c56fa35a77ee4d259290f55a9ebc8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;_q&lt;/code&gt; and &lt;code&gt;_v&lt;/code&gt; - Ignore these; they're used internally for backreferences.</source>
          <target state="translated">&lt;code&gt;_q&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;_v&lt;/code&gt; -&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;忽略这些；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它们在内部用于反向引用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5af38e258f7e226c7d709ceda6a3abb0eee58431" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;attribute&lt;/code&gt; - Repeated, each attribute.</source>
          <target state="translated">&lt;code&gt;attribute&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -每个属性重复一次。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abf905e3408bbd38122e76e96951949af09821a3" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;attribute_name&lt;/code&gt; - Repeated, each attribute name.</source>
          <target state="translated">&lt;code&gt;attribute_name&lt;/code&gt; -&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重复的每个属性名称。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="77ef2ebf2740b3003af96487fc0dd8a7ba118232" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;attribute_value&lt;/code&gt; - Repeated, each attribute value. This includes the quotes if it was quoted.</source>
          <target state="translated">&lt;code&gt;attribute_value&lt;/code&gt; -&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重复的每个属性值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果包含引号，则包括引号。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2fd5528febd1427b52442fa61d692056bc0fe6c9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;attributes&lt;/code&gt; - All attributes inside the tag. Use this to get all attributes if you don't get repeated groups.</source>
          <target state="translated">&lt;code&gt;attributes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -标签内的所有属性。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您没有重复的组，请使用它来获取所有属性。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="460a27e0006886fdf800c3d08dbadf7a30dc0478" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;cdata&lt;/code&gt; - If it's a &lt;code&gt;&amp;lt;![CDATA[...]]&amp;gt;&lt;/code&gt;, the CDATA contents.</source>
          <target state="translated">&lt;code&gt;cdata&lt;/code&gt; -&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果它是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;![CDATA[...]]&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，则CDATA内容。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ace024213200d16b6883f14135b9d388d90a8143" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;close_tag&lt;/code&gt; - If it's a close tag (&lt;code&gt;&amp;lt;/div&amp;gt;&lt;/code&gt;), the tag name.</source>
          <target state="translated">&lt;code&gt;close_tag&lt;/code&gt; -&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果是关闭标签（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;/div&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;标签名称。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="11ca2311a1bdc145783958801123c62b8a3475cf" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;comment&lt;/code&gt; - If it's a comment, the comment contents.</source>
          <target state="translated">&lt;code&gt;comment&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -如果是评论，则评论内容。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="611629c2a2c1d3167ab21223962bf67e773b600a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;content&lt;/code&gt; - All of the content up to the next tag. You could leave this out.</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -直到下一个标签的所有内容。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以忽略这个。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d0226a1899dd0ebdb7c7440b6a55858836acdda5" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;is_self_closing&lt;/code&gt; - This is &lt;code&gt;/&lt;/code&gt; if it's a self-closing tag, otherwise nothing.</source>
          <target state="translated">&lt;code&gt;is_self_closing&lt;/code&gt; -&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果是自闭标签，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;/&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，否则为空。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8373f55c65f57b758dedaca89483f064574d33dc" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;markup&lt;/code&gt; - The entire tag with everything in it.</source>
          <target state="translated">&lt;code&gt;markup&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -包含所有内容的整个标签。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c5ae4655932bfcb85cf29fcd2f5442305f0d6ad" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;tag&lt;/code&gt; - If it's an open tag (&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;), the tag name.</source>
          <target state="translated">&lt;code&gt;tag&lt;/code&gt; -&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果是开放标签（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），则为标签名称。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4eeb907c5063d5d1ac6ada80e5dec10b1fd63993" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;(this isn't really valid HTML, but I'm a nice guy)&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（这不是真正有效的HTML，但我是个好人）&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a05a4642a54a51dbdac5578a723590a5ccb96c81" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Performance note - It's quick. This is the fastest tag parser I've seen&lt;br/&gt;
(there may be faster, who knows).&lt;br/&gt;
I have several specific versions.  It is also excellent as scraper&lt;br/&gt;
(if you're the hands-on type).&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;效果说明-快速。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是我见过的最快的标签解析器&lt;/font&gt;&lt;/font&gt;&lt;br/&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; （可能更快，谁知道）。&lt;/font&gt;&lt;/font&gt;&lt;br/&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 我有几个特定版本。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它也非常适合用作刮板&lt;/font&gt;&lt;/font&gt;&lt;br/&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; （如果您是动手型的话）。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4be0ecb33c003878e40261acd51179a8ef956166" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Web page note - I've never seen a web page (or xhtml/xml) that this&lt;br/&gt;
had trouble with. If you find one, let me know.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;网页说明-我从未见过&lt;/font&gt;&lt;/font&gt;&lt;br/&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 遇到&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;问题的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;网页（或xhtml / xml）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果找到一个，请告诉我。&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ffd8d1ef48a0a114b118e0659e400a83d7ec6e5b" translate="yes" xml:space="preserve">
          <source>Actually, HTML parsing with regex is perfectly possible in PHP. You just have to parse the whole string backwards using &lt;code&gt;strrpos&lt;/code&gt; to find &lt;code&gt;&amp;lt;&lt;/code&gt; and repeat the regex from there using ungreedy specifiers each time to get over nested tags. Not fancy and terribly slow on large things, but I used it for my own personal template editor for my website. I wasn't actually parsing HTML, but a few custom tags I made for querying database entries to display tables of data (my &lt;code&gt;&amp;lt;#if()&amp;gt;&lt;/code&gt; tag could highlight special entries this way). I wasn't prepared to go for an XML parser on just a couple of self created tags (with very non-XML data within them) here and there.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上，用regex进行HTML解析在PHP中是完全可行的。您只需要使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;strrpos&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;向后解析整个字符串&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来找到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后每次使用不贪婪的说明符从那里重复正则表达式即可克服嵌套标记。在大型事物上并不花哨并且非常慢，但是我将其用于我自己的网站个人模板编辑器。我实际上不是解析HTML，但是我做了一些自定义标签来查询数据库条目以显示数据表（我的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;#if()&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;标签可以用这种方式突出显示特殊条目）。我不准备只在几个自创建的标记（其中包含非常非XML数据）上使用XML解析器。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f9b908fef12f22b2368da1032c9fa1f1faa12c2a" translate="yes" xml:space="preserve">
          <source>As far as just parsing the tags, it can be done with
regex and used to strip tags from a document.</source>
          <target state="translated">至于只是解析标签,可以用regex来完成,并且用来从文档中剥离标签。</target>
        </trans-unit>
        <trans-unit id="4eed14802878eb14f3ffcdad3442285458d4e215" translate="yes" xml:space="preserve">
          <source>As far as parsing goes, regular expressions can be useful in the &quot;lexical analysis&quot; (lexer) stage, where the input is broken down into tokens. It's less useful in the actual &quot;build a parse tree&quot; stage.</source>
          <target state="translated">就解析而言,正则表达式在 &quot;词法分析&quot;(lexer)阶段可以派上用场,将输入分解成令牌。但在实际的 &quot;建立解析树 &quot;阶段就没有那么有用了。</target>
        </trans-unit>
        <trans-unit id="986811b4873e92aa52d2cb350591ecf649e9b81c" translate="yes" xml:space="preserve">
          <source>As new HTML or xml or any other develop new constructs, just add it as
one of the alternations.</source>
          <target state="translated">作为新的HTML或xml或任何其他开发新的构造,只需将其添加为交替使用。</target>
        </trans-unit>
        <trans-unit id="2cb616430e7f124af50af96cae6e391bfa655b52" translate="yes" xml:space="preserve">
          <source>Because there are many ways to &quot;screw up&quot; HTML that browsers will treat in a rather liberal way but it would take quite some effort to reproduce the browser's liberal behaviour to cover all cases with regular expressions, so your regex will inevitably fail on some special cases, and that would possibly introduce serious security gaps in your system.</source>
          <target state="translated">因为有很多方法可以 &quot;搞砸 &quot;HTML,浏览器会以相当宽松的方式来对待,但要重现浏览器的宽松行为来覆盖所有情况下的正则表达式,需要花费相当大的精力,所以你的regex在一些特殊情况下难免会失败,这可能会给你的系统带来严重的安全漏洞。</target>
        </trans-unit>
        <trans-unit id="7d92b9aebfbcec09915d99df147389b86e3db52c" translate="yes" xml:space="preserve">
          <source>CDATA - &lt;code&gt;&amp;lt;![CDATA[ ... ]]&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CDATA- &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;![CDATA[ ... ]]&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a3932c2e445d48802345074cd339f6a0c1bfcab" translate="yes" xml:space="preserve">
          <source>Close Tag - &lt;code&gt;&amp;lt;/div&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关闭标签- &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;/div&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc17f6736d621be60a557975bb3c31e1a0d50519" translate="yes" xml:space="preserve">
          <source>Comment - &lt;code&gt;&amp;lt;!-- ... --&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注释- &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;!-- ... --&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8773408d41d04ee9f99efe839bcb81a88d852ca2" translate="yes" xml:space="preserve">
          <source>Complete raw regex</source>
          <target state="translated">完整的原始汇算表</target>
        </trans-unit>
        <trans-unit id="d055caf259e1c4f2af0654bdb9ae984892cb9241" translate="yes" xml:space="preserve">
          <source>Demo here: &lt;a href=&quot;https://regex101.com/r/mH8jSu/11&quot;&gt;https://regex101.com/r/mH8jSu/11&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;演示在这里：&lt;/font&gt;&lt;a href=&quot;https://regex101.com/r/mH8jSu/11&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//regex101.com/r/mH8jSu/11&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a6de1a502bc05f5e24dc0a18448418fb4fbb4546" translate="yes" xml:space="preserve">
          <source>Entire HTML parsing is not possible with regular expressions, since it depends on matching the opening and the closing tag which is not possible with regexps.</source>
          <target state="translated">使用正则表达式无法对整个HTML进行解析,因为它依赖于匹配开局和结尾标签,而这在regexps中是不可能的。</target>
        </trans-unit>
        <trans-unit id="d6af410eb4941f72c23b14a17594d77df639cda4" translate="yes" xml:space="preserve">
          <source>Escaped Quotes - &lt;code&gt;&amp;lt;a title='John\'s Story'&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转义报价- &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;a title='John\'s Story'&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc143b21737108470de082a1f68f39117cb4dec2" translate="yes" xml:space="preserve">
          <source>For an HTML parser, I'd expect it to only accept well-formed HTML and that requires capabilities outside what a regular expression can do (they cannot &quot;count&quot; and make sure that a given number of opening elements are balanced by the same number of closing elements).</source>
          <target state="translated">对于一个HTML解析器来说,我希望它只接受格式良好的HTML,这需要正则表达式以外的能力(它们不能 &quot;计数 &quot;并确保给定数量的起始元素被相同数量的闭合元素所平衡)。</target>
        </trans-unit>
        <trans-unit id="805586c8512e4781fc08c656680be7cb2ec9d28a" translate="yes" xml:space="preserve">
          <source>For example, it is an error for &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags to be nested; if the web page is working correctly, then using a regular expression to grab a &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; would be completely reasonable.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;嵌套&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;标记&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是错误的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果网页正常工作，则使用正则表达式获取&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将是完全合理的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ea78541c96f9ecce68b8c671908b07b15dfafb4" translate="yes" xml:space="preserve">
          <source>For quick&amp;acute;n&amp;acute;dirty regexp will do fine.  But the fundamental thing to know is that it is &lt;em&gt;impossible&lt;/em&gt; to construct a regexp that will &lt;em&gt;correctly&lt;/em&gt; parse HTML.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于quick&amp;acute;n&amp;acute;dirty正则表达式将很好。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是要知道的基本知识是，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不可能&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;构造一个可以&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正确&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解析HTML &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的正则表达式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b4a327d01e5b16c1d6fb9247ad706f438a94461" translate="yes" xml:space="preserve">
          <source>Formatted look</source>
          <target state="translated">格式化的外观</target>
        </trans-unit>
        <trans-unit id="771cee857d4f9831b9622222e8e07ee4504e3ac1" translate="yes" xml:space="preserve">
          <source>HTML/XML is divided into markup and content. 
Regex is only useful doing a lexical tag parse.
I guess you could deduce the content.
It would be a good choice for a SAX parser.
Tags and content could be delivered to a user
defined function where nesting/closure of elements
can be kept track of.</source>
          <target state="translated">HTMLXML分为标记和内容。Regex只有在做词法标签解析时才有用。我想你可以推导出内容。对于SAX解析器来说,这将是一个不错的选择。标签和内容可以交付给一个用户定义的函数,在这个函数中,可以跟踪元素的嵌套关闭。</target>
        </trans-unit>
        <trans-unit id="b6c4d9f3ede1060a1b3d94b5675ef28675741ed7" translate="yes" xml:space="preserve">
          <source>I believe that the answer lies in computation theory. For a language to be parsed using regex it must be by definition &quot;regular&quot; (&lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_language&quot;&gt;link&lt;/a&gt;). HTML is not a regular language as it does not meet a number of criteria for a regular language (much to do with the many levels of nesting inherent in html code). If you are interested in the theory of computation I would recommend &lt;a href=&quot;http://books.google.co.uk/books?id=eRYFAAAACAAJ&amp;amp;dq=theory+of+computation&amp;amp;ei=WqimSamaGYvCMvCFrIQO&quot;&gt;this&lt;/a&gt; book.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我相信答案就在于计算理论。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于要使用正则表达式进行解析的语言，其定义必须为&amp;ldquo;常规&amp;rdquo;（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_language&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;链接&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;HTML不是常规语言，因为它不满足常规语言的许多标准（与html代码固有的许多嵌套级别有关）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您对计算理论感兴趣，我会推荐&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://books.google.co.uk/books?id=eRYFAAAACAAJ&amp;amp;dq=theory+of+computation&amp;amp;ei=WqimSamaGYvCMvCFrIQO&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;本书。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4a928a77722b241bbded7ef2c3a06defb882a827" translate="yes" xml:space="preserve">
          <source>I guess I'm saying it's a tradeoff. Sometimes implementing or using a correct parser--as easy as that may be--might not be worth the trouble if accuracy isn't critical.</source>
          <target state="translated">我想我是说这是一种权衡。有时实现或使用一个正确的解析器----尽管这可能很容易---但如果精度不重要的话,可能就不值得麻烦了。</target>
        </trans-unit>
        <trans-unit id="d12e476321794c8e7a9a27947227c6300c9f92e0" translate="yes" xml:space="preserve">
          <source>I recently did some web scraping using only Selenium and regular expressions.  I got away with it because the data I wanted was put in a &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;, and put in a simple table format (so I could even count on &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; to be non-nested--which is actually highly unusual).  In some degree, regular expressions were even almost necessary, because some of the structure I needed to access was delimited by comments.  (Beautiful Soup can give you comments, but it would have been difficult to grab &lt;code&gt;&amp;lt;!-- BEGIN --&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;!-- END --&amp;gt;&lt;/code&gt; blocks using Beautiful Soup.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我最近仅使用Selenium和正则表达式进行了一些Web抓取。我之所以放弃，是因为我想要的数据以&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;格式放置，并以简单的表格格式放置（因此我什至可以指望&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;table&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;tr&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;td&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;成为非嵌套-这实际上是非常不寻常的）。在某种程度上，正则表达式甚至几乎是必需的，因为我需要访问的某些结构由注释分隔。 （&amp;ldquo;美丽的汤&amp;rdquo;可以给您评论，但是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&amp;ldquo;美丽的汤&amp;rdquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;很难抓住&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;!-- BEGIN --&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;!-- END --&amp;gt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;块。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b9ec2e21e1f1340402bed281e8475e9516fa540" translate="yes" xml:space="preserve">
          <source>I tried my hand at a regex for this too. It's mostly useful for finding chunks of content paired with the next HTML tag, and it doesn't look for &lt;strong&gt;&lt;em&gt;matching&lt;/em&gt;&lt;/strong&gt; close tags, but it will pick up close tags. Roll a stack in your own language to check those.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我也为此尝试了一个正则表达式。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这对于查找与下一个HTML标记配对的内容块最有用，并且它不会寻找&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;匹配的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关闭标记，但是会拾取关闭标记。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用您自己的语言滚动堆栈以检查这些内容。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="41123a269aea2954cdb8834f744ec25a89fde6c8" translate="yes" xml:space="preserve">
          <source>I'd use this in the context of writing a library that would allow me to perform HTML element retrieval akin to that of JavaScript's &lt;code&gt;[x].getElementsByTagName()&lt;/code&gt;, for example.  I'd just splice up the functionality I wrote in the DEFINE section of the regex and use it for stepping inside of a tree of elements, one at time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我将在编写库的上下文中使用此库，该库将使我能够执行类似于JavaScript的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[x].getElementsByTagName()&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; HTML元素检索&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我只是拼接了我在正则表达式的DEFINE部分中编写的功能，并将其用于单步进入元素树中。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c7c8dc5c9060790d4fe3b8d116db9bb1dc613d94" translate="yes" xml:space="preserve">
          <source>If I had to worry about nested tables, however, my approach simply would not have worked!  I would have had to fall back on Beautiful Soup.  Even then, however, sometimes you can use a regular expression to grab the chunk you need, and then drill down from there.</source>
          <target state="translated">然而,如果我必须担心嵌套表的问题,我的方法根本就行不通! 我就不得不求助于Beautiful Soup了。不过,即便如此,有时你也可以用正则表达式抓住你需要的大块,然后从那里往下钻。</target>
        </trans-unit>
        <trans-unit id="4f567391c297dab2d68e4b4a12e0168f2cdcf300" translate="yes" xml:space="preserve">
          <source>If used passively, there is never a problem
But, if you &lt;em&gt;force&lt;/em&gt; something to match by interspersing it with
a wanted attribute/value pair, and don't provide adequate protection
from backtracking, it's an out of control nightmare.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果以被动方式使用，则永远不会有问题。但是，如果您&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过将某些内容与所需的属性/值对相互穿插来&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;强迫&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;某项内容匹配，并且没有提供足够的防止回溯的保护措施，那将是一场失控的噩梦。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4cc43662eb969957208dfee823f1135d7e384e6a" translate="yes" xml:space="preserve">
          <source>If you just want to find all URLs that look like &lt;code&gt;http://.../&lt;/code&gt; you're fine with regexps. But if you want to find all URLs that are in a a-Element that has the class 'mylink' you probably better use a appropriate parser.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您只想查找所有看起来像&lt;/font&gt;&lt;/font&gt; &lt;code&gt;http://.../&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; URL，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以使用正则&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表达式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，如果要查找具有&amp;ldquo; mylink&amp;rdquo;类的a-Element中的所有URL，则最好使用适当的解析器。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="10c862c323b02ffd4219cfe4a2001bff7b5bd5f3" translate="yes" xml:space="preserve">
          <source>If your regex engine doesn't support repeated named captures, there's a section called out that you can use to get each attribute. Just run that regex on the &lt;code&gt;attributes&lt;/code&gt; group to get each &lt;code&gt;attribute&lt;/code&gt;, &lt;code&gt;attribute_name&lt;/code&gt; and &lt;code&gt;attribute_value&lt;/code&gt; out of it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您的正则表达式引擎不支持重复的命名捕获，则可以调用一个部分来获取每个属性。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只需在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;attributes&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上运行该正则表达式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即可获取其中的每个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;attribute&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;attribute_name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;attribute_value&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="953de26c516b1cb0e64a7fa054794c93260b8994" translate="yes" xml:space="preserve">
          <source>If your regex flavor supports repeated named captures then you're golden, but Python &lt;code&gt;re&lt;/code&gt; doesn't (I know regex does, but I need to use vanilla Python). Here's what you get:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您的regex风格支持重复的命名捕获，那么您会很成功，但是Python &lt;/font&gt;&lt;/font&gt; &lt;code&gt;re&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不会（我知道regex可以，但是我需要使用香草Python）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是您得到的：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a73238d323a90cf237a3c986e41589880059661b" translate="yes" xml:space="preserve">
          <source>In that case, misparsing some of the documents isn't going to be a big deal. Nobody but you will see the mistakes, and if you're very lucky there will be few enough that you can follow up individually.</source>
          <target state="translated">在这种情况下,把一些文件写错了也不是什么大问题。除了你,没有人会看到这些错误,如果你很幸运的话,会有少数的错误,足以让你单独跟进。</target>
        </trans-unit>
        <trans-unit id="2f036fc60d3bc85fc4d19b8962c8916eb441f7a5" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;$url&lt;/code&gt; will indeed contain
&lt;code&gt;http://example.com/whatever.jpg&lt;/code&gt;.  But what happens when
you start getting HTML like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;$url&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上将包含 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;http://example.com/whatever.jpg&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，当您开始这样获取HTML时会发生什么：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0bcc661e821002abff3e02aa0f156b2626e74d77" translate="yes" xml:space="preserve">
          <source>It is also, the single most &lt;em&gt;root of all evil&lt;/em&gt; to regular expressions.
The way it's used will trigger a bump-along to satisfy it's greedy, must-match
quantified container.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它也是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正则表达式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;邪恶的根源&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它的使用方式将触发颠簸，以满足其贪婪的，必须匹配的量化容器。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a862faf5daeb0b771f20fad26a1bfdbf39ec4609" translate="yes" xml:space="preserve">
          <source>It looks so simple, and it might be simple for a single, unchanging file, but for anything that you're going to be doing on arbitrary HTML data, regexes are just a recipe for future heartache.</source>
          <target state="translated">它看起来很简单,对于一个单一的、不变的文件来说可能很简单,但对于任何你要在任意的HTML数据上做的事情,regexes都会让你以后的心痛。</target>
        </trans-unit>
        <trans-unit id="0460d7137809e80d4fcda9dba3e135cde4d467ed" translate="yes" xml:space="preserve">
          <source>It seems like every question on stackoverflow where the asker is using regex to grab some information from HTML will inevitably have an &quot;answer&quot; that says not to use regex to parse HTML.</source>
          <target state="translated">似乎每一个在 stackoverflow 上的问题,如果提问者使用 regex 来抓取 HTML 中的一些信息,都难免会有一个 &quot;答案&quot;,说不要使用 regex 来解析 HTML。</target>
        </trans-unit>
        <trans-unit id="5f17419b650a933a340ed879260fdd0460aad705" translate="yes" xml:space="preserve">
          <source>It's also pretty good about not triggering on malformed tags, like when you forget a &lt;code&gt;&amp;lt;&lt;/code&gt; or &lt;code&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关于不触发格式错误的标记也很不错，例如当您忘记&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; 时&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e76a2620404a008b7607079dab16a5996e4cc6cb" translate="yes" xml:space="preserve">
          <source>Just be careful with your assumptions. I can think of a few ways the regexp shortcut can backfire if you're trying to parse something that will be shown in public, for example.</source>
          <target state="translated">只是要小心你的假设。我可以想到几种方法,如果你试图解析一些会在公共场合显示的东西,比如说,regexp快捷方式可能会起反作用。</target>
        </trans-unit>
        <trans-unit id="0ee036c1f21cc99a4f592fa76b90dff8d34867f1" translate="yes" xml:space="preserve">
          <source>Keep in mind that while HTML itself isn't regular, portions of a page you are looking at &lt;em&gt;might&lt;/em&gt; be regular.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请记住，尽管HTML本身不是常规的，但是您正在查看的页面部分&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是常规的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ad1182dabcb25618b6f52fdf17404e7316ef7e7" translate="yes" xml:space="preserve">
          <source>Moreover, is there just something fundamental that I don't understand about regex that makes them a bad choice for parsing in general?</source>
          <target state="translated">此外,是不是有什么根本性的东西我不明白,使它们在一般情况下成为解析的坏选择?</target>
        </trans-unit>
        <trans-unit id="7b57db2c767fc080d0fe413b92c1da4a8329d1da" translate="yes" xml:space="preserve">
          <source>Moving on, we also see that you just can't search for a specific tag
without parsing &lt;em&gt;ALL&lt;/em&gt; tags.
I mean you could, but it would have to use a combination of
verbs like (*SKIP)(*FAIL) but still all tags have to be parsed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;继续，我们还看到您只是在不解析&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;标签的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;情况下无法搜索特定&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;标签。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我的意思是可以，但是它必须使用动词的组合，例如（* SKIP）（* FAIL），但仍然必须解析所有标签。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6e2de52d7c4e1998f605bf1da981560205660795" translate="yes" xml:space="preserve">
          <source>Named Captures For Interesting Bits</source>
          <target state="translated">命名为 &quot;有趣的片段 &quot;的攻略</target>
        </trans-unit>
        <trans-unit id="6468d1a0463a6c63ac5aab38d6bbfbf49311b8b5" translate="yes" xml:space="preserve">
          <source>Open Tag - &lt;code&gt;&amp;lt;div ...&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;打开标签- &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;div ...&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db602c6706b5bfc281b0eb97b1273314aee7a1b0" translate="yes" xml:space="preserve">
          <source>Optional Attribute Values - &lt;code&gt;&amp;lt;input checked&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可选属性值- &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;input checked&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d97d9ff49465ad7fe5019b81b0366d2d25125b1f" translate="yes" xml:space="preserve">
          <source>Over years of testing, I've found the secret to the
way browsers parse tags, both well and ill formed.</source>
          <target state="translated">在多年的测试中,我发现了浏览器解析标签的方式的秘密,不管是好的还是不好的,都是如此。</target>
        </trans-unit>
        <trans-unit id="dfa6eff151200d8d6545cb4b94eb5f156c6d29d6" translate="yes" xml:space="preserve">
          <source>Regarding the suitability of regexes for parsing in general: they aren't suitable. Have you ever seen the sorts of regexes you would need to parse most languages?</source>
          <target state="translated">关于一般情况下的regexes是否适合解析的问题:它们不适合。你见过解析大多数语言所需要的各种regexes吗?</target>
        </trans-unit>
        <trans-unit id="24a0b72ea201351d180c46f25e197e873f7d461b" translate="yes" xml:space="preserve">
          <source>Regular expressions are not powerful enough for such a language like HTML. Sure, there are some examples where you can use regular expressions. But in general it is not appropriate for parsing.</source>
          <target state="translated">对于HTML这样的语言来说,正则表达式还不够强大。当然,有一些例子可以使用正则表达式。但一般来说,它不适合用于解析。</target>
        </trans-unit>
        <trans-unit id="636d175efd6f428f69463df2da6c8fe049bb3971" translate="yes" xml:space="preserve">
          <source>Regular expressions can only match &lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_grammar&quot;&gt;regular languages&lt;/a&gt; but HTML is a &lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;context-free language&lt;/a&gt; and &lt;em&gt;not&lt;/em&gt; a regular language (As @StefanPochmann pointed out, regular languages are also context-free, so context-free doesn't necessarily mean not regular). The only thing you can do with regexps on HTML is heuristics but that will not work on every condition. It should be possible to present a HTML file that will be matched wrongly by any regular expression.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正则表达式只能匹配&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Regular_grammar&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正则语言，&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是HTML是无&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Context-free_grammar&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上下文语言，&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不是&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正则语言（如@StefanPochmann所指出的，正则语言也是无上下文的，因此无上下文不一定意味着不正则）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以对HTML的正则表达式执行的唯一操作是启发式，但这并不适用于所有条件。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该有可能呈现一个HTML文件，该文件将被任何正则表达式错误地匹配。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="927b0062082eb10a452df4fc67911db996f665b2" translate="yes" xml:space="preserve">
          <source>Regular expressions were not designed to handle a nested tag structure, and it is at best complicated (at worst, impossible) to handle all the possible edge cases you get with real HTML.</source>
          <target state="translated">正则表达式不是为了处理嵌套的标签结构而设计的,它最多是复杂(最坏的情况下,不可能)处理真正的HTML可能出现的所有边缘情况。</target>
        </trans-unit>
        <trans-unit id="508b1efb96364e901464c76ce38c62f0abff37e6" translate="yes" xml:space="preserve">
          <source>Say you've got a file of HTML where you're trying to extract URLs from
&amp;lt;img&amp;gt; tags.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设您有一个HTML文件，您正尝试从&amp;lt;img&amp;gt;标签提取URL。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e7e40b11994f4e086dff8723b500eec52892423b" translate="yes" xml:space="preserve">
          <source>Self-Closing Tag - &lt;code&gt;&amp;lt;div .../&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;自闭合标签- &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;div .../&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3761f4e690af3e670098893c902afc349b3fba45" translate="yes" xml:space="preserve">
          <source>Single / Double Quotes - &lt;code&gt;&amp;lt;div style=&quot;...&quot;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;单引号/双引号- &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;div style=&quot;...&quot;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="906ad5ec89fbc3ba7f9ddc51c7cb1ca99de49b99" translate="yes" xml:space="preserve">
          <source>So you write a regex like this in Perl:</source>
          <target state="translated">所以你用Perl写一个像这样的regex。</target>
        </trans-unit>
        <trans-unit id="61c8d502682262f0a5766160aa8f7dbc7ee2111c" translate="yes" xml:space="preserve">
          <source>So, even though this question is considerably dead, it still shows up in a Google search. I read it and thought &quot;challenge accepted&quot; and finished fixing my simple code without having to replace everything. Decided to offer a different opinion to anyone searching for a similar reason. Also the last answer was posted 4 hours ago so this is still a hot topic.</source>
          <target state="translated">所以,虽然这个问题已经相当的死了,但在Google搜索中还是会显示出来。我看了一下,觉得 &quot;接受挑战&quot;,完成了我的简单代码的修复,不需要更换所有的东西。决定提供一个不同的意见,给所有搜索类似原因的人提供不同的意见。另外最后一个答案是在4个小时前发布的,所以这还是个热门话题。</target>
        </trans-unit>
        <trans-unit id="567a68686cb783a7d8b628180c0b05993979443b" translate="yes" xml:space="preserve">
          <source>So, to passively parse all tags, a regex is needed like the one below.
This particular one matches &lt;em&gt;invisible content&lt;/em&gt; as well.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，要被动地解析所有标签，需要像下面这样的正则表达式。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个特定的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内容&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;匹配&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不可见的内容&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="82ffd16a33e0b1ca997c28cc674e2da41660757d" translate="yes" xml:space="preserve">
          <source>So, will this be the final 100% answer for validating HTML?  No.  But it's a start and with a little more work, it can be done.  However, trying to do it inside of one regex execution is not practical, nor efficient.</source>
          <target state="translated">那么,这将是验证HTML的最终100%的答案吗?不,但这只是一个开始,只要再多做一点工作,就可以做到。然而,试图在一个regex的执行过程中完成它并不实用,也不高效。</target>
        </trans-unit>
        <trans-unit id="76703768894d77a69bdb2cb028259a2c1f199d02" translate="yes" xml:space="preserve">
          <source>Spaces Around Equals Signs - &lt;code&gt;&amp;lt;a href = '...'&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;等号周围的空格- &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;a href = '...'&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d956892852d89421b1011d518c075b3d6cc210fb" translate="yes" xml:space="preserve">
          <source>Suppose you're, oh, maybe parsing web pages that link to your site--perhaps you found them with a Google link search--and you want a quick way to get a general idea of the context surround your link. You're trying to run a little report that might alert you to link spam, something like that.</source>
          <target state="translated">假设你正在解析链接到你网站的网页----也许你通过Google链接搜索找到了它们----你想通过一个快速的方法来了解你的链接的上下文。你试图运行一个小报告,可能会提醒你链接垃圾链接,类似的东西。</target>
        </trans-unit>
        <trans-unit id="23da7f4c7c18eb2ebd589bfe31c1218cc0fba8fa" translate="yes" xml:space="preserve">
          <source>Sure, there are problems that can be solved easily with regular expressions. But the emphasis lies on &lt;strong&gt;easily&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，有些问题可以使用正则表达式轻松解决。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是重点在于&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;轻松&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e6b567f228f781835db0f4b0b2c11bf319986aa0" translate="yes" xml:space="preserve">
          <source>The consensus above is that in general it is a bad idea. However if the HTML structure is known (and unlikely to change) then it is still a valid approach.</source>
          <target state="translated">上面的共识是,一般来说,这是个坏主意。但是,如果HTML结构是已知的(而且不太可能改变),那么这仍然是一个有效的方法。</target>
        </trans-unit>
        <trans-unit id="4d96306d3138d617684a4147a7d448a28bcb9851" translate="yes" xml:space="preserve">
          <source>The core of these tags use this regex</source>
          <target state="translated">这些标签的核心是使用这个Rgex的核心内容</target>
        </trans-unit>
        <trans-unit id="12c0a3b216cd7502c6d3189af310c64e02a2c8a9" translate="yes" xml:space="preserve">
          <source>The normal elements are parsed with this form:</source>
          <target state="translated">一般的元素都是用这种形式解析的。</target>
        </trans-unit>
        <trans-unit id="7a07e2cdf904bab293c8f44a993c4a9fe9dc10c1" translate="yes" xml:space="preserve">
          <source>The problem is that most users who ask a question that has to do with HTML and regex do this because they can't find an own regex that works. Then one has to think whether everything would be easier when using a DOM or SAX parser or something similar. They are optimized and constructed for the purpose of working with XML-like document structures.</source>
          <target state="translated">问题是,大多数用户在问一个与HTML和regex有关的问题时,都会问到这个问题,因为他们找不到一个自己的regex来解决。然后,人们不得不思考,如果使用DOM或SAX解析器或类似的东西,是否一切都会更容易。它们是为了处理类似XML的文档结构而优化和构造的。</target>
        </trans-unit>
        <trans-unit id="6e926028424ea6949c4225f11ab427abee4f09dc" translate="yes" xml:space="preserve">
          <source>The reason is that regexps can&amp;rsquo;t handle arbitarly nested expressions.  See &lt;a href=&quot;https://stackoverflow.com/questions/133601/can-regular-expressions-be-used-to-match-nested-patterns&quot;&gt;Can regular expressions be used to match nested patterns?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原因是正则表达式不能处理任意嵌套的表达式。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请参见&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/133601/can-regular-expressions-be-used-to-match-nested-patterns&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以使用正则表达式匹配嵌套模式吗？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4eeca31a261d423ec3ac405a2c49416342d83155" translate="yes" xml:space="preserve">
          <source>The reason is that tag syntax may be hidden inside other tags, etc.</source>
          <target state="translated">原因是标签的语法可能隐藏在其他标签内部等。</target>
        </trans-unit>
        <trans-unit id="ab4a31e37e413916e078017e76d634dbb0c47a2a" translate="yes" xml:space="preserve">
          <source>There are definitely cases where using a regular expression to parse some information from HTML is the correct way to go - it depends a lot on the specific situation.</source>
          <target state="translated">在有些情况下,使用正则表达式来解析HTML中的一些信息肯定是正确的方法---这在很大程度上取决于具体情况。</target>
        </trans-unit>
        <trans-unit id="794883a71e0ddf1afb3ad404866ef3ec43cd06e4" translate="yes" xml:space="preserve">
          <source>This expression retrieves attributes from HTML elements. It supports:</source>
          <target state="translated">这个表达式可以从HTML元素中检索属性。它支持。</target>
        </trans-unit>
        <trans-unit id="424e665dacfa9f73d392ac137fc1c59a0633c306" translate="yes" xml:space="preserve">
          <source>This is the general form for just plain old tags.
Notice the  &lt;code&gt;[\w:]&lt;/code&gt; representing the tag name?
In reality, the &lt;em&gt;legal&lt;/em&gt; characters representing the tag name
are an incredible list of Unicode characters.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是普通旧标签的一般形式。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;[\w:]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代表标签名称吗？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代表标签名称&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;合法&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字符是令人难以置信的Unicode字符列表。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="27f1c16cde1d4634c9abd15b03adc6f2c244fb97" translate="yes" xml:space="preserve">
          <source>This one is designed for Python (it might work for other languages, haven't tried it, it uses positive lookaheads, negative lookbehinds, and named backreferences).  Supports:</source>
          <target state="translated">这个是为Python设计的(它可能适用于其他语言,还没试过,它使用了正向查找头,负向查找尾,以及命名的反向引用)。支持。</target>
        </trans-unit>
        <trans-unit id="db2913cc31865a5c12e5006695805e8e5cd592a9" translate="yes" xml:space="preserve">
          <source>Two quick reasons:</source>
          <target state="translated">两个简单的理由:</target>
        </trans-unit>
        <trans-unit id="f340f0710f69a62c5eaa6eb685638c10004a4e31" translate="yes" xml:space="preserve">
          <source>Unquoted / Quoted Attribute Values - &lt;code&gt;&amp;lt;div style='...'&amp;gt;&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;未加引号/加引号的属性值- &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&amp;lt;div style='...'&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf979f25ebcf0dd8489293a6a06ecd67cf8578c4" translate="yes" xml:space="preserve">
          <source>Use with 'sx' options.  'g' too if you're feeling lucky:</source>
          <target state="translated">与'sx'选项一起使用。如果你觉得幸运的话,也可以用'g'。</target>
        </trans-unit>
        <trans-unit id="7de133097d25bd9a014248818c72fa8c4f3f6d1d" translate="yes" xml:space="preserve">
          <source>Using regular expressions to parse HTML: why not</source>
          <target state="translated">使用正则表达式来解析HTML:为什么不可以?</target>
        </trans-unit>
        <trans-unit id="b3ab1467cb4e1b478099a1f9b90f27ecfc70116f" translate="yes" xml:space="preserve">
          <source>Why not? I'm aware that there are quote-unquote &quot;real&quot; HTML parsers out there like &lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/&quot;&gt;Beautiful Soup&lt;/a&gt;, and I'm sure they're powerful and useful, but if you're just doing something simple, quick, or dirty, then why bother using something so complicated when a few regex statements will work just fine?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为什么不？我知道那里有没有引号的&amp;ldquo;真实&amp;rdquo; HTML解析器，例如&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.crummy.com/software/BeautifulSoup/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Beautiful Soup&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且我确定它们功能强大且有用，但是如果您只是在做简单，快速或肮脏的事情，那为什么呢？当使用一些正则表达式语句就可以了吗？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9757013b0804ad8c5bcc00418e369208ee7725ed" translate="yes" xml:space="preserve">
          <source>You'll notice this &lt;code&gt;[^&amp;gt;]?&lt;/code&gt; as one of the alternations.
This will match unbalanced quotes from ill-formed tags.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您会注意到这个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[^&amp;gt;]?&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作为交替之一。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这将匹配格式错误的标签中不平衡的报价。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="57d2b94efe0c3ae7cf849406d8094f61fc11dcf1" translate="yes" xml:space="preserve">
          <source>You, know...there's a lot of mentality of you &lt;strong&gt;CAN'T&lt;/strong&gt; do it and I think that everyone on both sides of the fence are right and wrong.  You &lt;strong&gt;CAN&lt;/strong&gt; do it, but it takes a little more processing than just running one regex against it.  Take &lt;a href=&quot;http://bit.ly/1MKKkXh&quot;&gt;this&lt;/a&gt; (I wrote this inside of an hour) as an example.  It assumes the HTML is completely valid, but depending on what language you're using to apply the aforementioned regex, you could do some fixing of the HTML to make sure that it will succeed.  For example, removing closing tags that are not supposed to be there: &lt;em&gt;&lt;code&gt;&amp;lt;/img&amp;gt;&lt;/code&gt;&lt;/em&gt; for example.  Then, add the closing single HTML forward slash to elements that are missing them, etc.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;你知道...还有很多你的心态&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CAN NOT&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;做到这一点，我认为在两侧护栏，每个人都对与错。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;你&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CAN&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;做到这一点，但它需要一点点的不只是运行反对一个正则表达式更多的处理。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://bit.ly/1MKKkXh&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（我在一小时内写完）为例。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它假定HTML完全有效，但是取决于您使用哪种语言来应用上述正则表达式，您可以对HTML进行一些修复以确保其成功。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，删除不应存在的结束标记：&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如&lt;/font&gt;&lt;/font&gt;&lt;em&gt; &lt;code&gt;&amp;lt;/img&amp;gt;&lt;/code&gt; &lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，将结尾的单个HTML正斜杠添加到缺少它们的元素中，等等。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="873967e9412cc5fa50158062ff68caa1c43ab3ab" translate="yes" xml:space="preserve">
          <source>any number of attributes,</source>
          <target state="translated">任何数量的属性。</target>
        </trans-unit>
        <trans-unit id="6744ddde92c22c1c167220426fccdfaef678e371" translate="yes" xml:space="preserve">
          <source>check only for attributes inside tags,</source>
          <target state="translated">只检查标签内的属性。</target>
        </trans-unit>
        <trans-unit id="8ed1965df231e75838d517228b4031588e174b88" translate="yes" xml:space="preserve">
          <source>escape comments, and</source>
          <target state="translated">逃避评论,以及</target>
        </trans-unit>
        <trans-unit id="c1738279e9cde423daaac3154dcca4a3a326f3fd" translate="yes" xml:space="preserve">
          <source>escaped quotes inside attributes,</source>
          <target state="translated">属性中的转引号。</target>
        </trans-unit>
        <trans-unit id="e29bf94c70de579d842c40216992453d7c91fda5" translate="yes" xml:space="preserve">
          <source>manage different quotes within an attribute value.</source>
          <target state="translated">管理一个属性值内的不同引号。</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="447bb1d2f2dfd2da2f95b672536d879635f5a4fa" translate="yes" xml:space="preserve">
          <source>or you start getting false positives from</source>
          <target state="translated">或者你开始得到假阳性的</target>
        </trans-unit>
        <trans-unit id="66438fef6a53531bfd96d44917c3853150f0b1b7" translate="yes" xml:space="preserve">
          <source>single / double quotes,</source>
          <target state="translated">单双引号。</target>
        </trans-unit>
        <trans-unit id="cc0b573da7b5f047bd17290ccd3e7f707a068599" translate="yes" xml:space="preserve">
          <source>spaces around equals signs,</source>
          <target state="translated">等号周围的空格。</target>
        </trans-unit>
        <trans-unit id="ba713ac9420a250a30aca6e2d8d055ad04109320" translate="yes" xml:space="preserve">
          <source>unquoted / quoted attributes,</source>
          <target state="translated">未引用引用的属性。</target>
        </trans-unit>
        <trans-unit id="b64567507aff7840957cce12ea0db64871c11462" translate="yes" xml:space="preserve">
          <source>writing a regex that can stand up to malicious input is hard; way harder than using a prebuilt tool</source>
          <target state="translated">编写一个能经得起恶意输入的输入符是很难的,比使用预建工具难得多了。</target>
        </trans-unit>
        <trans-unit id="dc619408694343df63807b45e39db0ef41a98202" translate="yes" xml:space="preserve">
          <source>writing a regex that can work with the ridiculous markup that you will inevitably be stuck with is hard; way harder than using a prebuilt tool</source>
          <target state="translated">编写一个可以使用可笑的标记的regex是很难的,这比使用一个预构建的工具要难得多。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
