<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/59895">
    <body>
      <group id="59895">
        <trans-unit id="19a18fc4d4b50e61530b0cfb075c6c2ed407c75d" translate="yes" xml:space="preserve">
          <source>18eedfe1c99df68dc94d4a94712a71aaa8e1e9e36cacf421b9463dd2bbaa02906d0d6656</source>
          <target state="translated">18eedfe1c99df68dc94d4a94712a71aaa8e1e9e36cacf421b9463dd2bbaa02906d0d6656</target>
        </trans-unit>
        <trans-unit id="bf0eaf87a792df5e1034cb33ebb1ee9d074c5b22" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.gnu.org/s/bash/manual/bash.html#Environment&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; is worth mentioning as an alternative to &lt;code&gt;$0&lt;/code&gt;.  If you're running a script from Bash, the accepted answer can be shortened to:</source>
          <target state="translated">&lt;a href=&quot;http://www.gnu.org/s/bash/manual/bash.html#Environment&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;は &lt;code&gt;$0&lt;/code&gt; 代わりとして言及する価値があります 。 Bashからスクリプトを実行している場合、受け入れられる回答は次のように短縮できます。</target>
        </trans-unit>
        <trans-unit id="593fbc86ef10e2bd792ac1985c4267c146009c42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SCRIPT_PATH&lt;/code&gt; is given in full path, no matter how it is called.</source>
          <target state="translated">&lt;code&gt;SCRIPT_PATH&lt;/code&gt; は、どのように呼び出されても、フルパスで指定されます。</target>
        </trans-unit>
        <trans-unit id="7823bfeac488dfb6d0fa9044c88f386df6a09bf4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pwd&lt;/code&gt; can be used to find the current working directory, and &lt;code&gt;dirname&lt;/code&gt; to find the directory of a particular file (command that was run, is &lt;code&gt;$0&lt;/code&gt;, so &lt;code&gt;dirname $0&lt;/code&gt; should give you the directory of the current script).</source>
          <target state="translated">&lt;code&gt;pwd&lt;/code&gt; は現在の作業ディレクトリを見つけるために使用でき、 &lt;code&gt;dirname&lt;/code&gt; は特定のファイルのディレクトリを見つけるために使用できます（実行されたコマンドは &lt;code&gt;$0&lt;/code&gt; 、 &lt;code&gt;dirname $0&lt;/code&gt; は現在のスクリプトのディレクトリを提供します）。</target>
        </trans-unit>
        <trans-unit id="6d18c950a3d7f2476e076d0ab011a954913b53e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readlink&lt;/code&gt; will resolve the script path to an absolute path from the root of the filesystem. So, any paths containing single or double dots, tildes and/or symbolic links will be resolved to a full path.</source>
          <target state="translated">&lt;code&gt;readlink&lt;/code&gt; は、スクリプトパスをファイルシステムのルートからの絶対パスに解決します。 したがって、シングルドットまたはダブルドット、チルド、および/またはシンボリックリンクを含むパスは、フルパスに解決されます。</target>
        </trans-unit>
        <trans-unit id="0581627fdb0bac69bb25fa3efd994b4e62714351" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt;&lt;/strong&gt; - the full path to the script. The value of this will be correct even when the script is being sourced, e.g. &lt;code&gt;source &amp;lt;(echo 'echo $0')&lt;/code&gt; prints &lt;strong&gt;bash&lt;/strong&gt;, while replacing it with &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; will print the full path of the script. (Of course, this assumes you're OK taking a dependency on Bash.)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; &lt;/strong&gt; -スクリプトへの&lt;strong&gt;絶対&lt;/strong&gt;パス。 この値は、スクリプトがソースされている場合でも正しくなります。たとえば、 &lt;code&gt;source &amp;lt;(echo 'echo $0')&lt;/code&gt; は&lt;strong&gt;bashを&lt;/strong&gt;出力しますが、 &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; 置き換えると、スクリプトの完全なパスが出力されます。 （もちろん、これはあなたがBashへの依存を受け入れても大丈夫であることを前提としています。）</target>
        </trans-unit>
        <trans-unit id="07ce80449c0b3e3f277e4aeb4c0cb9d5d13239a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;readlink -f&lt;/code&gt;&lt;/strong&gt; - Recursively resolves any symlinks in the specified path. This is a GNU extension, and not available on (for example) BSD systems. If you're running a Mac, you can use Homebrew to install GNU &lt;code&gt;coreutils&lt;/code&gt; and supplant this with &lt;strong&gt;&lt;code&gt;greadlink -f&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;readlink -f&lt;/code&gt; -&lt;/strong&gt;指定されたパスのシンボリックリンクを再帰的に解決します。 これはGNU拡張であり、（たとえば）BSDシステムでは使用できません。 Macを実行している場合は、Homebrewを使用してGNU &lt;code&gt;coreutils&lt;/code&gt; をインストールし、これを&lt;strong&gt; &lt;code&gt;greadlink -f&lt;/code&gt; &lt;/strong&gt;で&lt;strong&gt;置き換える&lt;/strong&gt;ことができます。</target>
        </trans-unit>
        <trans-unit id="426fbf2c3b86a3a618cbd3f9d4a86baf50463f6f" translate="yes" xml:space="preserve">
          <source>Absolute paths or relative paths</source>
          <target state="translated">絶対パスまたは相対パス</target>
        </trans-unit>
        <trans-unit id="4d5e28e7a0e956bd9e43ce42784d9f9cdb3a1a56" translate="yes" xml:space="preserve">
          <source>Again, but using the full path to the script:</source>
          <target state="translated">繰り返しになりますが、スクリプトへのフルパスを使用しています。</target>
        </trans-unit>
        <trans-unit id="31df5ecd19815d979653fa19bbfcdd3f7579bf3e" translate="yes" xml:space="preserve">
          <source>Also a lot of people assume you're running the script from a shell so they forget when you open a new script it defaults to your home.</source>
          <target state="translated">また、多くの人はシェルからスクリプトを実行していると思い込んでいるので、新しいスクリプトを開いたときのデフォルトが自分の家になっていることを忘れてしまいます。</target>
        </trans-unit>
        <trans-unit id="5cc881cb0d3b8741b77229be62a98f44e6db9d66" translate="yes" xml:space="preserve">
          <source>Also, watch out for &lt;a href=&quot;http://bosker.wordpress.com/2012/02/12/bash-scripters-beware-of-the-cdpath/&quot;&gt;&lt;code&gt;$CDPATH&lt;/code&gt; gotchas&lt;/a&gt;, and stderr output side effects if the user has smartly overridden cd to redirect output to stderr instead (including escape sequences, such as when calling &lt;code&gt;update_terminal_cwd &amp;gt;&amp;amp;2&lt;/code&gt; on Mac). Adding &lt;code&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; at the end of your &lt;code&gt;cd&lt;/code&gt; command will take care of both possibilities.</source>
          <target state="translated">また、ユーザーが代わりにcdをオーバーライドして出力をstderrにリダイレクトする場合は、 &lt;a href=&quot;http://bosker.wordpress.com/2012/02/12/bash-scripters-beware-of-the-cdpath/&quot;&gt; &lt;code&gt;$CDPATH&lt;/code&gt; gotchas&lt;/a&gt;とstderr出力の副作用に注意してください（Macで &lt;code&gt;update_terminal_cwd &amp;gt;&amp;amp;2&lt;/code&gt; を呼び出すときなどのエスケープシーケンスを含む）。 &lt;code&gt;cd&lt;/code&gt; コマンドの最後に &lt;code&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; を追加すると、両方の可能性が処理されます。</target>
        </trans-unit>
        <trans-unit id="82ae5dde6d9ef2e46a9b902e17c82253e6391ecf" translate="yes" xml:space="preserve">
          <source>Alternatively you can try the following function in bash:</source>
          <target state="translated">あるいは、bashで以下の関数を試してみることもできます。</target>
        </trans-unit>
        <trans-unit id="e053cd2da59279d2a0608bc7768f1b1f529d9e11" translate="yes" xml:space="preserve">
          <source>Alternatively, if the bash script itself is a &lt;strong&gt;relative symlink&lt;/strong&gt; you &lt;em&gt;want&lt;/em&gt; to follow it and return the full path of the linked-to script:</source>
          <target state="translated">または、bashスクリプト自体が&lt;strong&gt;相対シンボリックリンクである&lt;/strong&gt;場合は、それに従って、リンク先のスクリプトの完全パスを返します。</target>
        </trans-unit>
        <trans-unit id="e969dea8cd5921be63a767f83c70cdc21ad8e248" translate="yes" xml:space="preserve">
          <source>Although just</source>
          <target state="translated">ただ</target>
        </trans-unit>
        <trans-unit id="08ff941f8ba378bc98bfbb6b1945c211a1cf671d" translate="yes" xml:space="preserve">
          <source>And finally using a symbolic link to execute the script:</source>
          <target state="translated">そして最後にシンボリックリンクを使ってスクリプトを実行します。</target>
        </trans-unit>
        <trans-unit id="0b7be30335048b9362beef0dcaaa21ecad8777d9" translate="yes" xml:space="preserve">
          <source>And it will print something like:</source>
          <target state="translated">みたいなのが印刷されます</target>
        </trans-unit>
        <trans-unit id="abac3354c23bb46705fe1229d339a683605c1ae3" translate="yes" xml:space="preserve">
          <source>And of course &lt;strong&gt;&lt;code&gt;dirname&lt;/code&gt;&lt;/strong&gt; gets the parent directory of the path.</source>
          <target state="translated">そしてもちろん&lt;strong&gt; &lt;code&gt;dirname&lt;/code&gt; &lt;/strong&gt;はパスの親ディレクトリを取得します。</target>
        </trans-unit>
        <trans-unit id="760013e12b493fa6407f1a2ce1efb48c91f8cef6" translate="yes" xml:space="preserve">
          <source>Bash script absolute path with OS X</source>
          <target state="translated">OS XでBashスクリプトの絶対パス</target>
        </trans-unit>
        <trans-unit id="0f28fd68e004022f6abcd795c8d0296f7d6715ac" translate="yes" xml:space="preserve">
          <source>Beware: if you &lt;code&gt;cd&lt;/code&gt; to a different directory before running this snippet, the result may be incorrect!</source>
          <target state="translated">注意：このスニペットを実行する前に別のディレクトリに &lt;code&gt;cd&lt;/code&gt; すると、結果が正しくない場合があります。</target>
        </trans-unit>
        <trans-unit id="2e27eaacc3ad357f5d5f74812ad0688f6b0fc661" translate="yes" xml:space="preserve">
          <source>But, as &lt;strong&gt;matt b&lt;/strong&gt; pointed out, the path returned is different depending on how the script is called. &lt;code&gt;pwd&lt;/code&gt; doesn't do the job because that only tells you what the current directory is, not what directory the script resides in. Additionally, if a symbolic link to a script is executed, you're going to get a (probably relative) path to where the link resides, not the actual script.</source>
          <target state="translated">しかし、 &lt;strong&gt;matt bが&lt;/strong&gt;指摘したように、返されるパスはスクリプトの呼び出し方法によって異なります。 &lt;code&gt;pwd&lt;/code&gt; は、現在のディレクトリが何であるかを通知するだけで、スクリプトが存在するディレクトリを通知しないため、ジョブを実行しません。さらに、スクリプトへのシンボリックリンクが実行されると、（おそらく相対）パスを取得します実際のスクリプトではなく、リンクが存在する場所へ。</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="e0855567fdf07ed8e9074f37448001287e233f16" translate="yes" xml:space="preserve">
          <source>File and directory soft links</source>
          <target state="translated">ファイルとディレクトリのソフトリンク</target>
        </trans-unit>
        <trans-unit id="fed5301d79c7b6f1a7c8546ea54449b1afeeeaa5" translate="yes" xml:space="preserve">
          <source>Filenames beginning with a hyphen</source>
          <target state="translated">ハイフンで始まるファイル名</target>
        </trans-unit>
        <trans-unit id="772062a56cf9b814d3042408e52f123d2ada045a" translate="yes" xml:space="preserve">
          <source>For systems having GNU coreutils &lt;code&gt;readlink&lt;/code&gt; (eg. linux):</source>
          <target state="translated">GNU coreutils &lt;code&gt;readlink&lt;/code&gt; を備えたシステム（例：linux）：</target>
        </trans-unit>
        <trans-unit id="721536b3b45c387e4bee8ead6b8c3dba91e6d655" translate="yes" xml:space="preserve">
          <source>From the comment track it seems not to work with Mac OS.
I have no idea why that is. Any suggestions?</source>
          <target state="translated">コメント欄を見る限り、Mac OSでは動作しないようです。その理由がさっぱりわかりません。何か提案はありますか?</target>
        </trans-unit>
        <trans-unit id="cc396b4d831b322640a5f760d49c543208d2cfd8" translate="yes" xml:space="preserve">
          <source>Here is a POSIX compliant one-liner:</source>
          <target state="translated">POSIX準拠のワンライナーを紹介します。</target>
        </trans-unit>
        <trans-unit id="7e6caa82bfaa440bd1e01986a8ac88b7f3d089a6" translate="yes" xml:space="preserve">
          <source>Here is an easy-to-remember script:</source>
          <target state="translated">覚えやすいスクリプトをご紹介します。</target>
        </trans-unit>
        <trans-unit id="7a6b9a74a02f93af7c524bc132c55dc467e6be32" translate="yes" xml:space="preserve">
          <source>Here is the simple, correct way:</source>
          <target state="translated">ここでは、シンプルで正しい方法をご紹介します。</target>
        </trans-unit>
        <trans-unit id="7e2786c7429ea5f9dc687d1fac3e1e4a84e09bad" translate="yes" xml:space="preserve">
          <source>Here's a script demonstrating each of these, &lt;code&gt;whatdir.sh&lt;/code&gt;:</source>
          <target state="translated">これらは &lt;code&gt;whatdir.sh&lt;/code&gt; のそれぞれを示すスクリプトです 。</target>
        </trans-unit>
        <trans-unit id="79d4dc6932c6940edea09332c0a40e4c385f867e" translate="yes" xml:space="preserve">
          <source>Here's an example of its usage:</source>
          <target state="translated">その使用例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="f67626bb87966ae92799fbed14c52f02b6a20974" translate="yes" xml:space="preserve">
          <source>Hmm, if in the path basename &amp;amp; dirname are just not going to cut it
and walking the path is hard (what if parent didn't export PATH!).
However, the shell has to have an open handle to its script, and in
bash the handle is #255.</source>
          <target state="translated">うーん、パス内にある場合、basename＆dirnameはそれをカットせず、パスを歩くのは困難です（親がPATHをエクスポートしなかった場合はどうでしょう！）。 ただし、シェルにはスクリプトへのオープンハンドルが必要であり、bashではハンドルは＃255です。</target>
        </trans-unit>
        <trans-unit id="2c514cd534e6b677e18c9f6ef72d1038f975e863" translate="yes" xml:space="preserve">
          <source>How do I get the path of the directory in which a &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; script is located, &lt;em&gt;inside&lt;/em&gt; that script?</source>
          <target state="translated">スクリプト内で、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt;スクリプトが配置されているディレクトリのパスを取得するにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="e94507b21cbe42200554606d16c3782465fae406" translate="yes" xml:space="preserve">
          <source>How to get the source directory of a Bash script from within the script itself</source>
          <target state="translated">スクリプト内からBashスクリプトのソースディレクトリを取得する方法</target>
        </trans-unit>
        <trans-unit id="15565602373c482c48a874ebd82fe09c139ba724" translate="yes" xml:space="preserve">
          <source>How to set current working directory to the directory of the script?</source>
          <target state="translated">現在の作業ディレクトリをスクリプトのディレクトリに設定するには?</target>
        </trans-unit>
        <trans-unit id="c1dc3b40f2fb5f6b76faaa750db69827966305ce" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;dirname&lt;/code&gt; gives precisely the directory portion of the filename, which more likely than not is going to be relative to the current working directory. If your script needs to change directory for some reason, then the output from &lt;code&gt;dirname&lt;/code&gt; becomes meaningless.</source>
          <target state="translated">ただし、 &lt;code&gt;dirname&lt;/code&gt; はファイル名のディレクトリ部分を正確に示します。これは、おそらく現在の作業ディレクトリに関連している可能性があります。 スクリプトが何らかの理由でディレクトリを変更する必要がある場合、 &lt;code&gt;dirname&lt;/code&gt; からの出力は無意味になります。</target>
        </trans-unit>
        <trans-unit id="fd781f58f78adcaf88471d8e16c79fde52b8abc9" translate="yes" xml:space="preserve">
          <source>I am tired of coming to this page over and over to copy paste the one-liner in the accepted answer. The problem with that is it is not easy to understand and remember.</source>
          <target state="translated">受理された回答にワンライナーをコピペするために何度も何度もこのページに来るのは疲れます。問題は、わかりにくくて覚えにくいことです。</target>
        </trans-unit>
        <trans-unit id="c65940fe653c04e6d217fd71b5bc36c973d94e09" translate="yes" xml:space="preserve">
          <source>I believe I've got this one. I'm late to the party, but I think some will appreciate it being here if they come across this thread. The comments should explain:</source>
          <target state="translated">私はこれを手に入れたと思っています。遅ればせながら、このスレッドに出くわしたら、ここにあることを喜ぶ人もいると思います。コメントで説明します。</target>
        </trans-unit>
        <trans-unit id="a5564a6ec07273d60ff4548ab635ae9209aad476" translate="yes" xml:space="preserve">
          <source>I don't think this is as easy as others have made it out to be.  &lt;code&gt;pwd&lt;/code&gt; doesn't work, as the current directory is not necessarily the directory with the script.  &lt;code&gt;$0&lt;/code&gt; doesn't always have the information either.  Consider the following three ways to invoke a script:</source>
          <target state="translated">他の人が考えているほど簡単ではありません。 現在のディレクトリは必ずしもスクリプトのあるディレクトリではないため、 &lt;code&gt;pwd&lt;/code&gt; は機能しません。 &lt;code&gt;$0&lt;/code&gt; も常に情報を持っているわけではありません。 スクリプトを呼び出すには、次の3つの方法を検討してください。</target>
        </trans-unit>
        <trans-unit id="314e2d8c80409f81525019944bae934fac7d14de" translate="yes" xml:space="preserve">
          <source>I suggest the following:</source>
          <target state="translated">私は次のように提案しています。</target>
        </trans-unit>
        <trans-unit id="2ff8ae24228298e42c1024dc75a685fff4c70183" translate="yes" xml:space="preserve">
          <source>I tried all of these and none worked. One was very close but had a tiny bug that broke it badly; they forgot to wrap the path in quotation marks.</source>
          <target state="translated">これらをすべて試してみましたが、どれもうまくいきませんでした。1つは非常に近かったのですが、小さなバグでひどく壊れてしまいました。</target>
        </trans-unit>
        <trans-unit id="fedbbd02f03e12ac9d3beeef3636203bf88f7cb9" translate="yes" xml:space="preserve">
          <source>I want to use a Bash script as a launcher for another application. I want to change the working directory to the one where the Bash script is located, so I can operate on the files in that directory, like so:</source>
          <target state="translated">Bash スクリプトを別のアプリケーションのランチャーとして使いたい。作業ディレクトリをBashスクリプトのあるディレクトリに変更して、そのディレクトリ内のファイルを操作できるようにしたい。</target>
        </trans-unit>
        <trans-unit id="ce81d457123493a7d7d88fddc69383893c3220b7" translate="yes" xml:space="preserve">
          <source>I would use something like this:</source>
          <target state="translated">私ならこんな感じのものを使います。</target>
        </trans-unit>
        <trans-unit id="2171f703ddd878f550591c0e07925f51cc2b067b" translate="yes" xml:space="preserve">
          <source>I've compared many of the answers given, and come up with some more compact solutions. These seem to handle all of the crazy edge cases that arise from your favorite combination of:</source>
          <target state="translated">私は与えられた答えの多くを比較し、いくつかのよりコンパクトな解決策を思いつきました。これらはあなたの好きな組み合わせから発生する狂ったようなエッジケースのすべてを処理しているように見えます。</target>
        </trans-unit>
        <trans-unit id="e58b329aff37f278c76fdb1e35272c1bf2d42971" translate="yes" xml:space="preserve">
          <source>If you're running from Linux, it seems that using the &lt;code&gt;proc&lt;/code&gt; handle is the best solution to locate the fully resolved source of the currently running script (in an interactive session, the link points to the respective &lt;code&gt;/dev/pts/X&lt;/code&gt;):</source>
          <target state="translated">Linuxから実行している場合、 &lt;code&gt;proc&lt;/code&gt; ハンドルを使用することが、現在実行中のスクリプトの完全に解決されたソースを見つけるための最良の解決策であるようです（インタラクティブセッションでは、リンクはそれぞれの &lt;code&gt;/dev/pts/X&lt;/code&gt; を指します）。</target>
        </trans-unit>
        <trans-unit id="f5006f4b7d8d744f73e4fc441d26d052cf92f989" translate="yes" xml:space="preserve">
          <source>In the first and third ways &lt;code&gt;$0&lt;/code&gt; doesn't have the full path information.  In the second and third, &lt;code&gt;pwd&lt;/code&gt; does not work.  The only way to get the directory in the third way would be to run through the path and find the file with the correct match.  Basically the code would have to redo what the OS does.</source>
          <target state="translated">最初と3番目の方法では、 &lt;code&gt;$0&lt;/code&gt; は完全なパス情報がありません。 2番目と3番目では、 &lt;code&gt;pwd&lt;/code&gt; は機能しません。 3番目の方法でディレクトリを取得する唯一の方法は、パスを実行して、一致するファイルを見つけることです。 基本的に、コードはOSの処理をやり直す必要があります。</target>
        </trans-unit>
        <trans-unit id="bb7c16b349eb08b9c0b10fa5d3251652f7054cc9" translate="yes" xml:space="preserve">
          <source>Invocation as &lt;code&gt;script&lt;/code&gt;, &lt;code&gt;bash script&lt;/code&gt;, &lt;code&gt;bash -c script&lt;/code&gt;, &lt;code&gt;source script&lt;/code&gt;, or &lt;code&gt;. script&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;script&lt;/code&gt; 、 &lt;code&gt;bash script&lt;/code&gt; 、 &lt;code&gt;bash -c script&lt;/code&gt; 、 &lt;code&gt;source script&lt;/code&gt; 、またはとしての呼び出し &lt;code&gt;. script&lt;/code&gt; 脚本</target>
        </trans-unit>
        <trans-unit id="a02f22ad602d2ef6e382c04099658f152ab19842" translate="yes" xml:space="preserve">
          <source>It doesn't matter where the user is or how he calls the script, this will always work.</source>
          <target state="translated">ユーザーがどこにいても、どのようにスクリプトを呼び出しても、これは常に動作します。</target>
        </trans-unit>
        <trans-unit id="38bb10b3d907511b9279efee2507d873a4fc242c" translate="yes" xml:space="preserve">
          <source>It will work as long as the last component of the path used to find the script is not a symlink (directory links are OK).  If you also want to resolve any links to the script itself, you need a multi-line solution:</source>
          <target state="translated">スクリプトを見つけるために使用されるパスの最後のコンポーネントがシンボリックリンクでない限り、動作します (ディレクトリリンクはOK)。スクリプト自体へのリンクも解決したい場合は、複数行で解決する必要があります。</target>
        </trans-unit>
        <trans-unit id="4605dc46bd09b4eaa7af587e1386b633fdeb4323" translate="yes" xml:space="preserve">
          <source>Just make sure you locate this at start of the script.</source>
          <target state="translated">スクリプトの最初にこれがあることを確認してください。</target>
        </trans-unit>
        <trans-unit id="624f152e5413ea8ae957872eddedd2d49c644430" translate="yes" xml:space="preserve">
          <source>More details can be found in &quot;&lt;a href=&quot;https://www.electrictoolbox.com/bash-script-directory/&quot;&gt;Which directory is that bash script in?&lt;/a&gt;&quot;.</source>
          <target state="translated">詳細については、「 &lt;a href=&quot;https://www.electrictoolbox.com/bash-script-directory/&quot;&gt;bashスクリプトが含まれているディレクトリは？&lt;/a&gt; 」を参照してください。</target>
        </trans-unit>
        <trans-unit id="0a0d73ad9eb09a3f63bbc70b597f635f18a702db" translate="yes" xml:space="preserve">
          <source>Note that this has to be the first statement in your script.</source>
          <target state="translated">これはスクリプトの最初のステートメントでなければならないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="3d775fc4bf5f21ab130d923a6fabfc949f661ed4" translate="yes" xml:space="preserve">
          <source>Note that you need to use &lt;code&gt;#!/bin/bash&lt;/code&gt; and not &lt;code&gt;#!/bin/sh&lt;/code&gt; since it's a Bash extension.</source>
          <target state="translated">Bashの拡張機能であるため、 &lt;code&gt;#!/bin/sh&lt;/code&gt; ではなく＃！/ bin / &lt;code&gt;#!/bin/bash&lt;/code&gt; を使用する必要があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="1ad78cc1e56befe9d3d057f04c18efb0f0ba1ffd" translate="yes" xml:space="preserve">
          <source>Note: In Bash, it's recommended to use&lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; instead of &lt;code&gt;$0&lt;/code&gt;, otherwise path can break when sourcing the file (&lt;code&gt;source&lt;/code&gt;/&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="translated">注：Bashでは、 &lt;code&gt;$0&lt;/code&gt; 代わりに$ &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; を使用することをお勧めします。そうしないと、ファイル（ &lt;code&gt;source&lt;/code&gt; / &lt;code&gt;.&lt;/code&gt; ）をソースするときにパスが壊れる可能性があります。</target>
        </trans-unit>
        <trans-unit id="498c8b437a7497a048fd6a708c55520b984927c0" translate="yes" xml:space="preserve">
          <source>Now changing directories:</source>
          <target state="translated">ディレクトリを変更するようになりました。</target>
        </trans-unit>
        <trans-unit id="2cbc4a1754fa2b1a92f79674fc1cded648d99d4c" translate="yes" xml:space="preserve">
          <source>One way to do what you are asking would be to just hardcode the data in the &lt;code&gt;/usr/share&lt;/code&gt; directory, and reference it by its full path.  Data shoudn't be in the &lt;code&gt;/usr/bin&lt;/code&gt; directory anyway, so this is probably the thing to do.</source>
          <target state="translated">求めていることを行う1つの方法は、 &lt;code&gt;/usr/share&lt;/code&gt; ディレクトリのデータをハードコードし、フルパスで参照することです。 とにかく、データは &lt;code&gt;/usr/bin&lt;/code&gt; ディレクトリにあるべきではないので、これはおそらく行うべきことです。</target>
        </trans-unit>
        <trans-unit id="39c788876858d9fdd3ed2ab494830cb7baca1db1" translate="yes" xml:space="preserve">
          <source>Related:</source>
          <target state="translated">Related:</target>
        </trans-unit>
        <trans-unit id="a9d017586904a386f0684539c8f132954aec5924" translate="yes" xml:space="preserve">
          <source>Reliable way for a Bash script to get the full path to itself</source>
          <target state="translated">Bash スクリプトが自分自身へのフルパスを取得するための信頼できる方法</target>
        </trans-unit>
        <trans-unit id="d02835a79470dbbc2e975df36f0e76821643fa48" translate="yes" xml:space="preserve">
          <source>Running this script in my home dir, using a relative path:</source>
          <target state="translated">このスクリプトを相対パスを使ってホームディレクトリで実行しています。</target>
        </trans-unit>
        <trans-unit id="0310b5ce654c85162f919b8cb40084ecbe9c6fae" translate="yes" xml:space="preserve">
          <source>Say you have a &lt;strong&gt;~/bin&lt;/strong&gt; directory, which is in your &lt;strong&gt;$PATH&lt;/strong&gt;. You have script &lt;strong&gt;A&lt;/strong&gt; inside this directory. It &lt;strong&gt;source&lt;/strong&gt;s script &lt;strong&gt;~/bin/lib/B&lt;/strong&gt;. You know where the included script is relative to the original one (the subdirectory &lt;strong&gt;lib&lt;/strong&gt;), but not where it is relative to the user's current directory.</source>
          <target state="translated">&lt;strong&gt;$ PATHに&lt;/strong&gt;ある&lt;strong&gt;〜/ bin&lt;/strong&gt;ディレクトリがあるとします。 このディレクトリ内にスクリプト&lt;strong&gt;A&lt;/strong&gt;があります。 スクリプト&lt;strong&gt;〜/ bin / lib / Bを&lt;/strong&gt; &lt;strong&gt;ソースとし&lt;/strong&gt;ます。 含まれているスクリプトが元のスクリプト（サブディレクトリ&lt;strong&gt;lib&lt;/strong&gt; ）との相対位置はわかっていますが、ユーザーの現在のディレクトリとの相対位置はわかっていません。</target>
        </trans-unit>
        <trans-unit id="08c0715b171236193ef556a3e6ee0e0d4b8a54d0" translate="yes" xml:space="preserve">
          <source>See
&lt;a href=&quot;https://pastebin.com/J8KjxrPF&quot;&gt;https://pastebin.com/J8KjxrPF&lt;/a&gt;</source>
          <target state="translated">See
&lt;a href=&quot;https://pastebin.com/J8KjxrPF&quot;&gt;https://pastebin.com/J8KjxrPF&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="179405fffe479820e45c426b988de99252c1cd22" translate="yes" xml:space="preserve">
          <source>See the man pages for &lt;code&gt;dirname&lt;/code&gt; and &lt;code&gt;readlink&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dirname&lt;/code&gt; と &lt;code&gt;readlink&lt;/code&gt; のマニュアルページを参照してください。</target>
        </trans-unit>
        <trans-unit id="c6b3f2bbd8222358a7517260fde7e7932a399471" translate="yes" xml:space="preserve">
          <source>Short answer:</source>
          <target state="translated">答えは簡単だ</target>
        </trans-unit>
        <trans-unit id="a0d149ae2639019b6c5406830fed3b68dbc7b252" translate="yes" xml:space="preserve">
          <source>Since the script will be run in a separate bash instance, there is no need to restore the working directory afterwards, but if you do want to change back in your script for some reason, you can easily assign the value of &lt;code&gt;pwd&lt;/code&gt; to a variable before you change directory, for future use.</source>
          <target state="translated">スクリプトは別のbashインスタンスで実行されるため、後で作業ディレクトリを復元する必要はありませんが、何らかの理由でスクリプトを元に戻す場合は、前に変数に &lt;code&gt;pwd&lt;/code&gt; の値を簡単に割り当てることができます将来使用するためにディレクトリを変更します。</target>
        </trans-unit>
        <trans-unit id="bf31e1601b7845dedc267cf1517109936836664c" translate="yes" xml:space="preserve">
          <source>So to make it actually useful here's how to change to the directory of the running script:</source>
          <target state="translated">そこで、実際に使えるようにするために、実行中のスクリプトのディレクトリを変更する方法をご紹介します。</target>
        </trans-unit>
        <trans-unit id="9e8c62d67f4534baba003d7d0611dac78c2ec24b" translate="yes" xml:space="preserve">
          <source>Some others have mentioned the &lt;code&gt;readlink&lt;/code&gt; command, but at its simplest, you can use:</source>
          <target state="translated">&lt;code&gt;readlink&lt;/code&gt; コマンドについて言及している人もいますが、最も簡単な方法は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="972566de850ad7f90e9bb841308fa335acf3511e" translate="yes" xml:space="preserve">
          <source>Spaces, tabs, newlines, unicode, etc. in directories and/or filename</source>
          <target state="translated">スペース、タブ、改行、ユニコードなどのディレクトリやファイル名の中で</target>
        </trans-unit>
        <trans-unit id="1ec65979ffd82e8d4fe3bade4ddad36f365785d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dirname&lt;/code&gt; command is the most basic, simply parsing the path up to the filename off of the &lt;code&gt;$0&lt;/code&gt; (script name) variable:</source>
          <target state="translated">&lt;code&gt;dirname&lt;/code&gt; コマンドは最も基本的なもので、 &lt;code&gt;$0&lt;/code&gt; （スクリプト名）変数からファイル名までのパスを解析するだけです。</target>
        </trans-unit>
        <trans-unit id="c2502d6f2d208ee4aa0c27823d3f504b519b349d" translate="yes" xml:space="preserve">
          <source>The above should cover your needs for locating the currently running script on Linux, but if you don't have the &lt;code&gt;proc&lt;/code&gt; filesystem at your disposal, or if you're trying to locate the fully resolved path of some other file, then maybe you'll find the below code helpful. It's only a slight modification from the above one-liner. If you're playing around with strange directory/filenames, checking the output with both &lt;code&gt;ls&lt;/code&gt; and &lt;code&gt;readlink&lt;/code&gt; is informative, as &lt;code&gt;ls&lt;/code&gt; will output &quot;simplified&quot; paths, substituting &lt;code&gt;?&lt;/code&gt; for things like newlines.</source>
          <target state="translated">上記はLinuxで現在実行中のスクリプトを見つける必要性をカバーするはずですが、 &lt;code&gt;proc&lt;/code&gt; ファイルシステムが自由に利用できない場合、または他のファイルの完全に解決されたパスを見つけようとしている場合は、以下のコードが参考になります。 上記のワンライナーを少し変更しただけです。 奇妙なディレクトリ/ファイル名で遊んでいる場合は、 &lt;code&gt;ls&lt;/code&gt; が「単純化された」パスを出力して &lt;code&gt;?&lt;/code&gt; 改行のようなもののために。</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">アウトプットです。</target>
        </trans-unit>
        <trans-unit id="1ba8640e9fee25016a4dad8164c1faefe6e9b381" translate="yes" xml:space="preserve">
          <source>The shortest and most elegant way to do this is:</source>
          <target state="translated">最短でエレガントな方法です。</target>
        </trans-unit>
        <trans-unit id="5f00be7ce17d97d6d2b8ad5eedab1814c2f7db86" translate="yes" xml:space="preserve">
          <source>There's no need to use &lt;code&gt;BASH_SOURCE&lt;/code&gt; when &lt;code&gt;$0&lt;/code&gt; contains the script filename.</source>
          <target state="translated">&lt;code&gt;$0&lt;/code&gt; にスクリプトファイル名が含まれている場合は、 &lt;code&gt;BASH_SOURCE&lt;/code&gt; を使用する必要はありません。</target>
        </trans-unit>
        <trans-unit id="708db81f22b4189fbca177dd22f22687e2096158" translate="yes" xml:space="preserve">
          <source>This comment and code Copyleft, selectable license under the GPL2.0 or later or CC-SA 3.0  (CreativeCommons Share Alike) or later. (c) 2008. All rights reserved. No warranty of any kind. You have been warned.</source>
          <target state="translated">このコメントとコードのCopyleft、GPL2.0以降、またはCC-SA 3.0 (CreativeCommons Share Alike)以降のライセンスの下で選択可能です。(c)2008.すべての著作権を保有しています。いかなる種類の保証もありません。警告されています。</target>
        </trans-unit>
        <trans-unit id="9b87a680ec2f32548e3f66bb1cd9591fa03074fb" translate="yes" xml:space="preserve">
          <source>This function takes 1 argument. If argument has already absolute path, print it as it is, otherwise print &lt;code&gt;$PWD&lt;/code&gt; variable + filename argument (without &lt;code&gt;./&lt;/code&gt; prefix).</source>
          <target state="translated">この関数は1つの引数を取ります。 引数がすでに絶対パスを持っている場合はそのまま印刷し、そうでない場合は &lt;code&gt;$PWD&lt;/code&gt; 変数+ファイル名の引数（ &lt;code&gt;./&lt;/code&gt; プレフィックスなし）を印刷します。</target>
        </trans-unit>
        <trans-unit id="1fbe2218965d16cf412a3cb4e57e7dabce8dfa88" translate="yes" xml:space="preserve">
          <source>This gets it right regardless how or where you run it:</source>
          <target state="translated">これは、どのように、またはどこで実行するかにかかわらず、それを正しく取得します。</target>
        </trans-unit>
        <trans-unit id="e6228e8bc7f23574e8589322511f54bee4d824b4" translate="yes" xml:space="preserve">
          <source>This gets the current working directory on Mac OS X 10.6.6:</source>
          <target state="translated">これはMac OS X 10.6.6.6のカレントワーキングディレクトリを取得します。</target>
        </trans-unit>
        <trans-unit id="b50df0d2b5baa8b71ef8e15ca44df475f421e8ba" translate="yes" xml:space="preserve">
          <source>This has a small bit of ugliness to it, but the fix is compact and easy to understand. We aren't using bash primitives only, but I'm okay with that because &lt;code&gt;readlink&lt;/code&gt; simplifies the task considerably. The &lt;code&gt;echo X&lt;/code&gt; adds an &lt;code&gt;X&lt;/code&gt; to the end of the variable string so that any trailing whitespace in the filename doesn't get eaten, and the parameter substitution &lt;code&gt;${VAR%X}&lt;/code&gt; at the end of the line gets rid of the &lt;code&gt;X&lt;/code&gt;. Because &lt;code&gt;readlink&lt;/code&gt; adds a newline of its own (which would normally be eaten in the command substitution if not for our previous trickery), we have to get rid of that, too. This is most easily accomplished using the &lt;code&gt;$''&lt;/code&gt; quoting scheme, which lets us use escape sequences such as &lt;code&gt;\n&lt;/code&gt; to represent newlines (this is also how you can easily make deviously named directories and files).</source>
          <target state="translated">これには少し醜い点がありますが、修正はコンパクトで理解しやすいものです。 bashプリミティブのみを使用しているわけではありませんが、 &lt;code&gt;readlink&lt;/code&gt; はタスクを大幅に簡略化するので大丈夫です。 &lt;code&gt;echo X&lt;/code&gt; は、変数文字列の末尾に &lt;code&gt;X&lt;/code&gt; を追加して、ファイル名の末尾の空白が食べられないようにし、行末のパラメータ置換 &lt;code&gt;${VAR%X}&lt;/code&gt; が &lt;code&gt;X&lt;/code&gt; を取り除きます。 &lt;code&gt;readlink&lt;/code&gt; が独自の改行を追加するため（以前の策略ではない場合、コマンド置換で通常使用されます）、それも取り除く必要があります。 これは、 &lt;code&gt;$''&lt;/code&gt; クォートスキームを使用して最も簡単に実現できます。これにより、 &lt;code&gt;\n&lt;/code&gt; などのエスケープシーケンスを使用して改行を表すことができます（これは、わかりやすい名前のディレクトリとファイルを簡単に作成する方法でもあります）。</target>
        </trans-unit>
        <trans-unit id="5aa844422368c235d4798b12c5b40f9de43120b8" translate="yes" xml:space="preserve">
          <source>This is Linux specific, but you could use:</source>
          <target state="translated">これはLinux特有のものですが、使ってもいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="86fd117c80732a5737dd5bfc313248aa05132334" translate="yes" xml:space="preserve">
          <source>This is a slight revision to the solution e-satis and 3bcdnlklvc04a pointed out in &lt;a href=&quot;https://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-in/179231#179231&quot;&gt;their answer&lt;/a&gt;:</source>
          <target state="translated">これは、ソリューションe-satisのわずかな改訂であり、3bcdnlklvc04a &lt;a href=&quot;https://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-in/179231#179231&quot;&gt;が回答で&lt;/a&gt;指摘しました 。</target>
        </trans-unit>
        <trans-unit id="2b6bbbcdc45501c525a87758ecc98df605856ec4" translate="yes" xml:space="preserve">
          <source>This is solved by the following (inside &lt;strong&gt;A&lt;/strong&gt;):</source>
          <target state="translated">これは、以下によって解決されます（内部&lt;strong&gt;A&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="624fd87ddc71cc2f52e33f6b137ca769fdd435b7" translate="yes" xml:space="preserve">
          <source>This last one will work with any combination of aliases, &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;bash -c&lt;/code&gt;, symlinks, etc.</source>
          <target state="translated">この最後のものは、エイリアス、 &lt;code&gt;source&lt;/code&gt; 、 &lt;code&gt;bash -c&lt;/code&gt; 、シンボリックリンクなどの任意の組み合わせで機能します。</target>
        </trans-unit>
        <trans-unit id="4983e48bae3b4d2a9a56065e7e14eeea962257d4" translate="yes" xml:space="preserve">
          <source>This should do it:</source>
          <target state="translated">これでいいんじゃないかな。</target>
        </trans-unit>
        <trans-unit id="aa4c83ddd30660c0e83b985de4ded174bb141cac" translate="yes" xml:space="preserve">
          <source>This should still work in all the cases they listed.</source>
          <target state="translated">これは、彼らがリストアップしたすべてのケースでまだ機能するはずです。</target>
        </trans-unit>
        <trans-unit id="cf9699e13a8ba01954113516dc2f3d41f207c58e" translate="yes" xml:space="preserve">
          <source>This way, you get an absolute, rather then relative directory.</source>
          <target state="translated">この方法では、相対ディレクトリではなく絶対ディレクトリを取得します。</target>
        </trans-unit>
        <trans-unit id="135bc3de061ad99bdf9de61474343b6e2e61806c" translate="yes" xml:space="preserve">
          <source>This will prevent &lt;code&gt;popd&lt;/code&gt; after a failed &lt;code&gt;pushd&lt;/code&gt;, thanks to konsolebox.</source>
          <target state="translated">これにより、konsoleboxのおかげで、pushdが失敗した後の &lt;code&gt;popd&lt;/code&gt; が防止されます。</target>
        </trans-unit>
        <trans-unit id="0f135b85dac7caba81ee8d5eef93c2b91b8b9911" translate="yes" xml:space="preserve">
          <source>This works in bash-3.2:</source>
          <target state="translated">これはbash-3.2で動作します。</target>
        </trans-unit>
        <trans-unit id="5e15ddfd0077a5cc542009118703466b054f19ef" translate="yes" xml:space="preserve">
          <source>This works with symlinks and spaces in path.</source>
          <target state="translated">これは、パス内のシンボリックリンクとスペースで動作します。</target>
        </trans-unit>
        <trans-unit id="8ced09545b20da47e415417b4eae8c1d46add0ea" translate="yes" xml:space="preserve">
          <source>This would work on all platforms and is super clean.</source>
          <target state="translated">これはすべてのプラットフォームで動作し、超クリーンです。</target>
        </trans-unit>
        <trans-unit id="a96b4d115e1a2f99afb8930b0cb45b42796745d8" translate="yes" xml:space="preserve">
          <source>To sum up many answers:</source>
          <target state="translated">多くの答えをまとめること。</target>
        </trans-unit>
        <trans-unit id="9affde8f5ff7bf2ca4f7667daf66a026dee38eb7" translate="yes" xml:space="preserve">
          <source>To understand how it works, try running this more verbose form:</source>
          <target state="translated">これがどのように動作するかを理解するために、このより冗長な形式で実行してみてください。</target>
        </trans-unit>
        <trans-unit id="132b79908b7776a375cc7193c424540ac793a2f9" translate="yes" xml:space="preserve">
          <source>Try the following cross-compatible solution:</source>
          <target state="translated">以下のクロス互換性のあるソリューションを試してみてください。</target>
        </trans-unit>
        <trans-unit id="826ada9994010e1474b6c934921317e2b2fc33d2" translate="yes" xml:space="preserve">
          <source>Try this directory on for size:</source>
          <target state="translated">このディレクトリのサイズを試してみてください。</target>
        </trans-unit>
        <trans-unit id="38020961644634d637fb2ca7e47c7574cbf790d7" translate="yes" xml:space="preserve">
          <source>Try using:</source>
          <target state="translated">使ってみてください。</target>
        </trans-unit>
        <trans-unit id="9a452526a7c03b98a7b0cff9b23c4571ffe98669" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;dirname &quot;$0&quot;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;dirname &quot;$0&quot;&lt;/code&gt; 使用します。</target>
        </trans-unit>
        <trans-unit id="cee68f731daaa055fef6e7d60b2e005a40ccd507" translate="yes" xml:space="preserve">
          <source>Used Commands</source>
          <target state="translated">使用コマンド</target>
        </trans-unit>
        <trans-unit id="a647143996cb15d8f49750108a38d0c04b574b6a" translate="yes" xml:space="preserve">
          <source>Works for all versions,including</source>
          <target state="translated">を含むすべてのバージョンで動作します。</target>
        </trans-unit>
        <trans-unit id="4478c870924518a381357cbdddc6fd2693d6b087" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;$BASH_SOURCE&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;$BASH_SOURCE&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="f3e45657c5047bf94cb7ca6a37215e8c261e76dc" translate="yes" xml:space="preserve">
          <source>as the commands such as &lt;code&gt;realpath&lt;/code&gt; or &lt;code&gt;readlink&lt;/code&gt; could be not available (depending on the operating system).</source>
          <target state="translated">（オペレーティングシステムによっては） &lt;code&gt;realpath&lt;/code&gt; や &lt;code&gt;readlink&lt;/code&gt; などのコマンドが使用できない場合があるためです。</target>
        </trans-unit>
        <trans-unit id="3b35d515a2cad2dbe851141ccbc96b335f97be3e" translate="yes" xml:space="preserve">
          <source>is a useful one-liner which will give you the full directory name of the script no matter where it is being called from.</source>
          <target state="translated">は便利なワンライナーで、どこから呼び出されてもスクリプトの完全なディレクトリ名を教えてくれます。</target>
        </trans-unit>
        <trans-unit id="23a79b97adcea69578a7d61d5b1b5bea3a07c8d0" translate="yes" xml:space="preserve">
          <source>or (&lt;a href=&quot;http://mywiki.wooledge.org/BashFAQ/082&quot;&gt;preferably&lt;/a&gt;):</source>
          <target state="translated">または（ &lt;a href=&quot;http://mywiki.wooledge.org/BashFAQ/082&quot;&gt;できれば&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="4a9fbc967654f7ea7a6ba8346e46b6dc14178a2d" translate="yes" xml:space="preserve">
          <source>solves the specific scenario in the question, I find having the absolute path to more more useful generally.</source>
          <target state="translated">は、質問の特定のシナリオを解決し、私はより一般的に有用なより多くの絶対パスを持っていることを見つける。</target>
        </trans-unit>
        <trans-unit id="06e8f4de34464eed78185a34e3f0bf59d4c3790c" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;pwd&lt;/code&gt; alone will not work if you are not running the script from the directory it is contained in.</source>
          <target state="translated">スクリプトが含まれているディレクトリからスクリプトを実行していない場合、 &lt;code&gt;pwd&lt;/code&gt; のみを使用しても機能しません。</target>
        </trans-unit>
        <trans-unit id="5417682a89cadfcccf3667346fea39b977cb8c68" translate="yes" xml:space="preserve">
          <source>when arg &lt;code&gt;$0&lt;/code&gt; is modified from caller.</source>
          <target state="translated">arg &lt;code&gt;$0&lt;/code&gt; が呼び出し元から変更されたとき。</target>
        </trans-unit>
        <trans-unit id="d9aceea7d088301ee05fb56104bb7954812ddde0" translate="yes" xml:space="preserve">
          <source>when called via multple depth soft link,</source>
          <target state="translated">マルチプルデプスソフトリンク経由で呼び出された場合</target>
        </trans-unit>
        <trans-unit id="5214b91d429aa811e23fe9cdd6fb85ec9ab8f9a3" translate="yes" xml:space="preserve">
          <source>when script called by command &quot;&lt;code&gt;source&lt;/code&gt;&quot; aka &lt;code&gt;.&lt;/code&gt; (dot) operator.</source>
          <target state="translated">スクリプトがコマンド &quot; &lt;code&gt;source&lt;/code&gt; &quot;別名で呼び出されたとき &lt;code&gt;.&lt;/code&gt; （ドット）演算子。</target>
        </trans-unit>
        <trans-unit id="e87310bd2c8f2488b7a4fb47d9de8ff04e1d2137" translate="yes" xml:space="preserve">
          <source>when the file it</source>
          <target state="translated">ファイルが</target>
        </trans-unit>
        <trans-unit id="ea5bdf31e3db8283bb30dac33b0fe419cb0a6ca2" translate="yes" xml:space="preserve">
          <source>works for me.</source>
          <target state="translated">私のために働いています。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
