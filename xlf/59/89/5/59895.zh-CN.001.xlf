<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/59895">
    <body>
      <group id="59895">
        <trans-unit id="19a18fc4d4b50e61530b0cfb075c6c2ed407c75d" translate="yes" xml:space="preserve">
          <source>18eedfe1c99df68dc94d4a94712a71aaa8e1e9e36cacf421b9463dd2bbaa02906d0d6656</source>
          <target state="translated">18eedfe1c99df68dc94d4a94712a71aaa8e1e9e36cacf421b9463dd2bbaa02906d0d6656</target>
        </trans-unit>
        <trans-unit id="bf0eaf87a792df5e1034cb33ebb1ee9d074c5b22" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.gnu.org/s/bash/manual/bash.html#Environment&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; is worth mentioning as an alternative to &lt;code&gt;$0&lt;/code&gt;.  If you're running a script from Bash, the accepted answer can be shortened to:</source>
          <target state="translated">&lt;a href=&quot;http://www.gnu.org/s/bash/manual/bash.html#Environment&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt;作为 &lt;code&gt;$0&lt;/code&gt; 的替代品值得一提。 如果您正在从Bash运行脚本，则可以将接受的答案缩短为：</target>
        </trans-unit>
        <trans-unit id="593fbc86ef10e2bd792ac1985c4267c146009c42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SCRIPT_PATH&lt;/code&gt; is given in full path, no matter how it is called.</source>
          <target state="translated">&lt;code&gt;SCRIPT_PATH&lt;/code&gt; 完整路径给出。</target>
        </trans-unit>
        <trans-unit id="7823bfeac488dfb6d0fa9044c88f386df6a09bf4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pwd&lt;/code&gt; can be used to find the current working directory, and &lt;code&gt;dirname&lt;/code&gt; to find the directory of a particular file (command that was run, is &lt;code&gt;$0&lt;/code&gt;, so &lt;code&gt;dirname $0&lt;/code&gt; should give you the directory of the current script).</source>
          <target state="translated">&lt;code&gt;pwd&lt;/code&gt; 可用于查找当前工作目录， &lt;code&gt;dirname&lt;/code&gt; 可用于查找特定文件的目录（运行的命令是 &lt;code&gt;$0&lt;/code&gt; ，因此 &lt;code&gt;dirname $0&lt;/code&gt; 应该为您提供当前脚本的目录）。</target>
        </trans-unit>
        <trans-unit id="6d18c950a3d7f2476e076d0ab011a954913b53e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readlink&lt;/code&gt; will resolve the script path to an absolute path from the root of the filesystem. So, any paths containing single or double dots, tildes and/or symbolic links will be resolved to a full path.</source>
          <target state="translated">&lt;code&gt;readlink&lt;/code&gt; 会将脚本路径解析为从文件系统根目录开始的绝对路径。 因此，任何包含单点或双点，波浪号和/或符号链接的路径都将解析为完整路径。</target>
        </trans-unit>
        <trans-unit id="0581627fdb0bac69bb25fa3efd994b4e62714351" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt;&lt;/strong&gt; - the full path to the script. The value of this will be correct even when the script is being sourced, e.g. &lt;code&gt;source &amp;lt;(echo 'echo $0')&lt;/code&gt; prints &lt;strong&gt;bash&lt;/strong&gt;, while replacing it with &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; will print the full path of the script. (Of course, this assumes you're OK taking a dependency on Bash.)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; &lt;/strong&gt; -脚本的完整路径。 即使 &lt;code&gt;source &amp;lt;(echo 'echo $0')&lt;/code&gt; 是脚本，此值也将是正确的，例如source &amp;lt;（ &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; $ 0'）打印&lt;strong&gt;bash&lt;/strong&gt; ，而用$ {BASH_SOURCE [0]}替换&lt;strong&gt;bash&lt;/strong&gt;将打印脚本的完整路径。 （当然，这假设您可以依赖Bash。）</target>
        </trans-unit>
        <trans-unit id="07ce80449c0b3e3f277e4aeb4c0cb9d5d13239a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;readlink -f&lt;/code&gt;&lt;/strong&gt; - Recursively resolves any symlinks in the specified path. This is a GNU extension, and not available on (for example) BSD systems. If you're running a Mac, you can use Homebrew to install GNU &lt;code&gt;coreutils&lt;/code&gt; and supplant this with &lt;strong&gt;&lt;code&gt;greadlink -f&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;readlink -f&lt;/code&gt; -&lt;/strong&gt;递归解析指定路径中的所有符号链接。 这是GNU扩展，在（例如）BSD系统上不可用。 如果您使用的是Mac，则可以使用Homebrew安装GNU &lt;code&gt;coreutils&lt;/code&gt; ,并使用&lt;strong&gt; &lt;code&gt;greadlink -f&lt;/code&gt; &lt;/strong&gt;代替它。</target>
        </trans-unit>
        <trans-unit id="426fbf2c3b86a3a618cbd3f9d4a86baf50463f6f" translate="yes" xml:space="preserve">
          <source>Absolute paths or relative paths</source>
          <target state="translated">绝对路径或相对路径</target>
        </trans-unit>
        <trans-unit id="4d5e28e7a0e956bd9e43ce42784d9f9cdb3a1a56" translate="yes" xml:space="preserve">
          <source>Again, but using the full path to the script:</source>
          <target state="translated">再次,但使用脚本的完整路径。</target>
        </trans-unit>
        <trans-unit id="31df5ecd19815d979653fa19bbfcdd3f7579bf3e" translate="yes" xml:space="preserve">
          <source>Also a lot of people assume you're running the script from a shell so they forget when you open a new script it defaults to your home.</source>
          <target state="translated">另外,很多人认为你是从shell中运行的脚本,所以当你打开一个新的脚本时,他们会忘记它默认为你的主页。</target>
        </trans-unit>
        <trans-unit id="5cc881cb0d3b8741b77229be62a98f44e6db9d66" translate="yes" xml:space="preserve">
          <source>Also, watch out for &lt;a href=&quot;http://bosker.wordpress.com/2012/02/12/bash-scripters-beware-of-the-cdpath/&quot;&gt;&lt;code&gt;$CDPATH&lt;/code&gt; gotchas&lt;/a&gt;, and stderr output side effects if the user has smartly overridden cd to redirect output to stderr instead (including escape sequences, such as when calling &lt;code&gt;update_terminal_cwd &amp;gt;&amp;amp;2&lt;/code&gt; on Mac). Adding &lt;code&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; at the end of your &lt;code&gt;cd&lt;/code&gt; command will take care of both possibilities.</source>
          <target state="translated">另外，请注意&lt;a href=&quot;http://bosker.wordpress.com/2012/02/12/bash-scripters-beware-of-the-cdpath/&quot;&gt; &lt;code&gt;$CDPATH&lt;/code&gt; gotchas&lt;/a&gt;和stderr输出的副作用，如果用户巧妙地覆盖了cd来将输出重定向到stderr（包括转义序列，例如在Mac上调用 &lt;code&gt;update_terminal_cwd &amp;gt;&amp;amp;2&lt;/code&gt; ）。 在 &lt;code&gt;cd&lt;/code&gt; 命令的末尾添加 &lt;code&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; 将解决这两种可能性。</target>
        </trans-unit>
        <trans-unit id="82ae5dde6d9ef2e46a9b902e17c82253e6391ecf" translate="yes" xml:space="preserve">
          <source>Alternatively you can try the following function in bash:</source>
          <target state="translated">另外,你也可以在bash中试试下面的功能。</target>
        </trans-unit>
        <trans-unit id="e053cd2da59279d2a0608bc7768f1b1f529d9e11" translate="yes" xml:space="preserve">
          <source>Alternatively, if the bash script itself is a &lt;strong&gt;relative symlink&lt;/strong&gt; you &lt;em&gt;want&lt;/em&gt; to follow it and return the full path of the linked-to script:</source>
          <target state="translated">另外，如果bash脚本本身是&lt;strong&gt;相对符号链接，则&lt;/strong&gt;您&lt;em&gt;要&lt;/em&gt;跟随它并返回链接脚本的完整路径：</target>
        </trans-unit>
        <trans-unit id="e969dea8cd5921be63a767f83c70cdc21ad8e248" translate="yes" xml:space="preserve">
          <source>Although just</source>
          <target state="translated">虽然只是</target>
        </trans-unit>
        <trans-unit id="08ff941f8ba378bc98bfbb6b1945c211a1cf671d" translate="yes" xml:space="preserve">
          <source>And finally using a symbolic link to execute the script:</source>
          <target state="translated">最后用一个符号链接来执行脚本。</target>
        </trans-unit>
        <trans-unit id="0b7be30335048b9362beef0dcaaa21ecad8777d9" translate="yes" xml:space="preserve">
          <source>And it will print something like:</source>
          <target state="translated">它将打印出类似的东西:</target>
        </trans-unit>
        <trans-unit id="abac3354c23bb46705fe1229d339a683605c1ae3" translate="yes" xml:space="preserve">
          <source>And of course &lt;strong&gt;&lt;code&gt;dirname&lt;/code&gt;&lt;/strong&gt; gets the parent directory of the path.</source>
          <target state="translated">当然， &lt;strong&gt; &lt;code&gt;dirname&lt;/code&gt; &lt;/strong&gt;获取路径的父目录。</target>
        </trans-unit>
        <trans-unit id="760013e12b493fa6407f1a2ce1efb48c91f8cef6" translate="yes" xml:space="preserve">
          <source>Bash script absolute path with OS X</source>
          <target state="translated">使用OS X的Bash脚本绝对路径</target>
        </trans-unit>
        <trans-unit id="0f28fd68e004022f6abcd795c8d0296f7d6715ac" translate="yes" xml:space="preserve">
          <source>Beware: if you &lt;code&gt;cd&lt;/code&gt; to a different directory before running this snippet, the result may be incorrect!</source>
          <target state="translated">请注意：如果在运行此代码段之前先将 &lt;code&gt;cd&lt;/code&gt; 切换到其他目录，则结果可能不正确！</target>
        </trans-unit>
        <trans-unit id="2e27eaacc3ad357f5d5f74812ad0688f6b0fc661" translate="yes" xml:space="preserve">
          <source>But, as &lt;strong&gt;matt b&lt;/strong&gt; pointed out, the path returned is different depending on how the script is called. &lt;code&gt;pwd&lt;/code&gt; doesn't do the job because that only tells you what the current directory is, not what directory the script resides in. Additionally, if a symbolic link to a script is executed, you're going to get a (probably relative) path to where the link resides, not the actual script.</source>
          <target state="translated">但是，正如&lt;strong&gt;matt b所&lt;/strong&gt;指出的，根据调用脚本的方式，返回的路径是不同的。 &lt;code&gt;pwd&lt;/code&gt; 不会执行此操作，因为它只会告诉您当前目录是什么，而不是脚本所在的目录。此外，如果执行了指向脚本的符号链接，您将获得（可能是相对的）路径链接所在的位置，而不是实际的脚本。</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="e0855567fdf07ed8e9074f37448001287e233f16" translate="yes" xml:space="preserve">
          <source>File and directory soft links</source>
          <target state="translated">文件和目录软链接</target>
        </trans-unit>
        <trans-unit id="fed5301d79c7b6f1a7c8546ea54449b1afeeeaa5" translate="yes" xml:space="preserve">
          <source>Filenames beginning with a hyphen</source>
          <target state="translated">以连字符开头的文件名</target>
        </trans-unit>
        <trans-unit id="772062a56cf9b814d3042408e52f123d2ada045a" translate="yes" xml:space="preserve">
          <source>For systems having GNU coreutils &lt;code&gt;readlink&lt;/code&gt; (eg. linux):</source>
          <target state="translated">对于具有GNU coreutils &lt;code&gt;readlink&lt;/code&gt; 的系统（例如linux）：</target>
        </trans-unit>
        <trans-unit id="721536b3b45c387e4bee8ead6b8c3dba91e6d655" translate="yes" xml:space="preserve">
          <source>From the comment track it seems not to work with Mac OS.
I have no idea why that is. Any suggestions?</source>
          <target state="translated">从评论轨迹上看,似乎不能在Mac OS上使用。我不知道为什么会这样。有什么建议吗?</target>
        </trans-unit>
        <trans-unit id="cc396b4d831b322640a5f760d49c543208d2cfd8" translate="yes" xml:space="preserve">
          <source>Here is a POSIX compliant one-liner:</source>
          <target state="translated">这里有一个符合POSIX的单行本。</target>
        </trans-unit>
        <trans-unit id="7e6caa82bfaa440bd1e01986a8ac88b7f3d089a6" translate="yes" xml:space="preserve">
          <source>Here is an easy-to-remember script:</source>
          <target state="translated">下面是一个容易记忆的脚本。</target>
        </trans-unit>
        <trans-unit id="7a6b9a74a02f93af7c524bc132c55dc467e6be32" translate="yes" xml:space="preserve">
          <source>Here is the simple, correct way:</source>
          <target state="translated">这里有一个简单、正确的方法。</target>
        </trans-unit>
        <trans-unit id="7e2786c7429ea5f9dc687d1fac3e1e4a84e09bad" translate="yes" xml:space="preserve">
          <source>Here's a script demonstrating each of these, &lt;code&gt;whatdir.sh&lt;/code&gt;:</source>
          <target state="translated">这是演示每个脚本的脚本 &lt;code&gt;whatdir.sh&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="79d4dc6932c6940edea09332c0a40e4c385f867e" translate="yes" xml:space="preserve">
          <source>Here's an example of its usage:</source>
          <target state="translated">这里举个例子说明一下它的用法。</target>
        </trans-unit>
        <trans-unit id="f67626bb87966ae92799fbed14c52f02b6a20974" translate="yes" xml:space="preserve">
          <source>Hmm, if in the path basename &amp;amp; dirname are just not going to cut it
and walking the path is hard (what if parent didn't export PATH!).
However, the shell has to have an open handle to its script, and in
bash the handle is #255.</source>
          <target state="translated">嗯，如果在路径名中，基名和目录名只是不会被剪切，并且走路径很困难（如果父项未导出PATH会怎样！）。 但是，shell必须为其脚本打开一个句柄，在bash中，句柄为＃255。</target>
        </trans-unit>
        <trans-unit id="2c514cd534e6b677e18c9f6ef72d1038f975e863" translate="yes" xml:space="preserve">
          <source>How do I get the path of the directory in which a &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; script is located, &lt;em&gt;inside&lt;/em&gt; that script?</source>
          <target state="translated">如何在脚本&lt;em&gt;内获取&lt;/em&gt; &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt;脚本所在目录的路径？</target>
        </trans-unit>
        <trans-unit id="e94507b21cbe42200554606d16c3782465fae406" translate="yes" xml:space="preserve">
          <source>How to get the source directory of a Bash script from within the script itself</source>
          <target state="translated">如何从脚本本身获取Bash脚本的源目录?</target>
        </trans-unit>
        <trans-unit id="15565602373c482c48a874ebd82fe09c139ba724" translate="yes" xml:space="preserve">
          <source>How to set current working directory to the directory of the script?</source>
          <target state="translated">如何将当前工作目录设置为脚本的目录?</target>
        </trans-unit>
        <trans-unit id="c1dc3b40f2fb5f6b76faaa750db69827966305ce" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;dirname&lt;/code&gt; gives precisely the directory portion of the filename, which more likely than not is going to be relative to the current working directory. If your script needs to change directory for some reason, then the output from &lt;code&gt;dirname&lt;/code&gt; becomes meaningless.</source>
          <target state="translated">但是， &lt;code&gt;dirname&lt;/code&gt; 恰好提供了文件名的目录部分，该部分很可能相对于当前工作目录。 如果您的脚本由于某种原因需要更改目录，则目录名的输出将变得毫无意义。</target>
        </trans-unit>
        <trans-unit id="fd781f58f78adcaf88471d8e16c79fde52b8abc9" translate="yes" xml:space="preserve">
          <source>I am tired of coming to this page over and over to copy paste the one-liner in the accepted answer. The problem with that is it is not easy to understand and remember.</source>
          <target state="translated">我已经厌倦了一遍又一遍地来到这个页面,把接受的答案中的单行本复制粘贴下来。但问题是不容易理解和记忆。</target>
        </trans-unit>
        <trans-unit id="c65940fe653c04e6d217fd71b5bc36c973d94e09" translate="yes" xml:space="preserve">
          <source>I believe I've got this one. I'm late to the party, but I think some will appreciate it being here if they come across this thread. The comments should explain:</source>
          <target state="translated">我相信我已经拿到了这个。我是来晚了,但我想如果有人看到这条线程,会很感激它在这里。评论中应该会有解释。</target>
        </trans-unit>
        <trans-unit id="a5564a6ec07273d60ff4548ab635ae9209aad476" translate="yes" xml:space="preserve">
          <source>I don't think this is as easy as others have made it out to be.  &lt;code&gt;pwd&lt;/code&gt; doesn't work, as the current directory is not necessarily the directory with the script.  &lt;code&gt;$0&lt;/code&gt; doesn't always have the information either.  Consider the following three ways to invoke a script:</source>
          <target state="translated">我认为这并不像其他人想象的那么容易。 &lt;code&gt;pwd&lt;/code&gt; 不起作用，因为当前目录不一定是包含脚本的目录。 &lt;code&gt;$0&lt;/code&gt; 也不总是具有该信息。 考虑以下三种调用脚本的方法：</target>
        </trans-unit>
        <trans-unit id="314e2d8c80409f81525019944bae934fac7d14de" translate="yes" xml:space="preserve">
          <source>I suggest the following:</source>
          <target state="translated">我的建议如下:</target>
        </trans-unit>
        <trans-unit id="2ff8ae24228298e42c1024dc75a685fff4c70183" translate="yes" xml:space="preserve">
          <source>I tried all of these and none worked. One was very close but had a tiny bug that broke it badly; they forgot to wrap the path in quotation marks.</source>
          <target state="translated">我试了所有这些,都没有成功。有一个很接近,但有一个小虫子把它弄坏了,他们忘了用引号把路径包起来。</target>
        </trans-unit>
        <trans-unit id="fedbbd02f03e12ac9d3beeef3636203bf88f7cb9" translate="yes" xml:space="preserve">
          <source>I want to use a Bash script as a launcher for another application. I want to change the working directory to the one where the Bash script is located, so I can operate on the files in that directory, like so:</source>
          <target state="translated">我想用一个Bash脚本作为另一个应用程序的启动器。我想把工作目录改为Bash脚本所在的目录,这样我就可以对该目录下的文件进行操作,就像这样。</target>
        </trans-unit>
        <trans-unit id="ce81d457123493a7d7d88fddc69383893c3220b7" translate="yes" xml:space="preserve">
          <source>I would use something like this:</source>
          <target state="translated">我想用这样的东西。</target>
        </trans-unit>
        <trans-unit id="2171f703ddd878f550591c0e07925f51cc2b067b" translate="yes" xml:space="preserve">
          <source>I've compared many of the answers given, and come up with some more compact solutions. These seem to handle all of the crazy edge cases that arise from your favorite combination of:</source>
          <target state="translated">我比较了很多给出的答案,得出了一些比较紧凑的解决方案。这些似乎可以处理所有你喜欢的组合所产生的疯狂边缘情况。</target>
        </trans-unit>
        <trans-unit id="e58b329aff37f278c76fdb1e35272c1bf2d42971" translate="yes" xml:space="preserve">
          <source>If you're running from Linux, it seems that using the &lt;code&gt;proc&lt;/code&gt; handle is the best solution to locate the fully resolved source of the currently running script (in an interactive session, the link points to the respective &lt;code&gt;/dev/pts/X&lt;/code&gt;):</source>
          <target state="translated">如果您是在Linux上运行，似乎使用 &lt;code&gt;proc&lt;/code&gt; 句柄是找到当前运行脚本的完全解析源的最佳解决方案（在交互式会话中，链接指向相应的 &lt;code&gt;/dev/pts/X&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="f5006f4b7d8d744f73e4fc441d26d052cf92f989" translate="yes" xml:space="preserve">
          <source>In the first and third ways &lt;code&gt;$0&lt;/code&gt; doesn't have the full path information.  In the second and third, &lt;code&gt;pwd&lt;/code&gt; does not work.  The only way to get the directory in the third way would be to run through the path and find the file with the correct match.  Basically the code would have to redo what the OS does.</source>
          <target state="translated">在第一种和第三种方式中， &lt;code&gt;$0&lt;/code&gt; 没有完整的路径信息。 在第二个和第三个中， &lt;code&gt;pwd&lt;/code&gt; 不起作用。 以第三种方式获取目录的唯一方法是遍历路径并找到具有正确匹配项的文件。 基本上，代码将不得不重做操作系统。</target>
        </trans-unit>
        <trans-unit id="bb7c16b349eb08b9c0b10fa5d3251652f7054cc9" translate="yes" xml:space="preserve">
          <source>Invocation as &lt;code&gt;script&lt;/code&gt;, &lt;code&gt;bash script&lt;/code&gt;, &lt;code&gt;bash -c script&lt;/code&gt;, &lt;code&gt;source script&lt;/code&gt;, or &lt;code&gt;. script&lt;/code&gt;</source>
          <target state="translated">作为 &lt;code&gt;script&lt;/code&gt; ， &lt;code&gt;bash script&lt;/code&gt; ， &lt;code&gt;bash -c script&lt;/code&gt; ， &lt;code&gt;source script&lt;/code&gt; 或调用 &lt;code&gt;. script&lt;/code&gt; 脚本</target>
        </trans-unit>
        <trans-unit id="a02f22ad602d2ef6e382c04099658f152ab19842" translate="yes" xml:space="preserve">
          <source>It doesn't matter where the user is or how he calls the script, this will always work.</source>
          <target state="translated">不管用户在哪里,也不管他如何调用脚本,这一点永远是有效的。</target>
        </trans-unit>
        <trans-unit id="38bb10b3d907511b9279efee2507d873a4fc242c" translate="yes" xml:space="preserve">
          <source>It will work as long as the last component of the path used to find the script is not a symlink (directory links are OK).  If you also want to resolve any links to the script itself, you need a multi-line solution:</source>
          <target state="translated">只要用于查找脚本的路径中的最后一个组件不是symlink(目录链接是可以的),它就可以工作。如果你还想解决脚本本身的任何链接,你需要一个多行的解决方案。</target>
        </trans-unit>
        <trans-unit id="4605dc46bd09b4eaa7af587e1386b633fdeb4323" translate="yes" xml:space="preserve">
          <source>Just make sure you locate this at start of the script.</source>
          <target state="translated">只要确保你在剧本的开头找到这个就可以了。</target>
        </trans-unit>
        <trans-unit id="624f152e5413ea8ae957872eddedd2d49c644430" translate="yes" xml:space="preserve">
          <source>More details can be found in &quot;&lt;a href=&quot;https://www.electrictoolbox.com/bash-script-directory/&quot;&gt;Which directory is that bash script in?&lt;/a&gt;&quot;.</source>
          <target state="translated">可以在&amp;ldquo; &lt;a href=&quot;https://www.electrictoolbox.com/bash-script-directory/&quot;&gt;该bash脚本所在的目录？&lt;/a&gt; &amp;rdquo;中找到更多详细信息。</target>
        </trans-unit>
        <trans-unit id="0a0d73ad9eb09a3f63bbc70b597f635f18a702db" translate="yes" xml:space="preserve">
          <source>Note that this has to be the first statement in your script.</source>
          <target state="translated">注意,这必须是你的脚本中的第一个语句。</target>
        </trans-unit>
        <trans-unit id="3d775fc4bf5f21ab130d923a6fabfc949f661ed4" translate="yes" xml:space="preserve">
          <source>Note that you need to use &lt;code&gt;#!/bin/bash&lt;/code&gt; and not &lt;code&gt;#!/bin/sh&lt;/code&gt; since it's a Bash extension.</source>
          <target state="translated">请注意，由于它是Bash扩展名，因此您需要使用 &lt;code&gt;#!/bin/bash&lt;/code&gt; 而不是 &lt;code&gt;#!/bin/sh&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1ad78cc1e56befe9d3d057f04c18efb0f0ba1ffd" translate="yes" xml:space="preserve">
          <source>Note: In Bash, it's recommended to use&lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; instead of &lt;code&gt;$0&lt;/code&gt;, otherwise path can break when sourcing the file (&lt;code&gt;source&lt;/code&gt;/&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="translated">注意：在Bash中，建议使用 &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; 而不是 &lt;code&gt;$0&lt;/code&gt; ，否则在获取文件（ &lt;code&gt;source&lt;/code&gt; / &lt;code&gt;.&lt;/code&gt; ）时路径可能会中断。</target>
        </trans-unit>
        <trans-unit id="498c8b437a7497a048fd6a708c55520b984927c0" translate="yes" xml:space="preserve">
          <source>Now changing directories:</source>
          <target state="translated">现在更换目录。</target>
        </trans-unit>
        <trans-unit id="2cbc4a1754fa2b1a92f79674fc1cded648d99d4c" translate="yes" xml:space="preserve">
          <source>One way to do what you are asking would be to just hardcode the data in the &lt;code&gt;/usr/share&lt;/code&gt; directory, and reference it by its full path.  Data shoudn't be in the &lt;code&gt;/usr/bin&lt;/code&gt; directory anyway, so this is probably the thing to do.</source>
          <target state="translated">一种您要执行的操作的方法是仅对 &lt;code&gt;/usr/share&lt;/code&gt; 目录中的数据进行硬编码，然后按其完整路径进行引用。 无论如何，数据都不应该在 &lt;code&gt;/usr/bin&lt;/code&gt; 目录中，所以这可能是要做的事情。</target>
        </trans-unit>
        <trans-unit id="39c788876858d9fdd3ed2ab494830cb7baca1db1" translate="yes" xml:space="preserve">
          <source>Related:</source>
          <target state="translated">Related:</target>
        </trans-unit>
        <trans-unit id="a9d017586904a386f0684539c8f132954aec5924" translate="yes" xml:space="preserve">
          <source>Reliable way for a Bash script to get the full path to itself</source>
          <target state="translated">可靠的Bash脚本获取到自己的完整路径的方法。</target>
        </trans-unit>
        <trans-unit id="d02835a79470dbbc2e975df36f0e76821643fa48" translate="yes" xml:space="preserve">
          <source>Running this script in my home dir, using a relative path:</source>
          <target state="translated">在我的home dir中运行这个脚本,使用相对路径。</target>
        </trans-unit>
        <trans-unit id="0310b5ce654c85162f919b8cb40084ecbe9c6fae" translate="yes" xml:space="preserve">
          <source>Say you have a &lt;strong&gt;~/bin&lt;/strong&gt; directory, which is in your &lt;strong&gt;$PATH&lt;/strong&gt;. You have script &lt;strong&gt;A&lt;/strong&gt; inside this directory. It &lt;strong&gt;source&lt;/strong&gt;s script &lt;strong&gt;~/bin/lib/B&lt;/strong&gt;. You know where the included script is relative to the original one (the subdirectory &lt;strong&gt;lib&lt;/strong&gt;), but not where it is relative to the user's current directory.</source>
          <target state="translated">假设您有一个&lt;strong&gt;〜/ bin&lt;/strong&gt;目录，该目录位于&lt;strong&gt;$ PATH中&lt;/strong&gt; 。 您在此目录中有脚本&lt;strong&gt;A。&lt;/strong&gt; 它的脚本为&lt;strong&gt;〜/ bin / lib / B。&lt;/strong&gt; 您知道所包含的脚本相对于原始脚本在何处（子目录&lt;strong&gt;lib&lt;/strong&gt; ），但相对于用户当前目录却不知道。</target>
        </trans-unit>
        <trans-unit id="08c0715b171236193ef556a3e6ee0e0d4b8a54d0" translate="yes" xml:space="preserve">
          <source>See
&lt;a href=&quot;https://pastebin.com/J8KjxrPF&quot;&gt;https://pastebin.com/J8KjxrPF&lt;/a&gt;</source>
          <target state="translated">See
&lt;a href=&quot;https://pastebin.com/J8KjxrPF&quot;&gt;https://pastebin.com/J8KjxrPF&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="179405fffe479820e45c426b988de99252c1cd22" translate="yes" xml:space="preserve">
          <source>See the man pages for &lt;code&gt;dirname&lt;/code&gt; and &lt;code&gt;readlink&lt;/code&gt;.</source>
          <target state="translated">有关 &lt;code&gt;dirname&lt;/code&gt; 和 &lt;code&gt;readlink&lt;/code&gt; 的信息,请参见手册页。</target>
        </trans-unit>
        <trans-unit id="c6b3f2bbd8222358a7517260fde7e7932a399471" translate="yes" xml:space="preserve">
          <source>Short answer:</source>
          <target state="translated">简短的答案是:</target>
        </trans-unit>
        <trans-unit id="a0d149ae2639019b6c5406830fed3b68dbc7b252" translate="yes" xml:space="preserve">
          <source>Since the script will be run in a separate bash instance, there is no need to restore the working directory afterwards, but if you do want to change back in your script for some reason, you can easily assign the value of &lt;code&gt;pwd&lt;/code&gt; to a variable before you change directory, for future use.</source>
          <target state="translated">由于脚本将在单独的bash实例中运行，因此此后无需还原工作目录，但是如果您出于某种原因确实想要在脚本中进行更改，则可以轻松地将 &lt;code&gt;pwd&lt;/code&gt; 的值分配给变量您更改目录，以备将来使用。</target>
        </trans-unit>
        <trans-unit id="bf31e1601b7845dedc267cf1517109936836664c" translate="yes" xml:space="preserve">
          <source>So to make it actually useful here's how to change to the directory of the running script:</source>
          <target state="translated">所以为了让它真正有用,下面是如何改到运行脚本的目录。</target>
        </trans-unit>
        <trans-unit id="9e8c62d67f4534baba003d7d0611dac78c2ec24b" translate="yes" xml:space="preserve">
          <source>Some others have mentioned the &lt;code&gt;readlink&lt;/code&gt; command, but at its simplest, you can use:</source>
          <target state="translated">其他一些人提到了 &lt;code&gt;readlink&lt;/code&gt; 命令，但最简单的方法是：</target>
        </trans-unit>
        <trans-unit id="972566de850ad7f90e9bb841308fa335acf3511e" translate="yes" xml:space="preserve">
          <source>Spaces, tabs, newlines, unicode, etc. in directories and/or filename</source>
          <target state="translated">目录和文件名中的空格、制表符、换行符、统一码等。</target>
        </trans-unit>
        <trans-unit id="1ec65979ffd82e8d4fe3bade4ddad36f365785d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dirname&lt;/code&gt; command is the most basic, simply parsing the path up to the filename off of the &lt;code&gt;$0&lt;/code&gt; (script name) variable:</source>
          <target state="translated">&lt;code&gt;dirname&lt;/code&gt; 命令是最基本的命令，只需解析 &lt;code&gt;$0&lt;/code&gt; （脚本名称）变量中的文件名路径：</target>
        </trans-unit>
        <trans-unit id="c2502d6f2d208ee4aa0c27823d3f504b519b349d" translate="yes" xml:space="preserve">
          <source>The above should cover your needs for locating the currently running script on Linux, but if you don't have the &lt;code&gt;proc&lt;/code&gt; filesystem at your disposal, or if you're trying to locate the fully resolved path of some other file, then maybe you'll find the below code helpful. It's only a slight modification from the above one-liner. If you're playing around with strange directory/filenames, checking the output with both &lt;code&gt;ls&lt;/code&gt; and &lt;code&gt;readlink&lt;/code&gt; is informative, as &lt;code&gt;ls&lt;/code&gt; will output &quot;simplified&quot; paths, substituting &lt;code&gt;?&lt;/code&gt; for things like newlines.</source>
          <target state="translated">上面的内容可以满足您在Linux上查找当前正在运行的脚本的需求，但是如果您没有 &lt;code&gt;proc&lt;/code&gt; 文件系统可供使用，或者您要查找其他文件的完全解析路径，那么也许会发现以下代码很有帮助。 这只是上述单线的略微修改。 如果您正在使用奇怪的目录/文件名，请同时检查 &lt;code&gt;ls&lt;/code&gt; 和 &lt;code&gt;readlink&lt;/code&gt; 的输出是否有用，因为 &lt;code&gt;ls&lt;/code&gt; 将输出&amp;ldquo;简化的&amp;rdquo;路径，用 &lt;code&gt;?&lt;/code&gt; 用于换行。</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">的输出。</target>
        </trans-unit>
        <trans-unit id="1ba8640e9fee25016a4dad8164c1faefe6e9b381" translate="yes" xml:space="preserve">
          <source>The shortest and most elegant way to do this is:</source>
          <target state="translated">最短、最优雅的方法是。</target>
        </trans-unit>
        <trans-unit id="5f00be7ce17d97d6d2b8ad5eedab1814c2f7db86" translate="yes" xml:space="preserve">
          <source>There's no need to use &lt;code&gt;BASH_SOURCE&lt;/code&gt; when &lt;code&gt;$0&lt;/code&gt; contains the script filename.</source>
          <target state="translated">&lt;code&gt;$0&lt;/code&gt; 包含脚本文件名时，无需使用 &lt;code&gt;BASH_SOURCE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="708db81f22b4189fbca177dd22f22687e2096158" translate="yes" xml:space="preserve">
          <source>This comment and code Copyleft, selectable license under the GPL2.0 or later or CC-SA 3.0  (CreativeCommons Share Alike) or later. (c) 2008. All rights reserved. No warranty of any kind. You have been warned.</source>
          <target state="translated">本评论和代码Copyleft,可选择GPL2.0或更高版本或CC-SA 3.0 (CreativeCommons Share Alike)或更高版本的许可。(c)2008.保留所有权利。不提供任何形式的保证。您已被警告。</target>
        </trans-unit>
        <trans-unit id="9b87a680ec2f32548e3f66bb1cd9591fa03074fb" translate="yes" xml:space="preserve">
          <source>This function takes 1 argument. If argument has already absolute path, print it as it is, otherwise print &lt;code&gt;$PWD&lt;/code&gt; variable + filename argument (without &lt;code&gt;./&lt;/code&gt; prefix).</source>
          <target state="translated">此函数有1个参数。 如果参数已经具有绝对路径，则按原样打印，否则打印 &lt;code&gt;$PWD&lt;/code&gt; 变量+文件名参数（不带 &lt;code&gt;./&lt;/code&gt; 前缀）。</target>
        </trans-unit>
        <trans-unit id="1fbe2218965d16cf412a3cb4e57e7dabce8dfa88" translate="yes" xml:space="preserve">
          <source>This gets it right regardless how or where you run it:</source>
          <target state="translated">无论你是如何运行的,还是在哪里运行的,这都是正确的。</target>
        </trans-unit>
        <trans-unit id="e6228e8bc7f23574e8589322511f54bee4d824b4" translate="yes" xml:space="preserve">
          <source>This gets the current working directory on Mac OS X 10.6.6:</source>
          <target state="translated">这将获得Mac OS X 10.6.6.6上的当前工作目录。</target>
        </trans-unit>
        <trans-unit id="b50df0d2b5baa8b71ef8e15ca44df475f421e8ba" translate="yes" xml:space="preserve">
          <source>This has a small bit of ugliness to it, but the fix is compact and easy to understand. We aren't using bash primitives only, but I'm okay with that because &lt;code&gt;readlink&lt;/code&gt; simplifies the task considerably. The &lt;code&gt;echo X&lt;/code&gt; adds an &lt;code&gt;X&lt;/code&gt; to the end of the variable string so that any trailing whitespace in the filename doesn't get eaten, and the parameter substitution &lt;code&gt;${VAR%X}&lt;/code&gt; at the end of the line gets rid of the &lt;code&gt;X&lt;/code&gt;. Because &lt;code&gt;readlink&lt;/code&gt; adds a newline of its own (which would normally be eaten in the command substitution if not for our previous trickery), we have to get rid of that, too. This is most easily accomplished using the &lt;code&gt;$''&lt;/code&gt; quoting scheme, which lets us use escape sequences such as &lt;code&gt;\n&lt;/code&gt; to represent newlines (this is also how you can easily make deviously named directories and files).</source>
          <target state="translated">这有点丑陋，但修复程序紧凑且易于理解。 我们不仅仅使用bash原语，但我可以接受，因为 &lt;code&gt;readlink&lt;/code&gt; 大大简化了任务。 &lt;code&gt;echo X&lt;/code&gt; 在变量字符串的末尾添加一个 &lt;code&gt;X&lt;/code&gt; ，这样就不会吃掉文件名中的任何结尾空格，并且在行末尾的参数替换 &lt;code&gt;${VAR%X}&lt;/code&gt; 摆脱了 &lt;code&gt;X&lt;/code&gt; 。 由于 &lt;code&gt;readlink&lt;/code&gt; 会添加自己的换行符（如果不使用我们以前的技巧 ，通常会在命令替换中吃掉换行符），所以我们也必须摆脱它。 使用 &lt;code&gt;$''&lt;/code&gt; 引用方案最容易实现这一点，该方案使我们可以使用转义序列（例如 &lt;code&gt;\n&lt;/code&gt; 来表示换行符（这也是您可以轻松地创建明确命名的目录和文件的方式）。</target>
        </trans-unit>
        <trans-unit id="5aa844422368c235d4798b12c5b40f9de43120b8" translate="yes" xml:space="preserve">
          <source>This is Linux specific, but you could use:</source>
          <target state="translated">这是Linux特有的,但你可以使用。</target>
        </trans-unit>
        <trans-unit id="86fd117c80732a5737dd5bfc313248aa05132334" translate="yes" xml:space="preserve">
          <source>This is a slight revision to the solution e-satis and 3bcdnlklvc04a pointed out in &lt;a href=&quot;https://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-in/179231#179231&quot;&gt;their answer&lt;/a&gt;:</source>
          <target state="translated">这是对解决方案e-satis和3bcdnlklvc04a的略微修订， &lt;a href=&quot;https://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-in/179231#179231&quot;&gt;它们&lt;/a&gt;在其答案中指出：</target>
        </trans-unit>
        <trans-unit id="2b6bbbcdc45501c525a87758ecc98df605856ec4" translate="yes" xml:space="preserve">
          <source>This is solved by the following (inside &lt;strong&gt;A&lt;/strong&gt;):</source>
          <target state="translated">这可以通过以下方法解决（在&lt;strong&gt;A内&lt;/strong&gt; ）：</target>
        </trans-unit>
        <trans-unit id="624fd87ddc71cc2f52e33f6b137ca769fdd435b7" translate="yes" xml:space="preserve">
          <source>This last one will work with any combination of aliases, &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;bash -c&lt;/code&gt;, symlinks, etc.</source>
          <target state="translated">这最后一个将与别名， &lt;code&gt;source&lt;/code&gt; ， &lt;code&gt;bash -c&lt;/code&gt; ，symlinks等的任意组合一起使用。</target>
        </trans-unit>
        <trans-unit id="4983e48bae3b4d2a9a56065e7e14eeea962257d4" translate="yes" xml:space="preserve">
          <source>This should do it:</source>
          <target state="translated">这个应该就可以了。</target>
        </trans-unit>
        <trans-unit id="aa4c83ddd30660c0e83b985de4ded174bb141cac" translate="yes" xml:space="preserve">
          <source>This should still work in all the cases they listed.</source>
          <target state="translated">这在他们列出的所有情况下应该还是可以的。</target>
        </trans-unit>
        <trans-unit id="cf9699e13a8ba01954113516dc2f3d41f207c58e" translate="yes" xml:space="preserve">
          <source>This way, you get an absolute, rather then relative directory.</source>
          <target state="translated">这样,你得到的是一个绝对目录,而不是相对目录。</target>
        </trans-unit>
        <trans-unit id="135bc3de061ad99bdf9de61474343b6e2e61806c" translate="yes" xml:space="preserve">
          <source>This will prevent &lt;code&gt;popd&lt;/code&gt; after a failed &lt;code&gt;pushd&lt;/code&gt;, thanks to konsolebox.</source>
          <target state="translated">由于konsolebox，这将防止在失败的推送后弹出。</target>
        </trans-unit>
        <trans-unit id="0f135b85dac7caba81ee8d5eef93c2b91b8b9911" translate="yes" xml:space="preserve">
          <source>This works in bash-3.2:</source>
          <target state="translated">这在bash-3.2中可以使用。</target>
        </trans-unit>
        <trans-unit id="5e15ddfd0077a5cc542009118703466b054f19ef" translate="yes" xml:space="preserve">
          <source>This works with symlinks and spaces in path.</source>
          <target state="translated">这可以用symlinks和路径中的空格。</target>
        </trans-unit>
        <trans-unit id="8ced09545b20da47e415417b4eae8c1d46add0ea" translate="yes" xml:space="preserve">
          <source>This would work on all platforms and is super clean.</source>
          <target state="translated">这在所有平台上都能用,而且超级干净。</target>
        </trans-unit>
        <trans-unit id="a96b4d115e1a2f99afb8930b0cb45b42796745d8" translate="yes" xml:space="preserve">
          <source>To sum up many answers:</source>
          <target state="translated">总结了很多答案。</target>
        </trans-unit>
        <trans-unit id="9affde8f5ff7bf2ca4f7667daf66a026dee38eb7" translate="yes" xml:space="preserve">
          <source>To understand how it works, try running this more verbose form:</source>
          <target state="translated">要了解它是如何工作的,请尝试运行这个更动听的形式。</target>
        </trans-unit>
        <trans-unit id="132b79908b7776a375cc7193c424540ac793a2f9" translate="yes" xml:space="preserve">
          <source>Try the following cross-compatible solution:</source>
          <target state="translated">试试下面的交叉兼容解决方案。</target>
        </trans-unit>
        <trans-unit id="826ada9994010e1474b6c934921317e2b2fc33d2" translate="yes" xml:space="preserve">
          <source>Try this directory on for size:</source>
          <target state="translated">试试这个目录的大小。</target>
        </trans-unit>
        <trans-unit id="38020961644634d637fb2ca7e47c7574cbf790d7" translate="yes" xml:space="preserve">
          <source>Try using:</source>
          <target state="translated">试着使用。</target>
        </trans-unit>
        <trans-unit id="9a452526a7c03b98a7b0cff9b23c4571ffe98669" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;dirname &quot;$0&quot;&lt;/code&gt;:</source>
          <target state="translated">使用 &lt;code&gt;dirname &quot;$0&quot;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="cee68f731daaa055fef6e7d60b2e005a40ccd507" translate="yes" xml:space="preserve">
          <source>Used Commands</source>
          <target state="translated">使用过的命令</target>
        </trans-unit>
        <trans-unit id="a647143996cb15d8f49750108a38d0c04b574b6a" translate="yes" xml:space="preserve">
          <source>Works for all versions,including</source>
          <target state="translated">适用于所有版本,包括</target>
        </trans-unit>
        <trans-unit id="4478c870924518a381357cbdddc6fd2693d6b087" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;$BASH_SOURCE&lt;/code&gt;:</source>
          <target state="translated">您可以使用 &lt;code&gt;$BASH_SOURCE&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="f3e45657c5047bf94cb7ca6a37215e8c261e76dc" translate="yes" xml:space="preserve">
          <source>as the commands such as &lt;code&gt;realpath&lt;/code&gt; or &lt;code&gt;readlink&lt;/code&gt; could be not available (depending on the operating system).</source>
          <target state="translated">因为诸如 &lt;code&gt;realpath&lt;/code&gt; 或 &lt;code&gt;readlink&lt;/code&gt; 之类的命令可能不可用（取决于操作系统）。</target>
        </trans-unit>
        <trans-unit id="3b35d515a2cad2dbe851141ccbc96b335f97be3e" translate="yes" xml:space="preserve">
          <source>is a useful one-liner which will give you the full directory name of the script no matter where it is being called from.</source>
          <target state="translated">是一个有用的单行本,无论脚本从哪里被调用,它都会给你一个完整的目录名。</target>
        </trans-unit>
        <trans-unit id="23a79b97adcea69578a7d61d5b1b5bea3a07c8d0" translate="yes" xml:space="preserve">
          <source>or (&lt;a href=&quot;http://mywiki.wooledge.org/BashFAQ/082&quot;&gt;preferably&lt;/a&gt;):</source>
          <target state="translated">或（ &lt;a href=&quot;http://mywiki.wooledge.org/BashFAQ/082&quot;&gt;最好&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="4a9fbc967654f7ea7a6ba8346e46b6dc14178a2d" translate="yes" xml:space="preserve">
          <source>solves the specific scenario in the question, I find having the absolute path to more more useful generally.</source>
          <target state="translated">解决了问题中的具体方案,我觉得有了绝对的路径,一般情况下更有用。</target>
        </trans-unit>
        <trans-unit id="06e8f4de34464eed78185a34e3f0bf59d4c3790c" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;pwd&lt;/code&gt; alone will not work if you are not running the script from the directory it is contained in.</source>
          <target state="translated">如果不从脚本所在的目录中运行脚本，则仅使用 &lt;code&gt;pwd&lt;/code&gt; 不能正常工作。</target>
        </trans-unit>
        <trans-unit id="5417682a89cadfcccf3667346fea39b977cb8c68" translate="yes" xml:space="preserve">
          <source>when arg &lt;code&gt;$0&lt;/code&gt; is modified from caller.</source>
          <target state="translated">从调用方修改arg &lt;code&gt;$0&lt;/code&gt; 时。</target>
        </trans-unit>
        <trans-unit id="d9aceea7d088301ee05fb56104bb7954812ddde0" translate="yes" xml:space="preserve">
          <source>when called via multple depth soft link,</source>
          <target state="translated">当通过多深度软链路调用时。</target>
        </trans-unit>
        <trans-unit id="5214b91d429aa811e23fe9cdd6fb85ec9ab8f9a3" translate="yes" xml:space="preserve">
          <source>when script called by command &quot;&lt;code&gt;source&lt;/code&gt;&quot; aka &lt;code&gt;.&lt;/code&gt; (dot) operator.</source>
          <target state="translated">当脚本被命令&amp;ldquo; &lt;code&gt;source&lt;/code&gt; &amp;rdquo;调用时 &lt;code&gt;.&lt;/code&gt; （点）运算符。</target>
        </trans-unit>
        <trans-unit id="e87310bd2c8f2488b7a4fb47d9de8ff04e1d2137" translate="yes" xml:space="preserve">
          <source>when the file it</source>
          <target state="translated">文件时,它</target>
        </trans-unit>
        <trans-unit id="ea5bdf31e3db8283bb30dac33b0fe419cb0a6ca2" translate="yes" xml:space="preserve">
          <source>works for me.</source>
          <target state="translated">对我来说很管用</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
