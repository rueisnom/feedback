<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/59895">
    <body>
      <group id="59895">
        <trans-unit id="19a18fc4d4b50e61530b0cfb075c6c2ed407c75d" translate="yes" xml:space="preserve">
          <source>18eedfe1c99df68dc94d4a94712a71aaa8e1e9e36cacf421b9463dd2bbaa02906d0d6656</source>
          <target state="translated">18eedfe1c99df68dc94d4a94712a71aaa8e1e9e36cacf421b9463dd2bbaa02906d0d6656</target>
        </trans-unit>
        <trans-unit id="bf0eaf87a792df5e1034cb33ebb1ee9d074c5b22" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.gnu.org/s/bash/manual/bash.html#Environment&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; is worth mentioning as an alternative to &lt;code&gt;$0&lt;/code&gt;.  If you're running a script from Bash, the accepted answer can be shortened to:</source>
          <target state="translated">&lt;a href=&quot;http://www.gnu.org/s/bash/manual/bash.html#Environment&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; стоит упомянуть как альтернативу &lt;code&gt;$0&lt;/code&gt; . Если вы запускаете скрипт из Bash, принятый ответ может быть сокращен до:</target>
        </trans-unit>
        <trans-unit id="593fbc86ef10e2bd792ac1985c4267c146009c42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SCRIPT_PATH&lt;/code&gt; is given in full path, no matter how it is called.</source>
          <target state="translated">&lt;code&gt;SCRIPT_PATH&lt;/code&gt; задается в полном пути, независимо от того, как он вызывается.</target>
        </trans-unit>
        <trans-unit id="7823bfeac488dfb6d0fa9044c88f386df6a09bf4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pwd&lt;/code&gt; can be used to find the current working directory, and &lt;code&gt;dirname&lt;/code&gt; to find the directory of a particular file (command that was run, is &lt;code&gt;$0&lt;/code&gt;, so &lt;code&gt;dirname $0&lt;/code&gt; should give you the directory of the current script).</source>
          <target state="translated">&lt;code&gt;pwd&lt;/code&gt; может использоваться для поиска текущего рабочего каталога, а &lt;code&gt;dirname&lt;/code&gt; - для поиска каталога определенного файла (команда, которая была запущена, равна &lt;code&gt;$0&lt;/code&gt; , поэтому &lt;code&gt;dirname $0&lt;/code&gt; должна предоставить каталог текущего сценария).</target>
        </trans-unit>
        <trans-unit id="6d18c950a3d7f2476e076d0ab011a954913b53e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readlink&lt;/code&gt; will resolve the script path to an absolute path from the root of the filesystem. So, any paths containing single or double dots, tildes and/or symbolic links will be resolved to a full path.</source>
          <target state="translated">&lt;code&gt;readlink&lt;/code&gt; разрешит путь сценария к абсолютному пути от корня файловой системы. Таким образом, любые пути, содержащие одинарные или двойные точки, тильды и / или символические ссылки, будут преобразованы в полный путь.</target>
        </trans-unit>
        <trans-unit id="0581627fdb0bac69bb25fa3efd994b4e62714351" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt;&lt;/strong&gt; - the full path to the script. The value of this will be correct even when the script is being sourced, e.g. &lt;code&gt;source &amp;lt;(echo 'echo $0')&lt;/code&gt; prints &lt;strong&gt;bash&lt;/strong&gt;, while replacing it with &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; will print the full path of the script. (Of course, this assumes you're OK taking a dependency on Bash.)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; &lt;/strong&gt; - полный путь к скрипту. Значение этого параметра будет правильным даже при получении сценария, например, &lt;code&gt;source &amp;lt;(echo 'echo $0')&lt;/code&gt; печатает &lt;strong&gt;bash&lt;/strong&gt; , а при замене его на &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; будет напечатан полный путь к сценарию. (Конечно, это предполагает, что вы в порядке, принимая зависимость от Bash.)</target>
        </trans-unit>
        <trans-unit id="07ce80449c0b3e3f277e4aeb4c0cb9d5d13239a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;readlink -f&lt;/code&gt;&lt;/strong&gt; - Recursively resolves any symlinks in the specified path. This is a GNU extension, and not available on (for example) BSD systems. If you're running a Mac, you can use Homebrew to install GNU &lt;code&gt;coreutils&lt;/code&gt; and supplant this with &lt;strong&gt;&lt;code&gt;greadlink -f&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;readlink -f&lt;/code&gt; &lt;/strong&gt; - рекурсивно разрешает любые символические ссылки в указанном пути. Это расширение GNU, которое недоступно (например, в системах BSD). Если у вас Mac, вы можете использовать Homebrew для установки GNU &lt;code&gt;coreutils&lt;/code&gt; и заменить его с помощью &lt;strong&gt; &lt;code&gt;greadlink -f&lt;/code&gt; &lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="426fbf2c3b86a3a618cbd3f9d4a86baf50463f6f" translate="yes" xml:space="preserve">
          <source>Absolute paths or relative paths</source>
          <target state="translated">Абсолютные пути или относительные пути</target>
        </trans-unit>
        <trans-unit id="4d5e28e7a0e956bd9e43ce42784d9f9cdb3a1a56" translate="yes" xml:space="preserve">
          <source>Again, but using the full path to the script:</source>
          <target state="translated">Опять же,но используя полный путь к скрипту:</target>
        </trans-unit>
        <trans-unit id="31df5ecd19815d979653fa19bbfcdd3f7579bf3e" translate="yes" xml:space="preserve">
          <source>Also a lot of people assume you're running the script from a shell so they forget when you open a new script it defaults to your home.</source>
          <target state="translated">Также многие люди предполагают,что вы запускаете скрипт из оболочки,так что они забывают,когда вы открываете новый скрипт по умолчанию у себя дома.</target>
        </trans-unit>
        <trans-unit id="5cc881cb0d3b8741b77229be62a98f44e6db9d66" translate="yes" xml:space="preserve">
          <source>Also, watch out for &lt;a href=&quot;http://bosker.wordpress.com/2012/02/12/bash-scripters-beware-of-the-cdpath/&quot;&gt;&lt;code&gt;$CDPATH&lt;/code&gt; gotchas&lt;/a&gt;, and stderr output side effects if the user has smartly overridden cd to redirect output to stderr instead (including escape sequences, such as when calling &lt;code&gt;update_terminal_cwd &amp;gt;&amp;amp;2&lt;/code&gt; on Mac). Adding &lt;code&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; at the end of your &lt;code&gt;cd&lt;/code&gt; command will take care of both possibilities.</source>
          <target state="translated">Кроме того, следите за &lt;a href=&quot;http://bosker.wordpress.com/2012/02/12/bash-scripters-beware-of-the-cdpath/&quot;&gt; &lt;code&gt;$CDPATH&lt;/code&gt; &lt;/a&gt; и побочными эффектами вывода stderr, если пользователь умело переопределил cd для перенаправления вывода на stderr (включая escape-последовательности, например, при вызове &lt;code&gt;update_terminal_cwd &amp;gt;&amp;amp;2&lt;/code&gt; на Mac). Добавление &lt;code&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; в конце вашей команды &lt;code&gt;cd&lt;/code&gt; позаботится об обеих возможностях.</target>
        </trans-unit>
        <trans-unit id="82ae5dde6d9ef2e46a9b902e17c82253e6391ecf" translate="yes" xml:space="preserve">
          <source>Alternatively you can try the following function in bash:</source>
          <target state="translated">В качестве альтернативы вы можете попробовать следующую функцию в bash:</target>
        </trans-unit>
        <trans-unit id="e053cd2da59279d2a0608bc7768f1b1f529d9e11" translate="yes" xml:space="preserve">
          <source>Alternatively, if the bash script itself is a &lt;strong&gt;relative symlink&lt;/strong&gt; you &lt;em&gt;want&lt;/em&gt; to follow it and return the full path of the linked-to script:</source>
          <target state="translated">В качестве альтернативы, если сам скрипт bash является &lt;strong&gt;относительной символической ссылкой,&lt;/strong&gt; вы &lt;em&gt;хотите&lt;/em&gt; перейти по нему и вернуть полный путь связанного сценария:</target>
        </trans-unit>
        <trans-unit id="e969dea8cd5921be63a767f83c70cdc21ad8e248" translate="yes" xml:space="preserve">
          <source>Although just</source>
          <target state="translated">Хотя только</target>
        </trans-unit>
        <trans-unit id="08ff941f8ba378bc98bfbb6b1945c211a1cf671d" translate="yes" xml:space="preserve">
          <source>And finally using a symbolic link to execute the script:</source>
          <target state="translated">И,наконец,использование символической ссылки для выполнения скрипта:</target>
        </trans-unit>
        <trans-unit id="0b7be30335048b9362beef0dcaaa21ecad8777d9" translate="yes" xml:space="preserve">
          <source>And it will print something like:</source>
          <target state="translated">И он напечатает что-нибудь вроде:</target>
        </trans-unit>
        <trans-unit id="abac3354c23bb46705fe1229d339a683605c1ae3" translate="yes" xml:space="preserve">
          <source>And of course &lt;strong&gt;&lt;code&gt;dirname&lt;/code&gt;&lt;/strong&gt; gets the parent directory of the path.</source>
          <target state="translated">И, конечно, &lt;strong&gt; &lt;code&gt;dirname&lt;/code&gt; &lt;/strong&gt; получает родительский каталог пути.</target>
        </trans-unit>
        <trans-unit id="760013e12b493fa6407f1a2ce1efb48c91f8cef6" translate="yes" xml:space="preserve">
          <source>Bash script absolute path with OS X</source>
          <target state="translated">Абсолютный путь бэш-скрипта с OS X</target>
        </trans-unit>
        <trans-unit id="0f28fd68e004022f6abcd795c8d0296f7d6715ac" translate="yes" xml:space="preserve">
          <source>Beware: if you &lt;code&gt;cd&lt;/code&gt; to a different directory before running this snippet, the result may be incorrect!</source>
          <target state="translated">Осторожно: если вы запустили &lt;code&gt;cd&lt;/code&gt; в другой каталог перед запуском этого фрагмента, результат может быть неверным!</target>
        </trans-unit>
        <trans-unit id="2e27eaacc3ad357f5d5f74812ad0688f6b0fc661" translate="yes" xml:space="preserve">
          <source>But, as &lt;strong&gt;matt b&lt;/strong&gt; pointed out, the path returned is different depending on how the script is called. &lt;code&gt;pwd&lt;/code&gt; doesn't do the job because that only tells you what the current directory is, not what directory the script resides in. Additionally, if a symbolic link to a script is executed, you're going to get a (probably relative) path to where the link resides, not the actual script.</source>
          <target state="translated">Но, как указал &lt;strong&gt;matt b&lt;/strong&gt; , возвращаемый путь отличается в зависимости от того, как вызывается скрипт. &lt;code&gt;pwd&lt;/code&gt; не выполняет эту работу, потому что он говорит только о том, что является текущим каталогом, а не в каком каталоге находится скрипт. Кроме того, если выполняется символическая ссылка на скрипт, вы получите (возможно, относительный) путь где находится ссылка, а не фактический скрипт.</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="e0855567fdf07ed8e9074f37448001287e233f16" translate="yes" xml:space="preserve">
          <source>File and directory soft links</source>
          <target state="translated">Программные ссылки на файлы и каталоги</target>
        </trans-unit>
        <trans-unit id="fed5301d79c7b6f1a7c8546ea54449b1afeeeaa5" translate="yes" xml:space="preserve">
          <source>Filenames beginning with a hyphen</source>
          <target state="translated">Фильмы начинаются с дефиса</target>
        </trans-unit>
        <trans-unit id="772062a56cf9b814d3042408e52f123d2ada045a" translate="yes" xml:space="preserve">
          <source>For systems having GNU coreutils &lt;code&gt;readlink&lt;/code&gt; (eg. linux):</source>
          <target state="translated">Для систем, имеющих GNU coreutils &lt;code&gt;readlink&lt;/code&gt; (например, linux):</target>
        </trans-unit>
        <trans-unit id="721536b3b45c387e4bee8ead6b8c3dba91e6d655" translate="yes" xml:space="preserve">
          <source>From the comment track it seems not to work with Mac OS.
I have no idea why that is. Any suggestions?</source>
          <target state="translated">Из комментария кажется,что он не работает с Mac OS.Понятия не имею,почему.Есть предложения?</target>
        </trans-unit>
        <trans-unit id="cc396b4d831b322640a5f760d49c543208d2cfd8" translate="yes" xml:space="preserve">
          <source>Here is a POSIX compliant one-liner:</source>
          <target state="translated">Вот один лайнер,совместимый с POSIX:</target>
        </trans-unit>
        <trans-unit id="7e6caa82bfaa440bd1e01986a8ac88b7f3d089a6" translate="yes" xml:space="preserve">
          <source>Here is an easy-to-remember script:</source>
          <target state="translated">Вот простой для запоминания сценарий:</target>
        </trans-unit>
        <trans-unit id="7a6b9a74a02f93af7c524bc132c55dc467e6be32" translate="yes" xml:space="preserve">
          <source>Here is the simple, correct way:</source>
          <target state="translated">Вот простой,правильный способ:</target>
        </trans-unit>
        <trans-unit id="7e2786c7429ea5f9dc687d1fac3e1e4a84e09bad" translate="yes" xml:space="preserve">
          <source>Here's a script demonstrating each of these, &lt;code&gt;whatdir.sh&lt;/code&gt;:</source>
          <target state="translated">Вот скрипт, демонстрирующий каждый из них, &lt;code&gt;whatdir.sh&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="79d4dc6932c6940edea09332c0a40e4c385f867e" translate="yes" xml:space="preserve">
          <source>Here's an example of its usage:</source>
          <target state="translated">Вот пример его использования:</target>
        </trans-unit>
        <trans-unit id="f67626bb87966ae92799fbed14c52f02b6a20974" translate="yes" xml:space="preserve">
          <source>Hmm, if in the path basename &amp;amp; dirname are just not going to cut it
and walking the path is hard (what if parent didn't export PATH!).
However, the shell has to have an open handle to its script, and in
bash the handle is #255.</source>
          <target state="translated">Хм, если в пути basename и dirname просто не собираются его обрезать, и пройти путь сложно (что если родитель не экспортировал PATH!). Однако оболочка должна иметь открытый дескриптор своего скрипта, а в bash дескриптор # 255.</target>
        </trans-unit>
        <trans-unit id="2c514cd534e6b677e18c9f6ef72d1038f975e863" translate="yes" xml:space="preserve">
          <source>How do I get the path of the directory in which a &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; script is located, &lt;em&gt;inside&lt;/em&gt; that script?</source>
          <target state="translated">Как мне получить путь к каталогу, в котором находится скрипт &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; , &lt;em&gt;внутри&lt;/em&gt; этого скрипта?</target>
        </trans-unit>
        <trans-unit id="e94507b21cbe42200554606d16c3782465fae406" translate="yes" xml:space="preserve">
          <source>How to get the source directory of a Bash script from within the script itself</source>
          <target state="translated">Как получить исходный каталог Bash скрипта из самого скрипта.</target>
        </trans-unit>
        <trans-unit id="15565602373c482c48a874ebd82fe09c139ba724" translate="yes" xml:space="preserve">
          <source>How to set current working directory to the directory of the script?</source>
          <target state="translated">Как установить текущий рабочий каталог в каталог скрипта?</target>
        </trans-unit>
        <trans-unit id="c1dc3b40f2fb5f6b76faaa750db69827966305ce" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;dirname&lt;/code&gt; gives precisely the directory portion of the filename, which more likely than not is going to be relative to the current working directory. If your script needs to change directory for some reason, then the output from &lt;code&gt;dirname&lt;/code&gt; becomes meaningless.</source>
          <target state="translated">Тем не менее, &lt;code&gt;dirname&lt;/code&gt; дает именно ту часть каталога с именем файла, которая, скорее всего, будет относительно текущего рабочего каталога. Если вашему сценарию необходимо изменить каталог по какой-то причине, вывод &lt;code&gt;dirname&lt;/code&gt; становится бессмысленным.</target>
        </trans-unit>
        <trans-unit id="fd781f58f78adcaf88471d8e16c79fde52b8abc9" translate="yes" xml:space="preserve">
          <source>I am tired of coming to this page over and over to copy paste the one-liner in the accepted answer. The problem with that is it is not easy to understand and remember.</source>
          <target state="translated">Я устал приходить на эту страницу снова и снова,чтобы скопировать вставьте один лайнер в принятый ответ.Проблема в том,что это нелегко понять и запомнить.</target>
        </trans-unit>
        <trans-unit id="c65940fe653c04e6d217fd71b5bc36c973d94e09" translate="yes" xml:space="preserve">
          <source>I believe I've got this one. I'm late to the party, but I think some will appreciate it being here if they come across this thread. The comments should explain:</source>
          <target state="translated">Кажется,у меня есть вот это.Я опаздываю на вечеринку,но думаю,некоторые оценят,что они здесь,если наткнутся на эту нить.Комментарии должны объяснить:</target>
        </trans-unit>
        <trans-unit id="a5564a6ec07273d60ff4548ab635ae9209aad476" translate="yes" xml:space="preserve">
          <source>I don't think this is as easy as others have made it out to be.  &lt;code&gt;pwd&lt;/code&gt; doesn't work, as the current directory is not necessarily the directory with the script.  &lt;code&gt;$0&lt;/code&gt; doesn't always have the information either.  Consider the following three ways to invoke a script:</source>
          <target state="translated">Я не думаю, что это так просто, как это сделали другие. &lt;code&gt;pwd&lt;/code&gt; не работает, так как текущий каталог не обязательно является каталогом со скриптом. &lt;code&gt;$0&lt;/code&gt; тоже не всегда имеет информацию. Рассмотрим следующие три способа вызова скрипта:</target>
        </trans-unit>
        <trans-unit id="314e2d8c80409f81525019944bae934fac7d14de" translate="yes" xml:space="preserve">
          <source>I suggest the following:</source>
          <target state="translated">Я предлагаю следующее:</target>
        </trans-unit>
        <trans-unit id="2ff8ae24228298e42c1024dc75a685fff4c70183" translate="yes" xml:space="preserve">
          <source>I tried all of these and none worked. One was very close but had a tiny bug that broke it badly; they forgot to wrap the path in quotation marks.</source>
          <target state="translated">Я перепробовал все это и ничто не сработало.Один из них был очень близко,но у него был крошечный жучок,который плохо его сломал;они забыли обернуть путь в кавычки.</target>
        </trans-unit>
        <trans-unit id="fedbbd02f03e12ac9d3beeef3636203bf88f7cb9" translate="yes" xml:space="preserve">
          <source>I want to use a Bash script as a launcher for another application. I want to change the working directory to the one where the Bash script is located, so I can operate on the files in that directory, like so:</source>
          <target state="translated">Я хочу использовать Bash скрипт в качестве запуска для другого приложения.Я хочу изменить рабочую директорию на ту,где расположен Bash скрипт,чтобы я мог работать с файлами в этой директории:</target>
        </trans-unit>
        <trans-unit id="ce81d457123493a7d7d88fddc69383893c3220b7" translate="yes" xml:space="preserve">
          <source>I would use something like this:</source>
          <target state="translated">Я бы использовал что-нибудь подобное:</target>
        </trans-unit>
        <trans-unit id="2171f703ddd878f550591c0e07925f51cc2b067b" translate="yes" xml:space="preserve">
          <source>I've compared many of the answers given, and come up with some more compact solutions. These seem to handle all of the crazy edge cases that arise from your favorite combination of:</source>
          <target state="translated">Я сравнил многие из полученных ответов и придумал несколько более компактных решений.Они,кажется,справляются со всеми сумасшедшими делами по краям,которые возникают из вашей любимой комбинации:</target>
        </trans-unit>
        <trans-unit id="e58b329aff37f278c76fdb1e35272c1bf2d42971" translate="yes" xml:space="preserve">
          <source>If you're running from Linux, it seems that using the &lt;code&gt;proc&lt;/code&gt; handle is the best solution to locate the fully resolved source of the currently running script (in an interactive session, the link points to the respective &lt;code&gt;/dev/pts/X&lt;/code&gt;):</source>
          <target state="translated">Если вы работаете в Linux, кажется, что использование дескриптора &lt;code&gt;proc&lt;/code&gt; является лучшим решением для поиска полностью разрешенного источника запущенного в данный момент скрипта (в интерактивном сеансе ссылка указывает на соответствующий &lt;code&gt;/dev/pts/X&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="f5006f4b7d8d744f73e4fc441d26d052cf92f989" translate="yes" xml:space="preserve">
          <source>In the first and third ways &lt;code&gt;$0&lt;/code&gt; doesn't have the full path information.  In the second and third, &lt;code&gt;pwd&lt;/code&gt; does not work.  The only way to get the directory in the third way would be to run through the path and find the file with the correct match.  Basically the code would have to redo what the OS does.</source>
          <target state="translated">В первом и третьем способах &lt;code&gt;$0&lt;/code&gt; не имеет полной информации о пути. Во втором и третьем &lt;code&gt;pwd&lt;/code&gt; не работает. Единственный способ получить каталог третьим способом - это запустить путь и найти файл с правильным соответствием. В основном код должен был бы переделывать то, что делает ОС.</target>
        </trans-unit>
        <trans-unit id="bb7c16b349eb08b9c0b10fa5d3251652f7054cc9" translate="yes" xml:space="preserve">
          <source>Invocation as &lt;code&gt;script&lt;/code&gt;, &lt;code&gt;bash script&lt;/code&gt;, &lt;code&gt;bash -c script&lt;/code&gt;, &lt;code&gt;source script&lt;/code&gt;, or &lt;code&gt;. script&lt;/code&gt;</source>
          <target state="translated">Вызов в качестве &lt;code&gt;script&lt;/code&gt; , сценария &lt;code&gt;bash script&lt;/code&gt; &lt;code&gt;bash -c script&lt;/code&gt; , &lt;code&gt;source script&lt;/code&gt; или &lt;code&gt;. script&lt;/code&gt; скрипт</target>
        </trans-unit>
        <trans-unit id="a02f22ad602d2ef6e382c04099658f152ab19842" translate="yes" xml:space="preserve">
          <source>It doesn't matter where the user is or how he calls the script, this will always work.</source>
          <target state="translated">Неважно,где пользователь и как он вызывает скрипт,это всегда будет работать.</target>
        </trans-unit>
        <trans-unit id="38bb10b3d907511b9279efee2507d873a4fc242c" translate="yes" xml:space="preserve">
          <source>It will work as long as the last component of the path used to find the script is not a symlink (directory links are OK).  If you also want to resolve any links to the script itself, you need a multi-line solution:</source>
          <target state="translated">Он будет работать до тех пор,пока последний компонент пути,используемого для поиска скрипта,не является сим-ссылкой (ссылки на каталоги OK).Если вы также хотите разрешить любые ссылки на сам скрипт,вам нужно многострочное решение:</target>
        </trans-unit>
        <trans-unit id="4605dc46bd09b4eaa7af587e1386b633fdeb4323" translate="yes" xml:space="preserve">
          <source>Just make sure you locate this at start of the script.</source>
          <target state="translated">Просто убедитесь,что нашли это в начале сценария.</target>
        </trans-unit>
        <trans-unit id="624f152e5413ea8ae957872eddedd2d49c644430" translate="yes" xml:space="preserve">
          <source>More details can be found in &quot;&lt;a href=&quot;https://www.electrictoolbox.com/bash-script-directory/&quot;&gt;Which directory is that bash script in?&lt;/a&gt;&quot;.</source>
          <target state="translated">Более подробную информацию можно найти в &lt;a href=&quot;https://www.electrictoolbox.com/bash-script-directory/&quot;&gt;разделе&lt;/a&gt; &amp;laquo;В каком каталоге находится этот bash-скрипт? &amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0a0d73ad9eb09a3f63bbc70b597f635f18a702db" translate="yes" xml:space="preserve">
          <source>Note that this has to be the first statement in your script.</source>
          <target state="translated">Обратите внимание,что это должно быть первое утверждение в вашем сценарии.</target>
        </trans-unit>
        <trans-unit id="3d775fc4bf5f21ab130d923a6fabfc949f661ed4" translate="yes" xml:space="preserve">
          <source>Note that you need to use &lt;code&gt;#!/bin/bash&lt;/code&gt; and not &lt;code&gt;#!/bin/sh&lt;/code&gt; since it's a Bash extension.</source>
          <target state="translated">Обратите внимание, что вам нужно использовать &lt;code&gt;#!/bin/bash&lt;/code&gt; а не &lt;code&gt;#!/bin/sh&lt;/code&gt; так как это расширение Bash.</target>
        </trans-unit>
        <trans-unit id="1ad78cc1e56befe9d3d057f04c18efb0f0ba1ffd" translate="yes" xml:space="preserve">
          <source>Note: In Bash, it's recommended to use&lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; instead of &lt;code&gt;$0&lt;/code&gt;, otherwise path can break when sourcing the file (&lt;code&gt;source&lt;/code&gt;/&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="translated">Примечание. В Bash рекомендуется использовать &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; вместо &lt;code&gt;$0&lt;/code&gt; , в противном случае путь может оборваться при поиске файла ( &lt;code&gt;source&lt;/code&gt; / &lt;code&gt;.&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="498c8b437a7497a048fd6a708c55520b984927c0" translate="yes" xml:space="preserve">
          <source>Now changing directories:</source>
          <target state="translated">Теперь меняю каталоги:</target>
        </trans-unit>
        <trans-unit id="2cbc4a1754fa2b1a92f79674fc1cded648d99d4c" translate="yes" xml:space="preserve">
          <source>One way to do what you are asking would be to just hardcode the data in the &lt;code&gt;/usr/share&lt;/code&gt; directory, and reference it by its full path.  Data shoudn't be in the &lt;code&gt;/usr/bin&lt;/code&gt; directory anyway, so this is probably the thing to do.</source>
          <target state="translated">Один из способов сделать то, что вы просите, - это просто жестко закодировать данные в каталоге &lt;code&gt;/usr/share&lt;/code&gt; и ссылаться на них по полному пути. В любом случае, данные не должны находиться в каталоге &lt;code&gt;/usr/bin&lt;/code&gt; , так что это, вероятно, то, что нужно сделать.</target>
        </trans-unit>
        <trans-unit id="39c788876858d9fdd3ed2ab494830cb7baca1db1" translate="yes" xml:space="preserve">
          <source>Related:</source>
          <target state="translated">Related:</target>
        </trans-unit>
        <trans-unit id="a9d017586904a386f0684539c8f132954aec5924" translate="yes" xml:space="preserve">
          <source>Reliable way for a Bash script to get the full path to itself</source>
          <target state="translated">Надежный способ для Бэш-скрипта получить полный путь к самому себе.</target>
        </trans-unit>
        <trans-unit id="d02835a79470dbbc2e975df36f0e76821643fa48" translate="yes" xml:space="preserve">
          <source>Running this script in my home dir, using a relative path:</source>
          <target state="translated">Запуск этого сценария в моем домашнем дире,используя относительный путь:</target>
        </trans-unit>
        <trans-unit id="0310b5ce654c85162f919b8cb40084ecbe9c6fae" translate="yes" xml:space="preserve">
          <source>Say you have a &lt;strong&gt;~/bin&lt;/strong&gt; directory, which is in your &lt;strong&gt;$PATH&lt;/strong&gt;. You have script &lt;strong&gt;A&lt;/strong&gt; inside this directory. It &lt;strong&gt;source&lt;/strong&gt;s script &lt;strong&gt;~/bin/lib/B&lt;/strong&gt;. You know where the included script is relative to the original one (the subdirectory &lt;strong&gt;lib&lt;/strong&gt;), but not where it is relative to the user's current directory.</source>
          <target state="translated">Допустим, у вас есть каталог &lt;strong&gt;~ / bin&lt;/strong&gt; , который находится в вашем &lt;strong&gt;$ PATH&lt;/strong&gt; . У вас есть скрипт &lt;strong&gt;А&lt;/strong&gt; внутри этого каталога. Это &lt;strong&gt;исходный&lt;/strong&gt; текст сценария &lt;strong&gt;~ / bin / lib / B.&lt;/strong&gt; Вы знаете, где включенный скрипт относительно исходного (подкаталог &lt;strong&gt;lib&lt;/strong&gt; ), но не где он относительно текущего каталога пользователя.</target>
        </trans-unit>
        <trans-unit id="08c0715b171236193ef556a3e6ee0e0d4b8a54d0" translate="yes" xml:space="preserve">
          <source>See
&lt;a href=&quot;https://pastebin.com/J8KjxrPF&quot;&gt;https://pastebin.com/J8KjxrPF&lt;/a&gt;</source>
          <target state="translated">See
&lt;a href=&quot;https://pastebin.com/J8KjxrPF&quot;&gt;https://pastebin.com/J8KjxrPF&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="179405fffe479820e45c426b988de99252c1cd22" translate="yes" xml:space="preserve">
          <source>See the man pages for &lt;code&gt;dirname&lt;/code&gt; and &lt;code&gt;readlink&lt;/code&gt;.</source>
          <target state="translated">Смотрите справочные страницы для &lt;code&gt;dirname&lt;/code&gt; и &lt;code&gt;readlink&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6b3f2bbd8222358a7517260fde7e7932a399471" translate="yes" xml:space="preserve">
          <source>Short answer:</source>
          <target state="translated">Короткий ответ:</target>
        </trans-unit>
        <trans-unit id="a0d149ae2639019b6c5406830fed3b68dbc7b252" translate="yes" xml:space="preserve">
          <source>Since the script will be run in a separate bash instance, there is no need to restore the working directory afterwards, but if you do want to change back in your script for some reason, you can easily assign the value of &lt;code&gt;pwd&lt;/code&gt; to a variable before you change directory, for future use.</source>
          <target state="translated">Поскольку скрипт будет запускаться в отдельном экземпляре bash, нет необходимости впоследствии восстанавливать рабочий каталог, но если вы по какой-то причине захотите вернуться обратно в свой скрипт, вы можете легко присвоить значение &lt;code&gt;pwd&lt;/code&gt; переменной до Вы меняете каталог, для будущего использования.</target>
        </trans-unit>
        <trans-unit id="bf31e1601b7845dedc267cf1517109936836664c" translate="yes" xml:space="preserve">
          <source>So to make it actually useful here's how to change to the directory of the running script:</source>
          <target state="translated">Итак,чтобы сделать его действительно полезным,вот как изменить каталог выполняемого скрипта:</target>
        </trans-unit>
        <trans-unit id="9e8c62d67f4534baba003d7d0611dac78c2ec24b" translate="yes" xml:space="preserve">
          <source>Some others have mentioned the &lt;code&gt;readlink&lt;/code&gt; command, but at its simplest, you can use:</source>
          <target state="translated">Некоторые другие упоминали команду &lt;code&gt;readlink&lt;/code&gt; , но в ее простейшем случае вы можете использовать:</target>
        </trans-unit>
        <trans-unit id="972566de850ad7f90e9bb841308fa335acf3511e" translate="yes" xml:space="preserve">
          <source>Spaces, tabs, newlines, unicode, etc. in directories and/or filename</source>
          <target state="translated">Пробелы,закладки,новые строки,юникод и т.д.в каталогах андоры и имя файла</target>
        </trans-unit>
        <trans-unit id="1ec65979ffd82e8d4fe3bade4ddad36f365785d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dirname&lt;/code&gt; command is the most basic, simply parsing the path up to the filename off of the &lt;code&gt;$0&lt;/code&gt; (script name) variable:</source>
          <target state="translated">Команда &lt;code&gt;dirname&lt;/code&gt; является самой простой, просто анализируя путь к имени файла из переменной &lt;code&gt;$0&lt;/code&gt; (имя скрипта):</target>
        </trans-unit>
        <trans-unit id="c2502d6f2d208ee4aa0c27823d3f504b519b349d" translate="yes" xml:space="preserve">
          <source>The above should cover your needs for locating the currently running script on Linux, but if you don't have the &lt;code&gt;proc&lt;/code&gt; filesystem at your disposal, or if you're trying to locate the fully resolved path of some other file, then maybe you'll find the below code helpful. It's only a slight modification from the above one-liner. If you're playing around with strange directory/filenames, checking the output with both &lt;code&gt;ls&lt;/code&gt; and &lt;code&gt;readlink&lt;/code&gt; is informative, as &lt;code&gt;ls&lt;/code&gt; will output &quot;simplified&quot; paths, substituting &lt;code&gt;?&lt;/code&gt; for things like newlines.</source>
          <target state="translated">Вышеприведенное должно охватывать ваши потребности в поиске текущего запущенного скрипта в Linux, но если у вас нет файловой системы &lt;code&gt;proc&lt;/code&gt; в вашем распоряжении, или если вы пытаетесь найти полностью разрешенный путь какого-либо другого файла, то, возможно, вы ' Вы найдете следующий код полезным. Это всего лишь небольшая модификация вышеупомянутой однострочной. Если вы играете со странными каталогами / именами файлов, проверка вывода с помощью &lt;code&gt;ls&lt;/code&gt; и &lt;code&gt;readlink&lt;/code&gt; информативна, так как &lt;code&gt;ls&lt;/code&gt; выведет &amp;laquo;упрощенные&amp;raquo; пути, заменяя &lt;code&gt;?&lt;/code&gt; для таких вещей, как перевод строки.</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">Выход:</target>
        </trans-unit>
        <trans-unit id="1ba8640e9fee25016a4dad8164c1faefe6e9b381" translate="yes" xml:space="preserve">
          <source>The shortest and most elegant way to do this is:</source>
          <target state="translated">Самый короткий и элегантный способ сделать это:</target>
        </trans-unit>
        <trans-unit id="5f00be7ce17d97d6d2b8ad5eedab1814c2f7db86" translate="yes" xml:space="preserve">
          <source>There's no need to use &lt;code&gt;BASH_SOURCE&lt;/code&gt; when &lt;code&gt;$0&lt;/code&gt; contains the script filename.</source>
          <target state="translated">Нет необходимости использовать &lt;code&gt;BASH_SOURCE&lt;/code&gt; , когда &lt;code&gt;$0&lt;/code&gt; содержит имя файла сценария.</target>
        </trans-unit>
        <trans-unit id="708db81f22b4189fbca177dd22f22687e2096158" translate="yes" xml:space="preserve">
          <source>This comment and code Copyleft, selectable license under the GPL2.0 or later or CC-SA 3.0  (CreativeCommons Share Alike) or later. (c) 2008. All rights reserved. No warranty of any kind. You have been warned.</source>
          <target state="translated">Этот комментарий и код с авторским левом,выбираемая лицензия по GPL2.0 или более поздней версии,или CC-SA 3.0 (CreativeCommons Share Alike)или более поздней версии.(c)2008.Все права защищены.Никаких гарантий.Вы были предупреждены.</target>
        </trans-unit>
        <trans-unit id="9b87a680ec2f32548e3f66bb1cd9591fa03074fb" translate="yes" xml:space="preserve">
          <source>This function takes 1 argument. If argument has already absolute path, print it as it is, otherwise print &lt;code&gt;$PWD&lt;/code&gt; variable + filename argument (without &lt;code&gt;./&lt;/code&gt; prefix).</source>
          <target state="translated">Эта функция принимает 1 аргумент. Если аргумент уже имеет абсолютный путь, выведите его как есть, в противном случае выведите переменную &lt;code&gt;$PWD&lt;/code&gt; + аргумент имени файла (без префикса &lt;code&gt;./&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1fbe2218965d16cf412a3cb4e57e7dabce8dfa88" translate="yes" xml:space="preserve">
          <source>This gets it right regardless how or where you run it:</source>
          <target state="translated">Это дает правильный результат,независимо от того,как и где ты его запускаешь:</target>
        </trans-unit>
        <trans-unit id="e6228e8bc7f23574e8589322511f54bee4d824b4" translate="yes" xml:space="preserve">
          <source>This gets the current working directory on Mac OS X 10.6.6:</source>
          <target state="translated">В результате получается текущая рабочая директория на Mac OS X 10.6.6:</target>
        </trans-unit>
        <trans-unit id="b50df0d2b5baa8b71ef8e15ca44df475f421e8ba" translate="yes" xml:space="preserve">
          <source>This has a small bit of ugliness to it, but the fix is compact and easy to understand. We aren't using bash primitives only, but I'm okay with that because &lt;code&gt;readlink&lt;/code&gt; simplifies the task considerably. The &lt;code&gt;echo X&lt;/code&gt; adds an &lt;code&gt;X&lt;/code&gt; to the end of the variable string so that any trailing whitespace in the filename doesn't get eaten, and the parameter substitution &lt;code&gt;${VAR%X}&lt;/code&gt; at the end of the line gets rid of the &lt;code&gt;X&lt;/code&gt;. Because &lt;code&gt;readlink&lt;/code&gt; adds a newline of its own (which would normally be eaten in the command substitution if not for our previous trickery), we have to get rid of that, too. This is most easily accomplished using the &lt;code&gt;$''&lt;/code&gt; quoting scheme, which lets us use escape sequences such as &lt;code&gt;\n&lt;/code&gt; to represent newlines (this is also how you can easily make deviously named directories and files).</source>
          <target state="translated">Это немного уродливо, но исправление компактно и легко для понимания. Мы не используем только примитивы bash, но я согласен с этим, потому что &lt;code&gt;readlink&lt;/code&gt; значительно упрощает задачу. &lt;code&gt;echo X&lt;/code&gt; добавляет &lt;code&gt;X&lt;/code&gt; в конец строки переменной, так что любые пробелы в имени файла не съедаются, а подстановка параметра &lt;code&gt;${VAR%X}&lt;/code&gt; в конце строки избавляется от &lt;code&gt;X&lt;/code&gt; . Поскольку &lt;code&gt;readlink&lt;/code&gt; добавляет собственную новую строку (которая обычно используется в подстановке команд, если бы не наш предыдущий трюк), мы также должны избавиться от этого. Этого легче всего достичь, используя схему цитирования &lt;code&gt;$''&lt;/code&gt; , которая позволяет нам использовать escape-последовательности, такие как &lt;code&gt;\n&lt;/code&gt; для представления новых строк (это также то, как вы можете легко создавать каталоги и файлы с коварными именами).</target>
        </trans-unit>
        <trans-unit id="5aa844422368c235d4798b12c5b40f9de43120b8" translate="yes" xml:space="preserve">
          <source>This is Linux specific, but you could use:</source>
          <target state="translated">Это специфично для Linux,но вы можете использовать его:</target>
        </trans-unit>
        <trans-unit id="86fd117c80732a5737dd5bfc313248aa05132334" translate="yes" xml:space="preserve">
          <source>This is a slight revision to the solution e-satis and 3bcdnlklvc04a pointed out in &lt;a href=&quot;https://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-in/179231#179231&quot;&gt;their answer&lt;/a&gt;:</source>
          <target state="translated">Это небольшой пересмотр решения e-sat, и 3bcdnlklvc04a указал в &lt;a href=&quot;https://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-in/179231#179231&quot;&gt;своем ответе&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2b6bbbcdc45501c525a87758ecc98df605856ec4" translate="yes" xml:space="preserve">
          <source>This is solved by the following (inside &lt;strong&gt;A&lt;/strong&gt;):</source>
          <target state="translated">Это решается следующим (внутри &lt;strong&gt;А&lt;/strong&gt; ):</target>
        </trans-unit>
        <trans-unit id="624fd87ddc71cc2f52e33f6b137ca769fdd435b7" translate="yes" xml:space="preserve">
          <source>This last one will work with any combination of aliases, &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;bash -c&lt;/code&gt;, symlinks, etc.</source>
          <target state="translated">Этот последний будет работать с любой комбинацией псевдонимов, &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;bash -c&lt;/code&gt; , символических ссылок и т. Д.</target>
        </trans-unit>
        <trans-unit id="4983e48bae3b4d2a9a56065e7e14eeea962257d4" translate="yes" xml:space="preserve">
          <source>This should do it:</source>
          <target state="translated">Это должно сработать:</target>
        </trans-unit>
        <trans-unit id="aa4c83ddd30660c0e83b985de4ded174bb141cac" translate="yes" xml:space="preserve">
          <source>This should still work in all the cases they listed.</source>
          <target state="translated">Это все равно должно сработать во всех перечисленных ими случаях.</target>
        </trans-unit>
        <trans-unit id="cf9699e13a8ba01954113516dc2f3d41f207c58e" translate="yes" xml:space="preserve">
          <source>This way, you get an absolute, rather then relative directory.</source>
          <target state="translated">Таким образом,вы получаете абсолютный,а не относительный каталог.</target>
        </trans-unit>
        <trans-unit id="135bc3de061ad99bdf9de61474343b6e2e61806c" translate="yes" xml:space="preserve">
          <source>This will prevent &lt;code&gt;popd&lt;/code&gt; after a failed &lt;code&gt;pushd&lt;/code&gt;, thanks to konsolebox.</source>
          <target state="translated">Это предотвратит &lt;code&gt;popd&lt;/code&gt; после неудачного &lt;code&gt;pushd&lt;/code&gt; благодаря konsolebox.</target>
        </trans-unit>
        <trans-unit id="0f135b85dac7caba81ee8d5eef93c2b91b8b9911" translate="yes" xml:space="preserve">
          <source>This works in bash-3.2:</source>
          <target state="translated">Это работает в Баш-3.2:</target>
        </trans-unit>
        <trans-unit id="5e15ddfd0077a5cc542009118703466b054f19ef" translate="yes" xml:space="preserve">
          <source>This works with symlinks and spaces in path.</source>
          <target state="translated">Это работает с симлинками и пространствами на пути.</target>
        </trans-unit>
        <trans-unit id="8ced09545b20da47e415417b4eae8c1d46add0ea" translate="yes" xml:space="preserve">
          <source>This would work on all platforms and is super clean.</source>
          <target state="translated">Это сработает на всех платформах и будет очень чисто.</target>
        </trans-unit>
        <trans-unit id="a96b4d115e1a2f99afb8930b0cb45b42796745d8" translate="yes" xml:space="preserve">
          <source>To sum up many answers:</source>
          <target state="translated">Подводя итог многим ответам:</target>
        </trans-unit>
        <trans-unit id="9affde8f5ff7bf2ca4f7667daf66a026dee38eb7" translate="yes" xml:space="preserve">
          <source>To understand how it works, try running this more verbose form:</source>
          <target state="translated">Чтобы понять,как это работает,попробуйте запустить эту более многословную форму:</target>
        </trans-unit>
        <trans-unit id="132b79908b7776a375cc7193c424540ac793a2f9" translate="yes" xml:space="preserve">
          <source>Try the following cross-compatible solution:</source>
          <target state="translated">Попробуйте следующее кросс-совместимое решение:</target>
        </trans-unit>
        <trans-unit id="826ada9994010e1474b6c934921317e2b2fc33d2" translate="yes" xml:space="preserve">
          <source>Try this directory on for size:</source>
          <target state="translated">Попробуйте этот каталог на размер:</target>
        </trans-unit>
        <trans-unit id="38020961644634d637fb2ca7e47c7574cbf790d7" translate="yes" xml:space="preserve">
          <source>Try using:</source>
          <target state="translated">Попробуй использовать:</target>
        </trans-unit>
        <trans-unit id="9a452526a7c03b98a7b0cff9b23c4571ffe98669" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;dirname &quot;$0&quot;&lt;/code&gt;:</source>
          <target state="translated">Используйте &lt;code&gt;dirname &quot;$0&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cee68f731daaa055fef6e7d60b2e005a40ccd507" translate="yes" xml:space="preserve">
          <source>Used Commands</source>
          <target state="translated">Использованные команды</target>
        </trans-unit>
        <trans-unit id="a647143996cb15d8f49750108a38d0c04b574b6a" translate="yes" xml:space="preserve">
          <source>Works for all versions,including</source>
          <target state="translated">Работает для всех версий,включая</target>
        </trans-unit>
        <trans-unit id="4478c870924518a381357cbdddc6fd2693d6b087" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;$BASH_SOURCE&lt;/code&gt;:</source>
          <target state="translated">Вы можете использовать &lt;code&gt;$BASH_SOURCE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f3e45657c5047bf94cb7ca6a37215e8c261e76dc" translate="yes" xml:space="preserve">
          <source>as the commands such as &lt;code&gt;realpath&lt;/code&gt; or &lt;code&gt;readlink&lt;/code&gt; could be not available (depending on the operating system).</source>
          <target state="translated">поскольку такие команды, как &lt;code&gt;realpath&lt;/code&gt; или &lt;code&gt;readlink&lt;/code&gt; , могут быть недоступны (в зависимости от операционной системы).</target>
        </trans-unit>
        <trans-unit id="3b35d515a2cad2dbe851141ccbc96b335f97be3e" translate="yes" xml:space="preserve">
          <source>is a useful one-liner which will give you the full directory name of the script no matter where it is being called from.</source>
          <target state="translated">это полезный одиночный лайнер,который даст вам полное имя каталога скрипта независимо от того,откуда он вызывается.</target>
        </trans-unit>
        <trans-unit id="23a79b97adcea69578a7d61d5b1b5bea3a07c8d0" translate="yes" xml:space="preserve">
          <source>or (&lt;a href=&quot;http://mywiki.wooledge.org/BashFAQ/082&quot;&gt;preferably&lt;/a&gt;):</source>
          <target state="translated">или ( &lt;a href=&quot;http://mywiki.wooledge.org/BashFAQ/082&quot;&gt;предпочтительно&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="4a9fbc967654f7ea7a6ba8346e46b6dc14178a2d" translate="yes" xml:space="preserve">
          <source>solves the specific scenario in the question, I find having the absolute path to more more useful generally.</source>
          <target state="translated">решает конкретный сценарий в вопросе,на мой взгляд,имея абсолютный путь к более полезному в целом.</target>
        </trans-unit>
        <trans-unit id="06e8f4de34464eed78185a34e3f0bf59d4c3790c" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;pwd&lt;/code&gt; alone will not work if you are not running the script from the directory it is contained in.</source>
          <target state="translated">использование только &lt;code&gt;pwd&lt;/code&gt; не будет работать, если вы не запускаете скрипт из каталога, в котором он находится.</target>
        </trans-unit>
        <trans-unit id="5417682a89cadfcccf3667346fea39b977cb8c68" translate="yes" xml:space="preserve">
          <source>when arg &lt;code&gt;$0&lt;/code&gt; is modified from caller.</source>
          <target state="translated">когда arg &lt;code&gt;$0&lt;/code&gt; изменяется от вызывающей стороны.</target>
        </trans-unit>
        <trans-unit id="d9aceea7d088301ee05fb56104bb7954812ddde0" translate="yes" xml:space="preserve">
          <source>when called via multple depth soft link,</source>
          <target state="translated">при вызове через мягкую связь multple depth,</target>
        </trans-unit>
        <trans-unit id="5214b91d429aa811e23fe9cdd6fb85ec9ab8f9a3" translate="yes" xml:space="preserve">
          <source>when script called by command &quot;&lt;code&gt;source&lt;/code&gt;&quot; aka &lt;code&gt;.&lt;/code&gt; (dot) operator.</source>
          <target state="translated">когда скрипт вызывается командой &quot; &lt;code&gt;source&lt;/code&gt; &quot; ака &lt;code&gt;.&lt;/code&gt; (точка) оператор.</target>
        </trans-unit>
        <trans-unit id="e87310bd2c8f2488b7a4fb47d9de8ff04e1d2137" translate="yes" xml:space="preserve">
          <source>when the file it</source>
          <target state="translated">когда файл</target>
        </trans-unit>
        <trans-unit id="ea5bdf31e3db8283bb30dac33b0fe419cb0a6ca2" translate="yes" xml:space="preserve">
          <source>works for me.</source>
          <target state="translated">работает на меня.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
