<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/59895">
    <body>
      <group id="59895">
        <trans-unit id="19a18fc4d4b50e61530b0cfb075c6c2ed407c75d" translate="yes" xml:space="preserve">
          <source>18eedfe1c99df68dc94d4a94712a71aaa8e1e9e36cacf421b9463dd2bbaa02906d0d6656</source>
          <target state="translated">18eedfe1c99df68dc94d4a94712a71aaa8e1e9e36cacf421b9463dd2bbaa02906d0d6656</target>
        </trans-unit>
        <trans-unit id="bf0eaf87a792df5e1034cb33ebb1ee9d074c5b22" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.gnu.org/s/bash/manual/bash.html#Environment&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; is worth mentioning as an alternative to &lt;code&gt;$0&lt;/code&gt;.  If you're running a script from Bash, the accepted answer can be shortened to:</source>
          <target state="translated">&lt;a href=&quot;http://www.gnu.org/s/bash/manual/bash.html#Environment&quot;&gt; &lt;code&gt;$_&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;$0&lt;/code&gt; 의 대안으로 언급 할 가치가 있습니다. Bash에서 스크립트를 실행하는 경우 허용되는 답변을 다음과 같이 단축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="593fbc86ef10e2bd792ac1985c4267c146009c42" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;SCRIPT_PATH&lt;/code&gt; is given in full path, no matter how it is called.</source>
          <target state="translated">&lt;code&gt;SCRIPT_PATH&lt;/code&gt; 는 호출 방법에 관계없이 전체 경로로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7823bfeac488dfb6d0fa9044c88f386df6a09bf4" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;pwd&lt;/code&gt; can be used to find the current working directory, and &lt;code&gt;dirname&lt;/code&gt; to find the directory of a particular file (command that was run, is &lt;code&gt;$0&lt;/code&gt;, so &lt;code&gt;dirname $0&lt;/code&gt; should give you the directory of the current script).</source>
          <target state="translated">&lt;code&gt;pwd&lt;/code&gt; 를 사용하여 현재 작업 디렉토리를 찾고 &lt;code&gt;dirname&lt;/code&gt; 을 사용하여 특정 파일의 디렉토리를 찾을 수 있습니다 (실행 된 명령은 &lt;code&gt;$0&lt;/code&gt; 이므로 &lt;code&gt;dirname $0&lt;/code&gt; 은 현재 스크립트의 디렉토리를 제공합니다).</target>
        </trans-unit>
        <trans-unit id="6d18c950a3d7f2476e076d0ab011a954913b53e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;readlink&lt;/code&gt; will resolve the script path to an absolute path from the root of the filesystem. So, any paths containing single or double dots, tildes and/or symbolic links will be resolved to a full path.</source>
          <target state="translated">&lt;code&gt;readlink&lt;/code&gt; 는 파일 시스템의 루트에서 스크립트 경로를 절대 경로로 해석합니다. 따라서 단일 또는 이중 도트, 물결표 및 / 또는 심볼릭 링크가 포함 된 경로는 전체 경로로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="0581627fdb0bac69bb25fa3efd994b4e62714351" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt;&lt;/strong&gt; - the full path to the script. The value of this will be correct even when the script is being sourced, e.g. &lt;code&gt;source &amp;lt;(echo 'echo $0')&lt;/code&gt; prints &lt;strong&gt;bash&lt;/strong&gt;, while replacing it with &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; will print the full path of the script. (Of course, this assumes you're OK taking a dependency on Bash.)</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; &lt;/strong&gt; -스크립트의 전체 경로 이 값은 스크립트가 소싱되는 경우에도 정확합니다. 예를 들어 &lt;code&gt;source &amp;lt;(echo 'echo $0')&lt;/code&gt; 은 &lt;strong&gt;bash를&lt;/strong&gt; 인쇄하고 &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; 스크립트의 전체 경로가 인쇄됩니다. (물론 이것은 Bash에 의존하는 것이 좋다고 가정합니다.)</target>
        </trans-unit>
        <trans-unit id="07ce80449c0b3e3f277e4aeb4c0cb9d5d13239a7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;readlink -f&lt;/code&gt;&lt;/strong&gt; - Recursively resolves any symlinks in the specified path. This is a GNU extension, and not available on (for example) BSD systems. If you're running a Mac, you can use Homebrew to install GNU &lt;code&gt;coreutils&lt;/code&gt; and supplant this with &lt;strong&gt;&lt;code&gt;greadlink -f&lt;/code&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;readlink -f&lt;/code&gt; -&lt;/strong&gt; 지정된 경로의 모든 심볼릭 링크를 재귀 적으로 해결합니다. 이것은 GNU 확장이며 BSD 시스템에서는 사용할 수 없습니다. Mac을 사용하는 경우 Homebrew를 사용하여 GNU &lt;code&gt;coreutils&lt;/code&gt; 를 설치하고 &lt;strong&gt; &lt;code&gt;greadlink -f&lt;/code&gt; 로&lt;/strong&gt; 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="426fbf2c3b86a3a618cbd3f9d4a86baf50463f6f" translate="yes" xml:space="preserve">
          <source>Absolute paths or relative paths</source>
          <target state="translated">절대 경로 또는 상대 경로</target>
        </trans-unit>
        <trans-unit id="4d5e28e7a0e956bd9e43ce42784d9f9cdb3a1a56" translate="yes" xml:space="preserve">
          <source>Again, but using the full path to the script:</source>
          <target state="translated">다시 말하지만 스크립트의 전체 경로를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="31df5ecd19815d979653fa19bbfcdd3f7579bf3e" translate="yes" xml:space="preserve">
          <source>Also a lot of people assume you're running the script from a shell so they forget when you open a new script it defaults to your home.</source>
          <target state="translated">또한 많은 사람들이 쉘에서 스크립트를 실행한다고 가정하므로 새 스크립트를 열 때 기본값은 집입니다.</target>
        </trans-unit>
        <trans-unit id="5cc881cb0d3b8741b77229be62a98f44e6db9d66" translate="yes" xml:space="preserve">
          <source>Also, watch out for &lt;a href=&quot;http://bosker.wordpress.com/2012/02/12/bash-scripters-beware-of-the-cdpath/&quot;&gt;&lt;code&gt;$CDPATH&lt;/code&gt; gotchas&lt;/a&gt;, and stderr output side effects if the user has smartly overridden cd to redirect output to stderr instead (including escape sequences, such as when calling &lt;code&gt;update_terminal_cwd &amp;gt;&amp;amp;2&lt;/code&gt; on Mac). Adding &lt;code&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; at the end of your &lt;code&gt;cd&lt;/code&gt; command will take care of both possibilities.</source>
          <target state="translated">또한 &lt;a href=&quot;http://bosker.wordpress.com/2012/02/12/bash-scripters-beware-of-the-cdpath/&quot;&gt; &lt;code&gt;$CDPATH&lt;/code&gt; gotchas&lt;/a&gt; 및 stderr 출력 부작용에주의하십시오. &lt;code&gt;cd&lt;/code&gt; 명령 끝에 &lt;code&gt;&amp;gt;/dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; 을 추가하면 두 가지 가능성이 모두 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="82ae5dde6d9ef2e46a9b902e17c82253e6391ecf" translate="yes" xml:space="preserve">
          <source>Alternatively you can try the following function in bash:</source>
          <target state="translated">또는 bash에서 다음 기능을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e053cd2da59279d2a0608bc7768f1b1f529d9e11" translate="yes" xml:space="preserve">
          <source>Alternatively, if the bash script itself is a &lt;strong&gt;relative symlink&lt;/strong&gt; you &lt;em&gt;want&lt;/em&gt; to follow it and return the full path of the linked-to script:</source>
          <target state="translated">또는 bash 스크립트 자체가 &lt;strong&gt;상대 symlink 인&lt;/strong&gt; 경우이를 따르고 링크 된 스크립트의 전체 경로를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="e969dea8cd5921be63a767f83c70cdc21ad8e248" translate="yes" xml:space="preserve">
          <source>Although just</source>
          <target state="translated">그냥</target>
        </trans-unit>
        <trans-unit id="08ff941f8ba378bc98bfbb6b1945c211a1cf671d" translate="yes" xml:space="preserve">
          <source>And finally using a symbolic link to execute the script:</source>
          <target state="translated">마지막으로 심볼릭 링크를 사용하여 스크립트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="0b7be30335048b9362beef0dcaaa21ecad8777d9" translate="yes" xml:space="preserve">
          <source>And it will print something like:</source>
          <target state="translated">그리고 그것은 다음과 같이 인쇄됩니다 :</target>
        </trans-unit>
        <trans-unit id="abac3354c23bb46705fe1229d339a683605c1ae3" translate="yes" xml:space="preserve">
          <source>And of course &lt;strong&gt;&lt;code&gt;dirname&lt;/code&gt;&lt;/strong&gt; gets the parent directory of the path.</source>
          <target state="translated">물론 &lt;strong&gt; &lt;code&gt;dirname&lt;/code&gt; &lt;/strong&gt; 은 경로의 상위 디렉토리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="760013e12b493fa6407f1a2ce1efb48c91f8cef6" translate="yes" xml:space="preserve">
          <source>Bash script absolute path with OS X</source>
          <target state="translated">OS X의 Bash 스크립트 절대 경로</target>
        </trans-unit>
        <trans-unit id="0f28fd68e004022f6abcd795c8d0296f7d6715ac" translate="yes" xml:space="preserve">
          <source>Beware: if you &lt;code&gt;cd&lt;/code&gt; to a different directory before running this snippet, the result may be incorrect!</source>
          <target state="translated">이 스 니펫을 실행하기 전에 다른 디렉토리로 &lt;code&gt;cd&lt;/code&gt; 를 넣으면 결과가 올바르지 않을 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="2e27eaacc3ad357f5d5f74812ad0688f6b0fc661" translate="yes" xml:space="preserve">
          <source>But, as &lt;strong&gt;matt b&lt;/strong&gt; pointed out, the path returned is different depending on how the script is called. &lt;code&gt;pwd&lt;/code&gt; doesn't do the job because that only tells you what the current directory is, not what directory the script resides in. Additionally, if a symbolic link to a script is executed, you're going to get a (probably relative) path to where the link resides, not the actual script.</source>
          <target state="translated">그러나 &lt;strong&gt;매트 b가&lt;/strong&gt; 지적했듯이 반환되는 경로는 스크립트 호출 방법에 따라 다릅니다. &lt;code&gt;pwd&lt;/code&gt; 는 현재 디렉토리가 무엇인지, 스크립트가 어떤 디렉토리에 있는지 알려주지 않기 때문에 작업을 수행하지 않습니다. 또한 스크립트에 대한 심볼릭 링크가 실행되면 (아마도 상대적인) 경로를 얻게됩니다 실제 스크립트가 아닌 링크가있는 위치</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="e0855567fdf07ed8e9074f37448001287e233f16" translate="yes" xml:space="preserve">
          <source>File and directory soft links</source>
          <target state="translated">파일 및 디렉토리 소프트 링크</target>
        </trans-unit>
        <trans-unit id="fed5301d79c7b6f1a7c8546ea54449b1afeeeaa5" translate="yes" xml:space="preserve">
          <source>Filenames beginning with a hyphen</source>
          <target state="translated">하이픈으로 시작하는 파일 이름</target>
        </trans-unit>
        <trans-unit id="772062a56cf9b814d3042408e52f123d2ada045a" translate="yes" xml:space="preserve">
          <source>For systems having GNU coreutils &lt;code&gt;readlink&lt;/code&gt; (eg. linux):</source>
          <target state="translated">GNU coreutils &lt;code&gt;readlink&lt;/code&gt; 가있는 시스템 (예 : Linux) :</target>
        </trans-unit>
        <trans-unit id="721536b3b45c387e4bee8ead6b8c3dba91e6d655" translate="yes" xml:space="preserve">
          <source>From the comment track it seems not to work with Mac OS.
I have no idea why that is. Any suggestions?</source>
          <target state="translated">댓글 트랙에서 Mac OS에서는 작동하지 않는 것 같습니다. 왜 그런지 모르겠습니다. 어떤 제안?</target>
        </trans-unit>
        <trans-unit id="cc396b4d831b322640a5f760d49c543208d2cfd8" translate="yes" xml:space="preserve">
          <source>Here is a POSIX compliant one-liner:</source>
          <target state="translated">POSIX 호환 단일 라이너는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e6caa82bfaa440bd1e01986a8ac88b7f3d089a6" translate="yes" xml:space="preserve">
          <source>Here is an easy-to-remember script:</source>
          <target state="translated">다음은 기억하기 쉬운 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="7a6b9a74a02f93af7c524bc132c55dc467e6be32" translate="yes" xml:space="preserve">
          <source>Here is the simple, correct way:</source>
          <target state="translated">간단하고 올바른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7e2786c7429ea5f9dc687d1fac3e1e4a84e09bad" translate="yes" xml:space="preserve">
          <source>Here's a script demonstrating each of these, &lt;code&gt;whatdir.sh&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;whatdir.sh&lt;/code&gt; 각각을 보여주는 스크립트입니다.</target>
        </trans-unit>
        <trans-unit id="79d4dc6932c6940edea09332c0a40e4c385f867e" translate="yes" xml:space="preserve">
          <source>Here's an example of its usage:</source>
          <target state="translated">사용법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f67626bb87966ae92799fbed14c52f02b6a20974" translate="yes" xml:space="preserve">
          <source>Hmm, if in the path basename &amp;amp; dirname are just not going to cut it
and walking the path is hard (what if parent didn't export PATH!).
However, the shell has to have an open handle to its script, and in
bash the handle is #255.</source>
          <target state="translated">흠, 경로에서 basename &amp;amp; dirname이 그것을 자르지 않고 경로를 걷는 것이 어렵다면 (부모가 PATH를 내 보내지 않으면 어떻게 될까요!) 그러나 쉘에는 스크립트에 대한 열린 핸들이 있어야하며 bash에서 핸들은 # 255입니다.</target>
        </trans-unit>
        <trans-unit id="2c514cd534e6b677e18c9f6ef72d1038f975e863" translate="yes" xml:space="preserve">
          <source>How do I get the path of the directory in which a &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; script is located, &lt;em&gt;inside&lt;/em&gt; that script?</source>
          <target state="translated">해당 스크립트 &lt;em&gt;내&lt;/em&gt; 에서 &lt;a href=&quot;http://en.wikipedia.org/wiki/Bash_%28Unix_shell%29&quot;&gt;Bash&lt;/a&gt; 스크립트가있는 디렉토리의 경로를 얻으려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="e94507b21cbe42200554606d16c3782465fae406" translate="yes" xml:space="preserve">
          <source>How to get the source directory of a Bash script from within the script itself</source>
          <target state="translated">스크립트 자체에서 Bash 스크립트의 소스 디렉토리를 얻는 방법</target>
        </trans-unit>
        <trans-unit id="15565602373c482c48a874ebd82fe09c139ba724" translate="yes" xml:space="preserve">
          <source>How to set current working directory to the directory of the script?</source>
          <target state="translated">현재 작업 디렉토리를 스크립트의 디렉토리로 설정하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="c1dc3b40f2fb5f6b76faaa750db69827966305ce" translate="yes" xml:space="preserve">
          <source>However, &lt;code&gt;dirname&lt;/code&gt; gives precisely the directory portion of the filename, which more likely than not is going to be relative to the current working directory. If your script needs to change directory for some reason, then the output from &lt;code&gt;dirname&lt;/code&gt; becomes meaningless.</source>
          <target state="translated">그러나 &lt;code&gt;dirname&lt;/code&gt; 은 파일 이름의 디렉토리 부분을 정확하게 제공하므로 현재 작업 디렉토리와 관련이 없을 가능성이 높습니다. 어떤 이유로 스크립트가 디렉토리를 변경해야하는 경우, &lt;code&gt;dirname&lt;/code&gt; 의 출력은 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="fd781f58f78adcaf88471d8e16c79fde52b8abc9" translate="yes" xml:space="preserve">
          <source>I am tired of coming to this page over and over to copy paste the one-liner in the accepted answer. The problem with that is it is not easy to understand and remember.</source>
          <target state="translated">허용 된 답변에 한 줄짜리 붙여 넣기를 복사하기 위해이 페이지에 여러 번 와서 피곤합니다. 그 문제는 이해하고 기억하기 쉽지 않다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c65940fe653c04e6d217fd71b5bc36c973d94e09" translate="yes" xml:space="preserve">
          <source>I believe I've got this one. I'm late to the party, but I think some will appreciate it being here if they come across this thread. The comments should explain:</source>
          <target state="translated">나는 이것을 가지고 있다고 믿는다. 나는 파티에 늦었지만 일부 사람들 이이 스레드를 발견하면 여기에 있다는 것에 감사 할 것이라고 생각합니다. 의견은 다음을 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="a5564a6ec07273d60ff4548ab635ae9209aad476" translate="yes" xml:space="preserve">
          <source>I don't think this is as easy as others have made it out to be.  &lt;code&gt;pwd&lt;/code&gt; doesn't work, as the current directory is not necessarily the directory with the script.  &lt;code&gt;$0&lt;/code&gt; doesn't always have the information either.  Consider the following three ways to invoke a script:</source>
          <target state="translated">나는 이것이 다른 사람들이 그렇게 쉬운 것처럼 생각하지 않습니다. 현재 디렉토리가 반드시 스크립트가있는 디렉토리 일 필요는 없으므로 &lt;code&gt;pwd&lt;/code&gt; 가 작동하지 않습니다. &lt;code&gt;$0&lt;/code&gt; 항상 정보가있는 것은 아닙니다. 스크립트를 호출하는 다음 세 가지 방법을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="314e2d8c80409f81525019944bae934fac7d14de" translate="yes" xml:space="preserve">
          <source>I suggest the following:</source>
          <target state="translated">나는 다음을 제안한다.</target>
        </trans-unit>
        <trans-unit id="2ff8ae24228298e42c1024dc75a685fff4c70183" translate="yes" xml:space="preserve">
          <source>I tried all of these and none worked. One was very close but had a tiny bug that broke it badly; they forgot to wrap the path in quotation marks.</source>
          <target state="translated">나는 이것들을 모두 시도했지만 아무도 효과가 없었다. 하나는 매우 가까웠지만 작은 버그로 인해 심하게 부러졌습니다. 그들은 경로를 따옴표로 묶는 것을 잊었습니다.</target>
        </trans-unit>
        <trans-unit id="fedbbd02f03e12ac9d3beeef3636203bf88f7cb9" translate="yes" xml:space="preserve">
          <source>I want to use a Bash script as a launcher for another application. I want to change the working directory to the one where the Bash script is located, so I can operate on the files in that directory, like so:</source>
          <target state="translated">Bash 스크립트를 다른 응용 프로그램의 실행기로 사용하고 싶습니다. 작업 디렉토리를 Bash 스크립트가있는 디렉토리로 변경하고 싶으므로 해당 디렉토리의 파일을 다음과 같이 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce81d457123493a7d7d88fddc69383893c3220b7" translate="yes" xml:space="preserve">
          <source>I would use something like this:</source>
          <target state="translated">나는 이와 같은 것을 사용할 것이다 :</target>
        </trans-unit>
        <trans-unit id="2171f703ddd878f550591c0e07925f51cc2b067b" translate="yes" xml:space="preserve">
          <source>I've compared many of the answers given, and come up with some more compact solutions. These seem to handle all of the crazy edge cases that arise from your favorite combination of:</source>
          <target state="translated">나는 주어진 많은 답변을 비교하고 더 작은 솔루션을 생각해 냈습니다. 이들은 당신이 좋아하는 조합에서 발생하는 모든 미친 사건을 처리하는 것처럼 보입니다.</target>
        </trans-unit>
        <trans-unit id="e58b329aff37f278c76fdb1e35272c1bf2d42971" translate="yes" xml:space="preserve">
          <source>If you're running from Linux, it seems that using the &lt;code&gt;proc&lt;/code&gt; handle is the best solution to locate the fully resolved source of the currently running script (in an interactive session, the link points to the respective &lt;code&gt;/dev/pts/X&lt;/code&gt;):</source>
          <target state="translated">Linux에서 실행중인 경우 &lt;code&gt;proc&lt;/code&gt; 핸들을 사용하는 것이 현재 실행중인 스크립트의 완전히 해결 된 소스를 찾는 가장 좋은 솔루션 인 것 같습니다 (대화식 세션에서 링크는 해당 &lt;code&gt;/dev/pts/X&lt;/code&gt; 를 가리킴 ).</target>
        </trans-unit>
        <trans-unit id="f5006f4b7d8d744f73e4fc441d26d052cf92f989" translate="yes" xml:space="preserve">
          <source>In the first and third ways &lt;code&gt;$0&lt;/code&gt; doesn't have the full path information.  In the second and third, &lt;code&gt;pwd&lt;/code&gt; does not work.  The only way to get the directory in the third way would be to run through the path and find the file with the correct match.  Basically the code would have to redo what the OS does.</source>
          <target state="translated">첫 번째와 세 번째 방법으로 &lt;code&gt;$0&lt;/code&gt; 에는 전체 경로 정보가 없습니다. 두 번째와 세 번째에서는 &lt;code&gt;pwd&lt;/code&gt; 가 작동하지 않습니다. 세 번째 방법으로 디렉토리를 얻는 유일한 방법은 경로를 통해 실행하고 일치하는 파일을 찾는 것입니다. 기본적으로 코드는 OS의 기능을 다시 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb7c16b349eb08b9c0b10fa5d3251652f7054cc9" translate="yes" xml:space="preserve">
          <source>Invocation as &lt;code&gt;script&lt;/code&gt;, &lt;code&gt;bash script&lt;/code&gt;, &lt;code&gt;bash -c script&lt;/code&gt;, &lt;code&gt;source script&lt;/code&gt;, or &lt;code&gt;. script&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;script&lt;/code&gt; , &lt;code&gt;bash script&lt;/code&gt; , &lt;code&gt;bash -c script&lt;/code&gt; , &lt;code&gt;source script&lt;/code&gt; 또는로 호출 &lt;code&gt;. script&lt;/code&gt; 스크립트</target>
        </trans-unit>
        <trans-unit id="a02f22ad602d2ef6e382c04099658f152ab19842" translate="yes" xml:space="preserve">
          <source>It doesn't matter where the user is or how he calls the script, this will always work.</source>
          <target state="translated">사용자의 위치 나 스크립트 호출 방식에 관계없이 항상 작동합니다.</target>
        </trans-unit>
        <trans-unit id="38bb10b3d907511b9279efee2507d873a4fc242c" translate="yes" xml:space="preserve">
          <source>It will work as long as the last component of the path used to find the script is not a symlink (directory links are OK).  If you also want to resolve any links to the script itself, you need a multi-line solution:</source>
          <target state="translated">스크립트를 찾는 데 사용 된 경로의 마지막 구성 요소가 심볼릭 링크가 아닌 한 (디렉토리 링크는 정상 임) 작동합니다. 스크립트 자체에 대한 링크도 해결하려면 여러 줄 솔루션이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4605dc46bd09b4eaa7af587e1386b633fdeb4323" translate="yes" xml:space="preserve">
          <source>Just make sure you locate this at start of the script.</source>
          <target state="translated">스크립트 시작시이 위치를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="624f152e5413ea8ae957872eddedd2d49c644430" translate="yes" xml:space="preserve">
          <source>More details can be found in &quot;&lt;a href=&quot;https://www.electrictoolbox.com/bash-script-directory/&quot;&gt;Which directory is that bash script in?&lt;/a&gt;&quot;.</source>
          <target state="translated">자세한 내용은 &quot; &lt;a href=&quot;https://www.electrictoolbox.com/bash-script-directory/&quot;&gt;bash 스크립트가있는 디렉토리는 무엇입니까?&lt;/a&gt; &quot; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a0d73ad9eb09a3f63bbc70b597f635f18a702db" translate="yes" xml:space="preserve">
          <source>Note that this has to be the first statement in your script.</source>
          <target state="translated">이것은 스크립트에서 첫 번째 문장이어야합니다.</target>
        </trans-unit>
        <trans-unit id="3d775fc4bf5f21ab130d923a6fabfc949f661ed4" translate="yes" xml:space="preserve">
          <source>Note that you need to use &lt;code&gt;#!/bin/bash&lt;/code&gt; and not &lt;code&gt;#!/bin/sh&lt;/code&gt; since it's a Bash extension.</source>
          <target state="translated">Bash 확장이므로 &lt;code&gt;#!/bin/sh&lt;/code&gt; 가 아니라 #! / bin / &lt;code&gt;#!/bin/bash&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ad78cc1e56befe9d3d057f04c18efb0f0ba1ffd" translate="yes" xml:space="preserve">
          <source>Note: In Bash, it's recommended to use&lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; instead of &lt;code&gt;$0&lt;/code&gt;, otherwise path can break when sourcing the file (&lt;code&gt;source&lt;/code&gt;/&lt;code&gt;.&lt;/code&gt;).</source>
          <target state="translated">참고 : Bash에서는 &lt;code&gt;$0&lt;/code&gt; 대신 &lt;code&gt;${BASH_SOURCE[0]}&lt;/code&gt; 을 사용하는 것이 좋습니다. 그렇지 않으면 파일 ( &lt;code&gt;source&lt;/code&gt; / &lt;code&gt;.&lt;/code&gt; )을 소싱 할 때 경로가 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="498c8b437a7497a048fd6a708c55520b984927c0" translate="yes" xml:space="preserve">
          <source>Now changing directories:</source>
          <target state="translated">이제 디렉토리 변경 :</target>
        </trans-unit>
        <trans-unit id="2cbc4a1754fa2b1a92f79674fc1cded648d99d4c" translate="yes" xml:space="preserve">
          <source>One way to do what you are asking would be to just hardcode the data in the &lt;code&gt;/usr/share&lt;/code&gt; directory, and reference it by its full path.  Data shoudn't be in the &lt;code&gt;/usr/bin&lt;/code&gt; directory anyway, so this is probably the thing to do.</source>
          <target state="translated">요청하는 것을 수행하는 한 가지 방법은 &lt;code&gt;/usr/share&lt;/code&gt; 디렉토리의 데이터를 하드 코딩하고 전체 경로로 참조하는 것입니다. 어쨌든 데이터는 &lt;code&gt;/usr/bin&lt;/code&gt; 디렉토리에 없어야하므로 아마도 그렇게해야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="39c788876858d9fdd3ed2ab494830cb7baca1db1" translate="yes" xml:space="preserve">
          <source>Related:</source>
          <target state="translated">Related:</target>
        </trans-unit>
        <trans-unit id="a9d017586904a386f0684539c8f132954aec5924" translate="yes" xml:space="preserve">
          <source>Reliable way for a Bash script to get the full path to itself</source>
          <target state="translated">Bash 스크립트가 자신의 전체 경로를 얻는 신뢰할 수있는 방법</target>
        </trans-unit>
        <trans-unit id="d02835a79470dbbc2e975df36f0e76821643fa48" translate="yes" xml:space="preserve">
          <source>Running this script in my home dir, using a relative path:</source>
          <target state="translated">상대 경로를 사용하여 내 홈 디렉토리 에서이 스크립트를 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="0310b5ce654c85162f919b8cb40084ecbe9c6fae" translate="yes" xml:space="preserve">
          <source>Say you have a &lt;strong&gt;~/bin&lt;/strong&gt; directory, which is in your &lt;strong&gt;$PATH&lt;/strong&gt;. You have script &lt;strong&gt;A&lt;/strong&gt; inside this directory. It &lt;strong&gt;source&lt;/strong&gt;s script &lt;strong&gt;~/bin/lib/B&lt;/strong&gt;. You know where the included script is relative to the original one (the subdirectory &lt;strong&gt;lib&lt;/strong&gt;), but not where it is relative to the user's current directory.</source>
          <target state="translated">&lt;strong&gt;$ PATH&lt;/strong&gt; 에 &lt;strong&gt;~ / bin&lt;/strong&gt; 디렉토리가 있다고 가정하십시오. 이 디렉토리 안에 스크립트 &lt;strong&gt;A가&lt;/strong&gt; 있습니다. &lt;strong&gt;~ / bin / lib / B&lt;/strong&gt; 스크립트를 제공합니다. 포함 된 스크립트가 원래 스크립트 (하위 디렉토리 &lt;strong&gt;lib&lt;/strong&gt; )와 관련이 있지만 사용자의 현재 디렉토리와 관련이있는 곳은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="08c0715b171236193ef556a3e6ee0e0d4b8a54d0" translate="yes" xml:space="preserve">
          <source>See
&lt;a href=&quot;https://pastebin.com/J8KjxrPF&quot;&gt;https://pastebin.com/J8KjxrPF&lt;/a&gt;</source>
          <target state="translated">See
&lt;a href=&quot;https://pastebin.com/J8KjxrPF&quot;&gt;https://pastebin.com/J8KjxrPF&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="179405fffe479820e45c426b988de99252c1cd22" translate="yes" xml:space="preserve">
          <source>See the man pages for &lt;code&gt;dirname&lt;/code&gt; and &lt;code&gt;readlink&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dirname&lt;/code&gt; 및 &lt;code&gt;readlink&lt;/code&gt; 매뉴얼 페이지를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c6b3f2bbd8222358a7517260fde7e7932a399471" translate="yes" xml:space="preserve">
          <source>Short answer:</source>
          <target state="translated">짧은 답변:</target>
        </trans-unit>
        <trans-unit id="a0d149ae2639019b6c5406830fed3b68dbc7b252" translate="yes" xml:space="preserve">
          <source>Since the script will be run in a separate bash instance, there is no need to restore the working directory afterwards, but if you do want to change back in your script for some reason, you can easily assign the value of &lt;code&gt;pwd&lt;/code&gt; to a variable before you change directory, for future use.</source>
          <target state="translated">스크립트는 별도의 bash 인스턴스에서 실행되므로 나중에 작업 디렉토리를 복원 할 필요는 없지만 어떤 이유로 스크립트를 다시 변경하려면 &lt;code&gt;pwd&lt;/code&gt; 값을 변수에 쉽게 할당 할 수 있습니다 나중에 사용하기 위해 디렉토리를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="bf31e1601b7845dedc267cf1517109936836664c" translate="yes" xml:space="preserve">
          <source>So to make it actually useful here's how to change to the directory of the running script:</source>
          <target state="translated">실제로 유용하게 만들기 위해 실행중인 스크립트의 디렉토리로 변경하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9e8c62d67f4534baba003d7d0611dac78c2ec24b" translate="yes" xml:space="preserve">
          <source>Some others have mentioned the &lt;code&gt;readlink&lt;/code&gt; command, but at its simplest, you can use:</source>
          <target state="translated">다른 사람들은 &lt;code&gt;readlink&lt;/code&gt; 명령을 언급했지만 가장 간단하게 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="972566de850ad7f90e9bb841308fa335acf3511e" translate="yes" xml:space="preserve">
          <source>Spaces, tabs, newlines, unicode, etc. in directories and/or filename</source>
          <target state="translated">디렉토리 및 / 또는 파일 이름의 공백, 탭, 줄 바꿈, 유니 코드 등</target>
        </trans-unit>
        <trans-unit id="1ec65979ffd82e8d4fe3bade4ddad36f365785d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dirname&lt;/code&gt; command is the most basic, simply parsing the path up to the filename off of the &lt;code&gt;$0&lt;/code&gt; (script name) variable:</source>
          <target state="translated">&lt;code&gt;dirname&lt;/code&gt; 명령은 가장 기본적인 방법으로 &lt;code&gt;$0&lt;/code&gt; (스크립트 이름) 변수에서 파일 이름까지의 경로를 구문 분석하면됩니다.</target>
        </trans-unit>
        <trans-unit id="c2502d6f2d208ee4aa0c27823d3f504b519b349d" translate="yes" xml:space="preserve">
          <source>The above should cover your needs for locating the currently running script on Linux, but if you don't have the &lt;code&gt;proc&lt;/code&gt; filesystem at your disposal, or if you're trying to locate the fully resolved path of some other file, then maybe you'll find the below code helpful. It's only a slight modification from the above one-liner. If you're playing around with strange directory/filenames, checking the output with both &lt;code&gt;ls&lt;/code&gt; and &lt;code&gt;readlink&lt;/code&gt; is informative, as &lt;code&gt;ls&lt;/code&gt; will output &quot;simplified&quot; paths, substituting &lt;code&gt;?&lt;/code&gt; for things like newlines.</source>
          <target state="translated">위의 내용은 Linux에서 현재 실행중인 스크립트를 찾는 데 필요한 사항을 다루지 만 &lt;code&gt;proc&lt;/code&gt; 파일 시스템이 없거나 다른 파일의 완전히 해결 된 경로를 찾으려고하면 아마도 아래 코드가 도움이 될 것입니다. 위의 한 줄짜리에서 약간 수정 된 것입니다. 이상한 디렉토리 / 파일 이름으로 놀고 있다면 &lt;code&gt;ls&lt;/code&gt; 와 &lt;code&gt;readlink&lt;/code&gt; 로 출력을 확인하는 것이 유익합니다. &lt;code&gt;ls&lt;/code&gt; 는 &quot;간단한&quot;경로를 출력하고 &lt;code&gt;?&lt;/code&gt; 개행과 같은 것들.</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">출력 :</target>
        </trans-unit>
        <trans-unit id="1ba8640e9fee25016a4dad8164c1faefe6e9b381" translate="yes" xml:space="preserve">
          <source>The shortest and most elegant way to do this is:</source>
          <target state="translated">가장 짧고 우아한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f00be7ce17d97d6d2b8ad5eedab1814c2f7db86" translate="yes" xml:space="preserve">
          <source>There's no need to use &lt;code&gt;BASH_SOURCE&lt;/code&gt; when &lt;code&gt;$0&lt;/code&gt; contains the script filename.</source>
          <target state="translated">&lt;code&gt;$0&lt;/code&gt; 에 스크립트 파일 이름이 포함되어 있으면 &lt;code&gt;BASH_SOURCE&lt;/code&gt; 를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="708db81f22b4189fbca177dd22f22687e2096158" translate="yes" xml:space="preserve">
          <source>This comment and code Copyleft, selectable license under the GPL2.0 or later or CC-SA 3.0  (CreativeCommons Share Alike) or later. (c) 2008. All rights reserved. No warranty of any kind. You have been warned.</source>
          <target state="translated">이 의견 및 코드는 GPL2.0 이상 또는 CC-SA 3.0 (CreativeCommons Share Alike) 이상에서 선택 가능한 라이센스 인 Copyleft입니다. (c) 2008. 모든 권리 보유. 어떤 종류의 보증도 없습니다. 경고를 받았습니다.</target>
        </trans-unit>
        <trans-unit id="9b87a680ec2f32548e3f66bb1cd9591fa03074fb" translate="yes" xml:space="preserve">
          <source>This function takes 1 argument. If argument has already absolute path, print it as it is, otherwise print &lt;code&gt;$PWD&lt;/code&gt; variable + filename argument (without &lt;code&gt;./&lt;/code&gt; prefix).</source>
          <target state="translated">이 함수는 1 개의 인수를 갖습니다. 인수에 이미 절대 경로가 있으면 그대로 인쇄하고, 그렇지 않으면 &lt;code&gt;$PWD&lt;/code&gt; 변수 + 파일 이름 인수 ( &lt;code&gt;./&lt;/code&gt; 접두사없이)를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="1fbe2218965d16cf412a3cb4e57e7dabce8dfa88" translate="yes" xml:space="preserve">
          <source>This gets it right regardless how or where you run it:</source>
          <target state="translated">이것은 어디서 어떻게 실행하는지에 관계없이 올바르게 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e6228e8bc7f23574e8589322511f54bee4d824b4" translate="yes" xml:space="preserve">
          <source>This gets the current working directory on Mac OS X 10.6.6:</source>
          <target state="translated">Mac OS X 10.6.6에서 현재 작업 디렉토리를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="b50df0d2b5baa8b71ef8e15ca44df475f421e8ba" translate="yes" xml:space="preserve">
          <source>This has a small bit of ugliness to it, but the fix is compact and easy to understand. We aren't using bash primitives only, but I'm okay with that because &lt;code&gt;readlink&lt;/code&gt; simplifies the task considerably. The &lt;code&gt;echo X&lt;/code&gt; adds an &lt;code&gt;X&lt;/code&gt; to the end of the variable string so that any trailing whitespace in the filename doesn't get eaten, and the parameter substitution &lt;code&gt;${VAR%X}&lt;/code&gt; at the end of the line gets rid of the &lt;code&gt;X&lt;/code&gt;. Because &lt;code&gt;readlink&lt;/code&gt; adds a newline of its own (which would normally be eaten in the command substitution if not for our previous trickery), we have to get rid of that, too. This is most easily accomplished using the &lt;code&gt;$''&lt;/code&gt; quoting scheme, which lets us use escape sequences such as &lt;code&gt;\n&lt;/code&gt; to represent newlines (this is also how you can easily make deviously named directories and files).</source>
          <target state="translated">여기에는 약간의 추악함이 있지만 수정은 작고 이해하기 쉽습니다. 우리는 bash 프리미티브만을 사용하지 않지만 &lt;code&gt;readlink&lt;/code&gt; 가 작업을 상당히 단순화하기 때문에 괜찮습니다. &lt;code&gt;echo X&lt;/code&gt; 는 변수 문자열의 끝에 &lt;code&gt;X&lt;/code&gt; 를 추가하여 파일 이름의 후행 공백을 먹지 않고 행 끝에있는 매개 변수 대체 &lt;code&gt;${VAR%X}&lt;/code&gt; 가 &lt;code&gt;X&lt;/code&gt; 를 제거합니다. &lt;code&gt;readlink&lt;/code&gt; 는 그 자체의 개행을 추가하기 때문에 (이전의 속임수가 아닌 경우 일반적으로 명령 대체에서 먹게 됨) 우리도 그것을 제거해야합니다. 이것은 &lt;code&gt;$''&lt;/code&gt; 인용 체계를 사용하여 가장 쉽게 수행됩니다. &lt;code&gt;\n&lt;/code&gt; 과 같은 이스케이프 시퀀스를 사용하여 줄 바꿈을 표현할 수 있습니다 (이것은 이름이 지정된 디렉토리와 파일을 쉽게 만들 수있는 방법이기도합니다).</target>
        </trans-unit>
        <trans-unit id="5aa844422368c235d4798b12c5b40f9de43120b8" translate="yes" xml:space="preserve">
          <source>This is Linux specific, but you could use:</source>
          <target state="translated">이것은 Linux마다 다르지만 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86fd117c80732a5737dd5bfc313248aa05132334" translate="yes" xml:space="preserve">
          <source>This is a slight revision to the solution e-satis and 3bcdnlklvc04a pointed out in &lt;a href=&quot;https://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-in/179231#179231&quot;&gt;their answer&lt;/a&gt;:</source>
          <target state="translated">이것은 솔루션 e-satis와 3bcdnlklvc04a에 대한 약간의 수정입니다.</target>
        </trans-unit>
        <trans-unit id="2b6bbbcdc45501c525a87758ecc98df605856ec4" translate="yes" xml:space="preserve">
          <source>This is solved by the following (inside &lt;strong&gt;A&lt;/strong&gt;):</source>
          <target state="translated">이것은 ( &lt;strong&gt;A&lt;/strong&gt; 내부) 다음으로 해결됩니다.</target>
        </trans-unit>
        <trans-unit id="624fd87ddc71cc2f52e33f6b137ca769fdd435b7" translate="yes" xml:space="preserve">
          <source>This last one will work with any combination of aliases, &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;bash -c&lt;/code&gt;, symlinks, etc.</source>
          <target state="translated">이 마지막은 별명, &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;bash -c&lt;/code&gt; , symlinks 등의 조합으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="4983e48bae3b4d2a9a56065e7e14eeea962257d4" translate="yes" xml:space="preserve">
          <source>This should do it:</source>
          <target state="translated">이것은해야합니다 :</target>
        </trans-unit>
        <trans-unit id="aa4c83ddd30660c0e83b985de4ded174bb141cac" translate="yes" xml:space="preserve">
          <source>This should still work in all the cases they listed.</source>
          <target state="translated">이것은 그들이 나열된 모든 경우에 여전히 작동합니다.</target>
        </trans-unit>
        <trans-unit id="cf9699e13a8ba01954113516dc2f3d41f207c58e" translate="yes" xml:space="preserve">
          <source>This way, you get an absolute, rather then relative directory.</source>
          <target state="translated">이런 식으로 상대 디렉토리가 아닌 절대 디렉토리를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="135bc3de061ad99bdf9de61474343b6e2e61806c" translate="yes" xml:space="preserve">
          <source>This will prevent &lt;code&gt;popd&lt;/code&gt; after a failed &lt;code&gt;pushd&lt;/code&gt;, thanks to konsolebox.</source>
          <target state="translated">konsolebox 덕분에 푸시 실패 후 팝이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0f135b85dac7caba81ee8d5eef93c2b91b8b9911" translate="yes" xml:space="preserve">
          <source>This works in bash-3.2:</source>
          <target state="translated">이것은 bash-3.2에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="5e15ddfd0077a5cc542009118703466b054f19ef" translate="yes" xml:space="preserve">
          <source>This works with symlinks and spaces in path.</source>
          <target state="translated">이것은 경로의 심볼릭 링크 및 공백과 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8ced09545b20da47e415417b4eae8c1d46add0ea" translate="yes" xml:space="preserve">
          <source>This would work on all platforms and is super clean.</source>
          <target state="translated">이것은 모든 플랫폼에서 작동하며 매우 깨끗합니다.</target>
        </trans-unit>
        <trans-unit id="a96b4d115e1a2f99afb8930b0cb45b42796745d8" translate="yes" xml:space="preserve">
          <source>To sum up many answers:</source>
          <target state="translated">많은 답변을 요약하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9affde8f5ff7bf2ca4f7667daf66a026dee38eb7" translate="yes" xml:space="preserve">
          <source>To understand how it works, try running this more verbose form:</source>
          <target state="translated">작동 방식을 이해하려면 다음과 같은 더 자세한 양식을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="132b79908b7776a375cc7193c424540ac793a2f9" translate="yes" xml:space="preserve">
          <source>Try the following cross-compatible solution:</source>
          <target state="translated">다음과 같은 상호 호환 솔루션을 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="826ada9994010e1474b6c934921317e2b2fc33d2" translate="yes" xml:space="preserve">
          <source>Try this directory on for size:</source>
          <target state="translated">이 디렉토리를 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="38020961644634d637fb2ca7e47c7574cbf790d7" translate="yes" xml:space="preserve">
          <source>Try using:</source>
          <target state="translated">다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9a452526a7c03b98a7b0cff9b23c4571ffe98669" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;dirname &quot;$0&quot;&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;dirname &quot;$0&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="cee68f731daaa055fef6e7d60b2e005a40ccd507" translate="yes" xml:space="preserve">
          <source>Used Commands</source>
          <target state="translated">사용 된 명령</target>
        </trans-unit>
        <trans-unit id="a647143996cb15d8f49750108a38d0c04b574b6a" translate="yes" xml:space="preserve">
          <source>Works for all versions,including</source>
          <target state="translated">다음을 포함한 모든 버전에서 작동</target>
        </trans-unit>
        <trans-unit id="4478c870924518a381357cbdddc6fd2693d6b087" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;$BASH_SOURCE&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;$BASH_SOURCE&lt;/code&gt; 를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="f3e45657c5047bf94cb7ca6a37215e8c261e76dc" translate="yes" xml:space="preserve">
          <source>as the commands such as &lt;code&gt;realpath&lt;/code&gt; or &lt;code&gt;readlink&lt;/code&gt; could be not available (depending on the operating system).</source>
          <target state="translated">&lt;code&gt;realpath&lt;/code&gt; 또는 &lt;code&gt;readlink&lt;/code&gt; 와 같은 명령을 사용할 수 없기 때문에 (운영 체제에 따라 다름).</target>
        </trans-unit>
        <trans-unit id="3b35d515a2cad2dbe851141ccbc96b335f97be3e" translate="yes" xml:space="preserve">
          <source>is a useful one-liner which will give you the full directory name of the script no matter where it is being called from.</source>
          <target state="translated">어디에서 스크립트를 호출하든 스크립트의 전체 디렉토리 이름을 제공하는 유용한 one-liner입니다.</target>
        </trans-unit>
        <trans-unit id="23a79b97adcea69578a7d61d5b1b5bea3a07c8d0" translate="yes" xml:space="preserve">
          <source>or (&lt;a href=&quot;http://mywiki.wooledge.org/BashFAQ/082&quot;&gt;preferably&lt;/a&gt;):</source>
          <target state="translated">또는 ( &lt;a href=&quot;http://mywiki.wooledge.org/BashFAQ/082&quot;&gt;바람직하게는&lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="4a9fbc967654f7ea7a6ba8346e46b6dc14178a2d" translate="yes" xml:space="preserve">
          <source>solves the specific scenario in the question, I find having the absolute path to more more useful generally.</source>
          <target state="translated">질문의 특정 시나리오를 해결하면 더 일반적으로 더 유용한 방법을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06e8f4de34464eed78185a34e3f0bf59d4c3790c" translate="yes" xml:space="preserve">
          <source>using &lt;code&gt;pwd&lt;/code&gt; alone will not work if you are not running the script from the directory it is contained in.</source>
          <target state="translated">포함 된 디렉토리에서 스크립트를 실행하지 않으면 &lt;code&gt;pwd&lt;/code&gt; 만 사용하면 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5417682a89cadfcccf3667346fea39b977cb8c68" translate="yes" xml:space="preserve">
          <source>when arg &lt;code&gt;$0&lt;/code&gt; is modified from caller.</source>
          <target state="translated">arg &lt;code&gt;$0&lt;/code&gt; 이 호출자로부터 수정 될 때.</target>
        </trans-unit>
        <trans-unit id="d9aceea7d088301ee05fb56104bb7954812ddde0" translate="yes" xml:space="preserve">
          <source>when called via multple depth soft link,</source>
          <target state="translated">다중 깊이 소프트 링크를 통해 호출 될 때</target>
        </trans-unit>
        <trans-unit id="5214b91d429aa811e23fe9cdd6fb85ec9ab8f9a3" translate="yes" xml:space="preserve">
          <source>when script called by command &quot;&lt;code&gt;source&lt;/code&gt;&quot; aka &lt;code&gt;.&lt;/code&gt; (dot) operator.</source>
          <target state="translated">&quot; &lt;code&gt;source&lt;/code&gt; &quot;명령으로 스크립트를 호출 한 경우 (점) 연산자.</target>
        </trans-unit>
        <trans-unit id="e87310bd2c8f2488b7a4fb47d9de8ff04e1d2137" translate="yes" xml:space="preserve">
          <source>when the file it</source>
          <target state="translated">때 파일</target>
        </trans-unit>
        <trans-unit id="ea5bdf31e3db8283bb30dac33b0fe419cb0a6ca2" translate="yes" xml:space="preserve">
          <source>works for me.</source>
          <target state="translated">나를 위해 작동합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
