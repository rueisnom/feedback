<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/661561">
    <body>
      <group id="661561">
        <trans-unit id="06e8f5916a582a85868630f3154c466f7fc04910" translate="yes" xml:space="preserve">
          <source>&quot;serviceGUI()&quot; is a GUI level method within the form (this) that can change as many controls as you want. Call &quot;updateGUI()&quot; from the other thread. Parameters can be added to pass values, or (probably faster) use class scope variables with locks on them as required if there is any possibility of a clash between threads accessing them that could cause instability.  Use BeginInvoke instead of Invoke if the non-GUI thread is time critical (keeping Brian Gideon's warning in mind).</source>
          <target state="translated">&quot;serviceGUI()&quot; es un método de nivel GUI dentro del formulario (este)que puede cambiar tantos controles como se desee.Llama a &quot;updateGUI()&quot; desde el otro hilo.Se pueden añadir parámetros para pasar valores,o (probablemente más rápido)usar variables de alcance de clase con bloqueos en ellas según se requiera si hay alguna posibilidad de un choque entre los hilos que acceden a ellas que pueda causar inestabilidad.Usar BeginInvoke en lugar de Invoke si el hilo no-GUI es de tiempo crítico (teniendo en cuenta la advertencia de Brian Gideon).</target>
        </trans-unit>
        <trans-unit id="ef8ec856c4ab1a77f14b563ee4ef56d73621c6ac" translate="yes" xml:space="preserve">
          <source>(The code is typed here out of my head, so I haven't checked for correct syntax, etc., but it should get you going.)</source>
          <target state="translated">(El código está escrito aquí fuera de mi cabeza,así que no he comprobado la sintaxis correcta,etc.,pero debería ponerte en marcha.)</target>
        </trans-unit>
        <trans-unit id="0b9d4de19ed62632e2e708a5b3d176bf82f4ae93" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.threading.tasks.task.aspx&quot;&gt;Task&lt;/a&gt; instead of &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.threading.thread.aspx&quot;&gt;Thread&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.threading.tasks.task.aspx&quot;&gt;Tarea en&lt;/a&gt; lugar de &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.threading.thread.aspx&quot;&gt;Hilo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a035d2e7e3c891ee830ddcb57bb2ffe98c02f4e3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskcreationoptions.aspx&quot;&gt;TaskCreationOptions.LongRunning&lt;/a&gt; that hints to do not queue the task into &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.threading.threadpool.aspx&quot;&gt;ThreadPool&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.threading.tasks.taskcreationoptions.aspx&quot;&gt;TaskCreationOptions.LongRunning&lt;/a&gt; que sugiere no poner la tarea en cola en &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.threading.threadpool.aspx&quot;&gt;ThreadPool&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79df28c45d995623e2b44da7f9e393555db0ba13" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/vstudio/hh156513.aspx&quot;&gt;async&lt;/a&gt; keyword, that allows to use &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/vstudio/hh156528.aspx&quot;&gt;await&lt;/a&gt; which in turn prevent the event handler from reaching the completion state till the task finished and in the meantime doesn't block the UI thread.</source>
          <target state="translated">palabra clave &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/vstudio/hh156513.aspx&quot;&gt;as&amp;iacute;ncrona&lt;/a&gt; , que permite usar el sistema &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/vstudio/hh156528.aspx&quot;&gt;wait,&lt;/a&gt; que a su vez evita que el controlador de eventos alcance el estado de finalizaci&amp;oacute;n hasta que finalice la tarea y, mientras tanto, no bloquea el hilo de la interfaz de usuario.</target>
        </trans-unit>
        <trans-unit id="b25bb1684a5a528e8195bd99abb1e1bd38903c79" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Main Code (put this inside of your form's class code):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;C&amp;oacute;digo principal (ponga esto dentro del c&amp;oacute;digo de clase de su formulario):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2003baf2e128c2d5d838f3388dd29fde682d6122" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Some argumentation&lt;/strong&gt;: Usually it is bad for code readability to put {} after an &lt;code&gt;if ()&lt;/code&gt; statement in one line. But in this case it is routine all-the-same &quot;mantra&quot;. It doesn't break code readability if this method is consistent over the project. And it saves your code from littering (one line of code instead of five).</source>
          <target state="translated">&lt;strong&gt;Algunos argumentos&lt;/strong&gt; : por lo general, es malo para la legibilidad del c&amp;oacute;digo poner {} despu&amp;eacute;s de una instrucci&amp;oacute;n &lt;code&gt;if ()&lt;/code&gt; en una l&amp;iacute;nea. Pero en este caso es el &quot;mantra&quot; de rutina. No interrumpe la legibilidad del c&amp;oacute;digo si este m&amp;eacute;todo es consistente durante el proyecto. Y ahorra su c&amp;oacute;digo de basura (una l&amp;iacute;nea de c&amp;oacute;digo en lugar de cinco).</target>
        </trans-unit>
        <trans-unit id="18c4f89ccd64d4745a0ce358a66f7450a781b0a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THAT is IT&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;ESO ES&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e71411d3df4fe0bd35c4b498343bf90c08652137" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE 05/10/2010:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ACTUALIZACI&amp;Oacute;N 10/05/2010:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="86a9fd4506d2f1904c60a22271b325d8665578a8" translate="yes" xml:space="preserve">
          <source>And so, I can now update the display with one line, from anywhere in the entire program in the manner which you think it would work without any threading:</source>
          <target state="translated">Y así,ahora puedo actualizar la pantalla con una línea,desde cualquier lugar en todo el programa de la manera que usted piensa que funcionaría sin ningún tipo de hilo:</target>
        </trans-unit>
        <trans-unit id="92eb0cd81eb0849be1e04dcb26e19c8969ffeb0e" translate="yes" xml:space="preserve">
          <source>And the delegate can update a Label on the GUI:</source>
          <target state="translated">Y el delegado puede actualizar una etiqueta en la interfaz gráfica de usuario:</target>
        </trans-unit>
        <trans-unit id="31cf02132c161d997ad0904997ef28bbf25cf885" translate="yes" xml:space="preserve">
          <source>As you see &lt;code&gt;if(InvokeRequired) {something long}&lt;/code&gt; you just know &quot;this function is safe to call from another thread&quot;.</source>
          <target state="translated">Como puede ver &lt;code&gt;if(InvokeRequired) {something long}&lt;/code&gt; simplemente sabe &quot;esta funci&amp;oacute;n es segura para llamar desde otro hilo&quot;.</target>
        </trans-unit>
        <trans-unit id="4a35af3462ca25779e2ead4d564c4eae67de2e9a" translate="yes" xml:space="preserve">
          <source>Asynchronous implementation of an event handler (Yes, that's all):</source>
          <target state="translated">Implementación asincrónica de un manejador de eventos (Sí,eso es todo):</target>
        </trans-unit>
        <trans-unit id="8b1c94f495b755cc182cea3bf12cd2fb5c4f86b6" translate="yes" xml:space="preserve">
          <source>Because of the triviality of the scenario I would actually have the UI thread poll for the status. I think you will find that it can be quite elegant.</source>
          <target state="translated">Debido a la trivialidad del escenario,yo tendría el sondeo del hilo de UI para el estado.Creo que encontrará que puede ser bastante elegante.</target>
        </trans-unit>
        <trans-unit id="a5e64b95b0c01be281f2ccfdf82bae3b8f9af418" translate="yes" xml:space="preserve">
          <source>Call it like this:</source>
          <target state="translated">Llámalo así:</target>
        </trans-unit>
        <trans-unit id="b6a6569e280e9bf50679b2e7fdfde8cef142de82" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;Invoke&lt;/code&gt; on the worker thread is a blocking call. It will temporarily halt the work being done in that thread.</source>
          <target state="translated">&lt;code&gt;Invoke&lt;/code&gt; en el subproceso de trabajo es una llamada de bloqueo. Se detendr&amp;aacute; temporalmente el trabajo que se realiza en ese hilo.</target>
        </trans-unit>
        <trans-unit id="97eb2b24ef99f5fc0403791b5825f6c4dddd3dda" translate="yes" xml:space="preserve">
          <source>Create a class variable:</source>
          <target state="translated">Crear una variable de clase:</target>
        </trans-unit>
        <trans-unit id="6130f4f9231c1b4bf96ddf7abe1635202ab486a4" translate="yes" xml:space="preserve">
          <source>Don't be confused with &lt;code&gt;Thread(() =&amp;gt; .....)&lt;/code&gt;. I use an anonymous function or lambda expression when I work on a thread. To reduce the lines of code you can use the &lt;code&gt;ThreadStart(..)&lt;/code&gt; method too which I am not supposed to explain here.</source>
          <target state="translated">No se confunda con &lt;code&gt;Thread(() =&amp;gt; .....)&lt;/code&gt; . Uso una funci&amp;oacute;n an&amp;oacute;nima o una expresi&amp;oacute;n lambda cuando trabajo en un hilo. Para reducir las l&amp;iacute;neas de c&amp;oacute;digo, tambi&amp;eacute;n puede usar el &lt;code&gt;ThreadStart(..)&lt;/code&gt; que no se supone que explique aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="a0acb89cb85cc4e8876d890aa4ed05b9e360f129" translate="yes" xml:space="preserve">
          <source>Finally, on .NET 4.5 and up you can also use &lt;code&gt;Progress&amp;lt;T&amp;gt;&lt;/code&gt; (which basically captures &lt;code&gt;SynchronizationContext.Current&lt;/code&gt; upon its creation) as demonstrated by &lt;a href=&quot;https://stackoverflow.com/a/18033198/67824&quot;&gt;Ryszard Dżegan's&lt;/a&gt; for cases where the long-running operation needs to run UI code while still working.</source>
          <target state="translated">Finalmente, en .NET 4.5 y &lt;a href=&quot;https://stackoverflow.com/a/18033198/67824&quot;&gt;versiones posteriores&lt;/a&gt; tambi&amp;eacute;n puede usar &lt;code&gt;Progress&amp;lt;T&amp;gt;&lt;/code&gt; (que b&amp;aacute;sicamente captura &lt;code&gt;SynchronizationContext.Current&lt;/code&gt; despu&amp;eacute;s de su creaci&amp;oacute;n) como lo demostr&amp;oacute; Ryszard Dżegan para casos en los que la operaci&amp;oacute;n de larga duraci&amp;oacute;n necesita ejecutar c&amp;oacute;digo de interfaz de usuario mientras a&amp;uacute;n funciona.</target>
        </trans-unit>
        <trans-unit id="ec398c7a3d79e8c67608a9ce86eab350611e8846" translate="yes" xml:space="preserve">
          <source>Fire and forget extension method for .NET 3.5+</source>
          <target state="translated">Método de extensión &quot;Dispara y olvida&quot; para .NET 3.5+</target>
        </trans-unit>
        <trans-unit id="2e35b1fb8ba3d7e2dd21da213a139491ce2a4046" translate="yes" xml:space="preserve">
          <source>For .NET 2.0, here's a nice bit of code I wrote that does exactly what you want, and works for any property on a &lt;code&gt;Control&lt;/code&gt;:</source>
          <target state="translated">Para .NET 2.0, aqu&amp;iacute; hay un buen c&amp;oacute;digo que escrib&amp;iacute; que hace exactamente lo que quieres y funciona para cualquier propiedad en un &lt;code&gt;Control&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2beba6e59821c8a1127e2df78047c54d33830c4f" translate="yes" xml:space="preserve">
          <source>For .NET 3.0 you should use this code:</source>
          <target state="translated">Para .NET 3.0 deberías usar este código:</target>
        </trans-unit>
        <trans-unit id="98dff10044987f5f2e03ce583b305d872fa344ec" translate="yes" xml:space="preserve">
          <source>For &lt;strong&gt;WinForms&lt;/strong&gt;:</source>
          <target state="translated">Para &lt;strong&gt;WinForms&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="56bbfb092f2e4518b7c0ee804f7a1dd641583300" translate="yes" xml:space="preserve">
          <source>For a function that has arguments:</source>
          <target state="translated">Para una función que tiene argumentos:</target>
        </trans-unit>
        <trans-unit id="1b7c73ed1ea910b060aaea933548856fef7a9a25" translate="yes" xml:space="preserve">
          <source>For a more verbose examples see: &lt;a href=&quot;http://channel9.msdn.com/Events/TechEd/Australia/Tech-Ed-Australia-2011/DEV411&quot;&gt;The Future of C#: Good things come to those who 'await'&lt;/a&gt; by &lt;a href=&quot;http://www.linkedin.com/in/albahari&quot;&gt;Joseph Albahari&lt;/a&gt;.</source>
          <target state="translated">Para ver ejemplos m&amp;aacute;s detallados, ver: &lt;a href=&quot;http://channel9.msdn.com/Events/TechEd/Australia/Tech-Ed-Australia-2011/DEV411&quot;&gt;El futuro de C #: Las cosas buenas llegan a quienes 'esperan'&lt;/a&gt; por &lt;a href=&quot;http://www.linkedin.com/in/albahari&quot;&gt;Joseph Albahari&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6904a474c24d10e266026cccdd06550753898a0a" translate="yes" xml:space="preserve">
          <source>For example, access a control other than in the current thread:</source>
          <target state="translated">Por ejemplo,acceder a un control que no esté en el hilo actual:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="faf13e57945a7572c6f9e83ad1f17bafee632f3d" translate="yes" xml:space="preserve">
          <source>For many purposes it's as simple as this:</source>
          <target state="translated">Para muchos propósitos es tan simple como esto:</target>
        </trans-unit>
        <trans-unit id="3b2e156fbe1d1b92baf603cda3f080390c5c043f" translate="yes" xml:space="preserve">
          <source>For no arguments:</source>
          <target state="translated">Sin discusiones:</target>
        </trans-unit>
        <trans-unit id="997bf8d685345ddc24ee54a5b37af9603b7393b0" translate="yes" xml:space="preserve">
          <source>Handling exceptions</source>
          <target state="translated">Manejo de excepciones</target>
        </trans-unit>
        <trans-unit id="cc36938e8dad96fe3d3b7f2b4f5f92c96a7453c7" translate="yes" xml:space="preserve">
          <source>Handling long work</source>
          <target state="translated">Manejar un trabajo largo</target>
        </trans-unit>
        <trans-unit id="c8f223d1c487f7583dd813f1ecc75eddaba6910a" translate="yes" xml:space="preserve">
          <source>Hence I added the runtime checks to ensure that the passed-in property does actually belong to the &lt;code&gt;Control&lt;/code&gt; that the method's being called on. Not perfect, but still a lot better than the .NET 2.0 version.</source>
          <target state="translated">Por lo tanto, agregu&amp;eacute; las comprobaciones de tiempo de ejecuci&amp;oacute;n para garantizar que la propiedad transferida realmente pertenezca al &lt;code&gt;Control&lt;/code&gt; al que se llama el m&amp;eacute;todo. No es perfecto, pero sigue siendo mucho mejor que la versi&amp;oacute;n .NET 2.0.</target>
        </trans-unit>
        <trans-unit id="91e5087eaf54fef1ea7de0b2cc2c05ec2df6078a" translate="yes" xml:space="preserve">
          <source>How could I do that?</source>
          <target state="translated">¿Cómo podría hacer eso?</target>
        </trans-unit>
        <trans-unit id="4f9b3d0143e673c727a6b3bca332d46bae2e97c3" translate="yes" xml:space="preserve">
          <source>How do I update the GUI from another thread</source>
          <target state="translated">¿Cómo actualizo la interfaz gráfica de usuario desde otro hilo</target>
        </trans-unit>
        <trans-unit id="e30cbf94521432af2759b5116a560d2c9047e2d2" translate="yes" xml:space="preserve">
          <source>I am yet to find out what the above line means, but it works.</source>
          <target state="translated">Aún no he averiguado qué significa la línea anterior,pero funciona.</target>
        </trans-unit>
        <trans-unit id="d75f4c8516e085079c2b37c9d22d6534ebf9b1bb" translate="yes" xml:space="preserve">
          <source>I feed my forms that get updated by another thread with an instance of this &lt;strong&gt;ThreadSafeGuiCommand&lt;/strong&gt;, and I define methods that update the GUI (in my Form) like this:</source>
          <target state="translated">Alimento mis formularios que son actualizados por otro hilo con una instancia de este &lt;strong&gt;ThreadSafeGuiCommand&lt;/strong&gt; , y defino m&amp;eacute;todos que actualizan la GUI (en mi formulario) de esta manera:</target>
        </trans-unit>
        <trans-unit id="b3e97b17cf9ba388b9d642a6a1c3fcdebc54d0c2" translate="yes" xml:space="preserve">
          <source>I have a &lt;code&gt;Form&lt;/code&gt; running on &lt;code&gt;thread1&lt;/code&gt;, and from that I'm starting another thread (&lt;code&gt;thread2&lt;/code&gt;).</source>
          <target state="translated">Tengo un &lt;code&gt;Form&lt;/code&gt; ejecut&amp;aacute;ndose en &lt;code&gt;thread1&lt;/code&gt; , y a partir de ah&amp;iacute; estoy comenzando otro thread ( &lt;code&gt;thread2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="673c3233f31fc8161d1b8335bf93aed55c89f33d" translate="yes" xml:space="preserve">
          <source>I have a &lt;strong&gt;WPF&lt;/strong&gt; application and have defined a worker as below:</source>
          <target state="translated">Tengo una aplicaci&amp;oacute;n &lt;strong&gt;WPF&lt;/strong&gt; y he definido un trabajador de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="0a0d08ab211012a7374ff01f309c22ef8996d5d1" translate="yes" xml:space="preserve">
          <source>I have a dialog form called &lt;code&gt;form_Diagnostics,&lt;/code&gt; which has a richtext box, called &lt;code&gt;updateDiagWindow,&lt;/code&gt; which I am using as a sort of logging display.  I needed to be able to update its text from all threads. The extra lines allow the window to automatically scroll to the newest lines.</source>
          <target state="translated">Tengo un formulario de di&amp;aacute;logo llamado &lt;code&gt;form_Diagnostics,&lt;/code&gt; que tiene un cuadro de texto enriquecido, llamado &lt;code&gt;updateDiagWindow,&lt;/code&gt; que estoy usando como una especie de pantalla de registro. Necesitaba poder actualizar su texto desde todos los hilos. Las l&amp;iacute;neas adicionales permiten que la ventana se desplace autom&amp;aacute;ticamente a las l&amp;iacute;neas m&amp;aacute;s nuevas.</target>
        </trans-unit>
        <trans-unit id="132fe4097141f95bb8edf31f41595d41d8bbe0f0" translate="yes" xml:space="preserve">
          <source>I just read the answers and this appears to be a very hot topic. I'm currently using .NET 3.5 SP1 and Windows Forms.</source>
          <target state="translated">Acabo de leer las respuestas y esto parece ser un tema muy caliente.Actualmente estoy usando .NET 3.5 SP1 y Windows Forms.</target>
        </trans-unit>
        <trans-unit id="f7e90bc70333188d650eb16c562d30a498ce44cb" translate="yes" xml:space="preserve">
          <source>If anyone has any further suggestions on how to improve this code for compile-time safety, please comment!</source>
          <target state="translated">Si alguien tiene alguna otra sugerencia para mejorar este código para la seguridad en tiempo de compilación,por favor coméntelo.</target>
        </trans-unit>
        <trans-unit id="289fd35c9b61e17d98149973f29b477c011f5190" translate="yes" xml:space="preserve">
          <source>If the user closes the form just before &lt;code&gt;this.Invoke&lt;/code&gt; is called (remember, &lt;code&gt;this&lt;/code&gt; is the &lt;code&gt;Form&lt;/code&gt; object), an &lt;code&gt;ObjectDisposedException&lt;/code&gt; will be likely fired.</source>
          <target state="translated">Si el usuario cierra el formulario justo antes de &lt;code&gt;this.Invoke&lt;/code&gt; se llama a Invoke (recuerde, &lt;code&gt;this&lt;/code&gt; es el objeto &lt;code&gt;Form&lt;/code&gt; ), es probable que se &lt;code&gt;ObjectDisposedException&lt;/code&gt; una excepci&amp;oacute;n ObjectDisposedException .</target>
        </trans-unit>
        <trans-unit id="12ac3feffdf8fef0f3c58110db30508567a1b86d" translate="yes" xml:space="preserve">
          <source>If you're using .NET 3.0 or above, you could rewrite the above method as an extension method of the &lt;code&gt;Control&lt;/code&gt; class, which would then simplify the call to:</source>
          <target state="translated">Si est&amp;aacute; utilizando .NET 3.0 o superior, podr&amp;iacute;a volver a escribir el m&amp;eacute;todo anterior como un m&amp;eacute;todo de extensi&amp;oacute;n de la clase &lt;code&gt;Control&lt;/code&gt; , que luego simplificar&amp;iacute;a la llamada a:</target>
        </trans-unit>
        <trans-unit id="02404b5453ff580641d38103cb594dc85397418b" translate="yes" xml:space="preserve">
          <source>Implementation of the second thread that notifies the UI thread:</source>
          <target state="translated">Implementación del segundo hilo que notifica el hilo de la UI:</target>
        </trans-unit>
        <trans-unit id="f87ff8dd949c92969afc3406bf77ce811681cb41" translate="yes" xml:space="preserve">
          <source>In order to do this, you'll have to Invoke the event-handler instead of calling it directly.</source>
          <target state="translated">Para ello,tendrás que invocar al encargado del evento en lugar de llamarlo directamente.</target>
        </trans-unit>
        <trans-unit id="4bc79a4a1bcef7705ee83799ec4eecbba2db8fff" translate="yes" xml:space="preserve">
          <source>In order to easily raise events this way, I've created an extension method, which allows me to simplify raising an event by just calling:</source>
          <target state="translated">Para poder levantar fácilmente los eventos de esta manera,he creado un método de extensión,que me permite simplificar el levantamiento de un evento con sólo llamar:</target>
        </trans-unit>
        <trans-unit id="b830d14884e12014b9fbbb1b8c12c03362e347d8" translate="yes" xml:space="preserve">
          <source>In order to make sure that the code above works with Windows Forms and WPF, and all other platforms, you can have a look at the &lt;code&gt;AsyncOperation&lt;/code&gt;, &lt;code&gt;AsyncOperationManager&lt;/code&gt; and &lt;code&gt;SynchronizationContext&lt;/code&gt; classes.</source>
          <target state="translated">Para asegurarse de que el c&amp;oacute;digo anterior funcione con Windows Forms y WPF, y todas las dem&amp;aacute;s plataformas, puede echar un vistazo a las &lt;code&gt;AsyncOperation&lt;/code&gt; , &lt;code&gt;AsyncOperationManager&lt;/code&gt; y &lt;code&gt;SynchronizationContext&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bafa3bcbde8b11dd6f6f8474aefd0328f29bcfe" translate="yes" xml:space="preserve">
          <source>In this way I'm quite sure that I will have my GUI updated whatever thread will make the call, optionally waiting for a well-defined amount of time (the timeout).</source>
          <target state="translated">De esta manera estoy bastante seguro de que tendré mi GUI actualizada,sea cual sea el hilo que haga la llamada,opcionalmente esperando una cantidad de tiempo bien definida (el timeout).</target>
        </trans-unit>
        <trans-unit id="276b67ef3fc2886fd07cc136f0032509ab969c9c" translate="yes" xml:space="preserve">
          <source>Issue:</source>
          <target state="translated">Issue:</target>
        </trans-unit>
        <trans-unit id="5c09f5610595c3681b6b9f8f860e90814d3912f2" translate="yes" xml:space="preserve">
          <source>It adds null-checking to the result of the &quot;as MemberExpression&quot;.</source>
          <target state="translated">Añade el control de nulidad al resultado de la &quot;expresión como miembro&quot;.</target>
        </trans-unit>
        <trans-unit id="1b357f202ac6a997dd222e67afc35f9fc43181a2" translate="yes" xml:space="preserve">
          <source>It improves the static type-safety.</source>
          <target state="translated">Mejora la seguridad del tipo estático.</target>
        </trans-unit>
        <trans-unit id="2049dc7e0c56277861206c459256923e73eae66d" translate="yes" xml:space="preserve">
          <source>Make a delegate like this:</source>
          <target state="translated">Hacer un delegado como este:</target>
        </trans-unit>
        <trans-unit id="056232f0995be14e2c690931206e0b7768bc0410" translate="yes" xml:space="preserve">
          <source>Make sure you do not call &lt;code&gt;BeginInvoke&lt;/code&gt; too frequently or it could overrun the message pump.</source>
          <target state="translated">Aseg&amp;uacute;rese de no llamar a &lt;code&gt;BeginInvoke&lt;/code&gt; con demasiada frecuencia o podr&amp;iacute;a sobrepasar la bomba de mensajes.</target>
        </trans-unit>
        <trans-unit id="95fbbc35d31bba9e8d7c5dfc4ef99aabafcb4a88" translate="yes" xml:space="preserve">
          <source>Most of the other answers are a little complex for me on this question (I'm new to C#), so I am writing mine:</source>
          <target state="translated">La mayoría de las otras respuestas son un poco complejas para mí en esta pregunta (soy nuevo en C#),así que estoy escribiendo la mía:</target>
        </trans-unit>
        <trans-unit id="51e734044597a111c1f012c920b2b3988f90701f" translate="yes" xml:space="preserve">
          <source>My version is to insert &lt;strong&gt;one line&lt;/strong&gt; of recursive &quot;mantra&quot;:</source>
          <target state="translated">Mi versi&amp;oacute;n es insertar &lt;strong&gt;una l&amp;iacute;nea&lt;/strong&gt; de &quot;mantra&quot; recursivo:</target>
        </trans-unit>
        <trans-unit id="2558a11cabafcc1fceb617a3bb2f29ff0e2d092a" translate="yes" xml:space="preserve">
          <source>None of the Invoke stuff in the previous answers is necessary.</source>
          <target state="translated">Nada de lo de Invocar en las respuestas anteriores es necesario.</target>
        </trans-unit>
        <trans-unit id="fdf42dcb4fbc864cb93f4aafe738399a8c2b9a1b" translate="yes" xml:space="preserve">
          <source>Not only is the property name now checked at compile time, the property's type is as well, so it's impossible to (for example) assign a string value to a boolean property, and hence cause a runtime exception.</source>
          <target state="translated">No sólo se comprueba el nombre de la propiedad en tiempo de compilación,sino que también se comprueba el tipo de la propiedad,por lo que es imposible (por ejemplo)asignar un valor de cadena a una propiedad booleana y,por lo tanto,causar una excepción en tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="f8785b60684e9800ab98a1dc1bf249b101f93460" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;BeginInvoke()&lt;/code&gt; is preferred over &lt;code&gt;Invoke()&lt;/code&gt; because it's less likely to cause deadlocks (however, this is not an issue here when just assigning text to a label):</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;BeginInvoke()&lt;/code&gt; se prefiere sobre &lt;code&gt;Invoke()&lt;/code&gt; porque es menos probable que cause puntos muertos (sin embargo, esto no es un problema aqu&amp;iacute; cuando solo se asigna texto a una etiqueta):</target>
        </trans-unit>
        <trans-unit id="3b46560eddc4c2f341e378a4c3cff35634afa23f" translate="yes" xml:space="preserve">
          <source>Note that on .NET 4.0 and up you should really be using tasks for async operations. See &lt;a href=&quot;https://stackoverflow.com/a/23596503/67824&quot;&gt;n-san's&lt;/a&gt; answer for the equivalent task-based approach (using &lt;code&gt;TaskScheduler.FromCurrentSynchronizationContext&lt;/code&gt;).</source>
          <target state="translated">Tenga en cuenta que en .NET 4.0 y versiones posteriores realmente deber&amp;iacute;a estar utilizando tareas para operaciones as&amp;iacute;ncronas. Vea &lt;a href=&quot;https://stackoverflow.com/a/23596503/67824&quot;&gt;la&lt;/a&gt; respuesta de n-san para el enfoque basado en tareas equivalente (usando &lt;code&gt;TaskScheduler.FromCurrentSynchronizationContext&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8103dd89abcff6d3327db6c01953b9066dbdc3d4" translate="yes" xml:space="preserve">
          <source>Note that the code above will not work on WPF projects, since WPF controls do not implement the &lt;code&gt;ISynchronizeInvoke&lt;/code&gt; interface.</source>
          <target state="translated">Tenga en cuenta que el c&amp;oacute;digo anterior no funcionar&amp;aacute; en proyectos WPF, ya que los controles WPF no implementan la interfaz &lt;code&gt;ISynchronizeInvoke&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c771f07cef7313574a9235981615ab2f7d9d44ab" translate="yes" xml:space="preserve">
          <source>Notice that &lt;code&gt;Invoke&lt;/code&gt; blocks execution until it completes--this is synchronous code. The question doesn't ask about asynchronous code, but there is lots of &lt;a href=&quot;https://stackoverflow.com/search?q=c%23+await+async+pattern&quot;&gt;content on Stack Overflow&lt;/a&gt; about writing asynchronous code when you want to learn about it.</source>
          <target state="translated">Observe que &lt;code&gt;Invoke&lt;/code&gt; bloquea la ejecuci&amp;oacute;n hasta que se complete; este es un c&amp;oacute;digo s&amp;iacute;ncrono. La pregunta no se refiere al c&amp;oacute;digo asincr&amp;oacute;nico, pero hay mucho &lt;a href=&quot;https://stackoverflow.com/search?q=c%23+await+async+pattern&quot;&gt;contenido en Stack Overflow&lt;/a&gt; sobre la escritura de c&amp;oacute;digo asincr&amp;oacute;nico cuando desea obtener informaci&amp;oacute;n al respecto.</target>
        </trans-unit>
        <trans-unit id="0a1c8d08a9994e288f56b821c9bf285da6f45d73" translate="yes" xml:space="preserve">
          <source>Notice the following:</source>
          <target state="translated">Fíjese en lo siguiente:</target>
        </trans-unit>
        <trans-unit id="d16a100a5358238efcfc9836314ca5968079b253" translate="yes" xml:space="preserve">
          <source>Of course, you can also make use of the BackGroundWorker class, which will abstract this matter for you.</source>
          <target state="translated">Por supuesto,también puede hacer uso de la clase de BackGroundWorker,que hará un resumen de este asunto para usted.</target>
        </trans-unit>
        <trans-unit id="66466dd59f9ceb2a8b17064a55b074d3b8c714ae" translate="yes" xml:space="preserve">
          <source>One final thing, be sure to set the &lt;code&gt;WorkerReportsProgress&lt;/code&gt; flag, or the &lt;code&gt;ReportProgress&lt;/code&gt; method will be completely ignored.</source>
          <target state="translated">Una &amp;uacute;ltima cosa, aseg&amp;uacute;rese de establecer el indicador &lt;code&gt;WorkerReportsProgress&lt;/code&gt; , o el m&amp;eacute;todo &lt;code&gt;ReportProgress&lt;/code&gt; ser&amp;aacute; completamente ignorado.</target>
        </trans-unit>
        <trans-unit id="12d48e80773109c8f6b741f7df399cd3845e0c23" translate="yes" xml:space="preserve">
          <source>Optional stuff:
Personally I came up coding the following:</source>
          <target state="translated">Cosas opcionales:Personalmente,he llegado a codificar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="100c1db1be5b773c9c74b97faae9575686f93549" translate="yes" xml:space="preserve">
          <source>Or use Action delegate instead:</source>
          <target state="translated">O utilizar el delegado de acción en su lugar:</target>
        </trans-unit>
        <trans-unit id="b61328bc36dfc2cefe53b2d82b151660926a54f0" translate="yes" xml:space="preserve">
          <source>Otherwise, the original is a very nice solution.</source>
          <target state="translated">Por lo demás,el original es una solución muy agradable.</target>
        </trans-unit>
        <trans-unit id="23f14e23058aa2b641c25cfbb0f02248fbc6d917" translate="yes" xml:space="preserve">
          <source>Progress class (see &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/hh138298.aspx&quot;&gt;IProgress Interface&lt;/a&gt;) that supports &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;Separation of Concerns (SoC)&lt;/a&gt; design principle and doesn't require explicit dispatcher and invoking. It uses the current &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.threading.synchronizationcontext.aspx&quot;&gt;SynchronizationContext&lt;/a&gt; from its creation place (here the UI thread).</source>
          <target state="translated">Clase de progreso (ver &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/hh138298.aspx&quot;&gt;Interfaz de IProgress&lt;/a&gt; ) que admite el principio de dise&amp;ntilde;o &lt;a href=&quot;http://en.wikipedia.org/wiki/Separation_of_concerns&quot;&gt;de Separaci&amp;oacute;n de preocupaciones (SoC)&lt;/a&gt; y no requiere un despachador e invocaci&amp;oacute;n expl&amp;iacute;citos. Utiliza el &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.threading.synchronizationcontext.aspx&quot;&gt;SynchronizationContext&lt;/a&gt; actual desde su lugar de creaci&amp;oacute;n (aqu&amp;iacute; el hilo de la interfaz de usuario).</target>
        </trans-unit>
        <trans-unit id="abdfeb8d9e9f9912b938c6b48378c1505d318136" translate="yes" xml:space="preserve">
          <source>Salvete! Having searched for this question, I found the answers by &lt;em&gt;FrankG&lt;/em&gt; and &lt;em&gt;Oregon Ghost&lt;/em&gt; to be the easiest most useful to me. Now, I code in Visual Basic and ran this snippet through a convertor; so I'm not sure quite how it turns out.</source>
          <target state="translated">Salvete! Despu&amp;eacute;s de buscar esta pregunta, las respuestas de &lt;em&gt;FrankG&lt;/em&gt; y &lt;em&gt;Oregon Ghost&lt;/em&gt; me parecieron las m&amp;aacute;s f&amp;aacute;ciles y &amp;uacute;tiles. Ahora, codifico en Visual Basic y ejecut&amp;eacute; este fragmento a trav&amp;eacute;s de un convertidor; as&amp;iacute; que no estoy seguro de c&amp;oacute;mo resulta.</target>
        </trans-unit>
        <trans-unit id="7365313197e7145513a48d71144c6b3db82f7f9d" translate="yes" xml:space="preserve">
          <source>See also about &lt;a href=&quot;https://stackoverflow.com/a/19023209/2042090&quot;&gt;UI Threading Model&lt;/a&gt; concept.</source>
          <target state="translated">Consulte tambi&amp;eacute;n sobre el concepto de &lt;a href=&quot;https://stackoverflow.com/a/19023209/2042090&quot;&gt;modelo de subprocesos de interfaz&lt;/a&gt; de usuario .</target>
        </trans-unit>
        <trans-unit id="2f6c77a6fa91a9c251ca66971241fa23e5e5b7c3" translate="yes" xml:space="preserve">
          <source>See here for a comparison of the two: &lt;a href=&quot;https://stackoverflow.com/questions/1167771/methodinvoker-vs-action-for-control-begininvoke&quot;&gt;MethodInvoker vs Action for Control.BeginInvoke&lt;/a&gt;</source>
          <target state="translated">Vea aqu&amp;iacute; para una comparaci&amp;oacute;n de los dos: &lt;a href=&quot;https://stackoverflow.com/questions/1167771/methodinvoker-vs-action-for-control-begininvoke&quot;&gt;MethodInvoker vs Action for Control.BeginInvoke&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="40fd68e2415e8732c933a74161b6c77553357df7" translate="yes" xml:space="preserve">
          <source>Set it in the constructor that creates your UI:</source>
          <target state="translated">Colócalo en el constructor que crea tu UI:</target>
        </trans-unit>
        <trans-unit id="52f38ef8f878567d18c1a45521f930ba910e3908" translate="yes" xml:space="preserve">
          <source>Short and clean code written in sequential manner without callbacks and explicit threads.</source>
          <target state="translated">Un código corto y limpio escrito de forma secuencial sin devoluciones de llamada e hilos explícitos.</target>
        </trans-unit>
        <trans-unit id="3467985a31de5bca2f25c74837931bdba0251217" translate="yes" xml:space="preserve">
          <source>Simply use something like this:</source>
          <target state="translated">Simplemente usa algo como esto:</target>
        </trans-unit>
        <trans-unit id="36b786dba50cd33fdb52fcf04106f6a18d10f580" translate="yes" xml:space="preserve">
          <source>Since &lt;a href=&quot;https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29#Versions&quot;&gt;.NET 4.5 and C# 5.0&lt;/a&gt; you should use &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/hh873175.aspx&quot;&gt;&lt;strong&gt;Task-based Asynchronous Pattern (TAP)&lt;/strong&gt;&lt;/a&gt; along with &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/vstudio/hh156513.aspx&quot;&gt;&lt;strong&gt;async&lt;/strong&gt;&lt;/a&gt;-&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/vstudio/hh156528.aspx&quot;&gt;&lt;strong&gt;await&lt;/strong&gt;&lt;/a&gt; keywords &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/hh873175.aspx&quot;&gt;&lt;strong&gt;&lt;em&gt;in all areas&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; (including the GUI):</source>
          <target state="translated">Desde &lt;a href=&quot;https://en.wikipedia.org/wiki/C_Sharp_%28programming_language%29#Versions&quot;&gt;.NET 4.5 y C # 5.0&lt;/a&gt; , debe usar &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/hh873175.aspx&quot;&gt;&lt;strong&gt;un patr&amp;oacute;n asincr&amp;oacute;nico basado en tareas (TAP)&lt;/strong&gt;&lt;/a&gt; junto con &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/vstudio/hh156513.aspx&quot;&gt;&lt;strong&gt;as&amp;iacute;ncrono&lt;/strong&gt;&lt;/a&gt; : &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/vstudio/hh156528.aspx&quot;&gt;&lt;strong&gt;aguarde las&lt;/strong&gt;&lt;/a&gt; palabras clave &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/hh873175.aspx&quot;&gt;&lt;strong&gt;&lt;em&gt;en todas las &amp;aacute;reas&lt;/em&gt;&lt;/strong&gt;&lt;/a&gt; (incluida la GUI):</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="b0adad1a41f59dfd023426181ac2ee9bbb1e5c3c" translate="yes" xml:space="preserve">
          <source>TAP is the recommended asynchronous design pattern for new development</source>
          <target state="translated">TAP es el patrón de diseño asíncrono recomendado para el nuevo desarrollo</target>
        </trans-unit>
        <trans-unit id="1027d988d679bf8e554c1732eadd813bbc690bca" translate="yes" xml:space="preserve">
          <source>That's fine if you always want to update the same field. If you've got more complicated updates to make, you could define a class to represent the UI state and pass it to the ReportProgress method.</source>
          <target state="translated">Está bien si siempre quieres actualizar el mismo campo.Si tienes que hacer actualizaciones más complicadas,podrías definir una clase para representar el estado de la UI y pasarla al método ReportProgress.</target>
        </trans-unit>
        <trans-unit id="39161d34d01cd3bf75ecfbcbc1975fbc70a5af52" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;InvokeRequired&lt;/strong&gt; property, as described &lt;a href=&quot;http://msdn.microsoft.com/it-it/library/system.windows.forms.control.invokerequired(v=vs.90).aspx&quot;&gt;here (Control.InvokeRequired Property reference to MSDN)&lt;/a&gt; returns true if the call was made from a thread that is not the GUI thread, false either if the call was made from the GUI thread, or if the &lt;strong&gt;Handle&lt;/strong&gt; was not created yet.</source>
          <target state="translated">La propiedad &lt;strong&gt;InvokeRequired&lt;/strong&gt; , como se describe &lt;a href=&quot;http://msdn.microsoft.com/it-it/library/system.windows.forms.control.invokerequired(v=vs.90).aspx&quot;&gt;aqu&amp;iacute; (referencia de propiedad Control.InvokeRequired a MSDN)&lt;/a&gt; devuelve verdadero si la llamada se realiz&amp;oacute; desde un subproceso que no es el subproceso GUI, falso si la llamada se realiz&amp;oacute; desde el subproceso GUI o si el &lt;strong&gt;identificador&lt;/strong&gt; fue No creado a&amp;uacute;n.</target>
        </trans-unit>
        <trans-unit id="756201256fb178cf21491ba3265438d3a68f743b" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;simplest&lt;/strong&gt; way is an anonymous method passed into &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/zyzhdc6b(v=vs.110).aspx&quot;&gt;&lt;code&gt;Label.Invoke&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">La forma &lt;strong&gt;m&amp;aacute;s simple&lt;/strong&gt; es un m&amp;eacute;todo an&amp;oacute;nimo pasado a &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/zyzhdc6b(v=vs.110).aspx&quot;&gt; &lt;code&gt;Label.Invoke&lt;/code&gt; &lt;/a&gt; . Invoke :</target>
        </trans-unit>
        <trans-unit id="8fa8a0ac6dd3403c4ef0c36c1588c7afcb068c73" translate="yes" xml:space="preserve">
          <source>The UI and worker threads remain loosely coupled as opposed to the &lt;code&gt;Control.Invoke&lt;/code&gt; or &lt;code&gt;Control.BeginInvoke&lt;/code&gt; approach which tightly couples them.</source>
          <target state="translated">La interfaz de usuario y los subprocesos de trabajo permanecen ligeramente acoplados en comparaci&amp;oacute;n con el enfoque &lt;code&gt;Control.Invoke&lt;/code&gt; o &lt;code&gt;Control.BeginInvoke&lt;/code&gt; que los une estrechamente.</target>
        </trans-unit>
        <trans-unit id="df6e6c4bb5a7f46ea2cacf1ae0fcd0a3a35bd7dd" translate="yes" xml:space="preserve">
          <source>The UI thread gets to dictate when and how often the UI gets updated.</source>
          <target state="translated">El hilo de la interfaz de usuario dicta cuándo y con qué frecuencia se actualiza la interfaz de usuario.</target>
        </trans-unit>
        <trans-unit id="47d01262caa2797c54cc31cd37be606cc13b9d94" translate="yes" xml:space="preserve">
          <source>The UI thread will not impede the progress of the worker thread.</source>
          <target state="translated">El hilo de la UI no impedirá el progreso del hilo del trabajador.</target>
        </trans-unit>
        <trans-unit id="81b51d5dd17beeed7cda13dc3eeee333fe995292" translate="yes" xml:space="preserve">
          <source>The approach avoids the marshaling operation required when using the &lt;code&gt;ISynchronizeInvoke.Invoke&lt;/code&gt; and &lt;code&gt;ISynchronizeInvoke.BeginInvoke&lt;/code&gt; methods. There is nothing wrong with using the marshaling technique, but there are a couple of caveats you need to be aware of.</source>
          <target state="translated">El enfoque evita la operaci&amp;oacute;n de &lt;code&gt;ISynchronizeInvoke.Invoke&lt;/code&gt; necesaria cuando se utilizan los m&amp;eacute;todos ISynchronizeInvoke.Invoke e &lt;code&gt;ISynchronizeInvoke.BeginInvoke&lt;/code&gt; . No hay nada de malo en usar la t&amp;eacute;cnica de clasificaci&amp;oacute;n, pero hay algunas advertencias que debes tener en cuenta.</target>
        </trans-unit>
        <trans-unit id="79b47f9f0987822dc91f8dd482d9c5e991f3d35e" translate="yes" xml:space="preserve">
          <source>The below snippet is an example of how to handle exceptions and toggle button's &lt;code&gt;Enabled&lt;/code&gt; property to prevent multiple clicks during background execution.</source>
          <target state="translated">El fragmento a continuaci&amp;oacute;n es un ejemplo de c&amp;oacute;mo manejar excepciones y activar la propiedad del bot&amp;oacute;n &lt;code&gt;Enabled&lt;/code&gt; para evitar clics m&amp;uacute;ltiples durante la ejecuci&amp;oacute;n en segundo plano.</target>
        </trans-unit>
        <trans-unit id="e015ca7a822ecdf8f0e3421ccd4f5df68686553a" translate="yes" xml:space="preserve">
          <source>The compiler will fail if the user passes the wrong data type.</source>
          <target state="translated">El compilador fallará si el usuario pasa el tipo de datos equivocado.</target>
        </trans-unit>
        <trans-unit id="8567ff643886c694396f9e4a9d0c0d1211b1e19c" translate="yes" xml:space="preserve">
          <source>The easiest way I think:</source>
          <target state="translated">La forma más fácil que creo:</target>
        </trans-unit>
        <trans-unit id="b39707b1e5e242357e99cdebdf24e5add3a9e092" translate="yes" xml:space="preserve">
          <source>The intervals at which the UI and worker threads perform operations can remain independent.</source>
          <target state="translated">Los intervalos en los que los hilos de la UI y del trabajador realizan las operaciones pueden permanecer independientes.</target>
        </trans-unit>
        <trans-unit id="55abdac7d630f4990d136d5aa079d215cae4975d" translate="yes" xml:space="preserve">
          <source>The simple solution is to use &lt;code&gt;Control.Invoke&lt;/code&gt;.</source>
          <target state="translated">La soluci&amp;oacute;n simple es usar &lt;code&gt;Control.Invoke&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="697cecf0765f8d870b9a2135694b6c3743b72472" translate="yes" xml:space="preserve">
          <source>The solution is to use &lt;code&gt;SynchronizationContext&lt;/code&gt;, specifically &lt;code&gt;SynchronizationContext.Current&lt;/code&gt; as &lt;a href=&quot;https://stackoverflow.com/a/21888091/67824&quot;&gt;hamilton.danielb&lt;/a&gt; suggests (other answers rely on specific &lt;code&gt;SynchronizationContext&lt;/code&gt; implementations which is completely unnecessary). I would slightly modify his code to use &lt;code&gt;SynchronizationContext.Post&lt;/code&gt; rather than &lt;code&gt;SynchronizationContext.Send&lt;/code&gt; though (as there's typically no need for the worker thread to wait):</source>
          <target state="translated">La soluci&amp;oacute;n es usar &lt;code&gt;SynchronizationContext&lt;/code&gt; , espec&amp;iacute;ficamente &lt;code&gt;SynchronizationContext.Current&lt;/code&gt; como sugiere &lt;a href=&quot;https://stackoverflow.com/a/21888091/67824&quot;&gt;hamilton.danielb&lt;/a&gt; (otras respuestas se basan en implementaciones espec&amp;iacute;ficas de &lt;code&gt;SynchronizationContext&lt;/code&gt; que son completamente innecesarias). Modificar&amp;iacute;a ligeramente su c&amp;oacute;digo para usar &lt;code&gt;SynchronizationContext.Post&lt;/code&gt; en lugar de &lt;code&gt;SynchronizationContext.Send&lt;/code&gt; (aunque normalmente no hay necesidad de que el hilo de trabajo espere):</target>
        </trans-unit>
        <trans-unit id="b3f8d0f13fffd30bb077dcec3d38358ee933a1bb" translate="yes" xml:space="preserve">
          <source>The strategy I propose in this answer reverses the communication roles of the threads. Instead of the worker thread pushing the data the UI thread polls for it. This a common pattern used in many scenarios. Since all you are wanting to do is display progress information from the worker thread then I think you will find that this solution is a great alternative to the marshaling solution. It has the following advantages.</source>
          <target state="translated">La estrategia que propongo en esta respuesta invierte los papeles de comunicación de los hilos.En lugar de que el hilo de los trabajadores empuje los datos,el hilo de la UI los sondea.Este es un patrón común usado en muchos escenarios.Dado que todo lo que quieres hacer es mostrar la información de progreso del hilo de trabajadores,creo que encontrarás que esta solución es una gran alternativa a la solución de clasificación.Tiene las siguientes ventajas.</target>
        </trans-unit>
        <trans-unit id="e2bf2df106b88f13d3a763d19ed8cd2c16ab6024" translate="yes" xml:space="preserve">
          <source>The vast majority of answers use &lt;code&gt;Control.Invoke&lt;/code&gt; which is a &lt;a href=&quot;https://stackoverflow.com/a/7480544/67824&quot;&gt;race condition waiting to happen&lt;/a&gt;. For example, consider the accepted answer:</source>
          <target state="translated">La gran mayor&amp;iacute;a de las respuestas usan &lt;code&gt;Control.Invoke&lt;/code&gt; , que es una &lt;a href=&quot;https://stackoverflow.com/a/7480544/67824&quot;&gt;condici&amp;oacute;n de carrera que espera suceder&lt;/a&gt; . Por ejemplo, considere la respuesta aceptada:</target>
        </trans-unit>
        <trans-unit id="604d10e37bd6af9f02cf2c7b04e768daa803e87b" translate="yes" xml:space="preserve">
          <source>The well-known formula greatly described in the previous answers that makes use of the &lt;strong&gt;InvokeRequired&lt;/strong&gt; property covers most of the cases, but not the entire pool.</source>
          <target state="translated">La conocida f&amp;oacute;rmula ampliamente descrita en las respuestas anteriores que hace uso de la propiedad &lt;strong&gt;InvokeRequired&lt;/strong&gt; cubre la mayor&amp;iacute;a de los casos, pero no todo el grupo.</target>
        </trans-unit>
        <trans-unit id="890683f7e44a47f2e3e262a17effcf44679d2e5d" translate="yes" xml:space="preserve">
          <source>The worker thread cannot dominate the time the UI thread spends updating.</source>
          <target state="translated">El hilo del trabajador no puede dominar el tiempo que el hilo de la UI pasa actualizándose.</target>
        </trans-unit>
        <trans-unit id="24c15df597a8d91320fbb037c4c52d1c2ac1d46d" translate="yes" xml:space="preserve">
          <source>The worker thread cannot overrun the UI thread's message pump.</source>
          <target state="translated">El hilo de trabajo no puede sobrecargar la bomba de mensajes del hilo de la UI.</target>
        </trans-unit>
        <trans-unit id="e403b384ca605c89f5c9fda03bc185ce21b30ae6" translate="yes" xml:space="preserve">
          <source>Then in the UI you need to cross threads to change the actual control... like a label or a progress bar.</source>
          <target state="translated">Entonces en la UI necesitas cruzar hilos para cambiar el control real...como una etiqueta o una barra de progreso.</target>
        </trans-unit>
        <trans-unit id="4aa5926b4ce72b26fddea8c5290a922f2a8c4579" translate="yes" xml:space="preserve">
          <source>Then you can chain your tasks so that when the result is ready then another task (which is scheduled on the UI thread) picks it and assigns it to a label.</source>
          <target state="translated">Entonces puedes encadenar tus tareas para que cuando el resultado esté listo,otra tarea (que está programada en el hilo de la interfaz de usuario)lo recoja y lo asigne a una etiqueta.</target>
        </trans-unit>
        <trans-unit id="b493d42db3d0b22ec3d0ca66af71edce5ca57b85" translate="yes" xml:space="preserve">
          <source>Then, the recommended solution for new development is:</source>
          <target state="translated">Entonces,la solución recomendada para el nuevo desarrollo es:</target>
        </trans-unit>
        <trans-unit id="30f7e9ddf06f0e7aa560f115e09993fdf9cf8354" translate="yes" xml:space="preserve">
          <source>There the &lt;code&gt;lblThreshold&lt;/code&gt; is a Label and &lt;code&gt;Speed_Threshold&lt;/code&gt; is a global variable.</source>
          <target state="translated">All&amp;iacute; el &lt;code&gt;lblThreshold&lt;/code&gt; es una etiqueta y &lt;code&gt;Speed_Threshold&lt;/code&gt; es una variable global.</target>
        </trans-unit>
        <trans-unit id="d8b1a4d114196a3469d1f751f037104143e931e4" translate="yes" xml:space="preserve">
          <source>This actually caused some of our released software to hang. It was easy enough to fix by replacing &lt;code&gt;Invoke()&lt;/code&gt; with &lt;code&gt;BeginInvoke()&lt;/code&gt;. Unless you have a need for synchronous operation, which may be the case if you need a return value, use &lt;code&gt;BeginInvoke()&lt;/code&gt;.</source>
          <target state="translated">En realidad, esto provoc&amp;oacute; que se bloqueara parte de nuestro software lanzado. Fue bastante f&amp;aacute;cil de solucionar reemplazando &lt;code&gt;Invoke()&lt;/code&gt; con &lt;code&gt;BeginInvoke()&lt;/code&gt; . A menos que necesite una operaci&amp;oacute;n s&amp;iacute;ncrona, que puede ser el caso si necesita un valor de retorno, use &lt;code&gt;BeginInvoke()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e65e8d671f84a6a2a146ac8452477f963671d53" translate="yes" xml:space="preserve">
          <source>This can be called using the following line of code:</source>
          <target state="translated">Esto se puede llamar usando la siguiente línea de código:</target>
        </trans-unit>
        <trans-unit id="5a253bbb5583b45b0a67f50671c842577192f9a8" translate="yes" xml:space="preserve">
          <source>This can cause an &lt;strong&gt;InvalidOperationException&lt;/strong&gt; if the operations before the label's update &quot;take less time&quot; (read it and interpret it as a simplification) than the time it takes for the GUI thread to create the &lt;strong&gt;Form&lt;/strong&gt;'s &lt;strong&gt;Handle&lt;/strong&gt;. This happens within the &lt;strong&gt;ShowDialog()&lt;/strong&gt; method.</source>
          <target state="translated">Esto puede causar una &lt;strong&gt;InvalidOperationException&lt;/strong&gt; si las operaciones antes de la actualizaci&amp;oacute;n de la etiqueta &quot;toman menos tiempo&quot; ( &lt;strong&gt;l&amp;eacute;alo&lt;/strong&gt; e interpretelo como una simplificaci&amp;oacute;n) que el tiempo que le toma al hilo GUI crear el &lt;strong&gt;Identificador&lt;/strong&gt; del &lt;strong&gt;Formulario&lt;/strong&gt; . Esto sucede dentro del m&amp;eacute;todo &lt;strong&gt;ShowDialog ()&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9371b80c5f5586fe1db295b43782ca3a487a2159" translate="yes" xml:space="preserve">
          <source>This in my C# 3.0 variation of Ian Kemp's solution:</source>
          <target state="translated">Esto en mi variación C#3.0 de la solución de Ian Kemp:</target>
        </trans-unit>
        <trans-unit id="36837b3159c884b81f190c3ee515db09b2793b97" translate="yes" xml:space="preserve">
          <source>This is the classic way you should do this:</source>
          <target state="translated">Esta es la forma clásica de hacer esto:</target>
        </trans-unit>
        <trans-unit id="69600c6f800be4b97d0cb2581b0ac02d97900218" translate="yes" xml:space="preserve">
          <source>This one is similar to the solution above using .NET Framework 3.0, but it solved the issue of &lt;strong&gt;compile-time safety support&lt;/strong&gt;.</source>
          <target state="translated">Esta es similar a la soluci&amp;oacute;n anterior usando .NET Framework 3.0, pero resolvi&amp;oacute; el problema del &lt;strong&gt;soporte de seguridad en tiempo&lt;/strong&gt; de &lt;strong&gt;compilaci&amp;oacute;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="fa62c9094cf0e45a7e4a6063b5094a87f058c4c6" translate="yes" xml:space="preserve">
          <source>This works for tasks (not threads) which are the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd460717.aspx&quot;&gt;preferred way of writing concurrent code now&lt;/a&gt;.</source>
          <target state="translated">Esto funciona para tareas (no hilos) que son la &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd460717.aspx&quot;&gt;forma preferida de escribir c&amp;oacute;digo concurrente ahora&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f96cff712f63bde79316d19b692dfc592274706" translate="yes" xml:space="preserve">
          <source>Threading code is often buggy and always hard to test. You don't need to write threading code to update the user interface from a background task. Just use the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.componentmodel.backgroundworker.aspx&quot;&gt;BackgroundWorker&lt;/a&gt; class to run the task and its &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/a3zbdb1t.aspx&quot;&gt;ReportProgress&lt;/a&gt; method to update the user interface. Usually, you just report a percentage complete, but there's another overload that includes a state object. Here's an example that just reports a string object:</source>
          <target state="translated">El c&amp;oacute;digo de subprocesos suele tener errores y siempre es dif&amp;iacute;cil de probar. No necesita escribir c&amp;oacute;digo de subprocesos para actualizar la interfaz de usuario desde una tarea en segundo plano. Simplemente use la clase &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.componentmodel.backgroundworker.aspx&quot;&gt;BackgroundWorker&lt;/a&gt; para ejecutar la tarea y su m&amp;eacute;todo &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/a3zbdb1t.aspx&quot;&gt;ReportProgress&lt;/a&gt; para actualizar la interfaz de usuario. Por lo general, solo informa un porcentaje completo, pero hay otra sobrecarga que incluye un objeto de estado. Aqu&amp;iacute; hay un ejemplo que solo informa un objeto de cadena:</target>
        </trans-unit>
        <trans-unit id="4e2995652eca6ee4618bdd8e0460a24c8da67b5b" translate="yes" xml:space="preserve">
          <source>To use:</source>
          <target state="translated">Para usar:</target>
        </trans-unit>
        <trans-unit id="855a24afe57fcde7916916da3235b6566b77bbd3" translate="yes" xml:space="preserve">
          <source>Try to refresh the label using this</source>
          <target state="translated">Intenta refrescar la etiqueta usando esto</target>
        </trans-unit>
        <trans-unit id="7ddd9dbab79025d426f64387b0d83c755b5e4e8e" translate="yes" xml:space="preserve">
          <source>Unfortunately this doesn't stop anyone from doing stupid things such as passing in another &lt;code&gt;Control&lt;/code&gt;'s property and value, so the following will happily compile:</source>
          <target state="translated">Desafortunadamente, esto no impide que nadie haga cosas est&amp;uacute;pidas como pasar la propiedad y el valor de otro &lt;code&gt;Control&lt;/code&gt; , por lo que lo siguiente se compilar&amp;aacute; felizmente:</target>
        </trans-unit>
        <trans-unit id="4bddb850ecf801bcf903bcdac2f98cb8c731daf3" translate="yes" xml:space="preserve">
          <source>Variation of &lt;a href=&quot;https://stackoverflow.com/questions/661561/how-to-update-the-gui-from-another-thread-in-c/661662#661662&quot;&gt;Marc Gravell's &lt;strong&gt;simplest&lt;/strong&gt; solution&lt;/a&gt; for .NET 4:</source>
          <target state="translated">Variaci&amp;oacute;n de &lt;a href=&quot;https://stackoverflow.com/questions/661561/how-to-update-the-gui-from-another-thread-in-c/661662#661662&quot;&gt;la soluci&amp;oacute;n &lt;strong&gt;m&amp;aacute;s simple&lt;/strong&gt;&lt;/a&gt; de Marc Gravell para .NET 4:</target>
        </trans-unit>
        <trans-unit id="93d59e4fac4a61382bde7634c1bf5fd82eeda470" translate="yes" xml:space="preserve">
          <source>What if the &lt;strong&gt;Handle&lt;/strong&gt; has not been created yet?</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasa si la &lt;strong&gt;manija&lt;/strong&gt; a&amp;uacute;n no se ha creado?</target>
        </trans-unit>
        <trans-unit id="39694840820e4b8992cae49492d54071f31619cc" translate="yes" xml:space="preserve">
          <source>When I encountered the same issue I sought help from Google, but rather than give me a simple solution it confused me more by giving examples of &lt;code&gt;MethodInvoker&lt;/code&gt; and blah blah blah. So I decided to solve it on my own. Here is my solution:</source>
          <target state="translated">Cuando encontr&amp;eacute; el mismo problema, busqu&amp;eacute; ayuda de Google, pero en lugar de darme una soluci&amp;oacute;n simple, me confundi&amp;oacute; m&amp;aacute;s al dar ejemplos de &lt;code&gt;MethodInvoker&lt;/code&gt; y bla, bla, bla. As&amp;iacute; que decid&amp;iacute; resolverlo por mi cuenta. Aqu&amp;iacute; est&amp;aacute; mi soluci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="117b5c3090e1de4904d1018be2cb9656af1f384a" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;Invoke()&lt;/code&gt; you are waiting for the method to return. Now, it may be that you do something in the invoked code that will need to wait for the thread, which may not be immediately obvious if it's buried in some functions that you are calling, which itself may happen indirectly via event handlers. So you would be waiting for the thread, the thread would be waiting for you and you are deadlocked.</source>
          <target state="translated">Al usar &lt;code&gt;Invoke()&lt;/code&gt; , est&amp;aacute; esperando que regrese el m&amp;eacute;todo. Ahora, puede ser que haga algo en el c&amp;oacute;digo invocado que tendr&amp;aacute; que esperar al hilo, lo que puede no ser inmediatamente obvio si est&amp;aacute; oculto en algunas funciones que est&amp;aacute; llamando, lo que en s&amp;iacute; mismo puede suceder indirectamente a trav&amp;eacute;s de controladores de eventos. Entonces estar&amp;iacute;as esperando el hilo, el hilo te estar&amp;iacute;a esperando y est&amp;aacute;s estancado.</target>
        </trans-unit>
        <trans-unit id="ace168a0655e9650d03a6eb7281a0176d46125fb" translate="yes" xml:space="preserve">
          <source>When you want to update the label:</source>
          <target state="translated">Cuando quieras actualizar la etiqueta:</target>
        </trans-unit>
        <trans-unit id="a6c30215367b2619abb1efd599355c95d38dc78a" translate="yes" xml:space="preserve">
          <source>When you're in the UI thread you could ask it for its synchronization context task scheduler. It would give you a &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd997402%28v=vs.110%29.aspx&quot;&gt;TaskScheduler&lt;/a&gt; that schedules everything on the UI thread.</source>
          <target state="translated">Cuando est&amp;eacute; en el subproceso de la interfaz de usuario, puede pedirle su programador de tareas de contexto de sincronizaci&amp;oacute;n. Le dar&amp;iacute;a un &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd997402%28v=vs.110%29.aspx&quot;&gt;TaskScheduler&lt;/a&gt; que programa todo en el hilo de la interfaz de usuario.</target>
        </trans-unit>
        <trans-unit id="aebd548c021054503461285e4f96d9292d440588" translate="yes" xml:space="preserve">
          <source>Which is the simplest way to update a &lt;code&gt;Label&lt;/code&gt; from another &lt;code&gt;Thread&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;Cu&amp;aacute;l es la forma m&amp;aacute;s sencilla de actualizar una &lt;code&gt;Label&lt;/code&gt; desde otro &lt;code&gt;Thread&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="ccf1cfc0ec51766294ead6f7014e102235b667c3" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;thread2&lt;/code&gt; is processing some files I would like to update a &lt;code&gt;Label&lt;/code&gt; on the &lt;code&gt;Form&lt;/code&gt; with the current status of &lt;code&gt;thread2&lt;/code&gt;'s work.</source>
          <target state="translated">Mientras &lt;code&gt;thread2&lt;/code&gt; procesa algunos archivos, me gustar&amp;iacute;a actualizar una &lt;code&gt;Label&lt;/code&gt; en el &lt;code&gt;Form&lt;/code&gt; con el estado actual del &lt;code&gt;thread2&lt;/code&gt; de thread2 .</target>
        </trans-unit>
        <trans-unit id="276f0c42dd06946cd66deb4e508b2933d99f22b0" translate="yes" xml:space="preserve">
          <source>You call it like this:</source>
          <target state="translated">Lo llamas así:</target>
        </trans-unit>
        <trans-unit id="eac883ef65248c488fbe272042c9115ef0e7f11b" translate="yes" xml:space="preserve">
          <source>You can call this function in a new thread like this</source>
          <target state="translated">Puedes llamar a esta función en un nuevo hilo como este</target>
        </trans-unit>
        <trans-unit id="8d8577637730eec0209d28a2bfab74ba363a6e8b" translate="yes" xml:space="preserve">
          <source>You can come across an exception if you want to have a modal form shown and updated by another thread. Because you want that form shown modally, you could do the following:</source>
          <target state="translated">Puedes encontrar una excepción si quieres que se muestre una forma modal y se actualice por otro hilo.Porque quieres que esa forma se muestre de forma modal,podrías hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="b6fc7a97eadd36502f04ede9995f8c91e25f81aa" translate="yes" xml:space="preserve">
          <source>You can do this by raising your event like this:</source>
          <target state="translated">Puedes hacerlo levantando tu evento de esta manera:</target>
        </trans-unit>
        <trans-unit id="64d8906876b7f8391b99d6ea381a03ebd72b23b2" translate="yes" xml:space="preserve">
          <source>You can handle the operation to perform if the &lt;strong&gt;Handle&lt;/strong&gt; has not been created yet: You can just ignore the GUI update (like shown in the code above) or you can wait (more risky).
This should answer the question.</source>
          <target state="translated">Puede manejar la operaci&amp;oacute;n a realizar si el &lt;strong&gt;controlador&lt;/strong&gt; a&amp;uacute;n no se ha creado: simplemente puede ignorar la actualizaci&amp;oacute;n de la GUI (como se muestra en el c&amp;oacute;digo anterior) o puede esperar (m&amp;aacute;s riesgoso). Esto deber&amp;iacute;a responder la pregunta.</target>
        </trans-unit>
        <trans-unit id="743a055c3d5e093dfdde319126585293e865c2ba" translate="yes" xml:space="preserve">
          <source>You may use the already-existing delegate &lt;code&gt;Action&lt;/code&gt;:</source>
          <target state="translated">Puede usar la &lt;code&gt;Action&lt;/code&gt; delegada ya existente:</target>
        </trans-unit>
        <trans-unit id="52dda13121e4647f295e6a6c0a7d8f0aa9581409" translate="yes" xml:space="preserve">
          <source>You must use invoke and delegate</source>
          <target state="translated">Debes usar invocar y delegar</target>
        </trans-unit>
        <trans-unit id="6f8c60526ff0287a0bfb1c1dc666f1119b1e1e4d" translate="yes" xml:space="preserve">
          <source>You need to look at WindowsFormsSynchronizationContext:</source>
          <target state="translated">Tienes que mirar WindowsFormsSynchronizationContext:</target>
        </trans-unit>
        <trans-unit id="f0a9572441b9e570c583b3d7d7241c210e0bc176" translate="yes" xml:space="preserve">
          <source>You should also check for the &lt;strong&gt;Handle&lt;/strong&gt; like this:</source>
          <target state="translated">Tambi&amp;eacute;n debe verificar el &lt;strong&gt;mango de&lt;/strong&gt; esta manera:</target>
        </trans-unit>
        <trans-unit id="2ebe7f42a2e8f4ba3bd7b673b1baede123148e84" translate="yes" xml:space="preserve">
          <source>You'll have to make sure that the update happens on the correct thread; the UI thread.</source>
          <target state="translated">Tendrás que asegurarte de que la actualización se realice en el hilo correcto;el hilo de la interfaz de usuario.</target>
        </trans-unit>
        <trans-unit id="45a682c62de33d9b5b3ebe367b58c3b4d401d546" translate="yes" xml:space="preserve">
          <source>You'll need to Invoke the method on the GUI thread. You can do that by calling Control.Invoke.</source>
          <target state="translated">Necesitarás invocar el método en el hilo de la GUI.Puedes hacerlo llamando a Control.Invoke.</target>
        </trans-unit>
        <trans-unit id="ab978b0aa28912ee18d6dfd0c3ccd422c64d3e8d" translate="yes" xml:space="preserve">
          <source>Your worker thread has an event. Your UI thread starts off another thread to do the work and hooks up that worker event so you can display the state of the worker thread.</source>
          <target state="translated">Tu hilo de trabajo tiene un evento.Tu hilo de UI inicia otro hilo para hacer el trabajo y engancha ese evento de trabajo para que puedas mostrar el estado del hilo de trabajo.</target>
        </trans-unit>
        <trans-unit id="a4904d0772e515c0faa1d297969bae0f69b5dae3" translate="yes" xml:space="preserve">
          <source>instead of &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms228963.aspx&quot;&gt;Asynchronous Programming Model (APM)&lt;/a&gt; and &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/wewwczdw.aspx&quot;&gt;Event-based Asynchronous Pattern (EAP)&lt;/a&gt; (the latter includes the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.componentmodel.backgroundworker%28v=vs.95%29.aspx&quot;&gt;BackgroundWorker Class&lt;/a&gt;).</source>
          <target state="translated">en lugar del &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms228963.aspx&quot;&gt;Modelo de programaci&amp;oacute;n asincr&amp;oacute;nica (APM)&lt;/a&gt; y el &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/wewwczdw.aspx&quot;&gt;Patr&amp;oacute;n asincr&amp;oacute;nico basado en eventos (EAP)&lt;/a&gt; (este &amp;uacute;ltimo incluye la &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/system.componentmodel.backgroundworker%28v=vs.95%29.aspx&quot;&gt;Clase BackgroundWorker&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="271f2b2b763ae88d25e8a52b1980ecf07d016741" translate="yes" xml:space="preserve">
          <source>which uses LINQ and lambda expressions to allow much cleaner, simpler and safer syntax:</source>
          <target state="translated">que utiliza expresiones LINQ y lambda para permitir una sintaxis mucho más limpia,simple y segura:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
