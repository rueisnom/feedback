<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/663171">
    <body>
      <group id="663171">
        <trans-unit id="bb2b114b08418c34507afbbccbffc6d5d5bf3b30" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MyString[a:b]&lt;/code&gt; gives you a substring from index a to (b - 1).</source>
          <target state="translated">&lt;code&gt;MyString[a:b]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为您提供了从索引a到（b-1）的子字符串。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="45760efc23fa74d2733fec0f0612f28e10359568" translate="yes" xml:space="preserve">
          <source>A common way to achieve this is by string slicing.</source>
          <target state="translated">常见的一种方法是串片法。</target>
        </trans-unit>
        <trans-unit id="be25f4f0c9fe8f4ce5332512d017bad2a2b90097" translate="yes" xml:space="preserve">
          <source>And if you left the : in the middle as well you got the simplest substring, which would be the 5th character (count starting with 0, so it's the blank in this case):</source>
          <target state="translated">如果你把&quot;:&quot;也留在中间,你就得到了最简单的子串,这将是第5个字符(以0开始的计数,所以在这种情况下是空白)。</target>
        </trans-unit>
        <trans-unit id="03696b354e1583b3d089805f502e26d680e5d58a" translate="yes" xml:space="preserve">
          <source>But Python's behaviour is different; it expects beginning and one after END (!). &lt;strong&gt;This is difficult to spot by beginners.&lt;/strong&gt; So the correct replacement for Substr(s, beginning, LENGTH) is</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是Python的行为是不同的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它期望从开始到结束（！）。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;初学者很难发现这一点。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所以Substr（s，Beginning，LENGTH）的正确替换是&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="72af277c4ceabe1b18623a423e2e12decb888f3c" translate="yes" xml:space="preserve">
          <source>How do I get a substring of a string in Python</source>
          <target state="translated">如何在Python中获取字符串的子串?</target>
        </trans-unit>
        <trans-unit id="37caeb72f5c5d2e7d4252eb43bec0c7a17770af3" translate="yes" xml:space="preserve">
          <source>I explain slice notation in great detail in &lt;a href=&quot;https://stackoverflow.com/a/24713353/541136&quot;&gt;my answer to Explain slice notation Question.&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我在&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/24713353/541136&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解释切片符号问题的答案中会&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;详细&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解释切片符号。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d17b7a78ec6e0383a5bafde74e8f4694cfe7d5d0" translate="yes" xml:space="preserve">
          <source>I would like to add two points to the discussion:</source>
          <target state="translated">我想在讨论中补充两点。</target>
        </trans-unit>
        <trans-unit id="82b061817ddb577bf0c7c4504414e4abf9b5941d" translate="yes" xml:space="preserve">
          <source>If leaving the second part means 'till the end', and if you leave the first part, does it start from the start?</source>
          <target state="translated">如果离开第二部分的意思是'一直到最后',如果离开第一部分,是不是从头开始呢?</target>
        </trans-unit>
        <trans-unit id="d8b306ae1450d9bda52b455cec40decb74041383" translate="yes" xml:space="preserve">
          <source>If leaving the second part means 'till the end', if you leave the first part, does it start from the start?</source>
          <target state="translated">如果离开第二部分是指'直到最后',如果离开第一部分,是不是从头开始呢?</target>
        </trans-unit>
        <trans-unit id="c65717911852e1d6872f5d755d62e1e51f004e12" translate="yes" xml:space="preserve">
          <source>If myString contains an account number that begins at offset 6 and has length 9, then you can extract the account number this way: &lt;code&gt;acct = myString[6:][:9]&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果myString包含以偏移量6开始且长度为9的帐号，则可以通过以下方式提取帐号：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;acct = myString[6:][:9]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a02b32e5d79c26f8f18a02f4904b52c93fa869b9" translate="yes" xml:space="preserve">
          <source>If the OP accepts that, they might want to try, in an experimental fashion,</source>
          <target state="translated">如果OP接受这一点,他们可能想尝试一下,以实验的方式。</target>
        </trans-unit>
        <trans-unit id="93b1f16641100fe48ed2fbe19f870b35997519da" translate="yes" xml:space="preserve">
          <source>If we want to know how many money I got left.</source>
          <target state="translated">如果我们想知道我还剩下多少钱。</target>
        </trans-unit>
        <trans-unit id="0fce1248c2f6eed4a9fcc962665f8d262ecf9696" translate="yes" xml:space="preserve">
          <source>If you leave out the second parameter it is implicitly the end of the string.</source>
          <target state="translated">如果你省略了第二个参数,那就是隐含在字符串的末尾。</target>
        </trans-unit>
        <trans-unit id="6bbd5068b5de96eb495b597406e2d6a02c7807d4" translate="yes" xml:space="preserve">
          <source>If you leave the first part, you get</source>
          <target state="translated">如果你离开第一部分,你会得到</target>
        </trans-unit>
        <trans-unit id="a11aedd3ff3cba312b072f8ee5867b1ac4940c95" translate="yes" xml:space="preserve">
          <source>In order to avoid that, Python offers a built-in object &lt;code&gt;slice()&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了避免这种情况，Python提供了一个内置对象&lt;/font&gt;&lt;/font&gt; &lt;code&gt;slice()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6283c8164d27c90e9a2079e99677f2b986d58d1b" translate="yes" xml:space="preserve">
          <source>Is there a way to substring a string in Python, to get a new string from the 3rd character to the end of the string?</source>
          <target state="translated">有没有一种方法可以在Python中对字符串进行子串化,从第3个字符到字符串末尾得到一个新的字符串?</target>
        </trans-unit>
        <trans-unit id="ece84792d63b0eb3323a2b54f34f10f77a5e0a5a" translate="yes" xml:space="preserve">
          <source>Is there a way to substring a string in Python, to get a new string from the third character to the end of the string?</source>
          <target state="translated">有没有一种方法可以在Python中对字符串进行子串化,从第三个字符到字符串末尾得到一个新的字符串?</target>
        </trans-unit>
        <trans-unit id="8456dba4bc6a3160a5061d6a3cc6ddc2b9c13d60" translate="yes" xml:space="preserve">
          <source>It works - no error is raised, and no default 'string padding' occurs.</source>
          <target state="translated">它可以工作--不会出现错误,也不会出现默认的 &quot;字符串填充&quot;。</target>
        </trans-unit>
        <trans-unit id="03e1b06c5166f335c0cd937a7fe8527135c9a9a0" translate="yes" xml:space="preserve">
          <source>Just for completeness as nobody else has mentioned it.  The third parameter to an array slice is a step.  So reversing a string is as simple as:</source>
          <target state="translated">只是为了完整,因为别人没有提到过。数组切片的第三个参数是一个步长。所以反转一个字符串就像。</target>
        </trans-unit>
        <trans-unit id="3d06deb4ad0950828e550bb5a48b3e3cdad172b6" translate="yes" xml:space="preserve">
          <source>Maybe I missed it, but I couldn't find a complete answer on this page to the original question(s) because variables are not further discussed here. So I had to go on searching.</source>
          <target state="translated">也许是错过了,但我在这个页面上找不到完整的答案,因为这里没有进一步讨论变量的问题。所以,我只好继续搜索。</target>
        </trans-unit>
        <trans-unit id="647f60a3db170cec777ec46450755bee5d5e163e" translate="yes" xml:space="preserve">
          <source>Maybe like &lt;code&gt;myString[2:end]&lt;/code&gt;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;也许像&lt;/font&gt;&lt;/font&gt; &lt;code&gt;myString[2:end]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="266320304024ed4917f4c0383eedc3b45372fa0e" translate="yes" xml:space="preserve">
          <source>Normal solution:</source>
          <target state="translated">正常的解决方案。</target>
        </trans-unit>
        <trans-unit id="d94acdb679afe6e50144bbec4b36193bab4a936b" translate="yes" xml:space="preserve">
          <source>Note that we include start in the slice, but we only go up to, and not including, stop.</source>
          <target state="translated">注意,我们在分片中包括了开始,但我们只上升到,不包括停止。</target>
        </trans-unit>
        <trans-unit id="ccfbc158b23c87b93608c5ad8949830687487ff3" translate="yes" xml:space="preserve">
          <source>One example seems to be missing here: full (shallow) copy.</source>
          <target state="translated">这里似乎少了一个例子:全(浅)拷贝。</target>
        </trans-unit>
        <trans-unit id="0f7ae1d404b06f46195b15ba66bb9fdf3a427083" translate="yes" xml:space="preserve">
          <source>Or selecting alternate characters would be:</source>
          <target state="translated">或者选择备用角色会是:</target>
        </trans-unit>
        <trans-unit id="6d59e79fdbcb09f7ff5df6948b0a321c806a3751" translate="yes" xml:space="preserve">
          <source>Python calls this concept &quot;slicing&quot; and it works on more than just strings. Take a look &lt;a href=&quot;https://stackoverflow.com/questions/509211/good-primer-for-python-slice-notation&quot;&gt;here&lt;/a&gt; for a comprehensive introduction.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Python称这个概念为&amp;ldquo;切片&amp;rdquo;，它不仅适用于字符串，还适用于更多的领域。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;看看&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/509211/good-primer-for-python-slice-notation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的一个全面的介绍。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="be44fab2e02ff1fb19e7a95d93ef8b0519818eba" translate="yes" xml:space="preserve">
          <source>Python has &lt;a href=&quot;https://docs.python.org/3/library/functions.html#slice&quot;&gt;slice&lt;/a&gt; objects:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Python具有&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.python.org/3/library/functions.html#slice&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;切片&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ea83de223085099ac346603fcec4963475d93d84" translate="yes" xml:space="preserve">
          <source>Since I'm not yet allowed to comment, let me add my conclusion here. I'm sure I was not the only one interested in it when accessing this page:</source>
          <target state="translated">因为我还不能发表评论,所以我在这里补充一下我的结论。我相信在进入这个页面的时候,肯定不是只有我一个人对此感兴趣。</target>
        </trans-unit>
        <trans-unit id="66f231bd4e5079d87528ea365c1c0a78cd648b1b" translate="yes" xml:space="preserve">
          <source>Slice notation has 3 important arguments:</source>
          <target state="translated">切片记号法有3个重要的论点。</target>
        </trans-unit>
        <trans-unit id="c9498238b22efa2d132165a4c9f3f72f2607b3c2" translate="yes" xml:space="preserve">
          <source>So the parameters are &lt;code&gt;beginning&lt;/code&gt; and &lt;code&gt;LENGTH&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此参数为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;beginning&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;LENGTH&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1c3c4cdf66b03592319cd5ad400b942e37774922" translate="yes" xml:space="preserve">
          <source>Substr() normally (i.e. PHP and Perl) works this way:</source>
          <target state="translated">Substr()通常是这样工作的(即PHP和Perl)。</target>
        </trans-unit>
        <trans-unit id="e6145aee3b9f1f291a76cfbe6001948067d791b1" translate="yes" xml:space="preserve">
          <source>The ability to step forwards and backwards through the string maintains consistency with being able to array slice from the start or end.</source>
          <target state="translated">通过字符串向前和后退的能力与能够从起点或终点阵列切片保持一致。</target>
        </trans-unit>
        <trans-unit id="50018a343d3d55aeef291ec49c142d3a92ace5aa" translate="yes" xml:space="preserve">
          <source>Their defaults when not given are &lt;code&gt;None&lt;/code&gt; - but we can pass them explicitly:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果未指定，则默认值为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;None&lt;/code&gt; -&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但我们可以显式传递它们：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="45b8ce25eda537c88eb131fc46d0e98ef96d08ef" translate="yes" xml:space="preserve">
          <source>This is a common idiom for creating a copy of sequence types (not of interned strings), &lt;code&gt;[:]&lt;/code&gt;. Shallow copies a list, see &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/323689/python-list-slice-used-for-no-obvious-reason&quot;&gt;Python list slice syntax used for no obvious reason&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是用于创建序列类型（而非插入字符串）&lt;/font&gt;&lt;/font&gt; &lt;code&gt;[:]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的副本的常见用法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浅表复制列表，请参阅&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/323689/python-list-slice-used-for-no-obvious-reason&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;无明显原因的Python列表切片语法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4d598ee370327f140740e84e4314ebac258c1fbf" translate="yes" xml:space="preserve">
          <source>This is particularly helpful in functions, where you can't provide an empty space as an argument:</source>
          <target state="translated">这在函数中特别有用,因为在函数中,你不能提供一个空的空间作为参数。</target>
        </trans-unit>
        <trans-unit id="0b31408034c254e21b47ef16055c38634113627a" translate="yes" xml:space="preserve">
          <source>Using hardcoded indexes itself can be a mess.</source>
          <target state="translated">使用硬编码的索引本身就会很麻烦。</target>
        </trans-unit>
        <trans-unit id="b29adcc689b53351636fa5314541d2ddd60ef848" translate="yes" xml:space="preserve">
          <source>Using slice you gain readability.</source>
          <target state="translated">使用切片,你会获得可读性。</target>
        </trans-unit>
        <trans-unit id="6eb9a8d68fff5dbfc658280b5fd9570ca2d74004" translate="yes" xml:space="preserve">
          <source>Using slices:</source>
          <target state="translated">使用切片。</target>
        </trans-unit>
        <trans-unit id="5d2dfc2c6daedb5d3cd8d310cc9f373c97f6f7c4" translate="yes" xml:space="preserve">
          <source>When step is &lt;code&gt;None&lt;/code&gt;, by default the slice uses &lt;code&gt;1&lt;/code&gt; for the step. If you step with a negative integer, Python is smart enough to go from the end to the beginning.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当step为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;None&lt;/code&gt; 时&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，默认情况下，切片将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用作步骤。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您使用负整数执行操作，则Python足够聪明，可以从头到尾进行操作。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="32edf108767dc235557702b4f4f0c5d6d73f229b" translate="yes" xml:space="preserve">
          <source>Yes, for example:</source>
          <target state="translated">是的,比如说。</target>
        </trans-unit>
        <trans-unit id="7af3e9675d4d00f605bad9ff053554eeefeb534d" translate="yes" xml:space="preserve">
          <source>Yes, this actually works if you assign, or &lt;a href=&quot;https://docs.python.org/reference/simple_stmts.html#assignment-statements&quot;&gt;bind&lt;/a&gt;, the name,&lt;code&gt;end&lt;/code&gt;, to constant singleton, &lt;code&gt;None&lt;/code&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是的，如果您将&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;名称&lt;/font&gt; &lt;code&gt;end&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;分配或&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://docs.python.org/reference/simple_stmts.html#assignment-statements&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;绑定&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到常量单例，&lt;/font&gt; &lt;code&gt;None&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这实际上是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可行的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="13178f7d6a2ee0dd15b3e1f22d9a4098c1b6f879" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;None&lt;/code&gt; instead on an empty space to specify &quot;from the start&quot; or &quot;to the end&quot;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在空白处&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;None&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来指定&amp;ldquo;从头开始&amp;rdquo;或&amp;ldquo;到末尾&amp;rdquo;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0bf08684d21f35a109bbfcb9e497852ed8628753" translate="yes" xml:space="preserve">
          <source>You've got it right there except for &quot;end&quot;. It's called slice notation. Your example should read:</source>
          <target state="translated">除了 &quot;结尾 &quot;之外,你已经弄明白了。这就是所谓的切片记号法。你的例子应该写成:</target>
        </trans-unit>
        <trans-unit id="2b020927d3c6eb407223a1baa3d6ce3597a3f88d" translate="yes" xml:space="preserve">
          <source>start</source>
          <target state="translated">start</target>
        </trans-unit>
        <trans-unit id="bd370d1b6f9b3580a77083b3ed3256c621f44a99" translate="yes" xml:space="preserve">
          <source>step</source>
          <target state="translated">step</target>
        </trans-unit>
        <trans-unit id="1b480158e1f30e0b6cee7813e9ecf094bd6b3745" translate="yes" xml:space="preserve">
          <source>stop</source>
          <target state="translated">stop</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
