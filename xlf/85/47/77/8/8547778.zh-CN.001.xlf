<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/8547778">
    <body>
      <group id="8547778">
        <trans-unit id="89ec615e8896a817a1338b981c5dd02618028624" translate="yes" xml:space="preserve">
          <source>(It shows FLOP/s for different values of &lt;code&gt;n&lt;/code&gt;.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（它显示&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不同值的FLOP / s &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="12da5ea81004fb4224ae834c50a9dde8a5706fc0" translate="yes" xml:space="preserve">
          <source>5 Regions - Explanations</source>
          <target state="translated">5个区域----解释</target>
        </trans-unit>
        <trans-unit id="b14907e1ba792b57aecd8a4bf1e7f6c09685b346" translate="yes" xml:space="preserve">
          <source>&lt;strike&gt;Here, as the data sizes increases, the amount of relative overhead goes down and the performance &quot;saturates&quot;. Here two loops is slower because it has twice as much loop and branching overhead.&lt;/strike&gt;</source>
          <target state="translated">&lt;strike&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里，随着数据大小的增加，相对开销的数量减少，性能&amp;ldquo;饱和&amp;rdquo;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里，两个循环比较慢，因为它的循环和分支开销是其两倍。&lt;/font&gt;&lt;/font&gt;&lt;/strike&gt;</target>
        </trans-unit>
        <trans-unit id="69479992a61ec0eb9e53f2ae7d6230f7aea2402f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1st Case:&lt;/strong&gt; - Only one summation but two independent function calls.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第一种情况：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -只有一个求和，但有两个独立的函数调用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="63a03495083598dadf8617e71321f11f6da3036b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2 x Intel Xeon X5482 Harpertown @ 3.2 GHz:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2个Intel Xeon X5482 Harpertown @ 3.2 GHz：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8dd2234cdf691ae3d1c9d696aa07b739c688a8b7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2nd Case:&lt;/strong&gt; - Two summations but each has its own function call.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第二种情况：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -两个求和，但每个求和都有自己的函数调用。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ac5177fa49c357654e6cf65a86c3c6135e13b3b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;6.206 seconds&lt;/strong&gt; with one loop and &lt;strong&gt;2.116 seconds&lt;/strong&gt; with two loops. This reproduces the OP's results exactly.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一圈为6.206秒&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两圈&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2.116秒&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这将准确地再现OP的结果。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="152bc0110de9ef28e70c5321422c739a7c563036" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;First Case:&lt;/em&gt;&lt;/strong&gt; On first iteration the &lt;code&gt;Boss&lt;/code&gt; has to initially go 100 feet to give the order slip to &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; goes off and does his thing, but then the &lt;code&gt;Boss&lt;/code&gt; has to travel 500 feet to &lt;code&gt;C&lt;/code&gt; to give him his order slip. Then on the next iteration and every other iteration after the &lt;code&gt;Boss&lt;/code&gt; has to go back and forth 500 feet between the two.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第一种情况：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在第一次迭代中，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须先走100英尺才能将订单单交给&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;离开并做他的事，但随后&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须走500英尺到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;才能给他单订单。然后在下一次迭代中，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之后的所有其他迭代必须在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两者之间来回500英尺。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b3d8ae7e9620b4a3b3a01e77c1f42a469984bc3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Second Case:&lt;/em&gt;&lt;/strong&gt;&lt;code&gt;The Boss&lt;/code&gt; has to travel 100 feet on the first iteration to &lt;code&gt;A&lt;/code&gt;, but after that he is already there and just waits for &lt;code&gt;A&lt;/code&gt; to get back until all slips are filled. Then the &lt;code&gt;Boss&lt;/code&gt; has to travel 500 feet on the first iteration to &lt;code&gt;C&lt;/code&gt; because &lt;code&gt;C&lt;/code&gt; is 500 feet from &lt;code&gt;A&lt;/code&gt; since this &lt;code&gt;Boss( Summation, For Loop )&lt;/code&gt; is being called right after working with &lt;code&gt;A&lt;/code&gt; and then just waits like he did with &lt;code&gt;A&lt;/code&gt; until all of &lt;code&gt;C's&lt;/code&gt; order slips are done.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第二种情况：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt; &lt;code&gt;The Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在第一次迭代中必须走100英尺才能到达&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是之后他已经在那里并且只等&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;回来直到所有单子都装满。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要旅行500英尺的第一次迭代&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是500英尺&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因为这个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss( Summation, For Loop )&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正与工作后立即叫&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，然后就等待他能像&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，直到所有的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C's&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;订单单已完成。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8db4c14c29a7d105d2f99dd7e4cab04e750bd539" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Assessing The Problem&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;评估问题&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bd63d84ed789fbfe62fd115ddd944db74e9a753b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Benchmark Results:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;基准结果：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a385dd46f24c302ea5ca744977eaa5b99101b83b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Case 1&lt;/strong&gt; is a classic interpolation problem that happens to be an inefficient one. I also think that this was one of the leading reasons of why many machine architectures and developers ended up building and designing multi-core systems with the ability to do multi-threaded applications as well as parallel programming.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;情况1&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是一个经典的插值问题，碰巧是一个效率低下的问题。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我还认为，这就是许多机器体系结构和开发人员最终构建和设计具有执行多线程应用程序以及并行编程能力的多核系统的主要原因之一。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db76f0a25108e4cb963d0a08f23235f505a9cc91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusion:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusion:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee9af54fbd9a13fc657b8c9037b7dfde2362914f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Could you provide some solid insight into the details that lead to the different cache behaviors as illustrated by the five regions on the following graph?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您能否对导致不同缓存行为的细节提供深入的了解，如下图的五个区域所示？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f64c2fa0ab45059d9d2b05c465150bbadd393a29" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT : It does in fact look like you are allocating all the arrays separately.&lt;/strong&gt;
Usually when such large allocations are requested, the allocator will request fresh pages from the OS. Therefore, there is a high chance that large allocations will appear at the same offset from a page-boundary.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编辑：实际上，它的确看起来像您是分别分配所有数组。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 通常，当请求如此大的分配时，分配器会从OS请求新页面。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，很有可能大分配将出现在与页面边界相同的偏移量处。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff82481600ca4b72142ffa0c5df31cb8e1828e64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Here's the test code:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是测试代码：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="104d7d0e822b5338538004327c987e53d73680da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I cannot replicate the results discussed here.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我无法复制此处讨论的结果。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="112ae0b490d81db4a257a03413092f9a19eef61c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In the first two tests, the arrays are allocated separately.&lt;/strong&gt; You'll notice that they all have the same alignment relative to the page.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在前两个测试中，分别分配数组。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您会注意到它们相对于页面都具有相同的对齐方式。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4eb70f5351695541ea10eb07e79eea4cb293448a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In the second two tests, the arrays are packed together to break that alignment.&lt;/strong&gt; Here you'll notice both loops are faster. Furthermore, the second (double) loop is now the slower one as you would normally expect.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在后两个测试中，将数组打包在一起以破坏对齐方式。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里，您会注意到两个循环都更快。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此外，第二（双）循环现在比通常预期的要慢。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8e94c672f74af08d7f271531102f1986340b6dec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;It might also be interesting to point out the differences between CPU/cache architectures, by providing a similar graph for these CPUs.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过为这些CPU提供类似的图形来指出CPU /缓存体系结构之间的差异也可能很有趣。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="234647d3ac335a2b9c1c73ef786914ed30da0bc5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's Investigate&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;让我们调查一下&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0992f369b3bd576e62bd26ec8024546b329d7025" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Our Assertions:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们的断言：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bce0cd5ffb2a37fba775193b4bf5ba59883c25c2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Regarding These Questions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关于这些问题&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="883cd845c12162f162451345532a4622afe44219" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Region 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;区域1：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c3a069490cad64b2abbf3ad037bad18e1f4ba80" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Region 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;区域2：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49b07d776f5d212a4b7f02a4946b33b5f222234c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Region 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;区域3：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cadf6d1e9cc3c16346b4db73abfa9efeefa2911d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Region 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;区域4：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2704be14d7b23daec07410a5dd7685d9fa30cda2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Region 5:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;区域5：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7ae2cc3d2bb2ec34c48c443e7891cfc09bd5f463" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Summary with Analogy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;类比总结&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4984ec011b334dc8f00bd50924d4167bb704d1a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Algorithms:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;算法：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df9ac0ca08c80980b68a2fa485d69fb68d2aaa69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Approach&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该方法&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eec929ed1c8347dcecf86a47fbb2804dba304932" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Comparison of Arbitrary Values&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;任意值的比较&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec70960c24f99d8101f34115f16fb94cf32e1c01" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Consideration&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;考虑&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d8b01854004cefcf81fbcc247efc2e4e0797a699" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Difference In Distances Traveled&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;行驶距离的差异&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9e3a70475f876caae8f6a04b7f0e07646a22f2ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Ending Results&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最终结果&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3bdeca04c971828619464a9072d48f1805614670" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The OPs Amended Question(s)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;OP修订的问题&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="415a6cc46e0f95521c4e7cb395b0523a2dc5c7de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Observation:&lt;/strong&gt; - &lt;em&gt;The differences between the two algorithms&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;观察结果：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两种算法之间的差异&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="76781d11095b245a6f8c86e1771fa82fec1ba4b3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Original Question&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;原始问题&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c2361582818f9044502e5f10dd5db390bc078247" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Perspective&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;观点&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7d18f8f2bee619589b857aee842936d61a6270c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The Test Cases:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;测试案例：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f94195bfa3d4122553a525b3ba8b2def28614f7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What We Do Know&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们所知道的&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f99489672c41c8daa933d99ea58acb903a2b5c58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What We Don't Know&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们不知道的&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="521b0abab75a6ac4655f23b9618ac7ccc724efb0" translate="yes" xml:space="preserve">
          <source>@Mysticial's answer convinced a lot of people (including me), probably because it was the only one that seemed to rely on facts, but it was only one &quot;data point&quot; of the truth.</source>
          <target state="translated">@Mysticial的回答说服了很多人(包括我在内),可能是因为它是唯一一个看似依赖事实的答案,但它只是真相的一个 &quot;数据点&quot;。</target>
        </trans-unit>
        <trans-unit id="0e15339689c74cb259c9d321c1b1b5454cd6bed7" translate="yes" xml:space="preserve">
          <source>A straight assignment with no computation would be a cleaner test of memory access time and would create a test that is uniform irrespective of the loop count. Maybe I missed something in the conversation, but it is worth thinking twice about. If the plus is left out of the assignment, the cumulative time is almost identical at 31 seconds each.</source>
          <target state="translated">没有计算的直接赋值会是一个更干净的内存访问时间测试,而且会产生一个不考虑循环数的统一测试。也许是我在谈话中漏掉了什么,但这是值得深思的。如果把加法遗漏在赋值中,累计时间几乎是一致的,每次31秒。</target>
        </trans-unit>
        <trans-unit id="b2921679a209c3a19ed571424cfe0ea586224ba2" translate="yes" xml:space="preserve">
          <source>After looking at the code for a while it became quite apparent what the problem is and what is generating it. Lets break this down into an algorithmic problem and look at it from the perspective of using mathematical notations then apply an analogy to the math problems as well as to the algorithms.</source>
          <target state="translated">看了一段时间的代码后,问题是什么,是什么产生的,就很明显了。让我们把这个问题分解成一个算法问题,从使用数学符号的角度来看,然后应用类比的方式来看待这个问题,同时也是算法问题。</target>
        </trans-unit>
        <trans-unit id="a01e33f4dcdb6ba1ae9f34a97cf8f6deeedf1a8d" translate="yes" xml:space="preserve">
          <source>And</source>
          <target state="translated">And</target>
        </trans-unit>
        <trans-unit id="68af471cbe64993c128953195c25db2546c9c3a6" translate="yes" xml:space="preserve">
          <source>And this approximation is the average difference between these two loops both algorithmically and machine operations involving software optimizations and machine instructions. So when the data set grows linearly, so does the difference in time between the two. Algorithm 1 has more fetches than algorithm 2 which is evident when the &lt;code&gt;Boss&lt;/code&gt; had to travel back and forth the maximum distance between &lt;code&gt;A&lt;/code&gt; &amp;amp; &lt;code&gt;C&lt;/code&gt; for every iteration after the first iteration while Algorithm 2 the &lt;code&gt;Boss&lt;/code&gt; had to travel to &lt;code&gt;A&lt;/code&gt; once and then after being done with &lt;code&gt;A&lt;/code&gt; he had to travel a maximum distance only one time when going from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;C&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个近似值是算法和机器操作（包括软件优化和机器指令）在这两个循环之间的平均差。因此，当数据集线性增长时，两者之间的时间差也将增加。算法1的取数比算法2的取数多，这在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第一次迭代后每次迭代都必须&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;之间最大距离来回移动&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而算法2 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必须&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一次又一次&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到达&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时明显可见。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;到&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;时，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一起他只能走一次最大距离&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d9088cef1499e648db384472fce2fb57166ffcad" translate="yes" xml:space="preserve">
          <source>And this is a hard-to-explain one: Initialized data, that is allocated once and reused for every following test case of different vector size:</source>
          <target state="translated">而这是一个很难解释的问题。初始化的数据,就是分配一次,并对下面每一个不同大小的向量的测试用例重复使用。</target>
        </trans-unit>
        <trans-unit id="6bc397ce8c790298abec880d37b0008e7ad386fd" translate="yes" xml:space="preserve">
          <source>Array sizes ranged from 2^16 to 2^24, using eight loops. I was careful to initialize the source arrays so the &lt;code&gt;+=&lt;/code&gt; assignment wasn't asking the &lt;a href=&quot;http://en.wikipedia.org/wiki/Floating-point_unit&quot;&gt;FPU&lt;/a&gt; to add memory garbage interpreted as a double.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用八个循环，数组大小从2 ^ 16到2 ^ 24。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我小心地初始化了源数组，因此&lt;/font&gt;&lt;/font&gt; &lt;code&gt;+=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分配没有要求&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Floating-point_unit&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FPU&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;添加解释为double的内存垃圾。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d798d18424176f8a0f98a50c4c4dec04767bbde5" translate="yes" xml:space="preserve">
          <source>As @Stephen Cannon points out in the comments, there is very likely possibility that this alignment causes &lt;strong&gt;&lt;em&gt;false aliasing&lt;/em&gt;&lt;/strong&gt; in the load/store units or the cache. I Googled around for this and found that Intel actually has a hardware counter for &lt;strong&gt;&lt;em&gt;partial address aliasing&lt;/em&gt;&lt;/strong&gt; stalls:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正如@Stephen Cannon在评论中指出的那样，这种对齐很可能导致&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;加载/存储单元或缓存中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;出现&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;错误的别名&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我在Google上搜索了一下，发现英特尔实际上有一个硬件计数器，用于&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;部分地址别名&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;停顿：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c35e4900a7c68daeafb264cda2682267df9d2546" translate="yes" xml:space="preserve">
          <source>As I have demonstrated without a doubt, there is an underlying issue even before the Hardware and Software becomes involved. Now as for the management of memory and caching along with page files, etc. which all works together in an integrated set of systems between: &lt;code&gt;The Architecture&lt;/code&gt; { Hardware, Firmware, some Embedded Drivers, Kernels and ASM Instruction Sets }, &lt;code&gt;The OS&lt;/code&gt;{ File and Memory Management systems, Drivers and the Registry }, &lt;code&gt;The Compiler&lt;/code&gt; { Translation Units and Optimizations of the Source Code }, and even the &lt;code&gt;Source Code&lt;/code&gt; itself with its set(s) of distinctive algorithms; we can already see that there is a bottleneck that is happening within the first algorithm before we even apply it to any machine with any arbitrary &lt;code&gt;Architecture&lt;/code&gt;, &lt;code&gt;OS&lt;/code&gt;, and &lt;code&gt;Programmable Language&lt;/code&gt; compared to the second algorithm. So there already existed a problem before involving the intrinsics of a modern computer.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正如我毫无疑问地证明的那样，甚至在涉及硬件和软件之前就存在一个潜在的问题。现在，有关内存和缓存以及页面文件等的管理，它们都在以下系统之间的集成系统中协同工作：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;The Architecture&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; {硬件，固件，某些嵌入式驱动程序，内核和ASM指令集}，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;The OS&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; {文件以及内存管理系统，驱动程序和注册表}，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;The Compiler&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; {源代码的翻译单元和优化}，甚至&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Source Code&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;本身及其独特算法集；我们已经看到在第一个算法中存在瓶颈，甚至在将它应用于任何具有任意&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Architecture&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与第二种算法相比&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;体系结构&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;OS&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Programmable Language&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，在涉及现代计算机的内在要素之前已经存在一个问题。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db05e8a585a74c2b37aa36f6b4ef683ef80e1764" translate="yes" xml:space="preserve">
          <source>As you might expect, initializing &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; inside the loop using &lt;code&gt;InitToZero[j]&lt;/code&gt; gave the combined approach an advantage, as they were done back-to-back before the assignments to &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt;, but still within 10%. Go figure.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如您所料，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用&lt;/font&gt; &lt;code&gt;InitToZero[j]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;在循环内&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;初始化&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;d&lt;/code&gt; 可以&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使组合方法具有优势，因为它们是在分配给&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;之前背对背完成的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但仍在10％以内。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;去搞清楚。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6eeb01c453d49806a69030f78b4610c8007b3c99" translate="yes" xml:space="preserve">
          <source>Assuming a fairly dumb caching policy of &lt;em&gt;if the byte is not in the cache, put it there and get the following byte too while we are at it&lt;/em&gt; you will get a scenario something like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设一个相当愚蠢的缓存策略是&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果该字节不在缓存中，则将其放在那里并在我们处于缓存状态时也获取下一个字节，&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您将看到类似以下的情况：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2621108dbdca1d058df9e1e89bdc18d55d8d9d56" translate="yes" xml:space="preserve">
          <source>Assuming a simple LIFO caching policy, this code:</source>
          <target state="translated">假设一个简单的LIFO缓存策略,这个代码。</target>
        </trans-unit>
        <trans-unit id="3460682488e6d7cc96dbc4d2d00519a722ffcdff" translate="yes" xml:space="preserve">
          <source>At this point, nothing fits in cache. So you're bound by memory bandwidth.</source>
          <target state="translated">这时,缓存里没有什么东西能装得下。所以,你被内存带宽所束缚。</target>
        </trans-unit>
        <trans-unit id="847dd1a8dd5a0fcb1deef24af0fdd56bf4308a6a" translate="yes" xml:space="preserve">
          <source>At this point, the data no longer fits in L1 cache. So performance is capped by the L1 &amp;lt;-&amp;gt; L2 cache bandwidth.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此时，数据不再适合L1缓存。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，性能受L1 &amp;lt;-&amp;gt; L2缓存带宽的限制。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d744e9fe7c6bd65afd8a445005ae9f5103b27665" translate="yes" xml:space="preserve">
          <source>Compiled on MS &lt;a href=&quot;http://en.wikipedia.org/wiki/Visual_C++#32-bit_versions&quot;&gt;Visual C++ 10.0&lt;/a&gt; with full optimization and &lt;a href=&quot;http://en.wikipedia.org/wiki/SSE2&quot;&gt;SSE2&lt;/a&gt; enabled for 32-bit on a &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core_2&quot;&gt;Intel Core 2&lt;/a&gt; Duo (x64), the first example takes 5.5&amp;nbsp;seconds and the double-loop example takes only 1.9&amp;nbsp;seconds. My question is: (Please refer to the my rephrased question at the bottom)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有完全优化&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;功能的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;MS &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Visual_C++#32-bit_versions&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Visual C ++ 10.0&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上编译，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core_2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Intel Core 2&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Duo（x64）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上为32位启用了&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/SSE2&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SSE2&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，第一个示例花费5.5秒，而双循环示例仅花费1.9秒。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我的问题是：（请参阅底部的我改写的问题）&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ce5cd38e3fb59188d515e8d4753f99e250f4c136" translate="yes" xml:space="preserve">
          <source>Considering the OP's original question about the 2 variants of the for loops and his amended question towards the behavior of caches along with many of the other excellent answers and useful comments; I'd like to try and do something different here by taking a different approach about this situation and problem.</source>
          <target state="translated">考虑到OP最初提出的关于for循环的2个变体的问题和他对缓存行为的修正问题,以及许多其他优秀的回答和有用的评论;我想在这里尝试做一些不同的事情,对这种情况和问题采取不同的方法。</target>
        </trans-unit>
        <trans-unit id="2658124dfdcfa4171d5ed289bdc8e7cce5a9eacb" translate="yes" xml:space="preserve">
          <source>Considering the two loops and all of the discussion about cache and page filing I'd like to take another approach as to looking at this from a different perspective. One that doesn't involve the cache and page files nor the executions to allocate memory, in fact this approach doesn't even concern the actual hardware or the software at all.</source>
          <target state="translated">考虑到这两个循环和所有关于缓存和页面文件的讨论,我想从另一个角度来看待这个问题。一个不涉及到缓存和页面文件,也不涉及到分配内存的执行,事实上,这种方法甚至根本不涉及到实际的硬件和软件。</target>
        </trans-unit>
        <trans-unit id="7cd90e2c4a5daa4b5570598684f8432ccd97991f" translate="yes" xml:space="preserve">
          <source>Could you provide some solid insight into the details that lead to the different cache behaviors as illustrated by the five regions on the following graph?</source>
          <target state="translated">你能不能提供一些确切的见解,说明导致不同的缓存行为的细节,如下图中的五个区域所示?</target>
        </trans-unit>
        <trans-unit id="45e62524f888dc26206083147534d2d045cfe01f" translate="yes" xml:space="preserve">
          <source>Disassembly for the first loop basically looks like this (this block is repeated about five times in the full program):</source>
          <target state="translated">第一个循环的解构基本上是这样的(这个块在整个程序中重复了5次左右)。</target>
        </trans-unit>
        <trans-unit id="f5aded222c02776b41379bab0f381d5cb63dc8c0" translate="yes" xml:space="preserve">
          <source>EDIT: Results on an &lt;em&gt;actual&lt;/em&gt; Core 2 architecture machine:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编辑：在&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际的&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Core 2体系结构机器&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上的结果&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c1cdf0b350bbd524d76c4339c2d1b23bdd3868e0" translate="yes" xml:space="preserve">
          <source>EDIT: The question turned out to be of no relevance, as the behavior severely depends on the sizes of the arrays (n) and the CPU cache. So if there is further interest, I rephrase the question:</source>
          <target state="translated">EDIT:这个问题被证明是没有意义的,因为这个行为严重依赖于数组的大小(n)和CPU缓存。所以,如果有进一步的兴趣,我重新提出这个问题。</target>
        </trans-unit>
        <trans-unit id="56c9875ac0dcfe30c44dfb65704f11fe74371099" translate="yes" xml:space="preserve">
          <source>Each loop of the double loop example produces this code (the following block is repeated about three times):</source>
          <target state="translated">双循环示例的每个循环都会产生这样的代码(下面的代码块大约重复三次)。</target>
        </trans-unit>
        <trans-unit id="7339be587541117a0089da7851906a2b9aeddb3a" translate="yes" xml:space="preserve">
          <source>Every low-level performance related question on Stack&amp;nbsp;Overflow should be required to provide MFLOPS information for the whole range of cache relevant data sizes! It's a waste of everybody's time to think of answers and especially discuss them with others without this information.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该要求有关堆栈溢出的每个与低级别性能相关的问题，以提供有关整个高速缓存相关数据大小范围的MFLOPS信息！&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;浪费每个人思考答案的时间，尤其是在没有这些信息的情况下与其他人讨论答案。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0f030db38dc8179d25718d183c7994c1ad7bfec3" translate="yes" xml:space="preserve">
          <source>Hardware is &lt;a href=&quot;http://en.wikipedia.org/wiki/Dell_XPS#XPS_8500&quot;&gt;Dell XPS 8500&lt;/a&gt; with generation 3 &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core i7&lt;/a&gt; @ 3.4&amp;nbsp;GHz and 8&amp;nbsp;GB memory. For 2^16 to 2^24, using eight loops, the cumulative time was 44.987 and 40.965 respectively. Visual C++ 2010, fully optimized.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;硬件是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Dell_XPS#XPS_8500&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dell XPS 8500，&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有第三代&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Core i7&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; @ 3.4 GHz和8 GB内存。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对于2 ^ 16到2 ^ 24，使用八个循环，累积时间分别为44.987和40.965。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;完全优化的Visual C ++ 2010。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c1bbe64c3e6e15af998d9942383e89f52b14b186" translate="yes" xml:space="preserve">
          <source>However, in order for false aliasing to occur, there must be a large enough stride between the datasets. This is why you don't see this in region 3.</source>
          <target state="translated">然而,为了使假别名发生,数据集之间必须有足够大的跨度。这就是为什么你在区域3中没有看到这种情况。</target>
        </trans-unit>
        <trans-unit id="f3b9fd0727ad4b649df8f9eab11b90ef6e577209" translate="yes" xml:space="preserve">
          <source>However; it is not to say that these new questions are not of importance because they themselves are and they do play a role after all. They do impact the procedures and the overall performance and that is evident with the various graphs and assessments from many who have given their answer(s) and or comment(s). If you pay attention to the analogy of the &lt;code&gt;Boss&lt;/code&gt; and the two workers &lt;code&gt;A&lt;/code&gt; &amp;amp; &lt;code&gt;B&lt;/code&gt; who had to go and retrieve packages from &lt;code&gt;C&lt;/code&gt; &amp;amp; &lt;code&gt;D&lt;/code&gt; respectively and considering the mathematical notations of the two algorithms in question you can see that without even the involvement of the computer &lt;code&gt;Case 2&lt;/code&gt; is approximately 60% faster than &lt;code&gt;Case 1&lt;/code&gt; and when you look at the graphs and charts after these algorithms have been applied to source code, compiled and optimized and executed through the OS to perform operations on the given hardware you even see a little more degradation between the differences in these algorithms.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然而;并不是说这些新问题并不重要，因为它们本身是重要的，而且它们毕竟会发挥作用。它们确实会影响程序和整体性能，这在许多给出答案和/或评论的图表和评估中很明显。如果您注意&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和两个工人&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;B&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的类比，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;他们不得不&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分别&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;D&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;那里取回包裹，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并考虑这两个算法的数学符号，您会发现，甚至没有计算机&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Case 2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;比&lt;/font&gt; &lt;code&gt;Case 1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;快60％&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 当您将这些算法应用于源代码，通过OS进行编译，优化和执行以在给定的硬件上执行操作之后查看图形和图表时，这些算法之间的差异甚至会有所降低。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a7a60ea46f57285511450482a75f3927deb922e3" translate="yes" xml:space="preserve">
          <source>I don't know if poor benchmark code is to blame, or what, but the two methods are within 10% of each other on my machine using the following code, and one loop is usually just slightly faster than two - as you'd expect.</source>
          <target state="translated">我不知道是基准代码差,还是什么原因,但在我的机器上使用下面的代码,这两个方法的速度都在10%以内,而且一个循环通常只比两个快一点--正如你所期望的那样。</target>
        </trans-unit>
        <trans-unit id="00589175b0e2daeb748e811866d66c98117bcd29" translate="yes" xml:space="preserve">
          <source>I played around with various schemes, such as putting the assignment of &lt;code&gt;b[j]&lt;/code&gt;, &lt;code&gt;d[j]&lt;/code&gt; to &lt;code&gt;InitToZero[j]&lt;/code&gt; inside the loops, and also with using &lt;code&gt;+= b[j] = 1&lt;/code&gt; and &lt;code&gt;+= d[j] = 1&lt;/code&gt;, and I got fairly consistent results.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我&lt;/font&gt; &lt;code&gt;InitToZero[j]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;了各种方案，例如将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b[j]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;d[j]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的赋值分配&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;InitToZero [j]&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到循环内，还使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;+= b[j] = 1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;+= d[j] = 1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我得到了相当一致的结果。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="817cfd78e867bee0df782d3f8d5e3e892f050739" translate="yes" xml:space="preserve">
          <source>I run Visual&amp;nbsp;Studio&amp;nbsp;2015 on an E5-1620 3.5&amp;nbsp;GHz processor with 16&amp;nbsp;GB RAM.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我在具有16 GB RAM的E5-1620 3.5 GHz处理器上运行Visual Studio 2015。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="00808f1a2f2eb9b821cd5d0d2373ff5c65a160b7" translate="yes" xml:space="preserve">
          <source>I suspect you are beginning to see where I am going.</source>
          <target state="translated">我怀疑你已经开始明白我的去处了。</target>
        </trans-unit>
        <trans-unit id="3bc087c8089b4797e291481227838ac53530b7b7" translate="yes" xml:space="preserve">
          <source>I will now begin to explain how all of this works below.</source>
          <target state="translated">下面我就开始解释一下这一切是如何运作的。</target>
        </trans-unit>
        <trans-unit id="99ed91ab9852dd4c4c00c7c70971a0fa0add2aea" translate="yes" xml:space="preserve">
          <source>I'm not sure exactly what's going on here... Alignment could still play an effect as Agner Fog mentions &lt;a href=&quot;http://www.agner.org/optimize/blog/read.php?i=142&quot;&gt;cache bank conflicts&lt;/a&gt;. (That link is about Sandy Bridge, but the idea should still be applicable to Core 2.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我不确定这到底是怎么回事...对齐仍然可以发挥作用，因为Agner Fog提到了&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.agner.org/optimize/blog/read.php?i=142&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;缓存库冲突&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（该链接是关于Sandy Bridge的，但该想法仍应适用于Core2。）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e87dc3e0b3d9d315844cac4303a6acbe9bf72c81" translate="yes" xml:space="preserve">
          <source>I'm not sure why it was decided that MFLOPS was a relevant metric. I though the idea was to focus on memory accesses, so I tried to minimize the amount of floating point computation time. I left in the &lt;code&gt;+=&lt;/code&gt;, but I am not sure why.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我不确定为什么决定MFLOPS是一个相关指标。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尽管我的想法是专注于内存访问，所以我尝试将浮点计算时间减至最少。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我离开了&lt;/font&gt;&lt;/font&gt; &lt;code&gt;+=&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是我不确定为什么。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7810945b5da00839bd6f4244b4ecc9f6be09aa4c" translate="yes" xml:space="preserve">
          <source>If I've guessed correctly on how you are allocating your arrays, they &lt;strong&gt;&lt;em&gt;are likely to be aligned to the page line&lt;/em&gt;&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果我猜对了如何分配数组，则它们&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;很可能与page line对齐&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6592d47a260c0445aa4f71f91675b748c2da8bb8" translate="yes" xml:space="preserve">
          <source>If you noticed &lt;code&gt;F2()&lt;/code&gt; only exists in &lt;code&gt;Sum&lt;/code&gt; where both &lt;code&gt;Sum1&lt;/code&gt; and &lt;code&gt;Sum2&lt;/code&gt; only contains &lt;code&gt;F1()&lt;/code&gt;. This will also be evident later on as well when we begin to conclude that there is sort of an optimization happening from the second algorithm.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您发现&lt;/font&gt;&lt;/font&gt; &lt;code&gt;F2()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;仅存在于&lt;/font&gt; &lt;code&gt;Sum1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt; &lt;code&gt;Sum2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;都只包含&lt;/font&gt; &lt;code&gt;F1()&lt;/code&gt; 的&lt;/font&gt; &lt;code&gt;Sum&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。当我们开始得出结论，第二种算法正在发生某种优化时，这也将在以后显而易见。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="29e5b3147124613363d4d8415c0344079da0b91e" translate="yes" xml:space="preserve">
          <source>Imagine you are working on a machine where &lt;code&gt;n&lt;/code&gt; was just the right value for it only to be possible to hold two of your arrays in memory at one time, but the total memory available, via disk caching, was still sufficient to hold all four.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设您在一台机器上工作，而&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只是一个正确的值，因为它只能一次将两个阵列保存在内存中，但是通过磁盘缓存可用的总内存仍然足以容纳全部四个。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c3438355ba619bc8749166614f228c594f1da22" translate="yes" xml:space="preserve">
          <source>In both cases we have 4 functions to work with and 2 function calls with 2 operations being done on each function call. So we will set these up as functions and function calls to be &lt;code&gt;F1()&lt;/code&gt;, &lt;code&gt;F2()&lt;/code&gt;, &lt;code&gt;f(a)&lt;/code&gt;, &lt;code&gt;f(b)&lt;/code&gt;, &lt;code&gt;f(c)&lt;/code&gt; and &lt;code&gt;f(d)&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这两种情况下，我们都有4个函数可以使用，有2个函数调用，每个函数调用都需要进行2个操作。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，我们将这些函数设置为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;F1()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;F2()&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f(b)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f(c)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f(d)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="dc2ed913dd196a5e776a8b6d35e3db01e80c5fbd" translate="yes" xml:space="preserve">
          <source>In this situation it is the structure of the process of the work being done and it does go to show that &lt;strong&gt;Case 2&lt;/strong&gt; is more efficient from both that partial optimization of having a similar function declaration and definition where it is only the variables that differ by name. And we also see that the total distance traveled in &lt;strong&gt;Case 1&lt;/strong&gt; is much farther than it is in &lt;strong&gt;Case 2&lt;/strong&gt; and we can consider this distance traveled our &lt;em&gt;Time Factor&lt;/em&gt; between the two algorithms. &lt;strong&gt;Case 1&lt;/strong&gt; has considerable more work to do than &lt;strong&gt;Case 2&lt;/strong&gt; does. This was also seen in the evidence of the &lt;code&gt;ASM&lt;/code&gt; that was shown between both cases. Even with what was already said about these cases, it also doesn't account for the fact that in &lt;strong&gt;Case 1&lt;/strong&gt; the boss will have to wait for both &lt;code&gt;A&lt;/code&gt; &amp;amp; &lt;code&gt;C&lt;/code&gt; to get back before he can go back to &lt;code&gt;A&lt;/code&gt; again on the next iteration and it also doesn't account for the fact that if &lt;code&gt;A&lt;/code&gt; or &lt;code&gt;B&lt;/code&gt; is taking an extremely long time then both the &lt;code&gt;Boss&lt;/code&gt; and the other worker(s) are also waiting at an idle. In &lt;strong&gt;Case 2&lt;/strong&gt; the only one being idle is the &lt;code&gt;Boss&lt;/code&gt; until the worker gets back. So even this has an impact on the algorithm.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，这是工作过程的结构，它确实表明，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;案例2&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;比具有部分相似的函数声明和定义的局部优化更为有效，其中仅变量名不同。而且我们还看到，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;案例1中&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;经过的总距离&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;比&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;案例2中的&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要远得多&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我们可以考虑此距离经过&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两种算法之间的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;时间因子&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;案例1&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;比&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;案例2&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有更多的工作要做&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。在&lt;/font&gt; &lt;code&gt;ASM&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的证据中也可以看到这一点&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两种情况之间都显示出这一点。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即使已经对这些案例进行了说明，这也不能说明在&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;案例1&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中老板必须等待&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;＆&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;都返回，然后才能&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在下一次迭代中再次&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;返回&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，如果&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;B&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;花费的时间很长，那么&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和其他工作人员也都闲着闲着，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这也没有考虑到这一事实&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;案例2中&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，只有一个空闲的人是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;直到工人回来。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，即使这也会影响算法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0a80769f1c0a8b8d244565169e5bab5c0615b3ee" translate="yes" xml:space="preserve">
          <source>It is already apparent that many have already done this by looking at the heap allocations, bench mark tests, looking at RAM, Cache and Page Files. Looking at specific data points and specific iteration indexes was also included and the various conversations about this specific problem has many people starting to question other related things about it. So how do we begin to look at this problem by using mathematical algorithms and applying an analogy to it? We start off by making a couple of assertions! Then we build out our algorithm from there.</source>
          <target state="translated">通过看堆分配、基准标记测试、看RAM、Cache和Page Files,显然已经有很多人做了这样的事情。看具体的数据点和具体的迭代索引也在其中,关于这个具体问题的各种讨论让很多人开始质疑其他相关的东西。那么,我们该如何开始用数学算法来看待这个问题,并对其进行类比应用呢?我们先从几个断言开始! 然后,我们从这里开始构建出我们的算法。</target>
        </trans-unit>
        <trans-unit id="a8fc6816b3d2ad8d20c28b136a6c91005b108c66" translate="yes" xml:space="preserve">
          <source>It is the only point, where one-loop (namely with continuous allocation) beats the two-loop version. (This made Mysticial's answer possible, at all.)</source>
          <target state="translated">这是唯一的一点,单环(即用连续分配)击败了双环版。(这使得Mysticial的答案成为了可能,根本就是这样)。</target>
        </trans-unit>
        <trans-unit id="95d30c52570fa07e0e4cf2e00d425ec2c718c6fa" translate="yes" xml:space="preserve">
          <source>It may be old C++ and optimizations. On my computer I obtained almost the same speed:</source>
          <target state="translated">可能是老的C++和优化。在我的电脑上,我获得了几乎相同的速度。</target>
        </trans-unit>
        <trans-unit id="fd3c6fcb78898a4d9ab59044ecc39ae0efeecae2" translate="yes" xml:space="preserve">
          <source>It might also be interesting to point out the differences between CPU/cache architectures, by providing a similar graph for these CPUs.</source>
          <target state="translated">通过为这些CPU提供类似的图形,指出CPUcache架构之间的差异,可能也是很有意思的。</target>
        </trans-unit>
        <trans-unit id="5f7fc9c2d2d9a467270b23261b4cc69da5f9ed02" translate="yes" xml:space="preserve">
          <source>It possesses the greatest discrepancy between the one and two loop'ed version (almost a factor of three)</source>
          <target state="translated">它拥有一环和二环版之间最大的差距(几乎是三倍的差距)。</target>
        </trans-unit>
        <trans-unit id="59d7c3084de99bdf974adebf4d8683cc639f6dc2" translate="yes" xml:space="preserve">
          <source>It's because the CPU doesn't have so many cache misses (where it has to wait for the array data to come from the RAM chips). It would be interesting for you to adjust the size of the arrays continually so that you exceed the sizes of the &lt;a href=&quot;http://en.wikipedia.org/wiki/CPU_cache#Multi-level_caches&quot;&gt;level 1 cache&lt;/a&gt; (L1), and then the &lt;a href=&quot;http://en.wikipedia.org/wiki/CPU_cache#Multi-level_caches&quot;&gt;level 2 cache&lt;/a&gt; (L2), of your CPU and plot the time taken for your code to execute against the sizes of the arrays. The graph shouldn't be a straight line like you'd expect.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是因为CPU没有太多的高速缓存未命中（它必须等待阵列数据来自RAM芯片）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您将不断调整数组的大小，使其超过&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CPU的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/CPU_cache#Multi-level_caches&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1级缓存&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（L1）和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/CPU_cache#Multi-level_caches&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2级缓存&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（L2）的大小，并绘制代码花费的时间，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这将很有趣。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对数组的大小执行。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该图不应是您期望的直线。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e6e48b4df68ffacb1c2b954a22ff59182a5abdcc" translate="yes" xml:space="preserve">
          <source>It's not because of a different code, but because of caching: RAM is slower than the CPU registers and a cache memory is inside the CPU to avoid to write the RAM every time a variable is changing. But the cache is not big as the RAM is, hence, it maps only a fraction of it.</source>
          <target state="translated">这不是因为代码不同,而是因为缓存的原因:RAM比CPU的寄存器慢,CPU内部有一个缓存存储器,避免每次变量变化时都要写RAM。但缓存并没有RAM那么大,因此,缓存只映射了其中的一小部分。</target>
        </trans-unit>
        <trans-unit id="4f98a0ef7e9ea5be7322aaa75bdddab7edfda7fc" translate="yes" xml:space="preserve">
          <source>Looking at it from this kind of an approach without involving how the Hardware, OS and Compiler(s) works together to do heap allocations that involves working with RAM, Cache, Page Files, etc.; the mathematics that are at the foundation of these algorithms shows us which of these two is the better solution. We can use an analogy where a &lt;code&gt;Boss&lt;/code&gt; or &lt;code&gt;Summation&lt;/code&gt; that will represent a &lt;code&gt;For Loop&lt;/code&gt; that has to travel between workers &lt;code&gt;A&lt;/code&gt; &amp;amp; &lt;code&gt;B&lt;/code&gt; we can easily see that &lt;strong&gt;Case 2&lt;/strong&gt; is at least &lt;strong&gt;&lt;sup&gt;1&lt;/sup&gt;/&lt;sub&gt;2&lt;/sub&gt;&lt;/strong&gt; as fast if not a little more than &lt;strong&gt;Case 1&lt;/strong&gt; due to the difference in the distance that is needed to travel and the time taken between the workers. This math lines up almost virtually and perfectly with both the Bench Mark Times as well as the amount of differences in Assembly Instructions.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从这种方法看待它，而无需涉及硬件，操作系统和编译器如何协同工作以进行堆分配，这涉及使用RAM，缓存，页面文件等。这些算法基础上的数学方法向我们展示了这两种方法中哪种更好。我们可以用一个比喻，其中一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Summation&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，将代表一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;For Loop&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有工人之间的旅行&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;＆&lt;/font&gt;&lt;/font&gt; &lt;code&gt;B&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我们不难看出，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;第2种情况&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是至少&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; / &lt;/font&gt;&lt;/font&gt;&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一样快，如果不是有点超过&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;案例1&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于行进距离和工人之间花费的时间不同。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该数学运算几乎与基准时间以及汇编说明中的差异几乎完全一致。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88b8ab7191d7a7de92e0270b1e10017d27a3a95d" translate="yes" xml:space="preserve">
          <source>Note that my initial question was at &lt;strong&gt;n = 100.000&lt;/strong&gt;. This point (by accident) exhibits special behavior:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请注意，我最初的问题是&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;n = 100.000&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这一点（偶然）表现出特殊的行为：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b299d49402d695f6cbcf85018ddd57470d6420e6" translate="yes" xml:space="preserve">
          <source>Now if the &quot;Data&quot; set is fairly small it may not seem all that bad of a difference at first but since &lt;code&gt;Case 1&lt;/code&gt; is about &lt;code&gt;60 - 70%&lt;/code&gt; slower than &lt;code&gt;Case 2&lt;/code&gt; we can look at the growth of this function as being in terms of the differences in time executions:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，如果&amp;ldquo;数据&amp;rdquo;组是相当小的，可能似乎不是所有的在第一，但由于差的不良&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Case 1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为约&lt;/font&gt;&lt;/font&gt; &lt;code&gt;60 - 70%&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;速度低于&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Case 2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我们可以看看这个函数的增长来讲是时间执行的差异：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eca24602b960c6a890ccd38ee6f72f25af9a65d1" translate="yes" xml:space="preserve">
          <source>OK, the right answer definitely has to do something with the CPU cache. But to use the cache argument can be quite difficult, especially without data.</source>
          <target state="translated">OK,正确的答案肯定和CPU缓存有关。但是要使用缓存参数,尤其是在没有数据的情况下,使用缓存参数是相当困难的。</target>
        </trans-unit>
        <trans-unit id="580a776c6b642fccec58ff95f40d16a839dd873b" translate="yes" xml:space="preserve">
          <source>Observations:</source>
          <target state="translated">Observations:</target>
        </trans-unit>
        <trans-unit id="d4cd934a3267228345d82320582325609db4ac86" translate="yes" xml:space="preserve">
          <source>One loop: 1.577 ms</source>
          <target state="translated">一圈。1.577毫秒</target>
        </trans-unit>
        <trans-unit id="067285dbce4f2ae23a4e8256bf22a68036bb1d40" translate="yes" xml:space="preserve">
          <source>PPS: Here is the full code. It uses &lt;a href=&quot;https://www.threadingbuildingblocks.org/&quot;&gt;TBB&lt;/a&gt;&lt;code&gt;Tick_Count&lt;/code&gt; for higher resolution timing, which can be disabled by not defining the &lt;code&gt;TBB_TIMING&lt;/code&gt; Macro:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;PPS：这是完整的代码。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.threadingbuildingblocks.org/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TBB &lt;/font&gt;&lt;/font&gt;&lt;/a&gt; &lt;code&gt;Tick_Count&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;获得更高分辨率的时序，可以通过不定义&lt;/font&gt;&lt;/font&gt; &lt;code&gt;TBB_TIMING&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;宏&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来禁用它&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="150892f3a6e1c9444336bf5fbf39ad8c8df7f488" translate="yes" xml:space="preserve">
          <source>PS: I am not sure, if this helps:</source>
          <target state="translated">PS:我不知道,如果这样做有帮助的话。</target>
        </trans-unit>
        <trans-unit id="37563549c2b48fdb7b187f4ea1cf03ceecec4985" translate="yes" xml:space="preserve">
          <source>PS: I changed the loops to count down to zero, and the combined method was marginally faster. Scratching my head. Note the new array sizing and loop counts.</source>
          <target state="translated">PS:我把环路改成了倒数为零,综合法稍微快了一点。挠了挠头。注意新的数组大小和循环次数。</target>
        </trans-unit>
        <trans-unit id="929017ada05ac8077c3ebc10b0f695a210b9db02" translate="yes" xml:space="preserve">
          <source>Proposal</source>
          <target state="translated">Proposal</target>
        </trans-unit>
        <trans-unit id="5f6bd53d4ce24c4aa4a3ee3123d8ab5b9cf113bb" translate="yes" xml:space="preserve">
          <source>Repeat for &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重复&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;d&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="52a60be214c602639707f5280f5a30ec124a81d3" translate="yes" xml:space="preserve">
          <source>Say &lt;code&gt;n = 2&lt;/code&gt; and we are working with bytes. In my scenario we thus have &lt;strong&gt;just 4 bytes of RAM&lt;/strong&gt; and the rest of our memory is significantly slower (say 100 times longer access).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设&lt;/font&gt;&lt;/font&gt; &lt;code&gt;n = 2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我们正在处理字节。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，在我的情况下，我们&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只有4个字节的RAM&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，而其余​​的内存则显着变慢（例如，访问时间增加了100倍）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b768a5099eeede624e8fb1ccf0c00e1ae7bd2c7f" translate="yes" xml:space="preserve">
          <source>Since we are working with an 8 byte pointer and dealing with Heap allocation let's consider this problem here. Let us say that the &lt;code&gt;Boss&lt;/code&gt; is 100 feet from &lt;code&gt;A&lt;/code&gt; and that &lt;code&gt;A&lt;/code&gt; is 500 feet from &lt;code&gt;C&lt;/code&gt;. We don't need to worry about how far the &lt;code&gt;Boss&lt;/code&gt; is initially from &lt;code&gt;C&lt;/code&gt; because of the order of executions. In both cases the &lt;code&gt;Boss&lt;/code&gt; initially travels from &lt;code&gt;A&lt;/code&gt; first then to &lt;code&gt;B&lt;/code&gt;. This analogy isn't to say that this distance is exact; it is just a use test case scenario to show the workings of the algorithms. In many cases when doing heap allocations and working with the cache and page files, these distances between address locations may not vary that much in differences or they can very significantly depending on the nature of the data types and the array sizes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于我们正在使用8字节指针并处理堆分配，因此我们在这里考虑此问题。让我们说，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是从100英尺&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从500英尺&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于执行的顺序，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们不必担心&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最初与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的距离。在这两种情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最初&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;都是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;先行然后到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;B&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个比喻并不是说这个距离是准确的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这只是一个用例，可以说明算法的工作原理。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在许多情况下，当进行堆分配以及使用缓存和页面文件时，地址位置之间的距离差异可能不会有太大变化，或者取决于数据类型和数组大小的性质，它们之间的差异可能非常明显。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b403afffa673d5c9286b0e779fa6f2102008bfda" translate="yes" xml:space="preserve">
          <source>So by these numbers it would almost look as if Algorithm One should be 99% slower than Algorithm Two; however, this is only the &lt;code&gt;The Boss's&lt;/code&gt; part or responsibility of the algorithms and it doesn't account for the actual workers &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt;, &amp;amp; &lt;code&gt;D&lt;/code&gt; and what they have to do on each and every iteration of the Loop. So the bosses job only accounts for about 15 - 40% of the total work being done. So the bulk of the work which is done through the workers has a slight bigger impact towards keeping the ratio of the speed rate differences to about 50-70%</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，根据这些数字，似乎算法一的速度应该比算法二的速度慢99％；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，这仅是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;The Boss's&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一部分或算法的责任，它没有考虑实际的工作人员&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;B&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;D&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以及他们在Loop的每次迭代中要做的事情。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，老板的工作仅占完成工作总数的15-40％。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，通过工人完成的大部分工作对于将速度差异率保持在50％到70％之间有较大的影响。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d0c27d22f565b7d4dff65f8ce28522fe98c5a597" translate="yes" xml:space="preserve">
          <source>So trying to have the &lt;code&gt;Boss&lt;/code&gt; focusing on doing two similar things at once and juggling them back and forth instead of focusing on similar consecutive tasks  is going to make him quite angry by the end of the day because he had to travel and work twice as much. Therefor do not lose the scope of the situation by letting your boss getting into an interpolated bottleneck because the boss's spouse and children wouldn't appreciate it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，试图让&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;专注于做两件事，而不是专注于连续完成类似的事情，而不是专注于相继的任务，这会使他在一天结束前很生气，因为他不得不旅行和工作两倍。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，不要让您的老板陷入插补的瓶颈，因为老板的配偶和子女不会对此感到高兴。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c92f2896cb97a5cd76721e9be1ae06c663d9ea6d" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;a1&lt;/code&gt;, &lt;code&gt;b1&lt;/code&gt;, &lt;code&gt;c1&lt;/code&gt;, and &lt;code&gt;d1&lt;/code&gt; point to heap memory and my numerical code has the following core loop.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;d1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指向堆内存，而我的数字代码具有以下核心循环。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae49864322db83eb4df4027d1cc46e331bab97d8" translate="yes" xml:space="preserve">
          <source>That's why I combined his test (using a continuous vs. separate allocation) and @James' Answer's advice.</source>
          <target state="translated">这也是为什么我把他的测试(用连续分配与单独分配的方式)和@James的回答结合起来的原因。</target>
        </trans-unit>
        <trans-unit id="d13556ea98fb233bf53b98bb4c31b76c5382d7df" translate="yes" xml:space="preserve">
          <source>The OP's code:</source>
          <target state="translated">OP的代码。</target>
        </trans-unit>
        <trans-unit id="49a4378a00b62449fce4898fcf15f09e54099521" translate="yes" xml:space="preserve">
          <source>The first code modifies distant memory addresses alternating them at each loop, thus requiring continuously to invalidate the cache.</source>
          <target state="translated">第一个代码在每个循环中交替修改远处的内存地址,因此需要不断地使缓存失效。</target>
        </trans-unit>
        <trans-unit id="5ef3f200dc1df02296aa0d9d57d5f615abafce03" translate="yes" xml:space="preserve">
          <source>The first loop alternates writing in each variable. The second and third ones only make small jumps of element size.</source>
          <target state="translated">第一个循环在每个变量中交替写入。第二个和第三个只做元素大小的小跳跃。</target>
        </trans-unit>
        <trans-unit id="53b362c1ef639785451d5a3c807cb56df98f4cb6" translate="yes" xml:space="preserve">
          <source>The graphs below shows, that most of the answers and especially the majority of comments to the question and answers can be considered completely wrong or true depending on the exact scenario and parameters used.</source>
          <target state="translated">从下图中可以看出,大多数的答案,特别是大多数对问题和答案的评论,可以认为是完全错误的,也可以认为是正确的,这取决于所使用的具体情景和参数。</target>
        </trans-unit>
        <trans-unit id="11061dc8aadf1e63250f11fc975aecbd7a854095" translate="yes" xml:space="preserve">
          <source>The iterations through the first case &lt;code&gt;Sum&lt;/code&gt; calls &lt;code&gt;f(a)&lt;/code&gt; that will add to its self &lt;code&gt;f(b)&lt;/code&gt; then it calls &lt;code&gt;f(c)&lt;/code&gt; that will do the same but add &lt;code&gt;f(d)&lt;/code&gt; to itself for each &lt;code&gt;100000 iterations&lt;/code&gt;. In the second case we have &lt;code&gt;Sum1&lt;/code&gt; and &lt;code&gt;Sum2&lt;/code&gt; And both act the same as if they were the same function being called twice in a row.
In this case we can treat &lt;code&gt;Sum1&lt;/code&gt; and &lt;code&gt;Sum2&lt;/code&gt; as just plain old &lt;code&gt;Sum&lt;/code&gt; where &lt;code&gt;Sum&lt;/code&gt; in this case looks like this: &lt;code&gt;Sum n=1 : [1,100000] { f(a) = f(a) + f(b); }&lt;/code&gt; and now this looks like an optimization where we can just consider it to be the same function.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font class=&quot;goog-text-highlight&quot; style=&quot;vertical-align: inherit;&quot;&gt;通过第一种情况的迭代&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Sum&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font class=&quot;goog-text-highlight&quot; style=&quot;vertical-align: inherit;&quot;&gt;调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font class=&quot;goog-text-highlight&quot; style=&quot;vertical-align: inherit;&quot;&gt;将添加到其自身&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f(b)&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font class=&quot;goog-text-highlight&quot; style=&quot;vertical-align: inherit;&quot;&gt;然后调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f(c)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font class=&quot;goog-text-highlight&quot; style=&quot;vertical-align: inherit;&quot;&gt;进行相同的操作，但&lt;/font&gt;&lt;font class=&quot;goog-text-highlight&quot; style=&quot;vertical-align: inherit;&quot;&gt;每进行&lt;/font&gt; &lt;code&gt;100000 iterations&lt;/code&gt; &lt;font class=&quot;goog-text-highlight&quot; style=&quot;vertical-align: inherit;&quot;&gt;将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f(d)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font class=&quot;goog-text-highlight&quot; style=&quot;vertical-align: inherit;&quot;&gt;添加&lt;/font&gt;&lt;font class=&quot;goog-text-highlight&quot; style=&quot;vertical-align: inherit;&quot;&gt;到自身&lt;/font&gt;&lt;font class=&quot;goog-text-highlight&quot; style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在第二种情况下，我们具有&lt;/font&gt; &lt;code&gt;Sum1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt; &lt;code&gt;Sum2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;，它们的行为相同，就好像它们是同一函数连续被调用两次一样。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，我们可以将&lt;/font&gt; &lt;code&gt;Sum1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt; &lt;code&gt;Sum2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;视为普通旧的&lt;/font&gt; &lt;code&gt;Sum&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt; &lt;code&gt;Sum&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;看起来像这样：&lt;/font&gt; &lt;code&gt;Sum n=1 : [1,100000] { f(a) = f(a) + f(b); }&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;}&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 现在看来这是一种优化，我们可以认为它是相同的功能。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="839acec8e710ad109f431376a6eb49f7c7173d08" translate="yes" xml:space="preserve">
          <source>The performance drop in the single-loop is what we are observing. And as mentioned, this is due to the alignment which (most likely) causes &lt;strong&gt;&lt;em&gt;false aliasing&lt;/em&gt;&lt;/strong&gt; stalls in the processor load/store units.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们正在观察单循环中的性能下降。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并且如前所述，这是由于对齐（最有可能）导致&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;处理器加载/存储单元中的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假混叠&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;停顿。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="47a017a142106a11ba95f378f7d97256b0fed87e" translate="yes" xml:space="preserve">
          <source>The question turned out to be of no relevance, as the behavior severely depends on the sizes of the arrays (n) and the CPU cache. So if there is further interest, I rephrase the question:</source>
          <target state="translated">这个问题原来没有任何意义,因为这个行为严重依赖于数组的大小(n)和CPU的缓存。所以,如果有进一步的兴趣,我重新提出这个问题。</target>
        </trans-unit>
        <trans-unit id="55e711a480f8599f3590ea8955ae90c25f96f446" translate="yes" xml:space="preserve">
          <source>The result using initialized data:</source>
          <target state="translated">使用初始化数据的结果。</target>
        </trans-unit>
        <trans-unit id="fd12f7273e3c644dfeec1cc8b110b33e50ab5389" translate="yes" xml:space="preserve">
          <source>The result using uninitialized data (this is what Mysticial tested):</source>
          <target state="translated">使用未初始化数据的结果(Mysticial就是这样测试的)。</target>
        </trans-unit>
        <trans-unit id="ec79e2db350f70819922aeda7c7c4a134df70af6" translate="yes" xml:space="preserve">
          <source>The second code don't alternate: it just flow on adjacent addresses twice. This makes all the job to be completed in the cache, invalidating it only after the second loop starts.</source>
          <target state="translated">第二个代码不交替:它只是在相邻地址上流过两次。这使得所有的工作都要在缓存中完成,只有在第二次循环开始后才会失效。</target>
        </trans-unit>
        <trans-unit id="962b2d1921173e1b25de62eb8401f26848105752" translate="yes" xml:space="preserve">
          <source>The second loop involves a lot less cache activity, so it's easier for the processor to keep up with the memory demands.</source>
          <target state="translated">第二个循环涉及的缓存活动要少很多,所以处理器更容易跟上内存需求。</target>
        </trans-unit>
        <trans-unit id="b406d7fb1215ac51706584a1368661dc6d6bb19f" translate="yes" xml:space="preserve">
          <source>There are many answers, that led to a lot of discussion, but let's face it: Cache issues can be very complex and are not one dimensional. They depend heavily on the size of the data, so my question was unfair: It turned out to be at a very interesting point in the cache graph.</source>
          <target state="translated">有很多答案,引发了很多讨论,但我们要面对现实。缓存问题可能是非常复杂的,而且不是一个维度的。它们在很大程度上取决于数据的大小,所以我的问题很不公平:原来是在缓存图的一个非常有趣的点上。</target>
        </trans-unit>
        <trans-unit id="1dde209c4b83d4186745de8cde5c487345b16c11" translate="yes" xml:space="preserve">
          <source>There seems to be a little confusion/misunderstanding here so I will try to elaborate a little using an example.</source>
          <target state="translated">这里似乎有一点混乱的误解,所以我试着用一个例子来说明一下。</target>
        </trans-unit>
        <trans-unit id="13059574a86e8647f17f49a9a0b752694791c080" translate="yes" xml:space="preserve">
          <source>Think of the &lt;code&gt;For Loops&lt;/code&gt; as being the &lt;code&gt;Summations&lt;/code&gt; that does the iterations as being a &lt;code&gt;Boss&lt;/code&gt; that is giving orders to two people &lt;code&gt;A&lt;/code&gt; &amp;amp; &lt;code&gt;B&lt;/code&gt; and that their jobs are to meat &lt;code&gt;C&lt;/code&gt; &amp;amp; &lt;code&gt;D&lt;/code&gt; respectively and to pick up some package from them and return it. In the analogy here the for loop or summation iterations and condition checks themselves doesn't actually represent the &lt;code&gt;Boss&lt;/code&gt;. What actually represents the &lt;code&gt;Boss&lt;/code&gt; here is not from the actual mathematical algorithms directly, but from the actual concept of &lt;code&gt;Scope&lt;/code&gt; and &lt;code&gt;Code Block&lt;/code&gt; within a routine or sub-routine, method, function, translation unit, etc. The first algorithm has 1 scope where the 2nd algorithm has 2 consecutive scopes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;For Loops&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;看作是进行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;迭代&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Summations&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是将两个人&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt; &lt;code&gt;B&lt;/code&gt; 分别&lt;font style=&quot;vertical-align: inherit;&quot;&gt;下达命令&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，他们的工作分别是给&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt; &lt;code&gt;D&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;求肉&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并从他们那里拿走一些包装并返回。以此类推，for循环或求和迭代和条件检查本身实际上并不代表&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;。这里真正代表&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的不是直接来自实际的数学算法，而是来自&lt;/font&gt; &lt;code&gt;Scope&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt; &lt;code&gt;Code Block&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;的实际概念&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 在例程或子例程，方法，函数，翻译单元等中。第一种算法具有1个作用域，第二种算法具有2个连续的作用域。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7d22a1fbb64d76304433f24947bf410c0f8af3df" translate="yes" xml:space="preserve">
          <source>This is a classic cache thrash scenario.</source>
          <target state="translated">这是一个典型的cache thrash场景。</target>
        </trans-unit>
        <trans-unit id="b8ffc8c4ef1a03c73bb9e0821c047ab1262b9819" translate="yes" xml:space="preserve">
          <source>This loop is executed 10,000 times via another outer &lt;code&gt;for&lt;/code&gt; loop. To speed it up, I changed the code to:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该循环通过另一个外部&lt;/font&gt;&lt;/font&gt; &lt;code&gt;for&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;循环&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;执行了10,000次&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为了加快速度，我将代码更改为：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fdc4cb320e8145a3a5607c0217bc3a252c1582a3" translate="yes" xml:space="preserve">
          <source>This means that all your accesses in each loop will fall on the same cache way. However, Intel processors have had 8-way L1 cache associativity for a while. But in reality, the performance isn't completely uniform. Accessing 4-ways is still slower than say 2-ways.</source>
          <target state="translated">这意味着,你在每个循环中的所有访问都将落在同一个缓存方式上。不过,英特尔处理器已经有一段时间的8路L1缓存关联性了。但实际上,性能并不完全统一。访问4路还是比说2路要慢。</target>
        </trans-unit>
        <trans-unit id="116c64a804cda018eff54aace684b048096784b8" translate="yes" xml:space="preserve">
          <source>This one is easy. The dataset is so small that the performance is dominated by overhead like looping and branching.</source>
          <target state="translated">这个很简单。数据集太小了,以至于性能上受开销如循环和分支等的支配。</target>
        </trans-unit>
        <trans-unit id="b993a65de9f293825c5e5d9683062a32d8b141b3" translate="yes" xml:space="preserve">
          <source>Total cost = &lt;code&gt;(100 + 100 + 1 + 1) * 2 = 404&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;总费用= &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(100 + 100 + 1 + 1) * 2 = 404&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19d3bb17d59a55f8338d5c4fce0ae33dc728b87f" translate="yes" xml:space="preserve">
          <source>Total cost = &lt;code&gt;(100 + 100 + 100 + 100) * 2 = 800&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;总费用= &lt;/font&gt;&lt;/font&gt; &lt;code&gt;(100 + 100 + 100 + 100) * 2 = 800&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03360fc5f946227bc07190906ff6d7139444c907" translate="yes" xml:space="preserve">
          <source>Try writing two parallel lines of 20 crosses with a pen and paper separated by 20&amp;nbsp;cm. Try once finishing one and then the other line and try another time by writting a cross in each line alternately.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尝试用相隔20厘米的钢笔和纸书写两条20条交叉的平行线。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;尝试先完成一条，然后再完成另一行，然后通过在每行中交替写一个十字来尝试另一次。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="53bfab4d116eca32e1091f50ff7bca7f57441a62" translate="yes" xml:space="preserve">
          <source>Two loops: 1.507 ms</source>
          <target state="translated">两圈。1.507毫秒</target>
        </trans-unit>
        <trans-unit id="466d5a25d4be7521ae09c87f6a46e0b628a3542a" translate="yes" xml:space="preserve">
          <source>Upon further analysis of this, I believe this is (at least partially) caused by data alignment of the four pointers. This will cause some level of cache bank/way conflicts.</source>
          <target state="translated">经过进一步分析,我认为这(至少部分)是由四个指针的数据对齐造成的。这就会造成一定程度上的缓存银行通道冲突。</target>
        </trans-unit>
        <trans-unit id="cfeab75af6e84b33c6a6527778a734b3d9e7b1ed" translate="yes" xml:space="preserve">
          <source>We can easily see that 600 is far less than 10 million. Now this isn't exact, because we don't know the actual difference in distance between which address of RAM or from which Cache or Page File each call on each iteration is going to be due to many other unseen variables, but this is just an assessment of the situation to be aware of and trying to look at it from the worst case scenario.</source>
          <target state="translated">我们不难看出,600远小于1000万。现在,这并不确切,因为我们不知道RAM的哪个地址或从哪个Cache或Page File每次迭代上的调用会因为很多其他看不见的变量而产生实际的距离差异,但这只是对情况的评估,需要注意,并试图从最坏的情况下看。</target>
        </trans-unit>
        <trans-unit id="fc174d905f4eb44c872c08d03546c6a40948ee8c" translate="yes" xml:space="preserve">
          <source>We do not know how long it will take for each case unless if we set a counter and run a bench mark test. However the bench marks were already included from the original question and from some of the answers and comments as well and we can see a significant difference between the two and this is the whole reasoning of this question to this problem and for the answering of it to begin with.</source>
          <target state="translated">我们不知道每道题要花多少时间,除非我们设置一个计数器,做一个基准分数测试。然而,从原题和一些答案和评论中已经包含了基准分数,我们可以看到两者之间有很大的差异,这就是这个问题的整个推理,也是这个问题的答案的开始。</target>
        </trans-unit>
        <trans-unit id="0e08bbd8348ea9fc71c47393bb70640f1c01606b" translate="yes" xml:space="preserve">
          <source>We know is that his loop will run 100,000 times. We also know that &lt;code&gt;a1&lt;/code&gt;, &lt;code&gt;b1&lt;/code&gt;, &lt;code&gt;c1&lt;/code&gt; &amp;amp; &lt;code&gt;d1&lt;/code&gt; are pointers on a 64-bit architecture. Within C++ on a 32-bit machine all pointers are 4 bytes and on a 64-bit machine they are 8 bytes in size since pointers are of a fixed length. We know that we have 32 bytes in which to allocate for in both cases. The only difference is we are allocating 32 bytes or 2 sets of 2-8bytes on each iteration where in the 2nd case we are allocating 16 bytes for each iteration for both of the independent loops. So both loops still equals 32 bytes in total allocations. With this information let's go ahead and show the general math, algorithm and analogy of it. We do know the amount of times that the same set or group of operations will have to be performed in both cases. We do know the amount of memory that needs to be allocated in both cases. We can asses that the overall work load of the allocations between both cases will be approximately the same.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们知道他的循环将运行100,000次。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我们还知道&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;d1&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是64位架构上的指针。在C ++中，在32位计算机上，所有指针均为4个字节，而在64位计算机上，指针均为8个字节，因为指针的长度是固定的。我们知道在两种情况下我们都需要分配32个字节。唯一的区别是我们在每次迭代中分配32字节或2组2-8字节，在第二种情况下，我们为两个独立循环的每次迭代分配16个字节。因此，两个循环的总分配仍然等于32个字节。有了这些信息，让我们继续展示它的一般数学，算法和类比。我们确实知道在两种情况下必须执行相同的一组或一组操作的次数。我们确实知道在两种情况下都需要分配的内存量。我们可以估计，两种情况下分配的总工作量将大致相同。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6fe2e5f01c8d98ddfcee1b601d0fceb67a183e49" translate="yes" xml:space="preserve">
          <source>We will let our loop and its iterations be a Summation that starts at 1 and ends at 100000 instead of starting with 0 as in the loops for we don't need to worry about the 0 indexing scheme of memory addressing since we are just interested in the algorithm itself.</source>
          <target state="translated">我们将让我们的循环和它的迭代是一个从1开始,以100000结束的求和,而不是像循环中的0开始,因为我们不需要担心内存寻址的0索引方案,因为我们只对算法本身感兴趣。</target>
        </trans-unit>
        <trans-unit id="92ea6c5b9c179b6799de261eafa3d472f7094b3e" translate="yes" xml:space="preserve">
          <source>Why are elementwise additions much faster in separate loops than in a combined loop</source>
          <target state="translated">为什么单独循环中的元素加法要比合并循环快得多?</target>
        </trans-unit>
        <trans-unit id="18d746b56edfc3b8c8160872d27b4b8ee0118420" translate="yes" xml:space="preserve">
          <source>Why is one loop so much slower than two loops?</source>
          <target state="translated">为什么一个回路比两个回路慢得多?</target>
        </trans-unit>
        <trans-unit id="564f8c6e76fbd512be2e38dabdfdd61550d0c3cc" translate="yes" xml:space="preserve">
          <source>With</source>
          <target state="translated">With</target>
        </trans-unit>
        <trans-unit id="4b65d240f83b92820bd73e3c9a1ea691dbb385f6" translate="yes" xml:space="preserve">
          <source>With what we seen in the second case it almost appears as if there is optimization since both for loops have the same exact signature, but this isn't the real issue. The issue isn't the work that is being done by &lt;code&gt;f(a)&lt;/code&gt;,&lt;code&gt;f(b)&lt;/code&gt;,&lt;code&gt;f(c)&lt;/code&gt;&amp;amp;&lt;code&gt;f(d)&lt;/code&gt; in both cases and the comparison between the two it is the difference in the distance that the Summation has to travel in both cases that gives you the difference in time execution.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在第二种情况下，由于两个for循环具有相同的确切签名，因此几乎看起来好像是在进行优化，但这不是真正的问题。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;问题不是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两种情况下&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f(a)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f(b)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f(c)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;f(d)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所做的工作，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;两者之间的比较是求和的距离差异在两种情况下都必须旅行，这使您在执行时间上有所不同。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5b289bf7d150d141a9a06f034bc238a251f98430" translate="yes" xml:space="preserve">
          <source>Within the first case on each call slip the &lt;code&gt;Boss&lt;/code&gt; goes to &lt;code&gt;A&lt;/code&gt; and gives the order and &lt;code&gt;A&lt;/code&gt; goes off to fetch &lt;code&gt;B's&lt;/code&gt; package then the &lt;code&gt;Boss&lt;/code&gt; goes to &lt;code&gt;C&lt;/code&gt; and gives the orders to do the same and receive the package from &lt;code&gt;D&lt;/code&gt; on each iteration.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在每个呼叫单的第一种情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并下达订单，而&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转到获取&lt;/font&gt;&lt;/font&gt; &lt;code&gt;B's&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包，然后&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;转到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并下达订单以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在每次迭代中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;D&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;接收包&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="39b360ce4a3ca0bb5ddbee9c9161b830580197e7" translate="yes" xml:space="preserve">
          <source>Within the second case the &lt;code&gt;Boss&lt;/code&gt; works directly with &lt;code&gt;A&lt;/code&gt; to go and fetch &lt;code&gt;B's&lt;/code&gt; package until all packages are received. Then the &lt;code&gt;Boss&lt;/code&gt; works with &lt;code&gt;C&lt;/code&gt; to do the same for getting all of &lt;code&gt;D's&lt;/code&gt; packages.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在第二种情况下，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;直接与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;A&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一起去取回&lt;/font&gt;&lt;/font&gt; &lt;code&gt;B's&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包裹，直到收到所有包裹为止。然后，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Boss&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与&lt;/font&gt;&lt;/font&gt; &lt;code&gt;C&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一起完成获取&lt;/font&gt;&lt;/font&gt; &lt;code&gt;D's&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;程序包的操作。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3110f136849c94cb9d21af5da4f6ed9ad5781ffe" translate="yes" xml:space="preserve">
          <source>You are probably not seeing disk caching in your tests but you are probably seeing the side effects of some other form of caching.</source>
          <target state="translated">你可能在测试中没有看到磁盘缓存,但你可能看到的是其他形式的缓存的副作用。</target>
        </trans-unit>
        <trans-unit id="d64399c3ca292db5e91589fa738bc463f2006e98" translate="yes" xml:space="preserve">
          <source>cache &lt;code&gt;a[0]&lt;/code&gt; and &lt;code&gt;a[1]&lt;/code&gt; then &lt;code&gt;b[0]&lt;/code&gt; and &lt;code&gt;b[1]&lt;/code&gt; and set &lt;code&gt;a[0] = a[0] + b[0]&lt;/code&gt; in cache - there are now four bytes in cache, &lt;code&gt;a[0], a[1]&lt;/code&gt; and &lt;code&gt;b[0], b[1]&lt;/code&gt;. Cost = 100 + 100.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;缓存&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[1]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;缓存&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b[0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b[1]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在缓存中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;设置&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[0] = a[0] + b[0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -现在缓存中有四个字节，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[0], a[1]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b[0], b[1]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;费用= 100 + 100。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="684691450b6f67d64ea5716630cb055d1cdb5528" translate="yes" xml:space="preserve">
          <source>eject &lt;code&gt;a[0], a[1], b[0], b[1]&lt;/code&gt; from cache and cache &lt;code&gt;c[0]&lt;/code&gt; and &lt;code&gt;c[1]&lt;/code&gt; then &lt;code&gt;d[0]&lt;/code&gt; and &lt;code&gt;d[1]&lt;/code&gt; and set &lt;code&gt;c[0] = c[0] + d[0]&lt;/code&gt; in cache. Cost = 100 + 100.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从缓存中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;弹出&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[0], a[1], b[0], b[1]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，然后缓存&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c[0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c[1]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后&lt;/font&gt;&lt;/font&gt; &lt;code&gt;d[0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;d[1]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并设置&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c[0] = c[0] + d[0]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;缓存中的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;c [0] + d [0]&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;费用= 100 + 100。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a45d1263f7e0797a6fe6f7b721f3312f94b14dd6" translate="yes" xml:space="preserve">
          <source>set &lt;code&gt;a[1] = a[1] + b[1]&lt;/code&gt; in cache. Cost = 1 + 1.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在缓存中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;设置&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a[1] = a[1] + b[1]&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;费用= 1 + 1。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e726e4b336529f67262f81f3ff5432cad1d3985d" translate="yes" xml:space="preserve">
          <source>the other loop</source>
          <target state="translated">另一环</target>
        </trans-unit>
        <trans-unit id="871fc8b4792054b058d6099d151b8f4a8322450f" translate="yes" xml:space="preserve">
          <source>will page out two arrays and page in the other two &lt;strong&gt;every time around the loop&lt;/strong&gt;. This would obviously be &lt;strong&gt;much&lt;/strong&gt; slower.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每次循环&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;都会分页出两个数组，并分页到另外两个&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这显然是&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;很多&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;慢。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="30905af2bb584e30c36e5d7802c5f32420f342d3" translate="yes" xml:space="preserve">
          <source>would first cause &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to be loaded into RAM and then be worked on entirely in RAM. When the second loop starts, &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; would then be loaded from disk into RAM and operated on.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先会导致&lt;/font&gt;&lt;/font&gt; &lt;code&gt;a&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;b&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;加载到RAM中，然后完全在RAM中处理。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当第二个循环开始时，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后将&lt;/font&gt;&lt;/font&gt; &lt;code&gt;c&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;d&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从磁盘加载到RAM中并进行操作。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
