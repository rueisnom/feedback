<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1108">
    <body>
      <group id="1108">
        <trans-unit id="7c6f976f4e1f247357643420b0f1d5edff13eef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Example 1&lt;/em&gt;&lt;/strong&gt; - &lt;em&gt;sorted vs unsorted fields&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예 1&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 분류되지 않은 필드 대 분류&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad6ea987ddb5784c13bde986d9834b1b8aa7cc8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Example 2&lt;/em&gt;&lt;/strong&gt;  - &lt;em&gt;indexing&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예 2&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 색인&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c263d6e1ec3808a54cf13984a9ccf2fe20c030b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How a database index can help performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터베이스 인덱스가 성능을 향상시키는 방법&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ee6c6ffc954bb7d8e7f64c641b17ff3a602b455" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does B-trees index work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B- 트리 색인은 어떻게 작동합니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1038135901ca45cbc26e89cf4438b522835561bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does a database know when to use an index?&lt;/strong&gt;
When a query like &amp;ldquo;SELECT * FROM Employee WHERE Employee_Name = &amp;lsquo;Abc&amp;rsquo; &amp;rdquo; is run, the database will check to see if there is an index on the column(s) being queried. Assuming the Employee_Name column does have an index created on it, the database will have to decide whether it actually makes sense to use the index to find the values being searched &amp;ndash; because there are some scenarios where it is actually less efficient to use the database index, and more efficient just to scan the entire table.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터베이스는 인덱스 사용시기를 어떻게 알 수 있습니까? &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;ldquo;SELECT * FROM Employee WHERE Employee_Name = 'Abc'&amp;rdquo;와 같은 쿼리가 실행되면 데이터베이스는 쿼리중인 열에 인덱스가 있는지 확인합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Employee_Name 컬럼에 인덱스가 작성되었다고 가정하면 데이터베이스는 실제로 인덱스를 사용하여 검색중인 값을 찾는 것이 적합한 지 여부를 결정해야합니다. 실제로 데이터베이스 인덱스를 사용하는 것이 덜 효율적인 시나리오가 있기 때문입니다. 전체 테이블을 스캔하는 것이 더 효율적입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff64d04a079079f647ecb61630eba86649659ead" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does a hash table index work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해시 테이블 인덱스는 어떻게 작동합니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c1ec9f40f4edd7eb75f8f619aa77433ee58d89b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does it work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;어떻게 작동합니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7776d2a490f8e3aaac3f9ca4505cab9d20b38b23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Pointers in MySQL are 2, 3, 4 or 5 bytes in length depending on the size of the table.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참고&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : MySQL의 포인터 길이는 테이블 크기에 따라 2, 3, 4 또는 5 바이트입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d1f023e6a4d3bc1e8bf916bde9bbdd1bedb1d70d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: char was used in place of varchar to allow for an accurate size on disk value. 
This sample database contains five million rows and is unindexed. The performance of several queries will now be analyzed. These are a query using the &lt;em&gt;id&lt;/em&gt; (a sorted key field) and one using the &lt;em&gt;firstName&lt;/em&gt; (a non-key unsorted field).</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;참고&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : 디스크 값에서 정확한 크기를 허용하기 위해 varchar 대신 char을 사용했습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 샘플 데이터베이스에는 5 백만 개의 행이 있으며 색인화되지 않았습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 여러 쿼리의 성능이 분석됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이들은 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;id&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (정렬 된 키 필드)를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용하는 쿼리 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이고 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (키가 아닌 정렬되지 않은 필드)을 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용하는 쿼리 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e55a4eef1abc15fd25c68f22657b346ff3abdb11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Description!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단한 설명!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f4ae4a04e94c61d13e11443fa35cbf4c8957624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The disadvantages of a hash index&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해시 인덱스의 단점&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d60b2311316bf1641d865996eaab467baf68c7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What exactly is inside a database index?&lt;/strong&gt;
So, now you know that a database index is created on a column in a table, and that the index stores the values in that specific column. But, it is important to understand that a database index does not store the values in the other columns of the same table. For example, if we create an index on the Employee_Name column, this means that the Employee_Age and Employee_Address column values are not also stored in the index. If we did just store all the other columns in the index, then it would be just like creating another copy of the entire table &amp;ndash; which would take up way too much space and would be very inefficient.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터베이스 인덱스 안에 정확히 무엇이 있습니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이제 데이터베이스 인덱스가 테이블의 열에 만들어지고 인덱스가 해당 특정 열에 값을 저장한다는 것을 알았습니다. 그러나 데이터베이스 인덱스는 동일한 테이블의 다른 열에 값을 저장하지 않는다는 것을 이해해야합니다. 예를 들어 Employee_Name 열에 인덱스를 만들면 Employee_Age 및 Employee_Address 열 값도 인덱스에 저장되지 않습니다. 인덱스에 다른 모든 열을 저장했다면 전체 테이블의 다른 복사본을 만드는 것과 같습니다. 너무 많은 공간을 차지하고 비효율적입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6428ecc202198be70cb1f1755663fa9831bc29a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is indexing?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱싱이란 무엇입니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="66754d988f4fcb1acc4a50297f2aadea10736289" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is the cost of having a database index?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터베이스 인덱스 비용은 얼마입니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e16a9f89c5c9cad39f49b095ddeef61be6287223" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What would happen without an index?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스가 없으면 어떻게됩니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba497667b700161a0513bd86c14414feabb5a6a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should it be used?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;언제 사용해야합니까?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c650694413b8d8c8e0547a99830e7752b6f6fb74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why is it needed?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;왜 필요한가요?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fadfcc0b3b5611c6320a2347916ace1ab3378c3e" translate="yes" xml:space="preserve">
          <source>A linear search on the id field would require an average of &lt;code&gt;N/2 = 500,000&lt;/code&gt; block accesses to find a value, given that the id field is a key field. But since the id field is also sorted, a binary search can be conducted requiring an average of &lt;code&gt;log2 1000000 = 19.93 = 20&lt;/code&gt; block accesses. Instantly we can see this is a drastic improvement.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;id 필드가 키 필드 인 경우 id 필드에서 선형 검색을 수행하려면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;값을 찾기 위해 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;평균 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N/2 = 500,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 블록 액세스 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 필요 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 id 필드도 정렬되므로 평균 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 1000000 = 19.93 = 20&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 블록 액세스 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 필요한 이진 검색을 수행 할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉시 우리는 이것이 대폭 개선되었음을 알 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="71f1a10902b7a8ccbae4cdba11a0b434fe2b432e" translate="yes" xml:space="preserve">
          <source>Also, a differentiation between clustered and non-clustered indexes is rather important.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 클러스터형 인덱스와 비 클러스터형 인덱스를 구분하는 것이 중요합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f959491d8665d67cf85a2cc9b96a16ed6e7c0149" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;index&lt;/code&gt; consists of &lt;strong&gt;column values(Eg: John) from one table&lt;/strong&gt;, and those values are stored in a &lt;strong&gt;data structure&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 구성 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;열 값 (예 : 존) 이상의 표에서&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , 그 값이 저장되는 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터 구조&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ad74fb25accebf8d6e8d23b44a80acc6acebc0d" translate="yes" xml:space="preserve">
          <source>An index is just a data structure that makes the searching faster for a specific column in a database. This structure is usually a b-tree or a hash table but it can be any other logic structure.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스는 데이터베이스의 특정 열을 더 빨리 검색 할 수있는 데이터 구조 일뿐입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 구조는 일반적으로 b- 트리 또는 해시 테이블이지만 다른 논리 구조 일 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae0587c6babe222342305dc974d0c1ee2fec283f" translate="yes" xml:space="preserve">
          <source>Another option is that, you could just go to the Index section of the book and then find what you are looking for by using the Name of the entity you are looking ( in this instance, German Shepherds) and also looking at the page number to quickly find what you are looking for.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또 다른 옵션은 책의 색인 섹션으로 이동 한 다음 찾고있는 엔터티의 이름 (이 예에서는 독일 셰퍼드)을 사용하여 원하는 것을 찾을 수 있으며 페이지 번호를 원하는 것을 빨리 찾을 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a42223342f004e5087636b0bd93ed01b59e5befd" translate="yes" xml:space="preserve">
          <source>Another problem with indexes is their fragmentation over time as data is inserted. &lt;code&gt;REORGANIZE&lt;/code&gt; helps, you must write routines to have it done.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스의 또 다른 문제점은 데이터가 삽입 될 때 시간이 지남에 따라 조각화되는 것입니다. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;REORGANIZE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 루틴을 작성하여 수행해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="670ae6c441f98e2a78f5820d589187b5910ea31c" translate="yes" xml:space="preserve">
          <source>As a general rule, an index should only be created on a table if the data in the indexed column will be queried frequently.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 인덱싱 된 열의 데이터를 자주 쿼리하는 경우 인덱스는 테이블에서만 만들어야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="06a4b006b5c2d9087ce316cf7000e63a79bca581" translate="yes" xml:space="preserve">
          <source>But then, in addition to actual 1000 pages, you will need another ~10 pages to show the indices, so totally 1010 pages.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 실제 1000 페이지 외에도 색인을 표시하려면 1010 페이지가 필요합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3d71c21621662c8be4c6dce7fd281e97dfd2c30e" translate="yes" xml:space="preserve">
          <source>But with an index page, you know where to go! And more, to lookup any particular Chapter that matters, you just need to look over the index page, again and again, every time. After finding the matching index you can efficiently jump to that chapter by skipping the rest.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 색인 페이지를 통해 어디로 가야하는지 알고 있습니다! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 중요한 특정 장을 찾아 보려면 매번 색인 페이지를 반복해서 살펴 봐야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일치하는 색인을 찾은 후 나머지를 건너 뛰어 해당 장으로 효율적으로 이동할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a2aeece8a7e18f9f6165280d858250ef5c41a36b" translate="yes" xml:space="preserve">
          <source>Classic example &lt;strong&gt;&quot;Index in Books&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;고전적인 예 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;도서의 색인&quot;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edfadc138c324a28c0ad48b4568b1c93f50ae608" translate="yes" xml:space="preserve">
          <source>Consider a &quot;Book&quot; of 1000 pages, divided by 10 Chapters, each section with 100 pages.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1000 장의 &quot;책&quot;을 10 개의 장으로 나누고 각 섹션에 100 개의 페이지가 있다고 가정하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccace75fa9dc2dfab316381c595f1cee029a29da" translate="yes" xml:space="preserve">
          <source>Database software would literally have to look at every single row in the Employee table to see if the Employee_Name for that row is &amp;lsquo;Abc&amp;rsquo;. And, because we want every row with the name &amp;lsquo;Abc&amp;rsquo; inside it, we can not just stop looking once we find just one row with the name &amp;lsquo;Abc&amp;rsquo;, because there could be other rows with the name &lt;strong&gt;Abc&lt;/strong&gt;. So, every row up until the last row must be searched &amp;ndash; which means thousands of rows in this scenario will have to be examined by the database to find the rows with the name &amp;lsquo;Abc&amp;rsquo;. This is what is called a &lt;strong&gt;full table scan&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터베이스 소프트웨어는 문자 그대로 Employee 테이블의 모든 단일 행을보고 해당 행의 Employee_Name이 'Abc'인지 확인해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;우리가 그 안에 이름 'ABC'와 모든 행을 원하기 때문에 우리가 이름을 'ABC'와 하나의 행을 발견하면 이름을 가진 다른 행이있을 수 있기 때문에, 우리는 그냥보고 중지 할 수 없습니다 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ABC 방송&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 마지막 행까지 모든 행을 검색해야합니다. 즉,이 시나리오에서 이름이 'Abc'인 행을 찾으려면 데이터베이스에서 수천 개의 행을 검사해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것이 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;전체 테이블 스캔입니다&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ceb478c45cb9fe55a55150694c3e2f7c5bd8f32f" translate="yes" xml:space="preserve">
          <source>Due to the fact that a number of records can only be sorted on one field, we can state that searching on a field that isn&amp;rsquo;t sorted requires a Linear Search which requires &lt;code&gt;N/2&lt;/code&gt; block accesses (on average), where &lt;code&gt;N&lt;/code&gt; is the number of blocks that the table spans. If that field is a non-key field (i.e. doesn&amp;rsquo;t contain unique entries) then the entire tablespace must be searched at &lt;code&gt;N&lt;/code&gt; block accesses.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여러 레코드를 한 필드에서만 정렬 할 수 있기 때문에 정렬되지 않은 필드를 검색하려면 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N/2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 블록 액세스 (평균) &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가 필요한 선형 검색이 필요 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하며 여기서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 테이블이 확장 된 블록 수 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해당 필드가 키가 아닌 필드 인 경우 (즉, 고유 한 항목을 포함하지 않는 경우) &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 블록 액세스 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;에서 전체 테이블 스페이스를 검색해야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e5bc6d47e649819c256f1169901b6aa5852d68ce" translate="yes" xml:space="preserve">
          <source>Example: We have a database table called &lt;code&gt;User&lt;/code&gt; with three columns &amp;ndash; &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Address&lt;/code&gt;. Assume that the &lt;code&gt;User&lt;/code&gt; table has thousands of rows.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예 : &lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt; &lt;code&gt;Age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 및 &lt;/font&gt; &lt;code&gt;Address&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;세 개의 열이있는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 라는 데이터베이스 테이블이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다. &lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 테이블에 수천 개의 행이 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있다고 가정하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6dfb64751c4bd0fadd0aadce8f3a9bec1f87f196" translate="yes" xml:space="preserve">
          <source>Firstly, let&amp;rsquo;s outline a sample database table schema;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;먼저 샘플 데이터베이스 테이블 스키마를 간략히 설명하겠습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67a6b5de80a5587dd3df63bd3b5cd82d3ef329d8" translate="yes" xml:space="preserve">
          <source>For information on queries to index a field, check out &lt;a href=&quot;https://stackoverflow.com/questions/1156/&quot;&gt;How do I index a database column&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;필드를 색인화하기위한 조회에 대한 정보 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1156/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는 데이터베이스 열을 색인화하는 방법을 참조&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a56b08d796085fa51779969ead12eba0cdf923dc" translate="yes" xml:space="preserve">
          <source>For instance, the query we discussed earlier could benefit from a hash index created on the Employee_Name column. The way a hash index would work is that the column value will be the key into the hash table and the actual value mapped to that key would just be a pointer to the row data in the table. Since a hash table is basically an associative array, a typical entry would look something like &amp;ldquo;Abc =&amp;gt; 0x28939&amp;Prime;, where 0x28939 is a reference to the table row where Abc is stored in memory. Looking up a value like &amp;ldquo;Abc&amp;rdquo; in a hash table index and getting back a reference to the row in memory is obviously a lot faster than scanning the table to find all the rows with a value of &amp;ldquo;Abc&amp;rdquo; in the Employee_Name column.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 앞에서 논의한 쿼리는 Employee_Name 열에서 생성 된 해시 인덱스의 이점을 활용할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해시 인덱스가 작동하는 방식은 열 값이 해시 테이블의 키가되고 해당 키에 매핑 된 실제 값은 테이블의 행 데이터에 대한 포인터 일뿐입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해시 테이블은 기본적으로 연관 배열이므로 일반적인 항목은 &quot;Abc =&amp;gt; 0x28939&quot;와 유사합니다. 여기서 0x28939는 Abc가 메모리에 저장된 테이블 행에 대한 참조입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해시 테이블 인덱스에서 &quot;Abc&quot;와 같은 값을 찾고 메모리의 행에 대한 참조를 가져 오는 것이 Employee_Name 열에서 값이 &quot;Abc&quot;인 모든 행을 찾기 위해 테이블을 스캔하는 것보다 훨씬 빠릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ba744e72c82249823f810b1d800ca0c81ff406e9" translate="yes" xml:space="preserve">
          <source>Given our sample database of &lt;code&gt;r = 5,000,000&lt;/code&gt; records of a fixed size giving a record length of &lt;code&gt;R = 204&lt;/code&gt; bytes and they are stored in a table using the MyISAM engine which is using the default block size &lt;code&gt;B = 1,024&lt;/code&gt; bytes. The blocking factor of the table would be &lt;code&gt;bfr = (B/R) = 1024/204 = 5&lt;/code&gt; records per disk block. The total number of blocks required to hold the table is &lt;code&gt;N = (r/bfr) = 5000000/5 = 1,000,000&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &lt;code&gt;R = 204&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 바이트 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 레코드 길이를 제공하는 고정 크기 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r = 5,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 레코드의 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;샘플 데이터베이스가 주어지면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본 블록 크기 &lt;/font&gt; &lt;code&gt;B = 1,024&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 바이트를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용하는 MyISAM 엔진을 사용하여 테이블에 저장 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;됩니다. 테이블의 차단 계수는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;디스크 블록 당 &lt;/font&gt; &lt;code&gt;bfr = (B/R) = 1024/204 = 5&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 레코드입니다. 테이블을 보유하는 데 필요한 총 블록 수는 &lt;/font&gt; &lt;code&gt;N = (r/bfr) = 5000000/5 = 1,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 블록입니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a612a719bfeff12051ef62ec18b988c42d957b8" translate="yes" xml:space="preserve">
          <source>Given our sample database of &lt;code&gt;r = 5,000,000&lt;/code&gt; records with an index record length of &lt;code&gt;R = 54&lt;/code&gt; bytes and using the default block size &lt;code&gt;B = 1,024&lt;/code&gt; bytes. The blocking factor of the index would be &lt;code&gt;bfr = (B/R) = 1024/54 = 18&lt;/code&gt; records per disk block. The total number of blocks required to hold the index is &lt;code&gt;N = (r/bfr) = 5000000/18 = 277,778&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스 레코드 길이가 &lt;/font&gt; &lt;code&gt;R = 54&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 바이트이고 기본 블록 크기 &lt;/font&gt; &lt;code&gt;B = 1,024&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 바이트를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용하는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r = 5,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 레코드 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 샘플 데이터베이스가 있다고 가정 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;합니다. 인덱스의 차단 계수는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;디스크 블록 당 &lt;/font&gt; &lt;code&gt;bfr = (B/R) = 1024/54 = 18&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 레코드입니다. 인덱스를 보유하는 데 필요한 총 블록 수는 &lt;/font&gt; &lt;code&gt;N = (r/bfr) = 5000000/18 = 277,778&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; 블록입니다.&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67d7d36ed55f5b6ce5bb067162a83dc511e7fd79" translate="yes" xml:space="preserve">
          <source>Given that an index record contains only the indexed field and a pointer to the original record, it stands to reason that it will be smaller than the multi-field record that it points to. So the index itself requires fewer disk blocks than the original table, which therefore requires fewer block accesses to iterate through. The schema for an index on the &lt;em&gt;firstName&lt;/em&gt; field is outlined below;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스 레코드에 인덱싱 된 필드와 원래 레코드에 대한 포인터 만 포함되어 있으면 해당 레코드가 가리키는 다중 필드 레코드보다 작은 이유가 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 인덱스 자체에는 원본 테이블보다 적은 수의 디스크 블록이 필요하므로 반복되는 블록 액세스가 더 적습니다. &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 필드 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 인덱스 스키마 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;는 다음과 같습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b8a40897243ff8b8b9b81a535752ccc504133a4" translate="yes" xml:space="preserve">
          <source>Given that creating an index requires additional disk space (277,778 blocks extra from the above example, a ~28% increase), and that too many indices can cause issues arising from the file systems size limits, careful thought must be used to select the correct fields to index.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스를 만들려면 추가 디스크 공간이 필요하고 (위의 예에서 277,778 개의 블록이 추가되어 ~ 28 % 증가) 너무 많은 인덱스가 파일 시스템 크기 제한으로 인해 문제를 일으킬 수 있으므로 올바른 선택을 위해 신중한 생각을 사용해야합니다 색인 할 필드.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6560699d2bd8f61f1f9e9e79eda860b41d744347" translate="yes" xml:space="preserve">
          <source>Given that indexing is so important as your data set increases in size, can someone explain how indexing works at a database-agnostic level?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터 세트의 크기가 커질수록 인덱싱이 중요하다는 것을 감안할 때 데이터베이스와 무관하게 인덱싱이 어떻게 작동하는지 설명 할 수 있습니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="32a8bd6432ae70cef621c292e079e404b892ba3b" translate="yes" xml:space="preserve">
          <source>Hash tables are not sorted data structures, and there are many types of queries which hash indexes can not even help with. For instance, suppose you want to find out all of the employees who are less than 40 years old. How could you do that with a hash table index? Well, it&amp;rsquo;s not possible because a hash table is only good for looking up key value pairs &amp;ndash; which means queries that check for equality</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해시 테이블은 정렬 된 데이터 구조가 아니며 해시 인덱스가 도움을 줄 수없는 여러 유형의 쿼리가 있습니다. 예를 들어 40 세 미만의 모든 직원을 찾으려고한다고 가정하십시오. 해시 테이블 인덱스로 어떻게 할 수 있습니까? 해시 테이블은 키 값 쌍을 찾는 데만 적합하기 때문에 불가능합니다. 즉, 동등성을 검사하는 쿼리를 의미합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d21860c9c34e97854024389404de25905618ed2" translate="yes" xml:space="preserve">
          <source>Helped me:- &lt;a href=&quot;https://stackoverflow.com/questions/1251636/what-do-clustered-and-non-clustered-index-actually-mean&quot;&gt;What do Clustered and Non clustered index actually mean?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나를 돕기 :- &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1251636/what-do-clustered-and-non-clustered-index-actually-mean&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;클러스터 및 비 클러스터 인덱스는 실제로 무엇을 의미합니까?&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3cca3a8a00a3a45f0a5c76f372683f44b7b1881" translate="yes" xml:space="preserve">
          <source>How do database indexes work</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터베이스 인덱스 작동 방법&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5452e26c95523ae9f9b07a1f3bae3db9dbe68101" translate="yes" xml:space="preserve">
          <source>How does database indexing work</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터베이스 인덱싱 작동 방식&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7df16cfacc6d28d0dec6ecd7f0a8c16905729906" translate="yes" xml:space="preserve">
          <source>How to create an index:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스를 만드는 방법 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9a156ac7af5ee1f8d9b1e3dfc529d5d31e2a992" translate="yes" xml:space="preserve">
          <source>However, defining two different locations on two different hard disks for index data and table data can decrease/eliminate the problem of increased cost of time. This requires definition of additional file groups with according files on the desired hard disks and definition of table/index location as desired.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 인덱스 데이터 및 테이블 데이터에 대해 두 개의 다른 하드 디스크에서 두 개의 다른 위치를 정의하면 시간 비용 증가 문제를 줄이거 나 없앨 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 위해서는 원하는 하드 디스크에있는 파일과 함께 추가 파일 그룹을 정의하고 원하는대로 테이블 / 인덱스 위치를 정의해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef380204ad169fc2292c6fa188d9c6d356f78f84" translate="yes" xml:space="preserve">
          <source>If you have a book about dogs and you want to find an information about let's say, German Shepherds, you could of course flip through all the pages of the book and find what you are looking for  - but this of course is time consuming and not very fast.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;개에 관한 책이 있고 German Shepherds에 대한 정보를 찾고 싶다면 물론 책의 모든 페이지를 넘겨보고 찾고있는 것을 찾을 수는 있지만 시간이 많이 걸리지 않습니다. 매우 빠릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d8f04bd94bd160a1d96d45d2529a31258e82a393" translate="yes" xml:space="preserve">
          <source>In Database, the page number is referred to as a pointer which directs the database to the address on the disk where entity is located. Using the same German Shepherd analogy, we could have something like this (&amp;ldquo;German Shepherd&amp;rdquo;, 0x77129) where &lt;code&gt;0x77129&lt;/code&gt; is the address on the disk where the row data for German Shepherd is stored.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터베이스에서 페이지 번호는 데이터베이스를 엔티티가있는 디스크의 주소로 지정하는 포인터라고합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;동일한 German Shepherd 유추를 사용하면 다음과 같은 결과를 얻을 수 있습니다 (&amp;ldquo;German Shepherd&amp;rdquo;, 0x77129). 여기서 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0x77129&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 는 German Shepherd의 행 데이터가 저장된 디스크의 주소입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ef1c79649a1ffa63f8f1acd27875a9fcc448b06" translate="yes" xml:space="preserve">
          <source>In certain scenarios a heap is more helpful than a table with indexes,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특정 시나리오에서 힙은 인덱스가있는 테이블보다 유용합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c571b07f97ec082a06642bacb56f5d9267f7fdae" translate="yes" xml:space="preserve">
          <source>In short, an index is a data structure that stores the values for a specific column in a table so as to speed up query search.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단히 말해서 인덱스는 쿼리의 속도를 높이기 위해 테이블에 특정 열의 값을 저장하는 데이터 구조입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8e8e8ce6c1f5d8d1d05614c2f29659055232953f" translate="yes" xml:space="preserve">
          <source>Indexing is a way of sorting a number of records on multiple fields. Creating an index on a field in a table creates another data structure which holds the field value, and a pointer to the record it relates to. This index structure is then sorted, allowing Binary Searches to be performed on it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱싱은 여러 필드에서 여러 레코드를 정렬하는 방법입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;테이블의 필드에서 인덱스를 작성하면 필드 값을 보유하는 다른 데이터 구조와 관련 레코드에 대한 포인터가 작성됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그런 다음이 인덱스 구조를 정렬하여 이진 검색을 수행 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a611240736d03bf16b06eb89c51008f6b823f25d" translate="yes" xml:space="preserve">
          <source>It takes up space &amp;ndash; and the larger your table, the larger your index. Another performance hit with indexes is the fact that whenever you add, delete, or update rows in the corresponding table, the same operations will have to be done to your index. Remember that an index needs to contain the same up to the minute data as whatever is in the table column(s) that the index covers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;공간을 차지하고 테이블이 클수록 인덱스가 커집니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스의 또 다른 성능 저하는 해당 테이블에서 행을 추가, 삭제 또는 업데이트 할 때마다 인덱스에 대해 동일한 작업을 수행해야한다는 사실입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스는 인덱스가 포함하는 테이블 열에있는 것과 동일한 분 단위의 데이터를 포함해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="276b5a9e7eafc9116c94af7c4302e336bba600a7" translate="yes" xml:space="preserve">
          <source>Just a quick suggestion.. As indexing costs you additional writes and storage space, so if your application requires more insert/update operation, you might want to use tables without indexes, but if it requires more data retrieval operations, you should go for indexed table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱싱에 추가 쓰기 및 저장 공간이 필요하므로 응용 프로그램에 더 많은 삽입 / 업데이트 작업이 필요한 경우 인덱스가없는 테이블을 사용할 수 있지만 더 많은 데이터 검색 작업이 필요한 경우 인덱싱해야합니다. 표.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="79473d1d1fae832de50165b98ed9730e2335bcff" translate="yes" xml:space="preserve">
          <source>Just think of Database Index as Index of a book.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터베이스 색인을 책의 색인으로 생각하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9e6820fb508cdfb4143176447ba4ee4022ec87ef" translate="yes" xml:space="preserve">
          <source>Now a search using the &lt;em&gt;firstName&lt;/em&gt; field can utilize the index to increase performance. This allows for a binary search of the index with an average of &lt;code&gt;log2 277778 = 18.08 = 19&lt;/code&gt; block accesses. To find the address of the actual record, which requires a further block access to read, bringing the total to &lt;code&gt;19 + 1 = 20&lt;/code&gt; block accesses, a far cry from the 1,000,000 block accesses required to find a &lt;em&gt;firstName&lt;/em&gt; match in the non-indexed table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 필드를 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;사용한 검색 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;은 색인을 사용하여 성능을 향상시킬 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 통해 평균 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 277778 = 18.08 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 블록 액세스로 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스를 이진 검색 할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;읽을 수있는 추가 블록 액세스가 필요한 실제 레코드의 주소를 찾으려면 총 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;19 + 1 = 20&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 블록 액세스 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 가져 오면 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스되지 않은 테이블에서 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 일치 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 찾는 데 필요한 1,000,000 블록 액세스와는 거리가 멀어집니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a62e94584fca0d632abdef6d650cf49c229bbe33" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;firstName&lt;/em&gt; field is neither sorted nor a key field, so a binary search is impossible, nor are the values unique, and thus the table will require searching to the end for an exact &lt;code&gt;N = 1,000,000&lt;/code&gt; block accesses. It is this situation that indexing aims to correct.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 필드는 정렬되거나 키 필드가 아니므로 이진 검색이 불가능하거나 값이 고유하지 않으므로 테이블에서 정확한 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N = 1,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 블록 액세스 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 위해 끝까지 검색해야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱싱이 바로이 상황입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50cbc01eb392ec54b5d1caa08a59f11a5eb7f3b1" translate="yes" xml:space="preserve">
          <source>Now, imagine you want to find a particular Chapter that contains a word &quot;&lt;strong&gt;Alchemist&lt;/strong&gt;&quot;. Without an index page, you have no other option than scanning through the entire book/Chapters. i.e: 1000 pages.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 &quot; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Alchemist&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;라는 단어가 포함 된 특정 장을 찾고 싶다고 상상해보십시오 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;색인 페이지가 없으면 책 / 장 전체를 스캔하는 것 외에 다른 옵션이 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;즉 : 1000 페이지.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="777cb84ce5a934c14c04fb32c3c230b0028ab12b" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say that we want to run a query to find all the details of any employees who are named &amp;lsquo;Abc&amp;rsquo;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 'Abc'라는 직원의 모든 세부 정보를 찾기 위해 쿼리를 실행한다고 가정 해 봅시다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cb63ab6c0db77bef9b2c256e11bc06a79e6c6bd" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say that we want to run a query to find all the details of any users who are named 'John'. 
If we run the following query:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 'John'이라는 사용자의 모든 세부 정보를 찾기 위해 쿼리를 실행하려고한다고 가정하겠습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 쿼리를 실행하면&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="1d5c52ff7943b48eda6b1cf65c290aa09e17f098" translate="yes" xml:space="preserve">
          <source>Simple, huh?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단 하죠?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c573cfffeb370eb01525896bbc026605b0d66f5c" translate="yes" xml:space="preserve">
          <source>Since indices are only used to speed up the searching for a matching field within the records, it stands to reason that indexing fields used only for output would be simply a waste of disk space and processing time when doing an insert or delete operation, and thus should be avoided. Also given the nature of a binary search, the cardinality or uniqueness of the data is important. Indexing on a field with a cardinality of 2 would split the data in half, whereas a cardinality of 1,000 would return approximately 1,000 records. With such a low cardinality the effectiveness is reduced to a linear sort, and the query optimizer will avoid using the index if the cardinality is less than 30% of the record number, effectively making the index a waste of space.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스는 레코드 내에서 일치하는 필드를 빠르게 검색하는 데만 사용되므로 출력에만 사용되는 인덱싱 필드는 단순히 삽입 또는 삭제 작업을 수행 할 때 디스크 공간과 처리 시간을 낭비하게되므로 추론 할 수 있습니다. 피해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 이진 검색의 특성상 데이터의 카디널리티 또는 고유성이 중요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;카디널리티가 2 인 필드에서 인덱싱하면 데이터가 절반으로 분할되고 카디널리티가 1,000이면 약 1,000 개의 레코드가 반환됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이와 같은 카디널리티가 낮 으면 효율성이 선형 정렬로 감소하고 카디널리티가 레코드 수의 30 % 미만인 경우 쿼리 최적화 프로그램은 인덱스를 공간 낭비로 만드는 경우 인덱스 사용을 피합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e9732b1f53d3a2736ee890d12a683c1fc0c8f2cf" translate="yes" xml:space="preserve">
          <source>Since then I gained some insight about the downside of creating indexes:
if you write into a table (&lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt;) with one index, you have actually two writing operations in the file system. One for the table data and another one for the index data (and the resorting of it (and - if clustered - the resorting of the table data)). If table and index are located on the same hard disk this costs more time. Thus a table without an index (a heap) , would allow for quicker write operations. (if you had two indexes you would end up with three write operations, and so on)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그 이후로 색인 작성의 단점에 대한 통찰력을 얻었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하나의 색인 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;으로 테이블 ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;UPDATE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 또는 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;INSERT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )에 쓰면 실제로 파일 시스템에 두 가지 쓰기 작업이 있습니다. 하나는 테이블 데이터를위한 것이고 다른 하나는 인덱스 데이터를위한 것입니다 (그리고 그 데이터를 정리 (및 클러스터 된 경우, 테이블 데이터의 정리)). 테이블과 인덱스가 동일한 하드 디스크에있는 경우 시간이 더 걸립니다. 따라서 인덱스가없는 테이블 (힙)은 더 빠른 쓰기 작업을 허용합니다. (두 개의 인덱스가 있으면 세 번의 쓰기 작업 등으로 끝납니다)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="adecf93f2acfab3a69649212fe2efb7426f23e48" translate="yes" xml:space="preserve">
          <source>So now the database will use the index to find employees named John
  because the index will presumably be sorted alphabetically by the
  Users name. And, because it is sorted, it means searching for a name
  is a lot faster because all names starting with a &amp;ldquo;J&amp;rdquo; will be right
  next to each other in the index!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 데이터베이스는 색인을 사용하여 John이라는 직원을 찾습니다. 색인은 아마도 사용자 이름에 따라 알파벳순으로 정렬되기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 정렬되어 있기 때문에&amp;ldquo;J&amp;rdquo;로 시작하는 모든 이름이 색인에서 서로 바로 옆에 있기 때문에 이름 검색이 훨씬 빠릅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="26471d745a61045c6728ede7f132a76a50811d84" translate="yes" xml:space="preserve">
          <source>The database software would literally have to look at every single row in the &lt;code&gt;User&lt;/code&gt; table to see if the &lt;code&gt;Name&lt;/code&gt; for that row is &amp;lsquo;John&amp;rsquo;. This will take a long time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터베이스 소프트웨어는 문자 그대로 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 테이블 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 모든 단일 행 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;을보고 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해당 행 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 이 'John' &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인지 확인해야합니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;시간이 오래 걸립니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92388142fd95760bd53d3617559908024063026c" translate="yes" xml:space="preserve">
          <source>The downside to indexing is that these indices require additional space on the disk since the indices are stored together in a table using the MyISAM engine, this file can quickly reach the size limits of the underlying file system if many fields within the same table are indexed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱싱의 단점은 MyISAM 엔진을 사용하여 테이블에 인덱스가 함께 저장되므로 인덱스에 디스크에 추가 공간이 필요하다는 것입니다. 동일한 테이블 내의 많은 필드가 인덱스 된 경우이 파일은 기본 파일 시스템의 크기 제한에 빠르게 도달 할 수 있습니다 .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7d8c6667f49892d4041edae513099ceacb903c2e" translate="yes" xml:space="preserve">
          <source>The first time I read this it was very helpful to me. Thank you.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;내가 이것을 처음 읽었을 때 그것은 나에게 매우 도움이되었다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;감사합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6ab7299d1206cde9db1d5f739db12c3075d44567" translate="yes" xml:space="preserve">
          <source>The index is nothing but a data structure that &lt;strong&gt;stores the values for a specific column&lt;/strong&gt; in a table. An index is created on a column of a table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;테이블 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;의 특정 열에 대한 값을 저장&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 하는 데이터 구조 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일뿐입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스는 테이블의 열에 생성됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="126caeb9af8c72c10dc8b6168e0b5dd59a87df45" translate="yes" xml:space="preserve">
          <source>The reason B- trees are the most popular data structure for indexes is due to the fact that they are time efficient &amp;ndash; because look-ups, deletions, and insertions can all be done in logarithmic time. And, another major reason B- trees are more commonly used is because the data that is stored inside the B- tree can be sorted. The RDBMS typically determines which data structure is actually used for an index. But, in some scenarios with certain RDBMS&amp;rsquo;s, you can actually specify which data structure you want your database to use when you create the index itself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B- 트리가 인덱스에 가장 널리 사용되는 데이터 구조 인 이유는 조회, 삭제 및 삽입이 모두 로그 시간에 수행 될 수 있기 때문에 시간이 효율적이기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그리고 B- 트리가 더 일반적으로 사용되는 또 다른 주요 이유는 B- 트리 내부에 저장된 데이터를 정렬 할 수 있기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;RDBMS는 일반적으로 인덱스에 실제로 사용되는 데이터 구조를 결정합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 특정 RDBMS가있는 일부 시나리오에서는 실제로 색인 자체를 작성할 때 데이터베이스가 사용할 데이터 구조를 지정할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef4d79676e50d3782a878b91406b5f00f4a58cd0" translate="yes" xml:space="preserve">
          <source>The reason hash indexes are used is because hash tables are extremely efficient when it comes to just looking up values. So, queries that compare for equality to a string can retrieve values very fast if they use a hash index.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;해시 인덱스가 사용되는 이유는 해시 테이블이 값을 찾는 데 매우 효율적이기 때문입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 문자열과 동등을 비교하는 쿼리는 해시 인덱스를 사용하는 경우 값을 매우 빠르게 검색 할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="257d302baeb4a014b97399cca558bbb83e525e5d" translate="yes" xml:space="preserve">
          <source>The whole point of having an index is to speed up search queries by essentially cutting down the number of records/rows in a table that need to be examined. An index is a data structure (most commonly a B- tree) that stores the values for a specific column in a table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스를 갖는 요점은 검사해야 할 테이블의 레코드 / 행 수를 본질적으로 줄임으로써 검색 쿼리 속도를 높이는 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스는 테이블의 특정 열에 대한 값을 저장하는 데이터 구조 (가장 일반적으로 B- 트리)입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a4f5d021fd61272cfc727ba4d28ac004f08424f2" translate="yes" xml:space="preserve">
          <source>Things are simple in schools, isn't it? :P</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;학교에서는 일이 간단하지 않습니까? &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:피&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7503b65320d9c1b258a3d69a2f77ffa5cb85b3fa" translate="yes" xml:space="preserve">
          <source>This analogy is known as &lt;strong&gt;&quot;Full Table Scan&quot;&lt;/strong&gt; in database world.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 비유는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터베이스 세계에서 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;전체 테이블 스캔&quot;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 으로 알려져 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="814e34b9dbc0414d8df43d75cfeebb5d902126ee" translate="yes" xml:space="preserve">
          <source>This is where &lt;code&gt;index&lt;/code&gt; helps us: &lt;em&gt;index is used to speed up search queries by essentially cutting down the number of records/rows in a table that needs to be examined&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;곳이다 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 도움이 : &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;인덱스는 기본적으로 필요 검사 할 것을 테이블의 레코드 / 행의 수를 삭감하여 검색 쿼리 속도를하는 데 사용됩니다&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eae407d68bea00f32c03361bd34649b638b74dd0" translate="yes" xml:space="preserve">
          <source>Thus, the index is a separate section that stores values of indexed
  column + pointer to the indexed row in a sorted order for efficient
  look-ups.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 인덱스는 효율적인 조회를 위해 인덱스 된 열 + 인덱스 된 행에 대한 포인터의 값을 정렬 된 순서로 저장하는 별도의 섹션입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3388f2a0255a47ceeb6050962fbb9511180c8d29" translate="yes" xml:space="preserve">
          <source>What columns generally make good indexes?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 어떤 열이 좋은 색인을 만드는가?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e6f1df688c30d94eb68a3bb0fa23154aa1e18bc3" translate="yes" xml:space="preserve">
          <source>When data is stored on disk-based storage devices, it is stored as blocks of data. These blocks are accessed in their entirety, making them the atomic disk access operation. Disk blocks are structured in much the same way as linked lists; both contain a section for data, a pointer to the location of the next node (or block), and both need not be stored contiguously.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터가 디스크 기반 저장 장치에 저장되면 데이터 블록으로 저장됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 블록들은 전체적으로 액세스되어 원자 디스크 액세스 작업이됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;디스크 블록은 링크 된 목록과 거의 같은 방식으로 구성됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;둘 다 데이터 섹션, 다음 노드 (또는 블록)의 위치에 대한 포인터를 포함하며, 둘 다 연속적으로 저장할 필요는 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="93a2555206a0af83fbe551a83137431c161ed8c6" translate="yes" xml:space="preserve">
          <source>Whereas with a sorted field, a Binary Search may be used, which has &lt;code&gt;log2 N&lt;/code&gt; block accesses. Also since the data is sorted given a non-key field, the rest of the table doesn&amp;rsquo;t need to be searched for duplicate values, once a higher value is found. Thus the performance increase is substantial.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정렬 된 필드의 경우, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 N&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 블록 액세스 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;를 갖는 이진 검색이 사용될 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 키가 아닌 필드를 기준으로 데이터가 정렬되므로 더 높은 값을 찾으면 나머지 테이블에서 중복 값을 검색 할 필요가 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 성능이 크게 향상됩니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b533efcb68c06cbb661f675f72076a2242fa3ed" translate="yes" xml:space="preserve">
          <source>e.g:- If you have lots of rivalling writes but only one nightly read outside business hours for reporting.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들면 다음과 같습니다 .- 귀하가 경쟁 기록을 많이 가지고 있지만보고를 위해 업무 시간 외 1 일 밤에 한 번만 읽는 경우.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
