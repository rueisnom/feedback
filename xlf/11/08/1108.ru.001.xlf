<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1108">
    <body>
      <group id="1108">
        <trans-unit id="7c6f976f4e1f247357643420b0f1d5edff13eef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Example 1&lt;/em&gt;&lt;/strong&gt; - &lt;em&gt;sorted vs unsorted fields&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Пример 1&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; сортированные против несортированных полей&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad6ea987ddb5784c13bde986d9834b1b8aa7cc8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Example 2&lt;/em&gt;&lt;/strong&gt;  - &lt;em&gt;indexing&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Пример 2&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; индексация&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c263d6e1ec3808a54cf13984a9ccf2fe20c030b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How a database index can help performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как индекс базы данных может помочь производительности&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ee6c6ffc954bb7d8e7f64c641b17ff3a602b455" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does B-trees index work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как работает индекс B-деревьев?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1038135901ca45cbc26e89cf4438b522835561bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does a database know when to use an index?&lt;/strong&gt;
When a query like &amp;ldquo;SELECT * FROM Employee WHERE Employee_Name = &amp;lsquo;Abc&amp;rsquo; &amp;rdquo; is run, the database will check to see if there is an index on the column(s) being queried. Assuming the Employee_Name column does have an index created on it, the database will have to decide whether it actually makes sense to use the index to find the values being searched &amp;ndash; because there are some scenarios where it is actually less efficient to use the database index, and more efficient just to scan the entire table.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как база данных узнает, когда использовать индекс? &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Когда выполняется запрос типа &amp;laquo;SELECT * FROM Employee WHERE Employee_Name = 'Abc&amp;raquo; &amp;raquo;, база данных проверяет, есть ли индекс для столбца (столбцов), в котором выполняется запрос. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предполагая, что столбец Employee_Name имеет индекс, созданный для него, базе данных придется решить, имеет ли смысл использовать индекс для поиска искомых значений - потому что есть некоторые сценарии, где на самом деле менее эффективно использовать индекс базы данных. и эффективнее просто сканировать всю таблицу.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff64d04a079079f647ecb61630eba86649659ead" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does a hash table index work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как работает индекс хеш-таблицы?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c1ec9f40f4edd7eb75f8f619aa77433ee58d89b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does it work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как это работает?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7776d2a490f8e3aaac3f9ca4505cab9d20b38b23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Pointers in MySQL are 2, 3, 4 or 5 bytes in length depending on the size of the table.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Примечание&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . Указатели в MySQL имеют длину 2, 3, 4 или 5 байт в зависимости от размера таблицы.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d1f023e6a4d3bc1e8bf916bde9bbdd1bedb1d70d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: char was used in place of varchar to allow for an accurate size on disk value. 
This sample database contains five million rows and is unindexed. The performance of several queries will now be analyzed. These are a query using the &lt;em&gt;id&lt;/em&gt; (a sorted key field) and one using the &lt;em&gt;firstName&lt;/em&gt; (a non-key unsorted field).</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Примечание&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : вместо varchar использовался символ char для точного определения размера диска. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Этот образец базы данных содержит пять миллионов строк и не индексируется. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Производительность нескольких запросов теперь будет проанализирована. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это запрос с использованием &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;идентификатора&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (поле отсортированного ключа) и &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;запрос с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;использованием &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (не &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;отсортированное по ключу &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;поле).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e55a4eef1abc15fd25c68f22657b346ff3abdb11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Description!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Простое описание!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f4ae4a04e94c61d13e11443fa35cbf4c8957624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The disadvantages of a hash index&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Недостатки хеш-индекса&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d60b2311316bf1641d865996eaab467baf68c7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What exactly is inside a database index?&lt;/strong&gt;
So, now you know that a database index is created on a column in a table, and that the index stores the values in that specific column. But, it is important to understand that a database index does not store the values in the other columns of the same table. For example, if we create an index on the Employee_Name column, this means that the Employee_Age and Employee_Address column values are not also stored in the index. If we did just store all the other columns in the index, then it would be just like creating another copy of the entire table &amp;ndash; which would take up way too much space and would be very inefficient.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что именно находится внутри индекса базы данных?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Итак, теперь вы знаете, что для столбца в таблице создается индекс базы данных, и этот индекс хранит значения в этом конкретном столбце. Но важно понимать, что индекс базы данных не хранит значения в других столбцах той же таблицы. Например, если мы создаем индекс для столбца Employee_Name, это означает, что значения столбца Employee_Age и Employee_Address также не сохраняются в индексе. Если бы мы просто сохранили все остальные столбцы в индексе, то это было бы как создание другой копии всей таблицы, которая заняла бы слишком много места и была бы очень неэффективной.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6428ecc202198be70cb1f1755663fa9831bc29a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is indexing?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что такое индексация?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="66754d988f4fcb1acc4a50297f2aadea10736289" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is the cost of having a database index?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Какова стоимость наличия индекса базы данных?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e16a9f89c5c9cad39f49b095ddeef61be6287223" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What would happen without an index?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что будет без индекса?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba497667b700161a0513bd86c14414feabb5a6a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should it be used?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Когда его следует использовать?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c650694413b8d8c8e0547a99830e7752b6f6fb74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why is it needed?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Зачем это нужно?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fadfcc0b3b5611c6320a2347916ace1ab3378c3e" translate="yes" xml:space="preserve">
          <source>A linear search on the id field would require an average of &lt;code&gt;N/2 = 500,000&lt;/code&gt; block accesses to find a value, given that the id field is a key field. But since the id field is also sorted, a binary search can be conducted requiring an average of &lt;code&gt;log2 1000000 = 19.93 = 20&lt;/code&gt; block accesses. Instantly we can see this is a drastic improvement.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Линейный поиск в поле идентификатора потребует в среднем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N/2 = 500,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; обращений к блоку, чтобы найти значение, учитывая, что поле идентификатора является ключевым полем. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но поскольку поле id также отсортировано, можно выполнить бинарный поиск, требующий в среднем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 1000000 = 19.93 = 20&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; обращений к блоку. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Мгновенно мы видим, что это радикальное улучшение.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="71f1a10902b7a8ccbae4cdba11a0b434fe2b432e" translate="yes" xml:space="preserve">
          <source>Also, a differentiation between clustered and non-clustered indexes is rather important.</source>
          <target state="translated">Кроме того,довольно важно проводить различие между кластерными и некластерными индексами.</target>
        </trans-unit>
        <trans-unit id="f959491d8665d67cf85a2cc9b96a16ed6e7c0149" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;index&lt;/code&gt; consists of &lt;strong&gt;column values(Eg: John) from one table&lt;/strong&gt;, and those values are stored in a &lt;strong&gt;data structure&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; состоит из &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;значений столбцов (например: Джон) из одной таблицы&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , и эти значения сохраняются в &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;структуре данных&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ad74fb25accebf8d6e8d23b44a80acc6acebc0d" translate="yes" xml:space="preserve">
          <source>An index is just a data structure that makes the searching faster for a specific column in a database. This structure is usually a b-tree or a hash table but it can be any other logic structure.</source>
          <target state="translated">Индекс-это всего лишь структура данных,позволяющая ускорить поиск конкретного столбца в базе данных.Обычно это b-дерево или хэш-таблица,но это может быть любая другая логическая структура.</target>
        </trans-unit>
        <trans-unit id="ae0587c6babe222342305dc974d0c1ee2fec283f" translate="yes" xml:space="preserve">
          <source>Another option is that, you could just go to the Index section of the book and then find what you are looking for by using the Name of the entity you are looking ( in this instance, German Shepherds) and also looking at the page number to quickly find what you are looking for.</source>
          <target state="translated">Другой вариант заключается в том,что вы можете просто зайти в раздел &quot;Указатели&quot; книги и затем найти то,что вы ищете,используя Название сущности,которую вы ищете (в данном случае-Немецкие Пастыри),а также посмотреть на номер страницы,чтобы быстро найти то,что вы ищете.</target>
        </trans-unit>
        <trans-unit id="a42223342f004e5087636b0bd93ed01b59e5befd" translate="yes" xml:space="preserve">
          <source>Another problem with indexes is their fragmentation over time as data is inserted. &lt;code&gt;REORGANIZE&lt;/code&gt; helps, you must write routines to have it done.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Другая проблема с индексами заключается в их фрагментации с течением времени при вставке данных. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;REORGANIZE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; помогает, вы должны написать подпрограммы, чтобы сделать это.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="670ae6c441f98e2a78f5820d589187b5910ea31c" translate="yes" xml:space="preserve">
          <source>As a general rule, an index should only be created on a table if the data in the indexed column will be queried frequently.</source>
          <target state="translated">Как правило,индекс должен создаваться в таблице только в том случае,если данные в индексируемом столбце будут опрашиваться часто.</target>
        </trans-unit>
        <trans-unit id="06a4b006b5c2d9087ce316cf7000e63a79bca581" translate="yes" xml:space="preserve">
          <source>But then, in addition to actual 1000 pages, you will need another ~10 pages to show the indices, so totally 1010 pages.</source>
          <target state="translated">Но потом,в дополнение к реальным 1000 страницам,вам понадобится еще ~10 страниц,чтобы показать индексы,так что всего 1010 страниц.</target>
        </trans-unit>
        <trans-unit id="3d71c21621662c8be4c6dce7fd281e97dfd2c30e" translate="yes" xml:space="preserve">
          <source>But with an index page, you know where to go! And more, to lookup any particular Chapter that matters, you just need to look over the index page, again and again, every time. After finding the matching index you can efficiently jump to that chapter by skipping the rest.</source>
          <target state="translated">Но с индексной страницей ты знаешь,куда идти! И более того,чтобы посмотреть какую-то определенную Главу,которая имеет значение,нужно просто просматривать индексную страницу,снова и снова,каждый раз.После поиска подходящего индекса вы можете эффективно перейти к этой главе,пропустив остальное.</target>
        </trans-unit>
        <trans-unit id="a2aeece8a7e18f9f6165280d858250ef5c41a36b" translate="yes" xml:space="preserve">
          <source>Classic example &lt;strong&gt;&quot;Index in Books&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Классический пример &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Указатель в книгах&quot;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edfadc138c324a28c0ad48b4568b1c93f50ae608" translate="yes" xml:space="preserve">
          <source>Consider a &quot;Book&quot; of 1000 pages, divided by 10 Chapters, each section with 100 pages.</source>
          <target state="translated">Рассмотрим &quot;Книгу&quot; в 1000 страниц,разделенную на 10 глав,каждый раздел по 100 страниц.</target>
        </trans-unit>
        <trans-unit id="ccace75fa9dc2dfab316381c595f1cee029a29da" translate="yes" xml:space="preserve">
          <source>Database software would literally have to look at every single row in the Employee table to see if the Employee_Name for that row is &amp;lsquo;Abc&amp;rsquo;. And, because we want every row with the name &amp;lsquo;Abc&amp;rsquo; inside it, we can not just stop looking once we find just one row with the name &amp;lsquo;Abc&amp;rsquo;, because there could be other rows with the name &lt;strong&gt;Abc&lt;/strong&gt;. So, every row up until the last row must be searched &amp;ndash; which means thousands of rows in this scenario will have to be examined by the database to find the rows with the name &amp;lsquo;Abc&amp;rsquo;. This is what is called a &lt;strong&gt;full table scan&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Программному обеспечению базы данных в буквальном смысле пришлось бы просматривать каждую строку в таблице Employee, чтобы определить, является ли Employee_Name для этой строки 'Abc'. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И, поскольку нам нужна каждая строка с именем &amp;laquo;Abc&amp;raquo; внутри, мы не можем просто перестать искать, когда найдем только одну строку с именем &amp;laquo;Abc&amp;raquo;, потому что могут быть другие строки с именем &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Abc&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, каждая строка вплоть до последней строки должна быть найдена - это означает, что тысячи строк в этом сценарии должны быть проверены базой данных, чтобы найти строки с именем 'Abc'. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это то, что называется &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;полным сканированием таблицы&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ceb478c45cb9fe55a55150694c3e2f7c5bd8f32f" translate="yes" xml:space="preserve">
          <source>Due to the fact that a number of records can only be sorted on one field, we can state that searching on a field that isn&amp;rsquo;t sorted requires a Linear Search which requires &lt;code&gt;N/2&lt;/code&gt; block accesses (on average), where &lt;code&gt;N&lt;/code&gt; is the number of blocks that the table spans. If that field is a non-key field (i.e. doesn&amp;rsquo;t contain unique entries) then the entire tablespace must be searched at &lt;code&gt;N&lt;/code&gt; block accesses.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В связи с тем, что несколько записей могут быть отсортированы только по одному полю, мы можем констатировать, что для поиска по несортированному полю требуется линейный поиск, который требует &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N/2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; блоковых обращений (в среднем), где &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это количество блоков, которые охватывает таблица. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если это поле является неключевым (то есть не содержит уникальных записей), тогда все табличное пространство должно быть найдено при &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;доступе &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; блоков.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e5bc6d47e649819c256f1169901b6aa5852d68ce" translate="yes" xml:space="preserve">
          <source>Example: We have a database table called &lt;code&gt;User&lt;/code&gt; with three columns &amp;ndash; &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Address&lt;/code&gt;. Assume that the &lt;code&gt;User&lt;/code&gt; table has thousands of rows.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Пример: у нас есть таблица базы данных с именем &lt;/font&gt;&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; с тремя столбцами - &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Address&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Предположим, что &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;таблица &lt;/font&gt;&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; имеет тысячи строк.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6dfb64751c4bd0fadd0aadce8f3a9bec1f87f196" translate="yes" xml:space="preserve">
          <source>Firstly, let&amp;rsquo;s outline a sample database table schema;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Во-первых, давайте наметим пример схемы таблицы базы данных;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67a6b5de80a5587dd3df63bd3b5cd82d3ef329d8" translate="yes" xml:space="preserve">
          <source>For information on queries to index a field, check out &lt;a href=&quot;https://stackoverflow.com/questions/1156/&quot;&gt;How do I index a database column&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Информацию о запросах для индексирования поля смотрите в разделе &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1156/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как индексировать столбец базы данных&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a56b08d796085fa51779969ead12eba0cdf923dc" translate="yes" xml:space="preserve">
          <source>For instance, the query we discussed earlier could benefit from a hash index created on the Employee_Name column. The way a hash index would work is that the column value will be the key into the hash table and the actual value mapped to that key would just be a pointer to the row data in the table. Since a hash table is basically an associative array, a typical entry would look something like &amp;ldquo;Abc =&amp;gt; 0x28939&amp;Prime;, where 0x28939 is a reference to the table row where Abc is stored in memory. Looking up a value like &amp;ldquo;Abc&amp;rdquo; in a hash table index and getting back a reference to the row in memory is obviously a lot faster than scanning the table to find all the rows with a value of &amp;ldquo;Abc&amp;rdquo; in the Employee_Name column.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, запрос, который мы обсуждали ранее, может получить преимущество от хеш-индекса, созданного в столбце Employee_Name. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Способ работы хеш-индекса заключается в том, что значение столбца будет ключом в хеш-таблице, а фактическое значение, сопоставленное с этим ключом, будет просто указателем на данные строки в таблице. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поскольку хеш-таблица в основном является ассоциативным массивом, типичная запись будет выглядеть примерно так: &amp;laquo;Abc =&amp;gt; 0x28939&amp;raquo;, где 0x28939 - это ссылка на строку таблицы, в которой Abc хранится в памяти. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поиск значения типа &amp;laquo;Abc&amp;raquo; в индексе хэш-таблицы и получение ссылки на строку в памяти, очевидно, намного быстрее, чем сканирование таблицы, чтобы найти все строки со значением &amp;laquo;Abc&amp;raquo; в столбце Employee_Name.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ba744e72c82249823f810b1d800ca0c81ff406e9" translate="yes" xml:space="preserve">
          <source>Given our sample database of &lt;code&gt;r = 5,000,000&lt;/code&gt; records of a fixed size giving a record length of &lt;code&gt;R = 204&lt;/code&gt; bytes and they are stored in a table using the MyISAM engine which is using the default block size &lt;code&gt;B = 1,024&lt;/code&gt; bytes. The blocking factor of the table would be &lt;code&gt;bfr = (B/R) = 1024/204 = 5&lt;/code&gt; records per disk block. The total number of blocks required to hold the table is &lt;code&gt;N = (r/bfr) = 5000000/5 = 1,000,000&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Учитывая нашу примерную базу данных с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r = 5,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; записей фиксированного размера, дающих длину записи &lt;/font&gt;&lt;/font&gt; &lt;code&gt;R = 204&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; байта, и они хранятся в таблице с использованием механизма MyISAM, который использует размер блока по умолчанию &lt;/font&gt;&lt;/font&gt; &lt;code&gt;B = 1,024&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; байта. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Коэффициент блокировки таблицы будет &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bfr = (B/R) = 1024/204 = 5&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; записей на блок диска. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Общее количество блоков, необходимых для хранения таблицы, равно &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N = (r/bfr) = 5000000/5 = 1,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; блоков.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a612a719bfeff12051ef62ec18b988c42d957b8" translate="yes" xml:space="preserve">
          <source>Given our sample database of &lt;code&gt;r = 5,000,000&lt;/code&gt; records with an index record length of &lt;code&gt;R = 54&lt;/code&gt; bytes and using the default block size &lt;code&gt;B = 1,024&lt;/code&gt; bytes. The blocking factor of the index would be &lt;code&gt;bfr = (B/R) = 1024/54 = 18&lt;/code&gt; records per disk block. The total number of blocks required to hold the index is &lt;code&gt;N = (r/bfr) = 5000000/18 = 277,778&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Учитывая нашу примерную базу данных с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r = 5,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; записей с длиной записи индекса &lt;/font&gt;&lt;/font&gt; &lt;code&gt;R = 54&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; байта и использованием размера блока по умолчанию &lt;/font&gt;&lt;/font&gt; &lt;code&gt;B = 1,024&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; байта. Коэффициент блокировки индекса будет &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bfr = (B/R) = 1024/54 = 18&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; записей на блок диска. Общее количество блоков, необходимых для хранения индекса, равно &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N = (r/bfr) = 5000000/18 = 277,778&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; блоков.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67d7d36ed55f5b6ce5bb067162a83dc511e7fd79" translate="yes" xml:space="preserve">
          <source>Given that an index record contains only the indexed field and a pointer to the original record, it stands to reason that it will be smaller than the multi-field record that it points to. So the index itself requires fewer disk blocks than the original table, which therefore requires fewer block accesses to iterate through. The schema for an index on the &lt;em&gt;firstName&lt;/em&gt; field is outlined below;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Учитывая, что индексная запись содержит только индексированное поле и указатель на исходную запись, очевидно, что она будет меньше, чем многополевая запись, на которую она указывает. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, сам индекс требует меньше дисковых блоков, чем исходная таблица, поэтому для итераций требуется меньше обращений к блокам. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Схема для индекса в &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;поле &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; приведена ниже;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b8a40897243ff8b8b9b81a535752ccc504133a4" translate="yes" xml:space="preserve">
          <source>Given that creating an index requires additional disk space (277,778 blocks extra from the above example, a ~28% increase), and that too many indices can cause issues arising from the file systems size limits, careful thought must be used to select the correct fields to index.</source>
          <target state="translated">Учитывая,что создание индекса требует дополнительного дискового пространства (277 778 дополнительных блоков из приведенного выше примера,увеличение на ~28%),а также то,что слишком большое количество индексов может вызвать проблемы,связанные с ограничениями на размер файловых систем,необходимо тщательно продумать выбор правильных полей для индексации.</target>
        </trans-unit>
        <trans-unit id="6560699d2bd8f61f1f9e9e79eda860b41d744347" translate="yes" xml:space="preserve">
          <source>Given that indexing is so important as your data set increases in size, can someone explain how indexing works at a database-agnostic level?</source>
          <target state="translated">Учитывая,что индексирование настолько важно,что размер вашего набора данных увеличивается,может ли кто-нибудь объяснить,как работает индексирование на диагностическом уровне базы данных?</target>
        </trans-unit>
        <trans-unit id="32a8bd6432ae70cef621c292e079e404b892ba3b" translate="yes" xml:space="preserve">
          <source>Hash tables are not sorted data structures, and there are many types of queries which hash indexes can not even help with. For instance, suppose you want to find out all of the employees who are less than 40 years old. How could you do that with a hash table index? Well, it&amp;rsquo;s not possible because a hash table is only good for looking up key value pairs &amp;ndash; which means queries that check for equality</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Хеш-таблицы не являются отсортированными структурами данных, и существует много типов запросов, с которыми хеш-индексы могут даже не помочь. Например, предположим, что вы хотите узнать всех сотрудников, которым менее 40 лет. Как вы могли бы сделать это с индексом хэш-таблицы? Ну, это невозможно, потому что хеш-таблица хороша только для поиска пар ключ-значение - это означает, что запросы проверяют на равенство&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d21860c9c34e97854024389404de25905618ed2" translate="yes" xml:space="preserve">
          <source>Helped me:- &lt;a href=&quot;https://stackoverflow.com/questions/1251636/what-do-clustered-and-non-clustered-index-actually-mean&quot;&gt;What do Clustered and Non clustered index actually mean?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Помог мне: - &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1251636/what-do-clustered-and-non-clustered-index-actually-mean&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Что на самом деле означает Кластерный и Некластерный индекс?&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3cca3a8a00a3a45f0a5c76f372683f44b7b1881" translate="yes" xml:space="preserve">
          <source>How do database indexes work</source>
          <target state="translated">Как работают индексы базы данных</target>
        </trans-unit>
        <trans-unit id="5452e26c95523ae9f9b07a1f3bae3db9dbe68101" translate="yes" xml:space="preserve">
          <source>How does database indexing work</source>
          <target state="translated">Как работает индексирование базы данных</target>
        </trans-unit>
        <trans-unit id="7df16cfacc6d28d0dec6ecd7f0a8c16905729906" translate="yes" xml:space="preserve">
          <source>How to create an index:</source>
          <target state="translated">Как создать индекс:</target>
        </trans-unit>
        <trans-unit id="e9a156ac7af5ee1f8d9b1e3dfc529d5d31e2a992" translate="yes" xml:space="preserve">
          <source>However, defining two different locations on two different hard disks for index data and table data can decrease/eliminate the problem of increased cost of time. This requires definition of additional file groups with according files on the desired hard disks and definition of table/index location as desired.</source>
          <target state="translated">Однако,определение двух разных мест на двух разных жестких дисках для индексных и табличных данных может уменьшить проблему увеличения затрат времени.Это требует определения дополнительных файловых групп с соответствующими файлами на требуемых жестких дисках и определения местоположения табличных данных по желанию.</target>
        </trans-unit>
        <trans-unit id="ef380204ad169fc2292c6fa188d9c6d356f78f84" translate="yes" xml:space="preserve">
          <source>If you have a book about dogs and you want to find an information about let's say, German Shepherds, you could of course flip through all the pages of the book and find what you are looking for  - but this of course is time consuming and not very fast.</source>
          <target state="translated">Если у вас есть книга о собаках и вы хотите найти информацию,скажем,о немецких овчарках,вы,конечно,можете пролистать все страницы книги и найти то,что ищете-но это,конечно,занимает много времени и не очень быстро.</target>
        </trans-unit>
        <trans-unit id="d8f04bd94bd160a1d96d45d2529a31258e82a393" translate="yes" xml:space="preserve">
          <source>In Database, the page number is referred to as a pointer which directs the database to the address on the disk where entity is located. Using the same German Shepherd analogy, we could have something like this (&amp;ldquo;German Shepherd&amp;rdquo;, 0x77129) where &lt;code&gt;0x77129&lt;/code&gt; is the address on the disk where the row data for German Shepherd is stored.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В базе данных номер страницы называется указателем, который направляет базу данных на адрес на диске, где находится объект. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Используя ту же аналогию с немецкой овчаркой, мы можем получить что-то вроде этого (&amp;laquo;Немецкая овчарка&amp;raquo;, 0x77129), где &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0x77129&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; - это адрес на диске, где хранятся данные строки для немецкой овчарки.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ef1c79649a1ffa63f8f1acd27875a9fcc448b06" translate="yes" xml:space="preserve">
          <source>In certain scenarios a heap is more helpful than a table with indexes,</source>
          <target state="translated">В некоторых сценариях куча полезнее,чем таблица с индексами,</target>
        </trans-unit>
        <trans-unit id="c571b07f97ec082a06642bacb56f5d9267f7fdae" translate="yes" xml:space="preserve">
          <source>In short, an index is a data structure that stores the values for a specific column in a table so as to speed up query search.</source>
          <target state="translated">Короче говоря,индекс-это структура данных,в которой хранятся значения для конкретного столбца в таблице,чтобы ускорить поиск по запросу.</target>
        </trans-unit>
        <trans-unit id="8e8e8ce6c1f5d8d1d05614c2f29659055232953f" translate="yes" xml:space="preserve">
          <source>Indexing is a way of sorting a number of records on multiple fields. Creating an index on a field in a table creates another data structure which holds the field value, and a pointer to the record it relates to. This index structure is then sorted, allowing Binary Searches to be performed on it.</source>
          <target state="translated">Индексирование-это способ сортировки ряда записей по нескольким полям.Создание индекса по полю в таблице создает другую структуру данных,в которой хранится значение поля и указатель на запись,к которой оно относится.Затем эта структура индекса сортируется,позволяя выполнять на ней двоичный поиск.</target>
        </trans-unit>
        <trans-unit id="a611240736d03bf16b06eb89c51008f6b823f25d" translate="yes" xml:space="preserve">
          <source>It takes up space &amp;ndash; and the larger your table, the larger your index. Another performance hit with indexes is the fact that whenever you add, delete, or update rows in the corresponding table, the same operations will have to be done to your index. Remember that an index needs to contain the same up to the minute data as whatever is in the table column(s) that the index covers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это занимает место - и чем больше ваша таблица, тем больше ваш индекс. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Еще одним ударом по производительности с индексами является тот факт, что всякий раз, когда вы добавляете, удаляете или обновляете строки в соответствующей таблице, одни и те же операции должны выполняться с вашим индексом. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Помните, что индекс должен содержать те же самые данные с точностью до минуты, как и все, что находится в столбцах таблицы, которые покрывает индекс.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="276b5a9e7eafc9116c94af7c4302e336bba600a7" translate="yes" xml:space="preserve">
          <source>Just a quick suggestion.. As indexing costs you additional writes and storage space, so if your application requires more insert/update operation, you might want to use tables without indexes, but if it requires more data retrieval operations, you should go for indexed table.</source>
          <target state="translated">Просто небольшое предложение...Поскольку индексирование стоит дополнительных затрат на запись и хранение,поэтому если ваше приложение требует больше операций по обновлению вставки,вы,возможно,захотите использовать таблицы без индексов,но если это требует больше операций по извлечению данных,вам следует обратиться к индексированным таблицам.</target>
        </trans-unit>
        <trans-unit id="79473d1d1fae832de50165b98ed9730e2335bcff" translate="yes" xml:space="preserve">
          <source>Just think of Database Index as Index of a book.</source>
          <target state="translated">Просто подумай об Индексе Базы Данных как об Индексе Книги.</target>
        </trans-unit>
        <trans-unit id="9e6820fb508cdfb4143176447ba4ee4022ec87ef" translate="yes" xml:space="preserve">
          <source>Now a search using the &lt;em&gt;firstName&lt;/em&gt; field can utilize the index to increase performance. This allows for a binary search of the index with an average of &lt;code&gt;log2 277778 = 18.08 = 19&lt;/code&gt; block accesses. To find the address of the actual record, which requires a further block access to read, bringing the total to &lt;code&gt;19 + 1 = 20&lt;/code&gt; block accesses, a far cry from the 1,000,000 block accesses required to find a &lt;em&gt;firstName&lt;/em&gt; match in the non-indexed table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь поиск с использованием &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;поля &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; может использовать индекс для увеличения производительности. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это позволяет выполнять двоичный поиск по индексу со средним значением &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 277778 = 18.08 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; блоковых обращений. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Чтобы найти адрес фактической записи, которая требует дополнительного доступа к блоку для чтения, доведя общее количество до &lt;/font&gt;&lt;/font&gt; &lt;code&gt;19 + 1 = 20&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; обращений к блокам, это далеко от 1 000 000 обращений к блокам, необходимых для поиска соответствия &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в неиндексированной таблице. ,&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a62e94584fca0d632abdef6d650cf49c229bbe33" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;firstName&lt;/em&gt; field is neither sorted nor a key field, so a binary search is impossible, nor are the values unique, and thus the table will require searching to the end for an exact &lt;code&gt;N = 1,000,000&lt;/code&gt; block accesses. It is this situation that indexing aims to correct.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;поле &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; не сортируется и не является ключевым, поэтому двоичный поиск невозможен, а значения не являются уникальными, и, следовательно, таблица потребует поиска до конца для точного &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N = 1,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; обращений к блоку. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Именно эту ситуацию индексация стремится исправить.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50cbc01eb392ec54b5d1caa08a59f11a5eb7f3b1" translate="yes" xml:space="preserve">
          <source>Now, imagine you want to find a particular Chapter that contains a word &quot;&lt;strong&gt;Alchemist&lt;/strong&gt;&quot;. Without an index page, you have no other option than scanning through the entire book/Chapters. i.e: 1000 pages.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь представьте, что вы хотите найти определенную главу, которая содержит слово &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Алхимик&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Без индексной страницы у вас нет другого выбора, кроме сканирования всей книги / глав. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;т.е. 1000 страниц.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="777cb84ce5a934c14c04fb32c3c230b0028ab12b" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say that we want to run a query to find all the details of any employees who are named &amp;lsquo;Abc&amp;rsquo;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь предположим, что мы хотим запустить запрос, чтобы найти все детали любых сотрудников с именем &amp;laquo;Abc&amp;raquo;?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cb63ab6c0db77bef9b2c256e11bc06a79e6c6bd" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say that we want to run a query to find all the details of any users who are named 'John'. 
If we run the following query:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь предположим, что мы хотим запустить запрос, чтобы найти все данные о пользователях с именем &amp;laquo;Джон&amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если мы запустим следующий запрос:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">См.также</target>
        </trans-unit>
        <trans-unit id="1d5c52ff7943b48eda6b1cf65c290aa09e17f098" translate="yes" xml:space="preserve">
          <source>Simple, huh?</source>
          <target state="translated">Просто,да?</target>
        </trans-unit>
        <trans-unit id="c573cfffeb370eb01525896bbc026605b0d66f5c" translate="yes" xml:space="preserve">
          <source>Since indices are only used to speed up the searching for a matching field within the records, it stands to reason that indexing fields used only for output would be simply a waste of disk space and processing time when doing an insert or delete operation, and thus should be avoided. Also given the nature of a binary search, the cardinality or uniqueness of the data is important. Indexing on a field with a cardinality of 2 would split the data in half, whereas a cardinality of 1,000 would return approximately 1,000 records. With such a low cardinality the effectiveness is reduced to a linear sort, and the query optimizer will avoid using the index if the cardinality is less than 30% of the record number, effectively making the index a waste of space.</source>
          <target state="translated">Поскольку индексы используются только для ускорения поиска совпадающего поля в записях,есть основания полагать,что индексирование полей,используемых только для вывода,было бы просто пустой тратой дискового пространства и времени на обработку при выполнении операции вставки или удаления,и поэтому его следует избегать.Кроме того,учитывая характер двоичного поиска,важна кардинальность или уникальность данных.Индексирование по полю с кардинальностью 2 разбило бы данные пополам,в то время как кардинальность в 1000 возвращала бы около 1000 записей.При такой низкой кардинальности эффективность сводится к линейному виду,и оптимизатор запросов будет избегать использования индекса,если кардинальность составляет менее 30% от числа записей,что фактически превращает индекс в пустую трату места.</target>
        </trans-unit>
        <trans-unit id="e9732b1f53d3a2736ee890d12a683c1fc0c8f2cf" translate="yes" xml:space="preserve">
          <source>Since then I gained some insight about the downside of creating indexes:
if you write into a table (&lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt;) with one index, you have actually two writing operations in the file system. One for the table data and another one for the index data (and the resorting of it (and - if clustered - the resorting of the table data)). If table and index are located on the same hard disk this costs more time. Thus a table without an index (a heap) , would allow for quicker write operations. (if you had two indexes you would end up with three write operations, and so on)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;С тех пор я получил некоторое представление о недостатках создания индексов: если вы записываете в таблицу ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;UPDATE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или &lt;/font&gt;&lt;/font&gt; &lt;code&gt;INSERT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) с одним индексом, у вас фактически есть две операции записи в файловой системе. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Один для данных таблицы и другой для данных индекса (и их применение (и - если кластеризовано - обращение к данным таблицы)). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если таблица и индекс находятся на одном жестком диске, это стоит больше времени. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, таблица без индекса (кучи) позволит быстрее выполнять операции записи. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(если бы у вас было два индекса, вы бы получили три операции записи и т. д.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="adecf93f2acfab3a69649212fe2efb7426f23e48" translate="yes" xml:space="preserve">
          <source>So now the database will use the index to find employees named John
  because the index will presumably be sorted alphabetically by the
  Users name. And, because it is sorted, it means searching for a name
  is a lot faster because all names starting with a &amp;ldquo;J&amp;rdquo; will be right
  next to each other in the index!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Так что теперь база данных будет использовать индекс для поиска сотрудников по имени Джон, потому что индекс, вероятно, будет отсортирован в алфавитном порядке по имени пользователя. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И, поскольку оно отсортировано, это означает, что поиск имени выполняется намного быстрее, потому что все имена, начинающиеся с буквы &amp;laquo;J&amp;raquo;, будут находиться рядом друг с другом в индексе!&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="26471d745a61045c6728ede7f132a76a50811d84" translate="yes" xml:space="preserve">
          <source>The database software would literally have to look at every single row in the &lt;code&gt;User&lt;/code&gt; table to see if the &lt;code&gt;Name&lt;/code&gt; for that row is &amp;lsquo;John&amp;rsquo;. This will take a long time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Программному обеспечению базы данных в буквальном смысле пришлось бы просматривать каждую строку в &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;таблице &lt;/font&gt;&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; ,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; чтобы узнать, является ли &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; этой строки &amp;laquo;John&amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это займет много времени.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92388142fd95760bd53d3617559908024063026c" translate="yes" xml:space="preserve">
          <source>The downside to indexing is that these indices require additional space on the disk since the indices are stored together in a table using the MyISAM engine, this file can quickly reach the size limits of the underlying file system if many fields within the same table are indexed.</source>
          <target state="translated">Недостатком индексирования является то,что эти индексы требуют дополнительного места на диске,так как индексы хранятся вместе в таблице с помощью движка MyISAM,этот файл может быстро достичь границ размера базовой файловой системы,если индексируется много полей в одной и той же таблице.</target>
        </trans-unit>
        <trans-unit id="7d8c6667f49892d4041edae513099ceacb903c2e" translate="yes" xml:space="preserve">
          <source>The first time I read this it was very helpful to me. Thank you.</source>
          <target state="translated">В первый раз,когда я прочитал это,это было очень полезно для меня.Спасибо.</target>
        </trans-unit>
        <trans-unit id="6ab7299d1206cde9db1d5f739db12c3075d44567" translate="yes" xml:space="preserve">
          <source>The index is nothing but a data structure that &lt;strong&gt;stores the values for a specific column&lt;/strong&gt; in a table. An index is created on a column of a table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Индекс - это не что иное, как структура данных, в которой &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;хранятся значения для определенного столбца&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в таблице. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Индекс создается по столбцу таблицы.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="126caeb9af8c72c10dc8b6168e0b5dd59a87df45" translate="yes" xml:space="preserve">
          <source>The reason B- trees are the most popular data structure for indexes is due to the fact that they are time efficient &amp;ndash; because look-ups, deletions, and insertions can all be done in logarithmic time. And, another major reason B- trees are more commonly used is because the data that is stored inside the B- tree can be sorted. The RDBMS typically determines which data structure is actually used for an index. But, in some scenarios with certain RDBMS&amp;rsquo;s, you can actually specify which data structure you want your database to use when you create the index itself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Причина, по которой B-деревья являются самой популярной структурой данных для индексов, заключается в том, что они эффективны по времени, поскольку поиск, удаление и вставка могут выполняться в логарифмическом времени. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;И еще одна важная причина, по которой B-деревья чаще используются, заключается в том, что данные, хранящиеся в B-деревьях, могут быть отсортированы. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;СУБД обычно определяет, какая структура данных фактически используется для индекса. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Но в некоторых сценариях с определенными СУБД вы можете фактически указать, какую структуру данных вы хотите использовать в своей базе данных при создании самого индекса.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef4d79676e50d3782a878b91406b5f00f4a58cd0" translate="yes" xml:space="preserve">
          <source>The reason hash indexes are used is because hash tables are extremely efficient when it comes to just looking up values. So, queries that compare for equality to a string can retrieve values very fast if they use a hash index.</source>
          <target state="translated">Причина использования хэш-индексов заключается в том,что хэш-таблицы чрезвычайно эффективны,когда дело доходит до простого поиска значений.Таким образом,запросы,которые сравнивают равенство со строкой,могут получить значения очень быстро,если они используют хэш-индекс.</target>
        </trans-unit>
        <trans-unit id="257d302baeb4a014b97399cca558bbb83e525e5d" translate="yes" xml:space="preserve">
          <source>The whole point of having an index is to speed up search queries by essentially cutting down the number of records/rows in a table that need to be examined. An index is a data structure (most commonly a B- tree) that stores the values for a specific column in a table.</source>
          <target state="translated">Весь смысл наличия индекса заключается в том,чтобы ускорить поисковые запросы,существенно сокращая количество строк записей в таблице,которые необходимо исследовать.Индекс-это структура данных (чаще всего B-дерево),в котором хранятся значения для конкретного столбца таблицы.</target>
        </trans-unit>
        <trans-unit id="a4f5d021fd61272cfc727ba4d28ac004f08424f2" translate="yes" xml:space="preserve">
          <source>Things are simple in schools, isn't it? :P</source>
          <target state="translated">В школах все просто,не так ли? :П.</target>
        </trans-unit>
        <trans-unit id="7503b65320d9c1b258a3d69a2f77ffa5cb85b3fa" translate="yes" xml:space="preserve">
          <source>This analogy is known as &lt;strong&gt;&quot;Full Table Scan&quot;&lt;/strong&gt; in database world.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Эта аналогия известна как &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;laquo;полное сканирование таблицы&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в мире баз данных.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="814e34b9dbc0414d8df43d75cfeebb5d902126ee" translate="yes" xml:space="preserve">
          <source>This is where &lt;code&gt;index&lt;/code&gt; helps us: &lt;em&gt;index is used to speed up search queries by essentially cutting down the number of records/rows in a table that needs to be examined&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вот где &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;нам помогает &lt;/font&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;индекс используется для ускорения поисковых запросов, существенно сокращая количество записей / строк в таблице, которые необходимо изучить&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eae407d68bea00f32c03361bd34649b638b74dd0" translate="yes" xml:space="preserve">
          <source>Thus, the index is a separate section that stores values of indexed
  column + pointer to the indexed row in a sorted order for efficient
  look-ups.</source>
          <target state="translated">Таким образом,индекс представляет собой отдельный раздел,в котором хранятся значения проиндексированного столбца+указатель на проиндексированную строку в отсортированном порядке для эффективного поиска.</target>
        </trans-unit>
        <trans-unit id="3388f2a0255a47ceeb6050962fbb9511180c8d29" translate="yes" xml:space="preserve">
          <source>What columns generally make good indexes?</source>
          <target state="translated">Какие столбцы обычно составляют хорошие показатели?</target>
        </trans-unit>
        <trans-unit id="e6f1df688c30d94eb68a3bb0fa23154aa1e18bc3" translate="yes" xml:space="preserve">
          <source>When data is stored on disk-based storage devices, it is stored as blocks of data. These blocks are accessed in their entirety, making them the atomic disk access operation. Disk blocks are structured in much the same way as linked lists; both contain a section for data, a pointer to the location of the next node (or block), and both need not be stored contiguously.</source>
          <target state="translated">Когда данные хранятся на дисковых запоминающих устройствах,они хранятся в виде блоков данных.Доступ к этим блокам осуществляется в полном объеме,что делает их операциями атомарного доступа к диску.Дисковые блоки структурированы так же,как и связанные списки;оба содержат раздел для данных,указатель на местоположение следующего узла (или блока),и оба они не должны храниться неразрывно.</target>
        </trans-unit>
        <trans-unit id="93a2555206a0af83fbe551a83137431c161ed8c6" translate="yes" xml:space="preserve">
          <source>Whereas with a sorted field, a Binary Search may be used, which has &lt;code&gt;log2 N&lt;/code&gt; block accesses. Also since the data is sorted given a non-key field, the rest of the table doesn&amp;rsquo;t need to be searched for duplicate values, once a higher value is found. Thus the performance increase is substantial.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Принимая во внимание, что с отсортированным полем можно использовать двоичный поиск, который имеет &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 N&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; блочных обращений. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Кроме того, поскольку данные сортируются по неключевому полю, в остальной части таблицы не нужно искать дубликаты значений, как только будет найдено более высокое значение. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Таким образом, увеличение производительности является существенным.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b533efcb68c06cbb661f675f72076a2242fa3ed" translate="yes" xml:space="preserve">
          <source>e.g:- If you have lots of rivalling writes but only one nightly read outside business hours for reporting.</source>
          <target state="translated">Например:-Если у вас есть множество конкурирующих записей,но вы читаете только одну ночь в нерабочее время,чтобы сделать репортаж.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
