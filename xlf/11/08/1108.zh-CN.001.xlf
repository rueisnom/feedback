<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1108">
    <body>
      <group id="1108">
        <trans-unit id="7c6f976f4e1f247357643420b0f1d5edff13eef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Example 1&lt;/em&gt;&lt;/strong&gt; - &lt;em&gt;sorted vs unsorted fields&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实施例1&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;排序VS未排序的字段&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad6ea987ddb5784c13bde986d9834b1b8aa7cc8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Example 2&lt;/em&gt;&lt;/strong&gt;  - &lt;em&gt;indexing&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实施例2&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;索引&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c263d6e1ec3808a54cf13984a9ccf2fe20c030b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How a database index can help performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数据库索引如何帮助提高性能&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ee6c6ffc954bb7d8e7f64c641b17ff3a602b455" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does B-trees index work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B树索引如何工作？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1038135901ca45cbc26e89cf4438b522835561bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does a database know when to use an index?&lt;/strong&gt;
When a query like &amp;ldquo;SELECT * FROM Employee WHERE Employee_Name = &amp;lsquo;Abc&amp;rsquo; &amp;rdquo; is run, the database will check to see if there is an index on the column(s) being queried. Assuming the Employee_Name column does have an index created on it, the database will have to decide whether it actually makes sense to use the index to find the values being searched &amp;ndash; because there are some scenarios where it is actually less efficient to use the database index, and more efficient just to scan the entire table.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数据库如何知道何时使用索引？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 当运行&amp;ldquo; SELECT * FROM Employee WHERE Employee_Name ='Abc'&amp;rdquo;之类的查询时，数据库将检查要查询的列上是否有索引。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设Employee_Name列上确实创建了索引，数据库将必须决定使用索引来查找正在搜索的值是否真正有意义&amp;ndash;因为在某些情况下使用数据库索引的效率实际上较低，并且仅扫描整个表的效率更高。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff64d04a079079f647ecb61630eba86649659ead" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does a hash table index work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;哈希表索引如何工作？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c1ec9f40f4edd7eb75f8f619aa77433ee58d89b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does it work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它是如何工作的？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7776d2a490f8e3aaac3f9ca4505cab9d20b38b23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Pointers in MySQL are 2, 3, 4 or 5 bytes in length depending on the size of the table.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：MySQL中的指针长度为2、3、4或5个字节，具体取决于表的大小。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d1f023e6a4d3bc1e8bf916bde9bbdd1bedb1d70d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: char was used in place of varchar to allow for an accurate size on disk value. 
This sample database contains five million rows and is unindexed. The performance of several queries will now be analyzed. These are a query using the &lt;em&gt;id&lt;/em&gt; (a sorted key field) and one using the &lt;em&gt;firstName&lt;/em&gt; (a non-key unsorted field).</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注意&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：使用char代替varchar可以保证磁盘值的准确大小。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该示例数据库包含五百万行，并且没有索引。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在将分析几个查询的性能。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这些是使用&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;id&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（排序的键字段）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的查询，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以及使用&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（非键的未排序字段）的查询。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e55a4eef1abc15fd25c68f22657b346ff3abdb11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Description!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;简单说明！&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f4ae4a04e94c61d13e11443fa35cbf4c8957624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The disadvantages of a hash index&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;哈希索引的缺点&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d60b2311316bf1641d865996eaab467baf68c7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What exactly is inside a database index?&lt;/strong&gt;
So, now you know that a database index is created on a column in a table, and that the index stores the values in that specific column. But, it is important to understand that a database index does not store the values in the other columns of the same table. For example, if we create an index on the Employee_Name column, this means that the Employee_Age and Employee_Address column values are not also stored in the index. If we did just store all the other columns in the index, then it would be just like creating another copy of the entire table &amp;ndash; which would take up way too much space and would be very inefficient.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数据库索引内部到底是什么？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 因此，现在您知道在表的列上创建了数据库索引，并且该索引将值存储在该特定列中。但是，重要的是要了解数据库索引不会将值存储在同一表的其他列中。例如，如果我们在Employee_Name列上创建索引，这意味着Employee_Age和Employee_Address列值也未存储在索引中。如果我们只是将所有其他列都存储在索引中，则就像创建整个表的另一个副本一样，这将占用太多空间并且效率非常低下。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6428ecc202198be70cb1f1755663fa9831bc29a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is indexing?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;什么是索引？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="66754d988f4fcb1acc4a50297f2aadea10736289" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is the cost of having a database index?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数据库索引的成本是多少？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e16a9f89c5c9cad39f49b095ddeef61be6287223" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What would happen without an index?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有索引会发生什么？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba497667b700161a0513bd86c14414feabb5a6a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should it be used?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;什么时候应该使用？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c650694413b8d8c8e0547a99830e7752b6f6fb74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why is it needed?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为什么需要它？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fadfcc0b3b5611c6320a2347916ace1ab3378c3e" translate="yes" xml:space="preserve">
          <source>A linear search on the id field would require an average of &lt;code&gt;N/2 = 500,000&lt;/code&gt; block accesses to find a value, given that the id field is a key field. But since the id field is also sorted, a binary search can be conducted requiring an average of &lt;code&gt;log2 1000000 = 19.93 = 20&lt;/code&gt; block accesses. Instantly we can see this is a drastic improvement.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假设id字段是键字段，则对id字段进行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;线性搜索平均需要&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N/2 = 500,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;块访问才能找到一个值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是由于id字段也已排序，因此可以执行二进制搜索，平均需要&lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 1000000 = 19.93 = 20&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;块访问。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;立刻我们可以看到这是一个巨大的进步。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="71f1a10902b7a8ccbae4cdba11a0b434fe2b432e" translate="yes" xml:space="preserve">
          <source>Also, a differentiation between clustered and non-clustered indexes is rather important.</source>
          <target state="translated">另外,区分聚类指数和非聚类指数相当重要。</target>
        </trans-unit>
        <trans-unit id="f959491d8665d67cf85a2cc9b96a16ed6e7c0149" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;index&lt;/code&gt; consists of &lt;strong&gt;column values(Eg: John) from one table&lt;/strong&gt;, and those values are stored in a &lt;strong&gt;data structure&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;列值（例如：约翰）从一个表&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，这些值被存储在一个&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数据结构中&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ad74fb25accebf8d6e8d23b44a80acc6acebc0d" translate="yes" xml:space="preserve">
          <source>An index is just a data structure that makes the searching faster for a specific column in a database. This structure is usually a b-tree or a hash table but it can be any other logic structure.</source>
          <target state="translated">索引只是一种数据结构,它可以使数据库中的特定列的搜索速度更快。这种结构通常是B-树或哈希表,但也可以是其他任何逻辑结构。</target>
        </trans-unit>
        <trans-unit id="ae0587c6babe222342305dc974d0c1ee2fec283f" translate="yes" xml:space="preserve">
          <source>Another option is that, you could just go to the Index section of the book and then find what you are looking for by using the Name of the entity you are looking ( in this instance, German Shepherds) and also looking at the page number to quickly find what you are looking for.</source>
          <target state="translated">另一个选择是,你可以直接到书的索引部分,然后通过使用你要找的实体名称(在这个例子中,德国牧羊人),也可以看页码来快速找到你要找的东西。</target>
        </trans-unit>
        <trans-unit id="a42223342f004e5087636b0bd93ed01b59e5befd" translate="yes" xml:space="preserve">
          <source>Another problem with indexes is their fragmentation over time as data is inserted. &lt;code&gt;REORGANIZE&lt;/code&gt; helps, you must write routines to have it done.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;索引的另一个问题是随着数据的插入它们随着时间的推移会碎片化。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;REORGANIZE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;帮助，您必须编写例程来完成它。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="670ae6c441f98e2a78f5820d589187b5910ea31c" translate="yes" xml:space="preserve">
          <source>As a general rule, an index should only be created on a table if the data in the indexed column will be queried frequently.</source>
          <target state="translated">一般来说,只有在索引列中的数据会被频繁查询时,才应该在表上创建索引。</target>
        </trans-unit>
        <trans-unit id="06a4b006b5c2d9087ce316cf7000e63a79bca581" translate="yes" xml:space="preserve">
          <source>But then, in addition to actual 1000 pages, you will need another ~10 pages to show the indices, so totally 1010 pages.</source>
          <target state="translated">但这样一来,除了实际的1000页外,你还需要另外~10页来显示索引,所以完全是1010页。</target>
        </trans-unit>
        <trans-unit id="3d71c21621662c8be4c6dce7fd281e97dfd2c30e" translate="yes" xml:space="preserve">
          <source>But with an index page, you know where to go! And more, to lookup any particular Chapter that matters, you just need to look over the index page, again and again, every time. After finding the matching index you can efficiently jump to that chapter by skipping the rest.</source>
          <target state="translated">但有了索引页,你就知道该去哪里了! 更重要的是,要查找任何一个特定的章节,你只需要在索引页上一遍又一遍地翻阅,每次都是如此。找到匹配的索引后,你可以有效地跳过其他章节跳到该章节。</target>
        </trans-unit>
        <trans-unit id="a2aeece8a7e18f9f6165280d858250ef5c41a36b" translate="yes" xml:space="preserve">
          <source>Classic example &lt;strong&gt;&quot;Index in Books&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;经典示例&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;书籍索引&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edfadc138c324a28c0ad48b4568b1c93f50ae608" translate="yes" xml:space="preserve">
          <source>Consider a &quot;Book&quot; of 1000 pages, divided by 10 Chapters, each section with 100 pages.</source>
          <target state="translated">想想看一本1000页的 &quot;书&quot;,分10章,每节100页。</target>
        </trans-unit>
        <trans-unit id="ccace75fa9dc2dfab316381c595f1cee029a29da" translate="yes" xml:space="preserve">
          <source>Database software would literally have to look at every single row in the Employee table to see if the Employee_Name for that row is &amp;lsquo;Abc&amp;rsquo;. And, because we want every row with the name &amp;lsquo;Abc&amp;rsquo; inside it, we can not just stop looking once we find just one row with the name &amp;lsquo;Abc&amp;rsquo;, because there could be other rows with the name &lt;strong&gt;Abc&lt;/strong&gt;. So, every row up until the last row must be searched &amp;ndash; which means thousands of rows in this scenario will have to be examined by the database to find the rows with the name &amp;lsquo;Abc&amp;rsquo;. This is what is called a &lt;strong&gt;full table scan&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数据库软件实际上必须查看Employee表中的每一行，以查看该行的Employee_Name是否为'Abc'。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而且，因为我们希望每行中都包含名称为'Abc'，所以一旦找到仅一个名称为'Abc'的行，我们就不能停止寻找，因为可能会有其他名称为&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Abc的&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，必须搜索直到最后一行的每一行&amp;ndash;这意味着在这种情况下，数据库必须检查数千行才能找到名称为&amp;ldquo; Abc&amp;rdquo;的行。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这就是所谓的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;全表扫描&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ceb478c45cb9fe55a55150694c3e2f7c5bd8f32f" translate="yes" xml:space="preserve">
          <source>Due to the fact that a number of records can only be sorted on one field, we can state that searching on a field that isn&amp;rsquo;t sorted requires a Linear Search which requires &lt;code&gt;N/2&lt;/code&gt; block accesses (on average), where &lt;code&gt;N&lt;/code&gt; is the number of blocks that the table spans. If that field is a non-key field (i.e. doesn&amp;rsquo;t contain unique entries) then the entire tablespace must be searched at &lt;code&gt;N&lt;/code&gt; block accesses.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于许多记录只能在一个字段上排序，因此我们可以说，在未排序的字段上进行搜索需要进行线性搜索，该搜索需要进行&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N/2&lt;/code&gt; 个&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;块访问（平均），其中&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是该表跨越的块数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果该字段是非关键字段（即不包含唯一条目），则必须在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N&lt;/code&gt; 次&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;块访问中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;搜索整个表空间&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e5bc6d47e649819c256f1169901b6aa5852d68ce" translate="yes" xml:space="preserve">
          <source>Example: We have a database table called &lt;code&gt;User&lt;/code&gt; with three columns &amp;ndash; &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Address&lt;/code&gt;. Assume that the &lt;code&gt;User&lt;/code&gt; table has thousands of rows.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;示例：我们有一个名为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的数据库表，该表&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;具有三列&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Address&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假定&lt;/font&gt;&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表具有数千行。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6dfb64751c4bd0fadd0aadce8f3a9bec1f87f196" translate="yes" xml:space="preserve">
          <source>Firstly, let&amp;rsquo;s outline a sample database table schema;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;首先，让我们概述一个示例数据库表架构；&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67a6b5de80a5587dd3df63bd3b5cd82d3ef329d8" translate="yes" xml:space="preserve">
          <source>For information on queries to index a field, check out &lt;a href=&quot;https://stackoverflow.com/questions/1156/&quot;&gt;How do I index a database column&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关查询索引字段的信息，请查看&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1156/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如何索引数据库列&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a56b08d796085fa51779969ead12eba0cdf923dc" translate="yes" xml:space="preserve">
          <source>For instance, the query we discussed earlier could benefit from a hash index created on the Employee_Name column. The way a hash index would work is that the column value will be the key into the hash table and the actual value mapped to that key would just be a pointer to the row data in the table. Since a hash table is basically an associative array, a typical entry would look something like &amp;ldquo;Abc =&amp;gt; 0x28939&amp;Prime;, where 0x28939 is a reference to the table row where Abc is stored in memory. Looking up a value like &amp;ldquo;Abc&amp;rdquo; in a hash table index and getting back a reference to the row in memory is obviously a lot faster than scanning the table to find all the rows with a value of &amp;ldquo;Abc&amp;rdquo; in the Employee_Name column.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，我们前面讨论的查询可以从Employee_Name列上创建的哈希索引中受益。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;哈希索引的工作方式是，列值将成为哈希表中的键，而映射到该键的实际值将仅是指向表中行数据的指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由于哈希表基本上是一个关联数组，因此典型的条目看起来类似于&amp;ldquo; Abc =&amp;gt; 0x28939&amp;rdquo;，其中0x28939是对表行的引用，该行存储有Abc。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在哈希表索引中查找类似于&amp;ldquo; Abc&amp;rdquo;的值并返回对内存中行的引用显然比扫描表在Employee_Name列中查找所有值为&amp;ldquo; Abc&amp;rdquo;的行要快得多。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ba744e72c82249823f810b1d800ca0c81ff406e9" translate="yes" xml:space="preserve">
          <source>Given our sample database of &lt;code&gt;r = 5,000,000&lt;/code&gt; records of a fixed size giving a record length of &lt;code&gt;R = 204&lt;/code&gt; bytes and they are stored in a table using the MyISAM engine which is using the default block size &lt;code&gt;B = 1,024&lt;/code&gt; bytes. The blocking factor of the table would be &lt;code&gt;bfr = (B/R) = 1024/204 = 5&lt;/code&gt; records per disk block. The total number of blocks required to hold the table is &lt;code&gt;N = (r/bfr) = 5000000/5 = 1,000,000&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给定我们的样本数据库&lt;/font&gt;&lt;/font&gt; &lt;code&gt;r = 5,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;个固定大小的记录，记录长度为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;R = 204&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字节，并且使用MyISAM引擎将它们存储在表中，该引擎使用默认的块大小&lt;/font&gt;&lt;/font&gt; &lt;code&gt;B = 1,024&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字节。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该表的阻塞因子为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;bfr = (B/R) = 1024/204 = 5&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每个磁盘块&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;5&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;条记录。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;保存该表所需的块总数为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N = (r/bfr) = 5000000/5 = 1,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;个块。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a612a719bfeff12051ef62ec18b988c42d957b8" translate="yes" xml:space="preserve">
          <source>Given our sample database of &lt;code&gt;r = 5,000,000&lt;/code&gt; records with an index record length of &lt;code&gt;R = 54&lt;/code&gt; bytes and using the default block size &lt;code&gt;B = 1,024&lt;/code&gt; bytes. The blocking factor of the index would be &lt;code&gt;bfr = (B/R) = 1024/54 = 18&lt;/code&gt; records per disk block. The total number of blocks required to hold the index is &lt;code&gt;N = (r/bfr) = 5000000/18 = 277,778&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;给定我们的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;r = 5,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;条记录的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;示例数据库，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;索引记录长度为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;R = 54&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字节，并使用默认块大小&lt;/font&gt;&lt;/font&gt; &lt;code&gt;B = 1,024&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字节。索引的阻塞因子为&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;每个磁盘块&lt;/font&gt;&lt;/font&gt; &lt;code&gt;bfr = (B/R) = 1024/54 = 18&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;条记录。保持索引所需的块总数为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N = (r/bfr) = 5000000/18 = 277,778&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;个块。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67d7d36ed55f5b6ce5bb067162a83dc511e7fd79" translate="yes" xml:space="preserve">
          <source>Given that an index record contains only the indexed field and a pointer to the original record, it stands to reason that it will be smaller than the multi-field record that it points to. So the index itself requires fewer disk blocks than the original table, which therefore requires fewer block accesses to iterate through. The schema for an index on the &lt;em&gt;firstName&lt;/em&gt; field is outlined below;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;假定索引记录仅包含索引字段和指向原始记录的指针，则可以认为它会小于它指向的多字段记录。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，索引本身比原始表需要更少的磁盘块，因此需要更少的块访问来进行迭代。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;下面概述&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;了&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字段&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上的索引的架构&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;；&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b8a40897243ff8b8b9b81a535752ccc504133a4" translate="yes" xml:space="preserve">
          <source>Given that creating an index requires additional disk space (277,778 blocks extra from the above example, a ~28% increase), and that too many indices can cause issues arising from the file systems size limits, careful thought must be used to select the correct fields to index.</source>
          <target state="translated">考虑到创建一个索引需要额外的磁盘空间(比上面的例子多了277,778个块,增加了约28%),而且过多的索引可能会引起文件系统大小限制的问题,因此必须仔细考虑,选择正确的字段来做索引。</target>
        </trans-unit>
        <trans-unit id="6560699d2bd8f61f1f9e9e79eda860b41d744347" translate="yes" xml:space="preserve">
          <source>Given that indexing is so important as your data set increases in size, can someone explain how indexing works at a database-agnostic level?</source>
          <target state="translated">考虑到随着数据集规模的增加,索引编制是如此重要,有人能解释一下索引编制是如何在数据库无关的层面上工作的吗?</target>
        </trans-unit>
        <trans-unit id="32a8bd6432ae70cef621c292e079e404b892ba3b" translate="yes" xml:space="preserve">
          <source>Hash tables are not sorted data structures, and there are many types of queries which hash indexes can not even help with. For instance, suppose you want to find out all of the employees who are less than 40 years old. How could you do that with a hash table index? Well, it&amp;rsquo;s not possible because a hash table is only good for looking up key value pairs &amp;ndash; which means queries that check for equality</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;哈希表不是经过排序的数据结构，并且有许多类型的查询甚至无法提供哈希索引。例如，假设您想找出所有不到40岁的员工。您如何使用哈希表索引来做到这一点？好吧，这是不可能的，因为哈希表仅适合于查找键值对-这意味着查询将检查是否相等&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d21860c9c34e97854024389404de25905618ed2" translate="yes" xml:space="preserve">
          <source>Helped me:- &lt;a href=&quot;https://stackoverflow.com/questions/1251636/what-do-clustered-and-non-clustered-index-actually-mean&quot;&gt;What do Clustered and Non clustered index actually mean?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;帮助了我：- &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1251636/what-do-clustered-and-non-clustered-index-actually-mean&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;聚集索引和非聚集索引的实际含义是什么？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3cca3a8a00a3a45f0a5c76f372683f44b7b1881" translate="yes" xml:space="preserve">
          <source>How do database indexes work</source>
          <target state="translated">数据库索引是如何工作的</target>
        </trans-unit>
        <trans-unit id="5452e26c95523ae9f9b07a1f3bae3db9dbe68101" translate="yes" xml:space="preserve">
          <source>How does database indexing work</source>
          <target state="translated">数据库索引是如何工作的</target>
        </trans-unit>
        <trans-unit id="7df16cfacc6d28d0dec6ecd7f0a8c16905729906" translate="yes" xml:space="preserve">
          <source>How to create an index:</source>
          <target state="translated">如何建立一个索引。</target>
        </trans-unit>
        <trans-unit id="e9a156ac7af5ee1f8d9b1e3dfc529d5d31e2a992" translate="yes" xml:space="preserve">
          <source>However, defining two different locations on two different hard disks for index data and table data can decrease/eliminate the problem of increased cost of time. This requires definition of additional file groups with according files on the desired hard disks and definition of table/index location as desired.</source>
          <target state="translated">但是,在两个不同的硬盘上定义两个不同位置的索引数据和表数据,可以减少时间成本增加的问题。这需要在所需的硬盘上定义额外的文件组,并根据需要定义表索引的位置。</target>
        </trans-unit>
        <trans-unit id="ef380204ad169fc2292c6fa188d9c6d356f78f84" translate="yes" xml:space="preserve">
          <source>If you have a book about dogs and you want to find an information about let's say, German Shepherds, you could of course flip through all the pages of the book and find what you are looking for  - but this of course is time consuming and not very fast.</source>
          <target state="translated">如果你有一本关于狗的书,你想找一个关于德国牧羊犬的信息,比方说,你当然可以翻开书的所有页面,找到你要找的东西--但这当然是很费时间的,而且速度也不是很快。</target>
        </trans-unit>
        <trans-unit id="d8f04bd94bd160a1d96d45d2529a31258e82a393" translate="yes" xml:space="preserve">
          <source>In Database, the page number is referred to as a pointer which directs the database to the address on the disk where entity is located. Using the same German Shepherd analogy, we could have something like this (&amp;ldquo;German Shepherd&amp;rdquo;, 0x77129) where &lt;code&gt;0x77129&lt;/code&gt; is the address on the disk where the row data for German Shepherd is stored.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在数据库中，页码称为将数据库定向到实体所在磁盘上的地址的指针。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用相同的德国牧羊犬类比，我们可能会有类似的内容（&amp;ldquo;德国牧羊犬&amp;rdquo;，0x77129），其中&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0x77129&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是磁盘上存储德国牧羊犬行数据的地址。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ef1c79649a1ffa63f8f1acd27875a9fcc448b06" translate="yes" xml:space="preserve">
          <source>In certain scenarios a heap is more helpful than a table with indexes,</source>
          <target state="translated">在某些情况下,一个堆比一个带索引的表更有帮助。</target>
        </trans-unit>
        <trans-unit id="c571b07f97ec082a06642bacb56f5d9267f7fdae" translate="yes" xml:space="preserve">
          <source>In short, an index is a data structure that stores the values for a specific column in a table so as to speed up query search.</source>
          <target state="translated">简而言之,索引是一种数据结构,在表中存储特定列的值,以加快查询速度。</target>
        </trans-unit>
        <trans-unit id="8e8e8ce6c1f5d8d1d05614c2f29659055232953f" translate="yes" xml:space="preserve">
          <source>Indexing is a way of sorting a number of records on multiple fields. Creating an index on a field in a table creates another data structure which holds the field value, and a pointer to the record it relates to. This index structure is then sorted, allowing Binary Searches to be performed on it.</source>
          <target state="translated">索引是对多个字段上的若干记录进行排序的一种方法。在表中的一个字段上创建一个索引会创建另一个数据结构,该结构保存着该字段的值,以及一个指向其相关记录的指针。然后对这个索引结构进行排序,允许对其进行二进制搜索。</target>
        </trans-unit>
        <trans-unit id="a611240736d03bf16b06eb89c51008f6b823f25d" translate="yes" xml:space="preserve">
          <source>It takes up space &amp;ndash; and the larger your table, the larger your index. Another performance hit with indexes is the fact that whenever you add, delete, or update rows in the corresponding table, the same operations will have to be done to your index. Remember that an index needs to contain the same up to the minute data as whatever is in the table column(s) that the index covers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它占用空间&amp;ndash;表越大，索引越大。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;索引的另一个性能问题是，无论何时在相应表中添加，删除或更新行，都必须对索引执行相同的操作。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;请记住，索引需要包含与该索引涵盖的表列中相同的最新数据。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="276b5a9e7eafc9116c94af7c4302e336bba600a7" translate="yes" xml:space="preserve">
          <source>Just a quick suggestion.. As indexing costs you additional writes and storage space, so if your application requires more insert/update operation, you might want to use tables without indexes, but if it requires more data retrieval operations, you should go for indexed table.</source>
          <target state="translated">只是一个快速的建议.....由于索引化需要花费额外的写入和存储空间,所以如果你的应用程序需要更多的insertupdate操作,你可能会想使用没有索引的表,但如果需要更多的数据检索操作,你应该选择有索引的表。</target>
        </trans-unit>
        <trans-unit id="79473d1d1fae832de50165b98ed9730e2335bcff" translate="yes" xml:space="preserve">
          <source>Just think of Database Index as Index of a book.</source>
          <target state="translated">就把数据库索引看成是一本书的索引。</target>
        </trans-unit>
        <trans-unit id="9e6820fb508cdfb4143176447ba4ee4022ec87ef" translate="yes" xml:space="preserve">
          <source>Now a search using the &lt;em&gt;firstName&lt;/em&gt; field can utilize the index to increase performance. This allows for a binary search of the index with an average of &lt;code&gt;log2 277778 = 18.08 = 19&lt;/code&gt; block accesses. To find the address of the actual record, which requires a further block access to read, bringing the total to &lt;code&gt;19 + 1 = 20&lt;/code&gt; block accesses, a far cry from the 1,000,000 block accesses required to find a &lt;em&gt;firstName&lt;/em&gt; match in the non-indexed table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，使用&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字段&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;进行的搜索&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以利用索引来提高性能。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这允许对索引进行二进制搜索，平均记录为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 277778 = 18.08 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;块访问。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要查找实际记录的地址，这需要进一步的块访问来读取，从而使总数达到&lt;/font&gt;&lt;/font&gt; &lt;code&gt;19 + 1 = 20&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;块访问，这&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与在非索引表中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;查找&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;匹配&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所需的1,000,000个块访问相差甚远。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a62e94584fca0d632abdef6d650cf49c229bbe33" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;firstName&lt;/em&gt; field is neither sorted nor a key field, so a binary search is impossible, nor are the values unique, and thus the table will require searching to the end for an exact &lt;code&gt;N = 1,000,000&lt;/code&gt; block accesses. It is this situation that indexing aims to correct.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;字段既没有排序，也没有关键字字段，因此二进制搜索是不可能的，值也不是唯一的，因此该表将需要在末尾搜索精确的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N = 1,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;块访问。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;索引旨在纠正这种情况。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50cbc01eb392ec54b5d1caa08a59f11a5eb7f3b1" translate="yes" xml:space="preserve">
          <source>Now, imagine you want to find a particular Chapter that contains a word &quot;&lt;strong&gt;Alchemist&lt;/strong&gt;&quot;. Without an index page, you have no other option than scanning through the entire book/Chapters. i.e: 1000 pages.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，假设您要查找包含单词&amp;ldquo; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Alchemist&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &amp;rdquo; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的特定章节&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有索引页，除了浏览整本书/章节之外，您别无选择。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;即：1000页。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="777cb84ce5a934c14c04fb32c3c230b0028ab12b" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say that we want to run a query to find all the details of any employees who are named &amp;lsquo;Abc&amp;rsquo;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，假设我们要运行一个查询以查找名为&amp;ldquo; Abc&amp;rdquo;的所有员工的所有详细信息？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cb63ab6c0db77bef9b2c256e11bc06a79e6c6bd" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say that we want to run a query to find all the details of any users who are named 'John'. 
If we run the following query:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在，假设我们要运行一个查询来查找名为&amp;ldquo; John&amp;rdquo;的所有用户的所有详细信息。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果我们运行以下查询：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">另见</target>
        </trans-unit>
        <trans-unit id="1d5c52ff7943b48eda6b1cf65c290aa09e17f098" translate="yes" xml:space="preserve">
          <source>Simple, huh?</source>
          <target state="translated">很简单,嗯?</target>
        </trans-unit>
        <trans-unit id="c573cfffeb370eb01525896bbc026605b0d66f5c" translate="yes" xml:space="preserve">
          <source>Since indices are only used to speed up the searching for a matching field within the records, it stands to reason that indexing fields used only for output would be simply a waste of disk space and processing time when doing an insert or delete operation, and thus should be avoided. Also given the nature of a binary search, the cardinality or uniqueness of the data is important. Indexing on a field with a cardinality of 2 would split the data in half, whereas a cardinality of 1,000 would return approximately 1,000 records. With such a low cardinality the effectiveness is reduced to a linear sort, and the query optimizer will avoid using the index if the cardinality is less than 30% of the record number, effectively making the index a waste of space.</source>
          <target state="translated">由于索引仅用于加快记录中匹配字段的搜索速度,因此,在进行插入或删除操作时,对仅用于输出的字段进行索引,只会浪费磁盘空间和处理时间,因此应该避免。另外,鉴于二进制搜索的性质,数据的cardinality或唯一性也很重要。在一个字段上做索引,其万有引力为2的字段会把数据分成两半,而万有引力为1,000的字段会返回大约1,000条记录。在这样低的卡片率的情况下,效率会降低到线性排序,如果卡片率低于记录数的30%,查询优化器就会避免使用索引,实际上是在浪费空间。</target>
        </trans-unit>
        <trans-unit id="e9732b1f53d3a2736ee890d12a683c1fc0c8f2cf" translate="yes" xml:space="preserve">
          <source>Since then I gained some insight about the downside of creating indexes:
if you write into a table (&lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt;) with one index, you have actually two writing operations in the file system. One for the table data and another one for the index data (and the resorting of it (and - if clustered - the resorting of the table data)). If table and index are located on the same hard disk this costs more time. Thus a table without an index (a heap) , would allow for quicker write operations. (if you had two indexes you would end up with three write operations, and so on)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从那以后，我获得了有关创建索引的缺点的一些见解：如果&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用一个索引&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;写入表（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;UPDATE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或&lt;/font&gt;&lt;/font&gt; &lt;code&gt;INSERT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;），则文件系统中实际上有两次写入操作。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一个用于表数据，另一个用于索引数据（以及对它的替换（如果是群集的话，对表数据的替换））。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果表和索引位于同一硬盘上，则将花费更多时间。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，没有索引的表（堆）将允许更快的写入操作。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（如果您有两个索引，则最终将进行三个写操作，依此类推）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="adecf93f2acfab3a69649212fe2efb7426f23e48" translate="yes" xml:space="preserve">
          <source>So now the database will use the index to find employees named John
  because the index will presumably be sorted alphabetically by the
  Users name. And, because it is sorted, it means searching for a name
  is a lot faster because all names starting with a &amp;ldquo;J&amp;rdquo; will be right
  next to each other in the index!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，现在数据库将使用索引查找名为John的员工，因为该索引可能会按用户名的字母顺序进行排序。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而且，由于它是经过排序的，这意味着搜索名称的速度要快得多，因为所有以&amp;ldquo; J&amp;rdquo;开头的名称都将在索引中紧挨着！&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="26471d745a61045c6728ede7f132a76a50811d84" translate="yes" xml:space="preserve">
          <source>The database software would literally have to look at every single row in the &lt;code&gt;User&lt;/code&gt; table to see if the &lt;code&gt;Name&lt;/code&gt; for that row is &amp;lsquo;John&amp;rsquo;. This will take a long time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数据库软件实际上必须查看&lt;/font&gt;&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;中的每一行，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以查看&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是否为'John'。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这将花费很长时间。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92388142fd95760bd53d3617559908024063026c" translate="yes" xml:space="preserve">
          <source>The downside to indexing is that these indices require additional space on the disk since the indices are stored together in a table using the MyISAM engine, this file can quickly reach the size limits of the underlying file system if many fields within the same table are indexed.</source>
          <target state="translated">索引的缺点是这些索引需要额外的磁盘空间,因为这些索引使用MyISAM引擎存储在一个表中,如果在同一个表中的许多字段被索引,这个文件很快就会达到底层文件系统的大小限制。</target>
        </trans-unit>
        <trans-unit id="7d8c6667f49892d4041edae513099ceacb903c2e" translate="yes" xml:space="preserve">
          <source>The first time I read this it was very helpful to me. Thank you.</source>
          <target state="translated">我第一次读到这篇文章,对我有很大的帮助。谢谢你。</target>
        </trans-unit>
        <trans-unit id="6ab7299d1206cde9db1d5f739db12c3075d44567" translate="yes" xml:space="preserve">
          <source>The index is nothing but a data structure that &lt;strong&gt;stores the values for a specific column&lt;/strong&gt; in a table. An index is created on a column of a table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;索引不过是一种数据结构，该数据结构&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;存储&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表中&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特定列的值&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在表的列上创建索引。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="126caeb9af8c72c10dc8b6168e0b5dd59a87df45" translate="yes" xml:space="preserve">
          <source>The reason B- trees are the most popular data structure for indexes is due to the fact that they are time efficient &amp;ndash; because look-ups, deletions, and insertions can all be done in logarithmic time. And, another major reason B- trees are more commonly used is because the data that is stored inside the B- tree can be sorted. The RDBMS typically determines which data structure is actually used for an index. But, in some scenarios with certain RDBMS&amp;rsquo;s, you can actually specify which data structure you want your database to use when you create the index itself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B树是索引最流行的数据结构的原因是它们具有时间效率的事实&amp;ndash;因为查找，删除和插入都可以在对数时间内完成。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而且，B树被更普遍使用的另一个主要原因是因为可以对存储在B树中的数据进行排序。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;RDBMS通常确定哪种数据结构实际用于索引。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，在具有某些RDBMS的某些情况下，实际上可以指定在创建索引本身时希望数据库使用哪种数据结构。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef4d79676e50d3782a878b91406b5f00f4a58cd0" translate="yes" xml:space="preserve">
          <source>The reason hash indexes are used is because hash tables are extremely efficient when it comes to just looking up values. So, queries that compare for equality to a string can retrieve values very fast if they use a hash index.</source>
          <target state="translated">使用散列索引的原因是,当只查询值时,散列表的效率非常高。因此,如果使用哈希索引,对字符串进行等价比较的查询可以非常快速地检索到值。</target>
        </trans-unit>
        <trans-unit id="257d302baeb4a014b97399cca558bbb83e525e5d" translate="yes" xml:space="preserve">
          <source>The whole point of having an index is to speed up search queries by essentially cutting down the number of records/rows in a table that need to be examined. An index is a data structure (most commonly a B- tree) that stores the values for a specific column in a table.</source>
          <target state="translated">拥有一个索引的全部意义在于通过减少表中需要检查的记录rows的数量来加快搜索查询的速度。索引是一种数据结构(最常见的是B-树),它存储了表中特定列的值。</target>
        </trans-unit>
        <trans-unit id="a4f5d021fd61272cfc727ba4d28ac004f08424f2" translate="yes" xml:space="preserve">
          <source>Things are simple in schools, isn't it? :P</source>
          <target state="translated">学校里的事情很简单,不是吗?</target>
        </trans-unit>
        <trans-unit id="7503b65320d9c1b258a3d69a2f77ffa5cb85b3fa" translate="yes" xml:space="preserve">
          <source>This analogy is known as &lt;strong&gt;&quot;Full Table Scan&quot;&lt;/strong&gt; in database world.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这个类比&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在数据库世界中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;被称为&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;ldquo;全表扫描&amp;rdquo;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="814e34b9dbc0414d8df43d75cfeebb5d902126ee" translate="yes" xml:space="preserve">
          <source>This is where &lt;code&gt;index&lt;/code&gt; helps us: &lt;em&gt;index is used to speed up search queries by essentially cutting down the number of records/rows in a table that needs to be examined&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;帮助我们的地方：&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;索引用于通过实质上减少需要检查的表中的记录/行数来加速搜索查询&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eae407d68bea00f32c03361bd34649b638b74dd0" translate="yes" xml:space="preserve">
          <source>Thus, the index is a separate section that stores values of indexed
  column + pointer to the indexed row in a sorted order for efficient
  look-ups.</source>
          <target state="translated">因此,索引是一个独立的部分,以排序的方式存储索引列的值+指向索引行的指针,以达到高效查询的目的。</target>
        </trans-unit>
        <trans-unit id="3388f2a0255a47ceeb6050962fbb9511180c8d29" translate="yes" xml:space="preserve">
          <source>What columns generally make good indexes?</source>
          <target state="translated">一般来说,哪些列是好的索引?</target>
        </trans-unit>
        <trans-unit id="e6f1df688c30d94eb68a3bb0fa23154aa1e18bc3" translate="yes" xml:space="preserve">
          <source>When data is stored on disk-based storage devices, it is stored as blocks of data. These blocks are accessed in their entirety, making them the atomic disk access operation. Disk blocks are structured in much the same way as linked lists; both contain a section for data, a pointer to the location of the next node (or block), and both need not be stored contiguously.</source>
          <target state="translated">当数据被存储在基于磁盘的存储设备上时,它是以数据块的形式存储的。这些数据块被完整地访问,使其成为原子磁盘访问操作。磁盘块的结构与链接列表的结构基本相同;两者都包含一个数据部分,一个指向下一个节点(或块)的位置的指针,而且两者都不需要连续存储。</target>
        </trans-unit>
        <trans-unit id="93a2555206a0af83fbe551a83137431c161ed8c6" translate="yes" xml:space="preserve">
          <source>Whereas with a sorted field, a Binary Search may be used, which has &lt;code&gt;log2 N&lt;/code&gt; block accesses. Also since the data is sorted given a non-key field, the rest of the table doesn&amp;rsquo;t need to be searched for duplicate values, once a higher value is found. Thus the performance increase is substantial.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;而对于已排序的字段，可以使用二进制搜索，其具有&lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 N&lt;/code&gt; 个&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;块访问。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同样，由于给定的非键字段对数据进行了排序，因此一旦找到更高的值，就无需在表的其余部分中搜索重复的值。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，性能的提高是可观的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b533efcb68c06cbb661f675f72076a2242fa3ed" translate="yes" xml:space="preserve">
          <source>e.g:- If you have lots of rivalling writes but only one nightly read outside business hours for reporting.</source>
          <target state="translated">例如:--如果你有很多对立的写法,但在工作时间以外的晚上只读一次报告。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
