<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1108">
    <body>
      <group id="1108">
        <trans-unit id="7c6f976f4e1f247357643420b0f1d5edff13eef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Example 1&lt;/em&gt;&lt;/strong&gt; - &lt;em&gt;sorted vs unsorted fields&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ejemplo 1&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; campos ordenados vs no clasificados&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad6ea987ddb5784c13bde986d9834b1b8aa7cc8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Example 2&lt;/em&gt;&lt;/strong&gt;  - &lt;em&gt;indexing&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ejemplo 2&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; indexaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c263d6e1ec3808a54cf13984a9ccf2fe20c030b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How a database index can help performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C&amp;oacute;mo un &amp;iacute;ndice de base de datos puede ayudar al rendimiento&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ee6c6ffc954bb7d8e7f64c641b17ff3a602b455" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does B-trees index work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;C&amp;oacute;mo funciona el &amp;iacute;ndice B-trees?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1038135901ca45cbc26e89cf4438b522835561bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does a database know when to use an index?&lt;/strong&gt;
When a query like &amp;ldquo;SELECT * FROM Employee WHERE Employee_Name = &amp;lsquo;Abc&amp;rsquo; &amp;rdquo; is run, the database will check to see if there is an index on the column(s) being queried. Assuming the Employee_Name column does have an index created on it, the database will have to decide whether it actually makes sense to use the index to find the values being searched &amp;ndash; because there are some scenarios where it is actually less efficient to use the database index, and more efficient just to scan the entire table.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;C&amp;oacute;mo sabe una base de datos cu&amp;aacute;ndo usar un &amp;iacute;ndice? &lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Cuando se ejecuta una consulta como &quot;SELECT * FROM Employee WHERE Employee_Name = 'Abc'&quot;, la base de datos verificar&amp;aacute; si hay un &amp;iacute;ndice en las columnas que se consultan. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Suponiendo que la columna Employee_Name tiene un &amp;iacute;ndice creado, la base de datos tendr&amp;aacute; que decidir si realmente tiene sentido usar el &amp;iacute;ndice para encontrar los valores que se buscan, porque hay algunos escenarios en los que es menos eficiente usar el &amp;iacute;ndice de la base de datos. , y m&amp;aacute;s eficiente solo para escanear toda la tabla.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff64d04a079079f647ecb61630eba86649659ead" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does a hash table index work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;C&amp;oacute;mo funciona un &amp;iacute;ndice de tabla hash?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c1ec9f40f4edd7eb75f8f619aa77433ee58d89b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does it work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Como funciona?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7776d2a490f8e3aaac3f9ca4505cab9d20b38b23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Pointers in MySQL are 2, 3, 4 or 5 bytes in length depending on the size of the table.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nota&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : Los punteros en MySQL tienen una longitud de 2, 3, 4 o 5 bytes, dependiendo del tama&amp;ntilde;o de la tabla.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d1f023e6a4d3bc1e8bf916bde9bbdd1bedb1d70d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: char was used in place of varchar to allow for an accurate size on disk value. 
This sample database contains five million rows and is unindexed. The performance of several queries will now be analyzed. These are a query using the &lt;em&gt;id&lt;/em&gt; (a sorted key field) and one using the &lt;em&gt;firstName&lt;/em&gt; (a non-key unsorted field).</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Nota&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; : se us&amp;oacute; char en lugar de varchar para permitir un tama&amp;ntilde;o preciso en el valor del disco. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta base de datos de muestra contiene cinco millones de filas y no est&amp;aacute; indexada. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora se analizar&amp;aacute; el rendimiento de varias consultas. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Estos son una consulta mediante la &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;identificaci&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y uno (un campo clave ordenados) utilizando el &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;primerNombre&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; (sin ordenar un campo que no son clave).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e55a4eef1abc15fd25c68f22657b346ff3abdb11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Description!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Descripci&amp;oacute;n simple!&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f4ae4a04e94c61d13e11443fa35cbf4c8957624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The disadvantages of a hash index&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las desventajas de un &amp;iacute;ndice hash&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d60b2311316bf1641d865996eaab467baf68c7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What exactly is inside a database index?&lt;/strong&gt;
So, now you know that a database index is created on a column in a table, and that the index stores the values in that specific column. But, it is important to understand that a database index does not store the values in the other columns of the same table. For example, if we create an index on the Employee_Name column, this means that the Employee_Age and Employee_Address column values are not also stored in the index. If we did just store all the other columns in the index, then it would be just like creating another copy of the entire table &amp;ndash; which would take up way too much space and would be very inefficient.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Qu&amp;eacute; hay exactamente dentro de un &amp;iacute;ndice de base de datos?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; Entonces, ahora sabe que se crea un &amp;iacute;ndice de base de datos en una columna de una tabla y que el &amp;iacute;ndice almacena los valores en esa columna espec&amp;iacute;fica. Pero, es importante comprender que un &amp;iacute;ndice de base de datos no almacena los valores en las otras columnas de la misma tabla. Por ejemplo, si creamos un &amp;iacute;ndice en la columna Employee_Name, esto significa que los valores de la columna Employee_Age y Employee_Address tampoco se almacenan en el &amp;iacute;ndice. Si simplemente almacenamos todas las otras columnas en el &amp;iacute;ndice, ser&amp;iacute;a como crear otra copia de la tabla completa, lo que ocupar&amp;iacute;a demasiado espacio y ser&amp;iacute;a muy ineficiente.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6428ecc202198be70cb1f1755663fa9831bc29a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is indexing?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Qu&amp;eacute; es la indexaci&amp;oacute;n?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="66754d988f4fcb1acc4a50297f2aadea10736289" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is the cost of having a database index?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Cu&amp;aacute;l es el costo de tener un &amp;iacute;ndice de base de datos?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e16a9f89c5c9cad39f49b095ddeef61be6287223" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What would happen without an index?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Qu&amp;eacute; pasar&amp;iacute;a sin un &amp;iacute;ndice?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba497667b700161a0513bd86c14414feabb5a6a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should it be used?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Cu&amp;aacute;ndo deber&amp;iacute;a usarse?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c650694413b8d8c8e0547a99830e7752b6f6fb74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why is it needed?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Por qu&amp;eacute; es necesario?&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fadfcc0b3b5611c6320a2347916ace1ab3378c3e" translate="yes" xml:space="preserve">
          <source>A linear search on the id field would require an average of &lt;code&gt;N/2 = 500,000&lt;/code&gt; block accesses to find a value, given that the id field is a key field. But since the id field is also sorted, a binary search can be conducted requiring an average of &lt;code&gt;log2 1000000 = 19.93 = 20&lt;/code&gt; block accesses. Instantly we can see this is a drastic improvement.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Una b&amp;uacute;squeda lineal en el campo de identificaci&amp;oacute;n requerir&amp;iacute;a un promedio de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N/2 = 500,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; accesos de bloque para encontrar un valor, dado que el campo de identificaci&amp;oacute;n es un campo clave. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero dado que el campo id tambi&amp;eacute;n est&amp;aacute; ordenado, se puede realizar una b&amp;uacute;squeda binaria que requiere un promedio de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 1000000 = 19.93 = 20&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; accesos de bloque. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Al instante podemos ver que esto es una mejora dr&amp;aacute;stica.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="71f1a10902b7a8ccbae4cdba11a0b434fe2b432e" translate="yes" xml:space="preserve">
          <source>Also, a differentiation between clustered and non-clustered indexes is rather important.</source>
          <target state="translated">También es bastante importante la diferenciación entre los índices agrupados y no agrupados.</target>
        </trans-unit>
        <trans-unit id="f959491d8665d67cf85a2cc9b96a16ed6e7c0149" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;index&lt;/code&gt; consists of &lt;strong&gt;column values(Eg: John) from one table&lt;/strong&gt;, and those values are stored in a &lt;strong&gt;data structure&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un &lt;/font&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; consta de &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;valores&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;columna (por ejemplo, John) de una tabla&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , y esos valores se almacenan en una &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;estructura de datos&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ad74fb25accebf8d6e8d23b44a80acc6acebc0d" translate="yes" xml:space="preserve">
          <source>An index is just a data structure that makes the searching faster for a specific column in a database. This structure is usually a b-tree or a hash table but it can be any other logic structure.</source>
          <target state="translated">Un índice es sólo una estructura de datos que hace que la búsqueda sea más rápida para una columna específica en una base de datos.Esta estructura suele ser un árbol B o una tabla hash,pero puede ser cualquier otra estructura lógica.</target>
        </trans-unit>
        <trans-unit id="ae0587c6babe222342305dc974d0c1ee2fec283f" translate="yes" xml:space="preserve">
          <source>Another option is that, you could just go to the Index section of the book and then find what you are looking for by using the Name of the entity you are looking ( in this instance, German Shepherds) and also looking at the page number to quickly find what you are looking for.</source>
          <target state="translated">Otra opción es que,podría ir a la sección de Índice del libro y luego encontrar lo que está buscando utilizando el Nombre de la entidad que está buscando (en este caso,Pastores Alemanes)y también mirando el número de página para encontrar rápidamente lo que está buscando.</target>
        </trans-unit>
        <trans-unit id="a42223342f004e5087636b0bd93ed01b59e5befd" translate="yes" xml:space="preserve">
          <source>Another problem with indexes is their fragmentation over time as data is inserted. &lt;code&gt;REORGANIZE&lt;/code&gt; helps, you must write routines to have it done.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otro problema con los &amp;iacute;ndices es su fragmentaci&amp;oacute;n en el tiempo a medida que se insertan los datos. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;REORGANIZE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ayuda, debes escribir rutinas para hacerlo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="670ae6c441f98e2a78f5820d589187b5910ea31c" translate="yes" xml:space="preserve">
          <source>As a general rule, an index should only be created on a table if the data in the indexed column will be queried frequently.</source>
          <target state="translated">Por regla general,sólo se debe crear un índice en una tabla si los datos de la columna indexada se van a consultar con frecuencia.</target>
        </trans-unit>
        <trans-unit id="06a4b006b5c2d9087ce316cf7000e63a79bca581" translate="yes" xml:space="preserve">
          <source>But then, in addition to actual 1000 pages, you will need another ~10 pages to show the indices, so totally 1010 pages.</source>
          <target state="translated">Pero entonces,además de las 1000 páginas reales,necesitarás otras ~10 páginas para mostrar los índices,así que totalmente 1010 páginas.</target>
        </trans-unit>
        <trans-unit id="3d71c21621662c8be4c6dce7fd281e97dfd2c30e" translate="yes" xml:space="preserve">
          <source>But with an index page, you know where to go! And more, to lookup any particular Chapter that matters, you just need to look over the index page, again and again, every time. After finding the matching index you can efficiently jump to that chapter by skipping the rest.</source>
          <target state="translated">Pero con una página de índice,¡ya sabes a dónde ir! Y más,para buscar cualquier capítulo en particular que importe,sólo tienes que mirar la página índice,una y otra vez,cada vez.Después de encontrar el índice correspondiente puedes saltar eficientemente a ese capítulo saltándote el resto.</target>
        </trans-unit>
        <trans-unit id="a2aeece8a7e18f9f6165280d858250ef5c41a36b" translate="yes" xml:space="preserve">
          <source>Classic example &lt;strong&gt;&quot;Index in Books&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ejemplo cl&amp;aacute;sico &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;&amp;Iacute;ndice en libros&quot;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edfadc138c324a28c0ad48b4568b1c93f50ae608" translate="yes" xml:space="preserve">
          <source>Consider a &quot;Book&quot; of 1000 pages, divided by 10 Chapters, each section with 100 pages.</source>
          <target state="translated">Considere un &quot;Libro&quot; de 1000 páginas,dividido por 10 capítulos,cada sección con 100 páginas.</target>
        </trans-unit>
        <trans-unit id="ccace75fa9dc2dfab316381c595f1cee029a29da" translate="yes" xml:space="preserve">
          <source>Database software would literally have to look at every single row in the Employee table to see if the Employee_Name for that row is &amp;lsquo;Abc&amp;rsquo;. And, because we want every row with the name &amp;lsquo;Abc&amp;rsquo; inside it, we can not just stop looking once we find just one row with the name &amp;lsquo;Abc&amp;rsquo;, because there could be other rows with the name &lt;strong&gt;Abc&lt;/strong&gt;. So, every row up until the last row must be searched &amp;ndash; which means thousands of rows in this scenario will have to be examined by the database to find the rows with the name &amp;lsquo;Abc&amp;rsquo;. This is what is called a &lt;strong&gt;full table scan&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El software de la base de datos literalmente tendr&amp;iacute;a que mirar cada fila en la tabla de empleados para ver si Employee_Name para esa fila es 'Abc'. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y, dado que queremos cada fila con el nombre 'Abc' dentro, no podemos dejar de buscar una vez que encontramos solo una fila con el nombre 'Abc', porque podr&amp;iacute;a haber otras filas con el nombre &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Abc&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, cada fila hasta la &amp;uacute;ltima fila debe buscarse, lo que significa que la base de datos tendr&amp;aacute; que examinar miles de filas en este escenario para encontrar las filas con el nombre 'Abc'. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto es lo que se llama una &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;exploraci&amp;oacute;n de tabla completa&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ceb478c45cb9fe55a55150694c3e2f7c5bd8f32f" translate="yes" xml:space="preserve">
          <source>Due to the fact that a number of records can only be sorted on one field, we can state that searching on a field that isn&amp;rsquo;t sorted requires a Linear Search which requires &lt;code&gt;N/2&lt;/code&gt; block accesses (on average), where &lt;code&gt;N&lt;/code&gt; is the number of blocks that the table spans. If that field is a non-key field (i.e. doesn&amp;rsquo;t contain unique entries) then the entire tablespace must be searched at &lt;code&gt;N&lt;/code&gt; block accesses.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Debido al hecho de que varios registros solo se pueden ordenar en un campo, podemos afirmar que la b&amp;uacute;squeda en un campo que no est&amp;aacute; ordenado requiere una B&amp;uacute;squeda lineal que requiere &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N/2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; accesos de bloque (en promedio), donde &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es el cantidad de bloques que abarca la tabla. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si ese campo es un campo sin clave (es decir, no contiene entradas &amp;uacute;nicas), se debe buscar en todo el espacio de tabla en &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; accesos de bloque.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e5bc6d47e649819c256f1169901b6aa5852d68ce" translate="yes" xml:space="preserve">
          <source>Example: We have a database table called &lt;code&gt;User&lt;/code&gt; with three columns &amp;ndash; &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Address&lt;/code&gt;. Assume that the &lt;code&gt;User&lt;/code&gt; table has thousands of rows.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ejemplo: Tenemos una tabla de base de datos llamada &lt;/font&gt;&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; con tres columnas: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; y &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Address&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Suponga que la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tabla &lt;/font&gt;&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; tiene miles de filas.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6dfb64751c4bd0fadd0aadce8f3a9bec1f87f196" translate="yes" xml:space="preserve">
          <source>Firstly, let&amp;rsquo;s outline a sample database table schema;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En primer lugar, describamos un esquema de tabla de base de datos de muestra;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67a6b5de80a5587dd3df63bd3b5cd82d3ef329d8" translate="yes" xml:space="preserve">
          <source>For information on queries to index a field, check out &lt;a href=&quot;https://stackoverflow.com/questions/1156/&quot;&gt;How do I index a database column&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para obtener informaci&amp;oacute;n sobre las consultas para indexar un campo, consulte &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1156/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C&amp;oacute;mo indexar una columna de base de datos&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a56b08d796085fa51779969ead12eba0cdf923dc" translate="yes" xml:space="preserve">
          <source>For instance, the query we discussed earlier could benefit from a hash index created on the Employee_Name column. The way a hash index would work is that the column value will be the key into the hash table and the actual value mapped to that key would just be a pointer to the row data in the table. Since a hash table is basically an associative array, a typical entry would look something like &amp;ldquo;Abc =&amp;gt; 0x28939&amp;Prime;, where 0x28939 is a reference to the table row where Abc is stored in memory. Looking up a value like &amp;ldquo;Abc&amp;rdquo; in a hash table index and getting back a reference to the row in memory is obviously a lot faster than scanning the table to find all the rows with a value of &amp;ldquo;Abc&amp;rdquo; in the Employee_Name column.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por ejemplo, la consulta que discutimos anteriormente podr&amp;iacute;a beneficiarse de un &amp;iacute;ndice hash creado en la columna Employee_Name. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La forma en que funcionar&amp;iacute;a un &amp;iacute;ndice hash es que el valor de la columna ser&amp;aacute; la clave en la tabla hash y el valor real asignado a esa clave solo ser&amp;iacute;a un puntero a los datos de la fila en la tabla. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dado que una tabla hash es b&amp;aacute;sicamente una matriz asociativa, una entrada t&amp;iacute;pica se ver&amp;iacute;a algo as&amp;iacute; como &quot;Abc =&amp;gt; 0x28939&quot;, donde 0x28939 es una referencia a la fila de la tabla donde Abc se almacena en la memoria. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Buscar un valor como &quot;Abc&quot; en un &amp;iacute;ndice de tabla hash y recuperar una referencia a la fila en la memoria es obviamente mucho m&amp;aacute;s r&amp;aacute;pido que escanear la tabla para encontrar todas las filas con un valor de &quot;Abc&quot; en la columna Employee_Name.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ba744e72c82249823f810b1d800ca0c81ff406e9" translate="yes" xml:space="preserve">
          <source>Given our sample database of &lt;code&gt;r = 5,000,000&lt;/code&gt; records of a fixed size giving a record length of &lt;code&gt;R = 204&lt;/code&gt; bytes and they are stored in a table using the MyISAM engine which is using the default block size &lt;code&gt;B = 1,024&lt;/code&gt; bytes. The blocking factor of the table would be &lt;code&gt;bfr = (B/R) = 1024/204 = 5&lt;/code&gt; records per disk block. The total number of blocks required to hold the table is &lt;code&gt;N = (r/bfr) = 5000000/5 = 1,000,000&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dada nuestra base de datos de muestra de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r = 5,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; registros de un tama&amp;ntilde;o fijo que proporciona una longitud de registro de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;R = 204&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; bytes y se almacenan en una tabla usando el motor MyISAM que usa el tama&amp;ntilde;o de bloque predeterminado &lt;/font&gt;&lt;/font&gt; &lt;code&gt;B = 1,024&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; bytes. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El factor de bloqueo de la tabla ser&amp;iacute;a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bfr = (B/R) = 1024/204 = 5&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; registros por bloque de disco. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El n&amp;uacute;mero total de bloques necesarios para mantener la tabla es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N = (r/bfr) = 5000000/5 = 1,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; bloques.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a612a719bfeff12051ef62ec18b988c42d957b8" translate="yes" xml:space="preserve">
          <source>Given our sample database of &lt;code&gt;r = 5,000,000&lt;/code&gt; records with an index record length of &lt;code&gt;R = 54&lt;/code&gt; bytes and using the default block size &lt;code&gt;B = 1,024&lt;/code&gt; bytes. The blocking factor of the index would be &lt;code&gt;bfr = (B/R) = 1024/54 = 18&lt;/code&gt; records per disk block. The total number of blocks required to hold the index is &lt;code&gt;N = (r/bfr) = 5000000/18 = 277,778&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dada nuestra base de datos de muestra de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;r = 5,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; registros con una longitud de registro de &amp;iacute;ndice de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;R = 54&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; bytes y usando el tama&amp;ntilde;o de bloque predeterminado &lt;/font&gt;&lt;/font&gt; &lt;code&gt;B = 1,024&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; bytes. El factor de bloqueo del &amp;iacute;ndice ser&amp;iacute;a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;bfr = (B/R) = 1024/54 = 18&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; registros por bloque de disco. El n&amp;uacute;mero total de bloques necesarios para mantener el &amp;iacute;ndice es &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N = (r/bfr) = 5000000/18 = 277,778&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; bloques.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67d7d36ed55f5b6ce5bb067162a83dc511e7fd79" translate="yes" xml:space="preserve">
          <source>Given that an index record contains only the indexed field and a pointer to the original record, it stands to reason that it will be smaller than the multi-field record that it points to. So the index itself requires fewer disk blocks than the original table, which therefore requires fewer block accesses to iterate through. The schema for an index on the &lt;em&gt;firstName&lt;/em&gt; field is outlined below;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dado que un registro de &amp;iacute;ndice contiene solo el campo indexado y un puntero al registro original, es l&amp;oacute;gico pensar que ser&amp;aacute; m&amp;aacute;s peque&amp;ntilde;o que el registro de campo m&amp;uacute;ltiple al que apunta. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, el &amp;iacute;ndice en s&amp;iacute; mismo requiere menos bloques de disco que la tabla original, lo que, por lo tanto, requiere menos accesos de bloque para iterar. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El esquema para un &amp;iacute;ndice en el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;campo &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; se describe a continuaci&amp;oacute;n;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b8a40897243ff8b8b9b81a535752ccc504133a4" translate="yes" xml:space="preserve">
          <source>Given that creating an index requires additional disk space (277,778 blocks extra from the above example, a ~28% increase), and that too many indices can cause issues arising from the file systems size limits, careful thought must be used to select the correct fields to index.</source>
          <target state="translated">Dado que la creación de un índice requiere espacio adicional en el disco (277.778 bloques extra del ejemplo anterior,un aumento de ~28%),y que demasiados índices pueden causar problemas derivados de los límites de tamaño de los sistemas de archivos,se debe pensar cuidadosamente en la selección de los campos correctos para indexar.</target>
        </trans-unit>
        <trans-unit id="6560699d2bd8f61f1f9e9e79eda860b41d744347" translate="yes" xml:space="preserve">
          <source>Given that indexing is so important as your data set increases in size, can someone explain how indexing works at a database-agnostic level?</source>
          <target state="translated">Dado que la indexación es tan importante a medida que su conjunto de datos aumenta de tamaño,¿puede alguien explicar cómo funciona la indexación a nivel de la base de datos?</target>
        </trans-unit>
        <trans-unit id="32a8bd6432ae70cef621c292e079e404b892ba3b" translate="yes" xml:space="preserve">
          <source>Hash tables are not sorted data structures, and there are many types of queries which hash indexes can not even help with. For instance, suppose you want to find out all of the employees who are less than 40 years old. How could you do that with a hash table index? Well, it&amp;rsquo;s not possible because a hash table is only good for looking up key value pairs &amp;ndash; which means queries that check for equality</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Las tablas hash no son estructuras de datos ordenadas, y hay muchos tipos de consultas con las que los &amp;iacute;ndices hash ni siquiera pueden ayudar. Por ejemplo, suponga que desea conocer a todos los empleados que tienen menos de 40 a&amp;ntilde;os. &amp;iquest;C&amp;oacute;mo podr&amp;iacute;as hacer eso con un &amp;iacute;ndice de tabla hash? Bueno, no es posible porque una tabla hash solo es buena para buscar pares de valores clave, lo que significa consultas que verifican la igualdad&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d21860c9c34e97854024389404de25905618ed2" translate="yes" xml:space="preserve">
          <source>Helped me:- &lt;a href=&quot;https://stackoverflow.com/questions/1251636/what-do-clustered-and-non-clustered-index-actually-mean&quot;&gt;What do Clustered and Non clustered index actually mean?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Me ayud&amp;oacute;: - &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1251636/what-do-clustered-and-non-clustered-index-actually-mean&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Qu&amp;eacute; significan realmente el &amp;iacute;ndice agrupado y no agrupado?&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3cca3a8a00a3a45f0a5c76f372683f44b7b1881" translate="yes" xml:space="preserve">
          <source>How do database indexes work</source>
          <target state="translated">¿Cómo funcionan los índices de las bases de datos?</target>
        </trans-unit>
        <trans-unit id="5452e26c95523ae9f9b07a1f3bae3db9dbe68101" translate="yes" xml:space="preserve">
          <source>How does database indexing work</source>
          <target state="translated">¿Cómo funciona la indexación de la base de datos</target>
        </trans-unit>
        <trans-unit id="7df16cfacc6d28d0dec6ecd7f0a8c16905729906" translate="yes" xml:space="preserve">
          <source>How to create an index:</source>
          <target state="translated">Cómo crear un índice:</target>
        </trans-unit>
        <trans-unit id="e9a156ac7af5ee1f8d9b1e3dfc529d5d31e2a992" translate="yes" xml:space="preserve">
          <source>However, defining two different locations on two different hard disks for index data and table data can decrease/eliminate the problem of increased cost of time. This requires definition of additional file groups with according files on the desired hard disks and definition of table/index location as desired.</source>
          <target state="translated">Sin embargo,la definición de dos lugares diferentes en dos discos duros diferentes para los datos de índice y los datos de tabla puede disminuir-eliminar el problema del aumento del costo del tiempo.Esto requiere la definición de grupos de archivos adicionales con los archivos correspondientes en los discos duros deseados y la definición de la ubicación de los índices de tablas según se desee.</target>
        </trans-unit>
        <trans-unit id="ef380204ad169fc2292c6fa188d9c6d356f78f84" translate="yes" xml:space="preserve">
          <source>If you have a book about dogs and you want to find an information about let's say, German Shepherds, you could of course flip through all the pages of the book and find what you are looking for  - but this of course is time consuming and not very fast.</source>
          <target state="translated">Si tienes un libro sobre perros y quieres encontrar información sobre,digamos,los Pastores Alemanes,podrías por supuesto hojear todas las páginas del libro y encontrar lo que buscas,pero esto,por supuesto,lleva mucho tiempo y no es muy rápido.</target>
        </trans-unit>
        <trans-unit id="d8f04bd94bd160a1d96d45d2529a31258e82a393" translate="yes" xml:space="preserve">
          <source>In Database, the page number is referred to as a pointer which directs the database to the address on the disk where entity is located. Using the same German Shepherd analogy, we could have something like this (&amp;ldquo;German Shepherd&amp;rdquo;, 0x77129) where &lt;code&gt;0x77129&lt;/code&gt; is the address on the disk where the row data for German Shepherd is stored.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En la base de datos, el n&amp;uacute;mero de p&amp;aacute;gina se conoce como un puntero que dirige la base de datos a la direcci&amp;oacute;n en el disco donde se encuentra la entidad. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Usando la misma analog&amp;iacute;a del Pastor Alem&amp;aacute;n, podr&amp;iacute;amos tener algo como esto (&quot;Pastor Alem&amp;aacute;n&quot;, 0x77129) donde &lt;/font&gt;&lt;/font&gt; &lt;code&gt;0x77129&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; es la direcci&amp;oacute;n en el disco donde se almacenan los datos de la fila del Pastor Alem&amp;aacute;n.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ef1c79649a1ffa63f8f1acd27875a9fcc448b06" translate="yes" xml:space="preserve">
          <source>In certain scenarios a heap is more helpful than a table with indexes,</source>
          <target state="translated">En ciertos escenarios un montón es más útil que una tabla con índices,</target>
        </trans-unit>
        <trans-unit id="c571b07f97ec082a06642bacb56f5d9267f7fdae" translate="yes" xml:space="preserve">
          <source>In short, an index is a data structure that stores the values for a specific column in a table so as to speed up query search.</source>
          <target state="translated">En resumen,un índice es una estructura de datos que almacena los valores de una columna específica en una tabla para acelerar la búsqueda de la consulta.</target>
        </trans-unit>
        <trans-unit id="8e8e8ce6c1f5d8d1d05614c2f29659055232953f" translate="yes" xml:space="preserve">
          <source>Indexing is a way of sorting a number of records on multiple fields. Creating an index on a field in a table creates another data structure which holds the field value, and a pointer to the record it relates to. This index structure is then sorted, allowing Binary Searches to be performed on it.</source>
          <target state="translated">La indexación es una forma de clasificar una serie de registros en múltiples campos.La creación de un índice en un campo de una tabla crea otra estructura de datos que contiene el valor del campo y un puntero al registro con el que se relaciona.Esta estructura de índice se ordena entonces,permitiendo que se realicen búsquedas binarias en ella.</target>
        </trans-unit>
        <trans-unit id="a611240736d03bf16b06eb89c51008f6b823f25d" translate="yes" xml:space="preserve">
          <source>It takes up space &amp;ndash; and the larger your table, the larger your index. Another performance hit with indexes is the fact that whenever you add, delete, or update rows in the corresponding table, the same operations will have to be done to your index. Remember that an index needs to contain the same up to the minute data as whatever is in the table column(s) that the index covers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ocupa espacio, y cuanto mayor sea su tabla, mayor ser&amp;aacute; su &amp;iacute;ndice. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Otro golpe de rendimiento con los &amp;iacute;ndices es el hecho de que cada vez que agregue, elimine o actualice filas en la tabla correspondiente, se deber&amp;aacute;n realizar las mismas operaciones en su &amp;iacute;ndice. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Recuerde que un &amp;iacute;ndice debe contener los mismos datos hasta el minuto que lo que est&amp;eacute; en las columnas de la tabla que cubre el &amp;iacute;ndice.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="276b5a9e7eafc9116c94af7c4302e336bba600a7" translate="yes" xml:space="preserve">
          <source>Just a quick suggestion.. As indexing costs you additional writes and storage space, so if your application requires more insert/update operation, you might want to use tables without indexes, but if it requires more data retrieval operations, you should go for indexed table.</source>
          <target state="translated">Sólo una rápida sugerencia...Como la indexación le cuesta más espacio de escritura y almacenamiento,así que si su aplicación requiere más operaciones de actualización de insertos,tal vez desee utilizar tablas sin índices,pero si requiere más operaciones de recuperación de datos,debería optar por la tabla indexada.</target>
        </trans-unit>
        <trans-unit id="79473d1d1fae832de50165b98ed9730e2335bcff" translate="yes" xml:space="preserve">
          <source>Just think of Database Index as Index of a book.</source>
          <target state="translated">Piensa en el índice de la base de datos como el índice de un libro.</target>
        </trans-unit>
        <trans-unit id="9e6820fb508cdfb4143176447ba4ee4022ec87ef" translate="yes" xml:space="preserve">
          <source>Now a search using the &lt;em&gt;firstName&lt;/em&gt; field can utilize the index to increase performance. This allows for a binary search of the index with an average of &lt;code&gt;log2 277778 = 18.08 = 19&lt;/code&gt; block accesses. To find the address of the actual record, which requires a further block access to read, bringing the total to &lt;code&gt;19 + 1 = 20&lt;/code&gt; block accesses, a far cry from the 1,000,000 block accesses required to find a &lt;em&gt;firstName&lt;/em&gt; match in the non-indexed table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora, una b&amp;uacute;squeda con el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;campo &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; puede utilizar el &amp;iacute;ndice para aumentar el rendimiento. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto permite una b&amp;uacute;squeda binaria del &amp;iacute;ndice con un promedio de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 277778 = 18.08 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; accesos de bloque. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Para encontrar la direcci&amp;oacute;n del registro real, que requiere un acceso de bloque adicional para leer, llevando el total a &lt;/font&gt;&lt;/font&gt; &lt;code&gt;19 + 1 = 20&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; accesos de bloque, muy lejos de los 1,000,000 de accesos de bloque requeridos para encontrar una &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;coincidencia de &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;FirstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en la tabla no indexada .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a62e94584fca0d632abdef6d650cf49c229bbe33" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;firstName&lt;/em&gt; field is neither sorted nor a key field, so a binary search is impossible, nor are the values unique, and thus the table will require searching to the end for an exact &lt;code&gt;N = 1,000,000&lt;/code&gt; block accesses. It is this situation that indexing aims to correct.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;campo &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; no est&amp;aacute; ordenado ni es un campo clave, por lo que una b&amp;uacute;squeda binaria es imposible, ni los valores son &amp;uacute;nicos, por lo que la tabla requerir&amp;aacute; buscar hasta el final un &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;acceso &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;exacto de &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;bloques &lt;/font&gt;&lt;/font&gt; &lt;code&gt;N = 1,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Es esta situaci&amp;oacute;n que la indexaci&amp;oacute;n pretende corregir.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50cbc01eb392ec54b5d1caa08a59f11a5eb7f3b1" translate="yes" xml:space="preserve">
          <source>Now, imagine you want to find a particular Chapter that contains a word &quot;&lt;strong&gt;Alchemist&lt;/strong&gt;&quot;. Without an index page, you have no other option than scanning through the entire book/Chapters. i.e: 1000 pages.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora, imagina que quieres encontrar un Cap&amp;iacute;tulo en particular que contenga una palabra &quot; &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Alquimista&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; &quot;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Sin una p&amp;aacute;gina de &amp;iacute;ndice, no tiene otra opci&amp;oacute;n que escanear todo el libro / Cap&amp;iacute;tulos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;es decir: 1000 p&amp;aacute;ginas.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="777cb84ce5a934c14c04fb32c3c230b0028ab12b" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say that we want to run a query to find all the details of any employees who are named &amp;lsquo;Abc&amp;rsquo;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora, supongamos que queremos ejecutar una consulta para encontrar todos los detalles de cualquier empleado que se llame 'Abc'.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cb63ab6c0db77bef9b2c256e11bc06a79e6c6bd" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say that we want to run a query to find all the details of any users who are named 'John'. 
If we run the following query:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ahora, supongamos que queremos ejecutar una consulta para encontrar todos los detalles de cualquier usuario que se llame 'John'. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si ejecutamos la siguiente consulta:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">Ver también</target>
        </trans-unit>
        <trans-unit id="1d5c52ff7943b48eda6b1cf65c290aa09e17f098" translate="yes" xml:space="preserve">
          <source>Simple, huh?</source>
          <target state="translated">Simple,¿eh?</target>
        </trans-unit>
        <trans-unit id="c573cfffeb370eb01525896bbc026605b0d66f5c" translate="yes" xml:space="preserve">
          <source>Since indices are only used to speed up the searching for a matching field within the records, it stands to reason that indexing fields used only for output would be simply a waste of disk space and processing time when doing an insert or delete operation, and thus should be avoided. Also given the nature of a binary search, the cardinality or uniqueness of the data is important. Indexing on a field with a cardinality of 2 would split the data in half, whereas a cardinality of 1,000 would return approximately 1,000 records. With such a low cardinality the effectiveness is reduced to a linear sort, and the query optimizer will avoid using the index if the cardinality is less than 30% of the record number, effectively making the index a waste of space.</source>
          <target state="translated">Dado que los índices sólo se utilizan para acelerar la búsqueda de un campo coincidente dentro de los registros,es lógico que los campos de indización utilizados sólo para la salida serían simplemente una pérdida de espacio en el disco y de tiempo de procesamiento al realizar una operación de inserción o eliminación,y por lo tanto deben evitarse.También dada la naturaleza de una búsqueda binaria,la cardinalidad o singularidad de los datos es importante.La indexación en un campo con una cardinalidad de 2 dividiría los datos por la mitad,mientras que una cardinalidad de 1.000 devolvería aproximadamente 1.000 registros.Con una cardinalidad tan baja la efectividad se reduce a un tipo lineal,y el optimizador de consultas evitará usar el índice si la cardinalidad es menor del 30% del número de registros,haciendo efectivamente que el índice sea un desperdicio de espacio.</target>
        </trans-unit>
        <trans-unit id="e9732b1f53d3a2736ee890d12a683c1fc0c8f2cf" translate="yes" xml:space="preserve">
          <source>Since then I gained some insight about the downside of creating indexes:
if you write into a table (&lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt;) with one index, you have actually two writing operations in the file system. One for the table data and another one for the index data (and the resorting of it (and - if clustered - the resorting of the table data)). If table and index are located on the same hard disk this costs more time. Thus a table without an index (a heap) , would allow for quicker write operations. (if you had two indexes you would end up with three write operations, and so on)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Desde entonces, obtuve algunas ideas sobre la desventaja de crear &amp;iacute;ndices: si escribe en una tabla ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;UPDATE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; o &lt;/font&gt;&lt;/font&gt; &lt;code&gt;INSERT&lt;/code&gt; AR&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) con un &amp;iacute;ndice, en realidad tiene dos operaciones de escritura en el sistema de archivos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Uno para los datos de la tabla y otro para los datos del &amp;iacute;ndice (y el recurso de los mismos (y, si est&amp;aacute;n agrupados, el recurso de los datos de la tabla)). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si la tabla y el &amp;iacute;ndice se encuentran en el mismo disco duro, esto cuesta m&amp;aacute;s tiempo. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, una tabla sin &amp;iacute;ndice (un mont&amp;oacute;n) permitir&amp;iacute;a operaciones de escritura m&amp;aacute;s r&amp;aacute;pidas. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(si tuviera dos &amp;iacute;ndices, terminar&amp;iacute;a con tres operaciones de escritura, etc.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="adecf93f2acfab3a69649212fe2efb7426f23e48" translate="yes" xml:space="preserve">
          <source>So now the database will use the index to find employees named John
  because the index will presumably be sorted alphabetically by the
  Users name. And, because it is sorted, it means searching for a name
  is a lot faster because all names starting with a &amp;ldquo;J&amp;rdquo; will be right
  next to each other in the index!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Entonces, la base de datos usar&amp;aacute; el &amp;iacute;ndice para encontrar empleados llamados John porque el &amp;iacute;ndice probablemente se ordenar&amp;aacute; alfab&amp;eacute;ticamente por el nombre de los usuarios. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y, como est&amp;aacute; ordenado, significa que buscar un nombre es mucho m&amp;aacute;s r&amp;aacute;pido porque todos los nombres que comienzan con una &quot;J&quot; estar&amp;aacute;n uno al lado del otro en el &amp;iacute;ndice.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="26471d745a61045c6728ede7f132a76a50811d84" translate="yes" xml:space="preserve">
          <source>The database software would literally have to look at every single row in the &lt;code&gt;User&lt;/code&gt; table to see if the &lt;code&gt;Name&lt;/code&gt; for that row is &amp;lsquo;John&amp;rsquo;. This will take a long time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El software de la base de datos literalmente tendr&amp;iacute;a que mirar cada fila en la &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;tabla de &lt;/font&gt;&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para ver si el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; de esa fila es 'John'. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto llevar&amp;aacute; un largo tiempo.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92388142fd95760bd53d3617559908024063026c" translate="yes" xml:space="preserve">
          <source>The downside to indexing is that these indices require additional space on the disk since the indices are stored together in a table using the MyISAM engine, this file can quickly reach the size limits of the underlying file system if many fields within the same table are indexed.</source>
          <target state="translated">El inconveniente de la indexación es que estos índices requieren espacio adicional en el disco,ya que los índices se almacenan juntos en una tabla utilizando el motor MyISAM,este archivo puede alcanzar rápidamente los límites de tamaño del sistema de archivos subyacente si se indexan muchos campos dentro de la misma tabla.</target>
        </trans-unit>
        <trans-unit id="7d8c6667f49892d4041edae513099ceacb903c2e" translate="yes" xml:space="preserve">
          <source>The first time I read this it was very helpful to me. Thank you.</source>
          <target state="translated">La primera vez que leí esto fue muy útil para mí.Gracias.</target>
        </trans-unit>
        <trans-unit id="6ab7299d1206cde9db1d5f739db12c3075d44567" translate="yes" xml:space="preserve">
          <source>The index is nothing but a data structure that &lt;strong&gt;stores the values for a specific column&lt;/strong&gt; in a table. An index is created on a column of a table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El &amp;iacute;ndice no es m&amp;aacute;s que una estructura de datos que &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;almacena los valores para una columna espec&amp;iacute;fica&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en una tabla. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Se crea un &amp;iacute;ndice en una columna de una tabla.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="126caeb9af8c72c10dc8b6168e0b5dd59a87df45" translate="yes" xml:space="preserve">
          <source>The reason B- trees are the most popular data structure for indexes is due to the fact that they are time efficient &amp;ndash; because look-ups, deletions, and insertions can all be done in logarithmic time. And, another major reason B- trees are more commonly used is because the data that is stored inside the B- tree can be sorted. The RDBMS typically determines which data structure is actually used for an index. But, in some scenarios with certain RDBMS&amp;rsquo;s, you can actually specify which data structure you want your database to use when you create the index itself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La raz&amp;oacute;n por la que los &amp;aacute;rboles B son la estructura de datos m&amp;aacute;s popular para los &amp;iacute;ndices se debe al hecho de que son eficientes en el tiempo, ya que las b&amp;uacute;squedas, eliminaciones e inserciones se pueden realizar en tiempo logar&amp;iacute;tmico. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Y, otra raz&amp;oacute;n principal por la que los &amp;aacute;rboles B se usan m&amp;aacute;s com&amp;uacute;nmente es porque los datos que se almacenan dentro del &amp;aacute;rbol B se pueden ordenar. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El RDBMS generalmente determina qu&amp;eacute; estructura de datos se usa realmente para un &amp;iacute;ndice. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Pero, en algunos escenarios con ciertos RDBMS, puede especificar qu&amp;eacute; estructura de datos desea que use su base de datos cuando cree el &amp;iacute;ndice.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef4d79676e50d3782a878b91406b5f00f4a58cd0" translate="yes" xml:space="preserve">
          <source>The reason hash indexes are used is because hash tables are extremely efficient when it comes to just looking up values. So, queries that compare for equality to a string can retrieve values very fast if they use a hash index.</source>
          <target state="translated">La razón por la que se utilizan los índices hash es porque las tablas hash son extremadamente eficientes cuando se trata de buscar valores.Así,las consultas que se comparan por igualdad con una cadena pueden recuperar valores muy rápidamente si utilizan un índice hash.</target>
        </trans-unit>
        <trans-unit id="257d302baeb4a014b97399cca558bbb83e525e5d" translate="yes" xml:space="preserve">
          <source>The whole point of having an index is to speed up search queries by essentially cutting down the number of records/rows in a table that need to be examined. An index is a data structure (most commonly a B- tree) that stores the values for a specific column in a table.</source>
          <target state="translated">El objetivo de tener un índice es acelerar las consultas de búsqueda reduciendo esencialmente el número de filas de registros de una tabla que deben ser examinadas.Un índice es una estructura de datos (más comúnmente un árbol B-)que almacena los valores de una columna específica en una tabla.</target>
        </trans-unit>
        <trans-unit id="a4f5d021fd61272cfc727ba4d28ac004f08424f2" translate="yes" xml:space="preserve">
          <source>Things are simple in schools, isn't it? :P</source>
          <target state="translated">Las cosas son simples en las escuelas,¿no? :P</target>
        </trans-unit>
        <trans-unit id="7503b65320d9c1b258a3d69a2f77ffa5cb85b3fa" translate="yes" xml:space="preserve">
          <source>This analogy is known as &lt;strong&gt;&quot;Full Table Scan&quot;&lt;/strong&gt; in database world.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esta analog&amp;iacute;a se conoce como &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;Full Table Scan&quot;&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en el mundo de la base de datos.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="814e34b9dbc0414d8df43d75cfeebb5d902126ee" translate="yes" xml:space="preserve">
          <source>This is where &lt;code&gt;index&lt;/code&gt; helps us: &lt;em&gt;index is used to speed up search queries by essentially cutting down the number of records/rows in a table that needs to be examined&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Aqu&amp;iacute; es donde el &lt;/font&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; nos ayuda: el &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iacute;ndice se utiliza para acelerar las consultas de b&amp;uacute;squeda al reducir esencialmente el n&amp;uacute;mero de registros / filas en una tabla que debe examinarse&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eae407d68bea00f32c03361bd34649b638b74dd0" translate="yes" xml:space="preserve">
          <source>Thus, the index is a separate section that stores values of indexed
  column + pointer to the indexed row in a sorted order for efficient
  look-ups.</source>
          <target state="translated">Por lo tanto,el índice es una sección separada que almacena los valores de la columna indexada+el puntero a la fila indexada en un orden ordenado para una búsqueda eficiente.</target>
        </trans-unit>
        <trans-unit id="3388f2a0255a47ceeb6050962fbb9511180c8d29" translate="yes" xml:space="preserve">
          <source>What columns generally make good indexes?</source>
          <target state="translated">¿Qué columnas suelen ser buenos índices?</target>
        </trans-unit>
        <trans-unit id="e6f1df688c30d94eb68a3bb0fa23154aa1e18bc3" translate="yes" xml:space="preserve">
          <source>When data is stored on disk-based storage devices, it is stored as blocks of data. These blocks are accessed in their entirety, making them the atomic disk access operation. Disk blocks are structured in much the same way as linked lists; both contain a section for data, a pointer to the location of the next node (or block), and both need not be stored contiguously.</source>
          <target state="translated">Cuando los datos se almacenan en dispositivos de almacenamiento en disco,se almacenan como bloques de datos.Se accede a estos bloques en su totalidad,convirtiéndolos en la operación de acceso al disco atómico.Los bloques de disco están estructurados de manera muy similar a las listas vinculadas;ambos contienen una sección de datos,un puntero a la ubicación del siguiente nodo (o bloque),y no es necesario que ambos se almacenen de manera contigua.</target>
        </trans-unit>
        <trans-unit id="93a2555206a0af83fbe551a83137431c161ed8c6" translate="yes" xml:space="preserve">
          <source>Whereas with a sorted field, a Binary Search may be used, which has &lt;code&gt;log2 N&lt;/code&gt; block accesses. Also since the data is sorted given a non-key field, the rest of the table doesn&amp;rsquo;t need to be searched for duplicate values, once a higher value is found. Thus the performance increase is substantial.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Mientras que con un campo ordenado, se puede utilizar una b&amp;uacute;squeda binaria, que tiene &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;accesos de bloque &lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 N&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adem&amp;aacute;s, dado que los datos se ordenan dado un campo no clave, no es necesario buscar valores duplicados en el resto de la tabla una vez que se encuentra un valor m&amp;aacute;s alto. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, el aumento del rendimiento es sustancial.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b533efcb68c06cbb661f675f72076a2242fa3ed" translate="yes" xml:space="preserve">
          <source>e.g:- If you have lots of rivalling writes but only one nightly read outside business hours for reporting.</source>
          <target state="translated">e.g:-Si tienes muchos escritos rivales pero sólo una lectura nocturna fuera de las horas de trabajo para informar.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
