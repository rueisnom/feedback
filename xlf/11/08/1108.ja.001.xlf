<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1108">
    <body>
      <group id="1108">
        <trans-unit id="7c6f976f4e1f247357643420b0f1d5edff13eef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Example 1&lt;/em&gt;&lt;/strong&gt; - &lt;em&gt;sorted vs unsorted fields&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例1&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ソートされていないフィールド対ソート&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ad6ea987ddb5784c13bde986d9834b1b8aa7cc8e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;Example 2&lt;/em&gt;&lt;/strong&gt;  - &lt;em&gt;indexing&lt;/em&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例2&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;索引&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c263d6e1ec3808a54cf13984a9ccf2fe20c030b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How a database index can help performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;データベースインデックスがパフォーマンスにどのように役立つか&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ee6c6ffc954bb7d8e7f64c641b17ff3a602b455" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does B-trees index work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Bツリーインデックスはどのように機能しますか？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1038135901ca45cbc26e89cf4438b522835561bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does a database know when to use an index?&lt;/strong&gt;
When a query like &amp;ldquo;SELECT * FROM Employee WHERE Employee_Name = &amp;lsquo;Abc&amp;rsquo; &amp;rdquo; is run, the database will check to see if there is an index on the column(s) being queried. Assuming the Employee_Name column does have an index created on it, the database will have to decide whether it actually makes sense to use the index to find the values being searched &amp;ndash; because there are some scenarios where it is actually less efficient to use the database index, and more efficient just to scan the entire table.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;データベースは、インデックスをいつ使用するかをどのようにして知るのですか？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 「SELECT * FROM Employee WHERE Employee_Name = 'Abc'」のようなクエリが実行されると、データベースは、クエリ対象の列にインデックスがあるかどうかを確認します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Employee_Name列にインデックスが作成されていると仮定すると、データベースは、インデックスを使用して検索される値を見つけることが実際に意味があるかどうかを判断する必要があります。 、そしてテーブル全体をスキャンするだけでより効率的です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ff64d04a079079f647ecb61630eba86649659ead" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does a hash table index work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハッシュテーブルインデックスはどのように機能しますか？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c1ec9f40f4edd7eb75f8f619aa77433ee58d89b6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How does it work?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それはどのように機能しますか？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7776d2a490f8e3aaac3f9ca4505cab9d20b38b23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: Pointers in MySQL are 2, 3, 4 or 5 bytes in length depending on the size of the table.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：MySQLのポインタは、テーブルのサイズに応じて、長さが2、3、4、または5バイトです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d1f023e6a4d3bc1e8bf916bde9bbdd1bedb1d70d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt;: char was used in place of varchar to allow for an accurate size on disk value. 
This sample database contains five million rows and is unindexed. The performance of several queries will now be analyzed. These are a query using the &lt;em&gt;id&lt;/em&gt; (a sorted key field) and one using the &lt;em&gt;firstName&lt;/em&gt; (a non-key unsorted field).</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：varcharの代わりにcharを使用して、ディスク上の正確なサイズの値を可能にしました。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このサンプルデータベースには500万行が含まれ、インデックス付けされていません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;いくつかのクエリのパフォーマンスが分析されます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これらは、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;id&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（ソートされたキーフィールド）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用したクエリ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（キー以外のソートされていないフィールド）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用したクエリ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e55a4eef1abc15fd25c68f22657b346ff3abdb11" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Description!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;簡単な説明！&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5f4ae4a04e94c61d13e11443fa35cbf4c8957624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The disadvantages of a hash index&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハッシュインデックスの欠点&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d60b2311316bf1641d865996eaab467baf68c7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What exactly is inside a database index?&lt;/strong&gt;
So, now you know that a database index is created on a column in a table, and that the index stores the values in that specific column. But, it is important to understand that a database index does not store the values in the other columns of the same table. For example, if we create an index on the Employee_Name column, this means that the Employee_Age and Employee_Address column values are not also stored in the index. If we did just store all the other columns in the index, then it would be just like creating another copy of the entire table &amp;ndash; which would take up way too much space and would be very inefficient.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正確にはデータベースインデックスの内部には何がありますか？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; これで、データベースインデックスがテーブルの列に作成され、その特定の列に値がインデックスに格納されることがわかりました。ただし、データベースインデックスは同じテーブルの他の列に値を格納しないことを理解することが重要です。たとえば、Employee_Name列にインデックスを作成する場合、これはEmployee_Age列とEmployee_Address列の値もインデックスに格納されないことを意味します。インデックスに他のすべての列を格納しただけの場合は、テーブル全体の別のコピーを作成するのと同じです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6428ecc202198be70cb1f1755663fa9831bc29a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is indexing?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;索引付けとは何ですか？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="66754d988f4fcb1acc4a50297f2aadea10736289" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is the cost of having a database index?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;データベースインデックスを作成するコストはどのくらいですか？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e16a9f89c5c9cad39f49b095ddeef61be6287223" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What would happen without an index?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インデックスがないとどうなりますか？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ba497667b700161a0513bd86c14414feabb5a6a1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;When should it be used?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;いつ使用すべきですか？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c650694413b8d8c8e0547a99830e7752b6f6fb74" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why is it needed?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;なぜそれが必要なのですか？&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fadfcc0b3b5611c6320a2347916ace1ab3378c3e" translate="yes" xml:space="preserve">
          <source>A linear search on the id field would require an average of &lt;code&gt;N/2 = 500,000&lt;/code&gt; block accesses to find a value, given that the id field is a key field. But since the id field is also sorted, a binary search can be conducted requiring an average of &lt;code&gt;log2 1000000 = 19.93 = 20&lt;/code&gt; block accesses. Instantly we can see this is a drastic improvement.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;idフィールドがキーフィールドである場合、&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;idフィールドの線形検索では&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、値を見つけるために&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;平均&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N/2 = 500,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブロックアクセス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が必要になり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;しかし、idフィールドもソートされているため、平均で&lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 1000000 = 19.93 = 20&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブロックアクセスを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;必要とするバイナリ検索を実行できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは劇的な改善であることがすぐにわかります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="71f1a10902b7a8ccbae4cdba11a0b434fe2b432e" translate="yes" xml:space="preserve">
          <source>Also, a differentiation between clustered and non-clustered indexes is rather important.</source>
          <target state="translated">また、クラスター化されたインデックスと非クラスター化されたインデックスの区別もむしろ重要です。</target>
        </trans-unit>
        <trans-unit id="f959491d8665d67cf85a2cc9b96a16ed6e7c0149" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;index&lt;/code&gt; consists of &lt;strong&gt;column values(Eg: John) from one table&lt;/strong&gt;, and those values are stored in a &lt;strong&gt;data structure&lt;/strong&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;から成る&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;列の値（例：ジョン）のテーブルから&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、それらの値はに格納され&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たデータ構造&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1ad74fb25accebf8d6e8d23b44a80acc6acebc0d" translate="yes" xml:space="preserve">
          <source>An index is just a data structure that makes the searching faster for a specific column in a database. This structure is usually a b-tree or a hash table but it can be any other logic structure.</source>
          <target state="translated">インデックスとは、データベース内の特定のカラムの検索を高速化するデータ構造のことです。この構造体は通常b-treeやハッシュテーブルですが、他の論理構造体であっても構いません。</target>
        </trans-unit>
        <trans-unit id="ae0587c6babe222342305dc974d0c1ee2fec283f" translate="yes" xml:space="preserve">
          <source>Another option is that, you could just go to the Index section of the book and then find what you are looking for by using the Name of the entity you are looking ( in this instance, German Shepherds) and also looking at the page number to quickly find what you are looking for.</source>
          <target state="translated">もう一つの選択肢は、本のインデックスセクションに行き、探しているものを見つけるために、探している実体の名前(この例では、ジャーマンシェパード)を使用して、また、あなたが探しているものを迅速に見つけるためにページ番号を見ることができるということです。</target>
        </trans-unit>
        <trans-unit id="a42223342f004e5087636b0bd93ed01b59e5befd" translate="yes" xml:space="preserve">
          <source>Another problem with indexes is their fragmentation over time as data is inserted. &lt;code&gt;REORGANIZE&lt;/code&gt; helps, you must write routines to have it done.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インデックスに関するもう1つの問題は、データが挿入されるときのインデックスの断片化です。&lt;/font&gt;&lt;/font&gt; &lt;code&gt;REORGANIZE&lt;/code&gt; が&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;役立ちます。それを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;するには、ルーチンを作成する必要があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="670ae6c441f98e2a78f5820d589187b5910ea31c" translate="yes" xml:space="preserve">
          <source>As a general rule, an index should only be created on a table if the data in the indexed column will be queried frequently.</source>
          <target state="translated">原則として、インデックスが作成されるのは、インデックスが作成された列のデータが頻繁にクエリされる場合にのみ、テーブルにインデックスを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="06a4b006b5c2d9087ce316cf7000e63a79bca581" translate="yes" xml:space="preserve">
          <source>But then, in addition to actual 1000 pages, you will need another ~10 pages to show the indices, so totally 1010 pages.</source>
          <target state="translated">しかし、その後、実際の1000ページに加えて、あなたはインデックスを表示するために別の〜10ページが必要になりますので、完全に1010ページ。</target>
        </trans-unit>
        <trans-unit id="3d71c21621662c8be4c6dce7fd281e97dfd2c30e" translate="yes" xml:space="preserve">
          <source>But with an index page, you know where to go! And more, to lookup any particular Chapter that matters, you just need to look over the index page, again and again, every time. After finding the matching index you can efficiently jump to that chapter by skipping the rest.</source>
          <target state="translated">しかし、インデックスページがあれば、どこに行けばいいのかがわかります。さらに、重要な特定の章を調べるためには、インデックスページに何度も何度も目を通す必要があります。マッチするインデックスを見つけた後は、残りの部分をスキップして、効率的にその章にジャンプすることができます。</target>
        </trans-unit>
        <trans-unit id="a2aeece8a7e18f9f6165280d858250ef5c41a36b" translate="yes" xml:space="preserve">
          <source>Classic example &lt;strong&gt;&quot;Index in Books&quot;&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;古典的な例&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「本の索引」&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="edfadc138c324a28c0ad48b4568b1c93f50ae608" translate="yes" xml:space="preserve">
          <source>Consider a &quot;Book&quot; of 1000 pages, divided by 10 Chapters, each section with 100 pages.</source>
          <target state="translated">1000ページの「本」を10章100ページで分割して考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="ccace75fa9dc2dfab316381c595f1cee029a29da" translate="yes" xml:space="preserve">
          <source>Database software would literally have to look at every single row in the Employee table to see if the Employee_Name for that row is &amp;lsquo;Abc&amp;rsquo;. And, because we want every row with the name &amp;lsquo;Abc&amp;rsquo; inside it, we can not just stop looking once we find just one row with the name &amp;lsquo;Abc&amp;rsquo;, because there could be other rows with the name &lt;strong&gt;Abc&lt;/strong&gt;. So, every row up until the last row must be searched &amp;ndash; which means thousands of rows in this scenario will have to be examined by the database to find the rows with the name &amp;lsquo;Abc&amp;rsquo;. This is what is called a &lt;strong&gt;full table scan&lt;/strong&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;データベースソフトウェアは、その行のEmployee_Nameが 'Abc'であるかどうかを確認するために、文字どおりEmployeeテーブルのすべての行を調べる必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我々はその中に名前「ABC」ですべての行をしたいので、我々は名前「ABC」でただ一つの行を見つけたら、名前を持つ他の行があるかもしれませんのでそして、私たちは、探して停止することはできません&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Abcの&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、最後の行までのすべての行を検索する必要があります。つまり、このシナリオでは数千の行をデータベースで調べて、「Abc」という名前の行を見つける必要があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これはいわゆる&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;全表スキャンです&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ceb478c45cb9fe55a55150694c3e2f7c5bd8f32f" translate="yes" xml:space="preserve">
          <source>Due to the fact that a number of records can only be sorted on one field, we can state that searching on a field that isn&amp;rsquo;t sorted requires a Linear Search which requires &lt;code&gt;N/2&lt;/code&gt; block accesses (on average), where &lt;code&gt;N&lt;/code&gt; is the number of blocks that the table spans. If that field is a non-key field (i.e. doesn&amp;rsquo;t contain unique entries) then the entire tablespace must be searched at &lt;code&gt;N&lt;/code&gt; block accesses.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;いくつかのレコードは1つのフィールドでのみ並べ替えることができるため、並べ替えられていないフィールドの検索には、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N/2&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブロックアクセス（平均）&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を必要とする線形検索が必要であると説明できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。ここで、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はテーブルがまたがるブロックの数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;そのフィールドが非キーフィールド（つまり、一意のエントリを含まない）の場合、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブロックアクセス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;でテーブルスペース全体を検索する必要があります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e5bc6d47e649819c256f1169901b6aa5852d68ce" translate="yes" xml:space="preserve">
          <source>Example: We have a database table called &lt;code&gt;User&lt;/code&gt; with three columns &amp;ndash; &lt;code&gt;Name&lt;/code&gt;, &lt;code&gt;Age&lt;/code&gt; and &lt;code&gt;Address&lt;/code&gt;. Assume that the &lt;code&gt;User&lt;/code&gt; table has thousands of rows.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例：&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt; &lt;code&gt;Age&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;、&lt;/font&gt; &lt;code&gt;Address&lt;/code&gt; という&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 3つの列&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を持つ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;というデータベーステーブルがあります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;テーブルに数千の行がある&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;と仮定し&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6dfb64751c4bd0fadd0aadce8f3a9bec1f87f196" translate="yes" xml:space="preserve">
          <source>Firstly, let&amp;rsquo;s outline a sample database table schema;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最初に、サンプルのデータベーステーブルスキーマの概要を説明します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67a6b5de80a5587dd3df63bd3b5cd82d3ef329d8" translate="yes" xml:space="preserve">
          <source>For information on queries to index a field, check out &lt;a href=&quot;https://stackoverflow.com/questions/1156/&quot;&gt;How do I index a database column&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;フィールドにインデックスを付けるクエリの詳細については&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1156/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、データベースの列にインデックスを付ける方法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;をご覧ください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a56b08d796085fa51779969ead12eba0cdf923dc" translate="yes" xml:space="preserve">
          <source>For instance, the query we discussed earlier could benefit from a hash index created on the Employee_Name column. The way a hash index would work is that the column value will be the key into the hash table and the actual value mapped to that key would just be a pointer to the row data in the table. Since a hash table is basically an associative array, a typical entry would look something like &amp;ldquo;Abc =&amp;gt; 0x28939&amp;Prime;, where 0x28939 is a reference to the table row where Abc is stored in memory. Looking up a value like &amp;ldquo;Abc&amp;rdquo; in a hash table index and getting back a reference to the row in memory is obviously a lot faster than scanning the table to find all the rows with a value of &amp;ldquo;Abc&amp;rdquo; in the Employee_Name column.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえば、前に説明したクエリは、Employee_Name列に作成されたハッシュインデックスの恩恵を受けることができます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハッシュインデックスが機能する方法は、列の値がハッシュテーブルへのキーになり、そのキーにマップされた実際の値がテーブルの行データへのポインターになることです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハッシュテーブルは基本的に連想配列であるため、一般的なエントリは「Abc =&amp;gt; 0x28939」のようになります。0x28939は、Abcがメモリに格納されているテーブル行への参照です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハッシュテーブルインデックスで「Abc」などの値を検索し、メモリ内の行への参照を取得する方が、テーブルをスキャンしてEmployee_Name列に「Abc」の値を持つすべての行を見つけるよりも明らかに高速です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ba744e72c82249823f810b1d800ca0c81ff406e9" translate="yes" xml:space="preserve">
          <source>Given our sample database of &lt;code&gt;r = 5,000,000&lt;/code&gt; records of a fixed size giving a record length of &lt;code&gt;R = 204&lt;/code&gt; bytes and they are stored in a table using the MyISAM engine which is using the default block size &lt;code&gt;B = 1,024&lt;/code&gt; bytes. The blocking factor of the table would be &lt;code&gt;bfr = (B/R) = 1024/204 = 5&lt;/code&gt; records per disk block. The total number of blocks required to hold the table is &lt;code&gt;N = (r/bfr) = 5000000/5 = 1,000,000&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;r = 5,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;レコードの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;サンプルデータベースが&lt;/font&gt;&lt;/font&gt; &lt;code&gt;R = 204&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;バイトの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;レコード長を与える固定長の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;場合、デフォルトのブロックサイズ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;B = 1,024&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;バイト&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用するMyISAMエンジンを使用してテーブルに格納され&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;テーブルのブロック化係数は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;bfr = (B/R) = 1024/204 = 5&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ディスクブロックあたり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;5&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;レコードになります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;テーブルを保持するために必要なブロックの総数は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N = (r/bfr) = 5000000/5 = 1,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブロックです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9a612a719bfeff12051ef62ec18b988c42d957b8" translate="yes" xml:space="preserve">
          <source>Given our sample database of &lt;code&gt;r = 5,000,000&lt;/code&gt; records with an index record length of &lt;code&gt;R = 54&lt;/code&gt; bytes and using the default block size &lt;code&gt;B = 1,024&lt;/code&gt; bytes. The blocking factor of the index would be &lt;code&gt;bfr = (B/R) = 1024/54 = 18&lt;/code&gt; records per disk block. The total number of blocks required to hold the index is &lt;code&gt;N = (r/bfr) = 5000000/18 = 277,778&lt;/code&gt; blocks.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;サンプルデータベースが&lt;/font&gt;&lt;/font&gt; &lt;code&gt;r = 5,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;レコードで、インデックスレコード長が&lt;/font&gt;&lt;/font&gt; &lt;code&gt;R = 54&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;バイトで、デフォルトのブロックサイズ&lt;/font&gt;&lt;/font&gt; &lt;code&gt;B = 1,024&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;バイト&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用しているとし&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。インデックスのブロック化係数は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;bfr = (B/R) = 1024/54 = 18&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ディスクブロックあたり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;18&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;レコードになります。インデックスを保持するために必要なブロックの総数は、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N = (r/bfr) = 5000000/18 = 277,778&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブロックです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="67d7d36ed55f5b6ce5bb067162a83dc511e7fd79" translate="yes" xml:space="preserve">
          <source>Given that an index record contains only the indexed field and a pointer to the original record, it stands to reason that it will be smaller than the multi-field record that it points to. So the index itself requires fewer disk blocks than the original table, which therefore requires fewer block accesses to iterate through. The schema for an index on the &lt;em&gt;firstName&lt;/em&gt; field is outlined below;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インデックスレコードにインデックス付きフィールドと元のレコードへのポインターのみが含まれている場合、それが指すマルチフィールドレコードよりも小さくなることは当然です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、インデックス自体は元のテーブルよりも少ないディスクブロックしか必要としないため、反復処理に必要なブロックアクセスが少なくなります。&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;フィールドの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インデックスのスキーマの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;概要を以下に示します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b8a40897243ff8b8b9b81a535752ccc504133a4" translate="yes" xml:space="preserve">
          <source>Given that creating an index requires additional disk space (277,778 blocks extra from the above example, a ~28% increase), and that too many indices can cause issues arising from the file systems size limits, careful thought must be used to select the correct fields to index.</source>
          <target state="translated">インデックスの作成には追加のディスク容量が必要であり(上記の例から277,778ブロック、約28%の増加)、インデックスが多すぎるとファイルシステムのサイズ制限に起因する問題を引き起こす可能性があることを考えると、インデックスを作成するための正しいフィールドを選択するためには慎重に考えなければなりません。</target>
        </trans-unit>
        <trans-unit id="6560699d2bd8f61f1f9e9e79eda860b41d744347" translate="yes" xml:space="preserve">
          <source>Given that indexing is so important as your data set increases in size, can someone explain how indexing works at a database-agnostic level?</source>
          <target state="translated">データセットのサイズが大きくなるにつれてインデックス作成が非常に重要になることを考えると、誰かデータベースにとらわれないレベルでインデックス作成がどのように機能するかを説明してくれませんか?</target>
        </trans-unit>
        <trans-unit id="32a8bd6432ae70cef621c292e079e404b892ba3b" translate="yes" xml:space="preserve">
          <source>Hash tables are not sorted data structures, and there are many types of queries which hash indexes can not even help with. For instance, suppose you want to find out all of the employees who are less than 40 years old. How could you do that with a hash table index? Well, it&amp;rsquo;s not possible because a hash table is only good for looking up key value pairs &amp;ndash; which means queries that check for equality</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ハッシュテーブルは並べ替えられたデータ構造ではなく、ハッシュインデックスが役に立たない多くの種類のクエリがあります。たとえば、40歳未満のすべての従業員を検索するとします。ハッシュテーブルインデックスを使用してどうすればよいでしょうか。まあ、それは不可能です。ハッシュテーブルはキーと値のペアを検索する場合にのみ有効です。つまり、等価性をチェックするクエリです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d21860c9c34e97854024389404de25905618ed2" translate="yes" xml:space="preserve">
          <source>Helped me:- &lt;a href=&quot;https://stackoverflow.com/questions/1251636/what-do-clustered-and-non-clustered-index-actually-mean&quot;&gt;What do Clustered and Non clustered index actually mean?&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私を助けました：- &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1251636/what-do-clustered-and-non-clustered-index-actually-mean&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;クラスタ化インデックスと非クラスタ化インデックスは実際にはどういう意味ですか？&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d3cca3a8a00a3a45f0a5c76f372683f44b7b1881" translate="yes" xml:space="preserve">
          <source>How do database indexes work</source>
          <target state="translated">データベースのインデックスはどのように動作するのか</target>
        </trans-unit>
        <trans-unit id="5452e26c95523ae9f9b07a1f3bae3db9dbe68101" translate="yes" xml:space="preserve">
          <source>How does database indexing work</source>
          <target state="translated">データベースのインデックス作成はどのようにして行われるのか</target>
        </trans-unit>
        <trans-unit id="7df16cfacc6d28d0dec6ecd7f0a8c16905729906" translate="yes" xml:space="preserve">
          <source>How to create an index:</source>
          <target state="translated">インデックスの作成方法。</target>
        </trans-unit>
        <trans-unit id="e9a156ac7af5ee1f8d9b1e3dfc529d5d31e2a992" translate="yes" xml:space="preserve">
          <source>However, defining two different locations on two different hard disks for index data and table data can decrease/eliminate the problem of increased cost of time. This requires definition of additional file groups with according files on the desired hard disks and definition of table/index location as desired.</source>
          <target state="translated">しかし、インデックスデータとテーブルデータのために2つの異なるハードディスク上の2つの異なる場所を定義することは、時間的なコストの増加という問題を減少させることができる。このためには、所望のハードディスク上に対応するファイルを有するファイル群を追加で定義し、所望に応じてtableindexの位置を定義する必要がある。</target>
        </trans-unit>
        <trans-unit id="ef380204ad169fc2292c6fa188d9c6d356f78f84" translate="yes" xml:space="preserve">
          <source>If you have a book about dogs and you want to find an information about let's say, German Shepherds, you could of course flip through all the pages of the book and find what you are looking for  - but this of course is time consuming and not very fast.</source>
          <target state="translated">もしあなたが犬についての本を持っていて、ジャーマンシェパードについての情報を見つけたい場合は、もちろん本のすべてのページをめくって探しているものを見つけることができます-しかし、これはもちろん時間がかかりますし、あまり速くはありません。</target>
        </trans-unit>
        <trans-unit id="d8f04bd94bd160a1d96d45d2529a31258e82a393" translate="yes" xml:space="preserve">
          <source>In Database, the page number is referred to as a pointer which directs the database to the address on the disk where entity is located. Using the same German Shepherd analogy, we could have something like this (&amp;ldquo;German Shepherd&amp;rdquo;, 0x77129) where &lt;code&gt;0x77129&lt;/code&gt; is the address on the disk where the row data for German Shepherd is stored.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;データベースでは、ページ番号は、エンティティが配置されているディスク上のアドレスにデータベースを転送するポインタと呼ばれます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同じジャーマンシェパードの例えを使用すると、次のようになります（「ジャーマンシェパード」、0x77129）&lt;/font&gt;&lt;/font&gt; &lt;code&gt;0x77129&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はジャーマンシェパードの行データが格納されているディスク上のアドレスです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ef1c79649a1ffa63f8f1acd27875a9fcc448b06" translate="yes" xml:space="preserve">
          <source>In certain scenarios a heap is more helpful than a table with indexes,</source>
          <target state="translated">特定のシナリオでは、インデックスを持つテーブルよりもヒープの方が有用です。</target>
        </trans-unit>
        <trans-unit id="c571b07f97ec082a06642bacb56f5d9267f7fdae" translate="yes" xml:space="preserve">
          <source>In short, an index is a data structure that stores the values for a specific column in a table so as to speed up query search.</source>
          <target state="translated">つまり、インデックスとは、クエリ検索を高速化するために、テーブル内の特定の列の値を格納するデータ構造のことです。</target>
        </trans-unit>
        <trans-unit id="8e8e8ce6c1f5d8d1d05614c2f29659055232953f" translate="yes" xml:space="preserve">
          <source>Indexing is a way of sorting a number of records on multiple fields. Creating an index on a field in a table creates another data structure which holds the field value, and a pointer to the record it relates to. This index structure is then sorted, allowing Binary Searches to be performed on it.</source>
          <target state="translated">インデックス作成は、複数のフィールド上の多数のレコードを並べ替える方法です。テーブル内のフィールドにインデックスを作成すると、フィールドの値を保持する別のデータ構造体が作成され、それが関連するレコードへのポインタが作成されます。このインデックス構造体がソートされ、バイナリ検索を実行できるようになります。</target>
        </trans-unit>
        <trans-unit id="a611240736d03bf16b06eb89c51008f6b823f25d" translate="yes" xml:space="preserve">
          <source>It takes up space &amp;ndash; and the larger your table, the larger your index. Another performance hit with indexes is the fact that whenever you add, delete, or update rows in the corresponding table, the same operations will have to be done to your index. Remember that an index needs to contain the same up to the minute data as whatever is in the table column(s) that the index covers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;スペースを使用します。テーブルが大きいほど、インデックスも大きくなります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インデックスのもう1つのパフォーマンスヒットは、対応するテーブルの行を追加、削除、または更新するたびに、同じ操作をインデックスに対して実行する必要があるという事実です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インデックスには、インデックスがカバーするテーブルの列にあるものと同じ分までのデータを含める必要があることに注意してください。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="276b5a9e7eafc9116c94af7c4302e336bba600a7" translate="yes" xml:space="preserve">
          <source>Just a quick suggestion.. As indexing costs you additional writes and storage space, so if your application requires more insert/update operation, you might want to use tables without indexes, but if it requires more data retrieval operations, you should go for indexed table.</source>
          <target state="translated">ちょっとした提案ですが...。インデックスを使用すると、追加の書き込みとストレージ容量がかかるので、アプリケーションがより多くのinsertupdate操作を必要とする場合は、インデックスなしのテーブルを使用したい場合がありますが、それはより多くのデータ検索操作を必要とする場合は、インデックス付きのテーブルのために行く必要があります。</target>
        </trans-unit>
        <trans-unit id="79473d1d1fae832de50165b98ed9730e2335bcff" translate="yes" xml:space="preserve">
          <source>Just think of Database Index as Index of a book.</source>
          <target state="translated">データベースインデックスは本のインデックスだと思ってください。</target>
        </trans-unit>
        <trans-unit id="9e6820fb508cdfb4143176447ba4ee4022ec87ef" translate="yes" xml:space="preserve">
          <source>Now a search using the &lt;em&gt;firstName&lt;/em&gt; field can utilize the index to increase performance. This allows for a binary search of the index with an average of &lt;code&gt;log2 277778 = 18.08 = 19&lt;/code&gt; block accesses. To find the address of the actual record, which requires a further block access to read, bringing the total to &lt;code&gt;19 + 1 = 20&lt;/code&gt; block accesses, a far cry from the 1,000,000 block accesses required to find a &lt;em&gt;firstName&lt;/em&gt; match in the non-indexed table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これで、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;フィールド&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を使用した検索で&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インデックスを利用してパフォーマンスを向上させることができます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これにより、平均&lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 277778 = 18.08 = 19&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブロックアクセス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のインデックスのバイナリ検索が可能になります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;実際のレコードのアドレスを見つけるには、読み取りにさらにブロックアクセスが必要であり、合計で&lt;/font&gt;&lt;/font&gt; &lt;code&gt;19 + 1 = 20&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブロックアクセスになります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;非インデックステーブルで&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstNameの&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一致&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を見つけるのに必要な1,000,000ブロックアクセスとはかけ離れて&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;います。 。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a62e94584fca0d632abdef6d650cf49c229bbe33" translate="yes" xml:space="preserve">
          <source>Now the &lt;em&gt;firstName&lt;/em&gt; field is neither sorted nor a key field, so a binary search is impossible, nor are the values unique, and thus the table will require searching to the end for an exact &lt;code&gt;N = 1,000,000&lt;/code&gt; block accesses. It is this situation that indexing aims to correct.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これで、&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;firstName&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;フィールドはソートされず、キーフィールドでもないため、バイナリ検索は不可能であり、値も一意ではないため、テーブルは、正確な&lt;/font&gt;&lt;/font&gt; &lt;code&gt;N = 1,000,000&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブロックアクセスの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ために最後まで検索する必要があり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インデックス作成が修正を目的とするのはこの状況です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="50cbc01eb392ec54b5d1caa08a59f11a5eb7f3b1" translate="yes" xml:space="preserve">
          <source>Now, imagine you want to find a particular Chapter that contains a word &quot;&lt;strong&gt;Alchemist&lt;/strong&gt;&quot;. Without an index page, you have no other option than scanning through the entire book/Chapters. i.e: 1000 pages.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここで、「&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Alchemist&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;」&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;という単語を含む特定のチャプターを検索するとします&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;索引ページがないと、本全体または章全体をスキャンする以外に選択肢はありません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すなわち：1000ページ。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="777cb84ce5a934c14c04fb32c3c230b0028ab12b" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say that we want to run a query to find all the details of any employees who are named &amp;lsquo;Abc&amp;rsquo;?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここで、「Abc」という名前の従業員の詳細をすべて検索するクエリを実行するとします。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9cb63ab6c0db77bef9b2c256e11bc06a79e6c6bd" translate="yes" xml:space="preserve">
          <source>Now, let&amp;rsquo;s say that we want to run a query to find all the details of any users who are named 'John'. 
If we run the following query:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここで、「John」という名前のユーザーのすべての詳細を検索するクエリを実行するとします。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;次のクエリを実行すると、&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">参照</target>
        </trans-unit>
        <trans-unit id="1d5c52ff7943b48eda6b1cf65c290aa09e17f098" translate="yes" xml:space="preserve">
          <source>Simple, huh?</source>
          <target state="translated">簡単だろ?</target>
        </trans-unit>
        <trans-unit id="c573cfffeb370eb01525896bbc026605b0d66f5c" translate="yes" xml:space="preserve">
          <source>Since indices are only used to speed up the searching for a matching field within the records, it stands to reason that indexing fields used only for output would be simply a waste of disk space and processing time when doing an insert or delete operation, and thus should be avoided. Also given the nature of a binary search, the cardinality or uniqueness of the data is important. Indexing on a field with a cardinality of 2 would split the data in half, whereas a cardinality of 1,000 would return approximately 1,000 records. With such a low cardinality the effectiveness is reduced to a linear sort, and the query optimizer will avoid using the index if the cardinality is less than 30% of the record number, effectively making the index a waste of space.</source>
          <target state="translated">インデックスはレコード内の一致するフィールドの検索を高速化するためにのみ使用されるので、出力にのみ使用されるフィールドにインデックスを付けることは、挿入や削除操作を行う際のディスクスペースと処理時間の無駄になるので、避けるべきです。また、バイナリ検索の性質上、データのカーディナリティや一意性も重要です。カーディナリティが2のフィールドにインデックスを作成するとデータが半分になりますが、カーディナリティが1,000の場合は約1,000レコードが返されます。このような低いカーディナリティでは、有効性は線形ソートにまで低下し、クエリオプティマイザはカーディナリティがレコード番号の30%未満の場合、インデックスの使用を避けてしまい、インデックスを効果的にスペースの無駄にしてしまいます。</target>
        </trans-unit>
        <trans-unit id="e9732b1f53d3a2736ee890d12a683c1fc0c8f2cf" translate="yes" xml:space="preserve">
          <source>Since then I gained some insight about the downside of creating indexes:
if you write into a table (&lt;code&gt;UPDATE&lt;/code&gt; or &lt;code&gt;INSERT&lt;/code&gt;) with one index, you have actually two writing operations in the file system. One for the table data and another one for the index data (and the resorting of it (and - if clustered - the resorting of the table data)). If table and index are located on the same hard disk this costs more time. Thus a table without an index (a heap) , would allow for quicker write operations. (if you had two indexes you would end up with three write operations, and so on)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それ以来、インデックスを作成することのマイナス面についていくつかの洞察を得ました&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。1つのインデックスを使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;してテーブル（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;UPDATE&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;または&lt;/font&gt;&lt;/font&gt; &lt;code&gt;INSERT&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）に書き込む場合、実際にはファイルシステムで2つの書き込み操作があります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1つはテーブルデータ用で、もう1つはインデックスデータ用です（およびそれを再ソートする（および-クラスタ化されている場合は、テーブルデータを再ソートする））。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;テーブルとインデックスが同じハードディスク上にある場合、これにより多くの時間がかかります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、インデックス（ヒープ）のないテーブルでは、より高速な書き込み操作が可能になります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（2つのインデックスがある場合、3つの書き込み操作が発生することになります）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="adecf93f2acfab3a69649212fe2efb7426f23e48" translate="yes" xml:space="preserve">
          <source>So now the database will use the index to find employees named John
  because the index will presumably be sorted alphabetically by the
  Users name. And, because it is sorted, it means searching for a name
  is a lot faster because all names starting with a &amp;ldquo;J&amp;rdquo; will be right
  next to each other in the index!</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、データベースでインデックスが使用され、Johnという名前の従業員が検索されます。これは、インデックスがおそらくユーザー名でアルファベット順にソートされるためです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、ソートされているため、「J」で始まるすべての名前がインデックス内で互いに隣り合うため、名前の検索がはるかに高速になります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="26471d745a61045c6728ede7f132a76a50811d84" translate="yes" xml:space="preserve">
          <source>The database software would literally have to look at every single row in the &lt;code&gt;User&lt;/code&gt; table to see if the &lt;code&gt;Name&lt;/code&gt; for that row is &amp;lsquo;John&amp;rsquo;. This will take a long time.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;データベースソフトウェアは、文字どおり&lt;/font&gt;&lt;/font&gt; &lt;code&gt;User&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;テーブルの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;すべての行を調べて&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、その行&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;の&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Name&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が「John」である&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;かどうかを確認する必要があり&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これには時間がかかります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="92388142fd95760bd53d3617559908024063026c" translate="yes" xml:space="preserve">
          <source>The downside to indexing is that these indices require additional space on the disk since the indices are stored together in a table using the MyISAM engine, this file can quickly reach the size limits of the underlying file system if many fields within the same table are indexed.</source>
          <target state="translated">インデックス化の欠点は、インデックスがMyISAMエンジンを使用してテーブルに一緒に格納されるため、これらのインデックスはディスク上に追加のスペースを必要とすることです。</target>
        </trans-unit>
        <trans-unit id="7d8c6667f49892d4041edae513099ceacb903c2e" translate="yes" xml:space="preserve">
          <source>The first time I read this it was very helpful to me. Thank you.</source>
          <target state="translated">初めて読みましたが、とても参考になりました。ありがとうございました。</target>
        </trans-unit>
        <trans-unit id="6ab7299d1206cde9db1d5f739db12c3075d44567" translate="yes" xml:space="preserve">
          <source>The index is nothing but a data structure that &lt;strong&gt;stores the values for a specific column&lt;/strong&gt; in a table. An index is created on a column of a table.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インデックスは&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、テーブルの&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;特定の列の値を格納&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;するデータ構造にすぎません&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インデックスはテーブルの列に作成されます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="126caeb9af8c72c10dc8b6168e0b5dd59a87df45" translate="yes" xml:space="preserve">
          <source>The reason B- trees are the most popular data structure for indexes is due to the fact that they are time efficient &amp;ndash; because look-ups, deletions, and insertions can all be done in logarithmic time. And, another major reason B- trees are more commonly used is because the data that is stored inside the B- tree can be sorted. The RDBMS typically determines which data structure is actually used for an index. But, in some scenarios with certain RDBMS&amp;rsquo;s, you can actually specify which data structure you want your database to use when you create the index itself.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;B-treeがインデックスの最も一般的なデータ構造である理由は、それらが時間効率が良いという事実によるものです-ルックアップ、削除、および挿入はすべて対数時間で実行できるためです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、B-treeがより一般的に使用されるもう1つの主な理由は、B-tree内に格納されているデータをソートできるためです。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;RDBMSは通常、実際にインデックスに使用されるデータ構造を決定します。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ただし、特定のRDBMSを使用する一部のシナリオでは、インデックス自体を作成するときに、データベースで使用するデータ構造を実際に指定できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef4d79676e50d3782a878b91406b5f00f4a58cd0" translate="yes" xml:space="preserve">
          <source>The reason hash indexes are used is because hash tables are extremely efficient when it comes to just looking up values. So, queries that compare for equality to a string can retrieve values very fast if they use a hash index.</source>
          <target state="translated">ハッシュインデックスが使用される理由は、ハッシュテーブルは単に値を検索するだけでは非常に効率的だからです。そのため、文字列と等しいかどうかを比較するクエリは、ハッシュインデックスを使用すれば非常に速く値を取得することができます。</target>
        </trans-unit>
        <trans-unit id="257d302baeb4a014b97399cca558bbb83e525e5d" translate="yes" xml:space="preserve">
          <source>The whole point of having an index is to speed up search queries by essentially cutting down the number of records/rows in a table that need to be examined. An index is a data structure (most commonly a B- tree) that stores the values for a specific column in a table.</source>
          <target state="translated">インデックスを持つことの全体的なポイントは、調査が必要なテーブル内のレコード行の数を本質的に削減することで、検索クエリを高速化することです。インデックスとは、テーブル内の特定の列の値を格納するデータ構造(最も一般的なB-ツリー)のことです。</target>
        </trans-unit>
        <trans-unit id="a4f5d021fd61272cfc727ba4d28ac004f08424f2" translate="yes" xml:space="preserve">
          <source>Things are simple in schools, isn't it? :P</source>
          <target state="translated">学校は簡単なんですね。</target>
        </trans-unit>
        <trans-unit id="7503b65320d9c1b258a3d69a2f77ffa5cb85b3fa" translate="yes" xml:space="preserve">
          <source>This analogy is known as &lt;strong&gt;&quot;Full Table Scan&quot;&lt;/strong&gt; in database world.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;この類推は&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;、データベースの世界では&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;「フルテーブルスキャン」&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;として知られ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ています。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="814e34b9dbc0414d8df43d75cfeebb5d902126ee" translate="yes" xml:space="preserve">
          <source>This is where &lt;code&gt;index&lt;/code&gt; helps us: &lt;em&gt;index is used to speed up search queries by essentially cutting down the number of records/rows in a table that needs to be examined&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここで&lt;/font&gt;&lt;/font&gt; &lt;code&gt;index&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;役立ちます。&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;インデックスは、調査する必要があるテーブルのレコード/行の数を本質的に削減することにより、検索クエリを高速化するために使用され&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="eae407d68bea00f32c03361bd34649b638b74dd0" translate="yes" xml:space="preserve">
          <source>Thus, the index is a separate section that stores values of indexed
  column + pointer to the indexed row in a sorted order for efficient
  look-ups.</source>
          <target state="translated">このように、インデックスは、効率的なルックアップのために、インデックスされた列の値+インデックスされた行へのポインタをソートされた順序で格納する別のセクションです。</target>
        </trans-unit>
        <trans-unit id="3388f2a0255a47ceeb6050962fbb9511180c8d29" translate="yes" xml:space="preserve">
          <source>What columns generally make good indexes?</source>
          <target state="translated">一般的にどのようなカラムが良いインデックスになるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="e6f1df688c30d94eb68a3bb0fa23154aa1e18bc3" translate="yes" xml:space="preserve">
          <source>When data is stored on disk-based storage devices, it is stored as blocks of data. These blocks are accessed in their entirety, making them the atomic disk access operation. Disk blocks are structured in much the same way as linked lists; both contain a section for data, a pointer to the location of the next node (or block), and both need not be stored contiguously.</source>
          <target state="translated">ディスクベースの記憶装置にデータが格納されるとき、データはデータのブロックとして格納される。これらのブロックはその全体にアクセスされ、アトミックディスクアクセス操作となります。ディスクブロックは、リンクされたリストとほぼ同じ方法で構造化されています。どちらもデータのセクションと次のノード(またはブロック)の位置へのポインタを含み、両方とも連続して保存される必要はありません。</target>
        </trans-unit>
        <trans-unit id="93a2555206a0af83fbe551a83137431c161ed8c6" translate="yes" xml:space="preserve">
          <source>Whereas with a sorted field, a Binary Search may be used, which has &lt;code&gt;log2 N&lt;/code&gt; block accesses. Also since the data is sorted given a non-key field, the rest of the table doesn&amp;rsquo;t need to be searched for duplicate values, once a higher value is found. Thus the performance increase is substantial.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一方、ソートされたフィールドでは、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;log2 N&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ブロックアクセス&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;を持つバイナリ検索を使用できます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;また、キー以外のフィールドを指定してデータがソートされるため、より高い値が見つかったら、テーブルの残りの部分で重複する値を検索する必要はありません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、パフォーマンスの向上はかなりのものです。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8b533efcb68c06cbb661f675f72076a2242fa3ed" translate="yes" xml:space="preserve">
          <source>e.g:- If you have lots of rivalling writes but only one nightly read outside business hours for reporting.</source>
          <target state="translated">例:-競合する書き込みがたくさんあるが、レポート作成のために営業時間外に毎晩1回しか読まない場合。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
