<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/11832914">
    <body>
      <group id="11832914">
        <trans-unit id="b6ece284bdcef543af3fa04af9f8140b35cca2c3" translate="yes" xml:space="preserve">
          <source>(As an alternative, you could also try the &lt;a href=&quot;https://github.com/jhohlfeld/round10&quot;&gt;round10&lt;/a&gt; library which provides a similarly-behaving function with a wildly different implementation.)</source>
          <target state="translated">（作为替代方案，您也可以尝试&lt;a href=&quot;https://github.com/jhohlfeld/round10&quot;&gt;round10&lt;/a&gt;库，该库提供行为类似但功能完全不同的实现。）</target>
        </trans-unit>
        <trans-unit id="6681674ef7ab7bb360570aaedfa1b23c78b184b2" translate="yes" xml:space="preserve">
          <source>... I get 0.015, which should round to 0.02, and which is noticeably &lt;em&gt;not&lt;/em&gt; the 56-decimal-place number I earlier said that all of these numbers were exactly equal to. So what dark magic is this?</source>
          <target state="translated">...我得到0.015，应该四舍五入为0.02，而且显然&lt;em&gt;不是&lt;/em&gt;我早先所说的所有这些数字都完全相等的56位小数。 那么这是什么黑魔法？</target>
        </trans-unit>
        <trans-unit id="c6a08c79c3157a0800a5664fbe8ac079f3090599" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toFixed(2)&lt;/code&gt; here 2 is number of digits upto which we want to round this num.</source>
          <target state="translated">&lt;code&gt;toFixed(2)&lt;/code&gt; ,这里2是要舍入该数字的位数。</target>
        </trans-unit>
        <trans-unit id="6f89dbbb6171fb257097653bce48c99201d2bf6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT (2019):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;编辑（2019）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="94c3f2940bab5ea0c2d43ef846e1ca78e2d60ba3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT (december 2019):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;编辑（2019年12月）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e23e8588def29ed89ca632405fa7089ba47d19e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; to ensure things like 1.005 round correctly, we use</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;为了确保像1.005这样的东西正确取整，我们使用</target>
        </trans-unit>
        <trans-unit id="4abe7a00ac8031d5894c9ec2f50051099b25c203" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; This is not a universal solution for everyone. There are several different rounding algorithms, your implementation can be different, depends on your requirements. &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;https://en.wikipedia.org/wiki/Rounding&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;这不是所有人的通用解决方案。 舍入算法有几种，您的实现可以有所不同，取决于您的要求。 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;https://zh.wikipedia.org/wiki/舍入&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5700e435626d6a7bc525fba922f6696dce2146e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;None of the answers found here is correct&lt;/strong&gt;. @stinkycheeseman asked to &lt;strong&gt;round up&lt;/strong&gt;, you all rounded the number.</source>
          <target state="translated">&lt;strong&gt;这里没有找到正确的答案&lt;/strong&gt; 。 @stinkycheeseman要求&lt;strong&gt;四舍五入&lt;/strong&gt; ，你们都四舍五入了数字。</target>
        </trans-unit>
        <trans-unit id="8f505dab513fc6e66e32870147f13bf544aaf130" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 1&lt;/strong&gt; is to use a script with required rounding algorithm, for example:</source>
          <target state="translated">&lt;strong&gt;解决方案1&lt;/strong&gt;是使用具有所需舍入算法的脚本，例如：</target>
        </trans-unit>
        <trans-unit id="60da7ee155aad83e9fc691a1e3f288cb20397643" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 2&lt;/strong&gt; is to avoid front end calculations and pull rounded values from the backend server.</source>
          <target state="translated">&lt;strong&gt;解决方案2&lt;/strong&gt;是避免前端计算，并从后端服务器提取舍入的值。</target>
        </trans-unit>
        <trans-unit id="de4e79b8a1f775972ba777a47804a2f6c93dc4ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;That is simply the way floating point numbers works in a computer.&lt;/strong&gt; Like 99% of programming languages, JavaScript doesn't have &lt;em&gt;home made&lt;/em&gt; floating point numbers; it relies on the CPU/FPU for that. A computer uses binary, and in binary, there isn't any numbers like &lt;code&gt;0.1&lt;/code&gt;, but a mere binary approximation for that. Why? For the same reason than 1/3 cannot be written in decimal: its value is 0.33333333... with an infinity of threes.</source>
          <target state="translated">&lt;strong&gt;这就是浮点数在计算机中的工作方式。&lt;/strong&gt; 像99％的编程语言一样，JavaScript没有&lt;em&gt;自制的&lt;/em&gt;浮点数。 它依赖于CPU / FPU。 计算机使用二进制，并且在二进制中，没有像 &lt;code&gt;0.1&lt;/code&gt; 这样的数字，而仅仅是二进制近似值。 为什么？ 出于同样的原因，不能以十进制写1/3：其值为0.33333333 ...，且无穷三进制。</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1b2af8daa9bf0f51bff3121bdff06a9eef9fdbd" translate="yes" xml:space="preserve">
          <source>A precise rounding method. Source: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Mozilla&lt;/a&gt;</source>
          <target state="translated">精确的舍入方法。 资料来源： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Mozilla&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="69b2d171eb62a98f494d32dbf0399f2c6f867adf" translate="yes" xml:space="preserve">
          <source>A simple drop in solution that provides accurate decimal rounding, flooring, and ceiling, with an optional precision variable without adding a whole library.</source>
          <target state="translated">一个简单的滴入式解决方案,可以提供精确的小数四舍五入、落地、封顶,可选精度变量,无需增加整个库。</target>
        </trans-unit>
        <trans-unit id="d87b6d4b2b1d92b09f50fecdbf7a3fb93cdb0de7" translate="yes" xml:space="preserve">
          <source>Adapted from the solution provided here: &lt;a href=&quot;https://stackoverflow.com/a/48850944/6910392&quot;&gt;https://stackoverflow.com/a/48850944/6910392&lt;/a&gt;</source>
          <target state="translated">改编自此处提供的解决方案： &lt;a href=&quot;https://stackoverflow.com/a/48850944/6910392&quot;&gt;https&lt;/a&gt; : //stackoverflow.com/a/48850944/6910392</target>
        </trans-unit>
        <trans-unit id="b39ace06fe7843f11aa15e7af8ac8aa65286c4d1" translate="yes" xml:space="preserve">
          <source>After running through various iterations of all the possible ways to achieve true accurate decimal rounding precision, it is clear that the most accurate and efficient solution is to use Number.EPSILON. This provides a true mathematical solution to the problem of floating point math precision. It can be easily polyfilled as shown here: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&lt;/a&gt; to support all of the last remaining IE users (then again maybe we should stop doing that).</source>
          <target state="translated">在经过所有可能的方式的各种迭代以达到真正准确的十进制舍入精度之后，很明显，最准确和有效的解决方案是使用Number.EPSILON。 这为浮点数学精度问题提供了一个真正的数学解决方案。 可以很容易地对其进行填充，如下所示： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;https&lt;/a&gt; : //developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON以支持所有剩余的IE用户（那么也许我们再次应该停止这样做）。</target>
        </trans-unit>
        <trans-unit id="f575b52acd8ef9eab6fdcf0d803b1f78d5741f89" translate="yes" xml:space="preserve">
          <source>Also it's worth noting that this is not a &lt;em&gt;JavaScript weirdness&lt;/em&gt; like some people stated.</source>
          <target state="translated">同样值得注意的是，这并不是某些人所说的&lt;em&gt;JavaScript怪异之处&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4937c3ee7e26dbf578cfd6247ad524d28ec2b62" translate="yes" xml:space="preserve">
          <source>As asked in the comments, let's clarify one thing: adding &lt;code&gt;Number.EPSILON&lt;/code&gt; is relevant only when the value to round is the result of an arithmetic operation, as it can swallow some floating point error delta.</source>
          <target state="translated">正如评论中所要求的，让我们澄清一件事：仅当要舍入的值是算术运算的结果时，添加 &lt;code&gt;Number.EPSILON&lt;/code&gt; 才是相关的，因为它会吞噬一些浮点错误增量。</target>
        </trans-unit>
        <trans-unit id="5c1aa79e884353e01805297b4ffdc0e1b809104c" translate="yes" xml:space="preserve">
          <source>But what if you have the second kind of Number - a value taken from a continuous scale, where there's no reason to think that approximate decimal representations with fewer decimal places are more &lt;em&gt;accurate&lt;/em&gt; than those with more? In that case, we &lt;em&gt;don't&lt;/em&gt; want to respect the String representation, because that representation (as explained in the spec) is already sort-of-rounded; we don't want to make the mistake of saying &quot;0.014999999...375 rounds up to 0.015, which rounds up to 0.02, so 0.014999999...375 rounds up to 0.02&quot;.</source>
          <target state="translated">但是，如果您拥有第二种数字-取自连续刻度的值，而又没有理由认为小数位数较少的近似十进制表示比小数位数&lt;em&gt;精确的&lt;/em&gt;多呢？ 在这种情况下，我们不想遵守String表示形式，因为该表示形式（如规范中所述）已经是四舍五入的； 我们不想犯这样的错误：&amp;ldquo; 0.014999999 ... 375舍入到0.015，它舍入到0.02，所以0.014999999 ... 375舍入到0.02&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="ab662aee31f190e347238c5fbc1e7d6128a3dbdd" translate="yes" xml:space="preserve">
          <source>Compared to Lavamantis's solution, we can do...</source>
          <target state="translated">与Lavamantis的解决方案相比,我们可以.....</target>
        </trans-unit>
        <trans-unit id="8589b8976170efc90ee30bed08325d4b4f5fb025" translate="yes" xml:space="preserve">
          <source>Consider &lt;code&gt;.toFixed()&lt;/code&gt; and &lt;code&gt;.toPrecision()&lt;/code&gt;:</source>
          <target state="translated">考虑 &lt;code&gt;.toFixed()&lt;/code&gt; 和 &lt;code&gt;.toPrecision()&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="85511932eb0bd6ee919a34a7f2c6087bb0a5fb7b" translate="yes" xml:space="preserve">
          <source>Easiest way:</source>
          <target state="translated">最简单的方法。</target>
        </trans-unit>
        <trans-unit id="5e297a41e8ef5ac08adf9ee0810c2244721fa92b" translate="yes" xml:space="preserve">
          <source>Eg:</source>
          <target state="translated">Eg:</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">用例:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="945a73f60f58235e70de75adb211e4394558c073" translate="yes" xml:space="preserve">
          <source>For me &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Math.round()&lt;/a&gt; was not giving correct answer. I found &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt;toFixed(2)&lt;/a&gt; works better. 
Below are examples of both:</source>
          <target state="translated">对我来说&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Math.round（）&lt;/a&gt;没有给出正确的答案。 我发现&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt;toFixed（2）&lt;/a&gt;效果更好。 以下是这两个示例：</target>
        </trans-unit>
        <trans-unit id="edbdada6b4155dd45ec8fd8ab20607a6462b6549" translate="yes" xml:space="preserve">
          <source>Here come &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/a&gt;. That number is the difference between 1 and the &lt;em&gt;next&lt;/em&gt; number existing in the double precision floating point numbers. &lt;strong&gt;That's it: There is no number between &lt;code&gt;1&lt;/code&gt; and 1 + &lt;code&gt;Number.EPSILON&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">这是&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; &lt;/a&gt; 。 该数字是1和双精度浮点数中存在的&lt;em&gt;下一个&lt;/em&gt;数字之间的差。 &lt;strong&gt;就是这样： &lt;code&gt;1&lt;/code&gt; 到1 + &lt;code&gt;Number.EPSILON&lt;/code&gt; 之间没有数字。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="582a28d3d6f5875f42faffd53f6dca41c44e4409" translate="yes" xml:space="preserve">
          <source>Here is a prototype method:</source>
          <target state="translated">这里有一个原型方法。</target>
        </trans-unit>
        <trans-unit id="2becac006f82ed17841b46654302952a6af24ef5" translate="yes" xml:space="preserve">
          <source>Here is a simple way to do it:</source>
          <target state="translated">这里有一个简单的方法。</target>
        </trans-unit>
        <trans-unit id="86712cc5731f9156c956e2225c2cb563bb12f349" translate="yes" xml:space="preserve">
          <source>Here is the function I use to solve the floating point decimals issues &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round#Example%3a_Decimal_rounding&quot;&gt;also based on MDN&lt;/a&gt;. It is even more generic (but less concise) than Lavamantis's solution:</source>
          <target state="translated">这是我用来&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round#Example%3a_Decimal_rounding&quot;&gt;基于MDN&lt;/a&gt;解决浮点小数问题的函数。 它比Lavamantis的解决方案更通用（但不那么简洁）：</target>
        </trans-unit>
        <trans-unit id="c0d5875b4c5849ab3bfd33eea8d2f49977f4bd52" translate="yes" xml:space="preserve">
          <source>Here we can simply use the built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt;&lt;code&gt;toFixed&lt;/code&gt;&lt;/a&gt; method. Note that by calling &lt;code&gt;Number()&lt;/code&gt; on the String returned by &lt;code&gt;toFixed&lt;/code&gt;, we get a Number whose String representation has no trailing zeroes (thanks to the way JavaScript computes the String representation of a Number, discussed earlier in this answer).</source>
          <target state="translated">在这里，我们可以简单地使用内置的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt; &lt;code&gt;toFixed&lt;/code&gt; &lt;/a&gt;方法。 请注意，通过在 &lt;code&gt;toFixed&lt;/code&gt; 返回的String上调用 &lt;code&gt;Number()&lt;/code&gt; ，我们得到一个Number，其String表示形式不带尾随零（这要归功于此答案前面讨论的JavaScript计算Number的String表示形式的方式）。</target>
        </trans-unit>
        <trans-unit id="c0f0c4ff59640480547b46eb98247d0405dde5a2" translate="yes" xml:space="preserve">
          <source>Here, also is one function I wrote to do arithmetic rounding correctly. You can test it yourself.</source>
          <target state="translated">这里,也是我写的一个函数,可以正确地进行算术四舍五入。你可以自己测试一下。</target>
        </trans-unit>
        <trans-unit id="75553f548ebe8d7c4d7be06075a2ad90b25c726b" translate="yes" xml:space="preserve">
          <source>How can I do this in JavaScript?</source>
          <target state="translated">如何才能在JavaScript中做到这一点?</target>
        </trans-unit>
        <trans-unit id="379bf1ec8b931f6919ae70cbdb99b7a15e4424b6" translate="yes" xml:space="preserve">
          <source>I found this over on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;MDN&lt;/a&gt;. Their way avoids the problem with 1.005 that was &lt;a href=&quot;https://stackoverflow.com/questions/11832914/round-up-to-2-decimal-places-in-javascript#comment24719818_11832950&quot;&gt;mentioned&lt;/a&gt;.</source>
          <target state="translated">我在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;MDN&lt;/a&gt;上发现了这一点。 他们的方法避免了&lt;a href=&quot;https://stackoverflow.com/questions/11832914/round-up-to-2-decimal-places-in-javascript#comment24719818_11832950&quot;&gt;提到的&lt;/a&gt; 1.005问题。</target>
        </trans-unit>
        <trans-unit id="070221396ffd7adc80f964d497ffbcc8f1956377" translate="yes" xml:space="preserve">
          <source>I guess, this is because 1.555 is actually something like float 1.55499994 behind the scenes.</source>
          <target state="translated">我想,这是因为1.555其实是浮动1.5549999994的背后的东西。</target>
        </trans-unit>
        <trans-unit id="07e838235f2a025cd47854a685499d5a0537ecfb" translate="yes" xml:space="preserve">
          <source>I removed the variant &lt;code&gt;n.toFixed(2)&lt;/code&gt;, because it is not correct. Thank you @avalanche1</source>
          <target state="translated">我删除了变体 &lt;code&gt;n.toFixed(2)&lt;/code&gt; ，因为它不正确。 谢谢@ avalanche1</target>
        </trans-unit>
        <trans-unit id="48bd35342cfdaf130a7708310f7a72f622b696f6" translate="yes" xml:space="preserve">
          <source>I'd like to round at most 2 decimal places, but &lt;em&gt;only if necessary&lt;/em&gt;.</source>
          <target state="translated">我想最多舍入小数点后两位，但&lt;em&gt;仅在必要时才可以&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec800790fcee0bf08442c4630dae0d9ba7b6d988" translate="yes" xml:space="preserve">
          <source>If the value is a number:</source>
          <target state="translated">如果值是一个数字。</target>
        </trans-unit>
        <trans-unit id="b1fefa7ba2439d746003f46853a7371ff731d113" translate="yes" xml:space="preserve">
          <source>If the value is a text type:</source>
          <target state="translated">如果该值为文本类型。</target>
        </trans-unit>
        <trans-unit id="e41c41447951ebc94d036fd32ec620302036e867" translate="yes" xml:space="preserve">
          <source>If you are open to libraries you can use &lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;bignumber.js&lt;/a&gt;</source>
          <target state="translated">如果您对图书馆开放，可以使用&lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;bignumber.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc26938bf0e0296802c89e07ccde26e1ab90731a" translate="yes" xml:space="preserve">
          <source>If you are using lodash library, you can use the round method of lodash like following.</source>
          <target state="translated">如果你使用的是Lodash库,你可以使用以下的Lodash的圆形方法。</target>
        </trans-unit>
        <trans-unit id="3216546a05d95fdf5f5508347421f9837590b56b" translate="yes" xml:space="preserve">
          <source>If you need to be strict and add digits just if needed it can use &lt;code&gt;replace&lt;/code&gt;</source>
          <target state="translated">如果您需要严格要求并在需要时添加数字，则可以使用 &lt;code&gt;replace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a938b4696af9e98610818f1d8d206757dad7ae27" translate="yes" xml:space="preserve">
          <source>If your project uses jQuery or lodash, you can also find proper &lt;code&gt;round&lt;/code&gt; method in the libraries.</source>
          <target state="translated">如果您的项目使用jQuery或lodash，您还可以在库中找到合适的 &lt;code&gt;round&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="6af9e62dcf39a0d15e0f97e5a60d274500525b0b" translate="yes" xml:space="preserve">
          <source>In fact, in the code I'm using &lt;code&gt;ESPILON_RATE = 1 + 4 * Number.EPSILON&lt;/code&gt; and &lt;code&gt;EPSILON_ZERO = 4 * Number.MIN_VALUE&lt;/code&gt; (four times the epsilon), because I want an equality checker loose enough for cumulating floating point error.</source>
          <target state="translated">实际上，在代码中，我使用的是 &lt;code&gt;ESPILON_RATE = 1 + 4 * Number.EPSILON&lt;/code&gt; 和 &lt;code&gt;EPSILON_ZERO = 4 * Number.MIN_VALUE&lt;/code&gt; （四倍于epsilon），因为我希望相等性检查器足够松散以累积浮点错误。</target>
        </trans-unit>
        <trans-unit id="ef69761016065df342a41f1ba61cbdee1af2e52f" translate="yes" xml:space="preserve">
          <source>In general, rounding is done by scaling: &lt;code&gt;round(num / p) * p&lt;/code&gt;</source>
          <target state="translated">通常，舍入是通过缩放来完成的： &lt;code&gt;round(num / p) * p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="79d70dcb4f9ee8b7d94ed9539586cc73c0d399da" translate="yes" xml:space="preserve">
          <source>Input:</source>
          <target state="translated">Input:</target>
        </trans-unit>
        <trans-unit id="5bdb51e539dd788122b75e12613282cb9a59033d" translate="yes" xml:space="preserve">
          <source>It converts it to a string, and then back into an integer / float.</source>
          <target state="translated">它将其转换为字符串,然后返回到一个整数浮点。</target>
        </trans-unit>
        <trans-unit id="e7f26dce8602d2aa4e2f07b9f0b39e5804a7316d" translate="yes" xml:space="preserve">
          <source>It doesn't solve the '1.005 rounding problem' though - since it is intrinsic to how &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/101163/what-causes-floating-point-rounding-errors&quot;&gt;float fractions are being processed&lt;/a&gt;.</source>
          <target state="translated">但是，它不能解决&amp;ldquo; 1.005舍入问题&amp;rdquo;，因为它是&lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/101163/what-causes-floating-point-rounding-errors&quot;&gt;处理浮点数的&lt;/a&gt;固有方法 。</target>
        </trans-unit>
        <trans-unit id="bb18705dfa4dbaefc58019dd86183424f5d60d6a" translate="yes" xml:space="preserve">
          <source>It may work for you,</source>
          <target state="translated">它可能对你有用。</target>
        </trans-unit>
        <trans-unit id="9db4057b0b1aefd3eabe9d5558fa88ce0408b22f" translate="yes" xml:space="preserve">
          <source>It seems like &lt;code&gt;Math.round&lt;/code&gt; is a better solution. &lt;strong&gt;But it is not!&lt;/strong&gt; In some cases it will &lt;strong&gt;NOT&lt;/strong&gt; round correctly:</source>
          <target state="translated">看来 &lt;code&gt;Math.round&lt;/code&gt; 是更好的解决方案。 &lt;strong&gt;但这不是！&lt;/strong&gt; 在某些情况下，它将无法正确舍入：</target>
        </trans-unit>
        <trans-unit id="de7e2f930d8192a22533ff7c52eeb7a294e46200" translate="yes" xml:space="preserve">
          <source>It's not useful when the value comes from a direct source (e.g.: literal, user input or sensor).</source>
          <target state="translated">当值来自直接来源(如:字面、用户输入或传感器)时,它是没有用的。</target>
        </trans-unit>
        <trans-unit id="d16bae6ae960069cfbe9eb6b916a4ba5bc5ae155" translate="yes" xml:space="preserve">
          <source>Just use native code &lt;code&gt;.toFixed()&lt;/code&gt;</source>
          <target state="translated">只需使用本机代码 &lt;code&gt;.toFixed()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b1a5d323275c298c4aa9b8992ef25578960b7c0" translate="yes" xml:space="preserve">
          <source>Lately, I use a function similar to this one for comparing numbers epsilon-aware:</source>
          <target state="translated">最近,我用了一个类似于这样的函数,用于比较数字Epsilon-aware的数字。</target>
        </trans-unit>
        <trans-unit id="adb23d3b5115886051bb54739f5c553032bc9dc7" translate="yes" xml:space="preserve">
          <source>Like @maganap and some peoples have pointed out, it's best to add &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/a&gt; before multiplying:</source>
          <target state="translated">就像@maganap以及一些人指出的那样，最好在相乘之前添加&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; &lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="2787e27648a8b92aefd69a68e92ccec35c88a574" translate="yes" xml:space="preserve">
          <source>MarkG and Lavamantis offered a much better solution than the one that has been accepted. It's a shame they don't get more upvotes!</source>
          <target state="translated">MarkG和Lavamantis提供了一个比已经被接受的方案好得多的解决方案。很可惜他们没有得到更多的支持票!</target>
        </trans-unit>
        <trans-unit id="e9cb187413866bee5719685fd8cb0c4a9882de1d" translate="yes" xml:space="preserve">
          <source>MarkG's answer is the correct one.  Here's a generic extension for any number of decimal places.</source>
          <target state="translated">MarkG的答案是正确的。这里有一个通用的扩展,可以任意扩展到小数点后数。</target>
        </trans-unit>
        <trans-unit id="428f9655e67ff46265d67320cd0ccfe0319be407" translate="yes" xml:space="preserve">
          <source>Math.round(num) vs num.toFixed(0) and browser inconsistencies</source>
          <target state="translated">Math.round(num)vs num.toFixed(0)与浏览器不一致</target>
        </trans-unit>
        <trans-unit id="ff707f109be190d332352b938ccc8b3c4e06e97c" translate="yes" xml:space="preserve">
          <source>My use-case is &lt;a href=&quot;https://www.npmjs.com/package/doormen&quot;&gt;an assertion + data validation lib&lt;/a&gt; I'm developing for many years.</source>
          <target state="translated">我的用例是我多年开发&lt;a href=&quot;https://www.npmjs.com/package/doormen&quot;&gt;的断言+数据验证库&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="59377d5faf3749e97822f1f1971ecded10a972a6" translate="yes" xml:space="preserve">
          <source>No one seems to be aware of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">似乎没有人知道&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="ca5e324249ddd6187831ef808ea93363a2b26711" translate="yes" xml:space="preserve">
          <source>Of course, none of this discussion has directly answered what &lt;code&gt;roundTo2DP(m)&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; return. If &lt;code&gt;m&lt;/code&gt;'s exact value is 0.01499999999999999944488848768742172978818416595458984375, but its String representation is '0.015', then what is the &lt;em&gt;correct&lt;/em&gt; answer - mathematically, practically, philosophically, or whatever - when we round it to two decimal places?</source>
          <target state="translated">当然，这些讨论都没有直接回答 &lt;code&gt;roundTo2DP(m)&lt;/code&gt; &lt;em&gt;应该&lt;/em&gt;返回什么。 如果 &lt;code&gt;m&lt;/code&gt; 的准确值为0.01499999999999999944488848768742172978818416595458984375，但其字符串表示形式为'0.015'，那么当我们将其四舍五入到小数点后两位时， &lt;em&gt;正确&lt;/em&gt;答案是什么？</target>
        </trans-unit>
        <trans-unit id="9de972621e113a6822f18823d2063f32eba7fcf6" translate="yes" xml:space="preserve">
          <source>On the other hand, you probably want to respect the binary floating point value and round downwards when your value is from an inherently continuous scale - for instance, if it's a reading from a sensor.</source>
          <target state="translated">另一方面,当你的值来自于一个固有的连续刻度时,你可能希望尊重二进制浮点值,并向下取整--例如,如果是传感器的读数。</target>
        </trans-unit>
        <trans-unit id="6bbbecb3438fd6440ef7f77e7aea3b5d8bdb6531" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;.toFixed(NumberOfDecimalPlaces)&lt;/code&gt;.</source>
          <target state="translated">可以使用 &lt;code&gt;.toFixed(NumberOfDecimalPlaces)&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="576fa80104f1e9d06e3d6fd8ed6dedc8629cc5e4" translate="yes" xml:space="preserve">
          <source>One way to achieve such a rounding &lt;em&gt;only if necessary&lt;/em&gt; is to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString&quot;&gt;Number.prototype.toLocaleString()&lt;/a&gt;:</source>
          <target state="translated">&lt;em&gt;仅在必要时&lt;/em&gt;实现这种舍入的一种方法是使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString&quot;&gt;Number.prototype.toLocaleString（）&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="c1d0e0227161567c5c8a46e530e257ab7932de2e" translate="yes" xml:space="preserve">
          <source>Round to at most 2 decimal places (only if necessary)</source>
          <target state="translated">最多四舍五入到小数点后2位(仅在必要的情况下)。</target>
        </trans-unit>
        <trans-unit id="1b3ea2091e0125bb10b50729a167add8b2875170" translate="yes" xml:space="preserve">
          <source>Since ES6 there is a 'proper' way (without overriding statics and creating workarounds) to do this by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Number/toPrecision&quot;&gt;using toPrecision&lt;/a&gt;</source>
          <target state="translated">从ES6开始，有一种&amp;ldquo;正确&amp;rdquo;的方法（没有覆盖静态变量和创建解决方法）通过&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Number/toPrecision&quot;&gt;使用toPrecision&lt;/a&gt;来执行此操作</target>
        </trans-unit>
        <trans-unit id="c131372ed2ef9d5afca4b7ffe157d796543820d0" translate="yes" xml:space="preserve">
          <source>So far, it looks perfect for me.
I hope it will help.</source>
          <target state="translated">到目前为止,它看起来很适合我。希望能帮到你。</target>
        </trans-unit>
        <trans-unit id="d9eb0d47c4da3723a4af8473544b8419da09be27" translate="yes" xml:space="preserve">
          <source>So when I write &lt;code&gt;m = 0.0150000000000000001&lt;/code&gt;, the &lt;em&gt;exact value of &lt;code&gt;m&lt;/code&gt;&lt;/em&gt; that I end up with is closer to &lt;code&gt;0.01&lt;/code&gt; than it is to &lt;code&gt;0.02&lt;/code&gt;. And yet, if I convert &lt;code&gt;m&lt;/code&gt; to a String...</source>
          <target state="translated">因此，当我写 &lt;code&gt;m = 0.0150000000000000001&lt;/code&gt; ，我最终&lt;em&gt;得到的 &lt;code&gt;m&lt;/code&gt; &lt;/em&gt;的&lt;em&gt;精确值&lt;/em&gt;更接近 &lt;code&gt;0.01&lt;/code&gt; ,而不是 &lt;code&gt;0.02&lt;/code&gt; 。 但是，如果我将 &lt;code&gt;m&lt;/code&gt; 转换为String ...</target>
        </trans-unit>
        <trans-unit id="3b8d42473f0fced361a981334f253d2ee119f7bd" translate="yes" xml:space="preserve">
          <source>Suppose we have a function, &lt;code&gt;roundTo2DP(num)&lt;/code&gt;, that takes a float as an argument and returns a value rounded to 2 decimal places. What should each of these expressions evaluate to?</source>
          <target state="translated">假设我们有一个函数 &lt;code&gt;roundTo2DP(num)&lt;/code&gt; ，该函数将float用作参数并返回四舍五入到小数点后两位的值。 这些表达式中的每个表达式的结果是什么？</target>
        </trans-unit>
        <trans-unit id="6bfb5e628c414a067972ade779b24a3a568b3fd7" translate="yes" xml:space="preserve">
          <source>The 'obvious' answer is that the first example should round to 0.01 (because it's closer to 0.01 than to 0.02) while the other two should round to 0.02 (because 0.0150000000000000001 is closer to 0.02 than to 0.01, and because 0.015 is exactly halfway between them and there is a mathematical convention that such numbers get rounded up).</source>
          <target state="translated">很明显的答案是,第一个例子应该四舍五入到0.01(因为它比0.02更接近于0.01),而另两个例子应该四舍五入到0.02(因为0.01500000000000000000001比0.01更接近于0.02,而且因为0.015正好是它们之间的一半,而且有一个数学惯例,这样的数字会被四舍五入)。</target>
        </trans-unit>
        <trans-unit id="c544245c0ffab197bc3584e928cfc903bd4d3964" translate="yes" xml:space="preserve">
          <source>The answer can be found in the ECMAScript specification, in section &lt;a href=&quot;http://www.ecma-international.org/ecma-262/7.0/#sec-tostring-applied-to-the-number-type&quot;&gt;&lt;em&gt;7.1.12.1: ToString applied to the Number type&lt;/em&gt;&lt;/a&gt;. Here the rules for converting some Number &lt;em&gt;m&lt;/em&gt; to a String are laid down. The key part is point 5, in which an integer &lt;em&gt;s&lt;/em&gt; is generated whose digits will be used in the String representation of &lt;em&gt;m&lt;/em&gt;:</source>
          <target state="translated">答案可在ECMAScript规范的第&lt;a href=&quot;http://www.ecma-international.org/ecma-262/7.0/#sec-tostring-applied-to-the-number-type&quot;&gt;&lt;em&gt;7.1.12.1&lt;/em&gt;&lt;/a&gt;节&lt;em&gt;：适用于Number类型的ToString中找到&lt;/em&gt; 。 这里规定了将一些数字&lt;em&gt;m&lt;/em&gt;转换为字符串的规则。 关键部分是点5，其中生成一个整数&lt;em&gt;s&lt;/em&gt; ，其数字将用于&lt;em&gt;m&lt;/em&gt;的String表示形式：</target>
        </trans-unit>
        <trans-unit id="df090e3c30fa1d731e05b5ce4f35661d5e7baf7c" translate="yes" xml:space="preserve">
          <source>The catch, which you may have guessed, is that &lt;code&gt;roundTo2DP&lt;/code&gt;&lt;em&gt;cannot possibly&lt;/em&gt; be implemented to give those obvious answers, because all three numbers passed to it are &lt;em&gt;the same number&lt;/em&gt;. IEEE 754 binary floating point numbers (the kind used by JavaScript) can't exactly represent most non-integer numbers, and so all three numeric literals above get rounded to a nearby valid floating point number. This number, as it happens, is &lt;em&gt;exactly&lt;/em&gt;</source>
          <target state="translated">您可能已经猜到了，有个问题是， &lt;em&gt;可能&lt;/em&gt;无法实现 &lt;code&gt;roundTo2DP&lt;/code&gt; 来给出那些明显的答案，因为传递给它的所有三个数字都是&lt;em&gt;相同的数字&lt;/em&gt; 。 IEEE 754二进制浮点数（JavaScript使用的那种）不能精确地表示大多数非整数，因此上面的所有三个数字文字都会四舍五入为附近的有效浮点数。 这个数字恰好是</target>
        </trans-unit>
        <trans-unit id="17eaea0baa02c017f3ef107833be95e25d292bd7" translate="yes" xml:space="preserve">
          <source>The function above is &lt;em&gt;probably&lt;/em&gt; what you want to use to avoid users ever witnessing numbers that they have entered being rounded wrongly.</source>
          <target state="translated">上面的功能&lt;em&gt;可能&lt;/em&gt;是您想要使用的功能，以避免用户看到他们输入的数字被错误舍入。</target>
        </trans-unit>
        <trans-unit id="7a1df7bf3e06ffb09c0be63d9ac99109b43decd2" translate="yes" xml:space="preserve">
          <source>The key part here is the requirement that &quot;&lt;em&gt;k&lt;/em&gt; is as small as possible&quot;. What that requirement amounts to is a requirement that, given a Number &lt;code&gt;m&lt;/code&gt;, the value of &lt;code&gt;String(m)&lt;/code&gt; must have &lt;em&gt;the least possible number of digits&lt;/em&gt; while still satisfying the requirement that &lt;code&gt;Number(String(m)) === m&lt;/code&gt;. Since we already know that &lt;code&gt;0.015 === 0.0150000000000000001&lt;/code&gt;, it's now clear why &lt;code&gt;String(0.0150000000000000001) === '0.015'&lt;/code&gt; must be true.</source>
          <target state="translated">这里的关键部分是&amp;ldquo; &lt;em&gt;k&lt;/em&gt;尽可能小&amp;rdquo;的要求。 该要求等于给定一个数字 &lt;code&gt;m&lt;/code&gt; ， &lt;code&gt;String(m)&lt;/code&gt; 的值必须具有&lt;em&gt;尽可能少的数字，&lt;/em&gt;同时仍满足 &lt;code&gt;Number(String(m)) === m&lt;/code&gt; 。 因为我们已经知道 &lt;code&gt;0.015 === 0.0150000000000000001&lt;/code&gt; ，所以现在很清楚为什么 &lt;code&gt;String(0.0150000000000000001) === '0.015'&lt;/code&gt; 必须为true。</target>
        </trans-unit>
        <trans-unit id="d9304dfd5b20a84c90c202df6981188a19c4637d" translate="yes" xml:space="preserve">
          <source>The value being represented is inherently discrete, e.g. an amount of currency in a 3-decimal-place currency like dinars. In this case, the &lt;em&gt;true&lt;/em&gt; value of a Number like 0.015 &lt;em&gt;is&lt;/em&gt; 0.015, and the 0.0149999999... representation that it gets in binary floating point is a rounding error. (Of course, many will argue, reasonably, that you should use a decimal library for handling such values and never represent them as binary floating point Numbers in the first place.)</source>
          <target state="translated">表示的值本质上是离散的，例如，以3个小数位数的货币表示的货币数量，如第纳尔。 在这种情况下，像0.015这样的Number的&lt;em&gt;真实&lt;/em&gt;值&lt;em&gt;是&lt;/em&gt; 0.015，并且它在二进制浮点数中获得的0.0149999999 ...表示形式是舍入误差。 （当然，许多人会合理地说，您应该使用十进制库来处理此类值，而从一开始就不要将它们表示为二进制浮点数。）</target>
        </trans-unit>
        <trans-unit id="0606e71f981fa36e43313e05fde67bea41c0e859" translate="yes" xml:space="preserve">
          <source>The value was typed by a user. In this case, again, the exact decimal number entered is more 'true' than the nearest binary floating point representation.</source>
          <target state="translated">值是由用户输入的。在这种情况下,同样,输入的精确小数比最接近的二进制浮点表示法更 &quot;真实&quot;。</target>
        </trans-unit>
        <trans-unit id="8727bcf5e244c818b657462e6c613378e3d0d0c7" translate="yes" xml:space="preserve">
          <source>Then you would simply pass in the value.</source>
          <target state="translated">那么你只需将值传入即可。</target>
        </trans-unit>
        <trans-unit id="f76d9f0b8979b7733602f015e3ba04fd7d5a9502" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to do that. For people like me, the Lodash's variant</source>
          <target state="translated">有几种方法可以做到这一点。对于像我这样的人来说,洛达什的变异体</target>
        </trans-unit>
        <trans-unit id="068e2e768c65c4ad778691dec9f43778213541e5" translate="yes" xml:space="preserve">
          <source>There is a downside that values like 1.5 will give &quot;1.50&quot; as the output. A fix suggested by @minitech:</source>
          <target state="translated">有一个坏处,就是像1.5这样的值会给出 &quot;1.50 &quot;的输出。由@minitech建议的一个修复方法。</target>
        </trans-unit>
        <trans-unit id="38387a87e059184ebabf02e5e267b74130d78c64" translate="yes" xml:space="preserve">
          <source>There is no single correct answer to this. It depends upon your use case. You probably want to respect the String representation and round upwards when:</source>
          <target state="translated">这个问题没有单一的正确答案。这取决于你的用例。你可能希望尊重String表示法,并在此基础上进行四舍五入。</target>
        </trans-unit>
        <trans-unit id="de80e004c8c33e4edbcec58d2afcf0444b42e1b1" translate="yes" xml:space="preserve">
          <source>These two approaches require different code. To respect the String representation of the Number, we can (with quite a bit of reasonably subtle code) implement our own rounding that acts directly on the String representation, digit by digit, using the same algorithm you would've used in school when you were taught how to round numbers. Below is an example which respects the OP's requirement of representing the number to 2 decimal places &quot;only when necessary&quot; by stripping trailing zeroes after the decimal point; you may, of course, need to tweak it to your precise needs.</source>
          <target state="translated">这两种方法需要不同的代码。为了尊重数字的String表示法,我们可以(用一些合理的微妙的代码)实现我们自己的四舍五入,直接作用于String表示法,用你在学校里教你如何四舍五入的算法。下面是一个例子,它尊重了OP的要求,通过在小数点后去掉小数点后的尾数零,将数字表示为2位小数,&quot;只有在必要的时候&quot;;当然,你可能需要根据你的精确需求来调整它。</target>
        </trans-unit>
        <trans-unit id="9cc618b8fa630d85d81948907d250ac34fd31d00" translate="yes" xml:space="preserve">
          <source>This is the simplest, more elegant solution (and I am the best of the world;):</source>
          <target state="translated">这是最简单、最优雅的解决方案(而我是世界上最好的;)。</target>
        </trans-unit>
        <trans-unit id="03640ca35a3d05dde0a5a618e1942cbb23d4aba2" translate="yes" xml:space="preserve">
          <source>This may help you:</source>
          <target state="translated">这或许能帮到你。</target>
        </trans-unit>
        <trans-unit id="e3a53ec34f6c2117910f386788bc9d743450046a" translate="yes" xml:space="preserve">
          <source>This question is complicated.</source>
          <target state="translated">这个问题很复杂。</target>
        </trans-unit>
        <trans-unit id="13ea220ac7311f1b88e69de6b5b2c466b9a1e184" translate="yes" xml:space="preserve">
          <source>This will provide exactly the output you expect, but as strings. You can still convert those back to numbers if that's not the data type you expect.</source>
          <target state="translated">这将提供你所期望的输出,但是是字符串。如果不是你所期望的数据类型,你仍然可以将其转换为数字。</target>
        </trans-unit>
        <trans-unit id="9845257528e47964d89c7b7b37c418107088920b" translate="yes" xml:space="preserve">
          <source>To round up, use this:</source>
          <target state="translated">要四舍五入,就用这个。</target>
        </trans-unit>
        <trans-unit id="cdb9e11f95eb4c3103b6460c4ec8869fcb19ed0a" translate="yes" xml:space="preserve">
          <source>Try this &lt;strong&gt;light weight&lt;/strong&gt; solution:</source>
          <target state="translated">试试这个&lt;strong&gt;轻量级的&lt;/strong&gt;解决方案：</target>
        </trans-unit>
        <trans-unit id="c83890cd9cde34e76f22e6c092f33233337bbeef" translate="yes" xml:space="preserve">
          <source>Unit test:</source>
          <target state="translated">单元测试。</target>
        </trans-unit>
        <trans-unit id="aa46e3b43b8698bd79a3510bffe6645c067a8510" translate="yes" xml:space="preserve">
          <source>Update 1</source>
          <target state="translated">更新1</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="1a83ebd9832b047f8e615f8f8336e3bea08f97fc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Math.round(num * 100) / 100&lt;/code&gt;</source>
          <target state="translated">使用 &lt;code&gt;Math.round(num * 100) / 100&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bd604b7778cb749d711fce9848c8397bb74f3d3" translate="yes" xml:space="preserve">
          <source>Use it with:</source>
          <target state="translated">用它与。</target>
        </trans-unit>
        <trans-unit id="287f960a3fb8c81611e2058a39f3f4dbd770ca5c" translate="yes" xml:space="preserve">
          <source>Use something like this 
&quot;parseFloat(parseFloat(value).toFixed(2))&quot;</source>
          <target state="translated">使用像这样的 &quot;parseFloat(parseFloat(value).toFixed(2))&quot;</target>
        </trans-unit>
        <trans-unit id="1e246aa236aacfd965aad87ba2d103b9f3166262" translate="yes" xml:space="preserve">
          <source>Use this function &lt;code&gt;Number(x).toFixed(2);&lt;/code&gt;</source>
          <target state="translated">使用此函数 &lt;code&gt;Number(x).toFixed(2);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f36b531ef3ac37932099200af1af63e95a073826" translate="yes" xml:space="preserve">
          <source>Using the exponential notation handles rounding of +ve numbers, correctly.
However, this method fails to round -ve edge cases correctly.</source>
          <target state="translated">使用指数记数法正确地处理了+ve的四舍五入。但是,这种方法不能正确地对-ve边的情况进行四舍五入。</target>
        </trans-unit>
        <trans-unit id="782632eccf1234978150e666e6c53e7e804c43c0" translate="yes" xml:space="preserve">
          <source>You can see that all three numbers are the same at your browser console, Node shell, or other JavaScript interpreter. Just compare them:</source>
          <target state="translated">你可以在浏览器控制台、Node shell或其他JavaScript解释器中看到这三个数字都是一样的。比较一下就知道了。</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">你可以使用</target>
        </trans-unit>
        <trans-unit id="dec1b74b3d17f081a5bca5eb814e512fffe48c57" translate="yes" xml:space="preserve">
          <source>You could enhance it to round to any arbitrary number of decimals by adding a second parameter.</source>
          <target state="translated">你可以通过添加第二个参数来增强它,将其四舍五入到任意的小数点。</target>
        </trans-unit>
        <trans-unit id="a0e67eb620416238a8b294395b73dca4cd9691e0" translate="yes" xml:space="preserve">
          <source>You might want to go ahead and make a separate function to do it for you though:</source>
          <target state="translated">你可能会想去做一个单独的功能来为你做,虽然。</target>
        </trans-unit>
        <trans-unit id="1fbe39fdfef0c51e98d97ae9df64c7e3ee2085a2" translate="yes" xml:space="preserve">
          <source>You should use:</source>
          <target state="translated">你应该使用。</target>
        </trans-unit>
        <trans-unit id="1975acf7e3e1614d24accc2456f01338f73bcf5d" translate="yes" xml:space="preserve">
          <source>for more information, you can have a look at this link</source>
          <target state="translated">欲了解更多信息,你可以看一下这个链接</target>
        </trans-unit>
        <trans-unit id="c9736e8b5c06255cf70c5c66cbb121f59efb655d" translate="yes" xml:space="preserve">
          <source>let &lt;em&gt;n&lt;/em&gt;, &lt;em&gt;k&lt;/em&gt;, and &lt;em&gt;s&lt;/em&gt; be integers such that &lt;em&gt;k&lt;/em&gt; &amp;ge; 1, 10&lt;sup&gt;&lt;i&gt;k&lt;/i&gt;-1&lt;/sup&gt; &amp;le; &lt;em&gt;s&lt;/em&gt; &amp;lt; 10&lt;sup&gt;&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt;, the Number value for &lt;em&gt;s&lt;/em&gt; &amp;times; 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;-&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt; is &lt;em&gt;m&lt;/em&gt;, and &lt;em&gt;k&lt;/em&gt; is as small as possible. Note that k is the number of digits in the decimal representation of &lt;em&gt;s&lt;/em&gt;, that &lt;em&gt;s&lt;/em&gt; is not divisible by 10, and that the least significant digit of &lt;em&gt;s&lt;/em&gt; is not necessarily uniquely determined by these criteria.</source>
          <target state="translated">令&lt;em&gt;n&lt;/em&gt; ， &lt;em&gt;k&lt;/em&gt;和&lt;em&gt;s&lt;/em&gt;为整数，使得k&amp;ge;1，10 &lt;sup&gt;&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt; -1&amp;le;s &amp;lt;10 &lt;sup&gt;&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt; ， &lt;em&gt;s&lt;/em&gt; &amp;times;10 &lt;sup&gt;&lt;i&gt;n&lt;/i&gt; - &lt;i&gt;k&lt;/i&gt;&lt;/sup&gt;的Number值为&lt;em&gt;m&lt;/em&gt; ，并且&lt;em&gt;k&lt;/em&gt;尽可能小。 请注意，k是&lt;em&gt;s&lt;/em&gt;的十进制表示形式中的位数， &lt;em&gt;s&lt;/em&gt;不能被10整除，并且&lt;em&gt;s&lt;/em&gt;的最低有效位不一定由这些准则唯一确定。</target>
        </trans-unit>
        <trans-unit id="79a55b28f42f64f7f17d4f2f7c30cbe7a2bd50a6" translate="yes" xml:space="preserve">
          <source>then you can just &lt;code&gt;parseFloat&lt;/code&gt; and zeroes will 'go away'.</source>
          <target state="translated">那么您只需 &lt;code&gt;parseFloat&lt;/code&gt; ，零将&amp;ldquo;消失&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="d9b4f0c3f620d92bff0c5ce1441899f7830fa702" translate="yes" xml:space="preserve">
          <source>to know the difference between toFixed and round. You can have a look at &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/566564/javascript-functions-math-roundnum-vs-num-tofixed0-and-browser-inconsistenci&quot;&gt;Math.round(num) vs num.toFixed(0) and browser inconsistencies&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">知道toFix和round之间的区别。 您可以看看&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/566564/javascript-functions-math-roundnum-vs-num-tofixed0-and-browser-inconsistenci&quot;&gt;Math.round（num）与num.toFixed（0）和浏览器不一致&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="88e23d7331fc1070d7d98a821a40134dbbdd7cca" translate="yes" xml:space="preserve">
          <source>toFixed() will also &lt;strong&gt;NOT&lt;/strong&gt; round correctly in some cases (tested in Chrome v.55.0.2883.87)!</source>
          <target state="translated">在某些情况下，toFixed（）也&lt;strong&gt;不会&lt;/strong&gt;正确舍入（已在Chrome v.55.0.2883.87中测试）！</target>
        </trans-unit>
        <trans-unit id="8a851e1ca9928f5dba505859dc2784363657f289" translate="yes" xml:space="preserve">
          <source>which is closer to 0.01 than to 0.02.</source>
          <target state="translated">它接近于0.01,而不是0.02。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
