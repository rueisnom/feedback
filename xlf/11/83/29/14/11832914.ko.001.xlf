<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/11832914">
    <body>
      <group id="11832914">
        <trans-unit id="b6ece284bdcef543af3fa04af9f8140b35cca2c3" translate="yes" xml:space="preserve">
          <source>(As an alternative, you could also try the &lt;a href=&quot;https://github.com/jhohlfeld/round10&quot;&gt;round10&lt;/a&gt; library which provides a similarly-behaving function with a wildly different implementation.)</source>
          <target state="translated">(대안으로, 다른 구현으로 비슷하게 동작하는 기능을 제공하는 &lt;a href=&quot;https://github.com/jhohlfeld/round10&quot;&gt;round10&lt;/a&gt; 라이브러리를 사용해 볼 수도 있습니다.)</target>
        </trans-unit>
        <trans-unit id="6681674ef7ab7bb360570aaedfa1b23c78b184b2" translate="yes" xml:space="preserve">
          <source>... I get 0.015, which should round to 0.02, and which is noticeably &lt;em&gt;not&lt;/em&gt; the 56-decimal-place number I earlier said that all of these numbers were exactly equal to. So what dark magic is this?</source>
          <target state="translated">... 0.015를 얻습니다. 0.02로 반올림해야합니다. 이것은 이전 에이 모든 숫자가 정확히 같았다고 말한 56 세 자리 수는 &lt;em&gt;아닙니다&lt;/em&gt; . 이게 무슨 마법입니까?</target>
        </trans-unit>
        <trans-unit id="c6a08c79c3157a0800a5664fbe8ac079f3090599" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toFixed(2)&lt;/code&gt; here 2 is number of digits upto which we want to round this num.</source>
          <target state="translated">&lt;code&gt;toFixed(2)&lt;/code&gt; 여기서 2는이 숫자를 반올림 할 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="6f89dbbb6171fb257097653bce48c99201d2bf6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT (2019):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;편집 (2019) :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="94c3f2940bab5ea0c2d43ef846e1ca78e2d60ba3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT (december 2019):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;편집 (2019 년 12 월) :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e23e8588def29ed89ca632405fa7089ba47d19e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; to ensure things like 1.005 round correctly, we use</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; 1.005와 같은 것을 올바르게 반올림하기 위해</target>
        </trans-unit>
        <trans-unit id="4abe7a00ac8031d5894c9ec2f50051099b25c203" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; This is not a universal solution for everyone. There are several different rounding algorithms, your implementation can be different, depends on your requirements. &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;https://en.wikipedia.org/wiki/Rounding&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 이것은 모든 사람에게 보편적 인 솔루션은 아닙니다. 몇 가지 다른 반올림 알고리즘이 있으며 구현이 다를 수 있으며 요구 사항에 따라 다릅니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;https://en.wikipedia.org/wiki/Rounding&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5700e435626d6a7bc525fba922f6696dce2146e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;None of the answers found here is correct&lt;/strong&gt;. @stinkycheeseman asked to &lt;strong&gt;round up&lt;/strong&gt;, you all rounded the number.</source>
          <target state="translated">&lt;strong&gt;여기서 찾은 답변 중 올바른 것은 없습니다&lt;/strong&gt; . @stinkycheeseman은 반올림을 요청했습니다. 모두 수를 반올림했습니다.</target>
        </trans-unit>
        <trans-unit id="8f505dab513fc6e66e32870147f13bf544aaf130" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 1&lt;/strong&gt; is to use a script with required rounding algorithm, for example:</source>
          <target state="translated">&lt;strong&gt;솔루션 1&lt;/strong&gt; 은 필요한 반올림 알고리즘이있는 스크립트를 사용하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="60da7ee155aad83e9fc691a1e3f288cb20397643" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 2&lt;/strong&gt; is to avoid front end calculations and pull rounded values from the backend server.</source>
          <target state="translated">&lt;strong&gt;해결 방법 2&lt;/strong&gt; 는 프런트 엔드 계산을 피하고 백엔드 서버에서 반올림 된 값을 가져 오는 것입니다.</target>
        </trans-unit>
        <trans-unit id="de4e79b8a1f775972ba777a47804a2f6c93dc4ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;That is simply the way floating point numbers works in a computer.&lt;/strong&gt; Like 99% of programming languages, JavaScript doesn't have &lt;em&gt;home made&lt;/em&gt; floating point numbers; it relies on the CPU/FPU for that. A computer uses binary, and in binary, there isn't any numbers like &lt;code&gt;0.1&lt;/code&gt;, but a mere binary approximation for that. Why? For the same reason than 1/3 cannot be written in decimal: its value is 0.33333333... with an infinity of threes.</source>
          <target state="translated">&lt;strong&gt;이는 부동 소수점 숫자가 컴퓨터에서 작동하는 방식입니다.&lt;/strong&gt; 프로그래밍 언어의 99 %와 마찬가지로 JavaScript에는 &lt;em&gt;집에서 만든&lt;/em&gt; 부동 소수점 숫자가 없습니다. 이를 위해 CPU / FPU에 의존합니다. 컴퓨터는 이진법을 사용하며, 이진법에서는 &lt;code&gt;0.1&lt;/code&gt; 과 같은 숫자는 없지만 그에 대한 단순한 이진 근사법입니다. 왜? 같은 이유로 1/3보다 10 진수로 쓸 수 없습니다. 값은 0.33333333입니다. 무한대는 3입니다.</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1b2af8daa9bf0f51bff3121bdff06a9eef9fdbd" translate="yes" xml:space="preserve">
          <source>A precise rounding method. Source: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Mozilla&lt;/a&gt;</source>
          <target state="translated">정확한 반올림 방법. 출처 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Mozilla&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="69b2d171eb62a98f494d32dbf0399f2c6f867adf" translate="yes" xml:space="preserve">
          <source>A simple drop in solution that provides accurate decimal rounding, flooring, and ceiling, with an optional precision variable without adding a whole library.</source>
          <target state="translated">전체 라이브러리를 추가하지 않고도 선택적 정밀도 변수를 사용하여 정확한 10 진수 반올림, 바닥 및 천장을 제공하는 간단한 솔루션 드롭.</target>
        </trans-unit>
        <trans-unit id="d87b6d4b2b1d92b09f50fecdbf7a3fb93cdb0de7" translate="yes" xml:space="preserve">
          <source>Adapted from the solution provided here: &lt;a href=&quot;https://stackoverflow.com/a/48850944/6910392&quot;&gt;https://stackoverflow.com/a/48850944/6910392&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/48850944/6910392&quot;&gt;https://stackoverflow.com/a/48850944/6910392에&lt;/a&gt; 제공된 솔루션에서 채택되었습니다.</target>
        </trans-unit>
        <trans-unit id="b39ace06fe7843f11aa15e7af8ac8aa65286c4d1" translate="yes" xml:space="preserve">
          <source>After running through various iterations of all the possible ways to achieve true accurate decimal rounding precision, it is clear that the most accurate and efficient solution is to use Number.EPSILON. This provides a true mathematical solution to the problem of floating point math precision. It can be easily polyfilled as shown here: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&lt;/a&gt; to support all of the last remaining IE users (then again maybe we should stop doing that).</source>
          <target state="translated">정확한 정확한 십진 반올림 정밀도를 달성하기 위해 가능한 모든 방법을 다양하게 반복 한 후에 가장 정확하고 효율적인 솔루션은 Number.EPSILON을 사용하는 것입니다. 이는 부동 소수점 수학 정밀도 문제에 대한 진정한 수학 솔루션을 제공합니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&lt;/a&gt; 은 다음과 같이 쉽게 채울 수 있습니다. 그만해야합니다).</target>
        </trans-unit>
        <trans-unit id="f575b52acd8ef9eab6fdcf0d803b1f78d5741f89" translate="yes" xml:space="preserve">
          <source>Also it's worth noting that this is not a &lt;em&gt;JavaScript weirdness&lt;/em&gt; like some people stated.</source>
          <target state="translated">또한 이것은 일부 사람들이 언급 한 것처럼 &lt;em&gt;JavaScript 이상한&lt;/em&gt; 점이 아니라는 점에 주목할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4937c3ee7e26dbf578cfd6247ad524d28ec2b62" translate="yes" xml:space="preserve">
          <source>As asked in the comments, let's clarify one thing: adding &lt;code&gt;Number.EPSILON&lt;/code&gt; is relevant only when the value to round is the result of an arithmetic operation, as it can swallow some floating point error delta.</source>
          <target state="translated">주석에서 묻는 것처럼 한 가지를 분명히 해 보겠습니다. &lt;code&gt;Number.EPSILON&lt;/code&gt; 추가는 일부 부동 소수점 오류 델타를 삼킬 수 있으므로 반올림 할 값이 산술 연산의 결과 인 경우에만 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="5c1aa79e884353e01805297b4ffdc0e1b809104c" translate="yes" xml:space="preserve">
          <source>But what if you have the second kind of Number - a value taken from a continuous scale, where there's no reason to think that approximate decimal representations with fewer decimal places are more &lt;em&gt;accurate&lt;/em&gt; than those with more? In that case, we &lt;em&gt;don't&lt;/em&gt; want to respect the String representation, because that representation (as explained in the spec) is already sort-of-rounded; we don't want to make the mistake of saying &quot;0.014999999...375 rounds up to 0.015, which rounds up to 0.02, so 0.014999999...375 rounds up to 0.02&quot;.</source>
          <target state="translated">그러나 두 번째 종류의 숫자-연속 스케일에서 가져온 값을 사용하면 소수점 이하 자릿수가 적은 근사 소수를 더 많이 나타내는 것보다 더 &lt;em&gt;정확&lt;/em&gt; 하다고 생각할 이유가 없습니다. 이 경우, 우리 &lt;em&gt;는&lt;/em&gt; String 표현을 존중하고 싶지 &lt;em&gt;않습니다.&lt;/em&gt; 그 표현은 (사양에서 설명 된 바와 같이) 이미 반올림 되었기 때문입니다. &quot;0.014999999 ... 375는 0.015로 반올림하여 0.02로 반올림하므로 0.014999999 ... 375는 0.02로 반올림&quot;하는 실수를 저지르고 싶지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab662aee31f190e347238c5fbc1e7d6128a3dbdd" translate="yes" xml:space="preserve">
          <source>Compared to Lavamantis's solution, we can do...</source>
          <target state="translated">Lavamantis의 솔루션과 비교하여 우리는 할 수 있습니다 ...</target>
        </trans-unit>
        <trans-unit id="8589b8976170efc90ee30bed08325d4b4f5fb025" translate="yes" xml:space="preserve">
          <source>Consider &lt;code&gt;.toFixed()&lt;/code&gt; and &lt;code&gt;.toPrecision()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.toFixed()&lt;/code&gt; 및 &lt;code&gt;.toPrecision()&lt;/code&gt; 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="85511932eb0bd6ee919a34a7f2c6087bb0a5fb7b" translate="yes" xml:space="preserve">
          <source>Easiest way:</source>
          <target state="translated">가장 쉬운 방법:</target>
        </trans-unit>
        <trans-unit id="5e297a41e8ef5ac08adf9ee0810c2244721fa92b" translate="yes" xml:space="preserve">
          <source>Eg:</source>
          <target state="translated">Eg:</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="945a73f60f58235e70de75adb211e4394558c073" translate="yes" xml:space="preserve">
          <source>For me &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Math.round()&lt;/a&gt; was not giving correct answer. I found &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt;toFixed(2)&lt;/a&gt; works better. 
Below are examples of both:</source>
          <target state="translated">나에게 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Math.round ()&lt;/a&gt; 는 정답을주지 못했습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt;toFixed (2)&lt;/a&gt; 가 더 잘 작동 한다는 것을 알았습니다. 아래는 두 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="edbdada6b4155dd45ec8fd8ab20607a6462b6549" translate="yes" xml:space="preserve">
          <source>Here come &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/a&gt;. That number is the difference between 1 and the &lt;em&gt;next&lt;/em&gt; number existing in the double precision floating point numbers. &lt;strong&gt;That's it: There is no number between &lt;code&gt;1&lt;/code&gt; and 1 + &lt;code&gt;Number.EPSILON&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">여기 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; 이&lt;/a&gt; 있습니다. 이 숫자는 배정 밀도 부동 소수점 숫자에 존재하는 1과 &lt;em&gt;다음&lt;/em&gt; 숫자의 차이입니다. &lt;strong&gt;그게 다야 : &lt;code&gt;1&lt;/code&gt; 과 1 + &lt;code&gt;Number.EPSILON&lt;/code&gt; 사이에는 숫자가 없습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="582a28d3d6f5875f42faffd53f6dca41c44e4409" translate="yes" xml:space="preserve">
          <source>Here is a prototype method:</source>
          <target state="translated">다음은 프로토 타입 방법입니다.</target>
        </trans-unit>
        <trans-unit id="2becac006f82ed17841b46654302952a6af24ef5" translate="yes" xml:space="preserve">
          <source>Here is a simple way to do it:</source>
          <target state="translated">간단한 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="86712cc5731f9156c956e2225c2cb563bb12f349" translate="yes" xml:space="preserve">
          <source>Here is the function I use to solve the floating point decimals issues &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round#Example%3a_Decimal_rounding&quot;&gt;also based on MDN&lt;/a&gt;. It is even more generic (but less concise) than Lavamantis's solution:</source>
          <target state="translated">다음은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round#Example%3a_Decimal_rounding&quot;&gt;MDN 기반&lt;/a&gt; 의 부동 소수점 10 진수 문제를 해결하는 데 사용하는 함수입니다. Lavamantis의 솔루션보다 훨씬 일반적이지만 덜 간결합니다.</target>
        </trans-unit>
        <trans-unit id="c0d5875b4c5849ab3bfd33eea8d2f49977f4bd52" translate="yes" xml:space="preserve">
          <source>Here we can simply use the built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt;&lt;code&gt;toFixed&lt;/code&gt;&lt;/a&gt; method. Note that by calling &lt;code&gt;Number()&lt;/code&gt; on the String returned by &lt;code&gt;toFixed&lt;/code&gt;, we get a Number whose String representation has no trailing zeroes (thanks to the way JavaScript computes the String representation of a Number, discussed earlier in this answer).</source>
          <target state="translated">여기서는 내장 된 고정 방법을 사용할 수 있습니다. &lt;code&gt;toFixed&lt;/code&gt; 가 반환 한 String에서 &lt;code&gt;Number()&lt;/code&gt; 를 호출하면 String 표현에 후행 0이없는 Number가 표시됩니다 (이 답변의 앞부분에서 설명한 JavaScript가 Number의 String 표현을 계산하는 방식 덕분입니다).</target>
        </trans-unit>
        <trans-unit id="c0f0c4ff59640480547b46eb98247d0405dde5a2" translate="yes" xml:space="preserve">
          <source>Here, also is one function I wrote to do arithmetic rounding correctly. You can test it yourself.</source>
          <target state="translated">여기에 산술 반올림을 올바르게 수행하기 위해 작성한 함수도 있습니다. 직접 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75553f548ebe8d7c4d7be06075a2ad90b25c726b" translate="yes" xml:space="preserve">
          <source>How can I do this in JavaScript?</source>
          <target state="translated">JavaScript로 어떻게 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="379bf1ec8b931f6919ae70cbdb99b7a15e4424b6" translate="yes" xml:space="preserve">
          <source>I found this over on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;MDN&lt;/a&gt;. Their way avoids the problem with 1.005 that was &lt;a href=&quot;https://stackoverflow.com/questions/11832914/round-up-to-2-decimal-places-in-javascript#comment24719818_11832950&quot;&gt;mentioned&lt;/a&gt;.</source>
          <target state="translated">나는 이것을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;MDN&lt;/a&gt; 에서 발견했다. 그들의 방법은 &lt;a href=&quot;https://stackoverflow.com/questions/11832914/round-up-to-2-decimal-places-in-javascript#comment24719818_11832950&quot;&gt;언급 된&lt;/a&gt; 1.005의 문제를 피합니다.</target>
        </trans-unit>
        <trans-unit id="070221396ffd7adc80f964d497ffbcc8f1956377" translate="yes" xml:space="preserve">
          <source>I guess, this is because 1.555 is actually something like float 1.55499994 behind the scenes.</source>
          <target state="translated">내 생각에 이것은 1.555가 실제로 배후에 1.55499994 인 플로트와 같은 것이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="07e838235f2a025cd47854a685499d5a0537ecfb" translate="yes" xml:space="preserve">
          <source>I removed the variant &lt;code&gt;n.toFixed(2)&lt;/code&gt;, because it is not correct. Thank you @avalanche1</source>
          <target state="translated">&lt;code&gt;n.toFixed(2)&lt;/code&gt; 변형이 올바르지 않으므로 제거했습니다. 감사합니다 @ avalanche1</target>
        </trans-unit>
        <trans-unit id="48bd35342cfdaf130a7708310f7a72f622b696f6" translate="yes" xml:space="preserve">
          <source>I'd like to round at most 2 decimal places, but &lt;em&gt;only if necessary&lt;/em&gt;.</source>
          <target state="translated">소수점 이하 두 자리까지 반올림하고 싶지만 &lt;em&gt;필요한 경우에만&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ec800790fcee0bf08442c4630dae0d9ba7b6d988" translate="yes" xml:space="preserve">
          <source>If the value is a number:</source>
          <target state="translated">값이 숫자 인 경우 :</target>
        </trans-unit>
        <trans-unit id="b1fefa7ba2439d746003f46853a7371ff731d113" translate="yes" xml:space="preserve">
          <source>If the value is a text type:</source>
          <target state="translated">값이 텍스트 유형 인 경우 :</target>
        </trans-unit>
        <trans-unit id="e41c41447951ebc94d036fd32ec620302036e867" translate="yes" xml:space="preserve">
          <source>If you are open to libraries you can use &lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;bignumber.js&lt;/a&gt;</source>
          <target state="translated">라이브러리가 열려 있으면 &lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;bignumber.js&lt;/a&gt; 를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="dc26938bf0e0296802c89e07ccde26e1ab90731a" translate="yes" xml:space="preserve">
          <source>If you are using lodash library, you can use the round method of lodash like following.</source>
          <target state="translated">lodash 라이브러리를 사용하는 경우 다음과 같이 lodash의 라운드 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3216546a05d95fdf5f5508347421f9837590b56b" translate="yes" xml:space="preserve">
          <source>If you need to be strict and add digits just if needed it can use &lt;code&gt;replace&lt;/code&gt;</source>
          <target state="translated">엄격해야하고 필요한 경우 숫자를 추가하면 &lt;code&gt;replace&lt;/code&gt; 를 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a938b4696af9e98610818f1d8d206757dad7ae27" translate="yes" xml:space="preserve">
          <source>If your project uses jQuery or lodash, you can also find proper &lt;code&gt;round&lt;/code&gt; method in the libraries.</source>
          <target state="translated">프로젝트가 jQuery 또는 lodash를 사용하는 경우 라이브러리에서 적절한 &lt;code&gt;round&lt;/code&gt; 방법을 찾을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6af9e62dcf39a0d15e0f97e5a60d274500525b0b" translate="yes" xml:space="preserve">
          <source>In fact, in the code I'm using &lt;code&gt;ESPILON_RATE = 1 + 4 * Number.EPSILON&lt;/code&gt; and &lt;code&gt;EPSILON_ZERO = 4 * Number.MIN_VALUE&lt;/code&gt; (four times the epsilon), because I want an equality checker loose enough for cumulating floating point error.</source>
          <target state="translated">실제로 코드에서 &lt;code&gt;ESPILON_RATE = 1 + 4 * Number.EPSILON&lt;/code&gt; 및 &lt;code&gt;EPSILON_ZERO = 4 * Number.MIN_VALUE&lt;/code&gt; (엡실론의 4 배)를 사용하고 있습니다. 왜냐하면 부동 소수점 오류를 누적하기에 충분한 등식 검사기가 필요하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="ef69761016065df342a41f1ba61cbdee1af2e52f" translate="yes" xml:space="preserve">
          <source>In general, rounding is done by scaling: &lt;code&gt;round(num / p) * p&lt;/code&gt;</source>
          <target state="translated">일반적으로 반올림은 스케일링에 의해 수행됩니다. &lt;code&gt;round(num / p) * p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="79d70dcb4f9ee8b7d94ed9539586cc73c0d399da" translate="yes" xml:space="preserve">
          <source>Input:</source>
          <target state="translated">Input:</target>
        </trans-unit>
        <trans-unit id="5bdb51e539dd788122b75e12613282cb9a59033d" translate="yes" xml:space="preserve">
          <source>It converts it to a string, and then back into an integer / float.</source>
          <target state="translated">문자열로 변환 한 다음 다시 정수 / 부동 소수점으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="e7f26dce8602d2aa4e2f07b9f0b39e5804a7316d" translate="yes" xml:space="preserve">
          <source>It doesn't solve the '1.005 rounding problem' though - since it is intrinsic to how &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/101163/what-causes-floating-point-rounding-errors&quot;&gt;float fractions are being processed&lt;/a&gt;.</source>
          <target state="translated">'1.005 반올림 문제'는 해결하지 못합니다. &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/101163/what-causes-floating-point-rounding-errors&quot;&gt;부동 소수점이 처리되는&lt;/a&gt; 방식에 내재되어 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="bb18705dfa4dbaefc58019dd86183424f5d60d6a" translate="yes" xml:space="preserve">
          <source>It may work for you,</source>
          <target state="translated">그것은 당신을 위해 일할 수 있습니다,</target>
        </trans-unit>
        <trans-unit id="9db4057b0b1aefd3eabe9d5558fa88ce0408b22f" translate="yes" xml:space="preserve">
          <source>It seems like &lt;code&gt;Math.round&lt;/code&gt; is a better solution. &lt;strong&gt;But it is not!&lt;/strong&gt; In some cases it will &lt;strong&gt;NOT&lt;/strong&gt; round correctly:</source>
          <target state="translated">&lt;code&gt;Math.round&lt;/code&gt; 가 더 나은 솔루션 인 것 같습니다. &lt;strong&gt;그러나 그렇지 않습니다!&lt;/strong&gt; 어떤 경우에는 올바르게 반올림 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="de7e2f930d8192a22533ff7c52eeb7a294e46200" translate="yes" xml:space="preserve">
          <source>It's not useful when the value comes from a direct source (e.g.: literal, user input or sensor).</source>
          <target state="translated">값이 직접 소스 (예 : 리터럴, 사용자 입력 또는 센서)에서 오는 경우에는 유용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d16bae6ae960069cfbe9eb6b916a4ba5bc5ae155" translate="yes" xml:space="preserve">
          <source>Just use native code &lt;code&gt;.toFixed()&lt;/code&gt;</source>
          <target state="translated">네이티브 코드를 사용하십시오. &lt;code&gt;.toFixed()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b1a5d323275c298c4aa9b8992ef25578960b7c0" translate="yes" xml:space="preserve">
          <source>Lately, I use a function similar to this one for comparing numbers epsilon-aware:</source>
          <target state="translated">최근에 나는 엡실론을 인식하는 숫자를 비교하기 위해이 기능과 비슷한 기능을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="adb23d3b5115886051bb54739f5c553032bc9dc7" translate="yes" xml:space="preserve">
          <source>Like @maganap and some peoples have pointed out, it's best to add &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/a&gt; before multiplying:</source>
          <target state="translated">@maganap과 일부 사람들이 지적했듯이 곱하기 전에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; &lt;/a&gt; 을 추가하는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2787e27648a8b92aefd69a68e92ccec35c88a574" translate="yes" xml:space="preserve">
          <source>MarkG and Lavamantis offered a much better solution than the one that has been accepted. It's a shame they don't get more upvotes!</source>
          <target state="translated">MarkG와 Lavamantis는 수용된 것보다 훨씬 나은 솔루션을 제공했습니다. 그들이 더 많은지지를 얻지 못하는 것은 부끄러운 일입니다!</target>
        </trans-unit>
        <trans-unit id="e9cb187413866bee5719685fd8cb0c4a9882de1d" translate="yes" xml:space="preserve">
          <source>MarkG's answer is the correct one.  Here's a generic extension for any number of decimal places.</source>
          <target state="translated">MarkG의 답변이 정답입니다. 소수점 이하 자릿수에 대한 일반적인 확장은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="428f9655e67ff46265d67320cd0ccfe0319be407" translate="yes" xml:space="preserve">
          <source>Math.round(num) vs num.toFixed(0) and browser inconsistencies</source>
          <target state="translated">Math.round (num) 대 num.toFixed (0) 및 브라우저 불일치</target>
        </trans-unit>
        <trans-unit id="ff707f109be190d332352b938ccc8b3c4e06e97c" translate="yes" xml:space="preserve">
          <source>My use-case is &lt;a href=&quot;https://www.npmjs.com/package/doormen&quot;&gt;an assertion + data validation lib&lt;/a&gt; I'm developing for many years.</source>
          <target state="translated">내 유스 케이스는 몇 년 동안 개발중인 &lt;a href=&quot;https://www.npmjs.com/package/doormen&quot;&gt;주장 + 데이터 유효성 검사 라이브러리&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="59377d5faf3749e97822f1f1971ecded10a972a6" translate="yes" xml:space="preserve">
          <source>No one seems to be aware of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">아무도 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; 을&lt;/a&gt; 알고있는 것 같지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="ca5e324249ddd6187831ef808ea93363a2b26711" translate="yes" xml:space="preserve">
          <source>Of course, none of this discussion has directly answered what &lt;code&gt;roundTo2DP(m)&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; return. If &lt;code&gt;m&lt;/code&gt;'s exact value is 0.01499999999999999944488848768742172978818416595458984375, but its String representation is '0.015', then what is the &lt;em&gt;correct&lt;/em&gt; answer - mathematically, practically, philosophically, or whatever - when we round it to two decimal places?</source>
          <target state="translated">물론,이 토론 중 어느 것도 &lt;code&gt;roundTo2DP(m)&lt;/code&gt; &lt;em&gt;이&lt;/em&gt; 어떤 것을 반환 해야하는지 직접 대답하지 않았습니다. &lt;code&gt;m&lt;/code&gt; 의 정확한 값이 0.01499999999999999944488848768742172978818416595458984375이지만 문자열 표현이 '0.015'인 경우 수학적으로, 실제적으로, 철학적으로 또는 소수점 이하 두 자리로 반올림 할 때 정답은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9de972621e113a6822f18823d2063f32eba7fcf6" translate="yes" xml:space="preserve">
          <source>On the other hand, you probably want to respect the binary floating point value and round downwards when your value is from an inherently continuous scale - for instance, if it's a reading from a sensor.</source>
          <target state="translated">반면, 이진 부동 소수점 값을 존중하고 값이 본질적으로 연속적인 스케일 (예 : 센서에서 읽은 값) 인 경우 아래쪽으로 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="6bbbecb3438fd6440ef7f77e7aea3b5d8bdb6531" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;.toFixed(NumberOfDecimalPlaces)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.toFixed(NumberOfDecimalPlaces)&lt;/code&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="576fa80104f1e9d06e3d6fd8ed6dedc8629cc5e4" translate="yes" xml:space="preserve">
          <source>One way to achieve such a rounding &lt;em&gt;only if necessary&lt;/em&gt; is to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString&quot;&gt;Number.prototype.toLocaleString()&lt;/a&gt;:</source>
          <target state="translated">&lt;em&gt;필요한 경우에만&lt;/em&gt; 이러한 반올림을 달성하는 한 가지 방법은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString&quot;&gt;Number.prototype.toLocaleString ()&lt;/a&gt; 을 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="c1d0e0227161567c5c8a46e530e257ab7932de2e" translate="yes" xml:space="preserve">
          <source>Round to at most 2 decimal places (only if necessary)</source>
          <target state="translated">소수점 이하 2 자리까지 반올림 (필요한 경우에만)</target>
        </trans-unit>
        <trans-unit id="1b3ea2091e0125bb10b50729a167add8b2875170" translate="yes" xml:space="preserve">
          <source>Since ES6 there is a 'proper' way (without overriding statics and creating workarounds) to do this by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Number/toPrecision&quot;&gt;using toPrecision&lt;/a&gt;</source>
          <target state="translated">ES6부터 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Number/toPrecision&quot;&gt;toPrecision&lt;/a&gt; 을 사용하여 이것을 수행하는 '적절한'방법이 있습니다 (정적을 재정의하지 않고 해결 방법을 작성하지 않음)</target>
        </trans-unit>
        <trans-unit id="c131372ed2ef9d5afca4b7ffe157d796543820d0" translate="yes" xml:space="preserve">
          <source>So far, it looks perfect for me.
I hope it will help.</source>
          <target state="translated">지금까지는 나에게 완벽 해 보입니다. 도움이 되길 바랍니다.</target>
        </trans-unit>
        <trans-unit id="d9eb0d47c4da3723a4af8473544b8419da09be27" translate="yes" xml:space="preserve">
          <source>So when I write &lt;code&gt;m = 0.0150000000000000001&lt;/code&gt;, the &lt;em&gt;exact value of &lt;code&gt;m&lt;/code&gt;&lt;/em&gt; that I end up with is closer to &lt;code&gt;0.01&lt;/code&gt; than it is to &lt;code&gt;0.02&lt;/code&gt;. And yet, if I convert &lt;code&gt;m&lt;/code&gt; to a String...</source>
          <target state="translated">따라서 &lt;code&gt;m = 0.0150000000000000001&lt;/code&gt; 쓰면 m 의 &lt;em&gt;정확한 값은&lt;/em&gt; &lt;code&gt;0.02&lt;/code&gt; 보다 &lt;code&gt;0.01&lt;/code&gt; 에 가깝습니다. 그러나 &lt;code&gt;m&lt;/code&gt; 을 문자열로 변환하면 ...</target>
        </trans-unit>
        <trans-unit id="3b8d42473f0fced361a981334f253d2ee119f7bd" translate="yes" xml:space="preserve">
          <source>Suppose we have a function, &lt;code&gt;roundTo2DP(num)&lt;/code&gt;, that takes a float as an argument and returns a value rounded to 2 decimal places. What should each of these expressions evaluate to?</source>
          <target state="translated">float를 인수로 사용하고 소수점 이하 2 자리로 반올림 한 값을 반환하는 &lt;code&gt;roundTo2DP(num)&lt;/code&gt; 함수가 있다고 가정합니다. 이러한 각 표현은 무엇을 평가해야합니까?</target>
        </trans-unit>
        <trans-unit id="6bfb5e628c414a067972ade779b24a3a568b3fd7" translate="yes" xml:space="preserve">
          <source>The 'obvious' answer is that the first example should round to 0.01 (because it's closer to 0.01 than to 0.02) while the other two should round to 0.02 (because 0.0150000000000000001 is closer to 0.02 than to 0.01, and because 0.015 is exactly halfway between them and there is a mathematical convention that such numbers get rounded up).</source>
          <target state="translated">'명백한'답변은 첫 번째 예제는 0.01로 반올림해야하고 (0.02보다 0.01에 가깝기 때문에) 다른 두 개는 0.02로 반올림해야합니다 (0.0150000000000000001은 0.01보다 0.02에 가깝기 때문에 0.015는 정확히 중간에 있기 때문에) 그들과 같은 숫자가 반올림되는 수학적 규칙이 있습니다).</target>
        </trans-unit>
        <trans-unit id="c544245c0ffab197bc3584e928cfc903bd4d3964" translate="yes" xml:space="preserve">
          <source>The answer can be found in the ECMAScript specification, in section &lt;a href=&quot;http://www.ecma-international.org/ecma-262/7.0/#sec-tostring-applied-to-the-number-type&quot;&gt;&lt;em&gt;7.1.12.1: ToString applied to the Number type&lt;/em&gt;&lt;/a&gt;. Here the rules for converting some Number &lt;em&gt;m&lt;/em&gt; to a String are laid down. The key part is point 5, in which an integer &lt;em&gt;s&lt;/em&gt; is generated whose digits will be used in the String representation of &lt;em&gt;m&lt;/em&gt;:</source>
          <target state="translated">이에 대한 답변은 ECMAScript 사양의 &lt;a href=&quot;http://www.ecma-international.org/ecma-262/7.0/#sec-tostring-applied-to-the-number-type&quot;&gt;&lt;em&gt;7.1.12.1 : ToString이 Number 유형에 적용됨&lt;/em&gt;&lt;/a&gt; 섹션에 있습니다. 여기에 일부 숫자 &lt;em&gt;m&lt;/em&gt; 을 문자열로 변환하는 규칙이 정리되어 있습니다. 핵심 부분은 포인트 5이며, &lt;em&gt;m&lt;/em&gt; 의 문자열 표현에 숫자가 사용될 정수 &lt;em&gt;s&lt;/em&gt; 가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="df090e3c30fa1d731e05b5ce4f35661d5e7baf7c" translate="yes" xml:space="preserve">
          <source>The catch, which you may have guessed, is that &lt;code&gt;roundTo2DP&lt;/code&gt;&lt;em&gt;cannot possibly&lt;/em&gt; be implemented to give those obvious answers, because all three numbers passed to it are &lt;em&gt;the same number&lt;/em&gt;. IEEE 754 binary floating point numbers (the kind used by JavaScript) can't exactly represent most non-integer numbers, and so all three numeric literals above get rounded to a nearby valid floating point number. This number, as it happens, is &lt;em&gt;exactly&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;어쩌면&lt;/em&gt; &lt;code&gt;roundTo2DP&lt;/code&gt; &lt;em&gt;수&lt;/em&gt; 있겠지만 , roundTo2DP &lt;em&gt;는&lt;/em&gt; 전달 된 세 개의 숫자가 모두 같은 숫자이기 때문에 이러한 명확한 답변을 제공하기 위해 구현할 &lt;em&gt;수 없습니다&lt;/em&gt; . IEEE 754 이진 부동 소수점 숫자 (JavaScript에서 사용되는 종류)는 대부분의 정수가 아닌 숫자를 정확하게 나타낼 수 없으므로 위의 세 숫자 리터럴은 모두 근처의 유효한 부동 소수점 숫자로 반올림됩니다. 이 숫자는 발생하는 &lt;em&gt;대로 정확하게&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17eaea0baa02c017f3ef107833be95e25d292bd7" translate="yes" xml:space="preserve">
          <source>The function above is &lt;em&gt;probably&lt;/em&gt; what you want to use to avoid users ever witnessing numbers that they have entered being rounded wrongly.</source>
          <target state="translated">위의 기능은 사용자가 입력 한 숫자가 잘못 반올림되는 것을 방지하기 위해 사용하려는 &lt;em&gt;것일&lt;/em&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a1df7bf3e06ffb09c0be63d9ac99109b43decd2" translate="yes" xml:space="preserve">
          <source>The key part here is the requirement that &quot;&lt;em&gt;k&lt;/em&gt; is as small as possible&quot;. What that requirement amounts to is a requirement that, given a Number &lt;code&gt;m&lt;/code&gt;, the value of &lt;code&gt;String(m)&lt;/code&gt; must have &lt;em&gt;the least possible number of digits&lt;/em&gt; while still satisfying the requirement that &lt;code&gt;Number(String(m)) === m&lt;/code&gt;. Since we already know that &lt;code&gt;0.015 === 0.0150000000000000001&lt;/code&gt;, it's now clear why &lt;code&gt;String(0.0150000000000000001) === '0.015'&lt;/code&gt; must be true.</source>
          <target state="translated">여기서 중요한 부분은 &quot; &lt;em&gt;k&lt;/em&gt; 는 가능한 한 작아야&quot;한다는 요구 사항입니다. 요구 사항이 &lt;em&gt;중요한&lt;/em&gt; 것은 Number &lt;code&gt;m&lt;/code&gt; 을 지정하면 &lt;code&gt;String(m)&lt;/code&gt; 값은 &lt;em&gt;가능한 최소 자릿수&lt;/em&gt; 를 가져야하지만 &lt;code&gt;Number(String(m)) === m&lt;/code&gt; 요구 사항을 만족시켜야한다는 요구 사항입니다. 우리는 이미 &lt;code&gt;0.015 === 0.0150000000000000001&lt;/code&gt; 이라는 것을 알고 있기 때문에 &lt;code&gt;String(0.0150000000000000001) === '0.015'&lt;/code&gt; 가 참이어야하는 이유가 분명합니다.</target>
        </trans-unit>
        <trans-unit id="d9304dfd5b20a84c90c202df6981188a19c4637d" translate="yes" xml:space="preserve">
          <source>The value being represented is inherently discrete, e.g. an amount of currency in a 3-decimal-place currency like dinars. In this case, the &lt;em&gt;true&lt;/em&gt; value of a Number like 0.015 &lt;em&gt;is&lt;/em&gt; 0.015, and the 0.0149999999... representation that it gets in binary floating point is a rounding error. (Of course, many will argue, reasonably, that you should use a decimal library for handling such values and never represent them as binary floating point Numbers in the first place.)</source>
          <target state="translated">표현되는 가치는 본질적으로 불 연속적입니다 (예 : 디나르와 같은 3 자리 통화의 통화 금액). 이 경우 0.015와 같은 Number의 &lt;em&gt;실제&lt;/em&gt; 값 &lt;em&gt;은&lt;/em&gt; 0.015이며, 이진 부동 소수점으로 얻는 0.0149999999 ... 표현은 반올림 오류입니다. (물론, 많은 사람들은 그러한 값을 처리하기 위해 10 진수 라이브러리를 사용해야하며 처음에는 이진 부동 소수점 숫자로 나타내지 않아야한다고 합리적으로 주장합니다.)</target>
        </trans-unit>
        <trans-unit id="0606e71f981fa36e43313e05fde67bea41c0e859" translate="yes" xml:space="preserve">
          <source>The value was typed by a user. In this case, again, the exact decimal number entered is more 'true' than the nearest binary floating point representation.</source>
          <target state="translated">사용자가 값을 입력했습니다. 이 경우에도 입력 한 정확한 십진수는 가장 가까운 이진 부동 소수점 표현보다 '참'입니다.</target>
        </trans-unit>
        <trans-unit id="8727bcf5e244c818b657462e6c613378e3d0d0c7" translate="yes" xml:space="preserve">
          <source>Then you would simply pass in the value.</source>
          <target state="translated">그런 다음 단순히 값을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="f76d9f0b8979b7733602f015e3ba04fd7d5a9502" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to do that. For people like me, the Lodash's variant</source>
          <target state="translated">몇 가지 방법이 있습니다. 나와 같은 사람들에게 Lodash의 변형</target>
        </trans-unit>
        <trans-unit id="068e2e768c65c4ad778691dec9f43778213541e5" translate="yes" xml:space="preserve">
          <source>There is a downside that values like 1.5 will give &quot;1.50&quot; as the output. A fix suggested by @minitech:</source>
          <target state="translated">1.5와 같은 값은 &quot;1.50&quot;을 출력으로 제공한다는 단점이 있습니다. @minitech가 제안한 수정 사항 :</target>
        </trans-unit>
        <trans-unit id="38387a87e059184ebabf02e5e267b74130d78c64" translate="yes" xml:space="preserve">
          <source>There is no single correct answer to this. It depends upon your use case. You probably want to respect the String representation and round upwards when:</source>
          <target state="translated">이에 대한 올바른 정답은 없습니다. 사용 사례에 따라 다릅니다. 다음과 같은 경우 문자열 표현을 존중하고 위쪽으로 반올림하려고합니다.</target>
        </trans-unit>
        <trans-unit id="de80e004c8c33e4edbcec58d2afcf0444b42e1b1" translate="yes" xml:space="preserve">
          <source>These two approaches require different code. To respect the String representation of the Number, we can (with quite a bit of reasonably subtle code) implement our own rounding that acts directly on the String representation, digit by digit, using the same algorithm you would've used in school when you were taught how to round numbers. Below is an example which respects the OP's requirement of representing the number to 2 decimal places &quot;only when necessary&quot; by stripping trailing zeroes after the decimal point; you may, of course, need to tweak it to your precise needs.</source>
          <target state="translated">이 두 가지 접근 방식에는 다른 코드가 필요합니다. 숫자의 문자열 표현을 존중하기 위해 우리는 (합리적으로 약간의 미묘한 코드로) 학교에서 사용했을 때와 동일한 알고리즘을 사용하여 숫자로 숫자로 문자열 표현에 직접 작용하는 자체 반올림을 구현할 수 있습니다 숫자를 반올림하는 방법을 배웠습니다. 다음은 소수점 이하의 후행 0을 제거하여 &quot;필요한 경우에만&quot;소수점 이하 2 자리까지 숫자를 나타내는 OP의 요구 사항을 준수하는 예입니다. 물론 정확한 요구에 맞게 조정해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cc618b8fa630d85d81948907d250ac34fd31d00" translate="yes" xml:space="preserve">
          <source>This is the simplest, more elegant solution (and I am the best of the world;):</source>
          <target state="translated">이것은 가장 간단하고 우아한 솔루션입니다 (그리고 나는 세계 최고입니다).</target>
        </trans-unit>
        <trans-unit id="03640ca35a3d05dde0a5a618e1942cbb23d4aba2" translate="yes" xml:space="preserve">
          <source>This may help you:</source>
          <target state="translated">이것은 당신을 도울 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="e3a53ec34f6c2117910f386788bc9d743450046a" translate="yes" xml:space="preserve">
          <source>This question is complicated.</source>
          <target state="translated">이 질문은 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="13ea220ac7311f1b88e69de6b5b2c466b9a1e184" translate="yes" xml:space="preserve">
          <source>This will provide exactly the output you expect, but as strings. You can still convert those back to numbers if that's not the data type you expect.</source>
          <target state="translated">이것은 당신이 예상 한대로 정확하게 출력을 제공 할 것입니다. 예상 한 데이터 유형이 아닌 경우 숫자를 다시 숫자로 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9845257528e47964d89c7b7b37c418107088920b" translate="yes" xml:space="preserve">
          <source>To round up, use this:</source>
          <target state="translated">반올림하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cdb9e11f95eb4c3103b6460c4ec8869fcb19ed0a" translate="yes" xml:space="preserve">
          <source>Try this &lt;strong&gt;light weight&lt;/strong&gt; solution:</source>
          <target state="translated">이 &lt;strong&gt;경량&lt;/strong&gt; 솔루션을 사용해보십시오.</target>
        </trans-unit>
        <trans-unit id="c83890cd9cde34e76f22e6c092f33233337bbeef" translate="yes" xml:space="preserve">
          <source>Unit test:</source>
          <target state="translated">단위 테스트 :</target>
        </trans-unit>
        <trans-unit id="aa46e3b43b8698bd79a3510bffe6645c067a8510" translate="yes" xml:space="preserve">
          <source>Update 1</source>
          <target state="translated">업데이트 1</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="1a83ebd9832b047f8e615f8f8336e3bea08f97fc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Math.round(num * 100) / 100&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Math.round(num * 100) / 100&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bd604b7778cb749d711fce9848c8397bb74f3d3" translate="yes" xml:space="preserve">
          <source>Use it with:</source>
          <target state="translated">함께 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="287f960a3fb8c81611e2058a39f3f4dbd770ca5c" translate="yes" xml:space="preserve">
          <source>Use something like this 
&quot;parseFloat(parseFloat(value).toFixed(2))&quot;</source>
          <target state="translated">&quot;parseFloat (parseFloat (value) .toFixed (2))&quot;와 같은 것을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1e246aa236aacfd965aad87ba2d103b9f3166262" translate="yes" xml:space="preserve">
          <source>Use this function &lt;code&gt;Number(x).toFixed(2);&lt;/code&gt;</source>
          <target state="translated">이 함수를 사용하십시오. &lt;code&gt;Number(x).toFixed(2);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f36b531ef3ac37932099200af1af63e95a073826" translate="yes" xml:space="preserve">
          <source>Using the exponential notation handles rounding of +ve numbers, correctly.
However, this method fails to round -ve edge cases correctly.</source>
          <target state="translated">지수 표기법을 사용하면 + ve 숫자의 반올림을 올바르게 처리합니다. 그러나이 방법은 -ve edge 사례를 올바르게 반올림하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="782632eccf1234978150e666e6c53e7e804c43c0" translate="yes" xml:space="preserve">
          <source>You can see that all three numbers are the same at your browser console, Node shell, or other JavaScript interpreter. Just compare them:</source>
          <target state="translated">브라우저 콘솔, 노드 셸 또는 기타 JavaScript 인터프리터에서 세 숫자가 모두 같은 것을 알 수 있습니다. 그냥 그들을 비교하십시오 :</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">당신이 사용할 수있는</target>
        </trans-unit>
        <trans-unit id="dec1b74b3d17f081a5bca5eb814e512fffe48c57" translate="yes" xml:space="preserve">
          <source>You could enhance it to round to any arbitrary number of decimals by adding a second parameter.</source>
          <target state="translated">두 번째 매개 변수를 추가하여 임의의 소수 자릿수로 반올림하도록 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0e67eb620416238a8b294395b73dca4cd9691e0" translate="yes" xml:space="preserve">
          <source>You might want to go ahead and make a separate function to do it for you though:</source>
          <target state="translated">그래도 당신을 위해 그것을하기 위해 별도의 기능을 만들고 싶을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1fbe39fdfef0c51e98d97ae9df64c7e3ee2085a2" translate="yes" xml:space="preserve">
          <source>You should use:</source>
          <target state="translated">다음을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="1975acf7e3e1614d24accc2456f01338f73bcf5d" translate="yes" xml:space="preserve">
          <source>for more information, you can have a look at this link</source>
          <target state="translated">자세한 내용은이 링크를 참조하십시오</target>
        </trans-unit>
        <trans-unit id="c9736e8b5c06255cf70c5c66cbb121f59efb655d" translate="yes" xml:space="preserve">
          <source>let &lt;em&gt;n&lt;/em&gt;, &lt;em&gt;k&lt;/em&gt;, and &lt;em&gt;s&lt;/em&gt; be integers such that &lt;em&gt;k&lt;/em&gt; &amp;ge; 1, 10&lt;sup&gt;&lt;i&gt;k&lt;/i&gt;-1&lt;/sup&gt; &amp;le; &lt;em&gt;s&lt;/em&gt; &amp;lt; 10&lt;sup&gt;&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt;, the Number value for &lt;em&gt;s&lt;/em&gt; &amp;times; 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;-&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt; is &lt;em&gt;m&lt;/em&gt;, and &lt;em&gt;k&lt;/em&gt; is as small as possible. Note that k is the number of digits in the decimal representation of &lt;em&gt;s&lt;/em&gt;, that &lt;em&gt;s&lt;/em&gt; is not divisible by 10, and that the least significant digit of &lt;em&gt;s&lt;/em&gt; is not necessarily uniquely determined by these criteria.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; , &lt;em&gt;k&lt;/em&gt; 및 &lt;em&gt;s&lt;/em&gt; 는 &lt;em&gt;k&lt;/em&gt; &amp;ge; 1, 10 &lt;sup&gt;&lt;i&gt;k&lt;/i&gt; -1&lt;/sup&gt; &amp;le; &lt;em&gt;s&lt;/em&gt; &amp;lt;10 &lt;sup&gt;&lt;i&gt;k가&lt;/i&gt;&lt;/sup&gt; 되도록 정수로하고 &lt;em&gt;s&lt;/em&gt; &amp;times; 10 &lt;sup&gt;&lt;i&gt;n&lt;/i&gt; - &lt;i&gt;k&lt;/i&gt;&lt;/sup&gt; &lt;em&gt;의&lt;/em&gt; 숫자 값은 &lt;em&gt;m&lt;/em&gt; 이고 &lt;em&gt;k&lt;/em&gt; 는 가능한 작습니다. k는 &lt;em&gt;s&lt;/em&gt; 의 10 진수 표현에서 자릿수이며, &lt;em&gt;s&lt;/em&gt; 는 10으로 나눌 수 없으며, &lt;em&gt;s의&lt;/em&gt; 최하위 자릿수가 반드시 이러한 기준에 의해 고유하게 결정되는 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="79a55b28f42f64f7f17d4f2f7c30cbe7a2bd50a6" translate="yes" xml:space="preserve">
          <source>then you can just &lt;code&gt;parseFloat&lt;/code&gt; and zeroes will 'go away'.</source>
          <target state="translated">&lt;code&gt;parseFloat&lt;/code&gt; 를 파싱하면 0이 사라집니다.</target>
        </trans-unit>
        <trans-unit id="d9b4f0c3f620d92bff0c5ce1441899f7830fa702" translate="yes" xml:space="preserve">
          <source>to know the difference between toFixed and round. You can have a look at &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/566564/javascript-functions-math-roundnum-vs-num-tofixed0-and-browser-inconsistenci&quot;&gt;Math.round(num) vs num.toFixed(0) and browser inconsistencies&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">toFixed와 round의 차이점을 알 수 있습니다. &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/566564/javascript-functions-math-roundnum-vs-num-tofixed0-and-browser-inconsistenci&quot;&gt;Math.round (num) vs num.toFixed (0) 및 브라우저 불일치를&lt;/a&gt;&lt;/em&gt; 살펴볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88e23d7331fc1070d7d98a821a40134dbbdd7cca" translate="yes" xml:space="preserve">
          <source>toFixed() will also &lt;strong&gt;NOT&lt;/strong&gt; round correctly in some cases (tested in Chrome v.55.0.2883.87)!</source>
          <target state="translated">경우에 따라 toFixed ()도 올바르게 반올림 &lt;strong&gt;되지 않습니다&lt;/strong&gt; (Chrome v.55.0.2883.87에서 테스트)!</target>
        </trans-unit>
        <trans-unit id="8a851e1ca9928f5dba505859dc2784363657f289" translate="yes" xml:space="preserve">
          <source>which is closer to 0.01 than to 0.02.</source>
          <target state="translated">0.02보다 0.01에 가깝습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
