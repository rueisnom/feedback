<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/11832914">
    <body>
      <group id="11832914">
        <trans-unit id="b6ece284bdcef543af3fa04af9f8140b35cca2c3" translate="yes" xml:space="preserve">
          <source>(As an alternative, you could also try the &lt;a href=&quot;https://github.com/jhohlfeld/round10&quot;&gt;round10&lt;/a&gt; library which provides a similarly-behaving function with a wildly different implementation.)</source>
          <target state="translated">(В качестве альтернативы вы могли бы также попробовать библиотеку &lt;a href=&quot;https://github.com/jhohlfeld/round10&quot;&gt;round10,&lt;/a&gt; которая предоставляет функцию с аналогичным поведением и имеет совершенно другую реализацию.)</target>
        </trans-unit>
        <trans-unit id="6681674ef7ab7bb360570aaedfa1b23c78b184b2" translate="yes" xml:space="preserve">
          <source>... I get 0.015, which should round to 0.02, and which is noticeably &lt;em&gt;not&lt;/em&gt; the 56-decimal-place number I earlier said that all of these numbers were exactly equal to. So what dark magic is this?</source>
          <target state="translated">... Я получаю 0,015, что должно округляться до 0,02, и это заметно &lt;em&gt;не&lt;/em&gt; то число с 56 десятичными разрядами, о котором я ранее говорил, что все эти числа в точности равны. Так что это за темная магия?</target>
        </trans-unit>
        <trans-unit id="c6a08c79c3157a0800a5664fbe8ac079f3090599" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toFixed(2)&lt;/code&gt; here 2 is number of digits upto which we want to round this num.</source>
          <target state="translated">&lt;code&gt;toFixed(2)&lt;/code&gt; здесь 2 - это число цифр, до которого мы хотим округлить это число.</target>
        </trans-unit>
        <trans-unit id="6f89dbbb6171fb257097653bce48c99201d2bf6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT (2019):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;РЕДАКТИРОВАТЬ (2019):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="94c3f2940bab5ea0c2d43ef846e1ca78e2d60ba3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT (december 2019):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;РЕДАКТИРОВАТЬ (декабрь 2019 года):&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e23e8588def29ed89ca632405fa7089ba47d19e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; to ensure things like 1.005 round correctly, we use</source>
          <target state="translated">&lt;strong&gt;Редактировать:&lt;/strong&gt; чтобы убедиться, что такие вещи, как 1.005 раунд правильно, мы используем</target>
        </trans-unit>
        <trans-unit id="4abe7a00ac8031d5894c9ec2f50051099b25c203" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; This is not a universal solution for everyone. There are several different rounding algorithms, your implementation can be different, depends on your requirements. &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;https://en.wikipedia.org/wiki/Rounding&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;ПРИМЕЧАНИЕ:&lt;/strong&gt; это не универсальное решение для всех. Существует несколько разных алгоритмов округления, ваша реализация может быть разной, зависит от ваших требований. &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;https://en.wikipedia.org/wiki/Rounding&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5700e435626d6a7bc525fba922f6696dce2146e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;None of the answers found here is correct&lt;/strong&gt;. @stinkycheeseman asked to &lt;strong&gt;round up&lt;/strong&gt;, you all rounded the number.</source>
          <target state="translated">&lt;strong&gt;Ни один из найденных здесь ответов не является правильным&lt;/strong&gt; . @stinkycheeseman попросил &lt;strong&gt;округлить&lt;/strong&gt; , вы все округлили число.</target>
        </trans-unit>
        <trans-unit id="8f505dab513fc6e66e32870147f13bf544aaf130" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 1&lt;/strong&gt; is to use a script with required rounding algorithm, for example:</source>
          <target state="translated">&lt;strong&gt;Решение 1&lt;/strong&gt; - использовать скрипт с необходимым алгоритмом округления, например:</target>
        </trans-unit>
        <trans-unit id="60da7ee155aad83e9fc691a1e3f288cb20397643" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 2&lt;/strong&gt; is to avoid front end calculations and pull rounded values from the backend server.</source>
          <target state="translated">&lt;strong&gt;Решение 2&lt;/strong&gt; состоит в том, чтобы избежать расчетов переднего плана и получить округленные значения с внутреннего сервера.</target>
        </trans-unit>
        <trans-unit id="de4e79b8a1f775972ba777a47804a2f6c93dc4ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;That is simply the way floating point numbers works in a computer.&lt;/strong&gt; Like 99% of programming languages, JavaScript doesn't have &lt;em&gt;home made&lt;/em&gt; floating point numbers; it relies on the CPU/FPU for that. A computer uses binary, and in binary, there isn't any numbers like &lt;code&gt;0.1&lt;/code&gt;, but a mere binary approximation for that. Why? For the same reason than 1/3 cannot be written in decimal: its value is 0.33333333... with an infinity of threes.</source>
          <target state="translated">&lt;strong&gt;Это просто способ, которым числа с плавающей запятой работают в компьютере.&lt;/strong&gt; Как и в 99% языков программирования, JavaScript не имеет &lt;em&gt;самодельных&lt;/em&gt; чисел с плавающей точкой; для этого он использует CPU / FPU. Компьютер использует двоичный код, а в двоичном коде нет таких чисел, как &lt;code&gt;0.1&lt;/code&gt; , а просто двоичное приближение для этого. Почему? По той же причине, что 1/3 нельзя записать в десятичном виде: его значение равно 0,33333333 ... с бесконечностью троек.</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1b2af8daa9bf0f51bff3121bdff06a9eef9fdbd" translate="yes" xml:space="preserve">
          <source>A precise rounding method. Source: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Mozilla&lt;/a&gt;</source>
          <target state="translated">Точный метод округления. Источник: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Мозилла&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="69b2d171eb62a98f494d32dbf0399f2c6f867adf" translate="yes" xml:space="preserve">
          <source>A simple drop in solution that provides accurate decimal rounding, flooring, and ceiling, with an optional precision variable without adding a whole library.</source>
          <target state="translated">Простое решение,которое обеспечивает точное округление в десятичную дробь,пол и потолок,с опциональной точной переменной без добавления целой библиотеки.</target>
        </trans-unit>
        <trans-unit id="d87b6d4b2b1d92b09f50fecdbf7a3fb93cdb0de7" translate="yes" xml:space="preserve">
          <source>Adapted from the solution provided here: &lt;a href=&quot;https://stackoverflow.com/a/48850944/6910392&quot;&gt;https://stackoverflow.com/a/48850944/6910392&lt;/a&gt;</source>
          <target state="translated">Адаптировано из решения, представленного здесь: &lt;a href=&quot;https://stackoverflow.com/a/48850944/6910392&quot;&gt;https://stackoverflow.com/a/48850944/6910392&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b39ace06fe7843f11aa15e7af8ac8aa65286c4d1" translate="yes" xml:space="preserve">
          <source>After running through various iterations of all the possible ways to achieve true accurate decimal rounding precision, it is clear that the most accurate and efficient solution is to use Number.EPSILON. This provides a true mathematical solution to the problem of floating point math precision. It can be easily polyfilled as shown here: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&lt;/a&gt; to support all of the last remaining IE users (then again maybe we should stop doing that).</source>
          <target state="translated">После прохождения различных итераций всех возможных способов достижения по-настоящему точной точности округления десятичных чисел становится ясно, что наиболее точным и эффективным решением является использование Number.EPSILON. Это обеспечивает истинное математическое решение проблемы математической точности с плавающей запятой. Его можно легко заполнить, как показано здесь: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&lt;/a&gt; для поддержки всех последних оставшихся пользователей IE (тогда, опять же, возможно, мы должен прекратить делать это).</target>
        </trans-unit>
        <trans-unit id="f575b52acd8ef9eab6fdcf0d803b1f78d5741f89" translate="yes" xml:space="preserve">
          <source>Also it's worth noting that this is not a &lt;em&gt;JavaScript weirdness&lt;/em&gt; like some people stated.</source>
          <target state="translated">Также стоит отметить, что это не &lt;em&gt;странность JavaScript,&lt;/em&gt; как утверждают некоторые люди.</target>
        </trans-unit>
        <trans-unit id="c4937c3ee7e26dbf578cfd6247ad524d28ec2b62" translate="yes" xml:space="preserve">
          <source>As asked in the comments, let's clarify one thing: adding &lt;code&gt;Number.EPSILON&lt;/code&gt; is relevant only when the value to round is the result of an arithmetic operation, as it can swallow some floating point error delta.</source>
          <target state="translated">Как было &lt;code&gt;Number.EPSILON&lt;/code&gt; в комментариях, давайте проясним одну вещь: добавление Number.EPSILON уместно только тогда, когда значение округлять является результатом арифметической операции, поскольку оно может проглотить некоторую дельту ошибки с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="5c1aa79e884353e01805297b4ffdc0e1b809104c" translate="yes" xml:space="preserve">
          <source>But what if you have the second kind of Number - a value taken from a continuous scale, where there's no reason to think that approximate decimal representations with fewer decimal places are more &lt;em&gt;accurate&lt;/em&gt; than those with more? In that case, we &lt;em&gt;don't&lt;/em&gt; want to respect the String representation, because that representation (as explained in the spec) is already sort-of-rounded; we don't want to make the mistake of saying &quot;0.014999999...375 rounds up to 0.015, which rounds up to 0.02, so 0.014999999...375 rounds up to 0.02&quot;.</source>
          <target state="translated">Но что, если у вас есть второй тип числа - значение, взятое из непрерывной шкалы, где нет оснований думать, что приближенные десятичные представления с меньшим количеством десятичных знаков более &lt;em&gt;точны,&lt;/em&gt; чем те, у которых больше? В этом случае мы &lt;em&gt;не&lt;/em&gt; хотим уважать представление String, потому что это представление (как объяснено в спецификации) уже является своего рода округленным; мы не хотим ошибаться, говоря: &amp;laquo;0,014999999 ... 375 округляет до 0,015, что округляет до 0,02, поэтому 0,014999999 ... 375 округляет до 0,02&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="ab662aee31f190e347238c5fbc1e7d6128a3dbdd" translate="yes" xml:space="preserve">
          <source>Compared to Lavamantis's solution, we can do...</source>
          <target state="translated">По сравнению с решением Лавамантиса,мы можем сделать...</target>
        </trans-unit>
        <trans-unit id="8589b8976170efc90ee30bed08325d4b4f5fb025" translate="yes" xml:space="preserve">
          <source>Consider &lt;code&gt;.toFixed()&lt;/code&gt; and &lt;code&gt;.toPrecision()&lt;/code&gt;:</source>
          <target state="translated">Рассмотрим &lt;code&gt;.toFixed()&lt;/code&gt; и &lt;code&gt;.toPrecision()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="85511932eb0bd6ee919a34a7f2c6087bb0a5fb7b" translate="yes" xml:space="preserve">
          <source>Easiest way:</source>
          <target state="translated">Самый простой способ:</target>
        </trans-unit>
        <trans-unit id="5e297a41e8ef5ac08adf9ee0810c2244721fa92b" translate="yes" xml:space="preserve">
          <source>Eg:</source>
          <target state="translated">Eg:</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">Пример использования:</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="945a73f60f58235e70de75adb211e4394558c073" translate="yes" xml:space="preserve">
          <source>For me &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Math.round()&lt;/a&gt; was not giving correct answer. I found &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt;toFixed(2)&lt;/a&gt; works better. 
Below are examples of both:</source>
          <target state="translated">Для меня &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Math.round ()&lt;/a&gt; не давал правильного ответа. Я нашел &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt;toFixed (2)&lt;/a&gt; работает лучше. Ниже приведены примеры обоих:</target>
        </trans-unit>
        <trans-unit id="edbdada6b4155dd45ec8fd8ab20607a6462b6549" translate="yes" xml:space="preserve">
          <source>Here come &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/a&gt;. That number is the difference between 1 and the &lt;em&gt;next&lt;/em&gt; number existing in the double precision floating point numbers. &lt;strong&gt;That's it: There is no number between &lt;code&gt;1&lt;/code&gt; and 1 + &lt;code&gt;Number.EPSILON&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">А вот и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; &lt;/a&gt; . ЭПСИЛОН . Это число представляет собой разницу между 1 и &lt;em&gt;следующим&lt;/em&gt; числом, существующим в числах с плавающей запятой двойной точности. &lt;strong&gt;Вот и все: не существует числа между &lt;code&gt;1&lt;/code&gt; и 1 + &lt;code&gt;Number.EPSILON&lt;/code&gt; . ЭПСИЛОН .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="582a28d3d6f5875f42faffd53f6dca41c44e4409" translate="yes" xml:space="preserve">
          <source>Here is a prototype method:</source>
          <target state="translated">Вот прототипный метод:</target>
        </trans-unit>
        <trans-unit id="2becac006f82ed17841b46654302952a6af24ef5" translate="yes" xml:space="preserve">
          <source>Here is a simple way to do it:</source>
          <target state="translated">Вот простой способ сделать это:</target>
        </trans-unit>
        <trans-unit id="86712cc5731f9156c956e2225c2cb563bb12f349" translate="yes" xml:space="preserve">
          <source>Here is the function I use to solve the floating point decimals issues &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round#Example%3a_Decimal_rounding&quot;&gt;also based on MDN&lt;/a&gt;. It is even more generic (but less concise) than Lavamantis's solution:</source>
          <target state="translated">Вот функция, которую я использую для решения десятичных чисел с плавающей запятой, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round#Example%3a_Decimal_rounding&quot;&gt;также основанная на MDN&lt;/a&gt; . Это даже более универсально (но менее кратко), чем решение Lavamantis:</target>
        </trans-unit>
        <trans-unit id="c0d5875b4c5849ab3bfd33eea8d2f49977f4bd52" translate="yes" xml:space="preserve">
          <source>Here we can simply use the built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt;&lt;code&gt;toFixed&lt;/code&gt;&lt;/a&gt; method. Note that by calling &lt;code&gt;Number()&lt;/code&gt; on the String returned by &lt;code&gt;toFixed&lt;/code&gt;, we get a Number whose String representation has no trailing zeroes (thanks to the way JavaScript computes the String representation of a Number, discussed earlier in this answer).</source>
          <target state="translated">Здесь мы можем просто использовать встроенный метод &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt; &lt;code&gt;toFixed&lt;/code&gt; &lt;/a&gt; . Обратите внимание, что, вызывая &lt;code&gt;Number()&lt;/code&gt; для String, возвращаемой &lt;code&gt;toFixed&lt;/code&gt; , мы получаем Number, в котором строковое представление не имеет конечных нулей (благодаря тому, как JavaScript вычисляет строковое представление Number, как обсуждалось ранее в этом ответе).</target>
        </trans-unit>
        <trans-unit id="c0f0c4ff59640480547b46eb98247d0405dde5a2" translate="yes" xml:space="preserve">
          <source>Here, also is one function I wrote to do arithmetic rounding correctly. You can test it yourself.</source>
          <target state="translated">Вот еще одна функция,которую я написал,чтобы сделать арифметическое округление правильно.Ты можешь протестировать ее сам.</target>
        </trans-unit>
        <trans-unit id="75553f548ebe8d7c4d7be06075a2ad90b25c726b" translate="yes" xml:space="preserve">
          <source>How can I do this in JavaScript?</source>
          <target state="translated">Как это сделать на JavaScript?</target>
        </trans-unit>
        <trans-unit id="379bf1ec8b931f6919ae70cbdb99b7a15e4424b6" translate="yes" xml:space="preserve">
          <source>I found this over on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;MDN&lt;/a&gt;. Their way avoids the problem with 1.005 that was &lt;a href=&quot;https://stackoverflow.com/questions/11832914/round-up-to-2-decimal-places-in-javascript#comment24719818_11832950&quot;&gt;mentioned&lt;/a&gt;.</source>
          <target state="translated">Я нашел это на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;MDN&lt;/a&gt; . Их путь позволяет избежать проблемы с 1.005, о которой &lt;a href=&quot;https://stackoverflow.com/questions/11832914/round-up-to-2-decimal-places-in-javascript#comment24719818_11832950&quot;&gt;упоминалось&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="070221396ffd7adc80f964d497ffbcc8f1956377" translate="yes" xml:space="preserve">
          <source>I guess, this is because 1.555 is actually something like float 1.55499994 behind the scenes.</source>
          <target state="translated">Наверное,это потому,что 1.555 на самом деле что-то вроде поплавка 1.55499994 за кулисами.</target>
        </trans-unit>
        <trans-unit id="07e838235f2a025cd47854a685499d5a0537ecfb" translate="yes" xml:space="preserve">
          <source>I removed the variant &lt;code&gt;n.toFixed(2)&lt;/code&gt;, because it is not correct. Thank you @avalanche1</source>
          <target state="translated">Я удалил вариант &lt;code&gt;n.toFixed(2)&lt;/code&gt; , потому что это не правильно. Спасибо @ avalanche1</target>
        </trans-unit>
        <trans-unit id="48bd35342cfdaf130a7708310f7a72f622b696f6" translate="yes" xml:space="preserve">
          <source>I'd like to round at most 2 decimal places, but &lt;em&gt;only if necessary&lt;/em&gt;.</source>
          <target state="translated">Я хотел бы округлить не более 2 десятичных знаков, но &lt;em&gt;только при необходимости&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ec800790fcee0bf08442c4630dae0d9ba7b6d988" translate="yes" xml:space="preserve">
          <source>If the value is a number:</source>
          <target state="translated">Если значение является числом:</target>
        </trans-unit>
        <trans-unit id="b1fefa7ba2439d746003f46853a7371ff731d113" translate="yes" xml:space="preserve">
          <source>If the value is a text type:</source>
          <target state="translated">Если значение является текстовым:</target>
        </trans-unit>
        <trans-unit id="e41c41447951ebc94d036fd32ec620302036e867" translate="yes" xml:space="preserve">
          <source>If you are open to libraries you can use &lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;bignumber.js&lt;/a&gt;</source>
          <target state="translated">Если вы открыты для библиотек, вы можете использовать &lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;bignumber.js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dc26938bf0e0296802c89e07ccde26e1ab90731a" translate="yes" xml:space="preserve">
          <source>If you are using lodash library, you can use the round method of lodash like following.</source>
          <target state="translated">Если вы используете библиотеку домиков,вы можете использовать круглый метод домиков,как показано ниже.</target>
        </trans-unit>
        <trans-unit id="3216546a05d95fdf5f5508347421f9837590b56b" translate="yes" xml:space="preserve">
          <source>If you need to be strict and add digits just if needed it can use &lt;code&gt;replace&lt;/code&gt;</source>
          <target state="translated">Если вам нужно быть строгим и добавлять цифры только при необходимости, можно использовать &lt;code&gt;replace&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a938b4696af9e98610818f1d8d206757dad7ae27" translate="yes" xml:space="preserve">
          <source>If your project uses jQuery or lodash, you can also find proper &lt;code&gt;round&lt;/code&gt; method in the libraries.</source>
          <target state="translated">Если ваш проект использует jQuery или lodash, вы также можете найти подходящий метод &lt;code&gt;round&lt;/code&gt; в библиотеках.</target>
        </trans-unit>
        <trans-unit id="6af9e62dcf39a0d15e0f97e5a60d274500525b0b" translate="yes" xml:space="preserve">
          <source>In fact, in the code I'm using &lt;code&gt;ESPILON_RATE = 1 + 4 * Number.EPSILON&lt;/code&gt; and &lt;code&gt;EPSILON_ZERO = 4 * Number.MIN_VALUE&lt;/code&gt; (four times the epsilon), because I want an equality checker loose enough for cumulating floating point error.</source>
          <target state="translated">Фактически, в коде я использую &lt;code&gt;ESPILON_RATE = 1 + 4 * Number.EPSILON&lt;/code&gt; и &lt;code&gt;EPSILON_ZERO = 4 * Number.MIN_VALUE&lt;/code&gt; (в четыре раза больше epsilon), потому что я хочу, чтобы средство проверки равенства было достаточно свободным для накопления ошибки с плавающей запятой.</target>
        </trans-unit>
        <trans-unit id="ef69761016065df342a41f1ba61cbdee1af2e52f" translate="yes" xml:space="preserve">
          <source>In general, rounding is done by scaling: &lt;code&gt;round(num / p) * p&lt;/code&gt;</source>
          <target state="translated">Как правило, округление выполняется путем масштабирования: &lt;code&gt;round(num / p) * p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="79d70dcb4f9ee8b7d94ed9539586cc73c0d399da" translate="yes" xml:space="preserve">
          <source>Input:</source>
          <target state="translated">Input:</target>
        </trans-unit>
        <trans-unit id="5bdb51e539dd788122b75e12613282cb9a59033d" translate="yes" xml:space="preserve">
          <source>It converts it to a string, and then back into an integer / float.</source>
          <target state="translated">Он преобразует его в строку,а затем обратно в целое число с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="e7f26dce8602d2aa4e2f07b9f0b39e5804a7316d" translate="yes" xml:space="preserve">
          <source>It doesn't solve the '1.005 rounding problem' though - since it is intrinsic to how &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/101163/what-causes-floating-point-rounding-errors&quot;&gt;float fractions are being processed&lt;/a&gt;.</source>
          <target state="translated">Однако это не решает &amp;laquo;проблему округления 1.005&amp;raquo;, поскольку это присуще тому, как &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/101163/what-causes-floating-point-rounding-errors&quot;&gt;обрабатываются дробные дроби&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb18705dfa4dbaefc58019dd86183424f5d60d6a" translate="yes" xml:space="preserve">
          <source>It may work for you,</source>
          <target state="translated">Это может сработать на тебя,</target>
        </trans-unit>
        <trans-unit id="9db4057b0b1aefd3eabe9d5558fa88ce0408b22f" translate="yes" xml:space="preserve">
          <source>It seems like &lt;code&gt;Math.round&lt;/code&gt; is a better solution. &lt;strong&gt;But it is not!&lt;/strong&gt; In some cases it will &lt;strong&gt;NOT&lt;/strong&gt; round correctly:</source>
          <target state="translated">Похоже, что &lt;code&gt;Math.round&lt;/code&gt; - лучшее решение. &lt;strong&gt;Но это не так!&lt;/strong&gt; В некоторых случаях это &lt;strong&gt;НЕ&lt;/strong&gt; будет округлено правильно:</target>
        </trans-unit>
        <trans-unit id="de7e2f930d8192a22533ff7c52eeb7a294e46200" translate="yes" xml:space="preserve">
          <source>It's not useful when the value comes from a direct source (e.g.: literal, user input or sensor).</source>
          <target state="translated">Это бесполезно,когда значение поступает из прямого источника (например:буквального,пользовательского входа или датчика).</target>
        </trans-unit>
        <trans-unit id="d16bae6ae960069cfbe9eb6b916a4ba5bc5ae155" translate="yes" xml:space="preserve">
          <source>Just use native code &lt;code&gt;.toFixed()&lt;/code&gt;</source>
          <target state="translated">Просто используйте собственный код &lt;code&gt;.toFixed()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b1a5d323275c298c4aa9b8992ef25578960b7c0" translate="yes" xml:space="preserve">
          <source>Lately, I use a function similar to this one for comparing numbers epsilon-aware:</source>
          <target state="translated">В последнее время я использую функцию,похожую на эту,для сравнения чисел epsilon-aware:</target>
        </trans-unit>
        <trans-unit id="adb23d3b5115886051bb54739f5c553032bc9dc7" translate="yes" xml:space="preserve">
          <source>Like @maganap and some peoples have pointed out, it's best to add &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/a&gt; before multiplying:</source>
          <target state="translated">Как @maganap и некоторые люди указали, лучше добавить &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; &lt;/a&gt; перед умножением:</target>
        </trans-unit>
        <trans-unit id="2787e27648a8b92aefd69a68e92ccec35c88a574" translate="yes" xml:space="preserve">
          <source>MarkG and Lavamantis offered a much better solution than the one that has been accepted. It's a shame they don't get more upvotes!</source>
          <target state="translated">MarkG и Lavamantis предложили гораздо лучшее решение,чем то,которое было принято.Жаль,что они не получили больше голосов!</target>
        </trans-unit>
        <trans-unit id="e9cb187413866bee5719685fd8cb0c4a9882de1d" translate="yes" xml:space="preserve">
          <source>MarkG's answer is the correct one.  Here's a generic extension for any number of decimal places.</source>
          <target state="translated">Ответ МаркГ-правильный.Вот общее расширение для любого количества знаков после запятой.</target>
        </trans-unit>
        <trans-unit id="428f9655e67ff46265d67320cd0ccfe0319be407" translate="yes" xml:space="preserve">
          <source>Math.round(num) vs num.toFixed(0) and browser inconsistencies</source>
          <target state="translated">Math.round(num)vs num.toFixed(0)и несоответствия в браузере</target>
        </trans-unit>
        <trans-unit id="ff707f109be190d332352b938ccc8b3c4e06e97c" translate="yes" xml:space="preserve">
          <source>My use-case is &lt;a href=&quot;https://www.npmjs.com/package/doormen&quot;&gt;an assertion + data validation lib&lt;/a&gt; I'm developing for many years.</source>
          <target state="translated">Мой вариант использования - &lt;a href=&quot;https://www.npmjs.com/package/doormen&quot;&gt;библиотека утверждений + проверки данных,&lt;/a&gt; которую я разрабатываю уже много лет.</target>
        </trans-unit>
        <trans-unit id="59377d5faf3749e97822f1f1971ecded10a972a6" translate="yes" xml:space="preserve">
          <source>No one seems to be aware of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Кажется, никто не знает о &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca5e324249ddd6187831ef808ea93363a2b26711" translate="yes" xml:space="preserve">
          <source>Of course, none of this discussion has directly answered what &lt;code&gt;roundTo2DP(m)&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; return. If &lt;code&gt;m&lt;/code&gt;'s exact value is 0.01499999999999999944488848768742172978818416595458984375, but its String representation is '0.015', then what is the &lt;em&gt;correct&lt;/em&gt; answer - mathematically, practically, philosophically, or whatever - when we round it to two decimal places?</source>
          <target state="translated">Конечно, ни одно из этого обсуждения не дало прямого ответа на то, что &lt;code&gt;roundTo2DP(m)&lt;/code&gt; &lt;em&gt;должен&lt;/em&gt; вернуться. Если точное значение m равно 0,01499999999999999944488848768742172978818416595458984375, но его строковое представление равно 0,015, то каков &lt;em&gt;правильный&lt;/em&gt; ответ - математически, практически, философски или как угодно - когда мы округляем его до двух десятичных знаков?</target>
        </trans-unit>
        <trans-unit id="9de972621e113a6822f18823d2063f32eba7fcf6" translate="yes" xml:space="preserve">
          <source>On the other hand, you probably want to respect the binary floating point value and round downwards when your value is from an inherently continuous scale - for instance, if it's a reading from a sensor.</source>
          <target state="translated">С другой стороны,вы,вероятно,хотите уважать двоичное значение с плавающей запятой и округлять вниз,когда ваше значение от по сути непрерывной шкалы-например,если это чтение с датчика.</target>
        </trans-unit>
        <trans-unit id="6bbbecb3438fd6440ef7f77e7aea3b5d8bdb6531" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;.toFixed(NumberOfDecimalPlaces)&lt;/code&gt;.</source>
          <target state="translated">Можно использовать &lt;code&gt;.toFixed(NumberOfDecimalPlaces)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="576fa80104f1e9d06e3d6fd8ed6dedc8629cc5e4" translate="yes" xml:space="preserve">
          <source>One way to achieve such a rounding &lt;em&gt;only if necessary&lt;/em&gt; is to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString&quot;&gt;Number.prototype.toLocaleString()&lt;/a&gt;:</source>
          <target state="translated">Один из способов добиться такого округления &lt;em&gt;только при необходимости&lt;/em&gt; - использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString&quot;&gt;Number.prototype.toLocaleString ()&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="c1d0e0227161567c5c8a46e530e257ab7932de2e" translate="yes" xml:space="preserve">
          <source>Round to at most 2 decimal places (only if necessary)</source>
          <target state="translated">Округляйте до 2-х знаков после запятой (только при необходимости).</target>
        </trans-unit>
        <trans-unit id="1b3ea2091e0125bb10b50729a167add8b2875170" translate="yes" xml:space="preserve">
          <source>Since ES6 there is a 'proper' way (without overriding statics and creating workarounds) to do this by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Number/toPrecision&quot;&gt;using toPrecision&lt;/a&gt;</source>
          <target state="translated">Начиная с ES6, существует &amp;laquo;правильный&amp;raquo; способ (без переопределения статики и создания обходных путей) сделать это с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Number/toPrecision&quot;&gt;помощью toPrecision.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c131372ed2ef9d5afca4b7ffe157d796543820d0" translate="yes" xml:space="preserve">
          <source>So far, it looks perfect for me.
I hope it will help.</source>
          <target state="translated">Пока это выглядит идеально для меня.Надеюсь,это поможет.</target>
        </trans-unit>
        <trans-unit id="d9eb0d47c4da3723a4af8473544b8419da09be27" translate="yes" xml:space="preserve">
          <source>So when I write &lt;code&gt;m = 0.0150000000000000001&lt;/code&gt;, the &lt;em&gt;exact value of &lt;code&gt;m&lt;/code&gt;&lt;/em&gt; that I end up with is closer to &lt;code&gt;0.01&lt;/code&gt; than it is to &lt;code&gt;0.02&lt;/code&gt;. And yet, if I convert &lt;code&gt;m&lt;/code&gt; to a String...</source>
          <target state="translated">Поэтому, когда я пишу &lt;code&gt;m = 0.0150000000000000001&lt;/code&gt; , &lt;em&gt;точное значение &lt;code&gt;m&lt;/code&gt; ,&lt;/em&gt; которое я получаю, ближе к &lt;code&gt;0.01&lt;/code&gt; чем к &lt;code&gt;0.02&lt;/code&gt; . И все же, если я преобразую &lt;code&gt;m&lt;/code&gt; в строку ...</target>
        </trans-unit>
        <trans-unit id="3b8d42473f0fced361a981334f253d2ee119f7bd" translate="yes" xml:space="preserve">
          <source>Suppose we have a function, &lt;code&gt;roundTo2DP(num)&lt;/code&gt;, that takes a float as an argument and returns a value rounded to 2 decimal places. What should each of these expressions evaluate to?</source>
          <target state="translated">Предположим, у нас есть функция &lt;code&gt;roundTo2DP(num)&lt;/code&gt; , которая принимает в качестве аргумента число с плавающей точкой и возвращает значение, округленное до 2 десятичных знаков. Что должно оценивать каждое из этих выражений?</target>
        </trans-unit>
        <trans-unit id="6bfb5e628c414a067972ade779b24a3a568b3fd7" translate="yes" xml:space="preserve">
          <source>The 'obvious' answer is that the first example should round to 0.01 (because it's closer to 0.01 than to 0.02) while the other two should round to 0.02 (because 0.0150000000000000001 is closer to 0.02 than to 0.01, and because 0.015 is exactly halfway between them and there is a mathematical convention that such numbers get rounded up).</source>
          <target state="translated">Очевидный&quot; ответ заключается в том,что первый пример должен округляться до 0.01 (потому что он ближе к 0.01,чем к 0.02),а два других-до 0.02 (потому что 0.015000000000001 ближе к 0.02,чем к 0.01,и потому что 0.015 находится ровно на полпути между ними,и существует математическая конвенция,что такие числа округляются вверх).</target>
        </trans-unit>
        <trans-unit id="c544245c0ffab197bc3584e928cfc903bd4d3964" translate="yes" xml:space="preserve">
          <source>The answer can be found in the ECMAScript specification, in section &lt;a href=&quot;http://www.ecma-international.org/ecma-262/7.0/#sec-tostring-applied-to-the-number-type&quot;&gt;&lt;em&gt;7.1.12.1: ToString applied to the Number type&lt;/em&gt;&lt;/a&gt;. Here the rules for converting some Number &lt;em&gt;m&lt;/em&gt; to a String are laid down. The key part is point 5, in which an integer &lt;em&gt;s&lt;/em&gt; is generated whose digits will be used in the String representation of &lt;em&gt;m&lt;/em&gt;:</source>
          <target state="translated">Ответ можно найти в спецификации ECMAScript, в разделе &lt;a href=&quot;http://www.ecma-international.org/ecma-262/7.0/#sec-tostring-applied-to-the-number-type&quot;&gt;&lt;em&gt;7.1.12.1: ToString применяется к типу Number&lt;/em&gt;&lt;/a&gt; . Здесь изложены правила преобразования некоторого числа &lt;em&gt;m&lt;/em&gt; в строку. Ключевой частью является точка 5, в которой генерируется целое число &lt;em&gt;s&lt;/em&gt; , цифры которого будут использоваться в строковом представлении &lt;em&gt;m&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="df090e3c30fa1d731e05b5ce4f35661d5e7baf7c" translate="yes" xml:space="preserve">
          <source>The catch, which you may have guessed, is that &lt;code&gt;roundTo2DP&lt;/code&gt;&lt;em&gt;cannot possibly&lt;/em&gt; be implemented to give those obvious answers, because all three numbers passed to it are &lt;em&gt;the same number&lt;/em&gt;. IEEE 754 binary floating point numbers (the kind used by JavaScript) can't exactly represent most non-integer numbers, and so all three numeric literals above get rounded to a nearby valid floating point number. This number, as it happens, is &lt;em&gt;exactly&lt;/em&gt;</source>
          <target state="translated">&lt;code&gt;roundTo2DP&lt;/code&gt; , о которой вы, возможно, догадались, состоит в том, что roundTo2DP &lt;em&gt;не может&lt;/em&gt; быть реализован, чтобы дать эти очевидные ответы, потому что все три переданных ему числа - &lt;em&gt;это одно и то же число&lt;/em&gt; . Двоичные числа с плавающей точкой IEEE 754 (тип, используемый JavaScript) не может точно представлять большинство нецелых чисел, и поэтому все три числовых литерала выше округляются до ближайшего действительного числа с плавающей запятой. Это число, как это бывает, &lt;em&gt;точно&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17eaea0baa02c017f3ef107833be95e25d292bd7" translate="yes" xml:space="preserve">
          <source>The function above is &lt;em&gt;probably&lt;/em&gt; what you want to use to avoid users ever witnessing numbers that they have entered being rounded wrongly.</source>
          <target state="translated">Вышеприведенная функция - это, &lt;em&gt;вероятно,&lt;/em&gt; то, что вы хотите использовать, чтобы пользователи никогда не видели, что введенные ими числа неправильно округляются.</target>
        </trans-unit>
        <trans-unit id="7a1df7bf3e06ffb09c0be63d9ac99109b43decd2" translate="yes" xml:space="preserve">
          <source>The key part here is the requirement that &quot;&lt;em&gt;k&lt;/em&gt; is as small as possible&quot;. What that requirement amounts to is a requirement that, given a Number &lt;code&gt;m&lt;/code&gt;, the value of &lt;code&gt;String(m)&lt;/code&gt; must have &lt;em&gt;the least possible number of digits&lt;/em&gt; while still satisfying the requirement that &lt;code&gt;Number(String(m)) === m&lt;/code&gt;. Since we already know that &lt;code&gt;0.015 === 0.0150000000000000001&lt;/code&gt;, it's now clear why &lt;code&gt;String(0.0150000000000000001) === '0.015'&lt;/code&gt; must be true.</source>
          <target state="translated">Ключевой частью здесь является требование, чтобы &amp;laquo; &lt;em&gt;k было&lt;/em&gt; как можно меньше&amp;raquo;. То, к чему относится это требование, это требование о том, что для заданного числа &lt;code&gt;m&lt;/code&gt; значение &lt;code&gt;String(m)&lt;/code&gt; должно иметь &lt;em&gt;наименьшее возможное количество цифр,&lt;/em&gt; при этом удовлетворяя требованию, что &lt;code&gt;Number(String(m)) === m&lt;/code&gt; . Поскольку мы уже знаем, что &lt;code&gt;0.015 === 0.0150000000000000001&lt;/code&gt; , теперь понятно, почему &lt;code&gt;String(0.0150000000000000001) === '0.015'&lt;/code&gt; должно быть истинным.</target>
        </trans-unit>
        <trans-unit id="d9304dfd5b20a84c90c202df6981188a19c4637d" translate="yes" xml:space="preserve">
          <source>The value being represented is inherently discrete, e.g. an amount of currency in a 3-decimal-place currency like dinars. In this case, the &lt;em&gt;true&lt;/em&gt; value of a Number like 0.015 &lt;em&gt;is&lt;/em&gt; 0.015, and the 0.0149999999... representation that it gets in binary floating point is a rounding error. (Of course, many will argue, reasonably, that you should use a decimal library for handling such values and never represent them as binary floating point Numbers in the first place.)</source>
          <target state="translated">Представляемое значение по своей природе дискретно, например, количество валюты в валюте с 3 десятичными знаками, например, в динарах. В этом случае &lt;em&gt;истинное&lt;/em&gt; значение числа типа 0,015 &lt;em&gt;равно&lt;/em&gt; 0,015, а представление 0,0149999999 ..., которое оно получает в двоичной переменной с плавающей запятой, является ошибкой округления. (Конечно, многие будут разумно утверждать, что вы должны использовать десятичную библиотеку для обработки таких значений и никогда не представлять их как двоичные числа с плавающей запятой.)</target>
        </trans-unit>
        <trans-unit id="0606e71f981fa36e43313e05fde67bea41c0e859" translate="yes" xml:space="preserve">
          <source>The value was typed by a user. In this case, again, the exact decimal number entered is more 'true' than the nearest binary floating point representation.</source>
          <target state="translated">Значение было набрано пользователем.В данном случае,опять же,точное десятичное число,введенное в систему,больше &quot;true&quot;,чем ближайшее двоичное представление с плавающей точкой.</target>
        </trans-unit>
        <trans-unit id="8727bcf5e244c818b657462e6c613378e3d0d0c7" translate="yes" xml:space="preserve">
          <source>Then you would simply pass in the value.</source>
          <target state="translated">Тогда ты просто передашь значение.</target>
        </trans-unit>
        <trans-unit id="f76d9f0b8979b7733602f015e3ba04fd7d5a9502" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to do that. For people like me, the Lodash's variant</source>
          <target state="translated">Есть пара способов сделать это.Для таких людей,как я,вариант Лодаша...</target>
        </trans-unit>
        <trans-unit id="068e2e768c65c4ad778691dec9f43778213541e5" translate="yes" xml:space="preserve">
          <source>There is a downside that values like 1.5 will give &quot;1.50&quot; as the output. A fix suggested by @minitech:</source>
          <target state="translated">Недостатком является то,что такие значения,как 1.5,дают на выходе &quot;1.50&quot;.Исправление,предложенное @minitech:</target>
        </trans-unit>
        <trans-unit id="38387a87e059184ebabf02e5e267b74130d78c64" translate="yes" xml:space="preserve">
          <source>There is no single correct answer to this. It depends upon your use case. You probably want to respect the String representation and round upwards when:</source>
          <target state="translated">Нет ни одного правильного ответа.Это зависит от вашего случая использования.Вы,вероятно,хотите уважать представление Строки и округлить вверх,когда:</target>
        </trans-unit>
        <trans-unit id="de80e004c8c33e4edbcec58d2afcf0444b42e1b1" translate="yes" xml:space="preserve">
          <source>These two approaches require different code. To respect the String representation of the Number, we can (with quite a bit of reasonably subtle code) implement our own rounding that acts directly on the String representation, digit by digit, using the same algorithm you would've used in school when you were taught how to round numbers. Below is an example which respects the OP's requirement of representing the number to 2 decimal places &quot;only when necessary&quot; by stripping trailing zeroes after the decimal point; you may, of course, need to tweak it to your precise needs.</source>
          <target state="translated">Эти два подхода требуют разного кода.Чтобы уважать Строковое представление числа,мы можем (с довольно небольшим количеством достаточно тонкого кода)реализовать наше собственное округление,которое действует непосредственно на Строковом представлении,цифра за цифрой,используя тот же алгоритм,который вы бы использовали в школе,когда вас учили округлять числа.Ниже приведен пример,который соблюдает требование ОП по представлению числа до 2-х знаков после запятой &quot;только при необходимости&quot;,удаляя трейлинговые нули после запятой;вам,конечно же,может понадобиться подстроить его под свои точные нужды.</target>
        </trans-unit>
        <trans-unit id="9cc618b8fa630d85d81948907d250ac34fd31d00" translate="yes" xml:space="preserve">
          <source>This is the simplest, more elegant solution (and I am the best of the world;):</source>
          <target state="translated">Это самое простое,более элегантное решение (и я лучший в мире;):</target>
        </trans-unit>
        <trans-unit id="03640ca35a3d05dde0a5a618e1942cbb23d4aba2" translate="yes" xml:space="preserve">
          <source>This may help you:</source>
          <target state="translated">Это может тебе помочь:</target>
        </trans-unit>
        <trans-unit id="e3a53ec34f6c2117910f386788bc9d743450046a" translate="yes" xml:space="preserve">
          <source>This question is complicated.</source>
          <target state="translated">Этот вопрос сложный.</target>
        </trans-unit>
        <trans-unit id="13ea220ac7311f1b88e69de6b5b2c466b9a1e184" translate="yes" xml:space="preserve">
          <source>This will provide exactly the output you expect, but as strings. You can still convert those back to numbers if that's not the data type you expect.</source>
          <target state="translated">Это обеспечит именно тот результат,которого вы ожидаете,но в виде строк.Вы все еще можете преобразовать их обратно в числа,если это не тот тип данных,который вы ожидаете.</target>
        </trans-unit>
        <trans-unit id="9845257528e47964d89c7b7b37c418107088920b" translate="yes" xml:space="preserve">
          <source>To round up, use this:</source>
          <target state="translated">Чтобы собраться,используй это:</target>
        </trans-unit>
        <trans-unit id="cdb9e11f95eb4c3103b6460c4ec8869fcb19ed0a" translate="yes" xml:space="preserve">
          <source>Try this &lt;strong&gt;light weight&lt;/strong&gt; solution:</source>
          <target state="translated">Попробуйте это &lt;strong&gt;облегченное&lt;/strong&gt; решение:</target>
        </trans-unit>
        <trans-unit id="c83890cd9cde34e76f22e6c092f33233337bbeef" translate="yes" xml:space="preserve">
          <source>Unit test:</source>
          <target state="translated">Юнит-тест:</target>
        </trans-unit>
        <trans-unit id="aa46e3b43b8698bd79a3510bffe6645c067a8510" translate="yes" xml:space="preserve">
          <source>Update 1</source>
          <target state="translated">Обновление 1</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="1a83ebd9832b047f8e615f8f8336e3bea08f97fc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Math.round(num * 100) / 100&lt;/code&gt;</source>
          <target state="translated">Использовать &lt;code&gt;Math.round(num * 100) / 100&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bd604b7778cb749d711fce9848c8397bb74f3d3" translate="yes" xml:space="preserve">
          <source>Use it with:</source>
          <target state="translated">Используй его с:</target>
        </trans-unit>
        <trans-unit id="287f960a3fb8c81611e2058a39f3f4dbd770ca5c" translate="yes" xml:space="preserve">
          <source>Use something like this 
&quot;parseFloat(parseFloat(value).toFixed(2))&quot;</source>
          <target state="translated">Используйте нечто подобное &quot;parseFloat(parseFloat(value).toFixed(2))&quot;.</target>
        </trans-unit>
        <trans-unit id="1e246aa236aacfd965aad87ba2d103b9f3166262" translate="yes" xml:space="preserve">
          <source>Use this function &lt;code&gt;Number(x).toFixed(2);&lt;/code&gt;</source>
          <target state="translated">Используйте эту функцию &lt;code&gt;Number(x).toFixed(2);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f36b531ef3ac37932099200af1af63e95a073826" translate="yes" xml:space="preserve">
          <source>Using the exponential notation handles rounding of +ve numbers, correctly.
However, this method fails to round -ve edge cases correctly.</source>
          <target state="translated">Использование экспоненциальной нотации корректно обрабатывает округление +ve чисел.Однако,этот метод не может корректно округлить регистр +ve края.</target>
        </trans-unit>
        <trans-unit id="782632eccf1234978150e666e6c53e7e804c43c0" translate="yes" xml:space="preserve">
          <source>You can see that all three numbers are the same at your browser console, Node shell, or other JavaScript interpreter. Just compare them:</source>
          <target state="translated">Вы можете видеть,что все три числа одинаковы в консоли браузера,в Node shell или в другом интерпретаторе JavaScript.Просто сравните их:</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">Вы можете использовать</target>
        </trans-unit>
        <trans-unit id="dec1b74b3d17f081a5bca5eb814e512fffe48c57" translate="yes" xml:space="preserve">
          <source>You could enhance it to round to any arbitrary number of decimals by adding a second parameter.</source>
          <target state="translated">Вы можете увеличить его до произвольного количества десятичных дробей,добавив второй параметр.</target>
        </trans-unit>
        <trans-unit id="a0e67eb620416238a8b294395b73dca4cd9691e0" translate="yes" xml:space="preserve">
          <source>You might want to go ahead and make a separate function to do it for you though:</source>
          <target state="translated">Хотя,возможно,вы захотите сделать для себя отдельную функцию:</target>
        </trans-unit>
        <trans-unit id="1fbe39fdfef0c51e98d97ae9df64c7e3ee2085a2" translate="yes" xml:space="preserve">
          <source>You should use:</source>
          <target state="translated">Тебе стоит воспользоваться:</target>
        </trans-unit>
        <trans-unit id="1975acf7e3e1614d24accc2456f01338f73bcf5d" translate="yes" xml:space="preserve">
          <source>for more information, you can have a look at this link</source>
          <target state="translated">для получения дополнительной информации,вы можете посмотреть эту ссылку.</target>
        </trans-unit>
        <trans-unit id="c9736e8b5c06255cf70c5c66cbb121f59efb655d" translate="yes" xml:space="preserve">
          <source>let &lt;em&gt;n&lt;/em&gt;, &lt;em&gt;k&lt;/em&gt;, and &lt;em&gt;s&lt;/em&gt; be integers such that &lt;em&gt;k&lt;/em&gt; &amp;ge; 1, 10&lt;sup&gt;&lt;i&gt;k&lt;/i&gt;-1&lt;/sup&gt; &amp;le; &lt;em&gt;s&lt;/em&gt; &amp;lt; 10&lt;sup&gt;&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt;, the Number value for &lt;em&gt;s&lt;/em&gt; &amp;times; 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;-&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt; is &lt;em&gt;m&lt;/em&gt;, and &lt;em&gt;k&lt;/em&gt; is as small as possible. Note that k is the number of digits in the decimal representation of &lt;em&gt;s&lt;/em&gt;, that &lt;em&gt;s&lt;/em&gt; is not divisible by 10, and that the least significant digit of &lt;em&gt;s&lt;/em&gt; is not necessarily uniquely determined by these criteria.</source>
          <target state="translated">пусть &lt;em&gt;n&lt;/em&gt; , &lt;em&gt;k&lt;/em&gt; и &lt;em&gt;s&lt;/em&gt; - целые числа, такие что &lt;em&gt;k&lt;/em&gt; &amp;ge; 1, 10 &lt;sup&gt;&lt;i&gt;k&lt;/i&gt; -1&lt;/sup&gt; &amp;le; &lt;em&gt;s&lt;/em&gt; &amp;lt;10 &lt;sup&gt;&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt; , числовое значение для &lt;em&gt;s&lt;/em&gt; &amp;times; 10 &lt;sup&gt;&lt;i&gt;n&lt;/i&gt; - &lt;i&gt;k&lt;/i&gt;&lt;/sup&gt; равно &lt;em&gt;m&lt;/em&gt; , а &lt;em&gt;k&lt;/em&gt; настолько мало, насколько это возможно. Обратите внимание, что k - это количество цифр в десятичном представлении &lt;em&gt;s&lt;/em&gt; , что &lt;em&gt;s&lt;/em&gt; не делится на 10, и что младшая значащая цифра &lt;em&gt;s&lt;/em&gt; не обязательно определяется этими критериями однозначно.</target>
        </trans-unit>
        <trans-unit id="79a55b28f42f64f7f17d4f2f7c30cbe7a2bd50a6" translate="yes" xml:space="preserve">
          <source>then you can just &lt;code&gt;parseFloat&lt;/code&gt; and zeroes will 'go away'.</source>
          <target state="translated">тогда вы можете просто &lt;code&gt;parseFloat&lt;/code&gt; и нули &amp;laquo;уйдут&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="d9b4f0c3f620d92bff0c5ce1441899f7830fa702" translate="yes" xml:space="preserve">
          <source>to know the difference between toFixed and round. You can have a look at &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/566564/javascript-functions-math-roundnum-vs-num-tofixed0-and-browser-inconsistenci&quot;&gt;Math.round(num) vs num.toFixed(0) and browser inconsistencies&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">знать разницу между фиксированным и круглым. Вы можете взглянуть на &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/566564/javascript-functions-math-roundnum-vs-num-tofixed0-and-browser-inconsistenci&quot;&gt;Math.round (num) против num.toFixed (0) и несоответствия браузера&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="88e23d7331fc1070d7d98a821a40134dbbdd7cca" translate="yes" xml:space="preserve">
          <source>toFixed() will also &lt;strong&gt;NOT&lt;/strong&gt; round correctly in some cases (tested in Chrome v.55.0.2883.87)!</source>
          <target state="translated">toFixed () также &lt;strong&gt;НЕ&lt;/strong&gt; будет правильно округляться в некоторых случаях (протестировано в Chrome v.55.0.2883.87)!</target>
        </trans-unit>
        <trans-unit id="8a851e1ca9928f5dba505859dc2784363657f289" translate="yes" xml:space="preserve">
          <source>which is closer to 0.01 than to 0.02.</source>
          <target state="translated">что ближе к 0.01,чем к 0.02.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
