<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/11832914">
    <body>
      <group id="11832914">
        <trans-unit id="b6ece284bdcef543af3fa04af9f8140b35cca2c3" translate="yes" xml:space="preserve">
          <source>(As an alternative, you could also try the &lt;a href=&quot;https://github.com/jhohlfeld/round10&quot;&gt;round10&lt;/a&gt; library which provides a similarly-behaving function with a wildly different implementation.)</source>
          <target state="translated">（代わりに、 &lt;a href=&quot;https://github.com/jhohlfeld/round10&quot;&gt;まったく&lt;/a&gt;異なる実装で同様に動作する関数を提供するround10ライブラリを試すこともできます。）</target>
        </trans-unit>
        <trans-unit id="6681674ef7ab7bb360570aaedfa1b23c78b184b2" translate="yes" xml:space="preserve">
          <source>... I get 0.015, which should round to 0.02, and which is noticeably &lt;em&gt;not&lt;/em&gt; the 56-decimal-place number I earlier said that all of these numbers were exactly equal to. So what dark magic is this?</source>
          <target state="translated">... 0.015を取得します。これは0.02に四捨五入する必要があります。これは、前述の56桁の数値とは明らかに異なります。 これは何のダークマジックですか？</target>
        </trans-unit>
        <trans-unit id="c6a08c79c3157a0800a5664fbe8ac079f3090599" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;toFixed(2)&lt;/code&gt; here 2 is number of digits upto which we want to round this num.</source>
          <target state="translated">&lt;code&gt;toFixed(2)&lt;/code&gt; ここで2は、この数値を丸める桁数です。</target>
        </trans-unit>
        <trans-unit id="6f89dbbb6171fb257097653bce48c99201d2bf6d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT (2019):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;編集（2019）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="94c3f2940bab5ea0c2d43ef846e1ca78e2d60ba3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT (december 2019):&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;編集（2019年12月）：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e23e8588def29ed89ca632405fa7089ba47d19e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; to ensure things like 1.005 round correctly, we use</source>
          <target state="translated">&lt;strong&gt;編集：&lt;/strong&gt; 1.005のようなものを正しく丸めるために、</target>
        </trans-unit>
        <trans-unit id="4abe7a00ac8031d5894c9ec2f50051099b25c203" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;NOTE:&lt;/strong&gt; This is not a universal solution for everyone. There are several different rounding algorithms, your implementation can be different, depends on your requirements. &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;https://en.wikipedia.org/wiki/Rounding&lt;/a&gt;</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;これは万人向けの一般的なソリューションではありません。 いくつかの異なる丸めアルゴリズムがあり、実装は異なる場合があり、要件によって異なります。 &lt;a href=&quot;https://en.wikipedia.org/wiki/Rounding&quot;&gt;https://en.wikipedia.org/wiki/Rounding&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5700e435626d6a7bc525fba922f6696dce2146e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;None of the answers found here is correct&lt;/strong&gt;. @stinkycheeseman asked to &lt;strong&gt;round up&lt;/strong&gt;, you all rounded the number.</source>
          <target state="translated">&lt;strong&gt;ここで見つかった答えはどれも正しくありません&lt;/strong&gt; 。 @stinkycheesemanが切り上げを依頼しました。</target>
        </trans-unit>
        <trans-unit id="8f505dab513fc6e66e32870147f13bf544aaf130" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 1&lt;/strong&gt; is to use a script with required rounding algorithm, for example:</source>
          <target state="translated">&lt;strong&gt;解決策1&lt;/strong&gt;は、必要な丸めアルゴリズムを備えたスクリプトを使用することです。次に例を示します。</target>
        </trans-unit>
        <trans-unit id="60da7ee155aad83e9fc691a1e3f288cb20397643" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution 2&lt;/strong&gt; is to avoid front end calculations and pull rounded values from the backend server.</source>
          <target state="translated">&lt;strong&gt;ソリューション2&lt;/strong&gt;は、フロントエンドの計算を回避し、丸められた値をバックエンドサーバーから取得することです。</target>
        </trans-unit>
        <trans-unit id="de4e79b8a1f775972ba777a47804a2f6c93dc4ca" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;That is simply the way floating point numbers works in a computer.&lt;/strong&gt; Like 99% of programming languages, JavaScript doesn't have &lt;em&gt;home made&lt;/em&gt; floating point numbers; it relies on the CPU/FPU for that. A computer uses binary, and in binary, there isn't any numbers like &lt;code&gt;0.1&lt;/code&gt;, but a mere binary approximation for that. Why? For the same reason than 1/3 cannot be written in decimal: its value is 0.33333333... with an infinity of threes.</source>
          <target state="translated">&lt;strong&gt;これは、浮動小数点数がコンピュータで機能する方法です。&lt;/strong&gt; 99％のプログラミング言語と同様に、JavaScriptには&lt;em&gt;自家製の&lt;/em&gt;浮動小数点数がありません。 それはCPU / FPUに依存しています。 コンピュータはバイナリを使用し、バイナリでは &lt;code&gt;0.1&lt;/code&gt; のような数値はありませんが、そのための単なるバイナリ近似です。 どうして？ 同じ理由で、1/3を10進数で書くことはできません。その値は0.33333333 ...で、無限大の3です。</target>
        </trans-unit>
        <trans-unit id="9188873b53a0860b8d45c86992acf0ce33ebbec3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usage:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Usage:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e1b2af8daa9bf0f51bff3121bdff06a9eef9fdbd" translate="yes" xml:space="preserve">
          <source>A precise rounding method. Source: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Mozilla&lt;/a&gt;</source>
          <target state="translated">正確な丸め方法。 出典： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Mozilla&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="69b2d171eb62a98f494d32dbf0399f2c6f867adf" translate="yes" xml:space="preserve">
          <source>A simple drop in solution that provides accurate decimal rounding, flooring, and ceiling, with an optional precision variable without adding a whole library.</source>
          <target state="translated">ライブラリ全体を追加することなく、オプションの精度変数を使用して、正確な10進丸め、床、天井を提供するシンプルなドロップインソリューションです。</target>
        </trans-unit>
        <trans-unit id="d87b6d4b2b1d92b09f50fecdbf7a3fb93cdb0de7" translate="yes" xml:space="preserve">
          <source>Adapted from the solution provided here: &lt;a href=&quot;https://stackoverflow.com/a/48850944/6910392&quot;&gt;https://stackoverflow.com/a/48850944/6910392&lt;/a&gt;</source>
          <target state="translated">ここで提供されるソリューションから適応： &lt;a href=&quot;https://stackoverflow.com/a/48850944/6910392&quot;&gt;https&lt;/a&gt; : //stackoverflow.com/a/48850944/6910392</target>
        </trans-unit>
        <trans-unit id="b39ace06fe7843f11aa15e7af8ac8aa65286c4d1" translate="yes" xml:space="preserve">
          <source>After running through various iterations of all the possible ways to achieve true accurate decimal rounding precision, it is clear that the most accurate and efficient solution is to use Number.EPSILON. This provides a true mathematical solution to the problem of floating point math precision. It can be easily polyfilled as shown here: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&lt;/a&gt; to support all of the last remaining IE users (then again maybe we should stop doing that).</source>
          <target state="translated">真の正確な小数丸め精度を実現するために考えられるすべての方法のさまざまな反復を実行した後、最も正確かつ効率的なソリューションはNumber.EPSILONを使用することであることは明らかです。 これにより、浮動小数点演算の精度の問題に対する真の数学的なソリューションが提供されます。 次のように簡単にポリフィルできます。それをやめるべきです）。</target>
        </trans-unit>
        <trans-unit id="f575b52acd8ef9eab6fdcf0d803b1f78d5741f89" translate="yes" xml:space="preserve">
          <source>Also it's worth noting that this is not a &lt;em&gt;JavaScript weirdness&lt;/em&gt; like some people stated.</source>
          <target state="translated">また、これは一部の人々が述べたような&lt;em&gt;JavaScriptの奇妙さで&lt;/em&gt;はないことにも注意する価値があり&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="c4937c3ee7e26dbf578cfd6247ad524d28ec2b62" translate="yes" xml:space="preserve">
          <source>As asked in the comments, let's clarify one thing: adding &lt;code&gt;Number.EPSILON&lt;/code&gt; is relevant only when the value to round is the result of an arithmetic operation, as it can swallow some floating point error delta.</source>
          <target state="translated">コメントで尋ねられたように、1つ明確にしましょう &lt;code&gt;Number.EPSILON&lt;/code&gt; 追加は、浮動小数点エラーデルタを飲み込む可能性があるため、丸める値が算術演算の結果である場合にのみ関連します。</target>
        </trans-unit>
        <trans-unit id="5c1aa79e884353e01805297b4ffdc0e1b809104c" translate="yes" xml:space="preserve">
          <source>But what if you have the second kind of Number - a value taken from a continuous scale, where there's no reason to think that approximate decimal representations with fewer decimal places are more &lt;em&gt;accurate&lt;/em&gt; than those with more? In that case, we &lt;em&gt;don't&lt;/em&gt; want to respect the String representation, because that representation (as explained in the spec) is already sort-of-rounded; we don't want to make the mistake of saying &quot;0.014999999...375 rounds up to 0.015, which rounds up to 0.02, so 0.014999999...375 rounds up to 0.02&quot;.</source>
          <target state="translated">しかし、第2の種類の数値-小数点以下の桁数が少ない近似の10進表記が、小数点以下の桁数が多いものよりも&lt;em&gt;正確&lt;/em&gt;であると考える理由がない場合に、数値がある場合はどうでしょうか。 その場合、（仕様で説明されているように）String表現は既に丸められているため、String表現を尊重したく&lt;em&gt;ありませ&lt;/em&gt;ん。 「0.014999999 ... 375は0.015に切り上げられ、0.02に切り上げられるため、0.014999999 ... 375は0.02に切り上げられます」と言って間違えたくありません。</target>
        </trans-unit>
        <trans-unit id="ab662aee31f190e347238c5fbc1e7d6128a3dbdd" translate="yes" xml:space="preserve">
          <source>Compared to Lavamantis's solution, we can do...</source>
          <target state="translated">ラバマンティスの解決策に比べれば</target>
        </trans-unit>
        <trans-unit id="8589b8976170efc90ee30bed08325d4b4f5fb025" translate="yes" xml:space="preserve">
          <source>Consider &lt;code&gt;.toFixed()&lt;/code&gt; and &lt;code&gt;.toPrecision()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;.toFixed()&lt;/code&gt; および &lt;code&gt;.toPrecision()&lt;/code&gt; を検討してください。</target>
        </trans-unit>
        <trans-unit id="85511932eb0bd6ee919a34a7f2c6087bb0a5fb7b" translate="yes" xml:space="preserve">
          <source>Easiest way:</source>
          <target state="translated">一番簡単な方法です。</target>
        </trans-unit>
        <trans-unit id="5e297a41e8ef5ac08adf9ee0810c2244721fa92b" translate="yes" xml:space="preserve">
          <source>Eg:</source>
          <target state="translated">Eg:</target>
        </trans-unit>
        <trans-unit id="5ab7721397827b925456d2a147cb5704105a62a7" translate="yes" xml:space="preserve">
          <source>Example usage:</source>
          <target state="translated">使用例。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="945a73f60f58235e70de75adb211e4394558c073" translate="yes" xml:space="preserve">
          <source>For me &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Math.round()&lt;/a&gt; was not giving correct answer. I found &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt;toFixed(2)&lt;/a&gt; works better. 
Below are examples of both:</source>
          <target state="translated">私にとって、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;Math.round（）&lt;/a&gt;は正しい答えを与えていませんでした。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt;toFixed（2）の&lt;/a&gt;方がうまくいくことがわかりました。 以下は両方の例です。</target>
        </trans-unit>
        <trans-unit id="edbdada6b4155dd45ec8fd8ab20607a6462b6549" translate="yes" xml:space="preserve">
          <source>Here come &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/a&gt;. That number is the difference between 1 and the &lt;em&gt;next&lt;/em&gt; number existing in the double precision floating point numbers. &lt;strong&gt;That's it: There is no number between &lt;code&gt;1&lt;/code&gt; and 1 + &lt;code&gt;Number.EPSILON&lt;/code&gt;.&lt;/strong&gt;</source>
          <target state="translated">ここに&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; があり&lt;/a&gt;ます。 その数は、1と倍精度浮動小数点数に存在する&lt;em&gt;次の&lt;/em&gt;数の差です。 &lt;strong&gt;それだけです： &lt;code&gt;1&lt;/code&gt; と1 + &lt;code&gt;Number.EPSILON&lt;/code&gt; の間の数はありません。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="582a28d3d6f5875f42faffd53f6dca41c44e4409" translate="yes" xml:space="preserve">
          <source>Here is a prototype method:</source>
          <target state="translated">ここにプロトタイプの方法があります。</target>
        </trans-unit>
        <trans-unit id="2becac006f82ed17841b46654302952a6af24ef5" translate="yes" xml:space="preserve">
          <source>Here is a simple way to do it:</source>
          <target state="translated">簡単な方法をご紹介します。</target>
        </trans-unit>
        <trans-unit id="86712cc5731f9156c956e2225c2cb563bb12f349" translate="yes" xml:space="preserve">
          <source>Here is the function I use to solve the floating point decimals issues &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round#Example%3a_Decimal_rounding&quot;&gt;also based on MDN&lt;/a&gt;. It is even more generic (but less concise) than Lavamantis's solution:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round#Example%3a_Decimal_rounding&quot;&gt;MDNにも基づい&lt;/a&gt;て浮動小数点の10進数の問題を解決するために使用する関数は次のとおりです。 これは、Lavamantisのソリューションよりも一般的です（ただし簡潔ではありません）。</target>
        </trans-unit>
        <trans-unit id="c0d5875b4c5849ab3bfd33eea8d2f49977f4bd52" translate="yes" xml:space="preserve">
          <source>Here we can simply use the built-in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt;&lt;code&gt;toFixed&lt;/code&gt;&lt;/a&gt; method. Note that by calling &lt;code&gt;Number()&lt;/code&gt; on the String returned by &lt;code&gt;toFixed&lt;/code&gt;, we get a Number whose String representation has no trailing zeroes (thanks to the way JavaScript computes the String representation of a Number, discussed earlier in this answer).</source>
          <target state="translated">ここでは、単純に組み込みの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toFixed&quot;&gt; &lt;code&gt;toFixed&lt;/code&gt; &lt;/a&gt;メソッドを使用できます。 &lt;code&gt;toFixed&lt;/code&gt; によって返されたStringで &lt;code&gt;Number()&lt;/code&gt; を呼び出すと、String表現に後続ゼロがないNumberが取得されることに注意してください（JavaScriptがこの数値のString表現を計算する方法のおかげで、この回答で前述しました）。</target>
        </trans-unit>
        <trans-unit id="c0f0c4ff59640480547b46eb98247d0405dde5a2" translate="yes" xml:space="preserve">
          <source>Here, also is one function I wrote to do arithmetic rounding correctly. You can test it yourself.</source>
          <target state="translated">ここにも、算術で四捨五入を正しく行うために書いた関数があります。自分でテストしてみてください。</target>
        </trans-unit>
        <trans-unit id="75553f548ebe8d7c4d7be06075a2ad90b25c726b" translate="yes" xml:space="preserve">
          <source>How can I do this in JavaScript?</source>
          <target state="translated">JavaScriptではどうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="379bf1ec8b931f6919ae70cbdb99b7a15e4424b6" translate="yes" xml:space="preserve">
          <source>I found this over on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;MDN&lt;/a&gt;. Their way avoids the problem with 1.005 that was &lt;a href=&quot;https://stackoverflow.com/questions/11832914/round-up-to-2-decimal-places-in-javascript#comment24719818_11832950&quot;&gt;mentioned&lt;/a&gt;.</source>
          <target state="translated">私はこれを&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round&quot;&gt;MDNで&lt;/a&gt;見つけました。 彼らの方法は、 &lt;a href=&quot;https://stackoverflow.com/questions/11832914/round-up-to-2-decimal-places-in-javascript#comment24719818_11832950&quot;&gt;言及された&lt;/a&gt; 1.005の問題を回避します。</target>
        </trans-unit>
        <trans-unit id="070221396ffd7adc80f964d497ffbcc8f1956377" translate="yes" xml:space="preserve">
          <source>I guess, this is because 1.555 is actually something like float 1.55499994 behind the scenes.</source>
          <target state="translated">これは1.555が実は裏でfloat 1.55499994のようなものになっているからではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="07e838235f2a025cd47854a685499d5a0537ecfb" translate="yes" xml:space="preserve">
          <source>I removed the variant &lt;code&gt;n.toFixed(2)&lt;/code&gt;, because it is not correct. Thank you @avalanche1</source>
          <target state="translated">バリアント &lt;code&gt;n.toFixed(2)&lt;/code&gt; は 、正しくないため削除しました。 ありがとう@ avalanche1</target>
        </trans-unit>
        <trans-unit id="48bd35342cfdaf130a7708310f7a72f622b696f6" translate="yes" xml:space="preserve">
          <source>I'd like to round at most 2 decimal places, but &lt;em&gt;only if necessary&lt;/em&gt;.</source>
          <target state="translated">小数点以下2桁まで丸めたいのですが&lt;em&gt;、必要な場合のみです&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="ec800790fcee0bf08442c4630dae0d9ba7b6d988" translate="yes" xml:space="preserve">
          <source>If the value is a number:</source>
          <target state="translated">値が数値の場合。</target>
        </trans-unit>
        <trans-unit id="b1fefa7ba2439d746003f46853a7371ff731d113" translate="yes" xml:space="preserve">
          <source>If the value is a text type:</source>
          <target state="translated">値がテキスト型の場合。</target>
        </trans-unit>
        <trans-unit id="e41c41447951ebc94d036fd32ec620302036e867" translate="yes" xml:space="preserve">
          <source>If you are open to libraries you can use &lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;bignumber.js&lt;/a&gt;</source>
          <target state="translated">ライブラリを利用できる場合は、 &lt;a href=&quot;https://github.com/MikeMcl/bignumber.js/&quot;&gt;bignumber.js&lt;/a&gt;を使用できます。</target>
        </trans-unit>
        <trans-unit id="dc26938bf0e0296802c89e07ccde26e1ab90731a" translate="yes" xml:space="preserve">
          <source>If you are using lodash library, you can use the round method of lodash like following.</source>
          <target state="translated">lodashライブラリを使用している場合は、以下のように丸めて使うことができます。</target>
        </trans-unit>
        <trans-unit id="3216546a05d95fdf5f5508347421f9837590b56b" translate="yes" xml:space="preserve">
          <source>If you need to be strict and add digits just if needed it can use &lt;code&gt;replace&lt;/code&gt;</source>
          <target state="translated">厳密である必要があり、必要に応じて数字を追加する場合は、 &lt;code&gt;replace&lt;/code&gt; を使用できます</target>
        </trans-unit>
        <trans-unit id="a938b4696af9e98610818f1d8d206757dad7ae27" translate="yes" xml:space="preserve">
          <source>If your project uses jQuery or lodash, you can also find proper &lt;code&gt;round&lt;/code&gt; method in the libraries.</source>
          <target state="translated">プロジェクトでjQueryまたはlodashを使用している場合は、ライブラリで適切な &lt;code&gt;round&lt;/code&gt; メソッドを見つけることもできます。</target>
        </trans-unit>
        <trans-unit id="6af9e62dcf39a0d15e0f97e5a60d274500525b0b" translate="yes" xml:space="preserve">
          <source>In fact, in the code I'm using &lt;code&gt;ESPILON_RATE = 1 + 4 * Number.EPSILON&lt;/code&gt; and &lt;code&gt;EPSILON_ZERO = 4 * Number.MIN_VALUE&lt;/code&gt; (four times the epsilon), because I want an equality checker loose enough for cumulating floating point error.</source>
          <target state="translated">実際、コードで &lt;code&gt;ESPILON_RATE = 1 + 4 * Number.EPSILON&lt;/code&gt; および &lt;code&gt;EPSILON_ZERO = 4 * Number.MIN_VALUE&lt;/code&gt; （イプシロンの4倍）を使用しています。これは、浮動小数点エラーを累積するために十分に緩い等価チェッカーが必要だからです。</target>
        </trans-unit>
        <trans-unit id="ef69761016065df342a41f1ba61cbdee1af2e52f" translate="yes" xml:space="preserve">
          <source>In general, rounding is done by scaling: &lt;code&gt;round(num / p) * p&lt;/code&gt;</source>
          <target state="translated">一般的に、丸めはスケーリングによって行われます： &lt;code&gt;round(num / p) * p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="79d70dcb4f9ee8b7d94ed9539586cc73c0d399da" translate="yes" xml:space="preserve">
          <source>Input:</source>
          <target state="translated">Input:</target>
        </trans-unit>
        <trans-unit id="5bdb51e539dd788122b75e12613282cb9a59033d" translate="yes" xml:space="preserve">
          <source>It converts it to a string, and then back into an integer / float.</source>
          <target state="translated">それを文字列に変換して、整数のfloatに戻します。</target>
        </trans-unit>
        <trans-unit id="e7f26dce8602d2aa4e2f07b9f0b39e5804a7316d" translate="yes" xml:space="preserve">
          <source>It doesn't solve the '1.005 rounding problem' though - since it is intrinsic to how &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/101163/what-causes-floating-point-rounding-errors&quot;&gt;float fractions are being processed&lt;/a&gt;.</source>
          <target state="translated">ただし、「1.005丸めの問題」は解決されません。 &lt;a href=&quot;https://softwareengineering.stackexchange.com/questions/101163/what-causes-floating-point-rounding-errors&quot;&gt;浮動小数点数の処理&lt;/a&gt;方法に固有であるためです 。</target>
        </trans-unit>
        <trans-unit id="bb18705dfa4dbaefc58019dd86183424f5d60d6a" translate="yes" xml:space="preserve">
          <source>It may work for you,</source>
          <target state="translated">それはあなたのために働くかもしれません。</target>
        </trans-unit>
        <trans-unit id="9db4057b0b1aefd3eabe9d5558fa88ce0408b22f" translate="yes" xml:space="preserve">
          <source>It seems like &lt;code&gt;Math.round&lt;/code&gt; is a better solution. &lt;strong&gt;But it is not!&lt;/strong&gt; In some cases it will &lt;strong&gt;NOT&lt;/strong&gt; round correctly:</source>
          <target state="translated">&lt;code&gt;Math.round&lt;/code&gt; がより良い解決策のようです。 &lt;strong&gt;そうではありません！&lt;/strong&gt; 場合によっては、正しく丸められ&lt;strong&gt;ませ&lt;/strong&gt;ん。</target>
        </trans-unit>
        <trans-unit id="de7e2f930d8192a22533ff7c52eeb7a294e46200" translate="yes" xml:space="preserve">
          <source>It's not useful when the value comes from a direct source (e.g.: literal, user input or sensor).</source>
          <target state="translated">値が直接のソース(例:リテラル、ユーザー入力、センサー)からのものである場合は役に立ちません。</target>
        </trans-unit>
        <trans-unit id="d16bae6ae960069cfbe9eb6b916a4ba5bc5ae155" translate="yes" xml:space="preserve">
          <source>Just use native code &lt;code&gt;.toFixed()&lt;/code&gt;</source>
          <target state="translated">ネイティブコード &lt;code&gt;.toFixed()&lt;/code&gt; を使用するだけ</target>
        </trans-unit>
        <trans-unit id="5b1a5d323275c298c4aa9b8992ef25578960b7c0" translate="yes" xml:space="preserve">
          <source>Lately, I use a function similar to this one for comparing numbers epsilon-aware:</source>
          <target state="translated">最近は、イプシロンを意識した数字の比較には、これと似たような関数を使っています。</target>
        </trans-unit>
        <trans-unit id="adb23d3b5115886051bb54739f5c553032bc9dc7" translate="yes" xml:space="preserve">
          <source>Like @maganap and some peoples have pointed out, it's best to add &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/a&gt; before multiplying:</source>
          <target state="translated">@maganapや一部の人々が指摘したように、乗算する前に&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; &lt;/a&gt;を追加するのが最善です。</target>
        </trans-unit>
        <trans-unit id="2787e27648a8b92aefd69a68e92ccec35c88a574" translate="yes" xml:space="preserve">
          <source>MarkG and Lavamantis offered a much better solution than the one that has been accepted. It's a shame they don't get more upvotes!</source>
          <target state="translated">MarkGとLavamantisは、受け入れられたものよりもはるかに良い解決策を提案してくれました。彼らがより多くのアップバウトを得られないのは残念です!</target>
        </trans-unit>
        <trans-unit id="e9cb187413866bee5719685fd8cb0c4a9882de1d" translate="yes" xml:space="preserve">
          <source>MarkG's answer is the correct one.  Here's a generic extension for any number of decimal places.</source>
          <target state="translated">MarkGさんの答えが正解です。小数点以下の任意の数の一般的な拡張子はここにあります。</target>
        </trans-unit>
        <trans-unit id="428f9655e67ff46265d67320cd0ccfe0319be407" translate="yes" xml:space="preserve">
          <source>Math.round(num) vs num.toFixed(0) and browser inconsistencies</source>
          <target state="translated">Math.round(num)と num.toFixed(0)とブラウザの矛盾</target>
        </trans-unit>
        <trans-unit id="ff707f109be190d332352b938ccc8b3c4e06e97c" translate="yes" xml:space="preserve">
          <source>My use-case is &lt;a href=&quot;https://www.npmjs.com/package/doormen&quot;&gt;an assertion + data validation lib&lt;/a&gt; I'm developing for many years.</source>
          <target state="translated">私のユースケースは&lt;a href=&quot;https://www.npmjs.com/package/doormen&quot;&gt;、&lt;/a&gt;私が長年開発しているアサーション+データ検証ライブラリです。</target>
        </trans-unit>
        <trans-unit id="59377d5faf3749e97822f1f1971ecded10a972a6" translate="yes" xml:space="preserve">
          <source>No one seems to be aware of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt;&lt;code&gt;Number.EPSILON&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON&quot;&gt; &lt;code&gt;Number.EPSILON&lt;/code&gt; を&lt;/a&gt;意識している人はいません。</target>
        </trans-unit>
        <trans-unit id="ca5e324249ddd6187831ef808ea93363a2b26711" translate="yes" xml:space="preserve">
          <source>Of course, none of this discussion has directly answered what &lt;code&gt;roundTo2DP(m)&lt;/code&gt;&lt;em&gt;should&lt;/em&gt; return. If &lt;code&gt;m&lt;/code&gt;'s exact value is 0.01499999999999999944488848768742172978818416595458984375, but its String representation is '0.015', then what is the &lt;em&gt;correct&lt;/em&gt; answer - mathematically, practically, philosophically, or whatever - when we round it to two decimal places?</source>
          <target state="translated">もちろん、この議論はどれも、 &lt;code&gt;roundTo2DP(m)&lt;/code&gt; &lt;em&gt;が&lt;/em&gt;返す&lt;em&gt;べき&lt;/em&gt;ものに直接答えてい&lt;em&gt;ませ&lt;/em&gt;ん。 &lt;code&gt;m&lt;/code&gt; の正確な値が0.01499999999999999944488848768742172978818416595458984375であるが、その文字列表現が「0.015」である&lt;em&gt;場合&lt;/em&gt; 、数学的に、実際的に、哲学的に、または何でも、小数点以下2桁に四捨五入すると&lt;em&gt;正しい&lt;/em&gt;答えは何ですか？</target>
        </trans-unit>
        <trans-unit id="9de972621e113a6822f18823d2063f32eba7fcf6" translate="yes" xml:space="preserve">
          <source>On the other hand, you probably want to respect the binary floating point value and round downwards when your value is from an inherently continuous scale - for instance, if it's a reading from a sensor.</source>
          <target state="translated">一方、値が本質的に連続的なスケールからのものである場合、例えばセンサーからの読み取り値の場合、2進浮動小数点値を尊重して下向きに丸めたいと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="6bbbecb3438fd6440ef7f77e7aea3b5d8bdb6531" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;.toFixed(NumberOfDecimalPlaces)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;.toFixed(NumberOfDecimalPlaces)&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="576fa80104f1e9d06e3d6fd8ed6dedc8629cc5e4" translate="yes" xml:space="preserve">
          <source>One way to achieve such a rounding &lt;em&gt;only if necessary&lt;/em&gt; is to use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString&quot;&gt;Number.prototype.toLocaleString()&lt;/a&gt;:</source>
          <target state="translated">&lt;em&gt;必要な&lt;/em&gt;場合に&lt;em&gt;のみ&lt;/em&gt;このような丸めを実現する1つの方法は、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString&quot;&gt;Number.prototype.toLocaleString（）&lt;/a&gt;を使用することです 。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="c1d0e0227161567c5c8a46e530e257ab7932de2e" translate="yes" xml:space="preserve">
          <source>Round to at most 2 decimal places (only if necessary)</source>
          <target state="translated">最大で小数点以下2桁に丸める(必要な場合のみ</target>
        </trans-unit>
        <trans-unit id="1b3ea2091e0125bb10b50729a167add8b2875170" translate="yes" xml:space="preserve">
          <source>Since ES6 there is a 'proper' way (without overriding statics and creating workarounds) to do this by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Number/toPrecision&quot;&gt;using toPrecision&lt;/a&gt;</source>
          <target state="translated">ES6以降では、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Number/toPrecision&quot;&gt;toPrecisionを使用&lt;/a&gt;してこれを行う「適切な」方法があります（静的をオーバーライドせず、回避策を作成する必要はありません）。</target>
        </trans-unit>
        <trans-unit id="c131372ed2ef9d5afca4b7ffe157d796543820d0" translate="yes" xml:space="preserve">
          <source>So far, it looks perfect for me.
I hope it will help.</source>
          <target state="translated">今のところ、私にはぴったりのようです。参考になればと思います。</target>
        </trans-unit>
        <trans-unit id="d9eb0d47c4da3723a4af8473544b8419da09be27" translate="yes" xml:space="preserve">
          <source>So when I write &lt;code&gt;m = 0.0150000000000000001&lt;/code&gt;, the &lt;em&gt;exact value of &lt;code&gt;m&lt;/code&gt;&lt;/em&gt; that I end up with is closer to &lt;code&gt;0.01&lt;/code&gt; than it is to &lt;code&gt;0.02&lt;/code&gt;. And yet, if I convert &lt;code&gt;m&lt;/code&gt; to a String...</source>
          <target state="translated">したがって、 &lt;code&gt;m = 0.0150000000000000001&lt;/code&gt; と記述した&lt;em&gt;場合、 &lt;code&gt;m&lt;/code&gt; &lt;/em&gt;の&lt;em&gt;正確な値は&lt;/em&gt; &lt;code&gt;0.02&lt;/code&gt; よりも &lt;code&gt;0.01&lt;/code&gt; に近くなります。 それでも、 &lt;code&gt;m&lt;/code&gt; を文字列に変換すると...</target>
        </trans-unit>
        <trans-unit id="3b8d42473f0fced361a981334f253d2ee119f7bd" translate="yes" xml:space="preserve">
          <source>Suppose we have a function, &lt;code&gt;roundTo2DP(num)&lt;/code&gt;, that takes a float as an argument and returns a value rounded to 2 decimal places. What should each of these expressions evaluate to?</source>
          <target state="translated">floatを引数として取り、小数点以下2桁に丸めた値を返す関数 &lt;code&gt;roundTo2DP(num)&lt;/code&gt; があるとします。 これらの式のそれぞれは何を評価する必要がありますか？</target>
        </trans-unit>
        <trans-unit id="6bfb5e628c414a067972ade779b24a3a568b3fd7" translate="yes" xml:space="preserve">
          <source>The 'obvious' answer is that the first example should round to 0.01 (because it's closer to 0.01 than to 0.02) while the other two should round to 0.02 (because 0.0150000000000000001 is closer to 0.02 than to 0.01, and because 0.015 is exactly halfway between them and there is a mathematical convention that such numbers get rounded up).</source>
          <target state="translated">明らかな」答えは、最初の例は0.01に丸めるべきだということです(0.02よりも0.01に近いからです)が、他の2つは0.02に丸めるべきです(0.01よりも0.01に近い0.0150000000000000001が0.02に近いことと、0.015はそれらの間のちょうど半分であり、そのような数字は切り上げられるという数学的な慣習があるからです)。</target>
        </trans-unit>
        <trans-unit id="c544245c0ffab197bc3584e928cfc903bd4d3964" translate="yes" xml:space="preserve">
          <source>The answer can be found in the ECMAScript specification, in section &lt;a href=&quot;http://www.ecma-international.org/ecma-262/7.0/#sec-tostring-applied-to-the-number-type&quot;&gt;&lt;em&gt;7.1.12.1: ToString applied to the Number type&lt;/em&gt;&lt;/a&gt;. Here the rules for converting some Number &lt;em&gt;m&lt;/em&gt; to a String are laid down. The key part is point 5, in which an integer &lt;em&gt;s&lt;/em&gt; is generated whose digits will be used in the String representation of &lt;em&gt;m&lt;/em&gt;:</source>
          <target state="translated">その答えは、ECMAScript仕様のセクション&lt;a href=&quot;http://www.ecma-international.org/ecma-262/7.0/#sec-tostring-applied-to-the-number-type&quot;&gt;&lt;em&gt;7.1.12.1：Number型に適用されるToStringにあり&lt;/em&gt;&lt;/a&gt;ます。 ここで、いくつかの数値&lt;em&gt;m&lt;/em&gt;を文字列に変換するためのルールを説明します。 重要な部分はポイント5であり、整数&lt;em&gt;s&lt;/em&gt;が生成され、その桁は&lt;em&gt;mの&lt;/em&gt;文字列表現で使用されます。</target>
        </trans-unit>
        <trans-unit id="df090e3c30fa1d731e05b5ce4f35661d5e7baf7c" translate="yes" xml:space="preserve">
          <source>The catch, which you may have guessed, is that &lt;code&gt;roundTo2DP&lt;/code&gt;&lt;em&gt;cannot possibly&lt;/em&gt; be implemented to give those obvious answers, because all three numbers passed to it are &lt;em&gt;the same number&lt;/em&gt;. IEEE 754 binary floating point numbers (the kind used by JavaScript) can't exactly represent most non-integer numbers, and so all three numeric literals above get rounded to a nearby valid floating point number. This number, as it happens, is &lt;em&gt;exactly&lt;/em&gt;</source>
          <target state="translated">あなたが推測したかもしれないキャッチは、渡された3つの数値がすべて&lt;em&gt;同じ&lt;/em&gt;数値であるため、 &lt;code&gt;roundTo2DP&lt;/code&gt; &lt;em&gt;を&lt;/em&gt;実装してそれらの明白な答えを出す&lt;em&gt;ことはおそらくできない&lt;/em&gt;という&lt;em&gt;こと&lt;/em&gt;です。 IEEE 754 2進浮動小数点数（JavaScriptで使用される種類）は、ほとんどの非整数値を正確に表すことができないため、上記の3つの数値リテラルはすべて、近くの有効な浮動小数点数に丸められます。 この数は、偶然にも、 &lt;em&gt;まさに&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17eaea0baa02c017f3ef107833be95e25d292bd7" translate="yes" xml:space="preserve">
          <source>The function above is &lt;em&gt;probably&lt;/em&gt; what you want to use to avoid users ever witnessing numbers that they have entered being rounded wrongly.</source>
          <target state="translated">上記の関数は、ユーザーが入力した数値が誤って丸められるのを目撃しないようにするために使用するものです。</target>
        </trans-unit>
        <trans-unit id="7a1df7bf3e06ffb09c0be63d9ac99109b43decd2" translate="yes" xml:space="preserve">
          <source>The key part here is the requirement that &quot;&lt;em&gt;k&lt;/em&gt; is as small as possible&quot;. What that requirement amounts to is a requirement that, given a Number &lt;code&gt;m&lt;/code&gt;, the value of &lt;code&gt;String(m)&lt;/code&gt; must have &lt;em&gt;the least possible number of digits&lt;/em&gt; while still satisfying the requirement that &lt;code&gt;Number(String(m)) === m&lt;/code&gt;. Since we already know that &lt;code&gt;0.015 === 0.0150000000000000001&lt;/code&gt;, it's now clear why &lt;code&gt;String(0.0150000000000000001) === '0.015'&lt;/code&gt; must be true.</source>
          <target state="translated">ここで重要なのは、「 &lt;em&gt;k&lt;/em&gt;ができるだけ小さい」という要件です。 その要件は、Number &lt;code&gt;m&lt;/code&gt; が与えられた場合、 &lt;code&gt;String(m)&lt;/code&gt; の値は、 &lt;code&gt;Number(String(m)) === m&lt;/code&gt; という要件を満たしながら&lt;em&gt;、可能な限り最小桁数で&lt;/em&gt;なければならないという要件です。 &lt;code&gt;0.015 === 0.0150000000000000001&lt;/code&gt; であることはすでにわかっているため、 &lt;code&gt;String(0.0150000000000000001) === '0.015'&lt;/code&gt; がtrueである必要がある理由は明らかです。</target>
        </trans-unit>
        <trans-unit id="d9304dfd5b20a84c90c202df6981188a19c4637d" translate="yes" xml:space="preserve">
          <source>The value being represented is inherently discrete, e.g. an amount of currency in a 3-decimal-place currency like dinars. In this case, the &lt;em&gt;true&lt;/em&gt; value of a Number like 0.015 &lt;em&gt;is&lt;/em&gt; 0.015, and the 0.0149999999... representation that it gets in binary floating point is a rounding error. (Of course, many will argue, reasonably, that you should use a decimal library for handling such values and never represent them as binary floating point Numbers in the first place.)</source>
          <target state="translated">表現される値は本質的に離散的です。たとえば、ディナールのような3桁の通貨での通貨の金額。 この場合、0.015のような数値の&lt;em&gt;真の&lt;/em&gt;値&lt;em&gt;は&lt;/em&gt; 0.015であり、2進浮動小数点で取得される0.0149999999 ...表現は丸め誤差です。 （もちろん、多くの人は、そのような値を処理するために10進ライブラリーを使用し、そもそも2進浮動小数点数として決してそれらを表現してはならないと主張します。）</target>
        </trans-unit>
        <trans-unit id="0606e71f981fa36e43313e05fde67bea41c0e859" translate="yes" xml:space="preserve">
          <source>The value was typed by a user. In this case, again, the exact decimal number entered is more 'true' than the nearest binary floating point representation.</source>
          <target state="translated">値はユーザによって入力されたものです。この場合も、入力された正確な10進数は、最も近い2進数の浮動小数点表現よりも「真」です。</target>
        </trans-unit>
        <trans-unit id="8727bcf5e244c818b657462e6c613378e3d0d0c7" translate="yes" xml:space="preserve">
          <source>Then you would simply pass in the value.</source>
          <target state="translated">その場合は、単に値を渡すだけです。</target>
        </trans-unit>
        <trans-unit id="f76d9f0b8979b7733602f015e3ba04fd7d5a9502" translate="yes" xml:space="preserve">
          <source>There are a couple of ways to do that. For people like me, the Lodash's variant</source>
          <target state="translated">その方法はいくつかあります。私のような人にとっては、ローダッシュの変種</target>
        </trans-unit>
        <trans-unit id="068e2e768c65c4ad778691dec9f43778213541e5" translate="yes" xml:space="preserve">
          <source>There is a downside that values like 1.5 will give &quot;1.50&quot; as the output. A fix suggested by @minitech:</source>
          <target state="translated">1.5のような値が「1.50」を出力してしまうという欠点があります。ミニテックさんが提案してくれた修正。</target>
        </trans-unit>
        <trans-unit id="38387a87e059184ebabf02e5e267b74130d78c64" translate="yes" xml:space="preserve">
          <source>There is no single correct answer to this. It depends upon your use case. You probably want to respect the String representation and round upwards when:</source>
          <target state="translated">これに一つの正解はありません。それはあなたのユースケースに依存します。おそらく、String表現を尊重して、上向きに丸めたいと思うでしょう。</target>
        </trans-unit>
        <trans-unit id="de80e004c8c33e4edbcec58d2afcf0444b42e1b1" translate="yes" xml:space="preserve">
          <source>These two approaches require different code. To respect the String representation of the Number, we can (with quite a bit of reasonably subtle code) implement our own rounding that acts directly on the String representation, digit by digit, using the same algorithm you would've used in school when you were taught how to round numbers. Below is an example which respects the OP's requirement of representing the number to 2 decimal places &quot;only when necessary&quot; by stripping trailing zeroes after the decimal point; you may, of course, need to tweak it to your precise needs.</source>
          <target state="translated">これら2つのアプローチは異なるコードを必要とします。数の文字列表現を尊重するために、我々は(かなりの量の適度に微妙なコードを使って)一桁ずつ文字列表現に直接作用する独自の丸めを実装することができます。以下の例は、小数点以下のゼロを除去することにより、小数点以下2桁までの数値を「必要な場合のみ」表現するというOPの要件を尊重したものです。</target>
        </trans-unit>
        <trans-unit id="9cc618b8fa630d85d81948907d250ac34fd31d00" translate="yes" xml:space="preserve">
          <source>This is the simplest, more elegant solution (and I am the best of the world;):</source>
          <target state="translated">これが一番シンプルでエレガントな解決策です()</target>
        </trans-unit>
        <trans-unit id="03640ca35a3d05dde0a5a618e1942cbb23d4aba2" translate="yes" xml:space="preserve">
          <source>This may help you:</source>
          <target state="translated">これはあなたの助けになるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e3a53ec34f6c2117910f386788bc9d743450046a" translate="yes" xml:space="preserve">
          <source>This question is complicated.</source>
          <target state="translated">この質問は複雑です。</target>
        </trans-unit>
        <trans-unit id="13ea220ac7311f1b88e69de6b5b2c466b9a1e184" translate="yes" xml:space="preserve">
          <source>This will provide exactly the output you expect, but as strings. You can still convert those back to numbers if that's not the data type you expect.</source>
          <target state="translated">これにより、期待通りの出力が得られますが、文字列として出力されます。もしそれが期待しているデータ型ではない場合でも、数値に変換することができます。</target>
        </trans-unit>
        <trans-unit id="9845257528e47964d89c7b7b37c418107088920b" translate="yes" xml:space="preserve">
          <source>To round up, use this:</source>
          <target state="translated">丸め込むには、これを使います。</target>
        </trans-unit>
        <trans-unit id="cdb9e11f95eb4c3103b6460c4ec8869fcb19ed0a" translate="yes" xml:space="preserve">
          <source>Try this &lt;strong&gt;light weight&lt;/strong&gt; solution:</source>
          <target state="translated">この&lt;strong&gt;軽量&lt;/strong&gt;ソリューションを試してください：</target>
        </trans-unit>
        <trans-unit id="c83890cd9cde34e76f22e6c092f33233337bbeef" translate="yes" xml:space="preserve">
          <source>Unit test:</source>
          <target state="translated">ユニットテスト。</target>
        </trans-unit>
        <trans-unit id="aa46e3b43b8698bd79a3510bffe6645c067a8510" translate="yes" xml:space="preserve">
          <source>Update 1</source>
          <target state="translated">アップデート1</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="1a83ebd9832b047f8e615f8f8336e3bea08f97fc" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Math.round(num * 100) / 100&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Math.round(num * 100) / 100&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5bd604b7778cb749d711fce9848c8397bb74f3d3" translate="yes" xml:space="preserve">
          <source>Use it with:</source>
          <target state="translated">と一緒に使ってください。</target>
        </trans-unit>
        <trans-unit id="287f960a3fb8c81611e2058a39f3f4dbd770ca5c" translate="yes" xml:space="preserve">
          <source>Use something like this 
&quot;parseFloat(parseFloat(value).toFixed(2))&quot;</source>
          <target state="translated">次のようなものを使用します。&quot;parseFloat(parseFloat(value).toFixed(2))&quot;</target>
        </trans-unit>
        <trans-unit id="1e246aa236aacfd965aad87ba2d103b9f3166262" translate="yes" xml:space="preserve">
          <source>Use this function &lt;code&gt;Number(x).toFixed(2);&lt;/code&gt;</source>
          <target state="translated">この関数を使用します &lt;code&gt;Number(x).toFixed(2);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f36b531ef3ac37932099200af1af63e95a073826" translate="yes" xml:space="preserve">
          <source>Using the exponential notation handles rounding of +ve numbers, correctly.
However, this method fails to round -ve edge cases correctly.</source>
          <target state="translated">指数記法を使用すると、+ve数の丸めを正しく処理します。しかし、この方法では、-veの辺を正しく丸めることができません。</target>
        </trans-unit>
        <trans-unit id="782632eccf1234978150e666e6c53e7e804c43c0" translate="yes" xml:space="preserve">
          <source>You can see that all three numbers are the same at your browser console, Node shell, or other JavaScript interpreter. Just compare them:</source>
          <target state="translated">ブラウザのコンソール、Nodeシェル、または他のJavaScriptインタープリタで、3つの数字がすべて同じであることがわかります。ただ比較してみてください。</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">を使用することができます。</target>
        </trans-unit>
        <trans-unit id="dec1b74b3d17f081a5bca5eb814e512fffe48c57" translate="yes" xml:space="preserve">
          <source>You could enhance it to round to any arbitrary number of decimals by adding a second parameter.</source>
          <target state="translated">2 番目のパラメータを追加することで、任意の小数に丸めるように拡張することができます。</target>
        </trans-unit>
        <trans-unit id="a0e67eb620416238a8b294395b73dca4cd9691e0" translate="yes" xml:space="preserve">
          <source>You might want to go ahead and make a separate function to do it for you though:</source>
          <target state="translated">あなたは、あなたのためにそれを行うために別の関数を作成したい場合がありますが、先に行くかもしれません。</target>
        </trans-unit>
        <trans-unit id="1fbe39fdfef0c51e98d97ae9df64c7e3ee2085a2" translate="yes" xml:space="preserve">
          <source>You should use:</source>
          <target state="translated">使った方がいいですよ。</target>
        </trans-unit>
        <trans-unit id="1975acf7e3e1614d24accc2456f01338f73bcf5d" translate="yes" xml:space="preserve">
          <source>for more information, you can have a look at this link</source>
          <target state="translated">詳細については、このリンクを参照してください。</target>
        </trans-unit>
        <trans-unit id="c9736e8b5c06255cf70c5c66cbb121f59efb655d" translate="yes" xml:space="preserve">
          <source>let &lt;em&gt;n&lt;/em&gt;, &lt;em&gt;k&lt;/em&gt;, and &lt;em&gt;s&lt;/em&gt; be integers such that &lt;em&gt;k&lt;/em&gt; &amp;ge; 1, 10&lt;sup&gt;&lt;i&gt;k&lt;/i&gt;-1&lt;/sup&gt; &amp;le; &lt;em&gt;s&lt;/em&gt; &amp;lt; 10&lt;sup&gt;&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt;, the Number value for &lt;em&gt;s&lt;/em&gt; &amp;times; 10&lt;sup&gt;&lt;i&gt;n&lt;/i&gt;-&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt; is &lt;em&gt;m&lt;/em&gt;, and &lt;em&gt;k&lt;/em&gt; is as small as possible. Note that k is the number of digits in the decimal representation of &lt;em&gt;s&lt;/em&gt;, that &lt;em&gt;s&lt;/em&gt; is not divisible by 10, and that the least significant digit of &lt;em&gt;s&lt;/em&gt; is not necessarily uniquely determined by these criteria.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 、 &lt;em&gt;k&lt;/em&gt; 、および&lt;em&gt;sを&lt;/em&gt; 、k&amp;ge;1、10 &lt;em&gt;k&lt;/em&gt; -1&amp;le;s &amp;lt;10 &lt;sup&gt;&lt;i&gt;k&lt;/i&gt;&lt;/sup&gt;の整数とし、 &lt;em&gt;s&lt;/em&gt; &amp;times;10 &lt;sup&gt;&lt;i&gt;n&lt;/i&gt; - &lt;i&gt;k&lt;/i&gt;&lt;/sup&gt; &lt;em&gt;の&lt;/em&gt; Number値は&lt;em&gt;m&lt;/em&gt;であり、 &lt;em&gt;k&lt;/em&gt;はできるだけ小さくします。 kは&lt;em&gt;sの&lt;/em&gt; 10進表記の桁数であり、 &lt;em&gt;s&lt;/em&gt;は10で割り切れないこと、および&lt;em&gt;sの&lt;/em&gt;最下位桁はこれらの基準によって必ずしも一意に決定されるわけではないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="79a55b28f42f64f7f17d4f2f7c30cbe7a2bd50a6" translate="yes" xml:space="preserve">
          <source>then you can just &lt;code&gt;parseFloat&lt;/code&gt; and zeroes will 'go away'.</source>
          <target state="translated">その後、単に &lt;code&gt;parseFloat&lt;/code&gt; を実行すると、ゼロは「消えます」。</target>
        </trans-unit>
        <trans-unit id="d9b4f0c3f620d92bff0c5ce1441899f7830fa702" translate="yes" xml:space="preserve">
          <source>to know the difference between toFixed and round. You can have a look at &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/566564/javascript-functions-math-roundnum-vs-num-tofixed0-and-browser-inconsistenci&quot;&gt;Math.round(num) vs num.toFixed(0) and browser inconsistencies&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">toFixedとroundの違いを知る。 &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/questions/566564/javascript-functions-math-roundnum-vs-num-tofixed0-and-browser-inconsistenci&quot;&gt;Math.round（num）とnum.toFixed（0）とブラウザの不整合を確認でき&lt;/a&gt;&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="88e23d7331fc1070d7d98a821a40134dbbdd7cca" translate="yes" xml:space="preserve">
          <source>toFixed() will also &lt;strong&gt;NOT&lt;/strong&gt; round correctly in some cases (tested in Chrome v.55.0.2883.87)!</source>
          <target state="translated">toFixed（）も正しく丸められない場合があります（Chrome v.55.0.2883.87でテスト済み）。</target>
        </trans-unit>
        <trans-unit id="8a851e1ca9928f5dba505859dc2784363657f289" translate="yes" xml:space="preserve">
          <source>which is closer to 0.01 than to 0.02.</source>
          <target state="translated">の方が0.02よりも0.01に近い。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
