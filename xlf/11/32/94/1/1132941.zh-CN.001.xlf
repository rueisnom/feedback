<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1132941">
    <body>
      <group id="1132941">
        <trans-unit id="b69b153d9b8b6ca5cc39aae8241344dc670096ea" translate="yes" xml:space="preserve">
          <source>&quot;All functions with this problem &lt;strong&gt;suffer also from similar side effect problem on the actual parameter&lt;/strong&gt;,&quot;</source>
          <target state="translated">&amp;ldquo;所有具有此问题的功能&lt;strong&gt;在实际参数上也遭受类似的副作用问题&lt;/strong&gt; ，&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="626c5410f93ad070237bab8024217f1cdd086983" translate="yes" xml:space="preserve">
          <source>... we assign the argument &lt;code&gt;a&lt;/code&gt; to an &lt;em&gt;unnamed&lt;/em&gt; list, if the caller does not pass the value of a.</source>
          <target state="translated">...如果调用者未传递a的值，则将参数 &lt;code&gt;a&lt;/code&gt; 分配给&lt;em&gt;未命名&lt;/em&gt;列表。</target>
        </trans-unit>
        <trans-unit id="d6ae47a54ed3aae922aa9b755c46be05126dc9cc" translate="yes" xml:space="preserve">
          <source>...all variables found outside of the innermost scope are
  read-only (&lt;strong&gt;&lt;em&gt;an attempt to write to such a variable will simply create a
  new local variable in the innermost scope, leaving the identically
  named outer variable unchanged&lt;/em&gt;&lt;/strong&gt;).</source>
          <target state="translated">...在最内层作用域之外找到的所有变量都是只读的（ &lt;strong&gt;&lt;em&gt;尝试写入此类变量只会在最内层作用域内创建一个新的局部变量，而使名称相同的外层变量保持不变&lt;/em&gt;&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ce4a03df48f71c59cb88d1614e04c355fe07eb41" translate="yes" xml:space="preserve">
          <source>1)  The so-called problem of &quot;Mutable Default Argument&quot; is in general a special example demonstrating that:</source>
          <target state="translated">1)所谓的 &quot;Mutable Default Argument &quot;问题,一般来说是一个特殊的例子,证明了:。</target>
        </trans-unit>
        <trans-unit id="7ae49a8787afe33029393476223d3e6b04a350d7" translate="yes" xml:space="preserve">
          <source>3) In some cases is &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;the mutable behavior of default parameters useful&lt;/a&gt;.</source>
          <target state="translated">3）在某些情况下&lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;，默认参数的可变行为很有用&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="349e3dc6e53ca45e7b264f3f4ece59155e2a0d64" translate="yes" xml:space="preserve">
          <source>5 points in defense of Python</source>
          <target state="translated">防守Python的5分</target>
        </trans-unit>
        <trans-unit id="5619d3a6ff41fedee09fe44cfec87d091658e509" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;1</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt;1</target>
        </trans-unit>
        <trans-unit id="f9a7d25963aa0148809943888747c7bfdbad1397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;2</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt;2</target>
        </trans-unit>
        <trans-unit id="f2848d4bf5368cd6cc2a23c96bcb460686851bd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[]&lt;/code&gt; is an object, so is &lt;code&gt;None&lt;/code&gt; (the former is mutable while the latter is immutable. But the mutability has nothing to do with the question). None is somewhere in the space but we know it's there and there is only one copy of None there. So every time foo is invoked, items is evaluated (as opposed to some answer that it is only evaluated once) to be None, to be clear, the reference (or the address) of None. Then in the foo, item is changed to [], i.e., points to another object which has a different address.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; 是一个对象， &lt;code&gt;None&lt;/code&gt; 对象也是如此（前者是可变的，而后者是不可变的。但是可变性与问题无关）。 空间中没有一个地方，但我们知道它在那里，那里只有一个副本。 因此，每次调用foo时，项都会被评估为&amp;ldquo;无&amp;rdquo;（与之相对的回答是，该回答仅被评估一次），显然，该引用（或地址）为&amp;ldquo;无&amp;rdquo;。 然后在foo中，item更改为[]，即指向另一个具有不同地址的对象。</target>
        </trans-unit>
        <trans-unit id="0b51475de74c8a0af3e8ac61016a0b03493b9c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; doesn't change - every assignment call creates new int object - new object is printed</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 不变-每个分配调用都会创建一个新的int对象-打印新对象</target>
        </trans-unit>
        <trans-unit id="c91d4e033dfa8facf99b416bc8eb05efa39a8648" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; doesn't change - new array is build from default value and printed</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 不变-从默认值构建并打印新数组</target>
        </trans-unit>
        <trans-unit id="99868d483227e38115a490908f9eb6410e764c96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; changes - operation is performed on same object - and it is printed</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 更改-对同一对象执行操作-并打印</target>
        </trans-unit>
        <trans-unit id="1dce96d08fb23e6dd9bf8c83e0ce03a0c31931c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Astonished?&lt;/em&gt; The value inside the object changes! Consecutive calls to the function will now simply append to that embedded &lt;code&gt;list&lt;/code&gt; object:</source>
          <target state="translated">&lt;em&gt;吃惊吗&lt;/em&gt; 对象内部的值改变了！ 现在，对该函数的连续调用将简单地追加到该嵌入式 &lt;code&gt;list&lt;/code&gt; 对象：</target>
        </trans-unit>
        <trans-unit id="9a5e006676bccb5e949d65e43cc04bfdb3e0f5c0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This is not a design flaw&lt;/em&gt;. Anyone who trips over this is doing something wrong.</source>
          <target state="translated">&lt;em&gt;这不是设计缺陷&lt;/em&gt; 。 绊倒这个的人做错了什么。</target>
        </trans-unit>
        <trans-unit id="0bb5707416517e01b1b19796f5b4d8047f7be81f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(1)&lt;/strong&gt; is described in the Python &lt;a href=&quot;http://docs.python.org/tutorial/classes.html&quot;&gt;tutorial on classes&lt;/a&gt;. In an attempt to assign a value to a read-only class attribute:</source>
          <target state="translated">&lt;strong&gt;（1）&lt;/strong&gt;在&lt;a href=&quot;http://docs.python.org/tutorial/classes.html&quot;&gt;有关类&lt;/a&gt;的Python 教程中进行了描述。 尝试为只读类属性分配值：</target>
        </trans-unit>
        <trans-unit id="1e830734a74d3ffb326fa9a33d2d932c606c6e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.表现&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1c12447cabd52b525bef97e580f6be054679aad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Forcing bound parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.强制绑定参数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23662664198844161cfe301172c065fd31a550b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Introspection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.内省&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="329d395d793f53ccf44090cd1ed8d91c54ccbc68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Consistency&lt;/strong&gt;: Python &lt;em&gt;always&lt;/em&gt; passes objects, not names.
The default parameter is, obviously, part of the function 
heading (not the function body). It therefore ought to be evaluated
at module load time (and only at module load time, unless nested), not
at function call time.</source>
          <target state="translated">&lt;strong&gt;一致性&lt;/strong&gt; ：Python &lt;em&gt;始终&lt;/em&gt;传递对象，而不传递名称。 显然，默认参数是函数标题的一部分（而不是函数主体）。 因此，应该在模块加载时（并且仅在模块加载时，除非嵌套）进行评估，而不是在函数调用时进行评估。</target>
        </trans-unit>
        <trans-unit id="cf88699ee467bc4d13c8c871f2752ff94d964b35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default parameter values are evaluated from left to right when the function definition is executed.&lt;/strong&gt; This means that the expression is evaluated once, when the function is defined, and that the same &amp;ldquo;pre-computed&amp;rdquo; value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use &lt;code&gt;None&lt;/code&gt; as the default, and explicitly test for it in the body of the function, e.g.:</source>
          <target state="translated">&lt;strong&gt;执行功能定义时，默认参数值从左到右评估。&lt;/strong&gt; 这意味着在定义函数时，表达式将被计算一次，并且每次调用均使用相同的&amp;ldquo;预计算&amp;rdquo;值。 这对于理解默认参数是可变对象（例如列表或字典）时尤其重要：如果函数修改了该对象（例如，通过将项目附加到列表中），则默认值实际上已被修改。 这通常不是预期的。 解决此问题的一种方法是使用 &lt;code&gt;None&lt;/code&gt; 作为默认值，并在函数主体中明确测试它，例如：</target>
        </trans-unit>
        <trans-unit id="539d5ec10b781d448886afa96eab4c325719e096" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Edit&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="d7ce856e37c4d17dcd955af410f64cbfd4b44efb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Meta-learning&lt;/strong&gt;: Falling into the trap is actually a very
helpful moment (at least if you are a reflective learner),
because you will subsequently better understand the point 
&quot;Consistency&quot; above and that will
teach you a great deal about Python.</source>
          <target state="translated">&lt;strong&gt;元学习&lt;/strong&gt; ：陷入陷阱实际上是一个非常有用的时刻（至少如果您是一个反思型学习者），因为您随后将更好地理解上面的&amp;ldquo;一致性&amp;rdquo;这一点，这将教给您很多有关Python的知识。</target>
        </trans-unit>
        <trans-unit id="2c97178ae1f0df97cdd3aaefd09767743c8eb65b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preferred Method&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;首选方法&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="e76f2bbaaca5d9222981a5a9ed9effda9259956d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simplicity&lt;/strong&gt;: The behavior is simple in the following sense:
Most people fall into this trap only once, not several times.</source>
          <target state="translated">&lt;strong&gt;简单性&lt;/strong&gt; ：从以下意义上讲，行为很简单：大多数人只会陷入一次陷阱，而不会几次。</target>
        </trans-unit>
        <trans-unit id="d8e5d785db266e5750b7b9c674b8350975a43b24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution&lt;/strong&gt;:  a &lt;strong&gt;copy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;解决方案&lt;/strong&gt; ： &lt;strong&gt;副本&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37f9748bcb10eff54719d247d7d6981eb44d0507" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sufficient documentation&lt;/strong&gt;: In the most basic Python documentation,
the tutorial, the issue is loudly announced as
an &lt;strong&gt;&quot;Important warning&quot;&lt;/strong&gt; in the &lt;em&gt;first&lt;/em&gt; subsection of Section
&lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#default-argument-values&quot;&gt;&quot;More on Defining Functions&quot;&lt;/a&gt;.
The warning even uses boldface,
which is rarely applied outside of headings.
RTFM: Read the fine manual.</source>
          <target state="translated">&lt;strong&gt;足够的文档&lt;/strong&gt; ：在最基本的Python文档中，该教程在&lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#default-argument-values&quot;&gt;&amp;ldquo;更多关于定义函数&amp;rdquo;&lt;/a&gt;部分的&lt;em&gt;第一&lt;/em&gt;小节中以&lt;strong&gt;&amp;ldquo;重要警告&amp;rdquo;的&lt;/strong&gt;形式大声宣布该问题。 警告甚至使用黑体字，很少在标题之外使用。 RTFM：阅读精美的手册。</target>
        </trans-unit>
        <trans-unit id="5e1364752e34f5d31f57fbb793918340fe194bee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usefulness&lt;/strong&gt;: As Frederik Lundh points out in his explanation
of &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;&quot;Default Parameter Values in Python&quot;&lt;/a&gt;, the
current behavior can be quite useful for advanced programming.
(Use sparingly.)</source>
          <target state="translated">&lt;strong&gt;用途&lt;/strong&gt; ：正如Frederik Lundh在他对&lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;&amp;ldquo; Python中的默认参数值&amp;rdquo;的&lt;/a&gt;解释中指出的那样，当前行为对于高级编程可能非常有用。 （请谨慎使用。）</target>
        </trans-unit>
        <trans-unit id="294df7a72d2c1681571db14e9616ce4b1526495e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Wrong Method (probably...)&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;错误的方法（可能是...）&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="82a5f8350abc0dbeea17f36fef8010fcc85d54f4" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;*&lt;/sup&gt; To verify that Python evaluates the default arguments during compilation of the function, try executing the following:</source>
          <target state="translated">&lt;sup&gt;*&lt;/sup&gt;要在函数编译期间验证Python是否评估默认参数，请尝试执行以下命令：</target>
        </trans-unit>
        <trans-unit id="bb413fc5e883d792d1ef3763d765a7965fb2896f" translate="yes" xml:space="preserve">
          <source>====== No. 2 ========</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69abcbfba6763da9ac43abb483ce88455e698517" translate="yes" xml:space="preserve">
          <source>====== No. 3 =======</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b635b4f551391b730421190ef18f36b5a2349cd2" translate="yes" xml:space="preserve">
          <source>A brief introduction. First, there are two type of data types in python, one is simple elementary data type, like numbers, and another data type is objects. Second, when passing data to parameters, python pass elementary data type by value, i.e., make a local copy of the value to a local variable, but pass object by reference, i.e., pointers to the object.</source>
          <target state="translated">简单介绍一下。首先,Python中的数据类型有两种,一种是简单的基本数据类型,如数字,另一种数据类型是对象。第二,在向参数传递数据时,python通过值传递基本数据类型,即通过值传递基本数据类型,也就是把值拷贝到本地变量中,但通过引用传递对象,也就是指向对象的指针。</target>
        </trans-unit>
        <trans-unit id="3241c6873d2d65a534f9b317f8e6387aba7f1c09" translate="yes" xml:space="preserve">
          <source>A manager of mine once had his first encounter with this feature, and called it &quot;a dramatic design flaw&quot; of the language. I replied that the behavior had an underlying explanation, and it is indeed very puzzling and unexpected if you don't understand the internals. However, I was not able to answer (to myself) the following question: what is the reason for binding the default argument at function definition, and not at function execution? I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs?)</source>
          <target state="translated">我的一位经理曾有过第一次接触到这个功能,他说这是语言的 &quot;戏剧性的设计缺陷&quot;。我回答说,这个行为有其背后的解释,如果不懂内涵的话,确实很让人费解和意外。然而,我却无法回答(对自己)以下问题:在函数定义时绑定默认参数,而不是在函数执行时绑定默认参数的原因是什么?我怀疑这种经验行为是否有实际用途(在C语言中,谁真的会在C语言中使用静态变量,不滋生BUG呢?</target>
        </trans-unit>
        <trans-unit id="b690fd135a267cbcdaf75de80b96af3baa5767c7" translate="yes" xml:space="preserve">
          <source>A simple workaround using None</source>
          <target state="translated">一个简单的变通方法,使用None</target>
        </trans-unit>
        <trans-unit id="bdd7db67e420ecc9dcbd543e9f887304309b4542" translate="yes" xml:space="preserve">
          <source>A useful trick is to bind parameters of a lambda to the &lt;em&gt;current&lt;/em&gt; binding of a variable when the lambda is created.  For example:</source>
          <target state="translated">一个有用的技巧是在创建lambda时将lambda的参数绑定到变量的&lt;em&gt;当前&lt;/em&gt;绑定。 例如：</target>
        </trans-unit>
        <trans-unit id="66dcf0d939788f48ade0f8205215ced808c313bc" translate="yes" xml:space="preserve">
          <source>Actually, this is not a design flaw, and it is not because of internals, or performance.</source>
          <target state="translated">其实,这不是设计上的缺陷,也不是因为内饰,或者说是性能上的缺陷。</target>
        </trans-unit>
        <trans-unit id="995d1d076d3d58278102dc33655d7de6f9e9da69" translate="yes" xml:space="preserve">
          <source>Admitting the above two points, let's explain what happened to the python code. It's only because of passing by reference for objects, but has nothing to do with mutable/immutable, or arguably the fact that &quot;def&quot; statement is executed only once when it is defined.</source>
          <target state="translated">承认了以上两点,我们来解释一下python代码中出现的问题。这只是因为对象的引用传递,但与mutableimmutable无关,也可以说,&quot;def &quot;语句在定义时只执行一次。</target>
        </trans-unit>
        <trans-unit id="12e60dab7722d48c3d6b49bcd3fb84f98b18afcc" translate="yes" xml:space="preserve">
          <source>After Python executes this definition it will take any default parameters specified (&lt;code&gt;a = []&lt;/code&gt; here) and &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy&quot;&gt;cram them in the &lt;code&gt;__defaults__&lt;/code&gt; attribute for the function object&lt;/a&gt; (relevant section: Callables):</source>
          <target state="translated">Python执行此定义后，它将接受指定的任何默认参数（此处为 &lt;code&gt;a = []&lt;/code&gt; ）， &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy&quot;&gt;并将其 &lt;code&gt;__defaults__&lt;/code&gt; 函数对象的__defaults__属性中&lt;/a&gt; （相关部分：Callables）：</target>
        </trans-unit>
        <trans-unit id="00ee3bf105e662d4c817e2a1dc2ea4cb63f26aa2" translate="yes" xml:space="preserve">
          <source>All with the power of introspection!</source>
          <target state="translated">一切以反省的力量为前提!</target>
        </trans-unit>
        <trans-unit id="8511aa6f9e2aee5234b37fe72ed01ccf13a1f8e1" translate="yes" xml:space="preserve">
          <source>Already busy topic, but from what I read here, the following helped me realizing how it's working internally:</source>
          <target state="translated">已经很忙的话题,但从我在这里读到的内容来看,下面的内容帮助我意识到了内部的运作方式。</target>
        </trans-unit>
        <trans-unit id="edef5af058c46851da7320ae99d9fe37689e0b06" translate="yes" xml:space="preserve">
          <source>An absolutely safe solution is to &lt;strong&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;code&gt;deepcopy&lt;/code&gt;&lt;/strong&gt; the input object first and then to do whatever with the copy.</source>
          <target state="translated">绝对安全的解决方案是先&lt;strong&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/strong&gt;或&lt;strong&gt; &lt;code&gt;deepcopy&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;复制&lt;/strong&gt;输入对象，然后再执行复制操作。</target>
        </trans-unit>
        <trans-unit id="09883d93fd6b6978404b7d03e6adc34d60b2d91d" translate="yes" xml:space="preserve">
          <source>Anyone tinkering with Python long enough has been bitten (or torn to pieces) by the following issue:</source>
          <target state="translated">任何修炼Python足够久的人都会被下面的问题咬住(或撕碎)。</target>
        </trans-unit>
        <trans-unit id="7870ab2e57db73f3c412a09b43f15db1bdd86aa3" translate="yes" xml:space="preserve">
          <source>As others have extensively commented, the list parameter is bound to the function when it is defined as opposed to when it is executed.  Because lists and dictionaries are mutable, any alteration to this parameter will affect other calls to this function.  As a result, subsequent calls to the function will receive this shared list which may have been altered by any other calls to the function.  Worse yet, two parameters are using this function's shared parameter at the same time oblivious to the changes made by the other.</source>
          <target state="translated">正如其他人的广泛评论,list参数在定义函数的时候和执行函数的时候是绑定在一起的。因为列表和字典是可以变异的,对这个参数的任何修改都会影响到其他对这个函数的调用。因此,后续对该函数的调用将接收到这个共享的列表,而这个共享的列表可能已经被其他函数的任何调用改变了。更糟糕的是,两个参数同时使用这个函数的共享参数,而忽略了另一个参数所做的修改。</target>
        </trans-unit>
        <trans-unit id="32ec561bfb975a7dfa873e1e6e2af0f1d887859e" translate="yes" xml:space="preserve">
          <source>As soon as you get to think into this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of &quot;member data&quot; and therefore their state may change from one call to the other - exactly as in any other object.</source>
          <target state="translated">只要你能这样想,那么它就完全有意义了:一个函数就是一个被评价的对象;默认参数是一种 &quot;成员数据&quot;,因此它们的状态可能从一个调用到另一个调用都会发生变化--就像其他对象一样。</target>
        </trans-unit>
        <trans-unit id="1bfc5029b5667353a593e8232b61d516f6f5fa28" translate="yes" xml:space="preserve">
          <source>As the &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;tutorial section on control flow&lt;/a&gt; says:</source>
          <target state="translated">正如&lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;关于控制流&lt;/a&gt;的教程部分所述 ：</target>
        </trans-unit>
        <trans-unit id="8b63ee9af6651f22cd0d28d64f81656efa3a8b0b" translate="yes" xml:space="preserve">
          <source>As you can see, there &lt;em&gt;is&lt;/em&gt; a performance benefit when using immutable default arguments.  This can make a difference if it's a frequently called function or the default argument takes a long time to construct.  Also, bear in mind that Python isn't C.  In C you have constants that are pretty much free.  In Python you don't have this benefit.</source>
          <target state="translated">如您所见，使用不可变的默认参数可以提高性能。 如果这是一个经常调用的函数，或者默认参数需要花费很长时间来构造，则可能会有所不同。 另外，请记住，Python不是C。在C中，您拥有几乎免费的常量。 在Python中，您没有此好处。</target>
        </trans-unit>
        <trans-unit id="0af2a822a9873fb57c1a705017e412da7cf6eae6" translate="yes" xml:space="preserve">
          <source>At any time, if the caller doesn't tell us what &lt;code&gt;a&lt;/code&gt; is, we reuse &lt;code&gt;pavlo&lt;/code&gt;.</source>
          <target state="translated">在任何时候，如果呼叫者不告诉我们 &lt;code&gt;a&lt;/code&gt; 是什么，我们将重用 &lt;code&gt;pavlo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8a9041c4d4930adfbd1e5a18d381ab82f682a692" translate="yes" xml:space="preserve">
          <source>Baczek made an interesting example. Together with most of your comments and Utaal's in particular, I elaborated further:</source>
          <target state="translated">Baczek举了一个有趣的例子。结合你的大部分意见,特别是乌塔尔的意见,我进一步阐述了一下。</target>
        </trans-unit>
        <trans-unit id="80f28b6534c5364d872c03c837c8604f92ca736d" translate="yes" xml:space="preserve">
          <source>But this is why the usual instruction to new users is to create their default arguments like this instead:</source>
          <target state="translated">但这也是为什么通常给新用户的指令是这样创建他们的默认参数,而不是这样。</target>
        </trans-unit>
        <trans-unit id="ec8e7d1b53f4a45c292a101f3cc7d8154605e8fd" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;foo()&lt;/code&gt; again modifies &lt;code&gt;pavlo&lt;/code&gt; again:</source>
          <target state="translated">再次调用 &lt;code&gt;foo()&lt;/code&gt; 会再次修改 &lt;code&gt;pavlo&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7f12be39dc6279d3fabca7bbf354112e20d8c45e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;foo&lt;/code&gt; without overriding a default uses that default's value from &lt;code&gt;foo.func_defs&lt;/code&gt;. In this case, &lt;code&gt;foo.func_defs[0]&lt;/code&gt; is used for &lt;code&gt;a&lt;/code&gt; within function object's code scope. Changes to &lt;code&gt;a&lt;/code&gt; change &lt;code&gt;foo.func_defs[0]&lt;/code&gt;, which is part of the &lt;code&gt;foo&lt;/code&gt; object and persists between execution of the code in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">在不覆盖默认值的情况下调用 &lt;code&gt;foo&lt;/code&gt; 会使用 &lt;code&gt;foo.func_defs&lt;/code&gt; 中的默认值。 在这种情况下， &lt;code&gt;foo.func_defs[0]&lt;/code&gt; 用于内部函数对象的代码范围。 更改为更改 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; ，它是 &lt;code&gt;foo&lt;/code&gt; 对象的一部分，在foo中执行代码之间一直存在。</target>
        </trans-unit>
        <trans-unit id="2bbb1f97b956cffee0de7b85c6ac5416fc49a2bd" translate="yes" xml:space="preserve">
          <source>Compare this:</source>
          <target state="translated">对比一下。</target>
        </trans-unit>
        <trans-unit id="d0b35f2e80cf4078de3821051d01800d2a02ba30" translate="yes" xml:space="preserve">
          <source>Conclusion:</source>
          <target state="translated">Conclusion:</target>
        </trans-unit>
        <trans-unit id="89101438b832bbb4fe2957ecf228b15803627679" translate="yes" xml:space="preserve">
          <source>Consider the code:</source>
          <target state="translated">考虑一下代码。</target>
        </trans-unit>
        <trans-unit id="50ce20ee2ced0781e4776bbf85a113d06f364543" translate="yes" xml:space="preserve">
          <source>Consistency already says &quot;at definition&quot;: everything else of &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; is best evaluated at definition as well. Delaying parts of it would be the astonishing choice.</source>
          <target state="translated">一致性已经说过&amp;ldquo;在定义时&amp;rdquo;： &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; 的其他所有内容也最好在定义时进行评估。 延迟其中的一部分将是令人惊讶的选择。</target>
        </trans-unit>
        <trans-unit id="5e80e76fecb25c751bc0072a050074d6bf8b3a02" translate="yes" xml:space="preserve">
          <source>Default arguments get evaluated at the time the function is compiled into a function object. When used by the function, multiple times by that function, they are and remain the same object.</source>
          <target state="translated">默认参数在函数被编译成函数对象的时候就会被评估。当被函数使用时,被该函数多次使用时,它们是并保持相同的对象。</target>
        </trans-unit>
        <trans-unit id="0a13adb02282a5b13ea712ef898af3b40b3c9925" translate="yes" xml:space="preserve">
          <source>Defining a function affects two scopes: the defining scope &lt;em&gt;containing&lt;/em&gt; the function, and the execution  scope &lt;em&gt;contained by&lt;/em&gt; the function. While it is pretty clear how blocks map to scopes, the question is where &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; belongs to:</source>
          <target state="translated">定义函数会影响两个范围： &lt;em&gt;包含&lt;/em&gt;函数的定义范围和函数&lt;em&gt;包含&lt;/em&gt;的执行范围。 尽管很清楚块是如​​何映射到作用域的，但问题是 &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; 属于哪里：</target>
        </trans-unit>
        <trans-unit id="722360c4795e6584aab950e4f9ab28bf53d453fe" translate="yes" xml:space="preserve">
          <source>Demonstration</source>
          <target state="translated">Demonstration</target>
        </trans-unit>
        <trans-unit id="0cf2dad6fd4f2a353fd61dd22952442419c00063" translate="yes" xml:space="preserve">
          <source>Does this violate the principle of &quot;Least Astonishment&quot;?</source>
          <target state="translated">这是否违反了 &quot;最低限度的惊吓 &quot;原则?</target>
        </trans-unit>
        <trans-unit id="87ae29dc1cc2a0f0b1d8ff4a04b54a9e84f78784" translate="yes" xml:space="preserve">
          <source>Doing the binding inside the function would mean that &lt;code&gt;x&lt;/code&gt; is effectively bound to the specified default when the function is called, not defined, something that would present a deep flaw: the &lt;code&gt;def&lt;/code&gt; line would be &quot;hybrid&quot; in the sense that part of the binding (of the function object) would happen at definition, and part (assignment of default parameters) at function invocation time.</source>
          <target state="translated">在函数内部进行绑定将意味着在调用而不是定义函数时， &lt;code&gt;x&lt;/code&gt; 已有效绑定到指定的默认值，这会带来严重的缺陷： &lt;code&gt;def&lt;/code&gt; 行在绑定的一部分意义上是&amp;ldquo;混合的&amp;rdquo; （函数对象的）将在定义时发生，一部分（默认参数的分配）将在函数调用时发生。</target>
        </trans-unit>
        <trans-unit id="a1bc1de19c4470f909f862dada03b7e62dff2905" translate="yes" xml:space="preserve">
          <source>Each button can hold a distinct callback function which will display different value of &lt;code&gt;i&lt;/code&gt;. I can provide an example to show this:</source>
          <target state="translated">每个按钮可以包含一个不同的回调函数，该函数将显示不同的 &lt;code&gt;i&lt;/code&gt; 值。 我可以提供一个例子来说明这一点：</target>
        </trans-unit>
        <trans-unit id="3535364419d36fc620e4f5493d86ed8c6d64572c" translate="yes" xml:space="preserve">
          <source>Equivalent code:</source>
          <target state="translated">代码等价物。</target>
        </trans-unit>
        <trans-unit id="ff956d2a192938cf9d92d4c6a19f3ae8b72325fa" translate="yes" xml:space="preserve">
          <source>Every other answer explains why this is actually a nice and desired behavior, or why you shouldn't be needing this anyway. Mine is for those stubborn ones who want to exercise their right to bend the language to their will, not the other way around.</source>
          <target state="translated">每一个其他的答案都会解释为什么这其实是一种很好的、很想要的行为,或者说为什么你无论如何都不应该需要这个。我的答案是给那些固执的人,他们想行使自己的权利,让语言服从自己的意愿,而不是反过来。</target>
        </trans-unit>
        <trans-unit id="0dd24b3cfa0f1397c657fd1c280dfe16bb9e3f42" translate="yes" xml:space="preserve">
          <source>Example problem for &lt;a href=&quot;https://stackoverflow.com/q/13484107/448474&quot;&gt;a similar SO question&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/13484107/448474&quot;&gt;类似的SO问题的&lt;/a&gt;示例问题</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="bb7c7223c0f7cca03529ae9f865e01923e18d2e1" translate="yes" xml:space="preserve">
          <source>From the above explanations, we can see that the &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;effbot&lt;/a&gt; webpage recommended in the accepted answer failed to give a relevant answer to this question. What is more, I think a point in the effbot webpage is wrong. I think the code regarding the UI.Button is correct:</source>
          <target state="translated">从以上解释中，我们可以看到，在接受的答案中推荐的&lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;effbot&lt;/a&gt;网页未能对此问题提供相关的答案。 而且，我认为effbot网页中的一点是错误的。 我认为有关UI.Button的代码是正确的：</target>
        </trans-unit>
        <trans-unit id="ffce6790c5edcbed68ecf56b4ebcce15bf2962a7" translate="yes" xml:space="preserve">
          <source>Function After Execution:</source>
          <target state="translated">执行后的功能。</target>
        </trans-unit>
        <trans-unit id="c6a884852d8c2a2883d38ae384496603d3a89ca1" translate="yes" xml:space="preserve">
          <source>Function Before Execution:</source>
          <target state="translated">执行前的功能。</target>
        </trans-unit>
        <trans-unit id="31a489ea01d856da46704976b42a3727c3bf5489" translate="yes" xml:space="preserve">
          <source>Functions are objects (explained well in the accepted answer).</source>
          <target state="translated">功能是对象(在接受的答案中解释得很好)。</target>
        </trans-unit>
        <trans-unit id="33152c3a458131f199d601848f2ff938e88b23ff" translate="yes" xml:space="preserve">
          <source>Given a simple little function &lt;code&gt;func&lt;/code&gt; defined as:</source>
          <target state="translated">给定一个简单的小函数 &lt;code&gt;func&lt;/code&gt; ,定义为：</target>
        </trans-unit>
        <trans-unit id="dc7ed69775b531605c40861499142c0c9436b2e1" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;foo&lt;/code&gt; is an object and &lt;code&gt;a&lt;/code&gt; is an attribute of &lt;code&gt;foo&lt;/code&gt; (available at &lt;code&gt;foo.func_defs[0]&lt;/code&gt;). Since &lt;code&gt;a&lt;/code&gt; is a list, &lt;code&gt;a&lt;/code&gt; is mutable and is thus a read-write attribute of &lt;code&gt;foo&lt;/code&gt;. It is initialized to the empty list as specified by the signature when the function is instantiated, and is available for reading and writing as long as the function object exists.</source>
          <target state="translated">此处 &lt;code&gt;foo&lt;/code&gt; 是对象， &lt;code&gt;a&lt;/code&gt; 是 &lt;code&gt;foo&lt;/code&gt; 的属性（可从 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; ）。 因为 &lt;code&gt;a&lt;/code&gt; 是一个列表，所以 &lt;code&gt;a&lt;/code&gt; 是可变的，因此是 &lt;code&gt;foo&lt;/code&gt; 的可读写属性。 实例化函数时，它将初始化为签名指定的空列表，并且只要函数对象存在，就可以进行读取和写入。</target>
        </trans-unit>
        <trans-unit id="a60b329ec4b9d85ee4941270916f4f4532974b74" translate="yes" xml:space="preserve">
          <source>Here's a demonstration - you can verify that they are the same object each time they are referenced by</source>
          <target state="translated">这里有一个示范----你可以验证它们每次被引用时都是同一个对象。</target>
        </trans-unit>
        <trans-unit id="6fd4504fd06148ba79eed7136bc3c11e43b9b3ff" translate="yes" xml:space="preserve">
          <source>Hopefully it's enough to show that not executing the default argument expressions at the execution time of the &lt;code&gt;def&lt;/code&gt; statement isn't easy or doesn't make sense, or both.</source>
          <target state="translated">希望足以表明在 &lt;code&gt;def&lt;/code&gt; 语句的执行时间不执行默认参数表达式不是一件容易的事，或者没有道理，或者两者兼而有之。</target>
        </trans-unit>
        <trans-unit id="efcda094ecf8e11cea988762da8f1af71d231058" translate="yes" xml:space="preserve">
          <source>However, supposed later on in the code, I do something like</source>
          <target state="translated">然而,在代码的后面,我应该是这样做的</target>
        </trans-unit>
        <trans-unit id="b3f69934c5bc363d742e1cab32463a9509580910" translate="yes" xml:space="preserve">
          <source>However, we've lost the ability to introspect, and see what the default arguments &lt;em&gt;are&lt;/em&gt;.  Because the objects haven't been constructed, we can't ever get hold of them without actually calling the function.  The best we could do is to store off the source code and return that as a string.</source>
          <target state="translated">但是，我们失去了自省的能力，无法看到默认参数&lt;em&gt;是&lt;/em&gt; 。 因为尚未构造对象，所以如果不实际调用该函数，我们将无法拥有它们。 我们最好的办法是存储源代码，并将其作为字符串返回。</target>
        </trans-unit>
        <trans-unit id="62218df64348dca379d0be7d12cf753886ac8753" translate="yes" xml:space="preserve">
          <source>I agree it's a gotcha when you try to use default constructors, though.</source>
          <target state="translated">我同意当你尝试使用默认的构造函数时,这是个麻烦事。</target>
        </trans-unit>
        <trans-unit id="666a646463dc2675694b853c3a8d9d31ebba0462" translate="yes" xml:space="preserve">
          <source>I am going to demonstrate an alternative structure to pass a default list value to a function (it works equally well with dictionaries).</source>
          <target state="translated">我将演示一个替代结构,将一个默认的列表值传递给一个函数(这在字典中同样适用)。</target>
        </trans-unit>
        <trans-unit id="79228cdbb3c7bc21ef5719f719a1a0dd6dfbf36b" translate="yes" xml:space="preserve">
          <source>I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs ?)</source>
          <target state="translated">我怀疑经验行为是否有实际用途(谁真的在C语言中使用了静态变量,没有滋生BUG?</target>
        </trans-unit>
        <trans-unit id="43c16dd324ef24fec2c80514d01a8fbc2f28b9ba" translate="yes" xml:space="preserve">
          <source>I found it very clear, and I really suggest reading it for a better knowledge of how function objects work.</source>
          <target state="translated">我觉得很清楚,真的建议大家读一读,对功能对象的工作原理有更多的了解。</target>
        </trans-unit>
        <trans-unit id="e438a0bb860a536fec364c3e57d8144f3738861a" translate="yes" xml:space="preserve">
          <source>I know nothing about the Python interpreter inner workings (and I'm not an expert in compilers and interpreters either) so don't blame me if I propose anything unsensible or impossible.</source>
          <target state="translated">我对Python解释器的内部工作原理一无所知 (我也不是编译器和解释器方面的专家),所以如果我提出了什么不可能或不可能的东西,请不要怪我。</target>
        </trans-unit>
        <trans-unit id="71d7286361ceb622e718e696e33275d64365bcc6" translate="yes" xml:space="preserve">
          <source>I know, I know: that's a closure. Alternatively Python might provide a keyword to force definition-time binding:</source>
          <target state="translated">我知道,我知道:那是一个封闭。另外,Python可能会提供一个关键字来强制定义时间绑定。</target>
        </trans-unit>
        <trans-unit id="33854cd2f920283abdfe15942535e15a55a4bbc1" translate="yes" xml:space="preserve">
          <source>I personally like Python's current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible.</source>
          <target state="translated">我个人很喜欢Python目前的做法:当函数定义好后,默认的函数参数就会被评估,而那个对象永远是默认的。我想他们可以使用空列表进行特殊封装,但这种特殊封装会引起更多的惊奇,更不用说向后不兼容了。</target>
        </trans-unit>
        <trans-unit id="653d0fdb648a0e875a98321cd116616aaa059e3d" translate="yes" xml:space="preserve">
          <source>I sometimes exploit this behavior as an alternative to the following pattern:</source>
          <target state="translated">我有时会利用这种行为来替代下面的模式。</target>
        </trans-unit>
        <trans-unit id="1136692ed919e61fb64464e3c7faa84bec1902d1" translate="yes" xml:space="preserve">
          <source>I think the answer to this question lies in how python pass data to parameter (pass by value or by reference), not mutability or how python handle the &quot;def&quot; statement.</source>
          <target state="translated">我认为这个问题的答案在于Python如何将数据传递给参数(通过值传递或引用),而不是突变性或Python如何处理 &quot;def &quot;语句。</target>
        </trans-unit>
        <trans-unit id="344b69c74ad5e09938fa343f9bd784e609ba3f79" translate="yes" xml:space="preserve">
          <source>I used to think that creating the objects at runtime would be the better approach.  I'm less certain now, since you do lose some useful features, though it may be worth it regardless simply to prevent newbie confusion.  The disadvantages of doing so are:</source>
          <target state="translated">我曾经认为在运行时创建对象是比较好的方法。现在我不太确定了,因为你确实失去了一些有用的功能,尽管这样做可能是值得的,只是为了防止新手混淆。这样做的缺点是。</target>
        </trans-unit>
        <trans-unit id="f45c52b12ce7f1ce19a9035ae4c48dd9daa005c0" translate="yes" xml:space="preserve">
          <source>I'll give you a hint.  Here's the disassembly (see &lt;a href=&quot;http://docs.python.org/library/dis.html&quot;&gt;http://docs.python.org/library/dis.html&lt;/a&gt;):</source>
          <target state="translated">我会给你一个提示。 这是反汇编（请参阅&lt;a href=&quot;http://docs.python.org/library/dis.html&quot;&gt;http://docs.python.org/library/dis.html&lt;/a&gt; ）：</target>
        </trans-unit>
        <trans-unit id="63b9797c54d1f5b22108348202db1c0d9f27b5eb" translate="yes" xml:space="preserve">
          <source>I'm &lt;em&gt;really&lt;/em&gt; surprised no one has performed the insightful introspection offered by Python (&lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; apply) on callables.</source>
          <target state="translated">我真的&lt;em&gt;很&lt;/em&gt;惊讶，没有人对可调用对象执行Python提供的深刻的自省（适用 &lt;code&gt;2&lt;/code&gt; 和 &lt;code&gt;3&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="d560ac161f04d984906ccae5894dd8e5c74ba7d6" translate="yes" xml:space="preserve">
          <source>I'm gonna give you what I see as a useful example.</source>
          <target state="translated">我给大家举个我认为有用的例子。</target>
        </trans-unit>
        <trans-unit id="0ab4a274949e60b1dc8d810f1b8b6f0326e083c2" translate="yes" xml:space="preserve">
          <source>I've used this for instantiating client classes that access external resources, and also for creating dicts or lists for memoization.</source>
          <target state="translated">我用它来实例化访问外部资源的客户端类,也用它来创建dicts或列表来备忘。</target>
        </trans-unit>
        <trans-unit id="d4a17f0810bff8f4684352651e72c003f9d91265" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pavlo&lt;/code&gt; is mutable (modifiable), and &lt;code&gt;foo&lt;/code&gt; ends up modifying it, an effect we notice the next time &lt;code&gt;foo&lt;/code&gt; is called without specifying &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;pavlo&lt;/code&gt; 是可变的（可修改的），而 &lt;code&gt;foo&lt;/code&gt; 最终对其进行了修改，则我们注意到下一次调用 &lt;code&gt;foo&lt;/code&gt; 时没有指定 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2fde0c1e8b0aff298d01bf5aa7a719c471660837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;singleton&lt;/code&gt; is only used by &lt;code&gt;use_singleton&lt;/code&gt;, I like the following pattern as a replacement:</source>
          <target state="translated">如果 &lt;code&gt;singleton&lt;/code&gt; 仅由 &lt;code&gt;use_singleton&lt;/code&gt; 使用 ，则我喜欢以下模式作为替换：</target>
        </trans-unit>
        <trans-unit id="12b09ce5fbf5f05e7151c2f7f01217b353055234" translate="yes" xml:space="preserve">
          <source>If call-time evaluation is used, then the expensive function is called every time your function is used without an argument.  You'd either pay an expensive price on each call, or need to manually cache the value externally, polluting your namespace and adding verbosity.</source>
          <target state="translated">如果使用调用时评估,那么每次你的函数在没有参数的情况下都要调用昂贵的函数。你要么每次调用都要付出昂贵的代价,要么就需要手动缓存外部的值,污染你的命名空间,增加动词性。</target>
        </trans-unit>
        <trans-unit id="07abc281d43c1a8d21b4d3e16a4f89b6450862f6" translate="yes" xml:space="preserve">
          <source>If we execute &lt;code&gt;x[7]()&lt;/code&gt; we'll get 7 as expected, and &lt;code&gt;x[9]()&lt;/code&gt; will gives 9, another value of &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">如果执行 &lt;code&gt;x[7]()&lt;/code&gt; 我们将得到7的期望值，而 &lt;code&gt;x[9]()&lt;/code&gt; 将得到9的另一个值 &lt;code&gt;i&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5e5d0faf4767c71322e96d58c89f44e2f7d7004b" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want the default to be shared between subsequent calls,
  you can write the function like this instead:</source>
          <target state="translated">如果您不希望在后续调用之间共享默认值，则可以这样编写函数：</target>
        </trans-unit>
        <trans-unit id="a78835080b9cc304e7940760ebe5a74f9feb7089" translate="yes" xml:space="preserve">
          <source>If you need to destructively manipulate a local temporary in the course of computing something, and you need to start your manipulation from an argument value, you need to make a copy.</source>
          <target state="translated">如果你在计算东西的过程中需要破坏性地操纵一个本地临时性的东西,而你需要从一个参数值开始操纵,你需要做一个拷贝。</target>
        </trans-unit>
        <trans-unit id="ffce4f7ff1a5649ba9873493748437dec4a51845" translate="yes" xml:space="preserve">
          <source>In any case, Effbot has a very nice explanation of the reasons for this behavior in &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;Default Parameter Values in Python&lt;/a&gt;.</source>
          <target state="translated">无论如何，Effbot &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;在Python的Default Parameter Values中都&lt;/a&gt;很好地解释了这种现象的原因。</target>
        </trans-unit>
        <trans-unit id="bbd472fc6429abfdafc9add5359fa997a6a79049" translate="yes" xml:space="preserve">
          <source>In other words, instead of evaluating default parameters, why not store each of them, and evaluate them when the function is called?</source>
          <target state="translated">换句话说,为什么不对默认参数进行评估,而是逐一存储,并在函数调用时对其进行评估呢?</target>
        </trans-unit>
        <trans-unit id="44af44eea85fed48a31ed0183c38ed921ac1aabb" translate="yes" xml:space="preserve">
          <source>Input parameters objects shouldn't be modified in place (mutated) nor they should not be binded into an object returned by the function. (If we prefere programming without side effects which is strongly recommended. see &lt;a href=&quot;http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;Wiki about &quot;side effect&quot;&lt;/a&gt; (The first two paragraphs are relevent in this context.)
.)</source>
          <target state="translated">输入参数对象不应就地修改（突变），也不应将其绑定到函数返回的对象中。 （如果强烈希望我们建议不产生副作用的编程，请参阅&lt;a href=&quot;http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;Wiki有关&amp;ldquo;副作用&amp;rdquo;的信息&lt;/a&gt; （在此上下文中，前两段是相关内容）。）</target>
        </trans-unit>
        <trans-unit id="f428f84105fcce031afe75598a91587f547827e4" translate="yes" xml:space="preserve">
          <source>It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.</source>
          <target state="translated">这仅仅来自于Python中的函数是一流的对象,而不仅仅是一段代码。</target>
        </trans-unit>
        <trans-unit id="8d35c5155e3a7198376d876ba2ac22709cf724ee" translate="yes" xml:space="preserve">
          <source>It is a confusing feature and it is unfortunate in Python.</source>
          <target state="translated">这是个令人困惑的功能,在Python中是很不幸的。</target>
        </trans-unit>
        <trans-unit id="2d1e31d0ad97904bac773140d97936823786bfd4" translate="yes" xml:space="preserve">
          <source>It may be true that switching horses in midstream here would be asking for significant breakage, and that there could be more problems created by changing Python to intuitively handle Stefano's opening snippet. And it may be true that someone who knew Python internals well could explain a minefield of consequences. &lt;em&gt;However,&lt;/em&gt;</source>
          <target state="translated">的确，在此处中途更换马匹可能会造成重大损坏，并且通过更改Python以直观地处理Stefano的开头代码段可能会产生更多问题。 也许确实很了解Python内部知识的人可以解释后果的雷区。 &lt;em&gt;然而，&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f7b0650553f1d03b5617ea73a2e594063dbeff1b" translate="yes" xml:space="preserve">
          <source>It may be true that:</source>
          <target state="translated">可能是这样的:</target>
        </trans-unit>
        <trans-unit id="c88ae6b372096f323f1ae38ef63c959269132a80" translate="yes" xml:space="preserve">
          <source>It shouldn't be neither saved in any &lt;em&gt;public&lt;/em&gt; attribute of an instance returned by this function. (Assuming that &lt;em&gt;private&lt;/em&gt; attributes of instance should not be modified from outside of this class or subclasses by convention. i.e. &lt;code&gt;_var1&lt;/code&gt; is a private attribute )</source>
          <target state="translated">不应将其保存在此函数返回的实例的任何&lt;em&gt;公共&lt;/em&gt;属性中。 （假设实例的&lt;em&gt;私有&lt;/em&gt;属性不应按照惯例从此类或子类的外部进行修改。即 &lt;code&gt;_var1&lt;/code&gt; 是私有属性）</target>
        </trans-unit>
        <trans-unit id="a1d3a576ba48952d86d8cfdfe398ef2bddea704e" translate="yes" xml:space="preserve">
          <source>It's a performance optimization.  As a result of this functionality, which of these two function calls do you think is faster?</source>
          <target state="translated">这是一个性能优化。作为这个功能的结果,你觉得这两个函数调用哪个更快?</target>
        </trans-unit>
        <trans-unit id="0359bac5a1c47bf095f12d4add2a3b1b5b445f4a" translate="yes" xml:space="preserve">
          <source>It's important to note that the above solution breaks if you try to use keyword args, like so:</source>
          <target state="translated">值得注意的是,如果你尝试使用关键字args,比如这样,上面的解决方案就会崩溃。</target>
        </trans-unit>
        <trans-unit id="b6c89d685ac19d7565519a44bbc4a6d593564a24" translate="yes" xml:space="preserve">
          <source>It's just &quot;How It Works&quot;, and making it work differently in the function case would probably be complicated, and in the class case likely impossible, or at least slow down object instantiation a lot, as you would have to keep the class code around and execute it when objects are created.</source>
          <target state="translated">这只是 &quot;它是如何工作的&quot;,让它在函数的情况下以不同的方式工作,可能会很复杂,而在类的情况下很可能是不可能的,或者至少会使对象的实例化速度变慢很多,因为你必须保留类的代码,并在创建对象时执行它。</target>
        </trans-unit>
        <trans-unit id="fd310ea6b1cae2a6a063f0bd5d873b8e8d185946" translate="yes" xml:space="preserve">
          <source>Just change the function to be:</source>
          <target state="translated">只要把功能改成。</target>
        </trans-unit>
        <trans-unit id="7da4eaf92a58f20a9c68b073a49820f4346f33e5" translate="yes" xml:space="preserve">
          <source>Let's now execute this function:</source>
          <target state="translated">现在我们来执行这个函数。</target>
        </trans-unit>
        <trans-unit id="fd6ffcde729e6f54a9565146d7555da45d90700c" translate="yes" xml:space="preserve">
          <source>Look back to the original example and consider the above points:</source>
          <target state="translated">回头看看原来的例子,并考虑以上几点。</target>
        </trans-unit>
        <trans-unit id="7d52014db1eb1bc10080d5b3576313f9f6997662" translate="yes" xml:space="preserve">
          <source>Many builtin mutable types have a copy method like &lt;code&gt;some_dict.copy()&lt;/code&gt; or &lt;code&gt;some_set.copy()&lt;/code&gt; or can be copied easy like &lt;code&gt;somelist[:]&lt;/code&gt; or &lt;code&gt;list(some_list)&lt;/code&gt;. Every object can be also copied by &lt;code&gt;copy.copy(any_object)&lt;/code&gt; or more thorough by &lt;code&gt;copy.deepcopy()&lt;/code&gt; (the latter useful if the mutable object is composed from mutable objects). Some objects are fundamentally based on side effects like &quot;file&quot; object and can not be meaningfully reproduced by copy. &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm&quot;&gt;copying&lt;/a&gt;</source>
          <target state="translated">许多内置的可变类型具有诸如 &lt;code&gt;some_dict.copy()&lt;/code&gt; 或 &lt;code&gt;some_set.copy()&lt;/code&gt; 之类的复制方法，或者可以像 &lt;code&gt;somelist[:]&lt;/code&gt; 或 &lt;code&gt;list(some_list)&lt;/code&gt; 之类的易于复制的方法。 每个对象也可以通过 &lt;code&gt;copy.copy(any_object)&lt;/code&gt; 复制，也可以通过copy.deepcopy（）进行更彻底的 &lt;code&gt;copy.deepcopy()&lt;/code&gt; 如果可变对象是由可变对象组成的，后者很有用）。 某些对象从根本上是基于副作用的，例如&amp;ldquo;文件&amp;rdquo;对象，并且不能通过复制有意义地进行复制。 &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm&quot;&gt;复制中&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e23f5cbc0bbb2cbb8b27c449a4bcd8e9fbb38b2b" translate="yes" xml:space="preserve">
          <source>No default values in sight in this code, but you get exactly the same problem.</source>
          <target state="translated">在这个代码中没有看到默认值,但你得到的问题完全一样。</target>
        </trans-unit>
        <trans-unit id="b9b42c390ec8fb15d988160f4dd8c2a52791b6d6" translate="yes" xml:space="preserve">
          <source>Now let's redefine our function using this decorator:</source>
          <target state="translated">现在让我们用这个装饰器来重新定义我们的功能。</target>
        </trans-unit>
        <trans-unit id="b7e59f92481e8e7835898fa1c85ba3a27d892126" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;pavlo&lt;/code&gt; is [5].</source>
          <target state="translated">现在， &lt;code&gt;pavlo&lt;/code&gt; 是[5]。</target>
        </trans-unit>
        <trans-unit id="362ccf94780188762e961bb582f31f3d92a8d7ee" translate="yes" xml:space="preserve">
          <source>Now, compare this to the example from the documentation on &lt;a href=&quot;http://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;emulating the default argument behavior of other languages&lt;/a&gt;, such that the function signature defaults are used every time the function is executed:</source>
          <target state="translated">现在，将此与&lt;a href=&quot;http://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;模拟其他语言的默认参数行为&lt;/a&gt;的文档示例进行比较，以便每次执行函数时都使用函数签名默认值：</target>
        </trans-unit>
        <trans-unit id="64acff4f47942d13d4f208bda7e869e11d893a33" translate="yes" xml:space="preserve">
          <source>Now, does my map use the value of the &lt;code&gt;StringBuffer&lt;/code&gt; key when it was placed into the map, or does it store the key by reference?  Either way, someone is astonished; either the person who tried to get the object out of the &lt;code&gt;Map&lt;/code&gt; using a value identical to the one they put it in with, or the person who can't seem to retrieve their object even though the key they're using is literally the same object that was used to put it into the map (this is actually why Python doesn't allow its mutable built-in data types to be used as dictionary keys).</source>
          <target state="translated">现在，我的地图放置在地图中时是否使用 &lt;code&gt;StringBuffer&lt;/code&gt; 键的值，还是通过引用存储键？ 无论哪种方式，都会有人感到惊讶。 尝试使用与其放入对象的值相同的值从 &lt;code&gt;Map&lt;/code&gt; 获取对象的人，或者即使他们使用的键从字面上看也似乎无法检索其对象的人用于将其放入地图中的对象（这实际上是Python不允许将其可变的内置数据类型用作字典键的原因）。</target>
        </trans-unit>
        <trans-unit id="ca1782989bcd41936515ff547e98eb21e1c24f56" translate="yes" xml:space="preserve">
          <source>Now, let's see those &lt;code&gt;__defaults__&lt;/code&gt; again:</source>
          <target state="translated">现在，让我们再次看看那些 &lt;code&gt;__defaults__&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="03060fd5df0aea733c344b9b8691c947fcb3b65a" translate="yes" xml:space="preserve">
          <source>Now, suppose the behaviour of defaults could be changed so that this is the equivalent of:</source>
          <target state="translated">现在,假设可以改变默认的行为,这样就相当于:</target>
        </trans-unit>
        <trans-unit id="c8b8bb4b9ae89c0e3c42072a31a62c115adca126" translate="yes" xml:space="preserve">
          <source>Now, when to evaluate &lt;code&gt;default&lt;/code&gt;?</source>
          <target state="translated">现在，何时评估 &lt;code&gt;default&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="2d80698d75eb09b54cff119780e3f91af2942726" translate="yes" xml:space="preserve">
          <source>O.k, so an empty list as the single entry in &lt;code&gt;__defaults__&lt;/code&gt;, just as expected.</source>
          <target state="translated">好的，所以像预期的那样，将空列表作为 &lt;code&gt;__defaults__&lt;/code&gt; 中的单个条目。</target>
        </trans-unit>
        <trans-unit id="8ee84d967071869b5d4f78c07c4174525b7a125c" translate="yes" xml:space="preserve">
          <source>One answer is probably right there--it would effectively turn every function with default parameters into a closure.  Even if it's all hidden away in the interpreter and not a full-blown closure, the data's got to be stored somewhere.  It'd be slower and use more memory.</source>
          <target state="translated">一个答案可能就在这里----它将有效地把每个带默认参数的函数都变成一个闭包。即使它都隐藏在解释器中,而不是一个完整的闭包,数据也会被存储在某个地方。这将会比较慢,而且会使用更多的内存。</target>
        </trans-unit>
        <trans-unit id="11b18ef18f03165cd782bc4f836d003ad9d95019" translate="yes" xml:space="preserve">
          <source>Only if the side effect on the actual parameter is required but unwanted on the default parameter then the useful solution is &lt;code&gt;def ...(var1=None):&lt;/code&gt;&lt;code&gt;if var1 is None:&lt;/code&gt;&lt;code&gt;var1 = []&lt;/code&gt;&lt;a href=&quot;http://effbot.org/zone/default-values.htm#what-to-do-instead&quot;&gt;More..&lt;/a&gt;</source>
          <target state="translated">仅当对实际参数有副作用，而对默认参数无影响时，有用的解决方案是 &lt;code&gt;def ...(var1=None):&lt;/code&gt; &lt;code&gt;if var1 is None:&lt;/code&gt; &lt;code&gt;var1 = []&lt;/code&gt; &lt;a href=&quot;http://effbot.org/zone/default-values.htm#what-to-do-instead&quot;&gt;更多。&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="114258caa60ea3edd65afe4bbb8f1463ea7260f5" translate="yes" xml:space="preserve">
          <source>Per &lt;strong&gt;(1)&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;a new local variable also named &lt;code&gt;L&lt;/code&gt; is created in the local scope&lt;/em&gt;&lt;/strong&gt; and used for the remainder of the function call. &lt;code&gt;foo.func_defs[0]&lt;/code&gt; thus remains unchanged for future invocations of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">在&lt;strong&gt;（1）中&lt;/strong&gt; ， &lt;strong&gt;&lt;em&gt;在本地范围内创建了一个新的局部变量 &lt;code&gt;L&lt;/code&gt; &lt;/em&gt;&lt;/strong&gt; ， &lt;strong&gt;&lt;em&gt;该变量也称为L&lt;/em&gt;&lt;/strong&gt; ，用于其余的函数调用。 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; 因此对于以后的 &lt;code&gt;foo&lt;/code&gt; 调用保持不变。</target>
        </trans-unit>
        <trans-unit id="1d87aa1b1e7324f25c59d457e5df3e2ceb743377" translate="yes" xml:space="preserve">
          <source>Per Brett Slatkin's &quot;Effective Python: 59 Specific Ways to Write Better Python&quot;, &lt;em&gt;Item 20: Use &lt;code&gt;None&lt;/code&gt; and Docstrings to specify dynamic default arguments&lt;/em&gt; (p. 48)</source>
          <target state="translated">Per Brett Slatkin的&amp;ldquo;有效的Python：编写更好的Python的59种特定方式&amp;rdquo;， &lt;em&gt;第20项：使用 &lt;code&gt;None&lt;/code&gt; 和Docstrings指定动态默认参数&lt;/em&gt; （第48页）</target>
        </trans-unit>
        <trans-unit id="edbbe1dd270001c9959fe3b6bfc520ed27fa81f3" translate="yes" xml:space="preserve">
          <source>Provided that python objects &lt;strong&gt;are mutable&lt;/strong&gt; I think that this should be taken into account when designing the default arguments stuff.
When you instantiate a list:</source>
          <target state="translated">假设python对象&lt;strong&gt;是可变的，&lt;/strong&gt;我认为在设计默认参数时应考虑到这一点。 实例化列表时：</target>
        </trans-unit>
        <trans-unit id="e05c3327cf67fb602c3add427a88b4d544b75506" translate="yes" xml:space="preserve">
          <source>Python novices would expect this function to always return a list with only one element: &lt;code&gt;[5]&lt;/code&gt;. The result is instead very different, and very astonishing (for a novice):</source>
          <target state="translated">Python新手希望此函数始终返回仅包含一个元素的列表： &lt;code&gt;[5]&lt;/code&gt; 。 结果是非常不同的，并且非常令人惊讶（对于新手而言）：</target>
        </trans-unit>
        <trans-unit id="81f99a7ff268aeaf873fa4045929feaf18be7cd0" translate="yes" xml:space="preserve">
          <source>Python: The Mutable Default Argument</source>
          <target state="translated">Python。Mutable Default Argument</target>
        </trans-unit>
        <trans-unit id="48fb53aa0f56fcdc44c27cdce6ee6b0ac6e04929" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;parameter&lt;/code&gt; is a constant name, we can &quot;evaluate&quot; it at the same time as &lt;code&gt;def name&lt;/code&gt;. This also has the advantage it produces the function with a known signature as &lt;code&gt;name(parameter=...):&lt;/code&gt;, instead of a bare &lt;code&gt;name(...):&lt;/code&gt;.</source>
          <target state="translated">由于 &lt;code&gt;parameter&lt;/code&gt; 是常量名，因此我们可以与 &lt;code&gt;def name&lt;/code&gt; 同时&amp;ldquo;评估&amp;rdquo;它。 这还有一个优势，它可以生成具有已知签名的函数，即 &lt;code&gt;name(parameter=...):&lt;/code&gt; ：，而不是裸 &lt;code&gt;name(...):&lt;/code&gt; :。</target>
        </trans-unit>
        <trans-unit id="a5d182b67a7149475e28eef1bc9597d34d73b45e" translate="yes" xml:space="preserve">
          <source>Since I don't think this pattern is well known, I do put a short comment in to guard against future misunderstandings.</source>
          <target state="translated">因为我觉得这个模式不是很了解,所以我确实放了一个简短的评论,以防止以后的误解。</target>
        </trans-unit>
        <trans-unit id="1da4b14f89f2b2d481987a26be3a56b816db7930" translate="yes" xml:space="preserve">
          <source>Since the function body is executed anew each time, you always get a fresh new empty list if no argument was passed for &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">由于函数主体每次都会重新执行，因此如果没有为参数传递参数，则始终会得到一个新的空列表。</target>
        </trans-unit>
        <trans-unit id="8219cc9987e068b594e6f9212eabecd380fc4b23" translate="yes" xml:space="preserve">
          <source>Since the list is bound to the function when the function object is compiled and instantiated, this:</source>
          <target state="translated">因为当函数对象被编译和实例化时,列表被绑定到函数中,这。</target>
        </trans-unit>
        <trans-unit id="846d5d41860fc57cee6667664460f6fd3c443f37" translate="yes" xml:space="preserve">
          <source>So this is what you see (Remember, &lt;code&gt;pavlo&lt;/code&gt; is initialized to []):</source>
          <target state="translated">因此，这就是您所看到的（记住， &lt;code&gt;pavlo&lt;/code&gt; 已初始化为[]）：</target>
        </trans-unit>
        <trans-unit id="cc480e96946c5a4d81dbe64f85f0531baec48a48" translate="yes" xml:space="preserve">
          <source>So, &lt;code&gt;pavlo&lt;/code&gt; is still &lt;code&gt;[5, 5]&lt;/code&gt;.</source>
          <target state="translated">因此， &lt;code&gt;pavlo&lt;/code&gt; 仍然是 &lt;code&gt;[5, 5]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="135253f82ce516e45be9920a7c65b965b29a4cbe" translate="yes" xml:space="preserve">
          <source>So, let's do some introspection, a before and after to examine how the list gets expanded &lt;strong&gt;inside&lt;/strong&gt; the function object. I'm using &lt;code&gt;Python 3.x&lt;/code&gt; for this, for Python 2 the same applies (use &lt;code&gt;__defaults__&lt;/code&gt; or &lt;code&gt;func_defaults&lt;/code&gt; in Python 2; yes, two names for the same thing).</source>
          <target state="translated">因此，让我们进行一些自省，前后检查清单如何在函数对象&lt;strong&gt;内&lt;/strong&gt;扩展。 我为此使用 &lt;code&gt;Python 3.x&lt;/code&gt; ，对于Python 2同样适用（在Python 2中使用 &lt;code&gt;__defaults__&lt;/code&gt; 或 &lt;code&gt;func_defaults&lt;/code&gt; ；是的，两个名称相同）。</target>
        </trans-unit>
        <trans-unit id="ac03b13d0df29e0d823d1733d67a60356a13e49c" translate="yes" xml:space="preserve">
          <source>So, there you have it, the reason why this &lt;em&gt;'flaw'&lt;/em&gt; happens, is because default arguments are part of the function object. There's nothing weird going on here, it's all just a bit surprising.</source>
          <target state="translated">因此，出现&lt;em&gt;&amp;ldquo;缺陷&amp;rdquo;&lt;/em&gt;的原因是因为默认参数是函数对象的一部分。 这里没有什么奇怪的事情，这一切都令人惊讶。</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="2ffd73eaa6f051202977e48c6c85a797b6fd5a12" translate="yes" xml:space="preserve">
          <source>Someone is using every language/library feature, and</source>
          <target state="translated">有人在使用每一个语言库的功能,并且</target>
        </trans-unit>
        <trans-unit id="d42bae2973e05a62b137b51620fea4d9b147edc0" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;a&lt;/code&gt; when calling &lt;code&gt;foo()&lt;/code&gt; ensures &lt;code&gt;pavlo&lt;/code&gt; is not touched.</source>
          <target state="translated">在调用 &lt;code&gt;foo()&lt;/code&gt; 时指定 &lt;code&gt;a&lt;/code&gt; 可以确保不触摸 &lt;code&gt;pavlo&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f19d645e1fda82c64c713d7a7c9e1d69d1720d38" translate="yes" xml:space="preserve">
          <source>Suppose you have the following code</source>
          <target state="translated">假设你有以下代码</target>
        </trans-unit>
        <trans-unit id="2985042a12a99a3c98ea5fdbdde2134ab3ef8abf" translate="yes" xml:space="preserve">
          <source>Switching the behavior here would be ill-advised, but</source>
          <target state="translated">在这里改变行为是不明智的,但是</target>
        </trans-unit>
        <trans-unit id="eb8098887cd8190749f463f9cd047389241aa54c" translate="yes" xml:space="preserve">
          <source>TLDR: Define-time defaults are consistent and strictly more expressive.</source>
          <target state="translated">TLDR:Define-time defaults是一致的,严格说来更有表现力。</target>
        </trans-unit>
        <trans-unit id="baee8029959dfcc9ec36a00cfc022b60ddd58256" translate="yes" xml:space="preserve">
          <source>Taking &lt;strong&gt;(1)&lt;/strong&gt; and &lt;strong&gt;(2)&lt;/strong&gt; into account, one can see why this accomplishes the the desired behavior:</source>
          <target state="translated">考虑到&lt;strong&gt;（1）&lt;/strong&gt;和&lt;strong&gt;（2）&lt;/strong&gt; ，可以看到为什么这样做可以实现所需的行为：</target>
        </trans-unit>
        <trans-unit id="60e49eedb22450ed713b64f742443e241e6f5637" translate="yes" xml:space="preserve">
          <source>That is against the rules of functional programming, usually undesiderable and should be fixed both together.</source>
          <target state="translated">这就违背了函数式编程的规则,通常是不可以考虑的,应该一并固定下来。</target>
        </trans-unit>
        <trans-unit id="6283984545c4460e3d117123b9917e356ce0cec9" translate="yes" xml:space="preserve">
          <source>That said it should feature prominently in any good Python tutorial. Because as you mention, everyone runs into this problem sooner or later.</source>
          <target state="translated">话虽如此,但在任何优秀的 Python 教程中,它都应该占据显著位置。因为正如你所提到的,每个人迟早都会遇到这个问题。</target>
        </trans-unit>
        <trans-unit id="4742191818ba22d12f4df985ed0fa6ab565b9a93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def name&lt;/code&gt; part &lt;strong&gt;must&lt;/strong&gt; evaluate in the defining scope - we want &lt;code&gt;name&lt;/code&gt; to be available there, after all. Evaluating the function only inside itself would make it inaccessible.</source>
          <target state="translated">&lt;code&gt;def name&lt;/code&gt; 部分&lt;strong&gt;必须&lt;/strong&gt;在定义范围内进行评估-毕竟，我们希望在此处使用 &lt;code&gt;name&lt;/code&gt; 。 仅在内部评估函数将使其无法访问。</target>
        </trans-unit>
        <trans-unit id="211b17364c2c5fb881927eef3ad2c632ef6e4ead" translate="yes" xml:space="preserve">
          <source>The actual behavior is more consistent: everything of that line gets evaluated when that line is executed, meaning at function definition.</source>
          <target state="translated">实际的行为比较一致:当该行的所有内容都被执行时,即在函数定义时,该行的所有内容都会被评估。</target>
        </trans-unit>
        <trans-unit id="b21b3a47af1bce60cc5bdaa7db45df9e68ea6c1a" translate="yes" xml:space="preserve">
          <source>The behavior of read-only class attributes upon assignment attempts, and that</source>
          <target state="translated">只读类属性在尝试分配时的行为,以及</target>
        </trans-unit>
        <trans-unit id="d812f28bfd7bbbe507925925cde1cb11345acdb0" translate="yes" xml:space="preserve">
          <source>The common solution to combat this is to use &lt;code&gt;None&lt;/code&gt; as the default and then initialize in the function body:</source>
          <target state="translated">解决此问题的常见解决方案是使用 &lt;code&gt;None&lt;/code&gt; 作为默认值，然后在函数体内进行初始化：</target>
        </trans-unit>
        <trans-unit id="e6bc97e96787463bf81bb7eba82e092966902caa" translate="yes" xml:space="preserve">
          <source>The convention for achieving the desired result in Python is to
  provide a default value of &lt;code&gt;None&lt;/code&gt; and to document the actual behaviour
  in the docstring.</source>
          <target state="translated">在Python中实现所需结果的约定是提供默认值 &lt;code&gt;None&lt;/code&gt; 并在文档字符串中记录实际行为。</target>
        </trans-unit>
        <trans-unit id="12d835d927cd99c2caf5af5f3e46112259ed6aeb" translate="yes" xml:space="preserve">
          <source>The decorator could be adjusted to allow for that, but we leave this as an exercise for the reader ;)</source>
          <target state="translated">装修器可以调整,但我们将此作为一个练习,留给读者来使用;)</target>
        </trans-unit>
        <trans-unit id="5da3d3f2271874d0124b0b19b38e9cd58ca9fc21" translate="yes" xml:space="preserve">
          <source>The example in the question could fall into category 1 or 3. It's odd that it both modifies the passed list and returns it; you should pick one or the other.</source>
          <target state="translated">问题中的例子可能属于第一类或第三类。奇怪的是,它既修改了传递的列表,又返回了它,你应该选择其中一个或另一个。</target>
        </trans-unit>
        <trans-unit id="07a5b90c302821e9edaa02c42d4c5a34d0d660fb" translate="yes" xml:space="preserve">
          <source>The existing behavior is not Pythonic, and Python is successful because very little about the language violates the principle of least astonishment anywhere &lt;em&gt;near&lt;/em&gt; this badly. It is a real problem, whether or not it would be wise to uproot it. It is a design flaw. If you understand the language much better by trying to trace out the behavior, I can say that C++ does all of this and more; you learn a lot by navigating, for instance, subtle pointer errors. But this is not Pythonic: people who care about Python enough to persevere in the face of this behavior are people who are drawn to the language because Python has far fewer surprises than other language. Dabblers and the curious become Pythonistas when they are astonished at how little time it takes to get something working--not because of a design fl--I mean, hidden logic puzzle--that cuts against the intuitions of programmers who are drawn to Python because it &lt;strong&gt;Just Works&lt;/strong&gt;.</source>
          <target state="translated">现有的行为不是Python式的，Python之所以成功，是因为该语言几乎没有违反这方面的最小惊讶原则。 根除它是否明智是一个真正的问题。 这是一个设计缺陷。 如果您通过尝试找出行为来更好地理解该语言，则可以说C ++可以完成所有这些工作，甚至更多。 通过导航（例如）细微的指针错误，您学到了很多东西。 但这不是Python风格的：关心Python足以在这种行为面前持之以恒的人是被该语言吸引的人，因为Python比其他语言具有更少的惊喜。 当涉猎者和好奇者成为一名Pythonista专家时，他们惊讶地发现需要花很少的时间才能完成某些工作，而不是因为设计漏洞-我的意思是隐藏的逻辑难题-消除了被Python吸引的程序员的直觉因为它&lt;strong&gt;可行&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="16ba720afc950d5f92d65c94fa4b03086d39ddeb" translate="yes" xml:space="preserve">
          <source>The invocation of foo(1) make items point to a list object [] with an address, say, 11111111. the content of the list is changed to &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; in the foo function in the sequel, but the address is not changed, still 11111111. Then foo(2,[]) is coming. Although the [] in foo(2,[]) has the same content as the default parameter [] when calling foo(1), their address are different! Since we provide the parameter explicitly, &lt;code&gt;items&lt;/code&gt; has to take the address of this new &lt;code&gt;[]&lt;/code&gt;, say 2222222, and return it after making some change. Now foo(3) is executed. since only &lt;code&gt;x&lt;/code&gt; is provided, items has to take its default value again. What's the default value? It is set when defining the foo function: the list object located in 11111111. So the items is evaluated to be the address 11111111 having an element 1. The list located at 2222222 also contains one element 2, but it is not pointed by items any more. Consequently, An append of 3 will make &lt;code&gt;items&lt;/code&gt; [1,3].</source>
          <target state="translated">foo（1）的调用使项指向具有地址的列表对象[]，例如11111111。在续集的foo函数中，列表的内容更改为&lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; ，但地址未更改，仍然为11111111然后foo（2，[]）来了。 尽管在调用foo（1）时，foo（2，[]）中的[]与默认参数[]的内容相同，但它们的地址却不同！ 由于我们显式提供了参数，因此 &lt;code&gt;items&lt;/code&gt; 必须采用这个新 &lt;code&gt;[]&lt;/code&gt; 的地址，即2222222，并在进行一些更改后将其返回。 现在执行foo（3）。 由于仅提供 &lt;code&gt;x&lt;/code&gt; ，因此项必须再次采用其默认值。 默认值是多少？ 它是在定义foo函数时设置的：位于11111111的列表对象。因此，将这些项评估为具有元素1的地址11111111。位于2222222的列表也包含一个元素2，但是任何项目都不会指向该列表更多。 因此，追加3将使 &lt;code&gt;items&lt;/code&gt; [1,3]。</target>
        </trans-unit>
        <trans-unit id="960186c4fed60739e84ad1f39072643da3a4aa62" translate="yes" xml:space="preserve">
          <source>The only way to implement this otherwise would be to create a further closure with the i bound, ie:</source>
          <target state="translated">否则的话,唯一的实现方法就是用i绑定创建一个进一步的封闭,即。</target>
        </trans-unit>
        <trans-unit id="9a6df79e5dc84aaf86c93401973ff0f28eae8f32" translate="yes" xml:space="preserve">
          <source>The other answers, or at least some of them either make points 1 and 2 but not 3, or make point 3 and downplay points 1 and 2. &lt;strong&gt;But all three are true.&lt;/strong&gt;</source>
          <target state="translated">其他答案，或者至少其中一些答案得分为1和2，但不是3，或者得分为3，淡化得分为1和2。 &lt;strong&gt;但所有三个答案都是正确的。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="927ebe1c435f42420093f2af144d14cd34af2416" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;foo&lt;/code&gt; is &lt;em&gt;modifying&lt;/em&gt; a mutable variable passed in from the caller, when the caller doesn't expect this. Code like this would be fine if the function was called something like &lt;code&gt;append_5&lt;/code&gt;; then the caller would be calling the function in order to modify the value they pass in, and the behaviour would be expected. But such a function would be very unlikely to take a default argument, and probably wouldn't return the list (since the caller already has a reference to that list; the one it just passed in).</source>
          <target state="translated">问题在于，当调用方不希望这样做时， &lt;code&gt;foo&lt;/code&gt; 会&lt;em&gt;修改&lt;/em&gt;从调用方传入的可变变量。 如果函数被调用为诸如 &lt;code&gt;append_5&lt;/code&gt; 之类的代码，则这样的代码就可以了； 那么调用者将调用该函数以修改它们传递的值，并且行为将是预期的。 但是这样的函数不太可能采用默认参数，并且可能不会返回列表（因为调用者已经具有对该列表的引用；它只是传入了该列表）。</target>
        </trans-unit>
        <trans-unit id="65336feec4cf085e41224e4e768035259840cf58" translate="yes" xml:space="preserve">
          <source>The real problem lies with mutable variables, and all languages have this problem to some extent. Here's a question: suppose in Java I have the following code:</source>
          <target state="translated">真正的问题在于可突变变量,所有的语言在某种程度上都有这个问题。这里有一个问题:假设在Java中,我有以下代码。</target>
        </trans-unit>
        <trans-unit id="0a4fcade0686f8907935d1c1f96cfa776ce37445" translate="yes" xml:space="preserve">
          <source>The relevant part of the &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function-definitions&quot;&gt;documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function-definitions&quot;&gt;文档&lt;/a&gt;的相关部分：</target>
        </trans-unit>
        <trans-unit id="83a5fdca145464c718498a81f3ff52fe5cd258bb" translate="yes" xml:space="preserve">
          <source>The role of &lt;strong&gt;(2)&lt;/strong&gt; has been covered extensively in this thread. &lt;strong&gt;(1)&lt;/strong&gt; is likely the astonishment causing factor, as this behavior is not &quot;intuitive&quot; when coming from other languages.</source>
          <target state="translated">&lt;strong&gt;（2）&lt;/strong&gt;的作用已在该线程中广泛讨论。 &lt;strong&gt;（1）&lt;/strong&gt;可能是令人惊讶的原因，因为这种行为在来自其他语言时不是&amp;ldquo;直观&amp;rdquo;的。</target>
        </trans-unit>
        <trans-unit id="300e6346ced2778bb2850c432c17f5b9ac6cc781" translate="yes" xml:space="preserve">
          <source>The second option is nice because users of the function can pass in a callable, which may be already existing (such as a &lt;code&gt;type&lt;/code&gt;)</source>
          <target state="translated">第二个选项很好，因为函数的用户可以传递一个可调用的对象，该对象可能已经存在（例如 &lt;code&gt;type&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="a7a38b99177ce67bdf698f00a61b5341959f2954" translate="yes" xml:space="preserve">
          <source>The shortest answer would probably be &quot;definition is execution&quot;, therefore the whole argument makes no strict sense. As a more contrived example, you may cite this:</source>
          <target state="translated">最简短的答案可能是 &quot;定义就是执行&quot;,所以整个论点没有严格意义。你可以举出一个更复杂的例子:</target>
        </trans-unit>
        <trans-unit id="1545469b153fc84d77f2934491dab6d60119c4f8" translate="yes" xml:space="preserve">
          <source>The solutions here are:</source>
          <target state="translated">这里的解决办法是:</target>
        </trans-unit>
        <trans-unit id="9f29d3492458b50ad2b58ab7115f1bdab5c6dec2" translate="yes" xml:space="preserve">
          <source>The two choices are not equivalent, either: If &lt;code&gt;default&lt;/code&gt; is evaluated at definition time, it &lt;em&gt;can still&lt;/em&gt; affect execution time. If &lt;code&gt;default&lt;/code&gt; is evaluated at execution time, it &lt;em&gt;cannot&lt;/em&gt; affect definition time. Choosing &quot;at definition&quot; allows expressing both cases, while choosing &quot;at execution&quot; can express only one:</source>
          <target state="translated">两种选择都不相同：如果在定义时评估 &lt;code&gt;default&lt;/code&gt; 值，则它&lt;em&gt;仍会&lt;/em&gt;影响执行时间。 如果在执行时评估 &lt;code&gt;default&lt;/code&gt; 值，则它&lt;em&gt;不会&lt;/em&gt;影响定义时间。 选择&amp;ldquo;在定义时&amp;rdquo;允许表达两种情况，而选择&amp;ldquo;在执行时&amp;rdquo;只能表达一种情况：</target>
        </trans-unit>
        <trans-unit id="9d3b19afacd01fa6760d29ccb31fceacd0420b99" translate="yes" xml:space="preserve">
          <source>The usual instruction to new Python users:</source>
          <target state="translated">对Python新用户的常规指导。</target>
        </trans-unit>
        <trans-unit id="83431a0cce73cc9ea555626b7407f498ddeab772" translate="yes" xml:space="preserve">
          <source>There are 3 cases I see where you might run into this problem:</source>
          <target state="translated">在我看来有三种情况下,你可能会遇到这个问题。</target>
        </trans-unit>
        <trans-unit id="7d403bffc3efdc0e15e597031a66e58b86f1e427" translate="yes" xml:space="preserve">
          <source>There may be legitimate use cases for the 'Wrong Method' whereby the programmer intended the default list parameter to be shared, but this is more likely the exception than the rule.</source>
          <target state="translated">对于 &quot;错误的方法&quot;,可能有合法的使用案例,程序员希望共享默认的列表参数,但这很可能是例外而不是规则。</target>
        </trans-unit>
        <trans-unit id="e122131b734ffdd0c974c11125de9bf4d4ac1de3" translate="yes" xml:space="preserve">
          <source>They stay mutated because they are the same object each time.</source>
          <target state="translated">它们之所以保持变异,是因为它们每次都是同一个对象。</target>
        </trans-unit>
        <trans-unit id="42f87dc35743615ca50ba7a4e0a765f48628f38e" translate="yes" xml:space="preserve">
          <source>This &quot;bug&quot; gave me a lot of overtime work hours! But I'm beginning to see a potential use of it (but I would have liked it to be at the execution time, still)</source>
          <target state="translated">这个 &quot;BUG &quot;给了我很多的加班时间! 但我开始看到了它的潜在用途(但我还是希望它能在执行的时候,还是在执行的时候就好了</target>
        </trans-unit>
        <trans-unit id="09c551bd076af75de6f7f75f84e6e19528a70b20" translate="yes" xml:space="preserve">
          <source>This actually has nothing to do with default values, other than that it often comes up as an unexpected behaviour when you write functions with mutable default values.</source>
          <target state="translated">这其实和缺省值没有什么关系,只是当你写出带有可突变的缺省值的函数时,经常会出现这样的行为。</target>
        </trans-unit>
        <trans-unit id="91bf40b75c5eb2ec9fc9e9af2dee27f147910385" translate="yes" xml:space="preserve">
          <source>This behavior is easy explained by:</source>
          <target state="translated">这种行为很容易解释为:</target>
        </trans-unit>
        <trans-unit id="8e882fce06b5aa8e4902377bf10643c0438bee5c" translate="yes" xml:space="preserve">
          <source>This behavior is not surprising if you take the following into consideration:</source>
          <target state="translated">如果考虑到以下因素,这种行为并不奇怪。</target>
        </trans-unit>
        <trans-unit id="53ed8453d80a594313b39f617a24cd922589e53c" translate="yes" xml:space="preserve">
          <source>This code suffers from the exact same unexpected happenstance. bananas is a class attribute, and hence, when you add things to it, it's added to all instances of that class. The reason is exactly the same.</source>
          <target state="translated">bananas是一个类属性,因此,当你把东西添加到它的时候,它会被添加到该类的所有实例中。原因是完全一样的。</target>
        </trans-unit>
        <trans-unit id="5aa4790f0f096239796bd26d7ab23aed623fa5b3" translate="yes" xml:space="preserve">
          <source>This implementation ensures that each call to the function either receives the default list or else the list passed to the function.</source>
          <target state="translated">该实现确保每次调用该函数时,要么接收默认的列表,要么接收传递给该函数的列表。</target>
        </trans-unit>
        <trans-unit id="37aa3fb7ad8287604da5115ea29978831dfe3dda" translate="yes" xml:space="preserve">
          <source>This information is very useful for things like document generation, metaprogramming, decorators etc.</source>
          <target state="translated">这些信息对文档生成、元编程、装饰器等都非常有用。</target>
        </trans-unit>
        <trans-unit id="643cda6d4c6e34a04adb1a217260ad6665380a64" translate="yes" xml:space="preserve">
          <source>This is particularly neat for functions that take multiple arguments. Compare:</source>
          <target state="translated">这对于接受多个参数的函数来说,尤其适合。对比一下。</target>
        </trans-unit>
        <trans-unit id="e564daaa17ad1d2d62e46bbb59e0067c087845a8" translate="yes" xml:space="preserve">
          <source>This order of execution is frequently confusing to new users of Python. If you understand the Python execution model, then it becomes quite expected.</source>
          <target state="translated">这种执行顺序经常让Python的新用户感到困惑。如果你理解了Python的执行模型,那么它就会变得相当令人期待。</target>
        </trans-unit>
        <trans-unit id="b99a6bdeb57707ff2643e03cc6dbbbaa2acc3f12" translate="yes" xml:space="preserve">
          <source>This returns a list of functions that return 0,1,2,3... respectively.  If the behaviour is changed, they will instead bind &lt;code&gt;i&lt;/code&gt; to the &lt;em&gt;call-time&lt;/em&gt; value of i, so you would get a list of functions that all returned &lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">这将返回分别返回0、1、2、3 ...的函数列表。 如果行为发生变化，它们将把 &lt;code&gt;i&lt;/code&gt; 绑定到i的&lt;em&gt;调用&lt;/em&gt;时值，因此您将获得一个全部返回 &lt;code&gt;9&lt;/code&gt; 的函数列表。</target>
        </trans-unit>
        <trans-unit id="d1a3982204610904ddbc4a70de5860ec7e166984" translate="yes" xml:space="preserve">
          <source>This uses the None singleton as a sentinel object to tell the function whether or not we've gotten an argument other than the default. If we get no argument, then we actually want to use a new empty list, &lt;code&gt;[]&lt;/code&gt;, as the default.</source>
          <target state="translated">这将None单例用作哨兵对象，以告诉函数是否获得了默认值以外的参数。 如果没有参数，则实际上我们想使用一个新的空列表 &lt;code&gt;[]&lt;/code&gt; 作为默认值。</target>
        </trans-unit>
        <trans-unit id="4aedb952cd727e6e69581496e8e0b6ab6127d03c" translate="yes" xml:space="preserve">
          <source>To further validate my answer, let's take a look at two additional codes.</source>
          <target state="translated">为了进一步验证我的答案,我们再来看看另外两个代码。</target>
        </trans-unit>
        <trans-unit id="3488d10d037c07a6d63c40837ee02a62ef16f935" translate="yes" xml:space="preserve">
          <source>To further verify that the list in &lt;code&gt;__defaults__&lt;/code&gt; is the same as that used in the function &lt;code&gt;func&lt;/code&gt; you can just change your function to return the &lt;code&gt;id&lt;/code&gt; of the list &lt;code&gt;a&lt;/code&gt; used inside the function body. Then, compare it to the list in &lt;code&gt;__defaults__&lt;/code&gt; (position &lt;code&gt;[0]&lt;/code&gt; in &lt;code&gt;__defaults__&lt;/code&gt;) and you'll see how these are indeed refering to the same list instance:</source>
          <target state="translated">为了进一步验证 &lt;code&gt;__defaults__&lt;/code&gt; 中的列表与函数 &lt;code&gt;func&lt;/code&gt; 中使用的列表相同，您只需更改函数以返回在函数体内使用的列表 &lt;code&gt;id&lt;/code&gt; 。 然后，将其与 &lt;code&gt;__defaults__&lt;/code&gt; 中的列表进行比较 （ __defaults__中的位置 &lt;code&gt;[0]&lt;/code&gt; ），您将看到它们实际上是如何引用同一列表实例的：</target>
        </trans-unit>
        <trans-unit id="6c169f56bd97d585a628344306275a6fbb160c64" translate="yes" xml:space="preserve">
          <source>To make things simpler for this discussion, let's temporarily give the unnamed list a name. How about &lt;code&gt;pavlo&lt;/code&gt; ?</source>
          <target state="translated">为了使讨论更简单，让我们暂时为未命名列表命名。 &lt;code&gt;pavlo&lt;/code&gt; 怎么样 ？</target>
        </trans-unit>
        <trans-unit id="e3a6729bfe6a04ecd5a00fc68b6c0f6331500e7a" translate="yes" xml:space="preserve">
          <source>To me, it seems that the design decision was relative to where to put the scope of parameters: inside the function or &quot;together&quot; with it?</source>
          <target state="translated">在我看来,设计的决定似乎是相对于把参数的范围放在哪里:是放在函数内部还是和它 &quot;一起&quot;?</target>
        </trans-unit>
        <trans-unit id="636d1dcd268f11a46b28fe964396e61a54cf23da" translate="yes" xml:space="preserve">
          <source>Ugly, but it works.</source>
          <target state="translated">丑陋,但它的作用。</target>
        </trans-unit>
        <trans-unit id="f1f3a34856e7b498ab581f67c98cdf2d11513052" translate="yes" xml:space="preserve">
          <source>Upon &lt;code&gt;L = []&lt;/code&gt;, the assignment cannot succeed at &lt;code&gt;foo.func_defs[0]&lt;/code&gt;, because that attribute is read-only.</source>
          <target state="translated">在 &lt;code&gt;L = []&lt;/code&gt; ，赋值不能在 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; 处成功，因为该属性是只读的。</target>
        </trans-unit>
        <trans-unit id="b4add7a466713c04e3a9ff607faa91aff366d0f8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;None&lt;/code&gt; as your default value (or a nonce &lt;code&gt;object&lt;/code&gt;), and switch on that to create your values at runtime; or</source>
          <target state="translated">使用 &lt;code&gt;None&lt;/code&gt; 作为您的默认值（或nonce &lt;code&gt;object&lt;/code&gt; ），并在运行时将其打开以创建您的值； 要么</target>
        </trans-unit>
        <trans-unit id="ea379d2578b870e14c73410aa538eccdf7d0c72c" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;lambda&lt;/code&gt; as your default parameter, and call it within a try block to get the default value (this is the sort of thing that lambda abstraction is for).</source>
          <target state="translated">使用 &lt;code&gt;lambda&lt;/code&gt; 作为默认参数，然后在try块中调用它以获取默认值（这是lambda抽象用于的事情）。</target>
        </trans-unit>
        <trans-unit id="9ce0fb10a3874ece19a632c8bbfe4072e2abf695" translate="yes" xml:space="preserve">
          <source>We can get information about the arguments and defaults using the &lt;code&gt;inspect&lt;/code&gt; module, which</source>
          <target state="translated">我们可以使用 &lt;code&gt;inspect&lt;/code&gt; 模块获取有关参数和默认值的信息，</target>
        </trans-unit>
        <trans-unit id="f43fd0e1e7b924e195b0d1f43667f4b3ecb78cc3" translate="yes" xml:space="preserve">
          <source>We will &quot;fix&quot; this behavior with a decorator that will copy the default value instead of reusing the same instance for each positional argument left at its default value.</source>
          <target state="translated">我们将用一个装饰器来 &quot;修复 &quot;这种行为,它将复制默认值,而不是重复使用每个位置参数的默认值。</target>
        </trans-unit>
        <trans-unit id="028722da6bbfb13719d096b837a20e83f8b33121" translate="yes" xml:space="preserve">
          <source>Well, the reason is quite simply that bindings are done when code is executed, and the function definition is executed, well... when the functions is defined.</source>
          <target state="translated">嗯,原因很简单,就是在执行代码的时候进行绑定,而在执行函数定义的时候,嗯...........在定义函数的时候进行绑定。</target>
        </trans-unit>
        <trans-unit id="7ad15b2528d3a839026c0d58cd1ee45b2711f4f7" translate="yes" xml:space="preserve">
          <source>What you're asking is why this:</source>
          <target state="translated">你要问的是,为什么会这样。</target>
        </trans-unit>
        <trans-unit id="bb251fe5322c9cbb5669eb17fcc4c69cba91f98f" translate="yes" xml:space="preserve">
          <source>When I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple &lt;code&gt;(&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)&lt;/code&gt;</source>
          <target state="translated">当我看到吃的声明时，最令人吃惊的事情是认为，如果没有给出第一个参数，它将等于元组 &lt;code&gt;(&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92837d652717841e4dbdd22b5957c04117add88c" translate="yes" xml:space="preserve">
          <source>When Python encounters it, the first thing it will do is compile it in order to create a &lt;code&gt;code&lt;/code&gt; object for this function. While this compilation step is done, &lt;em&gt;Python &lt;strong&gt;evaluates&lt;/strong&gt;* and then &lt;strong&gt;stores&lt;/strong&gt; the default arguments (an empty list &lt;code&gt;[]&lt;/code&gt; here) in the function object itself&lt;/em&gt;. As the top answer mentioned: the list &lt;code&gt;a&lt;/code&gt; can now be considered a &lt;em&gt;member&lt;/em&gt; of the function &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">当Python遇到它时，它要做的第一件事就是对其进行编译，以便为此函数创建一个 &lt;code&gt;code&lt;/code&gt; 对象。 完成此编译步骤后， &lt;em&gt;Python &lt;strong&gt;计算&lt;/strong&gt; *，然后&lt;strong&gt;将&lt;/strong&gt;默认参数（此处为空列表 &lt;code&gt;[]&lt;/code&gt; ）存储在函数对象本身中&lt;/em&gt; 。 正如上面提到的最高答案：列表 &lt;code&gt;a&lt;/code&gt; 现在可以视为函数 &lt;code&gt;func&lt;/code&gt; 的&lt;em&gt;成员&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd17f911f362a654b5a6c64b275c0e88df650e11" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;foo&lt;/code&gt; function object is instantiated, &lt;code&gt;foo.func_defs[0]&lt;/code&gt; is set to &lt;code&gt;None&lt;/code&gt;, an immutable object.</source>
          <target state="translated">实例化 &lt;code&gt;foo&lt;/code&gt; 函数对象时， &lt;code&gt;foo.func_defs[0]&lt;/code&gt; 设置为 &lt;code&gt;None&lt;/code&gt; ，这是一个不可变的对象。</target>
        </trans-unit>
        <trans-unit id="6bb5893e3a075febba63fa1345cc1545dec24f55" translate="yes" xml:space="preserve">
          <source>When the function is executed with defaults (with no parameter specified for &lt;code&gt;L&lt;/code&gt; in the function call), &lt;code&gt;foo.func_defs[0]&lt;/code&gt; (&lt;code&gt;None&lt;/code&gt;) is available in the local scope as &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">当使用默认值执行函数（在函数调用中未为 &lt;code&gt;L&lt;/code&gt; 指定参数）时， &lt;code&gt;foo.func_defs[0]&lt;/code&gt; （ &lt;code&gt;None&lt;/code&gt; ）在本地范围内可作为 &lt;code&gt;L&lt;/code&gt; 使用 。</target>
        </trans-unit>
        <trans-unit id="c90da9c4543da64cdb8845246bc7bf7320e0bc1d" translate="yes" xml:space="preserve">
          <source>When they are mutable, when mutated (for example, by adding an element to it) they remain mutated on consecutive calls.</source>
          <target state="translated">当它们是可突变的,当它们被突变时(例如,在其中添加一个元素),它们在连续调用时仍然会被突变。</target>
        </trans-unit>
        <trans-unit id="2241f2b26702e693ed138e31ffa8bd03750a3109" translate="yes" xml:space="preserve">
          <source>When we do this:</source>
          <target state="translated">当我们这样做的时候。</target>
        </trans-unit>
        <trans-unit id="6912ff10f6eb1fb687cb173f4f87e2aa8cb150d3" translate="yes" xml:space="preserve">
          <source>Why don't you introspect?</source>
          <target state="translated">你为什么不反省一下?</target>
        </trans-unit>
        <trans-unit id="287fc26c3268d8d1c2a9357d670b0099b1576d07" translate="yes" xml:space="preserve">
          <source>Why should the &lt;code&gt;a=[]&lt;/code&gt; in</source>
          <target state="translated">为什么在 &lt;code&gt;a=[]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="52b2c683c383df4eb8aa68d958bd6badb17f2b85" translate="yes" xml:space="preserve">
          <source>Yes, it is unexpected. But once the penny drops, it fits in perfectly with how Python works in general. In fact, it's a good teaching aid, and once you understand why this happens, you'll grok python much better.</source>
          <target state="translated">是的,这是意料之外的。但是,一旦分文落下,它就很符合Python的一般工作原理。事实上,这是一个很好的教学辅助工具,一旦你明白了为什么会出现这种情况,你会更好地理解python。</target>
        </trans-unit>
        <trans-unit id="9083597dacf68f7853fb01578d3aa2ab71e8663f" translate="yes" xml:space="preserve">
          <source>You can get round this by replacing the object (and therefore the tie with the scope):</source>
          <target state="translated">你可以通过更换对象(因此用范围来代替领带)来绕过这个问题。</target>
        </trans-unit>
        <trans-unit id="b512ff0f2aacb271cc653788c90da69d6dfc77d3" translate="yes" xml:space="preserve">
          <source>You can verify that they are one and the same object by using &lt;code&gt;id&lt;/code&gt;:</source>
          <target state="translated">您可以使用 &lt;code&gt;id&lt;/code&gt; 验证它们是否是同一对象：</target>
        </trans-unit>
        <trans-unit id="b7a57f1c427b2aba87570b0fda4061b9802afcc3" translate="yes" xml:space="preserve">
          <source>You intend to leave the argument unmodified, but you accidentally &lt;em&gt;did&lt;/em&gt; modify it. That's a bug, fix it.</source>
          <target state="translated">您打算保留该参数不变，但无意中&lt;em&gt;确实对其进行了&lt;/em&gt;修改。 那是一个错误，修复它。</target>
        </trans-unit>
        <trans-unit id="c2929c645da85b138bef1656c13169d0ec045e7d" translate="yes" xml:space="preserve">
          <source>You intend to modify the argument as a side effect of the function. In this case it &lt;em&gt;never makes sense&lt;/em&gt; to have a default argument. The only exception is when you're abusing the argument list to have function attributes, e.g. &lt;code&gt;cache={}&lt;/code&gt;, and you wouldn't be expected to call the function with an actual argument at all.</source>
          <target state="translated">您打算修改参数作为函数的副作用。 在这种情况下， &lt;em&gt;没有&lt;/em&gt;默认参数是&lt;em&gt;没有意义的&lt;/em&gt; 。 唯一的例外是，当您滥用参数列表以具有函数属性时，例如 &lt;code&gt;cache={}&lt;/code&gt; ，根本就不会期望使用实际参数来调用函数。</target>
        </trans-unit>
        <trans-unit id="17d9e231f7ae8537e606b6c0973a016f0c3b9581" translate="yes" xml:space="preserve">
          <source>You intend to modify the argument for use inside the function, but didn't expect the modification to be viewable outside of the function. In that case you need to make a &lt;em&gt;copy&lt;/em&gt; of the argument, whether it was the default or not! Python is not a call-by-value language so it doesn't make the copy for you, you need to be explicit about it.</source>
          <target state="translated">您打算修改在函数内部使用的参数，但是并不希望修改在函数外部可见。 在这种情况下，无论是否为默认值，都需要&lt;em&gt;复制&lt;/em&gt;该参数！ Python不是一种按值调用的语言，因此它不能为您创建副本，您需要对其进行明确说明。</target>
        </trans-unit>
        <trans-unit id="a6ced87465fcf1eeb8fdd29b614471918519675e" translate="yes" xml:space="preserve">
          <source>Your example is a good one of a case where Python newcomers will be surprised and bitten.  But I'd argue that if we &quot;fixed&quot; this, then that would only create a different situation where they'd be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they're writing.</source>
          <target state="translated">你的例子是一个很好的例子,说明Python新手会被吓一跳,被咬了一口。但我认为,如果我们 &quot;固定 &quot;了这一点,那只会造成另一种情况,那就是他们反而会被咬,而且这种情况会更不直观。此外,在处理可变变量时总是这样;你总是会遇到这样的情况,有人可能会根据自己写的代码的不同,直觉上期望有一种或相反的行为。</target>
        </trans-unit>
        <trans-unit id="27311373d31b73eb41d1e0b30e06efc32dc97a21" translate="yes" xml:space="preserve">
          <source>Your original &lt;code&gt;foo&lt;/code&gt;, with a default argument, shouldn't be modifying &lt;code&gt;a&lt;/code&gt; whether it was explicitly passed in or got the default value. Your code should leave mutable arguments alone unless it is clear from the context/name/documentation that the arguments are supposed to be modified. Using mutable values passed in as arguments as local temporaries is an extremely bad idea, whether we're in Python or not and whether there are default arguments involved or not.</source>
          <target state="translated">您的原始 &lt;code&gt;foo&lt;/code&gt; （带有默认参数）不应修改是否已显式传入或获取了默认值。 除非上下文/名称/文档中明确指出应该修改自变量，否则您的代码应仅保留可变自变量。 将传入的可变值作为参数用作本地临时对象是一个极坏的主意，无论我们是否使用Python，是否涉及默认参数。</target>
        </trans-unit>
        <trans-unit id="a47c48016c7bd5e01546ccb1b762c78b706d5abe" translate="yes" xml:space="preserve">
          <source>[] is an object, so python pass the reference of [] to &lt;code&gt;a&lt;/code&gt;, i.e., &lt;code&gt;a&lt;/code&gt; is only a pointer to [] which lies in memory as an object. There is only one copy of [] with, however, many references to it. For the first foo(), the list [] is changed to &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; by append method. But Note that there is only one copy of the list object and this object now becomes &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt;. When running the second foo(), what effbot webpage says (items is not evaluated any more) is wrong. &lt;code&gt;a&lt;/code&gt; is evaluated to be the list object, although now the content of the object is &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt;. This is the effect of passing by reference! The result of foo(3) can be easily derived in the same way.</source>
          <target state="translated">[]是一个对象，因此python将[]的引用传递给 &lt;code&gt;a&lt;/code&gt; ，即， &lt;code&gt;a&lt;/code&gt; 只是指向[]的指针，该指针作为对象位于内存中。 []只有一个副本，但是有很多引用。 对于第一个foo（），通过append方法将列表[]更改为&lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; 。 但是请注意，列表对象只有一个副本，该对象现在变为&lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; 。 当运行第二个foo（）时，effbot网页上显示的内容（不再评估项目）是错误的。 尽管现在对象的内容为&lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; ，但是 &lt;code&gt;a&lt;/code&gt; 被评估为列表对象。 这是通过引用传递的效果！ foo（3）的结果可以用相同的方式轻松得出。</target>
        </trans-unit>
        <trans-unit id="811a1b05ff4f47b946f5851e4e0919d50dfa1cfc" translate="yes" xml:space="preserve">
          <source>and running it with &lt;code&gt;python example.py&lt;/code&gt;:</source>
          <target state="translated">并使用 &lt;code&gt;python example.py&lt;/code&gt; 运行它：</target>
        </trans-unit>
        <trans-unit id="049874c49f0ace21f9f13dd31c57abc695140bba" translate="yes" xml:space="preserve">
          <source>as you'll notice, &lt;code&gt;input()&lt;/code&gt; is called before the process of building the function and binding it to the name &lt;code&gt;bar&lt;/code&gt; is made.</source>
          <target state="translated">您会注意到，在构建函数并将其绑定到名称 &lt;code&gt;bar&lt;/code&gt; 的过程完成之前，将调用 &lt;code&gt;input()&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3375274202e5815d3135c4440713525187e9f33a" translate="yes" xml:space="preserve">
          <source>everything is passed by reference</source>
          <target state="translated">万物皆传</target>
        </trans-unit>
        <trans-unit id="127ad2d11d264ef1bc3b7c9367a87c065c2e20d2" translate="yes" xml:space="preserve">
          <source>except for the case of explicitly calling func(None, None), which we'll ignore.</source>
          <target state="translated">除了显式调用func(None,None)的情况,我们将忽略不计。</target>
        </trans-unit>
        <trans-unit id="fc5c678a45bcac56840b3c908642740f5ede6d3d" translate="yes" xml:space="preserve">
          <source>function (class etc.) declaration is executed only once, creating all default value objects</source>
          <target state="translated">函数(类等)声明只执行一次,创建所有的缺省值对象</target>
        </trans-unit>
        <trans-unit id="71759c14baa0f1b45b053d0754f9b76a716165c8" translate="yes" xml:space="preserve">
          <source>instantiate a new list on function definition and not on invocation?
It's just like you're asking &quot;if the user doesn't provide the argument then &lt;em&gt;instantiate&lt;/em&gt; a new list and use it as if it was produced by the caller&quot;.
I think this is ambiguous instead:</source>
          <target state="translated">在函数定义而不是调用上实例化一个新列表？ 就像您要问&amp;ldquo;如果用户不提供参数，则&lt;em&gt;实例化&lt;/em&gt;一个新列表并像调用方产生的那样使用它&amp;rdquo;。 我认为这是模棱两可的：</target>
        </trans-unit>
        <trans-unit id="9d29cbd7a4d1e405b35c263d8e5d5507492f015a" translate="yes" xml:space="preserve">
          <source>is almost exactly equivalent to this:</source>
          <target state="translated">几乎完全等同于此。</target>
        </trans-unit>
        <trans-unit id="d94296d98f302fe54eca1ccc91cf45236ffa89e2" translate="yes" xml:space="preserve">
          <source>isn't internally equivalent to this:</source>
          <target state="translated">并不是内部等同于此。</target>
        </trans-unit>
        <trans-unit id="3e5690a3202553a2f619db51e48332229bfe602f" translate="yes" xml:space="preserve">
          <source>it is entirely consistent to hold to both of the features above and still make another point:</source>
          <target state="translated">坚持上述两个特点,还能提出另一个观点是完全一致的。</target>
        </trans-unit>
        <trans-unit id="39fcd29280818de6a833974667212de642dcf2a7" translate="yes" xml:space="preserve">
          <source>observing that the id is the same each time the list is referenced,</source>
          <target state="translated">观察到每次引用列表的id都是一样的。</target>
        </trans-unit>
        <trans-unit id="d8e7da304415824d87e81f7b39df6675059d9a54" translate="yes" xml:space="preserve">
          <source>observing that the list stays changed when the function that uses it is called a second time,</source>
          <target state="translated">观察到当使用该列表的函数被第二次调用时,该列表保持不变。</target>
        </trans-unit>
        <trans-unit id="b573226ee49e1a1dd733f88915532ed8bd52e8f9" translate="yes" xml:space="preserve">
          <source>observing the order in which the output is printed from the source (which I conveniently numbered for you):</source>
          <target state="translated">观察从源头打印输出的顺序(我方便地给你编号)。</target>
        </trans-unit>
        <trans-unit id="04c9c0f5ccf58a5d42c14519b24d6f2145c58d5f" translate="yes" xml:space="preserve">
          <source>prints the following</source>
          <target state="translated">打印以下内容</target>
        </trans-unit>
        <trans-unit id="db480f941abc083354113eeeff05d261f2c92991" translate="yes" xml:space="preserve">
          <source>seeing that the list is created before the function has finished compiling to a function object,</source>
          <target state="translated">看到列表是在函数完成编译到函数对象之前创建的。</target>
        </trans-unit>
        <trans-unit id="7fae1298345bf082e2261fee60080aa9d63fe920" translate="yes" xml:space="preserve">
          <source>then if default parameters were bound at function execution rather than function declaration then I would be astonished (in a very bad way) to discover that fruits had been changed.  This would be more astonishing IMO than discovering that your &lt;code&gt;foo&lt;/code&gt; function above was mutating the list.</source>
          <target state="translated">然后，如果默认参数是在函数执行时绑定的，而不是在函数声明时绑定的，那么我会以一种非常糟糕的方式惊讶地发现结果已经改变。 与发现上面的 &lt;code&gt;foo&lt;/code&gt; 函数正在使列表发生变化相比，这将使IMO更加令人惊讶。</target>
        </trans-unit>
        <trans-unit id="f16bec6158470b4bee129a9e6c86214a2e496fdf" translate="yes" xml:space="preserve">
          <source>user, do you want &lt;code&gt;a&lt;/code&gt; to default to the datetime corresponding to when you're defining or executing &lt;code&gt;x&lt;/code&gt;?
In this case, as in the previous one, I'll keep the same behaviour as if the default argument &quot;assignment&quot; was the first instruction of the function (&lt;code&gt;datetime.now()&lt;/code&gt; called on function invocation).
On the other hand, if the user wanted the definition-time mapping he could write:</source>
          <target state="translated">用户，是否要将 &lt;code&gt;a&lt;/code&gt; 默认设置为定义或执行 &lt;code&gt;x&lt;/code&gt; 时的日期时间？ 在这种情况下，就像上一个例子一样，我将保持相同的行为，就像默认参数&amp;ldquo;赋值&amp;rdquo;是该函数的第一条指令 &lt;code&gt;datetime.now()&lt;/code&gt; 在函数调用上调用datetime.now（） ）一样。 另一方面，如果用户想要定义时间映射，则可以编写：</target>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="translated">with</target>
        </trans-unit>
        <trans-unit id="06e3de5b5b2d499fee4d0c87a0745254a4a566cb" translate="yes" xml:space="preserve">
          <source>you expect to get a &lt;strong&gt;new&lt;/strong&gt; list referenced by &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">您希望获得一个由引用的&lt;strong&gt;新&lt;/strong&gt;列表。</target>
        </trans-unit>
        <trans-unit id="8c194c14b318f40b680d2378e5d49d583177218c" translate="yes" xml:space="preserve">
          <source>“Least Astonishment” and the Mutable Default Argument</source>
          <target state="translated">&quot;最低限度的惊讶 &quot;和不可更改的默认论据</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
