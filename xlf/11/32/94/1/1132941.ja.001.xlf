<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1132941">
    <body>
      <group id="1132941">
        <trans-unit id="b69b153d9b8b6ca5cc39aae8241344dc670096ea" translate="yes" xml:space="preserve">
          <source>&quot;All functions with this problem &lt;strong&gt;suffer also from similar side effect problem on the actual parameter&lt;/strong&gt;,&quot;</source>
          <target state="translated">「この問題のあるすべての関数は&lt;strong&gt;、実際のパラメーターに関する同様の副作用の問題も抱えています&lt;/strong&gt; 。」</target>
        </trans-unit>
        <trans-unit id="626c5410f93ad070237bab8024217f1cdd086983" translate="yes" xml:space="preserve">
          <source>... we assign the argument &lt;code&gt;a&lt;/code&gt; to an &lt;em&gt;unnamed&lt;/em&gt; list, if the caller does not pass the value of a.</source>
          <target state="translated">...呼び出し元がaの値を渡さない場合、引数 &lt;code&gt;a&lt;/code&gt; を&lt;em&gt;名前のない&lt;/em&gt;リストに割り当てます。</target>
        </trans-unit>
        <trans-unit id="d6ae47a54ed3aae922aa9b755c46be05126dc9cc" translate="yes" xml:space="preserve">
          <source>...all variables found outside of the innermost scope are
  read-only (&lt;strong&gt;&lt;em&gt;an attempt to write to such a variable will simply create a
  new local variable in the innermost scope, leaving the identically
  named outer variable unchanged&lt;/em&gt;&lt;/strong&gt;).</source>
          <target state="translated">...最も内側のスコープの外側にあるすべての変数は読み取り専用です（ &lt;strong&gt;&lt;em&gt;このような変数に書き込もうとすると、最も内側のスコープに新しいローカル変数が作成され、同じ名前の外側の変数は変更されません&lt;/em&gt;&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ce4a03df48f71c59cb88d1614e04c355fe07eb41" translate="yes" xml:space="preserve">
          <source>1)  The so-called problem of &quot;Mutable Default Argument&quot; is in general a special example demonstrating that:</source>
          <target state="translated">1)いわゆる「Mutable Default Argument」の問題は、一般的にはそれを実証する特殊な例である。</target>
        </trans-unit>
        <trans-unit id="7ae49a8787afe33029393476223d3e6b04a350d7" translate="yes" xml:space="preserve">
          <source>3) In some cases is &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;the mutable behavior of default parameters useful&lt;/a&gt;.</source>
          <target state="translated">3）場合によっては&lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;、デフォルトパラメータの変更可能な動作が役立ち&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="349e3dc6e53ca45e7b264f3f4ece59155e2a0d64" translate="yes" xml:space="preserve">
          <source>5 points in defense of Python</source>
          <target state="translated">Pythonを守る5つのポイント</target>
        </trans-unit>
        <trans-unit id="5619d3a6ff41fedee09fe44cfec87d091658e509" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;1</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt;1</target>
        </trans-unit>
        <trans-unit id="f9a7d25963aa0148809943888747c7bfdbad1397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;2</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt;2</target>
        </trans-unit>
        <trans-unit id="f2848d4bf5368cd6cc2a23c96bcb460686851bd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[]&lt;/code&gt; is an object, so is &lt;code&gt;None&lt;/code&gt; (the former is mutable while the latter is immutable. But the mutability has nothing to do with the question). None is somewhere in the space but we know it's there and there is only one copy of None there. So every time foo is invoked, items is evaluated (as opposed to some answer that it is only evaluated once) to be None, to be clear, the reference (or the address) of None. Then in the foo, item is changed to [], i.e., points to another object which has a different address.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; はオブジェクトなので、 &lt;code&gt;None&lt;/code&gt; もそうです（前者は変更可能で、後者は不変です。ただし、変更可能性は質問とは関係ありません）。 スペースのどこにも存在しないものがありますが、存在することはわかっており、そこにはNoneのコピーが1つしかありません。 したがって、fooが呼び出されるたびに、項目は（1回しか評価されないといういくつかの回答とは対照的に）Noneであると明確にされ、Noneの参照（またはアドレス）であると評価されます。 次に、fooでitemが[]に変更されます。つまり、アドレスが異なる別のオブジェクトを指します。</target>
        </trans-unit>
        <trans-unit id="0b51475de74c8a0af3e8ac61016a0b03493b9c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; doesn't change - every assignment call creates new int object - new object is printed</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; は変更されません-割り当てを呼び出すたびに新しいintオブジェクトが作成されます-新しいオブジェクトが出力されます</target>
        </trans-unit>
        <trans-unit id="c91d4e033dfa8facf99b416bc8eb05efa39a8648" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; doesn't change - new array is build from default value and printed</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; は変更されません-新しい配列はデフォルト値から構築され、出力されます</target>
        </trans-unit>
        <trans-unit id="99868d483227e38115a490908f9eb6410e764c96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; changes - operation is performed on same object - and it is printed</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; の変更-操作は同じオブジェクトに対して実行され、出力されます</target>
        </trans-unit>
        <trans-unit id="1dce96d08fb23e6dd9bf8c83e0ce03a0c31931c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Astonished?&lt;/em&gt; The value inside the object changes! Consecutive calls to the function will now simply append to that embedded &lt;code&gt;list&lt;/code&gt; object:</source>
          <target state="translated">&lt;em&gt;びっくりした？&lt;/em&gt; オブジェクト内の値が変化します！ 関数を連続して呼び出すと、埋め込み &lt;code&gt;list&lt;/code&gt; オブジェクトに追加されるだけです。</target>
        </trans-unit>
        <trans-unit id="9a5e006676bccb5e949d65e43cc04bfdb3e0f5c0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This is not a design flaw&lt;/em&gt;. Anyone who trips over this is doing something wrong.</source>
          <target state="translated">&lt;em&gt;これは設計上の欠陥ではありません&lt;/em&gt; 。 これをトリップする人は誰でも何か間違ったことをしています。</target>
        </trans-unit>
        <trans-unit id="0bb5707416517e01b1b19796f5b4d8047f7be81f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(1)&lt;/strong&gt; is described in the Python &lt;a href=&quot;http://docs.python.org/tutorial/classes.html&quot;&gt;tutorial on classes&lt;/a&gt;. In an attempt to assign a value to a read-only class attribute:</source>
          <target state="translated">&lt;strong&gt;（1）&lt;/strong&gt;は、Python &lt;a href=&quot;http://docs.python.org/tutorial/classes.html&quot;&gt;チュートリアルのクラスで&lt;/a&gt;説明されています 。 読み取り専用のクラス属性に値を割り当てようとして：</target>
        </trans-unit>
        <trans-unit id="1e830734a74d3ffb326fa9a33d2d932c606c6e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.パフォーマンス&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1c12447cabd52b525bef97e580f6be054679aad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Forcing bound parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.バインドされたパラメーターの強制&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23662664198844161cfe301172c065fd31a550b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Introspection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3.内省&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="329d395d793f53ccf44090cd1ed8d91c54ccbc68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Consistency&lt;/strong&gt;: Python &lt;em&gt;always&lt;/em&gt; passes objects, not names.
The default parameter is, obviously, part of the function 
heading (not the function body). It therefore ought to be evaluated
at module load time (and only at module load time, unless nested), not
at function call time.</source>
          <target state="translated">&lt;strong&gt;一貫性&lt;/strong&gt; ：Pythonは&lt;em&gt;常に&lt;/em&gt;名前ではなくオブジェクトを渡します。 デフォルトのパラメータは、明らかに関数の見出しの一部です（関数の本体ではありません）。 したがって、関数の呼び出し時ではなく、モジュールのロード時に（ネストされていない限り、モジュールのロード時にのみ）評価する必要があります。</target>
        </trans-unit>
        <trans-unit id="cf88699ee467bc4d13c8c871f2752ff94d964b35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default parameter values are evaluated from left to right when the function definition is executed.&lt;/strong&gt; This means that the expression is evaluated once, when the function is defined, and that the same &amp;ldquo;pre-computed&amp;rdquo; value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use &lt;code&gt;None&lt;/code&gt; as the default, and explicitly test for it in the body of the function, e.g.:</source>
          <target state="translated">&lt;strong&gt;デフォルトのパラメーター値は、関数定義の実行時に左から右に評価されます。&lt;/strong&gt; これは、関数が定義されたときに式が1回評価され、呼び出しごとに同じ「事前計算された」値が使用されることを意味します。 これは、デフォルトパラメータがリストやディクショナリなどの可変オブジェクトである場合を理解するために特に重要です。関数がオブジェクトを変更する場合（たとえば、アイテムをリストに追加することにより）、デフォルト値は事実上変更されます。 これは通常、意図したものではありません。 これを回避する方法は、 &lt;code&gt;None&lt;/code&gt; をデフォルトとして使用し、関数の本体で明示的にテストすることです。例：</target>
        </trans-unit>
        <trans-unit id="539d5ec10b781d448886afa96eab4c325719e096" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Edit&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="d7ce856e37c4d17dcd955af410f64cbfd4b44efb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Meta-learning&lt;/strong&gt;: Falling into the trap is actually a very
helpful moment (at least if you are a reflective learner),
because you will subsequently better understand the point 
&quot;Consistency&quot; above and that will
teach you a great deal about Python.</source>
          <target state="translated">&lt;strong&gt;メタ学習&lt;/strong&gt; ：トラップに陥るのは実際には非常に役立つ瞬間です（少なくとも反射的な学習者の場合）。その後、上記の「一貫性」のポイントをよりよく理解し、Pythonについて多くを&lt;strong&gt;学ぶ&lt;/strong&gt;ことができるからです。</target>
        </trans-unit>
        <trans-unit id="2c97178ae1f0df97cdd3aaefd09767743c8eb65b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preferred Method&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;推奨される方法&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="e76f2bbaaca5d9222981a5a9ed9effda9259956d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simplicity&lt;/strong&gt;: The behavior is simple in the following sense:
Most people fall into this trap only once, not several times.</source>
          <target state="translated">&lt;strong&gt;単純さ&lt;/strong&gt; ：この動作は、次の意味で単純です。ほとんどの人はこのトラップに一度だけ陥り、何度も陥ることはありません。</target>
        </trans-unit>
        <trans-unit id="d8e5d785db266e5750b7b9c674b8350975a43b24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution&lt;/strong&gt;:  a &lt;strong&gt;copy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;解決策&lt;/strong&gt; ： &lt;strong&gt;コピー&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37f9748bcb10eff54719d247d7d6981eb44d0507" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sufficient documentation&lt;/strong&gt;: In the most basic Python documentation,
the tutorial, the issue is loudly announced as
an &lt;strong&gt;&quot;Important warning&quot;&lt;/strong&gt; in the &lt;em&gt;first&lt;/em&gt; subsection of Section
&lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#default-argument-values&quot;&gt;&quot;More on Defining Functions&quot;&lt;/a&gt;.
The warning even uses boldface,
which is rarely applied outside of headings.
RTFM: Read the fine manual.</source>
          <target state="translated">&lt;strong&gt;十分なドキュメント&lt;/strong&gt; ：最も基本的なPythonのドキュメントであるチュートリアルでは、 &lt;strong&gt;「&lt;/strong&gt; &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#default-argument-values&quot;&gt;関数の定義の詳細」の&lt;/a&gt; &lt;em&gt;最初の&lt;/em&gt;サブセクションで、問題が&lt;strong&gt;「重要な警告」&lt;/strong&gt;として大声で発表されています。 警告は太字を使用していますが、これは見出しの外側にはほとんど適用されません。 RTFM：細かいマニュアルを読んでください。</target>
        </trans-unit>
        <trans-unit id="5e1364752e34f5d31f57fbb793918340fe194bee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usefulness&lt;/strong&gt;: As Frederik Lundh points out in his explanation
of &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;&quot;Default Parameter Values in Python&quot;&lt;/a&gt;, the
current behavior can be quite useful for advanced programming.
(Use sparingly.)</source>
          <target state="translated">&lt;strong&gt;有用性&lt;/strong&gt; ：Frederik Lundhが&lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;&quot;Pythonのデフォルトパラメータ値&quot;の&lt;/a&gt;説明で指摘しているように、現在の動作は高度なプログラミングに非常に役立ちます。 （控えめに使用してください。）</target>
        </trans-unit>
        <trans-unit id="294df7a72d2c1681571db14e9616ce4b1526495e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Wrong Method (probably...)&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;間違った方法（おそらく...）&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="82a5f8350abc0dbeea17f36fef8010fcc85d54f4" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;*&lt;/sup&gt; To verify that Python evaluates the default arguments during compilation of the function, try executing the following:</source>
          <target state="translated">&lt;sup&gt;*&lt;/sup&gt;関数のコンパイル中にPythonがデフォルトの引数を評価することを確認するには、次のコマンドを実行してみます。</target>
        </trans-unit>
        <trans-unit id="bb413fc5e883d792d1ef3763d765a7965fb2896f" translate="yes" xml:space="preserve">
          <source>====== No. 2 ========</source>
          <target state="translated">第2号 ================================第2号</target>
        </trans-unit>
        <trans-unit id="69abcbfba6763da9ac43abb483ce88455e698517" translate="yes" xml:space="preserve">
          <source>====== No. 3 =======</source>
          <target state="translated">第3号 ========================================第3号 ================================</target>
        </trans-unit>
        <trans-unit id="b635b4f551391b730421190ef18f36b5a2349cd2" translate="yes" xml:space="preserve">
          <source>A brief introduction. First, there are two type of data types in python, one is simple elementary data type, like numbers, and another data type is objects. Second, when passing data to parameters, python pass elementary data type by value, i.e., make a local copy of the value to a local variable, but pass object by reference, i.e., pointers to the object.</source>
          <target state="translated">簡単に紹介します。まず、pythonには2種類のデータ型があり、1つは数字のような単純な素データ型で、もう1つはオブジェクト型です。第二に、パラメータにデータを渡す場合、pythonでは素データ型は値で渡しますが、オブジェクトは参照で渡します。</target>
        </trans-unit>
        <trans-unit id="3241c6873d2d65a534f9b317f8e6387aba7f1c09" translate="yes" xml:space="preserve">
          <source>A manager of mine once had his first encounter with this feature, and called it &quot;a dramatic design flaw&quot; of the language. I replied that the behavior had an underlying explanation, and it is indeed very puzzling and unexpected if you don't understand the internals. However, I was not able to answer (to myself) the following question: what is the reason for binding the default argument at function definition, and not at function execution? I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs?)</source>
          <target state="translated">私のマネージャーがこの機能に初めて遭遇したことがあり、それを言語の「劇的な設計上の欠陥」と呼んでいました。私は、その動作には根本的な説明があり、確かに内部を理解していないと非常に不可解で、予想外のことが起こると回答しました。しかし、「関数定義時にデフォルト引数をバインドし、関数実行時ではなく関数定義時にバインドする理由は何か?経験豊富な挙動に実用性があるのか疑問です(本当に誰がC言語でバグを繁殖させずに静的変数を使っていたのでしょうか?</target>
        </trans-unit>
        <trans-unit id="b690fd135a267cbcdaf75de80b96af3baa5767c7" translate="yes" xml:space="preserve">
          <source>A simple workaround using None</source>
          <target state="translated">None を使用した簡単な回避策</target>
        </trans-unit>
        <trans-unit id="bdd7db67e420ecc9dcbd543e9f887304309b4542" translate="yes" xml:space="preserve">
          <source>A useful trick is to bind parameters of a lambda to the &lt;em&gt;current&lt;/em&gt; binding of a variable when the lambda is created.  For example:</source>
          <target state="translated">便利なトリックは、ラムダの作成時に、ラムダのパラメーターを変数の&lt;em&gt;現在の&lt;/em&gt;バインディングにバインドすることです。 例えば：</target>
        </trans-unit>
        <trans-unit id="66dcf0d939788f48ade0f8205215ced808c313bc" translate="yes" xml:space="preserve">
          <source>Actually, this is not a design flaw, and it is not because of internals, or performance.</source>
          <target state="translated">実はこれは設計上の欠陥ではなく、内部の性能が原因ではありません。</target>
        </trans-unit>
        <trans-unit id="995d1d076d3d58278102dc33655d7de6f9e9da69" translate="yes" xml:space="preserve">
          <source>Admitting the above two points, let's explain what happened to the python code. It's only because of passing by reference for objects, but has nothing to do with mutable/immutable, or arguably the fact that &quot;def&quot; statement is executed only once when it is defined.</source>
          <target state="translated">上記2点を認めた上で、Pythonのコードがどうなったかを説明しましょう。これはオブジェクトの参照渡しのせいだけで、mutableimmutableとは関係ありませんし、def文が定義されているときに一度だけ実行されるというのも、議論の余地があります。</target>
        </trans-unit>
        <trans-unit id="12e60dab7722d48c3d6b49bcd3fb84f98b18afcc" translate="yes" xml:space="preserve">
          <source>After Python executes this definition it will take any default parameters specified (&lt;code&gt;a = []&lt;/code&gt; here) and &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy&quot;&gt;cram them in the &lt;code&gt;__defaults__&lt;/code&gt; attribute for the function object&lt;/a&gt; (relevant section: Callables):</source>
          <target state="translated">Pythonがこの定義を実行した後 &lt;code&gt;a = []&lt;/code&gt; 指定されたデフォルトのパラメーター（ここではa = [] ）を&lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy&quot;&gt; &lt;code&gt;__defaults__&lt;/code&gt; 、関数オブジェクトの__defaults__属性にそれらを詰め込みます&lt;/a&gt; （関連セクション：呼び出し可能）：</target>
        </trans-unit>
        <trans-unit id="00ee3bf105e662d4c817e2a1dc2ea4cb63f26aa2" translate="yes" xml:space="preserve">
          <source>All with the power of introspection!</source>
          <target state="translated">すべては内省の力で!</target>
        </trans-unit>
        <trans-unit id="8511aa6f9e2aee5234b37fe72ed01ccf13a1f8e1" translate="yes" xml:space="preserve">
          <source>Already busy topic, but from what I read here, the following helped me realizing how it's working internally:</source>
          <target state="translated">すでに忙しい話題ですが、ここを読んでいると、以下のようなことがわかり、社内での働き方を実感できました。</target>
        </trans-unit>
        <trans-unit id="edef5af058c46851da7320ae99d9fe37689e0b06" translate="yes" xml:space="preserve">
          <source>An absolutely safe solution is to &lt;strong&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;code&gt;deepcopy&lt;/code&gt;&lt;/strong&gt; the input object first and then to do whatever with the copy.</source>
          <target state="translated">絶対に安全なソリューションは、最初に入力オブジェクトを&lt;strong&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/strong&gt;または&lt;strong&gt; &lt;code&gt;deepcopy&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;コピー&lt;/strong&gt;してから、コピーで何でも実行することです。</target>
        </trans-unit>
        <trans-unit id="09883d93fd6b6978404b7d03e6adc34d60b2d91d" translate="yes" xml:space="preserve">
          <source>Anyone tinkering with Python long enough has been bitten (or torn to pieces) by the following issue:</source>
          <target state="translated">Pythonを長くいじっていた人は、次の問題で噛み付いてしまった(ボロボロになってしまった)ことがあります。</target>
        </trans-unit>
        <trans-unit id="7870ab2e57db73f3c412a09b43f15db1bdd86aa3" translate="yes" xml:space="preserve">
          <source>As others have extensively commented, the list parameter is bound to the function when it is defined as opposed to when it is executed.  Because lists and dictionaries are mutable, any alteration to this parameter will affect other calls to this function.  As a result, subsequent calls to the function will receive this shared list which may have been altered by any other calls to the function.  Worse yet, two parameters are using this function's shared parameter at the same time oblivious to the changes made by the other.</source>
          <target state="translated">他の人が広範囲にコメントしているように、リスト・パラメータは関数が実行されたときとは対照的に、定義されたときに関数にバインドされます。リストや辞書は突然変異可能なので、このパラメータを変更すると、他の関数の呼び出しにも影響を与えます。その結果、後続の関数呼び出しは、他の関数呼び出しによって変更された可能性のあるこの共有リストを受け取ることになります。さらに悪いことに、2つのパラメータが同時にこの関数の共有パラメータを使用している場合、もう1つのパラメータの変更に気づかないことになります。</target>
        </trans-unit>
        <trans-unit id="32ec561bfb975a7dfa873e1e6e2af0f1d887859e" translate="yes" xml:space="preserve">
          <source>As soon as you get to think into this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of &quot;member data&quot; and therefore their state may change from one call to the other - exactly as in any other object.</source>
          <target state="translated">関数はその定義に基づいて評価されるオブジェクトであり、デフォルトのパラメータは一種の「メンバーデータ」であり、その状態は他のオブジェクトと同じように呼び出しごとに変化することがあります。</target>
        </trans-unit>
        <trans-unit id="1bfc5029b5667353a593e8232b61d516f6f5fa28" translate="yes" xml:space="preserve">
          <source>As the &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;tutorial section on control flow&lt;/a&gt; says:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;制御フローのチュートリアルセクションで&lt;/a&gt;は、次のように述べています。</target>
        </trans-unit>
        <trans-unit id="8b63ee9af6651f22cd0d28d64f81656efa3a8b0b" translate="yes" xml:space="preserve">
          <source>As you can see, there &lt;em&gt;is&lt;/em&gt; a performance benefit when using immutable default arguments.  This can make a difference if it's a frequently called function or the default argument takes a long time to construct.  Also, bear in mind that Python isn't C.  In C you have constants that are pretty much free.  In Python you don't have this benefit.</source>
          <target state="translated">ご覧のとおり、不変のデフォルト引数を使用するとパフォーマンスが向上します。 これは、頻繁に呼び出される関数である場合、またはデフォルトの引数の作成に時間がかかる場合に、違いを生む可能性があります。 また、PythonはCではないことに注意してください。Cには、ほとんど自由な定数があります。 Pythonでは、この利点はありません。</target>
        </trans-unit>
        <trans-unit id="0af2a822a9873fb57c1a705017e412da7cf6eae6" translate="yes" xml:space="preserve">
          <source>At any time, if the caller doesn't tell us what &lt;code&gt;a&lt;/code&gt; is, we reuse &lt;code&gt;pavlo&lt;/code&gt;.</source>
          <target state="translated">いつでも、呼び出し元が &lt;code&gt;a&lt;/code&gt; が何であるかを教えてくれない場合は、 &lt;code&gt;pavlo&lt;/code&gt; を再利用します 。</target>
        </trans-unit>
        <trans-unit id="8a9041c4d4930adfbd1e5a18d381ab82f682a692" translate="yes" xml:space="preserve">
          <source>Baczek made an interesting example. Together with most of your comments and Utaal's in particular, I elaborated further:</source>
          <target state="translated">Baczekは興味深い例を作った。あなたのコメントのほとんどと、特にユタルのコメントと一緒に、私はさらに詳しく説明しました。</target>
        </trans-unit>
        <trans-unit id="80f28b6534c5364d872c03c837c8604f92ca736d" translate="yes" xml:space="preserve">
          <source>But this is why the usual instruction to new users is to create their default arguments like this instead:</source>
          <target state="translated">しかし、だからこそ、新しいユーザーへの通常の指示は、代わりにこのようなデフォルトの引数を作成することです。</target>
        </trans-unit>
        <trans-unit id="ec8e7d1b53f4a45c292a101f3cc7d8154605e8fd" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;foo()&lt;/code&gt; again modifies &lt;code&gt;pavlo&lt;/code&gt; again:</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; を再度呼び出すと、 &lt;code&gt;pavlo&lt;/code&gt; が再び変更されます。</target>
        </trans-unit>
        <trans-unit id="7f12be39dc6279d3fabca7bbf354112e20d8c45e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;foo&lt;/code&gt; without overriding a default uses that default's value from &lt;code&gt;foo.func_defs&lt;/code&gt;. In this case, &lt;code&gt;foo.func_defs[0]&lt;/code&gt; is used for &lt;code&gt;a&lt;/code&gt; within function object's code scope. Changes to &lt;code&gt;a&lt;/code&gt; change &lt;code&gt;foo.func_defs[0]&lt;/code&gt;, which is part of the &lt;code&gt;foo&lt;/code&gt; object and persists between execution of the code in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">デフォルトを上書きせずに &lt;code&gt;foo&lt;/code&gt; を呼び出すと、 &lt;code&gt;foo.func_defs&lt;/code&gt; からのデフォルトの値が使用されます。 この場合、 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; が関数オブジェクトのコードスコープ内で使用されます。 変更 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; へ &lt;code&gt;a&lt;/code&gt; 変更。これは &lt;code&gt;foo&lt;/code&gt; オブジェクトの一部であり、 foo内のコードの実行間で持続します。</target>
        </trans-unit>
        <trans-unit id="2bbb1f97b956cffee0de7b85c6ac5416fc49a2bd" translate="yes" xml:space="preserve">
          <source>Compare this:</source>
          <target state="translated">これを比較してみてください。</target>
        </trans-unit>
        <trans-unit id="d0b35f2e80cf4078de3821051d01800d2a02ba30" translate="yes" xml:space="preserve">
          <source>Conclusion:</source>
          <target state="translated">Conclusion:</target>
        </trans-unit>
        <trans-unit id="89101438b832bbb4fe2957ecf228b15803627679" translate="yes" xml:space="preserve">
          <source>Consider the code:</source>
          <target state="translated">コードを考えてみてください。</target>
        </trans-unit>
        <trans-unit id="50ce20ee2ced0781e4776bbf85a113d06f364543" translate="yes" xml:space="preserve">
          <source>Consistency already says &quot;at definition&quot;: everything else of &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; is best evaluated at definition as well. Delaying parts of it would be the astonishing choice.</source>
          <target state="translated">一貫性はすでに「定義時」と言っています： &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; 他のすべて：定義時にも評価されます。 それの一部を遅らせることは驚くべき選択でしょう。</target>
        </trans-unit>
        <trans-unit id="5e80e76fecb25c751bc0072a050074d6bf8b3a02" translate="yes" xml:space="preserve">
          <source>Default arguments get evaluated at the time the function is compiled into a function object. When used by the function, multiple times by that function, they are and remain the same object.</source>
          <target state="translated">デフォルトの引数は、関数が関数オブジェクトにコンパイルされたときに評価されます。関数によって複数回使用された場合、それらは同じオブジェクトであり、同じオブジェクトのままです。</target>
        </trans-unit>
        <trans-unit id="0a13adb02282a5b13ea712ef898af3b40b3c9925" translate="yes" xml:space="preserve">
          <source>Defining a function affects two scopes: the defining scope &lt;em&gt;containing&lt;/em&gt; the function, and the execution  scope &lt;em&gt;contained by&lt;/em&gt; the function. While it is pretty clear how blocks map to scopes, the question is where &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; belongs to:</source>
          <target state="translated">関数の定義は2つのスコープに影響します。関数&lt;em&gt;を含む&lt;/em&gt;定義スコープと、関数に&lt;em&gt;含まれる&lt;/em&gt;実行スコープです。 ブロックがどのようにスコープにマップされるかは明らかですが、問題は &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; がどこに属しているかです。</target>
        </trans-unit>
        <trans-unit id="722360c4795e6584aab950e4f9ab28bf53d453fe" translate="yes" xml:space="preserve">
          <source>Demonstration</source>
          <target state="translated">Demonstration</target>
        </trans-unit>
        <trans-unit id="0cf2dad6fd4f2a353fd61dd22952442419c00063" translate="yes" xml:space="preserve">
          <source>Does this violate the principle of &quot;Least Astonishment&quot;?</source>
          <target state="translated">これは「Least Astonishment」の原則に違反しているのでしょうか?</target>
        </trans-unit>
        <trans-unit id="87ae29dc1cc2a0f0b1d8ff4a04b54a9e84f78784" translate="yes" xml:space="preserve">
          <source>Doing the binding inside the function would mean that &lt;code&gt;x&lt;/code&gt; is effectively bound to the specified default when the function is called, not defined, something that would present a deep flaw: the &lt;code&gt;def&lt;/code&gt; line would be &quot;hybrid&quot; in the sense that part of the binding (of the function object) would happen at definition, and part (assignment of default parameters) at function invocation time.</source>
          <target state="translated">関数内でバインディングを行うと、関数が呼び出されたときに &lt;code&gt;x&lt;/code&gt; が指定されたデフォルトに効果的にバインドされ、定義されません。これは深い欠陥をもたらすものです &lt;code&gt;def&lt;/code&gt; 行は、バインディングの一部という意味で「ハイブリッド」になります。 （関数オブジェクトの）定義時に発生し、一部（デフォルトパラメータの割り当て）が関数の呼び出し時に発生します。</target>
        </trans-unit>
        <trans-unit id="a1bc1de19c4470f909f862dada03b7e62dff2905" translate="yes" xml:space="preserve">
          <source>Each button can hold a distinct callback function which will display different value of &lt;code&gt;i&lt;/code&gt;. I can provide an example to show this:</source>
          <target state="translated">各ボタンは、異なる &lt;code&gt;i&lt;/code&gt; の値を表示する個別のコールバック関数を保持できます。 これを示す例を提供できます。</target>
        </trans-unit>
        <trans-unit id="3535364419d36fc620e4f5493d86ed8c6d64572c" translate="yes" xml:space="preserve">
          <source>Equivalent code:</source>
          <target state="translated">コードに相当します。</target>
        </trans-unit>
        <trans-unit id="ff956d2a192938cf9d92d4c6a19f3ae8b72325fa" translate="yes" xml:space="preserve">
          <source>Every other answer explains why this is actually a nice and desired behavior, or why you shouldn't be needing this anyway. Mine is for those stubborn ones who want to exercise their right to bend the language to their will, not the other way around.</source>
          <target state="translated">他の答えは、なぜこれが実際には素敵で望ましい行動であるか、または、あなたはとにかくこれを必要としないべきである理由を説明しています。私のは、言語を自分の意志に合わせる権利を行使したい頑固な人のためのものです。</target>
        </trans-unit>
        <trans-unit id="0dd24b3cfa0f1397c657fd1c280dfe16bb9e3f42" translate="yes" xml:space="preserve">
          <source>Example problem for &lt;a href=&quot;https://stackoverflow.com/q/13484107/448474&quot;&gt;a similar SO question&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/13484107/448474&quot;&gt;同様のSO質問の&lt;/a&gt;問題の例</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="bb7c7223c0f7cca03529ae9f865e01923e18d2e1" translate="yes" xml:space="preserve">
          <source>From the above explanations, we can see that the &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;effbot&lt;/a&gt; webpage recommended in the accepted answer failed to give a relevant answer to this question. What is more, I think a point in the effbot webpage is wrong. I think the code regarding the UI.Button is correct:</source>
          <target state="translated">上記の説明から、承認された回答で推奨されている&lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;effbot&lt;/a&gt; Webページが、この質問に関連する回答を提供できなかったことがわかります。 さらに、私はeffbotウェブページのポイントが間違っていると思います。 UI.Buttonに関するコードは正しいと思います。</target>
        </trans-unit>
        <trans-unit id="ffce6790c5edcbed68ecf56b4ebcce15bf2962a7" translate="yes" xml:space="preserve">
          <source>Function After Execution:</source>
          <target state="translated">実行後の関数。</target>
        </trans-unit>
        <trans-unit id="c6a884852d8c2a2883d38ae384496603d3a89ca1" translate="yes" xml:space="preserve">
          <source>Function Before Execution:</source>
          <target state="translated">実行前の関数。</target>
        </trans-unit>
        <trans-unit id="31a489ea01d856da46704976b42a3727c3bf5489" translate="yes" xml:space="preserve">
          <source>Functions are objects (explained well in the accepted answer).</source>
          <target state="translated">関数は物体である(合格答案ではよく説明されている)。</target>
        </trans-unit>
        <trans-unit id="33152c3a458131f199d601848f2ff938e88b23ff" translate="yes" xml:space="preserve">
          <source>Given a simple little function &lt;code&gt;func&lt;/code&gt; defined as:</source>
          <target state="translated">次のように定義された単純な小さな関数 &lt;code&gt;func&lt;/code&gt; があるとします。</target>
        </trans-unit>
        <trans-unit id="dc7ed69775b531605c40861499142c0c9436b2e1" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;foo&lt;/code&gt; is an object and &lt;code&gt;a&lt;/code&gt; is an attribute of &lt;code&gt;foo&lt;/code&gt; (available at &lt;code&gt;foo.func_defs[0]&lt;/code&gt;). Since &lt;code&gt;a&lt;/code&gt; is a list, &lt;code&gt;a&lt;/code&gt; is mutable and is thus a read-write attribute of &lt;code&gt;foo&lt;/code&gt;. It is initialized to the empty list as specified by the signature when the function is instantiated, and is available for reading and writing as long as the function object exists.</source>
          <target state="translated">ここで、 &lt;code&gt;foo&lt;/code&gt; はオブジェクトであり &lt;code&gt;a&lt;/code&gt; は &lt;code&gt;foo&lt;/code&gt; の属性です（ &lt;code&gt;foo.func_defs[0]&lt;/code&gt; で利用可能）。 &lt;code&gt;a&lt;/code&gt; はリストである &lt;code&gt;a&lt;/code&gt; 、 aは変更可能であり、したがって &lt;code&gt;foo&lt;/code&gt; の読み取り/書き込み属性です。 これは、関数がインスタンス化されるときにシグネチャによって指定された空のリストに初期化され、関数オブジェクトが存在する限り、読み取りと書き込みに使用できます。</target>
        </trans-unit>
        <trans-unit id="a60b329ec4b9d85ee4941270916f4f4532974b74" translate="yes" xml:space="preserve">
          <source>Here's a demonstration - you can verify that they are the same object each time they are referenced by</source>
          <target state="translated">で参照されるたびに同じオブジェクトであることを確認することができます。</target>
        </trans-unit>
        <trans-unit id="6fd4504fd06148ba79eed7136bc3c11e43b9b3ff" translate="yes" xml:space="preserve">
          <source>Hopefully it's enough to show that not executing the default argument expressions at the execution time of the &lt;code&gt;def&lt;/code&gt; statement isn't easy or doesn't make sense, or both.</source>
          <target state="translated">うまくいけば、 &lt;code&gt;def&lt;/code&gt; ステートメントの実行時にデフォルトの引数式を実行しないことは容易ではないか、意味がないか、またはその両方であることを示すだけで十分です。</target>
        </trans-unit>
        <trans-unit id="efcda094ecf8e11cea988762da8f1af71d231058" translate="yes" xml:space="preserve">
          <source>However, supposed later on in the code, I do something like</source>
          <target state="translated">しかし、コードの後半では、次のようなことをしています。</target>
        </trans-unit>
        <trans-unit id="b3f69934c5bc363d742e1cab32463a9509580910" translate="yes" xml:space="preserve">
          <source>However, we've lost the ability to introspect, and see what the default arguments &lt;em&gt;are&lt;/em&gt;.  Because the objects haven't been constructed, we can't ever get hold of them without actually calling the function.  The best we could do is to store off the source code and return that as a string.</source>
          <target state="translated">ただし、イントロスペクションを実行できず、デフォルトの引数&lt;em&gt;が&lt;/em&gt;何であるかを確認できません。 オブジェクトが作成されていないため、実際に関数を呼び出さないと、オブジェクトを取得できません。 私たちができる最善の方法は、ソースコードを保存して、それを文字列として返すことです。</target>
        </trans-unit>
        <trans-unit id="62218df64348dca379d0be7d12cf753886ac8753" translate="yes" xml:space="preserve">
          <source>I agree it's a gotcha when you try to use default constructors, though.</source>
          <target state="translated">しかし、デフォルトのコンストラクタを使おうとすると、それは失敗だということには同意します。</target>
        </trans-unit>
        <trans-unit id="666a646463dc2675694b853c3a8d9d31ebba0462" translate="yes" xml:space="preserve">
          <source>I am going to demonstrate an alternative structure to pass a default list value to a function (it works equally well with dictionaries).</source>
          <target state="translated">デフォルトのリスト値を関数に渡すための代替構造をデモします(これは辞書でも同様に動作します)。</target>
        </trans-unit>
        <trans-unit id="79228cdbb3c7bc21ef5719f719a1a0dd6dfbf36b" translate="yes" xml:space="preserve">
          <source>I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs ?)</source>
          <target state="translated">私は、経験豊富な動作が実用的な使い方をしているのか疑問に思っています(誰が本当にC言語でバグを繁殖させずに静的変数を使ったのか?</target>
        </trans-unit>
        <trans-unit id="43c16dd324ef24fec2c80514d01a8fbc2f28b9ba" translate="yes" xml:space="preserve">
          <source>I found it very clear, and I really suggest reading it for a better knowledge of how function objects work.</source>
          <target state="translated">非常にわかりやすく、機能オブジェクトの仕組みをよりよく知るために読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="e438a0bb860a536fec364c3e57d8144f3738861a" translate="yes" xml:space="preserve">
          <source>I know nothing about the Python interpreter inner workings (and I'm not an expert in compilers and interpreters either) so don't blame me if I propose anything unsensible or impossible.</source>
          <target state="translated">私はPythonインタプリタの内部構造について何も知らないので(コンパイラやインタプリタの専門家でもありません)、意味不明なことや不可能なことを提案しても私を責めないでください。</target>
        </trans-unit>
        <trans-unit id="71d7286361ceb622e718e696e33275d64365bcc6" translate="yes" xml:space="preserve">
          <source>I know, I know: that's a closure. Alternatively Python might provide a keyword to force definition-time binding:</source>
          <target state="translated">わかっています、わかっています:これはクロージャです。別の方法として、Pythonは定義時のバインディングを強制するキーワードを提供するかもしれません。</target>
        </trans-unit>
        <trans-unit id="33854cd2f920283abdfe15942535e15a55a4bbc1" translate="yes" xml:space="preserve">
          <source>I personally like Python's current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible.</source>
          <target state="translated">個人的にはPythonの現在のアプローチが好きです:デフォルトの関数引数は関数が定義されたときに評価され、そのオブジェクトは常にデフォルトです。空のリストを使って特殊なケースにすることもできると思いますが、そのような特殊なケースは、下位互換性がないことは言うまでもありませんが、さらに驚くべきことを引き起こすでしょう。</target>
        </trans-unit>
        <trans-unit id="653d0fdb648a0e875a98321cd116616aaa059e3d" translate="yes" xml:space="preserve">
          <source>I sometimes exploit this behavior as an alternative to the following pattern:</source>
          <target state="translated">私は以下のパターンの代替として、この動作を利用することがあります。</target>
        </trans-unit>
        <trans-unit id="1136692ed919e61fb64464e3c7faa84bec1902d1" translate="yes" xml:space="preserve">
          <source>I think the answer to this question lies in how python pass data to parameter (pass by value or by reference), not mutability or how python handle the &quot;def&quot; statement.</source>
          <target state="translated">この質問の答えは、Pythonがどのようにしてパラメータにデータを渡すか(値渡しや参照渡し)にあると思いますが、変異性やpythonがどのように &quot;def &quot;文を扱うかではありません。</target>
        </trans-unit>
        <trans-unit id="344b69c74ad5e09938fa343f9bd784e609ba3f79" translate="yes" xml:space="preserve">
          <source>I used to think that creating the objects at runtime would be the better approach.  I'm less certain now, since you do lose some useful features, though it may be worth it regardless simply to prevent newbie confusion.  The disadvantages of doing so are:</source>
          <target state="translated">以前は、実行時にオブジェクトを作成する方が良いアプローチだと思っていました。しかし、初心者の混乱を防ぐためには、実行時にオブジェクトを作成する価値はあるかもしれません。この方法のデメリットは以下の通りです。</target>
        </trans-unit>
        <trans-unit id="f45c52b12ce7f1ce19a9035ae4c48dd9daa005c0" translate="yes" xml:space="preserve">
          <source>I'll give you a hint.  Here's the disassembly (see &lt;a href=&quot;http://docs.python.org/library/dis.html&quot;&gt;http://docs.python.org/library/dis.html&lt;/a&gt;):</source>
          <target state="translated">ヒントをあげましょう。 これが逆アセンブリです（ &lt;a href=&quot;http://docs.python.org/library/dis.html&quot;&gt;http://docs.python.org/library/dis.htmlを&lt;/a&gt;参照）：</target>
        </trans-unit>
        <trans-unit id="63b9797c54d1f5b22108348202db1c0d9f27b5eb" translate="yes" xml:space="preserve">
          <source>I'm &lt;em&gt;really&lt;/em&gt; surprised no one has performed the insightful introspection offered by Python (&lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; apply) on callables.</source>
          <target state="translated">Pythonが提供する洞察に満ちたイントロスペクション（ &lt;code&gt;2&lt;/code&gt; および &lt;code&gt;3&lt;/code&gt; が当てはまる）を呼び出し可能オブジェクトで実行した人がいない&lt;em&gt;ことに本当に&lt;/em&gt;驚いています。</target>
        </trans-unit>
        <trans-unit id="d560ac161f04d984906ccae5894dd8e5c74ba7d6" translate="yes" xml:space="preserve">
          <source>I'm gonna give you what I see as a useful example.</source>
          <target state="translated">私が参考になると思った例を挙げてみます。</target>
        </trans-unit>
        <trans-unit id="0ab4a274949e60b1dc8d810f1b8b6f0326e083c2" translate="yes" xml:space="preserve">
          <source>I've used this for instantiating client classes that access external resources, and also for creating dicts or lists for memoization.</source>
          <target state="translated">外部リソースにアクセスするクライアントクラスのインスタンス化や、メモ用のディクトやリストの作成に使っています。</target>
        </trans-unit>
        <trans-unit id="d4a17f0810bff8f4684352651e72c003f9d91265" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pavlo&lt;/code&gt; is mutable (modifiable), and &lt;code&gt;foo&lt;/code&gt; ends up modifying it, an effect we notice the next time &lt;code&gt;foo&lt;/code&gt; is called without specifying &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pavlo&lt;/code&gt; が変更可能（変更可能）で、 &lt;code&gt;foo&lt;/code&gt; がそれを変更してしまうと、次に &lt;code&gt;foo&lt;/code&gt; が呼び出されたときに &lt;code&gt;a&lt;/code&gt; を指定せずに効果が発生します。</target>
        </trans-unit>
        <trans-unit id="2fde0c1e8b0aff298d01bf5aa7a719c471660837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;singleton&lt;/code&gt; is only used by &lt;code&gt;use_singleton&lt;/code&gt;, I like the following pattern as a replacement:</source>
          <target state="translated">&lt;code&gt;singleton&lt;/code&gt; が &lt;code&gt;use_singleton&lt;/code&gt; によってのみ使用される場合、次のパターンを代わりに使用します。</target>
        </trans-unit>
        <trans-unit id="12b09ce5fbf5f05e7151c2f7f01217b353055234" translate="yes" xml:space="preserve">
          <source>If call-time evaluation is used, then the expensive function is called every time your function is used without an argument.  You'd either pay an expensive price on each call, or need to manually cache the value externally, polluting your namespace and adding verbosity.</source>
          <target state="translated">呼び出し時評価が使用されている場合、引数なしで関数が使用されるたびに高価な関数が呼び出されます。呼び出すたびに高価な代償を支払うか、手動で外部に値をキャッシュする必要があり、名前空間を汚染して冗長性が増します。</target>
        </trans-unit>
        <trans-unit id="07abc281d43c1a8d21b4d3e16a4f89b6450862f6" translate="yes" xml:space="preserve">
          <source>If we execute &lt;code&gt;x[7]()&lt;/code&gt; we'll get 7 as expected, and &lt;code&gt;x[9]()&lt;/code&gt; will gives 9, another value of &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x[7]()&lt;/code&gt; を実行すると、期待どおりに7になり、 &lt;code&gt;x[9]()&lt;/code&gt; は9に &lt;code&gt;i&lt;/code&gt; の別の値を返します。</target>
        </trans-unit>
        <trans-unit id="5e5d0faf4767c71322e96d58c89f44e2f7d7004b" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want the default to be shared between subsequent calls,
  you can write the function like this instead:</source>
          <target state="translated">後続の呼び出し間でデフォルトを共有したくない場合は、代わりに次のような関数を記述できます。</target>
        </trans-unit>
        <trans-unit id="a78835080b9cc304e7940760ebe5a74f9feb7089" translate="yes" xml:space="preserve">
          <source>If you need to destructively manipulate a local temporary in the course of computing something, and you need to start your manipulation from an argument value, you need to make a copy.</source>
          <target state="translated">何かを計算している最中にローカルテンポラリを破壊的に操作する必要があり、引数の値から操作を開始する必要がある場合は、コピーを作成する必要があります。</target>
        </trans-unit>
        <trans-unit id="ffce4f7ff1a5649ba9873493748437dec4a51845" translate="yes" xml:space="preserve">
          <source>In any case, Effbot has a very nice explanation of the reasons for this behavior in &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;Default Parameter Values in Python&lt;/a&gt;.</source>
          <target state="translated">いずれにせよ、Effbotはこの動作の理由について&lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;、Pythonのデフォルトのパラメーター値で&lt;/a&gt;非常によく説明しています。</target>
        </trans-unit>
        <trans-unit id="bbd472fc6429abfdafc9add5359fa997a6a79049" translate="yes" xml:space="preserve">
          <source>In other words, instead of evaluating default parameters, why not store each of them, and evaluate them when the function is called?</source>
          <target state="translated">つまり、デフォルトのパラメータを評価するのではなく、それぞれのパラメータを保存しておき、関数が呼ばれたときに評価すればいいのではないでしょうか?</target>
        </trans-unit>
        <trans-unit id="44af44eea85fed48a31ed0183c38ed921ac1aabb" translate="yes" xml:space="preserve">
          <source>Input parameters objects shouldn't be modified in place (mutated) nor they should not be binded into an object returned by the function. (If we prefere programming without side effects which is strongly recommended. see &lt;a href=&quot;http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;Wiki about &quot;side effect&quot;&lt;/a&gt; (The first two paragraphs are relevent in this context.)
.)</source>
          <target state="translated">入力パラメーターオブジェクトを適切に変更（変更）したり、関数から返されるオブジェクトにバインドしたりしないでください。 （強く推奨される副作用のないプログラミングを好む場合。 &lt;a href=&quot;http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;「副作用」&lt;/a&gt;についてのWikiを参照してください（このコンテキストでは、最初の2つの段落は関連しています。）。）</target>
        </trans-unit>
        <trans-unit id="f428f84105fcce031afe75598a91587f547827e4" translate="yes" xml:space="preserve">
          <source>It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.</source>
          <target state="translated">これは、Pythonの関数は一級品のオブジェクトであり、単なるコードの一部ではないという事実から来ています。</target>
        </trans-unit>
        <trans-unit id="8d35c5155e3a7198376d876ba2ac22709cf724ee" translate="yes" xml:space="preserve">
          <source>It is a confusing feature and it is unfortunate in Python.</source>
          <target state="translated">紛らわしい機能であり、Pythonでは残念なことになっています。</target>
        </trans-unit>
        <trans-unit id="2d1e31d0ad97904bac773140d97936823786bfd4" translate="yes" xml:space="preserve">
          <source>It may be true that switching horses in midstream here would be asking for significant breakage, and that there could be more problems created by changing Python to intuitively handle Stefano's opening snippet. And it may be true that someone who knew Python internals well could explain a minefield of consequences. &lt;em&gt;However,&lt;/em&gt;</source>
          <target state="translated">ここで途中で馬を切り替えると重大な破損が発生すること、そしてPythonを変更してStefanoのオープニングスニペットを直感的に処理することでさらに多くの問題が発生する可能性があることは事実です。 そして、Pythonの内部をよく知っている人が結果の地雷原を説明できるのは本当かもしれません。 &lt;em&gt;しかしながら、&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f7b0650553f1d03b5617ea73a2e594063dbeff1b" translate="yes" xml:space="preserve">
          <source>It may be true that:</source>
          <target state="translated">というのは事実かもしれません。</target>
        </trans-unit>
        <trans-unit id="c88ae6b372096f323f1ae38ef63c959269132a80" translate="yes" xml:space="preserve">
          <source>It shouldn't be neither saved in any &lt;em&gt;public&lt;/em&gt; attribute of an instance returned by this function. (Assuming that &lt;em&gt;private&lt;/em&gt; attributes of instance should not be modified from outside of this class or subclasses by convention. i.e. &lt;code&gt;_var1&lt;/code&gt; is a private attribute )</source>
          <target state="translated">この関数によって返されるインスタンスの&lt;em&gt;パブリック&lt;/em&gt;属性にも保存しないでください。 （インスタンスの&lt;em&gt;プライベート&lt;/em&gt;属性は、慣例によりこのクラスまたはサブクラスの外部から変更してはならないことを前提としています。つまり、 &lt;code&gt;_var1&lt;/code&gt; はプライベート属性です）</target>
        </trans-unit>
        <trans-unit id="a1d3a576ba48952d86d8cfdfe398ef2bddea704e" translate="yes" xml:space="preserve">
          <source>It's a performance optimization.  As a result of this functionality, which of these two function calls do you think is faster?</source>
          <target state="translated">パフォーマンスの最適化です。この機能の結果、この2つの関数呼び出しのうち、どちらが速いと思いますか?</target>
        </trans-unit>
        <trans-unit id="0359bac5a1c47bf095f12d4add2a3b1b5b445f4a" translate="yes" xml:space="preserve">
          <source>It's important to note that the above solution breaks if you try to use keyword args, like so:</source>
          <target state="translated">ここで注意しなければならないのは、上記のようにキーワード引数を使おうとすると、上記の解決策が壊れてしまうということです。</target>
        </trans-unit>
        <trans-unit id="b6c89d685ac19d7565519a44bbc4a6d593564a24" translate="yes" xml:space="preserve">
          <source>It's just &quot;How It Works&quot;, and making it work differently in the function case would probably be complicated, and in the class case likely impossible, or at least slow down object instantiation a lot, as you would have to keep the class code around and execute it when objects are created.</source>
          <target state="translated">これは「どのように動作するか」ということだけで、関数の場合は複雑で、クラスの場合はおそらく不可能でしょう。</target>
        </trans-unit>
        <trans-unit id="fd310ea6b1cae2a6a063f0bd5d873b8e8d185946" translate="yes" xml:space="preserve">
          <source>Just change the function to be:</source>
          <target state="translated">機能を変えればいいだけです。</target>
        </trans-unit>
        <trans-unit id="7da4eaf92a58f20a9c68b073a49820f4346f33e5" translate="yes" xml:space="preserve">
          <source>Let's now execute this function:</source>
          <target state="translated">では、この関数を実行してみましょう。</target>
        </trans-unit>
        <trans-unit id="fd6ffcde729e6f54a9565146d7555da45d90700c" translate="yes" xml:space="preserve">
          <source>Look back to the original example and consider the above points:</source>
          <target state="translated">元の例を振り返り、上記のポイントを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="7d52014db1eb1bc10080d5b3576313f9f6997662" translate="yes" xml:space="preserve">
          <source>Many builtin mutable types have a copy method like &lt;code&gt;some_dict.copy()&lt;/code&gt; or &lt;code&gt;some_set.copy()&lt;/code&gt; or can be copied easy like &lt;code&gt;somelist[:]&lt;/code&gt; or &lt;code&gt;list(some_list)&lt;/code&gt;. Every object can be also copied by &lt;code&gt;copy.copy(any_object)&lt;/code&gt; or more thorough by &lt;code&gt;copy.deepcopy()&lt;/code&gt; (the latter useful if the mutable object is composed from mutable objects). Some objects are fundamentally based on side effects like &quot;file&quot; object and can not be meaningfully reproduced by copy. &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm&quot;&gt;copying&lt;/a&gt;</source>
          <target state="translated">多くの組み込みの可変型には、 &lt;code&gt;some_dict.copy()&lt;/code&gt; や &lt;code&gt;some_set.copy()&lt;/code&gt; のようなコピーメソッドがあるか、 &lt;code&gt;somelist[:]&lt;/code&gt; や &lt;code&gt;list(some_list)&lt;/code&gt; のように簡単にコピーできます。 すべてのオブジェクトは、 &lt;code&gt;copy.copy(any_object)&lt;/code&gt; によってコピーすることも、 &lt;code&gt;copy.deepcopy()&lt;/code&gt; によってより完全にコピーすることもできます（後者は、可変オブジェクトが可変オブジェクトで構成されている場合に役立ちます）。 一部のオブジェクトは基本的に「ファイル」オブジェクトのような副作用に基づいており、コピーによって意味のある複製を行うことができません。 &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm&quot;&gt;コピー&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e23f5cbc0bbb2cbb8b27c449a4bcd8e9fbb38b2b" translate="yes" xml:space="preserve">
          <source>No default values in sight in this code, but you get exactly the same problem.</source>
          <target state="translated">このコードにはデフォルト値はありませんが、全く同じ問題が発生します。</target>
        </trans-unit>
        <trans-unit id="b9b42c390ec8fb15d988160f4dd8c2a52791b6d6" translate="yes" xml:space="preserve">
          <source>Now let's redefine our function using this decorator:</source>
          <target state="translated">では、このデコレータを使って関数を再定義してみましょう。</target>
        </trans-unit>
        <trans-unit id="b7e59f92481e8e7835898fa1c85ba3a27d892126" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;pavlo&lt;/code&gt; is [5].</source>
          <target state="translated">現在、 &lt;code&gt;pavlo&lt;/code&gt; は[5]です。</target>
        </trans-unit>
        <trans-unit id="362ccf94780188762e961bb582f31f3d92a8d7ee" translate="yes" xml:space="preserve">
          <source>Now, compare this to the example from the documentation on &lt;a href=&quot;http://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;emulating the default argument behavior of other languages&lt;/a&gt;, such that the function signature defaults are used every time the function is executed:</source>
          <target state="translated">ここで、これを&lt;a href=&quot;http://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;他の言語のデフォルトの引数動作のエミュレーション&lt;/a&gt;に関するドキュメントの例と比較し、関数が実行されるたびに関数シグネチャのデフォルトが使用されるようにします。</target>
        </trans-unit>
        <trans-unit id="64acff4f47942d13d4f208bda7e869e11d893a33" translate="yes" xml:space="preserve">
          <source>Now, does my map use the value of the &lt;code&gt;StringBuffer&lt;/code&gt; key when it was placed into the map, or does it store the key by reference?  Either way, someone is astonished; either the person who tried to get the object out of the &lt;code&gt;Map&lt;/code&gt; using a value identical to the one they put it in with, or the person who can't seem to retrieve their object even though the key they're using is literally the same object that was used to put it into the map (this is actually why Python doesn't allow its mutable built-in data types to be used as dictionary keys).</source>
          <target state="translated">今、私のマップは、マップに配置されたときに &lt;code&gt;StringBuffer&lt;/code&gt; キーの値を使用しますか、それとも参照によってキーを格納しますか？ いずれにせよ、誰かが驚いています。 元のオブジェクトと同じ値を使用してオブジェクトを &lt;code&gt;Map&lt;/code&gt; から取り出そうとした人、または使用しているキーが文字通り同じでもオブジェクトを取得できないように見える人マップに配置するために使用されたオブジェクト（これが実際に、Pythonがその可変の組み込みデータ型を辞書キーとして使用することを許可しない理由です）。</target>
        </trans-unit>
        <trans-unit id="ca1782989bcd41936515ff547e98eb21e1c24f56" translate="yes" xml:space="preserve">
          <source>Now, let's see those &lt;code&gt;__defaults__&lt;/code&gt; again:</source>
          <target state="translated">では、これらの &lt;code&gt;__defaults__&lt;/code&gt; をもう一度見てみましょう。</target>
        </trans-unit>
        <trans-unit id="03060fd5df0aea733c344b9b8691c947fcb3b65a" translate="yes" xml:space="preserve">
          <source>Now, suppose the behaviour of defaults could be changed so that this is the equivalent of:</source>
          <target state="translated">さて、デフォルトの振る舞いを変更して、これと同等のことができるようにしたとしましょう。</target>
        </trans-unit>
        <trans-unit id="c8b8bb4b9ae89c0e3c42072a31a62c115adca126" translate="yes" xml:space="preserve">
          <source>Now, when to evaluate &lt;code&gt;default&lt;/code&gt;?</source>
          <target state="translated">今、いつ &lt;code&gt;default&lt;/code&gt; を評価するのですか？</target>
        </trans-unit>
        <trans-unit id="2d80698d75eb09b54cff119780e3f91af2942726" translate="yes" xml:space="preserve">
          <source>O.k, so an empty list as the single entry in &lt;code&gt;__defaults__&lt;/code&gt;, just as expected.</source>
          <target state="translated">&lt;code&gt;__defaults__&lt;/code&gt; 、期待どおり、 __defaults__の単一のエントリとして空のリストを作成します。</target>
        </trans-unit>
        <trans-unit id="8ee84d967071869b5d4f78c07c4174525b7a125c" translate="yes" xml:space="preserve">
          <source>One answer is probably right there--it would effectively turn every function with default parameters into a closure.  Even if it's all hidden away in the interpreter and not a full-blown closure, the data's got to be stored somewhere.  It'd be slower and use more memory.</source>
          <target state="translated">デフォルトのパラメータを持つすべての関数を事実上クロージャにしてしまうことになります。たとえそれがすべてインタープリタの中に隠されていて、完全なクロージャではないとしても、データはどこかに保存されなければなりません。その方が遅くなるし、より多くのメモリを使うことになります。</target>
        </trans-unit>
        <trans-unit id="11b18ef18f03165cd782bc4f836d003ad9d95019" translate="yes" xml:space="preserve">
          <source>Only if the side effect on the actual parameter is required but unwanted on the default parameter then the useful solution is &lt;code&gt;def ...(var1=None):&lt;/code&gt;&lt;code&gt;if var1 is None:&lt;/code&gt;&lt;code&gt;var1 = []&lt;/code&gt;&lt;a href=&quot;http://effbot.org/zone/default-values.htm#what-to-do-instead&quot;&gt;More..&lt;/a&gt;</source>
          <target state="translated">実際のパラメータへの副作用が必要であるがデフォルトのパラメータでは望ましくない場合のみ、有用な解決策は &lt;code&gt;def ...(var1=None):&lt;/code&gt; &lt;code&gt;if var1 is None:&lt;/code&gt; &lt;code&gt;var1 = []&lt;/code&gt; &lt;a href=&quot;http://effbot.org/zone/default-values.htm#what-to-do-instead&quot;&gt;詳細...&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="114258caa60ea3edd65afe4bbb8f1463ea7260f5" translate="yes" xml:space="preserve">
          <source>Per &lt;strong&gt;(1)&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;a new local variable also named &lt;code&gt;L&lt;/code&gt; is created in the local scope&lt;/em&gt;&lt;/strong&gt; and used for the remainder of the function call. &lt;code&gt;foo.func_defs[0]&lt;/code&gt; thus remains unchanged for future invocations of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;（1）&lt;/strong&gt;に従って、 &lt;strong&gt;&lt;em&gt; &lt;code&gt;L&lt;/code&gt; という名前の新しいローカル変数がローカルスコープに作成され&lt;/em&gt;&lt;/strong&gt; 、関数呼び出しの残りの部分で使用されます。 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; は、今後の &lt;code&gt;foo&lt;/code&gt; の呼び出しのために変更されません。</target>
        </trans-unit>
        <trans-unit id="1d87aa1b1e7324f25c59d457e5df3e2ceb743377" translate="yes" xml:space="preserve">
          <source>Per Brett Slatkin's &quot;Effective Python: 59 Specific Ways to Write Better Python&quot;, &lt;em&gt;Item 20: Use &lt;code&gt;None&lt;/code&gt; and Docstrings to specify dynamic default arguments&lt;/em&gt; (p. 48)</source>
          <target state="translated">Brett Slatkinの「Effective Python：59 Specific Ways to Write Better Python」の&lt;em&gt;項目20： &lt;code&gt;None&lt;/code&gt; とDocstringsを使用して動的なデフォルト引数を指定する&lt;/em&gt; （p。</target>
        </trans-unit>
        <trans-unit id="edbbe1dd270001c9959fe3b6bfc520ed27fa81f3" translate="yes" xml:space="preserve">
          <source>Provided that python objects &lt;strong&gt;are mutable&lt;/strong&gt; I think that this should be taken into account when designing the default arguments stuff.
When you instantiate a list:</source>
          <target state="translated">Pythonオブジェクト&lt;strong&gt;が変更可能であれば&lt;/strong&gt; 、デフォルトの引数を設計するときにこれを考慮に入れる必要があると思います。 リストをインスタンス化するとき：</target>
        </trans-unit>
        <trans-unit id="e05c3327cf67fb602c3add427a88b4d544b75506" translate="yes" xml:space="preserve">
          <source>Python novices would expect this function to always return a list with only one element: &lt;code&gt;[5]&lt;/code&gt;. The result is instead very different, and very astonishing (for a novice):</source>
          <target state="translated">Python初心者は、この関数が常に1つの要素 &lt;code&gt;[5]&lt;/code&gt; のみを含むリストを返すことを期待します。 結果は非常に異なり、非常に驚​​くべきものです（初心者にとって）。</target>
        </trans-unit>
        <trans-unit id="81f99a7ff268aeaf873fa4045929feaf18be7cd0" translate="yes" xml:space="preserve">
          <source>Python: The Mutable Default Argument</source>
          <target state="translated">Pythonを使っています。Mutableなデフォルト引数</target>
        </trans-unit>
        <trans-unit id="48fb53aa0f56fcdc44c27cdce6ee6b0ac6e04929" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;parameter&lt;/code&gt; is a constant name, we can &quot;evaluate&quot; it at the same time as &lt;code&gt;def name&lt;/code&gt;. This also has the advantage it produces the function with a known signature as &lt;code&gt;name(parameter=...):&lt;/code&gt;, instead of a bare &lt;code&gt;name(...):&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parameter&lt;/code&gt; は定数名なので、 &lt;code&gt;def name&lt;/code&gt; と同時に「評価」できます。 これには、裸の &lt;code&gt;name(...):&lt;/code&gt; の代わりに、 &lt;code&gt;name(parameter=...):&lt;/code&gt; として既知のシグネチャを持つ関数を生成するという利点もあります 。</target>
        </trans-unit>
        <trans-unit id="a5d182b67a7149475e28eef1bc9597d34d73b45e" translate="yes" xml:space="preserve">
          <source>Since I don't think this pattern is well known, I do put a short comment in to guard against future misunderstandings.</source>
          <target state="translated">このパターンはあまり知られていないと思うので、今後の誤解を防ぐために短いコメントを入れておきます。</target>
        </trans-unit>
        <trans-unit id="1da4b14f89f2b2d481987a26be3a56b816db7930" translate="yes" xml:space="preserve">
          <source>Since the function body is executed anew each time, you always get a fresh new empty list if no argument was passed for &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">関数本体は毎回新しく実行されるため &lt;code&gt;a&lt;/code&gt; 引数が渡されなかった場合は、常に新しい空のリストが取得されます。</target>
        </trans-unit>
        <trans-unit id="8219cc9987e068b594e6f9212eabecd380fc4b23" translate="yes" xml:space="preserve">
          <source>Since the list is bound to the function when the function object is compiled and instantiated, this:</source>
          <target state="translated">関数オブジェクトがコンパイルされてインスタンス化されたときにリストが関数にバインドされるので、これは</target>
        </trans-unit>
        <trans-unit id="846d5d41860fc57cee6667664460f6fd3c443f37" translate="yes" xml:space="preserve">
          <source>So this is what you see (Remember, &lt;code&gt;pavlo&lt;/code&gt; is initialized to []):</source>
          <target state="translated">だからこれはあなたが見るものです（覚えておいてください、 &lt;code&gt;pavlo&lt;/code&gt; は[]に初期化されます）：</target>
        </trans-unit>
        <trans-unit id="cc480e96946c5a4d81dbe64f85f0531baec48a48" translate="yes" xml:space="preserve">
          <source>So, &lt;code&gt;pavlo&lt;/code&gt; is still &lt;code&gt;[5, 5]&lt;/code&gt;.</source>
          <target state="translated">したがって、 &lt;code&gt;pavlo&lt;/code&gt; はまだ &lt;code&gt;[5, 5]&lt;/code&gt; 5、5 ]です。</target>
        </trans-unit>
        <trans-unit id="135253f82ce516e45be9920a7c65b965b29a4cbe" translate="yes" xml:space="preserve">
          <source>So, let's do some introspection, a before and after to examine how the list gets expanded &lt;strong&gt;inside&lt;/strong&gt; the function object. I'm using &lt;code&gt;Python 3.x&lt;/code&gt; for this, for Python 2 the same applies (use &lt;code&gt;__defaults__&lt;/code&gt; or &lt;code&gt;func_defaults&lt;/code&gt; in Python 2; yes, two names for the same thing).</source>
          <target state="translated">それでは、関数オブジェクト&lt;strong&gt;内で&lt;/strong&gt;リストがどのように展開されるかを調べる前と後の内省を行いましょう。 私はこれに &lt;code&gt;Python 3.x&lt;/code&gt; を使用しています &lt;code&gt;__defaults__&lt;/code&gt; も同じことが当てはまります（Python 2では__defaults__または &lt;code&gt;func_defaults&lt;/code&gt; を使用してください 。そうです、同じものには2つの名前があります）。</target>
        </trans-unit>
        <trans-unit id="ac03b13d0df29e0d823d1733d67a60356a13e49c" translate="yes" xml:space="preserve">
          <source>So, there you have it, the reason why this &lt;em&gt;'flaw'&lt;/em&gt; happens, is because default arguments are part of the function object. There's nothing weird going on here, it's all just a bit surprising.</source>
          <target state="translated">つまり、この&lt;em&gt;「欠陥」&lt;/em&gt;が発生する理由は、デフォルトの引数が関数オブジェクトの一部であるためです。 ここで奇妙なことは何もありません、それはすべて少し驚くべきことです。</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="2ffd73eaa6f051202977e48c6c85a797b6fd5a12" translate="yes" xml:space="preserve">
          <source>Someone is using every language/library feature, and</source>
          <target state="translated">誰かがすべての言語ライブラリの機能を使用しています。</target>
        </trans-unit>
        <trans-unit id="d42bae2973e05a62b137b51620fea4d9b147edc0" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;a&lt;/code&gt; when calling &lt;code&gt;foo()&lt;/code&gt; ensures &lt;code&gt;pavlo&lt;/code&gt; is not touched.</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; を呼び出すときに &lt;code&gt;a&lt;/code&gt; を指定すると 、 &lt;code&gt;pavlo&lt;/code&gt; が操作されなくなります。</target>
        </trans-unit>
        <trans-unit id="f19d645e1fda82c64c713d7a7c9e1d69d1720d38" translate="yes" xml:space="preserve">
          <source>Suppose you have the following code</source>
          <target state="translated">以下のコードがあるとします。</target>
        </trans-unit>
        <trans-unit id="2985042a12a99a3c98ea5fdbdde2134ab3ef8abf" translate="yes" xml:space="preserve">
          <source>Switching the behavior here would be ill-advised, but</source>
          <target state="translated">ここで行動を切り替えるのは賢明ではありませんが</target>
        </trans-unit>
        <trans-unit id="eb8098887cd8190749f463f9cd047389241aa54c" translate="yes" xml:space="preserve">
          <source>TLDR: Define-time defaults are consistent and strictly more expressive.</source>
          <target state="translated">TLDR:定義時のデフォルトは一貫性があり、厳密にはより表現力を高めています。</target>
        </trans-unit>
        <trans-unit id="baee8029959dfcc9ec36a00cfc022b60ddd58256" translate="yes" xml:space="preserve">
          <source>Taking &lt;strong&gt;(1)&lt;/strong&gt; and &lt;strong&gt;(2)&lt;/strong&gt; into account, one can see why this accomplishes the the desired behavior:</source>
          <target state="translated">&lt;strong&gt;（1）&lt;/strong&gt;と&lt;strong&gt;（2）&lt;/strong&gt;を考慮すると、これが望ましい動作を達成する理由がわかります。</target>
        </trans-unit>
        <trans-unit id="60e49eedb22450ed713b64f742443e241e6f5637" translate="yes" xml:space="preserve">
          <source>That is against the rules of functional programming, usually undesiderable and should be fixed both together.</source>
          <target state="translated">それは、関数型プログラミングのルールに反しており、通常は考えられないと一緒に両方を修正する必要があります。</target>
        </trans-unit>
        <trans-unit id="6283984545c4460e3d117123b9917e356ce0cec9" translate="yes" xml:space="preserve">
          <source>That said it should feature prominently in any good Python tutorial. Because as you mention, everyone runs into this problem sooner or later.</source>
          <target state="translated">とはいえ、Pythonのチュートリアルでは、この問題は目立つように取り上げられるべきです。なぜなら、あなたが言及しているように、誰もが遅かれ早かれこの問題に遭遇するからです。</target>
        </trans-unit>
        <trans-unit id="4742191818ba22d12f4df985ed0fa6ab565b9a93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def name&lt;/code&gt; part &lt;strong&gt;must&lt;/strong&gt; evaluate in the defining scope - we want &lt;code&gt;name&lt;/code&gt; to be available there, after all. Evaluating the function only inside itself would make it inaccessible.</source>
          <target state="translated">&lt;code&gt;def name&lt;/code&gt; 部分は定義スコープで評価する&lt;strong&gt;必要があり&lt;/strong&gt;ます-結局、そこに &lt;code&gt;name&lt;/code&gt; を使用できるようにしたいのです。 関数を内部でのみ評価すると、アクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="211b17364c2c5fb881927eef3ad2c632ef6e4ead" translate="yes" xml:space="preserve">
          <source>The actual behavior is more consistent: everything of that line gets evaluated when that line is executed, meaning at function definition.</source>
          <target state="translated">実際の動作はより一貫性があり、その行が実行されたとき、つまり関数定義時に、その行のすべてが評価されます。</target>
        </trans-unit>
        <trans-unit id="b21b3a47af1bce60cc5bdaa7db45df9e68ea6c1a" translate="yes" xml:space="preserve">
          <source>The behavior of read-only class attributes upon assignment attempts, and that</source>
          <target state="translated">代入試行時の読み取り専用クラス属性の振る舞いと</target>
        </trans-unit>
        <trans-unit id="d812f28bfd7bbbe507925925cde1cb11345acdb0" translate="yes" xml:space="preserve">
          <source>The common solution to combat this is to use &lt;code&gt;None&lt;/code&gt; as the default and then initialize in the function body:</source>
          <target state="translated">これに対処するための一般的な解決策は、デフォルトとして &lt;code&gt;None&lt;/code&gt; を使用してから、関数本体で初期化することです。</target>
        </trans-unit>
        <trans-unit id="e6bc97e96787463bf81bb7eba82e092966902caa" translate="yes" xml:space="preserve">
          <source>The convention for achieving the desired result in Python is to
  provide a default value of &lt;code&gt;None&lt;/code&gt; and to document the actual behaviour
  in the docstring.</source>
          <target state="translated">Pythonで望ましい結果を得るための規則は、デフォルト値の &lt;code&gt;None&lt;/code&gt; を提供し、実際の動作をdocstringに文書化することです。</target>
        </trans-unit>
        <trans-unit id="12d835d927cd99c2caf5af5f3e46112259ed6aeb" translate="yes" xml:space="preserve">
          <source>The decorator could be adjusted to allow for that, but we leave this as an exercise for the reader ;)</source>
          <target state="translated">デコレータはそれを可能にするために調整することができますが、これは読者のための練習として残しておきます ;)</target>
        </trans-unit>
        <trans-unit id="5da3d3f2271874d0124b0b19b38e9cd58ca9fc21" translate="yes" xml:space="preserve">
          <source>The example in the question could fall into category 1 or 3. It's odd that it both modifies the passed list and returns it; you should pick one or the other.</source>
          <target state="translated">質問の例はカテゴリ1か3に該当します。それは、それが渡されたリストを修正し、それを返すことは奇妙です。</target>
        </trans-unit>
        <trans-unit id="07a5b90c302821e9edaa02c42d4c5a34d0d660fb" translate="yes" xml:space="preserve">
          <source>The existing behavior is not Pythonic, and Python is successful because very little about the language violates the principle of least astonishment anywhere &lt;em&gt;near&lt;/em&gt; this badly. It is a real problem, whether or not it would be wise to uproot it. It is a design flaw. If you understand the language much better by trying to trace out the behavior, I can say that C++ does all of this and more; you learn a lot by navigating, for instance, subtle pointer errors. But this is not Pythonic: people who care about Python enough to persevere in the face of this behavior are people who are drawn to the language because Python has far fewer surprises than other language. Dabblers and the curious become Pythonistas when they are astonished at how little time it takes to get something working--not because of a design fl--I mean, hidden logic puzzle--that cuts against the intuitions of programmers who are drawn to Python because it &lt;strong&gt;Just Works&lt;/strong&gt;.</source>
          <target state="translated">既存の振る舞いはPythonicではなく、Pythonは成功しています。なぜなら、この言語のほとんどは、これに&lt;em&gt;近い&lt;/em&gt;ところ&lt;em&gt;にある&lt;/em&gt;驚きの最小化の原則に違反しているためです。 それを根こそぎにすることが賢明であるかどうかにかかわらず、それは本当の問題です。 設計上の不具合です。 振る舞いを追跡することで言語をよりよく理解できれば、C ++はこれ以上のすべてを行うと言えるでしょう。 たとえば、微妙なポインタエラーをナビゲートすることで、多くのことを学びます。 しかし、これはPythonicではありません。この振る舞いに耐えるのに十分なほどPythonを気にする人々は、Pythonが他の言語よりも驚きが少ないため、その言語に惹かれます。 ダブラーと好奇心が強い人は、Pythonに惹かれるプログラマーの直感を損なう、設計FL（つまり、隠されたロジックパズル）のためではなく、何かを実行するのにかかる時間がわずかであることに驚いたときに、Pythonになります。それ&lt;strong&gt;だけで動作し&lt;/strong&gt;ます。</target>
        </trans-unit>
        <trans-unit id="16ba720afc950d5f92d65c94fa4b03086d39ddeb" translate="yes" xml:space="preserve">
          <source>The invocation of foo(1) make items point to a list object [] with an address, say, 11111111. the content of the list is changed to &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; in the foo function in the sequel, but the address is not changed, still 11111111. Then foo(2,[]) is coming. Although the [] in foo(2,[]) has the same content as the default parameter [] when calling foo(1), their address are different! Since we provide the parameter explicitly, &lt;code&gt;items&lt;/code&gt; has to take the address of this new &lt;code&gt;[]&lt;/code&gt;, say 2222222, and return it after making some change. Now foo(3) is executed. since only &lt;code&gt;x&lt;/code&gt; is provided, items has to take its default value again. What's the default value? It is set when defining the foo function: the list object located in 11111111. So the items is evaluated to be the address 11111111 having an element 1. The list located at 2222222 also contains one element 2, but it is not pointed by items any more. Consequently, An append of 3 will make &lt;code&gt;items&lt;/code&gt; [1,3].</source>
          <target state="translated">foo（1）を呼び出すと、アイテムは、たとえば11111111のアドレスを持つリストオブジェクト[]を指します。リストの内容は、続編のfoo関数で&lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt;に変更されますが、アドレスは変更されませんが、11111111のままです。 。その後、foo（2、[]）が来ます。 foo（2、[]）の[]は、foo（1）を呼び出すときのデフォルトパラメータ[]と同じ内容ですが、それらのアドレスは異なります！ パラメータを明示的に指定しているため、 &lt;code&gt;items&lt;/code&gt; はこの新しい &lt;code&gt;[]&lt;/code&gt; のアドレス、たとえば2222222を取得し、何らかの変更を加えた後にそれを返す必要があります。 これでfoo（3）が実行されました。 &lt;code&gt;x&lt;/code&gt; のみが指定されているため、アイテムは再びデフォルト値を使用する必要があります。 デフォルト値は何ですか？ これは、foo関数（11111111にあるリストオブジェクト）を定義するときに設定されます。したがって、アイテムは、要素1を持つアドレス11111111であると評価されます。2222222にあるリストにも1つの要素2が含まれていますが、アイテムによってポイントされていませんもっと。 したがって、3の追加は &lt;code&gt;items&lt;/code&gt; を作成します [1,3]。</target>
        </trans-unit>
        <trans-unit id="960186c4fed60739e84ad1f39072643da3a4aa62" translate="yes" xml:space="preserve">
          <source>The only way to implement this otherwise would be to create a further closure with the i bound, ie:</source>
          <target state="translated">これを実装する唯一の方法は、i をバインドしてさらにクロージャを作成することです。</target>
        </trans-unit>
        <trans-unit id="9a6df79e5dc84aaf86c93401973ff0f28eae8f32" translate="yes" xml:space="preserve">
          <source>The other answers, or at least some of them either make points 1 and 2 but not 3, or make point 3 and downplay points 1 and 2. &lt;strong&gt;But all three are true.&lt;/strong&gt;</source>
          <target state="translated">他の回答、または少なくともそのいくつかは、ポイント1と2を作成して3を作成しないか、ポイント3とダウンポイントを1と2に作成し&lt;strong&gt;ます。しかし、3つすべてが真です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="927ebe1c435f42420093f2af144d14cd34af2416" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;foo&lt;/code&gt; is &lt;em&gt;modifying&lt;/em&gt; a mutable variable passed in from the caller, when the caller doesn't expect this. Code like this would be fine if the function was called something like &lt;code&gt;append_5&lt;/code&gt;; then the caller would be calling the function in order to modify the value they pass in, and the behaviour would be expected. But such a function would be very unlikely to take a default argument, and probably wouldn't return the list (since the caller already has a reference to that list; the one it just passed in).</source>
          <target state="translated">問題は、呼び出し側が予期しないときに、 &lt;code&gt;foo&lt;/code&gt; が呼び出し側から渡された可変変数を変更していることです。 このようなコードは、関数が &lt;code&gt;append_5&lt;/code&gt; などのように呼び出された場合に問題ありません 。 次に、呼び出し元は、渡された値を変更するために関数を呼び出しますが、動作は予想されます。 しかし、そのような関数はデフォルトの引数をとる可能性が非常に低く、おそらくリストを返しません（呼び出し元がすでにそのリストへの参照を持っているため、渡されたばかりです）。</target>
        </trans-unit>
        <trans-unit id="65336feec4cf085e41224e4e768035259840cf58" translate="yes" xml:space="preserve">
          <source>The real problem lies with mutable variables, and all languages have this problem to some extent. Here's a question: suppose in Java I have the following code:</source>
          <target state="translated">本当の問題は可変変数にあり、すべての言語はある程度この問題を抱えています。ここで質問です:Javaで次のようなコードがあるとします。</target>
        </trans-unit>
        <trans-unit id="0a4fcade0686f8907935d1c1f96cfa776ce37445" translate="yes" xml:space="preserve">
          <source>The relevant part of the &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function-definitions&quot;&gt;documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function-definitions&quot;&gt;ドキュメント&lt;/a&gt;の関連部分：</target>
        </trans-unit>
        <trans-unit id="83a5fdca145464c718498a81f3ff52fe5cd258bb" translate="yes" xml:space="preserve">
          <source>The role of &lt;strong&gt;(2)&lt;/strong&gt; has been covered extensively in this thread. &lt;strong&gt;(1)&lt;/strong&gt; is likely the astonishment causing factor, as this behavior is not &quot;intuitive&quot; when coming from other languages.</source>
          <target state="translated">&lt;strong&gt;（2）&lt;/strong&gt;の役割は、このスレッドで広範囲にカバーされています。 &lt;strong&gt;（1）&lt;/strong&gt;他の言語から来た場合、この動作は「直感的」ではないため、おそらく驚異を引き起こす要因です。</target>
        </trans-unit>
        <trans-unit id="300e6346ced2778bb2850c432c17f5b9ac6cc781" translate="yes" xml:space="preserve">
          <source>The second option is nice because users of the function can pass in a callable, which may be already existing (such as a &lt;code&gt;type&lt;/code&gt;)</source>
          <target state="translated">2番目のオプションは、関数のユーザーが既に存在している可能性のあるcallable（ &lt;code&gt;type&lt;/code&gt; など）を渡すことができるので便利です。</target>
        </trans-unit>
        <trans-unit id="a7a38b99177ce67bdf698f00a61b5341959f2954" translate="yes" xml:space="preserve">
          <source>The shortest answer would probably be &quot;definition is execution&quot;, therefore the whole argument makes no strict sense. As a more contrived example, you may cite this:</source>
          <target state="translated">最短の答えは、おそらく「定義とは実行である」ということになるでしょうから、全体の議論は厳密な意味を持ちません。より対照的な例として、あなたはこれを引用することができます。</target>
        </trans-unit>
        <trans-unit id="1545469b153fc84d77f2934491dab6d60119c4f8" translate="yes" xml:space="preserve">
          <source>The solutions here are:</source>
          <target state="translated">ここでの解決策は</target>
        </trans-unit>
        <trans-unit id="9f29d3492458b50ad2b58ab7115f1bdab5c6dec2" translate="yes" xml:space="preserve">
          <source>The two choices are not equivalent, either: If &lt;code&gt;default&lt;/code&gt; is evaluated at definition time, it &lt;em&gt;can still&lt;/em&gt; affect execution time. If &lt;code&gt;default&lt;/code&gt; is evaluated at execution time, it &lt;em&gt;cannot&lt;/em&gt; affect definition time. Choosing &quot;at definition&quot; allows expressing both cases, while choosing &quot;at execution&quot; can express only one:</source>
          <target state="translated">2つの選択肢も同等ではありません。 &lt;code&gt;default&lt;/code&gt; が定義時に評価される場合&lt;em&gt;でも&lt;/em&gt; 、実行時間に影響を与える&lt;em&gt;可能性が&lt;/em&gt;あります。 &lt;code&gt;default&lt;/code&gt; が実行時に評価される場合、定義時間に影響を与えること&lt;em&gt;はできませ&lt;/em&gt;ん。 「定義時」を選択すると、両方のケースを表現できますが、「実行時」を選択すると、1つだけを表現できます。</target>
        </trans-unit>
        <trans-unit id="9d3b19afacd01fa6760d29ccb31fceacd0420b99" translate="yes" xml:space="preserve">
          <source>The usual instruction to new Python users:</source>
          <target state="translated">初めてのPythonユーザーへのお決まりの指示。</target>
        </trans-unit>
        <trans-unit id="83431a0cce73cc9ea555626b7407f498ddeab772" translate="yes" xml:space="preserve">
          <source>There are 3 cases I see where you might run into this problem:</source>
          <target state="translated">この問題に遭遇する可能性があると思われるケースは3つあります。</target>
        </trans-unit>
        <trans-unit id="7d403bffc3efdc0e15e597031a66e58b86f1e427" translate="yes" xml:space="preserve">
          <source>There may be legitimate use cases for the 'Wrong Method' whereby the programmer intended the default list parameter to be shared, but this is more likely the exception than the rule.</source>
          <target state="translated">プログラマがデフォルトのリストパラメータを共有することを意図した「Wrong Method」の正当な使用例があるかもしれませんが、これは規則というよりも例外である可能性が高いです。</target>
        </trans-unit>
        <trans-unit id="e122131b734ffdd0c974c11125de9bf4d4ac1de3" translate="yes" xml:space="preserve">
          <source>They stay mutated because they are the same object each time.</source>
          <target state="translated">彼らは毎回同じ物体であるため、突然変異したままです。</target>
        </trans-unit>
        <trans-unit id="42f87dc35743615ca50ba7a4e0a765f48628f38e" translate="yes" xml:space="preserve">
          <source>This &quot;bug&quot; gave me a lot of overtime work hours! But I'm beginning to see a potential use of it (but I would have liked it to be at the execution time, still)</source>
          <target state="translated">この「バグ」のせいで残業時間が多くなってしまいました! とはいえ、使い道の可能性が見えてきました(それでも実行時にはあってほしかったですが</target>
        </trans-unit>
        <trans-unit id="09c551bd076af75de6f7f75f84e6e19528a70b20" translate="yes" xml:space="preserve">
          <source>This actually has nothing to do with default values, other than that it often comes up as an unexpected behaviour when you write functions with mutable default values.</source>
          <target state="translated">これは実際にはデフォルト値とは何の関係もありませんが、デフォルト値が変更可能な関数を書いたときに予期せぬ動作として出てくることがよくあります。</target>
        </trans-unit>
        <trans-unit id="91bf40b75c5eb2ec9fc9e9af2dee27f147910385" translate="yes" xml:space="preserve">
          <source>This behavior is easy explained by:</source>
          <target state="translated">この挙動は簡単に説明できます。</target>
        </trans-unit>
        <trans-unit id="8e882fce06b5aa8e4902377bf10643c0438bee5c" translate="yes" xml:space="preserve">
          <source>This behavior is not surprising if you take the following into consideration:</source>
          <target state="translated">この行動は、以下のようなことを考慮しても不思議ではありません。</target>
        </trans-unit>
        <trans-unit id="53ed8453d80a594313b39f617a24cd922589e53c" translate="yes" xml:space="preserve">
          <source>This code suffers from the exact same unexpected happenstance. bananas is a class attribute, and hence, when you add things to it, it's added to all instances of that class. The reason is exactly the same.</source>
          <target state="translated">このコードは全く同じ予期せぬハプニングに悩まされています。バナナはクラスの属性であり、それゆえ、それに物を追加すると、そのクラスの全てのインスタンスに追加されます。理由は全く同じです。</target>
        </trans-unit>
        <trans-unit id="5aa4790f0f096239796bd26d7ab23aed623fa5b3" translate="yes" xml:space="preserve">
          <source>This implementation ensures that each call to the function either receives the default list or else the list passed to the function.</source>
          <target state="translated">この実装では、関数を呼び出すたびにデフォルトのリストを受け取るか、関数に渡されたリストを受け取るようにしています。</target>
        </trans-unit>
        <trans-unit id="37aa3fb7ad8287604da5115ea29978831dfe3dda" translate="yes" xml:space="preserve">
          <source>This information is very useful for things like document generation, metaprogramming, decorators etc.</source>
          <target state="translated">この情報は、ドキュメント生成、メタプログラミング、デコレータなどのようなものに非常に役立ちます。</target>
        </trans-unit>
        <trans-unit id="643cda6d4c6e34a04adb1a217260ad6665380a64" translate="yes" xml:space="preserve">
          <source>This is particularly neat for functions that take multiple arguments. Compare:</source>
          <target state="translated">これは、複数の引数を取る関数の場合に特に便利です。比較します。</target>
        </trans-unit>
        <trans-unit id="e564daaa17ad1d2d62e46bbb59e0067c087845a8" translate="yes" xml:space="preserve">
          <source>This order of execution is frequently confusing to new users of Python. If you understand the Python execution model, then it becomes quite expected.</source>
          <target state="translated">この実行順序は、Pythonを初めて使う人にとっては戸惑うことが多いです。Pythonの実行モデルを理解していれば、かなり期待できるようになります。</target>
        </trans-unit>
        <trans-unit id="b99a6bdeb57707ff2643e03cc6dbbbaa2acc3f12" translate="yes" xml:space="preserve">
          <source>This returns a list of functions that return 0,1,2,3... respectively.  If the behaviour is changed, they will instead bind &lt;code&gt;i&lt;/code&gt; to the &lt;em&gt;call-time&lt;/em&gt; value of i, so you would get a list of functions that all returned &lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">これは、それぞれ0、1、2、3 ...を返す関数のリストを返します。 動作が変更された場合は、代わりに &lt;code&gt;i&lt;/code&gt; をiの&lt;em&gt;呼び出し時の&lt;/em&gt;値にバインドするため、すべてが &lt;code&gt;9&lt;/code&gt; を返した関数のリストを取得します。</target>
        </trans-unit>
        <trans-unit id="d1a3982204610904ddbc4a70de5860ec7e166984" translate="yes" xml:space="preserve">
          <source>This uses the None singleton as a sentinel object to tell the function whether or not we've gotten an argument other than the default. If we get no argument, then we actually want to use a new empty list, &lt;code&gt;[]&lt;/code&gt;, as the default.</source>
          <target state="translated">これは、Noneシングルトンを番兵オブジェクトとして使用して、デフォルト以外の引数を取得したかどうかを関数に通知します。 引数がない場合、実際には新しい空のリスト &lt;code&gt;[]&lt;/code&gt; をデフォルトとして使用します。</target>
        </trans-unit>
        <trans-unit id="4aedb952cd727e6e69581496e8e0b6ab6127d03c" translate="yes" xml:space="preserve">
          <source>To further validate my answer, let's take a look at two additional codes.</source>
          <target state="translated">私の答えをさらに検証するために、さらに2つのコードを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="3488d10d037c07a6d63c40837ee02a62ef16f935" translate="yes" xml:space="preserve">
          <source>To further verify that the list in &lt;code&gt;__defaults__&lt;/code&gt; is the same as that used in the function &lt;code&gt;func&lt;/code&gt; you can just change your function to return the &lt;code&gt;id&lt;/code&gt; of the list &lt;code&gt;a&lt;/code&gt; used inside the function body. Then, compare it to the list in &lt;code&gt;__defaults__&lt;/code&gt; (position &lt;code&gt;[0]&lt;/code&gt; in &lt;code&gt;__defaults__&lt;/code&gt;) and you'll see how these are indeed refering to the same list instance:</source>
          <target state="translated">&lt;code&gt;__defaults__&lt;/code&gt; のリストが関数 &lt;code&gt;func&lt;/code&gt; で使用されているリストと同じであることをさらに確認するには、関数を変更して、関数本体内で使用されているリストの &lt;code&gt;id&lt;/code&gt; を返すだけです。 次に、それを &lt;code&gt;__defaults__&lt;/code&gt; のリスト（ __defaults__の &lt;code&gt;[0]&lt;/code&gt; の位置）と比較すると、これらが実際に同じリストインスタンスを参照していることがわかります。</target>
        </trans-unit>
        <trans-unit id="6c169f56bd97d585a628344306275a6fbb160c64" translate="yes" xml:space="preserve">
          <source>To make things simpler for this discussion, let's temporarily give the unnamed list a name. How about &lt;code&gt;pavlo&lt;/code&gt; ?</source>
          <target state="translated">この議論を簡単にするために、名前のないリストに一時的に名前を付けましょう。 &lt;code&gt;pavlo&lt;/code&gt; どうですか？</target>
        </trans-unit>
        <trans-unit id="e3a6729bfe6a04ecd5a00fc68b6c0f6331500e7a" translate="yes" xml:space="preserve">
          <source>To me, it seems that the design decision was relative to where to put the scope of parameters: inside the function or &quot;together&quot; with it?</source>
          <target state="translated">私にとっては、パラメータのスコープをどこに置くかという設計上の決定は、関数の中に置くのか、それとも関数と一緒に &quot;一緒に &quot;置くのかという相対的なものだったように思えます。</target>
        </trans-unit>
        <trans-unit id="636d1dcd268f11a46b28fe964396e61a54cf23da" translate="yes" xml:space="preserve">
          <source>Ugly, but it works.</source>
          <target state="translated">不細工だが、効果はある。</target>
        </trans-unit>
        <trans-unit id="f1f3a34856e7b498ab581f67c98cdf2d11513052" translate="yes" xml:space="preserve">
          <source>Upon &lt;code&gt;L = []&lt;/code&gt;, the assignment cannot succeed at &lt;code&gt;foo.func_defs[0]&lt;/code&gt;, because that attribute is read-only.</source>
          <target state="translated">&lt;code&gt;L = []&lt;/code&gt; 場合、属性は読み取り専用であるため、 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; での割り当ては成功しません。</target>
        </trans-unit>
        <trans-unit id="b4add7a466713c04e3a9ff607faa91aff366d0f8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;None&lt;/code&gt; as your default value (or a nonce &lt;code&gt;object&lt;/code&gt;), and switch on that to create your values at runtime; or</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; をデフォルト値（またはnonce &lt;code&gt;object&lt;/code&gt; ）として使用し、それをオンにして実行時に値を作成します。 または</target>
        </trans-unit>
        <trans-unit id="ea379d2578b870e14c73410aa538eccdf7d0c72c" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;lambda&lt;/code&gt; as your default parameter, and call it within a try block to get the default value (this is the sort of thing that lambda abstraction is for).</source>
          <target state="translated">&lt;code&gt;lambda&lt;/code&gt; をデフォルトのパラメーターとして使用し、それをtryブロック内で呼び出してデフォルト値を取得します（これはラムダ抽象化が対象とするものです）。</target>
        </trans-unit>
        <trans-unit id="9ce0fb10a3874ece19a632c8bbfe4072e2abf695" translate="yes" xml:space="preserve">
          <source>We can get information about the arguments and defaults using the &lt;code&gt;inspect&lt;/code&gt; module, which</source>
          <target state="translated">&lt;code&gt;inspect&lt;/code&gt; モジュールを使用して、引数とデフォルトに関する情報を取得できます。</target>
        </trans-unit>
        <trans-unit id="f43fd0e1e7b924e195b0d1f43667f4b3ecb78cc3" translate="yes" xml:space="preserve">
          <source>We will &quot;fix&quot; this behavior with a decorator that will copy the default value instead of reusing the same instance for each positional argument left at its default value.</source>
          <target state="translated">デフォルト値のままの各位置引数に対して同じインスタンスを再利用するのではなく、デフォルト値をコピーするデコレータを使って、この動作を「修正」します。</target>
        </trans-unit>
        <trans-unit id="028722da6bbfb13719d096b837a20e83f8b33121" translate="yes" xml:space="preserve">
          <source>Well, the reason is quite simply that bindings are done when code is executed, and the function definition is executed, well... when the functions is defined.</source>
          <target state="translated">まあ、理由は非常に単純で、バインディングはコードが実行されたときに行われ、関数の定義が実行されたときに、まあ...関数の定義が実行されたときに行われます。</target>
        </trans-unit>
        <trans-unit id="7ad15b2528d3a839026c0d58cd1ee45b2711f4f7" translate="yes" xml:space="preserve">
          <source>What you're asking is why this:</source>
          <target state="translated">何を聞いているのかというと、これはなぜなのかということです。</target>
        </trans-unit>
        <trans-unit id="bb251fe5322c9cbb5669eb17fcc4c69cba91f98f" translate="yes" xml:space="preserve">
          <source>When I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple &lt;code&gt;(&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)&lt;/code&gt;</source>
          <target state="translated">eatの宣言を見ると、最も驚くべきことは、最初のパラメーターが指定されていない場合、それがタプル &lt;code&gt;(&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)&lt;/code&gt; 等しいと考えることです。</target>
        </trans-unit>
        <trans-unit id="92837d652717841e4dbdd22b5957c04117add88c" translate="yes" xml:space="preserve">
          <source>When Python encounters it, the first thing it will do is compile it in order to create a &lt;code&gt;code&lt;/code&gt; object for this function. While this compilation step is done, &lt;em&gt;Python &lt;strong&gt;evaluates&lt;/strong&gt;* and then &lt;strong&gt;stores&lt;/strong&gt; the default arguments (an empty list &lt;code&gt;[]&lt;/code&gt; here) in the function object itself&lt;/em&gt;. As the top answer mentioned: the list &lt;code&gt;a&lt;/code&gt; can now be considered a &lt;em&gt;member&lt;/em&gt; of the function &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">Pythonがそれを検出すると、最初に行うのは、この関数の &lt;code&gt;code&lt;/code&gt; オブジェクトを作成するためにコンパイルすることです。 このコンパイル手順の実行中、 &lt;em&gt;Python &lt;strong&gt;は&lt;/strong&gt; *を&lt;strong&gt;評価し&lt;/strong&gt; 、デフォルトの引数（ここでは空のリスト &lt;code&gt;[]&lt;/code&gt; ）を関数オブジェクト自体に&lt;strong&gt;格納&lt;/strong&gt;します&lt;/em&gt; 。 一番上の答えが述べたように、リスト &lt;code&gt;a&lt;/code&gt; は関数 &lt;code&gt;func&lt;/code&gt; の &lt;em&gt;メンバー&lt;/em&gt;と見なすことができます。</target>
        </trans-unit>
        <trans-unit id="cd17f911f362a654b5a6c64b275c0e88df650e11" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;foo&lt;/code&gt; function object is instantiated, &lt;code&gt;foo.func_defs[0]&lt;/code&gt; is set to &lt;code&gt;None&lt;/code&gt;, an immutable object.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 関数オブジェクトがインスタンス化されると、 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; は不変オブジェクトである &lt;code&gt;None&lt;/code&gt; に設定されます。</target>
        </trans-unit>
        <trans-unit id="6bb5893e3a075febba63fa1345cc1545dec24f55" translate="yes" xml:space="preserve">
          <source>When the function is executed with defaults (with no parameter specified for &lt;code&gt;L&lt;/code&gt; in the function call), &lt;code&gt;foo.func_defs[0]&lt;/code&gt; (&lt;code&gt;None&lt;/code&gt;) is available in the local scope as &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">デフォルトで（関数呼び出しの &lt;code&gt;L&lt;/code&gt; にパラメーターが指定されていない）関数を実行すると、ローカルスコープで &lt;code&gt;foo.func_defs[0]&lt;/code&gt; （ &lt;code&gt;None&lt;/code&gt; ）が &lt;code&gt;L&lt;/code&gt; として使用できます。</target>
        </trans-unit>
        <trans-unit id="c90da9c4543da64cdb8845246bc7bf7320e0bc1d" translate="yes" xml:space="preserve">
          <source>When they are mutable, when mutated (for example, by adding an element to it) they remain mutated on consecutive calls.</source>
          <target state="translated">それらが突然変異可能である場合、(例えば、要素を追加することで)突然変異した場合、それらは連続した呼び出しでも突然変異したままになります。</target>
        </trans-unit>
        <trans-unit id="2241f2b26702e693ed138e31ffa8bd03750a3109" translate="yes" xml:space="preserve">
          <source>When we do this:</source>
          <target state="translated">これをやるときは</target>
        </trans-unit>
        <trans-unit id="6912ff10f6eb1fb687cb173f4f87e2aa8cb150d3" translate="yes" xml:space="preserve">
          <source>Why don't you introspect?</source>
          <target state="translated">内省してみませんか?</target>
        </trans-unit>
        <trans-unit id="287fc26c3268d8d1c2a9357d670b0099b1576d07" translate="yes" xml:space="preserve">
          <source>Why should the &lt;code&gt;a=[]&lt;/code&gt; in</source>
          <target state="translated">なぜ &lt;code&gt;a=[]&lt;/code&gt; に</target>
        </trans-unit>
        <trans-unit id="52b2c683c383df4eb8aa68d958bd6badb17f2b85" translate="yes" xml:space="preserve">
          <source>Yes, it is unexpected. But once the penny drops, it fits in perfectly with how Python works in general. In fact, it's a good teaching aid, and once you understand why this happens, you'll grok python much better.</source>
          <target state="translated">はい、予想外です。しかし、一旦ペニーが落ちると、それはPythonの一般的な動作の仕方に完全に適合します。実際、これは良い教材であり、なぜこのようなことが起こるのかを理解すれば、Pythonをよりよく理解することができるでしょう。</target>
        </trans-unit>
        <trans-unit id="9083597dacf68f7853fb01578d3aa2ab71e8663f" translate="yes" xml:space="preserve">
          <source>You can get round this by replacing the object (and therefore the tie with the scope):</source>
          <target state="translated">オブジェクトを置き換えることで、これを回避することができます(したがって、スコープとのタイを置き換えることで)。</target>
        </trans-unit>
        <trans-unit id="b512ff0f2aacb271cc653788c90da69d6dfc77d3" translate="yes" xml:space="preserve">
          <source>You can verify that they are one and the same object by using &lt;code&gt;id&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; を使用して、それらが同じオブジェクトであることを確認できます。</target>
        </trans-unit>
        <trans-unit id="b7a57f1c427b2aba87570b0fda4061b9802afcc3" translate="yes" xml:space="preserve">
          <source>You intend to leave the argument unmodified, but you accidentally &lt;em&gt;did&lt;/em&gt; modify it. That's a bug, fix it.</source>
          <target state="translated">引数を変更しないでおくつもりですが、誤っ&lt;em&gt;て&lt;/em&gt;変更しました。 それはバグです。修正してください。</target>
        </trans-unit>
        <trans-unit id="c2929c645da85b138bef1656c13169d0ec045e7d" translate="yes" xml:space="preserve">
          <source>You intend to modify the argument as a side effect of the function. In this case it &lt;em&gt;never makes sense&lt;/em&gt; to have a default argument. The only exception is when you're abusing the argument list to have function attributes, e.g. &lt;code&gt;cache={}&lt;/code&gt;, and you wouldn't be expected to call the function with an actual argument at all.</source>
          <target state="translated">関数の副作用として引数を変更しようとしています。 この場合、デフォルトの引数を持つ&lt;em&gt;ことは決して意味&lt;/em&gt;があり&lt;em&gt;ません&lt;/em&gt; 。 唯一の例外は、引数リストを悪用して関数属性（例： &lt;code&gt;cache={}&lt;/code&gt; ）を設定する場合で、実際の引数を指定して関数を呼び出すことはまったく想定されていません。</target>
        </trans-unit>
        <trans-unit id="17d9e231f7ae8537e606b6c0973a016f0c3b9581" translate="yes" xml:space="preserve">
          <source>You intend to modify the argument for use inside the function, but didn't expect the modification to be viewable outside of the function. In that case you need to make a &lt;em&gt;copy&lt;/em&gt; of the argument, whether it was the default or not! Python is not a call-by-value language so it doesn't make the copy for you, you need to be explicit about it.</source>
          <target state="translated">関数内で使用するために引数を変更するつもりでしたが、関数の外で変更が表示されるとは想定していませんでした。 その場合、それがデフォルトかどうかにかかわらず、引数の&lt;em&gt;コピー&lt;/em&gt;を作成する必要があります！ Pythonは値渡し言語ではないため、コピーは作成されません。明示する必要があります。</target>
        </trans-unit>
        <trans-unit id="a6ced87465fcf1eeb8fdd29b614471918519675e" translate="yes" xml:space="preserve">
          <source>Your example is a good one of a case where Python newcomers will be surprised and bitten.  But I'd argue that if we &quot;fixed&quot; this, then that would only create a different situation where they'd be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they're writing.</source>
          <target state="translated">あなたの例は、Pythonの新規参入者が驚いてかじられるケースの良い例です。しかし、もしこれを「修正」した場合、彼らが噛まれてしまうような別の状況が生まれるだけで、その状況はさらに直感的ではなくなるでしょう。さらに、これは可変変数を扱うときには常にそうです。</target>
        </trans-unit>
        <trans-unit id="27311373d31b73eb41d1e0b30e06efc32dc97a21" translate="yes" xml:space="preserve">
          <source>Your original &lt;code&gt;foo&lt;/code&gt;, with a default argument, shouldn't be modifying &lt;code&gt;a&lt;/code&gt; whether it was explicitly passed in or got the default value. Your code should leave mutable arguments alone unless it is clear from the context/name/documentation that the arguments are supposed to be modified. Using mutable values passed in as arguments as local temporaries is an extremely bad idea, whether we're in Python or not and whether there are default arguments involved or not.</source>
          <target state="translated">デフォルトの引数を持つ元の &lt;code&gt;foo&lt;/code&gt; は 、明示的に渡されたか、デフォルト値を取得し &lt;code&gt;a&lt;/code&gt; かを変更してはなりません。 引数が変更されることになっていることがcontext / name / documentationから明らかでない限り、コードは変更可能な引数をそのままにする必要があります。 引数として渡された可変値をローカル一時変数として使用することは、Pythonを使用しているかどうかに関係なく、デフォルトの引数が含まれているかどうかに関係なく、非常に悪い考えです。</target>
        </trans-unit>
        <trans-unit id="a47c48016c7bd5e01546ccb1b762c78b706d5abe" translate="yes" xml:space="preserve">
          <source>[] is an object, so python pass the reference of [] to &lt;code&gt;a&lt;/code&gt;, i.e., &lt;code&gt;a&lt;/code&gt; is only a pointer to [] which lies in memory as an object. There is only one copy of [] with, however, many references to it. For the first foo(), the list [] is changed to &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; by append method. But Note that there is only one copy of the list object and this object now becomes &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt;. When running the second foo(), what effbot webpage says (items is not evaluated any more) is wrong. &lt;code&gt;a&lt;/code&gt; is evaluated to be the list object, although now the content of the object is &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt;. This is the effect of passing by reference! The result of foo(3) can be easily derived in the same way.</source>
          <target state="translated">[]はオブジェクトであるため、Pythonは[]の参照をに渡します。つまり、 &lt;code&gt;a&lt;/code&gt; はオブジェクトとしてメモリ内にある[]へのポインタにすぎません。 []のコピーは1つしかありませんが、多くの参照があります。 最初のfoo（）では、リスト[]がappendメソッドによって&lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1に&lt;/a&gt;変更されます。 ただし、リストオブジェクトのコピーは1つしかなく、このオブジェクトは&lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1に&lt;/a&gt;なることに注意してください。 2番目のfoo（）を実行すると、effbot Webページが言う（アイテムはもう評価されない）のが間違っています。 &lt;code&gt;a&lt;/code&gt; はリストオブジェクトであると評価されますが、オブジェクトのコンテンツは&lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt;です。 これは参照渡しの効果です！ foo（3）の結果は、同じ方法で簡単に導出できます。</target>
        </trans-unit>
        <trans-unit id="811a1b05ff4f47b946f5851e4e0919d50dfa1cfc" translate="yes" xml:space="preserve">
          <source>and running it with &lt;code&gt;python example.py&lt;/code&gt;:</source>
          <target state="translated">そしてそれを &lt;code&gt;python example.py&lt;/code&gt; で実行します ：</target>
        </trans-unit>
        <trans-unit id="049874c49f0ace21f9f13dd31c57abc695140bba" translate="yes" xml:space="preserve">
          <source>as you'll notice, &lt;code&gt;input()&lt;/code&gt; is called before the process of building the function and binding it to the name &lt;code&gt;bar&lt;/code&gt; is made.</source>
          <target state="translated">お気づきのように、 &lt;code&gt;input()&lt;/code&gt; は、関数を作成して名前 &lt;code&gt;bar&lt;/code&gt; バインドするプロセスが行われる前に呼び出されます。</target>
        </trans-unit>
        <trans-unit id="3375274202e5815d3135c4440713525187e9f33a" translate="yes" xml:space="preserve">
          <source>everything is passed by reference</source>
          <target state="translated">すべからく参照で渡される</target>
        </trans-unit>
        <trans-unit id="127ad2d11d264ef1bc3b7c9367a87c065c2e20d2" translate="yes" xml:space="preserve">
          <source>except for the case of explicitly calling func(None, None), which we'll ignore.</source>
          <target state="translated">は、明示的に func(None,None)を呼び出す場合を除き、無視します。</target>
        </trans-unit>
        <trans-unit id="fc5c678a45bcac56840b3c908642740f5ede6d3d" translate="yes" xml:space="preserve">
          <source>function (class etc.) declaration is executed only once, creating all default value objects</source>
          <target state="translated">関数宣言は一度だけ実行され、すべてのデフォルト値オブジェクトが作成されます。</target>
        </trans-unit>
        <trans-unit id="71759c14baa0f1b45b053d0754f9b76a716165c8" translate="yes" xml:space="preserve">
          <source>instantiate a new list on function definition and not on invocation?
It's just like you're asking &quot;if the user doesn't provide the argument then &lt;em&gt;instantiate&lt;/em&gt; a new list and use it as if it was produced by the caller&quot;.
I think this is ambiguous instead:</source>
          <target state="translated">呼び出しではなく関数定義で新しいリストをインスタンス化しますか？ それは、「ユーザーが引数を提供しない場合は、新しいリストを&lt;em&gt;インスタンス化&lt;/em&gt;して、呼び出し元によって生成された場合と同様に使用する」ように要求するのと同じです。 これは曖昧だと思います。</target>
        </trans-unit>
        <trans-unit id="9d29cbd7a4d1e405b35c263d8e5d5507492f015a" translate="yes" xml:space="preserve">
          <source>is almost exactly equivalent to this:</source>
          <target state="translated">はほぼこれに相当します。</target>
        </trans-unit>
        <trans-unit id="d94296d98f302fe54eca1ccc91cf45236ffa89e2" translate="yes" xml:space="preserve">
          <source>isn't internally equivalent to this:</source>
          <target state="translated">は内部的にはこれに相当するものではありません。</target>
        </trans-unit>
        <trans-unit id="3e5690a3202553a2f619db51e48332229bfe602f" translate="yes" xml:space="preserve">
          <source>it is entirely consistent to hold to both of the features above and still make another point:</source>
          <target state="translated">上記の両方の特徴を保持しながら、別のポイントを主張することは完全に一貫しています。</target>
        </trans-unit>
        <trans-unit id="39fcd29280818de6a833974667212de642dcf2a7" translate="yes" xml:space="preserve">
          <source>observing that the id is the same each time the list is referenced,</source>
          <target state="translated">リストが参照されるたびに id が同じであることを観察します。</target>
        </trans-unit>
        <trans-unit id="d8e7da304415824d87e81f7b39df6675059d9a54" translate="yes" xml:space="preserve">
          <source>observing that the list stays changed when the function that uses it is called a second time,</source>
          <target state="translated">リストを使用している関数が2回目に呼び出されたときに、リストが変更されたままになることを観察します。</target>
        </trans-unit>
        <trans-unit id="b573226ee49e1a1dd733f88915532ed8bd52e8f9" translate="yes" xml:space="preserve">
          <source>observing the order in which the output is printed from the source (which I conveniently numbered for you):</source>
          <target state="translated">ソースから出力が印刷される順番を観察しています(私はあなたのために便利な番号を付けました)。</target>
        </trans-unit>
        <trans-unit id="04c9c0f5ccf58a5d42c14519b24d6f2145c58d5f" translate="yes" xml:space="preserve">
          <source>prints the following</source>
          <target state="translated">次のように表示されます。</target>
        </trans-unit>
        <trans-unit id="db480f941abc083354113eeeff05d261f2c92991" translate="yes" xml:space="preserve">
          <source>seeing that the list is created before the function has finished compiling to a function object,</source>
          <target state="translated">関数が関数オブジェクトへのコンパイルを終了する前にリストが作成されていることを確認します。</target>
        </trans-unit>
        <trans-unit id="7fae1298345bf082e2261fee60080aa9d63fe920" translate="yes" xml:space="preserve">
          <source>then if default parameters were bound at function execution rather than function declaration then I would be astonished (in a very bad way) to discover that fruits had been changed.  This would be more astonishing IMO than discovering that your &lt;code&gt;foo&lt;/code&gt; function above was mutating the list.</source>
          <target state="translated">関数の宣言ではなく、関数の実行時にデフォルトのパラメーターがバインドされている場合、果物が変更されたことを（非常に悪い方法で）びっくりします。 これは、上記の &lt;code&gt;foo&lt;/code&gt; 関数がリストを変更していることを発見するよりも、驚くべきIMOです。</target>
        </trans-unit>
        <trans-unit id="f16bec6158470b4bee129a9e6c86214a2e496fdf" translate="yes" xml:space="preserve">
          <source>user, do you want &lt;code&gt;a&lt;/code&gt; to default to the datetime corresponding to when you're defining or executing &lt;code&gt;x&lt;/code&gt;?
In this case, as in the previous one, I'll keep the same behaviour as if the default argument &quot;assignment&quot; was the first instruction of the function (&lt;code&gt;datetime.now()&lt;/code&gt; called on function invocation).
On the other hand, if the user wanted the definition-time mapping he could write:</source>
          <target state="translated">ユーザー、 &lt;code&gt;x&lt;/code&gt; を定義または実行するときに対応する日時にデフォルト設定しますか？ この場合、前の例と同様に、デフォルトの引数「割り当て」が関数の最初の命令である場合と同じ動作を維持します（関数の呼び出し時に &lt;code&gt;datetime.now()&lt;/code&gt; が呼び出されます）。 一方、ユーザーが定義時のマッピングを希望する場合は、次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="translated">with</target>
        </trans-unit>
        <trans-unit id="06e3de5b5b2d499fee4d0c87a0745254a4a566cb" translate="yes" xml:space="preserve">
          <source>you expect to get a &lt;strong&gt;new&lt;/strong&gt; list referenced by &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">によって参照される&lt;strong&gt;新しい&lt;/strong&gt;リストを取得する必要があります。</target>
        </trans-unit>
        <trans-unit id="8c194c14b318f40b680d2378e5d49d583177218c" translate="yes" xml:space="preserve">
          <source>“Least Astonishment” and the Mutable Default Argument</source>
          <target state="translated">&quot;最小驚愕」と不変の既定論証</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
