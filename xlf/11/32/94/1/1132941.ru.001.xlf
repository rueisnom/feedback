<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1132941">
    <body>
      <group id="1132941">
        <trans-unit id="b69b153d9b8b6ca5cc39aae8241344dc670096ea" translate="yes" xml:space="preserve">
          <source>&quot;All functions with this problem &lt;strong&gt;suffer also from similar side effect problem on the actual parameter&lt;/strong&gt;,&quot;</source>
          <target state="translated">&amp;laquo;Все функции с этой проблемой &lt;strong&gt;страдают также от аналогичной проблемы побочных эффектов на фактический параметр&lt;/strong&gt; &amp;raquo;</target>
        </trans-unit>
        <trans-unit id="626c5410f93ad070237bab8024217f1cdd086983" translate="yes" xml:space="preserve">
          <source>... we assign the argument &lt;code&gt;a&lt;/code&gt; to an &lt;em&gt;unnamed&lt;/em&gt; list, if the caller does not pass the value of a.</source>
          <target state="translated">... мы присваиваем аргумент &lt;code&gt;a&lt;/code&gt; &lt;em&gt;неназванному&lt;/em&gt; списку, если вызывающая сторона не передает значение a.</target>
        </trans-unit>
        <trans-unit id="d6ae47a54ed3aae922aa9b755c46be05126dc9cc" translate="yes" xml:space="preserve">
          <source>...all variables found outside of the innermost scope are
  read-only (&lt;strong&gt;&lt;em&gt;an attempt to write to such a variable will simply create a
  new local variable in the innermost scope, leaving the identically
  named outer variable unchanged&lt;/em&gt;&lt;/strong&gt;).</source>
          <target state="translated">... все переменные, найденные вне самой внутренней области, доступны только для чтения ( &lt;strong&gt;&lt;em&gt;попытка записи в такую ​​переменную просто создаст новую локальную переменную в самой внутренней области, оставив внешнюю переменную с таким же именем без изменений&lt;/em&gt;&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="ce4a03df48f71c59cb88d1614e04c355fe07eb41" translate="yes" xml:space="preserve">
          <source>1)  The so-called problem of &quot;Mutable Default Argument&quot; is in general a special example demonstrating that:</source>
          <target state="translated">1)Так называемая проблема &quot;Аргумент по умолчанию&quot; в целом является особым примером,демонстрирующим это:</target>
        </trans-unit>
        <trans-unit id="7ae49a8787afe33029393476223d3e6b04a350d7" translate="yes" xml:space="preserve">
          <source>3) In some cases is &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;the mutable behavior of default parameters useful&lt;/a&gt;.</source>
          <target state="translated">3) В некоторых случаях &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;изменчивое поведение параметров по умолчанию полезно&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="349e3dc6e53ca45e7b264f3f4ece59155e2a0d64" translate="yes" xml:space="preserve">
          <source>5 points in defense of Python</source>
          <target state="translated">5 очков в защиту Питона</target>
        </trans-unit>
        <trans-unit id="5619d3a6ff41fedee09fe44cfec87d091658e509" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;1</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt;1</target>
        </trans-unit>
        <trans-unit id="f9a7d25963aa0148809943888747c7bfdbad1397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;2</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt;2</target>
        </trans-unit>
        <trans-unit id="f2848d4bf5368cd6cc2a23c96bcb460686851bd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[]&lt;/code&gt; is an object, so is &lt;code&gt;None&lt;/code&gt; (the former is mutable while the latter is immutable. But the mutability has nothing to do with the question). None is somewhere in the space but we know it's there and there is only one copy of None there. So every time foo is invoked, items is evaluated (as opposed to some answer that it is only evaluated once) to be None, to be clear, the reference (or the address) of None. Then in the foo, item is changed to [], i.e., points to another object which has a different address.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; - это объект, как и &lt;code&gt;None&lt;/code&gt; (первый является изменяемым, а второй неизменным. Но изменчивость не имеет ничего общего с вопросом). Никто не находится где-то в пространстве, но мы знаем, что это там, и там есть только одна копия Никого. Таким образом, каждый раз, когда вызывается foo, элементы оцениваются (в отличие от некоторого ответа, что он оценивается только один раз) как None, чтобы быть понятным, ссылка (или адрес) None. Затем в foo элемент изменяется на [], т. Е. Указывает на другой объект с другим адресом.</target>
        </trans-unit>
        <trans-unit id="0b51475de74c8a0af3e8ac61016a0b03493b9c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; doesn't change - every assignment call creates new int object - new object is printed</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; не меняется - каждый вызов присваивания создает новый объект int - печатается новый объект</target>
        </trans-unit>
        <trans-unit id="c91d4e033dfa8facf99b416bc8eb05efa39a8648" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; doesn't change - new array is build from default value and printed</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; не изменяется - новый массив строится из значения по умолчанию и печатается</target>
        </trans-unit>
        <trans-unit id="99868d483227e38115a490908f9eb6410e764c96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; changes - operation is performed on same object - and it is printed</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; изменения - операция выполняется над тем же объектом - и она печатается</target>
        </trans-unit>
        <trans-unit id="1dce96d08fb23e6dd9bf8c83e0ce03a0c31931c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Astonished?&lt;/em&gt; The value inside the object changes! Consecutive calls to the function will now simply append to that embedded &lt;code&gt;list&lt;/code&gt; object:</source>
          <target state="translated">&lt;em&gt;Изумленные?&lt;/em&gt; Значение внутри объекта меняется! Последовательные вызовы функции теперь просто добавляются к этому встроенному объекту &lt;code&gt;list&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9a5e006676bccb5e949d65e43cc04bfdb3e0f5c0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This is not a design flaw&lt;/em&gt;. Anyone who trips over this is doing something wrong.</source>
          <target state="translated">&lt;em&gt;Это не недостаток дизайна&lt;/em&gt; . Тот, кто спотыкается об этом, делает что-то не так</target>
        </trans-unit>
        <trans-unit id="0bb5707416517e01b1b19796f5b4d8047f7be81f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(1)&lt;/strong&gt; is described in the Python &lt;a href=&quot;http://docs.python.org/tutorial/classes.html&quot;&gt;tutorial on classes&lt;/a&gt;. In an attempt to assign a value to a read-only class attribute:</source>
          <target state="translated">&lt;strong&gt;(1)&lt;/strong&gt; описано в &lt;a href=&quot;http://docs.python.org/tutorial/classes.html&quot;&gt;учебнике по&lt;/a&gt; Python по классам . При попытке присвоить значение атрибуту класса только для чтения:</target>
        </trans-unit>
        <trans-unit id="1e830734a74d3ffb326fa9a33d2d932c606c6e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. Производительность&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1c12447cabd52b525bef97e580f6be054679aad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Forcing bound parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. Принудительное связывание параметров&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23662664198844161cfe301172c065fd31a550b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Introspection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3. Самоанализ&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="329d395d793f53ccf44090cd1ed8d91c54ccbc68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Consistency&lt;/strong&gt;: Python &lt;em&gt;always&lt;/em&gt; passes objects, not names.
The default parameter is, obviously, part of the function 
heading (not the function body). It therefore ought to be evaluated
at module load time (and only at module load time, unless nested), not
at function call time.</source>
          <target state="translated">&lt;strong&gt;Согласованность&lt;/strong&gt; : Python &lt;em&gt;всегда&lt;/em&gt; передает объекты, а не имена. Параметр по умолчанию, очевидно, является частью заголовка функции (а не тела функции). Поэтому его следует оценивать во время загрузки модуля (и только во время загрузки модуля, если оно не вложено), а не во время вызова функции.</target>
        </trans-unit>
        <trans-unit id="cf88699ee467bc4d13c8c871f2752ff94d964b35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default parameter values are evaluated from left to right when the function definition is executed.&lt;/strong&gt; This means that the expression is evaluated once, when the function is defined, and that the same &amp;ldquo;pre-computed&amp;rdquo; value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use &lt;code&gt;None&lt;/code&gt; as the default, and explicitly test for it in the body of the function, e.g.:</source>
          <target state="translated">&lt;strong&gt;Значения параметров по умолчанию оцениваются слева направо при выполнении определения функции.&lt;/strong&gt; Это означает, что выражение вычисляется один раз, когда функция определена, и что для каждого вызова используется одно и то же &amp;laquo;предварительно вычисленное&amp;raquo; значение. Это особенно важно понимать, когда параметр по умолчанию является изменяемым объектом, таким как список или словарь: если функция изменяет объект (например, путем добавления элемента в список), значение по умолчанию фактически изменяется. Это вообще не то, что было задумано. Чтобы обойти это, используйте &lt;code&gt;None&lt;/code&gt; по умолчанию и явно протестируйте его в теле функции, например:</target>
        </trans-unit>
        <trans-unit id="539d5ec10b781d448886afa96eab4c325719e096" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Edit&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="d7ce856e37c4d17dcd955af410f64cbfd4b44efb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Meta-learning&lt;/strong&gt;: Falling into the trap is actually a very
helpful moment (at least if you are a reflective learner),
because you will subsequently better understand the point 
&quot;Consistency&quot; above and that will
teach you a great deal about Python.</source>
          <target state="translated">&lt;strong&gt;Мета-обучение&lt;/strong&gt; : Попадание в ловушку на самом деле является очень полезным моментом (по крайней мере, если вы учитесь размышлять), потому что впоследствии вы лучше поймете пункт &amp;laquo;Согласованность&amp;raquo; выше, и это многому научит вас о Python.</target>
        </trans-unit>
        <trans-unit id="2c97178ae1f0df97cdd3aaefd09767743c8eb65b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preferred Method&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Предпочитаемый метод&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="e76f2bbaaca5d9222981a5a9ed9effda9259956d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simplicity&lt;/strong&gt;: The behavior is simple in the following sense:
Most people fall into this trap only once, not several times.</source>
          <target state="translated">&lt;strong&gt;Простота&lt;/strong&gt; : поведение простое в следующем смысле: большинство людей попадают в эту ловушку только один раз, а не несколько раз.</target>
        </trans-unit>
        <trans-unit id="d8e5d785db266e5750b7b9c674b8350975a43b24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution&lt;/strong&gt;:  a &lt;strong&gt;copy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Решение&lt;/strong&gt; : &lt;strong&gt;копия&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37f9748bcb10eff54719d247d7d6981eb44d0507" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sufficient documentation&lt;/strong&gt;: In the most basic Python documentation,
the tutorial, the issue is loudly announced as
an &lt;strong&gt;&quot;Important warning&quot;&lt;/strong&gt; in the &lt;em&gt;first&lt;/em&gt; subsection of Section
&lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#default-argument-values&quot;&gt;&quot;More on Defining Functions&quot;&lt;/a&gt;.
The warning even uses boldface,
which is rarely applied outside of headings.
RTFM: Read the fine manual.</source>
          <target state="translated">&lt;strong&gt;Достаточная документация&lt;/strong&gt; : в самой базовой документации Python, учебнике, проблема громко объявлена ​​как &lt;strong&gt;&amp;laquo;Важное предупреждение&amp;raquo;&lt;/strong&gt; в &lt;em&gt;первом&lt;/em&gt; подразделе Раздела &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#default-argument-values&quot;&gt;&amp;laquo;Подробнее об определении функций&amp;raquo;&lt;/a&gt; . В предупреждении даже используется жирный шрифт, который редко применяется за пределами заголовков. RTFM: прочитайте прекрасное руководство.</target>
        </trans-unit>
        <trans-unit id="5e1364752e34f5d31f57fbb793918340fe194bee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usefulness&lt;/strong&gt;: As Frederik Lundh points out in his explanation
of &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;&quot;Default Parameter Values in Python&quot;&lt;/a&gt;, the
current behavior can be quite useful for advanced programming.
(Use sparingly.)</source>
          <target state="translated">&lt;strong&gt;Полезность&lt;/strong&gt; : как Фредерик Лунд указывает в своем объяснении &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;&amp;laquo;Значения параметров по умолчанию в Python&amp;raquo;&lt;/a&gt; , текущее поведение может быть весьма полезным для продвинутого программирования. (Используйте экономно.)</target>
        </trans-unit>
        <trans-unit id="294df7a72d2c1681571db14e9616ce4b1526495e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Wrong Method (probably...)&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Неправильный метод (вероятно ...)&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="82a5f8350abc0dbeea17f36fef8010fcc85d54f4" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;*&lt;/sup&gt; To verify that Python evaluates the default arguments during compilation of the function, try executing the following:</source>
          <target state="translated">&lt;sup&gt;*&lt;/sup&gt; Чтобы убедиться, что Python оценивает аргументы по умолчанию во время компиляции функции, попробуйте выполнить следующее:</target>
        </trans-unit>
        <trans-unit id="bb413fc5e883d792d1ef3763d765a7965fb2896f" translate="yes" xml:space="preserve">
          <source>====== No. 2 ========</source>
          <target state="translated">==============Нет.2 ============</target>
        </trans-unit>
        <trans-unit id="69abcbfba6763da9ac43abb483ce88455e698517" translate="yes" xml:space="preserve">
          <source>====== No. 3 =======</source>
          <target state="translated">==========Нет.3 =======</target>
        </trans-unit>
        <trans-unit id="b635b4f551391b730421190ef18f36b5a2349cd2" translate="yes" xml:space="preserve">
          <source>A brief introduction. First, there are two type of data types in python, one is simple elementary data type, like numbers, and another data type is objects. Second, when passing data to parameters, python pass elementary data type by value, i.e., make a local copy of the value to a local variable, but pass object by reference, i.e., pointers to the object.</source>
          <target state="translated">Краткое вступление.Во-первых,в питоне существует два типа данных,один из которых является простым элементарным типом данных,как числа,а другой тип данных-это объекты.Во-вторых,при передаче данных в параметры,питон передаёт элементарный тип данных по значению,т.е.делает локальную копию значения в локальную переменную,но передаёт объект по ссылке,т.е.указатели на объект.</target>
        </trans-unit>
        <trans-unit id="3241c6873d2d65a534f9b317f8e6387aba7f1c09" translate="yes" xml:space="preserve">
          <source>A manager of mine once had his first encounter with this feature, and called it &quot;a dramatic design flaw&quot; of the language. I replied that the behavior had an underlying explanation, and it is indeed very puzzling and unexpected if you don't understand the internals. However, I was not able to answer (to myself) the following question: what is the reason for binding the default argument at function definition, and not at function execution? I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs?)</source>
          <target state="translated">Мой менеджер однажды впервые столкнулся с этой особенностью и назвал ее &quot;драматическим дизайнерским дефектом&quot; языка.Я ответил,что поведение имело основополагающее объяснение,и это действительно очень загадочно и неожиданно,если вы не понимаете внутренностей.Однако я не смог ответить (себе)на следующий вопрос:в чем причина связывания аргумента по умолчанию при определении функции,а не при ее выполнении? Я сомневаюсь,что опытное поведение имеет практическое применение (кто на самом деле использовал статические переменные на C,без ошибок в размножении?).</target>
        </trans-unit>
        <trans-unit id="b690fd135a267cbcdaf75de80b96af3baa5767c7" translate="yes" xml:space="preserve">
          <source>A simple workaround using None</source>
          <target state="translated">Простой обходной приём с использованием None</target>
        </trans-unit>
        <trans-unit id="bdd7db67e420ecc9dcbd543e9f887304309b4542" translate="yes" xml:space="preserve">
          <source>A useful trick is to bind parameters of a lambda to the &lt;em&gt;current&lt;/em&gt; binding of a variable when the lambda is created.  For example:</source>
          <target state="translated">Полезный трюк - привязать параметры лямбды к &lt;em&gt;текущей&lt;/em&gt; привязке переменной при создании лямбды. Например:</target>
        </trans-unit>
        <trans-unit id="66dcf0d939788f48ade0f8205215ced808c313bc" translate="yes" xml:space="preserve">
          <source>Actually, this is not a design flaw, and it is not because of internals, or performance.</source>
          <target state="translated">На самом деле,это не недостаток дизайна,и не из-за интерьера или производительности.</target>
        </trans-unit>
        <trans-unit id="995d1d076d3d58278102dc33655d7de6f9e9da69" translate="yes" xml:space="preserve">
          <source>Admitting the above two points, let's explain what happened to the python code. It's only because of passing by reference for objects, but has nothing to do with mutable/immutable, or arguably the fact that &quot;def&quot; statement is executed only once when it is defined.</source>
          <target state="translated">Признавая вышесказанное,давайте объясним,что случилось с кодом питона.Это связано только с передачей по ссылке для объектов,но не имеет никакого отношения к mutableimmutable,или,возможно,с тем,что утверждение &quot;def&quot; выполняется только один раз,когда оно определено.</target>
        </trans-unit>
        <trans-unit id="12e60dab7722d48c3d6b49bcd3fb84f98b18afcc" translate="yes" xml:space="preserve">
          <source>After Python executes this definition it will take any default parameters specified (&lt;code&gt;a = []&lt;/code&gt; here) and &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy&quot;&gt;cram them in the &lt;code&gt;__defaults__&lt;/code&gt; attribute for the function object&lt;/a&gt; (relevant section: Callables):</source>
          <target state="translated">После того, как Python выполнит это определение, он возьмет любые заданные по умолчанию параметры (здесь &lt;code&gt;a = []&lt;/code&gt; ) и &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy&quot;&gt;поместит их в атрибут &lt;code&gt;__defaults__&lt;/code&gt; для объекта функции&lt;/a&gt; (соответствующий раздел: Callables):</target>
        </trans-unit>
        <trans-unit id="00ee3bf105e662d4c817e2a1dc2ea4cb63f26aa2" translate="yes" xml:space="preserve">
          <source>All with the power of introspection!</source>
          <target state="translated">Все с силой самоанализа!</target>
        </trans-unit>
        <trans-unit id="8511aa6f9e2aee5234b37fe72ed01ccf13a1f8e1" translate="yes" xml:space="preserve">
          <source>Already busy topic, but from what I read here, the following helped me realizing how it's working internally:</source>
          <target state="translated">Уже занятая тема,но из того,что я прочитал здесь,следующее помогло мне понять,как это работает внутри:</target>
        </trans-unit>
        <trans-unit id="edef5af058c46851da7320ae99d9fe37689e0b06" translate="yes" xml:space="preserve">
          <source>An absolutely safe solution is to &lt;strong&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;code&gt;deepcopy&lt;/code&gt;&lt;/strong&gt; the input object first and then to do whatever with the copy.</source>
          <target state="translated">Абсолютно безопасное решение - &lt;strong&gt; &lt;code&gt;deepcopy&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/strong&gt; или &lt;strong&gt;глубоко скопировать&lt;/strong&gt; входной объект, а затем делать с копией все, что угодно.</target>
        </trans-unit>
        <trans-unit id="09883d93fd6b6978404b7d03e6adc34d60b2d91d" translate="yes" xml:space="preserve">
          <source>Anyone tinkering with Python long enough has been bitten (or torn to pieces) by the following issue:</source>
          <target state="translated">Любого,кто достаточно долго занимался дрессировкой Python,укусил (или порвал на куски)следующий вопрос:</target>
        </trans-unit>
        <trans-unit id="7870ab2e57db73f3c412a09b43f15db1bdd86aa3" translate="yes" xml:space="preserve">
          <source>As others have extensively commented, the list parameter is bound to the function when it is defined as opposed to when it is executed.  Because lists and dictionaries are mutable, any alteration to this parameter will affect other calls to this function.  As a result, subsequent calls to the function will receive this shared list which may have been altered by any other calls to the function.  Worse yet, two parameters are using this function's shared parameter at the same time oblivious to the changes made by the other.</source>
          <target state="translated">Как уже неоднократно отмечалось,параметр list привязывается к функции,когда она определена,в отличие от того,когда она выполняется.Поскольку списки и словари являются мутируемыми,любое изменение этого параметра повлияет на другие вызовы этой функции.В результате,при последующих вызовах функции будет получен этот общий список,который мог быть изменен другими вызовами функции.Хуже того,два параметра используют общий параметр этой функции одновременно,не обращая внимания на изменения,внесенные другим параметром.</target>
        </trans-unit>
        <trans-unit id="32ec561bfb975a7dfa873e1e6e2af0f1d887859e" translate="yes" xml:space="preserve">
          <source>As soon as you get to think into this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of &quot;member data&quot; and therefore their state may change from one call to the other - exactly as in any other object.</source>
          <target state="translated">Как только вы размышляете над этим,то это полностью имеет смысл:функция-это объект,который оценивается по ее определению;по умолчанию параметры-это своего рода &quot;данные члена&quot;,и поэтому их состояние может меняться от одного вызова к другому-точно так же,как и в любом другом объекте.</target>
        </trans-unit>
        <trans-unit id="1bfc5029b5667353a593e8232b61d516f6f5fa28" translate="yes" xml:space="preserve">
          <source>As the &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;tutorial section on control flow&lt;/a&gt; says:</source>
          <target state="translated">Как сказано в &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;учебном разделе о потоке управления&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8b63ee9af6651f22cd0d28d64f81656efa3a8b0b" translate="yes" xml:space="preserve">
          <source>As you can see, there &lt;em&gt;is&lt;/em&gt; a performance benefit when using immutable default arguments.  This can make a difference if it's a frequently called function or the default argument takes a long time to construct.  Also, bear in mind that Python isn't C.  In C you have constants that are pretty much free.  In Python you don't have this benefit.</source>
          <target state="translated">Как видите, при использовании неизменяемых аргументов по умолчанию выигрыш в производительности. Это может иметь значение, если это часто вызываемая функция или для создания аргумента по умолчанию требуется много времени. Также имейте в виду, что Python не C. В C у вас есть константы, которые в значительной степени свободны. В Python у вас нет этой выгоды.</target>
        </trans-unit>
        <trans-unit id="0af2a822a9873fb57c1a705017e412da7cf6eae6" translate="yes" xml:space="preserve">
          <source>At any time, if the caller doesn't tell us what &lt;code&gt;a&lt;/code&gt; is, we reuse &lt;code&gt;pavlo&lt;/code&gt;.</source>
          <target state="translated">В любое время, если вызывающая &lt;code&gt;pavlo&lt;/code&gt; не сообщает нам, что &lt;code&gt;a&lt;/code&gt; , мы повторно используем pavlo .</target>
        </trans-unit>
        <trans-unit id="8a9041c4d4930adfbd1e5a18d381ab82f682a692" translate="yes" xml:space="preserve">
          <source>Baczek made an interesting example. Together with most of your comments and Utaal's in particular, I elaborated further:</source>
          <target state="translated">Бакчек сделал интересный пример.Вместе с большинством ваших комментариев и Утаалом,в частности,я более подробно остановился на этом:</target>
        </trans-unit>
        <trans-unit id="80f28b6534c5364d872c03c837c8604f92ca736d" translate="yes" xml:space="preserve">
          <source>But this is why the usual instruction to new users is to create their default arguments like this instead:</source>
          <target state="translated">Но именно поэтому обычной инструкцией для новых пользователей является создание их аргументов по умолчанию таким образом:</target>
        </trans-unit>
        <trans-unit id="ec8e7d1b53f4a45c292a101f3cc7d8154605e8fd" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;foo()&lt;/code&gt; again modifies &lt;code&gt;pavlo&lt;/code&gt; again:</source>
          <target state="translated">Вызов &lt;code&gt;foo()&lt;/code&gt; снова изменяет &lt;code&gt;pavlo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7f12be39dc6279d3fabca7bbf354112e20d8c45e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;foo&lt;/code&gt; without overriding a default uses that default's value from &lt;code&gt;foo.func_defs&lt;/code&gt;. In this case, &lt;code&gt;foo.func_defs[0]&lt;/code&gt; is used for &lt;code&gt;a&lt;/code&gt; within function object's code scope. Changes to &lt;code&gt;a&lt;/code&gt; change &lt;code&gt;foo.func_defs[0]&lt;/code&gt;, which is part of the &lt;code&gt;foo&lt;/code&gt; object and persists between execution of the code in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Вызов &lt;code&gt;foo&lt;/code&gt; без переопределения значения по умолчанию использует значение по умолчанию из &lt;code&gt;foo.func_defs&lt;/code&gt; . В этом случае &lt;code&gt;foo.func_defs[0]&lt;/code&gt; используется для области кода объекта функции. Изменения в изменении &lt;code&gt;foo.func_defs[0]&lt;/code&gt; , которое является частью объекта &lt;code&gt;foo&lt;/code&gt; и сохраняется между выполнением кода в &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bbb1f97b956cffee0de7b85c6ac5416fc49a2bd" translate="yes" xml:space="preserve">
          <source>Compare this:</source>
          <target state="translated">Сравните это:</target>
        </trans-unit>
        <trans-unit id="d0b35f2e80cf4078de3821051d01800d2a02ba30" translate="yes" xml:space="preserve">
          <source>Conclusion:</source>
          <target state="translated">Conclusion:</target>
        </trans-unit>
        <trans-unit id="89101438b832bbb4fe2957ecf228b15803627679" translate="yes" xml:space="preserve">
          <source>Consider the code:</source>
          <target state="translated">Рассмотрим код:</target>
        </trans-unit>
        <trans-unit id="50ce20ee2ced0781e4776bbf85a113d06f364543" translate="yes" xml:space="preserve">
          <source>Consistency already says &quot;at definition&quot;: everything else of &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; is best evaluated at definition as well. Delaying parts of it would be the astonishing choice.</source>
          <target state="translated">Согласованность уже говорит &amp;laquo;при определении&amp;raquo;: все остальное из &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; лучше всего оценивать и при определении. Задержка частей была бы удивительным выбором.</target>
        </trans-unit>
        <trans-unit id="5e80e76fecb25c751bc0072a050074d6bf8b3a02" translate="yes" xml:space="preserve">
          <source>Default arguments get evaluated at the time the function is compiled into a function object. When used by the function, multiple times by that function, they are and remain the same object.</source>
          <target state="translated">Аргументы по умолчанию вычисляются при компиляции функции в объект функции.При многократном использовании этой функцией они являются и остаются одним и тем же объектом.</target>
        </trans-unit>
        <trans-unit id="0a13adb02282a5b13ea712ef898af3b40b3c9925" translate="yes" xml:space="preserve">
          <source>Defining a function affects two scopes: the defining scope &lt;em&gt;containing&lt;/em&gt; the function, and the execution  scope &lt;em&gt;contained by&lt;/em&gt; the function. While it is pretty clear how blocks map to scopes, the question is where &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; belongs to:</source>
          <target state="translated">Определение функции влияет на две области: область определения, &lt;em&gt;содержащую&lt;/em&gt; функцию, и область выполнения, &lt;em&gt;содержащуюся&lt;/em&gt; в функции. Хотя довольно ясно, как блоки отображаются в области видимости, вопрос в том, где &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; принадлежит:</target>
        </trans-unit>
        <trans-unit id="722360c4795e6584aab950e4f9ab28bf53d453fe" translate="yes" xml:space="preserve">
          <source>Demonstration</source>
          <target state="translated">Demonstration</target>
        </trans-unit>
        <trans-unit id="0cf2dad6fd4f2a353fd61dd22952442419c00063" translate="yes" xml:space="preserve">
          <source>Does this violate the principle of &quot;Least Astonishment&quot;?</source>
          <target state="translated">Нарушает ли это принцип &quot;Наименьшего Удивления&quot;?</target>
        </trans-unit>
        <trans-unit id="87ae29dc1cc2a0f0b1d8ff4a04b54a9e84f78784" translate="yes" xml:space="preserve">
          <source>Doing the binding inside the function would mean that &lt;code&gt;x&lt;/code&gt; is effectively bound to the specified default when the function is called, not defined, something that would present a deep flaw: the &lt;code&gt;def&lt;/code&gt; line would be &quot;hybrid&quot; in the sense that part of the binding (of the function object) would happen at definition, and part (assignment of default parameters) at function invocation time.</source>
          <target state="translated">Выполнение привязки внутри функции будет означать, что &lt;code&gt;x&lt;/code&gt; эффективно привязан к указанному значению по умолчанию, когда функция вызывается, а не определяется, что представляет собой серьезный недостаток: строка &lt;code&gt;def&lt;/code&gt; будет &amp;laquo;гибридной&amp;raquo; в том смысле, что часть привязки (объекта функции) происходит при определении, а часть (назначение параметров по умолчанию) во время вызова функции.</target>
        </trans-unit>
        <trans-unit id="a1bc1de19c4470f909f862dada03b7e62dff2905" translate="yes" xml:space="preserve">
          <source>Each button can hold a distinct callback function which will display different value of &lt;code&gt;i&lt;/code&gt;. I can provide an example to show this:</source>
          <target state="translated">Каждая кнопка может содержать отдельную функцию обратного вызова, которая будет отображать различное значение &lt;code&gt;i&lt;/code&gt; . Я могу предоставить пример, чтобы показать это:</target>
        </trans-unit>
        <trans-unit id="3535364419d36fc620e4f5493d86ed8c6d64572c" translate="yes" xml:space="preserve">
          <source>Equivalent code:</source>
          <target state="translated">Эквивалент кода:</target>
        </trans-unit>
        <trans-unit id="ff956d2a192938cf9d92d4c6a19f3ae8b72325fa" translate="yes" xml:space="preserve">
          <source>Every other answer explains why this is actually a nice and desired behavior, or why you shouldn't be needing this anyway. Mine is for those stubborn ones who want to exercise their right to bend the language to their will, not the other way around.</source>
          <target state="translated">Каждый второй ответ объясняет,почему на самом деле это хорошее и желаемое поведение,или почему вам все равно это не нужно.Мой ответ предназначен для тех упрямых,кто хочет осуществить свое право на сгибание языка по своей воле,а не наоборот.</target>
        </trans-unit>
        <trans-unit id="0dd24b3cfa0f1397c657fd1c280dfe16bb9e3f42" translate="yes" xml:space="preserve">
          <source>Example problem for &lt;a href=&quot;https://stackoverflow.com/q/13484107/448474&quot;&gt;a similar SO question&lt;/a&gt;</source>
          <target state="translated">Пример задачи для &lt;a href=&quot;https://stackoverflow.com/q/13484107/448474&quot;&gt;аналогичного вопроса SO&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="bb7c7223c0f7cca03529ae9f865e01923e18d2e1" translate="yes" xml:space="preserve">
          <source>From the above explanations, we can see that the &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;effbot&lt;/a&gt; webpage recommended in the accepted answer failed to give a relevant answer to this question. What is more, I think a point in the effbot webpage is wrong. I think the code regarding the UI.Button is correct:</source>
          <target state="translated">Из приведенных выше объяснений мы видим, что веб-страница &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;effbot,&lt;/a&gt; рекомендованная в принятом ответе, не дала соответствующего ответа на этот вопрос. Более того, я думаю, что точка на веб-странице effbot неверна. Я думаю, что код относительно UI.Button правильный:</target>
        </trans-unit>
        <trans-unit id="ffce6790c5edcbed68ecf56b4ebcce15bf2962a7" translate="yes" xml:space="preserve">
          <source>Function After Execution:</source>
          <target state="translated">Функция после выполнения:</target>
        </trans-unit>
        <trans-unit id="c6a884852d8c2a2883d38ae384496603d3a89ca1" translate="yes" xml:space="preserve">
          <source>Function Before Execution:</source>
          <target state="translated">Функция перед исполнением:</target>
        </trans-unit>
        <trans-unit id="31a489ea01d856da46704976b42a3727c3bf5489" translate="yes" xml:space="preserve">
          <source>Functions are objects (explained well in the accepted answer).</source>
          <target state="translated">Функции являются объектами (хорошо объяснены в принятом ответе).</target>
        </trans-unit>
        <trans-unit id="33152c3a458131f199d601848f2ff938e88b23ff" translate="yes" xml:space="preserve">
          <source>Given a simple little function &lt;code&gt;func&lt;/code&gt; defined as:</source>
          <target state="translated">Дана простая маленькая функция &lt;code&gt;func&lt;/code&gt; , определенная как:</target>
        </trans-unit>
        <trans-unit id="dc7ed69775b531605c40861499142c0c9436b2e1" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;foo&lt;/code&gt; is an object and &lt;code&gt;a&lt;/code&gt; is an attribute of &lt;code&gt;foo&lt;/code&gt; (available at &lt;code&gt;foo.func_defs[0]&lt;/code&gt;). Since &lt;code&gt;a&lt;/code&gt; is a list, &lt;code&gt;a&lt;/code&gt; is mutable and is thus a read-write attribute of &lt;code&gt;foo&lt;/code&gt;. It is initialized to the empty list as specified by the signature when the function is instantiated, and is available for reading and writing as long as the function object exists.</source>
          <target state="translated">Здесь &lt;code&gt;foo&lt;/code&gt; является объектом, а &lt;code&gt;a&lt;/code&gt; является атрибутом &lt;code&gt;foo&lt;/code&gt; (доступно по адресу &lt;code&gt;foo.func_defs[0]&lt;/code&gt; ). Поскольку &lt;code&gt;a&lt;/code&gt; является списком, &lt;code&gt;a&lt;/code&gt; является изменяемым и, таким образом, является атрибутом &lt;code&gt;foo&lt;/code&gt; для чтения и записи. Он инициализируется пустым списком, как указано в сигнатуре, когда создается экземпляр функции, и доступен для чтения и записи, пока существует объект функции.</target>
        </trans-unit>
        <trans-unit id="a60b329ec4b9d85ee4941270916f4f4532974b74" translate="yes" xml:space="preserve">
          <source>Here's a demonstration - you can verify that they are the same object each time they are referenced by</source>
          <target state="translated">Вот демонстрация-вы можете проверить,что они являются одним и тем же объектом,каждый раз,когда на них ссылаются по</target>
        </trans-unit>
        <trans-unit id="6fd4504fd06148ba79eed7136bc3c11e43b9b3ff" translate="yes" xml:space="preserve">
          <source>Hopefully it's enough to show that not executing the default argument expressions at the execution time of the &lt;code&gt;def&lt;/code&gt; statement isn't easy or doesn't make sense, or both.</source>
          <target state="translated">Надеюсь, этого достаточно, чтобы показать, что невыполнение выражений аргументов по умолчанию во время выполнения оператора &lt;code&gt;def&lt;/code&gt; не простое или не имеет смысла, или и то, и другое.</target>
        </trans-unit>
        <trans-unit id="efcda094ecf8e11cea988762da8f1af71d231058" translate="yes" xml:space="preserve">
          <source>However, supposed later on in the code, I do something like</source>
          <target state="translated">Однако,как предполагается позже в коде,я делаю что-то вроде...</target>
        </trans-unit>
        <trans-unit id="b3f69934c5bc363d742e1cab32463a9509580910" translate="yes" xml:space="preserve">
          <source>However, we've lost the ability to introspect, and see what the default arguments &lt;em&gt;are&lt;/em&gt;.  Because the objects haven't been constructed, we can't ever get hold of them without actually calling the function.  The best we could do is to store off the source code and return that as a string.</source>
          <target state="translated">Тем не менее, мы потеряли способность анализировать и смотреть, каковы аргументы по умолчанию. Поскольку объекты не были построены, мы никогда не сможем их заполучить, фактически не вызвав функцию. Лучшее, что мы можем сделать, это сохранить исходный код и вернуть его в виде строки.</target>
        </trans-unit>
        <trans-unit id="62218df64348dca379d0be7d12cf753886ac8753" translate="yes" xml:space="preserve">
          <source>I agree it's a gotcha when you try to use default constructors, though.</source>
          <target state="translated">Я согласен,что это неприятно,когда ты пытаешься использовать конструкторы по умолчанию.</target>
        </trans-unit>
        <trans-unit id="666a646463dc2675694b853c3a8d9d31ebba0462" translate="yes" xml:space="preserve">
          <source>I am going to demonstrate an alternative structure to pass a default list value to a function (it works equally well with dictionaries).</source>
          <target state="translated">Я собираюсь продемонстрировать альтернативную структуру для передачи функции значения списка по умолчанию (она одинаково хорошо работает со словарями).</target>
        </trans-unit>
        <trans-unit id="79228cdbb3c7bc21ef5719f719a1a0dd6dfbf36b" translate="yes" xml:space="preserve">
          <source>I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs ?)</source>
          <target state="translated">Я сомневаюсь,что опытное поведение имеет практическое применение (кто на самом деле использовал статические переменные на C,без ошибок в размножении?)</target>
        </trans-unit>
        <trans-unit id="43c16dd324ef24fec2c80514d01a8fbc2f28b9ba" translate="yes" xml:space="preserve">
          <source>I found it very clear, and I really suggest reading it for a better knowledge of how function objects work.</source>
          <target state="translated">Я нашел это очень ясным,и я действительно предлагаю прочитать его для лучшего понимания того,как работают функциональные объекты.</target>
        </trans-unit>
        <trans-unit id="e438a0bb860a536fec364c3e57d8144f3738861a" translate="yes" xml:space="preserve">
          <source>I know nothing about the Python interpreter inner workings (and I'm not an expert in compilers and interpreters either) so don't blame me if I propose anything unsensible or impossible.</source>
          <target state="translated">Я ничего не знаю о внутреннем устройстве интерпретатора Python (и я тоже не эксперт в компиляторах и интерпретаторах),так что не вините меня,если я предлагаю что-то недоступное или невозможное.</target>
        </trans-unit>
        <trans-unit id="71d7286361ceb622e718e696e33275d64365bcc6" translate="yes" xml:space="preserve">
          <source>I know, I know: that's a closure. Alternatively Python might provide a keyword to force definition-time binding:</source>
          <target state="translated">Я знаю,знаю:это закрытие.В качестве альтернативы Python может предоставить ключевое слово для принудительного определения времени:</target>
        </trans-unit>
        <trans-unit id="33854cd2f920283abdfe15942535e15a55a4bbc1" translate="yes" xml:space="preserve">
          <source>I personally like Python's current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible.</source>
          <target state="translated">Лично мне нравится текущий подход Python:аргументы функции по умолчанию вычисляются,когда функция определена,и этот объект всегда является объектом по умолчанию.Я полагаю,что они могли бы использоваться в специальных случаях с пустым списком,но такой специальный корпус вызвал бы ещё большее удивление,не говоря уже о том,что он обратно несовместим.</target>
        </trans-unit>
        <trans-unit id="653d0fdb648a0e875a98321cd116616aaa059e3d" translate="yes" xml:space="preserve">
          <source>I sometimes exploit this behavior as an alternative to the following pattern:</source>
          <target state="translated">Иногда я использую это поведение как альтернативу следующему шаблону:</target>
        </trans-unit>
        <trans-unit id="1136692ed919e61fb64464e3c7faa84bec1902d1" translate="yes" xml:space="preserve">
          <source>I think the answer to this question lies in how python pass data to parameter (pass by value or by reference), not mutability or how python handle the &quot;def&quot; statement.</source>
          <target state="translated">Думаю,ответ на этот вопрос заключается в том,как питон передаёт данные в параметр (передаёт по значению или по ссылке),а не в мутируемости или как питон обрабатывает утверждение &quot;def&quot;.</target>
        </trans-unit>
        <trans-unit id="344b69c74ad5e09938fa343f9bd784e609ba3f79" translate="yes" xml:space="preserve">
          <source>I used to think that creating the objects at runtime would be the better approach.  I'm less certain now, since you do lose some useful features, though it may be worth it regardless simply to prevent newbie confusion.  The disadvantages of doing so are:</source>
          <target state="translated">Раньше я думал,что создание объектов во время исполнения будет лучшим подходом.Сейчас я менее уверен в этом,так как вы теряете некоторые полезные функции,хотя это может стоить того вне зависимости от того,чтобы просто предотвратить путаницу новичков.Недостатки в этом:</target>
        </trans-unit>
        <trans-unit id="f45c52b12ce7f1ce19a9035ae4c48dd9daa005c0" translate="yes" xml:space="preserve">
          <source>I'll give you a hint.  Here's the disassembly (see &lt;a href=&quot;http://docs.python.org/library/dis.html&quot;&gt;http://docs.python.org/library/dis.html&lt;/a&gt;):</source>
          <target state="translated">Я дам вам подсказку. Вот разборка (см. &lt;a href=&quot;http://docs.python.org/library/dis.html&quot;&gt;Http://docs.python.org/library/dis.html&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="63b9797c54d1f5b22108348202db1c0d9f27b5eb" translate="yes" xml:space="preserve">
          <source>I'm &lt;em&gt;really&lt;/em&gt; surprised no one has performed the insightful introspection offered by Python (&lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; apply) on callables.</source>
          <target state="translated">Я &lt;em&gt;действительно&lt;/em&gt; удивлен, что никто не выполнил проницательный самоанализ, предложенный Python ( &lt;code&gt;2&lt;/code&gt; и &lt;code&gt;3&lt;/code&gt; применяются) для вызываемых.</target>
        </trans-unit>
        <trans-unit id="d560ac161f04d984906ccae5894dd8e5c74ba7d6" translate="yes" xml:space="preserve">
          <source>I'm gonna give you what I see as a useful example.</source>
          <target state="translated">Я дам тебе то,что вижу в качестве полезного примера.</target>
        </trans-unit>
        <trans-unit id="0ab4a274949e60b1dc8d810f1b8b6f0326e083c2" translate="yes" xml:space="preserve">
          <source>I've used this for instantiating client classes that access external resources, and also for creating dicts or lists for memoization.</source>
          <target state="translated">Я использовал это для инстанцирования клиентских классов,которые получают доступ к внешним ресурсам,а также для создания знаков или списков для запоминания.</target>
        </trans-unit>
        <trans-unit id="d4a17f0810bff8f4684352651e72c003f9d91265" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pavlo&lt;/code&gt; is mutable (modifiable), and &lt;code&gt;foo&lt;/code&gt; ends up modifying it, an effect we notice the next time &lt;code&gt;foo&lt;/code&gt; is called without specifying &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Если &lt;code&gt;pavlo&lt;/code&gt; является изменяемым (модифицируемым), и &lt;code&gt;foo&lt;/code&gt; в конечном итоге модифицирует его, эффект, который мы заметим при следующем вызове &lt;code&gt;foo&lt;/code&gt; без указания &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fde0c1e8b0aff298d01bf5aa7a719c471660837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;singleton&lt;/code&gt; is only used by &lt;code&gt;use_singleton&lt;/code&gt;, I like the following pattern as a replacement:</source>
          <target state="translated">Если &lt;code&gt;singleton&lt;/code&gt; используется только &lt;code&gt;use_singleton&lt;/code&gt; , мне нравится следующий шаблон в качестве замены:</target>
        </trans-unit>
        <trans-unit id="12b09ce5fbf5f05e7151c2f7f01217b353055234" translate="yes" xml:space="preserve">
          <source>If call-time evaluation is used, then the expensive function is called every time your function is used without an argument.  You'd either pay an expensive price on each call, or need to manually cache the value externally, polluting your namespace and adding verbosity.</source>
          <target state="translated">Если используется оценка во время вызова,то дорогая функция вызывается каждый раз,когда ваша функция используется без аргумента.Вы либо платите дорогую цену за каждый вызов,либо вручную кэшируете значение внешне,загрязняя пространство имён и добавляя глаголы.</target>
        </trans-unit>
        <trans-unit id="07abc281d43c1a8d21b4d3e16a4f89b6450862f6" translate="yes" xml:space="preserve">
          <source>If we execute &lt;code&gt;x[7]()&lt;/code&gt; we'll get 7 as expected, and &lt;code&gt;x[9]()&lt;/code&gt; will gives 9, another value of &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Если мы выполним &lt;code&gt;x[7]()&lt;/code&gt; мы получим 7, как и ожидалось, а &lt;code&gt;x[9]()&lt;/code&gt; даст 9, еще одно значение &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e5d0faf4767c71322e96d58c89f44e2f7d7004b" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want the default to be shared between subsequent calls,
  you can write the function like this instead:</source>
          <target state="translated">Если вы не хотите, чтобы значение по умолчанию было общим для последующих вызовов, вы можете написать такую ​​функцию:</target>
        </trans-unit>
        <trans-unit id="a78835080b9cc304e7940760ebe5a74f9feb7089" translate="yes" xml:space="preserve">
          <source>If you need to destructively manipulate a local temporary in the course of computing something, and you need to start your manipulation from an argument value, you need to make a copy.</source>
          <target state="translated">Если вам нужно деструктивно манипулировать локальным временным фактором в процессе вычисления чего-то,и вам нужно начать манипуляцию со значения аргумента,вам нужно сделать копию.</target>
        </trans-unit>
        <trans-unit id="ffce4f7ff1a5649ba9873493748437dec4a51845" translate="yes" xml:space="preserve">
          <source>In any case, Effbot has a very nice explanation of the reasons for this behavior in &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;Default Parameter Values in Python&lt;/a&gt;.</source>
          <target state="translated">В любом случае, у Effbot есть очень хорошее объяснение причин такого поведения в &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;значениях параметров&lt;/a&gt; по умолчанию в Python .</target>
        </trans-unit>
        <trans-unit id="bbd472fc6429abfdafc9add5359fa997a6a79049" translate="yes" xml:space="preserve">
          <source>In other words, instead of evaluating default parameters, why not store each of them, and evaluate them when the function is called?</source>
          <target state="translated">Другими словами,вместо того,чтобы вычислять параметры по умолчанию,почему бы не хранить каждый из них,и не оценивать их при вызове функции?</target>
        </trans-unit>
        <trans-unit id="44af44eea85fed48a31ed0183c38ed921ac1aabb" translate="yes" xml:space="preserve">
          <source>Input parameters objects shouldn't be modified in place (mutated) nor they should not be binded into an object returned by the function. (If we prefere programming without side effects which is strongly recommended. see &lt;a href=&quot;http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;Wiki about &quot;side effect&quot;&lt;/a&gt; (The first two paragraphs are relevent in this context.)
.)</source>
          <target state="translated">Объекты входных параметров не должны быть изменены на месте (видоизменены) и не должны быть связаны в объект, возвращаемый функцией. (Если мы предпочитаем программирование без побочных эффектов, что настоятельно рекомендуется. См. &lt;a href=&quot;http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;Вики о &amp;laquo;побочном эффекте&amp;raquo;&lt;/a&gt; (первые два абзаца являются подходящими в этом контексте.).)</target>
        </trans-unit>
        <trans-unit id="f428f84105fcce031afe75598a91587f547827e4" translate="yes" xml:space="preserve">
          <source>It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.</source>
          <target state="translated">Это связано с тем,что функции на Python-это первоклассные объекты,а не просто кусок кода.</target>
        </trans-unit>
        <trans-unit id="8d35c5155e3a7198376d876ba2ac22709cf724ee" translate="yes" xml:space="preserve">
          <source>It is a confusing feature and it is unfortunate in Python.</source>
          <target state="translated">Это сбивает с толку и прискорбно на Питоне.</target>
        </trans-unit>
        <trans-unit id="2d1e31d0ad97904bac773140d97936823786bfd4" translate="yes" xml:space="preserve">
          <source>It may be true that switching horses in midstream here would be asking for significant breakage, and that there could be more problems created by changing Python to intuitively handle Stefano's opening snippet. And it may be true that someone who knew Python internals well could explain a minefield of consequences. &lt;em&gt;However,&lt;/em&gt;</source>
          <target state="translated">Возможно, это правда, что переключение лошадей в среднем потоке здесь потребовало бы значительных поломок, и что может быть больше проблем, созданных путем изменения Python для интуитивной обработки открывающего фрагмента Стефано. И это может быть правдой, что тот, кто хорошо знал внутренности Python, мог объяснить минное поле последствий. &lt;em&gt;Однако,&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f7b0650553f1d03b5617ea73a2e594063dbeff1b" translate="yes" xml:space="preserve">
          <source>It may be true that:</source>
          <target state="translated">Возможно,это правда:</target>
        </trans-unit>
        <trans-unit id="c88ae6b372096f323f1ae38ef63c959269132a80" translate="yes" xml:space="preserve">
          <source>It shouldn't be neither saved in any &lt;em&gt;public&lt;/em&gt; attribute of an instance returned by this function. (Assuming that &lt;em&gt;private&lt;/em&gt; attributes of instance should not be modified from outside of this class or subclasses by convention. i.e. &lt;code&gt;_var1&lt;/code&gt; is a private attribute )</source>
          <target state="translated">Он не должен быть сохранен ни в каком &lt;em&gt;открытом&lt;/em&gt; атрибуте экземпляра, возвращенного этой функцией. (Предполагается, что &lt;em&gt;закрытые&lt;/em&gt; атрибуты экземпляра не должны изменяться извне этого класса или подклассов по соглашению. &lt;code&gt;_var1&lt;/code&gt; есть _var1 является приватным атрибутом)</target>
        </trans-unit>
        <trans-unit id="a1d3a576ba48952d86d8cfdfe398ef2bddea704e" translate="yes" xml:space="preserve">
          <source>It's a performance optimization.  As a result of this functionality, which of these two function calls do you think is faster?</source>
          <target state="translated">Это оптимизация производительности.В результате этой функциональности,какой из этих двух вызовов функций,по-вашему,быстрее?</target>
        </trans-unit>
        <trans-unit id="0359bac5a1c47bf095f12d4add2a3b1b5b445f4a" translate="yes" xml:space="preserve">
          <source>It's important to note that the above solution breaks if you try to use keyword args, like so:</source>
          <target state="translated">Важно отметить,что вышеуказанное решение ломается,если вы попытаетесь использовать аргументы по ключевым словам:</target>
        </trans-unit>
        <trans-unit id="b6c89d685ac19d7565519a44bbc4a6d593564a24" translate="yes" xml:space="preserve">
          <source>It's just &quot;How It Works&quot;, and making it work differently in the function case would probably be complicated, and in the class case likely impossible, or at least slow down object instantiation a lot, as you would have to keep the class code around and execute it when objects are created.</source>
          <target state="translated">Это просто &quot;Как это работает&quot;,и сделать так,чтобы он работал по-другому в случае с функцией,вероятно,будет сложно,а в случае с классом,вероятно,невозможно,или,по крайней мере,сильно замедлить инстанцирование объектов,так как вам придется держать код класса вокруг и выполнять его,когда объекты создаются.</target>
        </trans-unit>
        <trans-unit id="fd310ea6b1cae2a6a063f0bd5d873b8e8d185946" translate="yes" xml:space="preserve">
          <source>Just change the function to be:</source>
          <target state="translated">Просто измените функцию:</target>
        </trans-unit>
        <trans-unit id="7da4eaf92a58f20a9c68b073a49820f4346f33e5" translate="yes" xml:space="preserve">
          <source>Let's now execute this function:</source>
          <target state="translated">Теперь давайте выполним эту функцию:</target>
        </trans-unit>
        <trans-unit id="fd6ffcde729e6f54a9565146d7555da45d90700c" translate="yes" xml:space="preserve">
          <source>Look back to the original example and consider the above points:</source>
          <target state="translated">Оглянитесь на исходный пример и рассмотрите вышеприведенные моменты:</target>
        </trans-unit>
        <trans-unit id="7d52014db1eb1bc10080d5b3576313f9f6997662" translate="yes" xml:space="preserve">
          <source>Many builtin mutable types have a copy method like &lt;code&gt;some_dict.copy()&lt;/code&gt; or &lt;code&gt;some_set.copy()&lt;/code&gt; or can be copied easy like &lt;code&gt;somelist[:]&lt;/code&gt; or &lt;code&gt;list(some_list)&lt;/code&gt;. Every object can be also copied by &lt;code&gt;copy.copy(any_object)&lt;/code&gt; or more thorough by &lt;code&gt;copy.deepcopy()&lt;/code&gt; (the latter useful if the mutable object is composed from mutable objects). Some objects are fundamentally based on side effects like &quot;file&quot; object and can not be meaningfully reproduced by copy. &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm&quot;&gt;copying&lt;/a&gt;</source>
          <target state="translated">Многие встроенные изменяемые типы имеют метод копирования, например &lt;code&gt;some_dict.copy()&lt;/code&gt; или &lt;code&gt;some_set.copy()&lt;/code&gt; или могут быть легко скопированы, как &lt;code&gt;somelist[:]&lt;/code&gt; или &lt;code&gt;list(some_list)&lt;/code&gt; . Каждый объект также может быть скопирован с помощью &lt;code&gt;copy.copy(any_object)&lt;/code&gt; или более детально с помощью &lt;code&gt;copy.deepcopy()&lt;/code&gt; (последний полезен, если изменяемый объект состоит из изменяемых объектов). Некоторые объекты основаны на побочных эффектах, таких как &amp;laquo;файловый&amp;raquo; объект, и не могут быть воспроизведены путем копирования. &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm&quot;&gt;копирование&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e23f5cbc0bbb2cbb8b27c449a4bcd8e9fbb38b2b" translate="yes" xml:space="preserve">
          <source>No default values in sight in this code, but you get exactly the same problem.</source>
          <target state="translated">В этом коде нет значений по умолчанию,но вы получаете точно такую же проблему.</target>
        </trans-unit>
        <trans-unit id="b9b42c390ec8fb15d988160f4dd8c2a52791b6d6" translate="yes" xml:space="preserve">
          <source>Now let's redefine our function using this decorator:</source>
          <target state="translated">Теперь давайте переопределим нашу функцию с помощью этого декоратора:</target>
        </trans-unit>
        <trans-unit id="b7e59f92481e8e7835898fa1c85ba3a27d892126" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;pavlo&lt;/code&gt; is [5].</source>
          <target state="translated">Теперь &lt;code&gt;pavlo&lt;/code&gt; [5].</target>
        </trans-unit>
        <trans-unit id="362ccf94780188762e961bb582f31f3d92a8d7ee" translate="yes" xml:space="preserve">
          <source>Now, compare this to the example from the documentation on &lt;a href=&quot;http://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;emulating the default argument behavior of other languages&lt;/a&gt;, such that the function signature defaults are used every time the function is executed:</source>
          <target state="translated">Теперь сравните это с примером из документации по &lt;a href=&quot;http://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;эмуляции поведения аргументов по умолчанию в других языках&lt;/a&gt; , так что значения сигнатур функции по умолчанию используются каждый раз, когда функция выполняется:</target>
        </trans-unit>
        <trans-unit id="64acff4f47942d13d4f208bda7e869e11d893a33" translate="yes" xml:space="preserve">
          <source>Now, does my map use the value of the &lt;code&gt;StringBuffer&lt;/code&gt; key when it was placed into the map, or does it store the key by reference?  Either way, someone is astonished; either the person who tried to get the object out of the &lt;code&gt;Map&lt;/code&gt; using a value identical to the one they put it in with, or the person who can't seem to retrieve their object even though the key they're using is literally the same object that was used to put it into the map (this is actually why Python doesn't allow its mutable built-in data types to be used as dictionary keys).</source>
          <target state="translated">Теперь моя карта использует значение ключа &lt;code&gt;StringBuffer&lt;/code&gt; , когда он был помещен в карту, или он хранит ключ по ссылке? В любом случае, кто-то удивлен; либо человек, который пытался вытащить объект из &lt;code&gt;Map&lt;/code&gt; используя значение, идентичное тому, с которым он его вставил, либо человек, который, кажется, не может получить свой объект, даже если ключ, который они используют, буквально одинаков. объект, который использовался для помещения его в карту (именно поэтому Python не позволяет использовать его изменяемые встроенные типы данных в качестве ключей словаря).</target>
        </trans-unit>
        <trans-unit id="ca1782989bcd41936515ff547e98eb21e1c24f56" translate="yes" xml:space="preserve">
          <source>Now, let's see those &lt;code&gt;__defaults__&lt;/code&gt; again:</source>
          <target state="translated">Теперь давайте снова посмотрим на эти &lt;code&gt;__defaults__&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="03060fd5df0aea733c344b9b8691c947fcb3b65a" translate="yes" xml:space="preserve">
          <source>Now, suppose the behaviour of defaults could be changed so that this is the equivalent of:</source>
          <target state="translated">Теперь предположим,что поведение установок по умолчанию может быть изменено таким образом,чтобы это было эквивалентом:</target>
        </trans-unit>
        <trans-unit id="c8b8bb4b9ae89c0e3c42072a31a62c115adca126" translate="yes" xml:space="preserve">
          <source>Now, when to evaluate &lt;code&gt;default&lt;/code&gt;?</source>
          <target state="translated">Теперь, когда оценивать &lt;code&gt;default&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="2d80698d75eb09b54cff119780e3f91af2942726" translate="yes" xml:space="preserve">
          <source>O.k, so an empty list as the single entry in &lt;code&gt;__defaults__&lt;/code&gt;, just as expected.</source>
          <target state="translated">Итак, пустой список как отдельная запись в &lt;code&gt;__defaults__&lt;/code&gt; , как и ожидалось.</target>
        </trans-unit>
        <trans-unit id="8ee84d967071869b5d4f78c07c4174525b7a125c" translate="yes" xml:space="preserve">
          <source>One answer is probably right there--it would effectively turn every function with default parameters into a closure.  Even if it's all hidden away in the interpreter and not a full-blown closure, the data's got to be stored somewhere.  It'd be slower and use more memory.</source>
          <target state="translated">Один из ответов на этот вопрос,вероятно,правильный-он фактически превратит каждую функцию с параметрами по умолчанию в закрытие.Даже если все это скрыто в интерпретаторе и не является полноценным закрытием,данные должны где-то храниться.Это было бы медленнее и использовало бы больше памяти.</target>
        </trans-unit>
        <trans-unit id="11b18ef18f03165cd782bc4f836d003ad9d95019" translate="yes" xml:space="preserve">
          <source>Only if the side effect on the actual parameter is required but unwanted on the default parameter then the useful solution is &lt;code&gt;def ...(var1=None):&lt;/code&gt;&lt;code&gt;if var1 is None:&lt;/code&gt;&lt;code&gt;var1 = []&lt;/code&gt;&lt;a href=&quot;http://effbot.org/zone/default-values.htm#what-to-do-instead&quot;&gt;More..&lt;/a&gt;</source>
          <target state="translated">Только если побочный эффект для фактического параметра является обязательным, но нежелательным для параметра по умолчанию, тогда полезным решением является &lt;code&gt;def ...(var1=None):&lt;/code&gt; &lt;code&gt;if var1 is None:&lt;/code&gt; &lt;code&gt;var1 = []&lt;/code&gt; &lt;a href=&quot;http://effbot.org/zone/default-values.htm#what-to-do-instead&quot;&gt;Подробнее ..&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="114258caa60ea3edd65afe4bbb8f1463ea7260f5" translate="yes" xml:space="preserve">
          <source>Per &lt;strong&gt;(1)&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;a new local variable also named &lt;code&gt;L&lt;/code&gt; is created in the local scope&lt;/em&gt;&lt;/strong&gt; and used for the remainder of the function call. &lt;code&gt;foo.func_defs[0]&lt;/code&gt; thus remains unchanged for future invocations of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Согласно &lt;strong&gt;(1)&lt;/strong&gt; , &lt;strong&gt;&lt;em&gt;новая локальная переменная, также называемая &lt;code&gt;L&lt;/code&gt; , создается в локальной области&lt;/em&gt;&lt;/strong&gt; и используется для оставшейся части вызова функции. &lt;code&gt;foo.func_defs[0]&lt;/code&gt; образом, foo.func_defs [0] остается неизменным для будущих вызовов &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d87aa1b1e7324f25c59d457e5df3e2ceb743377" translate="yes" xml:space="preserve">
          <source>Per Brett Slatkin's &quot;Effective Python: 59 Specific Ways to Write Better Python&quot;, &lt;em&gt;Item 20: Use &lt;code&gt;None&lt;/code&gt; and Docstrings to specify dynamic default arguments&lt;/em&gt; (p. 48)</source>
          <target state="translated">Пер Бретт Слаткин &quot;Эффективный Python: 59 конкретных способов написать лучший Python&quot;, &lt;em&gt;пункт 20. Использование &lt;code&gt;None&lt;/code&gt; и строк документации для указания динамических аргументов по умолчанию&lt;/em&gt; (стр. 48)</target>
        </trans-unit>
        <trans-unit id="edbbe1dd270001c9959fe3b6bfc520ed27fa81f3" translate="yes" xml:space="preserve">
          <source>Provided that python objects &lt;strong&gt;are mutable&lt;/strong&gt; I think that this should be taken into account when designing the default arguments stuff.
When you instantiate a list:</source>
          <target state="translated">При условии, что объекты Python &lt;strong&gt;изменчивы,&lt;/strong&gt; я думаю, что это следует учитывать при разработке аргументов по умолчанию. Когда вы создаете экземпляр списка:</target>
        </trans-unit>
        <trans-unit id="e05c3327cf67fb602c3add427a88b4d544b75506" translate="yes" xml:space="preserve">
          <source>Python novices would expect this function to always return a list with only one element: &lt;code&gt;[5]&lt;/code&gt;. The result is instead very different, and very astonishing (for a novice):</source>
          <target state="translated">Новички в Python ожидают, что эта функция всегда будет возвращать список только с одним элементом: &lt;code&gt;[5]&lt;/code&gt; . Вместо этого результат очень отличается и очень удивителен (для новичка):</target>
        </trans-unit>
        <trans-unit id="81f99a7ff268aeaf873fa4045929feaf18be7cd0" translate="yes" xml:space="preserve">
          <source>Python: The Mutable Default Argument</source>
          <target state="translated">Питон:Аргумент &quot;Мутируемый по умолчанию</target>
        </trans-unit>
        <trans-unit id="48fb53aa0f56fcdc44c27cdce6ee6b0ac6e04929" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;parameter&lt;/code&gt; is a constant name, we can &quot;evaluate&quot; it at the same time as &lt;code&gt;def name&lt;/code&gt;. This also has the advantage it produces the function with a known signature as &lt;code&gt;name(parameter=...):&lt;/code&gt;, instead of a bare &lt;code&gt;name(...):&lt;/code&gt;.</source>
          <target state="translated">Поскольку &lt;code&gt;parameter&lt;/code&gt; является константным именем, мы можем &amp;laquo;оценить&amp;raquo; его одновременно с &lt;code&gt;def name&lt;/code&gt; . Это также имеет то преимущество, что создает функцию с известной сигнатурой как &lt;code&gt;name(parameter=...):&lt;/code&gt; вместо простого &lt;code&gt;name(...):&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a5d182b67a7149475e28eef1bc9597d34d73b45e" translate="yes" xml:space="preserve">
          <source>Since I don't think this pattern is well known, I do put a short comment in to guard against future misunderstandings.</source>
          <target state="translated">Так как я не думаю,что эта закономерность хорошо известна,я делаю короткий комментарий,чтобы предотвратить будущие недоразумения.</target>
        </trans-unit>
        <trans-unit id="1da4b14f89f2b2d481987a26be3a56b816db7930" translate="yes" xml:space="preserve">
          <source>Since the function body is executed anew each time, you always get a fresh new empty list if no argument was passed for &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Поскольку тело функции выполняется заново каждый раз, вы всегда получаете новый новый пустой список, если для &lt;code&gt;a&lt;/code&gt; не передан аргумент.</target>
        </trans-unit>
        <trans-unit id="8219cc9987e068b594e6f9212eabecd380fc4b23" translate="yes" xml:space="preserve">
          <source>Since the list is bound to the function when the function object is compiled and instantiated, this:</source>
          <target state="translated">Так как список привязывается к функции,когда объект функции компилируется и инстанцируется,то это:</target>
        </trans-unit>
        <trans-unit id="846d5d41860fc57cee6667664460f6fd3c443f37" translate="yes" xml:space="preserve">
          <source>So this is what you see (Remember, &lt;code&gt;pavlo&lt;/code&gt; is initialized to []):</source>
          <target state="translated">Вот что вы видите (помните, что &lt;code&gt;pavlo&lt;/code&gt; инициализируется как []):</target>
        </trans-unit>
        <trans-unit id="cc480e96946c5a4d81dbe64f85f0531baec48a48" translate="yes" xml:space="preserve">
          <source>So, &lt;code&gt;pavlo&lt;/code&gt; is still &lt;code&gt;[5, 5]&lt;/code&gt;.</source>
          <target state="translated">Итак, &lt;code&gt;pavlo&lt;/code&gt; все еще &lt;code&gt;[5, 5]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="135253f82ce516e45be9920a7c65b965b29a4cbe" translate="yes" xml:space="preserve">
          <source>So, let's do some introspection, a before and after to examine how the list gets expanded &lt;strong&gt;inside&lt;/strong&gt; the function object. I'm using &lt;code&gt;Python 3.x&lt;/code&gt; for this, for Python 2 the same applies (use &lt;code&gt;__defaults__&lt;/code&gt; or &lt;code&gt;func_defaults&lt;/code&gt; in Python 2; yes, two names for the same thing).</source>
          <target state="translated">Итак, давайте проведем некоторый самоанализ, до и после, чтобы проверить, как список расширяется &lt;strong&gt;внутри&lt;/strong&gt; объекта функции. Я использую &lt;code&gt;Python 3.x&lt;/code&gt; для этого, для Python 2 применяется то же самое (используйте &lt;code&gt;__defaults__&lt;/code&gt; или &lt;code&gt;func_defaults&lt;/code&gt; в Python 2; да, два имени для одной и той же вещи).</target>
        </trans-unit>
        <trans-unit id="ac03b13d0df29e0d823d1733d67a60356a13e49c" translate="yes" xml:space="preserve">
          <source>So, there you have it, the reason why this &lt;em&gt;'flaw'&lt;/em&gt; happens, is because default arguments are part of the function object. There's nothing weird going on here, it's all just a bit surprising.</source>
          <target state="translated">Итак, у вас есть причина, по которой возникает этот &lt;em&gt;&amp;laquo;недостаток&amp;raquo;&lt;/em&gt; , потому что аргументы по умолчанию являются частью объекта функции. Здесь нет ничего странного, все это немного удивляет.</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="2ffd73eaa6f051202977e48c6c85a797b6fd5a12" translate="yes" xml:space="preserve">
          <source>Someone is using every language/library feature, and</source>
          <target state="translated">Кто-то использует каждую лингвистическую библиотеку,и</target>
        </trans-unit>
        <trans-unit id="d42bae2973e05a62b137b51620fea4d9b147edc0" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;a&lt;/code&gt; when calling &lt;code&gt;foo()&lt;/code&gt; ensures &lt;code&gt;pavlo&lt;/code&gt; is not touched.</source>
          <target state="translated">Указание при вызове &lt;code&gt;foo()&lt;/code&gt; гарантирует, что &lt;code&gt;pavlo&lt;/code&gt; не будет затронут.</target>
        </trans-unit>
        <trans-unit id="f19d645e1fda82c64c713d7a7c9e1d69d1720d38" translate="yes" xml:space="preserve">
          <source>Suppose you have the following code</source>
          <target state="translated">Предположим,у вас есть следующий код</target>
        </trans-unit>
        <trans-unit id="2985042a12a99a3c98ea5fdbdde2134ab3ef8abf" translate="yes" xml:space="preserve">
          <source>Switching the behavior here would be ill-advised, but</source>
          <target state="translated">Изменить поведение здесь было бы неразумно,но...</target>
        </trans-unit>
        <trans-unit id="eb8098887cd8190749f463f9cd047389241aa54c" translate="yes" xml:space="preserve">
          <source>TLDR: Define-time defaults are consistent and strictly more expressive.</source>
          <target state="translated">TLDR:значения по умолчанию по умолчанию по умолчанию последовательны и строго более выразительны.</target>
        </trans-unit>
        <trans-unit id="baee8029959dfcc9ec36a00cfc022b60ddd58256" translate="yes" xml:space="preserve">
          <source>Taking &lt;strong&gt;(1)&lt;/strong&gt; and &lt;strong&gt;(2)&lt;/strong&gt; into account, one can see why this accomplishes the the desired behavior:</source>
          <target state="translated">Принимая во внимание &lt;strong&gt;(1)&lt;/strong&gt; и &lt;strong&gt;(2)&lt;/strong&gt; , можно понять, почему это приводит к желаемому поведению:</target>
        </trans-unit>
        <trans-unit id="60e49eedb22450ed713b64f742443e241e6f5637" translate="yes" xml:space="preserve">
          <source>That is against the rules of functional programming, usually undesiderable and should be fixed both together.</source>
          <target state="translated">Это противоречит правилам функционального программирования,как правило,неудобоваримым,и должно быть зафиксировано оба вместе.</target>
        </trans-unit>
        <trans-unit id="6283984545c4460e3d117123b9917e356ce0cec9" translate="yes" xml:space="preserve">
          <source>That said it should feature prominently in any good Python tutorial. Because as you mention, everyone runs into this problem sooner or later.</source>
          <target state="translated">Тем не менее,это должно быть заметно в любом хорошем учебном пособии по Пайтону.Потому что,как вы уже упоминали,рано или поздно все рано или поздно столкнутся с этой проблемой.</target>
        </trans-unit>
        <trans-unit id="4742191818ba22d12f4df985ed0fa6ab565b9a93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def name&lt;/code&gt; part &lt;strong&gt;must&lt;/strong&gt; evaluate in the defining scope - we want &lt;code&gt;name&lt;/code&gt; to be available there, after all. Evaluating the function only inside itself would make it inaccessible.</source>
          <target state="translated">Часть &lt;code&gt;def name&lt;/code&gt; &lt;strong&gt;должна&lt;/strong&gt; вычисляться в определяющей области действия - мы хотим, чтобы &lt;code&gt;name&lt;/code&gt; было доступно там, в конце концов. Оценка функции только внутри себя сделает ее недоступной.</target>
        </trans-unit>
        <trans-unit id="211b17364c2c5fb881927eef3ad2c632ef6e4ead" translate="yes" xml:space="preserve">
          <source>The actual behavior is more consistent: everything of that line gets evaluated when that line is executed, meaning at function definition.</source>
          <target state="translated">Фактическое поведение более последовательное:при выполнении этой строки вычисляется все,что имеется в виду при определении функции.</target>
        </trans-unit>
        <trans-unit id="b21b3a47af1bce60cc5bdaa7db45df9e68ea6c1a" translate="yes" xml:space="preserve">
          <source>The behavior of read-only class attributes upon assignment attempts, and that</source>
          <target state="translated">Поведение атрибутов класса &quot;только для чтения&quot; при попытке присвоения,и что</target>
        </trans-unit>
        <trans-unit id="d812f28bfd7bbbe507925925cde1cb11345acdb0" translate="yes" xml:space="preserve">
          <source>The common solution to combat this is to use &lt;code&gt;None&lt;/code&gt; as the default and then initialize in the function body:</source>
          <target state="translated">Распространенным решением для борьбы с этим является использование &lt;code&gt;None&lt;/code&gt; по умолчанию, а затем инициализация в теле функции:</target>
        </trans-unit>
        <trans-unit id="e6bc97e96787463bf81bb7eba82e092966902caa" translate="yes" xml:space="preserve">
          <source>The convention for achieving the desired result in Python is to
  provide a default value of &lt;code&gt;None&lt;/code&gt; and to document the actual behaviour
  in the docstring.</source>
          <target state="translated">Соглашение для достижения желаемого результата в Python заключается в предоставлении значения по умолчанию &lt;code&gt;None&lt;/code&gt; и документировании фактического поведения в строке документации.</target>
        </trans-unit>
        <trans-unit id="12d835d927cd99c2caf5af5f3e46112259ed6aeb" translate="yes" xml:space="preserve">
          <source>The decorator could be adjusted to allow for that, but we leave this as an exercise for the reader ;)</source>
          <target state="translated">Декоратор может быть отрегулирован для этого,но мы оставляем это как упражнение для читателя ;)</target>
        </trans-unit>
        <trans-unit id="5da3d3f2271874d0124b0b19b38e9cd58ca9fc21" translate="yes" xml:space="preserve">
          <source>The example in the question could fall into category 1 or 3. It's odd that it both modifies the passed list and returns it; you should pick one or the other.</source>
          <target state="translated">Пример в вопросе может попасть в категорию 1 или 3.Странно,что он как изменяет переданный список,так и возвращает его;нужно выбрать тот или иной.</target>
        </trans-unit>
        <trans-unit id="07a5b90c302821e9edaa02c42d4c5a34d0d660fb" translate="yes" xml:space="preserve">
          <source>The existing behavior is not Pythonic, and Python is successful because very little about the language violates the principle of least astonishment anywhere &lt;em&gt;near&lt;/em&gt; this badly. It is a real problem, whether or not it would be wise to uproot it. It is a design flaw. If you understand the language much better by trying to trace out the behavior, I can say that C++ does all of this and more; you learn a lot by navigating, for instance, subtle pointer errors. But this is not Pythonic: people who care about Python enough to persevere in the face of this behavior are people who are drawn to the language because Python has far fewer surprises than other language. Dabblers and the curious become Pythonistas when they are astonished at how little time it takes to get something working--not because of a design fl--I mean, hidden logic puzzle--that cuts against the intuitions of programmers who are drawn to Python because it &lt;strong&gt;Just Works&lt;/strong&gt;.</source>
          <target state="translated">Существующее поведение не является Pythonic, и Python успешен, потому что очень мало о языке нарушает принцип наименьшего удивления где-либо &lt;em&gt;рядом с&lt;/em&gt; этим сильно. Это реальная проблема, было бы разумно искоренить это. Это недостаток дизайна. Если вы гораздо лучше понимаете язык, пытаясь отследить поведение, я могу сказать, что C ++ делает все это и даже больше; Вы многому научитесь, перемещаясь, например, по тонким ошибкам указателя. Но это не Pythonic: люди, которые заботятся о Python достаточно, чтобы выдержать это поведение, являются людьми, которых привлекает язык, потому что у Python гораздо меньше сюрпризов, чем у другого языка. Дейблеры и любопытные становятся Pythonistas, когда они удивляются тому, как мало времени требуется, чтобы что-то заработало - не из-за дизайна, я имею в виду скрытую логическую головоломку, которая прорезает интуицию программистов, которые тянутся к Python потому что это &lt;strong&gt;просто работает&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="16ba720afc950d5f92d65c94fa4b03086d39ddeb" translate="yes" xml:space="preserve">
          <source>The invocation of foo(1) make items point to a list object [] with an address, say, 11111111. the content of the list is changed to &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; in the foo function in the sequel, but the address is not changed, still 11111111. Then foo(2,[]) is coming. Although the [] in foo(2,[]) has the same content as the default parameter [] when calling foo(1), their address are different! Since we provide the parameter explicitly, &lt;code&gt;items&lt;/code&gt; has to take the address of this new &lt;code&gt;[]&lt;/code&gt;, say 2222222, and return it after making some change. Now foo(3) is executed. since only &lt;code&gt;x&lt;/code&gt; is provided, items has to take its default value again. What's the default value? It is set when defining the foo function: the list object located in 11111111. So the items is evaluated to be the address 11111111 having an element 1. The list located at 2222222 also contains one element 2, but it is not pointed by items any more. Consequently, An append of 3 will make &lt;code&gt;items&lt;/code&gt; [1,3].</source>
          <target state="translated">Вызов foo (1) заставляет элементы указывать на объект списка [] с адресом, скажем, 11111111. Содержимое списка изменяется на &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; в функции foo в дальнейшем, но адрес не изменяется, все же 11111111 Затем приходит foo (2, []). Хотя [] в foo (2, []) имеет то же содержимое, что и параметр по умолчанию [] при вызове foo (1), их адреса разные! Поскольку мы предоставляем параметр в явном виде, &lt;code&gt;items&lt;/code&gt; должен взять адрес этого нового &lt;code&gt;[]&lt;/code&gt; , скажем, 2222222, и вернуть его после внесения некоторых изменений. Теперь foo (3) выполняется. поскольку предоставляется только &lt;code&gt;x&lt;/code&gt; , элементы должны снова принять значение по умолчанию. Какое значение по умолчанию? Он устанавливается при определении функции foo: объекта списка, расположенного в 11111111. Таким образом, элементы оцениваются как адрес 11111111, имеющий элемент 1. Список, расположенный в 2222222, также содержит один элемент 2, но он не указывается элементами Больше. Следовательно, приложение из 3 сделает &lt;code&gt;items&lt;/code&gt; [1,3].</target>
        </trans-unit>
        <trans-unit id="960186c4fed60739e84ad1f39072643da3a4aa62" translate="yes" xml:space="preserve">
          <source>The only way to implement this otherwise would be to create a further closure with the i bound, ie:</source>
          <target state="translated">В противном случае единственный способ реализовать это-это создать дополнительное закрытие с привязкой к i:</target>
        </trans-unit>
        <trans-unit id="9a6df79e5dc84aaf86c93401973ff0f28eae8f32" translate="yes" xml:space="preserve">
          <source>The other answers, or at least some of them either make points 1 and 2 but not 3, or make point 3 and downplay points 1 and 2. &lt;strong&gt;But all three are true.&lt;/strong&gt;</source>
          <target state="translated">Другие ответы, или, по крайней мере, некоторые из них, либо ставят точки 1 и 2, но не 3, либо ставят точку 3 и преуменьшают очки 1 и 2. &lt;strong&gt;Но все три верны.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="927ebe1c435f42420093f2af144d14cd34af2416" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;foo&lt;/code&gt; is &lt;em&gt;modifying&lt;/em&gt; a mutable variable passed in from the caller, when the caller doesn't expect this. Code like this would be fine if the function was called something like &lt;code&gt;append_5&lt;/code&gt;; then the caller would be calling the function in order to modify the value they pass in, and the behaviour would be expected. But such a function would be very unlikely to take a default argument, and probably wouldn't return the list (since the caller already has a reference to that list; the one it just passed in).</source>
          <target state="translated">Проблема в том, что &lt;code&gt;foo&lt;/code&gt; &lt;em&gt;изменяет&lt;/em&gt; изменяемую переменную, передаваемую от вызывающей стороны, когда вызывающая сторона не ожидает этого. Код, подобный этому, был бы хорош, если бы функция &lt;code&gt;append_5&lt;/code&gt; как-то вроде append_5 ; тогда вызывающая сторона будет вызывать функцию, чтобы изменить передаваемое значение, и поведение будет ожидаемым. Но такая функция вряд ли будет принимать аргумент по умолчанию и, вероятно, не будет возвращать список (так как вызывающая сторона уже имеет ссылку на этот список; тот, который она только что передала).</target>
        </trans-unit>
        <trans-unit id="65336feec4cf085e41224e4e768035259840cf58" translate="yes" xml:space="preserve">
          <source>The real problem lies with mutable variables, and all languages have this problem to some extent. Here's a question: suppose in Java I have the following code:</source>
          <target state="translated">Реальная проблема заключается в мутируемых переменных,и все языки в некоторой степени имеют эту проблему.Возникает вопрос:предположим,что на Java у меня есть следующий код:</target>
        </trans-unit>
        <trans-unit id="0a4fcade0686f8907935d1c1f96cfa776ce37445" translate="yes" xml:space="preserve">
          <source>The relevant part of the &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function-definitions&quot;&gt;documentation&lt;/a&gt;:</source>
          <target state="translated">Соответствующая часть &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function-definitions&quot;&gt;документации&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="83a5fdca145464c718498a81f3ff52fe5cd258bb" translate="yes" xml:space="preserve">
          <source>The role of &lt;strong&gt;(2)&lt;/strong&gt; has been covered extensively in this thread. &lt;strong&gt;(1)&lt;/strong&gt; is likely the astonishment causing factor, as this behavior is not &quot;intuitive&quot; when coming from other languages.</source>
          <target state="translated">Роль &lt;strong&gt;(2)&lt;/strong&gt; широко освещалась в этой теме. &lt;strong&gt;(1)&lt;/strong&gt; , вероятно, является фактором, вызывающим удивление, так как это поведение не является &amp;laquo;интуитивным&amp;raquo; при переходе с других языков.</target>
        </trans-unit>
        <trans-unit id="300e6346ced2778bb2850c432c17f5b9ac6cc781" translate="yes" xml:space="preserve">
          <source>The second option is nice because users of the function can pass in a callable, which may be already existing (such as a &lt;code&gt;type&lt;/code&gt;)</source>
          <target state="translated">Второй вариант хорош, потому что пользователи функции могут передать вызываемый объект, который может уже существовать (например, &lt;code&gt;type&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a7a38b99177ce67bdf698f00a61b5341959f2954" translate="yes" xml:space="preserve">
          <source>The shortest answer would probably be &quot;definition is execution&quot;, therefore the whole argument makes no strict sense. As a more contrived example, you may cite this:</source>
          <target state="translated">Самым коротким ответом,вероятно,будет &quot;определение-исполнение&quot;,поэтому весь аргумент не имеет строгого смысла.В качестве более надуманного примера можно привести вот это:</target>
        </trans-unit>
        <trans-unit id="1545469b153fc84d77f2934491dab6d60119c4f8" translate="yes" xml:space="preserve">
          <source>The solutions here are:</source>
          <target state="translated">Решения здесь:</target>
        </trans-unit>
        <trans-unit id="9f29d3492458b50ad2b58ab7115f1bdab5c6dec2" translate="yes" xml:space="preserve">
          <source>The two choices are not equivalent, either: If &lt;code&gt;default&lt;/code&gt; is evaluated at definition time, it &lt;em&gt;can still&lt;/em&gt; affect execution time. If &lt;code&gt;default&lt;/code&gt; is evaluated at execution time, it &lt;em&gt;cannot&lt;/em&gt; affect definition time. Choosing &quot;at definition&quot; allows expressing both cases, while choosing &quot;at execution&quot; can express only one:</source>
          <target state="translated">Оба варианта также не эквивалентны: если &lt;code&gt;default&lt;/code&gt; оценивается во время определения, оно &lt;em&gt;все равно может&lt;/em&gt; влиять на время выполнения. Если &lt;code&gt;default&lt;/code&gt; оценивается во время выполнения, это &lt;em&gt;не может&lt;/em&gt; повлиять на время определения. Выбор &amp;laquo;при определении&amp;raquo; позволяет выразить оба случая, а при выборе &amp;laquo;при исполнении&amp;raquo; можно выразить только один:</target>
        </trans-unit>
        <trans-unit id="9d3b19afacd01fa6760d29ccb31fceacd0420b99" translate="yes" xml:space="preserve">
          <source>The usual instruction to new Python users:</source>
          <target state="translated">Обычная инструкция для новых пользователей Python:</target>
        </trans-unit>
        <trans-unit id="83431a0cce73cc9ea555626b7407f498ddeab772" translate="yes" xml:space="preserve">
          <source>There are 3 cases I see where you might run into this problem:</source>
          <target state="translated">Я вижу 3 случая,когда ты можешь столкнуться с этой проблемой:</target>
        </trans-unit>
        <trans-unit id="7d403bffc3efdc0e15e597031a66e58b86f1e427" translate="yes" xml:space="preserve">
          <source>There may be legitimate use cases for the 'Wrong Method' whereby the programmer intended the default list parameter to be shared, but this is more likely the exception than the rule.</source>
          <target state="translated">Могут быть законные случаи использования 'Неверного метода',когда программист намеревался,что параметр списка по умолчанию будет общим,но это скорее исключение,чем правило.</target>
        </trans-unit>
        <trans-unit id="e122131b734ffdd0c974c11125de9bf4d4ac1de3" translate="yes" xml:space="preserve">
          <source>They stay mutated because they are the same object each time.</source>
          <target state="translated">Они остаются мутированными,потому что каждый раз они являются одним и тем же объектом.</target>
        </trans-unit>
        <trans-unit id="42f87dc35743615ca50ba7a4e0a765f48628f38e" translate="yes" xml:space="preserve">
          <source>This &quot;bug&quot; gave me a lot of overtime work hours! But I'm beginning to see a potential use of it (but I would have liked it to be at the execution time, still)</source>
          <target state="translated">Этот &quot;жучок&quot; дал мне много сверхурочных рабочих часов! Но я начинаю видеть его потенциальное применение (но мне бы хотелось,чтобы он был во время исполнения,тем не менее).</target>
        </trans-unit>
        <trans-unit id="09c551bd076af75de6f7f75f84e6e19528a70b20" translate="yes" xml:space="preserve">
          <source>This actually has nothing to do with default values, other than that it often comes up as an unexpected behaviour when you write functions with mutable default values.</source>
          <target state="translated">На самом деле это не имеет ничего общего со значениями по умолчанию,кроме того,что это часто проявляется как неожиданное поведение,когда вы пишете функции с изменяемыми значениями по умолчанию.</target>
        </trans-unit>
        <trans-unit id="91bf40b75c5eb2ec9fc9e9af2dee27f147910385" translate="yes" xml:space="preserve">
          <source>This behavior is easy explained by:</source>
          <target state="translated">Такое поведение легко объяснить:</target>
        </trans-unit>
        <trans-unit id="8e882fce06b5aa8e4902377bf10643c0438bee5c" translate="yes" xml:space="preserve">
          <source>This behavior is not surprising if you take the following into consideration:</source>
          <target state="translated">Такое поведение неудивительно,если принять во внимание следующее:</target>
        </trans-unit>
        <trans-unit id="53ed8453d80a594313b39f617a24cd922589e53c" translate="yes" xml:space="preserve">
          <source>This code suffers from the exact same unexpected happenstance. bananas is a class attribute, and hence, when you add things to it, it's added to all instances of that class. The reason is exactly the same.</source>
          <target state="translated">Этот код страдает от одного и того же неожиданного случая.Бананы-это атрибут класса,а значит,когда вы что-то в него добавляете,он добавляется во все экземпляры этого класса.Причина точно такая же.</target>
        </trans-unit>
        <trans-unit id="5aa4790f0f096239796bd26d7ab23aed623fa5b3" translate="yes" xml:space="preserve">
          <source>This implementation ensures that each call to the function either receives the default list or else the list passed to the function.</source>
          <target state="translated">Эта реализация гарантирует,что каждый вызов функции либо получает список по умолчанию,либо список,переданный функции.</target>
        </trans-unit>
        <trans-unit id="37aa3fb7ad8287604da5115ea29978831dfe3dda" translate="yes" xml:space="preserve">
          <source>This information is very useful for things like document generation, metaprogramming, decorators etc.</source>
          <target state="translated">Эта информация очень полезна для таких вещей,как генерация документов,метапрограммирование,декораторы и т.д.</target>
        </trans-unit>
        <trans-unit id="643cda6d4c6e34a04adb1a217260ad6665380a64" translate="yes" xml:space="preserve">
          <source>This is particularly neat for functions that take multiple arguments. Compare:</source>
          <target state="translated">Это особенно удобно для функций,которые принимают несколько аргументов.Сравни:</target>
        </trans-unit>
        <trans-unit id="e564daaa17ad1d2d62e46bbb59e0067c087845a8" translate="yes" xml:space="preserve">
          <source>This order of execution is frequently confusing to new users of Python. If you understand the Python execution model, then it becomes quite expected.</source>
          <target state="translated">Такой порядок исполнения часто сбивает с толку новых пользователей Python.Если вы понимаете модель исполнения на Python,то это становится вполне ожидаемым.</target>
        </trans-unit>
        <trans-unit id="b99a6bdeb57707ff2643e03cc6dbbbaa2acc3f12" translate="yes" xml:space="preserve">
          <source>This returns a list of functions that return 0,1,2,3... respectively.  If the behaviour is changed, they will instead bind &lt;code&gt;i&lt;/code&gt; to the &lt;em&gt;call-time&lt;/em&gt; value of i, so you would get a list of functions that all returned &lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">Это возвращает список функций, которые возвращают 0,1,2,3 ... соответственно. Если поведение изменено, они вместо этого свяжут &lt;code&gt;i&lt;/code&gt; со значением &lt;em&gt;времени вызова&lt;/em&gt; i, так что вы получите список функций, которые все вернули &lt;code&gt;9&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1a3982204610904ddbc4a70de5860ec7e166984" translate="yes" xml:space="preserve">
          <source>This uses the None singleton as a sentinel object to tell the function whether or not we've gotten an argument other than the default. If we get no argument, then we actually want to use a new empty list, &lt;code&gt;[]&lt;/code&gt;, as the default.</source>
          <target state="translated">При этом используется синглтон None в качестве сторожевого объекта, чтобы сообщить функции, получили ли мы аргумент, отличный от значения по умолчанию. Если мы не получим аргумента, то мы фактически хотим использовать новый пустой список, &lt;code&gt;[]&lt;/code&gt; , по умолчанию.</target>
        </trans-unit>
        <trans-unit id="4aedb952cd727e6e69581496e8e0b6ab6127d03c" translate="yes" xml:space="preserve">
          <source>To further validate my answer, let's take a look at two additional codes.</source>
          <target state="translated">Чтобы еще раз подтвердить мой ответ,давайте посмотрим на два дополнительных кода.</target>
        </trans-unit>
        <trans-unit id="3488d10d037c07a6d63c40837ee02a62ef16f935" translate="yes" xml:space="preserve">
          <source>To further verify that the list in &lt;code&gt;__defaults__&lt;/code&gt; is the same as that used in the function &lt;code&gt;func&lt;/code&gt; you can just change your function to return the &lt;code&gt;id&lt;/code&gt; of the list &lt;code&gt;a&lt;/code&gt; used inside the function body. Then, compare it to the list in &lt;code&gt;__defaults__&lt;/code&gt; (position &lt;code&gt;[0]&lt;/code&gt; in &lt;code&gt;__defaults__&lt;/code&gt;) and you'll see how these are indeed refering to the same list instance:</source>
          <target state="translated">Для дальнейшей проверки того, что список в &lt;code&gt;__defaults__&lt;/code&gt; совпадает со списком, используемым в функции &lt;code&gt;func&lt;/code&gt; , вы можете просто изменить свою функцию, чтобы она возвращала &lt;code&gt;id&lt;/code&gt; списка, используемого внутри тела функции. Затем сравните его со списком в &lt;code&gt;__defaults__&lt;/code&gt; (позиция &lt;code&gt;[0]&lt;/code&gt; в &lt;code&gt;__defaults__&lt;/code&gt; ), и вы увидите, как они действительно ссылаются на тот же экземпляр списка:</target>
        </trans-unit>
        <trans-unit id="6c169f56bd97d585a628344306275a6fbb160c64" translate="yes" xml:space="preserve">
          <source>To make things simpler for this discussion, let's temporarily give the unnamed list a name. How about &lt;code&gt;pavlo&lt;/code&gt; ?</source>
          <target state="translated">Чтобы упростить обсуждение, давайте временно дадим неназванному списку имя. Как насчет &lt;code&gt;pavlo&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="e3a6729bfe6a04ecd5a00fc68b6c0f6331500e7a" translate="yes" xml:space="preserve">
          <source>To me, it seems that the design decision was relative to where to put the scope of parameters: inside the function or &quot;together&quot; with it?</source>
          <target state="translated">Мне кажется,что проектное решение относилось к тому,куда поместить объем параметров:внутри функции или &quot;вместе&quot; с ней?</target>
        </trans-unit>
        <trans-unit id="636d1dcd268f11a46b28fe964396e61a54cf23da" translate="yes" xml:space="preserve">
          <source>Ugly, but it works.</source>
          <target state="translated">Уродливо,но это работает.</target>
        </trans-unit>
        <trans-unit id="f1f3a34856e7b498ab581f67c98cdf2d11513052" translate="yes" xml:space="preserve">
          <source>Upon &lt;code&gt;L = []&lt;/code&gt;, the assignment cannot succeed at &lt;code&gt;foo.func_defs[0]&lt;/code&gt;, because that attribute is read-only.</source>
          <target state="translated">При &lt;code&gt;L = []&lt;/code&gt; назначение не может быть успешным в &lt;code&gt;foo.func_defs[0]&lt;/code&gt; , потому что этот атрибут только для чтения.</target>
        </trans-unit>
        <trans-unit id="b4add7a466713c04e3a9ff607faa91aff366d0f8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;None&lt;/code&gt; as your default value (or a nonce &lt;code&gt;object&lt;/code&gt;), and switch on that to create your values at runtime; or</source>
          <target state="translated">Используйте &lt;code&gt;None&lt;/code&gt; в качестве значения по умолчанию (или &lt;code&gt;object&lt;/code&gt; nonce) и включите его, чтобы создавать значения во время выполнения; или же</target>
        </trans-unit>
        <trans-unit id="ea379d2578b870e14c73410aa538eccdf7d0c72c" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;lambda&lt;/code&gt; as your default parameter, and call it within a try block to get the default value (this is the sort of thing that lambda abstraction is for).</source>
          <target state="translated">Используйте &lt;code&gt;lambda&lt;/code&gt; качестве параметра по умолчанию и вызывайте ее в блоке try, чтобы получить значение по умолчанию (для такого рода лямбда-абстракций).</target>
        </trans-unit>
        <trans-unit id="9ce0fb10a3874ece19a632c8bbfe4072e2abf695" translate="yes" xml:space="preserve">
          <source>We can get information about the arguments and defaults using the &lt;code&gt;inspect&lt;/code&gt; module, which</source>
          <target state="translated">Мы можем получить информацию об аргументах и ​​значениях по умолчанию, используя модуль &lt;code&gt;inspect&lt;/code&gt; , который</target>
        </trans-unit>
        <trans-unit id="f43fd0e1e7b924e195b0d1f43667f4b3ecb78cc3" translate="yes" xml:space="preserve">
          <source>We will &quot;fix&quot; this behavior with a decorator that will copy the default value instead of reusing the same instance for each positional argument left at its default value.</source>
          <target state="translated">Мы &quot;исправим&quot; такое поведение декоратором,который будет копировать значение по умолчанию,вместо того,чтобы повторно использовать один и тот же экземпляр для каждого позиционного аргумента,оставленного на его значении по умолчанию.</target>
        </trans-unit>
        <trans-unit id="028722da6bbfb13719d096b837a20e83f8b33121" translate="yes" xml:space="preserve">
          <source>Well, the reason is quite simply that bindings are done when code is executed, and the function definition is executed, well... when the functions is defined.</source>
          <target state="translated">Причина в том,что привязки выполняются,когда выполняется код,а определение функции выполняется,ну...когда определяются функции.</target>
        </trans-unit>
        <trans-unit id="7ad15b2528d3a839026c0d58cd1ee45b2711f4f7" translate="yes" xml:space="preserve">
          <source>What you're asking is why this:</source>
          <target state="translated">Ты спрашиваешь,почему это:</target>
        </trans-unit>
        <trans-unit id="bb251fe5322c9cbb5669eb17fcc4c69cba91f98f" translate="yes" xml:space="preserve">
          <source>When I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple &lt;code&gt;(&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)&lt;/code&gt;</source>
          <target state="translated">Когда я вижу объявление о еде, самое удивительное - думать, что если первый параметр не указан, он будет равен кортежу &lt;code&gt;(&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92837d652717841e4dbdd22b5957c04117add88c" translate="yes" xml:space="preserve">
          <source>When Python encounters it, the first thing it will do is compile it in order to create a &lt;code&gt;code&lt;/code&gt; object for this function. While this compilation step is done, &lt;em&gt;Python &lt;strong&gt;evaluates&lt;/strong&gt;* and then &lt;strong&gt;stores&lt;/strong&gt; the default arguments (an empty list &lt;code&gt;[]&lt;/code&gt; here) in the function object itself&lt;/em&gt;. As the top answer mentioned: the list &lt;code&gt;a&lt;/code&gt; can now be considered a &lt;em&gt;member&lt;/em&gt; of the function &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">Когда Python встречает его, первое, что он сделает, это скомпилирует его, чтобы создать объект &lt;code&gt;code&lt;/code&gt; для этой функции. Пока этот шаг компиляции выполнен, &lt;em&gt;Python &lt;strong&gt;оценивает&lt;/strong&gt; * и затем &lt;strong&gt;сохраняет&lt;/strong&gt; аргументы по умолчанию (здесь пустой список &lt;code&gt;[]&lt;/code&gt; ) в самом объекте функции&lt;/em&gt; . Как отмечается в верхнем ответе: список &lt;code&gt;a&lt;/code&gt; теперь можно считать &lt;em&gt;членом&lt;/em&gt; функции &lt;code&gt;func&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd17f911f362a654b5a6c64b275c0e88df650e11" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;foo&lt;/code&gt; function object is instantiated, &lt;code&gt;foo.func_defs[0]&lt;/code&gt; is set to &lt;code&gt;None&lt;/code&gt;, an immutable object.</source>
          <target state="translated">Когда &lt;code&gt;foo.func_defs[0]&lt;/code&gt; объект функции &lt;code&gt;foo&lt;/code&gt; , для foo.func_defs [0] устанавливается значение &lt;code&gt;None&lt;/code&gt; , неизменяемый объект.</target>
        </trans-unit>
        <trans-unit id="6bb5893e3a075febba63fa1345cc1545dec24f55" translate="yes" xml:space="preserve">
          <source>When the function is executed with defaults (with no parameter specified for &lt;code&gt;L&lt;/code&gt; in the function call), &lt;code&gt;foo.func_defs[0]&lt;/code&gt; (&lt;code&gt;None&lt;/code&gt;) is available in the local scope as &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">Когда функция выполняется со значениями по умолчанию (без параметра, указанного для &lt;code&gt;L&lt;/code&gt; в вызове функции), &lt;code&gt;foo.func_defs[0]&lt;/code&gt; ( &lt;code&gt;None&lt;/code&gt; ) доступен в локальной области как &lt;code&gt;L&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c90da9c4543da64cdb8845246bc7bf7320e0bc1d" translate="yes" xml:space="preserve">
          <source>When they are mutable, when mutated (for example, by adding an element to it) they remain mutated on consecutive calls.</source>
          <target state="translated">При мутации (например,при добавлении в нее элемента)они остаются мутированными при последовательных вызовах.</target>
        </trans-unit>
        <trans-unit id="2241f2b26702e693ed138e31ffa8bd03750a3109" translate="yes" xml:space="preserve">
          <source>When we do this:</source>
          <target state="translated">Когда мы это сделаем:</target>
        </trans-unit>
        <trans-unit id="6912ff10f6eb1fb687cb173f4f87e2aa8cb150d3" translate="yes" xml:space="preserve">
          <source>Why don't you introspect?</source>
          <target state="translated">Почему бы тебе не провести самоанализ?</target>
        </trans-unit>
        <trans-unit id="287fc26c3268d8d1c2a9357d670b0099b1576d07" translate="yes" xml:space="preserve">
          <source>Why should the &lt;code&gt;a=[]&lt;/code&gt; in</source>
          <target state="translated">Почему &lt;code&gt;a=[]&lt;/code&gt; в</target>
        </trans-unit>
        <trans-unit id="52b2c683c383df4eb8aa68d958bd6badb17f2b85" translate="yes" xml:space="preserve">
          <source>Yes, it is unexpected. But once the penny drops, it fits in perfectly with how Python works in general. In fact, it's a good teaching aid, and once you understand why this happens, you'll grok python much better.</source>
          <target state="translated">Да,это неожиданно.Но как только пенни падает,он прекрасно вписывается в то,как работает Python в целом.На самом деле,это хорошее учебное пособие,и как только вы поймете,почему это происходит,вы будете грокотать питон гораздо лучше.</target>
        </trans-unit>
        <trans-unit id="9083597dacf68f7853fb01578d3aa2ab71e8663f" translate="yes" xml:space="preserve">
          <source>You can get round this by replacing the object (and therefore the tie with the scope):</source>
          <target state="translated">Вы можете обойти это,заменив объект (и,следовательно,галстук на область видимости):</target>
        </trans-unit>
        <trans-unit id="b512ff0f2aacb271cc653788c90da69d6dfc77d3" translate="yes" xml:space="preserve">
          <source>You can verify that they are one and the same object by using &lt;code&gt;id&lt;/code&gt;:</source>
          <target state="translated">Вы можете проверить, что это один и тот же объект, используя &lt;code&gt;id&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b7a57f1c427b2aba87570b0fda4061b9802afcc3" translate="yes" xml:space="preserve">
          <source>You intend to leave the argument unmodified, but you accidentally &lt;em&gt;did&lt;/em&gt; modify it. That's a bug, fix it.</source>
          <target state="translated">Вы намерены оставить аргумент без изменений, но вы случайно изменили его. Это ошибка, исправьте это.</target>
        </trans-unit>
        <trans-unit id="c2929c645da85b138bef1656c13169d0ec045e7d" translate="yes" xml:space="preserve">
          <source>You intend to modify the argument as a side effect of the function. In this case it &lt;em&gt;never makes sense&lt;/em&gt; to have a default argument. The only exception is when you're abusing the argument list to have function attributes, e.g. &lt;code&gt;cache={}&lt;/code&gt;, and you wouldn't be expected to call the function with an actual argument at all.</source>
          <target state="translated">Вы намерены изменить аргумент как побочный эффект функции. В этом случае &lt;em&gt;никогда не имеет смысла&lt;/em&gt; иметь аргумент по умолчанию. Единственное исключение - когда вы злоупотребляете списком аргументов, чтобы иметь атрибуты функции, например &lt;code&gt;cache={}&lt;/code&gt; , и вы вообще не должны вызывать функцию с фактическим аргументом.</target>
        </trans-unit>
        <trans-unit id="17d9e231f7ae8537e606b6c0973a016f0c3b9581" translate="yes" xml:space="preserve">
          <source>You intend to modify the argument for use inside the function, but didn't expect the modification to be viewable outside of the function. In that case you need to make a &lt;em&gt;copy&lt;/em&gt; of the argument, whether it was the default or not! Python is not a call-by-value language so it doesn't make the copy for you, you need to be explicit about it.</source>
          <target state="translated">Вы намереваетесь изменить аргумент для использования внутри функции, но не ожидали, что модификация будет видимой вне функции. В этом случае вам нужно сделать &lt;em&gt;копию&lt;/em&gt; аргумента, был ли он по умолчанию или нет! Python не является языком вызова по значению, поэтому он не делает копию для вас, вам нужно четко об этом сказать.</target>
        </trans-unit>
        <trans-unit id="a6ced87465fcf1eeb8fdd29b614471918519675e" translate="yes" xml:space="preserve">
          <source>Your example is a good one of a case where Python newcomers will be surprised and bitten.  But I'd argue that if we &quot;fixed&quot; this, then that would only create a different situation where they'd be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they're writing.</source>
          <target state="translated">Ваш пример-хороший случай,когда новички Python будут удивлены и укушены.Но я бы возразил,что если мы &quot;исправим&quot; это,то это только создаст другую ситуацию,когда их будут кусать,и это будет ещё менее интуитивно понятно.Более того,это всегда так,когда имеешь дело с мутируемыми переменными;всегда встречаются случаи,когда кто-то может интуитивно ожидать одно или противоположное поведение в зависимости от того,какой код он пишет.</target>
        </trans-unit>
        <trans-unit id="27311373d31b73eb41d1e0b30e06efc32dc97a21" translate="yes" xml:space="preserve">
          <source>Your original &lt;code&gt;foo&lt;/code&gt;, with a default argument, shouldn't be modifying &lt;code&gt;a&lt;/code&gt; whether it was explicitly passed in or got the default value. Your code should leave mutable arguments alone unless it is clear from the context/name/documentation that the arguments are supposed to be modified. Using mutable values passed in as arguments as local temporaries is an extremely bad idea, whether we're in Python or not and whether there are default arguments involved or not.</source>
          <target state="translated">Ваш оригинальный &lt;code&gt;foo&lt;/code&gt; с аргументом по умолчанию не должен изменять, &lt;code&gt;a&lt;/code&gt; ли он передан явно или получил значение по умолчанию. Ваш код должен оставлять изменяемые аргументы в покое, если из контекста / имени / документации не ясно, что аргументы должны быть изменены. Использование изменяемых значений, передаваемых в качестве аргументов в качестве локальных временных файлов, является крайне плохой идеей, независимо от того, находимся ли мы в Python или нет, и задействованы ли аргументы по умолчанию или нет.</target>
        </trans-unit>
        <trans-unit id="a47c48016c7bd5e01546ccb1b762c78b706d5abe" translate="yes" xml:space="preserve">
          <source>[] is an object, so python pass the reference of [] to &lt;code&gt;a&lt;/code&gt;, i.e., &lt;code&gt;a&lt;/code&gt; is only a pointer to [] which lies in memory as an object. There is only one copy of [] with, however, many references to it. For the first foo(), the list [] is changed to &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; by append method. But Note that there is only one copy of the list object and this object now becomes &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt;. When running the second foo(), what effbot webpage says (items is not evaluated any more) is wrong. &lt;code&gt;a&lt;/code&gt; is evaluated to be the list object, although now the content of the object is &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt;. This is the effect of passing by reference! The result of foo(3) can be easily derived in the same way.</source>
          <target state="translated">[] является объектом, поэтому python передает ссылку [] на &lt;code&gt;a&lt;/code&gt; , т. е. &lt;code&gt;a&lt;/code&gt; является только указателем на [], который находится в памяти как объект. Существует только одна копия [] с множеством ссылок на нее. Для первого foo () список [] изменяется на &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; методом добавления. Но обратите внимание, что существует только одна копия объекта списка, и этот объект теперь становится &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; . Когда запускается второй foo (), то, что говорит веб-страница effbot (элементы больше не оцениваются), неверно. &lt;code&gt;a&lt;/code&gt; оценивается как объект списка, хотя теперь содержимое объекта равно &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; . Это эффект передачи по ссылке! Результат foo (3) может быть легко получен таким же образом.</target>
        </trans-unit>
        <trans-unit id="811a1b05ff4f47b946f5851e4e0919d50dfa1cfc" translate="yes" xml:space="preserve">
          <source>and running it with &lt;code&gt;python example.py&lt;/code&gt;:</source>
          <target state="translated">и запустить его с помощью &lt;code&gt;python example.py&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="049874c49f0ace21f9f13dd31c57abc695140bba" translate="yes" xml:space="preserve">
          <source>as you'll notice, &lt;code&gt;input()&lt;/code&gt; is called before the process of building the function and binding it to the name &lt;code&gt;bar&lt;/code&gt; is made.</source>
          <target state="translated">как вы заметите, &lt;code&gt;input()&lt;/code&gt; вызывается до того, как будет создан процесс построения функции и ее привязки к &lt;code&gt;bar&lt;/code&gt; имени.</target>
        </trans-unit>
        <trans-unit id="3375274202e5815d3135c4440713525187e9f33a" translate="yes" xml:space="preserve">
          <source>everything is passed by reference</source>
          <target state="translated">всё передаётся по ссылке</target>
        </trans-unit>
        <trans-unit id="127ad2d11d264ef1bc3b7c9367a87c065c2e20d2" translate="yes" xml:space="preserve">
          <source>except for the case of explicitly calling func(None, None), which we'll ignore.</source>
          <target state="translated">за исключением случая явного вызова функции(None,None),которую мы проигнорируем.</target>
        </trans-unit>
        <trans-unit id="fc5c678a45bcac56840b3c908642740f5ede6d3d" translate="yes" xml:space="preserve">
          <source>function (class etc.) declaration is executed only once, creating all default value objects</source>
          <target state="translated">декларация функции (класса и т.д.)выполняется только один раз,создавая все объекты значений по умолчанию</target>
        </trans-unit>
        <trans-unit id="71759c14baa0f1b45b053d0754f9b76a716165c8" translate="yes" xml:space="preserve">
          <source>instantiate a new list on function definition and not on invocation?
It's just like you're asking &quot;if the user doesn't provide the argument then &lt;em&gt;instantiate&lt;/em&gt; a new list and use it as if it was produced by the caller&quot;.
I think this is ambiguous instead:</source>
          <target state="translated">создать новый список по определению функции, а не по вызову? Это как если бы вы спросили: &amp;laquo;Если пользователь не предоставит аргумент, &lt;em&gt;создайте&lt;/em&gt; новый список и используйте его так, как если бы он был создан вызывающей стороной&amp;raquo;. Я думаю, что это двусмысленно:</target>
        </trans-unit>
        <trans-unit id="9d29cbd7a4d1e405b35c263d8e5d5507492f015a" translate="yes" xml:space="preserve">
          <source>is almost exactly equivalent to this:</source>
          <target state="translated">почти в точности эквивалентна этому:</target>
        </trans-unit>
        <trans-unit id="d94296d98f302fe54eca1ccc91cf45236ffa89e2" translate="yes" xml:space="preserve">
          <source>isn't internally equivalent to this:</source>
          <target state="translated">не является внутренним эквивалентом этого:</target>
        </trans-unit>
        <trans-unit id="3e5690a3202553a2f619db51e48332229bfe602f" translate="yes" xml:space="preserve">
          <source>it is entirely consistent to hold to both of the features above and still make another point:</source>
          <target state="translated">это полностью согласуется с тем,чтобы удержать оба вышеперечисленных признака,и все же сделать еще один пункт:</target>
        </trans-unit>
        <trans-unit id="39fcd29280818de6a833974667212de642dcf2a7" translate="yes" xml:space="preserve">
          <source>observing that the id is the same each time the list is referenced,</source>
          <target state="translated">наблюдая за тем,что идентификатор идентичен каждый раз,когда на него ссылаются,</target>
        </trans-unit>
        <trans-unit id="d8e7da304415824d87e81f7b39df6675059d9a54" translate="yes" xml:space="preserve">
          <source>observing that the list stays changed when the function that uses it is called a second time,</source>
          <target state="translated">наблюдая,что список остается измененным,когда функция,которая его использует,вызывается во второй раз,</target>
        </trans-unit>
        <trans-unit id="b573226ee49e1a1dd733f88915532ed8bd52e8f9" translate="yes" xml:space="preserve">
          <source>observing the order in which the output is printed from the source (which I conveniently numbered for you):</source>
          <target state="translated">соблюдая порядок,в котором вывод выводится из источника (который я удобно пронумеровал для вас):</target>
        </trans-unit>
        <trans-unit id="04c9c0f5ccf58a5d42c14519b24d6f2145c58d5f" translate="yes" xml:space="preserve">
          <source>prints the following</source>
          <target state="translated">печатает следующие документы</target>
        </trans-unit>
        <trans-unit id="db480f941abc083354113eeeff05d261f2c92991" translate="yes" xml:space="preserve">
          <source>seeing that the list is created before the function has finished compiling to a function object,</source>
          <target state="translated">видя,что список создается до того,как функция завершит компиляцию в объект функции,</target>
        </trans-unit>
        <trans-unit id="7fae1298345bf082e2261fee60080aa9d63fe920" translate="yes" xml:space="preserve">
          <source>then if default parameters were bound at function execution rather than function declaration then I would be astonished (in a very bad way) to discover that fruits had been changed.  This would be more astonishing IMO than discovering that your &lt;code&gt;foo&lt;/code&gt; function above was mutating the list.</source>
          <target state="translated">тогда, если параметры по умолчанию были связаны при выполнении функции, а не объявлении функции, то я был бы удивлен (очень плохим способом), чтобы обнаружить, что фрукты были изменены. Это было бы более поразительным IMO, чем обнаружение, что ваша функция &lt;code&gt;foo&lt;/code&gt; выше изменяла список.</target>
        </trans-unit>
        <trans-unit id="f16bec6158470b4bee129a9e6c86214a2e496fdf" translate="yes" xml:space="preserve">
          <source>user, do you want &lt;code&gt;a&lt;/code&gt; to default to the datetime corresponding to when you're defining or executing &lt;code&gt;x&lt;/code&gt;?
In this case, as in the previous one, I'll keep the same behaviour as if the default argument &quot;assignment&quot; was the first instruction of the function (&lt;code&gt;datetime.now()&lt;/code&gt; called on function invocation).
On the other hand, if the user wanted the definition-time mapping he could write:</source>
          <target state="translated">пользователь, вы хотите, чтобы по умолчанию дата и время соответствовали тому, когда вы определяете или выполняете &lt;code&gt;x&lt;/code&gt; ? В этом случае, как и в предыдущем, я буду вести себя так же, как если бы аргумент по умолчанию &amp;laquo;назначение&amp;raquo; был первой инструкцией функции ( &lt;code&gt;datetime.now()&lt;/code&gt; вызываемой при вызове функции). С другой стороны, если пользователь хочет отображать время определения, он может написать:</target>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="translated">with</target>
        </trans-unit>
        <trans-unit id="06e3de5b5b2d499fee4d0c87a0745254a4a566cb" translate="yes" xml:space="preserve">
          <source>you expect to get a &lt;strong&gt;new&lt;/strong&gt; list referenced by &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">вы ожидаете получить &lt;strong&gt;новый&lt;/strong&gt; список, на который ссылается &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c194c14b318f40b680d2378e5d49d583177218c" translate="yes" xml:space="preserve">
          <source>“Least Astonishment” and the Mutable Default Argument</source>
          <target state="translated">&quot;Наименьшее Удивление&quot; и &quot;Аргумент о ненадежности&quot;.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
