<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1132941">
    <body>
      <group id="1132941">
        <trans-unit id="b69b153d9b8b6ca5cc39aae8241344dc670096ea" translate="yes" xml:space="preserve">
          <source>&quot;All functions with this problem &lt;strong&gt;suffer also from similar side effect problem on the actual parameter&lt;/strong&gt;,&quot;</source>
          <target state="translated">&quot;이 문제를 가진 모든 기능 &lt;strong&gt;은 실제 매개 변수와 유사한 부작용 문제가 있습니다.&lt;/strong&gt; &quot;</target>
        </trans-unit>
        <trans-unit id="626c5410f93ad070237bab8024217f1cdd086983" translate="yes" xml:space="preserve">
          <source>... we assign the argument &lt;code&gt;a&lt;/code&gt; to an &lt;em&gt;unnamed&lt;/em&gt; list, if the caller does not pass the value of a.</source>
          <target state="translated">... 호출자가 a 값을 전달하지 않으면 인수 &lt;code&gt;a&lt;/code&gt; 를 &lt;em&gt;명명되지 않은&lt;/em&gt; 목록에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="d6ae47a54ed3aae922aa9b755c46be05126dc9cc" translate="yes" xml:space="preserve">
          <source>...all variables found outside of the innermost scope are
  read-only (&lt;strong&gt;&lt;em&gt;an attempt to write to such a variable will simply create a
  new local variable in the innermost scope, leaving the identically
  named outer variable unchanged&lt;/em&gt;&lt;/strong&gt;).</source>
          <target state="translated">... 가장 안쪽 범위 밖에서 발견 된 모든 변수는 읽기 전용입니다 ( &lt;strong&gt;&lt;em&gt;이러한 변수에 쓰려고하면 가장 안쪽 범위에 새 로컬 변수가 만들어지고 동일한 이름의 바깥 쪽 변수는 변경되지 않은 채로 남습니다&lt;/em&gt;&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="ce4a03df48f71c59cb88d1614e04c355fe07eb41" translate="yes" xml:space="preserve">
          <source>1)  The so-called problem of &quot;Mutable Default Argument&quot; is in general a special example demonstrating that:</source>
          <target state="translated">1) &quot;Mutable Default Argument&quot;의 소위 문제는 일반적으로 다음을 보여주는 특별한 예입니다.</target>
        </trans-unit>
        <trans-unit id="7ae49a8787afe33029393476223d3e6b04a350d7" translate="yes" xml:space="preserve">
          <source>3) In some cases is &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;the mutable behavior of default parameters useful&lt;/a&gt;.</source>
          <target state="translated">3) 경우에 &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;따라 기본 매개 변수의 변경 가능한 동작이 유용합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="349e3dc6e53ca45e7b264f3f4ece59155e2a0d64" translate="yes" xml:space="preserve">
          <source>5 points in defense of Python</source>
          <target state="translated">파이썬 방어에서 5 포인트</target>
        </trans-unit>
        <trans-unit id="5619d3a6ff41fedee09fe44cfec87d091658e509" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;1</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt;1</target>
        </trans-unit>
        <trans-unit id="f9a7d25963aa0148809943888747c7bfdbad1397" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;#&lt;/code&gt;2</source>
          <target state="translated">&lt;code&gt;#&lt;/code&gt;2</target>
        </trans-unit>
        <trans-unit id="f2848d4bf5368cd6cc2a23c96bcb460686851bd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;[]&lt;/code&gt; is an object, so is &lt;code&gt;None&lt;/code&gt; (the former is mutable while the latter is immutable. But the mutability has nothing to do with the question). None is somewhere in the space but we know it's there and there is only one copy of None there. So every time foo is invoked, items is evaluated (as opposed to some answer that it is only evaluated once) to be None, to be clear, the reference (or the address) of None. Then in the foo, item is changed to [], i.e., points to another object which has a different address.</source>
          <target state="translated">&lt;code&gt;[]&lt;/code&gt; 는 객체이므로 &lt;code&gt;None&lt;/code&gt; 도 마찬가지입니다 (후자는 변경할 수 없지만 후자는 변경할 수 없지만 질문과는 아무런 관련이 없습니다). 공간 어딘가에 아무도 없지만 거기에 있으며 없음 사본이 하나만 있다는 것을 알고 있습니다. 따라서 foo가 호출 될 때마다 항목은 (한 번만 평가된다는 대답과 달리) 없음, 명확함, 없음의 참조 (또는 주소)로 평가됩니다. 그런 다음 foo에서 item은 []로 변경됩니다. 즉, 주소가 다른 다른 객체를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="0b51475de74c8a0af3e8ac61016a0b03493b9c51" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a&lt;/code&gt; doesn't change - every assignment call creates new int object - new object is printed</source>
          <target state="translated">변경 사항 없음-모든 할당 호출이 새로운 int 객체를 생성합니다-새로운 객체가 인쇄됩니다</target>
        </trans-unit>
        <trans-unit id="c91d4e033dfa8facf99b416bc8eb05efa39a8648" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;b&lt;/code&gt; doesn't change - new array is build from default value and printed</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 는 바뀌지 않습니다-새로운 배열은 기본값에서 빌드되고 인쇄됩니다</target>
        </trans-unit>
        <trans-unit id="99868d483227e38115a490908f9eb6410e764c96" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;c&lt;/code&gt; changes - operation is performed on same object - and it is printed</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 변경-동일한 객체에서 작업이 수행되고 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="1dce96d08fb23e6dd9bf8c83e0ce03a0c31931c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Astonished?&lt;/em&gt; The value inside the object changes! Consecutive calls to the function will now simply append to that embedded &lt;code&gt;list&lt;/code&gt; object:</source>
          <target state="translated">&lt;em&gt;놀랐습니까?&lt;/em&gt; 객체 내부의 값이 변경됩니다! 함수에 대한 연속적인 호출은 이제 포함 된 &lt;code&gt;list&lt;/code&gt; 객체에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="9a5e006676bccb5e949d65e43cc04bfdb3e0f5c0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;This is not a design flaw&lt;/em&gt;. Anyone who trips over this is doing something wrong.</source>
          <target state="translated">&lt;em&gt;이것은 디자인 결함이 아닙니다&lt;/em&gt; . 이것을 넘어가는 사람은 무언가 잘못하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bb5707416517e01b1b19796f5b4d8047f7be81f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;(1)&lt;/strong&gt; is described in the Python &lt;a href=&quot;http://docs.python.org/tutorial/classes.html&quot;&gt;tutorial on classes&lt;/a&gt;. In an attempt to assign a value to a read-only class attribute:</source>
          <target state="translated">&lt;strong&gt;(1)&lt;/strong&gt; 은 &lt;a href=&quot;http://docs.python.org/tutorial/classes.html&quot;&gt;클래스&lt;/a&gt; 의 Python 튜토리얼에 설명되어 있습니다 . 읽기 전용 클래스 속성에 값을 할당하려는 경우 :</target>
        </trans-unit>
        <trans-unit id="1e830734a74d3ffb326fa9a33d2d932c606c6e1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. 성능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d1c12447cabd52b525bef97e580f6be054679aad" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Forcing bound parameters&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. 바인딩 된 매개 변수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23662664198844161cfe301172c065fd31a550b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;3. Introspection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;3. 내성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="329d395d793f53ccf44090cd1ed8d91c54ccbc68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Consistency&lt;/strong&gt;: Python &lt;em&gt;always&lt;/em&gt; passes objects, not names.
The default parameter is, obviously, part of the function 
heading (not the function body). It therefore ought to be evaluated
at module load time (and only at module load time, unless nested), not
at function call time.</source>
          <target state="translated">&lt;strong&gt;일관성&lt;/strong&gt; : 파이썬은 &lt;em&gt;항상&lt;/em&gt; 이름이 아닌 객체를 전달합니다. 기본 매개 변수는 분명히 함수 제목이 아닌 함수 제목의 일부입니다. 따라서 함수 호출 시가 아니라 모듈로드시 (및 중첩되지 않은 경우에만 모듈로드시에만) 평가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="cf88699ee467bc4d13c8c871f2752ff94d964b35" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Default parameter values are evaluated from left to right when the function definition is executed.&lt;/strong&gt; This means that the expression is evaluated once, when the function is defined, and that the same &amp;ldquo;pre-computed&amp;rdquo; value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use &lt;code&gt;None&lt;/code&gt; as the default, and explicitly test for it in the body of the function, e.g.:</source>
          <target state="translated">&lt;strong&gt;기능 정의가 실행될 때 기본 매개 변수 값은 왼쪽에서 오른쪽으로 평가됩니다.&lt;/strong&gt; 이는 함수가 정의 될 때 표현식이 한 번 평가되고 각 호출에 대해 동일한 &quot;사전 계산 된&quot;값이 사용됨을 의미합니다. 이것은 기본 매개 변수가 목록 또는 사전과 같이 변경 가능한 개체 인 경우를 이해하는 데 특히 중요합니다. 함수가 개체를 수정하면 (예 : 항목을 목록에 추가하여) 기본값이 실제로 수정됩니다. 이것은 일반적으로 의도 된 것이 아닙니다. 이를 해결하는 방법은 &lt;code&gt;None&lt;/code&gt; 을 기본값으로 사용하고 함수 본문에서 명시 적으로 테스트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="539d5ec10b781d448886afa96eab4c325719e096" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;Edit&lt;/strong&gt;:</target>
        </trans-unit>
        <trans-unit id="d7ce856e37c4d17dcd955af410f64cbfd4b44efb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Meta-learning&lt;/strong&gt;: Falling into the trap is actually a very
helpful moment (at least if you are a reflective learner),
because you will subsequently better understand the point 
&quot;Consistency&quot; above and that will
teach you a great deal about Python.</source>
          <target state="translated">&lt;strong&gt;메타 학습&lt;/strong&gt; : 함정에 빠지는 것은 실제로 매우 유용한 순간입니다 (적어도 반사 학습자 인 경우). 위의 &quot;일관성&quot;점을 더 잘 이해하고 파이썬에 대해 많은 것을 가르쳐 줄 것이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2c97178ae1f0df97cdd3aaefd09767743c8eb65b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Preferred Method&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;선호하는 방법&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="e76f2bbaaca5d9222981a5a9ed9effda9259956d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simplicity&lt;/strong&gt;: The behavior is simple in the following sense:
Most people fall into this trap only once, not several times.</source>
          <target state="translated">&lt;strong&gt;단순성&lt;/strong&gt; :이 동작은 다음과 같은 의미에서 간단합니다. 대부분의 사람들은이 함정에 몇 번만 빠지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d8e5d785db266e5750b7b9c674b8350975a43b24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Solution&lt;/strong&gt;:  a &lt;strong&gt;copy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;해결책&lt;/strong&gt; : &lt;strong&gt;사본&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="37f9748bcb10eff54719d247d7d6981eb44d0507" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sufficient documentation&lt;/strong&gt;: In the most basic Python documentation,
the tutorial, the issue is loudly announced as
an &lt;strong&gt;&quot;Important warning&quot;&lt;/strong&gt; in the &lt;em&gt;first&lt;/em&gt; subsection of Section
&lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#default-argument-values&quot;&gt;&quot;More on Defining Functions&quot;&lt;/a&gt;.
The warning even uses boldface,
which is rarely applied outside of headings.
RTFM: Read the fine manual.</source>
          <target state="translated">&lt;strong&gt;충분한 문서&lt;/strong&gt; : 가장 기본적인 파이썬 문서 인 튜토리얼에서이 문제는 &lt;a href=&quot;https://docs.python.org/3/tutorial/controlflow.html#default-argument-values&quot;&gt;&quot;추가 기능 정의에 대한 추가 정보&quot;&lt;/a&gt; 섹션의 &lt;em&gt;첫 번째&lt;/em&gt; 하위 섹션에서 &lt;strong&gt;&quot;중요한 경고&quot;&lt;/strong&gt; 로 크게 발표됩니다. 경고는 굵은 글씨를 사용하기도하며, 제목 외부에서는 거의 적용되지 않습니다. RTFM : 훌륭한 매뉴얼을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="5e1364752e34f5d31f57fbb793918340fe194bee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Usefulness&lt;/strong&gt;: As Frederik Lundh points out in his explanation
of &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;&quot;Default Parameter Values in Python&quot;&lt;/a&gt;, the
current behavior can be quite useful for advanced programming.
(Use sparingly.)</source>
          <target state="translated">&lt;strong&gt;유용성&lt;/strong&gt; : Frederik Lundh가 &lt;a href=&quot;http://effbot.org/zone/default-values.htm#valid-uses-for-mutable-defaults&quot;&gt;&quot;Python의 기본 매개 변수 값&quot;&lt;/a&gt; 에 대한 설명에서 지적한 것처럼 현재 동작은 고급 프로그래밍에 매우 유용 할 수 있습니다. (자주 사용하십시오.)</target>
        </trans-unit>
        <trans-unit id="294df7a72d2c1681571db14e9616ce4b1526495e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Wrong Method (probably...)&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;잘못된 방법 (아마도 ...)&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="82a5f8350abc0dbeea17f36fef8010fcc85d54f4" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;*&lt;/sup&gt; To verify that Python evaluates the default arguments during compilation of the function, try executing the following:</source>
          <target state="translated">&lt;sup&gt;*&lt;/sup&gt; 함수 컴파일 중에 파이썬이 기본 인수를 평가하는지 확인하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="bb413fc5e883d792d1ef3763d765a7965fb2896f" translate="yes" xml:space="preserve">
          <source>====== No. 2 ========</source>
          <target state="translated">====== 2 번 ========</target>
        </trans-unit>
        <trans-unit id="69abcbfba6763da9ac43abb483ce88455e698517" translate="yes" xml:space="preserve">
          <source>====== No. 3 =======</source>
          <target state="translated">====== 3 번 =======</target>
        </trans-unit>
        <trans-unit id="b635b4f551391b730421190ef18f36b5a2349cd2" translate="yes" xml:space="preserve">
          <source>A brief introduction. First, there are two type of data types in python, one is simple elementary data type, like numbers, and another data type is objects. Second, when passing data to parameters, python pass elementary data type by value, i.e., make a local copy of the value to a local variable, but pass object by reference, i.e., pointers to the object.</source>
          <target state="translated">간단한 소개. 첫째, 파이썬에는 두 가지 유형의 데이터 유형이 있습니다. 하나는 숫자와 같은 단순한 기본 데이터 유형이고 다른 하나는 객체입니다. 둘째, 데이터를 매개 변수에 전달할 때 Python은 기본 데이터 유형을 값으로 전달합니다. 즉, 값의 로컬 사본을 로컬 변수에 작성하지만 참조, 즉 객체에 대한 포인터로 객체를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="3241c6873d2d65a534f9b317f8e6387aba7f1c09" translate="yes" xml:space="preserve">
          <source>A manager of mine once had his first encounter with this feature, and called it &quot;a dramatic design flaw&quot; of the language. I replied that the behavior had an underlying explanation, and it is indeed very puzzling and unexpected if you don't understand the internals. However, I was not able to answer (to myself) the following question: what is the reason for binding the default argument at function definition, and not at function execution? I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs?)</source>
          <target state="translated">내 관리자는 한 번이 기능을 처음 접했으며 언어의 &quot;극적인 디자인 결함&quot;이라고 불렀습니다. 나는 그 행동이 근본적인 설명을 가지고 있다고 대답했으며, 당신이 내부를 이해하지 못한다면 실제로 매우 당혹스럽고 예상치 못한 것입니다. 그러나 나는 다음과 같은 질문에 대답 할 수 없었습니다. 함수 실행이 아닌 함수 정의에서 기본 인수를 바인딩하는 이유는 무엇입니까? 숙련 된 행동이 실제로 사용되는지 의심합니다 (누가 버그없이 C에서 정적 변수를 실제로 사용 했습니까?)</target>
        </trans-unit>
        <trans-unit id="b690fd135a267cbcdaf75de80b96af3baa5767c7" translate="yes" xml:space="preserve">
          <source>A simple workaround using None</source>
          <target state="translated">None을 사용하는 간단한 해결 방법</target>
        </trans-unit>
        <trans-unit id="bdd7db67e420ecc9dcbd543e9f887304309b4542" translate="yes" xml:space="preserve">
          <source>A useful trick is to bind parameters of a lambda to the &lt;em&gt;current&lt;/em&gt; binding of a variable when the lambda is created.  For example:</source>
          <target state="translated">유용한 방법은 람다가 생성 될 때 람다의 매개 변수를 변수의 &lt;em&gt;현재&lt;/em&gt; 바인딩에 바인딩하는 것입니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="66dcf0d939788f48ade0f8205215ced808c313bc" translate="yes" xml:space="preserve">
          <source>Actually, this is not a design flaw, and it is not because of internals, or performance.</source>
          <target state="translated">실제로 이것은 디자인 결함이 아니며 내부 또는 성능 때문이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="995d1d076d3d58278102dc33655d7de6f9e9da69" translate="yes" xml:space="preserve">
          <source>Admitting the above two points, let's explain what happened to the python code. It's only because of passing by reference for objects, but has nothing to do with mutable/immutable, or arguably the fact that &quot;def&quot; statement is executed only once when it is defined.</source>
          <target state="translated">위의 두 가지 점을 인정하면서 파이썬 코드에 무슨 일이 있었는지 설명해 봅시다. 객체에 대한 참조로 전달되기 때문일 뿐이지 만 변경 가능 / 불변 가능 또는 &quot;def&quot;문이 정의 될 때 한 번만 실행된다는 사실과는 아무런 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="12e60dab7722d48c3d6b49bcd3fb84f98b18afcc" translate="yes" xml:space="preserve">
          <source>After Python executes this definition it will take any default parameters specified (&lt;code&gt;a = []&lt;/code&gt; here) and &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy&quot;&gt;cram them in the &lt;code&gt;__defaults__&lt;/code&gt; attribute for the function object&lt;/a&gt; (relevant section: Callables):</source>
          <target state="translated">파이썬이이 정의를 실행 한 후에는 지정된 기본 매개 변수 (여기에서 &lt;code&gt;a = []&lt;/code&gt; )를 가져 &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#the-standard-type-hierarchy&quot;&gt;와서 함수 객체&lt;/a&gt; (관련 섹션 : Callables) 의 &lt;code&gt;__defaults__&lt;/code&gt; 속성에 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="00ee3bf105e662d4c817e2a1dc2ea4cb63f26aa2" translate="yes" xml:space="preserve">
          <source>All with the power of introspection!</source>
          <target state="translated">내성의 힘을 가진 모든 것!</target>
        </trans-unit>
        <trans-unit id="8511aa6f9e2aee5234b37fe72ed01ccf13a1f8e1" translate="yes" xml:space="preserve">
          <source>Already busy topic, but from what I read here, the following helped me realizing how it's working internally:</source>
          <target state="translated">이미 바쁜 주제이지만 여기서 읽은 내용을 통해 다음과 같은 내용이 내부에서 어떻게 작동하는지 알 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="edef5af058c46851da7320ae99d9fe37689e0b06" translate="yes" xml:space="preserve">
          <source>An absolutely safe solution is to &lt;strong&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/strong&gt; or &lt;strong&gt;&lt;code&gt;deepcopy&lt;/code&gt;&lt;/strong&gt; the input object first and then to do whatever with the copy.</source>
          <target state="translated">절대적으로 안전한 해결책은 입력 개체를 먼저 &lt;strong&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/strong&gt; 또는 &lt;strong&gt; &lt;code&gt;deepcopy&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;복사&lt;/strong&gt; 한 다음 복사본으로 무엇이든 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="09883d93fd6b6978404b7d03e6adc34d60b2d91d" translate="yes" xml:space="preserve">
          <source>Anyone tinkering with Python long enough has been bitten (or torn to pieces) by the following issue:</source>
          <target state="translated">파이썬으로 오랫동안 땜질을 한 사람은 다음과 같은 문제로 물렸거나 조각났습니다.</target>
        </trans-unit>
        <trans-unit id="7870ab2e57db73f3c412a09b43f15db1bdd86aa3" translate="yes" xml:space="preserve">
          <source>As others have extensively commented, the list parameter is bound to the function when it is defined as opposed to when it is executed.  Because lists and dictionaries are mutable, any alteration to this parameter will affect other calls to this function.  As a result, subsequent calls to the function will receive this shared list which may have been altered by any other calls to the function.  Worse yet, two parameters are using this function's shared parameter at the same time oblivious to the changes made by the other.</source>
          <target state="translated">다른 사람들이 광범위하게 언급했듯이 list 매개 변수는 함수가 실행될 때와 반대로 정의 될 때 함수에 바인딩됩니다. 목록과 사전은 변경할 수 있으므로이 매개 변수를 변경하면이 함수에 대한 다른 호출에 영향을줍니다. 결과적으로, 함수에 대한 후속 호출은 함수에 대한 다른 호출에 의해 변경되었을 수있는이 공유 목록을 수신합니다. 더 나쁜 것은 두 매개 변수가이 기능의 공유 매개 변수를 동시에 사용하고 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="32ec561bfb975a7dfa873e1e6e2af0f1d887859e" translate="yes" xml:space="preserve">
          <source>As soon as you get to think into this way, then it completely makes sense: a function is an object being evaluated on its definition; default parameters are kind of &quot;member data&quot; and therefore their state may change from one call to the other - exactly as in any other object.</source>
          <target state="translated">이런 식으로 생각하자마자 완전히 이해가됩니다. 함수는 정의에 대해 평가되는 객체입니다. 기본 매개 변수는 일종의 &quot;구성원 데이터&quot;이므로 다른 개체에서와 마찬가지로 상태가 한 호출에서 다른 호출로 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bfc5029b5667353a593e8232b61d516f6f5fa28" translate="yes" xml:space="preserve">
          <source>As the &lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;tutorial section on control flow&lt;/a&gt; says:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;제어 흐름에&lt;/a&gt; 대한 튜토리얼 섹션에서 다음과 같이 말합니다.</target>
        </trans-unit>
        <trans-unit id="8b63ee9af6651f22cd0d28d64f81656efa3a8b0b" translate="yes" xml:space="preserve">
          <source>As you can see, there &lt;em&gt;is&lt;/em&gt; a performance benefit when using immutable default arguments.  This can make a difference if it's a frequently called function or the default argument takes a long time to construct.  Also, bear in mind that Python isn't C.  In C you have constants that are pretty much free.  In Python you don't have this benefit.</source>
          <target state="translated">보시다시피 불변의 기본 인수를 사용하면 성능이 향상됩니다. 자주 호출되는 함수이거나 기본 인수를 구성하는 데 시간이 오래 걸리면 차이가 생길 수 있습니다. 또한 파이썬은 C가 아님을 명심하십시오. C에는 거의 무료 인 상수가 있습니다. 파이썬에서는이 이점이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0af2a822a9873fb57c1a705017e412da7cf6eae6" translate="yes" xml:space="preserve">
          <source>At any time, if the caller doesn't tell us what &lt;code&gt;a&lt;/code&gt; is, we reuse &lt;code&gt;pavlo&lt;/code&gt;.</source>
          <target state="translated">언제든지 발신자가 무엇인지 알려주지 않으면 &lt;code&gt;pavlo&lt;/code&gt; 를 재사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="8a9041c4d4930adfbd1e5a18d381ab82f682a692" translate="yes" xml:space="preserve">
          <source>Baczek made an interesting example. Together with most of your comments and Utaal's in particular, I elaborated further:</source>
          <target state="translated">Baczek이 흥미로운 예를 만들었습니다. 귀하의 의견과 Utaal의 의견과 함께, 나는 더 자세히 설명했습니다.</target>
        </trans-unit>
        <trans-unit id="80f28b6534c5364d872c03c837c8604f92ca736d" translate="yes" xml:space="preserve">
          <source>But this is why the usual instruction to new users is to create their default arguments like this instead:</source>
          <target state="translated">그러나 이것이 새로운 사용자에게 일반적인 지침이 대신 다음과 같은 기본 인수를 작성하는 이유입니다.</target>
        </trans-unit>
        <trans-unit id="ec8e7d1b53f4a45c292a101f3cc7d8154605e8fd" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;foo()&lt;/code&gt; again modifies &lt;code&gt;pavlo&lt;/code&gt; again:</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; 다시 호출하면 &lt;code&gt;pavlo&lt;/code&gt; 가 다시 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="7f12be39dc6279d3fabca7bbf354112e20d8c45e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;foo&lt;/code&gt; without overriding a default uses that default's value from &lt;code&gt;foo.func_defs&lt;/code&gt;. In this case, &lt;code&gt;foo.func_defs[0]&lt;/code&gt; is used for &lt;code&gt;a&lt;/code&gt; within function object's code scope. Changes to &lt;code&gt;a&lt;/code&gt; change &lt;code&gt;foo.func_defs[0]&lt;/code&gt;, which is part of the &lt;code&gt;foo&lt;/code&gt; object and persists between execution of the code in &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">기본값을 재정의하지 않고 &lt;code&gt;foo&lt;/code&gt; 를 호출하면 &lt;code&gt;foo.func_defs&lt;/code&gt; 의 기본값이 사용됩니다. 이 경우 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; 은 함수 객체의 코드 범위 내에서 사용됩니다. 변경 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; 변경됩니다 &lt;code&gt;a&lt;/code&gt; 이는 &lt;code&gt;foo&lt;/code&gt; 객체의 일부이며 foo 의 코드 실행 사이에 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2bbb1f97b956cffee0de7b85c6ac5416fc49a2bd" translate="yes" xml:space="preserve">
          <source>Compare this:</source>
          <target state="translated">이것을 비교하십시오 :</target>
        </trans-unit>
        <trans-unit id="d0b35f2e80cf4078de3821051d01800d2a02ba30" translate="yes" xml:space="preserve">
          <source>Conclusion:</source>
          <target state="translated">Conclusion:</target>
        </trans-unit>
        <trans-unit id="89101438b832bbb4fe2957ecf228b15803627679" translate="yes" xml:space="preserve">
          <source>Consider the code:</source>
          <target state="translated">코드를 고려하십시오 :</target>
        </trans-unit>
        <trans-unit id="50ce20ee2ced0781e4776bbf85a113d06f364543" translate="yes" xml:space="preserve">
          <source>Consistency already says &quot;at definition&quot;: everything else of &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; is best evaluated at definition as well. Delaying parts of it would be the astonishing choice.</source>
          <target state="translated">일관성은 이미 &quot;정의&quot;로 표시됩니다. &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; 이외의 모든 것은 정의에서도 가장 잘 평가됩니다. 그것의 일부를 연기하는 것은 놀라운 선택이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="5e80e76fecb25c751bc0072a050074d6bf8b3a02" translate="yes" xml:space="preserve">
          <source>Default arguments get evaluated at the time the function is compiled into a function object. When used by the function, multiple times by that function, they are and remain the same object.</source>
          <target state="translated">기본 인수는 함수가 함수 객체로 컴파일 될 때 평가됩니다. 함수가 해당 함수에 의해 여러 번 사용될 때 그것들은 같은 객체로 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a13adb02282a5b13ea712ef898af3b40b3c9925" translate="yes" xml:space="preserve">
          <source>Defining a function affects two scopes: the defining scope &lt;em&gt;containing&lt;/em&gt; the function, and the execution  scope &lt;em&gt;contained by&lt;/em&gt; the function. While it is pretty clear how blocks map to scopes, the question is where &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; belongs to:</source>
          <target state="translated">함수를 정의하면 함수를 &lt;em&gt;포함&lt;/em&gt; 하는 정의 범위와 함수가 &lt;em&gt;포함&lt;/em&gt; 하는 실행 범위의 두 가지 범위에 영향을줍니다. 블록이 범위에 어떻게 매핑되는지는 분명하지만 문제는 &lt;code&gt;def &amp;lt;name&amp;gt;(&amp;lt;args=defaults&amp;gt;):&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="722360c4795e6584aab950e4f9ab28bf53d453fe" translate="yes" xml:space="preserve">
          <source>Demonstration</source>
          <target state="translated">Demonstration</target>
        </trans-unit>
        <trans-unit id="0cf2dad6fd4f2a353fd61dd22952442419c00063" translate="yes" xml:space="preserve">
          <source>Does this violate the principle of &quot;Least Astonishment&quot;?</source>
          <target state="translated">이것이 &quot;최소한의 놀라움&quot;의 원칙을 위반합니까?</target>
        </trans-unit>
        <trans-unit id="87ae29dc1cc2a0f0b1d8ff4a04b54a9e84f78784" translate="yes" xml:space="preserve">
          <source>Doing the binding inside the function would mean that &lt;code&gt;x&lt;/code&gt; is effectively bound to the specified default when the function is called, not defined, something that would present a deep flaw: the &lt;code&gt;def&lt;/code&gt; line would be &quot;hybrid&quot; in the sense that part of the binding (of the function object) would happen at definition, and part (assignment of default parameters) at function invocation time.</source>
          <target state="translated">함수 내에서 바인딩을 수행하면 함수가 호출 될 때 &lt;code&gt;x&lt;/code&gt; 가 지정된 기본값에 효과적으로 바인딩된다는 것을 의미합니다. 정의되지 않은 무언가가 있습니다 &lt;code&gt;def&lt;/code&gt; 라인은 바인딩의 일부라는 의미에서 &quot;하이브리드&quot;가됩니다. 함수 함수의 정의는 정의에서 발생하고 함수 호출시 부분 (기본 매개 변수 할당)이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a1bc1de19c4470f909f862dada03b7e62dff2905" translate="yes" xml:space="preserve">
          <source>Each button can hold a distinct callback function which will display different value of &lt;code&gt;i&lt;/code&gt;. I can provide an example to show this:</source>
          <target state="translated">각 버튼에는 고유 한 콜백 기능이있어 서로 다른 &lt;code&gt;i&lt;/code&gt; 값을 표시 할 수 있습니다. 이것을 보여주는 예제를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3535364419d36fc620e4f5493d86ed8c6d64572c" translate="yes" xml:space="preserve">
          <source>Equivalent code:</source>
          <target state="translated">동등한 코드 :</target>
        </trans-unit>
        <trans-unit id="ff956d2a192938cf9d92d4c6a19f3ae8b72325fa" translate="yes" xml:space="preserve">
          <source>Every other answer explains why this is actually a nice and desired behavior, or why you shouldn't be needing this anyway. Mine is for those stubborn ones who want to exercise their right to bend the language to their will, not the other way around.</source>
          <target state="translated">다른 모든 대답은 왜 이것이 실제로 훌륭하고 바람직한 행동인지 또는 왜 이것이 필요하지 않은지를 설명합니다. 광산은 다른 방향이 아니라 자신의 의지에 따라 언어를 구부릴 권리를 행사하려는 고집이있는 사람들을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="0dd24b3cfa0f1397c657fd1c280dfe16bb9e3f42" translate="yes" xml:space="preserve">
          <source>Example problem for &lt;a href=&quot;https://stackoverflow.com/q/13484107/448474&quot;&gt;a similar SO question&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/q/13484107/448474&quot;&gt;비슷한 SO 질문에&lt;/a&gt; 대한 예제 문제</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="bb7c7223c0f7cca03529ae9f865e01923e18d2e1" translate="yes" xml:space="preserve">
          <source>From the above explanations, we can see that the &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;effbot&lt;/a&gt; webpage recommended in the accepted answer failed to give a relevant answer to this question. What is more, I think a point in the effbot webpage is wrong. I think the code regarding the UI.Button is correct:</source>
          <target state="translated">위의 설명에서 허용 된 답변에서 권장되는 &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;effbot&lt;/a&gt; 웹 페이지가이 질문에 대한 관련 답변을 제공하지 못했음을 알 수 있습니다. 또한 effbot 웹 페이지의 요점이 잘못되었다고 생각합니다. UI.Button 관련 코드가 정확하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="ffce6790c5edcbed68ecf56b4ebcce15bf2962a7" translate="yes" xml:space="preserve">
          <source>Function After Execution:</source>
          <target state="translated">실행 후 기능 :</target>
        </trans-unit>
        <trans-unit id="c6a884852d8c2a2883d38ae384496603d3a89ca1" translate="yes" xml:space="preserve">
          <source>Function Before Execution:</source>
          <target state="translated">실행 전 기능 :</target>
        </trans-unit>
        <trans-unit id="31a489ea01d856da46704976b42a3727c3bf5489" translate="yes" xml:space="preserve">
          <source>Functions are objects (explained well in the accepted answer).</source>
          <target state="translated">함수는 객체입니다 (허용 된 답변에 잘 설명되어 있음).</target>
        </trans-unit>
        <trans-unit id="33152c3a458131f199d601848f2ff938e88b23ff" translate="yes" xml:space="preserve">
          <source>Given a simple little function &lt;code&gt;func&lt;/code&gt; defined as:</source>
          <target state="translated">다음과 같이 정의 된 간단한 작은 함수 &lt;code&gt;func&lt;/code&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc7ed69775b531605c40861499142c0c9436b2e1" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;foo&lt;/code&gt; is an object and &lt;code&gt;a&lt;/code&gt; is an attribute of &lt;code&gt;foo&lt;/code&gt; (available at &lt;code&gt;foo.func_defs[0]&lt;/code&gt;). Since &lt;code&gt;a&lt;/code&gt; is a list, &lt;code&gt;a&lt;/code&gt; is mutable and is thus a read-write attribute of &lt;code&gt;foo&lt;/code&gt;. It is initialized to the empty list as specified by the signature when the function is instantiated, and is available for reading and writing as long as the function object exists.</source>
          <target state="translated">여기서 &lt;code&gt;foo&lt;/code&gt; 는 객체이고 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;foo&lt;/code&gt; 의 속성입니다 ( &lt;code&gt;foo.func_defs[0]&lt;/code&gt; 에서 사용 가능). &lt;code&gt;a&lt;/code&gt; 는 목록이므로 &lt;code&gt;a&lt;/code&gt; 는 변경 가능하므로 &lt;code&gt;foo&lt;/code&gt; 의 읽기 / 쓰기 속성입니다. 함수가 인스턴스화 될 때 서명으로 지정된대로 빈 목록으로 초기화되며 함수 오브젝트가 존재하는 한 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a60b329ec4b9d85ee4941270916f4f4532974b74" translate="yes" xml:space="preserve">
          <source>Here's a demonstration - you can verify that they are the same object each time they are referenced by</source>
          <target state="translated">다음은 데모입니다. 참조 할 때마다 동일한 객체인지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fd4504fd06148ba79eed7136bc3c11e43b9b3ff" translate="yes" xml:space="preserve">
          <source>Hopefully it's enough to show that not executing the default argument expressions at the execution time of the &lt;code&gt;def&lt;/code&gt; statement isn't easy or doesn't make sense, or both.</source>
          <target state="translated">다행히도 &lt;code&gt;def&lt;/code&gt; 문의 실행 시간에 기본 인수 표현식을 실행하지 않는 것이 쉽지 않거나 합리적이지 않다는 것을 보여주는 것으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="efcda094ecf8e11cea988762da8f1af71d231058" translate="yes" xml:space="preserve">
          <source>However, supposed later on in the code, I do something like</source>
          <target state="translated">그러나 코드에서 나중에 가정하면 다음과 같은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b3f69934c5bc363d742e1cab32463a9509580910" translate="yes" xml:space="preserve">
          <source>However, we've lost the ability to introspect, and see what the default arguments &lt;em&gt;are&lt;/em&gt;.  Because the objects haven't been constructed, we can't ever get hold of them without actually calling the function.  The best we could do is to store off the source code and return that as a string.</source>
          <target state="translated">그러나 우리는 내성을 검사하고 기본 인수 &lt;em&gt;가&lt;/em&gt; 무엇인지 확인하는 기능을 잃었습니다. 객체가 생성되지 않았으므로 실제로 함수를 호출하지 않으면 객체를 잡을 수 없습니다. 우리가 할 수있는 최선의 방법은 소스 코드를 저장하고 문자열로 반환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="62218df64348dca379d0be7d12cf753886ac8753" translate="yes" xml:space="preserve">
          <source>I agree it's a gotcha when you try to use default constructors, though.</source>
          <target state="translated">그래도 기본 생성자를 사용하려고 할 때 문제가 있음에 동의합니다.</target>
        </trans-unit>
        <trans-unit id="666a646463dc2675694b853c3a8d9d31ebba0462" translate="yes" xml:space="preserve">
          <source>I am going to demonstrate an alternative structure to pass a default list value to a function (it works equally well with dictionaries).</source>
          <target state="translated">기본 목록 값을 함수에 전달하는 대체 구조를 보여 드리겠습니다 (사전과 동일하게 작동합니다).</target>
        </trans-unit>
        <trans-unit id="79228cdbb3c7bc21ef5719f719a1a0dd6dfbf36b" translate="yes" xml:space="preserve">
          <source>I doubt the experienced behavior has a practical use (who really used static variables in C, without breeding bugs ?)</source>
          <target state="translated">경험이 풍부한 행동에 실용적인 용도가 있다고 의심합니다 (누가 버그없이 C에서 정적 변수를 실제로 사용 했습니까?)</target>
        </trans-unit>
        <trans-unit id="43c16dd324ef24fec2c80514d01a8fbc2f28b9ba" translate="yes" xml:space="preserve">
          <source>I found it very clear, and I really suggest reading it for a better knowledge of how function objects work.</source>
          <target state="translated">나는 그것이 매우 분명하다는 것을 알았고 함수 객체가 어떻게 작동하는지 더 잘 알기 위해 그것을 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="e438a0bb860a536fec364c3e57d8144f3738861a" translate="yes" xml:space="preserve">
          <source>I know nothing about the Python interpreter inner workings (and I'm not an expert in compilers and interpreters either) so don't blame me if I propose anything unsensible or impossible.</source>
          <target state="translated">나는 파이썬 인터프리터 내부 작업에 대해 아무것도 알지 못하며 (컴파일러 및 인터프리터도 전문가가 아닙니다) 무의미하거나 불가능한 것을 제안하더라도 나를 비난하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="71d7286361ceb622e718e696e33275d64365bcc6" translate="yes" xml:space="preserve">
          <source>I know, I know: that's a closure. Alternatively Python might provide a keyword to force definition-time binding:</source>
          <target state="translated">나는 알고있다 : 그것은 폐쇄이다. 또는 파이썬은 정의 시간 바인딩을 강제하는 키워드를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33854cd2f920283abdfe15942535e15a55a4bbc1" translate="yes" xml:space="preserve">
          <source>I personally like Python's current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible.</source>
          <target state="translated">필자는 개인적으로 파이썬의 현재 접근 방식을 좋아합니다. 기본 함수 인수는 함수가 정의되고 해당 객체가 항상 기본값 일 때 평가됩니다. 나는 그들이 빈 목록을 사용하여 특별한 경우를 가질 수 있다고 생각하지만, 그런 종류의 특별한 케이스는 더 이상 놀랍게 만들지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="653d0fdb648a0e875a98321cd116616aaa059e3d" translate="yes" xml:space="preserve">
          <source>I sometimes exploit this behavior as an alternative to the following pattern:</source>
          <target state="translated">때때로이 패턴을 다음 패턴의 대안으로 활용합니다.</target>
        </trans-unit>
        <trans-unit id="1136692ed919e61fb64464e3c7faa84bec1902d1" translate="yes" xml:space="preserve">
          <source>I think the answer to this question lies in how python pass data to parameter (pass by value or by reference), not mutability or how python handle the &quot;def&quot; statement.</source>
          <target state="translated">이 질문에 대한 대답은 파이썬이 데이터를 매개 변수에 전달하는 방법 (값 또는 참조로 전달), 가변성이 아닌 방법 또는 파이썬이 &quot;def&quot;문을 처리하는 방법에 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="344b69c74ad5e09938fa343f9bd784e609ba3f79" translate="yes" xml:space="preserve">
          <source>I used to think that creating the objects at runtime would be the better approach.  I'm less certain now, since you do lose some useful features, though it may be worth it regardless simply to prevent newbie confusion.  The disadvantages of doing so are:</source>
          <target state="translated">나는 런타임에 객체를 만드는 것이 더 나은 방법이라고 생각했습니다. 몇 가지 유용한 기능을 잃어 버렸으므로 초보자는 혼란스럽지 않습니다. 그렇게하는 단점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f45c52b12ce7f1ce19a9035ae4c48dd9daa005c0" translate="yes" xml:space="preserve">
          <source>I'll give you a hint.  Here's the disassembly (see &lt;a href=&quot;http://docs.python.org/library/dis.html&quot;&gt;http://docs.python.org/library/dis.html&lt;/a&gt;):</source>
          <target state="translated">힌트를 드리겠습니다. 분해는 다음과 같습니다 ( &lt;a href=&quot;http://docs.python.org/library/dis.html&quot;&gt;http://docs.python.org/library/dis.html 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="63b9797c54d1f5b22108348202db1c0d9f27b5eb" translate="yes" xml:space="preserve">
          <source>I'm &lt;em&gt;really&lt;/em&gt; surprised no one has performed the insightful introspection offered by Python (&lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; apply) on callables.</source>
          <target state="translated">나는 아무도 callables에 대해 파이썬 ( &lt;code&gt;2&lt;/code&gt; 및 &lt;code&gt;3&lt;/code&gt; 적용)이 제공하는 통찰력있는 내성 검사를 수행하지 않은 것에 놀랐습니다.</target>
        </trans-unit>
        <trans-unit id="d560ac161f04d984906ccae5894dd8e5c74ba7d6" translate="yes" xml:space="preserve">
          <source>I'm gonna give you what I see as a useful example.</source>
          <target state="translated">유용한 예라고 생각하는 것을 알려 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="0ab4a274949e60b1dc8d810f1b8b6f0326e083c2" translate="yes" xml:space="preserve">
          <source>I've used this for instantiating client classes that access external resources, and also for creating dicts or lists for memoization.</source>
          <target state="translated">외부 리소스에 액세스하는 클라이언트 클래스를 인스턴스화하고 메모를위한 dicts 또는 목록을 만들 때이 기능을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="d4a17f0810bff8f4684352651e72c003f9d91265" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;pavlo&lt;/code&gt; is mutable (modifiable), and &lt;code&gt;foo&lt;/code&gt; ends up modifying it, an effect we notice the next time &lt;code&gt;foo&lt;/code&gt; is called without specifying &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pavlo&lt;/code&gt; 가 변경 가능하고 (수정 가능) &lt;code&gt;foo&lt;/code&gt; 가이 를 수정하면 다음에 &lt;code&gt;foo&lt;/code&gt; 를 지정하지 않고 호출 할 때 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="2fde0c1e8b0aff298d01bf5aa7a719c471660837" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;singleton&lt;/code&gt; is only used by &lt;code&gt;use_singleton&lt;/code&gt;, I like the following pattern as a replacement:</source>
          <target state="translated">&lt;code&gt;singleton&lt;/code&gt; 이 &lt;code&gt;use_singleton&lt;/code&gt; 만 사용하는 경우 다음 패턴을 대체로 좋아합니다.</target>
        </trans-unit>
        <trans-unit id="12b09ce5fbf5f05e7151c2f7f01217b353055234" translate="yes" xml:space="preserve">
          <source>If call-time evaluation is used, then the expensive function is called every time your function is used without an argument.  You'd either pay an expensive price on each call, or need to manually cache the value externally, polluting your namespace and adding verbosity.</source>
          <target state="translated">호출 시간 평가를 사용하는 경우 인수없이 함수를 사용할 때마다 고가의 함수가 호출됩니다. 각 호출에 대해 비싼 가격을 지불하거나 외부 적으로 값을 수동으로 캐시하여 네임 스페이스를 오염시키고 자세한 정보를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="07abc281d43c1a8d21b4d3e16a4f89b6450862f6" translate="yes" xml:space="preserve">
          <source>If we execute &lt;code&gt;x[7]()&lt;/code&gt; we'll get 7 as expected, and &lt;code&gt;x[9]()&lt;/code&gt; will gives 9, another value of &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x[7]()&lt;/code&gt; 을 실행하면 예상대로 7이되고 &lt;code&gt;x[9]()&lt;/code&gt; 는 또 다른 &lt;code&gt;i&lt;/code&gt; 값인 9를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5e5d0faf4767c71322e96d58c89f44e2f7d7004b" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t want the default to be shared between subsequent calls,
  you can write the function like this instead:</source>
          <target state="translated">후속 호출간에 기본값을 공유하지 않으려면 대신 다음과 같이 함수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a78835080b9cc304e7940760ebe5a74f9feb7089" translate="yes" xml:space="preserve">
          <source>If you need to destructively manipulate a local temporary in the course of computing something, and you need to start your manipulation from an argument value, you need to make a copy.</source>
          <target state="translated">무언가를 계산하는 과정에서 로컬 임시 작업을 파괴적으로 조작해야하고 인수 값에서 조작을 시작해야하는 경우 사본을 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="ffce4f7ff1a5649ba9873493748437dec4a51845" translate="yes" xml:space="preserve">
          <source>In any case, Effbot has a very nice explanation of the reasons for this behavior in &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;Default Parameter Values in Python&lt;/a&gt;.</source>
          <target state="translated">어쨌든 Effbot은 &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;Python의 기본 매개 변수 값&lt;/a&gt; 에서이 동작의 이유에 대해 아주 잘 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bbd472fc6429abfdafc9add5359fa997a6a79049" translate="yes" xml:space="preserve">
          <source>In other words, instead of evaluating default parameters, why not store each of them, and evaluate them when the function is called?</source>
          <target state="translated">다시 말해, 기본 매개 변수를 평가하는 대신 각 매개 변수를 저장하지 말고 함수가 호출 될 때 평가하는 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="44af44eea85fed48a31ed0183c38ed921ac1aabb" translate="yes" xml:space="preserve">
          <source>Input parameters objects shouldn't be modified in place (mutated) nor they should not be binded into an object returned by the function. (If we prefere programming without side effects which is strongly recommended. see &lt;a href=&quot;http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;Wiki about &quot;side effect&quot;&lt;/a&gt; (The first two paragraphs are relevent in this context.)
.)</source>
          <target state="translated">입력 매개 변수 객체는 수정하거나 변경하지 말아야하며 함수가 반환 한 객체에 바인딩해서는 안됩니다. (부작용이없는 프로그래밍을 선호하는 경우 강력히 권장됩니다. &lt;a href=&quot;http://en.wikipedia.org/wiki/Side_effect_%28computer_science%29&quot;&gt;&quot;부작용&quot;에 대한 위키를&lt;/a&gt; 참조하십시오 (이 문맥에서 처음 두 단락은 관련됨).)</target>
        </trans-unit>
        <trans-unit id="f428f84105fcce031afe75598a91587f547827e4" translate="yes" xml:space="preserve">
          <source>It comes simply from the fact that functions in Python are first-class objects, and not only a piece of code.</source>
          <target state="translated">파이썬의 함수는 코드가 아니라 일류 객체라는 사실에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="8d35c5155e3a7198376d876ba2ac22709cf724ee" translate="yes" xml:space="preserve">
          <source>It is a confusing feature and it is unfortunate in Python.</source>
          <target state="translated">혼란스러운 기능이며 파이썬에서는 불행합니다.</target>
        </trans-unit>
        <trans-unit id="2d1e31d0ad97904bac773140d97936823786bfd4" translate="yes" xml:space="preserve">
          <source>It may be true that switching horses in midstream here would be asking for significant breakage, and that there could be more problems created by changing Python to intuitively handle Stefano's opening snippet. And it may be true that someone who knew Python internals well could explain a minefield of consequences. &lt;em&gt;However,&lt;/em&gt;</source>
          <target state="translated">여기서 미드 스트림에서 말을 바꾸는 것은 상당한 파손을 요구할 것이며, 스테파노의 오프닝 스 니펫을 직관적으로 처리하기 위해 파이썬을 변경함으로써 더 많은 문제가 발생할 수 있습니다. 그리고 파이썬 내부를 잘 아는 사람이 결과의 지뢰밭을 설명 할 수 있다는 것이 사실 일 수 있습니다. &lt;em&gt;하나,&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f7b0650553f1d03b5617ea73a2e594063dbeff1b" translate="yes" xml:space="preserve">
          <source>It may be true that:</source>
          <target state="translated">다음이 사실 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c88ae6b372096f323f1ae38ef63c959269132a80" translate="yes" xml:space="preserve">
          <source>It shouldn't be neither saved in any &lt;em&gt;public&lt;/em&gt; attribute of an instance returned by this function. (Assuming that &lt;em&gt;private&lt;/em&gt; attributes of instance should not be modified from outside of this class or subclasses by convention. i.e. &lt;code&gt;_var1&lt;/code&gt; is a private attribute )</source>
          <target state="translated">이 함수가 반환 한 인스턴스의 &lt;em&gt;public&lt;/em&gt; 속성에 저장해서는 안됩니다. (인스턴스의 &lt;em&gt;프라이빗&lt;/em&gt; 속성을 규칙에 &lt;code&gt;_var1&lt;/code&gt; 클래스 또는 서브 클래스 외부에서 수정해서는 안된다고 가정합니다. 즉, _var1 은 프라이빗 속성입니다)</target>
        </trans-unit>
        <trans-unit id="a1d3a576ba48952d86d8cfdfe398ef2bddea704e" translate="yes" xml:space="preserve">
          <source>It's a performance optimization.  As a result of this functionality, which of these two function calls do you think is faster?</source>
          <target state="translated">성능 최적화입니다. 이 기능의 결과로이 두 함수 호출 중 어느 것이 더 빠르다고 생각합니까?</target>
        </trans-unit>
        <trans-unit id="0359bac5a1c47bf095f12d4add2a3b1b5b445f4a" translate="yes" xml:space="preserve">
          <source>It's important to note that the above solution breaks if you try to use keyword args, like so:</source>
          <target state="translated">다음과 같이 키워드 인수를 사용하려고하면 위의 솔루션이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6c89d685ac19d7565519a44bbc4a6d593564a24" translate="yes" xml:space="preserve">
          <source>It's just &quot;How It Works&quot;, and making it work differently in the function case would probably be complicated, and in the class case likely impossible, or at least slow down object instantiation a lot, as you would have to keep the class code around and execute it when objects are created.</source>
          <target state="translated">그것은 단지 &quot;어떻게 작동 하는가&quot;일 뿐이며, 함수 케이스에서 다르게 작동하게 만드는 것은 아마도 복잡 할 것이고 클래스 케이스에서는 불가능할 수도 있고 적어도 클래스 인스턴스화를 유지해야하기 때문에 객체 인스턴스화를 많이 느리게 할 것입니다 객체가 생성되면 실행합니다.</target>
        </trans-unit>
        <trans-unit id="fd310ea6b1cae2a6a063f0bd5d873b8e8d185946" translate="yes" xml:space="preserve">
          <source>Just change the function to be:</source>
          <target state="translated">기능을 다음과 같이 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="7da4eaf92a58f20a9c68b073a49820f4346f33e5" translate="yes" xml:space="preserve">
          <source>Let's now execute this function:</source>
          <target state="translated">이제이 함수를 실행 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="fd6ffcde729e6f54a9565146d7555da45d90700c" translate="yes" xml:space="preserve">
          <source>Look back to the original example and consider the above points:</source>
          <target state="translated">원래 예를 되돌아보고 위의 사항을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="7d52014db1eb1bc10080d5b3576313f9f6997662" translate="yes" xml:space="preserve">
          <source>Many builtin mutable types have a copy method like &lt;code&gt;some_dict.copy()&lt;/code&gt; or &lt;code&gt;some_set.copy()&lt;/code&gt; or can be copied easy like &lt;code&gt;somelist[:]&lt;/code&gt; or &lt;code&gt;list(some_list)&lt;/code&gt;. Every object can be also copied by &lt;code&gt;copy.copy(any_object)&lt;/code&gt; or more thorough by &lt;code&gt;copy.deepcopy()&lt;/code&gt; (the latter useful if the mutable object is composed from mutable objects). Some objects are fundamentally based on side effects like &quot;file&quot; object and can not be meaningfully reproduced by copy. &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm&quot;&gt;copying&lt;/a&gt;</source>
          <target state="translated">많은 내장 변경 가능 유형에는 &lt;code&gt;some_dict.copy()&lt;/code&gt; 또는 &lt;code&gt;some_set.copy()&lt;/code&gt; 와 같은 복사 방법이 있거나 &lt;code&gt;somelist[:]&lt;/code&gt; 또는 &lt;code&gt;list(some_list)&lt;/code&gt; 와 같이 쉽게 복사 할 수 있습니다. 모든 객체는 &lt;code&gt;copy.copy(any_object)&lt;/code&gt; 복사하거나 &lt;code&gt;copy.deepcopy()&lt;/code&gt; 더 철저히 복사 할 수 있습니다 (후자는 가변 객체가 가변 객체로 구성된 경우 유용합니다). 일부 객체는 기본적으로 &quot;파일&quot;객체와 같은 부작용을 기반으로하며 복사로 의미있게 재현 할 수 없습니다. &lt;a href=&quot;http://effbot.org/pyfaq/how-do-i-copy-an-object-in-python.htm&quot;&gt;사자&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e23f5cbc0bbb2cbb8b27c449a4bcd8e9fbb38b2b" translate="yes" xml:space="preserve">
          <source>No default values in sight in this code, but you get exactly the same problem.</source>
          <target state="translated">이 코드에는 기본값이 없지만 정확히 같은 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9b42c390ec8fb15d988160f4dd8c2a52791b6d6" translate="yes" xml:space="preserve">
          <source>Now let's redefine our function using this decorator:</source>
          <target state="translated">이제이 데코레이터를 사용하여 함수를 재정의 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="b7e59f92481e8e7835898fa1c85ba3a27d892126" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;pavlo&lt;/code&gt; is [5].</source>
          <target state="translated">이제 &lt;code&gt;pavlo&lt;/code&gt; 는 [5]입니다.</target>
        </trans-unit>
        <trans-unit id="362ccf94780188762e961bb582f31f3d92a8d7ee" translate="yes" xml:space="preserve">
          <source>Now, compare this to the example from the documentation on &lt;a href=&quot;http://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;emulating the default argument behavior of other languages&lt;/a&gt;, such that the function signature defaults are used every time the function is executed:</source>
          <target state="translated">이제 이것을 &lt;a href=&quot;http://docs.python.org/tutorial/controlflow.html#default-argument-values&quot;&gt;다른 언어의 기본 인수 동작 에뮬레이션에&lt;/a&gt; 대한 문서의 예제와 비교하여 함수가 실행될 때마다 함수 서명 기본값이 사용되도록하십시오.</target>
        </trans-unit>
        <trans-unit id="64acff4f47942d13d4f208bda7e869e11d893a33" translate="yes" xml:space="preserve">
          <source>Now, does my map use the value of the &lt;code&gt;StringBuffer&lt;/code&gt; key when it was placed into the map, or does it store the key by reference?  Either way, someone is astonished; either the person who tried to get the object out of the &lt;code&gt;Map&lt;/code&gt; using a value identical to the one they put it in with, or the person who can't seem to retrieve their object even though the key they're using is literally the same object that was used to put it into the map (this is actually why Python doesn't allow its mutable built-in data types to be used as dictionary keys).</source>
          <target state="translated">자, 내 맵은 &lt;code&gt;StringBuffer&lt;/code&gt; 키가 맵에 배치되었을 때 값을 사용합니까, 아니면 참조로 키를 저장합니까? 어느 쪽이든, 누군가는 놀랐습니다. &lt;code&gt;Map&lt;/code&gt; 넣은 값과 동일한 값을 사용하여 맵 에서 오브젝트를 가져 오려고 시도한 사람 또는 사용중인 키가 문자 그대로 동일하더라도 오브젝트를 검색 할 수없는 사람 맵에 넣는 데 사용 된 객체 (실제로 파이썬은 가변 내장 데이터 유형을 사전 키로 사용할 수없는 이유입니다).</target>
        </trans-unit>
        <trans-unit id="ca1782989bcd41936515ff547e98eb21e1c24f56" translate="yes" xml:space="preserve">
          <source>Now, let's see those &lt;code&gt;__defaults__&lt;/code&gt; again:</source>
          <target state="translated">이제 &lt;code&gt;__defaults__&lt;/code&gt; 를 다시 봅시다 :</target>
        </trans-unit>
        <trans-unit id="03060fd5df0aea733c344b9b8691c947fcb3b65a" translate="yes" xml:space="preserve">
          <source>Now, suppose the behaviour of defaults could be changed so that this is the equivalent of:</source>
          <target state="translated">이제 기본 동작이 다음과 같도록 변경 될 수 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="c8b8bb4b9ae89c0e3c42072a31a62c115adca126" translate="yes" xml:space="preserve">
          <source>Now, when to evaluate &lt;code&gt;default&lt;/code&gt;?</source>
          <target state="translated">이제 언제 &lt;code&gt;default&lt;/code&gt; 을 평가해야합니까?</target>
        </trans-unit>
        <trans-unit id="2d80698d75eb09b54cff119780e3f91af2942726" translate="yes" xml:space="preserve">
          <source>O.k, so an empty list as the single entry in &lt;code&gt;__defaults__&lt;/code&gt;, just as expected.</source>
          <target state="translated">좋아, 예상대로 &lt;code&gt;__defaults__&lt;/code&gt; 의 단일 항목으로 빈 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ee84d967071869b5d4f78c07c4174525b7a125c" translate="yes" xml:space="preserve">
          <source>One answer is probably right there--it would effectively turn every function with default parameters into a closure.  Even if it's all hidden away in the interpreter and not a full-blown closure, the data's got to be stored somewhere.  It'd be slower and use more memory.</source>
          <target state="translated">한 가지 대답은 아마도 거기에 있습니다. 기본 매개 변수가있는 모든 함수를 클로저로 효과적으로 전환합니다. 인터프리터에 숨겨져 있고 완전히 닫히지 않더라도 데이터는 어딘가에 저장되어야합니다. 속도가 느리고 더 많은 메모리를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="11b18ef18f03165cd782bc4f836d003ad9d95019" translate="yes" xml:space="preserve">
          <source>Only if the side effect on the actual parameter is required but unwanted on the default parameter then the useful solution is &lt;code&gt;def ...(var1=None):&lt;/code&gt;&lt;code&gt;if var1 is None:&lt;/code&gt;&lt;code&gt;var1 = []&lt;/code&gt;&lt;a href=&quot;http://effbot.org/zone/default-values.htm#what-to-do-instead&quot;&gt;More..&lt;/a&gt;</source>
          <target state="translated">실제 매개 변수에 대한 부작용이 필요하지만 기본 매개 변수에서 원하지 않는 경우에만 유용한 해결책은 &lt;code&gt;def ...(var1=None):&lt;/code&gt; &lt;code&gt;if var1 is None:&lt;/code&gt; &lt;code&gt;var1 = []&lt;/code&gt; &lt;a href=&quot;http://effbot.org/zone/default-values.htm#what-to-do-instead&quot;&gt;More ..&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="114258caa60ea3edd65afe4bbb8f1463ea7260f5" translate="yes" xml:space="preserve">
          <source>Per &lt;strong&gt;(1)&lt;/strong&gt;, &lt;strong&gt;&lt;em&gt;a new local variable also named &lt;code&gt;L&lt;/code&gt; is created in the local scope&lt;/em&gt;&lt;/strong&gt; and used for the remainder of the function call. &lt;code&gt;foo.func_defs[0]&lt;/code&gt; thus remains unchanged for future invocations of &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;(1)&lt;/strong&gt; 에 &lt;strong&gt;&lt;em&gt;따라 &lt;code&gt;L&lt;/code&gt; 이라는 이름의 새 로컬 변수가 로컬 범위에 만들어지고&lt;/em&gt;&lt;/strong&gt; 나머지 함수 호출에 사용됩니다. 따라서 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; 은 나중에 &lt;code&gt;foo&lt;/code&gt; 를 호출해도 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1d87aa1b1e7324f25c59d457e5df3e2ceb743377" translate="yes" xml:space="preserve">
          <source>Per Brett Slatkin's &quot;Effective Python: 59 Specific Ways to Write Better Python&quot;, &lt;em&gt;Item 20: Use &lt;code&gt;None&lt;/code&gt; and Docstrings to specify dynamic default arguments&lt;/em&gt; (p. 48)</source>
          <target state="translated">Brett Slatkin의 &quot;유효한 파이썬 : 더 나은 파이썬을 작성하는 59 가지 방법&quot;, &lt;em&gt;항목 20 : 동적 기본 인수를 지정하려면 &lt;code&gt;None&lt;/code&gt; 및 Docstrings를 사용하십시오&lt;/em&gt; (p. 48)</target>
        </trans-unit>
        <trans-unit id="edbbe1dd270001c9959fe3b6bfc520ed27fa81f3" translate="yes" xml:space="preserve">
          <source>Provided that python objects &lt;strong&gt;are mutable&lt;/strong&gt; I think that this should be taken into account when designing the default arguments stuff.
When you instantiate a list:</source>
          <target state="translated">파이썬 객체 &lt;strong&gt;가 변경 가능하다면&lt;/strong&gt; 기본 인수를 디자인 할 때 이것을 고려해야한다고 생각합니다. 목록을 인스턴스화 할 때 :</target>
        </trans-unit>
        <trans-unit id="e05c3327cf67fb602c3add427a88b4d544b75506" translate="yes" xml:space="preserve">
          <source>Python novices would expect this function to always return a list with only one element: &lt;code&gt;[5]&lt;/code&gt;. The result is instead very different, and very astonishing (for a novice):</source>
          <target state="translated">파이썬 초보자는이 함수가 항상 하나의 요소 ( &lt;code&gt;[5]&lt;/code&gt; ) 만있는 목록을 반환 할 것으로 기대합니다. 결과는 대신 매우 다르며 매우 초보자입니다.</target>
        </trans-unit>
        <trans-unit id="81f99a7ff268aeaf873fa4045929feaf18be7cd0" translate="yes" xml:space="preserve">
          <source>Python: The Mutable Default Argument</source>
          <target state="translated">파이썬 : 가변 기본 인수</target>
        </trans-unit>
        <trans-unit id="48fb53aa0f56fcdc44c27cdce6ee6b0ac6e04929" translate="yes" xml:space="preserve">
          <source>Since &lt;code&gt;parameter&lt;/code&gt; is a constant name, we can &quot;evaluate&quot; it at the same time as &lt;code&gt;def name&lt;/code&gt;. This also has the advantage it produces the function with a known signature as &lt;code&gt;name(parameter=...):&lt;/code&gt;, instead of a bare &lt;code&gt;name(...):&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;parameter&lt;/code&gt; 는 상수 이름이므로 &lt;code&gt;def name&lt;/code&gt; 과 동시에 &quot;평가&quot;할 수 있습니다. 또한 베어 &lt;code&gt;name(...):&lt;/code&gt; 대신 &lt;code&gt;name(parameter=...):&lt;/code&gt; 으로 알려진 서명을 가진 함수를 생성하는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5d182b67a7149475e28eef1bc9597d34d73b45e" translate="yes" xml:space="preserve">
          <source>Since I don't think this pattern is well known, I do put a short comment in to guard against future misunderstandings.</source>
          <target state="translated">나는이 패턴이 잘 알려져 있지 않다고 생각하기 때문에 미래의 오해를 막기 위해 짧은 의견을 제시합니다.</target>
        </trans-unit>
        <trans-unit id="1da4b14f89f2b2d481987a26be3a56b816db7930" translate="yes" xml:space="preserve">
          <source>Since the function body is executed anew each time, you always get a fresh new empty list if no argument was passed for &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">함수 본문은 매번 새로 실행되므로 a에 인수가 전달되지 않으면 항상 새로운 빈 목록이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="8219cc9987e068b594e6f9212eabecd380fc4b23" translate="yes" xml:space="preserve">
          <source>Since the list is bound to the function when the function object is compiled and instantiated, this:</source>
          <target state="translated">함수 객체가 컴파일되고 인스턴스화 될 때 목록이 함수에 바인딩되므로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="846d5d41860fc57cee6667664460f6fd3c443f37" translate="yes" xml:space="preserve">
          <source>So this is what you see (Remember, &lt;code&gt;pavlo&lt;/code&gt; is initialized to []):</source>
          <target state="translated">그래서 이것은 당신이 보는 것입니다 ( &lt;code&gt;pavlo&lt;/code&gt; 는 []로 초기화됩니다) :</target>
        </trans-unit>
        <trans-unit id="cc480e96946c5a4d81dbe64f85f0531baec48a48" translate="yes" xml:space="preserve">
          <source>So, &lt;code&gt;pavlo&lt;/code&gt; is still &lt;code&gt;[5, 5]&lt;/code&gt;.</source>
          <target state="translated">따라서 &lt;code&gt;pavlo&lt;/code&gt; 는 여전히 &lt;code&gt;[5, 5]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="135253f82ce516e45be9920a7c65b965b29a4cbe" translate="yes" xml:space="preserve">
          <source>So, let's do some introspection, a before and after to examine how the list gets expanded &lt;strong&gt;inside&lt;/strong&gt; the function object. I'm using &lt;code&gt;Python 3.x&lt;/code&gt; for this, for Python 2 the same applies (use &lt;code&gt;__defaults__&lt;/code&gt; or &lt;code&gt;func_defaults&lt;/code&gt; in Python 2; yes, two names for the same thing).</source>
          <target state="translated">이제 함수 객체 &lt;strong&gt;내&lt;/strong&gt; 에서 목록이 어떻게 확장되는지 조사하기 전과 후에 약간의 내부 검사를 해 봅시다. 나는 이것을 위해 &lt;code&gt;Python 3.x&lt;/code&gt; 를 사용하고 있습니다 &lt;code&gt;func_defaults&lt;/code&gt; 2의 경우도 마찬가지입니다 (Python 2에서는 &lt;code&gt;__defaults__&lt;/code&gt; 또는 func_defaults 를 사용하십시오; 예, 같은 이름은 두 개입니다).</target>
        </trans-unit>
        <trans-unit id="ac03b13d0df29e0d823d1733d67a60356a13e49c" translate="yes" xml:space="preserve">
          <source>So, there you have it, the reason why this &lt;em&gt;'flaw'&lt;/em&gt; happens, is because default arguments are part of the function object. There's nothing weird going on here, it's all just a bit surprising.</source>
          <target state="translated">따라서이 &lt;em&gt;'결함'이&lt;/em&gt; 발생하는 이유는 기본 인수가 함수 객체의 일부이기 때문입니다. 여기에는 이상한 일이 없습니다. 모두 조금 놀랍습니다.</target>
        </trans-unit>
        <trans-unit id="14b8aecd3aaaa33e35d9724dfec4e61ddcb14189" translate="yes" xml:space="preserve">
          <source>So:</source>
          <target state="translated">So:</target>
        </trans-unit>
        <trans-unit id="2ffd73eaa6f051202977e48c6c85a797b6fd5a12" translate="yes" xml:space="preserve">
          <source>Someone is using every language/library feature, and</source>
          <target state="translated">누군가가 모든 언어 / 라이브러리 기능을 사용하고 있으며</target>
        </trans-unit>
        <trans-unit id="d42bae2973e05a62b137b51620fea4d9b147edc0" translate="yes" xml:space="preserve">
          <source>Specifying &lt;code&gt;a&lt;/code&gt; when calling &lt;code&gt;foo()&lt;/code&gt; ensures &lt;code&gt;pavlo&lt;/code&gt; is not touched.</source>
          <target state="translated">&lt;code&gt;foo()&lt;/code&gt; 호출 할 때를 지정하면 &lt;code&gt;pavlo&lt;/code&gt; 가 건드리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f19d645e1fda82c64c713d7a7c9e1d69d1720d38" translate="yes" xml:space="preserve">
          <source>Suppose you have the following code</source>
          <target state="translated">다음 코드가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="2985042a12a99a3c98ea5fdbdde2134ab3ef8abf" translate="yes" xml:space="preserve">
          <source>Switching the behavior here would be ill-advised, but</source>
          <target state="translated">여기에서 동작을 전환하는 것은 좋지 않은 조언이지만</target>
        </trans-unit>
        <trans-unit id="eb8098887cd8190749f463f9cd047389241aa54c" translate="yes" xml:space="preserve">
          <source>TLDR: Define-time defaults are consistent and strictly more expressive.</source>
          <target state="translated">TLDR : 정의 시간 기본값은 일관되고 엄격하게 표현 적입니다.</target>
        </trans-unit>
        <trans-unit id="baee8029959dfcc9ec36a00cfc022b60ddd58256" translate="yes" xml:space="preserve">
          <source>Taking &lt;strong&gt;(1)&lt;/strong&gt; and &lt;strong&gt;(2)&lt;/strong&gt; into account, one can see why this accomplishes the the desired behavior:</source>
          <target state="translated">&lt;strong&gt;(1)&lt;/strong&gt; 과 &lt;strong&gt;(2)&lt;/strong&gt; 를 고려하면 이것이 원하는 동작을 달성하는 이유를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60e49eedb22450ed713b64f742443e241e6f5637" translate="yes" xml:space="preserve">
          <source>That is against the rules of functional programming, usually undesiderable and should be fixed both together.</source>
          <target state="translated">이는 함수형 프로그래밍 규칙에 위배되며 일반적으로 바람직하지 않으며 두 가지를 함께 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="6283984545c4460e3d117123b9917e356ce0cec9" translate="yes" xml:space="preserve">
          <source>That said it should feature prominently in any good Python tutorial. Because as you mention, everyone runs into this problem sooner or later.</source>
          <target state="translated">그것은 훌륭한 파이썬 튜토리얼에서 두드러지게 등장해야한다고 말했습니다. 언급했듯이 모든 사람이 조만간이 문제에 부딪칩니다.</target>
        </trans-unit>
        <trans-unit id="4742191818ba22d12f4df985ed0fa6ab565b9a93" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;def name&lt;/code&gt; part &lt;strong&gt;must&lt;/strong&gt; evaluate in the defining scope - we want &lt;code&gt;name&lt;/code&gt; to be available there, after all. Evaluating the function only inside itself would make it inaccessible.</source>
          <target state="translated">&lt;code&gt;def name&lt;/code&gt; 부분 &lt;strong&gt;은&lt;/strong&gt; 정의 범위에서 평가 &lt;strong&gt;해야합니다&lt;/strong&gt; . 결국 &lt;code&gt;name&lt;/code&gt; 을 사용할 수 있기를 바랍니다. 내부에서만 기능을 평가하면 액세스 할 수 없게됩니다.</target>
        </trans-unit>
        <trans-unit id="211b17364c2c5fb881927eef3ad2c632ef6e4ead" translate="yes" xml:space="preserve">
          <source>The actual behavior is more consistent: everything of that line gets evaluated when that line is executed, meaning at function definition.</source>
          <target state="translated">실제 동작은 더 일관성이 있습니다. 해당 행이 실행될 때 해당 행의 모든 ​​것이 평가되므로 함수 정의에서 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b21b3a47af1bce60cc5bdaa7db45df9e68ea6c1a" translate="yes" xml:space="preserve">
          <source>The behavior of read-only class attributes upon assignment attempts, and that</source>
          <target state="translated">할당 시도시 읽기 전용 클래스 속성의 동작 및</target>
        </trans-unit>
        <trans-unit id="d812f28bfd7bbbe507925925cde1cb11345acdb0" translate="yes" xml:space="preserve">
          <source>The common solution to combat this is to use &lt;code&gt;None&lt;/code&gt; as the default and then initialize in the function body:</source>
          <target state="translated">이를 방지하는 일반적인 솔루션은 &lt;code&gt;None&lt;/code&gt; 을 기본값으로 사용하고 함수 본문에서 초기화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="e6bc97e96787463bf81bb7eba82e092966902caa" translate="yes" xml:space="preserve">
          <source>The convention for achieving the desired result in Python is to
  provide a default value of &lt;code&gt;None&lt;/code&gt; and to document the actual behaviour
  in the docstring.</source>
          <target state="translated">Python에서 원하는 결과를 얻는 규칙은 기본값 &lt;code&gt;None&lt;/code&gt; 을 제공하고 docstring에서 실제 동작을 문서화하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="12d835d927cd99c2caf5af5f3e46112259ed6aeb" translate="yes" xml:space="preserve">
          <source>The decorator could be adjusted to allow for that, but we leave this as an exercise for the reader ;)</source>
          <target state="translated">데코레이터는 그것을 허용하도록 조정할 수 있지만 독자의 연습으로 남겨 둡니다.)</target>
        </trans-unit>
        <trans-unit id="5da3d3f2271874d0124b0b19b38e9cd58ca9fc21" translate="yes" xml:space="preserve">
          <source>The example in the question could fall into category 1 or 3. It's odd that it both modifies the passed list and returns it; you should pick one or the other.</source>
          <target state="translated">질문의 예는 카테고리 1 또는 3에 속할 수 있습니다. 전달 된 목록을 수정하고 리턴하는 것이 이상합니다. 둘 중 하나를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="07a5b90c302821e9edaa02c42d4c5a34d0d660fb" translate="yes" xml:space="preserve">
          <source>The existing behavior is not Pythonic, and Python is successful because very little about the language violates the principle of least astonishment anywhere &lt;em&gt;near&lt;/em&gt; this badly. It is a real problem, whether or not it would be wise to uproot it. It is a design flaw. If you understand the language much better by trying to trace out the behavior, I can say that C++ does all of this and more; you learn a lot by navigating, for instance, subtle pointer errors. But this is not Pythonic: people who care about Python enough to persevere in the face of this behavior are people who are drawn to the language because Python has far fewer surprises than other language. Dabblers and the curious become Pythonistas when they are astonished at how little time it takes to get something working--not because of a design fl--I mean, hidden logic puzzle--that cuts against the intuitions of programmers who are drawn to Python because it &lt;strong&gt;Just Works&lt;/strong&gt;.</source>
          <target state="translated">기존의 동작은 Pythonic이 아니며 Python은 언어에 대해 거의 거의이 &lt;em&gt;부근&lt;/em&gt; 의 가장 놀랍지 않은 원칙을 위반하기 때문에 성공합니다. 뿌리 뽑는 것이 현명한 지 아닌지에 따라 실제 문제입니다. 디자인 결함입니다. 동작을 추적하여 언어를 훨씬 더 잘 이해한다면 C ++이이 모든 것 이상을 수행한다고 말할 수 있습니다. 예를 들어 미묘한 포인터 오류를 탐색하여 많은 것을 배웁니다. 그러나 이것은 파이썬이 아닙니다. 파이썬이 다른 언어보다 놀라움이 훨씬 적기 때문에이 행동에 직면 할 정도로 파이썬에 관심이있는 사람들은 언어에 관심이있는 사람들입니다. 다 블러와 호기심은 파이썬에 이끌 리는 프로그래머의 직관을 가로막는 디자인 fl-즉 숨겨진 논리 퍼즐 때문이 아니라 작동하는 데 걸리는 시간이 얼마 남지 않았을 때 Pythonistas가됩니다. &lt;strong&gt;그냥 작동&lt;/strong&gt; 하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="16ba720afc950d5f92d65c94fa4b03086d39ddeb" translate="yes" xml:space="preserve">
          <source>The invocation of foo(1) make items point to a list object [] with an address, say, 11111111. the content of the list is changed to &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; in the foo function in the sequel, but the address is not changed, still 11111111. Then foo(2,[]) is coming. Although the [] in foo(2,[]) has the same content as the default parameter [] when calling foo(1), their address are different! Since we provide the parameter explicitly, &lt;code&gt;items&lt;/code&gt; has to take the address of this new &lt;code&gt;[]&lt;/code&gt;, say 2222222, and return it after making some change. Now foo(3) is executed. since only &lt;code&gt;x&lt;/code&gt; is provided, items has to take its default value again. What's the default value? It is set when defining the foo function: the list object located in 11111111. So the items is evaluated to be the address 11111111 having an element 1. The list located at 2222222 also contains one element 2, but it is not pointed by items any more. Consequently, An append of 3 will make &lt;code&gt;items&lt;/code&gt; [1,3].</source>
          <target state="translated">foo (1)을 호출하면 항목이 주소 (예 : 11111111)로 목록 객체 []를 가리키게됩니다. 목록의 내용은 속속의 foo 함수에서 &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; 로 변경되지만 주소는 변경되지 않습니다 (아직 11111111). foo (2, [])가옵니다. foo (2, [])의 []는 foo (1)을 호출 할 때 기본 매개 변수 []와 내용이 동일하지만 주소가 다릅니다! 매개 변수를 명시 적으로 제공하므로 &lt;code&gt;items&lt;/code&gt; 은이 새로운 &lt;code&gt;[]&lt;/code&gt; 의 주소 (예 : 2222222)를 가져 와서 약간 변경 한 후에 반환해야합니다. 이제 foo (3)이 실행됩니다. &lt;code&gt;x&lt;/code&gt; 만 제공되므로 항목은 기본값을 다시 가져와야합니다. 기본값은 무엇입니까? foo 함수를 정의 할 때 설정됩니다. 11111111에있는 목록 오브젝트입니다. 따라서 항목은 요소 1을 갖는 주소 11111111로 평가됩니다. 2222222에있는 목록에도 하나의 요소 2가 포함되지만 항목에 의해 지시되지는 않습니다. 더. 따라서 3을 추가하면 &lt;code&gt;items&lt;/code&gt; [1,3]이 만들어 집니다 .</target>
        </trans-unit>
        <trans-unit id="960186c4fed60739e84ad1f39072643da3a4aa62" translate="yes" xml:space="preserve">
          <source>The only way to implement this otherwise would be to create a further closure with the i bound, ie:</source>
          <target state="translated">그렇지 않으면 이것을 구현하는 유일한 방법은 i 바운드를 사용하여 추가 클로저를 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9a6df79e5dc84aaf86c93401973ff0f28eae8f32" translate="yes" xml:space="preserve">
          <source>The other answers, or at least some of them either make points 1 and 2 but not 3, or make point 3 and downplay points 1 and 2. &lt;strong&gt;But all three are true.&lt;/strong&gt;</source>
          <target state="translated">다른 답변 또는 적어도 일부는 포인트 1과 2를 만들지 만 3은 만들지 않거나 포인트 3과 다운 플레이 포인트 1과 2를 만듭니다. &lt;strong&gt;그러나 세 가지 모두 사실입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="927ebe1c435f42420093f2af144d14cd34af2416" translate="yes" xml:space="preserve">
          <source>The problem is that &lt;code&gt;foo&lt;/code&gt; is &lt;em&gt;modifying&lt;/em&gt; a mutable variable passed in from the caller, when the caller doesn't expect this. Code like this would be fine if the function was called something like &lt;code&gt;append_5&lt;/code&gt;; then the caller would be calling the function in order to modify the value they pass in, and the behaviour would be expected. But such a function would be very unlikely to take a default argument, and probably wouldn't return the list (since the caller already has a reference to that list; the one it just passed in).</source>
          <target state="translated">문제는 호출자가 이것을 기대하지 않을 때 &lt;code&gt;foo&lt;/code&gt; 가 호출자로부터 전달 된 가변 변수를 &lt;em&gt;수정&lt;/em&gt; 한다는 것입니다. 함수가 &lt;code&gt;append_5&lt;/code&gt; 와 같은 것으로 호출되면 이와 같은 코드가 좋습니다 . 그러면 호출자가 전달한 값을 수정하기 위해 함수를 호출하고 동작이 예상됩니다. 그러나 이러한 함수는 기본 인수를 취할 가능성이 거의 없으며 아마도 호출자가 이미 해당 목록에 대한 참조를 가지고 있기 때문에 목록을 반환하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="65336feec4cf085e41224e4e768035259840cf58" translate="yes" xml:space="preserve">
          <source>The real problem lies with mutable variables, and all languages have this problem to some extent. Here's a question: suppose in Java I have the following code:</source>
          <target state="translated">실제 문제는 가변 변수에 있으며 모든 언어에는 어느 정도이 문제가 있습니다. 질문이 있습니다 : Java에서 다음 코드가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="0a4fcade0686f8907935d1c1f96cfa776ce37445" translate="yes" xml:space="preserve">
          <source>The relevant part of the &lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function-definitions&quot;&gt;documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/reference/compound_stmts.html#function-definitions&quot;&gt;문서&lt;/a&gt; 의 관련 부분 :</target>
        </trans-unit>
        <trans-unit id="83a5fdca145464c718498a81f3ff52fe5cd258bb" translate="yes" xml:space="preserve">
          <source>The role of &lt;strong&gt;(2)&lt;/strong&gt; has been covered extensively in this thread. &lt;strong&gt;(1)&lt;/strong&gt; is likely the astonishment causing factor, as this behavior is not &quot;intuitive&quot; when coming from other languages.</source>
          <target state="translated">이 스레드에서 &lt;strong&gt;(2)&lt;/strong&gt; 의 역할이 광범위하게 다루어졌습니다. &lt;strong&gt;(1)&lt;/strong&gt; 이 행동은 다른 언어에서 올 때 &quot;직관적&quot;이 아니기 때문에 놀라운 원인이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="300e6346ced2778bb2850c432c17f5b9ac6cc781" translate="yes" xml:space="preserve">
          <source>The second option is nice because users of the function can pass in a callable, which may be already existing (such as a &lt;code&gt;type&lt;/code&gt;)</source>
          <target state="translated">두 번째 옵션은 함수의 사용자가 이미 존재하는 &lt;code&gt;type&lt;/code&gt; 의 콜 러블을 전달할 수 있기 때문에 좋습니다 (예 : type )</target>
        </trans-unit>
        <trans-unit id="a7a38b99177ce67bdf698f00a61b5341959f2954" translate="yes" xml:space="preserve">
          <source>The shortest answer would probably be &quot;definition is execution&quot;, therefore the whole argument makes no strict sense. As a more contrived example, you may cite this:</source>
          <target state="translated">가장 짧은 대답은 아마도 &quot;정의는 실행&quot;일 것이므로 전체 논증은 엄격하지 않습니다. 더 고안된 예로서, 당신은 이것을 인용 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="1545469b153fc84d77f2934491dab6d60119c4f8" translate="yes" xml:space="preserve">
          <source>The solutions here are:</source>
          <target state="translated">해결책은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f29d3492458b50ad2b58ab7115f1bdab5c6dec2" translate="yes" xml:space="preserve">
          <source>The two choices are not equivalent, either: If &lt;code&gt;default&lt;/code&gt; is evaluated at definition time, it &lt;em&gt;can still&lt;/em&gt; affect execution time. If &lt;code&gt;default&lt;/code&gt; is evaluated at execution time, it &lt;em&gt;cannot&lt;/em&gt; affect definition time. Choosing &quot;at definition&quot; allows expressing both cases, while choosing &quot;at execution&quot; can express only one:</source>
          <target state="translated">두 가지 선택도 동일하지 않습니다. 정의 시간에 &lt;code&gt;default&lt;/code&gt; 이 평가되는 경우 &lt;em&gt;여전히&lt;/em&gt; 실행 시간에 영향을 줄 &lt;em&gt;수 있습니다&lt;/em&gt; . 실행 시간에 &lt;code&gt;default&lt;/code&gt; 이 평가되면 정의 시간에 영향을 줄 &lt;em&gt;수 없습니다&lt;/em&gt; . &quot;정의&quot;를 선택하면 두 경우 모두를 표현할 수 있으며 &quot;실행시&quot;를 선택하면 다음 중 하나만 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d3b19afacd01fa6760d29ccb31fceacd0420b99" translate="yes" xml:space="preserve">
          <source>The usual instruction to new Python users:</source>
          <target state="translated">새로운 Python 사용자에게 일반적인 지침 :</target>
        </trans-unit>
        <trans-unit id="83431a0cce73cc9ea555626b7407f498ddeab772" translate="yes" xml:space="preserve">
          <source>There are 3 cases I see where you might run into this problem:</source>
          <target state="translated">이 문제가 발생할 수있는 곳은 3 가지입니다.</target>
        </trans-unit>
        <trans-unit id="7d403bffc3efdc0e15e597031a66e58b86f1e427" translate="yes" xml:space="preserve">
          <source>There may be legitimate use cases for the 'Wrong Method' whereby the programmer intended the default list parameter to be shared, but this is more likely the exception than the rule.</source>
          <target state="translated">프로그래머가 기본 목록 매개 변수를 공유하도록 의도 한 '잘못된 방법'에 대한 정당한 사용 사례가있을 수 있지만 이는 규칙보다 예외 일 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="e122131b734ffdd0c974c11125de9bf4d4ac1de3" translate="yes" xml:space="preserve">
          <source>They stay mutated because they are the same object each time.</source>
          <target state="translated">매번 같은 객체이기 때문에 돌연변이를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="42f87dc35743615ca50ba7a4e0a765f48628f38e" translate="yes" xml:space="preserve">
          <source>This &quot;bug&quot; gave me a lot of overtime work hours! But I'm beginning to see a potential use of it (but I would have liked it to be at the execution time, still)</source>
          <target state="translated">이 &quot;버그&quot;는 많은 초과 근무 시간을 주었다! 그러나 나는 그것을 잠재적으로 사용하기 시작했습니다 (그러나 여전히 실행 시간에 좋았을 것입니다)</target>
        </trans-unit>
        <trans-unit id="09c551bd076af75de6f7f75f84e6e19528a70b20" translate="yes" xml:space="preserve">
          <source>This actually has nothing to do with default values, other than that it often comes up as an unexpected behaviour when you write functions with mutable default values.</source>
          <target state="translated">이것은 변경 가능한 기본값으로 함수를 작성할 때 종종 예기치 않은 동작으로 나타나는 것 외에는 기본값과 아무 관련이 없습니다.</target>
        </trans-unit>
        <trans-unit id="91bf40b75c5eb2ec9fc9e9af2dee27f147910385" translate="yes" xml:space="preserve">
          <source>This behavior is easy explained by:</source>
          <target state="translated">이 동작은 다음과 같이 쉽게 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="8e882fce06b5aa8e4902377bf10643c0438bee5c" translate="yes" xml:space="preserve">
          <source>This behavior is not surprising if you take the following into consideration:</source>
          <target state="translated">다음을 고려하면이 동작은 놀라운 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="53ed8453d80a594313b39f617a24cd922589e53c" translate="yes" xml:space="preserve">
          <source>This code suffers from the exact same unexpected happenstance. bananas is a class attribute, and hence, when you add things to it, it's added to all instances of that class. The reason is exactly the same.</source>
          <target state="translated">이 코드는 정확히 예상치 못한 상황이 발생합니다. bananas는 클래스 속성이므로 항목을 추가하면 해당 클래스의 모든 인스턴스에 추가됩니다. 그 이유는 정확히 같습니다.</target>
        </trans-unit>
        <trans-unit id="5aa4790f0f096239796bd26d7ab23aed623fa5b3" translate="yes" xml:space="preserve">
          <source>This implementation ensures that each call to the function either receives the default list or else the list passed to the function.</source>
          <target state="translated">이 구현은 함수를 호출 할 때마다 기본 목록을 받거나 함수에 전달 된 목록을 받도록합니다.</target>
        </trans-unit>
        <trans-unit id="37aa3fb7ad8287604da5115ea29978831dfe3dda" translate="yes" xml:space="preserve">
          <source>This information is very useful for things like document generation, metaprogramming, decorators etc.</source>
          <target state="translated">이 정보는 문서 생성, 메타 프로그래밍, 데코레이터 등과 같은 것들에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="643cda6d4c6e34a04adb1a217260ad6665380a64" translate="yes" xml:space="preserve">
          <source>This is particularly neat for functions that take multiple arguments. Compare:</source>
          <target state="translated">이것은 여러 개의 인수를 취하는 함수에 특히 적합합니다. 비교:</target>
        </trans-unit>
        <trans-unit id="e564daaa17ad1d2d62e46bbb59e0067c087845a8" translate="yes" xml:space="preserve">
          <source>This order of execution is frequently confusing to new users of Python. If you understand the Python execution model, then it becomes quite expected.</source>
          <target state="translated">이 실행 순서는 종종 새로운 Python 사용자에게 혼란을줍니다. 파이썬 실행 모델을 이해하면 상당히 기대됩니다.</target>
        </trans-unit>
        <trans-unit id="b99a6bdeb57707ff2643e03cc6dbbbaa2acc3f12" translate="yes" xml:space="preserve">
          <source>This returns a list of functions that return 0,1,2,3... respectively.  If the behaviour is changed, they will instead bind &lt;code&gt;i&lt;/code&gt; to the &lt;em&gt;call-time&lt;/em&gt; value of i, so you would get a list of functions that all returned &lt;code&gt;9&lt;/code&gt;.</source>
          <target state="translated">이것은 각각 0,1,2,3 ...을 반환하는 함수 목록을 반환합니다. 동작이 변경되면 대신 &lt;code&gt;i&lt;/code&gt; 를 i 의 &lt;em&gt;호출 시간&lt;/em&gt; 값에 바인딩하므로 모두 &lt;code&gt;9&lt;/code&gt; 를 반환 한 함수 목록이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d1a3982204610904ddbc4a70de5860ec7e166984" translate="yes" xml:space="preserve">
          <source>This uses the None singleton as a sentinel object to tell the function whether or not we've gotten an argument other than the default. If we get no argument, then we actually want to use a new empty list, &lt;code&gt;[]&lt;/code&gt;, as the default.</source>
          <target state="translated">이것은 None 싱글 톤을 센티넬 객체로 사용하여 기본값 이외의 인수를 받았는지 여부를 함수에 알려줍니다. 인수가 없으면 실제로 빈 목록 인 &lt;code&gt;[]&lt;/code&gt; 를 기본값으로 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="4aedb952cd727e6e69581496e8e0b6ab6127d03c" translate="yes" xml:space="preserve">
          <source>To further validate my answer, let's take a look at two additional codes.</source>
          <target state="translated">내 대답을 더 검증하기 위해 두 가지 추가 코드를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3488d10d037c07a6d63c40837ee02a62ef16f935" translate="yes" xml:space="preserve">
          <source>To further verify that the list in &lt;code&gt;__defaults__&lt;/code&gt; is the same as that used in the function &lt;code&gt;func&lt;/code&gt; you can just change your function to return the &lt;code&gt;id&lt;/code&gt; of the list &lt;code&gt;a&lt;/code&gt; used inside the function body. Then, compare it to the list in &lt;code&gt;__defaults__&lt;/code&gt; (position &lt;code&gt;[0]&lt;/code&gt; in &lt;code&gt;__defaults__&lt;/code&gt;) and you'll see how these are indeed refering to the same list instance:</source>
          <target state="translated">&lt;code&gt;__defaults__&lt;/code&gt; 의 목록이 함수 &lt;code&gt;func&lt;/code&gt; 에서 사용한 목록과 동일한 지 확인하려면 함수 본문 &lt;code&gt;a&lt;/code&gt; 사용 된 목록의 &lt;code&gt;id&lt;/code&gt; 를 반환하도록 함수를 변경 하면 됩니다. 그런 다음 &lt;code&gt;__defaults__&lt;/code&gt; ( __defaults__의 위치 &lt;code&gt;[0]&lt;/code&gt; ) 목록과 비교하면 실제로 동일한 목록 인스턴스를 참조하는 방법을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c169f56bd97d585a628344306275a6fbb160c64" translate="yes" xml:space="preserve">
          <source>To make things simpler for this discussion, let's temporarily give the unnamed list a name. How about &lt;code&gt;pavlo&lt;/code&gt; ?</source>
          <target state="translated">이 토론을보다 간단하게하기 위해 이름없는 목록에 임시로 이름을 지정합시다. &lt;code&gt;pavlo&lt;/code&gt; 는 어때요 ?</target>
        </trans-unit>
        <trans-unit id="e3a6729bfe6a04ecd5a00fc68b6c0f6331500e7a" translate="yes" xml:space="preserve">
          <source>To me, it seems that the design decision was relative to where to put the scope of parameters: inside the function or &quot;together&quot; with it?</source>
          <target state="translated">나에게, 디자인 결정은 매개 변수의 범위를 어디에 넣을 것인지에 관한 것 같습니다 : 함수 내부 또는 &quot;함께&quot;?</target>
        </trans-unit>
        <trans-unit id="636d1dcd268f11a46b28fe964396e61a54cf23da" translate="yes" xml:space="preserve">
          <source>Ugly, but it works.</source>
          <target state="translated">추악하지만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f1f3a34856e7b498ab581f67c98cdf2d11513052" translate="yes" xml:space="preserve">
          <source>Upon &lt;code&gt;L = []&lt;/code&gt;, the assignment cannot succeed at &lt;code&gt;foo.func_defs[0]&lt;/code&gt;, because that attribute is read-only.</source>
          <target state="translated">&lt;code&gt;L = []&lt;/code&gt; 일 때 속성은 읽기 전용이므로 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; 에서 할당을 성공할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b4add7a466713c04e3a9ff607faa91aff366d0f8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;None&lt;/code&gt; as your default value (or a nonce &lt;code&gt;object&lt;/code&gt;), and switch on that to create your values at runtime; or</source>
          <target state="translated">&lt;code&gt;None&lt;/code&gt; 을 기본값 (또는 nonce &lt;code&gt;object&lt;/code&gt; )으로 사용하고이를 켜서 런타임에 값을 작성하십시오. 또는</target>
        </trans-unit>
        <trans-unit id="ea379d2578b870e14c73410aa538eccdf7d0c72c" translate="yes" xml:space="preserve">
          <source>Use a &lt;code&gt;lambda&lt;/code&gt; as your default parameter, and call it within a try block to get the default value (this is the sort of thing that lambda abstraction is for).</source>
          <target state="translated">&lt;code&gt;lambda&lt;/code&gt; 를 기본 매개 변수로 사용하고 try 블록 내에서 람다 를 호출하여 기본값을 얻습니다 (람다 추상화의 일종입니다).</target>
        </trans-unit>
        <trans-unit id="9ce0fb10a3874ece19a632c8bbfe4072e2abf695" translate="yes" xml:space="preserve">
          <source>We can get information about the arguments and defaults using the &lt;code&gt;inspect&lt;/code&gt; module, which</source>
          <target state="translated">&lt;code&gt;inspect&lt;/code&gt; 모듈을 사용하여 인수와 기본값에 대한 정보를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f43fd0e1e7b924e195b0d1f43667f4b3ecb78cc3" translate="yes" xml:space="preserve">
          <source>We will &quot;fix&quot; this behavior with a decorator that will copy the default value instead of reusing the same instance for each positional argument left at its default value.</source>
          <target state="translated">우리는 기본값으로 남겨진 각 위치 인수에 대해 동일한 인스턴스를 재사용하는 대신 기본값을 복사하는 데코레이터로이 동작을 &quot;수정&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="028722da6bbfb13719d096b837a20e83f8b33121" translate="yes" xml:space="preserve">
          <source>Well, the reason is quite simply that bindings are done when code is executed, and the function definition is executed, well... when the functions is defined.</source>
          <target state="translated">글쎄, 그 이유는 코드가 실행될 때 바인딩이 수행되고 함수가 정의 될 때 함수 정의가 실행되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="7ad15b2528d3a839026c0d58cd1ee45b2711f4f7" translate="yes" xml:space="preserve">
          <source>What you're asking is why this:</source>
          <target state="translated">당신이 묻는 것은 이것이 왜 그런지입니다.</target>
        </trans-unit>
        <trans-unit id="bb251fe5322c9cbb5669eb17fcc4c69cba91f98f" translate="yes" xml:space="preserve">
          <source>When I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple &lt;code&gt;(&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)&lt;/code&gt;</source>
          <target state="translated">내가 먹는 선언을 볼 때 가장 놀라운 것은 첫 번째 매개 변수가 제공되지 않으면 튜플과 동일하다고 생각하는 것입니다 &lt;code&gt;(&quot;apples&quot;, &quot;bananas&quot;, &quot;loganberries&quot;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92837d652717841e4dbdd22b5957c04117add88c" translate="yes" xml:space="preserve">
          <source>When Python encounters it, the first thing it will do is compile it in order to create a &lt;code&gt;code&lt;/code&gt; object for this function. While this compilation step is done, &lt;em&gt;Python &lt;strong&gt;evaluates&lt;/strong&gt;* and then &lt;strong&gt;stores&lt;/strong&gt; the default arguments (an empty list &lt;code&gt;[]&lt;/code&gt; here) in the function object itself&lt;/em&gt;. As the top answer mentioned: the list &lt;code&gt;a&lt;/code&gt; can now be considered a &lt;em&gt;member&lt;/em&gt; of the function &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">파이썬이 그것을 만나면, 가장 먼저 할 일은이 함수를위한 &lt;code&gt;code&lt;/code&gt; 객체를 만들기 위해 그것을 컴파일하는 것입니다. 이 컴파일 단계가 수행되는 동안 &lt;em&gt;Python &lt;strong&gt;은&lt;/strong&gt; *를 &lt;strong&gt;평가&lt;/strong&gt; 한 다음 기본 인수 (여기서는 빈 목록 &lt;code&gt;[]&lt;/code&gt; )를 함수 객체 자체에 저장합니다&lt;/em&gt; . 최고 답변이 언급했듯이 목록 &lt;code&gt;a&lt;/code&gt; 는 이제 &lt;code&gt;func&lt;/code&gt; 함수의 &lt;em&gt;멤버&lt;/em&gt; 로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd17f911f362a654b5a6c64b275c0e88df650e11" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;foo&lt;/code&gt; function object is instantiated, &lt;code&gt;foo.func_defs[0]&lt;/code&gt; is set to &lt;code&gt;None&lt;/code&gt;, an immutable object.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 함수 객체가 인스턴스화되면 &lt;code&gt;foo.func_defs[0]&lt;/code&gt; 이 변경 불가능한 객체 인 &lt;code&gt;None&lt;/code&gt; 으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6bb5893e3a075febba63fa1345cc1545dec24f55" translate="yes" xml:space="preserve">
          <source>When the function is executed with defaults (with no parameter specified for &lt;code&gt;L&lt;/code&gt; in the function call), &lt;code&gt;foo.func_defs[0]&lt;/code&gt; (&lt;code&gt;None&lt;/code&gt;) is available in the local scope as &lt;code&gt;L&lt;/code&gt;.</source>
          <target state="translated">함수가 기본값으로 실행되면 (함수 호출에서 &lt;code&gt;L&lt;/code&gt; 에 지정된 매개 변수없이) &lt;code&gt;foo.func_defs[0]&lt;/code&gt; ( &lt;code&gt;None&lt;/code&gt; )은 로컬 범위에서 &lt;code&gt;L&lt;/code&gt; 로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c90da9c4543da64cdb8845246bc7bf7320e0bc1d" translate="yes" xml:space="preserve">
          <source>When they are mutable, when mutated (for example, by adding an element to it) they remain mutated on consecutive calls.</source>
          <target state="translated">변경 가능한 경우 (예 : 요소를 추가하여) 변경하면 연속적인 호출에서 변경이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="2241f2b26702e693ed138e31ffa8bd03750a3109" translate="yes" xml:space="preserve">
          <source>When we do this:</source>
          <target state="translated">우리가 이것을 할 때 :</target>
        </trans-unit>
        <trans-unit id="6912ff10f6eb1fb687cb173f4f87e2aa8cb150d3" translate="yes" xml:space="preserve">
          <source>Why don't you introspect?</source>
          <target state="translated">왜 당신은 내성하지?</target>
        </trans-unit>
        <trans-unit id="287fc26c3268d8d1c2a9357d670b0099b1576d07" translate="yes" xml:space="preserve">
          <source>Why should the &lt;code&gt;a=[]&lt;/code&gt; in</source>
          <target state="translated">왜 &lt;code&gt;a=[]&lt;/code&gt; 에서</target>
        </trans-unit>
        <trans-unit id="52b2c683c383df4eb8aa68d958bd6badb17f2b85" translate="yes" xml:space="preserve">
          <source>Yes, it is unexpected. But once the penny drops, it fits in perfectly with how Python works in general. In fact, it's a good teaching aid, and once you understand why this happens, you'll grok python much better.</source>
          <target state="translated">그렇습니다. 그러나 페니가 떨어지면 파이썬의 일반적인 작동 방식과 완벽하게 맞습니다. 사실, 그것은 훌륭한 교육 보조 자료이며, 왜 이런 일이 발생했는지 이해하면 파이썬을 훨씬 더 잘 이해하게 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="9083597dacf68f7853fb01578d3aa2ab71e8663f" translate="yes" xml:space="preserve">
          <source>You can get round this by replacing the object (and therefore the tie with the scope):</source>
          <target state="translated">객체 (따라서 스코프와의 넥타이)를 바꾸면이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b512ff0f2aacb271cc653788c90da69d6dfc77d3" translate="yes" xml:space="preserve">
          <source>You can verify that they are one and the same object by using &lt;code&gt;id&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; 를 사용하여 이들이 하나의 동일한 객체인지 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7a57f1c427b2aba87570b0fda4061b9802afcc3" translate="yes" xml:space="preserve">
          <source>You intend to leave the argument unmodified, but you accidentally &lt;em&gt;did&lt;/em&gt; modify it. That's a bug, fix it.</source>
          <target state="translated">인수를 수정 &lt;em&gt;하지&lt;/em&gt; 않고 그대로 두려고했지만 실수로 수정했습니다. 그것은 버그입니다.</target>
        </trans-unit>
        <trans-unit id="c2929c645da85b138bef1656c13169d0ec045e7d" translate="yes" xml:space="preserve">
          <source>You intend to modify the argument as a side effect of the function. In this case it &lt;em&gt;never makes sense&lt;/em&gt; to have a default argument. The only exception is when you're abusing the argument list to have function attributes, e.g. &lt;code&gt;cache={}&lt;/code&gt;, and you wouldn't be expected to call the function with an actual argument at all.</source>
          <target state="translated">함수의 부작용으로 인수를 수정하려고합니다. 이 경우 기본 인수를 갖는 것은 &lt;em&gt;의미&lt;/em&gt; 가 &lt;em&gt;없습니다&lt;/em&gt; . 함수 목록 (예 : &lt;code&gt;cache={}&lt;/code&gt; ) 을 갖도록 인수 목록을 남용하고 실제 인수를 사용하여 함수를 호출하지 않을 경우는 예외입니다.</target>
        </trans-unit>
        <trans-unit id="17d9e231f7ae8537e606b6c0973a016f0c3b9581" translate="yes" xml:space="preserve">
          <source>You intend to modify the argument for use inside the function, but didn't expect the modification to be viewable outside of the function. In that case you need to make a &lt;em&gt;copy&lt;/em&gt; of the argument, whether it was the default or not! Python is not a call-by-value language so it doesn't make the copy for you, you need to be explicit about it.</source>
          <target state="translated">함수 내에서 사용하기 위해 인수를 수정하려고하지만 함수 외부에서 수정할 수있는 것으로 기대하지 않았습니다. 이 경우 기본 여부에 상관없이 인수의 &lt;em&gt;사본&lt;/em&gt; 을 작성해야합니다! 파이썬은 값별 호출 언어가 아니기 때문에 사본을 만들지 않으므로 명시 적으로 명시해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6ced87465fcf1eeb8fdd29b614471918519675e" translate="yes" xml:space="preserve">
          <source>Your example is a good one of a case where Python newcomers will be surprised and bitten.  But I'd argue that if we &quot;fixed&quot; this, then that would only create a different situation where they'd be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they're writing.</source>
          <target state="translated">귀하의 예는 파이썬 초보자가 놀라고 물린 사례 중 하나입니다. 그러나 만약 우리가이 문제를 &quot;고치게&quot;한다면, 그것은 오히려 물린 다른 상황을 만들어 낼 것이며, 덜 직관적 일 것이라고 주장 할 것입니다. 또한 가변 변수를 다룰 때 항상 그렇습니다. 어떤 코드를 작성하고 있는지에 따라 누군가가 직관적으로 하나 또는 반대 행동을 기대할 수있는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="27311373d31b73eb41d1e0b30e06efc32dc97a21" translate="yes" xml:space="preserve">
          <source>Your original &lt;code&gt;foo&lt;/code&gt;, with a default argument, shouldn't be modifying &lt;code&gt;a&lt;/code&gt; whether it was explicitly passed in or got the default value. Your code should leave mutable arguments alone unless it is clear from the context/name/documentation that the arguments are supposed to be modified. Using mutable values passed in as arguments as local temporaries is an extremely bad idea, whether we're in Python or not and whether there are default arguments involved or not.</source>
          <target state="translated">기본 인수가있는 원래 &lt;code&gt;foo&lt;/code&gt; 는 명시 적으로 전달되었는지 또는 기본값을 얻었는지 여부를 수정해서는 안됩니다. 컨텍스트 / 이름 / 문서에서 인수가 수정되어야한다는 것이 명확하지 않으면 코드는 가변 인수 만 남겨 두어야합니다. 지역 임시로 인수로 전달 된 가변 값을 사용하는 것은 파이썬에 있든 없든 기본 인수가 관련되어 있는지 여부에 관계없이 매우 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="a47c48016c7bd5e01546ccb1b762c78b706d5abe" translate="yes" xml:space="preserve">
          <source>[] is an object, so python pass the reference of [] to &lt;code&gt;a&lt;/code&gt;, i.e., &lt;code&gt;a&lt;/code&gt; is only a pointer to [] which lies in memory as an object. There is only one copy of [] with, however, many references to it. For the first foo(), the list [] is changed to &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; by append method. But Note that there is only one copy of the list object and this object now becomes &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt;. When running the second foo(), what effbot webpage says (items is not evaluated any more) is wrong. &lt;code&gt;a&lt;/code&gt; is evaluated to be the list object, although now the content of the object is &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt;. This is the effect of passing by reference! The result of foo(3) can be easily derived in the same way.</source>
          <target state="translated">[]는 객체이므로 파이썬은 []의 참조를 &lt;code&gt;a&lt;/code&gt; 로 전달합니다. 즉 &lt;code&gt;a&lt;/code&gt; 는 객체로 메모리에있는 []에 대한 포인터 일뿐입니다. 그러나 []의 사본은 하나만 있지만 이에 대한 많은 참조가 있습니다. 첫 번째 foo ()의 경우, append 메소드에 의해리스트 []가 &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; 로 변경됩니다. 그러나리스트 오브젝트의 사본은 하나만 있으며이 오브젝트는 이제 &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1이&lt;/a&gt; 됩니다. 두 번째 foo ()를 실행할 때 effbot 웹 페이지의 내용 (항목이 더 이상 평가되지 않음)이 잘못되었습니다. &lt;code&gt;a&lt;/code&gt; 는 목록 객체로 평가되지만 이제 객체의 내용은 &lt;a href=&quot;http://effbot.org/zone/default-values.htm&quot;&gt;1&lt;/a&gt; 입니다. 이것은 참조로 전달하는 효과입니다! foo (3)의 결과는 같은 방식으로 쉽게 파생 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="811a1b05ff4f47b946f5851e4e0919d50dfa1cfc" translate="yes" xml:space="preserve">
          <source>and running it with &lt;code&gt;python example.py&lt;/code&gt;:</source>
          <target state="translated">그리고 &lt;code&gt;python example.py&lt;/code&gt; 실행하십시오 :</target>
        </trans-unit>
        <trans-unit id="049874c49f0ace21f9f13dd31c57abc695140bba" translate="yes" xml:space="preserve">
          <source>as you'll notice, &lt;code&gt;input()&lt;/code&gt; is called before the process of building the function and binding it to the name &lt;code&gt;bar&lt;/code&gt; is made.</source>
          <target state="translated">아시다시피 &lt;code&gt;input()&lt;/code&gt; 은 함수를 빌드하고 이름 &lt;code&gt;bar&lt;/code&gt; 바인딩하기 전에 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="3375274202e5815d3135c4440713525187e9f33a" translate="yes" xml:space="preserve">
          <source>everything is passed by reference</source>
          <target state="translated">모든 것이 참조로 전달됩니다</target>
        </trans-unit>
        <trans-unit id="127ad2d11d264ef1bc3b7c9367a87c065c2e20d2" translate="yes" xml:space="preserve">
          <source>except for the case of explicitly calling func(None, None), which we'll ignore.</source>
          <target state="translated">func (None, None)을 명시 적으로 호출하는 경우를 제외하고는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="fc5c678a45bcac56840b3c908642740f5ede6d3d" translate="yes" xml:space="preserve">
          <source>function (class etc.) declaration is executed only once, creating all default value objects</source>
          <target state="translated">함수 (클래스 등) 선언은 한 번만 실행되어 모든 기본값 개체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="71759c14baa0f1b45b053d0754f9b76a716165c8" translate="yes" xml:space="preserve">
          <source>instantiate a new list on function definition and not on invocation?
It's just like you're asking &quot;if the user doesn't provide the argument then &lt;em&gt;instantiate&lt;/em&gt; a new list and use it as if it was produced by the caller&quot;.
I think this is ambiguous instead:</source>
          <target state="translated">호출이 아닌 함수 정의에 대한 새 목록을 인스턴스화합니까? &quot;사용자가 인수를 제공하지 않으면 새 목록을 &lt;em&gt;인스턴스화&lt;/em&gt; 하여 호출자가 생성 한 것처럼 사용하십시오&quot;라고 묻는 것과 같습니다. 나는 이것이 모호하다고 생각한다.</target>
        </trans-unit>
        <trans-unit id="9d29cbd7a4d1e405b35c263d8e5d5507492f015a" translate="yes" xml:space="preserve">
          <source>is almost exactly equivalent to this:</source>
          <target state="translated">거의 이것과 거의 같습니다 :</target>
        </trans-unit>
        <trans-unit id="d94296d98f302fe54eca1ccc91cf45236ffa89e2" translate="yes" xml:space="preserve">
          <source>isn't internally equivalent to this:</source>
          <target state="translated">내부적으로 이것과 동일하지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="3e5690a3202553a2f619db51e48332229bfe602f" translate="yes" xml:space="preserve">
          <source>it is entirely consistent to hold to both of the features above and still make another point:</source>
          <target state="translated">위의 두 기능을 모두 유지하면서 또 다른 점을 지적하는 것은 전적으로 일관됩니다.</target>
        </trans-unit>
        <trans-unit id="39fcd29280818de6a833974667212de642dcf2a7" translate="yes" xml:space="preserve">
          <source>observing that the id is the same each time the list is referenced,</source>
          <target state="translated">목록이 참조 될 때마다 ID가 동일하다는 것을 관찰하고,</target>
        </trans-unit>
        <trans-unit id="d8e7da304415824d87e81f7b39df6675059d9a54" translate="yes" xml:space="preserve">
          <source>observing that the list stays changed when the function that uses it is called a second time,</source>
          <target state="translated">목록을 사용하는 함수가 두 번째로 호출 될 때 목록이 변경된 상태로 유지되는 것을 관찰하면,</target>
        </trans-unit>
        <trans-unit id="b573226ee49e1a1dd733f88915532ed8bd52e8f9" translate="yes" xml:space="preserve">
          <source>observing the order in which the output is printed from the source (which I conveniently numbered for you):</source>
          <target state="translated">소스에서 출력이 인쇄되는 순서를 준수합니다 (편리하게 번호가 매겨져 있음).</target>
        </trans-unit>
        <trans-unit id="04c9c0f5ccf58a5d42c14519b24d6f2145c58d5f" translate="yes" xml:space="preserve">
          <source>prints the following</source>
          <target state="translated">다음을 인쇄합니다</target>
        </trans-unit>
        <trans-unit id="db480f941abc083354113eeeff05d261f2c92991" translate="yes" xml:space="preserve">
          <source>seeing that the list is created before the function has finished compiling to a function object,</source>
          <target state="translated">함수가 함수 객체에 대한 컴파일을 완료하기 전에 목록이 생성되는지 확인</target>
        </trans-unit>
        <trans-unit id="7fae1298345bf082e2261fee60080aa9d63fe920" translate="yes" xml:space="preserve">
          <source>then if default parameters were bound at function execution rather than function declaration then I would be astonished (in a very bad way) to discover that fruits had been changed.  This would be more astonishing IMO than discovering that your &lt;code&gt;foo&lt;/code&gt; function above was mutating the list.</source>
          <target state="translated">그런 다음 기본 매개 변수가 함수 선언이 아닌 함수 실행에 바인딩 된 경우 과일이 변경되었음을 알게되면 (매우 나쁜 방법으로) 놀라게됩니다. 이것은 위의 &lt;code&gt;foo&lt;/code&gt; 함수가 목록을 변경하고 있음을 발견하는 것보다 놀라운 IMO입니다.</target>
        </trans-unit>
        <trans-unit id="f16bec6158470b4bee129a9e6c86214a2e496fdf" translate="yes" xml:space="preserve">
          <source>user, do you want &lt;code&gt;a&lt;/code&gt; to default to the datetime corresponding to when you're defining or executing &lt;code&gt;x&lt;/code&gt;?
In this case, as in the previous one, I'll keep the same behaviour as if the default argument &quot;assignment&quot; was the first instruction of the function (&lt;code&gt;datetime.now()&lt;/code&gt; called on function invocation).
On the other hand, if the user wanted the definition-time mapping he could write:</source>
          <target state="translated">사용자는 &lt;code&gt;x&lt;/code&gt; 를 정의하거나 실행할 때의 날짜 시간을 기본값으로 설정 하시겠습니까? 이 경우 이전의 경우와 같이 기본 인수 &quot;assignment&quot;가 함수의 첫 번째 명령어 &lt;code&gt;datetime.now()&lt;/code&gt; 함수 호출시 호출 된 datetime.now ()) 와 동일한 동작을 유지합니다. 반면에 사용자가 정의 시간 매핑을 원하면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="translated">with</target>
        </trans-unit>
        <trans-unit id="06e3de5b5b2d499fee4d0c87a0745254a4a566cb" translate="yes" xml:space="preserve">
          <source>you expect to get a &lt;strong&gt;new&lt;/strong&gt; list referenced by &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">에 의해 참조되는 &lt;strong&gt;새&lt;/strong&gt; 목록을 얻을 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="8c194c14b318f40b680d2378e5d49d583177218c" translate="yes" xml:space="preserve">
          <source>“Least Astonishment” and the Mutable Default Argument</source>
          <target state="translated">&quot;최소한의 놀라움&quot;과 변하기 쉬운 기본 주장</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
