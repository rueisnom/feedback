<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/111102">
    <body>
      <group id="111102">
        <trans-unit id="edc3d87bc0d77451b24b00c1cf3016bdb95e72af" translate="yes" xml:space="preserve">
          <source>&quot;Come on &lt;em&gt;sing&lt;/em&gt;, Come and get &lt;em&gt;person&lt;/em&gt;!&quot;</source>
          <target state="translated">「 &lt;em&gt;歌い&lt;/em&gt;に来て、是非、 &lt;em&gt;人&lt;/em&gt;を手に入れよう！」</target>
        </trans-unit>
        <trans-unit id="7dd20ec9bc8964ce1c79283c85999cad1cee4dac" translate="yes" xml:space="preserve">
          <source>...is really a princess with a little girl inside.</source>
          <target state="translated">...中には本当に小さな女の子がいるお姫様です。</target>
        </trans-unit>
        <trans-unit id="103badd33a2698b99355a3659479f625c4c33efa" translate="yes" xml:space="preserve">
          <source>...telling stories about magic and fantasy.</source>
          <target state="translated">...魔法とファンタジーの話をしています。</target>
        </trans-unit>
        <trans-unit id="dd3acb8afd097803b9360b2f69c1fea1de5f28bb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Closure_(computer_science)&quot;&gt;Wikipedia on closures&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Closure_(computer_science)&quot;&gt;閉鎖に関するウィキペディア&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="66795f475c16753ced57a004591a7e32d1be97f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createClosure(n)&lt;/code&gt; returns a function that returns the n within that scope.</source>
          <target state="translated">&lt;code&gt;createClosure(n)&lt;/code&gt; は、そのスコープ内のnを返す関数を返します。</target>
        </trans-unit>
        <trans-unit id="0605c773a855ad7752167561fff57f3ec27930c0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you are familiar with stack frames, these calculators seem strange: How can they keep accessing &lt;code&gt;n&lt;/code&gt; after &lt;code&gt;make_calculator&lt;/code&gt; returns?  The answer is to imagine that JavaScript doesn't use &quot;stack frames&quot;, but instead uses &quot;heap frames&quot;, which can persist after the function call that made them returns.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;スタックフレームに精通している場合、これらの計算機は奇妙に &lt;code&gt;make_calculator&lt;/code&gt; ます。make_calculatorが戻った後、どのようにして &lt;code&gt;n&lt;/code&gt; にアクセスし続けることができますか？&lt;/em&gt; &lt;em&gt;答えは、JavaScriptが「スタックフレーム」を使用せず、代わりに「ヒープフレーム」を使用することを想像することです。これは、それらを作成した関数呼び出しが戻った後も存続することができます。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f02b4fea2cc85281d187a2a3101725f3bd466ca9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that &lt;code&gt;/*...*/&lt;/code&gt; and &lt;code&gt;//&lt;/code&gt; stop code being read by the browser.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;/*...*/&lt;/code&gt; および &lt;code&gt;//&lt;/code&gt; ブラウザによるコードの読み取りを停止することに注意してください。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11d4db30148058831981cd0f151cdbbc17e172a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://jondavidjohn.com/javascript-closure-explained-using-events/&quot;&gt;Full Blog Post&lt;/a&gt;&lt;/strong&gt; (including jQuery considerations)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://jondavidjohn.com/javascript-closure-explained-using-events/&quot;&gt;完全なブログ投稿&lt;/a&gt;&lt;/strong&gt; （jQueryの考慮事項を含む）</target>
        </trans-unit>
        <trans-unit id="2184405757c5883c445a99418ddb1a5ee63000ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A closure does not reference a copy of the &lt;em&gt;old values&lt;/em&gt; of variables in its scope.&lt;/strong&gt; The variables themselves are part of the closure, and so the value seen when accessing one of those variables is the latest value at the time it is accessed. This is why inner functions created inside of loops can be tricky, since each one has access to the same outer variables rather than grabbing a copy of the variables at the time the function is created or called.</source>
          <target state="translated">&lt;strong&gt;クロージャーは、そのスコープ内の変数の&lt;em&gt;古い値の&lt;/em&gt;コピーを参照しません。&lt;/strong&gt; 変数自体はクロージャの一部であるため、これらの変数の1つにアクセスしたときに表示される値は、アクセス時の最新の値です。 ループの内部で作成された内部関数は、関数が作成または呼び出されたときに変数のコピーを取得するのではなく、それぞれが同じ外部変数にアクセスできるため、これが難しい理由です。</target>
        </trans-unit>
        <trans-unit id="fca46227ced34fb88ba8cfe8076a5166aafd4927" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A closure is not only created when you return an inner function.&lt;/strong&gt; In fact, the enclosing function &lt;em&gt;does not need to return at all&lt;/em&gt; in order for its closure to be created. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be called immediately or any time later. Therefore, the closure of the enclosing function is probably created &lt;em&gt;as soon as the enclosing function is called&lt;/em&gt; since any inner function has access to that closure whenever the inner function is called, before or after the enclosing function returns.</source>
          <target state="translated">&lt;strong&gt;クロージャーは、内部関数を返すときに作成されるだけではありません。&lt;/strong&gt; 実際、クロージャーを作成するために、囲んでいる関数&lt;em&gt;が戻る必要はまったくありません&lt;/em&gt; 。 代わりに、内側の関数を外側のスコープの変数に割り当てるか、それを引数として別の関数に渡して、すぐにまたは後でいつでも呼び出すことができます。 したがって、内部関数が呼び出されるときはいつでも、内部関数が呼び出されると&lt;em&gt;すぐに、&lt;/em&gt;内部関数&lt;em&gt;が呼び出されるとすぐに、&lt;/em&gt;外部関数のクロージャが作成さ&lt;em&gt;れ&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="00219869d9055a1e27de043a26f737d91e3bf84a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A simple one-line closure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;シンプルな1行の閉鎖&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="91cf9ee5cd212f0f8bb3975b7361624cdd8591da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures are simple:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;クロージャーはシンプルです：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="250c978ae2221ba3664641f80c30d217a35cbabd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures use memory, but they don't cause memory leaks&lt;/strong&gt; since JavaScript by itself cleans up its own circular structures that are not referenced. Internet&amp;nbsp;Explorer memory leaks involving closures are created when it fails to disconnect DOM attribute values that reference closures, thus maintaining references to possibly circular structures.</source>
          <target state="translated">&lt;strong&gt;クロージャはメモリを使用しますが&lt;/strong&gt; 、JavaScript自体が参照されていない独自の循環構造をクリーンアップするため、 &lt;strong&gt;メモリリークは発生しません&lt;/strong&gt; 。 クロージャを参照するDOM属性値の切断に失敗すると、クロージャを含むInternet Explorerのメモリリークが発生し、循環構造への参照が維持される可能性があります。</target>
        </trans-unit>
        <trans-unit id="39211d5634ba3cd86a1dc857711c0d8ac86b5585" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Closures&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d15f24a4f0cd805269e16daabf51293fb70abdd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Details&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Details&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e10d41f97175e0e801260eba2b8480649a3edd17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I do not understand why the answers are so complex here.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ここでなぜ答えがそれほど複雑であるのか理解できません。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a50ab2a11da4fccbf9d1c29ea600ffcd387ddf7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;INSTRUCTIONS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;INSTRUCTIONS&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ff1823b9f3f4a4211cd7c4e7170f0588c83d10b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nested functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;入れ子関数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53afa8789f0371667bc4398726df5e5b35cd9345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Once upon a time:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;昔々：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f67d2cba0fc9f06b1b71e8974beb527b1d446b34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note that in an attempt to improve clarity and accuracy, this answer has been substantially changed from the original.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;わかりやすさと正確さを向上させるために、この回答は元の回答から大幅に変更されていることに注意してください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dfa0bbb5599405ba4b579ca14868a26d8d25c5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THE LONG CODE EXAMPLE ABOVE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;上記の長いコード例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0def28abff50b5453af5effe03f21c319e75a393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5d4cedc50da37d6975ca1e41fe4dc499b53f427" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;That is pretty much all there is to closures.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;クロージャについてはこれでほぼすべてです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e361521851a8d0097ea1590fec832e52c6bc93db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &quot;variables&quot; in a closure include any named functions&lt;/strong&gt; declared within the function. They also include arguments of the function. A closure also has access to its containing closure's variables, all the way up to the global scope.</source>
          <target state="translated">&lt;strong&gt;クロージャの「変数」には、関数&lt;/strong&gt;内で宣言された&lt;strong&gt;名前付き関数&lt;/strong&gt;が&lt;strong&gt;含まれ&lt;/strong&gt;ます。 関数の引数も含まれます。 クロージャは、それを含むクロージャの変数にも、グローバルスコープまでアクセスできます。</target>
        </trans-unit>
        <trans-unit id="4531071f03fc0a5d3c0274d7c65683c8b80868b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key point:&lt;/strong&gt; Each call to &lt;code&gt;make_calculator&lt;/code&gt; creates a new local variable &lt;code&gt;n&lt;/code&gt;, which continues to be usable by that calculator's &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt; functions long after &lt;code&gt;make_calculator&lt;/code&gt; returns.</source>
          <target state="translated">&lt;strong&gt;重要なポイント：&lt;/strong&gt; &lt;code&gt;make_calculator&lt;/code&gt; を呼び出すたびに 、新しいローカル変数 &lt;code&gt;n&lt;/code&gt; が作成されます。 &lt;code&gt;make_calculator&lt;/code&gt; は、 make_calculatorが戻った後も、その計算機の &lt;code&gt;add&lt;/code&gt; 関数と &lt;code&gt;multiply&lt;/code&gt; 関数で引き続き使用できます。</target>
        </trans-unit>
        <trans-unit id="c2f004a18b07e1ba3d927ea9c5aa182e662f6312" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The whole point is to ensure that if the inner function wants to access an outer variable in the future, it is able to do so.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;重要なのは、内部関数が将来外部変数にアクセスしたい場合に確実にアクセスできるようにすることです。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9289561f1d2c7006a3223c749a580963260ce102" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;*A C# question&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;* AC＃の質問&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2907f5d699e83f056b74043078bdbf321536087f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;sup&gt;**&lt;/sup&gt; Any outer function, if several are nested, or even in the global context, as &lt;a href=&quot;https://stackoverflow.com/a/5099447/706054&quot;&gt;this answer&lt;/a&gt; points out clearly.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;sup&gt;**&lt;/sup&gt; &lt;a href=&quot;https://stackoverflow.com/a/5099447/706054&quot;&gt;この回答が&lt;/a&gt;明確に指摘しているように、いくつかのネストされている場合、またはグローバルコンテキストでさえ、任意の外部関数。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="841613276b73dfb7dcf3075c43173d44d03601fb" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;sup&gt;*&lt;/sup&gt; For example, it covers all the points in the &quot;Closures for Dummies&quot; article given in &lt;a href=&quot;https://stackoverflow.com/a/111111/706054&quot;&gt;another answer&lt;/a&gt;, except example 6, which simply shows that variables can be used before they are declared, a nice fact to know but completely unrelated to closures. It also covers all the points in &lt;a href=&quot;https://stackoverflow.com/a/111200/706054&quot;&gt;the accepted answer&lt;/a&gt;, except for the points (1) that functions copy their arguments into local variables (the named function arguments), and (2) that copying numbers creates a new number, but copying an object reference gives you another reference to the same object. These are also good to know but again completely unrelated to closures. It is also very similar to the example in &lt;a href=&quot;https://stackoverflow.com/a/111114/706054&quot;&gt;this answer&lt;/a&gt; but a bit shorter and less abstract. It does not cover the point of &lt;a href=&quot;https://stackoverflow.com/a/17200991/706054&quot;&gt;this answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17308587?noredirect=1#comment26377355_111111&quot;&gt;this comment&lt;/a&gt;, which is that JavaScript makes it difficult to plug the &lt;em&gt;current&lt;/em&gt; value of a loop variable into your inner function: The &quot;plugging in&quot; step can only be done with a helper function that encloses your inner function and is invoked on each loop iteration. (Strictly speaking, the inner function accesses the helper function's copy of the variable, rather than having anything plugged in.) Again, very useful when creating closures, but not part of what a closure is or how it works. There is additional confusion due to closures working differently in functional languages like ML, where variables are bound to values rather than to storage space, providing a constant stream of people who understand closures in a way (namely the &quot;plugging in&quot; way) that is simply incorrect for JavaScript, where variables are always bound to storage space, and never to values. &lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;sup&gt;*&lt;/sup&gt;たとえば、例6を除いて、 &lt;a href=&quot;https://stackoverflow.com/a/111111/706054&quot;&gt;別の回答&lt;/a&gt;にある「Closures for Dummies」の記事のすべてのポイントをカバーしています 。例6は、変数が宣言される前に使用できることを示しています。知っておくと便利ですが、クロージャーとはまったく関係ありません。&lt;/sup&gt; &lt;sup&gt;（1）関数が引数をローカル変数（名前付き関数の引数）にコピーする点と、（2）数値をコピーすると新しい数値が作成されるが、オブジェクト参照をコピーする点を除いて&lt;a href=&quot;https://stackoverflow.com/a/111200/706054&quot;&gt;、受け入れられた回答の&lt;/a&gt;すべての点もカバーします同じオブジェクトへの別の参照を提供します。&lt;/sup&gt; &lt;sup&gt;これらも知っておくと良いですが、ここでも閉鎖とはまったく無関係です。&lt;/sup&gt; &lt;sup&gt;また、 &lt;a href=&quot;https://stackoverflow.com/a/111114/706054&quot;&gt;この回答&lt;/a&gt;の例と非常に似ていますが、少し短く、抽象的なものではありません。&lt;/sup&gt; &lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/a/17200991/706054&quot;&gt;この回答&lt;/a&gt;または&lt;a href=&quot;https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17308587?noredirect=1#comment26377355_111111&quot;&gt;このコメント&lt;/a&gt;の要点はカバーしていません。つまり、JavaScriptはループ変数の&lt;em&gt;現在の&lt;/em&gt;値を内部関数にプラグインすることを困難にします。「プラグイン」ステップは、囲まれたヘルパー関数でのみ実行できます内部関数であり、ループの各反復で呼び出されます。&lt;/sup&gt; &lt;sup&gt;（厳密に言うと、内部関数は、プラグインされているものではなく、ヘルパー関数の変数のコピーにアクセスします。）繰り返しになりますが、クロージャーを作成するときに非常に役立ちますが、クロージャーの機能や機能の一部ではありません。&lt;/sup&gt; &lt;sup&gt;MLのような関数型言語ではクロージャーが異なる働きをするため、混乱がさらにあります。変数はストレージスペースではなく値にバインドされ、クロージャーを（つまり、「プラグイン」の方法で）理解している人々の一定の流れを提供します変数は常にストレージスペースにバインドされ、値には決してバインドされないJavaScriptの場合は単に正しくありません。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="eb8e6848b2572e4d1686265bf069ed036b474a37" translate="yes" xml:space="preserve">
          <source>A closure in JavaScript is like keeping a reference (&lt;strong&gt;NOT&lt;/strong&gt; a copy) to the scope at the point of function declaration... plus a link to all the scopes nested outside that scope.</source>
          <target state="translated">JavaScriptでのクロージャーは、関数宣言の時点でスコープへの参照（コピーではない）を保持するようなものです...加えて、そのスコープの外にネストされたすべてのスコープへのリンク。</target>
        </trans-unit>
        <trans-unit id="9374176e6956e9c55a03f208ff3b626b273cf5dc" translate="yes" xml:space="preserve">
          <source>A closure is a function that has access to another function's scope (its variables and functions). The easiest way to create a closure is with a function within a function; the reason being that in JavaScript a function always has access to its containing function&amp;rsquo;s scope.</source>
          <target state="translated">クロージャは、別の関数のスコープ（変数と関数）にアクセスできる関数です。 クロージャを作成する最も簡単な方法は、関数内の関数を使用することです。 その理由は、JavaScriptでは関数は常にそれを含む関数のスコープにアクセスできるからです。</target>
        </trans-unit>
        <trans-unit id="fd2d062c668410ccdcd9af34cc85522e6c1afaa2" translate="yes" xml:space="preserve">
          <source>A closure is a link between a function and its outer lexical (ie. as-written) environment, such that the identifiers (variables, parameters, function declarations etc) defined within that environment are visible from within the function, regardless of when or from where the function is invoked.</source>
          <target state="translated">クロージャとは、関数とその外部の語彙環境(つまり書きかけの環境)との間のリンクで、その環境内で定義された識別子(変数、パラメータ、関数宣言など)が、いつ、どこから関数が呼び出されたかに関わらず、関数内から見えるようにすることです。</target>
        </trans-unit>
        <trans-unit id="cec926b0cb259356a86639e657b14e8e1b4d0b58" translate="yes" xml:space="preserve">
          <source>A closure is created when a function is declared; this closure is used to configure the execution context when the function is invoked.</source>
          <target state="translated">関数が宣言されるとクロージャが作成され、このクロージャは、関数が呼び出されたときの実行コンテキストを構成するために使用されます。</target>
        </trans-unit>
        <trans-unit id="88f672a9df48ba5975f39c3937c757038142dc61" translate="yes" xml:space="preserve">
          <source>A closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be used immediately. Therefore, the closure of the enclosing function probably already exists at the time that enclosing function was called since any inner function has access to it as soon as it is called.</source>
          <target state="translated">閉鎖は、内包関数を返したときだけに作られるわけではありません。実際には、囲んでいる関数は返す必要は全くありません。代わりに、内部関数を外部スコープの変数に代入したり、別の関数の引数として渡したりして、すぐに使えるようにすることもできます。したがって、囲い込み関数のクロージャは、囲い込み関数が呼ばれた時点ですでに存在している可能性が高いです。</target>
        </trans-unit>
        <trans-unit id="cfc70bbb817358717b49d080b1eca649757aa359" translate="yes" xml:space="preserve">
          <source>A closure is one way of supporting &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;first-class functions&lt;/a&gt;; it is an expression that can reference variables within its scope (when it was first declared), be assigned to a variable, be passed as an argument to a function, or be returned as a function result.</source>
          <target state="translated">クロージャーは、 &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;ファーストクラスの機能&lt;/a&gt;をサポートする1つの方法です。 これは、そのスコープ内で変数を参照できる（最初に宣言されたとき）、変数に割り当てられる、関数の引数として渡される、または関数の結果として返される式です。</target>
        </trans-unit>
        <trans-unit id="0ef763764e04164186e2a1ceb3806cf6d8f2b116" translate="yes" xml:space="preserve">
          <source>A closure is where an inner function has access to variables in its outer function. That's probably the simplest one-line explanation you can get for closures.</source>
          <target state="translated">クロージャとは、内側の関数が外側の関数の変数にアクセスすることです。これがクロージャについての最もシンプルな一行説明でしょう。</target>
        </trans-unit>
        <trans-unit id="3259e0c90916fb0e4045b771243c259d5847d8f6" translate="yes" xml:space="preserve">
          <source>A function doesn't have to &lt;em&gt;return&lt;/em&gt; in order to create a closure. Simply by virtue of its declaration, every function closes over its enclosing lexical environment, forming a closure.</source>
          <target state="translated">クロージャを作成するために関数が&lt;em&gt;戻る&lt;/em&gt;必要はありません。 単にその宣言のおかげで、すべての関数は、それを囲む語彙環境を閉じて、クロージャを形成します。</target>
        </trans-unit>
        <trans-unit id="026c5616609e62af2f61992526a7c3f75658b65c" translate="yes" xml:space="preserve">
          <source>A function in JavaScript is not just a reference to a set of instructions (as in C language), but it also includes a hidden data structure which is composed of references to all nonlocal variables it uses (captured variables). Such two-piece functions are called closures. Every function in JavaScript can be considered a closure.</source>
          <target state="translated">JavaScriptの関数は、(C言語のように)命令セットへの参照だけではなく、それが使用するすべての非ローカル変数(捕捉変数)への参照で構成される隠れたデータ構造も含んでいます。このような2ピース関数はクロージャと呼ばれています。JavaScriptのすべての関数はクロージャとみなすことができます。</target>
        </trans-unit>
        <trans-unit id="5ae534cf02a5858b2d840f1a7673a1afe06d7bfc" translate="yes" xml:space="preserve">
          <source>A function normally has a name, parentheses and braces. Like this:</source>
          <target state="translated">関数には通常、名前、括弧、中括弧があります。このように</target>
        </trans-unit>
        <trans-unit id="99a4243b87430cefe6f1afae7fcb4af6221200d0" translate="yes" xml:space="preserve">
          <source>A great explanation of how closures can &lt;a href=&quot;https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited&quot;&gt;cause memory leaks in IE&lt;/a&gt; if you are not careful.</source>
          <target state="translated">注意しないと&lt;a href=&quot;https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited&quot;&gt;、IEで&lt;/a&gt;クロージャーがメモリリークを引き起こす方法についての素晴らしい説明。</target>
        </trans-unit>
        <trans-unit id="c46e219fc09ff6a6e30c8ecd75a04e05369c3ec3" translate="yes" xml:space="preserve">
          <source>A nested function may continue to live after the outer function has finished:</source>
          <target state="translated">入れ子になった関数は、外側の関数が終了した後も生き続けることができます。</target>
        </trans-unit>
        <trans-unit id="4ab1874227fa89cd67efbb317da32d2f6c6a64fd" translate="yes" xml:space="preserve">
          <source>A new set of local variables is kept every time a function is called (given that the function contains a function declaration inside it, and a reference to that inside function is either returned or an external reference is kept for it in some way).</source>
          <target state="translated">関数が呼び出されるたびに、新しいローカル変数のセットが保持されます (関数の内部に関数宣言が含まれており、その内部の関数への参照が返されるか、何らかの方法で外部参照が保持されます)。</target>
        </trans-unit>
        <trans-unit id="5efdcbea95121298d3ad2d07cbbe7dcf0db4867d" translate="yes" xml:space="preserve">
          <source>ALERT: gorilla</source>
          <target state="translated">アラート:ゴリラ</target>
        </trans-unit>
        <trans-unit id="2d25aee06019d734098a42118e386bcd1cb56358" translate="yes" xml:space="preserve">
          <source>ALERT: monkey</source>
          <target state="translated">アラート:サル</target>
        </trans-unit>
        <trans-unit id="cd6c81ca63b69c9246d861c2e95db5f815d2ca1c" translate="yes" xml:space="preserve">
          <source>ALERT: monkey
ALERT: monkey</source>
          <target state="translated">ALERT:サル ALERT:サル</target>
        </trans-unit>
        <trans-unit id="37b0eb534510d977f89353bc69e9f62a4b8877f3" translate="yes" xml:space="preserve">
          <source>After the closures come the lines</source>
          <target state="translated">閉鎖の後にはセリフが来る</target>
        </trans-unit>
        <trans-unit id="473797be1179e97465610490a5af19283b615cbe" translate="yes" xml:space="preserve">
          <source>After the loop finished and &lt;code&gt;index&lt;/code&gt; was done being modified the end value was 10, therefore every function added to the array returns the value of the single &lt;code&gt;index&lt;/code&gt; variable which is now set to 10.</source>
          <target state="translated">ループが終了して &lt;code&gt;index&lt;/code&gt; が変更された後、終了値は10でした。したがって、配列に追加されたすべての関数は、現在10に設定されている単一の &lt;code&gt;index&lt;/code&gt; 変数の値を返します。</target>
        </trans-unit>
        <trans-unit id="0c5c53c9b406b802e8050cdcb2d55f485bc7eae0" translate="yes" xml:space="preserve">
          <source>After this we have the line</source>
          <target state="translated">この後には、次のような行があります。</target>
        </trans-unit>
        <trans-unit id="b1283dc7aa9afa2d62e552768aa61cc0797578c6" translate="yes" xml:space="preserve">
          <source>All four of these functions are closures as they all access their environment.</source>
          <target state="translated">これら4つの機能は、すべて自分の環境にアクセスするため、すべてクロージャです。</target>
        </trans-unit>
        <trans-unit id="e97e0f50a5e629695aedee5a89cca10ea6b0cb28" translate="yes" xml:space="preserve">
          <source>All of the functions added to the array return the SAME &lt;code&gt;index&lt;/code&gt; variable from the parent scope where it was defined instead of 10 different ones from 10 different scopes like the first example. The end result is that all 10 functions return the same variable from the same scope.</source>
          <target state="translated">配列に追加されたすべての関数は、最初の例のような10の異なるスコープからの10の異なる変数の代わりに、それが定義された親スコープからのSAME &lt;code&gt;index&lt;/code&gt; 変数を返します。 最終的に、10個の関数すべてが同じスコープから同じ変数を返します。</target>
        </trans-unit>
        <trans-unit id="e254452976bf3a1139922787e1c255443f069708" translate="yes" xml:space="preserve">
          <source>All this data stuff sounds a bit boring, but it is really very cool; we might have a function that tells a robot what to make for dinner. Let's say I invite you and your friend to my house. You like chicken legs best, I like sausages, your friend always wants what you want and my friend does not eat meat.</source>
          <target state="translated">このようなデータの話は少し退屈に聞こえるかもしれませんが、実際にはとてもクールです。例えば、私があなたとあなたの友人を私の家に招待したとします。あなたは鶏の足が一番好きで、私はソーセージが好きで、あなたの友達はいつもあなたの好きなものを欲しがり、私の友達は肉を食べません。</target>
        </trans-unit>
        <trans-unit id="86693ebc04e6080838a0974d1c5fdd94dcf0851e" translate="yes" xml:space="preserve">
          <source>All three global functions have a common reference to the &lt;em&gt;same&lt;/em&gt; closure because they are all declared within a single call to &lt;code&gt;setupSomeGlobals()&lt;/code&gt;.</source>
          <target state="translated">3つのグローバル関数はすべて、 &lt;code&gt;setupSomeGlobals()&lt;/code&gt; への1回の呼び出しで宣言されるため、 &lt;em&gt;同じ&lt;/em&gt;クロージャへの共通の参照を持っています。</target>
        </trans-unit>
        <trans-unit id="010ea26c09769d3f5e5a4fa466cb6c5456b66f63" translate="yes" xml:space="preserve">
          <source>All variables outside the returned function are available to the returned function, but they are not directly available to the returned function object...</source>
          <target state="translated">返された関数の外にある変数はすべて返ってきた関数で利用可能ですが、返ってきた関数のオブジェクトでは直接利用できません...。</target>
        </trans-unit>
        <trans-unit id="c4594b92814cb252202666c4d92f85aa73ea246b" translate="yes" xml:space="preserve">
          <source>Also, it must be understood that local variables in JavaScript are created not on the stack frame, but on the heap and destroyed only when no one is referencing them. When a function returns, references to its local variables are decremented, but they can still be non-null if during the current execution they became part of a closure and are still referenced by its lexically nested functions (which can happen only if the references to these nested functions were returned or otherwise transferred to some external code).</source>
          <target state="translated">また、JavaScriptのローカル変数はスタックフレーム上ではなくヒープ上に作成され、誰も参照していない場合にのみ破棄されることを理解しておかなければなりません。関数が返されると、そのローカル変数への参照はデクリメントされますが、現在の実行中にクロージャの一部となり、語彙的に入れ子になった関数によって参照されている場合には、それらはまだ非 null になる可能性があります (これは、これらの入れ子になった関数への参照が返されるか、その他の方法で外部コードに転送された場合にのみ起こり得ます)。</target>
        </trans-unit>
        <trans-unit id="3bce66ad1af625b4de8c481a747409bc48008eb0" translate="yes" xml:space="preserve">
          <source>Also, this private variable state is &lt;strong&gt;fully&lt;/strong&gt; accessible, for both readings and assigning to its private scoped variables.</source>
          <target state="translated">また、このプライベート変数の状態は、読み取りとプライベートスコープ変数への割り当ての両方で、 &lt;strong&gt;完全に&lt;/strong&gt;アクセス可能です。</target>
        </trans-unit>
        <trans-unit id="4f230a19f88726fa9de2c57f5cbfa8e8e4472abd" translate="yes" xml:space="preserve">
          <source>An answer for a six-year-old (assuming he knows what a function is and what a variable is, and what data is):</source>
          <target state="translated">6歳児の答え(関数とは何か、変数とは何か、データとは何かを知っていることが前提)。</target>
        </trans-unit>
        <trans-unit id="d7b09515b9865b30af6b3fa920a76512708611e1" translate="yes" xml:space="preserve">
          <source>An example of a closure</source>
          <target state="translated">閉鎖の例</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">一例です。</target>
        </trans-unit>
        <trans-unit id="819beada86acdf2bbd115d5e1db66e6b0bee2da8" translate="yes" xml:space="preserve">
          <source>And even though the grown-ups knew of real princesses, they would never believe in the unicorns or dragons because they could never see them. The grown-ups said that they only existed inside the little girl's imagination.</source>
          <target state="translated">そして、大人たちは本物のお姫様の存在を知っていても、ユニコーンやドラゴンを見ることができないので、絶対に信じようとはしませんでした。大人たちは、それらは少女の想像の中にしか存在しないと言っていました。</target>
        </trans-unit>
        <trans-unit id="57dfb708e06183c8ecb1f0c30e96af35afaf50ba" translate="yes" xml:space="preserve">
          <source>And here is where things get really interesting. If we were to get rid of outerFunction, say set it to null, you might think that referenceToInnerFunction would loose its access to the value of outerVar. But this is not the case.</source>
          <target state="translated">ここからが本当に興味深いところです。もし outerFunction を削除した場合、例えば null に設定した場合、referenceToInnerFunction は outerVar の値へのアクセスを失うと思うかもしれません。しかし、これはそうではありません。</target>
        </trans-unit>
        <trans-unit id="435fb8d87e8d248469850188da7e2ad10deaaf3b" translate="yes" xml:space="preserve">
          <source>And if you remember, when &lt;code&gt;this.say&lt;/code&gt; is created, it (as every function) gets an internal reference &lt;code&gt;this.say.[[Scope]]&lt;/code&gt; to the current LexicalEnvironment. So, the LexicalEnvironment of the current User execution stays in memory. All variables of User also are its properties, so they are also carefully kept, not junked as usually.</source>
          <target state="translated">そして、覚えているとしたら、 &lt;code&gt;this.say&lt;/code&gt; が作成されると、（すべての関数として）現在のLexicalEnvironmentへの内部参照 &lt;code&gt;this.say.[[Scope]]&lt;/code&gt; が取得されます。 したがって、現在のユーザー実行のLexicalEnvironmentはメモリに残ります。 Userのすべての変数もそのプロパティであるため、通常のようにジャンク化されることなく、慎重に保持されます。</target>
        </trans-unit>
        <trans-unit id="625ff0ae825173e464152e82b8c8264f2701a52a" translate="yes" xml:space="preserve">
          <source>And now, even though Mary is &quot;no longer running&quot;, the memory of her is not lost and her child will always remember her name and other secrets they shared during their time together.</source>
          <target state="translated">そして今、メアリーが「走らなくなった」とはいえ、メアリーの記憶は失われることはなく、子供はメアリーの名前や、一緒にいた時に共有した秘密をいつまでも覚えています。</target>
        </trans-unit>
        <trans-unit id="dd1dc01a62936ce68f2808899afc6036354d1594" translate="yes" xml:space="preserve">
          <source>And she would often tell them of her latest amazing adventure as a princess.</source>
          <target state="translated">そして、彼女はよくお姫様としての最新の驚くべき冒険を彼らに話していました。</target>
        </trans-unit>
        <trans-unit id="b4380f96cc0e7a3c2e34bc8ce6205c32c2126439" translate="yes" xml:space="preserve">
          <source>And yes, I'd even recommend it to a 6-year old -- if the 6-year old is learning about closures, then it's logical they're ready to comprehend the &lt;em&gt;concise and simple explanation&lt;/em&gt; provided in the article.</source>
          <target state="translated">はい、6歳の方にもお勧めします。6歳の方が閉鎖について学んでいるのであれば、記事で提供されている&lt;em&gt;簡潔で簡単な説明&lt;/em&gt;を理解する準備ができているのは当然です。</target>
        </trans-unit>
        <trans-unit id="174ee1c1a9c452a97f5a4e71705d3ba0633128b2" translate="yes" xml:space="preserve">
          <source>Another really simple way to explain it is in terms of scope:</source>
          <target state="translated">もう一つの本当に簡単な説明方法は、範囲という点です。</target>
        </trans-unit>
        <trans-unit id="efcadf61fe3fe42ed34cfdd66b0ecbf1ed3408ef" translate="yes" xml:space="preserve">
          <source>Any time you create a smaller scope inside of a larger scope, the smaller scope will always be able to see what is in the larger scope.</source>
          <target state="translated">大きなスコープの中に小さなスコープを作ると、いつでも大きなスコープの中に何が入っているのか、小さなスコープの中に何が入っているのかがわかるようになります。</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="d5593bba6625e12152d79d70e57424cdd0e4f606" translate="yes" xml:space="preserve">
          <source>As a father of a 6-year-old, currently teaching young children (and a relative novice to coding with no formal education so corrections will be required), I think the lesson would stick best through hands-on play. If the 6-year-old is ready to understand what a closure is, then they are old enough to have a go themselves. I'd suggest pasting the code into jsfiddle.net, explaining a bit, and leaving them alone to concoct a unique song. The explanatory text below is probably more appropriate for a 10 year old.</source>
          <target state="translated">6歳児の父親として、現在、幼い子供たちに教えています(そして、正式な教育を受けていないコーディングの相対的な初心者なので、修正が必要になるでしょう)が、私は、このレッスンは、実際に遊ぶことを通して、最高のものになると思います。6歳児がクロージャが何であるかを理解する準備ができているならば、彼ら自身でやってみるのに十分な年齢です。jsfiddle.netにコードを貼り付けて、少し説明して、ユニークな曲を作るために彼らを一人にしておくことをお勧めします。以下の説明文は、おそらく10歳の子供にはより適切なものでしょう。</target>
        </trans-unit>
        <trans-unit id="6568100bffff0b20e0c37f88a640e7173cdcd704" translate="yes" xml:space="preserve">
          <source>As we see, &lt;code&gt;this.say&lt;/code&gt; is a property in the user object, so it continues to live after User completed.</source>
          <target state="translated">ご覧のとおり、 &lt;code&gt;this.say&lt;/code&gt; はユーザーオブジェクトのプロパティなので、ユーザーが完了した後も存続します。</target>
        </trans-unit>
        <trans-unit id="e1626c59ebd74e38dd52b09e3c12153695d67816" translate="yes" xml:space="preserve">
          <source>As you can see, the toys left in the room are still accessible via the brother and no matter if the room is locked. Here is &lt;a href=&quot;http://jsbin.com/ubakor/9/edit&quot;&gt;a jsbin&lt;/a&gt; to play around with it.</source>
          <target state="translated">ご覧のとおり、部屋に残されたおもちゃは、部屋がロックされているかどうかに関係なく、兄弟を介して引き続きアクセスできます。 ここでそれを&lt;a href=&quot;http://jsbin.com/ubakor/9/edit&quot;&gt;いじるjsbin&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="890df09169ac0377be2b819d1f924abc0cd10e89" translate="yes" xml:space="preserve">
          <source>As you may guess, because the variables are re-created every time the function is called, and nobody else will know them, there must be a secret place where they are stored. It could be called &lt;strong&gt;Chamber of Secrets&lt;/strong&gt; or &lt;strong&gt;stack&lt;/strong&gt; or &lt;strong&gt;local scope&lt;/strong&gt; but it doesn't really matter. We know they are there, somewhere, hidden in the memory.</source>
          <target state="translated">ご想像のとおり、関数が呼び出されるたびに変数が再作成され、他の誰もそれらを知らないため、変数が格納される秘密の場所が必要です。 それ&lt;strong&gt;は秘密の部屋&lt;/strong&gt;または&lt;strong&gt;スタック&lt;/strong&gt;または&lt;strong&gt;ローカルスコープ&lt;/strong&gt;と呼ばれるかもしれませんが、それは本当に問題ではありません。 私たちは、彼らが記憶のどこかに隠れていることを知っています。</target>
        </trans-unit>
        <trans-unit id="986da2f4d4b325d9fb2c07a7e2b3897081cd863a" translate="yes" xml:space="preserve">
          <source>BRACES: &quot;Braces&quot; which look like this &lt;code&gt;{}&lt;/code&gt; are the tinted windows of our factory. From inside the factory you can see out, but from the outside you can't see in.</source>
          <target state="translated">ブレース：このように見える「ブレース」 &lt;code&gt;{}&lt;/code&gt; は、工場の色付きの窓です。 工場の中からは見えますが、外からは見えません。</target>
        </trans-unit>
        <trans-unit id="3575d07a466999847f383f17914159e3dbdd22b0" translate="yes" xml:space="preserve">
          <source>BROWSER: When you connect to the Internet on a computer, tablet or phone to visit a website, you use a browser. Examples you may know are Internet Explorer, Chrome, Firefox and Safari. The browser can understand JavaScript and tell the computer what it needs to do. The JavaScript instructions are called functions.</source>
          <target state="translated">ブラウザ:コンピュータやタブレット、携帯電話などでインターネットに接続してウェブサイトを閲覧する場合、ブラウザを使用します。ご存知の例としては、Internet Explorer、Chrome、Firefox、Safariなどがあります。ブラウザはJavaScriptを理解して、コンピュータに必要なことを指示することができます。このJavaScriptの指示を関数と呼びます。</target>
        </trans-unit>
        <trans-unit id="0419e91da10b803e76b92f8dffe5555643e1dd03" translate="yes" xml:space="preserve">
          <source>Because all these external variables referenced by a lexically nested function are actually local variables in the chain of its lexically enclosing functions (global variables can be assumed to be local variables of some root function), and every single execution of a function creates new instances of its local variables, it follows that every execution of a function returning (or otherwise transferring it out, such as registering it as a callback) a nested function creates a new closure (with its own potentially unique set of referenced nonlocal variables which represent its execution context).</source>
          <target state="translated">なぜなら、語彙的に入れ子にされた関数によって参照されるこれらの外部変数はすべて、実際には、その語彙的に入れ子にされた関数のチェーン内のローカル変数であり(グローバル変数は、何らかのルート関数のローカル変数であると仮定することができます)、関数を実行するたびに、そのローカル変数の新しいインスタンスが生成されるからです。</target>
        </trans-unit>
        <trans-unit id="42668682fc7dcf2769407c41fc937cdbf7dd8025" translate="yes" xml:space="preserve">
          <source>Because there was only one scope within the &lt;code&gt;createClosureArray()&lt;/code&gt; function, &lt;code&gt;index&lt;/code&gt; is only bound to a value within that scope. In other words, each time the loop changes the value of &lt;code&gt;index&lt;/code&gt;, it changes it for everything that references it within that scope.</source>
          <target state="translated">&lt;code&gt;createClosureArray()&lt;/code&gt; 関数内にはスコープが1つしかなかったため、 &lt;code&gt;index&lt;/code&gt; はそのスコープ内の値にのみバインドされます。 つまり、ループは &lt;code&gt;index&lt;/code&gt; の値を変更するたびに、そのスコープ内でそれを参照するすべての値を変更します。</target>
        </trans-unit>
        <trans-unit id="14c3a147917bc6f80510553c690b0ab8c8718635" translate="yes" xml:space="preserve">
          <source>But all they would see is a little girl...</source>
          <target state="translated">しかし、彼らの目に映るのは小さな女の子ばかり...。</target>
        </trans-unit>
        <trans-unit id="bb8c57c634a563056b164f5aeb01e4ac8232dc6d" translate="yes" xml:space="preserve">
          <source>But how is this so? How can referenceToInnerFunction still know the value of outerVar now that outerFunction has been set to null?</source>
          <target state="translated">しかし、どのようにしてそうなるのでしょうか?outerFunctionがnullに設定された今でも、どうやってreferenceToInnerFunctionが outerVarの値を知ることができるのでしょうか?</target>
        </trans-unit>
        <trans-unit id="146180db52e416274e24ed731f90ff6fc5ad3201" translate="yes" xml:space="preserve">
          <source>But she would always have to return back to her dull world of chores and grown-ups.</source>
          <target state="translated">しかし、彼女はいつまでたっても家事と大人の冴えない世界に戻らなければならない。</target>
        </trans-unit>
        <trans-unit id="866ff54f49d509edc499efd08ef16cd5aed44ee7" translate="yes" xml:space="preserve">
          <source>But the sad thing is, if the child is also a private variable of its parent function, it would also die when the parent ends, and the secrets would die with them.</source>
          <target state="translated">しかし、悲しいことに、子も親関数のプライベート変数になっていると、親が終了したときに子も一緒に死んでしまい、秘密も一緒に死んでしまうのです。</target>
        </trans-unit>
        <trans-unit id="dbf03411a9d8f9c4e1de5345b3a10c168dfc2df8" translate="yes" xml:space="preserve">
          <source>But we know the real truth; that the little girl with the princess inside...</source>
          <target state="translated">しかし、私たちは本当の真実を知っています。お姫様の中にいる少女のことを...</target>
        </trans-unit>
        <trans-unit id="a343ea5602007ce993e1966d841864424094a57f" translate="yes" xml:space="preserve">
          <source>But, in JavaScript there is this very special thing that functions which are created inside other functions, can also know the local variables of their parents and keep them as long as they live.</source>
          <target state="translated">しかし、JavaScriptでは、他の関数の内部で作成された関数も、その親のローカル変数を知っていて、生きている限りそれを保持することができるという、非常に特別なことがあります。</target>
        </trans-unit>
        <trans-unit id="5d22ad9eb11c8d7544b41c9fd9c72490630172cd" translate="yes" xml:space="preserve">
          <source>CLOSURES DONE RIGHT</source>
          <target state="translated">〆切り</target>
        </trans-unit>
        <trans-unit id="b8c469b8120b44b5dd72fc632091339193c9122a" translate="yes" xml:space="preserve">
          <source>CLOSURES DONE WRONG</source>
          <target state="translated">〆切の間違い</target>
        </trans-unit>
        <trans-unit id="3344264f6f33fcb6fbcf186f0b6ad57482d348ae" translate="yes" xml:space="preserve">
          <source>CLOSURES: The closures are the smaller functions that are inside the big &lt;em&gt;sing()&lt;/em&gt; function. The little factories inside the big factory. They each have their own braces which mean that the variables inside them can't be seen from the outside. That's why the names of the variables (&lt;em&gt;creature&lt;/em&gt; and &lt;em&gt;result&lt;/em&gt;) can be repeated in the closures but with different values. If you type these variable names in the console window, you won't get its value because it's hidden by two layers of tinted windows.</source>
          <target state="translated">クロージャ：クロージャは、大きな&lt;em&gt;sing（）&lt;/em&gt;関数内にある小さな関数です。 大きな工場内の小さな工場。 それらにはそれぞれ独自のブレースがあり、それらの内部の変数は外部から見ることができません。 変数の名前（ &lt;em&gt;creature&lt;/em&gt;と&lt;em&gt;result&lt;/em&gt; ）はクロージャーで繰り返し使用できますが、値が異なるのはそのためです。 これらの変数名をコンソールウィンドウに入力すると、色付きのウィンドウの2つのレイヤーによって非表示になるため、その値は取得されません。</target>
        </trans-unit>
        <trans-unit id="76ad173357129e5535c24cd674bddfaff61e8338" translate="yes" xml:space="preserve">
          <source>CODE: All the writing above is called &lt;em&gt;code&lt;/em&gt;. It is written in JavaScript.</source>
          <target state="translated">コード：上記のすべての記述は&lt;em&gt;コード&lt;/em&gt;と呼ばれ&lt;em&gt;ます&lt;/em&gt; 。 JavaScriptで書かれています。</target>
        </trans-unit>
        <trans-unit id="a0c7bc52b3fa8bb1b47ad931aa67baef1da44403" translate="yes" xml:space="preserve">
          <source>Can anybody consider that I am 6 and strangely interested in that subject ?</source>
          <target state="translated">誰もが私が6であることを考慮することができますし、奇妙にその主題に興味を持っている?</target>
        </trans-unit>
        <trans-unit id="0754a0ac49d4de7ab61d6c51b9280396aeeb0c9d" translate="yes" xml:space="preserve">
          <source>Can you explain closures to a 5-year-old?*</source>
          <target state="translated">5歳児にクロージングを説明できますか?</target>
        </trans-unit>
        <trans-unit id="c6abb0edfb41f4eed3192a92b93e8777584cfbc6" translate="yes" xml:space="preserve">
          <source>Closures are &lt;em&gt;not hard&lt;/em&gt; to understand once the core concept is grokked. However, they are impossible to understand by reading any theoretical or academically oriented explanations!</source>
          <target state="translated">中核となるコンセプトが理解できれば、クロージャーは理解しやすくなります。 ただし、理論的または学問的な説明を読んで理解することはできません。</target>
        </trans-unit>
        <trans-unit id="473e3864991bcdfffaa54377115d58425884b1de" translate="yes" xml:space="preserve">
          <source>Closures are a way to let a function
  have &lt;strong&gt;persistent, private variables&lt;/strong&gt; -
  that is, variables that only one
  function knows about, where it can
  keep track of info from previous times
  that it was run.</source>
          <target state="translated">クロージャーは、関数に&lt;strong&gt;永続的でプライベートな変数を&lt;/strong&gt;持たせる方法です。つまり、1つの関数だけが知っている変数で、実行された以前の情報を追跡できます。</target>
        </trans-unit>
        <trans-unit id="2dab57988b39942ebe3792aab7459b19fb524730" translate="yes" xml:space="preserve">
          <source>Closures are functions with a state. It is somewhat similar to &quot;this&quot; in the sense that &quot;this&quot; also provides state for a function but function and &quot;this&quot; are separate objects (&quot;this&quot; is just a fancy parameter, and the only way to bind it permanently to a function is to create a closure). While &quot;this&quot; and function always live separately, a function cannot be separated from its closure and the language provides no means to access captured variables.</source>
          <target state="translated">クロージャは状態を持つ関数です。this &quot;もまた関数に状態を提供しますが、関数と &quot;this &quot;は別のオブジェクトです(&quot;this &quot;は単なる空想のパラメータであり、それを関数に恒久的にバインドする唯一の方法はクロージャを作成することです)。this &quot;と関数は常に別々に存在していますが、関数はクロージャから切り離すことはできません。</target>
        </trans-unit>
        <trans-unit id="9a8fe763a050a9c6f2b9d029f15de875acec4c6c" translate="yes" xml:space="preserve">
          <source>Closures are hard to explain because they are used to make some behaviour work that everybody intuitively expects to work anyway. I find the best way to explain them (and the way that &lt;em&gt;I&lt;/em&gt; learned what they do) is to imagine the situation without them:</source>
          <target state="translated">クロージャは、誰もがとにかく直感的に機能することを期待する動作を機能させるために使用されるため、説明が困難です。 それらを説明する最良の方法（および&lt;em&gt;私が&lt;/em&gt;彼らが何をするか&lt;em&gt;を&lt;/em&gt;学んだ方法）は、それらのない状況を想像することです：</target>
        </trans-unit>
        <trans-unit id="13cd6611b47d0c0e96535f2857655ffbc4aec970" translate="yes" xml:space="preserve">
          <source>Closures are not magic</source>
          <target state="translated">閉じ込めは魔法ではない</target>
        </trans-unit>
        <trans-unit id="81857059bb8f6b3c5d16c47af8818ad9c8d4ef06" translate="yes" xml:space="preserve">
          <source>Closures are often used for creating functions with some hidden private data (but it's not always the case).</source>
          <target state="translated">クロージャは、いくつかのプライベートデータが隠された関数を作成する際によく使われます(ただし、必ずしもそうとは限りません)。</target>
        </trans-unit>
        <trans-unit id="f1f2dd80b45193a64a6fed6f703fea1610ee7907" translate="yes" xml:space="preserve">
          <source>Closures done right:</source>
          <target state="translated">閉じ込めは正しく行われています。</target>
        </trans-unit>
        <trans-unit id="2b5870c633c063933016ddcafff1a5b85221b713" translate="yes" xml:space="preserve">
          <source>Closures done wrong:</source>
          <target state="translated">閉じ込めが間違っていた</target>
        </trans-unit>
        <trans-unit id="65f3c9fe79ec9c90973a968f76051ad6208d1eff" translate="yes" xml:space="preserve">
          <source>Compare with a situation when a door was locked by draft and nobody inside (general function execution), and then some local fire occur and burn down the room (garbage collector:D), and then a new room was build and now you may leave another toys there (new function instance), but never get the same toys which were left in the first room instance.</source>
          <target state="translated">ドアがドラフトでロックされていて中に誰もいない場合(一般的な関数の実行)と、その後、いくつかのローカル火災が発生し、部屋を焼き払った場合(ゴミコレクタ:D)と比較して、新しい部屋が構築され、今、あなたはそこに別のおもちゃを残すことができます(新しい関数のインスタンス)が、最初の部屋のインスタンスに残されたのと同じおもちゃを取得することはありません。</target>
        </trans-unit>
        <trans-unit id="895fc54743a0a38a6edff320b747a9f3e67aa96b" translate="yes" xml:space="preserve">
          <source>Consider this option</source>
          <target state="translated">このオプションを検討する</target>
        </trans-unit>
        <trans-unit id="d29543a41f8e03fb1f0ca60d30879d8d14612042" translate="yes" xml:space="preserve">
          <source>DATA: Data is a collection of facts. It can be numbers, words, measurements, observations or even just descriptions of things. You can't touch it, smell it or taste it. You can write it down, speak it and hear it. You could use it to &lt;em&gt;create&lt;/em&gt; touch smell and taste using a computer. It can be made useful by a computer using code.</source>
          <target state="translated">データ：データはファクトのコレクションです。 数字、単語、測定値、観察結果、または単なる説明です。 触ったり、匂ったり、味わったりすることはできません。 あなたはそれを書き留め、それを話し、それを聞くことができます。 コンピューターを使用して、タッチの香りと味を&lt;em&gt;作成するために&lt;/em&gt;使用できます。 コードを使用してコンピュータで便利にできます。</target>
        </trans-unit>
        <trans-unit id="1386ebeed6520345b3b7b8e117496e328fb4ca5d" translate="yes" xml:space="preserve">
          <source>Dan invites Paul.
Dan asks Paul to bring one controller. How many controllers were brought to the party?</source>
          <target state="translated">ダンがポールを誘う。ダンはポールにコントローラーを1つ持ってくるように頼みます。パーティーには何台のコントローラーが持ってきたのか?</target>
        </trans-unit>
        <trans-unit id="ec2a42fc389ecb1dc4b9d0c461e02170df77d766" translate="yes" xml:space="preserve">
          <source>Douglas Crockford's simulated &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;private attributes and private methods&lt;/a&gt; for an object, using closures.</source>
          <target state="translated">Douglas Crockfordに&lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;よる、&lt;/a&gt;クロージャーを使用した、オブジェクトのプライベート属性とプライベートメソッドのシミュレーション。</target>
        </trans-unit>
        <trans-unit id="1f5d96dd43fe4410f4d7bee1eb9596663a115a2d" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;makeKitchen()&lt;/code&gt; is called, a new closure is created with its own separate &lt;code&gt;trashBags&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;makeKitchen()&lt;/code&gt; が呼び出される &lt;code&gt;trashBags&lt;/code&gt; 、独自の個別のtrashBagsで新しいクロージャーが作成されます。</target>
        </trans-unit>
        <trans-unit id="be4a4610d526a11fb6ad4a43add51b702b4757b8" translate="yes" xml:space="preserve">
          <source>Environment, which includes:</source>
          <target state="translated">を含む環境。</target>
        </trans-unit>
        <trans-unit id="d753a72a73e7b9b72686150b4751eec2271aff2d" translate="yes" xml:space="preserve">
          <source>Every function call creates a closure, but there would be no need to keep the closure around unless an inner function, which has access to the inside of the closure, can be called from outside the closure.  Returning the object with the &lt;code&gt;getTrashBag&lt;/code&gt; function does that here.</source>
          <target state="translated">すべての関数呼び出しはクロージャーを作成しますが、クロージャーの内部にアクセスできる内部関数がクロージャーの外部から呼び出されない限り、クロージャーを保持する必要はありません。 &lt;code&gt;getTrashBag&lt;/code&gt; 関数でオブジェクトを返すと、ここでそれが行われます。</target>
        </trans-unit>
        <trans-unit id="2df597c03eb2e94c01cea766bc9c9a3fbe100af1" translate="yes" xml:space="preserve">
          <source>Every function creates a closure because every function has a link to its outer lexical environment.</source>
          <target state="translated">すべての関数がクロージャを作成するのは、すべての関数がその外部語彙環境へのリンクを持っているからです。</target>
        </trans-unit>
        <trans-unit id="859b310d2eaece93608e0e89cc61e86978cb69a4" translate="yes" xml:space="preserve">
          <source>Every function in JavaScript maintains a link to its outer lexical environment. A lexical environment is a map of all the names (eg. variables, parameters) within a scope, with their values.</source>
          <target state="translated">JavaScript のすべての関数は、外部の辞書環境へのリンクを保持しています。字句環境とは、スコープ内のすべての名前 (変数やパラメータなど)とその値のマップのことです。</target>
        </trans-unit>
        <trans-unit id="45ace4e4578d45cf9975840a42650a40883c1e4a" translate="yes" xml:space="preserve">
          <source>Every time you call it, local variable &quot;name&quot; is created and given name &quot;Mary&quot;. And every time the function exits the variable is lost and the name is forgotten.</source>
          <target state="translated">呼び出すたびに、ローカル変数 &quot;name &quot;が作成され、名前 &quot;Mary &quot;が与えられます。そして、関数が終了するたびに変数は失われ、名前は忘れられます。</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="translated">例3</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="translated">例4</target>
        </trans-unit>
        <trans-unit id="dcb2a7f833e9a3ee29881cf3f00069ceeab20571" translate="yes" xml:space="preserve">
          <source>Example 5</source>
          <target state="translated">例5</target>
        </trans-unit>
        <trans-unit id="69126e599801a8577cf34e537a3e5b119797d966" translate="yes" xml:space="preserve">
          <source>Example 6</source>
          <target state="translated">例6</target>
        </trans-unit>
        <trans-unit id="5da743f6856f59f85c81f30e766731f5631a39c2" translate="yes" xml:space="preserve">
          <source>Example 7</source>
          <target state="translated">例7</target>
        </trans-unit>
        <trans-unit id="6f1ddb45d4ea126c3c0d9697dd3671172ae3bca1" translate="yes" xml:space="preserve">
          <source>Example for the first point by dlaliberte:</source>
          <target state="translated">dlaliberteによる1点目の例。</target>
        </trans-unit>
        <trans-unit id="9726b2f5643205ff1a7ab0c75e5e5eb34bbe5072" translate="yes" xml:space="preserve">
          <source>Example of a closure that uses the global environment:</source>
          <target state="translated">グローバル環境を利用したクロージャの例。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="e262aa4c560f1ae35fd6e5cf5ac45462ea46ecc8" translate="yes" xml:space="preserve">
          <source>F12</source>
          <target state="translated">F12</target>
        </trans-unit>
        <trans-unit id="770cc5fbad4b752ed78f4565ed7a44533e740e5d" translate="yes" xml:space="preserve">
          <source>FOREWORD: this answer was written when the question was:</source>
          <target state="translated">序文:この回答は質問があった時に書かれたものです。</target>
        </trans-unit>
        <trans-unit id="23ddff2ba060d9ccf1c6bed76f90cfb75043258a" translate="yes" xml:space="preserve">
          <source>FUNCTION: A function in JavaScript is like a factory. It might be a little factory with only one machine inside. Or it might contain many other little factories, each with many machines doing different jobs. In a real life clothes factory you might have reams of cloth and bobbins of thread going in and T-shirts and jeans coming out. Our JavaScript factory only processes data, it can't sew, drill a hole or melt metal. In our JavaScript factory data goes in and data comes out.</source>
          <target state="translated">FUNCTION:JavaScriptの関数は工場のようなものです。それは、内部に1台のマシンだけがある小さな工場かもしれません。また、工場の中にはたくさんの小さな工場があり、それぞれが異なる仕事をしている機械がたくさんあります。実際の洋服の工場では、たくさんの布や糸が入ってきて、Tシャツやジーンズが出てくるかもしれません。私たちの JavaScript ファクトリーはデータを処理するだけで、縫ったり、穴を開けたり、金属を溶かしたりすることはできません。JavaScript ファクトリーでは、データが入ってきて、データが出てきます。</target>
        </trans-unit>
        <trans-unit id="8084a292fef2035ee22a2314d1fd8d2ea5ef70cc" translate="yes" xml:space="preserve">
          <source>Fairly Obvious Solution</source>
          <target state="translated">かなり明白な解決策</target>
        </trans-unit>
        <trans-unit id="8d7ca8f60d208999584a7667dd568dbdc67e89aa" translate="yes" xml:space="preserve">
          <source>Final points:</source>
          <target state="translated">最終的には</target>
        </trans-unit>
        <trans-unit id="0db6ddf1596c4847d4487ff8d0eb1324a650d77c" translate="yes" xml:space="preserve">
          <source>First, when a function f is created, it is not created in an empty
space. There is a current LexicalEnvironment object. In the case
above, it&amp;rsquo;s window (a is undefined at the time of function
creation).</source>
          <target state="translated">まず、関数fを作成しても、空の空間には作成されません。 現在のLexicalEnvironmentオブジェクトがあります。 上記の場合、それはウィンドウです（aは関数作成時に未定義です）。</target>
        </trans-unit>
        <trans-unit id="2a73ef77ff6936404496b87ca2548febfdec5ccf" translate="yes" xml:space="preserve">
          <source>For an advanced child I would put something like the following. It is not perfect, but it makes you feel about what it is:</source>
          <target state="translated">上級者の子には以下のようなものを入れます。完璧ではありませんが、それが何なのかを感じさせてくれます。</target>
        </trans-unit>
        <trans-unit id="ea9adb725d4b9bd42aa2bf3daca3985abf217214" translate="yes" xml:space="preserve">
          <source>For some reason, closures seem really hard to understand when you read about them, but when you see some examples, it becomes clear how they work (it took me a while).
I recommend working through the examples carefully until you understand how they work. If you start using closures without fully understanding how they work, you would soon create some very weird bugs!</source>
          <target state="translated">なぜかクローゼットは、読んでいるととても難しく感じますが、いくつかの例を見てみると、その仕組みがはっきりしてきます(時間がかかりました)。私は、仕組みを理解するまで、注意深く例を見ながら作業することをお勧めします。もし、クロージャの仕組みを完全に理解せずに使い始めると、すぐに変なバグを作ってしまうでしょう。</target>
        </trans-unit>
        <trans-unit id="a6457c5f7670ec3d5b6eba35695e935bfa1d35af" translate="yes" xml:space="preserve">
          <source>Full post:</source>
          <target state="translated">フルポスト。</target>
        </trans-unit>
        <trans-unit id="086a1f90a0a0f91e7d5f1400d0b9f2eaa0c70efd" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;bar&lt;/code&gt;, together with its link with the lexical environment of function &lt;code&gt;foo&lt;/code&gt; is a closure.</source>
          <target state="translated">関数 &lt;code&gt;bar&lt;/code&gt; は、関数 &lt;code&gt;foo&lt;/code&gt; の字句環境とのリンクとともにクロージャです。</target>
        </trans-unit>
        <trans-unit id="df465d5385e7a5492e6da9185d4edd6ca0741d1e" translate="yes" xml:space="preserve">
          <source>Functions can be nested one inside another, forming a chain of LexicalEnvironments which can also be called a scope chain.</source>
          <target state="translated">関数を互いに入れ子にして LexicalEnvironments のチェーンを形成することもできますが、これはスコープチェーンとも呼ばれます。</target>
        </trans-unit>
        <trans-unit id="735a10dcfecac98bd4863f42c020b050d39de8ff" translate="yes" xml:space="preserve">
          <source>Functions can return data. One kind of data you can return from a function is another function. When that new function gets returned, all the variables and arguments used in the function that created it don't go away. Instead, that parent function &quot;closes.&quot; In other words, nothing can look inside of it and see the variables it used except for the function it returned. That new function has a special ability to look back inside the function that created it and see the data inside of it.</source>
          <target state="translated">関数はデータを返すことができます。関数から返すことができるデータの種類の一つは、別の関数です。その新しい関数が返されても、その関数を作った関数で使われていたすべての変数と引数は消えません。その代わりに、その親関数は &quot;クローズ &quot;します。言い換えれば、返された関数以外は、何も内部を見ることができず、その関数が使用した変数を見ることができないということです。その新しい関数は、その関数を作成した関数の内部を見返して、その関数の内部のデータを見ることができる特別な能力を持っています。</target>
        </trans-unit>
        <trans-unit id="d6e834997432ff006f3ca11dc3e560bb2b2db750" translate="yes" xml:space="preserve">
          <source>Functions define actions  - the main function is about singing. It contains a variable called &lt;em&gt;firstPart&lt;/em&gt; which applies to the singing about the person that applies to each of the verses of the song: &quot;There was &quot; + person + &quot; who swallowed&quot;. If you type &lt;em&gt;firstPart&lt;/em&gt; into the console, you won't get an answer because the variable is locked up in a function - the browser can't see inside the tinted windows of the braces.</source>
          <target state="translated">関数はアクションを定義します-主な関数は歌うことです。 これには、歌の各詩に当てはまる人についての歌唱に当てはまる&lt;em&gt;firstPart&lt;/em&gt;と呼ばれる変数が含まれています。「飲み込まれた+人+がありました」。 コンソールに&lt;em&gt;firstPart&lt;/em&gt;と入力すると、変数が関数内でロックされているため、応答が得られません。ブラウザは、ブレースの色付きのウィンドウ内を見ることができません。</target>
        </trans-unit>
        <trans-unit id="3ddedd19f21650712b05b0d15a1aaf5ed1d17916" translate="yes" xml:space="preserve">
          <source>Further points that explain why closures are interesting:</source>
          <target state="translated">クローズが面白い理由をさらに説明するポイント</target>
        </trans-unit>
        <trans-unit id="09cf114b1e0fe4fe38544c7a0d90cf0e556abc15" translate="yes" xml:space="preserve">
          <source>GLOBAL VARIABLE: &lt;em&gt;person&lt;/em&gt; is a global variable, meaning that if you change its value from &quot;an old lady&quot; to &quot;a young man&quot;, the &lt;em&gt;person&lt;/em&gt; will keep being a young man until you decide to change it again and that any other function in the code can see that it's a young man. Press the</source>
          <target state="translated">グローバル変数： &lt;em&gt;person&lt;/em&gt;はグローバル変数です。つまり、その値を「老婦人」から「若い男」に変更すると、その&lt;em&gt;人&lt;/em&gt;は再び変更することを決定し、その他の機能がコードは、それが若い男であることがわかります。 を押す</target>
        </trans-unit>
        <trans-unit id="25334edab2e807f8912b0462c0c1d557fdc5ebe8" translate="yes" xml:space="preserve">
          <source>Get it? So in our primary example, the count variable is contained within the closure and always available to the event handler, so it retains its state from click to click.</source>
          <target state="translated">分かりましたか?第一の例では、count変数はクロージャ内に含まれており、イベントハンドラで常に利用可能であるため、クリックからクリックまでの間、その状態を保持します。</target>
        </trans-unit>
        <trans-unit id="2a0bf64067ba96e19feb251aca269629de4b6291" translate="yes" xml:space="preserve">
          <source>Here is a closure:</source>
          <target state="translated">ここで締めくくりです。</target>
        </trans-unit>
        <trans-unit id="bcaab99f4090d108eb398f8a65a144183fe65bee" translate="yes" xml:space="preserve">
          <source>Here is a factory that produces calculators that can add and multiply:</source>
          <target state="translated">足し算・掛け算ができる電卓を製造している工場がここにあります。</target>
        </trans-unit>
        <trans-unit id="26c03c6b51995ce3cc45717ecfc54ea15182bfb0" translate="yes" xml:space="preserve">
          <source>Here is how I can convert my plane story into the code.</source>
          <target state="translated">ここでは、私の飛行機のストーリーをコードに変換する方法を紹介します。</target>
        </trans-unit>
        <trans-unit id="542541ad020f39c0dd65066d67e5d1be86126656" translate="yes" xml:space="preserve">
          <source>Here is the summary:</source>
          <target state="translated">以下、まとめです。</target>
        </trans-unit>
        <trans-unit id="880f763de0c8735d3a294c36e5df6df573d7c52c" translate="yes" xml:space="preserve">
          <source>Here's one of the examples:</source>
          <target state="translated">その一例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="5f5bf51aa2f2759a4b08230274e714f3e06de685" translate="yes" xml:space="preserve">
          <source>How I'd explain it to a six-year-old:</source>
          <target state="translated">6歳児にどう説明するかだな</target>
        </trans-unit>
        <trans-unit id="2e459856108a5cecf40e139f74b817f2e5e4faa0" translate="yes" xml:space="preserve">
          <source>How do JavaScript closures work</source>
          <target state="translated">JavaScript のクロージャはどのように動作するのか</target>
        </trans-unit>
        <trans-unit id="31c4f787c21a33dcc90753d93c735b54274f39d7" translate="yes" xml:space="preserve">
          <source>How would you explain JavaScript closures to someone with a knowledge of the concepts they consist of (for example functions, variables and the like), but does not understand closures themselves?</source>
          <target state="translated">JavaScriptのクロージャを、それらが構成する概念(例えば、関数や変数など)を知っていながら、クロージャ自体を理解していない人にどのように説明するのでしょうか?</target>
        </trans-unit>
        <trans-unit id="d0b12b69fd5500aab9c9d2b4a9addddfd30dacaf" translate="yes" xml:space="preserve">
          <source>However, since &lt;code&gt;tmp&lt;/code&gt; is still hanging around inside &lt;code&gt;bar&lt;/code&gt;'s closure, it is available to be incremented. It will be incremented each time you call &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;tmp&lt;/code&gt; はまだ &lt;code&gt;bar&lt;/code&gt; のクロージャー内にぶら下がっているので、インクリメントできます。 &lt;code&gt;bar&lt;/code&gt; を呼び出すたびにインクリメントされます 。</target>
        </trans-unit>
        <trans-unit id="be9d4d94dd6f35953099bde147c591bdd84ed51a" translate="yes" xml:space="preserve">
          <source>I have seen &lt;a href=&quot;http://en.wikipedia.org/wiki/Scheme_%28programming_language%29&quot;&gt;the Scheme example&lt;/a&gt; given on Wikipedia, but unfortunately it did not help.</source>
          <target state="translated">Wikipediaに&lt;a href=&quot;http://en.wikipedia.org/wiki/Scheme_%28programming_language%29&quot;&gt;あるSchemeの例&lt;/a&gt;を見たことがありますが、残念ながら役に立ちませんでした。</target>
        </trans-unit>
        <trans-unit id="c32c4a2db55c3bb615ab0b8d8acc3b66dadcac7d" translate="yes" xml:space="preserve">
          <source>I haven't got time to go shopping, so the function needs to know what we have in the fridge to make decisions. Each ingredient has a different cooking time and we want everything to be served hot by the robot at the same time. We need to provide the function with the data about what we like, the function could 'talk' to the fridge, and the function could control the robot.</source>
          <target state="translated">買い物に行く時間がないので、冷蔵庫に何があるかを知って判断する必要があります。それぞれの食材には異なる調理時間があり、すべての食材を同時にロボットが熱々の状態で提供してくれます。私たちが好きなものについてのデータを機能に提供する必要があり、機能は冷蔵庫に「話しかける」ことができ、機能はロボットを制御することができます。</target>
        </trans-unit>
        <trans-unit id="f67fa89b4f0fa9a4f122d225bd2121614d8b9416" translate="yes" xml:space="preserve">
          <source>I know there are plenty of solutions already, but I guess that this small and simple script can be useful to demonstrate the concept:</source>
          <target state="translated">すでに解決策はいくらでもあると思いますが、この小さくてシンプルなスクリプトがコンセプトを実証するのに役立つのではないでしょうか。</target>
        </trans-unit>
        <trans-unit id="68c15dba4a700bb7a32cb7aad9a30cdd109d35e6" translate="yes" xml:space="preserve">
          <source>I need to know how many times a button has been clicked and do something on every third click...</source>
          <target state="translated">ボタンが何回クリックされたかを知り、3回目のクリックごとに何かをする必要があります...。</target>
        </trans-unit>
        <trans-unit id="1729e172673bb9af9294d6a61fc1a00e839e1311" translate="yes" xml:space="preserve">
          <source>I put together an interactive JavaScript tutorial to explain how closures work.
&lt;a href=&quot;http://nathansjslessons.appspot.com&quot;&gt;What's a Closure?&lt;/a&gt;</source>
          <target state="translated">インタラクティブなJavaScriptチュートリアルをまとめて、クロージャーの仕組みを説明します。 &lt;a href=&quot;http://nathansjslessons.appspot.com&quot;&gt;クロージャとは？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="123fc03a330a7c38723bf7555ca4ff7a80024826" translate="yes" xml:space="preserve">
          <source>I still think &lt;a href=&quot;http://code.google.com/apis/ajax/playground/?exp=maps#closure_simple&quot;&gt;Google's explanation&lt;/a&gt; works very well and is concise:</source>
          <target state="translated">私は今でも&lt;a href=&quot;http://code.google.com/apis/ajax/playground/?exp=maps#closure_simple&quot;&gt;Googleの説明&lt;/a&gt;は非常にうまく機能し、簡潔であると思います ：</target>
        </trans-unit>
        <trans-unit id="0b506f3eb42bcf394c48e9df2a2bec6ef476dbaa" translate="yes" xml:space="preserve">
          <source>I suspect that closures in JavaScript differ from those normally found in functional languages.</source>
          <target state="translated">JavaScriptのクロージャは、関数型言語で通常見られるクロージャとは異なるのではないかと思います。</target>
        </trans-unit>
        <trans-unit id="24dbc47ee46dbf67b52513fbd1c704c76d217b00" translate="yes" xml:space="preserve">
          <source>I tend to learn better by GOOD/BAD comparisons. I like to see working code followed by non-working code that someone is likely to encounter. I put together &lt;a href=&quot;http://jsfiddle.net/KMQZK/&quot;&gt;a jsFiddle&lt;/a&gt; that does a comparison and tries to boil down the differences to the simplest explanations I could come up with.</source>
          <target state="translated">私は良い/悪い比較でよりよく学ぶ傾向があります。 動作しているコードに続いて、誰かが遭遇する可能性のある動作していないコードを見たいと思います。 比較を&lt;a href=&quot;http://jsfiddle.net/KMQZK/&quot;&gt;行うjsFiddle&lt;/a&gt;をまとめて、考えられる最も単純な説明に違いを取り除きます。</target>
        </trans-unit>
        <trans-unit id="4b2d52788d16d1aed76a99b2962dd7f9b814a6e8" translate="yes" xml:space="preserve">
          <source>I think normally a closure is a term for both the function along with a captured variable environment. Note that I do not use that definition in this article!</source>
          <target state="translated">通常、クロージャとは、関数とキャプチャされた変数環境の両方を指す言葉だと思います。この記事ではその定義を使用していないことに注意してください!</target>
        </trans-unit>
        <trans-unit id="96ede599b6969e1b90d8c62ab4084c1f1b9581b8" translate="yes" xml:space="preserve">
          <source>I wrote a blog post a while back explaining closures. Here's what I said about closures in terms of &lt;strong&gt;why&lt;/strong&gt; you'd want one.</source>
          <target state="translated">しばらく前に、閉鎖について説明するブログ投稿を書きました。 ここで、 &lt;strong&gt;なぜ&lt;/strong&gt;クロージャーが必要なの&lt;strong&gt;か&lt;/strong&gt;という観点から、クロージャーについて述べました。</target>
        </trans-unit>
        <trans-unit id="1f893746796fe79900cf9caf10941e2bdc53f26f" translate="yes" xml:space="preserve">
          <source>I'd simply point them to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures&quot;&gt;Mozilla Closures page&lt;/a&gt;. It's the best, most &lt;strong&gt;concise and simple explanation&lt;/strong&gt; of closure basics and practical usage that I've found. It is highly recommended to anyone learning JavaScript.</source>
          <target state="translated">単に&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures&quot;&gt;Mozilla Closuresページを参照するようにします&lt;/a&gt; 。 これは、私が見つけたクロージャーの基本と実際の使用法の最も&lt;strong&gt;簡潔で簡単な説明&lt;/strong&gt;です。 JavaScriptを学習している人には強くお勧めします。</target>
        </trans-unit>
        <trans-unit id="11877a1bd39d64fe0945ea5ee068c0234e433657" translate="yes" xml:space="preserve">
          <source>I'm a big fan of analogy and metaphor when explaining difficult concepts, so let me try my hand with a story.</source>
          <target state="translated">私は難しい概念を説明するときには類推や比喩が大好きなので、話のネタにしてみようと思います。</target>
        </trans-unit>
        <trans-unit id="6b990bce01318ec63bef46aec64d8b6ab67c944d" translate="yes" xml:space="preserve">
          <source>I'm pretty sure I was one of the only people that attempted to take the initial question literally. Since then, the question has mutated several times, so my answer may now seem incredibly silly &amp;amp; out of place. Hopefully the general idea of the story remains fun for some.</source>
          <target state="translated">私が文字通り最初の質問をしようとした唯一の人々の一人だったと確信しています。 それ以来、質問は何度も変化しているので、私の答えは信じられないほどばかげて、場違いに見えるかもしれません。 うまくいけば、ストーリーの一般的なアイデアは、一部の人にとって楽しいままです。</target>
        </trans-unit>
        <trans-unit id="4f6b0992401487db0a126fe9e7ad6b66cdcca276" translate="yes" xml:space="preserve">
          <source>If a function accesses its environment, then the function is a closure.</source>
          <target state="translated">関数がその環境にアクセスする場合、その関数はクロージャになります。</target>
        </trans-unit>
        <trans-unit id="f330a42bf372ed8fefe90c64085c3c7240fecf76" translate="yes" xml:space="preserve">
          <source>If a variable is read, but can not be found anywhere, an error is generated.</source>
          <target state="translated">変数を読み込んでもどこにも見つからない場合は、エラーが発生します。</target>
        </trans-unit>
        <trans-unit id="3cbc5f197b9dd09fc614b45e91092d33f7f9c144" translate="yes" xml:space="preserve">
          <source>If an inner function is returned by an outer, then the outer lexical environment will persist after the outer function has returned. This is because the outer lexical environment needs to be available if the inner function is eventually invoked.</source>
          <target state="translated">内側の関数が外側の関数によって返された場合、外側の辞書環境は外側の関数が返された後も持続します。これは、内部関数が最終的に呼び出された場合に外部辞書環境が利用可能である必要があるためです。</target>
        </trans-unit>
        <trans-unit id="dc578583b34a4a34bae69d350c3dfa0573e54e50" translate="yes" xml:space="preserve">
          <source>If everything seems completely unclear, then the best thing to do is to play with the examples. Reading an explanation is much harder than understanding examples.
My explanations of closures and stack-frames, etc. are not technically correct &amp;mdash; they are gross simplifications intended to help to understand. Once the basic idea is grokked, you can pick up the details later.</source>
          <target state="translated">すべてが完全に不明瞭に思われる場合は、例を試すことをお勧めします。 説明を読むことは、例を理解することよりもはるかに困難です。 クロージャーやスタックフレームなどについての私の説明は技術的に正しくありません&amp;mdash;それらは理解を助けることを意図した全体的な単純化です。 基本的なアイデアを理解したら、後で詳細を確認できます。</target>
        </trans-unit>
        <trans-unit id="4f08569e7c3d79200141ddddd7958d6b1ded5e4e" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;i&lt;/code&gt; is also defined using &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt;, then the output is:</source>
          <target state="translated">変数 &lt;code&gt;i&lt;/code&gt; も &lt;code&gt;var&lt;/code&gt; ではなく &lt;code&gt;let&lt;/code&gt; を使用して定義されている場合、出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="460b9688bda10bbf35ef9d0c1b98952a76ebb3ed" translate="yes" xml:space="preserve">
          <source>If you are trying to do any dynamic source code modifications (for example: &lt;code&gt;myFunction = Function(myFunction.toString().replace(/Hello/,'Hola'));&lt;/code&gt;), it won't work if &lt;code&gt;myFunction&lt;/code&gt; is a closure (of course, you would never even think of doing source code string substitution at runtime, but...).</source>
          <target state="translated">動的なソースコードを変更しようとしている場合（例： &lt;code&gt;myFunction = Function(myFunction.toString().replace(/Hello/,'Hola'));&lt;/code&gt; ）、 &lt;code&gt;myFunction&lt;/code&gt; がクロージャーの場合は機能しません（もちろん、実行時にソースコードの文字列置換を行うことさえ考えられませんが...）。</target>
        </trans-unit>
        <trans-unit id="f246fbc5dfee71350f8d01e881e3e75375300e1a" translate="yes" xml:space="preserve">
          <source>If you have &lt;em&gt;just&lt;/em&gt; learned closures (here or elsewhere!), then I am interested in any feedback from you about any changes you might suggest that could make this article clearer. Send an email to morrisjohns.com (morris_closure @). Please note that I am not a guru on JavaScript &amp;mdash; nor on closures.</source>
          <target state="translated">クロージャー（ここまたは他の場所で！）を学習した&lt;em&gt;ばかりの&lt;/em&gt;場合、この記事をより明確にするために提案できる変更についてのフィードバックに興味があります。 morrisjohns.com（morris_closure @）にメールを送信します。 私はJavaScriptの第一人者ではなく、クロージャーの第一人者でもないことに注意してください。</target>
        </trans-unit>
        <trans-unit id="6a8ed7866e246c92cf6dd70deac29290fa039a64" translate="yes" xml:space="preserve">
          <source>Imagine - you are playing with your little brothers and sisters in the entire house, and you are moving around with your toys and brought some of them into your older brother's room. After a while your brother returned from the school and went to his room, and he locked inside it, so now you could not access toys left there anymore in a direct way. But you could knock the door and ask your brother for that toys. This is called toy's &lt;em&gt;closure&lt;/em&gt;; your brother made it up for you, and he is now into outer &lt;em&gt;scope&lt;/em&gt;.</source>
          <target state="translated">想像してみてください。あなたは家全体で弟や妹と遊んでいて、おもちゃを持って動き回っていて、それらのいくつかを兄の部屋に持ってきました。 しばらくして、あなたの兄弟は学校から戻って彼の部屋に行きました、そして彼はその中に閉じ込めました、それであなたはもう直接そこに残っているおもちゃにアクセスすることができませんでした。 しかし、ドアをノックして、兄弟にそのおもちゃを頼むことができます。 これはおもちゃの&lt;em&gt;閉鎖&lt;/em&gt;と呼ばれます。 あなたの兄弟があなたのためにそれを作り上げました、そして彼は今や外の&lt;em&gt;スコープに入ってい&lt;/em&gt;ます。</target>
        </trans-unit>
        <trans-unit id="fabf25061406e8ca355bbb62da26e81c7a773acf" translate="yes" xml:space="preserve">
          <source>Imagine that the Stack Overflow Vote-Up and Vote-Down button events are implemented as closures, voteUp_click and voteDown_click, that have access to external variables isVotedUp and isVotedDown, which are defined globally. (For simplicity's sake, I am referring to StackOverflow's Question Vote buttons, not the array of Answer Vote buttons.)</source>
          <target state="translated">このイベントは、グローバルに定義されている外部変数 isVotedUp と isVotedDown にアクセスできるようになっています(簡単に言うと、ここでは StackOverflow の質問用投票ボタンのことを指しています。(簡単のため、ここでは StackOverflow の質問用投票ボタンを参照していますが、回答用投票ボタンの配列ではありません)。</target>
        </trans-unit>
        <trans-unit id="34fbb45dfd31d8c76706f4846facff1223ce9ab3" translate="yes" xml:space="preserve">
          <source>In C and most other common languages, &lt;em&gt;after&lt;/em&gt; a function returns, all the local variables are no longer accessible because the stack-frame is destroyed.</source>
          <target state="translated">Cおよび他のほとんどの一般的な言語で&lt;em&gt;は&lt;/em&gt; 、関数が戻った&lt;em&gt;後&lt;/em&gt; 、スタックフレームが破棄されるため、すべてのローカル変数にアクセスできなくなります。</target>
        </trans-unit>
        <trans-unit id="bde892a91769451e6aae5176cd04fd8bb3c261d1" translate="yes" xml:space="preserve">
          <source>In JavaScript, if you declare a function within another function, then the local variables of the outer function can remain accessible after returning from it. This is demonstrated above, because we call the function &lt;code&gt;say2()&lt;/code&gt; after we have returned from &lt;code&gt;sayHello2()&lt;/code&gt;. Notice that the code that we call references the variable &lt;code&gt;text&lt;/code&gt;, which was a &lt;em&gt;local variable&lt;/em&gt; of the function &lt;code&gt;sayHello2()&lt;/code&gt;.</source>
          <target state="translated">JavaScriptでは、別の関数内で関数を宣言すると、外部関数から戻った後も、外部関数のローカル変数にアクセスできます。 これは、 &lt;code&gt;sayHello2()&lt;/code&gt; から戻った後に関数 &lt;code&gt;say2()&lt;/code&gt; を呼び出すため、上記で示されています。 呼び出すコードが変数 &lt;code&gt;text&lt;/code&gt; 参照していることに注意してください。これは関数 &lt;code&gt;sayHello2()&lt;/code&gt; の &lt;em&gt;ローカル変数&lt;/em&gt;でした。</target>
        </trans-unit>
        <trans-unit id="66588c3a466a757d86d3ce97ab53a9423b323372" translate="yes" xml:space="preserve">
          <source>In a closure, the variables in the outer lexical environment &lt;em&gt;themselves&lt;/em&gt; are available, &lt;em&gt;not&lt;/em&gt; copies.</source>
          <target state="translated">クロージャでは、外側の字句環境の変数&lt;em&gt;自体&lt;/em&gt;がコピーで&lt;em&gt;はなく&lt;/em&gt;利用できます。</target>
        </trans-unit>
        <trans-unit id="be9e7184ed47abdf916495732c707da00b0bef5c" translate="yes" xml:space="preserve">
          <source>In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function.</source>
          <target state="translated">コンピュータサイエンスでは、クロージャとは、関数とその関数の非ローカル名(自由変数)の参照環境のことを指します。</target>
        </trans-unit>
        <trans-unit id="7f7dd1aaa3a43450511e179ef4935d2bfcf91e9f" translate="yes" xml:space="preserve">
          <source>In that sense, they let a function act a bit like an object with private attributes.</source>
          <target state="translated">その意味では、関数はプライベート属性を持つオブジェクトのように振る舞うことができます。</target>
        </trans-unit>
        <trans-unit id="0c18c47099c91026c3cd731edf3696ce2d7f9082" translate="yes" xml:space="preserve">
          <source>In the above code &lt;code&gt;createClosure(n)&lt;/code&gt; is invoked in every iteration of the loop. Note that I named the variable &lt;code&gt;n&lt;/code&gt; to highlight that it is a &lt;strong&gt;new&lt;/strong&gt; variable created in a new function scope and is not the same variable as &lt;code&gt;index&lt;/code&gt; which is bound to the outer scope.</source>
          <target state="translated">上記のコードでは、ループのすべての反復で &lt;code&gt;createClosure(n)&lt;/code&gt; が呼び出されます。 変数 &lt;code&gt;n&lt;/code&gt; に名前を付けたのは、それが新しい関数スコープで作成された新しい変数であり、外部スコープにバインドされている &lt;code&gt;index&lt;/code&gt; と同じ変数ではないことを示していることに注意してください。</target>
        </trans-unit>
        <trans-unit id="64ccd305f21918c690c8faf2eee3f539cb44d848" translate="yes" xml:space="preserve">
          <source>In the above code the loop was moved within the &lt;code&gt;createClosureArray()&lt;/code&gt; function and the function now just returns the completed array, which at first glance seems more intuitive.</source>
          <target state="translated">上記のコードでは、ループは &lt;code&gt;createClosureArray()&lt;/code&gt; 関数内に移動され、関数は完成した配列を返すだけです。これは、一見するとより直感的に見えます。</target>
        </trans-unit>
        <trans-unit id="b564dadb6ceca4494d7653f8c5e95bc5a27eaf2b" translate="yes" xml:space="preserve">
          <source>In the above example, I am using the closure behavior of JavaScript. &lt;strong&gt;This behavior allows any function to have access to the scope in which it was created, indefinitely.&lt;/strong&gt; To practically apply this, I immediately invoke a function that returns another function, and because the function I'm returning has access to the internal count variable (because of the closure behavior explained above) this results in a private scope for usage by the resulting function... Not so simple? Let's dilute it down...</source>
          <target state="translated">上記の例では、JavaScriptのクロージャー動作を使用しています。 &lt;strong&gt;この動作により、どの関数も、それが作成されたスコープに無期限にアクセスできます。&lt;/strong&gt; これを実際に適用するには、別の関数を返す関数をすぐに呼び出します。返される関数は内部のcount変数にアクセスできるため（上​​記で説明したクロージャーの動作のため）、結果として使用されるプライベートスコープが生成されます。関数...それほど単純ではありませんか？ 希釈しましょう...</target>
        </trans-unit>
        <trans-unit id="52291f67af5b2a395aa91f417749282ffa321ce5" translate="yes" xml:space="preserve">
          <source>In the above example, outerFunction is called which in turn calls innerFunction. Note how outerVar is available to innerFunction, evidenced by its correctly alerting the value of outerVar.</source>
          <target state="translated">上記の例では、 outerFunction が呼び出され、それが innerFunction を呼び出しています。outerVarがinnerFunctionで利用可能であることに注目してください。</target>
        </trans-unit>
        <trans-unit id="9accb51a40f9456dfff0b9b647c4adc451c98ff8" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;f&lt;/code&gt; closes over the lexical environment of the global execution context:</source>
          <target state="translated">次の例では、関数 &lt;code&gt;f&lt;/code&gt; がグローバル実行コンテキストの字句環境を閉じます。</target>
        </trans-unit>
        <trans-unit id="79e7feaad903ac12e4a4780516074d3c8e273603" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;h&lt;/code&gt; closes over the lexical environment of function &lt;code&gt;g&lt;/code&gt;, which, in turn, closes over the lexical environment of the global execution context.</source>
          <target state="translated">次の例では、関数 &lt;code&gt;h&lt;/code&gt; が関数 &lt;code&gt;g&lt;/code&gt; の字句環境を閉じ、次に関数gがグローバル実行コンテキストの字句環境を閉じます。</target>
        </trans-unit>
        <trans-unit id="d208e23250c79929b1202ec211a36dbeb87b68f9" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;j&lt;/code&gt; closes over the lexical environment of function &lt;code&gt;i&lt;/code&gt;, meaning that variable &lt;code&gt;x&lt;/code&gt; is visible from inside function &lt;code&gt;j&lt;/code&gt;, long after function &lt;code&gt;i&lt;/code&gt; has completed execution:</source>
          <target state="translated">次の例では、関数 &lt;code&gt;j&lt;/code&gt; は関数 &lt;code&gt;i&lt;/code&gt; の字句環境を閉じます。つまり、関数 &lt;code&gt;i&lt;/code&gt; が実行を完了した後もずっと、変数 &lt;code&gt;j&lt;/code&gt; は関数jの内部から可視です。</target>
        </trans-unit>
        <trans-unit id="9a42d2846a79c733d7b14604fa1cb2c0c4772121" translate="yes" xml:space="preserve">
          <source>In the terminology of the ECMAScript specification, a closure can be said to be implemented by the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt;&lt;code&gt;[[Environment]]&lt;/code&gt;&lt;/a&gt; reference of every function-object, which points to the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;lexical environment&lt;/a&gt; within which the function is defined.</source>
          <target state="translated">ECMAScript仕様の用語では、クロージャーは、すべての関数オブジェクトの&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt; &lt;code&gt;[[Environment]]&lt;/code&gt; &lt;/a&gt;参照によって実装され、関数が定義されている&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;字句環境&lt;/a&gt;を指します。</target>
        </trans-unit>
        <trans-unit id="88a0303f59536ee17cc71dcac48a7690fb59fb0b" translate="yes" xml:space="preserve">
          <source>In this case, the interpreter finds the variable in the
outer &lt;a href=&quot;http://javascript.info/tutorial/initialization&quot;&gt;&lt;code&gt;LexicalEnvironment&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">この場合、インタプリタは外部の&lt;a href=&quot;http://javascript.info/tutorial/initialization&quot;&gt; &lt;code&gt;LexicalEnvironment&lt;/code&gt; &lt;/a&gt;オブジェクトで変数を見つけます。</target>
        </trans-unit>
        <trans-unit id="517b1409687da9d9fcb673e99fbcc8dd23f7ee52" translate="yes" xml:space="preserve">
          <source>In this final example, each call to the main function creates a separate closure.</source>
          <target state="translated">この最後の例では、メイン関数を呼び出すたびに別のクロージャが作成されます。</target>
        </trans-unit>
        <trans-unit id="c7149ac43259f5072dae076e7d470d21214d7c4c" translate="yes" xml:space="preserve">
          <source>Inner functions like &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt;, which access variables declared in an outer function&lt;sup&gt;**&lt;/sup&gt;, are called &lt;em&gt;closures&lt;/em&gt;.</source>
          <target state="translated">外部関数&lt;sup&gt;**&lt;/sup&gt;で宣言された変数にアクセス &lt;code&gt;add&lt;/code&gt; や &lt;code&gt;multiply&lt;/code&gt; などの内部関数は、 &lt;em&gt;クロージャー&lt;/em&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="c535437331e2cd1ff0b52dab323b734568fde96b" translate="yes" xml:space="preserve">
          <source>It is possible to nest function declarations within function declarations within function declarations&amp;hellip;; you can get closures at more than one level.</source>
          <target state="translated">関数宣言内の関数宣言内に関数宣言をネストすることは可能です&amp;hellip;; 複数のレベルでクロージャを取得できます。</target>
        </trans-unit>
        <trans-unit id="bd8a1c5b969fb5ce6751ab00fdc753d6fe50bc42" translate="yes" xml:space="preserve">
          <source>It may be helpful to see what happens when a block-level declaration of the variable &lt;code&gt;item&lt;/code&gt; is used (via the &lt;code&gt;let&lt;/code&gt; keyword) instead of a function-scoped variable declaration via the &lt;code&gt;var&lt;/code&gt; keyword. If that change is made, then each anonymous function in the array &lt;code&gt;result&lt;/code&gt; has its own closure; when the example is run the output is as follows:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; キーワードによる関数スコープの変数宣言の代わりに（ &lt;code&gt;let&lt;/code&gt; キーワードによる）変数 &lt;code&gt;item&lt;/code&gt; ブロックレベルの宣言が使用されたときに何が起こるかを確認すると役立つ場合があります。 その変更が行われた場合、配列の &lt;code&gt;result&lt;/code&gt; 各無名関数には独自のクロージャーがあります。 例を実行すると、出力は次のようになります。</target>
        </trans-unit>
        <trans-unit id="3f6d29d5da52be16dfb12c7815fe37a9ce3fcf16" translate="yes" xml:space="preserve">
          <source>JAVASCRIPT: JavaScript is a language. Like English or French or Chinese are languages. There are lots of languages that are understood by computers and other electronic processors. For JavaScript to be understood by a computer it needs an interpreter. Imagine if a teacher who only speaks Russian comes to teach your class at school. When the teacher says &quot;все садятся&quot;, the class would not understand. But luckily you have a Russian pupil in your class who tells everyone this means &quot;everybody sit down&quot; - so you all do. The class is like a computer and the Russian pupil is the interpreter. For JavaScript the most common interpreter is called a browser.</source>
          <target state="translated">JAVASCRIPT:JavaScriptは言語です。英語やフランス語や中国語が言語であるように。コンピュータや他の電子プロセッサによって理解される言語はたくさんあります。JavaScriptがコンピュータに理解されるためには通訳が必要です。学校の授業にロシア語しか話せない先生が来たとしましょう。先生が&quot; все садятся &quot;と言っても、クラスは理解できないでしょう。しかし、幸運にもあなたのクラスにはロシア人の生徒がいて、その生徒は「みんな座って」という意味だとみんなに教えてくれます。クラスはコンピュータのようなもので、ロシア人の生徒が通訳をしています。JavaScript の最も一般的なインタプリタはブラウザと呼ばれています。</target>
        </trans-unit>
        <trans-unit id="f15fd20b3b607a06e5de7b00b5c8829cba54783d" translate="yes" xml:space="preserve">
          <source>JavaScript closures for beginners</source>
          <target state="translated">初心者のためのJavaScriptのクロージャ</target>
        </trans-unit>
        <trans-unit id="a4ad1062dbb50a6179be99978ca0015111394d54" translate="yes" xml:space="preserve">
          <source>JavaScript functions can access their:</source>
          <target state="translated">JavaScriptの機能は、その機能にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="18356dc7f56408ba6d488b26a212e8a89b8f9645" translate="yes" xml:space="preserve">
          <source>Let's imagine the next situation: a driver is sitting in a car. That car is inside a plane. Plane is in the airport. The ability of driver to access things outside his car, but inside the plane, even if that plane leaves an airport, is a closure. That's it. When you turn 27, look at the &lt;a href=&quot;https://stackoverflow.com/a/111200/1393791&quot;&gt;more detailed explanation&lt;/a&gt; or at the example below.</source>
          <target state="translated">次の状況を想像してみましょう：ドライバーが車に座っています。 その車は飛行機の中にあります。 飛行機は空港にあります。 ドライバーが自分の車の外にあるものの飛行機の内側にアクセスする能力は、たとえ飛行機が空港を出たとしても、閉鎖です。 それでおしまい。 27歳になったとき、 &lt;a href=&quot;https://stackoverflow.com/a/111200/1393791&quot;&gt;より詳細な説明&lt;/a&gt;または下の例を見てください。</target>
        </trans-unit>
        <trans-unit id="09b200c5ade4b1cb4a297a00afe3d45be8c9d80e" translate="yes" xml:space="preserve">
          <source>Like the old Albert said : &quot;If you can't explain it to a six-year old, you really don't understand it yourself.&amp;rdquo;. Well I tried to explain JS closures to a 27 years old friend and completely failed.</source>
          <target state="translated">古いアルバートが言ったように：「あなたがそれを6歳に説明することができないなら、あなたは本当にそれを自分で理解していません。</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="f4346c3dbf21e346a2dead6609d901d087e13650" translate="yes" xml:space="preserve">
          <source>Locals (that is, their local variables and local functions)</source>
          <target state="translated">ローカル (つまり、そのローカル変数とローカル関数)</target>
        </trans-unit>
        <trans-unit id="2b0aed7bf52a8c5e0e0cefef3f3b339f8c820a34" translate="yes" xml:space="preserve">
          <source>Looking at the output of &lt;code&gt;say2.toString()&lt;/code&gt;, we can see that the code refers to the variable &lt;code&gt;text&lt;/code&gt;. The anonymous function can reference &lt;code&gt;text&lt;/code&gt; which holds the value &lt;code&gt;'Hello Bob'&lt;/code&gt; because the local variables of &lt;code&gt;sayHello2()&lt;/code&gt; have been secretly kept alive in a closure.</source>
          <target state="translated">&lt;code&gt;say2.toString()&lt;/code&gt; の出力を見ると、コードが変数 &lt;code&gt;text&lt;/code&gt; を参照していることがわかります 。 匿名関数は、値 &lt;code&gt;'Hello Bob'&lt;/code&gt; を保持する &lt;code&gt;text&lt;/code&gt; を参照できます。これは、 &lt;code&gt;sayHello2()&lt;/code&gt; のローカル変数がクロージャーで密かに保持されているためです。</target>
        </trans-unit>
        <trans-unit id="5628f8a6b5fea1b9beca93e689568ae4c8efb6d1" translate="yes" xml:space="preserve">
          <source>Marking up LexicalEnvironments:</source>
          <target state="translated">LexicalEnvironments をマークアップします。</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes" xml:space="preserve">
          <source>More examples</source>
          <target state="translated">その他の例</target>
        </trans-unit>
        <trans-unit id="6f01bda547a9bb9e65d7ba349d7f92d2d69752b9" translate="yes" xml:space="preserve">
          <source>Most JavaScript programmers will understand how a reference to a function is returned to a variable (&lt;code&gt;say2&lt;/code&gt;) in the above code. If you don't, then you need to look at that before you can learn closures. A programmer using C would think of the function as returning a pointer to a function, and that the variables &lt;code&gt;say&lt;/code&gt; and &lt;code&gt;say2&lt;/code&gt; were each a pointer to a function.</source>
          <target state="translated">ほとんどのJavaScriptプログラマーは、上記のコードで関数への参照が変数（ &lt;code&gt;say2&lt;/code&gt; ）に返される方法を理解しています。 そうでない場合は、クロージャーを学ぶ前に、それを確認する必要があります。 Cを使用するプログラマは、関数を関数へのポインタを返すものと &lt;code&gt;say2&lt;/code&gt; 、変数 &lt;code&gt;say&lt;/code&gt; およびsay2はそれぞれ関数へのポインタであると考えます。</target>
        </trans-unit>
        <trans-unit id="fd66b2800310560a1ce2ba5a794b44747c843f0e" translate="yes" xml:space="preserve">
          <source>NAME: You can call a function just about whatever word you want. The example &quot;cookMeal&quot; is typical in joining two words together and giving the second one a capital letter at the beginning - but this is not necessary. It can't have a space in it, and it can't be a number on its own.</source>
          <target state="translated">NAMEです。好きな言葉で関数を呼び出すことができます。cookMeal &quot;という例は、2つの単語を結合し、2つ目の単語の先頭に大文字を与えるという典型的なものですが、これは必要ありません。しかし、これは必須ではありません。</target>
        </trans-unit>
        <trans-unit id="40c3e770c196ccb030cf74232292c69eb60717a3" translate="yes" xml:space="preserve">
          <source>Note that in the above example, if you call &lt;code&gt;setupSomeGlobals()&lt;/code&gt; again, then a new closure (stack-frame!) is created. The old &lt;code&gt;gLogNumber&lt;/code&gt;, &lt;code&gt;gIncreaseNumber&lt;/code&gt;, &lt;code&gt;gSetNumber&lt;/code&gt; variables are overwritten with &lt;em&gt;new&lt;/em&gt; functions that have the new closure. (In JavaScript, whenever you declare a function inside another function, the inside function(s) is/are recreated again &lt;em&gt;each&lt;/em&gt; time the outside function is called.)</source>
          <target state="translated">上記の例では、 &lt;code&gt;setupSomeGlobals()&lt;/code&gt; を再度呼び出すと、新しいクロージャー（stack-frame！）が作成されることに注意してください。 古い &lt;code&gt;gLogNumber&lt;/code&gt; 、 &lt;code&gt;gIncreaseNumber&lt;/code&gt; 、 &lt;code&gt;gSetNumber&lt;/code&gt; 変数は、新しいクロージャーを持つ&lt;em&gt;新しい&lt;/em&gt;関数で上書きされます。 （JavaScriptでは、別の関数の内部で関数を宣言すると、外部関数が呼び出されるたびに内部関数が再作成されます。）</target>
        </trans-unit>
        <trans-unit id="7dc2f9bd9efd8d1e52cbf8c35413ba1f4105f5a9" translate="yes" xml:space="preserve">
          <source>Note that outer functions are not required, though they do offer benefits I don't discuss here. By accessing data in its environment, a closure keeps that data alive. In the subcase of outer/inner functions, an outer function can create local data and eventually exit, and yet, if any inner function(s) survive after the outer function exits, then the inner function(s) keep the outer function's local data alive.</source>
          <target state="translated">外部関数は必須ではありませんが、ここでは説明しない利点があることに注意してください。環境内のデータにアクセスすることで、クロージャはそのデータを存続させます。外部関数のサブケースでは、外部関数はローカルデータを生成し、最終的には終了しますが、外部関数が終了した後に内部関数が生き残った場合、内部関数は外部関数のローカルデータを保持します。</target>
        </trans-unit>
        <trans-unit id="4b7d6be3be4533ef766e4ba6b6589adcce7bd0a0" translate="yes" xml:space="preserve">
          <source>Note that variables &lt;em&gt;themselves&lt;/em&gt; are visible from within a closure, &lt;em&gt;not&lt;/em&gt; copies.</source>
          <target state="translated">変数&lt;em&gt;自体&lt;/em&gt;はコピーで&lt;em&gt;はなく&lt;/em&gt; 、クロージャー内から見えることに注意してください。</target>
        </trans-unit>
        <trans-unit id="9dccaff8b91f1ebe851d8b10d10b8abb4daae146" translate="yes" xml:space="preserve">
          <source>Note that when you run the example, &lt;code&gt;&quot;item2 undefined&quot;&lt;/code&gt; is logged three times! This is because just like previous examples, there is only one closure for the local variables for &lt;code&gt;buildList&lt;/code&gt; (which are &lt;code&gt;result&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;item&lt;/code&gt;). When the anonymous functions are called on the line &lt;code&gt;fnlist[j]()&lt;/code&gt;; they all use the same single closure, and they use the current value for &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;item&lt;/code&gt; within that one closure (where &lt;code&gt;i&lt;/code&gt; has a value of &lt;code&gt;3&lt;/code&gt; because the loop had completed, and &lt;code&gt;item&lt;/code&gt; has a value of &lt;code&gt;'item2'&lt;/code&gt;). Note we are indexing from 0 hence &lt;code&gt;item&lt;/code&gt; has a value of &lt;code&gt;item2&lt;/code&gt;. And the i++ will increment &lt;code&gt;i&lt;/code&gt; to the value &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">この例を実行すると、 &lt;code&gt;&quot;item2 undefined&quot;&lt;/code&gt; が3回記録されることに注意してください。 これは、前の例と同様に、 &lt;code&gt;buildList&lt;/code&gt; のローカル変数（ &lt;code&gt;result&lt;/code&gt; 、 &lt;code&gt;i&lt;/code&gt; 、 &lt;code&gt;list&lt;/code&gt; 、 &lt;code&gt;item&lt;/code&gt; ）のクロージャが1つしかないためです。 匿名関数が &lt;code&gt;fnlist[j]()&lt;/code&gt; 行で呼び出されたとき。 それらはすべて同じ単一のクロージャを使用し、その1つのクロージャ内の &lt;code&gt;i&lt;/code&gt; と &lt;code&gt;item&lt;/code&gt; の現在の値を使用します（ループが完了したため、 &lt;code&gt;i&lt;/code&gt; の値は &lt;code&gt;3&lt;/code&gt; で、 &lt;code&gt;item&lt;/code&gt; の値は &lt;code&gt;'item2'&lt;/code&gt; です ）。 0からインデックスを作成しているため、 &lt;code&gt;item&lt;/code&gt; の値は &lt;code&gt;item2&lt;/code&gt; です。 そして、i ++は &lt;code&gt;i&lt;/code&gt; を値 &lt;code&gt;3&lt;/code&gt; にインクリメントします。</target>
        </trans-unit>
        <trans-unit id="2632a4becd02c75c95693519f5cf180b44a90456" translate="yes" xml:space="preserve">
          <source>Notice a few things here.</source>
          <target state="translated">ここでいくつかのことに注目してください。</target>
        </trans-unit>
        <trans-unit id="3393c390f2f8f559d4a2a520da1ec907eaeea621" translate="yes" xml:space="preserve">
          <source>Now consider the following:</source>
          <target state="translated">では、次のことを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="8495e70502d881bdf9b4145e67ce317efd57faac" translate="yes" xml:space="preserve">
          <source>Now this will work, but it does encroach into the outer scope by adding a variable, whose sole purpose is to keep track of the count. In some situations, this would be preferable as your outer application might need access to this information. But in this case, we are only changing every third click's behavior, so it is preferable to &lt;strong&gt;enclose this functionality inside the event handler&lt;/strong&gt;.</source>
          <target state="translated">これでうまくいきますが、変数を追加することで外側のスコープに侵入します。その唯一の目的はカウントを追跡することです。 場合によっては、外部アプリケーションがこの情報にアクセスする必要がある可能性があるため、この方法が適しています。 ただし、この場合、クリックの3回おきの動作のみを変更しているため、 &lt;strong&gt;この機能をイベントハンドラー内&lt;/strong&gt;に&lt;strong&gt;含める&lt;/strong&gt;ことが推奨されます。</target>
        </trans-unit>
        <trans-unit id="edc821fed74b8a83207ffcc4a681c6656cb0dbd9" translate="yes" xml:space="preserve">
          <source>Now what it &lt;em&gt;allows&lt;/em&gt; you to do can be more spectacular, see other answers.</source>
          <target state="translated">今それ&lt;em&gt;が&lt;/em&gt;あなたにできることはもっと壮観になることが&lt;em&gt;でき&lt;/em&gt;ます、他の答えを見てください。</target>
        </trans-unit>
        <trans-unit id="37b00465e1d26162d39a6df745e20f2e4e1c3722" translate="yes" xml:space="preserve">
          <source>Now, after the function &lt;em&gt;sing()&lt;/em&gt;, near the end of the code is the line</source>
          <target state="translated">ここで、関数&lt;em&gt;sing（）&lt;/em&gt;の後に、コードの終わり近くに次の行があります</target>
        </trans-unit>
        <trans-unit id="2b6292f13ea61f03e46a26b717197499baebf90b" translate="yes" xml:space="preserve">
          <source>Now, where's the definition of &lt;code&gt;x&lt;/code&gt;? We didn't define it in the current scope. The only solution is to let &lt;code&gt;plus5&lt;/code&gt;&lt;em&gt;carry&lt;/em&gt; its scope (or rather, its parent's scope) around. This way, &lt;code&gt;x&lt;/code&gt; is well-defined and it is bound to the value 5.</source>
          <target state="translated">さて、 &lt;code&gt;x&lt;/code&gt; の定義はどこにありますか？ 現在のスコープでは定義していません。 唯一の解決策は、 &lt;code&gt;plus5&lt;/code&gt; にそのスコープ（または、親のスコープ）を持ち越させる&lt;em&gt;こと&lt;/em&gt;です。 このようにして、 &lt;code&gt;x&lt;/code&gt; は明確に定義され、値5にバインドされます。</target>
        </trans-unit>
        <trans-unit id="9e15ed596afd3bc19fd5d61a060bb2a47cddef9b" translate="yes" xml:space="preserve">
          <source>OK, 6-year-old closures fan. Do you want to hear the simplest example of closure?</source>
          <target state="translated">OK、6歳のクロージャーファン。クロージングの一番簡単な例を聞きたいですか?</target>
        </trans-unit>
        <trans-unit id="d722330a80b9bc2dfce4ab9f7b615cda1f5e4764" translate="yes" xml:space="preserve">
          <source>Okay, talking with a 6-year old child, I would possibly use following associations.</source>
          <target state="translated">さて、6歳の子供と話していると、以下のような連想をすることがあります。</target>
        </trans-unit>
        <trans-unit id="148abbffcf1d27e45f3fc36604ef1e94841e9e4b" translate="yes" xml:space="preserve">
          <source>On  &lt;a href=&quot;http://www.howkidsdevelop.com/5-7years.html&quot;&gt;Childhood Development: 5 to 7 Years &lt;/a&gt; it says:</source>
          <target state="translated">&lt;a href=&quot;http://www.howkidsdevelop.com/5-7years.html&quot;&gt;小児期の発達について：5〜7年&lt;/a&gt;と言う：</target>
        </trans-unit>
        <trans-unit id="34b3df084cbf5c7a669b26ff1aacf3c99a1d1dc8" translate="yes" xml:space="preserve">
          <source>Original post by Morris can be found in the &lt;a href=&quot;http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies&quot;&gt;Internet Archive&lt;/a&gt;.</source>
          <target state="translated">モリスによる元の投稿は、 &lt;a href=&quot;http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies&quot;&gt;インターネットアーカイブにあり&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="681216b5a1437efa0ee50e426313a7fe8126153e" translate="yes" xml:space="preserve">
          <source>Our code begins with the word &lt;em&gt;function&lt;/em&gt;, so we know that it is one! Then the name of the function &lt;em&gt;sing&lt;/em&gt; - that's my own description of what the function is about. Then parentheses &lt;em&gt;()&lt;/em&gt;. The parentheses are always there for a function. Sometimes they are empty, and sometimes they have something in. This one has a word in: &lt;code&gt;(person)&lt;/code&gt;. After this there is a brace like this &lt;code&gt;{&lt;/code&gt; . This marks the start of the function &lt;em&gt;sing()&lt;/em&gt;. It has a partner which marks the end of &lt;em&gt;sing()&lt;/em&gt; like this &lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">コードは&lt;em&gt;function&lt;/em&gt;という単語で始まっているので、それが1つであることがわかります。 次に、関数の名前が&lt;em&gt;歌います&lt;/em&gt; -それは関数が何であるかについての私自身の説明です。 次に括弧&lt;em&gt;（）&lt;/em&gt; 。 括弧は関数の場合は常にそこにあります。 時々それらは空であり、時々彼らは何かを持っています。これは &lt;code&gt;(person)&lt;/code&gt; 言葉があります。 この後、このようなブレースがあります &lt;code&gt;{&lt;/code&gt; 。 これは、関数&lt;em&gt;sing（）&lt;/em&gt;の開始を示します。 このように&lt;em&gt;sing（）の&lt;/em&gt;終わりを示すパートナーがあります &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05c242ba6271e12b61564339fb6644d07e822a54" translate="yes" xml:space="preserve">
          <source>PARENTHESES: &quot;Parentheses&quot; or &lt;code&gt;()&lt;/code&gt; are the letter box on the JavaScript function factory's door or a post box in the street for sending packets of information to the factory. Sometimes the postbox might be marked &lt;em&gt;for example&lt;/em&gt;&lt;code&gt;cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime)&lt;/code&gt;, in which case you know what data you have to give it.</source>
          <target state="translated">括弧：「括弧」または &lt;code&gt;()&lt;/code&gt; は、JavaScript関数ファクトリのドアのレターボックス、または情報のパケットをファクトリに送信するための道路のポストボックスです。 場合によっては、ポストボックスに &lt;code&gt;cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime)&lt;/code&gt; などのマークが付けられることがあります。その場合、どのデータを渡さなければならないかがわかります。</target>
        </trans-unit>
        <trans-unit id="9144b2a7d95b704078de888cf37d60fe67becfb9" translate="yes" xml:space="preserve">
          <source>Perhaps a little beyond all but the most precocious of six-year-olds, but a few examples that helped make the concept of closure in JavaScript click for me.</source>
          <target state="translated">おそらく、6歳の最も早熟な子供以外のすべての人を少し超えているかもしれませんが、JavaScriptのクロージャの概念をクリックするのに役立ついくつかの例があります。</target>
        </trans-unit>
        <trans-unit id="5faa59d4bc3756040b8ce9e673c09f929e6ee9ba" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Result</target>
        </trans-unit>
        <trans-unit id="bcd4102717d8891f8d496a43ec74da14fa94f69e" translate="yes" xml:space="preserve">
          <source>Returning a &lt;code&gt;function&lt;/code&gt; from inside another function is the classic example of a closure, because the state inside the outer function is implicitly available to the returned inner function, even after the outer function has completed execution. This has a number of use-cases, including simulating private variables.</source>
          <target state="translated">外部関数の実行が完了した後でも、外部関数の内部の状態は、返された内部関数で暗黙的に使用できるため、別の関数の内部から &lt;code&gt;function&lt;/code&gt; を返すことは、クロージャの典型的な例です。 これには、プライベート変数のシミュレーションを含む、いくつかのユースケースがあります。</target>
        </trans-unit>
        <trans-unit id="ada6589cf526d0c74d239a16a5730f12743a8388" translate="yes" xml:space="preserve">
          <source>Second, when a closure is created, it retains a reference to all of its enclosing function&amp;rsquo;s variables and functions; it doesn&amp;rsquo;t get to pick and choose. And but so, closures should be used sparingly, or at least carefully, as they can be memory intensive; a lot of variables can be kept in memory long after a containing function has finished executing.</source>
          <target state="translated">次に、クロージャーが作成されると、クロージャーは、それを囲んでいる関数のすべての変数と関数への参照を保持します。 選択する必要はありません。 ただし、クロージャーはメモリを集中的に使用する可能性があるため、控えめに、または少なくとも慎重に使用する必要があります。 含まれている関数の実行が終了した後も、多くの変数をメモリに保持できます。</target>
        </trans-unit>
        <trans-unit id="67fe596a436afe4d7599b96bf46b1977ec2e0ef6" translate="yes" xml:space="preserve">
          <source>She lived in a wonderful world full of adventures. She met her Prince Charming, rode around her world on a unicorn, battled dragons, encountered talking animals, and many other fantastical things.</source>
          <target state="translated">彼女は冒険に満ちた素晴らしい世界に住んでいました。彼女は王子様に出会い、ユニコーンに乗って世界を駆け回り、ドラゴンと戦い、話す動物に遭遇し、他の多くの空想的なものを持っていました。</target>
        </trans-unit>
        <trans-unit id="07573b573651a019027237d961cc61054b6bec94" translate="yes" xml:space="preserve">
          <source>Since &lt;strong&gt;scope-defining construction in JavaScript is a function&lt;/strong&gt;, not a code block like in many other languages, &lt;strong&gt;what we usually mean by &lt;em&gt;closure&lt;/em&gt; in JavaScript&lt;/strong&gt; is a &lt;strong&gt;function working with nonlocal variables defined in already executed surrounding function&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;JavaScriptのスコープ定義構築は関数&lt;/strong&gt;であり、他の多くの言語のようなコードブロックではないため、 &lt;strong&gt;通常JavaScript&lt;/strong&gt;での&lt;strong&gt;&lt;em&gt;クロージャー&lt;/em&gt;と&lt;/strong&gt;は、 &lt;strong&gt;既に実行された周囲の関数で定義された非ローカル変数で機能する関数&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="e95fed48c1d8fabe097fc454c7b9211faa3636be" translate="yes" xml:space="preserve">
          <source>So this function might have something to do with singing, and might need some data about a person. It has instructions inside to do something with that data.</source>
          <target state="translated">この関数は歌を歌うことに関係しているかもしれませんし、人に関するデータが必要かもしれません。そのデータを使って何かをするための命令を 内部に持っています</target>
        </trans-unit>
        <trans-unit id="a50b97914eb409961a9c50a5aaf62d55c22e4149" translate="yes" xml:space="preserve">
          <source>So to live, the child has to leave before it's too late</source>
          <target state="translated">だから、生きるためには、子供は手遅れになる前に出て行かなければならない</target>
        </trans-unit>
        <trans-unit id="a2d88110733edd016cbeae6a733e1b0d67a3f3ba" translate="yes" xml:space="preserve">
          <source>So what are these closure thingys?</source>
          <target state="translated">で、この閉鎖的なものは何なんだ?</target>
        </trans-unit>
        <trans-unit id="454c8a36400b7eb57a810440ce57394bfb5816b7" translate="yes" xml:space="preserve">
          <source>So, as long as we are in the parent -function, it can create one or more child functions which do share the secret variables from the secret place.</source>
          <target state="translated">ですから、親-関数にいる限り、秘密の場所から秘密の変数を共有する1つ以上の子関数を作成することができます。</target>
        </trans-unit>
        <trans-unit id="0a89e976c7abc12da557c349bfa0ca485f347c7a" translate="yes" xml:space="preserve">
          <source>So, function g has access to g, a and f.</source>
          <target state="translated">つまり、関数gは、g、a、fにアクセスしていることになります。</target>
        </trans-unit>
        <trans-unit id="f9cca5aab093ddbfc4f01dcf36fc37ee09f0ff12" translate="yes" xml:space="preserve">
          <source>So, if you call the child &quot;Alice&quot;, she will respond</source>
          <target state="translated">なので、子供を「アリス」と呼ぶと反応するのは</target>
        </trans-unit>
        <trans-unit id="dbc77889f79e6ba70a51ccdd7b1d469ad3fe2209" translate="yes" xml:space="preserve">
          <source>So, whenever you see the &lt;code&gt;function&lt;/code&gt; keyword, code inside that function has access to variables declared outside the function.</source>
          <target state="translated">したがって、 &lt;code&gt;function&lt;/code&gt; キーワードが表示されている場合は常に、その関数内のコードは、関数外で宣言された変数にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="32a5b0910ff15915067cd48d69073b7ed24d5e07" translate="yes" xml:space="preserve">
          <source>Submitted by Morris on Tue, 2006-02-21 10:19.  Community-edited since.</source>
          <target state="translated">投稿者:モリス 投稿日:2006-02-21 10:19 以降コミュニティ編集しました。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="9025c4cc6a8af6eb5f548366877eea00d17ba2f8" translate="yes" xml:space="preserve">
          <source>Taking the question seriously, we should find out what a typical 6-year-old is capable of cognitively, though admittedly, one who is interested in JavaScript is not so typical.</source>
          <target state="translated">真面目に考えてみると、典型的な6歳児の認知能力はどうなのか、ということになりますが、JavaScriptに興味がある人はそうではないでしょう。</target>
        </trans-unit>
        <trans-unit id="67cecda122884bfa553becae4c5685cfae2cbb5f" translate="yes" xml:space="preserve">
          <source>Technically, in &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt;, &lt;strong&gt;every function is a closure&lt;/strong&gt;. It always has an access to variables defined in the surrounding scope.</source>
          <target state="translated">技術的には、 &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt;では、 &lt;strong&gt;すべての関数がクロージャ&lt;/strong&gt;です。 常に、周囲のスコープで定義された変数にアクセスできます。</target>
        </trans-unit>
        <trans-unit id="97cba4858411c435e526dd651157aac20178222c" translate="yes" xml:space="preserve">
          <source>Thanks</source>
          <target state="translated">Thanks</target>
        </trans-unit>
        <trans-unit id="30a5f96f9b652a33887df9866bf824d883055acd" translate="yes" xml:space="preserve">
          <source>That's all there is to tell.</source>
          <target state="translated">それだけでいいんです。</target>
        </trans-unit>
        <trans-unit id="ab6ae4b470ffe5a3279c44a289c97ea3536b0044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trashBags&lt;/code&gt; variable is local to the inside of each kitchen and is not accessible outside, but the inner function on the &lt;code&gt;getTrashBag&lt;/code&gt; property does have access to it.</source>
          <target state="translated">&lt;code&gt;trashBags&lt;/code&gt; 変数は各キッチンの内部にローカルであり、外部からはアクセスできませんが、 &lt;code&gt;getTrashBag&lt;/code&gt; プロパティの内部関数はそれにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="f4b0fe233c7b64030a0dc17c446f53a7aea9634c" translate="yes" xml:space="preserve">
          <source>The Straw Man</source>
          <target state="translated">ストローマン</target>
        </trans-unit>
        <trans-unit id="2ac247e683af2d84a6d9660b577f04e07e7d50da" translate="yes" xml:space="preserve">
          <source>The above code has a closure because the anonymous function &lt;code&gt;function() { console.log(text); }&lt;/code&gt; is declared &lt;em&gt;inside&lt;/em&gt; another function, &lt;code&gt;sayHello2()&lt;/code&gt; in this example. In JavaScript, if you use the &lt;code&gt;function&lt;/code&gt; keyword inside another function, you are creating a closure.</source>
          <target state="translated">匿名関数 &lt;code&gt;function() { console.log(text); }&lt;/code&gt; ため、上記のコードにはクロージャーがあります。 }は別の関数、この例では &lt;code&gt;sayHello2()&lt;/code&gt; &lt;em&gt;内&lt;/em&gt;で宣言されています。 JavaScriptでは、別の関数内で &lt;code&gt;function&lt;/code&gt; キーワードを使用すると、クロージャーが作成されます。</target>
        </trans-unit>
        <trans-unit id="7604834deb6d4981f78e51cc66d18c9e17faae70" translate="yes" xml:space="preserve">
          <source>The above function will also log 16, because the code inside &lt;code&gt;bar&lt;/code&gt; can still refer to argument &lt;code&gt;x&lt;/code&gt; and variable &lt;code&gt;tmp&lt;/code&gt;, even though they are no longer directly in scope.</source>
          <target state="translated">上記の関数は、16もログに記録します。これは、 &lt;code&gt;bar&lt;/code&gt; 内のコードが引数 &lt;code&gt;x&lt;/code&gt; と変数 &lt;code&gt;tmp&lt;/code&gt; を参照できるためです。ただし、直接スコープに含まれていません。</target>
        </trans-unit>
        <trans-unit id="246fdc56b891ef8cd6ddc925b1d907069e7fc98a" translate="yes" xml:space="preserve">
          <source>The author of &lt;em&gt;&lt;a href=&quot;http://javascript.info/tutorial/closures&quot;&gt;Closures&lt;/a&gt;&lt;/em&gt; has explained closures pretty well, explaining the reason why we need them and also explaining LexicalEnvironment which is necessary to understanding closures.</source>
          <target state="translated">Closuresの作者は、クロージャーをかなりよく説明し、クロージャーが必要な理由を説明し、クロージャーを理解するために必要なLexicalEnvironmentも説明しています。</target>
        </trans-unit>
        <trans-unit id="c13d0c83e1140ef05df23d7d967fd539e97fac2a" translate="yes" xml:space="preserve">
          <source>The browser keeps the LexicalEnvironment and all its properties (variables) in memory until there is an inner function which references it.</source>
          <target state="translated">ブラウザは、それを参照する内部関数が存在するまで、LexicalEnvironment とそのすべてのプロパティ (変数)をメモリに保持します。</target>
        </trans-unit>
        <trans-unit id="ebab32e0d02219305bce1886d9e8f64ed8614c91" translate="yes" xml:space="preserve">
          <source>The chain of lexical environments, linked between execution contexts via outer environment references, forms a &lt;em&gt;scope chain&lt;/em&gt; and defines the identifiers visible from any given function.</source>
          <target state="translated">外部環境参照を介して実行コンテキスト間でリンクされるレキシカル環境のチェーンは、 &lt;em&gt;スコープチェーン&lt;/em&gt;を形成し、任意の特定の関数から見える識別子を定義します。</target>
        </trans-unit>
        <trans-unit id="1f0b658a23c022351d31c0bee4a00408b17ba821" translate="yes" xml:space="preserve">
          <source>The children will always remember the secrets they have shared with their parents, even after their parents are
  gone. This is what closures are for functions.</source>
          <target state="translated">子どもたちは、親が亡くなった後も、親と共有した秘密を忘れない。クローゼットとはこういう機能のことです。</target>
        </trans-unit>
        <trans-unit id="d142ef727404c57948941e5ea1a82a1476684d84" translate="yes" xml:space="preserve">
          <source>The closures all know what the &lt;em&gt;sing()&lt;/em&gt; function's variable called &lt;em&gt;firstPart&lt;/em&gt; is, because they can see out from their tinted windows.</source>
          <target state="translated">クロージャーはすべて、 &lt;em&gt;sing（）&lt;/em&gt;関数の&lt;em&gt;firstPart&lt;/em&gt;と呼ばれる変数が何であるかを知っています。</target>
        </trans-unit>
        <trans-unit id="bb0d2327de1953161942f2ab9fa838498aa1dbcb" translate="yes" xml:space="preserve">
          <source>The example above is using an anonymous function, which was executed once. But it does not have to be. It can be named (e.g. &lt;code&gt;mkdb&lt;/code&gt;) and executed later, generating a database function each time it is invoked. Every generated function will have its own hidden database object. Another usage example of closures is when we don't return a function, but an object containing multiple functions for different purposes, each of those function having access to the same data.</source>
          <target state="translated">上記の例は、一度実行された無名関数を使用しています。 しかし、そうである必要はありません。 &lt;code&gt;mkdb&lt;/code&gt; などの名前を付けて後で実行し、呼び出されるたびにデータベース関数を生成できます。 生成されたすべての関数には、独自の非表示のデータベースオブジェクトがあります。 クロージャーのもう1つの使用例は、関数を返さない場合です。ただし、異なる目的で複数の関数を含むオブジェクトで、各関数が同じデータにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="d752ad30dcb07b4bf12c76bcaf1fd95663e1c173" translate="yes" xml:space="preserve">
          <source>The following code returns a reference to a function:</source>
          <target state="translated">次のコードは、関数への参照を返します。</target>
        </trans-unit>
        <trans-unit id="5215171b8fbe41f294967978f22f5060d88ee251" translate="yes" xml:space="preserve">
          <source>The following simple example covers all the main points of JavaScript closures.&lt;sup&gt;*&lt;/sup&gt;</source>
          <target state="translated">次の簡単な例は、JavaScriptクロージャーのすべての主要なポイントをカバーしています。 &lt;sup&gt;*&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ad531efca548a3919fa24597ab10762db1c48acd" translate="yes" xml:space="preserve">
          <source>The genius is that in JavaScript a function reference also has a secret reference to the closure it was created in &amp;mdash; similar to how delegates are a method pointer plus a secret reference to an object.</source>
          <target state="translated">天才は、JavaScriptでは関数参照にも、それが作成されたクロージャーへの秘密の参照があることです。デリゲートがメソッドポインターとオブジェクトへの秘密の参照であるのと同様です。</target>
        </trans-unit>
        <trans-unit id="45e0685cacab3e797413836c0a3b3870f011cdba" translate="yes" xml:space="preserve">
          <source>The inner function keeps a reference to the outer
LexicalEnvironment.</source>
          <target state="translated">内部の関数は、外部のLexicalEnvironmentへの参照を保持します。</target>
        </trans-unit>
        <trans-unit id="1222b712516a600e2c63dde997d35b726a9bade9" translate="yes" xml:space="preserve">
          <source>The inner function may access variables from it
any time even if the outer function is finished.</source>
          <target state="translated">外部関数が終了しても、内部関数はいつでも内部関数から変数にアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="0f440ed8885caea2f6a4de181d02ca1ce2bfd985" translate="yes" xml:space="preserve">
          <source>The kitchen is a closure that has a local variable, called &lt;code&gt;trashBags&lt;/code&gt;.  There is a function inside the kitchen called &lt;code&gt;getTrashBag&lt;/code&gt; that gets one trash bag and returns it.</source>
          <target state="translated">キッチンは、 &lt;code&gt;trashBags&lt;/code&gt; と呼ばれるローカル変数を持つクロージャーです。 キッチンの中に &lt;code&gt;getTrashBag&lt;/code&gt; という関数があり、ゴミ袋を1つ取得してそれを返します。</target>
        </trans-unit>
        <trans-unit id="e9eb91337dbe1342ddf4236b7c7460d616e8d494" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;result.push( function() {console.log(item + ' ' + list[i])}&lt;/code&gt; adds a reference to an anonymous function three times to the result array. If you are not so familiar with anonymous functions think of it like:</source>
          <target state="translated">行 &lt;code&gt;result.push( function() {console.log(item + ' ' + list[i])}&lt;/code&gt; は、無名関数への参照を結果配列に3回追加します。無名関数に慣れていない場合は、それは好きです：</target>
        </trans-unit>
        <trans-unit id="3719fe577c00cbcfb269ebde253db1c8de6cf36a" translate="yes" xml:space="preserve">
          <source>The process consists of two steps:</source>
          <target state="translated">プロセスは2つのステップで構成されています。</target>
        </trans-unit>
        <trans-unit id="a6b75fac7979ad9def4158f7b987a3aa8e383e53" translate="yes" xml:space="preserve">
          <source>The reason that referenceToInnerFunction can still access the value of outerVar is because when the closure was first created by placing innerFunction inside of outerFunction, innerFunction added a reference to outerFunction&amp;rsquo;s scope (its variables and functions) to its scope chain. What this means is that innerFunction has a pointer or reference to all of outerFunction&amp;rsquo;s variables, including outerVar. So even when outerFunction has finished executing, or even if it is deleted or set to null, the variables in its scope, like outerVar, stick around in memory because of the outstanding reference to them on the part of the innerFunction that has been returned to referenceToInnerFunction. To truly release outerVar and the rest of outerFunction&amp;rsquo;s variables from memory you would have to get rid of this outstanding reference to them, say by setting referenceToInnerFunction to null as well.</source>
          <target state="translated">referenceToInnerFunctionが引き続きouterVarの値にアクセスできる理由は、innerFunctionをouterFunction内に配置することによってクロージャが最初に作成されたときに、innerFunctionがそのスコープチェーンにouterFunctionのスコープ（その変数と関数）への参照を追加したためです。 つまり、innerFunctionには、outerVarを含むすべてのouterFunctionの変数へのポインタまたは参照があります。 そのため、outerFunctionの実行が終了した場合や、削除またはnullに設定されている場合でも、outerVarなどのスコープ内の変数は、innerFunctionに返された部分で未処理の参照があるため、メモリ内に留まります。 referenceToInnerFunction。 outerVarと残りのouterFunctionの変数をメモリから本当に解放するには、たとえばreferenceToInnerFunctionをnullに設定するなどして、これらの未処理の参照を取り除く必要があります。</target>
        </trans-unit>
        <trans-unit id="a52ec855c305cdd424a0acec2f16c794668d3e11" translate="yes" xml:space="preserve">
          <source>The secrets for JavaScript functions are the private variables</source>
          <target state="translated">JavaScript関数の秘密はプライベート変数</target>
        </trans-unit>
        <trans-unit id="c8048ace855f36cfe6ec5f055971d3ab6080b70b" translate="yes" xml:space="preserve">
          <source>The simplest example of a closure is this:</source>
          <target state="translated">閉鎖の最もシンプルな例はこれです。</target>
        </trans-unit>
        <trans-unit id="758516d667c0ca64ba31d36b4aa304b7d45c8074" translate="yes" xml:space="preserve">
          <source>The sing() function will call each of these functions in the order they are given. Then the sing() function's work will be done.</source>
          <target state="translated">sing()関数は、これらの関数のそれぞれを与えられた順に呼び出します。そして、sing()関数の作業は終了します。</target>
        </trans-unit>
        <trans-unit id="b2bfe35512d67b1120c27f2759f79e721a38d640" translate="yes" xml:space="preserve">
          <source>The three functions have shared access to the same closure &amp;mdash; the local variables of &lt;code&gt;setupSomeGlobals()&lt;/code&gt; when the three functions were defined.</source>
          <target state="translated">3つの関数は、同じクロージャーへのアクセスを共有しています&amp;mdash; 3つの関数が定義されたときの &lt;code&gt;setupSomeGlobals()&lt;/code&gt; のローカル変数。</target>
        </trans-unit>
        <trans-unit id="1683c5c3fdaabb276940a6471aab76eac2921b0e" translate="yes" xml:space="preserve">
          <source>There is a critical difference between a C pointer to a function and a JavaScript reference to a function. In JavaScript, you can think of a function reference variable as having both a pointer to a function &lt;em&gt;as well&lt;/em&gt; as a hidden pointer to a closure.</source>
          <target state="translated">関数へのCポインターと関数へのJavaScript参照との間には重大な違いがあります。 JavaScriptでは、関数参照変数は、関数へのポインターとクロージャーへの隠しポインターの両方を持つと考えることができます。</target>
        </trans-unit>
        <trans-unit id="04637ad8e1b34b4d45e60aaea6b490192d004b6f" translate="yes" xml:space="preserve">
          <source>There is no reason to believe closures are a complex design hack to address specific problems. No, closures are just about using a variable that comes from a higher scope &lt;strong&gt;from the perspective of where the function was declared (not run)&lt;/strong&gt;.</source>
          <target state="translated">クロージャーが特定の問題に対処するための複雑な設計ハックであると信じる理由はありません。 いいえ、クロージャは&lt;strong&gt;、関数が宣言された（実行されていない）点&lt;/strong&gt;から見た、より高いスコープ&lt;strong&gt;からの&lt;/strong&gt;変数を使用するためのものです。</target>
        </trans-unit>
        <trans-unit id="dc8da2d96ff3de796d0c72436a2ccd3f4dc18e12" translate="yes" xml:space="preserve">
          <source>There was a princess...</source>
          <target state="translated">お姫様がいた...</target>
        </trans-unit>
        <trans-unit id="7ee59ebacfd9d93a5dadb09b49abe5ed01b3d0c0" translate="yes" xml:space="preserve">
          <source>There you go; you're now fully encapsulating this behavior.</source>
          <target state="translated">これで、この動作が完全にカプセル化されました。</target>
        </trans-unit>
        <trans-unit id="f2e330c9ca939e298d2b5965f2b6b3e1b37e408b" translate="yes" xml:space="preserve">
          <source>This article is intended for programmers with some programming experience in a mainstream language, and who can read the following JavaScript function:</source>
          <target state="translated">この記事は、ある程度主流言語でのプログラミング経験があり、以下のJavaScriptの関数が読めるプログラマを対象としています。</target>
        </trans-unit>
        <trans-unit id="4dd1925d9c601a5cbe75680ad2654c7234add57a" translate="yes" xml:space="preserve">
          <source>This creates a new scope and &lt;code&gt;n&lt;/code&gt; is bound to that scope; this means we have 10 separate scopes, one for each iteration.</source>
          <target state="translated">これにより新しいスコープが作成され、 &lt;code&gt;n&lt;/code&gt; はそのスコープにバインドされます。 これは、反復ごとに1つずつ、10の個別のスコープがあることを意味します。</target>
        </trans-unit>
        <trans-unit id="7552ddbeac58a09947a400d7a7ab0c7823e95f06" translate="yes" xml:space="preserve">
          <source>This example shows that the closure contains any local variables that were declared inside the outer function before it exited. Note that the variable &lt;code&gt;alice&lt;/code&gt; is actually declared after the anonymous function. The anonymous function is declared first and when that function is called it can access the &lt;code&gt;alice&lt;/code&gt; variable because &lt;code&gt;alice&lt;/code&gt; is in the same scope (JavaScript does &lt;a href=&quot;https://stackoverflow.com/a/3725763/1269037&quot;&gt;variable hoisting&lt;/a&gt;).
Also &lt;code&gt;sayAlice()()&lt;/code&gt; just directly calls the function reference returned from &lt;code&gt;sayAlice()&lt;/code&gt; &amp;mdash; it is exactly the same as what was done previously but without the temporary variable.</source>
          <target state="translated">この例は、クロージャーに、それが終了する前に外部関数内で宣言されたローカル変数が含まれていることを示しています。 変数 &lt;code&gt;alice&lt;/code&gt; は実際には無名関数の後に宣言されていることに注意してください。 匿名関数が最初に宣言され、その関数が呼び出されると、 &lt;code&gt;alice&lt;/code&gt; が同じスコープ内にあるため（JavaScriptは&lt;a href=&quot;https://stackoverflow.com/a/3725763/1269037&quot;&gt;変数の巻き上げを行う&lt;/a&gt; ）、 &lt;code&gt;alice&lt;/code&gt; 変数にアクセスできます。 また、 &lt;code&gt;sayAlice()()&lt;/code&gt; は、 &lt;code&gt;sayAlice()&lt;/code&gt; から返された関数参照を直接呼び出すだけです。これは、以前に行われたものとまったく同じですが、一時変数がありません。</target>
        </trans-unit>
        <trans-unit id="d1bbfb6c03415d46436720884428eece40742855" translate="yes" xml:space="preserve">
          <source>This example shows that the local variables are not copied &amp;mdash; they are kept by reference. It is as though the stack-frame stays alive in memory even after the outer function exits!</source>
          <target state="translated">この例は、ローカル変数がコピーされないことを示しています&amp;mdash;それらは参照によって保持されます。 これは、外部関数が終了した後でも、スタックフレームがメモリに残っているかのようです。</target>
        </trans-unit>
        <trans-unit id="cd052212f50f2244a372f8c3023bb7e1c19cf13f" translate="yes" xml:space="preserve">
          <source>This is an attempt to clear up several (possible) misunderstandings about closures that appear in some of the other answers.</source>
          <target state="translated">これは、他の回答のいくつかに出てくる閉鎖に関するいくつかの(可能性のある)誤解を解き明かす試みです。</target>
        </trans-unit>
        <trans-unit id="789cc6e4df4d97f5dde344c2fdb9c85a7781a6d9" translate="yes" xml:space="preserve">
          <source>This is called a closure.</source>
          <target state="translated">これをクロージングといいます。</target>
        </trans-unit>
        <trans-unit id="d2b023972a185beed0da123eeebf515f35e6bed3" translate="yes" xml:space="preserve">
          <source>This line is calling the function, as if it were calling a dog</source>
          <target state="translated">この行は、犬を呼び出すように関数を呼び出しています。</target>
        </trans-unit>
        <trans-unit id="2e4d80d915cf259f32a4c6b7797dea00eab65b84" translate="yes" xml:space="preserve">
          <source>This one is a real gotcha for many people, so you need to understand it. Be very careful if you are defining a function within a loop: the local variables from the closure may not act as you might first think.</source>
          <target state="translated">これは多くの人にとって本当に困った問題なので、理解しておく必要があります。ループ内で関数を定義している場合は非常に注意が必要です。</target>
        </trans-unit>
        <trans-unit id="da5cb87fcafafecdacdfe6ed51e0a0d4f98b7585" translate="yes" xml:space="preserve">
          <source>This page explains closures so that a programmer can understand them &amp;mdash; using working JavaScript code. It is not for gurus or functional programmers.</source>
          <target state="translated">このページでは、プログラマーがクロージャを理解できるように、機能するJavaScriptコードを使用してクロージャについて説明します。 教祖や関数型プログラマー向けではありません。</target>
        </trans-unit>
        <trans-unit id="8a6c734fbaac2d3b867fa1c453a226b28d630cf7" translate="yes" xml:space="preserve">
          <source>This will log &lt;code&gt;16&lt;/code&gt; because function &lt;code&gt;bar&lt;/code&gt; closes over the parameter &lt;code&gt;x&lt;/code&gt; and the variable &lt;code&gt;tmp&lt;/code&gt;, both of which exist in the lexical environment of outer function &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">関数 &lt;code&gt;bar&lt;/code&gt; がパラメーター &lt;code&gt;x&lt;/code&gt; と変数 &lt;code&gt;tmp&lt;/code&gt; をクローズするため、これは &lt;code&gt;16&lt;/code&gt; をログに記録します。どちらも外部関数 &lt;code&gt;foo&lt;/code&gt; の字句環境に存在します。</target>
        </trans-unit>
        <trans-unit id="4e28adc0562a325e3e096fedb43aec2bcfc26cc2" translate="yes" xml:space="preserve">
          <source>To summarize:</source>
          <target state="translated">要約すると</target>
        </trans-unit>
        <trans-unit id="185cffe022e026a4122cc13897f61794b5e49d80" translate="yes" xml:space="preserve">
          <source>Tricky: note the &lt;code&gt;say&lt;/code&gt; variable is also inside the closure and could be accessed by any other function that might be declared within &lt;code&gt;sayAlice()&lt;/code&gt;, or it could be accessed recursively within the inside function.</source>
          <target state="translated">トリッキー： &lt;code&gt;say&lt;/code&gt; 変数もクロージャー内にあり、 &lt;code&gt;sayAlice()&lt;/code&gt; 内で宣言されている他の関数からアクセスできたり、内部関数内で再帰的にアクセスできることに注意してください。</target>
        </trans-unit>
        <trans-unit id="7738f68d43c61aa58c8d9b9546acdd53ba567dbc" translate="yes" xml:space="preserve">
          <source>Two brief summaries</source>
          <target state="translated">2つの簡単な要約</target>
        </trans-unit>
        <trans-unit id="43a5562bc755854b701217c3e2cea0041b6a10df" translate="yes" xml:space="preserve">
          <source>Two functions might look like they have the same source text, but have completely different behavior because of their 'hidden' closure. I don't think JavaScript code can actually find out if a function reference has a closure or not.</source>
          <target state="translated">2 つの関数が同じソーステキストを持っているように見えても、「隠された」クロージャのために全く異なる動作をしている場合があります。JavaScript のコードは、関数参照がクロージャを持っているかどうかを実際に見つけることはできないと思います。</target>
        </trans-unit>
        <trans-unit id="b6e33fa589c38cb3d120879b99ebe9f6503bd521" translate="yes" xml:space="preserve">
          <source>Two other things about closures to note. First, the closure will always have access to the last values of its containing function.</source>
          <target state="translated">クロージャについて注意すべきことが二つあります。第一に、クロージャは常にその関数の最後の値にアクセスできるということです。</target>
        </trans-unit>
        <trans-unit id="9c977033015ef8f81efe5ec1a386949630df27f5" translate="yes" xml:space="preserve">
          <source>VARIABLE: The letters &lt;em&gt;var&lt;/em&gt; stand for &quot;variable&quot;. A variable is like an envelope. On the outside this envelope is marked &quot;person&quot;. On the inside it contains a slip of paper with the information our function needs, some letters and spaces joined together like a piece of string (it's called a string) that make a phrase reading &quot;an old lady&quot;. Our envelope could contain other kinds of things like numbers (called integers), instructions (called functions), lists (called &lt;em&gt;arrays&lt;/em&gt;). Because this variable is written outside of all the braces &lt;code&gt;{}&lt;/code&gt;, and because you can see out through the tinted windows when you are inside the braces, this variable can be seen from anywhere in the code. We call this a 'global variable'.</source>
          <target state="translated">変数：文字&lt;em&gt;var&lt;/em&gt;は「変数」を表します。 変数はエンベロープのようなものです。 外側には、この封筒に「人物」のマークが付いています。 内部には、私たちの機能に必要な情報が記載された紙片が含まれ、文字やスペースが文字列（文字列と呼ばれます）のように結合され、「老婦人」というフレーズを作成します。 エンベロープには、数値（整数と呼ばれる）、命令（関数と呼ばれる）、リスト（ &lt;em&gt;配列&lt;/em&gt;と呼ばれる）などの他の種類のものを含めることができます。 この変数はすべてのブレース &lt;code&gt;{}&lt;/code&gt; の外側に書き込まれ、ブレースの内側にあるときは色付きのウィンドウを通して見ることができるため、この変数はコードのどこからでも見ることができます。 これを「グローバル変数」と呼びます。</target>
        </trans-unit>
        <trans-unit id="0a3b4dd6c2b81d0408e62dc4b0c7d9aa719858b8" translate="yes" xml:space="preserve">
          <source>We can code this in JavaScript like this:</source>
          <target state="translated">このようにJavaScriptでコード化することができます。</target>
        </trans-unit>
        <trans-unit id="0dd5ca9fc457449d5a7438bfa95e87b689ade82a" translate="yes" xml:space="preserve">
          <source>We can use this example to explain closures, as follows:</source>
          <target state="translated">この例を用いて、以下のようにクロージャを説明することができます。</target>
        </trans-unit>
        <trans-unit id="cfb7d9f151f2ce139f3a16a6d13ee0a6d6a9272b" translate="yes" xml:space="preserve">
          <source>What if a variable is accessed, but it isn&amp;rsquo;t local? Like here:</source>
          <target state="translated">変数がアクセスされたがローカルではない場合はどうなりますか？ ここみたいに：</target>
        </trans-unit>
        <trans-unit id="1e8f90f12d65d0d31eedfa442526261ad87df2b7" translate="yes" xml:space="preserve">
          <source>What might not be obvious is that since &lt;code&gt;createClosureArray()&lt;/code&gt; is only invoked once only one scope is created for this function instead of one for every iteration of the loop.</source>
          <target state="translated">明らかではないかもしれませんが、 &lt;code&gt;createClosureArray()&lt;/code&gt; が呼び出されるのは、ループの反復ごとに1つではなく、この関数に対して1つのスコープのみが作成されるためです。</target>
        </trans-unit>
        <trans-unit id="082f7b2b11f91eb896764f16c3c56d45e4ee7ca7" translate="yes" xml:space="preserve">
          <source>What would happen here if JavaScript &lt;em&gt;didn't&lt;/em&gt; know closures? Just replace the call in the last line by its method body (which is basically what function calls do) and you get:</source>
          <target state="translated">JavaScript &lt;em&gt;が&lt;/em&gt;クロージャーを認識&lt;em&gt;しなかっ&lt;/em&gt;た場合、ここで何が起こりますか？ 最後の行の呼び出しをメソッド本体（基本的には関数呼び出しが行うことです）に置き換えるだけで、次のようになります。</target>
        </trans-unit>
        <trans-unit id="0d4abbfdfc801f0827fc6f8072079568d1427247" translate="yes" xml:space="preserve">
          <source>When a JavaScript function is invoked, a new execution context &lt;code&gt;ec&lt;/code&gt; is created. Together with the function arguments and the target object, this execution context also receives a link to the lexical environment of the calling execution context, meaning the variables declared in the outer lexical environment (in the above example, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;) are available from &lt;code&gt;ec&lt;/code&gt;.</source>
          <target state="translated">JavaScript関数が呼び出されると、新しい実行コンテキスト &lt;code&gt;ec&lt;/code&gt; が作成されます。 関数の引数とターゲットオブジェクトとともに、この実行コンテキストは呼び出し元の実行コンテキストの字句環境へのリンクも受け取ります。つまり、外側の字句環境で宣言された変数（上記の例では &lt;code&gt;a&lt;/code&gt; と &lt;code&gt;b&lt;/code&gt; の両方）は &lt;code&gt;ec&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7551a120ee1e0a45d0b5cf36770825ae08a23f1" translate="yes" xml:space="preserve">
          <source>When a function (&lt;code&gt;foo&lt;/code&gt;) declares other functions (bar and baz), the family of local variables created in &lt;code&gt;foo&lt;/code&gt; is &lt;em&gt;not destroyed&lt;/em&gt; when the function exits. The variables merely become invisible to the outside world. &lt;code&gt;foo&lt;/code&gt; can therefore cunningly return the functions &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt;, and they can continue to read, write and communicate with each other through this closed-off family of variables (&quot;the closure&quot;) that nobody else can meddle with, not even someone who calls &lt;code&gt;foo&lt;/code&gt; again in future.</source>
          <target state="translated">関数（ &lt;code&gt;foo&lt;/code&gt; ）が他の関数（barとbaz）を宣言する場合、 &lt;code&gt;foo&lt;/code&gt; で作成されたローカル変数のファミリーは、関数が終了して&lt;em&gt;も破棄&lt;/em&gt;され&lt;em&gt;ません&lt;/em&gt; 。 変数は単に外の世界から見えなくなります。 したがって、 &lt;code&gt;foo&lt;/code&gt; は関数 &lt;code&gt;bar&lt;/code&gt; と &lt;code&gt;baz&lt;/code&gt; を巧みに返すことができ、この閉じられた変数のファミリー（「クロージャー」）を介して、相互に読み取り、書き込み、通信を続けることができます。 &lt;code&gt;foo&lt;/code&gt; は将来再び。</target>
        </trans-unit>
        <trans-unit id="a14a687cf5a4767a5c232cb3c825bc777cc5955b" translate="yes" xml:space="preserve">
          <source>When a function is created, it gets a hidden property, named [[Scope]], which references the current LexicalEnvironment.</source>
          <target state="translated">関数が作成されると、現在のLexicalEnvironmentを参照する[[Scope]]という隠れたプロパティを取得します。</target>
        </trans-unit>
        <trans-unit id="af97d2eb165c46e20d5beb31d9f67783d9ae76ed" translate="yes" xml:space="preserve">
          <source>When a function is invoked via the internal &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist&quot;&gt;&lt;code&gt;[[Call]]&lt;/code&gt;&lt;/a&gt; method, the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt;&lt;code&gt;[[Environment]]&lt;/code&gt;&lt;/a&gt; reference on the function-object is copied into the &lt;em&gt;outer environment reference&lt;/em&gt; of the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records&quot;&gt;environment record&lt;/a&gt; of the newly-created &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;execution context&lt;/a&gt; (stack frame).</source>
          <target state="translated">内部&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist&quot;&gt; &lt;code&gt;[[Call]]&lt;/code&gt; &lt;/a&gt;メソッドを介して関数が呼び出されると、関数オブジェクトの&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt; &lt;code&gt;[[Environment]]&lt;/code&gt; &lt;/a&gt;参照が、新しく作成された&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;実行コンテキスト&lt;/a&gt; （スタックフレーム）の&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records&quot;&gt;環境レコード&lt;/a&gt;の&lt;em&gt;外部環境参照&lt;/em&gt;にコピーされます。</target>
        </trans-unit>
        <trans-unit id="eda8d0ba8c86f2bcc7f89824f85d577c09f72064" translate="yes" xml:space="preserve">
          <source>When the browser has loaded the JavaScript code an reached this line, it will start the function. I put the line at the end to make sure that the browser has all the information it needs to run it.</source>
          <target state="translated">ブラウザがJavaScriptのコードを読み込んでこの行に到達すると、関数が起動します。ブラウザが実行に必要なすべての情報を持っていることを確認するために、この行を最後に置きました。</target>
        </trans-unit>
        <trans-unit id="656c8142287a1690f7f3625f825e5d62a85448e1" translate="yes" xml:space="preserve">
          <source>When the user clicks the VoteUp button, the voteUp_click function checks whether isVotedDown == true to determine whether to vote up or merely cancel a down vote. Function voteUp_click is a closure because it is accessing its environment.</source>
          <target state="translated">ユーザがVoteUpボタンをクリックすると、voteUp_click関数はisVotedDown ==trueかどうかをチェックして、上に投票するか、単に下に投票した票を取り消すかを判断します。voteUp_click関数は、その環境にアクセスしているため、クロージャです。</target>
        </trans-unit>
        <trans-unit id="6df579e2161f6eb523745bff56a56ef486a46f72" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;new Function(&amp;hellip;)&lt;/code&gt; (the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function&quot;&gt;Function constructor&lt;/a&gt;) inside a function, it does not close over its lexical environment: it closes over the global context instead. (The new function cannot reference the local variables of the outer function.)</source>
          <target state="translated">&lt;code&gt;new Function(&amp;hellip;)&lt;/code&gt; （ &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function&quot;&gt;関数コンストラクター&lt;/a&gt; ）を使用する場合、そのレキシカル環境ではなく、代わりにグローバルコンテキストで閉じます。 （新しい関数は外部関数のローカル変数を参照できません。）</target>
        </trans-unit>
        <trans-unit id="fc1b188972939bb322463b13d9e6d79ec73b22c6" translate="yes" xml:space="preserve">
          <source>Whenever a function is declared in JavaScript a closure is created.</source>
          <target state="translated">JavaScriptで関数が宣言されるたびにクロージャが作成されます。</target>
        </trans-unit>
        <trans-unit id="42d771d468376a7581a6ea18362bea86ddcf67ad" translate="yes" xml:space="preserve">
          <source>Whenever you use &lt;code&gt;eval()&lt;/code&gt; inside a function, a closure is used. The text you &lt;code&gt;eval&lt;/code&gt; can reference local variables of the function, and within &lt;code&gt;eval&lt;/code&gt; you can even create new local variables by using &lt;code&gt;eval('var foo = &amp;hellip;')&lt;/code&gt;</source>
          <target state="translated">関数内で &lt;code&gt;eval()&lt;/code&gt; を使用する場合は常に、クロージャーが使用されます。 &lt;code&gt;eval&lt;/code&gt; テキストは関数のローカル変数を参照でき、 &lt;code&gt;eval&lt;/code&gt; 内では &lt;code&gt;eval('var foo = &amp;hellip;')&lt;/code&gt; を使用して新しいローカル変数を作成することもできます</target>
        </trans-unit>
        <trans-unit id="68b3446fbf7d6fb0e4c451a7d1ae63e9f388e484" translate="yes" xml:space="preserve">
          <source>Within each scope &lt;code&gt;n&lt;/code&gt; is bound to whatever value it had when &lt;code&gt;createClosure(n)&lt;/code&gt; was invoked so the nested function that gets returned will always return the value of &lt;code&gt;n&lt;/code&gt; that it had when &lt;code&gt;createClosure(n)&lt;/code&gt; was invoked.</source>
          <target state="translated">各スコープ内では、 &lt;code&gt;n&lt;/code&gt; は &lt;code&gt;createClosure(n)&lt;/code&gt; が呼び出されたときに持っていた値にバインドされるため、返されるネストされた関数は常に &lt;code&gt;createClosure(n)&lt;/code&gt; が呼び出されたときの &lt;code&gt;n&lt;/code&gt; の値を返します。</target>
        </trans-unit>
        <trans-unit id="f3685d63e9253161c4b5418f6dbd94db0b7b6fc6" translate="yes" xml:space="preserve">
          <source>Within this function a variable named &lt;code&gt;index&lt;/code&gt; is defined. The loop runs and adds functions to the array that return &lt;code&gt;index&lt;/code&gt;. Note that &lt;code&gt;index&lt;/code&gt; is defined within the &lt;code&gt;createClosureArray&lt;/code&gt; function which only ever gets invoked one time.</source>
          <target state="translated">この関数内で、 &lt;code&gt;index&lt;/code&gt; という名前の変数が定義されています。 ループが実行され、 &lt;code&gt;index&lt;/code&gt; を返す関数が配列に追加されます 。 &lt;code&gt;index&lt;/code&gt; は、一度だけ呼び出される &lt;code&gt;createClosureArray&lt;/code&gt; 関数内で定義されることに注意してください。</target>
        </trans-unit>
        <trans-unit id="6930e04d92d01fa662d11df5aa5d0e9bd5d8f5f8" translate="yes" xml:space="preserve">
          <source>Yes. You probably use that many times a day.</source>
          <target state="translated">そうですね、一日に何度も使っているでしょう。</target>
        </trans-unit>
        <trans-unit id="d579fab7eac666a9836aa39e6b35da201bfec6ea" translate="yes" xml:space="preserve">
          <source>You know how grown-ups can own a house, and they call it home? When a mom has a child, the child doesn't really own anything, right? But its parents own a house, so whenever someone asks the child &quot;Where's your home?&quot;, he/she can answer &quot;that house!&quot;, and point to the house of its parents. A &quot;Closure&quot; is the ability of the child to always (even if abroad) be able to say it has a home, even though it's really the parent's who own the house.</source>
          <target state="translated">大人が家を所有して、それを家と呼ぶのはどうなのか知っていますか?ママが子供を産んだ時、子供は何も持っていませんよね?でも、親が家を持っているので、「あなたの家はどこ?」と聞かれても、「あの家!」と答えて、親の家を指し示すことができます。クロージャー」とは、たとえ海外であっても、本当に家を所有しているのは親なのに、常に「家がある」と言えるようになることです。</target>
        </trans-unit>
        <trans-unit id="f95a097c531667e7c2a6ae971917615f399a2b1d" translate="yes" xml:space="preserve">
          <source>You need to understand the &quot;variable hoisting&quot; feature in Javascript in order to understand this example.</source>
          <target state="translated">この例を理解するためには、Javascriptの「変数の巻き上げ」機能を理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="12fa562f7e0a2d3533b4af8a1d5c7d14b86a0f78" translate="yes" xml:space="preserve">
          <source>You're having a sleep over and you invite Dan.
You tell Dan to bring one XBox controller.</source>
          <target state="translated">あなたはお泊り会にダンを招待しました。ダンにXBoxのコントローラーを持ってくるように言った</target>
        </trans-unit>
        <trans-unit id="0a0db21e6a13f3e33a5d7e7ef217b86c21a634c3" translate="yes" xml:space="preserve">
          <source>Your child will be able to follow two-step directions. For example, if you say to your child, &quot;Go to the kitchen and get me a trash bag&quot; they will be able to remember that direction.</source>
          <target state="translated">お子さんは二段階の指示に従うことができるようになります。例えば、「台所に行ってゴミ袋を取ってきて」と言った場合、その指示を覚えられるようになります。</target>
        </trans-unit>
        <trans-unit id="65d09cbca9a2110fcca151e4c7f0c0fb68f6c5eb" translate="yes" xml:space="preserve">
          <source>anything in outer functions</source>
          <target state="translated">外的機能の何でも</target>
        </trans-unit>
        <trans-unit id="ebf5cf1386d90514706786d86faa965c625f69a5" translate="yes" xml:space="preserve">
          <source>button or look at the Options settings to open the developer console of a browser and type &quot;person&quot; to see what this value is. Type &lt;code&gt;person=&quot;a young man&quot;&lt;/code&gt; to change it and then type &quot;person&quot; again to see that it has changed.</source>
          <target state="translated">ボタンをクリックするか、オプション設定でブラウザの開発者コンソールを開き、「person」と入力してこの値を確認します。 &lt;code&gt;person=&quot;a young man&quot;&lt;/code&gt; と入力して変更し、もう一度 &quot;person&quot;と入力して変更されたことを確認します。</target>
        </trans-unit>
        <trans-unit id="a253f2310ab98afd2ae5163409dd162753885015" translate="yes" xml:space="preserve">
          <source>ems</source>
          <target state="translated">ems</target>
        </trans-unit>
        <trans-unit id="18c4aadf416cf320b65098f9eaf67f9101b6b90e" translate="yes" xml:space="preserve">
          <source>globals, including the DOM</source>
          <target state="translated">グローバルを含む、DOM</target>
        </trans-unit>
        <trans-unit id="4f7d81389762366c131edcfc1778acc037b192e4" translate="yes" xml:space="preserve">
          <source>n = 0</source>
          <target state="translated">n=0</target>
        </trans-unit>
        <trans-unit id="92ee913214330816c21ed1490df01843b5cb2075" translate="yes" xml:space="preserve">
          <source>n = 1</source>
          <target state="translated">n=1</target>
        </trans-unit>
        <trans-unit id="ac48f9f7795484b3747139f0e4cb0790db58945a" translate="yes" xml:space="preserve">
          <source>n = 10</source>
          <target state="translated">n=10</target>
        </trans-unit>
        <trans-unit id="9a3240ad86b2b1d076825686aaf98565beeaac04" translate="yes" xml:space="preserve">
          <source>n = 2</source>
          <target state="translated">n=2</target>
        </trans-unit>
        <trans-unit id="5c515985c0cd23c7519d06977a9d6767394ced82" translate="yes" xml:space="preserve">
          <source>n = 3</source>
          <target state="translated">n=3</target>
        </trans-unit>
        <trans-unit id="83402797555a7a7885fe6185251ac997c92f242d" translate="yes" xml:space="preserve">
          <source>n = 4</source>
          <target state="translated">n=4</target>
        </trans-unit>
        <trans-unit id="adb8f164b2e9a9a073815a5580b5848dc5c47b6f" translate="yes" xml:space="preserve">
          <source>n = 5</source>
          <target state="translated">n=5</target>
        </trans-unit>
        <trans-unit id="6fec459a8cd8a34f975e728d91238f3f70ad3b48" translate="yes" xml:space="preserve">
          <source>n = 6</source>
          <target state="translated">n=6</target>
        </trans-unit>
        <trans-unit id="fd8cf86ee6124bea277fbfcdf77a50b8452d4005" translate="yes" xml:space="preserve">
          <source>n = 7</source>
          <target state="translated">n=7</target>
        </trans-unit>
        <trans-unit id="f0f1184215b3e3a06534b7ea7b8d947bb19c606d" translate="yes" xml:space="preserve">
          <source>n = 8</source>
          <target state="translated">n=8</target>
        </trans-unit>
        <trans-unit id="2cdacf2d84f0a2faf20a870a9028c14e3ea19dd0" translate="yes" xml:space="preserve">
          <source>n = 9</source>
          <target state="translated">n=9</target>
        </trans-unit>
        <trans-unit id="435cb10a0d15e1b9ac626e4505828ceeac244444" translate="yes" xml:space="preserve">
          <source>referenceToInnerFunction is set to outerFunction(), which simply returns a reference to innerFunction. When referenceToInnerFunction is called, it returns outerVar. Again, as above, this demonstrates that innerFunction has access to outerVar, a variable of outerFunction. Furthermore, it is interesting to note that it retains this access even after outerFunction has finished executing.</source>
          <target state="translated">referenceToInnerFunction には outerFunction()が設定されており、これは単に innerFunction への参照を返すだけです。referenceToInnerFunction が呼び出されると、それは outerVar を返します。繰り返しになりますが、上記のように、これは innerFunction が outerFunction の変数である outerVar へのアクセスを持っていることを示しています。さらに、興味深いのは outerFunction の実行が終了した後も、このアクセスを保持していることです。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
