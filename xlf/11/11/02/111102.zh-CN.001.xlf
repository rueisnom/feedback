<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/111102">
    <body>
      <group id="111102">
        <trans-unit id="edc3d87bc0d77451b24b00c1cf3016bdb95e72af" translate="yes" xml:space="preserve">
          <source>&quot;Come on &lt;em&gt;sing&lt;/em&gt;, Come and get &lt;em&gt;person&lt;/em&gt;!&quot;</source>
          <target state="translated">&amp;ldquo; &lt;em&gt;唱歌&lt;/em&gt; ，来吧！&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="7dd20ec9bc8964ce1c79283c85999cad1cee4dac" translate="yes" xml:space="preserve">
          <source>...is really a princess with a little girl inside.</source>
          <target state="translated">............真的是个公主,里面还有个小女孩。</target>
        </trans-unit>
        <trans-unit id="103badd33a2698b99355a3659479f625c4c33efa" translate="yes" xml:space="preserve">
          <source>...telling stories about magic and fantasy.</source>
          <target state="translated">...讲述关于魔法和幻想的故事。</target>
        </trans-unit>
        <trans-unit id="dd3acb8afd097803b9360b2f69c1fea1de5f28bb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Closure_(computer_science)&quot;&gt;Wikipedia on closures&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Closure_(computer_science)&quot;&gt;关于关闭的维基百科&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="66795f475c16753ced57a004591a7e32d1be97f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createClosure(n)&lt;/code&gt; returns a function that returns the n within that scope.</source>
          <target state="translated">&lt;code&gt;createClosure(n)&lt;/code&gt; 返回一个函数，该函数返回该范围内的n。</target>
        </trans-unit>
        <trans-unit id="0605c773a855ad7752167561fff57f3ec27930c0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you are familiar with stack frames, these calculators seem strange: How can they keep accessing &lt;code&gt;n&lt;/code&gt; after &lt;code&gt;make_calculator&lt;/code&gt; returns?  The answer is to imagine that JavaScript doesn't use &quot;stack frames&quot;, but instead uses &quot;heap frames&quot;, which can persist after the function call that made them returns.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;如果您熟悉堆栈框架，这些计算器似乎很奇怪： &lt;code&gt;make_calculator&lt;/code&gt; 返回后，它们如何继续访问 &lt;code&gt;n&lt;/code&gt; ？&lt;/em&gt; &lt;em&gt;答案是想象JavaScript不使用&amp;ldquo;堆栈框架&amp;rdquo;，而是使用&amp;ldquo;堆框架&amp;rdquo;，该堆可以在使它们返回的函数调用之后持续存在。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f02b4fea2cc85281d187a2a3101725f3bd466ca9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that &lt;code&gt;/*...*/&lt;/code&gt; and &lt;code&gt;//&lt;/code&gt; stop code being read by the browser.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;请注意，/ * ... * /和 &lt;code&gt;//&lt;/code&gt; 停止代码被浏览器读取。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11d4db30148058831981cd0f151cdbbc17e172a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://jondavidjohn.com/javascript-closure-explained-using-events/&quot;&gt;Full Blog Post&lt;/a&gt;&lt;/strong&gt; (including jQuery considerations)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://jondavidjohn.com/javascript-closure-explained-using-events/&quot;&gt;完整的博客文章&lt;/a&gt;&lt;/strong&gt; （包括jQuery注意事项）</target>
        </trans-unit>
        <trans-unit id="2184405757c5883c445a99418ddb1a5ee63000ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A closure does not reference a copy of the &lt;em&gt;old values&lt;/em&gt; of variables in its scope.&lt;/strong&gt; The variables themselves are part of the closure, and so the value seen when accessing one of those variables is the latest value at the time it is accessed. This is why inner functions created inside of loops can be tricky, since each one has access to the same outer variables rather than grabbing a copy of the variables at the time the function is created or called.</source>
          <target state="translated">&lt;strong&gt;闭包在其范围内未引用变量的&lt;em&gt;旧值&lt;/em&gt;的副本。&lt;/strong&gt; 变量本身是闭包的一部分，因此访问这些变量之一时看到的值是被访问时的最新值。 这就是为什么在循环内部创建内部函数会很棘手的原因，因为每个函数都可以访问相同的外部变量，而不是在创建或调用函数时获取变量的副本。</target>
        </trans-unit>
        <trans-unit id="fca46227ced34fb88ba8cfe8076a5166aafd4927" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A closure is not only created when you return an inner function.&lt;/strong&gt; In fact, the enclosing function &lt;em&gt;does not need to return at all&lt;/em&gt; in order for its closure to be created. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be called immediately or any time later. Therefore, the closure of the enclosing function is probably created &lt;em&gt;as soon as the enclosing function is called&lt;/em&gt; since any inner function has access to that closure whenever the inner function is called, before or after the enclosing function returns.</source>
          <target state="translated">&lt;strong&gt;闭包不仅在您返回内部函数时创建。&lt;/strong&gt; 实际上，封闭函数&lt;em&gt;根本不需要返回&lt;/em&gt;即可创建封闭函数。 您可以改为将内部函数分配给外部作用域中的变量，或将其作为参数传递给另一个函数，在该函数中可以立即或在以后的任何时间调用它。 因此，可能会在&lt;em&gt;调用封闭函数后立即&lt;/em&gt;创建封闭函数的关闭，因为只要在调用封闭函数之前或之后，任何内部函数都可以访问该封闭。</target>
        </trans-unit>
        <trans-unit id="00219869d9055a1e27de043a26f737d91e3bf84a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A simple one-line closure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;简单的单行闭包&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="91cf9ee5cd212f0f8bb3975b7361624cdd8591da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures are simple:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;闭包很简单：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="250c978ae2221ba3664641f80c30d217a35cbabd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures use memory, but they don't cause memory leaks&lt;/strong&gt; since JavaScript by itself cleans up its own circular structures that are not referenced. Internet&amp;nbsp;Explorer memory leaks involving closures are created when it fails to disconnect DOM attribute values that reference closures, thus maintaining references to possibly circular structures.</source>
          <target state="translated">&lt;strong&gt;闭包使用内存，但是它们不会导致内存泄漏，&lt;/strong&gt;因为JavaScript本身会清理自己的未引用的循环结构。 当Internet Explorer无法断开引用闭包的DOM属性值的连接时，就会创建涉及闭包的Internet Explorer内存泄漏，从而维护对可能的圆形结构的引用。</target>
        </trans-unit>
        <trans-unit id="39211d5634ba3cd86a1dc857711c0d8ac86b5585" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Closures&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d15f24a4f0cd805269e16daabf51293fb70abdd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Details&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Details&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e10d41f97175e0e801260eba2b8480649a3edd17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I do not understand why the answers are so complex here.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;我不明白为什么答案在这里这么复杂。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a50ab2a11da4fccbf9d1c29ea600ffcd387ddf7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;INSTRUCTIONS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;INSTRUCTIONS&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ff1823b9f3f4a4211cd7c4e7170f0588c83d10b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nested functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;嵌套函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53afa8789f0371667bc4398726df5e5b35cd9345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Once upon a time:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;很久以前：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f67d2cba0fc9f06b1b71e8974beb527b1d446b34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note that in an attempt to improve clarity and accuracy, this answer has been substantially changed from the original.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;请注意，为了提高清晰度和准确性，此答案已与原始答案大为不同。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dfa0bbb5599405ba4b579ca14868a26d8d25c5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THE LONG CODE EXAMPLE ABOVE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;上面的长代码示例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0def28abff50b5453af5effe03f21c319e75a393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5d4cedc50da37d6975ca1e41fe4dc499b53f427" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;That is pretty much all there is to closures.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这几乎是闭包的全部内容。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e361521851a8d0097ea1590fec832e52c6bc93db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &quot;variables&quot; in a closure include any named functions&lt;/strong&gt; declared within the function. They also include arguments of the function. A closure also has access to its containing closure's variables, all the way up to the global scope.</source>
          <target state="translated">&lt;strong&gt;闭包中的&amp;ldquo;变量&amp;rdquo;包括&lt;/strong&gt;在函数内声明的&lt;strong&gt;任何命名&lt;/strong&gt;函数。 它们还包括函数的参数。 闭包还可以访问其包含的闭包的变量，直到全局范围为止。</target>
        </trans-unit>
        <trans-unit id="4531071f03fc0a5d3c0274d7c65683c8b80868b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key point:&lt;/strong&gt; Each call to &lt;code&gt;make_calculator&lt;/code&gt; creates a new local variable &lt;code&gt;n&lt;/code&gt;, which continues to be usable by that calculator's &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt; functions long after &lt;code&gt;make_calculator&lt;/code&gt; returns.</source>
          <target state="translated">&lt;strong&gt;关键点：&lt;/strong&gt;每次对 &lt;code&gt;make_calculator&lt;/code&gt; 的调用都会创建一个新的局部变量 &lt;code&gt;n&lt;/code&gt; ，在 &lt;code&gt;make_calculator&lt;/code&gt; 返回很长时间之后，该局部变量n仍可被该计算器的 &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;multiply&lt;/code&gt; 函数使用。</target>
        </trans-unit>
        <trans-unit id="c2f004a18b07e1ba3d927ea9c5aa182e662f6312" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The whole point is to ensure that if the inner function wants to access an outer variable in the future, it is able to do so.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;关键是要确保内部函数将来要访问外部变量，它能够这么做。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9289561f1d2c7006a3223c749a580963260ce102" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;*A C# question&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;* AC＃问题&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2907f5d699e83f056b74043078bdbf321536087f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;sup&gt;**&lt;/sup&gt; Any outer function, if several are nested, or even in the global context, as &lt;a href=&quot;https://stackoverflow.com/a/5099447/706054&quot;&gt;this answer&lt;/a&gt; points out clearly.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;sup&gt;**&lt;/sup&gt;任何外部函数（如果有多个嵌套），甚至在全局上下文中，正如&lt;a href=&quot;https://stackoverflow.com/a/5099447/706054&quot;&gt;该答案&lt;/a&gt;清楚指出的那样。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="841613276b73dfb7dcf3075c43173d44d03601fb" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;sup&gt;*&lt;/sup&gt; For example, it covers all the points in the &quot;Closures for Dummies&quot; article given in &lt;a href=&quot;https://stackoverflow.com/a/111111/706054&quot;&gt;another answer&lt;/a&gt;, except example 6, which simply shows that variables can be used before they are declared, a nice fact to know but completely unrelated to closures. It also covers all the points in &lt;a href=&quot;https://stackoverflow.com/a/111200/706054&quot;&gt;the accepted answer&lt;/a&gt;, except for the points (1) that functions copy their arguments into local variables (the named function arguments), and (2) that copying numbers creates a new number, but copying an object reference gives you another reference to the same object. These are also good to know but again completely unrelated to closures. It is also very similar to the example in &lt;a href=&quot;https://stackoverflow.com/a/111114/706054&quot;&gt;this answer&lt;/a&gt; but a bit shorter and less abstract. It does not cover the point of &lt;a href=&quot;https://stackoverflow.com/a/17200991/706054&quot;&gt;this answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17308587?noredirect=1#comment26377355_111111&quot;&gt;this comment&lt;/a&gt;, which is that JavaScript makes it difficult to plug the &lt;em&gt;current&lt;/em&gt; value of a loop variable into your inner function: The &quot;plugging in&quot; step can only be done with a helper function that encloses your inner function and is invoked on each loop iteration. (Strictly speaking, the inner function accesses the helper function's copy of the variable, rather than having anything plugged in.) Again, very useful when creating closures, but not part of what a closure is or how it works. There is additional confusion due to closures working differently in functional languages like ML, where variables are bound to values rather than to storage space, providing a constant stream of people who understand closures in a way (namely the &quot;plugging in&quot; way) that is simply incorrect for JavaScript, where variables are always bound to storage space, and never to values. &lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;sup&gt;*&lt;/sup&gt;例如，它涵盖了&lt;a href=&quot;https://stackoverflow.com/a/111111/706054&quot;&gt;另一个答案中&lt;/a&gt; &amp;ldquo;封闭的傻瓜&amp;rdquo;一文中的所有要点，例6除外，该示例仅表明变量可以在声明之前使用，这是一个很好的事实，但与闭合完全无关。&lt;/sup&gt; &lt;sup&gt;它还涵盖&lt;a href=&quot;https://stackoverflow.com/a/111200/706054&quot;&gt;了接受的答案&lt;/a&gt;中的所有要点，除了以下几点：（1）函数将其参数复制到局部变量（命名的函数参数），以及（2）复制数字创建新的数字，但复制对象引用给您另一个对同一对象的引用。&lt;/sup&gt; &lt;sup&gt;这些也是很好知道的，但又与闭包完全无关。&lt;/sup&gt; &lt;sup&gt;它也与&lt;a href=&quot;https://stackoverflow.com/a/111114/706054&quot;&gt;该答案中&lt;/a&gt;的示例非常相似，但更简短，更抽象。&lt;/sup&gt; &lt;sup&gt;它没有涵盖&lt;a href=&quot;https://stackoverflow.com/a/17200991/706054&quot;&gt;此答案&lt;/a&gt;或&lt;a href=&quot;https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17308587?noredirect=1#comment26377355_111111&quot;&gt;注释&lt;/a&gt;的要点，这是因为JavaScript使得很难将循环变量的&lt;em&gt;当前&lt;/em&gt;值插入到您的内部函数中：&amp;ldquo;插入&amp;rdquo;步骤只能通过包含辅助函数的函数来完成您的内部函数，并在每次循环迭代时调用。&lt;/sup&gt; &lt;sup&gt;（严格来说，内部函数访问变量的帮助函数的副本，而不是插入任何内容。）同样，在创建闭包时非常有用，但不是闭包的一部分或工作方式的一部分。&lt;/sup&gt; &lt;sup&gt;由于闭包在ML之类的功能语言中的工作方式不同，还存在其他混乱，在这种语言中，变量绑定到值而不是存储空间，从而提供了源源不断的了解闭包的人（即&amp;ldquo;插入&amp;rdquo;方式），即对于JavaScript而言，这是完全不正确的，因为JavaScript总是将变量绑定到存储空间，而不是绑定到值。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="eb8e6848b2572e4d1686265bf069ed036b474a37" translate="yes" xml:space="preserve">
          <source>A closure in JavaScript is like keeping a reference (&lt;strong&gt;NOT&lt;/strong&gt; a copy) to the scope at the point of function declaration... plus a link to all the scopes nested outside that scope.</source>
          <target state="translated">JavaScript中的闭包就像在函数声明时保留对范围的引用（ &lt;strong&gt;不是&lt;/strong&gt;副本）...以及指向嵌套在该范围之外的所有范围的链接。</target>
        </trans-unit>
        <trans-unit id="9374176e6956e9c55a03f208ff3b626b273cf5dc" translate="yes" xml:space="preserve">
          <source>A closure is a function that has access to another function's scope (its variables and functions). The easiest way to create a closure is with a function within a function; the reason being that in JavaScript a function always has access to its containing function&amp;rsquo;s scope.</source>
          <target state="translated">闭包是可以访问另一个函数的作用域（其变量和函数）的函数。 创建闭包的最简单方法是在函数中使用一个函数。 原因是在JavaScript中，函数始终可以访问其包含函数的作用域。</target>
        </trans-unit>
        <trans-unit id="fd2d062c668410ccdcd9af34cc85522e6c1afaa2" translate="yes" xml:space="preserve">
          <source>A closure is a link between a function and its outer lexical (ie. as-written) environment, such that the identifiers (variables, parameters, function declarations etc) defined within that environment are visible from within the function, regardless of when or from where the function is invoked.</source>
          <target state="translated">封闭是一个函数和它的外部词法环境(即写出来的)之间的链接,这样,在该环境中定义的标识符(变量、参数、函数声明等)在函数内部是可见的,无论函数在什么时候或在什么地方被调用。</target>
        </trans-unit>
        <trans-unit id="cec926b0cb259356a86639e657b14e8e1b4d0b58" translate="yes" xml:space="preserve">
          <source>A closure is created when a function is declared; this closure is used to configure the execution context when the function is invoked.</source>
          <target state="translated">当声明一个函数时,会创建一个闭包;这个闭包是用来配置函数被调用时的执行上下文。</target>
        </trans-unit>
        <trans-unit id="88f672a9df48ba5975f39c3937c757038142dc61" translate="yes" xml:space="preserve">
          <source>A closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be used immediately. Therefore, the closure of the enclosing function probably already exists at the time that enclosing function was called since any inner function has access to it as soon as it is called.</source>
          <target state="translated">封包函数并不是只有在返回内部函数时才会产生。事实上,包围的函数根本不需要返回。相反,你可能会把内部函数分配给外部作用域中的一个变量,或者把它作为参数传递给另一个可以立即使用的函数。因此,包围函数的闭包函数很可能在包围函数被调用的时候就已经存在,因为任何内部函数在被调用时都可以访问它。</target>
        </trans-unit>
        <trans-unit id="cfc70bbb817358717b49d080b1eca649757aa359" translate="yes" xml:space="preserve">
          <source>A closure is one way of supporting &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;first-class functions&lt;/a&gt;; it is an expression that can reference variables within its scope (when it was first declared), be assigned to a variable, be passed as an argument to a function, or be returned as a function result.</source>
          <target state="translated">闭包是支持&lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;一流功能的&lt;/a&gt;一种方式。 它是一个表达式，可以引用其范围内的变量（首次声明时），分配给变量，作为参数传递给函数或作为函数结果返回。</target>
        </trans-unit>
        <trans-unit id="0ef763764e04164186e2a1ceb3806cf6d8f2b116" translate="yes" xml:space="preserve">
          <source>A closure is where an inner function has access to variables in its outer function. That's probably the simplest one-line explanation you can get for closures.</source>
          <target state="translated">闭包是指内部函数可以访问其外部函数中的变量。这可能是对闭包的最简单的单行解释。</target>
        </trans-unit>
        <trans-unit id="3259e0c90916fb0e4045b771243c259d5847d8f6" translate="yes" xml:space="preserve">
          <source>A function doesn't have to &lt;em&gt;return&lt;/em&gt; in order to create a closure. Simply by virtue of its declaration, every function closes over its enclosing lexical environment, forming a closure.</source>
          <target state="translated">一个函数不必为了创建一个闭包而&lt;em&gt;返回&lt;/em&gt; 。 仅仅凭借其声明，每个函数都会在其封闭的词法环境中关闭，从而形成一个闭合。</target>
        </trans-unit>
        <trans-unit id="026c5616609e62af2f61992526a7c3f75658b65c" translate="yes" xml:space="preserve">
          <source>A function in JavaScript is not just a reference to a set of instructions (as in C language), but it also includes a hidden data structure which is composed of references to all nonlocal variables it uses (captured variables). Such two-piece functions are called closures. Every function in JavaScript can be considered a closure.</source>
          <target state="translated">JavaScript中的函数不仅仅是对一组指令的引用(像C语言中那样),它还包括一个隐藏的数据结构,这个结构是由它使用的所有非本地变量(捕获的变量)的引用组成的。这样的两部分函数被称为闭包函数。JavaScript中的每一个函数都可以被认为是一个闭包。</target>
        </trans-unit>
        <trans-unit id="5ae534cf02a5858b2d840f1a7673a1afe06d7bfc" translate="yes" xml:space="preserve">
          <source>A function normally has a name, parentheses and braces. Like this:</source>
          <target state="translated">一个函数通常有一个名称、括号和括号。像这样的。</target>
        </trans-unit>
        <trans-unit id="99a4243b87430cefe6f1afae7fcb4af6221200d0" translate="yes" xml:space="preserve">
          <source>A great explanation of how closures can &lt;a href=&quot;https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited&quot;&gt;cause memory leaks in IE&lt;/a&gt; if you are not careful.</source>
          <target state="translated">如果不小心，闭包将如何&lt;a href=&quot;https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited&quot;&gt;导致IE中的内存泄漏的&lt;/a&gt;绝佳解释。</target>
        </trans-unit>
        <trans-unit id="c46e219fc09ff6a6e30c8ecd75a04e05369c3ec3" translate="yes" xml:space="preserve">
          <source>A nested function may continue to live after the outer function has finished:</source>
          <target state="translated">嵌套功能在外部功能结束后,可以继续存活。</target>
        </trans-unit>
        <trans-unit id="4ab1874227fa89cd67efbb317da32d2f6c6a64fd" translate="yes" xml:space="preserve">
          <source>A new set of local variables is kept every time a function is called (given that the function contains a function declaration inside it, and a reference to that inside function is either returned or an external reference is kept for it in some way).</source>
          <target state="translated">每次调用一个函数时,都会保留一组新的局部变量(考虑到函数内部包含一个函数声明,并且函数内部的引用要么返回,要么以某种方式为其保留一个外部引用)。</target>
        </trans-unit>
        <trans-unit id="5efdcbea95121298d3ad2d07cbbe7dcf0db4867d" translate="yes" xml:space="preserve">
          <source>ALERT: gorilla</source>
          <target state="translated">警报:大猩猩</target>
        </trans-unit>
        <trans-unit id="2d25aee06019d734098a42118e386bcd1cb56358" translate="yes" xml:space="preserve">
          <source>ALERT: monkey</source>
          <target state="translated">警报:猴子</target>
        </trans-unit>
        <trans-unit id="cd6c81ca63b69c9246d861c2e95db5f815d2ca1c" translate="yes" xml:space="preserve">
          <source>ALERT: monkey
ALERT: monkey</source>
          <target state="translated">警报:猴子 警报:猴子</target>
        </trans-unit>
        <trans-unit id="37b0eb534510d977f89353bc69e9f62a4b8877f3" translate="yes" xml:space="preserve">
          <source>After the closures come the lines</source>
          <target state="translated">封闭后的线路是</target>
        </trans-unit>
        <trans-unit id="473797be1179e97465610490a5af19283b615cbe" translate="yes" xml:space="preserve">
          <source>After the loop finished and &lt;code&gt;index&lt;/code&gt; was done being modified the end value was 10, therefore every function added to the array returns the value of the single &lt;code&gt;index&lt;/code&gt; variable which is now set to 10.</source>
          <target state="translated">循环结束并完成 &lt;code&gt;index&lt;/code&gt; 修改后，最终值为10，因此，添加到数组的每个函数都返回单个 &lt;code&gt;index&lt;/code&gt; 变量的值，该值现在设置为10。</target>
        </trans-unit>
        <trans-unit id="0c5c53c9b406b802e8050cdcb2d55f485bc7eae0" translate="yes" xml:space="preserve">
          <source>After this we have the line</source>
          <target state="translated">在这之后,我们有了这一行</target>
        </trans-unit>
        <trans-unit id="b1283dc7aa9afa2d62e552768aa61cc0797578c6" translate="yes" xml:space="preserve">
          <source>All four of these functions are closures as they all access their environment.</source>
          <target state="translated">这四种功能都是封闭的,因为它们都能进入自己的环境。</target>
        </trans-unit>
        <trans-unit id="e97e0f50a5e629695aedee5a89cca10ea6b0cb28" translate="yes" xml:space="preserve">
          <source>All of the functions added to the array return the SAME &lt;code&gt;index&lt;/code&gt; variable from the parent scope where it was defined instead of 10 different ones from 10 different scopes like the first example. The end result is that all 10 functions return the same variable from the same scope.</source>
          <target state="translated">添加到数组的所有函数都从定义它的父作用域返回SAME &lt;code&gt;index&lt;/code&gt; 变量，而不是像第一个示例那样从10个不同作用域中返回10个不同的变量。 最终结果是所有10个函数都从同一作用域返回相同的变量。</target>
        </trans-unit>
        <trans-unit id="e254452976bf3a1139922787e1c255443f069708" translate="yes" xml:space="preserve">
          <source>All this data stuff sounds a bit boring, but it is really very cool; we might have a function that tells a robot what to make for dinner. Let's say I invite you and your friend to my house. You like chicken legs best, I like sausages, your friend always wants what you want and my friend does not eat meat.</source>
          <target state="translated">所有这些数据的东西听起来有点无聊,但其实非常酷;我们可能有一个功能,可以告诉机器人晚餐要做什么菜。假设我邀请你和你的朋友来我家做饭。你最喜欢吃鸡腿,我喜欢吃香肠,你的朋友总是想吃你想吃的东西,而我的朋友不吃肉。</target>
        </trans-unit>
        <trans-unit id="86693ebc04e6080838a0974d1c5fdd94dcf0851e" translate="yes" xml:space="preserve">
          <source>All three global functions have a common reference to the &lt;em&gt;same&lt;/em&gt; closure because they are all declared within a single call to &lt;code&gt;setupSomeGlobals()&lt;/code&gt;.</source>
          <target state="translated">这三个全局函数都对&lt;em&gt;同一&lt;/em&gt;闭包有共同的引用，因为它们都在一次调用 &lt;code&gt;setupSomeGlobals()&lt;/code&gt; 中声明 。</target>
        </trans-unit>
        <trans-unit id="010ea26c09769d3f5e5a4fa466cb6c5456b66f63" translate="yes" xml:space="preserve">
          <source>All variables outside the returned function are available to the returned function, but they are not directly available to the returned function object...</source>
          <target state="translated">所有在返回函数外的变量都是可用的,但它们不能直接对返回的函数对象.....</target>
        </trans-unit>
        <trans-unit id="c4594b92814cb252202666c4d92f85aa73ea246b" translate="yes" xml:space="preserve">
          <source>Also, it must be understood that local variables in JavaScript are created not on the stack frame, but on the heap and destroyed only when no one is referencing them. When a function returns, references to its local variables are decremented, but they can still be non-null if during the current execution they became part of a closure and are still referenced by its lexically nested functions (which can happen only if the references to these nested functions were returned or otherwise transferred to some external code).</source>
          <target state="translated">另外,必须理解的是,JavaScript中的局部变量不是在堆帧上创建的,而是在堆上创建的,只有在没有人引用时才会被销毁。当一个函数返回时,对其局部变量的引用被递减,但如果在当前执行过程中,这些变量成为闭包的一部分,并且仍然被其词法嵌套的函数引用(只有当这些嵌套函数的引用被返回或以其他方式转移到一些外部代码中时,才会发生这种情况),那么它们仍然可以是非空的。</target>
        </trans-unit>
        <trans-unit id="3bce66ad1af625b4de8c481a747409bc48008eb0" translate="yes" xml:space="preserve">
          <source>Also, this private variable state is &lt;strong&gt;fully&lt;/strong&gt; accessible, for both readings and assigning to its private scoped variables.</source>
          <target state="translated">同样，该私有变量状态是&lt;strong&gt;完全&lt;/strong&gt;可访问的，既可用于读取又可分配给其私有范围的变量。</target>
        </trans-unit>
        <trans-unit id="4f230a19f88726fa9de2c57f5cbfa8e8e4472abd" translate="yes" xml:space="preserve">
          <source>An answer for a six-year-old (assuming he knows what a function is and what a variable is, and what data is):</source>
          <target state="translated">一个六岁孩子的答案(假设他知道什么是函数,什么是变量,什么是数据)。</target>
        </trans-unit>
        <trans-unit id="d7b09515b9865b30af6b3fa920a76512708611e1" translate="yes" xml:space="preserve">
          <source>An example of a closure</source>
          <target state="translated">结案的一个例子</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">举个例子:</target>
        </trans-unit>
        <trans-unit id="819beada86acdf2bbd115d5e1db66e6b0bee2da8" translate="yes" xml:space="preserve">
          <source>And even though the grown-ups knew of real princesses, they would never believe in the unicorns or dragons because they could never see them. The grown-ups said that they only existed inside the little girl's imagination.</source>
          <target state="translated">而且就算大人们知道真正的公主,也不会相信独角兽和龙的存在,因为他们永远也看不到它们。大人们说,它们只存在于小女孩的想象中。</target>
        </trans-unit>
        <trans-unit id="57dfb708e06183c8ecb1f0c30e96af35afaf50ba" translate="yes" xml:space="preserve">
          <source>And here is where things get really interesting. If we were to get rid of outerFunction, say set it to null, you might think that referenceToInnerFunction would loose its access to the value of outerVar. But this is not the case.</source>
          <target state="translated">这里是事情变得非常有趣的地方。如果我们去掉 outerFunction,比如说把它设置为 null,你可能会认为 referenceToInnerFunction 将失去对 outerVar 的值的访问。但事实并非如此。</target>
        </trans-unit>
        <trans-unit id="435fb8d87e8d248469850188da7e2ad10deaaf3b" translate="yes" xml:space="preserve">
          <source>And if you remember, when &lt;code&gt;this.say&lt;/code&gt; is created, it (as every function) gets an internal reference &lt;code&gt;this.say.[[Scope]]&lt;/code&gt; to the current LexicalEnvironment. So, the LexicalEnvironment of the current User execution stays in memory. All variables of User also are its properties, so they are also carefully kept, not junked as usually.</source>
          <target state="translated">并且，如果您还记得，当创建 &lt;code&gt;this.say&lt;/code&gt; 时，它（作为每个函数）将获得内部 &lt;code&gt;this.say.[[Scope]]&lt;/code&gt; 到当前LexicalEnvironment的内部引用。 因此，当前用户执行的LexicalEnvironment保留在内存中。 User的所有变量也都是其属性，因此也要小心保留它们，而不是像平常一样。</target>
        </trans-unit>
        <trans-unit id="625ff0ae825173e464152e82b8c8264f2701a52a" translate="yes" xml:space="preserve">
          <source>And now, even though Mary is &quot;no longer running&quot;, the memory of her is not lost and her child will always remember her name and other secrets they shared during their time together.</source>
          <target state="translated">而现在,即使玛丽 &quot;不再奔波&quot;,但对她的记忆并没有消失,她的孩子也会永远记住她的名字和他们在一起的日子里分享的其他秘密。</target>
        </trans-unit>
        <trans-unit id="dd1dc01a62936ce68f2808899afc6036354d1594" translate="yes" xml:space="preserve">
          <source>And she would often tell them of her latest amazing adventure as a princess.</source>
          <target state="translated">而她经常会以公主的身份向他们讲述她最近的奇妙冒险。</target>
        </trans-unit>
        <trans-unit id="b4380f96cc0e7a3c2e34bc8ce6205c32c2126439" translate="yes" xml:space="preserve">
          <source>And yes, I'd even recommend it to a 6-year old -- if the 6-year old is learning about closures, then it's logical they're ready to comprehend the &lt;em&gt;concise and simple explanation&lt;/em&gt; provided in the article.</source>
          <target state="translated">是的，我什至推荐给6岁的孩子使用-如果6岁的孩子正在学习闭包，那么可以随时理解本文提供的&lt;em&gt;简洁明了&lt;/em&gt;的逻辑是合乎逻辑的。</target>
        </trans-unit>
        <trans-unit id="174ee1c1a9c452a97f5a4e71705d3ba0633128b2" translate="yes" xml:space="preserve">
          <source>Another really simple way to explain it is in terms of scope:</source>
          <target state="translated">另一个真正简单的解释方法是在范围上。</target>
        </trans-unit>
        <trans-unit id="efcadf61fe3fe42ed34cfdd66b0ecbf1ed3408ef" translate="yes" xml:space="preserve">
          <source>Any time you create a smaller scope inside of a larger scope, the smaller scope will always be able to see what is in the larger scope.</source>
          <target state="translated">任何时候你在大范围的范围内创建一个较小的范围,小范围的范围总能看到大范围内的东西。</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="d5593bba6625e12152d79d70e57424cdd0e4f606" translate="yes" xml:space="preserve">
          <source>As a father of a 6-year-old, currently teaching young children (and a relative novice to coding with no formal education so corrections will be required), I think the lesson would stick best through hands-on play. If the 6-year-old is ready to understand what a closure is, then they are old enough to have a go themselves. I'd suggest pasting the code into jsfiddle.net, explaining a bit, and leaving them alone to concoct a unique song. The explanatory text below is probably more appropriate for a 10 year old.</source>
          <target state="translated">作为一个6岁孩子的父亲,目前正在教年幼的孩子(也是一个相对的编码新手,没有接受过正规的教育,所以需要改正),我认为这门课最好是通过动手操作的方式来进行。如果6岁的孩子已经准备好了,可以理解什么是闭合,那么他们已经足够大了,可以自己动手操作了。我建议将代码粘贴到jsfiddle.net中,稍微解释一下,让他们自己去构思一首独特的歌曲。下面的解说词可能更适合10岁的孩子。</target>
        </trans-unit>
        <trans-unit id="6568100bffff0b20e0c37f88a640e7173cdcd704" translate="yes" xml:space="preserve">
          <source>As we see, &lt;code&gt;this.say&lt;/code&gt; is a property in the user object, so it continues to live after User completed.</source>
          <target state="translated">如我们所见， &lt;code&gt;this.say&lt;/code&gt; 是用户对象中的一个属性，因此它在用户完成后仍继续存在。</target>
        </trans-unit>
        <trans-unit id="e1626c59ebd74e38dd52b09e3c12153695d67816" translate="yes" xml:space="preserve">
          <source>As you can see, the toys left in the room are still accessible via the brother and no matter if the room is locked. Here is &lt;a href=&quot;http://jsbin.com/ubakor/9/edit&quot;&gt;a jsbin&lt;/a&gt; to play around with it.</source>
          <target state="translated">如您所见，无论房间是否上锁，仍然可以通过兄弟访问留在房间里的玩具。 这是&lt;a href=&quot;http://jsbin.com/ubakor/9/edit&quot;&gt;一个可玩的jsbin&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="890df09169ac0377be2b819d1f924abc0cd10e89" translate="yes" xml:space="preserve">
          <source>As you may guess, because the variables are re-created every time the function is called, and nobody else will know them, there must be a secret place where they are stored. It could be called &lt;strong&gt;Chamber of Secrets&lt;/strong&gt; or &lt;strong&gt;stack&lt;/strong&gt; or &lt;strong&gt;local scope&lt;/strong&gt; but it doesn't really matter. We know they are there, somewhere, hidden in the memory.</source>
          <target state="translated">您可能会猜到，因为每次调用函数时都会重新创建变量，并且没人会知道它们，所以必须在一个秘密的地方存储它们。 可以将其称为&lt;strong&gt;&amp;ldquo;密室&amp;rdquo;&lt;/strong&gt;或&amp;ldquo; &lt;strong&gt;堆栈&amp;rdquo;&lt;/strong&gt;或&amp;ldquo; &lt;strong&gt;本地范围&amp;rdquo;，&lt;/strong&gt;但这并不重要。 我们知道它们在那里，藏在内存中。</target>
        </trans-unit>
        <trans-unit id="986da2f4d4b325d9fb2c07a7e2b3897081cd863a" translate="yes" xml:space="preserve">
          <source>BRACES: &quot;Braces&quot; which look like this &lt;code&gt;{}&lt;/code&gt; are the tinted windows of our factory. From inside the factory you can see out, but from the outside you can't see in.</source>
          <target state="translated">大括号：看起来像 &lt;code&gt;{}&lt;/code&gt; 的 &amp;ldquo;括号&amp;rdquo;是我们工厂的有色窗户。 从工厂内部可以看到，但是从外部看不到。</target>
        </trans-unit>
        <trans-unit id="3575d07a466999847f383f17914159e3dbdd22b0" translate="yes" xml:space="preserve">
          <source>BROWSER: When you connect to the Internet on a computer, tablet or phone to visit a website, you use a browser. Examples you may know are Internet Explorer, Chrome, Firefox and Safari. The browser can understand JavaScript and tell the computer what it needs to do. The JavaScript instructions are called functions.</source>
          <target state="translated">浏览器:当您用电脑、平板电脑或手机连接到互联网上访问网站时,您使用的是浏览器。你可能知道的例子有Internet Explorer、Chrome、Firefox和Safari。浏览器可以理解JavaScript,并告诉计算机需要做什么。这些JavaScript指令被称为函数。</target>
        </trans-unit>
        <trans-unit id="0419e91da10b803e76b92f8dffe5555643e1dd03" translate="yes" xml:space="preserve">
          <source>Because all these external variables referenced by a lexically nested function are actually local variables in the chain of its lexically enclosing functions (global variables can be assumed to be local variables of some root function), and every single execution of a function creates new instances of its local variables, it follows that every execution of a function returning (or otherwise transferring it out, such as registering it as a callback) a nested function creates a new closure (with its own potentially unique set of referenced nonlocal variables which represent its execution context).</source>
          <target state="translated">由于词法嵌套函数引用的所有这些外部变量实际上都是它的词法包围函数链中的局部变量(全局变量可以被假定为某些根函数的局部变量),而且函数的每一次执行都会创建新的局部变量的实例,因此,每一次执行一个函数返回(或以其他方式将其转移出去,例如将其注册为回调)一个嵌套函数,就会创建一个新的闭包(有它自己的潜在唯一的引用非局部变量集,这些非局部变量代表它的执行上下文)。</target>
        </trans-unit>
        <trans-unit id="42668682fc7dcf2769407c41fc937cdbf7dd8025" translate="yes" xml:space="preserve">
          <source>Because there was only one scope within the &lt;code&gt;createClosureArray()&lt;/code&gt; function, &lt;code&gt;index&lt;/code&gt; is only bound to a value within that scope. In other words, each time the loop changes the value of &lt;code&gt;index&lt;/code&gt;, it changes it for everything that references it within that scope.</source>
          <target state="translated">由于 &lt;code&gt;createClosureArray()&lt;/code&gt; 函数中只有一个作用域，因此 &lt;code&gt;index&lt;/code&gt; 仅绑定到该范围内的一个值。 换句话说，每次循环更改 &lt;code&gt;index&lt;/code&gt; 的值时，都会为该范围内引用它的所有内容更改它。</target>
        </trans-unit>
        <trans-unit id="14c3a147917bc6f80510553c690b0ab8c8718635" translate="yes" xml:space="preserve">
          <source>But all they would see is a little girl...</source>
          <target state="translated">但他们看到的都是一个小女孩......</target>
        </trans-unit>
        <trans-unit id="bb8c57c634a563056b164f5aeb01e4ac8232dc6d" translate="yes" xml:space="preserve">
          <source>But how is this so? How can referenceToInnerFunction still know the value of outerVar now that outerFunction has been set to null?</source>
          <target state="translated">但是,为什么会这样呢?现在externalFunction被设为null了,怎么还能知道externalVar的值呢?</target>
        </trans-unit>
        <trans-unit id="146180db52e416274e24ed731f90ff6fc5ad3201" translate="yes" xml:space="preserve">
          <source>But she would always have to return back to her dull world of chores and grown-ups.</source>
          <target state="translated">但是,她总是要回到沉闷的家务和大人的世界里去。</target>
        </trans-unit>
        <trans-unit id="866ff54f49d509edc499efd08ef16cd5aed44ee7" translate="yes" xml:space="preserve">
          <source>But the sad thing is, if the child is also a private variable of its parent function, it would also die when the parent ends, and the secrets would die with them.</source>
          <target state="translated">但可悲的是,如果这个孩子也是它的父函数的私有变量,那么当父函数结束时,这个孩子也会随着父函数的结束而死,秘密也会随之而死。</target>
        </trans-unit>
        <trans-unit id="dbf03411a9d8f9c4e1de5345b3a10c168dfc2df8" translate="yes" xml:space="preserve">
          <source>But we know the real truth; that the little girl with the princess inside...</source>
          <target state="translated">但是,我们知道真正的真相,那就是里面有公主的小女孩......</target>
        </trans-unit>
        <trans-unit id="a343ea5602007ce993e1966d841864424094a57f" translate="yes" xml:space="preserve">
          <source>But, in JavaScript there is this very special thing that functions which are created inside other functions, can also know the local variables of their parents and keep them as long as they live.</source>
          <target state="translated">但是,在JavaScript中,有一个非常特殊的东西,那就是在其他函数内部创建的函数,也可以知道它们的父变量的本地变量,只要它们还活着,就可以保留它们。</target>
        </trans-unit>
        <trans-unit id="5d22ad9eb11c8d7544b41c9fd9c72490630172cd" translate="yes" xml:space="preserve">
          <source>CLOSURES DONE RIGHT</source>
          <target state="translated">合拢</target>
        </trans-unit>
        <trans-unit id="b8c469b8120b44b5dd72fc632091339193c9122a" translate="yes" xml:space="preserve">
          <source>CLOSURES DONE WRONG</source>
          <target state="translated">误封</target>
        </trans-unit>
        <trans-unit id="3344264f6f33fcb6fbcf186f0b6ad57482d348ae" translate="yes" xml:space="preserve">
          <source>CLOSURES: The closures are the smaller functions that are inside the big &lt;em&gt;sing()&lt;/em&gt; function. The little factories inside the big factory. They each have their own braces which mean that the variables inside them can't be seen from the outside. That's why the names of the variables (&lt;em&gt;creature&lt;/em&gt; and &lt;em&gt;result&lt;/em&gt;) can be repeated in the closures but with different values. If you type these variable names in the console window, you won't get its value because it's hidden by two layers of tinted windows.</source>
          <target state="translated">关闭：关闭是在&lt;em&gt;sing（）&lt;/em&gt;函数内部的较小函数。 大工厂里面的小工厂。 它们每个都有自己的大括号，这意味着它们的变量无法从外部看到。 这就是为什么变量名（ &lt;em&gt;生物&lt;/em&gt;和&lt;em&gt;结果&lt;/em&gt; ）可以在闭包中重复但值不同的原因。 如果在控制台窗口中键入这些变量名，则不会获得其值，因为它被两层着色窗口隐藏。</target>
        </trans-unit>
        <trans-unit id="76ad173357129e5535c24cd674bddfaff61e8338" translate="yes" xml:space="preserve">
          <source>CODE: All the writing above is called &lt;em&gt;code&lt;/em&gt;. It is written in JavaScript.</source>
          <target state="translated">代码：上面的所有文字都称为&lt;em&gt;代码&lt;/em&gt; 。 它是用JavaScript编写的。</target>
        </trans-unit>
        <trans-unit id="a0c7bc52b3fa8bb1b47ad931aa67baef1da44403" translate="yes" xml:space="preserve">
          <source>Can anybody consider that I am 6 and strangely interested in that subject ?</source>
          <target state="translated">有人能考虑到我是6岁,而且对这个话题感兴趣吗?</target>
        </trans-unit>
        <trans-unit id="0754a0ac49d4de7ab61d6c51b9280396aeeb0c9d" translate="yes" xml:space="preserve">
          <source>Can you explain closures to a 5-year-old?*</source>
          <target state="translated">你能给一个5岁的孩子解释一下吗?</target>
        </trans-unit>
        <trans-unit id="c6abb0edfb41f4eed3192a92b93e8777584cfbc6" translate="yes" xml:space="preserve">
          <source>Closures are &lt;em&gt;not hard&lt;/em&gt; to understand once the core concept is grokked. However, they are impossible to understand by reading any theoretical or academically oriented explanations!</source>
          <target state="translated">一旦核心概念浮出水面，关闭&lt;em&gt;就不&lt;/em&gt;难理解。 但是，通过阅读任何理论或学术上的解释是不可能理解它们的！</target>
        </trans-unit>
        <trans-unit id="473e3864991bcdfffaa54377115d58425884b1de" translate="yes" xml:space="preserve">
          <source>Closures are a way to let a function
  have &lt;strong&gt;persistent, private variables&lt;/strong&gt; -
  that is, variables that only one
  function knows about, where it can
  keep track of info from previous times
  that it was run.</source>
          <target state="translated">闭包是一种使函数具有&lt;strong&gt;永久性私有变量的&lt;/strong&gt;方法，也就是说，只有一个函数才知道的变量，它可以在其中跟踪以前运行时的信息。</target>
        </trans-unit>
        <trans-unit id="2dab57988b39942ebe3792aab7459b19fb524730" translate="yes" xml:space="preserve">
          <source>Closures are functions with a state. It is somewhat similar to &quot;this&quot; in the sense that &quot;this&quot; also provides state for a function but function and &quot;this&quot; are separate objects (&quot;this&quot; is just a fancy parameter, and the only way to bind it permanently to a function is to create a closure). While &quot;this&quot; and function always live separately, a function cannot be separated from its closure and the language provides no means to access captured variables.</source>
          <target state="translated">闭包是一个具有状态的函数。它与 &quot;this &quot;有点类似,&quot;this &quot;也为函数提供了状态,但函数和 &quot;this &quot;是独立的对象(&quot;this &quot;只是一个花哨的参数,唯一能将其永久绑定到函数上的方法就是创建一个闭包)。虽然 &quot;this &quot;和函数始终是分开生活的,但函数不能脱离它的闭包,语言也没有提供任何方法来访问捕获变量。</target>
        </trans-unit>
        <trans-unit id="9a8fe763a050a9c6f2b9d029f15de875acec4c6c" translate="yes" xml:space="preserve">
          <source>Closures are hard to explain because they are used to make some behaviour work that everybody intuitively expects to work anyway. I find the best way to explain them (and the way that &lt;em&gt;I&lt;/em&gt; learned what they do) is to imagine the situation without them:</source>
          <target state="translated">闭包很难解释，因为闭包用于使某些行为正常工作，每个人都希望它们能正常工作。 我发现解释它们的最佳方法（以及&lt;em&gt;我&lt;/em&gt;了解它们的方法）是想象没有它们的情况：</target>
        </trans-unit>
        <trans-unit id="13cd6611b47d0c0e96535f2857655ffbc4aec970" translate="yes" xml:space="preserve">
          <source>Closures are not magic</source>
          <target state="translated">封闭不是魔术</target>
        </trans-unit>
        <trans-unit id="81857059bb8f6b3c5d16c47af8818ad9c8d4ef06" translate="yes" xml:space="preserve">
          <source>Closures are often used for creating functions with some hidden private data (but it's not always the case).</source>
          <target state="translated">封闭器通常用于创建带有一些隐藏的私有数据的函数(但并不总是这样)。</target>
        </trans-unit>
        <trans-unit id="f1f2dd80b45193a64a6fed6f703fea1610ee7907" translate="yes" xml:space="preserve">
          <source>Closures done right:</source>
          <target state="translated">封锁做得很好。</target>
        </trans-unit>
        <trans-unit id="2b5870c633c063933016ddcafff1a5b85221b713" translate="yes" xml:space="preserve">
          <source>Closures done wrong:</source>
          <target state="translated">封闭做错了。</target>
        </trans-unit>
        <trans-unit id="65f3c9fe79ec9c90973a968f76051ad6208d1eff" translate="yes" xml:space="preserve">
          <source>Compare with a situation when a door was locked by draft and nobody inside (general function execution), and then some local fire occur and burn down the room (garbage collector:D), and then a new room was build and now you may leave another toys there (new function instance), but never get the same toys which were left in the first room instance.</source>
          <target state="translated">对比一下,有一种情况是门被草稿锁住了,里面没有人(一般功能执行),然后发生了一些局部火灾,烧毁了房间(垃圾收集器:D),然后建了一个新的房间,现在可以把另一个玩具留在那里(新的功能实例),但永远不会得到和第一个房间实例中的玩具一样的玩具。</target>
        </trans-unit>
        <trans-unit id="895fc54743a0a38a6edff320b747a9f3e67aa96b" translate="yes" xml:space="preserve">
          <source>Consider this option</source>
          <target state="translated">考虑一下这个选项</target>
        </trans-unit>
        <trans-unit id="d29543a41f8e03fb1f0ca60d30879d8d14612042" translate="yes" xml:space="preserve">
          <source>DATA: Data is a collection of facts. It can be numbers, words, measurements, observations or even just descriptions of things. You can't touch it, smell it or taste it. You can write it down, speak it and hear it. You could use it to &lt;em&gt;create&lt;/em&gt; touch smell and taste using a computer. It can be made useful by a computer using code.</source>
          <target state="translated">数据：数据是事实的集合。 它可以是数字，单词，量度，观察值，甚至只是事物的描述。 您不能触摸，闻到或尝尝它。 您可以写下来，说出来并听到。 您可以使用它在计算机上&lt;em&gt;产生&lt;/em&gt;触摸气味和味道。 计算机可以使用代码使它变得有用。</target>
        </trans-unit>
        <trans-unit id="1386ebeed6520345b3b7b8e117496e328fb4ca5d" translate="yes" xml:space="preserve">
          <source>Dan invites Paul.
Dan asks Paul to bring one controller. How many controllers were brought to the party?</source>
          <target state="translated">丹邀请保罗。丹要求保罗带一个控制器。派对上带了多少个控制器?</target>
        </trans-unit>
        <trans-unit id="ec2a42fc389ecb1dc4b9d0c461e02170df77d766" translate="yes" xml:space="preserve">
          <source>Douglas Crockford's simulated &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;private attributes and private methods&lt;/a&gt; for an object, using closures.</source>
          <target state="translated">Douglas Crockford使用闭包为对象模拟了对象的&lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;私有属性和私有方法&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="1f5d96dd43fe4410f4d7bee1eb9596663a115a2d" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;makeKitchen()&lt;/code&gt; is called, a new closure is created with its own separate &lt;code&gt;trashBags&lt;/code&gt;.</source>
          <target state="translated">每次调用 &lt;code&gt;makeKitchen()&lt;/code&gt; 时 ，都会使用其自己的单独的 &lt;code&gt;trashBags&lt;/code&gt; 创建一个新的闭包。</target>
        </trans-unit>
        <trans-unit id="be4a4610d526a11fb6ad4a43add51b702b4757b8" translate="yes" xml:space="preserve">
          <source>Environment, which includes:</source>
          <target state="translated">环境,其中包括:</target>
        </trans-unit>
        <trans-unit id="d753a72a73e7b9b72686150b4751eec2271aff2d" translate="yes" xml:space="preserve">
          <source>Every function call creates a closure, but there would be no need to keep the closure around unless an inner function, which has access to the inside of the closure, can be called from outside the closure.  Returning the object with the &lt;code&gt;getTrashBag&lt;/code&gt; function does that here.</source>
          <target state="translated">每个函数调用都会创建一个闭包，但是除非可以从闭包外部调用可以访问闭包内部的内部函数，否则无需保留闭包。 在这里使用 &lt;code&gt;getTrashBag&lt;/code&gt; 函数返回对象。</target>
        </trans-unit>
        <trans-unit id="d1e850e44398a4bd60c4144c1c65f8512d37dff4" translate="yes" xml:space="preserve">
          <source>Every function creates a closure, because every function has a link to its outer lexical environment.</source>
          <target state="translated">每一个函数都会产生一个闭合,因为每一个函数都有一个与外部词法环境的链接。</target>
        </trans-unit>
        <trans-unit id="adc27653e819f465f9e2820186db79ad5283608e" translate="yes" xml:space="preserve">
          <source>Every function in JavaScript maintains a link to its outer lexical environment. A lexical environment is a map of all the names (eg. variables, parameters) in a scope, with their values.</source>
          <target state="translated">JavaScript中的每个函数都维护着一个链接到它的外部词库环境。词法环境是一个范围内所有名称(如变量、参数)及其值的映射。</target>
        </trans-unit>
        <trans-unit id="45ace4e4578d45cf9975840a42650a40883c1e4a" translate="yes" xml:space="preserve">
          <source>Every time you call it, local variable &quot;name&quot; is created and given name &quot;Mary&quot;. And every time the function exits the variable is lost and the name is forgotten.</source>
          <target state="translated">每次调用时,本地变量 &quot;name &quot;会被创建并被赋予 &quot;Mary &quot;这个名字。而每次函数退出时,这个变量就会丢失,名字也会被遗忘。</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="translated">例3</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="translated">例4</target>
        </trans-unit>
        <trans-unit id="dcb2a7f833e9a3ee29881cf3f00069ceeab20571" translate="yes" xml:space="preserve">
          <source>Example 5</source>
          <target state="translated">例5</target>
        </trans-unit>
        <trans-unit id="69126e599801a8577cf34e537a3e5b119797d966" translate="yes" xml:space="preserve">
          <source>Example 6</source>
          <target state="translated">例子6</target>
        </trans-unit>
        <trans-unit id="5da743f6856f59f85c81f30e766731f5631a39c2" translate="yes" xml:space="preserve">
          <source>Example 7</source>
          <target state="translated">例7</target>
        </trans-unit>
        <trans-unit id="6f1ddb45d4ea126c3c0d9697dd3671172ae3bca1" translate="yes" xml:space="preserve">
          <source>Example for the first point by dlaliberte:</source>
          <target state="translated">第一点由dlaliberte举例说明。</target>
        </trans-unit>
        <trans-unit id="9726b2f5643205ff1a7ab0c75e5e5eb34bbe5072" translate="yes" xml:space="preserve">
          <source>Example of a closure that uses the global environment:</source>
          <target state="translated">使用全局环境的闭环的例子。</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="e262aa4c560f1ae35fd6e5cf5ac45462ea46ecc8" translate="yes" xml:space="preserve">
          <source>F12</source>
          <target state="translated">F12</target>
        </trans-unit>
        <trans-unit id="770cc5fbad4b752ed78f4565ed7a44533e740e5d" translate="yes" xml:space="preserve">
          <source>FOREWORD: this answer was written when the question was:</source>
          <target state="translated">前言:这个答案是在出题时写的。</target>
        </trans-unit>
        <trans-unit id="23ddff2ba060d9ccf1c6bed76f90cfb75043258a" translate="yes" xml:space="preserve">
          <source>FUNCTION: A function in JavaScript is like a factory. It might be a little factory with only one machine inside. Or it might contain many other little factories, each with many machines doing different jobs. In a real life clothes factory you might have reams of cloth and bobbins of thread going in and T-shirts and jeans coming out. Our JavaScript factory only processes data, it can't sew, drill a hole or melt metal. In our JavaScript factory data goes in and data comes out.</source>
          <target state="translated">FUNCTION:JavaScript中的函数就像一个工厂。它可能是一个小工厂,里面可能只有一台机器。或者它可能包含许多其他的小工厂,每个工厂里有许多机器在做不同的工作。在现实生活中的服装工厂中,你可能会有成堆的布和成捆的线进去,T恤和牛仔裤出来。而我们的JavaScript工厂只处理数据,它不能缝制、钻洞或熔化金属。在我们的JavaScript工厂中,数据进去,数据出来。</target>
        </trans-unit>
        <trans-unit id="8084a292fef2035ee22a2314d1fd8d2ea5ef70cc" translate="yes" xml:space="preserve">
          <source>Fairly Obvious Solution</source>
          <target state="translated">很明显的解决方案</target>
        </trans-unit>
        <trans-unit id="8d7ca8f60d208999584a7667dd568dbdc67e89aa" translate="yes" xml:space="preserve">
          <source>Final points:</source>
          <target state="translated">最后几点:</target>
        </trans-unit>
        <trans-unit id="0db6ddf1596c4847d4487ff8d0eb1324a650d77c" translate="yes" xml:space="preserve">
          <source>First, when a function f is created, it is not created in an empty
space. There is a current LexicalEnvironment object. In the case
above, it&amp;rsquo;s window (a is undefined at the time of function
creation).</source>
          <target state="translated">首先，创建函数f时，不会在空白处创建它。 当前有一个LexicalEnvironment对象。 在上述情况下，它是窗口（在函数创建时未定义a）。</target>
        </trans-unit>
        <trans-unit id="2a73ef77ff6936404496b87ca2548febfdec5ccf" translate="yes" xml:space="preserve">
          <source>For an advanced child I would put something like the following. It is not perfect, but it makes you feel about what it is:</source>
          <target state="translated">对于高年级的孩子,我会放下面这样的内容。虽然不完美,但能让你感受到它是什么。</target>
        </trans-unit>
        <trans-unit id="ea9adb725d4b9bd42aa2bf3daca3985abf217214" translate="yes" xml:space="preserve">
          <source>For some reason, closures seem really hard to understand when you read about them, but when you see some examples, it becomes clear how they work (it took me a while).
I recommend working through the examples carefully until you understand how they work. If you start using closures without fully understanding how they work, you would soon create some very weird bugs!</source>
          <target state="translated">由于某些原因,当你读到闭合器时,似乎真的很难理解,但当你看到一些例子时,你就会明白它们是如何工作的(我花了一段时间)。我建议你仔细阅读这些例子,直到你明白它们是如何工作的。如果你在没有完全理解它们的工作原理之前就开始使用闭包,那么你很快就会产生一些非常奇怪的BUG!</target>
        </trans-unit>
        <trans-unit id="a6457c5f7670ec3d5b6eba35695e935bfa1d35af" translate="yes" xml:space="preserve">
          <source>Full post:</source>
          <target state="translated">全职。</target>
        </trans-unit>
        <trans-unit id="086a1f90a0a0f91e7d5f1400d0b9f2eaa0c70efd" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;bar&lt;/code&gt;, together with its link with the lexical environment of function &lt;code&gt;foo&lt;/code&gt; is a closure.</source>
          <target state="translated">函数 &lt;code&gt;bar&lt;/code&gt; 及其与函数 &lt;code&gt;foo&lt;/code&gt; 的词法环境的链接都是闭包。</target>
        </trans-unit>
        <trans-unit id="df465d5385e7a5492e6da9185d4edd6ca0741d1e" translate="yes" xml:space="preserve">
          <source>Functions can be nested one inside another, forming a chain of LexicalEnvironments which can also be called a scope chain.</source>
          <target state="translated">函数可以相互嵌套,形成一个LexicalEnvironment链,也可以称为范围链。</target>
        </trans-unit>
        <trans-unit id="735a10dcfecac98bd4863f42c020b050d39de8ff" translate="yes" xml:space="preserve">
          <source>Functions can return data. One kind of data you can return from a function is another function. When that new function gets returned, all the variables and arguments used in the function that created it don't go away. Instead, that parent function &quot;closes.&quot; In other words, nothing can look inside of it and see the variables it used except for the function it returned. That new function has a special ability to look back inside the function that created it and see the data inside of it.</source>
          <target state="translated">函数可以返回数据。你可以从一个函数中返回的一种数据是另一个函数。当那个新函数被返回时,所有的变量和参数在创建它的函数中使用的变量和参数都不会消失。相反,那个父函数会 &quot;关闭&quot;。换句话说,除了它返回的函数之外,没有任何东西可以查看它的内部,也看不到它所使用的变量。这个新函数有一个特殊的能力,可以回看创建它的函数内部,看到它内部的数据。</target>
        </trans-unit>
        <trans-unit id="d6e834997432ff006f3ca11dc3e560bb2b2db750" translate="yes" xml:space="preserve">
          <source>Functions define actions  - the main function is about singing. It contains a variable called &lt;em&gt;firstPart&lt;/em&gt; which applies to the singing about the person that applies to each of the verses of the song: &quot;There was &quot; + person + &quot; who swallowed&quot;. If you type &lt;em&gt;firstPart&lt;/em&gt; into the console, you won't get an answer because the variable is locked up in a function - the browser can't see inside the tinted windows of the braces.</source>
          <target state="translated">功能定义动作-主要功能是唱歌。 它包含一个名为&lt;em&gt;firstPart&lt;/em&gt;的变量，该变量适用于歌唱每首歌的人的歌唱：&amp;ldquo;有&amp;ldquo; +人+谁在吞咽&amp;rdquo;。 如果在控制台中键入&lt;em&gt;firstPart&lt;/em&gt; ，则不会得到答案，因为该变量已锁定在函数中-浏览器无法在花括号的着色窗口内看到。</target>
        </trans-unit>
        <trans-unit id="3ddedd19f21650712b05b0d15a1aaf5ed1d17916" translate="yes" xml:space="preserve">
          <source>Further points that explain why closures are interesting:</source>
          <target state="translated">进一步解释为什么要关闭的观点是有趣的。</target>
        </trans-unit>
        <trans-unit id="09cf114b1e0fe4fe38544c7a0d90cf0e556abc15" translate="yes" xml:space="preserve">
          <source>GLOBAL VARIABLE: &lt;em&gt;person&lt;/em&gt; is a global variable, meaning that if you change its value from &quot;an old lady&quot; to &quot;a young man&quot;, the &lt;em&gt;person&lt;/em&gt; will keep being a young man until you decide to change it again and that any other function in the code can see that it's a young man. Press the</source>
          <target state="translated">GLOBAL VARIABLE： &lt;em&gt;person&lt;/em&gt;是一个全局变量，这意味着如果将其值从&amp;ldquo;老太太&amp;rdquo;更改为&amp;ldquo;年轻人&amp;rdquo;，则该&lt;em&gt;人&lt;/em&gt;将一直是年轻人，直到您决定再次更改它，并且其他任何功能代码可以看到这是一个年轻人。 按下</target>
        </trans-unit>
        <trans-unit id="25334edab2e807f8912b0462c0c1d557fdc5ebe8" translate="yes" xml:space="preserve">
          <source>Get it? So in our primary example, the count variable is contained within the closure and always available to the event handler, so it retains its state from click to click.</source>
          <target state="translated">明白了吗?所以在我们的主例子中,计数变量包含在闭包中,并且始终对事件处理程序可用,所以它从点击到点击都会保留状态。</target>
        </trans-unit>
        <trans-unit id="2a0bf64067ba96e19feb251aca269629de4b6291" translate="yes" xml:space="preserve">
          <source>Here is a closure:</source>
          <target state="translated">这里有一个结尾。</target>
        </trans-unit>
        <trans-unit id="bcaab99f4090d108eb398f8a65a144183fe65bee" translate="yes" xml:space="preserve">
          <source>Here is a factory that produces calculators that can add and multiply:</source>
          <target state="translated">这里有一个工厂生产的计算器,可以做加法和乘法。</target>
        </trans-unit>
        <trans-unit id="26c03c6b51995ce3cc45717ecfc54ea15182bfb0" translate="yes" xml:space="preserve">
          <source>Here is how I can convert my plane story into the code.</source>
          <target state="translated">以下是我如何将我的飞机故事转换为代码。</target>
        </trans-unit>
        <trans-unit id="542541ad020f39c0dd65066d67e5d1be86126656" translate="yes" xml:space="preserve">
          <source>Here is the summary:</source>
          <target state="translated">下面是总结。</target>
        </trans-unit>
        <trans-unit id="880f763de0c8735d3a294c36e5df6df573d7c52c" translate="yes" xml:space="preserve">
          <source>Here's one of the examples:</source>
          <target state="translated">这里是其中的一个例子。</target>
        </trans-unit>
        <trans-unit id="5f5bf51aa2f2759a4b08230274e714f3e06de685" translate="yes" xml:space="preserve">
          <source>How I'd explain it to a six-year-old:</source>
          <target state="translated">我怎么向一个六岁的孩子解释呢。</target>
        </trans-unit>
        <trans-unit id="2e459856108a5cecf40e139f74b817f2e5e4faa0" translate="yes" xml:space="preserve">
          <source>How do JavaScript closures work</source>
          <target state="translated">JavaScript闭包是如何工作的</target>
        </trans-unit>
        <trans-unit id="31c4f787c21a33dcc90753d93c735b54274f39d7" translate="yes" xml:space="preserve">
          <source>How would you explain JavaScript closures to someone with a knowledge of the concepts they consist of (for example functions, variables and the like), but does not understand closures themselves?</source>
          <target state="translated">你会如何向一个对JavaScript闭包概念(例如函数、变量等)有一定知识,但又不了解闭包本身的人解释?</target>
        </trans-unit>
        <trans-unit id="d0b12b69fd5500aab9c9d2b4a9addddfd30dacaf" translate="yes" xml:space="preserve">
          <source>However, since &lt;code&gt;tmp&lt;/code&gt; is still hanging around inside &lt;code&gt;bar&lt;/code&gt;'s closure, it is available to be incremented. It will be incremented each time you call &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">但是，由于 &lt;code&gt;tmp&lt;/code&gt; 仍然在 &lt;code&gt;bar&lt;/code&gt; 的闭包内部徘徊，因此可以将其递增。 每次调用 &lt;code&gt;bar&lt;/code&gt; 时，它将增加。</target>
        </trans-unit>
        <trans-unit id="be9d4d94dd6f35953099bde147c591bdd84ed51a" translate="yes" xml:space="preserve">
          <source>I have seen &lt;a href=&quot;http://en.wikipedia.org/wiki/Scheme_%28programming_language%29&quot;&gt;the Scheme example&lt;/a&gt; given on Wikipedia, but unfortunately it did not help.</source>
          <target state="translated">我已经在Wikipedia上看到&lt;a href=&quot;http://en.wikipedia.org/wiki/Scheme_%28programming_language%29&quot;&gt;了Scheme示例&lt;/a&gt; ，但是不幸的是它没有帮助。</target>
        </trans-unit>
        <trans-unit id="c32c4a2db55c3bb615ab0b8d8acc3b66dadcac7d" translate="yes" xml:space="preserve">
          <source>I haven't got time to go shopping, so the function needs to know what we have in the fridge to make decisions. Each ingredient has a different cooking time and we want everything to be served hot by the robot at the same time. We need to provide the function with the data about what we like, the function could 'talk' to the fridge, and the function could control the robot.</source>
          <target state="translated">我没有时间去买东西,所以功能需要知道我们冰箱里有什么东西,才能做出决定。每种食材都有不同的烹饪时间,我们希望所有的东西都能被机器人同时热好。我们需要向功能提供我们喜欢吃什么的数据,功能可以和冰箱 &quot;对话&quot;,功能可以控制机器人。</target>
        </trans-unit>
        <trans-unit id="f67fa89b4f0fa9a4f122d225bd2121614d8b9416" translate="yes" xml:space="preserve">
          <source>I know there are plenty of solutions already, but I guess that this small and simple script can be useful to demonstrate the concept:</source>
          <target state="translated">我知道已经有很多解决方案了,但我猜想,这种小而简单的脚本,在演示概念的时候,也能派上用场。</target>
        </trans-unit>
        <trans-unit id="68c15dba4a700bb7a32cb7aad9a30cdd109d35e6" translate="yes" xml:space="preserve">
          <source>I need to know how many times a button has been clicked and do something on every third click...</source>
          <target state="translated">我需要知道一个按钮被点击了多少次,并在每三次的点击上做一些事情......</target>
        </trans-unit>
        <trans-unit id="1729e172673bb9af9294d6a61fc1a00e839e1311" translate="yes" xml:space="preserve">
          <source>I put together an interactive JavaScript tutorial to explain how closures work.
&lt;a href=&quot;http://nathansjslessons.appspot.com&quot;&gt;What's a Closure?&lt;/a&gt;</source>
          <target state="translated">我整理了一个交互式JavaScript教程，以解释闭包是如何工作的。 &lt;a href=&quot;http://nathansjslessons.appspot.com&quot;&gt;什么是封包？&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="123fc03a330a7c38723bf7555ca4ff7a80024826" translate="yes" xml:space="preserve">
          <source>I still think &lt;a href=&quot;http://code.google.com/apis/ajax/playground/?exp=maps#closure_simple&quot;&gt;Google's explanation&lt;/a&gt; works very well and is concise:</source>
          <target state="translated">我仍然认为&lt;a href=&quot;http://code.google.com/apis/ajax/playground/?exp=maps#closure_simple&quot;&gt;Google的解释&lt;/a&gt;非常有效且简洁：</target>
        </trans-unit>
        <trans-unit id="0b506f3eb42bcf394c48e9df2a2bec6ef476dbaa" translate="yes" xml:space="preserve">
          <source>I suspect that closures in JavaScript differ from those normally found in functional languages.</source>
          <target state="translated">我怀疑JavaScript中的闭包与通常在功能语言中的闭包不同。</target>
        </trans-unit>
        <trans-unit id="24dbc47ee46dbf67b52513fbd1c704c76d217b00" translate="yes" xml:space="preserve">
          <source>I tend to learn better by GOOD/BAD comparisons. I like to see working code followed by non-working code that someone is likely to encounter. I put together &lt;a href=&quot;http://jsfiddle.net/KMQZK/&quot;&gt;a jsFiddle&lt;/a&gt; that does a comparison and tries to boil down the differences to the simplest explanations I could come up with.</source>
          <target state="translated">通过GOOD / BAD比较，我倾向于学得更好。 我喜欢看到有人可能会遇到的工作代码，然后是非工作代码。 我整理了&lt;a href=&quot;http://jsfiddle.net/KMQZK/&quot;&gt;一个jsFiddle&lt;/a&gt;进行比较，并尝试将差异归结为我能想到的最简单的解释。</target>
        </trans-unit>
        <trans-unit id="4b2d52788d16d1aed76a99b2962dd7f9b814a6e8" translate="yes" xml:space="preserve">
          <source>I think normally a closure is a term for both the function along with a captured variable environment. Note that I do not use that definition in this article!</source>
          <target state="translated">我认为通常情况下,闭包是指函数和捕获的变量环境一起的术语。注意,我在这篇文章中没有使用这个定义!</target>
        </trans-unit>
        <trans-unit id="96ede599b6969e1b90d8c62ab4084c1f1b9581b8" translate="yes" xml:space="preserve">
          <source>I wrote a blog post a while back explaining closures. Here's what I said about closures in terms of &lt;strong&gt;why&lt;/strong&gt; you'd want one.</source>
          <target state="translated">前一段时间，我写了一篇博客文章解释了闭包。 这就是我说的关于闭包的&lt;strong&gt;原因&lt;/strong&gt; ， &lt;strong&gt;因为&lt;/strong&gt;您想要一个闭包。</target>
        </trans-unit>
        <trans-unit id="1f893746796fe79900cf9caf10941e2bdc53f26f" translate="yes" xml:space="preserve">
          <source>I'd simply point them to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures&quot;&gt;Mozilla Closures page&lt;/a&gt;. It's the best, most &lt;strong&gt;concise and simple explanation&lt;/strong&gt; of closure basics and practical usage that I've found. It is highly recommended to anyone learning JavaScript.</source>
          <target state="translated">我只是将它们指向&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures&quot;&gt;Mozilla Closures页面&lt;/a&gt; 。 这是我发现的关于闭包基础知识和实际用法的最佳，最&lt;strong&gt;简洁明了的解释&lt;/strong&gt; 。 强烈建议任何学习JavaScript的人使用。</target>
        </trans-unit>
        <trans-unit id="11877a1bd39d64fe0945ea5ee068c0234e433657" translate="yes" xml:space="preserve">
          <source>I'm a big fan of analogy and metaphor when explaining difficult concepts, so let me try my hand with a story.</source>
          <target state="translated">在讲解难懂的概念时,我很喜欢打比方和比喻,所以让我用一个故事来试试。</target>
        </trans-unit>
        <trans-unit id="6b990bce01318ec63bef46aec64d8b6ab67c944d" translate="yes" xml:space="preserve">
          <source>I'm pretty sure I was one of the only people that attempted to take the initial question literally. Since then, the question has mutated several times, so my answer may now seem incredibly silly &amp;amp; out of place. Hopefully the general idea of the story remains fun for some.</source>
          <target state="translated">我敢肯定，我是唯一尝试从字面上回答最初问题的人之一。 从那时起，这个问题已经改变了几次，所以我的回答现在似乎变得非常愚蠢和不合适。 希望这个故事的总体思路对某些人仍然很有趣。</target>
        </trans-unit>
        <trans-unit id="4f6b0992401487db0a126fe9e7ad6b66cdcca276" translate="yes" xml:space="preserve">
          <source>If a function accesses its environment, then the function is a closure.</source>
          <target state="translated">如果一个函数访问了它的环境,那么这个函数就是一个闭包。</target>
        </trans-unit>
        <trans-unit id="f330a42bf372ed8fefe90c64085c3c7240fecf76" translate="yes" xml:space="preserve">
          <source>If a variable is read, but can not be found anywhere, an error is generated.</source>
          <target state="translated">如果读取了一个变量,但在任何地方找不到,就会产生一个错误。</target>
        </trans-unit>
        <trans-unit id="3cbc5f197b9dd09fc614b45e91092d33f7f9c144" translate="yes" xml:space="preserve">
          <source>If an inner function is returned by an outer, then the outer lexical environment will persist after the outer function has returned. This is because the outer lexical environment needs to be available if the inner function is eventually invoked.</source>
          <target state="translated">如果一个内部函数被外部函数返回,那么外部函数返回后,外部词库环境将持续存在。这是因为如果内部函数最终被调用,外部词法环境需要可用。</target>
        </trans-unit>
        <trans-unit id="dc578583b34a4a34bae69d350c3dfa0573e54e50" translate="yes" xml:space="preserve">
          <source>If everything seems completely unclear, then the best thing to do is to play with the examples. Reading an explanation is much harder than understanding examples.
My explanations of closures and stack-frames, etc. are not technically correct &amp;mdash; they are gross simplifications intended to help to understand. Once the basic idea is grokked, you can pick up the details later.</source>
          <target state="translated">如果一切似乎都不是很清楚，那么最好的办法就是尝试这些示例。 阅读说明比理解示例困难得多。 我对闭包和堆栈框架等的解释在技术上不正确-它们是旨在帮助理解的粗略简化。 一旦了解了基本概念，您便可以稍后进行详细了解。</target>
        </trans-unit>
        <trans-unit id="4f08569e7c3d79200141ddddd7958d6b1ded5e4e" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;i&lt;/code&gt; is also defined using &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt;, then the output is:</source>
          <target state="translated">如果变量 &lt;code&gt;i&lt;/code&gt; 也是使用 &lt;code&gt;let&lt;/code&gt; 而不是 &lt;code&gt;var&lt;/code&gt; 定义的，则输出为：</target>
        </trans-unit>
        <trans-unit id="460b9688bda10bbf35ef9d0c1b98952a76ebb3ed" translate="yes" xml:space="preserve">
          <source>If you are trying to do any dynamic source code modifications (for example: &lt;code&gt;myFunction = Function(myFunction.toString().replace(/Hello/,'Hola'));&lt;/code&gt;), it won't work if &lt;code&gt;myFunction&lt;/code&gt; is a closure (of course, you would never even think of doing source code string substitution at runtime, but...).</source>
          <target state="translated">如果您尝试进行任何动态源代码修改（例如： &lt;code&gt;myFunction = Function(myFunction.toString().replace(/Hello/,'Hola'));&lt;/code&gt; ），则如果 &lt;code&gt;myFunction&lt;/code&gt; 是闭包（当然，您甚至都不会想到在运行时进行源代码字符串替换，而是...）。</target>
        </trans-unit>
        <trans-unit id="f246fbc5dfee71350f8d01e881e3e75375300e1a" translate="yes" xml:space="preserve">
          <source>If you have &lt;em&gt;just&lt;/em&gt; learned closures (here or elsewhere!), then I am interested in any feedback from you about any changes you might suggest that could make this article clearer. Send an email to morrisjohns.com (morris_closure @). Please note that I am not a guru on JavaScript &amp;mdash; nor on closures.</source>
          <target state="translated">如果您&lt;em&gt;刚刚&lt;/em&gt;学习了闭包（在这里或其他地方！），那么我对您可能会建议使本文更清晰的任何更改所产生的反馈意见感兴趣。 发送电子邮件至morrisjohns.com（morris_closure @）。 请注意，我不是JavaScript专家，也不是闭包专家。</target>
        </trans-unit>
        <trans-unit id="6a8ed7866e246c92cf6dd70deac29290fa039a64" translate="yes" xml:space="preserve">
          <source>Imagine - you are playing with your little brothers and sisters in the entire house, and you are moving around with your toys and brought some of them into your older brother's room. After a while your brother returned from the school and went to his room, and he locked inside it, so now you could not access toys left there anymore in a direct way. But you could knock the door and ask your brother for that toys. This is called toy's &lt;em&gt;closure&lt;/em&gt;; your brother made it up for you, and he is now into outer &lt;em&gt;scope&lt;/em&gt;.</source>
          <target state="translated">想象一下-您正在与整个房子里的弟弟和妹妹一起玩耍，并且带着玩具走来走去，并将其中一些带入哥哥的房间。 过了一会儿，您的兄弟从学校返回并去了他的房间，他锁在房间里，所以现在您不能再直接访问那里剩下的玩具了。 但是你可以敲门，问你的兄弟那个玩具。 这称为玩具的&lt;em&gt;闭合&lt;/em&gt; ； 你的兄弟为你补上了，现在他进入了&lt;em&gt;范围&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="fabf25061406e8ca355bbb62da26e81c7a773acf" translate="yes" xml:space="preserve">
          <source>Imagine that the Stack Overflow Vote-Up and Vote-Down button events are implemented as closures, voteUp_click and voteDown_click, that have access to external variables isVotedUp and isVotedDown, which are defined globally. (For simplicity's sake, I am referring to StackOverflow's Question Vote buttons, not the array of Answer Vote buttons.)</source>
          <target state="translated">想象一下,Stack Overflow 的 VoteUp 和 VoteDown 按钮事件被实现为闭环,即 voteUp_click 和 voteDown_click,它们可以访问外部变量 isVotedUp 和 isVotedDown,这两个变量是全局定义的。(为了简单起见,我指的是StackOverflow的问题投票按钮,而不是答案投票按钮的数组)。</target>
        </trans-unit>
        <trans-unit id="34fbb45dfd31d8c76706f4846facff1223ce9ab3" translate="yes" xml:space="preserve">
          <source>In C and most other common languages, &lt;em&gt;after&lt;/em&gt; a function returns, all the local variables are no longer accessible because the stack-frame is destroyed.</source>
          <target state="translated">在C语言和大多数其他常见语言中，函数返回后，所有本地变量将不再可访问，因为堆栈框架被破坏了。</target>
        </trans-unit>
        <trans-unit id="bde892a91769451e6aae5176cd04fd8bb3c261d1" translate="yes" xml:space="preserve">
          <source>In JavaScript, if you declare a function within another function, then the local variables of the outer function can remain accessible after returning from it. This is demonstrated above, because we call the function &lt;code&gt;say2()&lt;/code&gt; after we have returned from &lt;code&gt;sayHello2()&lt;/code&gt;. Notice that the code that we call references the variable &lt;code&gt;text&lt;/code&gt;, which was a &lt;em&gt;local variable&lt;/em&gt; of the function &lt;code&gt;sayHello2()&lt;/code&gt;.</source>
          <target state="translated">在JavaScript中，如果您在另一个函数中声明一个函数，则外部函数的本地变量在返回后仍可访问。 上面已演示了这一点，因为我们从 &lt;code&gt;sayHello2()&lt;/code&gt; 返回之后调用了函数 &lt;code&gt;say2()&lt;/code&gt; （） 。 请注意，我们调用的代码引用了变量 &lt;code&gt;text&lt;/code&gt; ，这是 &lt;code&gt;sayHello2()&lt;/code&gt; 函数的&lt;em&gt;局部变量&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="66588c3a466a757d86d3ce97ab53a9423b323372" translate="yes" xml:space="preserve">
          <source>In a closure, the variables in the outer lexical environment &lt;em&gt;themselves&lt;/em&gt; are available, &lt;em&gt;not&lt;/em&gt; copies.</source>
          <target state="translated">在闭包中，外部词法环境中的变量&lt;em&gt;本身&lt;/em&gt;可用， &lt;em&gt;而不是&lt;/em&gt;副本。</target>
        </trans-unit>
        <trans-unit id="be9e7184ed47abdf916495732c707da00b0bef5c" translate="yes" xml:space="preserve">
          <source>In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function.</source>
          <target state="translated">在计算机科学中,闭包是指一个函数与该函数的非本地名(自由变量)的引用环境。</target>
        </trans-unit>
        <trans-unit id="7f7dd1aaa3a43450511e179ef4935d2bfcf91e9f" translate="yes" xml:space="preserve">
          <source>In that sense, they let a function act a bit like an object with private attributes.</source>
          <target state="translated">在这个意义上,它们让一个函数的行为有点像一个具有私有属性的对象。</target>
        </trans-unit>
        <trans-unit id="0c18c47099c91026c3cd731edf3696ce2d7f9082" translate="yes" xml:space="preserve">
          <source>In the above code &lt;code&gt;createClosure(n)&lt;/code&gt; is invoked in every iteration of the loop. Note that I named the variable &lt;code&gt;n&lt;/code&gt; to highlight that it is a &lt;strong&gt;new&lt;/strong&gt; variable created in a new function scope and is not the same variable as &lt;code&gt;index&lt;/code&gt; which is bound to the outer scope.</source>
          <target state="translated">在上面的代码中，循环的每次迭代都调用 &lt;code&gt;createClosure(n)&lt;/code&gt; 。 请注意，我将变量 &lt;code&gt;n&lt;/code&gt; 命名为突出显示它是在新函数作用域中创建的&lt;strong&gt;新&lt;/strong&gt;变量，而不是与绑定到外部作用域的 &lt;code&gt;index&lt;/code&gt; 相同的变量。</target>
        </trans-unit>
        <trans-unit id="64ccd305f21918c690c8faf2eee3f539cb44d848" translate="yes" xml:space="preserve">
          <source>In the above code the loop was moved within the &lt;code&gt;createClosureArray()&lt;/code&gt; function and the function now just returns the completed array, which at first glance seems more intuitive.</source>
          <target state="translated">在上面的代码中，循环在 &lt;code&gt;createClosureArray()&lt;/code&gt; 函数中移动，该函数现在仅返回完成的数组，乍一看似乎更直观。</target>
        </trans-unit>
        <trans-unit id="b564dadb6ceca4494d7653f8c5e95bc5a27eaf2b" translate="yes" xml:space="preserve">
          <source>In the above example, I am using the closure behavior of JavaScript. &lt;strong&gt;This behavior allows any function to have access to the scope in which it was created, indefinitely.&lt;/strong&gt; To practically apply this, I immediately invoke a function that returns another function, and because the function I'm returning has access to the internal count variable (because of the closure behavior explained above) this results in a private scope for usage by the resulting function... Not so simple? Let's dilute it down...</source>
          <target state="translated">在上面的示例中，我正在使用JavaScript的关闭行为。 &lt;strong&gt;此行为允许任何函数无限期地访问其创建范围。&lt;/strong&gt; 为了实际应用此方法，我立即调用一个返回另一个函数的函数，并且由于我返回的函数可以访问内部count变量（由于上述闭包行为），因此会导致私有范围供结果使用功能...不是那么简单吗？ 让我们稀释一下...</target>
        </trans-unit>
        <trans-unit id="52291f67af5b2a395aa91f417749282ffa321ce5" translate="yes" xml:space="preserve">
          <source>In the above example, outerFunction is called which in turn calls innerFunction. Note how outerVar is available to innerFunction, evidenced by its correctly alerting the value of outerVar.</source>
          <target state="translated">在上面的例子中,outerFunction被调用,而 outerFunction 又被调用 innerFunction。请注意 outerVar 是如何被 innerFunction 使用的,这从它正确地提示 outerVar 的值就可以证明。</target>
        </trans-unit>
        <trans-unit id="9accb51a40f9456dfff0b9b647c4adc451c98ff8" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;f&lt;/code&gt; closes over the lexical environment of the global execution context:</source>
          <target state="translated">在以下示例中，函数 &lt;code&gt;f&lt;/code&gt; 关闭了全局执行上下文的词法环境：</target>
        </trans-unit>
        <trans-unit id="79e7feaad903ac12e4a4780516074d3c8e273603" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;h&lt;/code&gt; closes over the lexical environment of function &lt;code&gt;g&lt;/code&gt;, which, in turn, closes over the lexical environment of the global execution context.</source>
          <target state="translated">在下面的示例中，函数 &lt;code&gt;h&lt;/code&gt; 关闭函数 &lt;code&gt;g&lt;/code&gt; 的词法环境，而后者又关闭全局执行上下文的词法环境。</target>
        </trans-unit>
        <trans-unit id="d208e23250c79929b1202ec211a36dbeb87b68f9" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;j&lt;/code&gt; closes over the lexical environment of function &lt;code&gt;i&lt;/code&gt;, meaning that variable &lt;code&gt;x&lt;/code&gt; is visible from inside function &lt;code&gt;j&lt;/code&gt;, long after function &lt;code&gt;i&lt;/code&gt; has completed execution:</source>
          <target state="translated">在下面的示例中，函数 &lt;code&gt;j&lt;/code&gt; 关闭了函数 &lt;code&gt;i&lt;/code&gt; 的词法环境，这意味着在函数 &lt;code&gt;i&lt;/code&gt; 完成执行很长时间之后，变量 &lt;code&gt;x&lt;/code&gt; 在函数 &lt;code&gt;j&lt;/code&gt; 内部可见：</target>
        </trans-unit>
        <trans-unit id="9a42d2846a79c733d7b14604fa1cb2c0c4772121" translate="yes" xml:space="preserve">
          <source>In the terminology of the ECMAScript specification, a closure can be said to be implemented by the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt;&lt;code&gt;[[Environment]]&lt;/code&gt;&lt;/a&gt; reference of every function-object, which points to the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;lexical environment&lt;/a&gt; within which the function is defined.</source>
          <target state="translated">在ECMAScript规范的术语中，可以说闭包是通过每个功能对象的&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt; &lt;code&gt;[[Environment]]&lt;/code&gt; &lt;/a&gt;引用实现的，该引用指向在其中定义功能的&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;词法环境&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="88a0303f59536ee17cc71dcac48a7690fb59fb0b" translate="yes" xml:space="preserve">
          <source>In this case, the interpreter finds the variable in the
outer &lt;a href=&quot;http://javascript.info/tutorial/initialization&quot;&gt;&lt;code&gt;LexicalEnvironment&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">在这种情况下，解释器在外部&lt;a href=&quot;http://javascript.info/tutorial/initialization&quot;&gt; &lt;code&gt;LexicalEnvironment&lt;/code&gt; &lt;/a&gt;对象中找到变量。</target>
        </trans-unit>
        <trans-unit id="517b1409687da9d9fcb673e99fbcc8dd23f7ee52" translate="yes" xml:space="preserve">
          <source>In this final example, each call to the main function creates a separate closure.</source>
          <target state="translated">在这个最后的例子中,每一次对主函数的调用都会创建一个单独的闭包。</target>
        </trans-unit>
        <trans-unit id="c7149ac43259f5072dae076e7d470d21214d7c4c" translate="yes" xml:space="preserve">
          <source>Inner functions like &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt;, which access variables declared in an outer function&lt;sup&gt;**&lt;/sup&gt;, are called &lt;em&gt;closures&lt;/em&gt;.</source>
          <target state="translated">像 &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;multiply&lt;/code&gt; 这样的内部函数，它们访问在外部函数&lt;sup&gt;**中&lt;/sup&gt;声明的变量，称为&lt;em&gt;闭包&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="c535437331e2cd1ff0b52dab323b734568fde96b" translate="yes" xml:space="preserve">
          <source>It is possible to nest function declarations within function declarations within function declarations&amp;hellip;; you can get closures at more than one level.</source>
          <target state="translated">可以将函数声明嵌套在函数声明内的函数声明中&amp;hellip;&amp;hellip;； 您可以获得多个级别的关闭。</target>
        </trans-unit>
        <trans-unit id="bd8a1c5b969fb5ce6751ab00fdc753d6fe50bc42" translate="yes" xml:space="preserve">
          <source>It may be helpful to see what happens when a block-level declaration of the variable &lt;code&gt;item&lt;/code&gt; is used (via the &lt;code&gt;let&lt;/code&gt; keyword) instead of a function-scoped variable declaration via the &lt;code&gt;var&lt;/code&gt; keyword. If that change is made, then each anonymous function in the array &lt;code&gt;result&lt;/code&gt; has its own closure; when the example is run the output is as follows:</source>
          <target state="translated">查看使用变量 &lt;code&gt;item&lt;/code&gt; 的块级声明（通过 &lt;code&gt;let&lt;/code&gt; 关键字）而不是通过 &lt;code&gt;var&lt;/code&gt; 关键字进行函数范围的变量声明时发生的情况可能会有所帮助。 如果进行了更改，则数组 &lt;code&gt;result&lt;/code&gt; 中的每个匿名函数都有其自己的结束符； 运行示例时，输出如下：</target>
        </trans-unit>
        <trans-unit id="3f6d29d5da52be16dfb12c7815fe37a9ce3fcf16" translate="yes" xml:space="preserve">
          <source>JAVASCRIPT: JavaScript is a language. Like English or French or Chinese are languages. There are lots of languages that are understood by computers and other electronic processors. For JavaScript to be understood by a computer it needs an interpreter. Imagine if a teacher who only speaks Russian comes to teach your class at school. When the teacher says &quot;все садятся&quot;, the class would not understand. But luckily you have a Russian pupil in your class who tells everyone this means &quot;everybody sit down&quot; - so you all do. The class is like a computer and the Russian pupil is the interpreter. For JavaScript the most common interpreter is called a browser.</source>
          <target state="translated">JAVASCRIPT:JavaScript是一种语言。就像英语或法语或中文都是语言一样。有很多语言可以被计算机和其他电子处理器所理解。要想让计算机理解JavaScript,它需要一个解释器。想象一下,如果一个只会说俄语的老师来学校给你上课。当老师说&quot; все садятся &quot;时,全班同学都听不懂。但幸运的是你班上有一个俄语学生,他告诉大家这句话的意思是 &quot;大家都坐下来&quot;--于是大家都坐下来了。课堂就像一台电脑,俄语学生就是翻译员。对于JavaScript来说,最常见的解释器叫做浏览器。</target>
        </trans-unit>
        <trans-unit id="f15fd20b3b607a06e5de7b00b5c8829cba54783d" translate="yes" xml:space="preserve">
          <source>JavaScript closures for beginners</source>
          <target state="translated">初学者的JavaScript闭合</target>
        </trans-unit>
        <trans-unit id="a4ad1062dbb50a6179be99978ca0015111394d54" translate="yes" xml:space="preserve">
          <source>JavaScript functions can access their:</source>
          <target state="translated">JavaScript功能可以访问其。</target>
        </trans-unit>
        <trans-unit id="18356dc7f56408ba6d488b26a212e8a89b8f9645" translate="yes" xml:space="preserve">
          <source>Let's imagine the next situation: a driver is sitting in a car. That car is inside a plane. Plane is in the airport. The ability of driver to access things outside his car, but inside the plane, even if that plane leaves an airport, is a closure. That's it. When you turn 27, look at the &lt;a href=&quot;https://stackoverflow.com/a/111200/1393791&quot;&gt;more detailed explanation&lt;/a&gt; or at the example below.</source>
          <target state="translated">让我们想象下一个情况：驾驶员坐在汽车上。 那辆车在飞机上。 飞机在机场。 驾驶员即使在飞机离开机场后也无法进入汽车外部但在飞机内部的东西，这是封闭的。 而已。 27岁时，请查看&lt;a href=&quot;https://stackoverflow.com/a/111200/1393791&quot;&gt;更详细的说明&lt;/a&gt;或以下示例。</target>
        </trans-unit>
        <trans-unit id="09b200c5ade4b1cb4a297a00afe3d45be8c9d80e" translate="yes" xml:space="preserve">
          <source>Like the old Albert said : &quot;If you can't explain it to a six-year old, you really don't understand it yourself.&amp;rdquo;. Well I tried to explain JS closures to a 27 years old friend and completely failed.</source>
          <target state="translated">就像老阿尔伯特所说：&amp;ldquo;如果您不能向六岁的孩子解释它，那么您自己真的不理解。&amp;rdquo;好吧，我试图向一个27岁的朋友解释JS的关闭，但完全失败了。</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="f4346c3dbf21e346a2dead6609d901d087e13650" translate="yes" xml:space="preserve">
          <source>Locals (that is, their local variables and local functions)</source>
          <target state="translated">本地变量(即其本地变量和本地函数)</target>
        </trans-unit>
        <trans-unit id="2b0aed7bf52a8c5e0e0cefef3f3b339f8c820a34" translate="yes" xml:space="preserve">
          <source>Looking at the output of &lt;code&gt;say2.toString()&lt;/code&gt;, we can see that the code refers to the variable &lt;code&gt;text&lt;/code&gt;. The anonymous function can reference &lt;code&gt;text&lt;/code&gt; which holds the value &lt;code&gt;'Hello Bob'&lt;/code&gt; because the local variables of &lt;code&gt;sayHello2()&lt;/code&gt; have been secretly kept alive in a closure.</source>
          <target state="translated">查看 &lt;code&gt;say2.toString()&lt;/code&gt; 的输出，我们可以看到该代码引用了变量 &lt;code&gt;text&lt;/code&gt; 。 匿名函数可以引用包含值 &lt;code&gt;'Hello Bob'&lt;/code&gt; &lt;code&gt;text&lt;/code&gt; ，因为 &lt;code&gt;sayHello2()&lt;/code&gt; 的局部变量已在闭包中秘密保持活动状态。</target>
        </trans-unit>
        <trans-unit id="5628f8a6b5fea1b9beca93e689568ae4c8efb6d1" translate="yes" xml:space="preserve">
          <source>Marking up LexicalEnvironments:</source>
          <target state="translated">标出LexicalEnvironments。</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes" xml:space="preserve">
          <source>More examples</source>
          <target state="translated">更多的例子</target>
        </trans-unit>
        <trans-unit id="6f01bda547a9bb9e65d7ba349d7f92d2d69752b9" translate="yes" xml:space="preserve">
          <source>Most JavaScript programmers will understand how a reference to a function is returned to a variable (&lt;code&gt;say2&lt;/code&gt;) in the above code. If you don't, then you need to look at that before you can learn closures. A programmer using C would think of the function as returning a pointer to a function, and that the variables &lt;code&gt;say&lt;/code&gt; and &lt;code&gt;say2&lt;/code&gt; were each a pointer to a function.</source>
          <target state="translated">大多数JavaScript程序员将理解如何在上述代码中 &lt;code&gt;say2&lt;/code&gt; 函数的引用返回到变量（ say2 ）。 如果不这样做，那么您需要先研究一下闭包。 使用C的程序员会将函数视为返回函数的指针，而变量 &lt;code&gt;say&lt;/code&gt; 和 &lt;code&gt;say2&lt;/code&gt; 分别是函数的指针。</target>
        </trans-unit>
        <trans-unit id="fd66b2800310560a1ce2ba5a794b44747c843f0e" translate="yes" xml:space="preserve">
          <source>NAME: You can call a function just about whatever word you want. The example &quot;cookMeal&quot; is typical in joining two words together and giving the second one a capital letter at the beginning - but this is not necessary. It can't have a space in it, and it can't be a number on its own.</source>
          <target state="translated">NAME。你可以调用一个函数,只要你想用什么词就可以了。例子 &quot;cookMeal &quot;是典型的将两个词连接在一起,并在开头给第二个词加一个大写的字母--但这不是必须的。它不能有一个空格,也不能是一个数字本身。</target>
        </trans-unit>
        <trans-unit id="40c3e770c196ccb030cf74232292c69eb60717a3" translate="yes" xml:space="preserve">
          <source>Note that in the above example, if you call &lt;code&gt;setupSomeGlobals()&lt;/code&gt; again, then a new closure (stack-frame!) is created. The old &lt;code&gt;gLogNumber&lt;/code&gt;, &lt;code&gt;gIncreaseNumber&lt;/code&gt;, &lt;code&gt;gSetNumber&lt;/code&gt; variables are overwritten with &lt;em&gt;new&lt;/em&gt; functions that have the new closure. (In JavaScript, whenever you declare a function inside another function, the inside function(s) is/are recreated again &lt;em&gt;each&lt;/em&gt; time the outside function is called.)</source>
          <target state="translated">请注意，在上面的示例中，如果再次调用 &lt;code&gt;setupSomeGlobals()&lt;/code&gt; ，则会创建一个新的闭包（堆栈框架！）。 旧的 &lt;code&gt;gLogNumber&lt;/code&gt; ， &lt;code&gt;gIncreaseNumber&lt;/code&gt; 和 &lt;code&gt;gSetNumber&lt;/code&gt; 变量将被具有新闭包的&lt;em&gt;新&lt;/em&gt;函数覆盖。 （在JavaScript中，每当在另一个函数中声明一个函数时，每次调用外部函数时都会重新创建&lt;em&gt;一个或&lt;/em&gt;多个内部函数。）</target>
        </trans-unit>
        <trans-unit id="7dc2f9bd9efd8d1e52cbf8c35413ba1f4105f5a9" translate="yes" xml:space="preserve">
          <source>Note that outer functions are not required, though they do offer benefits I don't discuss here. By accessing data in its environment, a closure keeps that data alive. In the subcase of outer/inner functions, an outer function can create local data and eventually exit, and yet, if any inner function(s) survive after the outer function exits, then the inner function(s) keep the outer function's local data alive.</source>
          <target state="translated">请注意,外部函数并不是必需的,尽管它们确实提供了一些好处,我在这里就不讨论了。通过访问其环境中的数据,一个闭合函数可以保持该数据的活力。在外延函数的子例中,一个外延函数可以创建本地数据并最终退出,然而,如果在外延函数退出后有任何内延函数存活下来,那么内延函数就会保持外延函数的本地数据的存活。</target>
        </trans-unit>
        <trans-unit id="4b7d6be3be4533ef766e4ba6b6589adcce7bd0a0" translate="yes" xml:space="preserve">
          <source>Note that variables &lt;em&gt;themselves&lt;/em&gt; are visible from within a closure, &lt;em&gt;not&lt;/em&gt; copies.</source>
          <target state="translated">请注意，变量&lt;em&gt;本身&lt;/em&gt;在闭包内部可见， &lt;em&gt;而不是&lt;/em&gt;副本。</target>
        </trans-unit>
        <trans-unit id="9dccaff8b91f1ebe851d8b10d10b8abb4daae146" translate="yes" xml:space="preserve">
          <source>Note that when you run the example, &lt;code&gt;&quot;item2 undefined&quot;&lt;/code&gt; is logged three times! This is because just like previous examples, there is only one closure for the local variables for &lt;code&gt;buildList&lt;/code&gt; (which are &lt;code&gt;result&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;item&lt;/code&gt;). When the anonymous functions are called on the line &lt;code&gt;fnlist[j]()&lt;/code&gt;; they all use the same single closure, and they use the current value for &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;item&lt;/code&gt; within that one closure (where &lt;code&gt;i&lt;/code&gt; has a value of &lt;code&gt;3&lt;/code&gt; because the loop had completed, and &lt;code&gt;item&lt;/code&gt; has a value of &lt;code&gt;'item2'&lt;/code&gt;). Note we are indexing from 0 hence &lt;code&gt;item&lt;/code&gt; has a value of &lt;code&gt;item2&lt;/code&gt;. And the i++ will increment &lt;code&gt;i&lt;/code&gt; to the value &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">请注意，在运行示例时， &lt;code&gt;&quot;item2 undefined&quot;&lt;/code&gt; 被记录了三次！ 这是因为就像前面的示例一样， &lt;code&gt;buildList&lt;/code&gt; 的局部变量（ &lt;code&gt;result&lt;/code&gt; ， &lt;code&gt;i&lt;/code&gt; ， &lt;code&gt;list&lt;/code&gt; 和 &lt;code&gt;item&lt;/code&gt; ）只有一个闭包。 当在行上调用匿名函数 &lt;code&gt;fnlist[j]()&lt;/code&gt; ； 它们都使用相同的单个闭包，并且使用该闭包中 &lt;code&gt;i&lt;/code&gt; 和 &lt;code&gt;item&lt;/code&gt; 的当前值（其中 &lt;code&gt;i&lt;/code&gt; 的值为 &lt;code&gt;3&lt;/code&gt; ,因为循环已完成， &lt;code&gt;item&lt;/code&gt; 的值为 &lt;code&gt;'item2'&lt;/code&gt; ）。 注意，我们从0开始索引，因此 &lt;code&gt;item&lt;/code&gt; 的值为 &lt;code&gt;item2&lt;/code&gt; 。 i ++将 &lt;code&gt;i&lt;/code&gt; 递增到值 &lt;code&gt;3&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="2632a4becd02c75c95693519f5cf180b44a90456" translate="yes" xml:space="preserve">
          <source>Notice a few things here.</source>
          <target state="translated">注意到这里有几件事。</target>
        </trans-unit>
        <trans-unit id="3393c390f2f8f559d4a2a520da1ec907eaeea621" translate="yes" xml:space="preserve">
          <source>Now consider the following:</source>
          <target state="translated">现在考虑以下几点:</target>
        </trans-unit>
        <trans-unit id="8495e70502d881bdf9b4145e67ce317efd57faac" translate="yes" xml:space="preserve">
          <source>Now this will work, but it does encroach into the outer scope by adding a variable, whose sole purpose is to keep track of the count. In some situations, this would be preferable as your outer application might need access to this information. But in this case, we are only changing every third click's behavior, so it is preferable to &lt;strong&gt;enclose this functionality inside the event handler&lt;/strong&gt;.</source>
          <target state="translated">现在这将起作用，但是它通过添加变量来侵入外部范围，该变量的唯一目的是跟踪计数。 在某些情况下，这将是更可取的，因为您的外部应用程序可能需要访问此信息。 但是在这种情况下，我们仅更改每三次单击的行为，因此最好&lt;strong&gt;将此功能封装在事件处理程序中&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="edc821fed74b8a83207ffcc4a681c6656cb0dbd9" translate="yes" xml:space="preserve">
          <source>Now what it &lt;em&gt;allows&lt;/em&gt; you to do can be more spectacular, see other answers.</source>
          <target state="translated">现在，它&lt;em&gt;允许&lt;/em&gt;您执行的操作会更加壮观，请参阅其他答案。</target>
        </trans-unit>
        <trans-unit id="37b00465e1d26162d39a6df745e20f2e4e1c3722" translate="yes" xml:space="preserve">
          <source>Now, after the function &lt;em&gt;sing()&lt;/em&gt;, near the end of the code is the line</source>
          <target state="translated">现在，在函数&lt;em&gt;sing（）之后&lt;/em&gt; ，代码的结尾附近是该行</target>
        </trans-unit>
        <trans-unit id="2b6292f13ea61f03e46a26b717197499baebf90b" translate="yes" xml:space="preserve">
          <source>Now, where's the definition of &lt;code&gt;x&lt;/code&gt;? We didn't define it in the current scope. The only solution is to let &lt;code&gt;plus5&lt;/code&gt;&lt;em&gt;carry&lt;/em&gt; its scope (or rather, its parent's scope) around. This way, &lt;code&gt;x&lt;/code&gt; is well-defined and it is bound to the value 5.</source>
          <target state="translated">现在， &lt;code&gt;x&lt;/code&gt; 的定义在哪里？ 我们没有在当前范围内对其进行定义。 唯一的解决方案是让 &lt;code&gt;plus5&lt;/code&gt; &lt;em&gt;携带&lt;/em&gt;其范围（或更确切地说，其父级的范围）。 这样， &lt;code&gt;x&lt;/code&gt; 定义明确，并绑定到值5。</target>
        </trans-unit>
        <trans-unit id="9e15ed596afd3bc19fd5d61a060bb2a47cddef9b" translate="yes" xml:space="preserve">
          <source>OK, 6-year-old closures fan. Do you want to hear the simplest example of closure?</source>
          <target state="translated">OK,6岁的闭门羹爱好者。你想听最简单的闭门羹的例子吗?</target>
        </trans-unit>
        <trans-unit id="d722330a80b9bc2dfce4ab9f7b615cda1f5e4764" translate="yes" xml:space="preserve">
          <source>Okay, talking with a 6-year old child, I would possibly use following associations.</source>
          <target state="translated">好吧,和一个6岁的孩子聊天,我可能会用以下联想。</target>
        </trans-unit>
        <trans-unit id="148abbffcf1d27e45f3fc36604ef1e94841e9e4b" translate="yes" xml:space="preserve">
          <source>On  &lt;a href=&quot;http://www.howkidsdevelop.com/5-7years.html&quot;&gt;Childhood Development: 5 to 7 Years &lt;/a&gt; it says:</source>
          <target state="translated">关于&lt;a href=&quot;http://www.howkidsdevelop.com/5-7years.html&quot;&gt;儿童发展：5至7年&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="34b3df084cbf5c7a669b26ff1aacf3c99a1d1dc8" translate="yes" xml:space="preserve">
          <source>Original post by Morris can be found in the &lt;a href=&quot;http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies&quot;&gt;Internet Archive&lt;/a&gt;.</source>
          <target state="translated">莫里斯（Morris）的原始帖子可以在&lt;a href=&quot;http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies&quot;&gt;Internet存档中&lt;/a&gt;找到。</target>
        </trans-unit>
        <trans-unit id="681216b5a1437efa0ee50e426313a7fe8126153e" translate="yes" xml:space="preserve">
          <source>Our code begins with the word &lt;em&gt;function&lt;/em&gt;, so we know that it is one! Then the name of the function &lt;em&gt;sing&lt;/em&gt; - that's my own description of what the function is about. Then parentheses &lt;em&gt;()&lt;/em&gt;. The parentheses are always there for a function. Sometimes they are empty, and sometimes they have something in. This one has a word in: &lt;code&gt;(person)&lt;/code&gt;. After this there is a brace like this &lt;code&gt;{&lt;/code&gt; . This marks the start of the function &lt;em&gt;sing()&lt;/em&gt;. It has a partner which marks the end of &lt;em&gt;sing()&lt;/em&gt; like this &lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">我们的代码以单词&lt;em&gt;function&lt;/em&gt;开头，因此我们知道它是一个！ 然后，函数的名称会&lt;em&gt;唱歌&lt;/em&gt; -这是我对函数含义的描述。 然后括号&lt;em&gt;（）&lt;/em&gt; 。 括号总是存在于函数中。 有时他们是空的，有时他们里面有东西。这个人的名字是： &lt;code&gt;(person)&lt;/code&gt; 。 在这之后有一个括号 &lt;code&gt;{&lt;/code&gt; 这标志着函数&lt;em&gt;sing（）的开始&lt;/em&gt; 。 它有一个标记&lt;em&gt;sing（）&lt;/em&gt;结束的伙伴，例如 &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05c242ba6271e12b61564339fb6644d07e822a54" translate="yes" xml:space="preserve">
          <source>PARENTHESES: &quot;Parentheses&quot; or &lt;code&gt;()&lt;/code&gt; are the letter box on the JavaScript function factory's door or a post box in the street for sending packets of information to the factory. Sometimes the postbox might be marked &lt;em&gt;for example&lt;/em&gt;&lt;code&gt;cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime)&lt;/code&gt;, in which case you know what data you have to give it.</source>
          <target state="translated">家长：&amp;ldquo;括号&amp;rdquo;或 &lt;code&gt;()&lt;/code&gt; 是JavaScript函数工厂门上的信箱或街道上用于向工厂发送信息包的信箱。 有时可能会标记邮箱&lt;em&gt;，例如&lt;/em&gt; &lt;code&gt;cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime)&lt;/code&gt; ，在这种情况下，您知道必须提供哪些数据。</target>
        </trans-unit>
        <trans-unit id="9144b2a7d95b704078de888cf37d60fe67becfb9" translate="yes" xml:space="preserve">
          <source>Perhaps a little beyond all but the most precocious of six-year-olds, but a few examples that helped make the concept of closure in JavaScript click for me.</source>
          <target state="translated">也许除了最早熟的六岁孩子之外,可能有点超出了所有的范围,但有几个例子,让我对JavaScript中的封闭概念有了一些帮助,让我点击了一下。</target>
        </trans-unit>
        <trans-unit id="5faa59d4bc3756040b8ce9e673c09f929e6ee9ba" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Result</target>
        </trans-unit>
        <trans-unit id="bcd4102717d8891f8d496a43ec74da14fa94f69e" translate="yes" xml:space="preserve">
          <source>Returning a &lt;code&gt;function&lt;/code&gt; from inside another function is the classic example of a closure, because the state inside the outer function is implicitly available to the returned inner function, even after the outer function has completed execution. This has a number of use-cases, including simulating private variables.</source>
          <target state="translated">从另一个函数内部返回一个 &lt;code&gt;function&lt;/code&gt; 是闭包的经典示例，因为即使在外部函数完成执行之后，外部函数内部的状态也隐式地可用于返回的内部函数。 这有许多用例，包括模拟私有变量。</target>
        </trans-unit>
        <trans-unit id="ada6589cf526d0c74d239a16a5730f12743a8388" translate="yes" xml:space="preserve">
          <source>Second, when a closure is created, it retains a reference to all of its enclosing function&amp;rsquo;s variables and functions; it doesn&amp;rsquo;t get to pick and choose. And but so, closures should be used sparingly, or at least carefully, as they can be memory intensive; a lot of variables can be kept in memory long after a containing function has finished executing.</source>
          <target state="translated">其次，在创建闭包时，它会保留对其所有封闭函数的变量和函数的引用； 它不是可以选择的。 但是，因此，应该谨慎使用闭包，或者至少要谨慎使用闭包，因为它们可能占用大量内存； 在包含函数执行完后很长一段时间内，许多变量可以保留在内存中。</target>
        </trans-unit>
        <trans-unit id="67fe596a436afe4d7599b96bf46b1977ec2e0ef6" translate="yes" xml:space="preserve">
          <source>She lived in a wonderful world full of adventures. She met her Prince Charming, rode around her world on a unicorn, battled dragons, encountered talking animals, and many other fantastical things.</source>
          <target state="translated">她生活在一个充满冒险的奇妙世界里。她遇到了她的白马王子,骑着独角兽在她的世界里兜兜转转,与龙战斗,遇到会说话的动物,还有很多奇幻的事情。</target>
        </trans-unit>
        <trans-unit id="07573b573651a019027237d961cc61054b6bec94" translate="yes" xml:space="preserve">
          <source>Since &lt;strong&gt;scope-defining construction in JavaScript is a function&lt;/strong&gt;, not a code block like in many other languages, &lt;strong&gt;what we usually mean by &lt;em&gt;closure&lt;/em&gt; in JavaScript&lt;/strong&gt; is a &lt;strong&gt;function working with nonlocal variables defined in already executed surrounding function&lt;/strong&gt;.</source>
          <target state="translated">由于&lt;strong&gt;JavaScript中的作用域定义构造是一个函数&lt;/strong&gt; ，而不是许多其他语言中的代码块&lt;strong&gt;，因此JavaScript&lt;/strong&gt;中的&lt;strong&gt;&lt;em&gt;闭包&lt;/em&gt;通常指的&lt;/strong&gt;是一个&lt;strong&gt;函数，&lt;/strong&gt;该&lt;strong&gt;函数使用已执行的周围函数中定义的非局部变量&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="e95fed48c1d8fabe097fc454c7b9211faa3636be" translate="yes" xml:space="preserve">
          <source>So this function might have something to do with singing, and might need some data about a person. It has instructions inside to do something with that data.</source>
          <target state="translated">所以这个功能可能跟唱歌有关,可能需要一些关于一个人的数据。它里面有指令,可以用这些数据做一些事情。</target>
        </trans-unit>
        <trans-unit id="a50b97914eb409961a9c50a5aaf62d55c22e4149" translate="yes" xml:space="preserve">
          <source>So to live, the child has to leave before it's too late</source>
          <target state="translated">所以要想活下来,孩子必须趁早离开</target>
        </trans-unit>
        <trans-unit id="a2d88110733edd016cbeae6a733e1b0d67a3f3ba" translate="yes" xml:space="preserve">
          <source>So what are these closure thingys?</source>
          <target state="translated">那么,这些封闭的东西是什么?</target>
        </trans-unit>
        <trans-unit id="454c8a36400b7eb57a810440ce57394bfb5816b7" translate="yes" xml:space="preserve">
          <source>So, as long as we are in the parent -function, it can create one or more child functions which do share the secret variables from the secret place.</source>
          <target state="translated">所以,只要我们在父-函数中,它就可以创建一个或多个子函数,而这些子函数确实可以从秘密的地方共享秘密变量。</target>
        </trans-unit>
        <trans-unit id="0a89e976c7abc12da557c349bfa0ca485f347c7a" translate="yes" xml:space="preserve">
          <source>So, function g has access to g, a and f.</source>
          <target state="translated">所以,函数g可以访问g、a和f。</target>
        </trans-unit>
        <trans-unit id="f9cca5aab093ddbfc4f01dcf36fc37ee09f0ff12" translate="yes" xml:space="preserve">
          <source>So, if you call the child &quot;Alice&quot;, she will respond</source>
          <target state="translated">所以,如果你叫孩子 &quot;爱丽丝&quot;,她就会响应</target>
        </trans-unit>
        <trans-unit id="dbc77889f79e6ba70a51ccdd7b1d469ad3fe2209" translate="yes" xml:space="preserve">
          <source>So, whenever you see the &lt;code&gt;function&lt;/code&gt; keyword, code inside that function has access to variables declared outside the function.</source>
          <target state="translated">因此，每当您看到 &lt;code&gt;function&lt;/code&gt; 关键字时，该函数内部的代码都可以访问在该函数外部声明的变量。</target>
        </trans-unit>
        <trans-unit id="32a5b0910ff15915067cd48d69073b7ed24d5e07" translate="yes" xml:space="preserve">
          <source>Submitted by Morris on Tue, 2006-02-21 10:19.  Community-edited since.</source>
          <target state="translated">由 Morris 于 星期二,2006-02-21 10:19 提交。社区编辑以来。</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="9025c4cc6a8af6eb5f548366877eea00d17ba2f8" translate="yes" xml:space="preserve">
          <source>Taking the question seriously, we should find out what a typical 6-year-old is capable of cognitively, though admittedly, one who is interested in JavaScript is not so typical.</source>
          <target state="translated">认真考虑这个问题,我们应该找出一个典型的6岁孩子的认知能力,虽然承认,一个对JavaScript感兴趣的人,并不是那么典型。</target>
        </trans-unit>
        <trans-unit id="67cecda122884bfa553becae4c5685cfae2cbb5f" translate="yes" xml:space="preserve">
          <source>Technically, in &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt;, &lt;strong&gt;every function is a closure&lt;/strong&gt;. It always has an access to variables defined in the surrounding scope.</source>
          <target state="translated">从技术上讲，在&lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript中&lt;/a&gt; ， &lt;strong&gt;每个函数都是一个闭包&lt;/strong&gt; 。 它始终可以访问在周围范围内定义的变量。</target>
        </trans-unit>
        <trans-unit id="97cba4858411c435e526dd651157aac20178222c" translate="yes" xml:space="preserve">
          <source>Thanks</source>
          <target state="translated">Thanks</target>
        </trans-unit>
        <trans-unit id="30a5f96f9b652a33887df9866bf824d883055acd" translate="yes" xml:space="preserve">
          <source>That's all there is to tell.</source>
          <target state="translated">就说到这里吧。</target>
        </trans-unit>
        <trans-unit id="ab6ae4b470ffe5a3279c44a289c97ea3536b0044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trashBags&lt;/code&gt; variable is local to the inside of each kitchen and is not accessible outside, but the inner function on the &lt;code&gt;getTrashBag&lt;/code&gt; property does have access to it.</source>
          <target state="translated">&lt;code&gt;trashBags&lt;/code&gt; 变量是每个厨房内部的局部变量，外部不能访问，但是 &lt;code&gt;getTrashBag&lt;/code&gt; 属性的内部函数可以访问该变量 。</target>
        </trans-unit>
        <trans-unit id="f4b0fe233c7b64030a0dc17c446f53a7aea9634c" translate="yes" xml:space="preserve">
          <source>The Straw Man</source>
          <target state="translated">稻草人</target>
        </trans-unit>
        <trans-unit id="2ac247e683af2d84a6d9660b577f04e07e7d50da" translate="yes" xml:space="preserve">
          <source>The above code has a closure because the anonymous function &lt;code&gt;function() { console.log(text); }&lt;/code&gt; is declared &lt;em&gt;inside&lt;/em&gt; another function, &lt;code&gt;sayHello2()&lt;/code&gt; in this example. In JavaScript, if you use the &lt;code&gt;function&lt;/code&gt; keyword inside another function, you are creating a closure.</source>
          <target state="translated">上面的代码已关闭，因为匿名函数 &lt;code&gt;function() { console.log(text); }&lt;/code&gt; } &lt;em&gt;在&lt;/em&gt;另一个函数&lt;em&gt;内部&lt;/em&gt;声明，在此示例中为 &lt;code&gt;sayHello2()&lt;/code&gt; 。 在JavaScript中，如果在另一个函数中使用 &lt;code&gt;function&lt;/code&gt; 关键字，则将创建一个闭包。</target>
        </trans-unit>
        <trans-unit id="a663b8d54dfafcfe4011bff6acb1a1b012b29b90" translate="yes" xml:space="preserve">
          <source>The above function will also log 16, because the code inside &lt;code&gt;bar&lt;/code&gt; can still refer to argument &lt;code&gt;x&lt;/code&gt; and variable &lt;code&gt;tmp&lt;/code&gt;, even though it they are no longer directly in scope.</source>
          <target state="translated">上面的函数还将记录16，因为 &lt;code&gt;bar&lt;/code&gt; 内的代码仍然可以引用参数 &lt;code&gt;x&lt;/code&gt; 和变量 &lt;code&gt;tmp&lt;/code&gt; ，即使它们不再直接在范围内。</target>
        </trans-unit>
        <trans-unit id="246fdc56b891ef8cd6ddc925b1d907069e7fc98a" translate="yes" xml:space="preserve">
          <source>The author of &lt;em&gt;&lt;a href=&quot;http://javascript.info/tutorial/closures&quot;&gt;Closures&lt;/a&gt;&lt;/em&gt; has explained closures pretty well, explaining the reason why we need them and also explaining LexicalEnvironment which is necessary to understanding closures.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://javascript.info/tutorial/closures&quot;&gt;Closures&lt;/a&gt;&lt;/em&gt;的作者很好地解释了闭包，解释了我们为什么需要它们的原因，还解释了LexicalEnvironment，这对于理解闭包是必需的。</target>
        </trans-unit>
        <trans-unit id="c13d0c83e1140ef05df23d7d967fd539e97fac2a" translate="yes" xml:space="preserve">
          <source>The browser keeps the LexicalEnvironment and all its properties (variables) in memory until there is an inner function which references it.</source>
          <target state="translated">浏览器将LexicalEnvironment和它的所有属性(变量)保存在内存中,直到有一个内部函数引用它。</target>
        </trans-unit>
        <trans-unit id="ebab32e0d02219305bce1886d9e8f64ed8614c91" translate="yes" xml:space="preserve">
          <source>The chain of lexical environments, linked between execution contexts via outer environment references, forms a &lt;em&gt;scope chain&lt;/em&gt; and defines the identifiers visible from any given function.</source>
          <target state="translated">通过外部环境引用在执行上下文之间链接的词汇环境链形成了&lt;em&gt;作用域链，&lt;/em&gt;并定义了从任何给定函数可见的标识符。</target>
        </trans-unit>
        <trans-unit id="1f0b658a23c022351d31c0bee4a00408b17ba821" translate="yes" xml:space="preserve">
          <source>The children will always remember the secrets they have shared with their parents, even after their parents are
  gone. This is what closures are for functions.</source>
          <target state="translated">即使父母不在了,孩子们也会永远记得自己和父母分享的秘密,即使父母不在了,孩子们也会永远记得。这就是封闭性的功能。</target>
        </trans-unit>
        <trans-unit id="d142ef727404c57948941e5ea1a82a1476684d84" translate="yes" xml:space="preserve">
          <source>The closures all know what the &lt;em&gt;sing()&lt;/em&gt; function's variable called &lt;em&gt;firstPart&lt;/em&gt; is, because they can see out from their tinted windows.</source>
          <target state="translated">闭包都知道&lt;em&gt;sing（）&lt;/em&gt;函数名为&lt;em&gt;firstPart&lt;/em&gt;的变量是什么，因为它们可以从其着色窗口中看到。</target>
        </trans-unit>
        <trans-unit id="bb0d2327de1953161942f2ab9fa838498aa1dbcb" translate="yes" xml:space="preserve">
          <source>The example above is using an anonymous function, which was executed once. But it does not have to be. It can be named (e.g. &lt;code&gt;mkdb&lt;/code&gt;) and executed later, generating a database function each time it is invoked. Every generated function will have its own hidden database object. Another usage example of closures is when we don't return a function, but an object containing multiple functions for different purposes, each of those function having access to the same data.</source>
          <target state="translated">上面的示例使用一个匿名函数，该函数执行一次。 但这不是必须的。 可以命名它（例如 &lt;code&gt;mkdb&lt;/code&gt; ）并在以后执行，每次调用它都会生成一个数据库函数。 每个生成的函数将具有其自己的隐藏数据库对象。 闭包的另一个用法示例是当我们不返回一个函数，而是一个对象，该对象包含出于不同目的的多个函数，这些函数中的每个函数都可以访问相同的数据。</target>
        </trans-unit>
        <trans-unit id="d752ad30dcb07b4bf12c76bcaf1fd95663e1c173" translate="yes" xml:space="preserve">
          <source>The following code returns a reference to a function:</source>
          <target state="translated">下面的代码返回一个函数的引用。</target>
        </trans-unit>
        <trans-unit id="5215171b8fbe41f294967978f22f5060d88ee251" translate="yes" xml:space="preserve">
          <source>The following simple example covers all the main points of JavaScript closures.&lt;sup&gt;*&lt;/sup&gt;</source>
          <target state="translated">以下简单示例涵盖了JavaScript闭包的所有要点。 &lt;sup&gt;*&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ad531efca548a3919fa24597ab10762db1c48acd" translate="yes" xml:space="preserve">
          <source>The genius is that in JavaScript a function reference also has a secret reference to the closure it was created in &amp;mdash; similar to how delegates are a method pointer plus a secret reference to an object.</source>
          <target state="translated">天才之处在于，在JavaScript中，函数引用还具有对其创建的闭包的秘密引用&amp;mdash;类似于委托如何成为方法指针以及对对象的秘密引用。</target>
        </trans-unit>
        <trans-unit id="45e0685cacab3e797413836c0a3b3870f011cdba" translate="yes" xml:space="preserve">
          <source>The inner function keeps a reference to the outer
LexicalEnvironment.</source>
          <target state="translated">内部函数保留了对外部LexicalEnvironment的引用。</target>
        </trans-unit>
        <trans-unit id="1222b712516a600e2c63dde997d35b726a9bade9" translate="yes" xml:space="preserve">
          <source>The inner function may access variables from it
any time even if the outer function is finished.</source>
          <target state="translated">即使外部函数已经完成,内部函数也可以随时从它那里访问变量。</target>
        </trans-unit>
        <trans-unit id="0f440ed8885caea2f6a4de181d02ca1ce2bfd985" translate="yes" xml:space="preserve">
          <source>The kitchen is a closure that has a local variable, called &lt;code&gt;trashBags&lt;/code&gt;.  There is a function inside the kitchen called &lt;code&gt;getTrashBag&lt;/code&gt; that gets one trash bag and returns it.</source>
          <target state="translated">厨房是一个封闭的 &lt;code&gt;trashBags&lt;/code&gt; ，它有一个局部变量，称为rashBags 。 厨房内部有一个名为 &lt;code&gt;getTrashBag&lt;/code&gt; 的函数，该函数获取一个垃圾袋并返回。</target>
        </trans-unit>
        <trans-unit id="e9eb91337dbe1342ddf4236b7c7460d616e8d494" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;result.push( function() {console.log(item + ' ' + list[i])}&lt;/code&gt; adds a reference to an anonymous function three times to the result array. If you are not so familiar with anonymous functions think of it like:</source>
          <target state="translated">第 &lt;code&gt;result.push( function() {console.log(item + ' ' + list[i])}&lt;/code&gt; 会在结果数组中添加对匿名函数的引用三次，如果您不太熟悉匿名函数，请考虑一下就如：</target>
        </trans-unit>
        <trans-unit id="3719fe577c00cbcfb269ebde253db1c8de6cf36a" translate="yes" xml:space="preserve">
          <source>The process consists of two steps:</source>
          <target state="translated">这个过程包括两个步骤:</target>
        </trans-unit>
        <trans-unit id="a6b75fac7979ad9def4158f7b987a3aa8e383e53" translate="yes" xml:space="preserve">
          <source>The reason that referenceToInnerFunction can still access the value of outerVar is because when the closure was first created by placing innerFunction inside of outerFunction, innerFunction added a reference to outerFunction&amp;rsquo;s scope (its variables and functions) to its scope chain. What this means is that innerFunction has a pointer or reference to all of outerFunction&amp;rsquo;s variables, including outerVar. So even when outerFunction has finished executing, or even if it is deleted or set to null, the variables in its scope, like outerVar, stick around in memory because of the outstanding reference to them on the part of the innerFunction that has been returned to referenceToInnerFunction. To truly release outerVar and the rest of outerFunction&amp;rsquo;s variables from memory you would have to get rid of this outstanding reference to them, say by setting referenceToInnerFunction to null as well.</source>
          <target state="translated">referenceToInnerFunction仍然可以访问outerVar的值的原因是，当通过将innerFunction放置在outerFunction的内部来首次创建闭包时，innerFunction在其作用域链中添加了对outerFunction的作用域（变量和函数）的引用。 这意味着innerFunction具有指向所有outerFunction变量（包括outerVar）的指针或引用。 因此，即使outerFunction完成执行，或者即使将其删除或设置为null，其范围内的变量（例如outerVar）也会在内存中停留，因为在internalFunction部分上对它们的出色引用referenceToInnerFunction。 为了从内存中真正释放outerVar和outerFunction的其余变量，您必须摆脱对它们的杰出引用，例如，将referenceToInnerFunction也设置为null。</target>
        </trans-unit>
        <trans-unit id="a52ec855c305cdd424a0acec2f16c794668d3e11" translate="yes" xml:space="preserve">
          <source>The secrets for JavaScript functions are the private variables</source>
          <target state="translated">JavaScript函数的秘诀是私有变量</target>
        </trans-unit>
        <trans-unit id="c8048ace855f36cfe6ec5f055971d3ab6080b70b" translate="yes" xml:space="preserve">
          <source>The simplest example of a closure is this:</source>
          <target state="translated">最简单的例子是这样的结尾。</target>
        </trans-unit>
        <trans-unit id="758516d667c0ca64ba31d36b4aa304b7d45c8074" translate="yes" xml:space="preserve">
          <source>The sing() function will call each of these functions in the order they are given. Then the sing() function's work will be done.</source>
          <target state="translated">sing()函数将按照给出的顺序调用这些函数。然后sing()函数的工作就完成了。</target>
        </trans-unit>
        <trans-unit id="b2bfe35512d67b1120c27f2759f79e721a38d640" translate="yes" xml:space="preserve">
          <source>The three functions have shared access to the same closure &amp;mdash; the local variables of &lt;code&gt;setupSomeGlobals()&lt;/code&gt; when the three functions were defined.</source>
          <target state="translated">这三个函数具有对同一个闭包的共享访问权限-定义了三个函数时， &lt;code&gt;setupSomeGlobals()&lt;/code&gt; 的局部变量。</target>
        </trans-unit>
        <trans-unit id="1683c5c3fdaabb276940a6471aab76eac2921b0e" translate="yes" xml:space="preserve">
          <source>There is a critical difference between a C pointer to a function and a JavaScript reference to a function. In JavaScript, you can think of a function reference variable as having both a pointer to a function &lt;em&gt;as well&lt;/em&gt; as a hidden pointer to a closure.</source>
          <target state="translated">指向函数的C指针和指向函数的JavaScript引用之间存在关键区别。 在JavaScript中，您可以认为函数引用变量既具有指向函数的指针又具有指向闭包的隐藏指针。</target>
        </trans-unit>
        <trans-unit id="04637ad8e1b34b4d45e60aaea6b490192d004b6f" translate="yes" xml:space="preserve">
          <source>There is no reason to believe closures are a complex design hack to address specific problems. No, closures are just about using a variable that comes from a higher scope &lt;strong&gt;from the perspective of where the function was declared (not run)&lt;/strong&gt;.</source>
          <target state="translated">没有理由相信闭包是解决特定问题的复杂设计方法。 不， &lt;strong&gt;从函数声明的位置（不运行）的角度来看&lt;/strong&gt; ，闭包只是使用来自更高范围的变量。</target>
        </trans-unit>
        <trans-unit id="dc8da2d96ff3de796d0c72436a2ccd3f4dc18e12" translate="yes" xml:space="preserve">
          <source>There was a princess...</source>
          <target state="translated">有一位公主.....</target>
        </trans-unit>
        <trans-unit id="7ee59ebacfd9d93a5dadb09b49abe5ed01b3d0c0" translate="yes" xml:space="preserve">
          <source>There you go; you're now fully encapsulating this behavior.</source>
          <target state="translated">给你;你现在完全封装了这种行为。</target>
        </trans-unit>
        <trans-unit id="f2e330c9ca939e298d2b5965f2b6b3e1b37e408b" translate="yes" xml:space="preserve">
          <source>This article is intended for programmers with some programming experience in a mainstream language, and who can read the following JavaScript function:</source>
          <target state="translated">这篇文章是为有一定的主流语言编程经验的程序员准备的,能看懂以下JavaScript函数的程序员。</target>
        </trans-unit>
        <trans-unit id="4dd1925d9c601a5cbe75680ad2654c7234add57a" translate="yes" xml:space="preserve">
          <source>This creates a new scope and &lt;code&gt;n&lt;/code&gt; is bound to that scope; this means we have 10 separate scopes, one for each iteration.</source>
          <target state="translated">这将创建一个新范围，并且 &lt;code&gt;n&lt;/code&gt; 绑定到该范围； 这意味着我们有10个单独的范围，每个迭代一个。</target>
        </trans-unit>
        <trans-unit id="7552ddbeac58a09947a400d7a7ab0c7823e95f06" translate="yes" xml:space="preserve">
          <source>This example shows that the closure contains any local variables that were declared inside the outer function before it exited. Note that the variable &lt;code&gt;alice&lt;/code&gt; is actually declared after the anonymous function. The anonymous function is declared first and when that function is called it can access the &lt;code&gt;alice&lt;/code&gt; variable because &lt;code&gt;alice&lt;/code&gt; is in the same scope (JavaScript does &lt;a href=&quot;https://stackoverflow.com/a/3725763/1269037&quot;&gt;variable hoisting&lt;/a&gt;).
Also &lt;code&gt;sayAlice()()&lt;/code&gt; just directly calls the function reference returned from &lt;code&gt;sayAlice()&lt;/code&gt; &amp;mdash; it is exactly the same as what was done previously but without the temporary variable.</source>
          <target state="translated">此示例显示闭包包含退出前在外部函数内部声明的任何局部变量。 请注意，变量 &lt;code&gt;alice&lt;/code&gt; 实际上是在匿名函数之后声明的。 首先声明匿名函数，并在调用该函数时可以访问 &lt;code&gt;alice&lt;/code&gt; 变量，因为 &lt;code&gt;alice&lt;/code&gt; 在同一作用域内（JavaScript进行&lt;a href=&quot;https://stackoverflow.com/a/3725763/1269037&quot;&gt;变量提升&lt;/a&gt; ）。 同样， &lt;code&gt;sayAlice()()&lt;/code&gt; 只是直接调用从 &lt;code&gt;sayAlice()&lt;/code&gt; 返回的函数引用-它与之前所做的操作完全相同，但没有临时变量。</target>
        </trans-unit>
        <trans-unit id="d1bbfb6c03415d46436720884428eece40742855" translate="yes" xml:space="preserve">
          <source>This example shows that the local variables are not copied &amp;mdash; they are kept by reference. It is as though the stack-frame stays alive in memory even after the outer function exits!</source>
          <target state="translated">此示例显示局部变量未复制-通过引用保留它们。 似乎即使外部函数退出后，堆栈框架仍在内存中保持活动状态！</target>
        </trans-unit>
        <trans-unit id="cd052212f50f2244a372f8c3023bb7e1c19cf13f" translate="yes" xml:space="preserve">
          <source>This is an attempt to clear up several (possible) misunderstandings about closures that appear in some of the other answers.</source>
          <target state="translated">这是在试图澄清其他一些答案中出现的关于关闭的几个(可能的)误解。</target>
        </trans-unit>
        <trans-unit id="789cc6e4df4d97f5dde344c2fdb9c85a7781a6d9" translate="yes" xml:space="preserve">
          <source>This is called a closure.</source>
          <target state="translated">这就是所谓的封闭。</target>
        </trans-unit>
        <trans-unit id="d2b023972a185beed0da123eeebf515f35e6bed3" translate="yes" xml:space="preserve">
          <source>This line is calling the function, as if it were calling a dog</source>
          <target state="translated">这一行是在调用函数,就好像是在调用狗一样</target>
        </trans-unit>
        <trans-unit id="2e4d80d915cf259f32a4c6b7797dea00eab65b84" translate="yes" xml:space="preserve">
          <source>This one is a real gotcha for many people, so you need to understand it. Be very careful if you are defining a function within a loop: the local variables from the closure may not act as you might first think.</source>
          <target state="translated">这个问题对很多人来说是个大忌,所以你需要理解它。如果你在循环中定义一个函数,一定要非常小心:来自于闭包的局部变量的作用可能并不像你首先想到的那样。</target>
        </trans-unit>
        <trans-unit id="da5cb87fcafafecdacdfe6ed51e0a0d4f98b7585" translate="yes" xml:space="preserve">
          <source>This page explains closures so that a programmer can understand them &amp;mdash; using working JavaScript code. It is not for gurus or functional programmers.</source>
          <target state="translated">本页介绍了闭包，以便程序员可以使用有效的JavaScript代码来理解闭包。 它不适用于专家或功能性程序员。</target>
        </trans-unit>
        <trans-unit id="b8bdefd19ecf3066cd4728c72ff52ab6024d11aa" translate="yes" xml:space="preserve">
          <source>This will log &lt;code&gt;16&lt;/code&gt;, because function &lt;code&gt;bar&lt;/code&gt; closes over the parameter &lt;code&gt;x&lt;/code&gt; and the variable &lt;code&gt;tmp&lt;/code&gt;, both of which exist in the lexical environment of outer function &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">这将记录为 &lt;code&gt;16&lt;/code&gt; ，因为功能 &lt;code&gt;bar&lt;/code&gt; 关闭了参数 &lt;code&gt;x&lt;/code&gt; 和变量 &lt;code&gt;tmp&lt;/code&gt; ，这两个参数都存在于外部函数 &lt;code&gt;foo&lt;/code&gt; 的词法环境中。</target>
        </trans-unit>
        <trans-unit id="4e28adc0562a325e3e096fedb43aec2bcfc26cc2" translate="yes" xml:space="preserve">
          <source>To summarize:</source>
          <target state="translated">总而言之:</target>
        </trans-unit>
        <trans-unit id="185cffe022e026a4122cc13897f61794b5e49d80" translate="yes" xml:space="preserve">
          <source>Tricky: note the &lt;code&gt;say&lt;/code&gt; variable is also inside the closure and could be accessed by any other function that might be declared within &lt;code&gt;sayAlice()&lt;/code&gt;, or it could be accessed recursively within the inside function.</source>
          <target state="translated">棘手：请注意， &lt;code&gt;say&lt;/code&gt; 变量也位于闭包内部，可以由在 &lt;code&gt;sayAlice()&lt;/code&gt; 中声明的任何其他函数访问，或者可以在内部函数中递归访问。</target>
        </trans-unit>
        <trans-unit id="7738f68d43c61aa58c8d9b9546acdd53ba567dbc" translate="yes" xml:space="preserve">
          <source>Two brief summaries</source>
          <target state="translated">两个简要总结</target>
        </trans-unit>
        <trans-unit id="43a5562bc755854b701217c3e2cea0041b6a10df" translate="yes" xml:space="preserve">
          <source>Two functions might look like they have the same source text, but have completely different behavior because of their 'hidden' closure. I don't think JavaScript code can actually find out if a function reference has a closure or not.</source>
          <target state="translated">两个函数可能看起来好像有相同的源文本,但由于它们的 &quot;隐藏 &quot;闭包而有完全不同的行为。我不认为JavaScript代码实际上可以发现一个函数引用是否有闭包。</target>
        </trans-unit>
        <trans-unit id="b6e33fa589c38cb3d120879b99ebe9f6503bd521" translate="yes" xml:space="preserve">
          <source>Two other things about closures to note. First, the closure will always have access to the last values of its containing function.</source>
          <target state="translated">关于闭包还有两件事需要注意。首先,闭包将始终可以访问其包含的函数的最后一个值。</target>
        </trans-unit>
        <trans-unit id="9c977033015ef8f81efe5ec1a386949630df27f5" translate="yes" xml:space="preserve">
          <source>VARIABLE: The letters &lt;em&gt;var&lt;/em&gt; stand for &quot;variable&quot;. A variable is like an envelope. On the outside this envelope is marked &quot;person&quot;. On the inside it contains a slip of paper with the information our function needs, some letters and spaces joined together like a piece of string (it's called a string) that make a phrase reading &quot;an old lady&quot;. Our envelope could contain other kinds of things like numbers (called integers), instructions (called functions), lists (called &lt;em&gt;arrays&lt;/em&gt;). Because this variable is written outside of all the braces &lt;code&gt;{}&lt;/code&gt;, and because you can see out through the tinted windows when you are inside the braces, this variable can be seen from anywhere in the code. We call this a 'global variable'.</source>
          <target state="translated">变量：字母&lt;em&gt;var&lt;/em&gt;代表&amp;ldquo;变量&amp;rdquo;。 变量就像一个信封。 在外面的信封上标有&amp;ldquo;人&amp;rdquo;字样。 它的内部包含一张纸条，上面有我们的功能所需的信息，一些字母和空格像一条绳子（称为绳子）连接在一起，构成一个短语，上面写着&amp;ldquo;一位老太太&amp;rdquo;。 我们的信封可能包含其他种类的东西，例如数字（称为整数），指令（称为函数），列表（称为&lt;em&gt;数组&lt;/em&gt; ）。 因为此变量写在所有大括号 &lt;code&gt;{}&lt;/code&gt; 之外 ，并且因为当您位于大括号内时可以看到着色窗口，所以可以从代码的任何位置看到此变量。 我们称其为&amp;ldquo;全局变量&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="0a3b4dd6c2b81d0408e62dc4b0c7d9aa719858b8" translate="yes" xml:space="preserve">
          <source>We can code this in JavaScript like this:</source>
          <target state="translated">我们可以这样用JavaScript进行编码。</target>
        </trans-unit>
        <trans-unit id="0dd5ca9fc457449d5a7438bfa95e87b689ade82a" translate="yes" xml:space="preserve">
          <source>We can use this example to explain closures, as follows:</source>
          <target state="translated">我们可以用这个例子来解释闭合,具体如下。</target>
        </trans-unit>
        <trans-unit id="cfb7d9f151f2ce139f3a16a6d13ee0a6d6a9272b" translate="yes" xml:space="preserve">
          <source>What if a variable is accessed, but it isn&amp;rsquo;t local? Like here:</source>
          <target state="translated">如果访问变量但不是局部变量怎么办？ 像这儿：</target>
        </trans-unit>
        <trans-unit id="1e8f90f12d65d0d31eedfa442526261ad87df2b7" translate="yes" xml:space="preserve">
          <source>What might not be obvious is that since &lt;code&gt;createClosureArray()&lt;/code&gt; is only invoked once only one scope is created for this function instead of one for every iteration of the loop.</source>
          <target state="translated">可能不明显的是，由于仅调用一次 &lt;code&gt;createClosureArray()&lt;/code&gt; 才能为此函数创建一个作用域，而不是每次循环都创建一个作用域。</target>
        </trans-unit>
        <trans-unit id="082f7b2b11f91eb896764f16c3c56d45e4ee7ca7" translate="yes" xml:space="preserve">
          <source>What would happen here if JavaScript &lt;em&gt;didn't&lt;/em&gt; know closures? Just replace the call in the last line by its method body (which is basically what function calls do) and you get:</source>
          <target state="translated">如果JavaScript &lt;em&gt;不&lt;/em&gt;知道闭包，在这里会发生什么？ 只需将最后一行的调用替换为其方法主体（基本上是函数调用所做的工作），您将获得：</target>
        </trans-unit>
        <trans-unit id="0d4abbfdfc801f0827fc6f8072079568d1427247" translate="yes" xml:space="preserve">
          <source>When a JavaScript function is invoked, a new execution context &lt;code&gt;ec&lt;/code&gt; is created. Together with the function arguments and the target object, this execution context also receives a link to the lexical environment of the calling execution context, meaning the variables declared in the outer lexical environment (in the above example, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;) are available from &lt;code&gt;ec&lt;/code&gt;.</source>
          <target state="translated">调用JavaScript函数时，将创建一个新的执行上下文 &lt;code&gt;ec&lt;/code&gt; 。 与函数参数和目标对象一起，此执行上下文还接收到调用执行上下文的词法环境的链接，这意味着可以在外部词法环境中声明的变量（在上面的示例中， &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 均可从）获得。 &lt;code&gt;ec&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="d7551a120ee1e0a45d0b5cf36770825ae08a23f1" translate="yes" xml:space="preserve">
          <source>When a function (&lt;code&gt;foo&lt;/code&gt;) declares other functions (bar and baz), the family of local variables created in &lt;code&gt;foo&lt;/code&gt; is &lt;em&gt;not destroyed&lt;/em&gt; when the function exits. The variables merely become invisible to the outside world. &lt;code&gt;foo&lt;/code&gt; can therefore cunningly return the functions &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt;, and they can continue to read, write and communicate with each other through this closed-off family of variables (&quot;the closure&quot;) that nobody else can meddle with, not even someone who calls &lt;code&gt;foo&lt;/code&gt; again in future.</source>
          <target state="translated">当函数（ &lt;code&gt;foo&lt;/code&gt; ）声明其他函数（bar和baz）时，在函数退出时&lt;em&gt;不会破坏&lt;/em&gt;在 &lt;code&gt;foo&lt;/code&gt; 中创建的局部变量系列。 这些变量只是对外界不可见。 &lt;code&gt;foo&lt;/code&gt; 因此可以巧妙地返回 &lt;code&gt;bar&lt;/code&gt; 和 &lt;code&gt;baz&lt;/code&gt; 函数，并且它们可以通过这个封闭的变量家族（&amp;ldquo;闭包&amp;rdquo;）继续进行读取，写入和通信，这些变量是其他任何人都无法干预的，甚至没有人可以介入 &lt;code&gt;foo&lt;/code&gt; 再来一次。</target>
        </trans-unit>
        <trans-unit id="a14a687cf5a4767a5c232cb3c825bc777cc5955b" translate="yes" xml:space="preserve">
          <source>When a function is created, it gets a hidden property, named [[Scope]], which references the current LexicalEnvironment.</source>
          <target state="translated">当一个函数被创建时,它将获得一个隐藏的属性,名为[[[[[Scope]]]],它引用了当前的LexicalEnvironment。</target>
        </trans-unit>
        <trans-unit id="af97d2eb165c46e20d5beb31d9f67783d9ae76ed" translate="yes" xml:space="preserve">
          <source>When a function is invoked via the internal &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist&quot;&gt;&lt;code&gt;[[Call]]&lt;/code&gt;&lt;/a&gt; method, the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt;&lt;code&gt;[[Environment]]&lt;/code&gt;&lt;/a&gt; reference on the function-object is copied into the &lt;em&gt;outer environment reference&lt;/em&gt; of the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records&quot;&gt;environment record&lt;/a&gt; of the newly-created &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;execution context&lt;/a&gt; (stack frame).</source>
          <target state="translated">通过内部&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist&quot;&gt; &lt;code&gt;[[Call]]&lt;/code&gt; &lt;/a&gt;方法调用功能时，功能对象上的&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt; &lt;code&gt;[[Environment]]&lt;/code&gt; &lt;/a&gt;引用将复制到新创建的&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;执行上下文&lt;/a&gt; （堆栈框架）的&lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records&quot;&gt;环境记录&lt;/a&gt;的&lt;em&gt;外部环境引用&lt;/em&gt;中。</target>
        </trans-unit>
        <trans-unit id="eda8d0ba8c86f2bcc7f89824f85d577c09f72064" translate="yes" xml:space="preserve">
          <source>When the browser has loaded the JavaScript code an reached this line, it will start the function. I put the line at the end to make sure that the browser has all the information it needs to run it.</source>
          <target state="translated">当浏览器加载了JavaScript代码并到达这一行时,它将启动函数。我把这一行放在最后,是为了确保浏览器有运行它所需要的所有信息。</target>
        </trans-unit>
        <trans-unit id="656c8142287a1690f7f3625f825e5d62a85448e1" translate="yes" xml:space="preserve">
          <source>When the user clicks the VoteUp button, the voteUp_click function checks whether isVotedDown == true to determine whether to vote up or merely cancel a down vote. Function voteUp_click is a closure because it is accessing its environment.</source>
          <target state="translated">当用户点击VoteUp按钮时,voteUp_click函数会检查isVotedDown是否==true,以决定是投上票还是仅仅取消下票。函数voteUp_click是一个封闭函数,因为它是在访问它的环境。</target>
        </trans-unit>
        <trans-unit id="6df579e2161f6eb523745bff56a56ef486a46f72" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;new Function(&amp;hellip;)&lt;/code&gt; (the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function&quot;&gt;Function constructor&lt;/a&gt;) inside a function, it does not close over its lexical environment: it closes over the global context instead. (The new function cannot reference the local variables of the outer function.)</source>
          <target state="translated">当您在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function&quot;&gt;函数&lt;/a&gt;内部使用 &lt;code&gt;new Function(&amp;hellip;)&lt;/code&gt; （ 函数构造函数）时，它不会关闭其词法环境：而是关闭全局上下文。 （新函数不能引用外部函数的局部变量。）</target>
        </trans-unit>
        <trans-unit id="fc1b188972939bb322463b13d9e6d79ec73b22c6" translate="yes" xml:space="preserve">
          <source>Whenever a function is declared in JavaScript a closure is created.</source>
          <target state="translated">每当JavaScript中声明了一个函数,就会创建一个闭包。</target>
        </trans-unit>
        <trans-unit id="42d771d468376a7581a6ea18362bea86ddcf67ad" translate="yes" xml:space="preserve">
          <source>Whenever you use &lt;code&gt;eval()&lt;/code&gt; inside a function, a closure is used. The text you &lt;code&gt;eval&lt;/code&gt; can reference local variables of the function, and within &lt;code&gt;eval&lt;/code&gt; you can even create new local variables by using &lt;code&gt;eval('var foo = &amp;hellip;')&lt;/code&gt;</source>
          <target state="translated">每当在 &lt;code&gt;eval()&lt;/code&gt; 内部使用eval（）时 ，都会使用闭包。 您 &lt;code&gt;eval&lt;/code&gt; 的文本可以引用函数的局部变量，并且在 &lt;code&gt;eval&lt;/code&gt; 内甚至可以使用 &lt;code&gt;eval('var foo = &amp;hellip;')&lt;/code&gt; 创建新的局部变量。</target>
        </trans-unit>
        <trans-unit id="68b3446fbf7d6fb0e4c451a7d1ae63e9f388e484" translate="yes" xml:space="preserve">
          <source>Within each scope &lt;code&gt;n&lt;/code&gt; is bound to whatever value it had when &lt;code&gt;createClosure(n)&lt;/code&gt; was invoked so the nested function that gets returned will always return the value of &lt;code&gt;n&lt;/code&gt; that it had when &lt;code&gt;createClosure(n)&lt;/code&gt; was invoked.</source>
          <target state="translated">在每个范围内， &lt;code&gt;n&lt;/code&gt; 绑定到调用 &lt;code&gt;createClosure(n)&lt;/code&gt; 时具有的任何值，因此要返回的嵌套函数将始终返回调用 &lt;code&gt;createClosure(n)&lt;/code&gt; 时具有的 &lt;code&gt;n&lt;/code&gt; 的值。</target>
        </trans-unit>
        <trans-unit id="f3685d63e9253161c4b5418f6dbd94db0b7b6fc6" translate="yes" xml:space="preserve">
          <source>Within this function a variable named &lt;code&gt;index&lt;/code&gt; is defined. The loop runs and adds functions to the array that return &lt;code&gt;index&lt;/code&gt;. Note that &lt;code&gt;index&lt;/code&gt; is defined within the &lt;code&gt;createClosureArray&lt;/code&gt; function which only ever gets invoked one time.</source>
          <target state="translated">在此函数中，定义了一个名为 &lt;code&gt;index&lt;/code&gt; 的变量。 循环运行并将函数添加到返回 &lt;code&gt;index&lt;/code&gt; 的数组中。 请注意， &lt;code&gt;index&lt;/code&gt; 是在 &lt;code&gt;createClosureArray&lt;/code&gt; 函数中定义的，该函数只能被调用一次。</target>
        </trans-unit>
        <trans-unit id="6930e04d92d01fa662d11df5aa5d0e9bd5d8f5f8" translate="yes" xml:space="preserve">
          <source>Yes. You probably use that many times a day.</source>
          <target state="translated">是的,你可能一天要用那么多次。</target>
        </trans-unit>
        <trans-unit id="d579fab7eac666a9836aa39e6b35da201bfec6ea" translate="yes" xml:space="preserve">
          <source>You know how grown-ups can own a house, and they call it home? When a mom has a child, the child doesn't really own anything, right? But its parents own a house, so whenever someone asks the child &quot;Where's your home?&quot;, he/she can answer &quot;that house!&quot;, and point to the house of its parents. A &quot;Closure&quot; is the ability of the child to always (even if abroad) be able to say it has a home, even though it's really the parent's who own the house.</source>
          <target state="translated">你知道大人们有了房子,就可以拥有一套房子,还叫家吗?当妈妈有了孩子,孩子其实并不拥有什么,对吧?但它的父母拥有一套房子,所以,每当有人问孩子 &quot;你的家在哪里?&quot;,他就可以回答 &quot;那套房子!&quot;,并指着父母的房子说:&quot;那套房子!&quot;。所谓 &quot;闭关&quot;,是指孩子能够始终(即使在国外)能说自己有家,即使房子真的是父母的,也能说自己有家。</target>
        </trans-unit>
        <trans-unit id="f95a097c531667e7c2a6ae971917615f399a2b1d" translate="yes" xml:space="preserve">
          <source>You need to understand the &quot;variable hoisting&quot; feature in Javascript in order to understand this example.</source>
          <target state="translated">为了理解这个例子,你需要了解Javascript中的 &quot;变量提升 &quot;功能。</target>
        </trans-unit>
        <trans-unit id="12fa562f7e0a2d3533b4af8a1d5c7d14b86a0f78" translate="yes" xml:space="preserve">
          <source>You're having a sleep over and you invite Dan.
You tell Dan to bring one XBox controller.</source>
          <target state="translated">你要在这里过夜,你邀请了Dan。 You're having a sleep over and you invite Dan.你叫Dan带一个XBox控制器来。</target>
        </trans-unit>
        <trans-unit id="0a0db21e6a13f3e33a5d7e7ef217b86c21a634c3" translate="yes" xml:space="preserve">
          <source>Your child will be able to follow two-step directions. For example, if you say to your child, &quot;Go to the kitchen and get me a trash bag&quot; they will be able to remember that direction.</source>
          <target state="translated">你的孩子将能够按照两步走的方向去做。例如,如果你对孩子说:&quot;去厨房给我拿个垃圾袋&quot;,他们就能记住这个方向。</target>
        </trans-unit>
        <trans-unit id="65d09cbca9a2110fcca151e4c7f0c0fb68f6c5eb" translate="yes" xml:space="preserve">
          <source>anything in outer functions</source>
          <target state="translated">外在功能</target>
        </trans-unit>
        <trans-unit id="ebf5cf1386d90514706786d86faa965c625f69a5" translate="yes" xml:space="preserve">
          <source>button or look at the Options settings to open the developer console of a browser and type &quot;person&quot; to see what this value is. Type &lt;code&gt;person=&quot;a young man&quot;&lt;/code&gt; to change it and then type &quot;person&quot; again to see that it has changed.</source>
          <target state="translated">按钮或查看&amp;ldquo;选项&amp;rdquo;设置以打开浏览器的开发人员控制台，然后键入&amp;ldquo; person&amp;rdquo;以查看该值是什么。 键入 &lt;code&gt;person=&quot;a young man&quot;&lt;/code&gt; 进行更改，然后再次键入&amp;ldquo; person&amp;rdquo;以查看其已更改。</target>
        </trans-unit>
        <trans-unit id="a253f2310ab98afd2ae5163409dd162753885015" translate="yes" xml:space="preserve">
          <source>ems</source>
          <target state="translated">ems</target>
        </trans-unit>
        <trans-unit id="18c4aadf416cf320b65098f9eaf67f9101b6b90e" translate="yes" xml:space="preserve">
          <source>globals, including the DOM</source>
          <target state="translated">球体,包括DOM</target>
        </trans-unit>
        <trans-unit id="4f7d81389762366c131edcfc1778acc037b192e4" translate="yes" xml:space="preserve">
          <source>n = 0</source>
          <target state="translated">n=0</target>
        </trans-unit>
        <trans-unit id="92ee913214330816c21ed1490df01843b5cb2075" translate="yes" xml:space="preserve">
          <source>n = 1</source>
          <target state="translated">n=1</target>
        </trans-unit>
        <trans-unit id="ac48f9f7795484b3747139f0e4cb0790db58945a" translate="yes" xml:space="preserve">
          <source>n = 10</source>
          <target state="translated">n=10</target>
        </trans-unit>
        <trans-unit id="9a3240ad86b2b1d076825686aaf98565beeaac04" translate="yes" xml:space="preserve">
          <source>n = 2</source>
          <target state="translated">n=2</target>
        </trans-unit>
        <trans-unit id="5c515985c0cd23c7519d06977a9d6767394ced82" translate="yes" xml:space="preserve">
          <source>n = 3</source>
          <target state="translated">n=3</target>
        </trans-unit>
        <trans-unit id="83402797555a7a7885fe6185251ac997c92f242d" translate="yes" xml:space="preserve">
          <source>n = 4</source>
          <target state="translated">n=4</target>
        </trans-unit>
        <trans-unit id="adb8f164b2e9a9a073815a5580b5848dc5c47b6f" translate="yes" xml:space="preserve">
          <source>n = 5</source>
          <target state="translated">n=5</target>
        </trans-unit>
        <trans-unit id="6fec459a8cd8a34f975e728d91238f3f70ad3b48" translate="yes" xml:space="preserve">
          <source>n = 6</source>
          <target state="translated">n=6</target>
        </trans-unit>
        <trans-unit id="fd8cf86ee6124bea277fbfcdf77a50b8452d4005" translate="yes" xml:space="preserve">
          <source>n = 7</source>
          <target state="translated">n=7</target>
        </trans-unit>
        <trans-unit id="f0f1184215b3e3a06534b7ea7b8d947bb19c606d" translate="yes" xml:space="preserve">
          <source>n = 8</source>
          <target state="translated">n=8</target>
        </trans-unit>
        <trans-unit id="2cdacf2d84f0a2faf20a870a9028c14e3ea19dd0" translate="yes" xml:space="preserve">
          <source>n = 9</source>
          <target state="translated">n=9</target>
        </trans-unit>
        <trans-unit id="435cb10a0d15e1b9ac626e4505828ceeac244444" translate="yes" xml:space="preserve">
          <source>referenceToInnerFunction is set to outerFunction(), which simply returns a reference to innerFunction. When referenceToInnerFunction is called, it returns outerVar. Again, as above, this demonstrates that innerFunction has access to outerVar, a variable of outerFunction. Furthermore, it is interesting to note that it retains this access even after outerFunction has finished executing.</source>
          <target state="translated">referenceToInnerFunction被设置为 outerFunction(),它简单地返回一个对innerFunction的引用。当调用referenceToInnerFunction时,它返回 outerVar。同样,如上所述,这表明 innerFunction 可以访问 outerFunction 的变量 outerVar。此外,值得注意的是,即使在 outerFunction 执行完毕后,它仍然保留了这个访问权限。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
