<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/111102">
    <body>
      <group id="111102">
        <trans-unit id="edc3d87bc0d77451b24b00c1cf3016bdb95e72af" translate="yes" xml:space="preserve">
          <source>&quot;Come on &lt;em&gt;sing&lt;/em&gt;, Come and get &lt;em&gt;person&lt;/em&gt;!&quot;</source>
          <target state="translated">&quot;Давай &lt;em&gt;петь&lt;/em&gt; , иди и возьми &lt;em&gt;человека&lt;/em&gt; !&quot;</target>
        </trans-unit>
        <trans-unit id="7dd20ec9bc8964ce1c79283c85999cad1cee4dac" translate="yes" xml:space="preserve">
          <source>...is really a princess with a little girl inside.</source>
          <target state="translated">...на самом деле принцесса с маленькой девочкой внутри.</target>
        </trans-unit>
        <trans-unit id="103badd33a2698b99355a3659479f625c4c33efa" translate="yes" xml:space="preserve">
          <source>...telling stories about magic and fantasy.</source>
          <target state="translated">...рассказывая истории о магии и фантазии.</target>
        </trans-unit>
        <trans-unit id="dd3acb8afd097803b9360b2f69c1fea1de5f28bb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Closure_(computer_science)&quot;&gt;Wikipedia on closures&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Closure_(computer_science)&quot;&gt;Википедия о замыканиях&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="66795f475c16753ced57a004591a7e32d1be97f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createClosure(n)&lt;/code&gt; returns a function that returns the n within that scope.</source>
          <target state="translated">&lt;code&gt;createClosure(n)&lt;/code&gt; возвращает функцию, которая возвращает n в этой области.</target>
        </trans-unit>
        <trans-unit id="0605c773a855ad7752167561fff57f3ec27930c0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you are familiar with stack frames, these calculators seem strange: How can they keep accessing &lt;code&gt;n&lt;/code&gt; after &lt;code&gt;make_calculator&lt;/code&gt; returns?  The answer is to imagine that JavaScript doesn't use &quot;stack frames&quot;, but instead uses &quot;heap frames&quot;, which can persist after the function call that made them returns.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Если вы знакомы со стековыми фреймами, эти калькуляторы кажутся странными: как они могут продолжать обращаться к &lt;code&gt;n&lt;/code&gt; после возвращения &lt;code&gt;make_calculator&lt;/code&gt; ?&lt;/em&gt; &lt;em&gt;Ответ состоит в том, чтобы представить, что JavaScript не использует &amp;laquo;стековые фреймы&amp;raquo;, а вместо этого использует &amp;laquo;кучные фреймы&amp;raquo;, которые могут сохраняться после возврата вызова функции, который их сделал.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f02b4fea2cc85281d187a2a3101725f3bd466ca9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that &lt;code&gt;/*...*/&lt;/code&gt; and &lt;code&gt;//&lt;/code&gt; stop code being read by the browser.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Обратите внимание, что &lt;code&gt;/*...*/&lt;/code&gt; и &lt;code&gt;//&lt;/code&gt; прекращаем чтение кода браузером.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11d4db30148058831981cd0f151cdbbc17e172a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://jondavidjohn.com/javascript-closure-explained-using-events/&quot;&gt;Full Blog Post&lt;/a&gt;&lt;/strong&gt; (including jQuery considerations)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://jondavidjohn.com/javascript-closure-explained-using-events/&quot;&gt;Полный пост в блоге&lt;/a&gt;&lt;/strong&gt; (включая соображения jQuery)</target>
        </trans-unit>
        <trans-unit id="2184405757c5883c445a99418ddb1a5ee63000ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A closure does not reference a copy of the &lt;em&gt;old values&lt;/em&gt; of variables in its scope.&lt;/strong&gt; The variables themselves are part of the closure, and so the value seen when accessing one of those variables is the latest value at the time it is accessed. This is why inner functions created inside of loops can be tricky, since each one has access to the same outer variables rather than grabbing a copy of the variables at the time the function is created or called.</source>
          <target state="translated">&lt;strong&gt;Закрытие не ссылается на копию &lt;em&gt;старых значений&lt;/em&gt; переменных в своей области видимости.&lt;/strong&gt; Сами переменные являются частью замыкания, и поэтому значение, видимое при обращении к одной из этих переменных, является самым последним значением на момент обращения к нему. Вот почему внутренние функции, созданные внутри циклов, могут быть хитрыми, поскольку каждая из них имеет доступ к одним и тем же внешним переменным, а не захватывает копию переменных во время создания или вызова функции.</target>
        </trans-unit>
        <trans-unit id="fca46227ced34fb88ba8cfe8076a5166aafd4927" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A closure is not only created when you return an inner function.&lt;/strong&gt; In fact, the enclosing function &lt;em&gt;does not need to return at all&lt;/em&gt; in order for its closure to be created. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be called immediately or any time later. Therefore, the closure of the enclosing function is probably created &lt;em&gt;as soon as the enclosing function is called&lt;/em&gt; since any inner function has access to that closure whenever the inner function is called, before or after the enclosing function returns.</source>
          <target state="translated">&lt;strong&gt;Закрытие создается не только когда вы возвращаете внутреннюю функцию.&lt;/strong&gt; Фактически, функция включения &lt;em&gt;вообще не должна возвращаться&lt;/em&gt; для создания своего замыкания. Вместо этого вы можете назначить свою внутреннюю функцию переменной во внешней области видимости или передать ее в качестве аргумента другой функции, где она может быть вызвана немедленно или в любое время позже. Следовательно, замыкание закрывающей функции, вероятно, создается, &lt;em&gt;как только вызывается включающая функция,&lt;/em&gt; поскольку любая внутренняя функция имеет доступ к этому замыканию всякий раз, когда вызывается внутренняя функция, до или после возврата закрывающей функции.</target>
        </trans-unit>
        <trans-unit id="00219869d9055a1e27de043a26f737d91e3bf84a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A simple one-line closure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Простое однострочное закрытие&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="91cf9ee5cd212f0f8bb3975b7361624cdd8591da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures are simple:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Замыкания просты:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="250c978ae2221ba3664641f80c30d217a35cbabd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures use memory, but they don't cause memory leaks&lt;/strong&gt; since JavaScript by itself cleans up its own circular structures that are not referenced. Internet&amp;nbsp;Explorer memory leaks involving closures are created when it fails to disconnect DOM attribute values that reference closures, thus maintaining references to possibly circular structures.</source>
          <target state="translated">&lt;strong&gt;Замыкания используют память, но они не вызывают утечек памяти,&lt;/strong&gt; поскольку JavaScript сам по себе очищает свои собственные циклические структуры, на которые нет ссылок. Утечки памяти в Internet Explorer, связанные с замыканиями, создаются, когда ему не удается отключить значения атрибутов DOM, которые ссылаются на замыкания, тем самым сохраняя ссылки на, возможно, циклические структуры.</target>
        </trans-unit>
        <trans-unit id="39211d5634ba3cd86a1dc857711c0d8ac86b5585" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Closures&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d15f24a4f0cd805269e16daabf51293fb70abdd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Details&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Details&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e10d41f97175e0e801260eba2b8480649a3edd17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I do not understand why the answers are so complex here.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Я не понимаю, почему ответы здесь такие сложные.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a50ab2a11da4fccbf9d1c29ea600ffcd387ddf7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;INSTRUCTIONS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;INSTRUCTIONS&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ff1823b9f3f4a4211cd7c4e7170f0588c83d10b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nested functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вложенные функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53afa8789f0371667bc4398726df5e5b35cd9345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Once upon a time:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Давным-давно:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f67d2cba0fc9f06b1b71e8974beb527b1d446b34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note that in an attempt to improve clarity and accuracy, this answer has been substantially changed from the original.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Обратите внимание, что в попытке улучшить ясность и точность, этот ответ был существенно изменен по сравнению с оригиналом.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dfa0bbb5599405ba4b579ca14868a26d8d25c5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THE LONG CODE EXAMPLE ABOVE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример длинного кода выше&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0def28abff50b5453af5effe03f21c319e75a393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5d4cedc50da37d6975ca1e41fe4dc499b53f427" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;That is pretty much all there is to closures.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Это почти все, что нужно для замыканий.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e361521851a8d0097ea1590fec832e52c6bc93db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &quot;variables&quot; in a closure include any named functions&lt;/strong&gt; declared within the function. They also include arguments of the function. A closure also has access to its containing closure's variables, all the way up to the global scope.</source>
          <target state="translated">&lt;strong&gt;&amp;laquo;Переменные&amp;raquo; в замыкании включают любые именованные функции,&lt;/strong&gt; объявленные внутри функции. Они также включают аргументы функции. Замыкание также имеет доступ к переменным содержащего замыкание, вплоть до глобальной области видимости.</target>
        </trans-unit>
        <trans-unit id="4531071f03fc0a5d3c0274d7c65683c8b80868b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key point:&lt;/strong&gt; Each call to &lt;code&gt;make_calculator&lt;/code&gt; creates a new local variable &lt;code&gt;n&lt;/code&gt;, which continues to be usable by that calculator's &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt; functions long after &lt;code&gt;make_calculator&lt;/code&gt; returns.</source>
          <target state="translated">&lt;strong&gt;Ключевой момент: при&lt;/strong&gt; каждом вызове &lt;code&gt;make_calculator&lt;/code&gt; создается новая локальная переменная &lt;code&gt;n&lt;/code&gt; , которая продолжает использоваться функциями &lt;code&gt;add&lt;/code&gt; и &lt;code&gt;multiply&lt;/code&gt; этого калькулятора еще долго после &lt;code&gt;make_calculator&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2f004a18b07e1ba3d927ea9c5aa182e662f6312" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The whole point is to ensure that if the inner function wants to access an outer variable in the future, it is able to do so.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Весь смысл в том, чтобы гарантировать, что если внутренняя функция захочет получить доступ к внешней переменной в будущем, она сможет это сделать.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9289561f1d2c7006a3223c749a580963260ce102" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;*A C# question&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;* AC # вопрос&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2907f5d699e83f056b74043078bdbf321536087f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;sup&gt;**&lt;/sup&gt; Any outer function, if several are nested, or even in the global context, as &lt;a href=&quot;https://stackoverflow.com/a/5099447/706054&quot;&gt;this answer&lt;/a&gt; points out clearly.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;sup&gt;**&lt;/sup&gt; Любая внешняя функция, если несколько вложена, или даже в глобальном контексте, как ясно указывает &lt;a href=&quot;https://stackoverflow.com/a/5099447/706054&quot;&gt;этот ответ&lt;/a&gt; .&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="841613276b73dfb7dcf3075c43173d44d03601fb" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;sup&gt;*&lt;/sup&gt; For example, it covers all the points in the &quot;Closures for Dummies&quot; article given in &lt;a href=&quot;https://stackoverflow.com/a/111111/706054&quot;&gt;another answer&lt;/a&gt;, except example 6, which simply shows that variables can be used before they are declared, a nice fact to know but completely unrelated to closures. It also covers all the points in &lt;a href=&quot;https://stackoverflow.com/a/111200/706054&quot;&gt;the accepted answer&lt;/a&gt;, except for the points (1) that functions copy their arguments into local variables (the named function arguments), and (2) that copying numbers creates a new number, but copying an object reference gives you another reference to the same object. These are also good to know but again completely unrelated to closures. It is also very similar to the example in &lt;a href=&quot;https://stackoverflow.com/a/111114/706054&quot;&gt;this answer&lt;/a&gt; but a bit shorter and less abstract. It does not cover the point of &lt;a href=&quot;https://stackoverflow.com/a/17200991/706054&quot;&gt;this answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17308587?noredirect=1#comment26377355_111111&quot;&gt;this comment&lt;/a&gt;, which is that JavaScript makes it difficult to plug the &lt;em&gt;current&lt;/em&gt; value of a loop variable into your inner function: The &quot;plugging in&quot; step can only be done with a helper function that encloses your inner function and is invoked on each loop iteration. (Strictly speaking, the inner function accesses the helper function's copy of the variable, rather than having anything plugged in.) Again, very useful when creating closures, but not part of what a closure is or how it works. There is additional confusion due to closures working differently in functional languages like ML, where variables are bound to values rather than to storage space, providing a constant stream of people who understand closures in a way (namely the &quot;plugging in&quot; way) that is simply incorrect for JavaScript, where variables are always bound to storage space, and never to values. &lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;sup&gt;*&lt;/sup&gt; Например, он охватывает все пункты в статье &amp;laquo;Замыкания для чайников&amp;raquo;, приведенной в &lt;a href=&quot;https://stackoverflow.com/a/111111/706054&quot;&gt;другом ответе&lt;/a&gt; , кроме примера 6, в котором просто показано, что переменные можно использовать до того, как они объявлены, - хороший факт, который нужно знать, но совершенно не связанный с замыканиями.&lt;/sup&gt; &lt;sup&gt;Он также охватывает все точки в &lt;a href=&quot;https://stackoverflow.com/a/111200/706054&quot;&gt;принятом ответе&lt;/a&gt; , за исключением точек (1), в которых функции копируют свои аргументы в локальные переменные (аргументы именованной функции), и (2) копирование чисел создает новый номер, но копирует ссылку на объект дает вам еще одну ссылку на тот же объект.&lt;/sup&gt; &lt;sup&gt;Это также полезно знать, но опять же совершенно не связано с замыканиями.&lt;/sup&gt; &lt;sup&gt;Это также очень похоже на пример в &lt;a href=&quot;https://stackoverflow.com/a/111114/706054&quot;&gt;этом ответе,&lt;/a&gt; но немного короче и менее абстрактно.&lt;/sup&gt; &lt;sup&gt;Он не охватывает суть &lt;a href=&quot;https://stackoverflow.com/a/17200991/706054&quot;&gt;этого ответа&lt;/a&gt; или &lt;a href=&quot;https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17308587?noredirect=1#comment26377355_111111&quot;&gt;этого комментария&lt;/a&gt; , заключающегося в том, что JavaScript затрудняет вставку &lt;em&gt;текущего&lt;/em&gt; значения переменной цикла в вашу внутреннюю функцию: шаг &amp;laquo;подключения&amp;raquo; может быть выполнен только с помощью вспомогательной функции, которая включает ваша внутренняя функция и вызывается на каждой итерации цикла.&lt;/sup&gt; &lt;sup&gt;(Строго говоря, внутренняя функция обращается к копии переменной вспомогательной функции, а не к чему-либо подключенному.) Опять же, очень полезно при создании замыканий, но не является частью того, что такое замыкание или как оно работает.&lt;/sup&gt; &lt;sup&gt;Существует дополнительная путаница из-за того, что замыкания работают по-разному в функциональных языках, таких как ML, где переменные связаны со значениями, а не с пространством хранения, предоставляя постоянный поток людей, которые понимают замыкания способом (а именно способом &amp;laquo;подключения&amp;raquo;), который является просто неверно для JavaScript, где переменные всегда связаны с пространством хранения, а не со значениями.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="eb8e6848b2572e4d1686265bf069ed036b474a37" translate="yes" xml:space="preserve">
          <source>A closure in JavaScript is like keeping a reference (&lt;strong&gt;NOT&lt;/strong&gt; a copy) to the scope at the point of function declaration... plus a link to all the scopes nested outside that scope.</source>
          <target state="translated">Закрытие в JavaScript похоже на сохранение ссылки ( &lt;strong&gt;НЕ&lt;/strong&gt; копии) на область действия в точке объявления функции ... плюс ссылку на все области действия, вложенные вне этой области.</target>
        </trans-unit>
        <trans-unit id="9374176e6956e9c55a03f208ff3b626b273cf5dc" translate="yes" xml:space="preserve">
          <source>A closure is a function that has access to another function's scope (its variables and functions). The easiest way to create a closure is with a function within a function; the reason being that in JavaScript a function always has access to its containing function&amp;rsquo;s scope.</source>
          <target state="translated">Закрытие - это функция, которая имеет доступ к области действия другой функции (ее переменным и функциям). Самый простой способ создать замыкание - использовать функцию внутри функции; причина в том, что в JavaScript функция всегда имеет доступ к области действия своей содержащей функции.</target>
        </trans-unit>
        <trans-unit id="fd2d062c668410ccdcd9af34cc85522e6c1afaa2" translate="yes" xml:space="preserve">
          <source>A closure is a link between a function and its outer lexical (ie. as-written) environment, such that the identifiers (variables, parameters, function declarations etc) defined within that environment are visible from within the function, regardless of when or from where the function is invoked.</source>
          <target state="translated">Закрытие-это связь между функцией и ее внешним лексическим (т.е.написанным)окружением,такая,что идентификаторы (переменные,параметры,объявления функций и т.д.),определенные внутри этого окружения,видны изнутри функции,независимо от того,когда и откуда вызывается функция.</target>
        </trans-unit>
        <trans-unit id="cec926b0cb259356a86639e657b14e8e1b4d0b58" translate="yes" xml:space="preserve">
          <source>A closure is created when a function is declared; this closure is used to configure the execution context when the function is invoked.</source>
          <target state="translated">Закрытие создается при объявлении функции;это закрытие используется для настройки контекста выполнения при вызове функции.</target>
        </trans-unit>
        <trans-unit id="88f672a9df48ba5975f39c3937c757038142dc61" translate="yes" xml:space="preserve">
          <source>A closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be used immediately. Therefore, the closure of the enclosing function probably already exists at the time that enclosing function was called since any inner function has access to it as soon as it is called.</source>
          <target state="translated">Закрытие создается не только при возвращении внутренней функции.На самом деле,функция закрытия вовсе не обязана возвращаться.Вместо этого можно присвоить внутреннюю функцию переменной во внешней области видимости или передать ее в качестве аргумента другой функции,где она может быть немедленно использована.Следовательно,закрытие ограждающей функции,вероятно,уже существует во время вызова ограждающей функции,поскольку любая внутренняя функция имеет доступ к ней,как только она вызывается.</target>
        </trans-unit>
        <trans-unit id="cfc70bbb817358717b49d080b1eca649757aa359" translate="yes" xml:space="preserve">
          <source>A closure is one way of supporting &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;first-class functions&lt;/a&gt;; it is an expression that can reference variables within its scope (when it was first declared), be assigned to a variable, be passed as an argument to a function, or be returned as a function result.</source>
          <target state="translated">Закрытие является одним из способов поддержки &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;первоклассных функций&lt;/a&gt; ; это выражение, которое может ссылаться на переменные в своей области (когда оно было впервые объявлено), быть назначенным переменной, передаваться в качестве аргумента функции или возвращаться как результат функции.</target>
        </trans-unit>
        <trans-unit id="0ef763764e04164186e2a1ceb3806cf6d8f2b116" translate="yes" xml:space="preserve">
          <source>A closure is where an inner function has access to variables in its outer function. That's probably the simplest one-line explanation you can get for closures.</source>
          <target state="translated">Закрытие-это когда внутренняя функция имеет доступ к переменным во внешней функции.Это,вероятно,самое простое однострочное объяснение,которое можно получить для замыкания.</target>
        </trans-unit>
        <trans-unit id="3259e0c90916fb0e4045b771243c259d5847d8f6" translate="yes" xml:space="preserve">
          <source>A function doesn't have to &lt;em&gt;return&lt;/em&gt; in order to create a closure. Simply by virtue of its declaration, every function closes over its enclosing lexical environment, forming a closure.</source>
          <target state="translated">Функция не должна &lt;em&gt;возвращаться&lt;/em&gt; , чтобы создать замыкание. Просто в силу своего объявления каждая функция закрывается в окружающей лексической среде, образуя замыкание.</target>
        </trans-unit>
        <trans-unit id="026c5616609e62af2f61992526a7c3f75658b65c" translate="yes" xml:space="preserve">
          <source>A function in JavaScript is not just a reference to a set of instructions (as in C language), but it also includes a hidden data structure which is composed of references to all nonlocal variables it uses (captured variables). Such two-piece functions are called closures. Every function in JavaScript can be considered a closure.</source>
          <target state="translated">Функция в JavaScript-это не только ссылка на набор инструкций (как в языке C),но и скрытая структура данных,которая состоит из ссылок на все нелокальные переменные,которые она использует (захваченные переменные).Такие двухкомпонентные функции называются замкнутыми.Каждая функция в JavaScript может считаться закрытием.</target>
        </trans-unit>
        <trans-unit id="5ae534cf02a5858b2d840f1a7673a1afe06d7bfc" translate="yes" xml:space="preserve">
          <source>A function normally has a name, parentheses and braces. Like this:</source>
          <target state="translated">Функция обычно имеет имя,круглые скобки и фигурные скобки.Вот так:</target>
        </trans-unit>
        <trans-unit id="99a4243b87430cefe6f1afae7fcb4af6221200d0" translate="yes" xml:space="preserve">
          <source>A great explanation of how closures can &lt;a href=&quot;https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited&quot;&gt;cause memory leaks in IE&lt;/a&gt; if you are not careful.</source>
          <target state="translated">Отличное объяснение того, как замыкания могут &lt;a href=&quot;https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited&quot;&gt;вызвать утечки памяти в IE,&lt;/a&gt; если вы не будете осторожны.</target>
        </trans-unit>
        <trans-unit id="c46e219fc09ff6a6e30c8ecd75a04e05369c3ec3" translate="yes" xml:space="preserve">
          <source>A nested function may continue to live after the outer function has finished:</source>
          <target state="translated">Вложенная функция может продолжать работать после завершения внешней функции:</target>
        </trans-unit>
        <trans-unit id="4ab1874227fa89cd67efbb317da32d2f6c6a64fd" translate="yes" xml:space="preserve">
          <source>A new set of local variables is kept every time a function is called (given that the function contains a function declaration inside it, and a reference to that inside function is either returned or an external reference is kept for it in some way).</source>
          <target state="translated">Новый набор локальных переменных сохраняется каждый раз при вызове функции (при условии,что внутри функции содержится объявление функции,а ссылка на нее внутри функции либо возвращается,либо для нее каким-либо образом сохраняется внешняя ссылка).</target>
        </trans-unit>
        <trans-unit id="5efdcbea95121298d3ad2d07cbbe7dcf0db4867d" translate="yes" xml:space="preserve">
          <source>ALERT: gorilla</source>
          <target state="translated">горилла</target>
        </trans-unit>
        <trans-unit id="2d25aee06019d734098a42118e386bcd1cb56358" translate="yes" xml:space="preserve">
          <source>ALERT: monkey</source>
          <target state="translated">обезьяна</target>
        </trans-unit>
        <trans-unit id="cd6c81ca63b69c9246d861c2e95db5f815d2ca1c" translate="yes" xml:space="preserve">
          <source>ALERT: monkey
ALERT: monkey</source>
          <target state="translated">АЛЕРТ:обезьяна АЛЕРТ:обезьяна</target>
        </trans-unit>
        <trans-unit id="37b0eb534510d977f89353bc69e9f62a4b8877f3" translate="yes" xml:space="preserve">
          <source>After the closures come the lines</source>
          <target state="translated">После закрытия приходят линии</target>
        </trans-unit>
        <trans-unit id="473797be1179e97465610490a5af19283b615cbe" translate="yes" xml:space="preserve">
          <source>After the loop finished and &lt;code&gt;index&lt;/code&gt; was done being modified the end value was 10, therefore every function added to the array returns the value of the single &lt;code&gt;index&lt;/code&gt; variable which is now set to 10.</source>
          <target state="translated">После того, как цикл завершился и &lt;code&gt;index&lt;/code&gt; был изменен, конечное значение было равно 10, поэтому каждая функция, добавленная в массив, возвращает значение единственной переменной &lt;code&gt;index&lt;/code&gt; которая теперь установлена ​​в 10.</target>
        </trans-unit>
        <trans-unit id="0c5c53c9b406b802e8050cdcb2d55f485bc7eae0" translate="yes" xml:space="preserve">
          <source>After this we have the line</source>
          <target state="translated">После этого у нас есть очередь</target>
        </trans-unit>
        <trans-unit id="b1283dc7aa9afa2d62e552768aa61cc0797578c6" translate="yes" xml:space="preserve">
          <source>All four of these functions are closures as they all access their environment.</source>
          <target state="translated">Все четыре эти функции закрываются,так как все они получают доступ к своей среде.</target>
        </trans-unit>
        <trans-unit id="e97e0f50a5e629695aedee5a89cca10ea6b0cb28" translate="yes" xml:space="preserve">
          <source>All of the functions added to the array return the SAME &lt;code&gt;index&lt;/code&gt; variable from the parent scope where it was defined instead of 10 different ones from 10 different scopes like the first example. The end result is that all 10 functions return the same variable from the same scope.</source>
          <target state="translated">Все функции, добавленные в массив, возвращают ту же самую &lt;code&gt;index&lt;/code&gt; переменную из родительской области, где она была определена, вместо 10 разных из 10 разных областей, как в первом примере. Конечным результатом является то, что все 10 функций возвращают одну и ту же переменную из одной и той же области видимости.</target>
        </trans-unit>
        <trans-unit id="e254452976bf3a1139922787e1c255443f069708" translate="yes" xml:space="preserve">
          <source>All this data stuff sounds a bit boring, but it is really very cool; we might have a function that tells a robot what to make for dinner. Let's say I invite you and your friend to my house. You like chicken legs best, I like sausages, your friend always wants what you want and my friend does not eat meat.</source>
          <target state="translated">Все эти данные звучат немного скучно,но на самом деле это очень круто;у нас может быть функция,которая говорит роботу,что приготовить на ужин.Скажем,я приглашаю тебя и твоего друга ко мне домой.Тебе больше нравятся куриные ножки,мне нравятся сосиски,твой друг всегда хочет то,что ты хочешь,а мой друг не ест мясо.</target>
        </trans-unit>
        <trans-unit id="86693ebc04e6080838a0974d1c5fdd94dcf0851e" translate="yes" xml:space="preserve">
          <source>All three global functions have a common reference to the &lt;em&gt;same&lt;/em&gt; closure because they are all declared within a single call to &lt;code&gt;setupSomeGlobals()&lt;/code&gt;.</source>
          <target state="translated">Все три глобальные функции имеют общую ссылку на &lt;em&gt;одно и&lt;/em&gt; то &lt;em&gt;же&lt;/em&gt; замыкание, поскольку все они объявлены в одном вызове &lt;code&gt;setupSomeGlobals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="010ea26c09769d3f5e5a4fa466cb6c5456b66f63" translate="yes" xml:space="preserve">
          <source>All variables outside the returned function are available to the returned function, but they are not directly available to the returned function object...</source>
          <target state="translated">Все переменные вне функции возврата доступны для возвращаемой функции,однако они не доступны непосредственно объекту возвращаемой функции....</target>
        </trans-unit>
        <trans-unit id="c4594b92814cb252202666c4d92f85aa73ea246b" translate="yes" xml:space="preserve">
          <source>Also, it must be understood that local variables in JavaScript are created not on the stack frame, but on the heap and destroyed only when no one is referencing them. When a function returns, references to its local variables are decremented, but they can still be non-null if during the current execution they became part of a closure and are still referenced by its lexically nested functions (which can happen only if the references to these nested functions were returned or otherwise transferred to some external code).</source>
          <target state="translated">Также следует понимать,что локальные переменные в JavaScript создаются не на фрейме стека,а на куче и уничтожаются только тогда,когда на них никто не ссылается.Когда функция возвращается,ссылки на ее локальные переменные декрементируются,но они все равно могут быть ненулевыми,если во время текущего исполнения они стали частью закрытия и на них по-прежнему ссылаются ее лексически вложенные функции (что может произойти только в том случае,если ссылки на эти вложенные функции были возвращены или иным образом переданы какому-либо внешнему коду).</target>
        </trans-unit>
        <trans-unit id="3bce66ad1af625b4de8c481a747409bc48008eb0" translate="yes" xml:space="preserve">
          <source>Also, this private variable state is &lt;strong&gt;fully&lt;/strong&gt; accessible, for both readings and assigning to its private scoped variables.</source>
          <target state="translated">Кроме того, это состояние закрытой переменной &lt;strong&gt;полностью&lt;/strong&gt; доступно как для чтения, так и для присваивания его закрытым переменным.</target>
        </trans-unit>
        <trans-unit id="4f230a19f88726fa9de2c57f5cbfa8e8e4472abd" translate="yes" xml:space="preserve">
          <source>An answer for a six-year-old (assuming he knows what a function is and what a variable is, and what data is):</source>
          <target state="translated">Ответ для шестилетнего подростка (предполагая,что он знает,что такое функция и что такое переменная,и что такое данные):</target>
        </trans-unit>
        <trans-unit id="d7b09515b9865b30af6b3fa920a76512708611e1" translate="yes" xml:space="preserve">
          <source>An example of a closure</source>
          <target state="translated">Пример закрытия</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">Пример:</target>
        </trans-unit>
        <trans-unit id="819beada86acdf2bbd115d5e1db66e6b0bee2da8" translate="yes" xml:space="preserve">
          <source>And even though the grown-ups knew of real princesses, they would never believe in the unicorns or dragons because they could never see them. The grown-ups said that they only existed inside the little girl's imagination.</source>
          <target state="translated">И хотя взрослые знали о настоящих принцессах,они никогда бы не поверили в единорогов или драконов,потому что никогда бы их не увидели.Взрослые говорили,что они существуют только в воображении маленькой девочки.</target>
        </trans-unit>
        <trans-unit id="57dfb708e06183c8ecb1f0c30e96af35afaf50ba" translate="yes" xml:space="preserve">
          <source>And here is where things get really interesting. If we were to get rid of outerFunction, say set it to null, you might think that referenceToInnerFunction would loose its access to the value of outerVar. But this is not the case.</source>
          <target state="translated">И вот где все становится действительно интересно.Если бы мы избавились от outerFunction,скажем,поставили бы ее в ноль,вы могли бы подумать,что referenceToInnerFunction потеряла бы доступ к значению outerVar.Но это не так.</target>
        </trans-unit>
        <trans-unit id="435fb8d87e8d248469850188da7e2ad10deaaf3b" translate="yes" xml:space="preserve">
          <source>And if you remember, when &lt;code&gt;this.say&lt;/code&gt; is created, it (as every function) gets an internal reference &lt;code&gt;this.say.[[Scope]]&lt;/code&gt; to the current LexicalEnvironment. So, the LexicalEnvironment of the current User execution stays in memory. All variables of User also are its properties, so they are also carefully kept, not junked as usually.</source>
          <target state="translated">И если вы помните, когда &lt;code&gt;this.say&lt;/code&gt; создается, он (как и каждая функция) получает внутреннюю ссылку &lt;code&gt;this.say.[[Scope]]&lt;/code&gt; на текущую LexicalEnvironment. Таким образом, LexicalEnvironment текущего выполнения пользователя остается в памяти. Все переменные User также являются его свойствами, поэтому они также тщательно сохраняются, а не отбрасываются, как обычно.</target>
        </trans-unit>
        <trans-unit id="625ff0ae825173e464152e82b8c8264f2701a52a" translate="yes" xml:space="preserve">
          <source>And now, even though Mary is &quot;no longer running&quot;, the memory of her is not lost and her child will always remember her name and other secrets they shared during their time together.</source>
          <target state="translated">И теперь,несмотря на то,что Мария &quot;больше не бежит&quot;,память о ней не теряется,и ее ребенок всегда будет помнить ее имя и другие секреты,которыми они делились во время совместной жизни.</target>
        </trans-unit>
        <trans-unit id="dd1dc01a62936ce68f2808899afc6036354d1594" translate="yes" xml:space="preserve">
          <source>And she would often tell them of her latest amazing adventure as a princess.</source>
          <target state="translated">И она часто рассказывала им о своих последних удивительных приключениях в качестве принцессы.</target>
        </trans-unit>
        <trans-unit id="b4380f96cc0e7a3c2e34bc8ce6205c32c2126439" translate="yes" xml:space="preserve">
          <source>And yes, I'd even recommend it to a 6-year old -- if the 6-year old is learning about closures, then it's logical they're ready to comprehend the &lt;em&gt;concise and simple explanation&lt;/em&gt; provided in the article.</source>
          <target state="translated">И да, я бы даже порекомендовал это 6-летнему ребенку - если 6-летний учится о замыканиях, то логично, что они готовы понять &lt;em&gt;краткое и простое объяснение, приведенное&lt;/em&gt; в статье.</target>
        </trans-unit>
        <trans-unit id="174ee1c1a9c452a97f5a4e71705d3ba0633128b2" translate="yes" xml:space="preserve">
          <source>Another really simple way to explain it is in terms of scope:</source>
          <target state="translated">Другой действительно простой способ объяснить это-с точки зрения сферы применения:</target>
        </trans-unit>
        <trans-unit id="efcadf61fe3fe42ed34cfdd66b0ecbf1ed3408ef" translate="yes" xml:space="preserve">
          <source>Any time you create a smaller scope inside of a larger scope, the smaller scope will always be able to see what is in the larger scope.</source>
          <target state="translated">Всякий раз,когда вы создаете меньший по размеру диапазон внутри большого,меньший по размеру всегда сможет увидеть,что находится в большом диапазоне.</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="d5593bba6625e12152d79d70e57424cdd0e4f606" translate="yes" xml:space="preserve">
          <source>As a father of a 6-year-old, currently teaching young children (and a relative novice to coding with no formal education so corrections will be required), I think the lesson would stick best through hands-on play. If the 6-year-old is ready to understand what a closure is, then they are old enough to have a go themselves. I'd suggest pasting the code into jsfiddle.net, explaining a bit, and leaving them alone to concoct a unique song. The explanatory text below is probably more appropriate for a 10 year old.</source>
          <target state="translated">Как отец 6-летнего ребенка,который в настоящее время обучает маленьких детей (и относительного новичка кодированию без формального образования,так что исправления будут необходимы),я думаю,что урок будет лучше всего держаться в ручной игре.Если 6-летний готов понять,что такое замыкание,то они достаточно взрослые,чтобы самим заниматься.Я бы предложил вставить код в jsfiddle.net,немного объяснив,и оставить их в покое,чтобы сочинить уникальную песню.Пояснительный текст ниже,вероятно,более подходит для 10-летнего.</target>
        </trans-unit>
        <trans-unit id="6568100bffff0b20e0c37f88a640e7173cdcd704" translate="yes" xml:space="preserve">
          <source>As we see, &lt;code&gt;this.say&lt;/code&gt; is a property in the user object, so it continues to live after User completed.</source>
          <target state="translated">Как мы видим, &lt;code&gt;this.say&lt;/code&gt; является свойством объекта user, поэтому он продолжает жить после завершения User.</target>
        </trans-unit>
        <trans-unit id="e1626c59ebd74e38dd52b09e3c12153695d67816" translate="yes" xml:space="preserve">
          <source>As you can see, the toys left in the room are still accessible via the brother and no matter if the room is locked. Here is &lt;a href=&quot;http://jsbin.com/ubakor/9/edit&quot;&gt;a jsbin&lt;/a&gt; to play around with it.</source>
          <target state="translated">Как видите, игрушки, оставленные в комнате, по-прежнему доступны через брата, и не важно, заперта ли комната. Вот &lt;a href=&quot;http://jsbin.com/ubakor/9/edit&quot;&gt;jsbin,&lt;/a&gt; чтобы поиграть с ним.</target>
        </trans-unit>
        <trans-unit id="890df09169ac0377be2b819d1f924abc0cd10e89" translate="yes" xml:space="preserve">
          <source>As you may guess, because the variables are re-created every time the function is called, and nobody else will know them, there must be a secret place where they are stored. It could be called &lt;strong&gt;Chamber of Secrets&lt;/strong&gt; or &lt;strong&gt;stack&lt;/strong&gt; or &lt;strong&gt;local scope&lt;/strong&gt; but it doesn't really matter. We know they are there, somewhere, hidden in the memory.</source>
          <target state="translated">Как вы можете догадаться, поскольку переменные создаются заново каждый раз, когда вызывается функция, и никто больше не узнает их, должно быть секретное место, где они хранятся. Это можно назвать &amp;laquo; &lt;strong&gt;Тайной комнатой&amp;raquo;,&lt;/strong&gt; &lt;strong&gt;стековой&lt;/strong&gt; или &lt;strong&gt;локальной областью,&lt;/strong&gt; но это не имеет значения. Мы знаем, что они где-то спрятаны в памяти.</target>
        </trans-unit>
        <trans-unit id="986da2f4d4b325d9fb2c07a7e2b3897081cd863a" translate="yes" xml:space="preserve">
          <source>BRACES: &quot;Braces&quot; which look like this &lt;code&gt;{}&lt;/code&gt; are the tinted windows of our factory. From inside the factory you can see out, but from the outside you can't see in.</source>
          <target state="translated">BRACES: &amp;laquo;Подтяжки&amp;raquo;, которые выглядят так &lt;code&gt;{}&lt;/code&gt; , являются тонированными окнами нашего завода. Внутри фабрики вы можете видеть снаружи, но снаружи вы не можете видеть внутри.</target>
        </trans-unit>
        <trans-unit id="3575d07a466999847f383f17914159e3dbdd22b0" translate="yes" xml:space="preserve">
          <source>BROWSER: When you connect to the Internet on a computer, tablet or phone to visit a website, you use a browser. Examples you may know are Internet Explorer, Chrome, Firefox and Safari. The browser can understand JavaScript and tell the computer what it needs to do. The JavaScript instructions are called functions.</source>
          <target state="translated">BROWSER:Когда вы подключаетесь к Интернету на компьютере,планшете или телефоне для посещения веб-сайта,вы используете браузер.Примерами,которые вам могут быть знакомы,являются Internet Explorer,Chrome,Firefox и Safari.Браузер может понимать JavaScript и говорить компьютеру,что ему нужно делать.Инструкции JavaScript называются функциями.</target>
        </trans-unit>
        <trans-unit id="0419e91da10b803e76b92f8dffe5555643e1dd03" translate="yes" xml:space="preserve">
          <source>Because all these external variables referenced by a lexically nested function are actually local variables in the chain of its lexically enclosing functions (global variables can be assumed to be local variables of some root function), and every single execution of a function creates new instances of its local variables, it follows that every execution of a function returning (or otherwise transferring it out, such as registering it as a callback) a nested function creates a new closure (with its own potentially unique set of referenced nonlocal variables which represent its execution context).</source>
          <target state="translated">Поскольку все эти внешние переменные,на которые ссылается лексически вложенная функция,на самом деле являются локальными переменными в цепочке ее лексически вмещающих функций (глобальными переменными можно считать локальные переменные некоторой корневой функции),и каждое отдельное выполнение функции создает новые экземпляры ее локальных переменных,то из этого следует,что каждое выполнение функции,возвращающей (или иным образом передающей ее,например,регистрирующей ее как обратный вызов)во вложенной функции,создает новое закрытие (со своим потенциально уникальным набором нелокальных переменных,на которые ссылается функция и которые представляют контекст ее выполнения).</target>
        </trans-unit>
        <trans-unit id="42668682fc7dcf2769407c41fc937cdbf7dd8025" translate="yes" xml:space="preserve">
          <source>Because there was only one scope within the &lt;code&gt;createClosureArray()&lt;/code&gt; function, &lt;code&gt;index&lt;/code&gt; is only bound to a value within that scope. In other words, each time the loop changes the value of &lt;code&gt;index&lt;/code&gt;, it changes it for everything that references it within that scope.</source>
          <target state="translated">Поскольку в функции &lt;code&gt;createClosureArray()&lt;/code&gt; была только одна область действия, &lt;code&gt;index&lt;/code&gt; привязан только к значению в этой области. Другими словами, каждый раз, когда цикл изменяет значение &lt;code&gt;index&lt;/code&gt; , он меняет его для всего, что ссылается на него в этой области.</target>
        </trans-unit>
        <trans-unit id="14c3a147917bc6f80510553c690b0ab8c8718635" translate="yes" xml:space="preserve">
          <source>But all they would see is a little girl...</source>
          <target state="translated">Но все,что они увидят,это маленькую девочку...</target>
        </trans-unit>
        <trans-unit id="bb8c57c634a563056b164f5aeb01e4ac8232dc6d" translate="yes" xml:space="preserve">
          <source>But how is this so? How can referenceToInnerFunction still know the value of outerVar now that outerFunction has been set to null?</source>
          <target state="translated">Но как это так? Как функция referenceToInnerFunction может все еще знать значение outerVar теперь,когда outerFunction была установлена на ноль?</target>
        </trans-unit>
        <trans-unit id="146180db52e416274e24ed731f90ff6fc5ad3201" translate="yes" xml:space="preserve">
          <source>But she would always have to return back to her dull world of chores and grown-ups.</source>
          <target state="translated">Но ей всегда придется возвращаться в свой скучный мир рутинной работы и взрослых.</target>
        </trans-unit>
        <trans-unit id="866ff54f49d509edc499efd08ef16cd5aed44ee7" translate="yes" xml:space="preserve">
          <source>But the sad thing is, if the child is also a private variable of its parent function, it would also die when the parent ends, and the secrets would die with them.</source>
          <target state="translated">Но печально то,что если ребенок также является частной переменной своей родительской функции,то он тоже умрет,когда закончится родительская,а секреты умрут вместе с ними.</target>
        </trans-unit>
        <trans-unit id="dbf03411a9d8f9c4e1de5345b3a10c168dfc2df8" translate="yes" xml:space="preserve">
          <source>But we know the real truth; that the little girl with the princess inside...</source>
          <target state="translated">Но мы знаем настоящую правду,что маленькая девочка с принцессой внутри...</target>
        </trans-unit>
        <trans-unit id="a343ea5602007ce993e1966d841864424094a57f" translate="yes" xml:space="preserve">
          <source>But, in JavaScript there is this very special thing that functions which are created inside other functions, can also know the local variables of their parents and keep them as long as they live.</source>
          <target state="translated">Но в JavaScript есть особенность,что функции,которые создаются внутри других функций,также могут знать локальные переменные своих родителей и хранить их до конца жизни.</target>
        </trans-unit>
        <trans-unit id="5d22ad9eb11c8d7544b41c9fd9c72490630172cd" translate="yes" xml:space="preserve">
          <source>CLOSURES DONE RIGHT</source>
          <target state="translated">ПРАВИЛЬНО ЗАКРЫТЫЕ ДВЕРИ</target>
        </trans-unit>
        <trans-unit id="b8c469b8120b44b5dd72fc632091339193c9122a" translate="yes" xml:space="preserve">
          <source>CLOSURES DONE WRONG</source>
          <target state="translated">НЕПРАВИЛЬНО ЗАКРЫТЫЕ ДВЕРИ</target>
        </trans-unit>
        <trans-unit id="3344264f6f33fcb6fbcf186f0b6ad57482d348ae" translate="yes" xml:space="preserve">
          <source>CLOSURES: The closures are the smaller functions that are inside the big &lt;em&gt;sing()&lt;/em&gt; function. The little factories inside the big factory. They each have their own braces which mean that the variables inside them can't be seen from the outside. That's why the names of the variables (&lt;em&gt;creature&lt;/em&gt; and &lt;em&gt;result&lt;/em&gt;) can be repeated in the closures but with different values. If you type these variable names in the console window, you won't get its value because it's hidden by two layers of tinted windows.</source>
          <target state="translated">ЗАКРЫТИЯ: замыкания - это меньшие функции, которые находятся внутри большой функции &lt;em&gt;sing ()&lt;/em&gt; . Маленькие фабрики внутри большой фабрики. Каждый из них имеет свои собственные скобки, которые означают, что переменные внутри них не видны снаружи. Вот почему имена переменных ( &lt;em&gt;существо&lt;/em&gt; и &lt;em&gt;результат&lt;/em&gt; ) могут повторяться в замыканиях, но с разными значениями. Если вы введете эти имена переменных в окне консоли, вы не получите их значение, потому что оно скрыто двумя слоями затемненных окон.</target>
        </trans-unit>
        <trans-unit id="76ad173357129e5535c24cd674bddfaff61e8338" translate="yes" xml:space="preserve">
          <source>CODE: All the writing above is called &lt;em&gt;code&lt;/em&gt;. It is written in JavaScript.</source>
          <target state="translated">КОД: Все написанное выше называется &lt;em&gt;кодом&lt;/em&gt; . Это написано в JavaScript.</target>
        </trans-unit>
        <trans-unit id="a0c7bc52b3fa8bb1b47ad931aa67baef1da44403" translate="yes" xml:space="preserve">
          <source>Can anybody consider that I am 6 and strangely interested in that subject ?</source>
          <target state="translated">Кто-нибудь может считать,что мне 6 и я странно интересуюсь этой темой?</target>
        </trans-unit>
        <trans-unit id="0754a0ac49d4de7ab61d6c51b9280396aeeb0c9d" translate="yes" xml:space="preserve">
          <source>Can you explain closures to a 5-year-old?*</source>
          <target state="translated">Ты можешь объяснить закрытие для 5-летнего ребенка?</target>
        </trans-unit>
        <trans-unit id="c6abb0edfb41f4eed3192a92b93e8777584cfbc6" translate="yes" xml:space="preserve">
          <source>Closures are &lt;em&gt;not hard&lt;/em&gt; to understand once the core concept is grokked. However, they are impossible to understand by reading any theoretical or academically oriented explanations!</source>
          <target state="translated">Замыкания &lt;em&gt;нетрудно&lt;/em&gt; понять, как только основная идея получится. Однако их невозможно понять, читая какие-либо теоретические или академически ориентированные объяснения!</target>
        </trans-unit>
        <trans-unit id="473e3864991bcdfffaa54377115d58425884b1de" translate="yes" xml:space="preserve">
          <source>Closures are a way to let a function
  have &lt;strong&gt;persistent, private variables&lt;/strong&gt; -
  that is, variables that only one
  function knows about, where it can
  keep track of info from previous times
  that it was run.</source>
          <target state="translated">Замыкания - это способ дать функции иметь &lt;strong&gt;постоянные закрытые переменные,&lt;/strong&gt; то есть переменные, о которых знает только одна функция, где она может отслеживать информацию за предыдущие периоды, когда она выполнялась.</target>
        </trans-unit>
        <trans-unit id="2dab57988b39942ebe3792aab7459b19fb524730" translate="yes" xml:space="preserve">
          <source>Closures are functions with a state. It is somewhat similar to &quot;this&quot; in the sense that &quot;this&quot; also provides state for a function but function and &quot;this&quot; are separate objects (&quot;this&quot; is just a fancy parameter, and the only way to bind it permanently to a function is to create a closure). While &quot;this&quot; and function always live separately, a function cannot be separated from its closure and the language provides no means to access captured variables.</source>
          <target state="translated">Закрытие-это функции с состоянием.Это несколько похоже на &quot;this&quot; в том смысле,что &quot;this&quot; также обеспечивает состояние для функции,но функция,а &quot;this&quot;-это отдельные объекты (&quot;this&quot;-это всего лишь причудливый параметр,и единственный способ привязать его постоянно к функции-это создать замыкание).В то время как &quot;this&quot; и функция всегда живут отдельно,функция не может быть отделена от своего закрытия,и язык не предоставляет никаких средств доступа к захваченным переменным.</target>
        </trans-unit>
        <trans-unit id="9a8fe763a050a9c6f2b9d029f15de875acec4c6c" translate="yes" xml:space="preserve">
          <source>Closures are hard to explain because they are used to make some behaviour work that everybody intuitively expects to work anyway. I find the best way to explain them (and the way that &lt;em&gt;I&lt;/em&gt; learned what they do) is to imagine the situation without them:</source>
          <target state="translated">Замыкания трудно объяснить, потому что они используются для того, чтобы заставить поведение работать так, как все интуитивно ожидают, что оно все равно будет работать. Я считаю, что лучший способ объяснить их (и способ, которым &lt;em&gt;я&lt;/em&gt; узнал, что они делают), это представить ситуацию без них:</target>
        </trans-unit>
        <trans-unit id="13cd6611b47d0c0e96535f2857655ffbc4aec970" translate="yes" xml:space="preserve">
          <source>Closures are not magic</source>
          <target state="translated">Закрытия не являются волшебством</target>
        </trans-unit>
        <trans-unit id="81857059bb8f6b3c5d16c47af8818ad9c8d4ef06" translate="yes" xml:space="preserve">
          <source>Closures are often used for creating functions with some hidden private data (but it's not always the case).</source>
          <target state="translated">Закрытия часто используются для создания функций со скрытыми приватными данными (но это не всегда так).</target>
        </trans-unit>
        <trans-unit id="f1f2dd80b45193a64a6fed6f703fea1610ee7907" translate="yes" xml:space="preserve">
          <source>Closures done right:</source>
          <target state="translated">Закрытие сделано правильно:</target>
        </trans-unit>
        <trans-unit id="2b5870c633c063933016ddcafff1a5b85221b713" translate="yes" xml:space="preserve">
          <source>Closures done wrong:</source>
          <target state="translated">Закрытие сделано неправильно:</target>
        </trans-unit>
        <trans-unit id="65f3c9fe79ec9c90973a968f76051ad6208d1eff" translate="yes" xml:space="preserve">
          <source>Compare with a situation when a door was locked by draft and nobody inside (general function execution), and then some local fire occur and burn down the room (garbage collector:D), and then a new room was build and now you may leave another toys there (new function instance), but never get the same toys which were left in the first room instance.</source>
          <target state="translated">Сравните с ситуацией,когда дверь была заперта черновиком и никого не было внутри (выполнение общей функции),а затем происходит какой-то локальный пожар и сжигание комнаты (сборщик мусора:D),а затем была построена новая комната и теперь вы можете оставить там еще одну игрушку (новый экземпляр функции),но никогда не получите те же самые игрушки,которые были оставлены в первом экземпляре комнаты.</target>
        </trans-unit>
        <trans-unit id="895fc54743a0a38a6edff320b747a9f3e67aa96b" translate="yes" xml:space="preserve">
          <source>Consider this option</source>
          <target state="translated">Рассмотрим этот вариант</target>
        </trans-unit>
        <trans-unit id="d29543a41f8e03fb1f0ca60d30879d8d14612042" translate="yes" xml:space="preserve">
          <source>DATA: Data is a collection of facts. It can be numbers, words, measurements, observations or even just descriptions of things. You can't touch it, smell it or taste it. You can write it down, speak it and hear it. You could use it to &lt;em&gt;create&lt;/em&gt; touch smell and taste using a computer. It can be made useful by a computer using code.</source>
          <target state="translated">ДАННЫЕ: Данные представляют собой набор фактов. Это могут быть цифры, слова, измерения, наблюдения или даже просто описания вещей. Вы не можете прикоснуться к нему, почувствовать запах или попробовать его. Вы можете записать это, сказать это и услышать это. Вы можете использовать это, чтобы &lt;em&gt;создать&lt;/em&gt; сенсорный запах и вкус, используя компьютер. Это может быть полезно на компьютере с помощью кода.</target>
        </trans-unit>
        <trans-unit id="1386ebeed6520345b3b7b8e117496e328fb4ca5d" translate="yes" xml:space="preserve">
          <source>Dan invites Paul.
Dan asks Paul to bring one controller. How many controllers were brought to the party?</source>
          <target state="translated">Дэн приглашает Пола.Дэн просит Пола принести один контроллер.Сколько контроллеров привезли на вечеринку?</target>
        </trans-unit>
        <trans-unit id="ec2a42fc389ecb1dc4b9d0c461e02170df77d766" translate="yes" xml:space="preserve">
          <source>Douglas Crockford's simulated &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;private attributes and private methods&lt;/a&gt; for an object, using closures.</source>
          <target state="translated">Дуглас Крокфорд смоделировал &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;частные атрибуты и частные методы&lt;/a&gt; для объекта, используя замыкания.</target>
        </trans-unit>
        <trans-unit id="1f5d96dd43fe4410f4d7bee1eb9596663a115a2d" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;makeKitchen()&lt;/code&gt; is called, a new closure is created with its own separate &lt;code&gt;trashBags&lt;/code&gt;.</source>
          <target state="translated">Каждый раз, когда &lt;code&gt;makeKitchen()&lt;/code&gt; , создается новое замыкание с отдельными &lt;code&gt;trashBags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be4a4610d526a11fb6ad4a43add51b702b4757b8" translate="yes" xml:space="preserve">
          <source>Environment, which includes:</source>
          <target state="translated">Окружающая среда,которая включает в себя</target>
        </trans-unit>
        <trans-unit id="d753a72a73e7b9b72686150b4751eec2271aff2d" translate="yes" xml:space="preserve">
          <source>Every function call creates a closure, but there would be no need to keep the closure around unless an inner function, which has access to the inside of the closure, can be called from outside the closure.  Returning the object with the &lt;code&gt;getTrashBag&lt;/code&gt; function does that here.</source>
          <target state="translated">Каждый вызов функции создает замыкание, но не было бы необходимости хранить замыкание вокруг, если только внутренняя функция, имеющая доступ к внутренней части замыкания, не может быть вызвана извне замыкания. Возврат объекта с &lt;code&gt;getTrashBag&lt;/code&gt; функции getTrashBag делает это здесь.</target>
        </trans-unit>
        <trans-unit id="d1e850e44398a4bd60c4144c1c65f8512d37dff4" translate="yes" xml:space="preserve">
          <source>Every function creates a closure, because every function has a link to its outer lexical environment.</source>
          <target state="translated">Каждая функция создает закрытие,потому что каждая функция имеет связь с внешней лексической средой.</target>
        </trans-unit>
        <trans-unit id="adc27653e819f465f9e2820186db79ad5283608e" translate="yes" xml:space="preserve">
          <source>Every function in JavaScript maintains a link to its outer lexical environment. A lexical environment is a map of all the names (eg. variables, parameters) in a scope, with their values.</source>
          <target state="translated">Каждая функция в JavaScript поддерживает ссылку на внешнюю лексическую среду.Лексическое окружение-это карта всех имен (например,переменных,параметров)в области видимости,с их значениями.</target>
        </trans-unit>
        <trans-unit id="45ace4e4578d45cf9975840a42650a40883c1e4a" translate="yes" xml:space="preserve">
          <source>Every time you call it, local variable &quot;name&quot; is created and given name &quot;Mary&quot;. And every time the function exits the variable is lost and the name is forgotten.</source>
          <target state="translated">При каждом вызове создается локальная переменная &quot;имя&quot; и присваивается имя &quot;Мария&quot;.И каждый раз,когда функция выходит из переменной,она теряется,а имя забывается.</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="translated">Пример 3</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="translated">Пример 4</target>
        </trans-unit>
        <trans-unit id="dcb2a7f833e9a3ee29881cf3f00069ceeab20571" translate="yes" xml:space="preserve">
          <source>Example 5</source>
          <target state="translated">Пример 5</target>
        </trans-unit>
        <trans-unit id="69126e599801a8577cf34e537a3e5b119797d966" translate="yes" xml:space="preserve">
          <source>Example 6</source>
          <target state="translated">Пример 6</target>
        </trans-unit>
        <trans-unit id="5da743f6856f59f85c81f30e766731f5631a39c2" translate="yes" xml:space="preserve">
          <source>Example 7</source>
          <target state="translated">Пример 7</target>
        </trans-unit>
        <trans-unit id="6f1ddb45d4ea126c3c0d9697dd3671172ae3bca1" translate="yes" xml:space="preserve">
          <source>Example for the first point by dlaliberte:</source>
          <target state="translated">Пример для первого пункта на dlaliberte:</target>
        </trans-unit>
        <trans-unit id="9726b2f5643205ff1a7ab0c75e5e5eb34bbe5072" translate="yes" xml:space="preserve">
          <source>Example of a closure that uses the global environment:</source>
          <target state="translated">Пример закрытия,использующего глобальную среду:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="e262aa4c560f1ae35fd6e5cf5ac45462ea46ecc8" translate="yes" xml:space="preserve">
          <source>F12</source>
          <target state="translated">F12</target>
        </trans-unit>
        <trans-unit id="770cc5fbad4b752ed78f4565ed7a44533e740e5d" translate="yes" xml:space="preserve">
          <source>FOREWORD: this answer was written when the question was:</source>
          <target state="translated">ФОРЕВОРД:этот ответ был написан,когда был задан вопрос:</target>
        </trans-unit>
        <trans-unit id="23ddff2ba060d9ccf1c6bed76f90cfb75043258a" translate="yes" xml:space="preserve">
          <source>FUNCTION: A function in JavaScript is like a factory. It might be a little factory with only one machine inside. Or it might contain many other little factories, each with many machines doing different jobs. In a real life clothes factory you might have reams of cloth and bobbins of thread going in and T-shirts and jeans coming out. Our JavaScript factory only processes data, it can't sew, drill a hole or melt metal. In our JavaScript factory data goes in and data comes out.</source>
          <target state="translated">ФУНКЦИЯ:Функция в JavaScript похожа на заводскую.Это может быть маленькая фабрика с одной машиной внутри.Или она может содержать много других маленьких фабрик,каждая из которых имеет много машин,выполняющих разные задачи.На фабрике по производству одежды в реальной жизни могут появляться пачки тканей и катушки с нитями,а также футболки и джинсы.Наша фабрика JavaScript обрабатывает только данные,она не может шить,сверлить отверстие или плавить металл.В нашей фабрике JavaScript данные заходят и выходят.</target>
        </trans-unit>
        <trans-unit id="8084a292fef2035ee22a2314d1fd8d2ea5ef70cc" translate="yes" xml:space="preserve">
          <source>Fairly Obvious Solution</source>
          <target state="translated">Достаточно очевидное решение</target>
        </trans-unit>
        <trans-unit id="8d7ca8f60d208999584a7667dd568dbdc67e89aa" translate="yes" xml:space="preserve">
          <source>Final points:</source>
          <target state="translated">Окончательные очки:</target>
        </trans-unit>
        <trans-unit id="0db6ddf1596c4847d4487ff8d0eb1324a650d77c" translate="yes" xml:space="preserve">
          <source>First, when a function f is created, it is not created in an empty
space. There is a current LexicalEnvironment object. In the case
above, it&amp;rsquo;s window (a is undefined at the time of function
creation).</source>
          <target state="translated">Во-первых, когда функция f создается, она не создается в пустом пространстве. Существует текущий объект LexicalEnvironment. В приведенном выше случае это окно (a не определено во время создания функции).</target>
        </trans-unit>
        <trans-unit id="2a73ef77ff6936404496b87ca2548febfdec5ccf" translate="yes" xml:space="preserve">
          <source>For an advanced child I would put something like the following. It is not perfect, but it makes you feel about what it is:</source>
          <target state="translated">Для продвинутого ребенка я бы поставил что-то вроде следующего.Это не идеально,но это заставляет тебя чувствовать,что это такое:</target>
        </trans-unit>
        <trans-unit id="ea9adb725d4b9bd42aa2bf3daca3985abf217214" translate="yes" xml:space="preserve">
          <source>For some reason, closures seem really hard to understand when you read about them, but when you see some examples, it becomes clear how they work (it took me a while).
I recommend working through the examples carefully until you understand how they work. If you start using closures without fully understanding how they work, you would soon create some very weird bugs!</source>
          <target state="translated">По каким-то причинам,кажется,что замыкания действительно трудно понять,когда вы читаете о них,но когда вы видите некоторые примеры,становится понятно,как они работают (это заняло у меня некоторое время).Я рекомендую внимательно проработать примеры до тех пор,пока вы не поймете,как они работают.Если вы начнете использовать замыкания без полного понимания того,как они работают,вскоре вы создадите очень странные ошибки!</target>
        </trans-unit>
        <trans-unit id="a6457c5f7670ec3d5b6eba35695e935bfa1d35af" translate="yes" xml:space="preserve">
          <source>Full post:</source>
          <target state="translated">Полный пост:</target>
        </trans-unit>
        <trans-unit id="086a1f90a0a0f91e7d5f1400d0b9f2eaa0c70efd" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;bar&lt;/code&gt;, together with its link with the lexical environment of function &lt;code&gt;foo&lt;/code&gt; is a closure.</source>
          <target state="translated">Функциональная &lt;code&gt;bar&lt;/code&gt; вместе с ее связью с лексическим окружением функции &lt;code&gt;foo&lt;/code&gt; является замыканием.</target>
        </trans-unit>
        <trans-unit id="df465d5385e7a5492e6da9185d4edd6ca0741d1e" translate="yes" xml:space="preserve">
          <source>Functions can be nested one inside another, forming a chain of LexicalEnvironments which can also be called a scope chain.</source>
          <target state="translated">Функции могут быть вложены друг в друга,образуя цепочку LexicalEnvironments,которую также можно назвать цепочкой scope.</target>
        </trans-unit>
        <trans-unit id="735a10dcfecac98bd4863f42c020b050d39de8ff" translate="yes" xml:space="preserve">
          <source>Functions can return data. One kind of data you can return from a function is another function. When that new function gets returned, all the variables and arguments used in the function that created it don't go away. Instead, that parent function &quot;closes.&quot; In other words, nothing can look inside of it and see the variables it used except for the function it returned. That new function has a special ability to look back inside the function that created it and see the data inside of it.</source>
          <target state="translated">Функции могут возвращать данные.Один вид данных,которые вы можете вернуть из функции,является другой функцией.Когда возвращается новая функция,все переменные и аргументы,использованные в функции,которая ее создала,не исчезают.Вместо этого родительская функция &quot;закрывается&quot;.Другими словами,ничто не может заглянуть внутрь нее и увидеть переменные,которые она использовала,кроме функции,которую она вернула.У этой новой функции есть особая возможность заглянуть внутрь создавшей ее функции и увидеть данные внутри нее.</target>
        </trans-unit>
        <trans-unit id="d6e834997432ff006f3ca11dc3e560bb2b2db750" translate="yes" xml:space="preserve">
          <source>Functions define actions  - the main function is about singing. It contains a variable called &lt;em&gt;firstPart&lt;/em&gt; which applies to the singing about the person that applies to each of the verses of the song: &quot;There was &quot; + person + &quot; who swallowed&quot;. If you type &lt;em&gt;firstPart&lt;/em&gt; into the console, you won't get an answer because the variable is locked up in a function - the browser can't see inside the tinted windows of the braces.</source>
          <target state="translated">Функции определяют действия - основная функция - пение. Он содержит переменную под названием &lt;em&gt;firstPart,&lt;/em&gt; которая применяется к пению о человеке, которое относится к каждому из стихов песни: &amp;laquo;Был&amp;laquo; + человек + &amp;raquo;, который проглотил&amp;raquo;. Если вы &lt;em&gt;введете firstPart&lt;/em&gt; в консоли, вы не получите ответ, потому что переменная заблокирована в функции - браузер не может видеть внутри окрашенных окон фигурных скобок.</target>
        </trans-unit>
        <trans-unit id="3ddedd19f21650712b05b0d15a1aaf5ed1d17916" translate="yes" xml:space="preserve">
          <source>Further points that explain why closures are interesting:</source>
          <target state="translated">Дальнейшие пункты,объясняющие,почему закрытие интересно:</target>
        </trans-unit>
        <trans-unit id="09cf114b1e0fe4fe38544c7a0d90cf0e556abc15" translate="yes" xml:space="preserve">
          <source>GLOBAL VARIABLE: &lt;em&gt;person&lt;/em&gt; is a global variable, meaning that if you change its value from &quot;an old lady&quot; to &quot;a young man&quot;, the &lt;em&gt;person&lt;/em&gt; will keep being a young man until you decide to change it again and that any other function in the code can see that it's a young man. Press the</source>
          <target state="translated">ГЛОБАЛЬНАЯ ПЕРЕМЕННАЯ: &lt;em&gt;человек&lt;/em&gt; - это глобальная переменная, означающая, что если вы измените ее значение со &amp;laquo;пожилой женщины&amp;raquo; на &amp;laquo;молодой человек&amp;raquo;, &lt;em&gt;человек&lt;/em&gt; будет оставаться молодым человеком, пока вы не решите изменить его снова и что любая другая функция в Код может видеть, что это молодой человек. нажмите</target>
        </trans-unit>
        <trans-unit id="25334edab2e807f8912b0462c0c1d557fdc5ebe8" translate="yes" xml:space="preserve">
          <source>Get it? So in our primary example, the count variable is contained within the closure and always available to the event handler, so it retains its state from click to click.</source>
          <target state="translated">Понял? Итак,в нашем основном примере,переменная счетчика содержится внутри закрытия и всегда доступна обработчику события,поэтому она сохраняет свое состояние от щелчка к щелчку.</target>
        </trans-unit>
        <trans-unit id="2a0bf64067ba96e19feb251aca269629de4b6291" translate="yes" xml:space="preserve">
          <source>Here is a closure:</source>
          <target state="translated">Закрыто:</target>
        </trans-unit>
        <trans-unit id="bcaab99f4090d108eb398f8a65a144183fe65bee" translate="yes" xml:space="preserve">
          <source>Here is a factory that produces calculators that can add and multiply:</source>
          <target state="translated">Здесь находится фабрика,которая производит калькуляторы,которые могут добавлять и умножать:</target>
        </trans-unit>
        <trans-unit id="26c03c6b51995ce3cc45717ecfc54ea15182bfb0" translate="yes" xml:space="preserve">
          <source>Here is how I can convert my plane story into the code.</source>
          <target state="translated">Вот как я могу преобразовать историю с моим самолетом в код.</target>
        </trans-unit>
        <trans-unit id="542541ad020f39c0dd65066d67e5d1be86126656" translate="yes" xml:space="preserve">
          <source>Here is the summary:</source>
          <target state="translated">Вот резюме:</target>
        </trans-unit>
        <trans-unit id="880f763de0c8735d3a294c36e5df6df573d7c52c" translate="yes" xml:space="preserve">
          <source>Here's one of the examples:</source>
          <target state="translated">Вот один из примеров:</target>
        </trans-unit>
        <trans-unit id="5f5bf51aa2f2759a4b08230274e714f3e06de685" translate="yes" xml:space="preserve">
          <source>How I'd explain it to a six-year-old:</source>
          <target state="translated">Как бы я объяснил это шестилетнему мальчику:</target>
        </trans-unit>
        <trans-unit id="2e459856108a5cecf40e139f74b817f2e5e4faa0" translate="yes" xml:space="preserve">
          <source>How do JavaScript closures work</source>
          <target state="translated">Как работают JavaScript-закрытия</target>
        </trans-unit>
        <trans-unit id="31c4f787c21a33dcc90753d93c735b54274f39d7" translate="yes" xml:space="preserve">
          <source>How would you explain JavaScript closures to someone with a knowledge of the concepts they consist of (for example functions, variables and the like), but does not understand closures themselves?</source>
          <target state="translated">Как бы вы объяснили замыкание JavaScript человеку,который знает,из каких понятий он состоит (например,функции,переменные и т.п.),но не понимает,из каких понятий он состоит,но не понимает самих замыканий?</target>
        </trans-unit>
        <trans-unit id="d0b12b69fd5500aab9c9d2b4a9addddfd30dacaf" translate="yes" xml:space="preserve">
          <source>However, since &lt;code&gt;tmp&lt;/code&gt; is still hanging around inside &lt;code&gt;bar&lt;/code&gt;'s closure, it is available to be incremented. It will be incremented each time you call &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">Тем не менее, поскольку &lt;code&gt;tmp&lt;/code&gt; все еще находится внутри закрытия &lt;code&gt;bar&lt;/code&gt; , его можно увеличивать. Это будет увеличиваться каждый раз, когда вы вызываете &lt;code&gt;bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be9d4d94dd6f35953099bde147c591bdd84ed51a" translate="yes" xml:space="preserve">
          <source>I have seen &lt;a href=&quot;http://en.wikipedia.org/wiki/Scheme_%28programming_language%29&quot;&gt;the Scheme example&lt;/a&gt; given on Wikipedia, but unfortunately it did not help.</source>
          <target state="translated">Я видел &lt;a href=&quot;http://en.wikipedia.org/wiki/Scheme_%28programming_language%29&quot;&gt;пример схемы,&lt;/a&gt; приведенный в Википедии, но, к сожалению, это не помогло.</target>
        </trans-unit>
        <trans-unit id="c32c4a2db55c3bb615ab0b8d8acc3b66dadcac7d" translate="yes" xml:space="preserve">
          <source>I haven't got time to go shopping, so the function needs to know what we have in the fridge to make decisions. Each ingredient has a different cooking time and we want everything to be served hot by the robot at the same time. We need to provide the function with the data about what we like, the function could 'talk' to the fridge, and the function could control the robot.</source>
          <target state="translated">У меня нет времени на шоппинг,так что функция должна знать,что у нас есть в холодильнике,чтобы принимать решения.Каждый ингредиент имеет разное время приготовления,и мы хотим,чтобы робот подавал все горячее одновременно.Мы должны обеспечить функцию данными о том,что нам нравится,функция может &quot;разговаривать&quot; с холодильником,а функция может управлять роботом.</target>
        </trans-unit>
        <trans-unit id="f67fa89b4f0fa9a4f122d225bd2121614d8b9416" translate="yes" xml:space="preserve">
          <source>I know there are plenty of solutions already, but I guess that this small and simple script can be useful to demonstrate the concept:</source>
          <target state="translated">Я знаю,что решений уже достаточно,но думаю,что этот маленький и простой скрипт может быть полезен для демонстрации концепции:</target>
        </trans-unit>
        <trans-unit id="68c15dba4a700bb7a32cb7aad9a30cdd109d35e6" translate="yes" xml:space="preserve">
          <source>I need to know how many times a button has been clicked and do something on every third click...</source>
          <target state="translated">Мне нужно знать,сколько раз была нажата кнопка,и делать что-то на каждом третьем клике...</target>
        </trans-unit>
        <trans-unit id="1729e172673bb9af9294d6a61fc1a00e839e1311" translate="yes" xml:space="preserve">
          <source>I put together an interactive JavaScript tutorial to explain how closures work.
&lt;a href=&quot;http://nathansjslessons.appspot.com&quot;&gt;What's a Closure?&lt;/a&gt;</source>
          <target state="translated">Я собрал интерактивное руководство по JavaScript, чтобы объяснить, как работают замыкания. &lt;a href=&quot;http://nathansjslessons.appspot.com&quot;&gt;Что такое закрытие?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="123fc03a330a7c38723bf7555ca4ff7a80024826" translate="yes" xml:space="preserve">
          <source>I still think &lt;a href=&quot;http://code.google.com/apis/ajax/playground/?exp=maps#closure_simple&quot;&gt;Google's explanation&lt;/a&gt; works very well and is concise:</source>
          <target state="translated">Я все еще думаю, &lt;a href=&quot;http://code.google.com/apis/ajax/playground/?exp=maps#closure_simple&quot;&gt;что объяснение Google&lt;/a&gt; работает очень хорошо и сжато:</target>
        </trans-unit>
        <trans-unit id="0b506f3eb42bcf394c48e9df2a2bec6ef476dbaa" translate="yes" xml:space="preserve">
          <source>I suspect that closures in JavaScript differ from those normally found in functional languages.</source>
          <target state="translated">Я подозреваю,что закрытия в JavaScript отличаются от тех,которые обычно встречаются в функциональных языках.</target>
        </trans-unit>
        <trans-unit id="24dbc47ee46dbf67b52513fbd1c704c76d217b00" translate="yes" xml:space="preserve">
          <source>I tend to learn better by GOOD/BAD comparisons. I like to see working code followed by non-working code that someone is likely to encounter. I put together &lt;a href=&quot;http://jsfiddle.net/KMQZK/&quot;&gt;a jsFiddle&lt;/a&gt; that does a comparison and tries to boil down the differences to the simplest explanations I could come up with.</source>
          <target state="translated">Я склонен учиться лучше, сравнивая ХОРОШИЕ / ПЛОХИЕ. Мне нравится видеть рабочий код, сопровождаемый нерабочим кодом, с которым кто-то может столкнуться. Я собрал &lt;a href=&quot;http://jsfiddle.net/KMQZK/&quot;&gt;jsFiddle,&lt;/a&gt; который делает сравнение и пытается свести различия к простейшим объяснениям, которые я смог придумать.</target>
        </trans-unit>
        <trans-unit id="4b2d52788d16d1aed76a99b2962dd7f9b814a6e8" translate="yes" xml:space="preserve">
          <source>I think normally a closure is a term for both the function along with a captured variable environment. Note that I do not use that definition in this article!</source>
          <target state="translated">Я думаю,что обычно закрытие-это термин и для функции,и для окружения захваченной переменной.Обратите внимание,что я не использую это определение в данной статье!</target>
        </trans-unit>
        <trans-unit id="96ede599b6969e1b90d8c62ab4084c1f1b9581b8" translate="yes" xml:space="preserve">
          <source>I wrote a blog post a while back explaining closures. Here's what I said about closures in terms of &lt;strong&gt;why&lt;/strong&gt; you'd want one.</source>
          <target state="translated">Некоторое время назад я написал сообщение в блоге, объясняющее закрытие. Вот то, что я сказал о замыканиях с точки зрения того, &lt;strong&gt;почему&lt;/strong&gt; вы хотите его.</target>
        </trans-unit>
        <trans-unit id="1f893746796fe79900cf9caf10941e2bdc53f26f" translate="yes" xml:space="preserve">
          <source>I'd simply point them to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures&quot;&gt;Mozilla Closures page&lt;/a&gt;. It's the best, most &lt;strong&gt;concise and simple explanation&lt;/strong&gt; of closure basics and practical usage that I've found. It is highly recommended to anyone learning JavaScript.</source>
          <target state="translated">Я бы просто указал им на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures&quot;&gt;страницу Mozilla Closures&lt;/a&gt; . Это лучшее, самое &lt;strong&gt;краткое и простое объяснение&lt;/strong&gt; основ закрытия и практического использования, которое я нашел. Настоятельно рекомендуется всем, кто изучает JavaScript.</target>
        </trans-unit>
        <trans-unit id="11877a1bd39d64fe0945ea5ee068c0234e433657" translate="yes" xml:space="preserve">
          <source>I'm a big fan of analogy and metaphor when explaining difficult concepts, so let me try my hand with a story.</source>
          <target state="translated">Я большой поклонник аналогии и метафоры при объяснении сложных понятий,так что позвольте мне попробовать свои силы в истории.</target>
        </trans-unit>
        <trans-unit id="6b990bce01318ec63bef46aec64d8b6ab67c944d" translate="yes" xml:space="preserve">
          <source>I'm pretty sure I was one of the only people that attempted to take the initial question literally. Since then, the question has mutated several times, so my answer may now seem incredibly silly &amp;amp; out of place. Hopefully the general idea of the story remains fun for some.</source>
          <target state="translated">Я почти уверен, что был одним из немногих, кто попытался ответить на первый вопрос буквально. С тех пор вопрос несколько раз мутировал, поэтому мой ответ теперь может показаться невероятно глупым и неуместным. Надеюсь, общая идея этой истории для некоторых остается забавной.</target>
        </trans-unit>
        <trans-unit id="4f6b0992401487db0a126fe9e7ad6b66cdcca276" translate="yes" xml:space="preserve">
          <source>If a function accesses its environment, then the function is a closure.</source>
          <target state="translated">Если какая-либо функция обращается к своей среде,то эта функция является закрытой.</target>
        </trans-unit>
        <trans-unit id="f330a42bf372ed8fefe90c64085c3c7240fecf76" translate="yes" xml:space="preserve">
          <source>If a variable is read, but can not be found anywhere, an error is generated.</source>
          <target state="translated">Если переменная прочитана,но нигде не может быть найдена,генерируется ошибка.</target>
        </trans-unit>
        <trans-unit id="3cbc5f197b9dd09fc614b45e91092d33f7f9c144" translate="yes" xml:space="preserve">
          <source>If an inner function is returned by an outer, then the outer lexical environment will persist after the outer function has returned. This is because the outer lexical environment needs to be available if the inner function is eventually invoked.</source>
          <target state="translated">Если внутренняя функция возвращается внешней,то внешняя лексическая среда будет сохраняться и после возврата внешней функции.Это связано с тем,что внешняя лексическая среда должна быть доступна,если в конечном счете вызывается внутренняя функция.</target>
        </trans-unit>
        <trans-unit id="dc578583b34a4a34bae69d350c3dfa0573e54e50" translate="yes" xml:space="preserve">
          <source>If everything seems completely unclear, then the best thing to do is to play with the examples. Reading an explanation is much harder than understanding examples.
My explanations of closures and stack-frames, etc. are not technically correct &amp;mdash; they are gross simplifications intended to help to understand. Once the basic idea is grokked, you can pick up the details later.</source>
          <target state="translated">Если все кажется совершенно неясным, то лучше всего поиграть с примерами. Читать объяснение намного сложнее, чем понимать примеры. Мои объяснения замыканий, стековых фреймов и т. Д. Не являются технически правильными - это грубые упрощения, призванные помочь понять. Как только основная идея получена, вы можете подобрать детали позже.</target>
        </trans-unit>
        <trans-unit id="4f08569e7c3d79200141ddddd7958d6b1ded5e4e" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;i&lt;/code&gt; is also defined using &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt;, then the output is:</source>
          <target state="translated">Если переменная &lt;code&gt;i&lt;/code&gt; также определена с использованием &lt;code&gt;let&lt;/code&gt; вместо &lt;code&gt;var&lt;/code&gt; , тогда вывод:</target>
        </trans-unit>
        <trans-unit id="460b9688bda10bbf35ef9d0c1b98952a76ebb3ed" translate="yes" xml:space="preserve">
          <source>If you are trying to do any dynamic source code modifications (for example: &lt;code&gt;myFunction = Function(myFunction.toString().replace(/Hello/,'Hola'));&lt;/code&gt;), it won't work if &lt;code&gt;myFunction&lt;/code&gt; is a closure (of course, you would never even think of doing source code string substitution at runtime, but...).</source>
          <target state="translated">Если вы пытаетесь внести какие-либо изменения в динамический исходный код (например, &lt;code&gt;myFunction = Function(myFunction.toString().replace(/Hello/,'Hola'));&lt;/code&gt; ), это не будет работать, если &lt;code&gt;myFunction&lt;/code&gt; является замыканием ( конечно, вы никогда бы не подумали о подстановке строк исходного кода во время выполнения, но ...).</target>
        </trans-unit>
        <trans-unit id="f246fbc5dfee71350f8d01e881e3e75375300e1a" translate="yes" xml:space="preserve">
          <source>If you have &lt;em&gt;just&lt;/em&gt; learned closures (here or elsewhere!), then I am interested in any feedback from you about any changes you might suggest that could make this article clearer. Send an email to morrisjohns.com (morris_closure @). Please note that I am not a guru on JavaScript &amp;mdash; nor on closures.</source>
          <target state="translated">Если вы &lt;em&gt;только что&lt;/em&gt; узнали о замыканиях (здесь или где-либо еще!), Меня интересуют любые ваши отзывы о любых изменениях, которые вы могли бы предложить, которые могли бы сделать эту статью более понятной. Отправить письмо на morrisjohns.com (morris_closure @). Обратите внимание, что я не гуру в JavaScript - ни в замыканиях.</target>
        </trans-unit>
        <trans-unit id="6a8ed7866e246c92cf6dd70deac29290fa039a64" translate="yes" xml:space="preserve">
          <source>Imagine - you are playing with your little brothers and sisters in the entire house, and you are moving around with your toys and brought some of them into your older brother's room. After a while your brother returned from the school and went to his room, and he locked inside it, so now you could not access toys left there anymore in a direct way. But you could knock the door and ask your brother for that toys. This is called toy's &lt;em&gt;closure&lt;/em&gt;; your brother made it up for you, and he is now into outer &lt;em&gt;scope&lt;/em&gt;.</source>
          <target state="translated">Представьте себе - вы играете со своими маленькими братьями и сестрами по всему дому, вы ходите со своими игрушками и приносите некоторые из них в комнату вашего старшего брата. Через некоторое время ваш брат вернулся из школы и пошел в свою комнату, и он запер ее внутри, так что теперь вы больше не могли получить прямой доступ к оставленным там игрушкам. Но вы можете постучать в дверь и попросить вашего брата за эти игрушки. Это называется &lt;em&gt;закрытием&lt;/em&gt; игрушки; твой брат сделал это для тебя, и теперь он во внешнем &lt;em&gt;масштабе&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fabf25061406e8ca355bbb62da26e81c7a773acf" translate="yes" xml:space="preserve">
          <source>Imagine that the Stack Overflow Vote-Up and Vote-Down button events are implemented as closures, voteUp_click and voteDown_click, that have access to external variables isVotedUp and isVotedDown, which are defined globally. (For simplicity's sake, I am referring to StackOverflow's Question Vote buttons, not the array of Answer Vote buttons.)</source>
          <target state="translated">Представьте себе,что события кнопок Stack Overflow Vote-Up и Vote-Down реализуются в виде закрытия,voteUp_click и voteDown_click,которые имеют доступ к внешним переменным isVotedUp и isVotedDown,которые определяются глобально.(Для простоты я имею в виду кнопки StackOverflow's Question Vote,а не массив кнопок Answer Vote).</target>
        </trans-unit>
        <trans-unit id="34fbb45dfd31d8c76706f4846facff1223ce9ab3" translate="yes" xml:space="preserve">
          <source>In C and most other common languages, &lt;em&gt;after&lt;/em&gt; a function returns, all the local variables are no longer accessible because the stack-frame is destroyed.</source>
          <target state="translated">В C и большинстве других распространенных языков &lt;em&gt;после&lt;/em&gt; возврата функции все локальные переменные больше не доступны, потому что стековый фрейм разрушен.</target>
        </trans-unit>
        <trans-unit id="bde892a91769451e6aae5176cd04fd8bb3c261d1" translate="yes" xml:space="preserve">
          <source>In JavaScript, if you declare a function within another function, then the local variables of the outer function can remain accessible after returning from it. This is demonstrated above, because we call the function &lt;code&gt;say2()&lt;/code&gt; after we have returned from &lt;code&gt;sayHello2()&lt;/code&gt;. Notice that the code that we call references the variable &lt;code&gt;text&lt;/code&gt;, which was a &lt;em&gt;local variable&lt;/em&gt; of the function &lt;code&gt;sayHello2()&lt;/code&gt;.</source>
          <target state="translated">В JavaScript, если вы объявляете функцию в другой функции, то локальные переменные внешней функции могут оставаться доступными после ее возвращения. Это продемонстрировано выше, потому что мы вызываем функцию &lt;code&gt;say2()&lt;/code&gt; после того, как вернулись из &lt;code&gt;sayHello2()&lt;/code&gt; . Обратите внимание, что вызываемый нами код ссылается на переменную &lt;code&gt;text&lt;/code&gt; , которая была &lt;em&gt;локальной переменной&lt;/em&gt; функции &lt;code&gt;sayHello2()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66588c3a466a757d86d3ce97ab53a9423b323372" translate="yes" xml:space="preserve">
          <source>In a closure, the variables in the outer lexical environment &lt;em&gt;themselves&lt;/em&gt; are available, &lt;em&gt;not&lt;/em&gt; copies.</source>
          <target state="translated">В заключение, переменные во внешней лексической среде &lt;em&gt;сами по себе&lt;/em&gt; доступны, а &lt;em&gt;не&lt;/em&gt; копируются.</target>
        </trans-unit>
        <trans-unit id="be9e7184ed47abdf916495732c707da00b0bef5c" translate="yes" xml:space="preserve">
          <source>In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function.</source>
          <target state="translated">В компьютерной науке замыкание-это функция вместе со средой ссылки на нелокальные имена (свободные переменные)этой функции.</target>
        </trans-unit>
        <trans-unit id="7f7dd1aaa3a43450511e179ef4935d2bfcf91e9f" translate="yes" xml:space="preserve">
          <source>In that sense, they let a function act a bit like an object with private attributes.</source>
          <target state="translated">В этом смысле,они позволяют функции действовать немного похожим на объект с приватными атрибутами.</target>
        </trans-unit>
        <trans-unit id="0c18c47099c91026c3cd731edf3696ce2d7f9082" translate="yes" xml:space="preserve">
          <source>In the above code &lt;code&gt;createClosure(n)&lt;/code&gt; is invoked in every iteration of the loop. Note that I named the variable &lt;code&gt;n&lt;/code&gt; to highlight that it is a &lt;strong&gt;new&lt;/strong&gt; variable created in a new function scope and is not the same variable as &lt;code&gt;index&lt;/code&gt; which is bound to the outer scope.</source>
          <target state="translated">В приведенном выше коде &lt;code&gt;createClosure(n)&lt;/code&gt; вызывается на каждой итерации цикла. Обратите внимание, что я назвал переменную &lt;code&gt;n&lt;/code&gt; , чтобы подчеркнуть, что это &lt;strong&gt;новая&lt;/strong&gt; переменная, созданная в новой области видимости функции и не совпадающая с &lt;code&gt;index&lt;/code&gt; который связан с внешней областью видимости.</target>
        </trans-unit>
        <trans-unit id="64ccd305f21918c690c8faf2eee3f539cb44d848" translate="yes" xml:space="preserve">
          <source>In the above code the loop was moved within the &lt;code&gt;createClosureArray()&lt;/code&gt; function and the function now just returns the completed array, which at first glance seems more intuitive.</source>
          <target state="translated">В приведенном выше коде цикл был перемещен в &lt;code&gt;createClosureArray()&lt;/code&gt; и теперь функция просто возвращает законченный массив, который на первый взгляд кажется более интуитивным.</target>
        </trans-unit>
        <trans-unit id="b564dadb6ceca4494d7653f8c5e95bc5a27eaf2b" translate="yes" xml:space="preserve">
          <source>In the above example, I am using the closure behavior of JavaScript. &lt;strong&gt;This behavior allows any function to have access to the scope in which it was created, indefinitely.&lt;/strong&gt; To practically apply this, I immediately invoke a function that returns another function, and because the function I'm returning has access to the internal count variable (because of the closure behavior explained above) this results in a private scope for usage by the resulting function... Not so simple? Let's dilute it down...</source>
          <target state="translated">В приведенном выше примере я использую поведение закрытия JavaScript. &lt;strong&gt;Такое поведение позволяет любой функции иметь доступ к области, в которой она была создана, на неопределенный срок.&lt;/strong&gt; Чтобы практически применить это, я немедленно вызываю функцию, которая возвращает другую функцию, и поскольку функция, которую я возвращаю, имеет доступ к внутренней переменной count (из-за описанного выше поведения замыкания), это приводит к закрытой области видимости для использования в результате функция ... не так просто? Давайте разбавим это ...</target>
        </trans-unit>
        <trans-unit id="52291f67af5b2a395aa91f417749282ffa321ce5" translate="yes" xml:space="preserve">
          <source>In the above example, outerFunction is called which in turn calls innerFunction. Note how outerVar is available to innerFunction, evidenced by its correctly alerting the value of outerVar.</source>
          <target state="translated">В приведенном выше примере вызывается внешняя функция,которая,в свою очередь,вызывает внутреннюю функцию.Обратите внимание на то,как outerVar доступен для innerFunction,о чем свидетельствует его правильное оповещение о значении outerVar.</target>
        </trans-unit>
        <trans-unit id="9accb51a40f9456dfff0b9b647c4adc451c98ff8" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;f&lt;/code&gt; closes over the lexical environment of the global execution context:</source>
          <target state="translated">В следующем примере функция &lt;code&gt;f&lt;/code&gt; закрывает лексическую среду глобального контекста выполнения:</target>
        </trans-unit>
        <trans-unit id="79e7feaad903ac12e4a4780516074d3c8e273603" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;h&lt;/code&gt; closes over the lexical environment of function &lt;code&gt;g&lt;/code&gt;, which, in turn, closes over the lexical environment of the global execution context.</source>
          <target state="translated">В следующем примере функция &lt;code&gt;h&lt;/code&gt; закрывается над лексической средой функции &lt;code&gt;g&lt;/code&gt; , которая, в свою очередь, закрывается над лексической средой глобального контекста выполнения.</target>
        </trans-unit>
        <trans-unit id="d208e23250c79929b1202ec211a36dbeb87b68f9" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;j&lt;/code&gt; closes over the lexical environment of function &lt;code&gt;i&lt;/code&gt;, meaning that variable &lt;code&gt;x&lt;/code&gt; is visible from inside function &lt;code&gt;j&lt;/code&gt;, long after function &lt;code&gt;i&lt;/code&gt; has completed execution:</source>
          <target state="translated">В следующем примере функция &lt;code&gt;j&lt;/code&gt; закрывается над лексическим окружением функции &lt;code&gt;i&lt;/code&gt; , что означает, что переменная &lt;code&gt;x&lt;/code&gt; видна внутри функции &lt;code&gt;j&lt;/code&gt; , еще долго после того, как функция &lt;code&gt;i&lt;/code&gt; завершила выполнение:</target>
        </trans-unit>
        <trans-unit id="9a42d2846a79c733d7b14604fa1cb2c0c4772121" translate="yes" xml:space="preserve">
          <source>In the terminology of the ECMAScript specification, a closure can be said to be implemented by the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt;&lt;code&gt;[[Environment]]&lt;/code&gt;&lt;/a&gt; reference of every function-object, which points to the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;lexical environment&lt;/a&gt; within which the function is defined.</source>
          <target state="translated">В терминологии спецификации ECMAScript можно сказать, что замыкание реализуется ссылкой &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt; &lt;code&gt;[[Environment]]&lt;/code&gt; &lt;/a&gt; каждого объекта-функции, которая указывает на &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;лексическую среду,&lt;/a&gt; в которой определена функция.</target>
        </trans-unit>
        <trans-unit id="88a0303f59536ee17cc71dcac48a7690fb59fb0b" translate="yes" xml:space="preserve">
          <source>In this case, the interpreter finds the variable in the
outer &lt;a href=&quot;http://javascript.info/tutorial/initialization&quot;&gt;&lt;code&gt;LexicalEnvironment&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">В этом случае интерпретатор находит переменную во внешнем объекте &lt;a href=&quot;http://javascript.info/tutorial/initialization&quot;&gt; &lt;code&gt;LexicalEnvironment&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="517b1409687da9d9fcb673e99fbcc8dd23f7ee52" translate="yes" xml:space="preserve">
          <source>In this final example, each call to the main function creates a separate closure.</source>
          <target state="translated">В этом последнем примере каждый вызов основной функции создает отдельное закрытие.</target>
        </trans-unit>
        <trans-unit id="c7149ac43259f5072dae076e7d470d21214d7c4c" translate="yes" xml:space="preserve">
          <source>Inner functions like &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt;, which access variables declared in an outer function&lt;sup&gt;**&lt;/sup&gt;, are called &lt;em&gt;closures&lt;/em&gt;.</source>
          <target state="translated">Внутренние функции, такие как &lt;code&gt;add&lt;/code&gt; и &lt;code&gt;multiply&lt;/code&gt; , которые обращаются к переменным, объявленным во внешней функции &lt;sup&gt;**&lt;/sup&gt; , называются &lt;em&gt;замыканиями&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c535437331e2cd1ff0b52dab323b734568fde96b" translate="yes" xml:space="preserve">
          <source>It is possible to nest function declarations within function declarations within function declarations&amp;hellip;; you can get closures at more than one level.</source>
          <target state="translated">Можно вложить объявления функций в объявления функций внутри объявлений функций&amp;hellip;; Вы можете получить замыкания на более чем одном уровне.</target>
        </trans-unit>
        <trans-unit id="bd8a1c5b969fb5ce6751ab00fdc753d6fe50bc42" translate="yes" xml:space="preserve">
          <source>It may be helpful to see what happens when a block-level declaration of the variable &lt;code&gt;item&lt;/code&gt; is used (via the &lt;code&gt;let&lt;/code&gt; keyword) instead of a function-scoped variable declaration via the &lt;code&gt;var&lt;/code&gt; keyword. If that change is made, then each anonymous function in the array &lt;code&gt;result&lt;/code&gt; has its own closure; when the example is run the output is as follows:</source>
          <target state="translated">Может быть полезно посмотреть, что происходит, когда объявление уровня переменной &lt;code&gt;item&lt;/code&gt; переменной (через ключевое слово &lt;code&gt;let&lt;/code&gt; ) вместо объявления переменной области действия через ключевое слово &lt;code&gt;var&lt;/code&gt; . Если это изменение сделано, то каждая анонимная функция в &lt;code&gt;result&lt;/code&gt; массива имеет свое собственное закрытие; когда запускается пример, вывод будет следующим:</target>
        </trans-unit>
        <trans-unit id="3f6d29d5da52be16dfb12c7815fe37a9ce3fcf16" translate="yes" xml:space="preserve">
          <source>JAVASCRIPT: JavaScript is a language. Like English or French or Chinese are languages. There are lots of languages that are understood by computers and other electronic processors. For JavaScript to be understood by a computer it needs an interpreter. Imagine if a teacher who only speaks Russian comes to teach your class at school. When the teacher says &quot;все садятся&quot;, the class would not understand. But luckily you have a Russian pupil in your class who tells everyone this means &quot;everybody sit down&quot; - so you all do. The class is like a computer and the Russian pupil is the interpreter. For JavaScript the most common interpreter is called a browser.</source>
          <target state="translated">JAVASCRIPT:JavaScript-это язык.Как и английский,французский или китайский языки.Существует множество языков,которые понимают компьютеры и другие электронные процессоры.Для того,чтобы JavaScript был понятен компьютеру,ему нужен переводчик.Представьте себе,если преподаватель,который говорит только по-русски,придет преподавать в вашем классе в школе.Когда учитель говорит &quot;все садятся&quot;,класс не поймет.Но,к счастью,в вашем классе есть русский ученик,который говорит всем,что это значит &quot;все садитесь&quot;-так вы все понимаете.Класс как компьютер,а русский ученик-переводчик.Для JavaScript самый распространенный переводчик называется браузером.</target>
        </trans-unit>
        <trans-unit id="f15fd20b3b607a06e5de7b00b5c8829cba54783d" translate="yes" xml:space="preserve">
          <source>JavaScript closures for beginners</source>
          <target state="translated">Закрытие JavaScript для новичков</target>
        </trans-unit>
        <trans-unit id="a4ad1062dbb50a6179be99978ca0015111394d54" translate="yes" xml:space="preserve">
          <source>JavaScript functions can access their:</source>
          <target state="translated">JavaScript-функции могут получить доступ к своим:</target>
        </trans-unit>
        <trans-unit id="18356dc7f56408ba6d488b26a212e8a89b8f9645" translate="yes" xml:space="preserve">
          <source>Let's imagine the next situation: a driver is sitting in a car. That car is inside a plane. Plane is in the airport. The ability of driver to access things outside his car, but inside the plane, even if that plane leaves an airport, is a closure. That's it. When you turn 27, look at the &lt;a href=&quot;https://stackoverflow.com/a/111200/1393791&quot;&gt;more detailed explanation&lt;/a&gt; or at the example below.</source>
          <target state="translated">Давайте представим следующую ситуацию: водитель сидит в машине. Эта машина в самолете. Самолет в аэропорту. Возможность водителя получить доступ к вещам вне его автомобиля, но внутри самолета, даже если этот самолет покидает аэропорт, является закрытием. Вот и все. Когда вам исполнится 27 лет, посмотрите на &lt;a href=&quot;https://stackoverflow.com/a/111200/1393791&quot;&gt;более подробное объяснение&lt;/a&gt; или на пример ниже.</target>
        </trans-unit>
        <trans-unit id="09b200c5ade4b1cb4a297a00afe3d45be8c9d80e" translate="yes" xml:space="preserve">
          <source>Like the old Albert said : &quot;If you can't explain it to a six-year old, you really don't understand it yourself.&amp;rdquo;. Well I tried to explain JS closures to a 27 years old friend and completely failed.</source>
          <target state="translated">Как сказал старый Альберт: &amp;laquo;Если вы не можете объяснить это шестилетнему, вы действительно сами этого не понимаете&amp;raquo;. Ну, я попытался объяснить закрытие JS другу 27 лет и потерпел неудачу.</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="f4346c3dbf21e346a2dead6609d901d087e13650" translate="yes" xml:space="preserve">
          <source>Locals (that is, their local variables and local functions)</source>
          <target state="translated">Локальные (то есть их локальные переменные и локальные функции).</target>
        </trans-unit>
        <trans-unit id="2b0aed7bf52a8c5e0e0cefef3f3b339f8c820a34" translate="yes" xml:space="preserve">
          <source>Looking at the output of &lt;code&gt;say2.toString()&lt;/code&gt;, we can see that the code refers to the variable &lt;code&gt;text&lt;/code&gt;. The anonymous function can reference &lt;code&gt;text&lt;/code&gt; which holds the value &lt;code&gt;'Hello Bob'&lt;/code&gt; because the local variables of &lt;code&gt;sayHello2()&lt;/code&gt; have been secretly kept alive in a closure.</source>
          <target state="translated">Глядя на выходные данные &lt;code&gt;say2.toString()&lt;/code&gt; , мы видим, что код ссылается на переменную &lt;code&gt;text&lt;/code&gt; . Анонимная функция может ссылаться на &lt;code&gt;text&lt;/code&gt; который содержит значение &lt;code&gt;'Hello Bob'&lt;/code&gt; потому что локальные переменные &lt;code&gt;sayHello2()&lt;/code&gt; тайно поддерживаются в замыкании.</target>
        </trans-unit>
        <trans-unit id="5628f8a6b5fea1b9beca93e689568ae4c8efb6d1" translate="yes" xml:space="preserve">
          <source>Marking up LexicalEnvironments:</source>
          <target state="translated">Маркирую Лексикальную Окружающую Среду:</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes" xml:space="preserve">
          <source>More examples</source>
          <target state="translated">Другие примеры</target>
        </trans-unit>
        <trans-unit id="6f01bda547a9bb9e65d7ba349d7f92d2d69752b9" translate="yes" xml:space="preserve">
          <source>Most JavaScript programmers will understand how a reference to a function is returned to a variable (&lt;code&gt;say2&lt;/code&gt;) in the above code. If you don't, then you need to look at that before you can learn closures. A programmer using C would think of the function as returning a pointer to a function, and that the variables &lt;code&gt;say&lt;/code&gt; and &lt;code&gt;say2&lt;/code&gt; were each a pointer to a function.</source>
          <target state="translated">Большинство программистов JavaScript поймут, как ссылка на функцию возвращается к переменной ( &lt;code&gt;say2&lt;/code&gt; ) в приведенном выше коде. Если вы этого не сделаете, то вам нужно посмотреть на это, прежде чем вы сможете научиться замыканиям. Программист, использующий C, мог бы думать о функции как о возвращении указателя на функцию, и что переменные &lt;code&gt;say&lt;/code&gt; и &lt;code&gt;say2&lt;/code&gt; были указателями на функцию.</target>
        </trans-unit>
        <trans-unit id="fd66b2800310560a1ce2ba5a794b44747c843f0e" translate="yes" xml:space="preserve">
          <source>NAME: You can call a function just about whatever word you want. The example &quot;cookMeal&quot; is typical in joining two words together and giving the second one a capital letter at the beginning - but this is not necessary. It can't have a space in it, and it can't be a number on its own.</source>
          <target state="translated">ФАМИЛИЯ:Ты можешь вызвать функцию,как раз по тому,что ты хочешь.Пример &quot;cookMeal&quot; типичен для объединения двух слов и придания второму в начале заглавной буквы-но в этом нет необходимости.В нем не может быть пробела,и оно не может быть числом само по себе.</target>
        </trans-unit>
        <trans-unit id="40c3e770c196ccb030cf74232292c69eb60717a3" translate="yes" xml:space="preserve">
          <source>Note that in the above example, if you call &lt;code&gt;setupSomeGlobals()&lt;/code&gt; again, then a new closure (stack-frame!) is created. The old &lt;code&gt;gLogNumber&lt;/code&gt;, &lt;code&gt;gIncreaseNumber&lt;/code&gt;, &lt;code&gt;gSetNumber&lt;/code&gt; variables are overwritten with &lt;em&gt;new&lt;/em&gt; functions that have the new closure. (In JavaScript, whenever you declare a function inside another function, the inside function(s) is/are recreated again &lt;em&gt;each&lt;/em&gt; time the outside function is called.)</source>
          <target state="translated">Обратите внимание, что в приведенном выше примере, если вы снова вызываете &lt;code&gt;setupSomeGlobals()&lt;/code&gt; , то создается новое замыкание (stack-frame!). Старые &lt;code&gt;gLogNumber&lt;/code&gt; , &lt;code&gt;gIncreaseNumber&lt;/code&gt; , &lt;code&gt;gSetNumber&lt;/code&gt; перезаписываются &lt;em&gt;новыми&lt;/em&gt; функциями с новым замыканием. (В JavaScript всякий раз, когда вы объявляете функцию внутри другой функции, внутренняя функция (и) воссоздается / воссоздается снова &lt;em&gt;каждый&lt;/em&gt; раз, когда вызывается внешняя функция.)</target>
        </trans-unit>
        <trans-unit id="7dc2f9bd9efd8d1e52cbf8c35413ba1f4105f5a9" translate="yes" xml:space="preserve">
          <source>Note that outer functions are not required, though they do offer benefits I don't discuss here. By accessing data in its environment, a closure keeps that data alive. In the subcase of outer/inner functions, an outer function can create local data and eventually exit, and yet, if any inner function(s) survive after the outer function exits, then the inner function(s) keep the outer function's local data alive.</source>
          <target state="translated">Обратите внимание,что внешние функции не являются обязательными,хотя они и предлагают преимущества,которые я здесь не обсуждаю.Получая доступ к данным в своей среде,закрытие сохраняет эти данные живыми.В подказе внешних функций внешняя функция может создавать локальные данные и,в конечном счете,выходить,и все же,если какая-либо внутренняя функция (функции)выживает после выхода из внешней функции,то внутренняя функция (функции)сохраняет локальные данные внешней функции.</target>
        </trans-unit>
        <trans-unit id="4b7d6be3be4533ef766e4ba6b6589adcce7bd0a0" translate="yes" xml:space="preserve">
          <source>Note that variables &lt;em&gt;themselves&lt;/em&gt; are visible from within a closure, &lt;em&gt;not&lt;/em&gt; copies.</source>
          <target state="translated">Обратите внимание, что &lt;em&gt;сами&lt;/em&gt; переменные видны из замыкания, а &lt;em&gt;не из&lt;/em&gt; копий.</target>
        </trans-unit>
        <trans-unit id="9dccaff8b91f1ebe851d8b10d10b8abb4daae146" translate="yes" xml:space="preserve">
          <source>Note that when you run the example, &lt;code&gt;&quot;item2 undefined&quot;&lt;/code&gt; is logged three times! This is because just like previous examples, there is only one closure for the local variables for &lt;code&gt;buildList&lt;/code&gt; (which are &lt;code&gt;result&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;item&lt;/code&gt;). When the anonymous functions are called on the line &lt;code&gt;fnlist[j]()&lt;/code&gt;; they all use the same single closure, and they use the current value for &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;item&lt;/code&gt; within that one closure (where &lt;code&gt;i&lt;/code&gt; has a value of &lt;code&gt;3&lt;/code&gt; because the loop had completed, and &lt;code&gt;item&lt;/code&gt; has a value of &lt;code&gt;'item2'&lt;/code&gt;). Note we are indexing from 0 hence &lt;code&gt;item&lt;/code&gt; has a value of &lt;code&gt;item2&lt;/code&gt;. And the i++ will increment &lt;code&gt;i&lt;/code&gt; to the value &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">Обратите внимание, что при запуске примера &lt;code&gt;&quot;item2 undefined&quot;&lt;/code&gt; регистрируется три раза! Это потому, что, как и в предыдущих примерах, есть только одно закрытие для локальных переменных для &lt;code&gt;buildList&lt;/code&gt; (которые являются &lt;code&gt;result&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; и &lt;code&gt;item&lt;/code&gt; ). Когда анонимные функции вызываются в строке &lt;code&gt;fnlist[j]()&lt;/code&gt; ; все они используют одно и то же замыкание, и они используют текущее значение для &lt;code&gt;i&lt;/code&gt; и &lt;code&gt;item&lt;/code&gt; в этом одном замыкании (где &lt;code&gt;i&lt;/code&gt; имеет значение &lt;code&gt;3&lt;/code&gt; , поскольку цикл завершен, а &lt;code&gt;item&lt;/code&gt; имеет значение &lt;code&gt;'item2'&lt;/code&gt; ). Обратите внимание, что мы индексируем от 0, следовательно, &lt;code&gt;item&lt;/code&gt; имеет значение &lt;code&gt;item2&lt;/code&gt; . И i ++ увеличит &lt;code&gt;i&lt;/code&gt; до значения &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2632a4becd02c75c95693519f5cf180b44a90456" translate="yes" xml:space="preserve">
          <source>Notice a few things here.</source>
          <target state="translated">Заметьте кое-что.</target>
        </trans-unit>
        <trans-unit id="3393c390f2f8f559d4a2a520da1ec907eaeea621" translate="yes" xml:space="preserve">
          <source>Now consider the following:</source>
          <target state="translated">Теперь рассмотрим следующее:</target>
        </trans-unit>
        <trans-unit id="8495e70502d881bdf9b4145e67ce317efd57faac" translate="yes" xml:space="preserve">
          <source>Now this will work, but it does encroach into the outer scope by adding a variable, whose sole purpose is to keep track of the count. In some situations, this would be preferable as your outer application might need access to this information. But in this case, we are only changing every third click's behavior, so it is preferable to &lt;strong&gt;enclose this functionality inside the event handler&lt;/strong&gt;.</source>
          <target state="translated">Теперь это сработает, но оно вторгается во внешнюю область, добавляя переменную, единственная цель которой - отслеживать количество. В некоторых ситуациях это будет предпочтительнее, поскольку вашему внешнему приложению может потребоваться доступ к этой информации. Но в этом случае мы меняем только поведение каждого третьего клика, поэтому желательно &lt;strong&gt;включить эту функцию в обработчик событий&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="edc821fed74b8a83207ffcc4a681c6656cb0dbd9" translate="yes" xml:space="preserve">
          <source>Now what it &lt;em&gt;allows&lt;/em&gt; you to do can be more spectacular, see other answers.</source>
          <target state="translated">Теперь то, что он &lt;em&gt;позволяет&lt;/em&gt; вам делать, может быть более впечатляющим, смотрите другие ответы.</target>
        </trans-unit>
        <trans-unit id="37b00465e1d26162d39a6df745e20f2e4e1c3722" translate="yes" xml:space="preserve">
          <source>Now, after the function &lt;em&gt;sing()&lt;/em&gt;, near the end of the code is the line</source>
          <target state="translated">Теперь, после функции &lt;em&gt;sing ()&lt;/em&gt; , ближе к концу кода находится строка</target>
        </trans-unit>
        <trans-unit id="2b6292f13ea61f03e46a26b717197499baebf90b" translate="yes" xml:space="preserve">
          <source>Now, where's the definition of &lt;code&gt;x&lt;/code&gt;? We didn't define it in the current scope. The only solution is to let &lt;code&gt;plus5&lt;/code&gt;&lt;em&gt;carry&lt;/em&gt; its scope (or rather, its parent's scope) around. This way, &lt;code&gt;x&lt;/code&gt; is well-defined and it is bound to the value 5.</source>
          <target state="translated">Теперь, где определение &lt;code&gt;x&lt;/code&gt; ? Мы не определили это в текущем объеме. Единственное решение состоит в том, чтобы позволить &lt;code&gt;plus5&lt;/code&gt; &lt;em&gt;переносить&lt;/em&gt; свою область (или, скорее, область действия своего родителя) вокруг. Таким образом, &lt;code&gt;x&lt;/code&gt; четко определено и связано со значением 5.</target>
        </trans-unit>
        <trans-unit id="9e15ed596afd3bc19fd5d61a060bb2a47cddef9b" translate="yes" xml:space="preserve">
          <source>OK, 6-year-old closures fan. Do you want to hear the simplest example of closure?</source>
          <target state="translated">Ладно,6-летний фанат закрытия.Хотите услышать самый простой пример закрытия?</target>
        </trans-unit>
        <trans-unit id="d722330a80b9bc2dfce4ab9f7b615cda1f5e4764" translate="yes" xml:space="preserve">
          <source>Okay, talking with a 6-year old child, I would possibly use following associations.</source>
          <target state="translated">Ладно,разговаривая с 6-летним ребенком,я,возможно,использую следующие ассоциации.</target>
        </trans-unit>
        <trans-unit id="148abbffcf1d27e45f3fc36604ef1e94841e9e4b" translate="yes" xml:space="preserve">
          <source>On  &lt;a href=&quot;http://www.howkidsdevelop.com/5-7years.html&quot;&gt;Childhood Development: 5 to 7 Years &lt;/a&gt; it says:</source>
          <target state="translated">О &lt;a href=&quot;http://www.howkidsdevelop.com/5-7years.html&quot;&gt;развитии детства: от 5 до 7 лет&lt;/a&gt; говорится:</target>
        </trans-unit>
        <trans-unit id="34b3df084cbf5c7a669b26ff1aacf3c99a1d1dc8" translate="yes" xml:space="preserve">
          <source>Original post by Morris can be found in the &lt;a href=&quot;http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies&quot;&gt;Internet Archive&lt;/a&gt;.</source>
          <target state="translated">Оригинальное сообщение Морриса можно найти в &lt;a href=&quot;http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies&quot;&gt;интернет-архиве&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="681216b5a1437efa0ee50e426313a7fe8126153e" translate="yes" xml:space="preserve">
          <source>Our code begins with the word &lt;em&gt;function&lt;/em&gt;, so we know that it is one! Then the name of the function &lt;em&gt;sing&lt;/em&gt; - that's my own description of what the function is about. Then parentheses &lt;em&gt;()&lt;/em&gt;. The parentheses are always there for a function. Sometimes they are empty, and sometimes they have something in. This one has a word in: &lt;code&gt;(person)&lt;/code&gt;. After this there is a brace like this &lt;code&gt;{&lt;/code&gt; . This marks the start of the function &lt;em&gt;sing()&lt;/em&gt;. It has a partner which marks the end of &lt;em&gt;sing()&lt;/em&gt; like this &lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">Наш код начинается со слова &lt;em&gt;function&lt;/em&gt; , поэтому мы знаем, что он один! Затем название функции &lt;em&gt;sing&lt;/em&gt; - это мое собственное описание того, о чем эта функция. Тогда круглые скобки &lt;em&gt;()&lt;/em&gt; . Скобки всегда есть для функции. Иногда они пусты, а иногда в них что-то есть. В этом есть слово: &lt;code&gt;(person)&lt;/code&gt; . После этого есть такая скобка &lt;code&gt;{&lt;/code&gt; . Это отмечает начало функции &lt;em&gt;sing ()&lt;/em&gt; . У него есть партнер, который отмечает конец &lt;em&gt;sing ()&lt;/em&gt; следующим образом:</target>
        </trans-unit>
        <trans-unit id="05c242ba6271e12b61564339fb6644d07e822a54" translate="yes" xml:space="preserve">
          <source>PARENTHESES: &quot;Parentheses&quot; or &lt;code&gt;()&lt;/code&gt; are the letter box on the JavaScript function factory's door or a post box in the street for sending packets of information to the factory. Sometimes the postbox might be marked &lt;em&gt;for example&lt;/em&gt;&lt;code&gt;cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime)&lt;/code&gt;, in which case you know what data you have to give it.</source>
          <target state="translated">РОДИТЕЛИ: &amp;laquo;Круглые скобки&amp;raquo; или &lt;code&gt;()&lt;/code&gt; - это почтовый ящик на двери фабрики функций JavaScript или почтовый ящик на улице для отправки пакетов информации на фабрику. Иногда почтовый ящик может быть отмечен, &lt;em&gt;например,&lt;/em&gt; &lt;code&gt;cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime)&lt;/code&gt; , и в этом случае вы знаете, какие данные вам нужно предоставить.</target>
        </trans-unit>
        <trans-unit id="9144b2a7d95b704078de888cf37d60fe67becfb9" translate="yes" xml:space="preserve">
          <source>Perhaps a little beyond all but the most precocious of six-year-olds, but a few examples that helped make the concept of closure in JavaScript click for me.</source>
          <target state="translated">Возможно,немного больше,чем все,кроме самых ранних шестилетних,но несколько примеров,которые помогли заставить концепцию закрытия в JavaScript кликнуть для меня.</target>
        </trans-unit>
        <trans-unit id="5faa59d4bc3756040b8ce9e673c09f929e6ee9ba" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Result</target>
        </trans-unit>
        <trans-unit id="bcd4102717d8891f8d496a43ec74da14fa94f69e" translate="yes" xml:space="preserve">
          <source>Returning a &lt;code&gt;function&lt;/code&gt; from inside another function is the classic example of a closure, because the state inside the outer function is implicitly available to the returned inner function, even after the outer function has completed execution. This has a number of use-cases, including simulating private variables.</source>
          <target state="translated">Возврат &lt;code&gt;function&lt;/code&gt; из другой функции является классическим примером замыкания, потому что состояние внутри внешней функции неявно доступно для возвращенной внутренней функции, даже после того, как внешняя функция завершила выполнение. Это имеет ряд вариантов использования, включая моделирование частных переменных.</target>
        </trans-unit>
        <trans-unit id="ada6589cf526d0c74d239a16a5730f12743a8388" translate="yes" xml:space="preserve">
          <source>Second, when a closure is created, it retains a reference to all of its enclosing function&amp;rsquo;s variables and functions; it doesn&amp;rsquo;t get to pick and choose. And but so, closures should be used sparingly, or at least carefully, as they can be memory intensive; a lot of variables can be kept in memory long after a containing function has finished executing.</source>
          <target state="translated">Во-вторых, когда создается замыкание, оно сохраняет ссылку на все переменные и функции своей включающей функции; это не может выбирать. И, тем не менее, затворы следует использовать с осторожностью или, по крайней мере, осторожно, так как они могут занимать много памяти; многие переменные могут храниться в памяти еще долго после завершения выполнения содержащей их функции.</target>
        </trans-unit>
        <trans-unit id="67fe596a436afe4d7599b96bf46b1977ec2e0ef6" translate="yes" xml:space="preserve">
          <source>She lived in a wonderful world full of adventures. She met her Prince Charming, rode around her world on a unicorn, battled dragons, encountered talking animals, and many other fantastical things.</source>
          <target state="translated">Она жила в удивительном мире,полном приключений.Она познакомилась со своим Прекрасным Принцем,каталась по миру на единороге,сражалась с драконами,встречалась с говорящими животными и многими другими фантастическими вещами.</target>
        </trans-unit>
        <trans-unit id="07573b573651a019027237d961cc61054b6bec94" translate="yes" xml:space="preserve">
          <source>Since &lt;strong&gt;scope-defining construction in JavaScript is a function&lt;/strong&gt;, not a code block like in many other languages, &lt;strong&gt;what we usually mean by &lt;em&gt;closure&lt;/em&gt; in JavaScript&lt;/strong&gt; is a &lt;strong&gt;function working with nonlocal variables defined in already executed surrounding function&lt;/strong&gt;.</source>
          <target state="translated">Поскольку &lt;strong&gt;определяющая область видимости в JavaScript является функцией&lt;/strong&gt; , а не блоком кода, как во многих других языках, &lt;strong&gt;то&lt;/strong&gt; , &lt;strong&gt;что мы обычно подразумеваем под &lt;em&gt;замыканием&lt;/em&gt; в JavaScript&lt;/strong&gt; , это &lt;strong&gt;функция, работающая с нелокальными переменными, определенными в уже выполненной окружающей функции&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e95fed48c1d8fabe097fc454c7b9211faa3636be" translate="yes" xml:space="preserve">
          <source>So this function might have something to do with singing, and might need some data about a person. It has instructions inside to do something with that data.</source>
          <target state="translated">Так что эта функция может иметь какое-то отношение к пению,и может потребоваться некоторая информация о человеке.У нее есть инструкции внутри,чтобы сделать что-то с этими данными.</target>
        </trans-unit>
        <trans-unit id="a50b97914eb409961a9c50a5aaf62d55c22e4149" translate="yes" xml:space="preserve">
          <source>So to live, the child has to leave before it's too late</source>
          <target state="translated">Так что,чтобы жить,ребенок должен уйти,пока не поздно.</target>
        </trans-unit>
        <trans-unit id="a2d88110733edd016cbeae6a733e1b0d67a3f3ba" translate="yes" xml:space="preserve">
          <source>So what are these closure thingys?</source>
          <target state="translated">Так что это за штуки с закрытием?</target>
        </trans-unit>
        <trans-unit id="454c8a36400b7eb57a810440ce57394bfb5816b7" translate="yes" xml:space="preserve">
          <source>So, as long as we are in the parent -function, it can create one or more child functions which do share the secret variables from the secret place.</source>
          <target state="translated">Таким образом,пока мы находимся в родительской функции,она может создавать одну или несколько дочерних функций,которые разделяют секретные переменные из секретного места.</target>
        </trans-unit>
        <trans-unit id="0a89e976c7abc12da557c349bfa0ca485f347c7a" translate="yes" xml:space="preserve">
          <source>So, function g has access to g, a and f.</source>
          <target state="translated">Итак,функция g имеет доступ к g,a и f.</target>
        </trans-unit>
        <trans-unit id="f9cca5aab093ddbfc4f01dcf36fc37ee09f0ff12" translate="yes" xml:space="preserve">
          <source>So, if you call the child &quot;Alice&quot;, she will respond</source>
          <target state="translated">Так что,если вы назовёте ребёнка &quot;Элис&quot;,она ответит.</target>
        </trans-unit>
        <trans-unit id="dbc77889f79e6ba70a51ccdd7b1d469ad3fe2209" translate="yes" xml:space="preserve">
          <source>So, whenever you see the &lt;code&gt;function&lt;/code&gt; keyword, code inside that function has access to variables declared outside the function.</source>
          <target state="translated">Поэтому всякий раз, когда вы видите ключевое слово &lt;code&gt;function&lt;/code&gt; , код внутри этой функции имеет доступ к переменным, объявленным вне функции.</target>
        </trans-unit>
        <trans-unit id="32a5b0910ff15915067cd48d69073b7ed24d5e07" translate="yes" xml:space="preserve">
          <source>Submitted by Morris on Tue, 2006-02-21 10:19.  Community-edited since.</source>
          <target state="translated">Представлено Моррисом во вторник,2006-02-21 10:19.Община редактируется с тех пор.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="9025c4cc6a8af6eb5f548366877eea00d17ba2f8" translate="yes" xml:space="preserve">
          <source>Taking the question seriously, we should find out what a typical 6-year-old is capable of cognitively, though admittedly, one who is interested in JavaScript is not so typical.</source>
          <target state="translated">Серьезно относясь к вопросу,следует выяснить,что способен познать типичный 6-летний подросток,хотя,по общему признанию,тот,кто интересуется JavaScript,не так уж и типичен.</target>
        </trans-unit>
        <trans-unit id="67cecda122884bfa553becae4c5685cfae2cbb5f" translate="yes" xml:space="preserve">
          <source>Technically, in &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt;, &lt;strong&gt;every function is a closure&lt;/strong&gt;. It always has an access to variables defined in the surrounding scope.</source>
          <target state="translated">Технически, в &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; &lt;strong&gt;каждая функция является замыканием&lt;/strong&gt; . Он всегда имеет доступ к переменным, определенным в окружающей области видимости.</target>
        </trans-unit>
        <trans-unit id="97cba4858411c435e526dd651157aac20178222c" translate="yes" xml:space="preserve">
          <source>Thanks</source>
          <target state="translated">Thanks</target>
        </trans-unit>
        <trans-unit id="30a5f96f9b652a33887df9866bf824d883055acd" translate="yes" xml:space="preserve">
          <source>That's all there is to tell.</source>
          <target state="translated">Это все,что можно сказать.</target>
        </trans-unit>
        <trans-unit id="ab6ae4b470ffe5a3279c44a289c97ea3536b0044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trashBags&lt;/code&gt; variable is local to the inside of each kitchen and is not accessible outside, but the inner function on the &lt;code&gt;getTrashBag&lt;/code&gt; property does have access to it.</source>
          <target state="translated">Переменная &lt;code&gt;trashBags&lt;/code&gt; является локальной для каждой кухни и недоступна снаружи, но внутренняя функция свойства &lt;code&gt;getTrashBag&lt;/code&gt; имеет к ней доступ.</target>
        </trans-unit>
        <trans-unit id="f4b0fe233c7b64030a0dc17c446f53a7aea9634c" translate="yes" xml:space="preserve">
          <source>The Straw Man</source>
          <target state="translated">Соломенный человек</target>
        </trans-unit>
        <trans-unit id="2ac247e683af2d84a6d9660b577f04e07e7d50da" translate="yes" xml:space="preserve">
          <source>The above code has a closure because the anonymous function &lt;code&gt;function() { console.log(text); }&lt;/code&gt; is declared &lt;em&gt;inside&lt;/em&gt; another function, &lt;code&gt;sayHello2()&lt;/code&gt; in this example. In JavaScript, if you use the &lt;code&gt;function&lt;/code&gt; keyword inside another function, you are creating a closure.</source>
          <target state="translated">Приведенный выше код имеет закрытие, потому что анонимная функция &lt;code&gt;function() { console.log(text); }&lt;/code&gt; } объявлен &lt;em&gt;внутри&lt;/em&gt; другой функции, скажем, в этом примере &lt;code&gt;sayHello2()&lt;/code&gt; . В JavaScript, если вы используете ключевое слово &lt;code&gt;function&lt;/code&gt; внутри другой функции, вы создаете замыкание.</target>
        </trans-unit>
        <trans-unit id="a663b8d54dfafcfe4011bff6acb1a1b012b29b90" translate="yes" xml:space="preserve">
          <source>The above function will also log 16, because the code inside &lt;code&gt;bar&lt;/code&gt; can still refer to argument &lt;code&gt;x&lt;/code&gt; and variable &lt;code&gt;tmp&lt;/code&gt;, even though it they are no longer directly in scope.</source>
          <target state="translated">Вышеприведенная функция также записывает 16, потому что код внутри &lt;code&gt;bar&lt;/code&gt; может ссылаться на аргумент &lt;code&gt;x&lt;/code&gt; и переменную &lt;code&gt;tmp&lt;/code&gt; , даже если они больше не находятся в области видимости.</target>
        </trans-unit>
        <trans-unit id="246fdc56b891ef8cd6ddc925b1d907069e7fc98a" translate="yes" xml:space="preserve">
          <source>The author of &lt;em&gt;&lt;a href=&quot;http://javascript.info/tutorial/closures&quot;&gt;Closures&lt;/a&gt;&lt;/em&gt; has explained closures pretty well, explaining the reason why we need them and also explaining LexicalEnvironment which is necessary to understanding closures.</source>
          <target state="translated">Автор &lt;em&gt;&lt;a href=&quot;http://javascript.info/tutorial/closures&quot;&gt;Closures&lt;/a&gt;&lt;/em&gt; довольно хорошо объяснил замыкания, объясняя причину, почему они нам нужны, а также объясняя LexicalEnvironment, что необходимо для понимания замыканий.</target>
        </trans-unit>
        <trans-unit id="c13d0c83e1140ef05df23d7d967fd539e97fac2a" translate="yes" xml:space="preserve">
          <source>The browser keeps the LexicalEnvironment and all its properties (variables) in memory until there is an inner function which references it.</source>
          <target state="translated">Браузер хранит в памяти LexicalEnvironment и все его свойства (переменные)до тех пор,пока не появится внутренняя функция,которая на него ссылается.</target>
        </trans-unit>
        <trans-unit id="ebab32e0d02219305bce1886d9e8f64ed8614c91" translate="yes" xml:space="preserve">
          <source>The chain of lexical environments, linked between execution contexts via outer environment references, forms a &lt;em&gt;scope chain&lt;/em&gt; and defines the identifiers visible from any given function.</source>
          <target state="translated">Цепочка лексических сред, связанная между контекстами выполнения посредством ссылок на внешнюю среду, образует &lt;em&gt;цепочку областей действия&lt;/em&gt; и определяет идентификаторы, видимые из любой данной функции.</target>
        </trans-unit>
        <trans-unit id="1f0b658a23c022351d31c0bee4a00408b17ba821" translate="yes" xml:space="preserve">
          <source>The children will always remember the secrets they have shared with their parents, even after their parents are
  gone. This is what closures are for functions.</source>
          <target state="translated">Дети всегда будут помнить секреты,которыми они поделились с родителями,даже после того,как их родители уйдут.Вот что такое замыкание для функций.</target>
        </trans-unit>
        <trans-unit id="d142ef727404c57948941e5ea1a82a1476684d84" translate="yes" xml:space="preserve">
          <source>The closures all know what the &lt;em&gt;sing()&lt;/em&gt; function's variable called &lt;em&gt;firstPart&lt;/em&gt; is, because they can see out from their tinted windows.</source>
          <target state="translated">Все замыкания знают, что такое переменная функции &lt;em&gt;sing ()&lt;/em&gt; под названием &lt;em&gt;firstPart&lt;/em&gt; , потому что они могут видеть из своих тонированных окон.</target>
        </trans-unit>
        <trans-unit id="bb0d2327de1953161942f2ab9fa838498aa1dbcb" translate="yes" xml:space="preserve">
          <source>The example above is using an anonymous function, which was executed once. But it does not have to be. It can be named (e.g. &lt;code&gt;mkdb&lt;/code&gt;) and executed later, generating a database function each time it is invoked. Every generated function will have its own hidden database object. Another usage example of closures is when we don't return a function, but an object containing multiple functions for different purposes, each of those function having access to the same data.</source>
          <target state="translated">В приведенном выше примере используется анонимная функция, которая была выполнена один раз. Но это не должно быть. Его можно назвать (например, &lt;code&gt;mkdb&lt;/code&gt; ) и выполнить позже, генерируя функцию базы данных каждый раз, когда она вызывается. Каждая сгенерированная функция будет иметь свой собственный скрытый объект базы данных. Другой пример использования замыканий - это когда мы не возвращаем функцию, а объект, содержащий несколько функций для разных целей, каждая из которых имеет доступ к одним и тем же данным.</target>
        </trans-unit>
        <trans-unit id="d752ad30dcb07b4bf12c76bcaf1fd95663e1c173" translate="yes" xml:space="preserve">
          <source>The following code returns a reference to a function:</source>
          <target state="translated">Следующий код возвращает ссылку на функцию:</target>
        </trans-unit>
        <trans-unit id="5215171b8fbe41f294967978f22f5060d88ee251" translate="yes" xml:space="preserve">
          <source>The following simple example covers all the main points of JavaScript closures.&lt;sup&gt;*&lt;/sup&gt;</source>
          <target state="translated">Следующий простой пример охватывает все основные моменты закрытия JavaScript. &lt;sup&gt;*&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ad531efca548a3919fa24597ab10762db1c48acd" translate="yes" xml:space="preserve">
          <source>The genius is that in JavaScript a function reference also has a secret reference to the closure it was created in &amp;mdash; similar to how delegates are a method pointer plus a secret reference to an object.</source>
          <target state="translated">Гениальность в том, что в JavaScript ссылка на функцию также имеет секретную ссылку на замыкание, в котором она была создана - подобно тому, как делегаты являются указателем метода плюс секретная ссылка на объект.</target>
        </trans-unit>
        <trans-unit id="45e0685cacab3e797413836c0a3b3870f011cdba" translate="yes" xml:space="preserve">
          <source>The inner function keeps a reference to the outer
LexicalEnvironment.</source>
          <target state="translated">Внутренняя функция сохраняет ссылку на внешнюю LexicalEnvironment.</target>
        </trans-unit>
        <trans-unit id="1222b712516a600e2c63dde997d35b726a9bade9" translate="yes" xml:space="preserve">
          <source>The inner function may access variables from it
any time even if the outer function is finished.</source>
          <target state="translated">Внутренняя функция может обращаться к переменным из нее в любое время,даже если внешняя функция закончена.</target>
        </trans-unit>
        <trans-unit id="0f440ed8885caea2f6a4de181d02ca1ce2bfd985" translate="yes" xml:space="preserve">
          <source>The kitchen is a closure that has a local variable, called &lt;code&gt;trashBags&lt;/code&gt;.  There is a function inside the kitchen called &lt;code&gt;getTrashBag&lt;/code&gt; that gets one trash bag and returns it.</source>
          <target state="translated">Кухня - это закрытие, которое имеет локальную переменную, называемую &lt;code&gt;trashBags&lt;/code&gt; . На кухне есть функция &lt;code&gt;getTrashBag&lt;/code&gt; , которая получает один мешок для мусора и возвращает его.</target>
        </trans-unit>
        <trans-unit id="e9eb91337dbe1342ddf4236b7c7460d616e8d494" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;result.push( function() {console.log(item + ' ' + list[i])}&lt;/code&gt; adds a reference to an anonymous function three times to the result array. If you are not so familiar with anonymous functions think of it like:</source>
          <target state="translated">Строка &lt;code&gt;result.push( function() {console.log(item + ' ' + list[i])}&lt;/code&gt; добавляет ссылку на анонимную функцию три раза в массив результатов. Если вы не очень знакомы с анонимными функциями, подумайте о это как:</target>
        </trans-unit>
        <trans-unit id="3719fe577c00cbcfb269ebde253db1c8de6cf36a" translate="yes" xml:space="preserve">
          <source>The process consists of two steps:</source>
          <target state="translated">Процесс состоит из двух этапов:</target>
        </trans-unit>
        <trans-unit id="a6b75fac7979ad9def4158f7b987a3aa8e383e53" translate="yes" xml:space="preserve">
          <source>The reason that referenceToInnerFunction can still access the value of outerVar is because when the closure was first created by placing innerFunction inside of outerFunction, innerFunction added a reference to outerFunction&amp;rsquo;s scope (its variables and functions) to its scope chain. What this means is that innerFunction has a pointer or reference to all of outerFunction&amp;rsquo;s variables, including outerVar. So even when outerFunction has finished executing, or even if it is deleted or set to null, the variables in its scope, like outerVar, stick around in memory because of the outstanding reference to them on the part of the innerFunction that has been returned to referenceToInnerFunction. To truly release outerVar and the rest of outerFunction&amp;rsquo;s variables from memory you would have to get rid of this outstanding reference to them, say by setting referenceToInnerFunction to null as well.</source>
          <target state="translated">Причина, по которой referenceToInnerFunction все еще может получить доступ к значению externalVar, заключается в том, что когда замыкание было впервые создано путем размещения innerFunction внутри externalFunction, innerFunction добавила ссылку на область действия externalFunction (ее переменные и функции) в свою цепочку областей действия. Это означает, что innerFunction имеет указатель или ссылку на все переменные externalFunction, включая externalVar. Таким образом, даже когда externalFunction завершит выполнение или даже если он удален или имеет значение null, переменные в его области видимости, такие как outerVar, останутся в памяти из-за выдающейся ссылки на них со стороны внутренней функции, которая была возвращена referenceToInnerFunction. Чтобы по-настоящему освободить externalVar и остальные переменные externalFunction из памяти, вам нужно избавиться от этой выдающейся ссылки на них, скажем, установив referenceToInnerFunction на ноль.</target>
        </trans-unit>
        <trans-unit id="a52ec855c305cdd424a0acec2f16c794668d3e11" translate="yes" xml:space="preserve">
          <source>The secrets for JavaScript functions are the private variables</source>
          <target state="translated">Секретом JavaScript-функций являются частные переменные.</target>
        </trans-unit>
        <trans-unit id="c8048ace855f36cfe6ec5f055971d3ab6080b70b" translate="yes" xml:space="preserve">
          <source>The simplest example of a closure is this:</source>
          <target state="translated">Самый простой пример закрытия:</target>
        </trans-unit>
        <trans-unit id="758516d667c0ca64ba31d36b4aa304b7d45c8074" translate="yes" xml:space="preserve">
          <source>The sing() function will call each of these functions in the order they are given. Then the sing() function's work will be done.</source>
          <target state="translated">Функция sing()вызовет каждую из этих функций в порядке их поступления.Затем будет выполнена работа функции sing().</target>
        </trans-unit>
        <trans-unit id="b2bfe35512d67b1120c27f2759f79e721a38d640" translate="yes" xml:space="preserve">
          <source>The three functions have shared access to the same closure &amp;mdash; the local variables of &lt;code&gt;setupSomeGlobals()&lt;/code&gt; when the three functions were defined.</source>
          <target state="translated">Три функции имеют общий доступ к одному и тому же замыканию - локальным переменным &lt;code&gt;setupSomeGlobals()&lt;/code&gt; когда были определены три функции.</target>
        </trans-unit>
        <trans-unit id="1683c5c3fdaabb276940a6471aab76eac2921b0e" translate="yes" xml:space="preserve">
          <source>There is a critical difference between a C pointer to a function and a JavaScript reference to a function. In JavaScript, you can think of a function reference variable as having both a pointer to a function &lt;em&gt;as well&lt;/em&gt; as a hidden pointer to a closure.</source>
          <target state="translated">Существует критическое различие между указателем C на функцию и ссылкой JavaScript на функцию. В JavaScript вы можете рассматривать переменную ссылки на функцию как имеющую как указатель на функцию, &lt;em&gt;так и&lt;/em&gt; скрытый указатель на замыкание.</target>
        </trans-unit>
        <trans-unit id="04637ad8e1b34b4d45e60aaea6b490192d004b6f" translate="yes" xml:space="preserve">
          <source>There is no reason to believe closures are a complex design hack to address specific problems. No, closures are just about using a variable that comes from a higher scope &lt;strong&gt;from the perspective of where the function was declared (not run)&lt;/strong&gt;.</source>
          <target state="translated">Нет никаких оснований полагать, что замыкания являются сложным конструктивным решением для решения конкретных проблем. Нет, замыкания - это просто использование переменной, которая приходит из более широкой области видимости &lt;strong&gt;с точки зрения того, где функция была объявлена ​​(не запущена)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="dc8da2d96ff3de796d0c72436a2ccd3f4dc18e12" translate="yes" xml:space="preserve">
          <source>There was a princess...</source>
          <target state="translated">Там была принцесса...</target>
        </trans-unit>
        <trans-unit id="7ee59ebacfd9d93a5dadb09b49abe5ed01b3d0c0" translate="yes" xml:space="preserve">
          <source>There you go; you're now fully encapsulating this behavior.</source>
          <target state="translated">Вот так,теперь ты полностью инкапсулируешь это поведение.</target>
        </trans-unit>
        <trans-unit id="f2e330c9ca939e298d2b5965f2b6b3e1b37e408b" translate="yes" xml:space="preserve">
          <source>This article is intended for programmers with some programming experience in a mainstream language, and who can read the following JavaScript function:</source>
          <target state="translated">Данная статья предназначена для программистов,имеющих некоторый опыт программирования на распространенном языке и умеющих читать следующую функцию JavaScript:</target>
        </trans-unit>
        <trans-unit id="4dd1925d9c601a5cbe75680ad2654c7234add57a" translate="yes" xml:space="preserve">
          <source>This creates a new scope and &lt;code&gt;n&lt;/code&gt; is bound to that scope; this means we have 10 separate scopes, one for each iteration.</source>
          <target state="translated">Это создает новую область, и &lt;code&gt;n&lt;/code&gt; привязывается к этой области; это означает, что у нас есть 10 отдельных областей, по одной на каждую итерацию.</target>
        </trans-unit>
        <trans-unit id="7552ddbeac58a09947a400d7a7ab0c7823e95f06" translate="yes" xml:space="preserve">
          <source>This example shows that the closure contains any local variables that were declared inside the outer function before it exited. Note that the variable &lt;code&gt;alice&lt;/code&gt; is actually declared after the anonymous function. The anonymous function is declared first and when that function is called it can access the &lt;code&gt;alice&lt;/code&gt; variable because &lt;code&gt;alice&lt;/code&gt; is in the same scope (JavaScript does &lt;a href=&quot;https://stackoverflow.com/a/3725763/1269037&quot;&gt;variable hoisting&lt;/a&gt;).
Also &lt;code&gt;sayAlice()()&lt;/code&gt; just directly calls the function reference returned from &lt;code&gt;sayAlice()&lt;/code&gt; &amp;mdash; it is exactly the same as what was done previously but without the temporary variable.</source>
          <target state="translated">В этом примере показано, что замыкание содержит все локальные переменные, которые были объявлены внутри внешней функции до ее выхода. Обратите внимание, что переменная &lt;code&gt;alice&lt;/code&gt; фактически объявляется после анонимной функции. Сначала анонимная функция объявляется, и когда эта функция вызывается, она может получить доступ к переменной &lt;code&gt;alice&lt;/code&gt; , потому что alice находится в той же области видимости (JavaScript выполняет &lt;a href=&quot;https://stackoverflow.com/a/3725763/1269037&quot;&gt;подъем переменной&lt;/a&gt; ). Также &lt;code&gt;sayAlice()()&lt;/code&gt; просто напрямую вызывает ссылку на функцию, возвращаемую из &lt;code&gt;sayAlice()&lt;/code&gt; - она ​​точно такая же, как и ранее, но без временной переменной.</target>
        </trans-unit>
        <trans-unit id="d1bbfb6c03415d46436720884428eece40742855" translate="yes" xml:space="preserve">
          <source>This example shows that the local variables are not copied &amp;mdash; they are kept by reference. It is as though the stack-frame stays alive in memory even after the outer function exits!</source>
          <target state="translated">Этот пример показывает, что локальные переменные не копируются - они хранятся по ссылке. Как будто стековый фрейм остается в памяти даже после выхода из внешней функции!</target>
        </trans-unit>
        <trans-unit id="cd052212f50f2244a372f8c3023bb7e1c19cf13f" translate="yes" xml:space="preserve">
          <source>This is an attempt to clear up several (possible) misunderstandings about closures that appear in some of the other answers.</source>
          <target state="translated">Это попытка прояснить некоторые (возможные)недоразумения по поводу закрытия,которые появляются в некоторых других ответах.</target>
        </trans-unit>
        <trans-unit id="789cc6e4df4d97f5dde344c2fdb9c85a7781a6d9" translate="yes" xml:space="preserve">
          <source>This is called a closure.</source>
          <target state="translated">Это называется закрытием.</target>
        </trans-unit>
        <trans-unit id="d2b023972a185beed0da123eeebf515f35e6bed3" translate="yes" xml:space="preserve">
          <source>This line is calling the function, as if it were calling a dog</source>
          <target state="translated">Эта линия вызывает функцию,как будто она вызывает собаку.</target>
        </trans-unit>
        <trans-unit id="2e4d80d915cf259f32a4c6b7797dea00eab65b84" translate="yes" xml:space="preserve">
          <source>This one is a real gotcha for many people, so you need to understand it. Be very careful if you are defining a function within a loop: the local variables from the closure may not act as you might first think.</source>
          <target state="translated">Эта-настоящая добыча для многих людей,так что тебе нужно ее понять.Будьте очень осторожны,если вы определяете функцию в цикле:локальные переменные после закрытия могут действовать не так,как вы могли бы подумать.</target>
        </trans-unit>
        <trans-unit id="da5cb87fcafafecdacdfe6ed51e0a0d4f98b7585" translate="yes" xml:space="preserve">
          <source>This page explains closures so that a programmer can understand them &amp;mdash; using working JavaScript code. It is not for gurus or functional programmers.</source>
          <target state="translated">Эта страница объясняет замыкания, чтобы программист мог их понять - используя рабочий код JavaScript. Это не для гуру или функциональных программистов.</target>
        </trans-unit>
        <trans-unit id="b8bdefd19ecf3066cd4728c72ff52ab6024d11aa" translate="yes" xml:space="preserve">
          <source>This will log &lt;code&gt;16&lt;/code&gt;, because function &lt;code&gt;bar&lt;/code&gt; closes over the parameter &lt;code&gt;x&lt;/code&gt; and the variable &lt;code&gt;tmp&lt;/code&gt;, both of which exist in the lexical environment of outer function &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Это будет записывать &lt;code&gt;16&lt;/code&gt; , потому что функциональная &lt;code&gt;bar&lt;/code&gt; закрывается над параметром &lt;code&gt;x&lt;/code&gt; и переменной &lt;code&gt;tmp&lt;/code&gt; , которые существуют в лексической среде внешней функции &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e28adc0562a325e3e096fedb43aec2bcfc26cc2" translate="yes" xml:space="preserve">
          <source>To summarize:</source>
          <target state="translated">Подводя итог:</target>
        </trans-unit>
        <trans-unit id="185cffe022e026a4122cc13897f61794b5e49d80" translate="yes" xml:space="preserve">
          <source>Tricky: note the &lt;code&gt;say&lt;/code&gt; variable is also inside the closure and could be accessed by any other function that might be declared within &lt;code&gt;sayAlice()&lt;/code&gt;, or it could be accessed recursively within the inside function.</source>
          <target state="translated">Заметим: обратите внимание, &lt;code&gt;say&lt;/code&gt; переменная say также находится внутри замыкания и может быть доступна любой другой функции, которая может быть объявлена ​​в &lt;code&gt;sayAlice()&lt;/code&gt; , или к ней можно получить доступ рекурсивно внутри внутренней функции.</target>
        </trans-unit>
        <trans-unit id="7738f68d43c61aa58c8d9b9546acdd53ba567dbc" translate="yes" xml:space="preserve">
          <source>Two brief summaries</source>
          <target state="translated">Два кратких резюме</target>
        </trans-unit>
        <trans-unit id="43a5562bc755854b701217c3e2cea0041b6a10df" translate="yes" xml:space="preserve">
          <source>Two functions might look like they have the same source text, but have completely different behavior because of their 'hidden' closure. I don't think JavaScript code can actually find out if a function reference has a closure or not.</source>
          <target state="translated">Две функции могут выглядеть так,как будто они имеют один и тот же исходный текст,но имеют совершенно разное поведение из-за их &quot;скрытого&quot; закрытия.Я не думаю,что JavaScript-код на самом деле может узнать,есть ли у ссылки на функцию закрытие или нет.</target>
        </trans-unit>
        <trans-unit id="b6e33fa589c38cb3d120879b99ebe9f6503bd521" translate="yes" xml:space="preserve">
          <source>Two other things about closures to note. First, the closure will always have access to the last values of its containing function.</source>
          <target state="translated">Еще две вещи насчет закрытия.Во-первых,закрытие всегда будет иметь доступ к последним значениям функции,содержащей его.</target>
        </trans-unit>
        <trans-unit id="9c977033015ef8f81efe5ec1a386949630df27f5" translate="yes" xml:space="preserve">
          <source>VARIABLE: The letters &lt;em&gt;var&lt;/em&gt; stand for &quot;variable&quot;. A variable is like an envelope. On the outside this envelope is marked &quot;person&quot;. On the inside it contains a slip of paper with the information our function needs, some letters and spaces joined together like a piece of string (it's called a string) that make a phrase reading &quot;an old lady&quot;. Our envelope could contain other kinds of things like numbers (called integers), instructions (called functions), lists (called &lt;em&gt;arrays&lt;/em&gt;). Because this variable is written outside of all the braces &lt;code&gt;{}&lt;/code&gt;, and because you can see out through the tinted windows when you are inside the braces, this variable can be seen from anywhere in the code. We call this a 'global variable'.</source>
          <target state="translated">VARIABLE: буквы &lt;em&gt;var&lt;/em&gt; означают &amp;laquo;переменная&amp;raquo;. Переменная похожа на конверт. Снаружи этот конверт помечен как &amp;laquo;человек&amp;raquo;. Внутри он содержит листок бумаги с информацией, которая нужна нашей функции, некоторые буквы и пробелы, соединенные вместе, как кусок строки (это называется строкой), которые делают фразу, читающую &amp;laquo;старуху&amp;raquo;. Наш конверт может содержать другие виды вещей, такие как числа (называемые целыми числами), инструкции (называемые функциями), списки (называемые &lt;em&gt;массивами&lt;/em&gt; ). Поскольку эта переменная записана вне всех фигурных скобок &lt;code&gt;{}&lt;/code&gt; , и поскольку вы можете видеть сквозь тонированные окна, когда находитесь внутри фигурных скобок, эту переменную можно увидеть из любого места в коде. Мы называем это &amp;laquo;глобальной переменной&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="0a3b4dd6c2b81d0408e62dc4b0c7d9aa719858b8" translate="yes" xml:space="preserve">
          <source>We can code this in JavaScript like this:</source>
          <target state="translated">Мы можем кодировать это на JavaScript вот так:</target>
        </trans-unit>
        <trans-unit id="0dd5ca9fc457449d5a7438bfa95e87b689ade82a" translate="yes" xml:space="preserve">
          <source>We can use this example to explain closures, as follows:</source>
          <target state="translated">Мы можем использовать этот пример для объяснения закрытия следующим образом:</target>
        </trans-unit>
        <trans-unit id="cfb7d9f151f2ce139f3a16a6d13ee0a6d6a9272b" translate="yes" xml:space="preserve">
          <source>What if a variable is accessed, but it isn&amp;rsquo;t local? Like here:</source>
          <target state="translated">Что если к переменной обращаются, но она не локальная? Как здесь:</target>
        </trans-unit>
        <trans-unit id="1e8f90f12d65d0d31eedfa442526261ad87df2b7" translate="yes" xml:space="preserve">
          <source>What might not be obvious is that since &lt;code&gt;createClosureArray()&lt;/code&gt; is only invoked once only one scope is created for this function instead of one for every iteration of the loop.</source>
          <target state="translated">Что может быть неочевидным, так это то, что &lt;code&gt;createClosureArray()&lt;/code&gt; вызывается только после того, как для этой функции создается только одна область видимости, а не одна для каждой итерации цикла.</target>
        </trans-unit>
        <trans-unit id="082f7b2b11f91eb896764f16c3c56d45e4ee7ca7" translate="yes" xml:space="preserve">
          <source>What would happen here if JavaScript &lt;em&gt;didn't&lt;/em&gt; know closures? Just replace the call in the last line by its method body (which is basically what function calls do) and you get:</source>
          <target state="translated">Что бы произошло здесь, если бы JavaScript &lt;em&gt;не&lt;/em&gt; знал замыканий? Просто замените вызов в последней строке на тело метода (что в основном и делают вызовы функций), и вы получите:</target>
        </trans-unit>
        <trans-unit id="0d4abbfdfc801f0827fc6f8072079568d1427247" translate="yes" xml:space="preserve">
          <source>When a JavaScript function is invoked, a new execution context &lt;code&gt;ec&lt;/code&gt; is created. Together with the function arguments and the target object, this execution context also receives a link to the lexical environment of the calling execution context, meaning the variables declared in the outer lexical environment (in the above example, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;) are available from &lt;code&gt;ec&lt;/code&gt;.</source>
          <target state="translated">Когда вызывается функция JavaScript, создается новый контекст выполнения &lt;code&gt;ec&lt;/code&gt; . Вместе с аргументами функции и целевым объектом этот контекст выполнения также получает ссылку на лексическую среду вызывающего контекста выполнения, то есть переменные, объявленные во внешней лексической среде (в приведенном выше примере и &lt;code&gt;a&lt;/code&gt; , и &lt;code&gt;b&lt;/code&gt; ) доступны из &lt;code&gt;ec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7551a120ee1e0a45d0b5cf36770825ae08a23f1" translate="yes" xml:space="preserve">
          <source>When a function (&lt;code&gt;foo&lt;/code&gt;) declares other functions (bar and baz), the family of local variables created in &lt;code&gt;foo&lt;/code&gt; is &lt;em&gt;not destroyed&lt;/em&gt; when the function exits. The variables merely become invisible to the outside world. &lt;code&gt;foo&lt;/code&gt; can therefore cunningly return the functions &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt;, and they can continue to read, write and communicate with each other through this closed-off family of variables (&quot;the closure&quot;) that nobody else can meddle with, not even someone who calls &lt;code&gt;foo&lt;/code&gt; again in future.</source>
          <target state="translated">Когда функция ( &lt;code&gt;foo&lt;/code&gt; ) объявляет другие функции (bar и baz), семейство локальных переменных, созданных в &lt;code&gt;foo&lt;/code&gt; , &lt;em&gt;не уничтожается&lt;/em&gt; при выходе из функции. Переменные просто становятся невидимыми для внешнего мира. Поэтому &lt;code&gt;foo&lt;/code&gt; может хитро вернуть функции &lt;code&gt;bar&lt;/code&gt; и &lt;code&gt;baz&lt;/code&gt; , и они могут продолжать читать, писать и общаться друг с другом через это закрытое семейство переменных (&amp;laquo;замыкание&amp;raquo;), с которыми никто не может вмешиваться, даже тот, кто вызывает &lt;code&gt;foo&lt;/code&gt; снова в будущем.</target>
        </trans-unit>
        <trans-unit id="a14a687cf5a4767a5c232cb3c825bc777cc5955b" translate="yes" xml:space="preserve">
          <source>When a function is created, it gets a hidden property, named [[Scope]], which references the current LexicalEnvironment.</source>
          <target state="translated">При создании функции она получает скрытое свойство с именем [[Scope]],которое ссылается на текущее LexicalEnvironment.</target>
        </trans-unit>
        <trans-unit id="af97d2eb165c46e20d5beb31d9f67783d9ae76ed" translate="yes" xml:space="preserve">
          <source>When a function is invoked via the internal &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist&quot;&gt;&lt;code&gt;[[Call]]&lt;/code&gt;&lt;/a&gt; method, the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt;&lt;code&gt;[[Environment]]&lt;/code&gt;&lt;/a&gt; reference on the function-object is copied into the &lt;em&gt;outer environment reference&lt;/em&gt; of the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records&quot;&gt;environment record&lt;/a&gt; of the newly-created &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;execution context&lt;/a&gt; (stack frame).</source>
          <target state="translated">Когда функция вызывается через внутренний метод &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist&quot;&gt; &lt;code&gt;[[Call]]&lt;/code&gt; &lt;/a&gt; , ссылка &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt; &lt;code&gt;[[Environment]]&lt;/code&gt; &lt;/a&gt; на объект-функцию копируется во &lt;em&gt;внешнюю ссылку&lt;/em&gt; &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records&quot;&gt;среды записи среды&lt;/a&gt; вновь созданного &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;контекста выполнения&lt;/a&gt; (стековый фрейм).</target>
        </trans-unit>
        <trans-unit id="eda8d0ba8c86f2bcc7f89824f85d577c09f72064" translate="yes" xml:space="preserve">
          <source>When the browser has loaded the JavaScript code an reached this line, it will start the function. I put the line at the end to make sure that the browser has all the information it needs to run it.</source>
          <target state="translated">Когда браузер загрузит JavaScript-код,достигший этой строки,он запустит функцию.Я ставлю строку в конец,чтобы убедиться,что в браузере есть вся информация,необходимая для его запуска.</target>
        </trans-unit>
        <trans-unit id="656c8142287a1690f7f3625f825e5d62a85448e1" translate="yes" xml:space="preserve">
          <source>When the user clicks the VoteUp button, the voteUp_click function checks whether isVotedDown == true to determine whether to vote up or merely cancel a down vote. Function voteUp_click is a closure because it is accessing its environment.</source>
          <target state="translated">Когда пользователь нажимает кнопку VoteUp,функция voteUp_click проверяет,isVotedDown ==true,чтобы определить,стоит ли голосовать вверх или просто отменить голос вниз.Функция voteUp_click является завершающей,так как обращается к своему окружению.</target>
        </trans-unit>
        <trans-unit id="6df579e2161f6eb523745bff56a56ef486a46f72" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;new Function(&amp;hellip;)&lt;/code&gt; (the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function&quot;&gt;Function constructor&lt;/a&gt;) inside a function, it does not close over its lexical environment: it closes over the global context instead. (The new function cannot reference the local variables of the outer function.)</source>
          <target state="translated">Когда вы используете &lt;code&gt;new Function(&amp;hellip;)&lt;/code&gt; ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function&quot;&gt;конструктор функции&lt;/a&gt; ) внутри функции, она не закрывается в своей лексической среде: вместо этого она закрывается в глобальном контексте. (Новая функция не может ссылаться на локальные переменные внешней функции.)</target>
        </trans-unit>
        <trans-unit id="fc1b188972939bb322463b13d9e6d79ec73b22c6" translate="yes" xml:space="preserve">
          <source>Whenever a function is declared in JavaScript a closure is created.</source>
          <target state="translated">Всякий раз,когда функция объявляется в JavaScript,создается закрытие.</target>
        </trans-unit>
        <trans-unit id="42d771d468376a7581a6ea18362bea86ddcf67ad" translate="yes" xml:space="preserve">
          <source>Whenever you use &lt;code&gt;eval()&lt;/code&gt; inside a function, a closure is used. The text you &lt;code&gt;eval&lt;/code&gt; can reference local variables of the function, and within &lt;code&gt;eval&lt;/code&gt; you can even create new local variables by using &lt;code&gt;eval('var foo = &amp;hellip;')&lt;/code&gt;</source>
          <target state="translated">Всякий раз, когда вы используете &lt;code&gt;eval()&lt;/code&gt; внутри функции, используется замыкание. Текст, который вы используете, может ссылаться на локальные переменные функции, а в &lt;code&gt;eval&lt;/code&gt; вы даже можете создавать новые локальные переменные, используя &lt;code&gt;eval('var foo = &amp;hellip;')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68b3446fbf7d6fb0e4c451a7d1ae63e9f388e484" translate="yes" xml:space="preserve">
          <source>Within each scope &lt;code&gt;n&lt;/code&gt; is bound to whatever value it had when &lt;code&gt;createClosure(n)&lt;/code&gt; was invoked so the nested function that gets returned will always return the value of &lt;code&gt;n&lt;/code&gt; that it had when &lt;code&gt;createClosure(n)&lt;/code&gt; was invoked.</source>
          <target state="translated">В каждой области видимости &lt;code&gt;n&lt;/code&gt; связан с любым значением, которое было у него при &lt;code&gt;createClosure(n)&lt;/code&gt; поэтому возвращаемая вложенная функция всегда будет возвращать значение &lt;code&gt;n&lt;/code&gt; , которое было при &lt;code&gt;createClosure(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3685d63e9253161c4b5418f6dbd94db0b7b6fc6" translate="yes" xml:space="preserve">
          <source>Within this function a variable named &lt;code&gt;index&lt;/code&gt; is defined. The loop runs and adds functions to the array that return &lt;code&gt;index&lt;/code&gt;. Note that &lt;code&gt;index&lt;/code&gt; is defined within the &lt;code&gt;createClosureArray&lt;/code&gt; function which only ever gets invoked one time.</source>
          <target state="translated">Внутри этой функции определяется переменная с именем &lt;code&gt;index&lt;/code&gt; . Цикл запускается и добавляет в массив функции, которые возвращают &lt;code&gt;index&lt;/code&gt; . Обратите внимание, что &lt;code&gt;index&lt;/code&gt; определен внутри функции &lt;code&gt;createClosureArray&lt;/code&gt; , которая вызывается только один раз.</target>
        </trans-unit>
        <trans-unit id="6930e04d92d01fa662d11df5aa5d0e9bd5d8f5f8" translate="yes" xml:space="preserve">
          <source>Yes. You probably use that many times a day.</source>
          <target state="translated">Да.Ты,наверное,используешь это много раз в день.</target>
        </trans-unit>
        <trans-unit id="d579fab7eac666a9836aa39e6b35da201bfec6ea" translate="yes" xml:space="preserve">
          <source>You know how grown-ups can own a house, and they call it home? When a mom has a child, the child doesn't really own anything, right? But its parents own a house, so whenever someone asks the child &quot;Where's your home?&quot;, he/she can answer &quot;that house!&quot;, and point to the house of its parents. A &quot;Closure&quot; is the ability of the child to always (even if abroad) be able to say it has a home, even though it's really the parent's who own the house.</source>
          <target state="translated">Ты знаешь,как взрослые могут владеть домом,и они называют его домом? Когда у мамы есть ребёнок,у ребёнка на самом деле ничего нет,верно? Но его родители владеют домом,поэтому всякий раз,когда кто-то спрашивает ребенка:&quot;Где твой дом?&quot;,он может ответить &quot;этот дом!&quot; и указать на дом его родителей.Замыкание&quot;-это способность ребенка всегда (даже за границей)быть в состоянии сказать,что у него есть дом,хотя на самом деле дом принадлежит его родителям.</target>
        </trans-unit>
        <trans-unit id="f95a097c531667e7c2a6ae971917615f399a2b1d" translate="yes" xml:space="preserve">
          <source>You need to understand the &quot;variable hoisting&quot; feature in Javascript in order to understand this example.</source>
          <target state="translated">Чтобы понять этот пример,необходимо понимать функцию &quot;подъем переменных&quot; в Javascript.</target>
        </trans-unit>
        <trans-unit id="12fa562f7e0a2d3533b4af8a1d5c7d14b86a0f78" translate="yes" xml:space="preserve">
          <source>You're having a sleep over and you invite Dan.
You tell Dan to bring one XBox controller.</source>
          <target state="translated">Ты переночеваешь и приглашаешь Дэна.Скажи Дэну,чтобы принёс один XBox-контроллер.</target>
        </trans-unit>
        <trans-unit id="0a0db21e6a13f3e33a5d7e7ef217b86c21a634c3" translate="yes" xml:space="preserve">
          <source>Your child will be able to follow two-step directions. For example, if you say to your child, &quot;Go to the kitchen and get me a trash bag&quot; they will be able to remember that direction.</source>
          <target state="translated">Ваш ребенок сможет следовать двухшаговым инструкциям.Например,если Вы скажете Вашему ребенку:&quot;Идите на кухню и принесите мне мусорный пакет&quot;,он сможет запомнить это направление.</target>
        </trans-unit>
        <trans-unit id="65d09cbca9a2110fcca151e4c7f0c0fb68f6c5eb" translate="yes" xml:space="preserve">
          <source>anything in outer functions</source>
          <target state="translated">все что угодно в наружных функциях</target>
        </trans-unit>
        <trans-unit id="ebf5cf1386d90514706786d86faa965c625f69a5" translate="yes" xml:space="preserve">
          <source>button or look at the Options settings to open the developer console of a browser and type &quot;person&quot; to see what this value is. Type &lt;code&gt;person=&quot;a young man&quot;&lt;/code&gt; to change it and then type &quot;person&quot; again to see that it has changed.</source>
          <target state="translated">Нажмите кнопку или посмотрите настройки параметров, чтобы открыть консоль разработчика браузера, и наберите &amp;laquo;person&amp;raquo;, чтобы увидеть, что это за значение. Введите &lt;code&gt;person=&quot;a young man&quot;&lt;/code&gt; чтобы изменить его, а затем снова введите &quot;person&quot;, чтобы увидеть, что оно изменилось.</target>
        </trans-unit>
        <trans-unit id="a253f2310ab98afd2ae5163409dd162753885015" translate="yes" xml:space="preserve">
          <source>ems</source>
          <target state="translated">ems</target>
        </trans-unit>
        <trans-unit id="18c4aadf416cf320b65098f9eaf67f9101b6b90e" translate="yes" xml:space="preserve">
          <source>globals, including the DOM</source>
          <target state="translated">шаровидные устройства,включая МДУ</target>
        </trans-unit>
        <trans-unit id="4f7d81389762366c131edcfc1778acc037b192e4" translate="yes" xml:space="preserve">
          <source>n = 0</source>
          <target state="translated">n=0</target>
        </trans-unit>
        <trans-unit id="92ee913214330816c21ed1490df01843b5cb2075" translate="yes" xml:space="preserve">
          <source>n = 1</source>
          <target state="translated">n=1</target>
        </trans-unit>
        <trans-unit id="ac48f9f7795484b3747139f0e4cb0790db58945a" translate="yes" xml:space="preserve">
          <source>n = 10</source>
          <target state="translated">n=10</target>
        </trans-unit>
        <trans-unit id="9a3240ad86b2b1d076825686aaf98565beeaac04" translate="yes" xml:space="preserve">
          <source>n = 2</source>
          <target state="translated">n=2</target>
        </trans-unit>
        <trans-unit id="5c515985c0cd23c7519d06977a9d6767394ced82" translate="yes" xml:space="preserve">
          <source>n = 3</source>
          <target state="translated">n=3</target>
        </trans-unit>
        <trans-unit id="83402797555a7a7885fe6185251ac997c92f242d" translate="yes" xml:space="preserve">
          <source>n = 4</source>
          <target state="translated">n=4</target>
        </trans-unit>
        <trans-unit id="adb8f164b2e9a9a073815a5580b5848dc5c47b6f" translate="yes" xml:space="preserve">
          <source>n = 5</source>
          <target state="translated">n=5</target>
        </trans-unit>
        <trans-unit id="6fec459a8cd8a34f975e728d91238f3f70ad3b48" translate="yes" xml:space="preserve">
          <source>n = 6</source>
          <target state="translated">n=6</target>
        </trans-unit>
        <trans-unit id="fd8cf86ee6124bea277fbfcdf77a50b8452d4005" translate="yes" xml:space="preserve">
          <source>n = 7</source>
          <target state="translated">n=7</target>
        </trans-unit>
        <trans-unit id="f0f1184215b3e3a06534b7ea7b8d947bb19c606d" translate="yes" xml:space="preserve">
          <source>n = 8</source>
          <target state="translated">n=8</target>
        </trans-unit>
        <trans-unit id="2cdacf2d84f0a2faf20a870a9028c14e3ea19dd0" translate="yes" xml:space="preserve">
          <source>n = 9</source>
          <target state="translated">n=9</target>
        </trans-unit>
        <trans-unit id="435cb10a0d15e1b9ac626e4505828ceeac244444" translate="yes" xml:space="preserve">
          <source>referenceToInnerFunction is set to outerFunction(), which simply returns a reference to innerFunction. When referenceToInnerFunction is called, it returns outerVar. Again, as above, this demonstrates that innerFunction has access to outerVar, a variable of outerFunction. Furthermore, it is interesting to note that it retains this access even after outerFunction has finished executing.</source>
          <target state="translated">referenceToInnerFunction устанавливается в значение outerFunction(),которая просто возвращает ссылку на функцию innerFunction.При вызове функции referenceToInnerFunction она возвращает outerVar.Опять же,как и выше,это показывает,что функция innerFunction имеет доступ к outerVar,переменной outerFunction.Более того,интересно отметить,что она сохраняет этот доступ даже после завершения выполнения outerFunction.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
