<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/111102">
    <body>
      <group id="111102">
        <trans-unit id="edc3d87bc0d77451b24b00c1cf3016bdb95e72af" translate="yes" xml:space="preserve">
          <source>&quot;Come on &lt;em&gt;sing&lt;/em&gt;, Come and get &lt;em&gt;person&lt;/em&gt;!&quot;</source>
          <target state="translated">&quot;&amp;iexcl;Vamos, &lt;em&gt;canta&lt;/em&gt; , ven a buscar &lt;em&gt;persona&lt;/em&gt; !&quot;</target>
        </trans-unit>
        <trans-unit id="7dd20ec9bc8964ce1c79283c85999cad1cee4dac" translate="yes" xml:space="preserve">
          <source>...is really a princess with a little girl inside.</source>
          <target state="translated">...es en realidad una princesa con una niña pequeña dentro.</target>
        </trans-unit>
        <trans-unit id="103badd33a2698b99355a3659479f625c4c33efa" translate="yes" xml:space="preserve">
          <source>...telling stories about magic and fantasy.</source>
          <target state="translated">...contando historias sobre magia y fantasía.</target>
        </trans-unit>
        <trans-unit id="dd3acb8afd097803b9360b2f69c1fea1de5f28bb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Closure_(computer_science)&quot;&gt;Wikipedia on closures&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Closure_(computer_science)&quot;&gt;Wikipedia sobre cierres&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="66795f475c16753ced57a004591a7e32d1be97f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createClosure(n)&lt;/code&gt; returns a function that returns the n within that scope.</source>
          <target state="translated">&lt;code&gt;createClosure(n)&lt;/code&gt; devuelve una funci&amp;oacute;n que devuelve el n dentro de ese &amp;aacute;mbito.</target>
        </trans-unit>
        <trans-unit id="0605c773a855ad7752167561fff57f3ec27930c0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you are familiar with stack frames, these calculators seem strange: How can they keep accessing &lt;code&gt;n&lt;/code&gt; after &lt;code&gt;make_calculator&lt;/code&gt; returns?  The answer is to imagine that JavaScript doesn't use &quot;stack frames&quot;, but instead uses &quot;heap frames&quot;, which can persist after the function call that made them returns.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Si est&amp;aacute; familiarizado con los marcos de pila, estas calculadoras parecen extra&amp;ntilde;as: &amp;iquest;c&amp;oacute;mo pueden seguir accediendo a &lt;code&gt;n&lt;/code&gt; despu&amp;eacute;s de que vuelve &lt;code&gt;make_calculator&lt;/code&gt; ?&lt;/em&gt; &lt;em&gt;La respuesta es imaginar que JavaScript no usa &quot;marcos de pila&quot;, sino que usa &quot;marcos de mont&amp;oacute;n&quot;, que pueden persistir despu&amp;eacute;s de la llamada a la funci&amp;oacute;n que los hizo regresar.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f02b4fea2cc85281d187a2a3101725f3bd466ca9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that &lt;code&gt;/*...*/&lt;/code&gt; and &lt;code&gt;//&lt;/code&gt; stop code being read by the browser.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Tenga en cuenta que &lt;code&gt;/*...*/&lt;/code&gt; y &lt;code&gt;//&lt;/code&gt; detienen el c&amp;oacute;digo que lee el navegador.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11d4db30148058831981cd0f151cdbbc17e172a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://jondavidjohn.com/javascript-closure-explained-using-events/&quot;&gt;Full Blog Post&lt;/a&gt;&lt;/strong&gt; (including jQuery considerations)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://jondavidjohn.com/javascript-closure-explained-using-events/&quot;&gt;Publicaci&amp;oacute;n de blog completa&lt;/a&gt;&lt;/strong&gt; (incluidas las consideraciones de jQuery)</target>
        </trans-unit>
        <trans-unit id="2184405757c5883c445a99418ddb1a5ee63000ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A closure does not reference a copy of the &lt;em&gt;old values&lt;/em&gt; of variables in its scope.&lt;/strong&gt; The variables themselves are part of the closure, and so the value seen when accessing one of those variables is the latest value at the time it is accessed. This is why inner functions created inside of loops can be tricky, since each one has access to the same outer variables rather than grabbing a copy of the variables at the time the function is created or called.</source>
          <target state="translated">&lt;strong&gt;Un cierre no hace referencia a una copia de los &lt;em&gt;valores antiguos&lt;/em&gt; de las variables en su alcance.&lt;/strong&gt; Las variables en s&amp;iacute; mismas son parte del cierre, por lo que el valor visto al acceder a una de esas variables es el &amp;uacute;ltimo valor en el momento en que se accede. Esta es la raz&amp;oacute;n por la cual las funciones internas creadas dentro de los bucles pueden ser complicadas, ya que cada una tiene acceso a las mismas variables externas en lugar de tomar una copia de las variables en el momento en que se crea o se llama a la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fca46227ced34fb88ba8cfe8076a5166aafd4927" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A closure is not only created when you return an inner function.&lt;/strong&gt; In fact, the enclosing function &lt;em&gt;does not need to return at all&lt;/em&gt; in order for its closure to be created. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be called immediately or any time later. Therefore, the closure of the enclosing function is probably created &lt;em&gt;as soon as the enclosing function is called&lt;/em&gt; since any inner function has access to that closure whenever the inner function is called, before or after the enclosing function returns.</source>
          <target state="translated">&lt;strong&gt;Un cierre no solo se crea cuando devuelve una funci&amp;oacute;n interna.&lt;/strong&gt; De hecho, la funci&amp;oacute;n de cierre &lt;em&gt;no necesita regresar&lt;/em&gt; para que se cree su cierre. En su lugar, puede asignar su funci&amp;oacute;n interna a una variable en un &amp;aacute;mbito externo, o pasarla como argumento a otra funci&amp;oacute;n donde pueda llamarse de inmediato o en cualquier momento posterior. Por lo tanto, el cierre de la funci&amp;oacute;n de cierre probablemente se crea &lt;em&gt;tan pronto como se llama a&lt;/em&gt; la funci&amp;oacute;n de cierre ya que cualquier funci&amp;oacute;n interna tiene acceso a ese cierre cada vez que se llama a la funci&amp;oacute;n interna, antes o despu&amp;eacute;s de que regrese la funci&amp;oacute;n de cierre.</target>
        </trans-unit>
        <trans-unit id="00219869d9055a1e27de043a26f737d91e3bf84a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A simple one-line closure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Un simple cierre de una l&amp;iacute;nea&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="91cf9ee5cd212f0f8bb3975b7361624cdd8591da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures are simple:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Los cierres son simples:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="250c978ae2221ba3664641f80c30d217a35cbabd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures use memory, but they don't cause memory leaks&lt;/strong&gt; since JavaScript by itself cleans up its own circular structures that are not referenced. Internet&amp;nbsp;Explorer memory leaks involving closures are created when it fails to disconnect DOM attribute values that reference closures, thus maintaining references to possibly circular structures.</source>
          <target state="translated">&lt;strong&gt;Los cierres usan memoria, pero no causan p&amp;eacute;rdidas de memoria&lt;/strong&gt; ya que JavaScript por s&amp;iacute; solo limpia sus propias estructuras circulares a las que no se hace referencia. Las p&amp;eacute;rdidas de memoria de Internet Explorer que involucran cierres se crean cuando no se desconectan los valores de los atributos DOM que hacen referencia a los cierres, manteniendo as&amp;iacute; referencias a estructuras posiblemente circulares.</target>
        </trans-unit>
        <trans-unit id="39211d5634ba3cd86a1dc857711c0d8ac86b5585" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Closures&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d15f24a4f0cd805269e16daabf51293fb70abdd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Details&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Details&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e10d41f97175e0e801260eba2b8480649a3edd17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I do not understand why the answers are so complex here.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;No entiendo por qu&amp;eacute; las respuestas son tan complejas aqu&amp;iacute;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a50ab2a11da4fccbf9d1c29ea600ffcd387ddf7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;INSTRUCTIONS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;INSTRUCTIONS&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ff1823b9f3f4a4211cd7c4e7170f0588c83d10b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nested functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Funciones anidadas&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53afa8789f0371667bc4398726df5e5b35cd9345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Once upon a time:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&amp;Eacute;rase una vez:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f67d2cba0fc9f06b1b71e8974beb527b1d446b34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note that in an attempt to improve clarity and accuracy, this answer has been substantially changed from the original.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Tenga en cuenta que, en un intento por mejorar la claridad y la precisi&amp;oacute;n, esta respuesta ha cambiado sustancialmente con respecto a la original.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dfa0bbb5599405ba4b579ca14868a26d8d25c5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THE LONG CODE EXAMPLE ABOVE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EL EJEMPLO DE C&amp;Oacute;DIGO LARGO ANTERIOR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0def28abff50b5453af5effe03f21c319e75a393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5d4cedc50da37d6975ca1e41fe4dc499b53f427" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;That is pretty much all there is to closures.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Eso es pr&amp;aacute;cticamente todo lo que hay para los cierres.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e361521851a8d0097ea1590fec832e52c6bc93db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &quot;variables&quot; in a closure include any named functions&lt;/strong&gt; declared within the function. They also include arguments of the function. A closure also has access to its containing closure's variables, all the way up to the global scope.</source>
          <target state="translated">&lt;strong&gt;Las &quot;variables&quot; en un cierre incluyen cualquier funci&amp;oacute;n nombrada&lt;/strong&gt; declarada dentro de la funci&amp;oacute;n. Tambi&amp;eacute;n incluyen argumentos de la funci&amp;oacute;n. Un cierre tambi&amp;eacute;n tiene acceso a las variables de cierre que lo contienen, hasta el alcance global.</target>
        </trans-unit>
        <trans-unit id="4531071f03fc0a5d3c0274d7c65683c8b80868b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key point:&lt;/strong&gt; Each call to &lt;code&gt;make_calculator&lt;/code&gt; creates a new local variable &lt;code&gt;n&lt;/code&gt;, which continues to be usable by that calculator's &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt; functions long after &lt;code&gt;make_calculator&lt;/code&gt; returns.</source>
          <target state="translated">&lt;strong&gt;El punto clave:&lt;/strong&gt; cada llamada a &lt;code&gt;make_calculator&lt;/code&gt; crea una nueva variable local &lt;code&gt;n&lt;/code&gt; , que contin&amp;uacute;a siendo utilizable por las funciones de &lt;code&gt;add&lt;/code&gt; y &lt;code&gt;multiply&lt;/code&gt; esa calculadora mucho despu&amp;eacute;s de que &lt;code&gt;make_calculator&lt;/code&gt; regrese.</target>
        </trans-unit>
        <trans-unit id="c2f004a18b07e1ba3d927ea9c5aa182e662f6312" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The whole point is to ensure that if the inner function wants to access an outer variable in the future, it is able to do so.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;El objetivo es garantizar que si la funci&amp;oacute;n interna quiere acceder a una variable externa en el futuro, pueda hacerlo.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9289561f1d2c7006a3223c749a580963260ce102" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;*A C# question&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;* AC # pregunta&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2907f5d699e83f056b74043078bdbf321536087f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;sup&gt;**&lt;/sup&gt; Any outer function, if several are nested, or even in the global context, as &lt;a href=&quot;https://stackoverflow.com/a/5099447/706054&quot;&gt;this answer&lt;/a&gt; points out clearly.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;sup&gt;**&lt;/sup&gt; Cualquier funci&amp;oacute;n externa, si varias est&amp;aacute;n anidadas, o incluso en el contexto global, como &lt;a href=&quot;https://stackoverflow.com/a/5099447/706054&quot;&gt;esta respuesta&lt;/a&gt; se&amp;ntilde;ala claramente.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="841613276b73dfb7dcf3075c43173d44d03601fb" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;sup&gt;*&lt;/sup&gt; For example, it covers all the points in the &quot;Closures for Dummies&quot; article given in &lt;a href=&quot;https://stackoverflow.com/a/111111/706054&quot;&gt;another answer&lt;/a&gt;, except example 6, which simply shows that variables can be used before they are declared, a nice fact to know but completely unrelated to closures. It also covers all the points in &lt;a href=&quot;https://stackoverflow.com/a/111200/706054&quot;&gt;the accepted answer&lt;/a&gt;, except for the points (1) that functions copy their arguments into local variables (the named function arguments), and (2) that copying numbers creates a new number, but copying an object reference gives you another reference to the same object. These are also good to know but again completely unrelated to closures. It is also very similar to the example in &lt;a href=&quot;https://stackoverflow.com/a/111114/706054&quot;&gt;this answer&lt;/a&gt; but a bit shorter and less abstract. It does not cover the point of &lt;a href=&quot;https://stackoverflow.com/a/17200991/706054&quot;&gt;this answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17308587?noredirect=1#comment26377355_111111&quot;&gt;this comment&lt;/a&gt;, which is that JavaScript makes it difficult to plug the &lt;em&gt;current&lt;/em&gt; value of a loop variable into your inner function: The &quot;plugging in&quot; step can only be done with a helper function that encloses your inner function and is invoked on each loop iteration. (Strictly speaking, the inner function accesses the helper function's copy of the variable, rather than having anything plugged in.) Again, very useful when creating closures, but not part of what a closure is or how it works. There is additional confusion due to closures working differently in functional languages like ML, where variables are bound to values rather than to storage space, providing a constant stream of people who understand closures in a way (namely the &quot;plugging in&quot; way) that is simply incorrect for JavaScript, where variables are always bound to storage space, and never to values. &lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;sup&gt;*&lt;/sup&gt; Por ejemplo, cubre todos los puntos en el art&amp;iacute;culo &quot;Cierres para tontos&quot; que figura en &lt;a href=&quot;https://stackoverflow.com/a/111111/706054&quot;&gt;otra respuesta&lt;/a&gt; , excepto el ejemplo 6, que simplemente muestra que las variables se pueden usar antes de que se declaren, un hecho agradable de conocer pero completamente ajeno a los cierres.&lt;/sup&gt; &lt;sup&gt;Tambi&amp;eacute;n cubre todos los puntos en &lt;a href=&quot;https://stackoverflow.com/a/111200/706054&quot;&gt;la respuesta aceptada&lt;/a&gt; , excepto los puntos (1) que las funciones copian sus argumentos en variables locales (los argumentos de la funci&amp;oacute;n nombrada), y (2) que copiar n&amp;uacute;meros crea un nuevo n&amp;uacute;mero, pero copiar una referencia de objeto le da otra referencia al mismo objeto.&lt;/sup&gt; &lt;sup&gt;Tambi&amp;eacute;n es bueno saberlo, pero nuevamente no tiene nada que ver con los cierres.&lt;/sup&gt; &lt;sup&gt;Tambi&amp;eacute;n es muy similar al ejemplo en &lt;a href=&quot;https://stackoverflow.com/a/111114/706054&quot;&gt;esta respuesta,&lt;/a&gt; pero un poco m&amp;aacute;s corto y menos abstracto.&lt;/sup&gt; &lt;sup&gt;No cubre el punto de &lt;a href=&quot;https://stackoverflow.com/a/17200991/706054&quot;&gt;esta respuesta&lt;/a&gt; o &lt;a href=&quot;https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17308587?noredirect=1#comment26377355_111111&quot;&gt;este comentario&lt;/a&gt; , que es que JavaScript hace que sea dif&amp;iacute;cil conectar el valor &lt;em&gt;actual&lt;/em&gt; de una variable de bucle en su funci&amp;oacute;n interna: el paso &quot;enchufar&quot; solo se puede hacer con una funci&amp;oacute;n auxiliar que encierra su funci&amp;oacute;n interna y se invoca en cada iteraci&amp;oacute;n del bucle.&lt;/sup&gt; &lt;sup&gt;(Estrictamente hablando, la funci&amp;oacute;n interna accede a la copia de la variable de la funci&amp;oacute;n auxiliar, en lugar de tener algo enchufado). De nuevo, es muy &amp;uacute;til cuando se crean cierres, pero no es parte de qu&amp;eacute; es un cierre o c&amp;oacute;mo funciona.&lt;/sup&gt; &lt;sup&gt;Existe una confusi&amp;oacute;n adicional debido a que los cierres funcionan de manera diferente en lenguajes funcionales como ML, donde las variables est&amp;aacute;n vinculadas a valores en lugar de espacio de almacenamiento, proporcionando un flujo constante de personas que entienden los cierres de una manera (es decir, la forma de &quot;enchufar&quot;) que es simplemente incorrecto para JavaScript, donde las variables siempre est&amp;aacute;n vinculadas al espacio de almacenamiento y nunca a los valores.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="eb8e6848b2572e4d1686265bf069ed036b474a37" translate="yes" xml:space="preserve">
          <source>A closure in JavaScript is like keeping a reference (&lt;strong&gt;NOT&lt;/strong&gt; a copy) to the scope at the point of function declaration... plus a link to all the scopes nested outside that scope.</source>
          <target state="translated">Un cierre en JavaScript es como mantener una referencia ( &lt;strong&gt;NO&lt;/strong&gt; una copia) al alcance en la declaraci&amp;oacute;n del punto de funci&amp;oacute;n ... m&amp;aacute;s un enlace a todos los &amp;aacute;mbitos anidados fuera de ese alcance.</target>
        </trans-unit>
        <trans-unit id="9374176e6956e9c55a03f208ff3b626b273cf5dc" translate="yes" xml:space="preserve">
          <source>A closure is a function that has access to another function's scope (its variables and functions). The easiest way to create a closure is with a function within a function; the reason being that in JavaScript a function always has access to its containing function&amp;rsquo;s scope.</source>
          <target state="translated">Un cierre es una funci&amp;oacute;n que tiene acceso al alcance de otra funci&amp;oacute;n (sus variables y funciones). La forma m&amp;aacute;s f&amp;aacute;cil de crear un cierre es con una funci&amp;oacute;n dentro de una funci&amp;oacute;n; La raz&amp;oacute;n es que en JavaScript una funci&amp;oacute;n siempre tiene acceso al alcance de la funci&amp;oacute;n que lo contiene.</target>
        </trans-unit>
        <trans-unit id="fd2d062c668410ccdcd9af34cc85522e6c1afaa2" translate="yes" xml:space="preserve">
          <source>A closure is a link between a function and its outer lexical (ie. as-written) environment, such that the identifiers (variables, parameters, function declarations etc) defined within that environment are visible from within the function, regardless of when or from where the function is invoked.</source>
          <target state="translated">Un cierre es un vínculo entre una función y su entorno léxico externo (es decir,tal como está escrito),de manera que los identificadores (variables,parámetros,declaraciones de la función,etc.)definidos dentro de ese entorno son visibles desde dentro de la función,independientemente de cuándo o desde dónde se invoca la función.</target>
        </trans-unit>
        <trans-unit id="cec926b0cb259356a86639e657b14e8e1b4d0b58" translate="yes" xml:space="preserve">
          <source>A closure is created when a function is declared; this closure is used to configure the execution context when the function is invoked.</source>
          <target state="translated">Se crea un cierre cuando se declara una función;este cierre se utiliza para configurar el contexto de ejecución cuando se invoca la función.</target>
        </trans-unit>
        <trans-unit id="88f672a9df48ba5975f39c3937c757038142dc61" translate="yes" xml:space="preserve">
          <source>A closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be used immediately. Therefore, the closure of the enclosing function probably already exists at the time that enclosing function was called since any inner function has access to it as soon as it is called.</source>
          <target state="translated">Un cierre no sólo se crea cuando se devuelve una función interna.De hecho,la función de cierre no necesita volver en absoluto.En su lugar,puede asignar su función interna a una variable de un ámbito exterior,o pasarla como argumento a otra función en la que pueda ser utilizada inmediatamente.Por lo tanto,el cierre de la función de encierro probablemente ya existe en el momento en que se llamó a esa función de encierro ya que cualquier función interna tiene acceso a ella tan pronto como se llama.</target>
        </trans-unit>
        <trans-unit id="cfc70bbb817358717b49d080b1eca649757aa359" translate="yes" xml:space="preserve">
          <source>A closure is one way of supporting &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;first-class functions&lt;/a&gt;; it is an expression that can reference variables within its scope (when it was first declared), be assigned to a variable, be passed as an argument to a function, or be returned as a function result.</source>
          <target state="translated">Un cierre es una forma de soportar &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;funciones de primera clase&lt;/a&gt; ; es una expresi&amp;oacute;n que puede hacer referencia a variables dentro de su alcance (cuando se declar&amp;oacute; por primera vez), asignarse a una variable, pasarse como argumento a una funci&amp;oacute;n o devolverse como resultado de una funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0ef763764e04164186e2a1ceb3806cf6d8f2b116" translate="yes" xml:space="preserve">
          <source>A closure is where an inner function has access to variables in its outer function. That's probably the simplest one-line explanation you can get for closures.</source>
          <target state="translated">Un cierre es cuando una función interna tiene acceso a variables en su función externa.Esa es probablemente la explicación más simple de una línea que se puede obtener para los cierres.</target>
        </trans-unit>
        <trans-unit id="3259e0c90916fb0e4045b771243c259d5847d8f6" translate="yes" xml:space="preserve">
          <source>A function doesn't have to &lt;em&gt;return&lt;/em&gt; in order to create a closure. Simply by virtue of its declaration, every function closes over its enclosing lexical environment, forming a closure.</source>
          <target state="translated">Una funci&amp;oacute;n no tiene que &lt;em&gt;volver&lt;/em&gt; para crear un cierre. Simplemente en virtud de su declaraci&amp;oacute;n, cada funci&amp;oacute;n se cierra sobre su entorno l&amp;eacute;xico que lo encierra, formando un cierre.</target>
        </trans-unit>
        <trans-unit id="026c5616609e62af2f61992526a7c3f75658b65c" translate="yes" xml:space="preserve">
          <source>A function in JavaScript is not just a reference to a set of instructions (as in C language), but it also includes a hidden data structure which is composed of references to all nonlocal variables it uses (captured variables). Such two-piece functions are called closures. Every function in JavaScript can be considered a closure.</source>
          <target state="translated">Una función en JavaScript no es sólo una referencia a un conjunto de instrucciones (como en el lenguaje C),sino que también incluye una estructura de datos oculta que se compone de referencias a todas las variables no locales que utiliza (variables capturadas).Estas funciones de dos piezas se denominan cierres.Cada función en JavaScript puede considerarse un cierre.</target>
        </trans-unit>
        <trans-unit id="5ae534cf02a5858b2d840f1a7673a1afe06d7bfc" translate="yes" xml:space="preserve">
          <source>A function normally has a name, parentheses and braces. Like this:</source>
          <target state="translated">Una función normalmente tiene un nombre,paréntesis y llaves.Como esto:</target>
        </trans-unit>
        <trans-unit id="99a4243b87430cefe6f1afae7fcb4af6221200d0" translate="yes" xml:space="preserve">
          <source>A great explanation of how closures can &lt;a href=&quot;https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited&quot;&gt;cause memory leaks in IE&lt;/a&gt; if you are not careful.</source>
          <target state="translated">Una gran explicaci&amp;oacute;n de c&amp;oacute;mo los cierres pueden &lt;a href=&quot;https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited&quot;&gt;causar p&amp;eacute;rdidas de memoria en IE&lt;/a&gt; si no tiene cuidado.</target>
        </trans-unit>
        <trans-unit id="c46e219fc09ff6a6e30c8ecd75a04e05369c3ec3" translate="yes" xml:space="preserve">
          <source>A nested function may continue to live after the outer function has finished:</source>
          <target state="translated">Una función anidada puede continuar viviendo después de que la función externa haya terminado:</target>
        </trans-unit>
        <trans-unit id="4ab1874227fa89cd67efbb317da32d2f6c6a64fd" translate="yes" xml:space="preserve">
          <source>A new set of local variables is kept every time a function is called (given that the function contains a function declaration inside it, and a reference to that inside function is either returned or an external reference is kept for it in some way).</source>
          <target state="translated">Cada vez que se llama a una función se guarda un nuevo conjunto de variables locales (dado que la función contiene una declaración de función dentro de ella,y se devuelve una referencia a esa función interna o se guarda una referencia externa para ella de alguna manera).</target>
        </trans-unit>
        <trans-unit id="5efdcbea95121298d3ad2d07cbbe7dcf0db4867d" translate="yes" xml:space="preserve">
          <source>ALERT: gorilla</source>
          <target state="translated">ALERT:gorilla</target>
        </trans-unit>
        <trans-unit id="2d25aee06019d734098a42118e386bcd1cb56358" translate="yes" xml:space="preserve">
          <source>ALERT: monkey</source>
          <target state="translated">ALERTA:mono</target>
        </trans-unit>
        <trans-unit id="cd6c81ca63b69c9246d861c2e95db5f815d2ca1c" translate="yes" xml:space="preserve">
          <source>ALERT: monkey
ALERT: monkey</source>
          <target state="translated">ALERTA:mono ALERTA:mono</target>
        </trans-unit>
        <trans-unit id="37b0eb534510d977f89353bc69e9f62a4b8877f3" translate="yes" xml:space="preserve">
          <source>After the closures come the lines</source>
          <target state="translated">Después de los cierres vienen las líneas</target>
        </trans-unit>
        <trans-unit id="473797be1179e97465610490a5af19283b615cbe" translate="yes" xml:space="preserve">
          <source>After the loop finished and &lt;code&gt;index&lt;/code&gt; was done being modified the end value was 10, therefore every function added to the array returns the value of the single &lt;code&gt;index&lt;/code&gt; variable which is now set to 10.</source>
          <target state="translated">Una vez que finaliz&amp;oacute; el ciclo y se modific&amp;oacute; el &lt;code&gt;index&lt;/code&gt; el valor final fue 10, por lo tanto, cada funci&amp;oacute;n agregada a la matriz devuelve el valor de la variable de &lt;code&gt;index&lt;/code&gt; &amp;uacute;nico que ahora se establece en 10.</target>
        </trans-unit>
        <trans-unit id="0c5c53c9b406b802e8050cdcb2d55f485bc7eae0" translate="yes" xml:space="preserve">
          <source>After this we have the line</source>
          <target state="translated">Después de esto tenemos la línea</target>
        </trans-unit>
        <trans-unit id="b1283dc7aa9afa2d62e552768aa61cc0797578c6" translate="yes" xml:space="preserve">
          <source>All four of these functions are closures as they all access their environment.</source>
          <target state="translated">Las cuatro funciones son cierres ya que todas acceden a su entorno.</target>
        </trans-unit>
        <trans-unit id="e97e0f50a5e629695aedee5a89cca10ea6b0cb28" translate="yes" xml:space="preserve">
          <source>All of the functions added to the array return the SAME &lt;code&gt;index&lt;/code&gt; variable from the parent scope where it was defined instead of 10 different ones from 10 different scopes like the first example. The end result is that all 10 functions return the same variable from the same scope.</source>
          <target state="translated">Todas las funciones agregadas a la matriz devuelven la MISMA variable de &lt;code&gt;index&lt;/code&gt; del &amp;aacute;mbito primario donde se defini&amp;oacute; en lugar de 10 diferentes de 10 &amp;aacute;mbitos diferentes como el primer ejemplo. El resultado final es que las 10 funciones devuelven la misma variable del mismo &amp;aacute;mbito.</target>
        </trans-unit>
        <trans-unit id="e254452976bf3a1139922787e1c255443f069708" translate="yes" xml:space="preserve">
          <source>All this data stuff sounds a bit boring, but it is really very cool; we might have a function that tells a robot what to make for dinner. Let's say I invite you and your friend to my house. You like chicken legs best, I like sausages, your friend always wants what you want and my friend does not eat meat.</source>
          <target state="translated">Todo esto de los datos suena un poco aburrido,pero es realmente genial;podríamos tener una función que le diga a un robot qué hacer para la cena.Digamos que los invito a ti y a tu amigo a mi casa.A ti te gustan más las patas de pollo,a mí me gustan las salchichas,tu amigo siempre quiere lo que tú quieres y mi amigo no come carne.</target>
        </trans-unit>
        <trans-unit id="86693ebc04e6080838a0974d1c5fdd94dcf0851e" translate="yes" xml:space="preserve">
          <source>All three global functions have a common reference to the &lt;em&gt;same&lt;/em&gt; closure because they are all declared within a single call to &lt;code&gt;setupSomeGlobals()&lt;/code&gt;.</source>
          <target state="translated">Las tres funciones globales tienen una referencia com&amp;uacute;n al &lt;em&gt;mismo&lt;/em&gt; cierre porque todas se declaran dentro de una sola llamada a &lt;code&gt;setupSomeGlobals()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="010ea26c09769d3f5e5a4fa466cb6c5456b66f63" translate="yes" xml:space="preserve">
          <source>All variables outside the returned function are available to the returned function, but they are not directly available to the returned function object...</source>
          <target state="translated">Todas las variables fuera de la función devuelta están disponibles para la función devuelta,pero no están directamente disponibles para el objeto de la función devuelta...</target>
        </trans-unit>
        <trans-unit id="c4594b92814cb252202666c4d92f85aa73ea246b" translate="yes" xml:space="preserve">
          <source>Also, it must be understood that local variables in JavaScript are created not on the stack frame, but on the heap and destroyed only when no one is referencing them. When a function returns, references to its local variables are decremented, but they can still be non-null if during the current execution they became part of a closure and are still referenced by its lexically nested functions (which can happen only if the references to these nested functions were returned or otherwise transferred to some external code).</source>
          <target state="translated">Además,debe entenderse que las variables locales en JavaScript no se crean en el marco de la pila,sino en el montón y se destruyen sólo cuando nadie hace referencia a ellas.Cuando una función regresa,las referencias a sus variables locales se reducen,pero pueden seguir siendo no nulas si durante la ejecución actual se han convertido en parte de un cierre y siguen siendo referenciadas por sus funciones anidadas léxicamente (lo que sólo puede ocurrir si las referencias a estas funciones anidadas se devuelven o se transfieren de otro modo a algún código externo).</target>
        </trans-unit>
        <trans-unit id="3bce66ad1af625b4de8c481a747409bc48008eb0" translate="yes" xml:space="preserve">
          <source>Also, this private variable state is &lt;strong&gt;fully&lt;/strong&gt; accessible, for both readings and assigning to its private scoped variables.</source>
          <target state="translated">Adem&amp;aacute;s, este estado de variable privada es &lt;strong&gt;totalmente&lt;/strong&gt; accesible, tanto para las lecturas como para la asignaci&amp;oacute;n a sus variables de &amp;aacute;mbito privado.</target>
        </trans-unit>
        <trans-unit id="4f230a19f88726fa9de2c57f5cbfa8e8e4472abd" translate="yes" xml:space="preserve">
          <source>An answer for a six-year-old (assuming he knows what a function is and what a variable is, and what data is):</source>
          <target state="translated">Una respuesta para un niño de seis años (suponiendo que sepa qué es una función y qué es una variable,y qué son los datos):</target>
        </trans-unit>
        <trans-unit id="d7b09515b9865b30af6b3fa920a76512708611e1" translate="yes" xml:space="preserve">
          <source>An example of a closure</source>
          <target state="translated">Un ejemplo de cierre</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">Un ejemplo:</target>
        </trans-unit>
        <trans-unit id="819beada86acdf2bbd115d5e1db66e6b0bee2da8" translate="yes" xml:space="preserve">
          <source>And even though the grown-ups knew of real princesses, they would never believe in the unicorns or dragons because they could never see them. The grown-ups said that they only existed inside the little girl's imagination.</source>
          <target state="translated">Y aunque los adultos conocían a las princesas reales,nunca creerían en los unicornios o dragones porque nunca los verían.Los adultos decían que sólo existían dentro de la imaginación de la niña.</target>
        </trans-unit>
        <trans-unit id="57dfb708e06183c8ecb1f0c30e96af35afaf50ba" translate="yes" xml:space="preserve">
          <source>And here is where things get really interesting. If we were to get rid of outerFunction, say set it to null, you might think that referenceToInnerFunction would loose its access to the value of outerVar. But this is not the case.</source>
          <target state="translated">Y aquí es donde las cosas se ponen realmente interesantes.Si nos deshiciéramos de la función externa,digamos que la pusiéramos en nulo,se podría pensar que la referencia a la función interna perdería su acceso al valor del radar externo.Pero este no es el caso.</target>
        </trans-unit>
        <trans-unit id="435fb8d87e8d248469850188da7e2ad10deaaf3b" translate="yes" xml:space="preserve">
          <source>And if you remember, when &lt;code&gt;this.say&lt;/code&gt; is created, it (as every function) gets an internal reference &lt;code&gt;this.say.[[Scope]]&lt;/code&gt; to the current LexicalEnvironment. So, the LexicalEnvironment of the current User execution stays in memory. All variables of User also are its properties, so they are also carefully kept, not junked as usually.</source>
          <target state="translated">Y si recuerdas, cuando se crea &lt;code&gt;this.say&lt;/code&gt; , (como cada funci&amp;oacute;n) obtiene una referencia interna &lt;code&gt;this.say.[[Scope]]&lt;/code&gt; al entorno Lexical actual. Por lo tanto, el entorno Lexical de la ejecuci&amp;oacute;n actual del usuario permanece en la memoria. Todas las variables de Usuario tambi&amp;eacute;n son sus propiedades, por lo que tambi&amp;eacute;n se guardan cuidadosamente, no se desechan como de costumbre.</target>
        </trans-unit>
        <trans-unit id="625ff0ae825173e464152e82b8c8264f2701a52a" translate="yes" xml:space="preserve">
          <source>And now, even though Mary is &quot;no longer running&quot;, the memory of her is not lost and her child will always remember her name and other secrets they shared during their time together.</source>
          <target state="translated">Y ahora,aunque María &quot;ya no corre&quot;,su memoria no se ha perdido y su hijo siempre recordará su nombre y otros secretos que compartieron durante su tiempo juntos.</target>
        </trans-unit>
        <trans-unit id="dd1dc01a62936ce68f2808899afc6036354d1594" translate="yes" xml:space="preserve">
          <source>And she would often tell them of her latest amazing adventure as a princess.</source>
          <target state="translated">Y a menudo les contaba su última y asombrosa aventura como princesa.</target>
        </trans-unit>
        <trans-unit id="b4380f96cc0e7a3c2e34bc8ce6205c32c2126439" translate="yes" xml:space="preserve">
          <source>And yes, I'd even recommend it to a 6-year old -- if the 6-year old is learning about closures, then it's logical they're ready to comprehend the &lt;em&gt;concise and simple explanation&lt;/em&gt; provided in the article.</source>
          <target state="translated">Y s&amp;iacute;, incluso lo recomendar&amp;iacute;a a un ni&amp;ntilde;o de 6 a&amp;ntilde;os: si el ni&amp;ntilde;o de 6 a&amp;ntilde;os est&amp;aacute; aprendiendo acerca de los cierres, entonces es l&amp;oacute;gico que est&amp;eacute; listo para comprender la &lt;em&gt;explicaci&amp;oacute;n concisa y simple&lt;/em&gt; proporcionada en el art&amp;iacute;culo.</target>
        </trans-unit>
        <trans-unit id="174ee1c1a9c452a97f5a4e71705d3ba0633128b2" translate="yes" xml:space="preserve">
          <source>Another really simple way to explain it is in terms of scope:</source>
          <target state="translated">Otra forma muy simple de explicarlo es en términos de alcance:</target>
        </trans-unit>
        <trans-unit id="efcadf61fe3fe42ed34cfdd66b0ecbf1ed3408ef" translate="yes" xml:space="preserve">
          <source>Any time you create a smaller scope inside of a larger scope, the smaller scope will always be able to see what is in the larger scope.</source>
          <target state="translated">Cada vez que se crea un alcance más pequeño dentro de un alcance más grande,el alcance más pequeño siempre podrá ver lo que hay en el alcance más grande.</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="d5593bba6625e12152d79d70e57424cdd0e4f606" translate="yes" xml:space="preserve">
          <source>As a father of a 6-year-old, currently teaching young children (and a relative novice to coding with no formal education so corrections will be required), I think the lesson would stick best through hands-on play. If the 6-year-old is ready to understand what a closure is, then they are old enough to have a go themselves. I'd suggest pasting the code into jsfiddle.net, explaining a bit, and leaving them alone to concoct a unique song. The explanatory text below is probably more appropriate for a 10 year old.</source>
          <target state="translated">Como padre de un niño de 6 años,que actualmente enseña a niños pequeños (y un relativo principiante a la codificación sin educación formal,por lo que se requerirán correcciones),creo que la lección se pegaría mejor a través del juego práctico.Si el niño de 6 años está listo para entender lo que es un cierre,entonces es lo suficientemente mayor para intentarlo por sí mismo.Sugiero que peguen el código en jsfiddle.net,explicando un poco,y dejándolos solos para inventar una canción única.El texto explicativo de abajo es probablemente más apropiado para un niño de 10 años.</target>
        </trans-unit>
        <trans-unit id="6568100bffff0b20e0c37f88a640e7173cdcd704" translate="yes" xml:space="preserve">
          <source>As we see, &lt;code&gt;this.say&lt;/code&gt; is a property in the user object, so it continues to live after User completed.</source>
          <target state="translated">Como vemos, &lt;code&gt;this.say&lt;/code&gt; es una propiedad en el objeto de usuario, por lo que contin&amp;uacute;a vivo despu&amp;eacute;s de que el Usuario haya completado.</target>
        </trans-unit>
        <trans-unit id="e1626c59ebd74e38dd52b09e3c12153695d67816" translate="yes" xml:space="preserve">
          <source>As you can see, the toys left in the room are still accessible via the brother and no matter if the room is locked. Here is &lt;a href=&quot;http://jsbin.com/ubakor/9/edit&quot;&gt;a jsbin&lt;/a&gt; to play around with it.</source>
          <target state="translated">Como puede ver, los juguetes que quedan en la habitaci&amp;oacute;n todav&amp;iacute;a son accesibles a trav&amp;eacute;s del hermano y no importa si la habitaci&amp;oacute;n est&amp;aacute; cerrada. Aqu&amp;iacute; hay &lt;a href=&quot;http://jsbin.com/ubakor/9/edit&quot;&gt;un jsbin&lt;/a&gt; para jugar con &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="890df09169ac0377be2b819d1f924abc0cd10e89" translate="yes" xml:space="preserve">
          <source>As you may guess, because the variables are re-created every time the function is called, and nobody else will know them, there must be a secret place where they are stored. It could be called &lt;strong&gt;Chamber of Secrets&lt;/strong&gt; or &lt;strong&gt;stack&lt;/strong&gt; or &lt;strong&gt;local scope&lt;/strong&gt; but it doesn't really matter. We know they are there, somewhere, hidden in the memory.</source>
          <target state="translated">Como puede suponer, debido a que las variables se vuelven a crear cada vez que se llama a la funci&amp;oacute;n, y nadie m&amp;aacute;s las conocer&amp;aacute;, debe haber un lugar secreto donde se almacenan. Podr&amp;iacute;a llamarse &lt;strong&gt;C&amp;aacute;mara de los Secretos&lt;/strong&gt; o &lt;strong&gt;pila&lt;/strong&gt; o &lt;strong&gt;&amp;aacute;mbito local,&lt;/strong&gt; pero en realidad no importa. Sabemos que est&amp;aacute;n all&amp;iacute;, en alg&amp;uacute;n lugar, escondidos en la memoria.</target>
        </trans-unit>
        <trans-unit id="986da2f4d4b325d9fb2c07a7e2b3897081cd863a" translate="yes" xml:space="preserve">
          <source>BRACES: &quot;Braces&quot; which look like this &lt;code&gt;{}&lt;/code&gt; are the tinted windows of our factory. From inside the factory you can see out, but from the outside you can't see in.</source>
          <target state="translated">BRAZOS: &quot;Braces&quot; que se ven as&amp;iacute; &lt;code&gt;{}&lt;/code&gt; son las ventanas tintadas de nuestra f&amp;aacute;brica. Desde el interior de la f&amp;aacute;brica se puede ver hacia afuera, pero desde afuera no se puede ver hacia adentro.</target>
        </trans-unit>
        <trans-unit id="3575d07a466999847f383f17914159e3dbdd22b0" translate="yes" xml:space="preserve">
          <source>BROWSER: When you connect to the Internet on a computer, tablet or phone to visit a website, you use a browser. Examples you may know are Internet Explorer, Chrome, Firefox and Safari. The browser can understand JavaScript and tell the computer what it needs to do. The JavaScript instructions are called functions.</source>
          <target state="translated">Cuando te conectas a Internet en una computadora,tableta o teléfono para visitar un sitio web,usas un navegador.Algunos ejemplos que puedes conocer son Internet Explorer,Chrome,Firefox y Safari.El navegador puede entender JavaScript y decirle a la computadora lo que necesita hacer.Las instrucciones de JavaScript se llaman funciones.</target>
        </trans-unit>
        <trans-unit id="0419e91da10b803e76b92f8dffe5555643e1dd03" translate="yes" xml:space="preserve">
          <source>Because all these external variables referenced by a lexically nested function are actually local variables in the chain of its lexically enclosing functions (global variables can be assumed to be local variables of some root function), and every single execution of a function creates new instances of its local variables, it follows that every execution of a function returning (or otherwise transferring it out, such as registering it as a callback) a nested function creates a new closure (with its own potentially unique set of referenced nonlocal variables which represent its execution context).</source>
          <target state="translated">Dado que todas esas variables externas a las que hace referencia una función anidada léxicamente son en realidad variables locales de la cadena de sus funciones que la encierran léxicamente (cabe suponer que las variables globales son variables locales de alguna función raíz),y que cada ejecución de una función crea nuevas instancias de sus variables locales,se deduce que cada ejecución de una función que devuelve (o que la transfiere de otro modo,por ejemplo registrándola como una llamada de retorno)una función anidada crea un nuevo cierre (con su propio conjunto potencialmente único de variables no locales referenciadas que representan su contexto de ejecución).</target>
        </trans-unit>
        <trans-unit id="42668682fc7dcf2769407c41fc937cdbf7dd8025" translate="yes" xml:space="preserve">
          <source>Because there was only one scope within the &lt;code&gt;createClosureArray()&lt;/code&gt; function, &lt;code&gt;index&lt;/code&gt; is only bound to a value within that scope. In other words, each time the loop changes the value of &lt;code&gt;index&lt;/code&gt;, it changes it for everything that references it within that scope.</source>
          <target state="translated">Debido a que solo hab&amp;iacute;a un alcance dentro de la funci&amp;oacute;n &lt;code&gt;createClosureArray()&lt;/code&gt; , el &lt;code&gt;index&lt;/code&gt; solo est&amp;aacute; vinculado a un valor dentro de ese alcance. En otras palabras, cada vez que el bucle cambia el valor del &lt;code&gt;index&lt;/code&gt; , lo cambia por todo lo que lo hace referencia dentro de ese alcance.</target>
        </trans-unit>
        <trans-unit id="14c3a147917bc6f80510553c690b0ab8c8718635" translate="yes" xml:space="preserve">
          <source>But all they would see is a little girl...</source>
          <target state="translated">Pero todo lo que verían es una niña pequeña...</target>
        </trans-unit>
        <trans-unit id="bb8c57c634a563056b164f5aeb01e4ac8232dc6d" translate="yes" xml:space="preserve">
          <source>But how is this so? How can referenceToInnerFunction still know the value of outerVar now that outerFunction has been set to null?</source>
          <target state="translated">Pero,¿cómo es eso? ¿Cómo puede la referencia a la Función Interna conocer el valor del radar exterior ahora que la Función Externa se ha establecido en nulo?</target>
        </trans-unit>
        <trans-unit id="146180db52e416274e24ed731f90ff6fc5ad3201" translate="yes" xml:space="preserve">
          <source>But she would always have to return back to her dull world of chores and grown-ups.</source>
          <target state="translated">Pero siempre tendría que volver a su aburrido mundo de tareas y adultos.</target>
        </trans-unit>
        <trans-unit id="866ff54f49d509edc499efd08ef16cd5aed44ee7" translate="yes" xml:space="preserve">
          <source>But the sad thing is, if the child is also a private variable of its parent function, it would also die when the parent ends, and the secrets would die with them.</source>
          <target state="translated">Pero lo triste es que si el niño es también una variable privada de su función parental,también morirá cuando el padre termine,y los secretos morirán con ellos.</target>
        </trans-unit>
        <trans-unit id="dbf03411a9d8f9c4e1de5345b3a10c168dfc2df8" translate="yes" xml:space="preserve">
          <source>But we know the real truth; that the little girl with the princess inside...</source>
          <target state="translated">Pero sabemos la verdadera verdad;que la niña con la princesa dentro...</target>
        </trans-unit>
        <trans-unit id="a343ea5602007ce993e1966d841864424094a57f" translate="yes" xml:space="preserve">
          <source>But, in JavaScript there is this very special thing that functions which are created inside other functions, can also know the local variables of their parents and keep them as long as they live.</source>
          <target state="translated">Pero,en JavaScript hay esta cosa muy especial que las funciones que se crean dentro de otras funciones,también pueden conocer las variables locales de sus padres y mantenerlas mientras vivan.</target>
        </trans-unit>
        <trans-unit id="5d22ad9eb11c8d7544b41c9fd9c72490630172cd" translate="yes" xml:space="preserve">
          <source>CLOSURES DONE RIGHT</source>
          <target state="translated">CIERRES BIEN HECHOS</target>
        </trans-unit>
        <trans-unit id="b8c469b8120b44b5dd72fc632091339193c9122a" translate="yes" xml:space="preserve">
          <source>CLOSURES DONE WRONG</source>
          <target state="translated">CIERRES HECHOS MAL</target>
        </trans-unit>
        <trans-unit id="3344264f6f33fcb6fbcf186f0b6ad57482d348ae" translate="yes" xml:space="preserve">
          <source>CLOSURES: The closures are the smaller functions that are inside the big &lt;em&gt;sing()&lt;/em&gt; function. The little factories inside the big factory. They each have their own braces which mean that the variables inside them can't be seen from the outside. That's why the names of the variables (&lt;em&gt;creature&lt;/em&gt; and &lt;em&gt;result&lt;/em&gt;) can be repeated in the closures but with different values. If you type these variable names in the console window, you won't get its value because it's hidden by two layers of tinted windows.</source>
          <target state="translated">CIERRES: Los cierres son las funciones m&amp;aacute;s peque&amp;ntilde;as que est&amp;aacute;n dentro de la funci&amp;oacute;n grande &lt;em&gt;sing ()&lt;/em&gt; . Las peque&amp;ntilde;as f&amp;aacute;bricas dentro de la gran f&amp;aacute;brica. Cada uno tiene sus propios aparatos ortop&amp;eacute;dicos, lo que significa que las variables dentro de ellos no se pueden ver desde el exterior. Es por eso que los nombres de las variables ( &lt;em&gt;criatura&lt;/em&gt; y &lt;em&gt;resultado&lt;/em&gt; ) pueden repetirse en los cierres pero con valores diferentes. Si escribe estos nombres de variables en la ventana de la consola, no obtendr&amp;aacute; su valor porque est&amp;aacute; oculto por dos capas de ventanas polarizadas.</target>
        </trans-unit>
        <trans-unit id="76ad173357129e5535c24cd674bddfaff61e8338" translate="yes" xml:space="preserve">
          <source>CODE: All the writing above is called &lt;em&gt;code&lt;/em&gt;. It is written in JavaScript.</source>
          <target state="translated">C&amp;Oacute;DIGO: Toda la escritura anterior se llama &lt;em&gt;c&amp;oacute;digo&lt;/em&gt; . Est&amp;aacute; escrito en JavaScript.</target>
        </trans-unit>
        <trans-unit id="a0c7bc52b3fa8bb1b47ad931aa67baef1da44403" translate="yes" xml:space="preserve">
          <source>Can anybody consider that I am 6 and strangely interested in that subject ?</source>
          <target state="translated">¿Alguien puede considerar que tengo 6 años y estoy extrañamente interesado en ese tema?</target>
        </trans-unit>
        <trans-unit id="0754a0ac49d4de7ab61d6c51b9280396aeeb0c9d" translate="yes" xml:space="preserve">
          <source>Can you explain closures to a 5-year-old?*</source>
          <target state="translated">¿Puedes explicarle los cierres a un niño de 5 años?</target>
        </trans-unit>
        <trans-unit id="c6abb0edfb41f4eed3192a92b93e8777584cfbc6" translate="yes" xml:space="preserve">
          <source>Closures are &lt;em&gt;not hard&lt;/em&gt; to understand once the core concept is grokked. However, they are impossible to understand by reading any theoretical or academically oriented explanations!</source>
          <target state="translated">Los cierres &lt;em&gt;no&lt;/em&gt; son &lt;em&gt;dif&amp;iacute;ciles&lt;/em&gt; de entender una vez que se asimila el concepto central. Sin embargo, &amp;iexcl;son imposibles de entender al leer cualquier explicaci&amp;oacute;n te&amp;oacute;rica o acad&amp;eacute;micamente orientada!</target>
        </trans-unit>
        <trans-unit id="473e3864991bcdfffaa54377115d58425884b1de" translate="yes" xml:space="preserve">
          <source>Closures are a way to let a function
  have &lt;strong&gt;persistent, private variables&lt;/strong&gt; -
  that is, variables that only one
  function knows about, where it can
  keep track of info from previous times
  that it was run.</source>
          <target state="translated">Los cierres son una forma de permitir que una funci&amp;oacute;n tenga &lt;strong&gt;variables privadas persistentes,&lt;/strong&gt; es decir, variables que solo una funci&amp;oacute;n conoce, donde puede realizar un seguimiento de la informaci&amp;oacute;n de tiempos anteriores en que se ejecut&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="2dab57988b39942ebe3792aab7459b19fb524730" translate="yes" xml:space="preserve">
          <source>Closures are functions with a state. It is somewhat similar to &quot;this&quot; in the sense that &quot;this&quot; also provides state for a function but function and &quot;this&quot; are separate objects (&quot;this&quot; is just a fancy parameter, and the only way to bind it permanently to a function is to create a closure). While &quot;this&quot; and function always live separately, a function cannot be separated from its closure and the language provides no means to access captured variables.</source>
          <target state="translated">Los cierres son funciones con un estado.Es algo similar a &quot;esto&quot; en el sentido de que &quot;esto&quot; también proporciona el estado para una función pero la función y &quot;esto&quot; son objetos separados (&quot;esto&quot; es sólo un parámetro de fantasía,y la única manera de unirlo permanentemente a una función es crear un cierre).Mientras que &quot;this&quot; y la función siempre viven por separado,una función no puede separarse de su cierre y el lenguaje no proporciona medios para acceder a las variables capturadas.</target>
        </trans-unit>
        <trans-unit id="9a8fe763a050a9c6f2b9d029f15de875acec4c6c" translate="yes" xml:space="preserve">
          <source>Closures are hard to explain because they are used to make some behaviour work that everybody intuitively expects to work anyway. I find the best way to explain them (and the way that &lt;em&gt;I&lt;/em&gt; learned what they do) is to imagine the situation without them:</source>
          <target state="translated">Los cierres son dif&amp;iacute;ciles de explicar porque se utilizan para hacer funcionar un comportamiento que todos intuitivamente esperan que funcione de todos modos. Creo que la mejor manera de explicarlos (y la forma en que aprend&amp;iacute; lo que hacen) es imaginar la situaci&amp;oacute;n sin ellos:</target>
        </trans-unit>
        <trans-unit id="13cd6611b47d0c0e96535f2857655ffbc4aec970" translate="yes" xml:space="preserve">
          <source>Closures are not magic</source>
          <target state="translated">Los cierres no son mágicos</target>
        </trans-unit>
        <trans-unit id="81857059bb8f6b3c5d16c47af8818ad9c8d4ef06" translate="yes" xml:space="preserve">
          <source>Closures are often used for creating functions with some hidden private data (but it's not always the case).</source>
          <target state="translated">Los cierres se utilizan a menudo para crear funciones con algunos datos privados ocultos (pero no siempre es así).</target>
        </trans-unit>
        <trans-unit id="f1f2dd80b45193a64a6fed6f703fea1610ee7907" translate="yes" xml:space="preserve">
          <source>Closures done right:</source>
          <target state="translated">Los cierres se han hecho bien:</target>
        </trans-unit>
        <trans-unit id="2b5870c633c063933016ddcafff1a5b85221b713" translate="yes" xml:space="preserve">
          <source>Closures done wrong:</source>
          <target state="translated">Los cierres se han hecho mal:</target>
        </trans-unit>
        <trans-unit id="65f3c9fe79ec9c90973a968f76051ad6208d1eff" translate="yes" xml:space="preserve">
          <source>Compare with a situation when a door was locked by draft and nobody inside (general function execution), and then some local fire occur and burn down the room (garbage collector:D), and then a new room was build and now you may leave another toys there (new function instance), but never get the same toys which were left in the first room instance.</source>
          <target state="translated">Compare con una situación en la que una puerta se cerró con llave por la corriente de aire y no había nadie dentro (ejecución de la función general),y luego ocurre un incendio local y se quema la habitación (recolector de basura:D),y luego se construye una nueva habitación y ahora se pueden dejar otros juguetes allí (instancia de la nueva función),pero nunca se consiguen los mismos juguetes que se dejaron en la primera instancia de la habitación.</target>
        </trans-unit>
        <trans-unit id="895fc54743a0a38a6edff320b747a9f3e67aa96b" translate="yes" xml:space="preserve">
          <source>Consider this option</source>
          <target state="translated">Considere esta opción</target>
        </trans-unit>
        <trans-unit id="d29543a41f8e03fb1f0ca60d30879d8d14612042" translate="yes" xml:space="preserve">
          <source>DATA: Data is a collection of facts. It can be numbers, words, measurements, observations or even just descriptions of things. You can't touch it, smell it or taste it. You can write it down, speak it and hear it. You could use it to &lt;em&gt;create&lt;/em&gt; touch smell and taste using a computer. It can be made useful by a computer using code.</source>
          <target state="translated">DATOS: Los datos son una colecci&amp;oacute;n de hechos. Pueden ser n&amp;uacute;meros, palabras, medidas, observaciones o incluso solo descripciones de cosas. No puedes tocarlo, olerlo o probarlo. Puedes escribirlo, hablarlo y escucharlo. Puede usarlo para &lt;em&gt;crear&lt;/em&gt; olores y sabores t&amp;aacute;ctiles usando una computadora. Puede ser &amp;uacute;til por una computadora usando c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="1386ebeed6520345b3b7b8e117496e328fb4ca5d" translate="yes" xml:space="preserve">
          <source>Dan invites Paul.
Dan asks Paul to bring one controller. How many controllers were brought to the party?</source>
          <target state="translated">Dan invita a Paul.Dan le pide a Paul que traiga un mando.¿Cuántos controladores se trajeron a la fiesta?</target>
        </trans-unit>
        <trans-unit id="ec2a42fc389ecb1dc4b9d0c461e02170df77d766" translate="yes" xml:space="preserve">
          <source>Douglas Crockford's simulated &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;private attributes and private methods&lt;/a&gt; for an object, using closures.</source>
          <target state="translated">Douglas Crockford simul&amp;oacute; &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;atributos privados y m&amp;eacute;todos privados&lt;/a&gt; para un objeto, utilizando cierres.</target>
        </trans-unit>
        <trans-unit id="1f5d96dd43fe4410f4d7bee1eb9596663a115a2d" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;makeKitchen()&lt;/code&gt; is called, a new closure is created with its own separate &lt;code&gt;trashBags&lt;/code&gt;.</source>
          <target state="translated">Cada vez que se llama a &lt;code&gt;makeKitchen()&lt;/code&gt; , se crea un nuevo cierre con sus propias &lt;code&gt;trashBags&lt;/code&gt; separadas.</target>
        </trans-unit>
        <trans-unit id="be4a4610d526a11fb6ad4a43add51b702b4757b8" translate="yes" xml:space="preserve">
          <source>Environment, which includes:</source>
          <target state="translated">El medio ambiente,que incluye:</target>
        </trans-unit>
        <trans-unit id="d753a72a73e7b9b72686150b4751eec2271aff2d" translate="yes" xml:space="preserve">
          <source>Every function call creates a closure, but there would be no need to keep the closure around unless an inner function, which has access to the inside of the closure, can be called from outside the closure.  Returning the object with the &lt;code&gt;getTrashBag&lt;/code&gt; function does that here.</source>
          <target state="translated">Cada llamada a la funci&amp;oacute;n crea un cierre, pero no ser&amp;iacute;a necesario mantener el cierre a menos que una funci&amp;oacute;n interna, que tiene acceso al interior del cierre, pueda llamarse desde fuera del cierre. Devolver el objeto con la funci&amp;oacute;n &lt;code&gt;getTrashBag&lt;/code&gt; hace eso aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="2df597c03eb2e94c01cea766bc9c9a3fbe100af1" translate="yes" xml:space="preserve">
          <source>Every function creates a closure because every function has a link to its outer lexical environment.</source>
          <target state="translated">Cada función crea un cierre porque cada función tiene un vínculo con su entorno léxico exterior.</target>
        </trans-unit>
        <trans-unit id="859b310d2eaece93608e0e89cc61e86978cb69a4" translate="yes" xml:space="preserve">
          <source>Every function in JavaScript maintains a link to its outer lexical environment. A lexical environment is a map of all the names (eg. variables, parameters) within a scope, with their values.</source>
          <target state="translated">Cada función en JavaScript mantiene un vínculo con su entorno léxico exterior.Un entorno léxico es un mapa de todos los nombres (por ejemplo,variables,parámetros)dentro de un ámbito,con sus valores.</target>
        </trans-unit>
        <trans-unit id="45ace4e4578d45cf9975840a42650a40883c1e4a" translate="yes" xml:space="preserve">
          <source>Every time you call it, local variable &quot;name&quot; is created and given name &quot;Mary&quot;. And every time the function exits the variable is lost and the name is forgotten.</source>
          <target state="translated">Cada vez que lo llamas,se crea la variable local &quot;nombre&quot; y se le da el nombre de &quot;María&quot;.Y cada vez que la función sale,la variable se pierde y el nombre se olvida.</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="translated">Ejemplo 3</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="translated">Ejemplo 4</target>
        </trans-unit>
        <trans-unit id="dcb2a7f833e9a3ee29881cf3f00069ceeab20571" translate="yes" xml:space="preserve">
          <source>Example 5</source>
          <target state="translated">Ejemplo 5</target>
        </trans-unit>
        <trans-unit id="69126e599801a8577cf34e537a3e5b119797d966" translate="yes" xml:space="preserve">
          <source>Example 6</source>
          <target state="translated">Ejemplo 6</target>
        </trans-unit>
        <trans-unit id="5da743f6856f59f85c81f30e766731f5631a39c2" translate="yes" xml:space="preserve">
          <source>Example 7</source>
          <target state="translated">Ejemplo 7</target>
        </trans-unit>
        <trans-unit id="6f1ddb45d4ea126c3c0d9697dd3671172ae3bca1" translate="yes" xml:space="preserve">
          <source>Example for the first point by dlaliberte:</source>
          <target state="translated">Ejemplo del primer punto por dlaliberte:</target>
        </trans-unit>
        <trans-unit id="9726b2f5643205ff1a7ab0c75e5e5eb34bbe5072" translate="yes" xml:space="preserve">
          <source>Example of a closure that uses the global environment:</source>
          <target state="translated">Ejemplo de un cierre que utiliza el medio ambiente global:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="e262aa4c560f1ae35fd6e5cf5ac45462ea46ecc8" translate="yes" xml:space="preserve">
          <source>F12</source>
          <target state="translated">F12</target>
        </trans-unit>
        <trans-unit id="770cc5fbad4b752ed78f4565ed7a44533e740e5d" translate="yes" xml:space="preserve">
          <source>FOREWORD: this answer was written when the question was:</source>
          <target state="translated">PRÓLOGO:esta respuesta fue escrita cuando la pregunta fue:</target>
        </trans-unit>
        <trans-unit id="23ddff2ba060d9ccf1c6bed76f90cfb75043258a" translate="yes" xml:space="preserve">
          <source>FUNCTION: A function in JavaScript is like a factory. It might be a little factory with only one machine inside. Or it might contain many other little factories, each with many machines doing different jobs. In a real life clothes factory you might have reams of cloth and bobbins of thread going in and T-shirts and jeans coming out. Our JavaScript factory only processes data, it can't sew, drill a hole or melt metal. In our JavaScript factory data goes in and data comes out.</source>
          <target state="translated">FUNCIÓN:Una función en JavaScript es como una fábrica.Podría ser una pequeña fábrica con una sola máquina en su interior.O podría contener muchas otras pequeñas fábricas,cada una con muchas máquinas haciendo diferentes trabajos.En una fábrica de ropa de la vida real puedes tener resmas de tela y bobinas de hilo entrando y camisetas y vaqueros saliendo.Nuestra fábrica de JavaScript sólo procesa datos,no puede coser,perforar un agujero o derretir metal.En nuestra fábrica de JavaScript los datos entran y salen.</target>
        </trans-unit>
        <trans-unit id="8084a292fef2035ee22a2314d1fd8d2ea5ef70cc" translate="yes" xml:space="preserve">
          <source>Fairly Obvious Solution</source>
          <target state="translated">Solución bastante obvia</target>
        </trans-unit>
        <trans-unit id="8d7ca8f60d208999584a7667dd568dbdc67e89aa" translate="yes" xml:space="preserve">
          <source>Final points:</source>
          <target state="translated">Puntos finales:</target>
        </trans-unit>
        <trans-unit id="0db6ddf1596c4847d4487ff8d0eb1324a650d77c" translate="yes" xml:space="preserve">
          <source>First, when a function f is created, it is not created in an empty
space. There is a current LexicalEnvironment object. In the case
above, it&amp;rsquo;s window (a is undefined at the time of function
creation).</source>
          <target state="translated">Primero, cuando se crea una funci&amp;oacute;n f, no se crea en un espacio vac&amp;iacute;o. Hay un objeto LexicalEnvironment actual. En el caso anterior, es una ventana (a no est&amp;aacute; definida en el momento de la creaci&amp;oacute;n de la funci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="2a73ef77ff6936404496b87ca2548febfdec5ccf" translate="yes" xml:space="preserve">
          <source>For an advanced child I would put something like the following. It is not perfect, but it makes you feel about what it is:</source>
          <target state="translated">Para un niño avanzado pondría algo como lo siguiente.No es perfecto,pero te hace sentir lo que es:</target>
        </trans-unit>
        <trans-unit id="ea9adb725d4b9bd42aa2bf3daca3985abf217214" translate="yes" xml:space="preserve">
          <source>For some reason, closures seem really hard to understand when you read about them, but when you see some examples, it becomes clear how they work (it took me a while).
I recommend working through the examples carefully until you understand how they work. If you start using closures without fully understanding how they work, you would soon create some very weird bugs!</source>
          <target state="translated">Por alguna razón,los cierres parecen muy difíciles de entender cuando se lee sobre ellos,pero cuando se ven algunos ejemplos,queda claro cómo funcionan (me llevó un tiempo).Recomiendo trabajar con los ejemplos cuidadosamente hasta que entiendas cómo funcionan.Si empiezas a usar los cierres sin entender completamente cómo funcionan,¡pronto crearás algunos bichos muy raros!</target>
        </trans-unit>
        <trans-unit id="a6457c5f7670ec3d5b6eba35695e935bfa1d35af" translate="yes" xml:space="preserve">
          <source>Full post:</source>
          <target state="translated">Puesto completo:</target>
        </trans-unit>
        <trans-unit id="086a1f90a0a0f91e7d5f1400d0b9f2eaa0c70efd" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;bar&lt;/code&gt;, together with its link with the lexical environment of function &lt;code&gt;foo&lt;/code&gt; is a closure.</source>
          <target state="translated">La &lt;code&gt;bar&lt;/code&gt; ra de funciones, junto con su v&amp;iacute;nculo con el entorno l&amp;eacute;xico de la funci&amp;oacute;n &lt;code&gt;foo&lt;/code&gt; , es un cierre.</target>
        </trans-unit>
        <trans-unit id="df465d5385e7a5492e6da9185d4edd6ca0741d1e" translate="yes" xml:space="preserve">
          <source>Functions can be nested one inside another, forming a chain of LexicalEnvironments which can also be called a scope chain.</source>
          <target state="translated">Las funciones pueden anidarse una dentro de otra,formando una cadena de entornos léxicos que también puede ser llamada cadena de alcance.</target>
        </trans-unit>
        <trans-unit id="735a10dcfecac98bd4863f42c020b050d39de8ff" translate="yes" xml:space="preserve">
          <source>Functions can return data. One kind of data you can return from a function is another function. When that new function gets returned, all the variables and arguments used in the function that created it don't go away. Instead, that parent function &quot;closes.&quot; In other words, nothing can look inside of it and see the variables it used except for the function it returned. That new function has a special ability to look back inside the function that created it and see the data inside of it.</source>
          <target state="translated">Las funciones pueden devolver datos.Un tipo de datos que puede devolver una función es otra función.Cuando esa nueva función es devuelta,todas las variables y argumentos usados en la función que la creó no desaparecen.En su lugar,esa función madre &quot;se cierra&quot;.En otras palabras,nada puede mirar dentro de ella y ver las variables que usó excepto la función que devolvió.Esa nueva función tiene una habilidad especial para mirar dentro de la función que la creó y ver los datos dentro de ella.</target>
        </trans-unit>
        <trans-unit id="d6e834997432ff006f3ca11dc3e560bb2b2db750" translate="yes" xml:space="preserve">
          <source>Functions define actions  - the main function is about singing. It contains a variable called &lt;em&gt;firstPart&lt;/em&gt; which applies to the singing about the person that applies to each of the verses of the song: &quot;There was &quot; + person + &quot; who swallowed&quot;. If you type &lt;em&gt;firstPart&lt;/em&gt; into the console, you won't get an answer because the variable is locked up in a function - the browser can't see inside the tinted windows of the braces.</source>
          <target state="translated">Las funciones definen acciones: la funci&amp;oacute;n principal se trata de cantar. Contiene una variable llamada &lt;em&gt;firstPart&lt;/em&gt; que se aplica al canto sobre la persona que se aplica a cada uno de los versos de la canci&amp;oacute;n: &quot;Hubo&quot; + persona + &quot;que trag&amp;oacute;&quot;. Si escribe &lt;em&gt;firstPart&lt;/em&gt; en la consola, no obtendr&amp;aacute; una respuesta porque la variable est&amp;aacute; bloqueada en una funci&amp;oacute;n: el navegador no puede ver dentro de las ventanas polarizadas de las llaves.</target>
        </trans-unit>
        <trans-unit id="3ddedd19f21650712b05b0d15a1aaf5ed1d17916" translate="yes" xml:space="preserve">
          <source>Further points that explain why closures are interesting:</source>
          <target state="translated">Otros puntos que explican por qué los cierres son interesantes:</target>
        </trans-unit>
        <trans-unit id="09cf114b1e0fe4fe38544c7a0d90cf0e556abc15" translate="yes" xml:space="preserve">
          <source>GLOBAL VARIABLE: &lt;em&gt;person&lt;/em&gt; is a global variable, meaning that if you change its value from &quot;an old lady&quot; to &quot;a young man&quot;, the &lt;em&gt;person&lt;/em&gt; will keep being a young man until you decide to change it again and that any other function in the code can see that it's a young man. Press the</source>
          <target state="translated">VARIABLE GLOBAL: &lt;em&gt;persona&lt;/em&gt; es una variable global, lo que significa que si cambia su valor de &quot;una anciana&quot; a &quot;un hombre joven&quot;, la &lt;em&gt;persona&lt;/em&gt; seguir&amp;aacute; siendo un hombre joven hasta que decida cambiarlo nuevamente y que cualquier otra funci&amp;oacute;n en El c&amp;oacute;digo puede ver que es un hombre joven. presione el</target>
        </trans-unit>
        <trans-unit id="25334edab2e807f8912b0462c0c1d557fdc5ebe8" translate="yes" xml:space="preserve">
          <source>Get it? So in our primary example, the count variable is contained within the closure and always available to the event handler, so it retains its state from click to click.</source>
          <target state="translated">¿Lo entiendes? Así que en nuestro ejemplo primario,la variable de conteo está contenida dentro del cierre y siempre disponible para el manejador de eventos,por lo que mantiene su estado de clic a clic.</target>
        </trans-unit>
        <trans-unit id="2a0bf64067ba96e19feb251aca269629de4b6291" translate="yes" xml:space="preserve">
          <source>Here is a closure:</source>
          <target state="translated">Aquí hay un cierre:</target>
        </trans-unit>
        <trans-unit id="bcaab99f4090d108eb398f8a65a144183fe65bee" translate="yes" xml:space="preserve">
          <source>Here is a factory that produces calculators that can add and multiply:</source>
          <target state="translated">Aquí hay una fábrica que produce calculadoras que pueden sumar y multiplicar:</target>
        </trans-unit>
        <trans-unit id="26c03c6b51995ce3cc45717ecfc54ea15182bfb0" translate="yes" xml:space="preserve">
          <source>Here is how I can convert my plane story into the code.</source>
          <target state="translated">Así es como puedo convertir mi historia del avión en el código.</target>
        </trans-unit>
        <trans-unit id="542541ad020f39c0dd65066d67e5d1be86126656" translate="yes" xml:space="preserve">
          <source>Here is the summary:</source>
          <target state="translated">Aquí está el resumen:</target>
        </trans-unit>
        <trans-unit id="880f763de0c8735d3a294c36e5df6df573d7c52c" translate="yes" xml:space="preserve">
          <source>Here's one of the examples:</source>
          <target state="translated">Aquí está uno de los ejemplos:</target>
        </trans-unit>
        <trans-unit id="5f5bf51aa2f2759a4b08230274e714f3e06de685" translate="yes" xml:space="preserve">
          <source>How I'd explain it to a six-year-old:</source>
          <target state="translated">Cómo se lo explicaría a un niño de seis años:</target>
        </trans-unit>
        <trans-unit id="2e459856108a5cecf40e139f74b817f2e5e4faa0" translate="yes" xml:space="preserve">
          <source>How do JavaScript closures work</source>
          <target state="translated">¿Cómo funcionan los cierres de JavaScript</target>
        </trans-unit>
        <trans-unit id="31c4f787c21a33dcc90753d93c735b54274f39d7" translate="yes" xml:space="preserve">
          <source>How would you explain JavaScript closures to someone with a knowledge of the concepts they consist of (for example functions, variables and the like), but does not understand closures themselves?</source>
          <target state="translated">¿Cómo explicaría los cierres de JavaScript a alguien que conoce los conceptos en que consisten (por ejemplo,funciones,variables y similares),pero que no entiende los cierres en sí mismos?</target>
        </trans-unit>
        <trans-unit id="d0b12b69fd5500aab9c9d2b4a9addddfd30dacaf" translate="yes" xml:space="preserve">
          <source>However, since &lt;code&gt;tmp&lt;/code&gt; is still hanging around inside &lt;code&gt;bar&lt;/code&gt;'s closure, it is available to be incremented. It will be incremented each time you call &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">Sin embargo, dado que &lt;code&gt;tmp&lt;/code&gt; todav&amp;iacute;a est&amp;aacute; dando vueltas dentro del cierre de la &lt;code&gt;bar&lt;/code&gt; ra , est&amp;aacute; disponible para ser incrementado. Se incrementar&amp;aacute; cada vez que llame a la &lt;code&gt;bar&lt;/code&gt; ra .</target>
        </trans-unit>
        <trans-unit id="be9d4d94dd6f35953099bde147c591bdd84ed51a" translate="yes" xml:space="preserve">
          <source>I have seen &lt;a href=&quot;http://en.wikipedia.org/wiki/Scheme_%28programming_language%29&quot;&gt;the Scheme example&lt;/a&gt; given on Wikipedia, but unfortunately it did not help.</source>
          <target state="translated">He visto &lt;a href=&quot;http://en.wikipedia.org/wiki/Scheme_%28programming_language%29&quot;&gt;el ejemplo de Scheme&lt;/a&gt; dado en Wikipedia, pero desafortunadamente no ayud&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="c32c4a2db55c3bb615ab0b8d8acc3b66dadcac7d" translate="yes" xml:space="preserve">
          <source>I haven't got time to go shopping, so the function needs to know what we have in the fridge to make decisions. Each ingredient has a different cooking time and we want everything to be served hot by the robot at the same time. We need to provide the function with the data about what we like, the function could 'talk' to the fridge, and the function could control the robot.</source>
          <target state="translated">No tengo tiempo para ir de compras,así que la función necesita saber qué tenemos en la nevera para tomar decisiones.Cada ingrediente tiene un tiempo de cocción diferente y queremos que todo sea servido caliente por el robot al mismo tiempo.Necesitamos proporcionar a la función los datos sobre lo que nos gusta,la función podría 'hablar' con la nevera,y la función podría controlar el robot.</target>
        </trans-unit>
        <trans-unit id="f67fa89b4f0fa9a4f122d225bd2121614d8b9416" translate="yes" xml:space="preserve">
          <source>I know there are plenty of solutions already, but I guess that this small and simple script can be useful to demonstrate the concept:</source>
          <target state="translated">Sé que ya hay muchas soluciones,pero supongo que este pequeño y simple guión puede ser útil para demostrar el concepto:</target>
        </trans-unit>
        <trans-unit id="68c15dba4a700bb7a32cb7aad9a30cdd109d35e6" translate="yes" xml:space="preserve">
          <source>I need to know how many times a button has been clicked and do something on every third click...</source>
          <target state="translated">Necesito saber cuántas veces se ha pulsado un botón y hacer algo cada tercer clic...</target>
        </trans-unit>
        <trans-unit id="1729e172673bb9af9294d6a61fc1a00e839e1311" translate="yes" xml:space="preserve">
          <source>I put together an interactive JavaScript tutorial to explain how closures work.
&lt;a href=&quot;http://nathansjslessons.appspot.com&quot;&gt;What's a Closure?&lt;/a&gt;</source>
          <target state="translated">Cre&amp;eacute; un tutorial interactivo de JavaScript para explicar c&amp;oacute;mo funcionan los cierres. &lt;a href=&quot;http://nathansjslessons.appspot.com&quot;&gt;&amp;iquest;Qu&amp;eacute; es un cierre?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="123fc03a330a7c38723bf7555ca4ff7a80024826" translate="yes" xml:space="preserve">
          <source>I still think &lt;a href=&quot;http://code.google.com/apis/ajax/playground/?exp=maps#closure_simple&quot;&gt;Google's explanation&lt;/a&gt; works very well and is concise:</source>
          <target state="translated">Todav&amp;iacute;a creo que &lt;a href=&quot;http://code.google.com/apis/ajax/playground/?exp=maps#closure_simple&quot;&gt;la explicaci&amp;oacute;n de Google&lt;/a&gt; funciona muy bien y es conciso:</target>
        </trans-unit>
        <trans-unit id="0b506f3eb42bcf394c48e9df2a2bec6ef476dbaa" translate="yes" xml:space="preserve">
          <source>I suspect that closures in JavaScript differ from those normally found in functional languages.</source>
          <target state="translated">Sospecho que los cierres en JavaScript difieren de los que se encuentran normalmente en los lenguajes funcionales.</target>
        </trans-unit>
        <trans-unit id="24dbc47ee46dbf67b52513fbd1c704c76d217b00" translate="yes" xml:space="preserve">
          <source>I tend to learn better by GOOD/BAD comparisons. I like to see working code followed by non-working code that someone is likely to encounter. I put together &lt;a href=&quot;http://jsfiddle.net/KMQZK/&quot;&gt;a jsFiddle&lt;/a&gt; that does a comparison and tries to boil down the differences to the simplest explanations I could come up with.</source>
          <target state="translated">Tiendo a aprender mejor mediante comparaciones BUENAS / MALAS. Me gusta ver el c&amp;oacute;digo de trabajo seguido de un c&amp;oacute;digo que no funciona que es probable que alguien encuentre. &lt;a href=&quot;http://jsfiddle.net/KMQZK/&quot;&gt;Cre&amp;eacute; un jsFiddle&lt;/a&gt; que hace una comparaci&amp;oacute;n e intenta reducir las diferencias a las explicaciones m&amp;aacute;s simples que se me ocurrieron.</target>
        </trans-unit>
        <trans-unit id="4b2d52788d16d1aed76a99b2962dd7f9b814a6e8" translate="yes" xml:space="preserve">
          <source>I think normally a closure is a term for both the function along with a captured variable environment. Note that I do not use that definition in this article!</source>
          <target state="translated">Creo que normalmente un cierre es un término para ambos,la función junto con un entorno variable capturado.Tenga en cuenta que no uso esa definición en este artículo!</target>
        </trans-unit>
        <trans-unit id="96ede599b6969e1b90d8c62ab4084c1f1b9581b8" translate="yes" xml:space="preserve">
          <source>I wrote a blog post a while back explaining closures. Here's what I said about closures in terms of &lt;strong&gt;why&lt;/strong&gt; you'd want one.</source>
          <target state="translated">Escrib&amp;iacute; una publicaci&amp;oacute;n de blog hace un tiempo explicando los cierres. Esto es lo que dije sobre los cierres en t&amp;eacute;rminos de &lt;strong&gt;por&lt;/strong&gt; qu&amp;eacute; querr&amp;iacute;as uno.</target>
        </trans-unit>
        <trans-unit id="1f893746796fe79900cf9caf10941e2bdc53f26f" translate="yes" xml:space="preserve">
          <source>I'd simply point them to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures&quot;&gt;Mozilla Closures page&lt;/a&gt;. It's the best, most &lt;strong&gt;concise and simple explanation&lt;/strong&gt; of closure basics and practical usage that I've found. It is highly recommended to anyone learning JavaScript.</source>
          <target state="translated">Simplemente los se&amp;ntilde;alar&amp;iacute;a a la &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures&quot;&gt;p&amp;aacute;gina de cierres de Mozilla&lt;/a&gt; . Es la mejor, m&amp;aacute;s &lt;strong&gt;concisa y simple explicaci&amp;oacute;n&lt;/strong&gt; de los conceptos b&amp;aacute;sicos de cierre y el uso pr&amp;aacute;ctico que he encontrado. Es muy recomendable para cualquiera que est&amp;eacute; aprendiendo JavaScript.</target>
        </trans-unit>
        <trans-unit id="11877a1bd39d64fe0945ea5ee068c0234e433657" translate="yes" xml:space="preserve">
          <source>I'm a big fan of analogy and metaphor when explaining difficult concepts, so let me try my hand with a story.</source>
          <target state="translated">Soy un gran fan de la analogía y la metáfora cuando explico conceptos difíciles,así que déjame probar mi mano con una historia.</target>
        </trans-unit>
        <trans-unit id="6b990bce01318ec63bef46aec64d8b6ab67c944d" translate="yes" xml:space="preserve">
          <source>I'm pretty sure I was one of the only people that attempted to take the initial question literally. Since then, the question has mutated several times, so my answer may now seem incredibly silly &amp;amp; out of place. Hopefully the general idea of the story remains fun for some.</source>
          <target state="translated">Estoy bastante seguro de que fui una de las &amp;uacute;nicas personas que intent&amp;oacute; tomar la pregunta inicial literalmente. Desde entonces, la pregunta ha mutado varias veces, por lo que mi respuesta ahora puede parecer incre&amp;iacute;blemente tonta y fuera de lugar. Esperemos que la idea general de la historia siga siendo divertida para algunos.</target>
        </trans-unit>
        <trans-unit id="4f6b0992401487db0a126fe9e7ad6b66cdcca276" translate="yes" xml:space="preserve">
          <source>If a function accesses its environment, then the function is a closure.</source>
          <target state="translated">Si una función accede a su entorno,entonces la función es un cierre.</target>
        </trans-unit>
        <trans-unit id="f330a42bf372ed8fefe90c64085c3c7240fecf76" translate="yes" xml:space="preserve">
          <source>If a variable is read, but can not be found anywhere, an error is generated.</source>
          <target state="translated">Si se lee una variable,pero no se encuentra en ninguna parte,se genera un error.</target>
        </trans-unit>
        <trans-unit id="3cbc5f197b9dd09fc614b45e91092d33f7f9c144" translate="yes" xml:space="preserve">
          <source>If an inner function is returned by an outer, then the outer lexical environment will persist after the outer function has returned. This is because the outer lexical environment needs to be available if the inner function is eventually invoked.</source>
          <target state="translated">Si una función interna es devuelta por una externa,entonces el ambiente léxico externo persistirá después de que la función externa haya regresado.Esto se debe a que el entorno léxico externo necesita estar disponible si la función interna es eventualmente invocada.</target>
        </trans-unit>
        <trans-unit id="dc578583b34a4a34bae69d350c3dfa0573e54e50" translate="yes" xml:space="preserve">
          <source>If everything seems completely unclear, then the best thing to do is to play with the examples. Reading an explanation is much harder than understanding examples.
My explanations of closures and stack-frames, etc. are not technically correct &amp;mdash; they are gross simplifications intended to help to understand. Once the basic idea is grokked, you can pick up the details later.</source>
          <target state="translated">Si todo parece completamente confuso, entonces lo mejor que puede hacer es jugar con los ejemplos. Leer una explicaci&amp;oacute;n es mucho m&amp;aacute;s dif&amp;iacute;cil que comprender ejemplos. Mis explicaciones de cierres y marcos de pila, etc., no son t&amp;eacute;cnicamente correctas, son simplificaciones groseras destinadas a ayudar a comprender. Una vez que la idea b&amp;aacute;sica es asimilada, puede retomar los detalles m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="4f08569e7c3d79200141ddddd7958d6b1ded5e4e" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;i&lt;/code&gt; is also defined using &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt;, then the output is:</source>
          <target state="translated">Si la variable &lt;code&gt;i&lt;/code&gt; tambi&amp;eacute;n se define usando &lt;code&gt;let&lt;/code&gt; en lugar de &lt;code&gt;var&lt;/code&gt; , entonces la salida es:</target>
        </trans-unit>
        <trans-unit id="460b9688bda10bbf35ef9d0c1b98952a76ebb3ed" translate="yes" xml:space="preserve">
          <source>If you are trying to do any dynamic source code modifications (for example: &lt;code&gt;myFunction = Function(myFunction.toString().replace(/Hello/,'Hola'));&lt;/code&gt;), it won't work if &lt;code&gt;myFunction&lt;/code&gt; is a closure (of course, you would never even think of doing source code string substitution at runtime, but...).</source>
          <target state="translated">Si est&amp;aacute; intentando realizar modificaciones din&amp;aacute;micas en el c&amp;oacute;digo fuente (por ejemplo: &lt;code&gt;myFunction = Function(myFunction.toString().replace(/Hello/,'Hola'));&lt;/code&gt; ), no funcionar&amp;aacute; si &lt;code&gt;myFunction&lt;/code&gt; es un cierre ( por supuesto, nunca pensar&amp;iacute;as en hacer una sustituci&amp;oacute;n de cadena de c&amp;oacute;digo fuente en tiempo de ejecuci&amp;oacute;n, pero ...).</target>
        </trans-unit>
        <trans-unit id="f246fbc5dfee71350f8d01e881e3e75375300e1a" translate="yes" xml:space="preserve">
          <source>If you have &lt;em&gt;just&lt;/em&gt; learned closures (here or elsewhere!), then I am interested in any feedback from you about any changes you might suggest that could make this article clearer. Send an email to morrisjohns.com (morris_closure @). Please note that I am not a guru on JavaScript &amp;mdash; nor on closures.</source>
          <target state="translated">Si &lt;em&gt;acaba de&lt;/em&gt; enterarse de los cierres (&amp;iexcl;aqu&amp;iacute; o en otro lugar!), Entonces me interesan sus comentarios sobre cualquier cambio que pueda sugerir que pueda aclarar este art&amp;iacute;culo. Env&amp;iacute;e un correo electr&amp;oacute;nico a morrisjohns.com (morris_closure @). Tenga en cuenta que no soy un gur&amp;uacute; en JavaScript, ni en los cierres.</target>
        </trans-unit>
        <trans-unit id="6a8ed7866e246c92cf6dd70deac29290fa039a64" translate="yes" xml:space="preserve">
          <source>Imagine - you are playing with your little brothers and sisters in the entire house, and you are moving around with your toys and brought some of them into your older brother's room. After a while your brother returned from the school and went to his room, and he locked inside it, so now you could not access toys left there anymore in a direct way. But you could knock the door and ask your brother for that toys. This is called toy's &lt;em&gt;closure&lt;/em&gt;; your brother made it up for you, and he is now into outer &lt;em&gt;scope&lt;/em&gt;.</source>
          <target state="translated">Imag&amp;iacute;nese: est&amp;aacute; jugando con sus hermanos y hermanas peque&amp;ntilde;os en toda la casa, y se est&amp;aacute; moviendo con sus juguetes y trajo algunos de ellos a la habitaci&amp;oacute;n de su hermano mayor. Despu&amp;eacute;s de un tiempo, tu hermano regres&amp;oacute; de la escuela y fue a su habitaci&amp;oacute;n, y &amp;eacute;l se encerr&amp;oacute; en ella, por lo que ahora ya no puedes acceder a los juguetes que quedan all&amp;iacute; de manera directa. Pero podr&amp;iacute;as tocar la puerta y pedirle a tu hermano esos juguetes. Esto se llama &lt;em&gt;cierre&lt;/em&gt; de juguete; tu hermano te lo invent&amp;oacute;, y ahora est&amp;aacute; fuera del &lt;em&gt;alcance&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fabf25061406e8ca355bbb62da26e81c7a773acf" translate="yes" xml:space="preserve">
          <source>Imagine that the Stack Overflow Vote-Up and Vote-Down button events are implemented as closures, voteUp_click and voteDown_click, that have access to external variables isVotedUp and isVotedDown, which are defined globally. (For simplicity's sake, I am referring to StackOverflow's Question Vote buttons, not the array of Answer Vote buttons.)</source>
          <target state="translated">Imagina que los eventos de desbordamiento de pila Vote-Up y Vote-Down se implementan como cierres,voteUp_click y voteDown_click,que tienen acceso a las variables externas isVotedUp e isVotedDown,que están definidas globalmente.(Por simplicidad,me refiero a los botones de Voto de Preguntas de StackOverflow,no al array de botones de Voto de Respuestas).</target>
        </trans-unit>
        <trans-unit id="34fbb45dfd31d8c76706f4846facff1223ce9ab3" translate="yes" xml:space="preserve">
          <source>In C and most other common languages, &lt;em&gt;after&lt;/em&gt; a function returns, all the local variables are no longer accessible because the stack-frame is destroyed.</source>
          <target state="translated">En C y en la mayor&amp;iacute;a de los otros lenguajes comunes, &lt;em&gt;despu&amp;eacute;s de que&lt;/em&gt; una funci&amp;oacute;n regresa, todas las variables locales ya no son accesibles porque el marco de la pila se destruye.</target>
        </trans-unit>
        <trans-unit id="bde892a91769451e6aae5176cd04fd8bb3c261d1" translate="yes" xml:space="preserve">
          <source>In JavaScript, if you declare a function within another function, then the local variables of the outer function can remain accessible after returning from it. This is demonstrated above, because we call the function &lt;code&gt;say2()&lt;/code&gt; after we have returned from &lt;code&gt;sayHello2()&lt;/code&gt;. Notice that the code that we call references the variable &lt;code&gt;text&lt;/code&gt;, which was a &lt;em&gt;local variable&lt;/em&gt; of the function &lt;code&gt;sayHello2()&lt;/code&gt;.</source>
          <target state="translated">En JavaScript, si declara una funci&amp;oacute;n dentro de otra funci&amp;oacute;n, las variables locales de la funci&amp;oacute;n externa pueden permanecer accesibles despu&amp;eacute;s de regresar de ella. Esto se demostr&amp;oacute; anteriormente, porque llamamos a la funci&amp;oacute;n &lt;code&gt;say2()&lt;/code&gt; despu&amp;eacute;s de haber regresado de &lt;code&gt;sayHello2()&lt;/code&gt; . Observe que el c&amp;oacute;digo que llamamos hace referencia a la variable &lt;code&gt;text&lt;/code&gt; o , que era una &lt;em&gt;variable local&lt;/em&gt; de la funci&amp;oacute;n &lt;code&gt;sayHello2()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66588c3a466a757d86d3ce97ab53a9423b323372" translate="yes" xml:space="preserve">
          <source>In a closure, the variables in the outer lexical environment &lt;em&gt;themselves&lt;/em&gt; are available, &lt;em&gt;not&lt;/em&gt; copies.</source>
          <target state="translated">En un cierre, las variables en el entorno l&amp;eacute;xico externo est&amp;aacute;n disponibles, &lt;em&gt;no&lt;/em&gt; copias.</target>
        </trans-unit>
        <trans-unit id="be9e7184ed47abdf916495732c707da00b0bef5c" translate="yes" xml:space="preserve">
          <source>In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function.</source>
          <target state="translated">En la informática,un cierre es una función junto con un entorno de referencia para los nombres no locales (variables libres)de esa función.</target>
        </trans-unit>
        <trans-unit id="7f7dd1aaa3a43450511e179ef4935d2bfcf91e9f" translate="yes" xml:space="preserve">
          <source>In that sense, they let a function act a bit like an object with private attributes.</source>
          <target state="translated">En ese sentido,dejan que una función actúe un poco como un objeto con atributos privados.</target>
        </trans-unit>
        <trans-unit id="0c18c47099c91026c3cd731edf3696ce2d7f9082" translate="yes" xml:space="preserve">
          <source>In the above code &lt;code&gt;createClosure(n)&lt;/code&gt; is invoked in every iteration of the loop. Note that I named the variable &lt;code&gt;n&lt;/code&gt; to highlight that it is a &lt;strong&gt;new&lt;/strong&gt; variable created in a new function scope and is not the same variable as &lt;code&gt;index&lt;/code&gt; which is bound to the outer scope.</source>
          <target state="translated">En el c&amp;oacute;digo anterior se invoca &lt;code&gt;createClosure(n)&lt;/code&gt; en cada iteraci&amp;oacute;n del bucle. Tenga en cuenta que nombr&amp;eacute; la variable &lt;code&gt;n&lt;/code&gt; para resaltar que es una &lt;strong&gt;nueva&lt;/strong&gt; variable creada en un nuevo alcance de funci&amp;oacute;n y no es la misma variable que el &lt;code&gt;index&lt;/code&gt; que est&amp;aacute; vinculado al alcance externo.</target>
        </trans-unit>
        <trans-unit id="64ccd305f21918c690c8faf2eee3f539cb44d848" translate="yes" xml:space="preserve">
          <source>In the above code the loop was moved within the &lt;code&gt;createClosureArray()&lt;/code&gt; function and the function now just returns the completed array, which at first glance seems more intuitive.</source>
          <target state="translated">En el c&amp;oacute;digo anterior, el bucle se movi&amp;oacute; dentro de la funci&amp;oacute;n &lt;code&gt;createClosureArray()&lt;/code&gt; y la funci&amp;oacute;n ahora solo devuelve la matriz completa, que a primera vista parece m&amp;aacute;s intuitiva.</target>
        </trans-unit>
        <trans-unit id="b564dadb6ceca4494d7653f8c5e95bc5a27eaf2b" translate="yes" xml:space="preserve">
          <source>In the above example, I am using the closure behavior of JavaScript. &lt;strong&gt;This behavior allows any function to have access to the scope in which it was created, indefinitely.&lt;/strong&gt; To practically apply this, I immediately invoke a function that returns another function, and because the function I'm returning has access to the internal count variable (because of the closure behavior explained above) this results in a private scope for usage by the resulting function... Not so simple? Let's dilute it down...</source>
          <target state="translated">En el ejemplo anterior, estoy usando el comportamiento de cierre de JavaScript. &lt;strong&gt;Este comportamiento permite que cualquier funci&amp;oacute;n tenga acceso al &amp;aacute;mbito en el que se cre&amp;oacute;, de forma indefinida.&lt;/strong&gt; Para aplicar esto pr&amp;aacute;cticamente, invoco inmediatamente una funci&amp;oacute;n que devuelve otra funci&amp;oacute;n, y debido a que la funci&amp;oacute;n que estoy devolviendo tiene acceso a la variable de recuento interno (debido al comportamiento de cierre explicado anteriormente), esto da como resultado un &amp;aacute;mbito privado para el uso por el resultado funci&amp;oacute;n ... &amp;iquest;No es tan simple? Vamos a diluirlo ...</target>
        </trans-unit>
        <trans-unit id="52291f67af5b2a395aa91f417749282ffa321ce5" translate="yes" xml:space="preserve">
          <source>In the above example, outerFunction is called which in turn calls innerFunction. Note how outerVar is available to innerFunction, evidenced by its correctly alerting the value of outerVar.</source>
          <target state="translated">En el ejemplo anterior,se llama función externa,que a su vez se llama función interna.Obsérvese cómo el VAR exterior está disponible para la Función Interna,lo que se evidencia en que alerta correctamente el valor del VAR exterior.</target>
        </trans-unit>
        <trans-unit id="9accb51a40f9456dfff0b9b647c4adc451c98ff8" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;f&lt;/code&gt; closes over the lexical environment of the global execution context:</source>
          <target state="translated">En el siguiente ejemplo, la funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; se cierra sobre el entorno l&amp;eacute;xico del contexto de ejecuci&amp;oacute;n global:</target>
        </trans-unit>
        <trans-unit id="79e7feaad903ac12e4a4780516074d3c8e273603" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;h&lt;/code&gt; closes over the lexical environment of function &lt;code&gt;g&lt;/code&gt;, which, in turn, closes over the lexical environment of the global execution context.</source>
          <target state="translated">En el siguiente ejemplo, la funci&amp;oacute;n &lt;code&gt;h&lt;/code&gt; se cierra sobre el entorno l&amp;eacute;xico de la funci&amp;oacute;n &lt;code&gt;g&lt;/code&gt; , que, a su vez, se cierra sobre el entorno l&amp;eacute;xico del contexto de ejecuci&amp;oacute;n global.</target>
        </trans-unit>
        <trans-unit id="d208e23250c79929b1202ec211a36dbeb87b68f9" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;j&lt;/code&gt; closes over the lexical environment of function &lt;code&gt;i&lt;/code&gt;, meaning that variable &lt;code&gt;x&lt;/code&gt; is visible from inside function &lt;code&gt;j&lt;/code&gt;, long after function &lt;code&gt;i&lt;/code&gt; has completed execution:</source>
          <target state="translated">En el siguiente ejemplo, la funci&amp;oacute;n &lt;code&gt;j&lt;/code&gt; se cierra sobre el entorno l&amp;eacute;xico de la funci&amp;oacute;n &lt;code&gt;i&lt;/code&gt; , lo que significa que la variable &lt;code&gt;x&lt;/code&gt; es visible desde el interior de la funci&amp;oacute;n &lt;code&gt;j&lt;/code&gt; , mucho despu&amp;eacute;s de que la funci&amp;oacute;n &lt;code&gt;i&lt;/code&gt; haya completado la ejecuci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="9a42d2846a79c733d7b14604fa1cb2c0c4772121" translate="yes" xml:space="preserve">
          <source>In the terminology of the ECMAScript specification, a closure can be said to be implemented by the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt;&lt;code&gt;[[Environment]]&lt;/code&gt;&lt;/a&gt; reference of every function-object, which points to the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;lexical environment&lt;/a&gt; within which the function is defined.</source>
          <target state="translated">En la terminolog&amp;iacute;a de la especificaci&amp;oacute;n ECMAScript, se puede decir que un cierre se implementa mediante la referencia &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt; &lt;code&gt;[[Environment]]&lt;/code&gt; &lt;/a&gt; de cada objeto de funci&amp;oacute;n, que apunta al &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;entorno l&amp;eacute;xico&lt;/a&gt; dentro del cual se define la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="88a0303f59536ee17cc71dcac48a7690fb59fb0b" translate="yes" xml:space="preserve">
          <source>In this case, the interpreter finds the variable in the
outer &lt;a href=&quot;http://javascript.info/tutorial/initialization&quot;&gt;&lt;code&gt;LexicalEnvironment&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">En este caso, el int&amp;eacute;rprete encuentra la variable en el objeto externo &lt;a href=&quot;http://javascript.info/tutorial/initialization&quot;&gt; &lt;code&gt;LexicalEnvironment&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="517b1409687da9d9fcb673e99fbcc8dd23f7ee52" translate="yes" xml:space="preserve">
          <source>In this final example, each call to the main function creates a separate closure.</source>
          <target state="translated">En este último ejemplo,cada llamada a la función principal crea un cierre separado.</target>
        </trans-unit>
        <trans-unit id="c7149ac43259f5072dae076e7d470d21214d7c4c" translate="yes" xml:space="preserve">
          <source>Inner functions like &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt;, which access variables declared in an outer function&lt;sup&gt;**&lt;/sup&gt;, are called &lt;em&gt;closures&lt;/em&gt;.</source>
          <target state="translated">Las funciones internas como &lt;code&gt;add&lt;/code&gt; y &lt;code&gt;multiply&lt;/code&gt; , que variables de acceso declaradas en una funci&amp;oacute;n externa &lt;sup&gt;**&lt;/sup&gt; , se denominan &lt;em&gt;cierres&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c535437331e2cd1ff0b52dab323b734568fde96b" translate="yes" xml:space="preserve">
          <source>It is possible to nest function declarations within function declarations within function declarations&amp;hellip;; you can get closures at more than one level.</source>
          <target state="translated">Es posible anidar declaraciones de funciones dentro de declaraciones de funciones dentro de declaraciones de funciones ...; Puede obtener cierres en m&amp;aacute;s de un nivel.</target>
        </trans-unit>
        <trans-unit id="bd8a1c5b969fb5ce6751ab00fdc753d6fe50bc42" translate="yes" xml:space="preserve">
          <source>It may be helpful to see what happens when a block-level declaration of the variable &lt;code&gt;item&lt;/code&gt; is used (via the &lt;code&gt;let&lt;/code&gt; keyword) instead of a function-scoped variable declaration via the &lt;code&gt;var&lt;/code&gt; keyword. If that change is made, then each anonymous function in the array &lt;code&gt;result&lt;/code&gt; has its own closure; when the example is run the output is as follows:</source>
          <target state="translated">Puede ser &amp;uacute;til ver qu&amp;eacute; sucede cuando se usa una declaraci&amp;oacute;n de nivel de bloque del &lt;code&gt;item&lt;/code&gt; variable (a trav&amp;eacute;s de la palabra clave &lt;code&gt;let&lt;/code&gt; ) en lugar de una declaraci&amp;oacute;n de variable con &amp;aacute;mbito de funci&amp;oacute;n a trav&amp;eacute;s de la palabra clave &lt;code&gt;var&lt;/code&gt; . Si se realiza ese cambio, entonces cada funci&amp;oacute;n an&amp;oacute;nima en el &lt;code&gt;result&lt;/code&gt; ado de la matriz tiene su propio cierre; cuando se ejecuta el ejemplo, la salida es la siguiente:</target>
        </trans-unit>
        <trans-unit id="3f6d29d5da52be16dfb12c7815fe37a9ce3fcf16" translate="yes" xml:space="preserve">
          <source>JAVASCRIPT: JavaScript is a language. Like English or French or Chinese are languages. There are lots of languages that are understood by computers and other electronic processors. For JavaScript to be understood by a computer it needs an interpreter. Imagine if a teacher who only speaks Russian comes to teach your class at school. When the teacher says &quot;все садятся&quot;, the class would not understand. But luckily you have a Russian pupil in your class who tells everyone this means &quot;everybody sit down&quot; - so you all do. The class is like a computer and the Russian pupil is the interpreter. For JavaScript the most common interpreter is called a browser.</source>
          <target state="translated">JAVASCRIPT:JavaScript es un lenguaje.Como el inglés,el francés o el chino son idiomas.Hay muchos idiomas que son entendidos por las computadoras y otros procesadores electrónicos.Para que un ordenador entienda el JavaScript necesita un intérprete.Imagina si un profesor que sólo habla ruso viene a enseñar tu clase en la escuela.Cuando el profesor dice &quot;все садятся&quot;,la clase no lo entendería.Pero por suerte tienes un alumno ruso en tu clase que le dice a todo el mundo que esto significa &quot;todo el mundo se sienta&quot;-así que todos lo hacéis.La clase es como un ordenador y el alumno ruso es el intérprete.Para JavaScript el intérprete más común se llama navegador.</target>
        </trans-unit>
        <trans-unit id="f15fd20b3b607a06e5de7b00b5c8829cba54783d" translate="yes" xml:space="preserve">
          <source>JavaScript closures for beginners</source>
          <target state="translated">Cierres de JavaScript para principiantes</target>
        </trans-unit>
        <trans-unit id="a4ad1062dbb50a6179be99978ca0015111394d54" translate="yes" xml:space="preserve">
          <source>JavaScript functions can access their:</source>
          <target state="translated">Las funciones de JavaScript pueden acceder a su:</target>
        </trans-unit>
        <trans-unit id="18356dc7f56408ba6d488b26a212e8a89b8f9645" translate="yes" xml:space="preserve">
          <source>Let's imagine the next situation: a driver is sitting in a car. That car is inside a plane. Plane is in the airport. The ability of driver to access things outside his car, but inside the plane, even if that plane leaves an airport, is a closure. That's it. When you turn 27, look at the &lt;a href=&quot;https://stackoverflow.com/a/111200/1393791&quot;&gt;more detailed explanation&lt;/a&gt; or at the example below.</source>
          <target state="translated">Imaginemos la siguiente situaci&amp;oacute;n: un conductor est&amp;aacute; sentado en un autom&amp;oacute;vil. Ese auto est&amp;aacute; dentro de un avi&amp;oacute;n. El avi&amp;oacute;n est&amp;aacute; en el aeropuerto. La capacidad del conductor para acceder a cosas fuera de su autom&amp;oacute;vil, pero dentro del avi&amp;oacute;n, incluso si ese avi&amp;oacute;n sale de un aeropuerto, es un cierre. Eso es. Cuando cumpla 27 a&amp;ntilde;os, mire la &lt;a href=&quot;https://stackoverflow.com/a/111200/1393791&quot;&gt;explicaci&amp;oacute;n m&amp;aacute;s detallada&lt;/a&gt; o el ejemplo a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="09b200c5ade4b1cb4a297a00afe3d45be8c9d80e" translate="yes" xml:space="preserve">
          <source>Like the old Albert said : &quot;If you can't explain it to a six-year old, you really don't understand it yourself.&amp;rdquo;. Well I tried to explain JS closures to a 27 years old friend and completely failed.</source>
          <target state="translated">Como dijo el viejo Albert: &quot;Si no puedes explic&amp;aacute;rselo a un ni&amp;ntilde;o de seis a&amp;ntilde;os, realmente no lo entiendes t&amp;uacute; mismo&quot;. Bueno, intent&amp;eacute; explicar los cierres de JS a un amigo de 27 a&amp;ntilde;os y fracas&amp;eacute; por completo.</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="f4346c3dbf21e346a2dead6609d901d087e13650" translate="yes" xml:space="preserve">
          <source>Locals (that is, their local variables and local functions)</source>
          <target state="translated">Locales (es decir,sus variables locales y funciones locales)</target>
        </trans-unit>
        <trans-unit id="2b0aed7bf52a8c5e0e0cefef3f3b339f8c820a34" translate="yes" xml:space="preserve">
          <source>Looking at the output of &lt;code&gt;say2.toString()&lt;/code&gt;, we can see that the code refers to the variable &lt;code&gt;text&lt;/code&gt;. The anonymous function can reference &lt;code&gt;text&lt;/code&gt; which holds the value &lt;code&gt;'Hello Bob'&lt;/code&gt; because the local variables of &lt;code&gt;sayHello2()&lt;/code&gt; have been secretly kept alive in a closure.</source>
          <target state="translated">Mirando la salida de &lt;code&gt;say2.toString()&lt;/code&gt; , podemos ver que el c&amp;oacute;digo se refiere al &lt;code&gt;text&lt;/code&gt; o variable. La funci&amp;oacute;n an&amp;oacute;nima puede hacer referencia a &lt;code&gt;text&lt;/code&gt; o que contiene el valor &lt;code&gt;'Hello Bob'&lt;/code&gt; porque las variables locales de &lt;code&gt;sayHello2()&lt;/code&gt; se han mantenido secretamente vivas en un cierre.</target>
        </trans-unit>
        <trans-unit id="5628f8a6b5fea1b9beca93e689568ae4c8efb6d1" translate="yes" xml:space="preserve">
          <source>Marking up LexicalEnvironments:</source>
          <target state="translated">Marcando los ambientes léxicos:</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes" xml:space="preserve">
          <source>More examples</source>
          <target state="translated">Más ejemplos</target>
        </trans-unit>
        <trans-unit id="6f01bda547a9bb9e65d7ba349d7f92d2d69752b9" translate="yes" xml:space="preserve">
          <source>Most JavaScript programmers will understand how a reference to a function is returned to a variable (&lt;code&gt;say2&lt;/code&gt;) in the above code. If you don't, then you need to look at that before you can learn closures. A programmer using C would think of the function as returning a pointer to a function, and that the variables &lt;code&gt;say&lt;/code&gt; and &lt;code&gt;say2&lt;/code&gt; were each a pointer to a function.</source>
          <target state="translated">La mayor&amp;iacute;a de los programadores de JavaScript entender&amp;aacute;n c&amp;oacute;mo se devuelve una referencia a una funci&amp;oacute;n a una variable (por &lt;code&gt;say2&lt;/code&gt; ) en el c&amp;oacute;digo anterior. Si no lo hace, entonces debe mirar eso antes de poder aprender los cierres. Un programador que usa C pensar&amp;iacute;a que la funci&amp;oacute;n devuelve un puntero a una funci&amp;oacute;n, y que las variables &lt;code&gt;say&lt;/code&gt; y &lt;code&gt;say2&lt;/code&gt; son cada una un puntero a una funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fd66b2800310560a1ce2ba5a794b44747c843f0e" translate="yes" xml:space="preserve">
          <source>NAME: You can call a function just about whatever word you want. The example &quot;cookMeal&quot; is typical in joining two words together and giving the second one a capital letter at the beginning - but this is not necessary. It can't have a space in it, and it can't be a number on its own.</source>
          <target state="translated">NOMBRE:Puedes llamar a una función con la palabra que quieras.El ejemplo &quot;cocinar-comida&quot; es típico en la unión de dos palabras y dar a la segunda una letra mayúscula al principio-pero esto no es necesario.No puede tener un espacio en ella,y no puede ser un número por sí solo.</target>
        </trans-unit>
        <trans-unit id="40c3e770c196ccb030cf74232292c69eb60717a3" translate="yes" xml:space="preserve">
          <source>Note that in the above example, if you call &lt;code&gt;setupSomeGlobals()&lt;/code&gt; again, then a new closure (stack-frame!) is created. The old &lt;code&gt;gLogNumber&lt;/code&gt;, &lt;code&gt;gIncreaseNumber&lt;/code&gt;, &lt;code&gt;gSetNumber&lt;/code&gt; variables are overwritten with &lt;em&gt;new&lt;/em&gt; functions that have the new closure. (In JavaScript, whenever you declare a function inside another function, the inside function(s) is/are recreated again &lt;em&gt;each&lt;/em&gt; time the outside function is called.)</source>
          <target state="translated">Tenga en cuenta que en el ejemplo anterior, si llama a &lt;code&gt;setupSomeGlobals()&lt;/code&gt; nuevamente, se crea un nuevo cierre (stack-frame!). Las antiguas &lt;code&gt;gLogNumber&lt;/code&gt; , &lt;code&gt;gIncreaseNumber&lt;/code&gt; , &lt;code&gt;gSetNumber&lt;/code&gt; se sobrescriben con &lt;em&gt;nuevas&lt;/em&gt; funciones que tienen el nuevo cierre. (En JavaScript, cada vez que declara una funci&amp;oacute;n dentro de otra funci&amp;oacute;n, las funciones internas se vuelven a crear &lt;em&gt;cada&lt;/em&gt; vez que se llama a la funci&amp;oacute;n externa).</target>
        </trans-unit>
        <trans-unit id="7dc2f9bd9efd8d1e52cbf8c35413ba1f4105f5a9" translate="yes" xml:space="preserve">
          <source>Note that outer functions are not required, though they do offer benefits I don't discuss here. By accessing data in its environment, a closure keeps that data alive. In the subcase of outer/inner functions, an outer function can create local data and eventually exit, and yet, if any inner function(s) survive after the outer function exits, then the inner function(s) keep the outer function's local data alive.</source>
          <target state="translated">Tenga en cuenta que las funciones externas no son necesarias,aunque ofrecen beneficios que no discuto aquí.Al acceder a los datos de su entorno,un cierre mantiene esos datos vivos.En el subcaso de las funciones externas internas,una función externa puede crear datos locales y eventualmente salir,y aún así,si alguna función(es)interna(s)sobrevive(n)después de que la función externa sale,entonces la(s)función(es)interna(s)mantiene(n)vivos los datos locales de la función externa.</target>
        </trans-unit>
        <trans-unit id="4b7d6be3be4533ef766e4ba6b6589adcce7bd0a0" translate="yes" xml:space="preserve">
          <source>Note that variables &lt;em&gt;themselves&lt;/em&gt; are visible from within a closure, &lt;em&gt;not&lt;/em&gt; copies.</source>
          <target state="translated">Tenga en cuenta que las variables en &lt;em&gt;s&amp;iacute;&lt;/em&gt; son visibles desde un cierre, &lt;em&gt;no&lt;/em&gt; copias.</target>
        </trans-unit>
        <trans-unit id="9dccaff8b91f1ebe851d8b10d10b8abb4daae146" translate="yes" xml:space="preserve">
          <source>Note that when you run the example, &lt;code&gt;&quot;item2 undefined&quot;&lt;/code&gt; is logged three times! This is because just like previous examples, there is only one closure for the local variables for &lt;code&gt;buildList&lt;/code&gt; (which are &lt;code&gt;result&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;item&lt;/code&gt;). When the anonymous functions are called on the line &lt;code&gt;fnlist[j]()&lt;/code&gt;; they all use the same single closure, and they use the current value for &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;item&lt;/code&gt; within that one closure (where &lt;code&gt;i&lt;/code&gt; has a value of &lt;code&gt;3&lt;/code&gt; because the loop had completed, and &lt;code&gt;item&lt;/code&gt; has a value of &lt;code&gt;'item2'&lt;/code&gt;). Note we are indexing from 0 hence &lt;code&gt;item&lt;/code&gt; has a value of &lt;code&gt;item2&lt;/code&gt;. And the i++ will increment &lt;code&gt;i&lt;/code&gt; to the value &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">Tenga en cuenta que cuando ejecuta el ejemplo, &lt;code&gt;&quot;item2 undefined&quot;&lt;/code&gt; se registra tres veces. Esto se debe a que, al igual que en los ejemplos anteriores, solo hay un cierre para las variables locales para &lt;code&gt;buildList&lt;/code&gt; (que son &lt;code&gt;result&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; y &lt;code&gt;item&lt;/code&gt; ). Cuando las funciones an&amp;oacute;nimas se &lt;code&gt;fnlist[j]()&lt;/code&gt; en la l&amp;iacute;nea fnlist [j] () ; todos usan el mismo cierre individual, y usan el valor actual para &lt;code&gt;i&lt;/code&gt; y &lt;code&gt;item&lt;/code&gt; dentro de ese cierre (donde &lt;code&gt;i&lt;/code&gt; un valor de &lt;code&gt;3&lt;/code&gt; porque el ciclo se ha completado y el &lt;code&gt;item&lt;/code&gt; tiene un valor de &lt;code&gt;'item2'&lt;/code&gt; ). Tenga en cuenta que estamos indexando desde 0, por lo tanto, el &lt;code&gt;item&lt;/code&gt; tiene un valor de &lt;code&gt;item2&lt;/code&gt; . Y el i ++ incrementar&amp;aacute; &lt;code&gt;i&lt;/code&gt; al valor &lt;code&gt;3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2632a4becd02c75c95693519f5cf180b44a90456" translate="yes" xml:space="preserve">
          <source>Notice a few things here.</source>
          <target state="translated">Note algunas cosas aquí.</target>
        </trans-unit>
        <trans-unit id="3393c390f2f8f559d4a2a520da1ec907eaeea621" translate="yes" xml:space="preserve">
          <source>Now consider the following:</source>
          <target state="translated">Ahora considera lo siguiente:</target>
        </trans-unit>
        <trans-unit id="8495e70502d881bdf9b4145e67ce317efd57faac" translate="yes" xml:space="preserve">
          <source>Now this will work, but it does encroach into the outer scope by adding a variable, whose sole purpose is to keep track of the count. In some situations, this would be preferable as your outer application might need access to this information. But in this case, we are only changing every third click's behavior, so it is preferable to &lt;strong&gt;enclose this functionality inside the event handler&lt;/strong&gt;.</source>
          <target state="translated">Ahora esto funcionar&amp;aacute;, pero invade el alcance externo al agregar una variable, cuyo &amp;uacute;nico prop&amp;oacute;sito es realizar un seguimiento del recuento. En algunas situaciones, esto ser&amp;iacute;a preferible ya que su aplicaci&amp;oacute;n externa podr&amp;iacute;a necesitar acceso a esta informaci&amp;oacute;n. Pero en este caso, solo estamos cambiando el comportamiento de cada tercer clic, por lo que es preferible &lt;strong&gt;incluir esta funcionalidad dentro del controlador de eventos&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="edc821fed74b8a83207ffcc4a681c6656cb0dbd9" translate="yes" xml:space="preserve">
          <source>Now what it &lt;em&gt;allows&lt;/em&gt; you to do can be more spectacular, see other answers.</source>
          <target state="translated">Ahora lo que te &lt;em&gt;permite&lt;/em&gt; hacer puede ser m&amp;aacute;s espectacular, mira otras respuestas.</target>
        </trans-unit>
        <trans-unit id="37b00465e1d26162d39a6df745e20f2e4e1c3722" translate="yes" xml:space="preserve">
          <source>Now, after the function &lt;em&gt;sing()&lt;/em&gt;, near the end of the code is the line</source>
          <target state="translated">Ahora, despu&amp;eacute;s de la funci&amp;oacute;n &lt;em&gt;sing ()&lt;/em&gt; , cerca del final del c&amp;oacute;digo est&amp;aacute; la l&amp;iacute;nea</target>
        </trans-unit>
        <trans-unit id="2b6292f13ea61f03e46a26b717197499baebf90b" translate="yes" xml:space="preserve">
          <source>Now, where's the definition of &lt;code&gt;x&lt;/code&gt;? We didn't define it in the current scope. The only solution is to let &lt;code&gt;plus5&lt;/code&gt;&lt;em&gt;carry&lt;/em&gt; its scope (or rather, its parent's scope) around. This way, &lt;code&gt;x&lt;/code&gt; is well-defined and it is bound to the value 5.</source>
          <target state="translated">Ahora, &amp;iquest;d&amp;oacute;nde est&amp;aacute; la definici&amp;oacute;n de &lt;code&gt;x&lt;/code&gt; ? No lo definimos en el alcance actual. La &amp;uacute;nica soluci&amp;oacute;n es dejar que &lt;code&gt;plus5&lt;/code&gt; &lt;em&gt;lleve&lt;/em&gt; su alcance (o m&amp;aacute;s bien, el alcance de su padre). De esta manera, &lt;code&gt;x&lt;/code&gt; est&amp;aacute; bien definido y est&amp;aacute; vinculado al valor 5.</target>
        </trans-unit>
        <trans-unit id="9e15ed596afd3bc19fd5d61a060bb2a47cddef9b" translate="yes" xml:space="preserve">
          <source>OK, 6-year-old closures fan. Do you want to hear the simplest example of closure?</source>
          <target state="translated">Bien,un niño de 6 años cierra el ventilador.¿Quieres oír el ejemplo más simple de cierre?</target>
        </trans-unit>
        <trans-unit id="d722330a80b9bc2dfce4ab9f7b615cda1f5e4764" translate="yes" xml:space="preserve">
          <source>Okay, talking with a 6-year old child, I would possibly use following associations.</source>
          <target state="translated">Bien,hablando con un niño de 6 años,posiblemente usaría las siguientes asociaciones.</target>
        </trans-unit>
        <trans-unit id="148abbffcf1d27e45f3fc36604ef1e94841e9e4b" translate="yes" xml:space="preserve">
          <source>On  &lt;a href=&quot;http://www.howkidsdevelop.com/5-7years.html&quot;&gt;Childhood Development: 5 to 7 Years &lt;/a&gt; it says:</source>
          <target state="translated">Sobre &lt;a href=&quot;http://www.howkidsdevelop.com/5-7years.html&quot;&gt;desarrollo infantil: 5 a 7 a&amp;ntilde;os&lt;/a&gt; dice:</target>
        </trans-unit>
        <trans-unit id="34b3df084cbf5c7a669b26ff1aacf3c99a1d1dc8" translate="yes" xml:space="preserve">
          <source>Original post by Morris can be found in the &lt;a href=&quot;http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies&quot;&gt;Internet Archive&lt;/a&gt;.</source>
          <target state="translated">La publicaci&amp;oacute;n original de Morris se puede encontrar en &lt;a href=&quot;http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies&quot;&gt;Internet Archive&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="681216b5a1437efa0ee50e426313a7fe8126153e" translate="yes" xml:space="preserve">
          <source>Our code begins with the word &lt;em&gt;function&lt;/em&gt;, so we know that it is one! Then the name of the function &lt;em&gt;sing&lt;/em&gt; - that's my own description of what the function is about. Then parentheses &lt;em&gt;()&lt;/em&gt;. The parentheses are always there for a function. Sometimes they are empty, and sometimes they have something in. This one has a word in: &lt;code&gt;(person)&lt;/code&gt;. After this there is a brace like this &lt;code&gt;{&lt;/code&gt; . This marks the start of the function &lt;em&gt;sing()&lt;/em&gt;. It has a partner which marks the end of &lt;em&gt;sing()&lt;/em&gt; like this &lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">Nuestro c&amp;oacute;digo comienza con la palabra &lt;em&gt;funci&amp;oacute;n&lt;/em&gt; , &amp;iexcl;as&amp;iacute; que sabemos que es uno! Luego, el nombre de la funci&amp;oacute;n &lt;em&gt;sing&lt;/em&gt; : esa es mi propia descripci&amp;oacute;n de lo que se trata la funci&amp;oacute;n. Luego par&amp;eacute;ntesis &lt;em&gt;()&lt;/em&gt; . Los par&amp;eacute;ntesis siempre est&amp;aacute;n ah&amp;iacute; para una funci&amp;oacute;n. Algunas veces est&amp;aacute;n vac&amp;iacute;as, y algunas veces tienen algo adentro. Esta palabra tiene una palabra: &lt;code&gt;(person)&lt;/code&gt; . Despu&amp;eacute;s de esto hay un aparato ortop&amp;eacute;dico como este &lt;code&gt;{&lt;/code&gt; . Esto marca el inicio de la funci&amp;oacute;n &lt;em&gt;sing ()&lt;/em&gt; . Tiene un compa&amp;ntilde;ero que marca el final de &lt;em&gt;sing ()&lt;/em&gt; as&amp;iacute; &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05c242ba6271e12b61564339fb6644d07e822a54" translate="yes" xml:space="preserve">
          <source>PARENTHESES: &quot;Parentheses&quot; or &lt;code&gt;()&lt;/code&gt; are the letter box on the JavaScript function factory's door or a post box in the street for sending packets of information to the factory. Sometimes the postbox might be marked &lt;em&gt;for example&lt;/em&gt;&lt;code&gt;cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime)&lt;/code&gt;, in which case you know what data you have to give it.</source>
          <target state="translated">PADRES: &quot;Par&amp;eacute;ntesis&quot; o &lt;code&gt;()&lt;/code&gt; son el buz&amp;oacute;n en la puerta de la f&amp;aacute;brica de funciones de JavaScript o un buz&amp;oacute;n en la calle para enviar paquetes de informaci&amp;oacute;n a la f&amp;aacute;brica. A veces, el buz&amp;oacute;n puede estar marcado, &lt;em&gt;por ejemplo,&lt;/em&gt; &lt;code&gt;cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime)&lt;/code&gt; , en cuyo caso usted sabe qu&amp;eacute; datos tiene que proporcionar.</target>
        </trans-unit>
        <trans-unit id="9144b2a7d95b704078de888cf37d60fe67becfb9" translate="yes" xml:space="preserve">
          <source>Perhaps a little beyond all but the most precocious of six-year-olds, but a few examples that helped make the concept of closure in JavaScript click for me.</source>
          <target state="translated">Tal vez un poco más allá de todos pero el más precoz de los niños de seis años,pero algunos ejemplos que ayudaron a que el concepto de cierre en JavaScript haga clic para mí.</target>
        </trans-unit>
        <trans-unit id="5faa59d4bc3756040b8ce9e673c09f929e6ee9ba" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Result</target>
        </trans-unit>
        <trans-unit id="bcd4102717d8891f8d496a43ec74da14fa94f69e" translate="yes" xml:space="preserve">
          <source>Returning a &lt;code&gt;function&lt;/code&gt; from inside another function is the classic example of a closure, because the state inside the outer function is implicitly available to the returned inner function, even after the outer function has completed execution. This has a number of use-cases, including simulating private variables.</source>
          <target state="translated">Devolver una &lt;code&gt;function&lt;/code&gt; desde dentro de otra funci&amp;oacute;n es el ejemplo cl&amp;aacute;sico de un cierre, porque el estado dentro de la funci&amp;oacute;n externa est&amp;aacute; impl&amp;iacute;citamente disponible para la funci&amp;oacute;n interna devuelta, incluso despu&amp;eacute;s de que la funci&amp;oacute;n externa haya completado la ejecuci&amp;oacute;n. Esto tiene una serie de casos de uso, incluida la simulaci&amp;oacute;n de variables privadas.</target>
        </trans-unit>
        <trans-unit id="ada6589cf526d0c74d239a16a5730f12743a8388" translate="yes" xml:space="preserve">
          <source>Second, when a closure is created, it retains a reference to all of its enclosing function&amp;rsquo;s variables and functions; it doesn&amp;rsquo;t get to pick and choose. And but so, closures should be used sparingly, or at least carefully, as they can be memory intensive; a lot of variables can be kept in memory long after a containing function has finished executing.</source>
          <target state="translated">Segundo, cuando se crea un cierre, retiene una referencia a todas las variables y funciones de su funci&amp;oacute;n de cierre; no llega a escoger y elegir. Y, sin embargo, los cierres deben usarse con moderaci&amp;oacute;n, o al menos con cuidado, ya que pueden requerir mucha memoria; Se pueden guardar muchas variables en la memoria mucho despu&amp;eacute;s de que una funci&amp;oacute;n que contiene haya terminado de ejecutarse.</target>
        </trans-unit>
        <trans-unit id="67fe596a436afe4d7599b96bf46b1977ec2e0ef6" translate="yes" xml:space="preserve">
          <source>She lived in a wonderful world full of adventures. She met her Prince Charming, rode around her world on a unicorn, battled dragons, encountered talking animals, and many other fantastical things.</source>
          <target state="translated">Vivió en un mundo maravilloso lleno de aventuras.Conoció a su príncipe azul,recorrió su mundo en un unicornio,luchó contra dragones,encontró animales que hablaban y muchas otras cosas fantásticas.</target>
        </trans-unit>
        <trans-unit id="07573b573651a019027237d961cc61054b6bec94" translate="yes" xml:space="preserve">
          <source>Since &lt;strong&gt;scope-defining construction in JavaScript is a function&lt;/strong&gt;, not a code block like in many other languages, &lt;strong&gt;what we usually mean by &lt;em&gt;closure&lt;/em&gt; in JavaScript&lt;/strong&gt; is a &lt;strong&gt;function working with nonlocal variables defined in already executed surrounding function&lt;/strong&gt;.</source>
          <target state="translated">Dado que la &lt;strong&gt;construcci&amp;oacute;n que define el alcance en JavaScript es una funci&amp;oacute;n&lt;/strong&gt; , no un bloque de c&amp;oacute;digo como en muchos otros lenguajes, &lt;strong&gt;lo que generalmente queremos decir con &lt;em&gt;cierre&lt;/em&gt; en JavaScript&lt;/strong&gt; es una &lt;strong&gt;funci&amp;oacute;n que trabaja con variables no locales definidas en una funci&amp;oacute;n circundante ya ejecutada&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="e95fed48c1d8fabe097fc454c7b9211faa3636be" translate="yes" xml:space="preserve">
          <source>So this function might have something to do with singing, and might need some data about a person. It has instructions inside to do something with that data.</source>
          <target state="translated">Así que esta función podría tener algo que ver con el canto,y podría necesitar algunos datos sobre una persona.Tiene instrucciones en su interior para hacer algo con esos datos.</target>
        </trans-unit>
        <trans-unit id="a50b97914eb409961a9c50a5aaf62d55c22e4149" translate="yes" xml:space="preserve">
          <source>So to live, the child has to leave before it's too late</source>
          <target state="translated">Así que para vivir,el niño tiene que irse antes de que sea demasiado tarde.</target>
        </trans-unit>
        <trans-unit id="a2d88110733edd016cbeae6a733e1b0d67a3f3ba" translate="yes" xml:space="preserve">
          <source>So what are these closure thingys?</source>
          <target state="translated">Entonces,¿qué son estas cosas de cierre?</target>
        </trans-unit>
        <trans-unit id="454c8a36400b7eb57a810440ce57394bfb5816b7" translate="yes" xml:space="preserve">
          <source>So, as long as we are in the parent -function, it can create one or more child functions which do share the secret variables from the secret place.</source>
          <target state="translated">Así que,mientras estemos en la función padre,puede crear una o más funciones hijo que compartan las variables secretas del lugar secreto.</target>
        </trans-unit>
        <trans-unit id="0a89e976c7abc12da557c349bfa0ca485f347c7a" translate="yes" xml:space="preserve">
          <source>So, function g has access to g, a and f.</source>
          <target state="translated">Así que la función g tiene acceso a g,a y f.</target>
        </trans-unit>
        <trans-unit id="f9cca5aab093ddbfc4f01dcf36fc37ee09f0ff12" translate="yes" xml:space="preserve">
          <source>So, if you call the child &quot;Alice&quot;, she will respond</source>
          <target state="translated">Así que,si llamas a la niña &quot;Alice&quot;,ella responderá</target>
        </trans-unit>
        <trans-unit id="dbc77889f79e6ba70a51ccdd7b1d469ad3fe2209" translate="yes" xml:space="preserve">
          <source>So, whenever you see the &lt;code&gt;function&lt;/code&gt; keyword, code inside that function has access to variables declared outside the function.</source>
          <target state="translated">Entonces, cada vez que vea la palabra clave de la &lt;code&gt;function&lt;/code&gt; , el c&amp;oacute;digo dentro de esa funci&amp;oacute;n tiene acceso a las variables declaradas fuera de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="32a5b0910ff15915067cd48d69073b7ed24d5e07" translate="yes" xml:space="preserve">
          <source>Submitted by Morris on Tue, 2006-02-21 10:19.  Community-edited since.</source>
          <target state="translated">Presentado por Morris el martes,2006-02-21 10:19.Editado por la comunidad desde entonces.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="9025c4cc6a8af6eb5f548366877eea00d17ba2f8" translate="yes" xml:space="preserve">
          <source>Taking the question seriously, we should find out what a typical 6-year-old is capable of cognitively, though admittedly, one who is interested in JavaScript is not so typical.</source>
          <target state="translated">Tomando en serio la pregunta,deberíamos averiguar lo que un niño típico de 6 años es capaz de hacer cognitivamente,aunque hay que reconocer que uno que se interesa por el JavaScript no es tan típico.</target>
        </trans-unit>
        <trans-unit id="67cecda122884bfa553becae4c5685cfae2cbb5f" translate="yes" xml:space="preserve">
          <source>Technically, in &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt;, &lt;strong&gt;every function is a closure&lt;/strong&gt;. It always has an access to variables defined in the surrounding scope.</source>
          <target state="translated">T&amp;eacute;cnicamente, en &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; , &lt;strong&gt;cada funci&amp;oacute;n es un cierre&lt;/strong&gt; . Siempre tiene acceso a variables definidas en el &amp;aacute;mbito circundante.</target>
        </trans-unit>
        <trans-unit id="97cba4858411c435e526dd651157aac20178222c" translate="yes" xml:space="preserve">
          <source>Thanks</source>
          <target state="translated">Thanks</target>
        </trans-unit>
        <trans-unit id="30a5f96f9b652a33887df9866bf824d883055acd" translate="yes" xml:space="preserve">
          <source>That's all there is to tell.</source>
          <target state="translated">Eso es todo lo que hay que decir.</target>
        </trans-unit>
        <trans-unit id="ab6ae4b470ffe5a3279c44a289c97ea3536b0044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trashBags&lt;/code&gt; variable is local to the inside of each kitchen and is not accessible outside, but the inner function on the &lt;code&gt;getTrashBag&lt;/code&gt; property does have access to it.</source>
          <target state="translated">La variable &lt;code&gt;trashBags&lt;/code&gt; es local en el interior de cada cocina y no es accesible desde afuera, pero la funci&amp;oacute;n interna en la propiedad &lt;code&gt;getTrashBag&lt;/code&gt; s&amp;iacute; tiene acceso a ella.</target>
        </trans-unit>
        <trans-unit id="f4b0fe233c7b64030a0dc17c446f53a7aea9634c" translate="yes" xml:space="preserve">
          <source>The Straw Man</source>
          <target state="translated">El Hombre de Paja</target>
        </trans-unit>
        <trans-unit id="2ac247e683af2d84a6d9660b577f04e07e7d50da" translate="yes" xml:space="preserve">
          <source>The above code has a closure because the anonymous function &lt;code&gt;function() { console.log(text); }&lt;/code&gt; is declared &lt;em&gt;inside&lt;/em&gt; another function, &lt;code&gt;sayHello2()&lt;/code&gt; in this example. In JavaScript, if you use the &lt;code&gt;function&lt;/code&gt; keyword inside another function, you are creating a closure.</source>
          <target state="translated">El c&amp;oacute;digo anterior tiene un cierre porque la funci&amp;oacute;n an&amp;oacute;nima &lt;code&gt;function() { console.log(text); }&lt;/code&gt; } se declara &lt;em&gt;dentro de&lt;/em&gt; otra funci&amp;oacute;n, &lt;code&gt;sayHello2()&lt;/code&gt; en este ejemplo. En JavaScript, si usa la palabra clave de &lt;code&gt;function&lt;/code&gt; dentro de otra funci&amp;oacute;n, est&amp;aacute; creando un cierre.</target>
        </trans-unit>
        <trans-unit id="7604834deb6d4981f78e51cc66d18c9e17faae70" translate="yes" xml:space="preserve">
          <source>The above function will also log 16, because the code inside &lt;code&gt;bar&lt;/code&gt; can still refer to argument &lt;code&gt;x&lt;/code&gt; and variable &lt;code&gt;tmp&lt;/code&gt;, even though they are no longer directly in scope.</source>
          <target state="translated">La funci&amp;oacute;n anterior tambi&amp;eacute;n registrar&amp;aacute; 16, porque el c&amp;oacute;digo dentro de la &lt;code&gt;bar&lt;/code&gt; ra todav&amp;iacute;a puede referirse al argumento &lt;code&gt;x&lt;/code&gt; y a la variable &lt;code&gt;tmp&lt;/code&gt; , a pesar de que ya no est&amp;aacute;n directamente en el alcance.</target>
        </trans-unit>
        <trans-unit id="246fdc56b891ef8cd6ddc925b1d907069e7fc98a" translate="yes" xml:space="preserve">
          <source>The author of &lt;em&gt;&lt;a href=&quot;http://javascript.info/tutorial/closures&quot;&gt;Closures&lt;/a&gt;&lt;/em&gt; has explained closures pretty well, explaining the reason why we need them and also explaining LexicalEnvironment which is necessary to understanding closures.</source>
          <target state="translated">El autor de &lt;em&gt;&lt;a href=&quot;http://javascript.info/tutorial/closures&quot;&gt;Closures&lt;/a&gt;&lt;/em&gt; ha explicado los cierres bastante bien, explicando la raz&amp;oacute;n por la cual los necesitamos y tambi&amp;eacute;n explicando el entorno Lexical que es necesario para comprender los cierres.</target>
        </trans-unit>
        <trans-unit id="c13d0c83e1140ef05df23d7d967fd539e97fac2a" translate="yes" xml:space="preserve">
          <source>The browser keeps the LexicalEnvironment and all its properties (variables) in memory until there is an inner function which references it.</source>
          <target state="translated">El navegador mantiene el Entorno Léxico y todas sus propiedades (variables)en la memoria hasta que hay una función interna que lo refiere.</target>
        </trans-unit>
        <trans-unit id="ebab32e0d02219305bce1886d9e8f64ed8614c91" translate="yes" xml:space="preserve">
          <source>The chain of lexical environments, linked between execution contexts via outer environment references, forms a &lt;em&gt;scope chain&lt;/em&gt; and defines the identifiers visible from any given function.</source>
          <target state="translated">La cadena de entornos l&amp;eacute;xicos, vinculada entre contextos de ejecuci&amp;oacute;n a trav&amp;eacute;s de referencias de entornos externos, forma una &lt;em&gt;cadena de alcance&lt;/em&gt; y define los identificadores visibles desde cualquier funci&amp;oacute;n dada.</target>
        </trans-unit>
        <trans-unit id="1f0b658a23c022351d31c0bee4a00408b17ba821" translate="yes" xml:space="preserve">
          <source>The children will always remember the secrets they have shared with their parents, even after their parents are
  gone. This is what closures are for functions.</source>
          <target state="translated">Los niños siempre recordarán los secretos que han compartido con sus padres,incluso después de que sus padres se hayan ido.Esto es lo que los cierres son para las funciones.</target>
        </trans-unit>
        <trans-unit id="d142ef727404c57948941e5ea1a82a1476684d84" translate="yes" xml:space="preserve">
          <source>The closures all know what the &lt;em&gt;sing()&lt;/em&gt; function's variable called &lt;em&gt;firstPart&lt;/em&gt; is, because they can see out from their tinted windows.</source>
          <target state="translated">Todos los cierres saben qu&amp;eacute; es la variable de la funci&amp;oacute;n &lt;em&gt;sing ()&lt;/em&gt; llamada &lt;em&gt;firstPart&lt;/em&gt; , porque pueden ver desde sus ventanas tintadas.</target>
        </trans-unit>
        <trans-unit id="bb0d2327de1953161942f2ab9fa838498aa1dbcb" translate="yes" xml:space="preserve">
          <source>The example above is using an anonymous function, which was executed once. But it does not have to be. It can be named (e.g. &lt;code&gt;mkdb&lt;/code&gt;) and executed later, generating a database function each time it is invoked. Every generated function will have its own hidden database object. Another usage example of closures is when we don't return a function, but an object containing multiple functions for different purposes, each of those function having access to the same data.</source>
          <target state="translated">El ejemplo anterior est&amp;aacute; utilizando una funci&amp;oacute;n an&amp;oacute;nima, que se ejecut&amp;oacute; una vez. Pero no tiene que ser as&amp;iacute;. Puede nombrarse (por ejemplo, &lt;code&gt;mkdb&lt;/code&gt; ) y ejecutarse m&amp;aacute;s tarde, generando una funci&amp;oacute;n de base de datos cada vez que se invoca. Cada funci&amp;oacute;n generada tendr&amp;aacute; su propio objeto de base de datos oculto. Otro ejemplo de uso de los cierres es cuando no devolvemos una funci&amp;oacute;n, sino un objeto que contiene m&amp;uacute;ltiples funciones para diferentes prop&amp;oacute;sitos, cada una de esas funciones tiene acceso a los mismos datos.</target>
        </trans-unit>
        <trans-unit id="d752ad30dcb07b4bf12c76bcaf1fd95663e1c173" translate="yes" xml:space="preserve">
          <source>The following code returns a reference to a function:</source>
          <target state="translated">El siguiente código devuelve una referencia a una función:</target>
        </trans-unit>
        <trans-unit id="5215171b8fbe41f294967978f22f5060d88ee251" translate="yes" xml:space="preserve">
          <source>The following simple example covers all the main points of JavaScript closures.&lt;sup&gt;*&lt;/sup&gt;</source>
          <target state="translated">El siguiente ejemplo simple cubre todos los puntos principales de los cierres de JavaScript. &lt;sup&gt;* *&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ad531efca548a3919fa24597ab10762db1c48acd" translate="yes" xml:space="preserve">
          <source>The genius is that in JavaScript a function reference also has a secret reference to the closure it was created in &amp;mdash; similar to how delegates are a method pointer plus a secret reference to an object.</source>
          <target state="translated">Lo genial es que en JavaScript una referencia de funci&amp;oacute;n tambi&amp;eacute;n tiene una referencia secreta al cierre en el que se cre&amp;oacute;, de forma similar a c&amp;oacute;mo los delegados son un puntero de m&amp;eacute;todo m&amp;aacute;s una referencia secreta a un objeto.</target>
        </trans-unit>
        <trans-unit id="45e0685cacab3e797413836c0a3b3870f011cdba" translate="yes" xml:space="preserve">
          <source>The inner function keeps a reference to the outer
LexicalEnvironment.</source>
          <target state="translated">La función interna mantiene una referencia al Ambiente Lógico externo.</target>
        </trans-unit>
        <trans-unit id="1222b712516a600e2c63dde997d35b726a9bade9" translate="yes" xml:space="preserve">
          <source>The inner function may access variables from it
any time even if the outer function is finished.</source>
          <target state="translated">La función interna puede acceder a las variables desde ella en cualquier momento,incluso si la función externa está terminada.</target>
        </trans-unit>
        <trans-unit id="0f440ed8885caea2f6a4de181d02ca1ce2bfd985" translate="yes" xml:space="preserve">
          <source>The kitchen is a closure that has a local variable, called &lt;code&gt;trashBags&lt;/code&gt;.  There is a function inside the kitchen called &lt;code&gt;getTrashBag&lt;/code&gt; that gets one trash bag and returns it.</source>
          <target state="translated">La cocina es un cierre que tiene una variable local, llamada &lt;code&gt;trashBags&lt;/code&gt; . Hay una funci&amp;oacute;n dentro de la cocina llamada &lt;code&gt;getTrashBag&lt;/code&gt; que obtiene una bolsa de basura y la devuelve.</target>
        </trans-unit>
        <trans-unit id="e9eb91337dbe1342ddf4236b7c7460d616e8d494" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;result.push( function() {console.log(item + ' ' + list[i])}&lt;/code&gt; adds a reference to an anonymous function three times to the result array. If you are not so familiar with anonymous functions think of it like:</source>
          <target state="translated">La l&amp;iacute;nea &lt;code&gt;result.push( function() {console.log(item + ' ' + list[i])}&lt;/code&gt; agrega una referencia a una funci&amp;oacute;n an&amp;oacute;nima tres veces a la matriz de resultados. Si no est&amp;aacute; tan familiarizado con las funciones an&amp;oacute;nimas, piense en es como:</target>
        </trans-unit>
        <trans-unit id="3719fe577c00cbcfb269ebde253db1c8de6cf36a" translate="yes" xml:space="preserve">
          <source>The process consists of two steps:</source>
          <target state="translated">El proceso consiste en dos pasos:</target>
        </trans-unit>
        <trans-unit id="a6b75fac7979ad9def4158f7b987a3aa8e383e53" translate="yes" xml:space="preserve">
          <source>The reason that referenceToInnerFunction can still access the value of outerVar is because when the closure was first created by placing innerFunction inside of outerFunction, innerFunction added a reference to outerFunction&amp;rsquo;s scope (its variables and functions) to its scope chain. What this means is that innerFunction has a pointer or reference to all of outerFunction&amp;rsquo;s variables, including outerVar. So even when outerFunction has finished executing, or even if it is deleted or set to null, the variables in its scope, like outerVar, stick around in memory because of the outstanding reference to them on the part of the innerFunction that has been returned to referenceToInnerFunction. To truly release outerVar and the rest of outerFunction&amp;rsquo;s variables from memory you would have to get rid of this outstanding reference to them, say by setting referenceToInnerFunction to null as well.</source>
          <target state="translated">La raz&amp;oacute;n por la que referenceToInnerFunction todav&amp;iacute;a puede acceder al valor de outsideVar es porque cuando el cierre se cre&amp;oacute; por primera vez colocando innerFunction dentro de outsideFunction, innerFunction agreg&amp;oacute; una referencia al alcance de externalFunction (sus variables y funciones) a su cadena de alcance. Lo que esto significa es que innerFunction tiene un puntero o una referencia a todas las variables de externalFunction, incluida externalVar. Entonces, incluso cuando externalFunction haya terminado de ejecutarse, o incluso si se elimina o se establece en nulo, las variables en su alcance, como externalVar, permanecen en la memoria debido a la referencia sobresaliente a ellas por parte de innerFunction que se ha devuelto a referenceToInnerFunction. Para liberar de la memoria a externalVar y al resto de las variables de externalFunction, tendr&amp;iacute;a que deshacerse de esta referencia sobresaliente a ellas, por ejemplo, estableciendo referenceToInnerFunction en null tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="a52ec855c305cdd424a0acec2f16c794668d3e11" translate="yes" xml:space="preserve">
          <source>The secrets for JavaScript functions are the private variables</source>
          <target state="translated">Los secretos de las funciones de JavaScript son las variables privadas</target>
        </trans-unit>
        <trans-unit id="c8048ace855f36cfe6ec5f055971d3ab6080b70b" translate="yes" xml:space="preserve">
          <source>The simplest example of a closure is this:</source>
          <target state="translated">El ejemplo más simple de un cierre es este:</target>
        </trans-unit>
        <trans-unit id="758516d667c0ca64ba31d36b4aa304b7d45c8074" translate="yes" xml:space="preserve">
          <source>The sing() function will call each of these functions in the order they are given. Then the sing() function's work will be done.</source>
          <target state="translated">La función sing()llamará a cada una de estas funciones en el orden en que se le da.Entonces el trabajo de la función sing()se hará.</target>
        </trans-unit>
        <trans-unit id="b2bfe35512d67b1120c27f2759f79e721a38d640" translate="yes" xml:space="preserve">
          <source>The three functions have shared access to the same closure &amp;mdash; the local variables of &lt;code&gt;setupSomeGlobals()&lt;/code&gt; when the three functions were defined.</source>
          <target state="translated">Las tres funciones tienen acceso compartido al mismo cierre: las variables locales de &lt;code&gt;setupSomeGlobals()&lt;/code&gt; cuando se definieron las tres funciones.</target>
        </trans-unit>
        <trans-unit id="1683c5c3fdaabb276940a6471aab76eac2921b0e" translate="yes" xml:space="preserve">
          <source>There is a critical difference between a C pointer to a function and a JavaScript reference to a function. In JavaScript, you can think of a function reference variable as having both a pointer to a function &lt;em&gt;as well&lt;/em&gt; as a hidden pointer to a closure.</source>
          <target state="translated">Hay una diferencia cr&amp;iacute;tica entre un puntero C a una funci&amp;oacute;n y una referencia de JavaScript a una funci&amp;oacute;n. En JavaScript, puede pensar que una variable de referencia de funci&amp;oacute;n tiene tanto un puntero a una funci&amp;oacute;n como un puntero oculto a un cierre.</target>
        </trans-unit>
        <trans-unit id="04637ad8e1b34b4d45e60aaea6b490192d004b6f" translate="yes" xml:space="preserve">
          <source>There is no reason to believe closures are a complex design hack to address specific problems. No, closures are just about using a variable that comes from a higher scope &lt;strong&gt;from the perspective of where the function was declared (not run)&lt;/strong&gt;.</source>
          <target state="translated">No hay raz&amp;oacute;n para creer que los cierres son un truco de dise&amp;ntilde;o complejo para abordar problemas espec&amp;iacute;ficos. No, los cierres consisten simplemente en utilizar una variable que proviene de un alcance m&amp;aacute;s alto &lt;strong&gt;desde la perspectiva de d&amp;oacute;nde se declar&amp;oacute; la funci&amp;oacute;n (no se ejecut&amp;oacute;)&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="dc8da2d96ff3de796d0c72436a2ccd3f4dc18e12" translate="yes" xml:space="preserve">
          <source>There was a princess...</source>
          <target state="translated">Había una princesa...</target>
        </trans-unit>
        <trans-unit id="7ee59ebacfd9d93a5dadb09b49abe5ed01b3d0c0" translate="yes" xml:space="preserve">
          <source>There you go; you're now fully encapsulating this behavior.</source>
          <target state="translated">Ahí lo tienes;ahora estás encapsulando completamente este comportamiento.</target>
        </trans-unit>
        <trans-unit id="f2e330c9ca939e298d2b5965f2b6b3e1b37e408b" translate="yes" xml:space="preserve">
          <source>This article is intended for programmers with some programming experience in a mainstream language, and who can read the following JavaScript function:</source>
          <target state="translated">Este artículo está dirigido a los programadores con cierta experiencia en programación en un lenguaje corriente,y que pueden leer la siguiente función de JavaScript:</target>
        </trans-unit>
        <trans-unit id="4dd1925d9c601a5cbe75680ad2654c7234add57a" translate="yes" xml:space="preserve">
          <source>This creates a new scope and &lt;code&gt;n&lt;/code&gt; is bound to that scope; this means we have 10 separate scopes, one for each iteration.</source>
          <target state="translated">Esto crea un nuevo alcance &lt;code&gt;n&lt;/code&gt; est&amp;aacute; vinculado a ese alcance; Esto significa que tenemos 10 &amp;aacute;mbitos separados, uno para cada iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7552ddbeac58a09947a400d7a7ab0c7823e95f06" translate="yes" xml:space="preserve">
          <source>This example shows that the closure contains any local variables that were declared inside the outer function before it exited. Note that the variable &lt;code&gt;alice&lt;/code&gt; is actually declared after the anonymous function. The anonymous function is declared first and when that function is called it can access the &lt;code&gt;alice&lt;/code&gt; variable because &lt;code&gt;alice&lt;/code&gt; is in the same scope (JavaScript does &lt;a href=&quot;https://stackoverflow.com/a/3725763/1269037&quot;&gt;variable hoisting&lt;/a&gt;).
Also &lt;code&gt;sayAlice()()&lt;/code&gt; just directly calls the function reference returned from &lt;code&gt;sayAlice()&lt;/code&gt; &amp;mdash; it is exactly the same as what was done previously but without the temporary variable.</source>
          <target state="translated">Este ejemplo muestra que el cierre contiene las variables locales que se declararon dentro de la funci&amp;oacute;n externa antes de salir. Tenga en cuenta que la variable &lt;code&gt;alice&lt;/code&gt; en realidad se declara despu&amp;eacute;s de la funci&amp;oacute;n an&amp;oacute;nima. La funci&amp;oacute;n an&amp;oacute;nima se declara primero y cuando se llama a esa funci&amp;oacute;n, puede acceder a la variable &lt;code&gt;alice&lt;/code&gt; porque alice est&amp;aacute; en el mismo &amp;aacute;mbito (JavaScript hace &lt;a href=&quot;https://stackoverflow.com/a/3725763/1269037&quot;&gt;elevaci&amp;oacute;n variable&lt;/a&gt; ). Tambi&amp;eacute;n &lt;code&gt;sayAlice()()&lt;/code&gt; solo llama directamente a la referencia de funci&amp;oacute;n devuelta por &lt;code&gt;sayAlice()&lt;/code&gt; : es exactamente lo mismo que se hizo anteriormente pero sin la variable temporal.</target>
        </trans-unit>
        <trans-unit id="d1bbfb6c03415d46436720884428eece40742855" translate="yes" xml:space="preserve">
          <source>This example shows that the local variables are not copied &amp;mdash; they are kept by reference. It is as though the stack-frame stays alive in memory even after the outer function exits!</source>
          <target state="translated">Este ejemplo muestra que las variables locales no se copian, sino que se guardan por referencia. &amp;iexcl;Es como si el marco de la pila permaneciera vivo en la memoria incluso despu&amp;eacute;s de que la funci&amp;oacute;n externa salga!</target>
        </trans-unit>
        <trans-unit id="cd052212f50f2244a372f8c3023bb7e1c19cf13f" translate="yes" xml:space="preserve">
          <source>This is an attempt to clear up several (possible) misunderstandings about closures that appear in some of the other answers.</source>
          <target state="translated">Este es un intento de aclarar varios (posibles)malentendidos sobre los cierres que aparecen en algunas de las otras respuestas.</target>
        </trans-unit>
        <trans-unit id="789cc6e4df4d97f5dde344c2fdb9c85a7781a6d9" translate="yes" xml:space="preserve">
          <source>This is called a closure.</source>
          <target state="translated">Esto se llama un cierre.</target>
        </trans-unit>
        <trans-unit id="d2b023972a185beed0da123eeebf515f35e6bed3" translate="yes" xml:space="preserve">
          <source>This line is calling the function, as if it were calling a dog</source>
          <target state="translated">Esta línea está llamando a la función,como si estuviera llamando a un perro</target>
        </trans-unit>
        <trans-unit id="2e4d80d915cf259f32a4c6b7797dea00eab65b84" translate="yes" xml:space="preserve">
          <source>This one is a real gotcha for many people, so you need to understand it. Be very careful if you are defining a function within a loop: the local variables from the closure may not act as you might first think.</source>
          <target state="translated">Este es un verdadero &quot;gotcha&quot; para mucha gente,así que tienes que entenderlo.Ten mucho cuidado si estás definiendo una función dentro de un bucle:las variables locales del cierre pueden no actuar como podrías pensar en un principio.</target>
        </trans-unit>
        <trans-unit id="da5cb87fcafafecdacdfe6ed51e0a0d4f98b7585" translate="yes" xml:space="preserve">
          <source>This page explains closures so that a programmer can understand them &amp;mdash; using working JavaScript code. It is not for gurus or functional programmers.</source>
          <target state="translated">Esta p&amp;aacute;gina explica los cierres para que un programador pueda entenderlos, utilizando un c&amp;oacute;digo JavaScript que funcione. No es para gur&amp;uacute;s o programadores funcionales.</target>
        </trans-unit>
        <trans-unit id="8a6c734fbaac2d3b867fa1c453a226b28d630cf7" translate="yes" xml:space="preserve">
          <source>This will log &lt;code&gt;16&lt;/code&gt; because function &lt;code&gt;bar&lt;/code&gt; closes over the parameter &lt;code&gt;x&lt;/code&gt; and the variable &lt;code&gt;tmp&lt;/code&gt;, both of which exist in the lexical environment of outer function &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">Esto registrar&amp;aacute; &lt;code&gt;16&lt;/code&gt; porque la &lt;code&gt;bar&lt;/code&gt; ra de funciones se cierra sobre el par&amp;aacute;metro &lt;code&gt;x&lt;/code&gt; y la variable &lt;code&gt;tmp&lt;/code&gt; , que existen en el entorno l&amp;eacute;xico de la funci&amp;oacute;n externa &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e28adc0562a325e3e096fedb43aec2bcfc26cc2" translate="yes" xml:space="preserve">
          <source>To summarize:</source>
          <target state="translated">Para resumir:</target>
        </trans-unit>
        <trans-unit id="185cffe022e026a4122cc13897f61794b5e49d80" translate="yes" xml:space="preserve">
          <source>Tricky: note the &lt;code&gt;say&lt;/code&gt; variable is also inside the closure and could be accessed by any other function that might be declared within &lt;code&gt;sayAlice()&lt;/code&gt;, or it could be accessed recursively within the inside function.</source>
          <target state="translated">Truco: tenga en cuenta que la variable &lt;code&gt;say&lt;/code&gt; tambi&amp;eacute;n est&amp;aacute; dentro del cierre y puede acceder a ella desde cualquier otra funci&amp;oacute;n que pueda declararse dentro de &lt;code&gt;sayAlice()&lt;/code&gt; , o puede accederse recursivamente dentro de la funci&amp;oacute;n inside.</target>
        </trans-unit>
        <trans-unit id="7738f68d43c61aa58c8d9b9546acdd53ba567dbc" translate="yes" xml:space="preserve">
          <source>Two brief summaries</source>
          <target state="translated">Dos breves resúmenes</target>
        </trans-unit>
        <trans-unit id="43a5562bc755854b701217c3e2cea0041b6a10df" translate="yes" xml:space="preserve">
          <source>Two functions might look like they have the same source text, but have completely different behavior because of their 'hidden' closure. I don't think JavaScript code can actually find out if a function reference has a closure or not.</source>
          <target state="translated">Dos funciones pueden parecer como si tuvieran el mismo texto de origen,pero tienen un comportamiento completamente diferente debido a su cierre &quot;oculto&quot;.No creo que el código JavaScript pueda realmente averiguar si una referencia de función tiene un cierre o no.</target>
        </trans-unit>
        <trans-unit id="b6e33fa589c38cb3d120879b99ebe9f6503bd521" translate="yes" xml:space="preserve">
          <source>Two other things about closures to note. First, the closure will always have access to the last values of its containing function.</source>
          <target state="translated">Otras dos cosas sobre los cierres a tener en cuenta.Primero,el cierre siempre tendrá acceso a los últimos valores de su función de contención.</target>
        </trans-unit>
        <trans-unit id="9c977033015ef8f81efe5ec1a386949630df27f5" translate="yes" xml:space="preserve">
          <source>VARIABLE: The letters &lt;em&gt;var&lt;/em&gt; stand for &quot;variable&quot;. A variable is like an envelope. On the outside this envelope is marked &quot;person&quot;. On the inside it contains a slip of paper with the information our function needs, some letters and spaces joined together like a piece of string (it's called a string) that make a phrase reading &quot;an old lady&quot;. Our envelope could contain other kinds of things like numbers (called integers), instructions (called functions), lists (called &lt;em&gt;arrays&lt;/em&gt;). Because this variable is written outside of all the braces &lt;code&gt;{}&lt;/code&gt;, and because you can see out through the tinted windows when you are inside the braces, this variable can be seen from anywhere in the code. We call this a 'global variable'.</source>
          <target state="translated">VARIABLE: Las letras &lt;em&gt;var&lt;/em&gt; significan &quot;variable&quot;. Una variable es como un sobre. En el exterior, este sobre est&amp;aacute; marcado como &quot;persona&quot;. En el interior contiene un trozo de papel con la informaci&amp;oacute;n que necesita nuestra funci&amp;oacute;n, algunas letras y espacios unidos como un trozo de cuerda (se llama cadena) que forman una frase que dice &quot;una anciana&quot;. Nuestro sobre podr&amp;iacute;a contener otros tipos de cosas como n&amp;uacute;meros (llamados enteros), instrucciones (llamadas funciones), listas (llamadas &lt;em&gt;matrices&lt;/em&gt; ). Debido a que esta variable se escribe fuera de todas las llaves &lt;code&gt;{}&lt;/code&gt; , y porque puede ver a trav&amp;eacute;s de las ventanas polarizadas cuando est&amp;aacute; dentro de las llaves, esta variable se puede ver desde cualquier parte del c&amp;oacute;digo. Llamamos a esto una 'variable global'.</target>
        </trans-unit>
        <trans-unit id="0a3b4dd6c2b81d0408e62dc4b0c7d9aa719858b8" translate="yes" xml:space="preserve">
          <source>We can code this in JavaScript like this:</source>
          <target state="translated">Podemos codificar esto en JavaScript así:</target>
        </trans-unit>
        <trans-unit id="0dd5ca9fc457449d5a7438bfa95e87b689ade82a" translate="yes" xml:space="preserve">
          <source>We can use this example to explain closures, as follows:</source>
          <target state="translated">Podemos usar este ejemplo para explicar los cierres,de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="cfb7d9f151f2ce139f3a16a6d13ee0a6d6a9272b" translate="yes" xml:space="preserve">
          <source>What if a variable is accessed, but it isn&amp;rsquo;t local? Like here:</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasa si se accede a una variable, pero no es local? Como aqu&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="1e8f90f12d65d0d31eedfa442526261ad87df2b7" translate="yes" xml:space="preserve">
          <source>What might not be obvious is that since &lt;code&gt;createClosureArray()&lt;/code&gt; is only invoked once only one scope is created for this function instead of one for every iteration of the loop.</source>
          <target state="translated">Lo que podr&amp;iacute;a no ser obvio es que ya que &lt;code&gt;createClosureArray()&lt;/code&gt; solo se invoca una vez que se crea un solo alcance para esta funci&amp;oacute;n en lugar de uno para cada iteraci&amp;oacute;n del bucle.</target>
        </trans-unit>
        <trans-unit id="082f7b2b11f91eb896764f16c3c56d45e4ee7ca7" translate="yes" xml:space="preserve">
          <source>What would happen here if JavaScript &lt;em&gt;didn't&lt;/em&gt; know closures? Just replace the call in the last line by its method body (which is basically what function calls do) and you get:</source>
          <target state="translated">&amp;iquest;Qu&amp;eacute; pasar&amp;iacute;a aqu&amp;iacute; si JavaScript &lt;em&gt;no&lt;/em&gt; supiera los cierres? Simplemente reemplace la llamada en la &amp;uacute;ltima l&amp;iacute;nea por su cuerpo de m&amp;eacute;todo (que es b&amp;aacute;sicamente lo que hacen las llamadas de funci&amp;oacute;n) y obtendr&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="0d4abbfdfc801f0827fc6f8072079568d1427247" translate="yes" xml:space="preserve">
          <source>When a JavaScript function is invoked, a new execution context &lt;code&gt;ec&lt;/code&gt; is created. Together with the function arguments and the target object, this execution context also receives a link to the lexical environment of the calling execution context, meaning the variables declared in the outer lexical environment (in the above example, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;) are available from &lt;code&gt;ec&lt;/code&gt;.</source>
          <target state="translated">Cuando se invoca una funci&amp;oacute;n de JavaScript, se crea un nuevo contexto de ejecuci&amp;oacute;n &lt;code&gt;ec&lt;/code&gt; . Junto con los argumentos de la funci&amp;oacute;n y el objeto de destino, este contexto de ejecuci&amp;oacute;n tambi&amp;eacute;n recibe un enlace al entorno l&amp;eacute;xico del contexto de ejecuci&amp;oacute;n de la llamada, lo que significa que las variables declaradas en el entorno l&amp;eacute;xico externo (en el ejemplo anterior, tanto &lt;code&gt;a&lt;/code&gt; como &lt;code&gt;b&lt;/code&gt; ) est&amp;aacute;n disponibles en &lt;code&gt;ec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7551a120ee1e0a45d0b5cf36770825ae08a23f1" translate="yes" xml:space="preserve">
          <source>When a function (&lt;code&gt;foo&lt;/code&gt;) declares other functions (bar and baz), the family of local variables created in &lt;code&gt;foo&lt;/code&gt; is &lt;em&gt;not destroyed&lt;/em&gt; when the function exits. The variables merely become invisible to the outside world. &lt;code&gt;foo&lt;/code&gt; can therefore cunningly return the functions &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt;, and they can continue to read, write and communicate with each other through this closed-off family of variables (&quot;the closure&quot;) that nobody else can meddle with, not even someone who calls &lt;code&gt;foo&lt;/code&gt; again in future.</source>
          <target state="translated">Cuando una funci&amp;oacute;n ( &lt;code&gt;foo&lt;/code&gt; ) declara otras funciones (bar y baz), la familia de variables locales creadas en &lt;code&gt;foo&lt;/code&gt; &lt;em&gt;no se destruye&lt;/em&gt; cuando la funci&amp;oacute;n sale. Las variables simplemente se vuelven invisibles para el mundo exterior. por lo tanto, &lt;code&gt;foo&lt;/code&gt; puede devolver astutamente las funciones &lt;code&gt;bar&lt;/code&gt; y &lt;code&gt;baz&lt;/code&gt; , y pueden continuar leyendo, escribiendo y comunic&amp;aacute;ndose entre s&amp;iacute; a trav&amp;eacute;s de esta familia cerrada de variables (&quot;el cierre&quot;) con la que nadie m&amp;aacute;s puede entrometerse, ni siquiera alguien que llame &lt;code&gt;foo&lt;/code&gt; nuevo en el futuro.</target>
        </trans-unit>
        <trans-unit id="a14a687cf5a4767a5c232cb3c825bc777cc5955b" translate="yes" xml:space="preserve">
          <source>When a function is created, it gets a hidden property, named [[Scope]], which references the current LexicalEnvironment.</source>
          <target state="translated">Cuando se crea una función,se obtiene una propiedad oculta,llamada [[Scope]],que hace referencia al entorno léxico actual.</target>
        </trans-unit>
        <trans-unit id="af97d2eb165c46e20d5beb31d9f67783d9ae76ed" translate="yes" xml:space="preserve">
          <source>When a function is invoked via the internal &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist&quot;&gt;&lt;code&gt;[[Call]]&lt;/code&gt;&lt;/a&gt; method, the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt;&lt;code&gt;[[Environment]]&lt;/code&gt;&lt;/a&gt; reference on the function-object is copied into the &lt;em&gt;outer environment reference&lt;/em&gt; of the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records&quot;&gt;environment record&lt;/a&gt; of the newly-created &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;execution context&lt;/a&gt; (stack frame).</source>
          <target state="translated">Cuando se invoca una funci&amp;oacute;n a trav&amp;eacute;s del m&amp;eacute;todo interno &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist&quot;&gt; &lt;code&gt;[[Call]]&lt;/code&gt; &lt;/a&gt; , la referencia &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt; &lt;code&gt;[[Environment]]&lt;/code&gt; &lt;/a&gt; en el objeto de funci&amp;oacute;n se copia en la &lt;em&gt;referencia&lt;/em&gt; de &lt;em&gt;entorno externo&lt;/em&gt; del &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records&quot;&gt;registro&lt;/a&gt; de entorno del &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;contexto de ejecuci&amp;oacute;n&lt;/a&gt; reci&amp;eacute;n creado (marco de pila).</target>
        </trans-unit>
        <trans-unit id="eda8d0ba8c86f2bcc7f89824f85d577c09f72064" translate="yes" xml:space="preserve">
          <source>When the browser has loaded the JavaScript code an reached this line, it will start the function. I put the line at the end to make sure that the browser has all the information it needs to run it.</source>
          <target state="translated">Cuando el navegador haya cargado el código JavaScript y llegue a esta línea,iniciará la función.Puse la línea al final para asegurarme de que el navegador tiene toda la información que necesita para ejecutarlo.</target>
        </trans-unit>
        <trans-unit id="656c8142287a1690f7f3625f825e5d62a85448e1" translate="yes" xml:space="preserve">
          <source>When the user clicks the VoteUp button, the voteUp_click function checks whether isVotedDown == true to determine whether to vote up or merely cancel a down vote. Function voteUp_click is a closure because it is accessing its environment.</source>
          <target state="translated">Cuando el usuario hace clic en el botón VoteUp,la función voteUp_click comprueba si esVotedDown ==true para determinar si se vota a favor o simplemente se cancela un voto en contra.La función voteUp_click es un cierre porque está accediendo a su entorno.</target>
        </trans-unit>
        <trans-unit id="6df579e2161f6eb523745bff56a56ef486a46f72" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;new Function(&amp;hellip;)&lt;/code&gt; (the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function&quot;&gt;Function constructor&lt;/a&gt;) inside a function, it does not close over its lexical environment: it closes over the global context instead. (The new function cannot reference the local variables of the outer function.)</source>
          <target state="translated">Cuando utiliza una &lt;code&gt;new Function(&amp;hellip;)&lt;/code&gt; (el &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function&quot;&gt;constructor de funciones&lt;/a&gt; ) dentro de una funci&amp;oacute;n, no se cierra sobre su entorno l&amp;eacute;xico: en su lugar, se cierra sobre el contexto global. (La nueva funci&amp;oacute;n no puede hacer referencia a las variables locales de la funci&amp;oacute;n externa).</target>
        </trans-unit>
        <trans-unit id="fc1b188972939bb322463b13d9e6d79ec73b22c6" translate="yes" xml:space="preserve">
          <source>Whenever a function is declared in JavaScript a closure is created.</source>
          <target state="translated">Cada vez que se declara una función en JavaScript se crea un cierre.</target>
        </trans-unit>
        <trans-unit id="42d771d468376a7581a6ea18362bea86ddcf67ad" translate="yes" xml:space="preserve">
          <source>Whenever you use &lt;code&gt;eval()&lt;/code&gt; inside a function, a closure is used. The text you &lt;code&gt;eval&lt;/code&gt; can reference local variables of the function, and within &lt;code&gt;eval&lt;/code&gt; you can even create new local variables by using &lt;code&gt;eval('var foo = &amp;hellip;')&lt;/code&gt;</source>
          <target state="translated">Cada vez que usa &lt;code&gt;eval()&lt;/code&gt; dentro de una funci&amp;oacute;n, se usa un cierre. El texto que &lt;code&gt;eval&lt;/code&gt; &amp;uacute;a puede hacer referencia a variables locales de la funci&amp;oacute;n, y dentro de &lt;code&gt;eval&lt;/code&gt; puede incluso crear nuevas variables locales utilizando &lt;code&gt;eval('var foo = &amp;hellip;')&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="68b3446fbf7d6fb0e4c451a7d1ae63e9f388e484" translate="yes" xml:space="preserve">
          <source>Within each scope &lt;code&gt;n&lt;/code&gt; is bound to whatever value it had when &lt;code&gt;createClosure(n)&lt;/code&gt; was invoked so the nested function that gets returned will always return the value of &lt;code&gt;n&lt;/code&gt; that it had when &lt;code&gt;createClosure(n)&lt;/code&gt; was invoked.</source>
          <target state="translated">Dentro de cada &amp;aacute;mbito, &lt;code&gt;n&lt;/code&gt; est&amp;aacute; vinculado al valor que ten&amp;iacute;a cuando se &lt;code&gt;createClosure(n)&lt;/code&gt; por lo que la funci&amp;oacute;n anidada que se devuelve siempre devolver&amp;aacute; el valor de &lt;code&gt;n&lt;/code&gt; que ten&amp;iacute;a cuando se &lt;code&gt;createClosure(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3685d63e9253161c4b5418f6dbd94db0b7b6fc6" translate="yes" xml:space="preserve">
          <source>Within this function a variable named &lt;code&gt;index&lt;/code&gt; is defined. The loop runs and adds functions to the array that return &lt;code&gt;index&lt;/code&gt;. Note that &lt;code&gt;index&lt;/code&gt; is defined within the &lt;code&gt;createClosureArray&lt;/code&gt; function which only ever gets invoked one time.</source>
          <target state="translated">Dentro de esta funci&amp;oacute;n se define una variable llamada &lt;code&gt;index&lt;/code&gt; . El bucle se ejecuta y agrega funciones a la matriz que devuelven el &lt;code&gt;index&lt;/code&gt; . Tenga en cuenta que el &lt;code&gt;index&lt;/code&gt; se define dentro de la funci&amp;oacute;n &lt;code&gt;createClosureArray&lt;/code&gt; que solo se invoca una vez.</target>
        </trans-unit>
        <trans-unit id="6930e04d92d01fa662d11df5aa5d0e9bd5d8f5f8" translate="yes" xml:space="preserve">
          <source>Yes. You probably use that many times a day.</source>
          <target state="translated">Sí.Probablemente lo uses muchas veces al día.</target>
        </trans-unit>
        <trans-unit id="d579fab7eac666a9836aa39e6b35da201bfec6ea" translate="yes" xml:space="preserve">
          <source>You know how grown-ups can own a house, and they call it home? When a mom has a child, the child doesn't really own anything, right? But its parents own a house, so whenever someone asks the child &quot;Where's your home?&quot;, he/she can answer &quot;that house!&quot;, and point to the house of its parents. A &quot;Closure&quot; is the ability of the child to always (even if abroad) be able to say it has a home, even though it's really the parent's who own the house.</source>
          <target state="translated">¿Sabes cómo los adultos pueden tener una casa,y la llaman hogar? Cuando una madre tiene un hijo,el niño no es realmente dueño de nada,¿verdad? Pero sus padres son dueños de una casa,así que cuando alguien le pregunta al niño &quot;¿Dónde está tu casa?&quot;,heshe puede responder &quot;¡esa casa!&quot;,y señalar la casa de sus padres.Un &quot;cierre&quot; es la capacidad del niño de poder decir siempre (aunque esté en el extranjero)que tiene una casa,aunque en realidad son los padres los que son dueños de la casa.</target>
        </trans-unit>
        <trans-unit id="f95a097c531667e7c2a6ae971917615f399a2b1d" translate="yes" xml:space="preserve">
          <source>You need to understand the &quot;variable hoisting&quot; feature in Javascript in order to understand this example.</source>
          <target state="translated">Necesitas entender la característica de &quot;elevación variable&quot; en Javascript para entender este ejemplo.</target>
        </trans-unit>
        <trans-unit id="12fa562f7e0a2d3533b4af8a1d5c7d14b86a0f78" translate="yes" xml:space="preserve">
          <source>You're having a sleep over and you invite Dan.
You tell Dan to bring one XBox controller.</source>
          <target state="translated">Te quedas a dormir e invitas a Dan.Le dices a Dan que traiga un controlador XBox.</target>
        </trans-unit>
        <trans-unit id="0a0db21e6a13f3e33a5d7e7ef217b86c21a634c3" translate="yes" xml:space="preserve">
          <source>Your child will be able to follow two-step directions. For example, if you say to your child, &quot;Go to the kitchen and get me a trash bag&quot; they will be able to remember that direction.</source>
          <target state="translated">Su hijo podrá seguir instrucciones de dos pasos.Por ejemplo,si le dice a su hijo,&quot;Ve a la cocina y tráeme una bolsa de basura&quot; será capaz de recordar esa dirección.</target>
        </trans-unit>
        <trans-unit id="65d09cbca9a2110fcca151e4c7f0c0fb68f6c5eb" translate="yes" xml:space="preserve">
          <source>anything in outer functions</source>
          <target state="translated">cualquier cosa en las funciones externas</target>
        </trans-unit>
        <trans-unit id="ebf5cf1386d90514706786d86faa965c625f69a5" translate="yes" xml:space="preserve">
          <source>button or look at the Options settings to open the developer console of a browser and type &quot;person&quot; to see what this value is. Type &lt;code&gt;person=&quot;a young man&quot;&lt;/code&gt; to change it and then type &quot;person&quot; again to see that it has changed.</source>
          <target state="translated">bot&amp;oacute;n o mire la configuraci&amp;oacute;n de Opciones para abrir la consola de desarrollador de un navegador y escriba &quot;persona&quot; para ver cu&amp;aacute;l es este valor. Escriba &lt;code&gt;person=&quot;a young man&quot;&lt;/code&gt; para cambiarlo y luego escriba &quot;person&quot; nuevamente para ver si ha cambiado.</target>
        </trans-unit>
        <trans-unit id="a253f2310ab98afd2ae5163409dd162753885015" translate="yes" xml:space="preserve">
          <source>ems</source>
          <target state="translated">ems</target>
        </trans-unit>
        <trans-unit id="18c4aadf416cf320b65098f9eaf67f9101b6b90e" translate="yes" xml:space="preserve">
          <source>globals, including the DOM</source>
          <target state="translated">globales,incluyendo el DOM</target>
        </trans-unit>
        <trans-unit id="4f7d81389762366c131edcfc1778acc037b192e4" translate="yes" xml:space="preserve">
          <source>n = 0</source>
          <target state="translated">n=0</target>
        </trans-unit>
        <trans-unit id="92ee913214330816c21ed1490df01843b5cb2075" translate="yes" xml:space="preserve">
          <source>n = 1</source>
          <target state="translated">n=1</target>
        </trans-unit>
        <trans-unit id="ac48f9f7795484b3747139f0e4cb0790db58945a" translate="yes" xml:space="preserve">
          <source>n = 10</source>
          <target state="translated">n=10</target>
        </trans-unit>
        <trans-unit id="9a3240ad86b2b1d076825686aaf98565beeaac04" translate="yes" xml:space="preserve">
          <source>n = 2</source>
          <target state="translated">n=2</target>
        </trans-unit>
        <trans-unit id="5c515985c0cd23c7519d06977a9d6767394ced82" translate="yes" xml:space="preserve">
          <source>n = 3</source>
          <target state="translated">n=3</target>
        </trans-unit>
        <trans-unit id="83402797555a7a7885fe6185251ac997c92f242d" translate="yes" xml:space="preserve">
          <source>n = 4</source>
          <target state="translated">n=4</target>
        </trans-unit>
        <trans-unit id="adb8f164b2e9a9a073815a5580b5848dc5c47b6f" translate="yes" xml:space="preserve">
          <source>n = 5</source>
          <target state="translated">n=5</target>
        </trans-unit>
        <trans-unit id="6fec459a8cd8a34f975e728d91238f3f70ad3b48" translate="yes" xml:space="preserve">
          <source>n = 6</source>
          <target state="translated">n=6</target>
        </trans-unit>
        <trans-unit id="fd8cf86ee6124bea277fbfcdf77a50b8452d4005" translate="yes" xml:space="preserve">
          <source>n = 7</source>
          <target state="translated">n=7</target>
        </trans-unit>
        <trans-unit id="f0f1184215b3e3a06534b7ea7b8d947bb19c606d" translate="yes" xml:space="preserve">
          <source>n = 8</source>
          <target state="translated">n=8</target>
        </trans-unit>
        <trans-unit id="2cdacf2d84f0a2faf20a870a9028c14e3ea19dd0" translate="yes" xml:space="preserve">
          <source>n = 9</source>
          <target state="translated">n=9</target>
        </trans-unit>
        <trans-unit id="435cb10a0d15e1b9ac626e4505828ceeac244444" translate="yes" xml:space="preserve">
          <source>referenceToInnerFunction is set to outerFunction(), which simply returns a reference to innerFunction. When referenceToInnerFunction is called, it returns outerVar. Again, as above, this demonstrates that innerFunction has access to outerVar, a variable of outerFunction. Furthermore, it is interesting to note that it retains this access even after outerFunction has finished executing.</source>
          <target state="translated">referenceToInnerFunction se ajusta a outerFunction(),que simplemente devuelve una referencia a innerFunction.Cuando se llama referenceToInnerFunction,devuelve a outerVar.Nuevamente,como en el caso anterior,esto demuestra que la Función Interna tiene acceso a outerVar,una variable de la Función Externa.Además,es interesante notar que retiene este acceso incluso después de que la Función externa ha terminado de ejecutarse.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
