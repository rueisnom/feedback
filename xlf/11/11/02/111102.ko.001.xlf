<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/111102">
    <body>
      <group id="111102">
        <trans-unit id="edc3d87bc0d77451b24b00c1cf3016bdb95e72af" translate="yes" xml:space="preserve">
          <source>&quot;Come on &lt;em&gt;sing&lt;/em&gt;, Come and get &lt;em&gt;person&lt;/em&gt;!&quot;</source>
          <target state="translated">&quot; &lt;em&gt;노래&lt;/em&gt; 와서 &lt;em&gt;사람을&lt;/em&gt; 잡아!&quot;</target>
        </trans-unit>
        <trans-unit id="7dd20ec9bc8964ce1c79283c85999cad1cee4dac" translate="yes" xml:space="preserve">
          <source>...is really a princess with a little girl inside.</source>
          <target state="translated">... 실내에 어린 소녀가있는 공주입니다.</target>
        </trans-unit>
        <trans-unit id="103badd33a2698b99355a3659479f625c4c33efa" translate="yes" xml:space="preserve">
          <source>...telling stories about magic and fantasy.</source>
          <target state="translated">... 마술과 환상에 관한 이야기를 들려줍니다.</target>
        </trans-unit>
        <trans-unit id="dd3acb8afd097803b9360b2f69c1fea1de5f28bb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://en.wikipedia.org/wiki/Closure_(computer_science)&quot;&gt;Wikipedia on closures&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Closure_(computer_science)&quot;&gt;클로저 위키 백과&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="66795f475c16753ced57a004591a7e32d1be97f1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;createClosure(n)&lt;/code&gt; returns a function that returns the n within that scope.</source>
          <target state="translated">&lt;code&gt;createClosure(n)&lt;/code&gt; 은 해당 범위 내에서 n을 반환하는 함수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0605c773a855ad7752167561fff57f3ec27930c0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;If you are familiar with stack frames, these calculators seem strange: How can they keep accessing &lt;code&gt;n&lt;/code&gt; after &lt;code&gt;make_calculator&lt;/code&gt; returns?  The answer is to imagine that JavaScript doesn't use &quot;stack frames&quot;, but instead uses &quot;heap frames&quot;, which can persist after the function call that made them returns.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;스택 프레임에 익숙하다면 이러한 계산기는 이상하게 보입니다. &lt;code&gt;make_calculator&lt;/code&gt; 가 반환 된 후에 어떻게 &lt;code&gt;n&lt;/code&gt; 에 계속 액세스 할 수 있습니까?&lt;/em&gt; &lt;em&gt;답은 JavaScript가 &quot;스택 프레임&quot;을 사용하지 않고 대신 &quot;힙 프레임&quot;을 사용한다는 것을 상상하는 것입니다. &quot;힙 프레임&quot;은 함수 호출이 반환 된 후에도 지속될 수 있습니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f02b4fea2cc85281d187a2a3101725f3bd466ca9" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Note that &lt;code&gt;/*...*/&lt;/code&gt; and &lt;code&gt;//&lt;/code&gt; stop code being read by the browser.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt; &lt;code&gt;/*...*/&lt;/code&gt; 및 &lt;code&gt;//&lt;/code&gt; 는 브라우저가 코드를 읽는 것을 중지합니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="11d4db30148058831981cd0f151cdbbc17e172a8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;a href=&quot;http://jondavidjohn.com/javascript-closure-explained-using-events/&quot;&gt;Full Blog Post&lt;/a&gt;&lt;/strong&gt; (including jQuery considerations)</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;http://jondavidjohn.com/javascript-closure-explained-using-events/&quot;&gt;전체 블로그 게시물&lt;/a&gt;&lt;/strong&gt; (jQuery 고려 사항 포함)</target>
        </trans-unit>
        <trans-unit id="2184405757c5883c445a99418ddb1a5ee63000ff" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A closure does not reference a copy of the &lt;em&gt;old values&lt;/em&gt; of variables in its scope.&lt;/strong&gt; The variables themselves are part of the closure, and so the value seen when accessing one of those variables is the latest value at the time it is accessed. This is why inner functions created inside of loops can be tricky, since each one has access to the same outer variables rather than grabbing a copy of the variables at the time the function is created or called.</source>
          <target state="translated">&lt;strong&gt;클로저는 해당 범위에있는 &lt;em&gt;이전&lt;/em&gt; 변수 &lt;em&gt;값&lt;/em&gt; 의 사본을 참조하지 않습니다.&lt;/strong&gt; 변수 자체는 클로저의 일부이므로 해당 변수 중 하나에 액세스 할 때 표시되는 값은 액세스 시점의 최신 값입니다. 이것이 루프 내부에서 생성 된 내부 함수가 까다로울 수있는 이유입니다. 각 함수는 함수가 생성되거나 호출 될 때 변수의 복사본을 잡는 대신 동일한 외부 변수에 액세스 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fca46227ced34fb88ba8cfe8076a5166aafd4927" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A closure is not only created when you return an inner function.&lt;/strong&gt; In fact, the enclosing function &lt;em&gt;does not need to return at all&lt;/em&gt; in order for its closure to be created. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be called immediately or any time later. Therefore, the closure of the enclosing function is probably created &lt;em&gt;as soon as the enclosing function is called&lt;/em&gt; since any inner function has access to that closure whenever the inner function is called, before or after the enclosing function returns.</source>
          <target state="translated">&lt;strong&gt;내부 함수를 반환 할 때 클로저가 만들어지는 것은 아닙니다.&lt;/strong&gt; 실제로, 폐쇄 함수를 작성하기 위해 엔 클로징 함수 &lt;em&gt;가 전혀 리턴 될 필요는 없습니다&lt;/em&gt; . 대신 내부 범위를 외부 범위의 변수에 할당하거나 즉시 또는 나중에 호출 할 수있는 다른 함수에 인수로 전달할 수 있습니다. 따라서, 내부 함수가 호출 될 때마다, 내부 함수가 리턴되기 전이나 후에 내부 함수가 해당 폐쇄에 액세스 할 수 있기 때문에, 폐쇄 함수가 닫히는 &lt;em&gt;즉시&lt;/em&gt; 폐쇄 함수의 폐쇄가 작성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00219869d9055a1e27de043a26f737d91e3bf84a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A simple one-line closure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;간단한 한 줄 폐쇄&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="91cf9ee5cd212f0f8bb3975b7361624cdd8591da" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures are simple:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;폐쇄는 간단하다 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="250c978ae2221ba3664641f80c30d217a35cbabd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures use memory, but they don't cause memory leaks&lt;/strong&gt; since JavaScript by itself cleans up its own circular structures that are not referenced. Internet&amp;nbsp;Explorer memory leaks involving closures are created when it fails to disconnect DOM attribute values that reference closures, thus maintaining references to possibly circular structures.</source>
          <target state="translated">&lt;strong&gt;클로저는 메모리를 사용하지만&lt;/strong&gt; JavaScript 자체는 참조되지 않는 자체 원형 구조를 정리하므로 &lt;strong&gt;메모리 누수를 일으키지&lt;/strong&gt; 않습니다. 클로저를 포함하는 Internet Explorer 메모리 누수는 클로저를 참조하는 DOM 속성 값의 연결을 끊는 데 실패하여 순환 구조에 대한 참조를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="39211d5634ba3cd86a1dc857711c0d8ac86b5585" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Closures&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Closures&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d15f24a4f0cd805269e16daabf51293fb70abdd7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Details&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Details&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e10d41f97175e0e801260eba2b8480649a3edd17" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;I do not understand why the answers are so complex here.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;나는 왜 대답이 그렇게 복잡한 지 이해하지 못한다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a50ab2a11da4fccbf9d1c29ea600ffcd387ddf7c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;INSTRUCTIONS&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;INSTRUCTIONS&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1ff1823b9f3f4a4211cd7c4e7170f0588c83d10b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Nested functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;중첩 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53afa8789f0371667bc4398726df5e5b35cd9345" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Once upon a time:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;옛날 옛적에:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f67d2cba0fc9f06b1b71e8974beb527b1d446b34" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Please note that in an attempt to improve clarity and accuracy, this answer has been substantially changed from the original.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;명확성과 정확성을 향상시키기 위해이 답변은 원본과 크게 달라졌습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0dfa0bbb5599405ba4b579ca14868a26d8d25c5d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;THE LONG CODE EXAMPLE ABOVE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;위의 긴 코드 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0def28abff50b5453af5effe03f21c319e75a393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d5d4cedc50da37d6975ca1e41fe4dc499b53f427" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;That is pretty much all there is to closures.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그것은 폐쇄에 거의 모든 것입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e361521851a8d0097ea1590fec832e52c6bc93db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The &quot;variables&quot; in a closure include any named functions&lt;/strong&gt; declared within the function. They also include arguments of the function. A closure also has access to its containing closure's variables, all the way up to the global scope.</source>
          <target state="translated">&lt;strong&gt;클로저의 &quot;변수&quot;에는 함수&lt;/strong&gt; 내에 선언 된 &lt;strong&gt;명명 된 함수&lt;/strong&gt; 가 &lt;strong&gt;포함&lt;/strong&gt; 됩니다. 또한 함수의 인수도 포함합니다. 클로저는 또한 클로저를 포함하는 클로저 변수에 대한 전역 액세스 권한을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="4531071f03fc0a5d3c0274d7c65683c8b80868b8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The key point:&lt;/strong&gt; Each call to &lt;code&gt;make_calculator&lt;/code&gt; creates a new local variable &lt;code&gt;n&lt;/code&gt;, which continues to be usable by that calculator's &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt; functions long after &lt;code&gt;make_calculator&lt;/code&gt; returns.</source>
          <target state="translated">&lt;strong&gt;요점 :&lt;/strong&gt; &lt;code&gt;make_calculator&lt;/code&gt; 를 호출 할 때 마다 &lt;code&gt;make_calculator&lt;/code&gt; 가 반환 된 후에도 해당 계산기의 &lt;code&gt;add&lt;/code&gt; 및 &lt;code&gt;multiply&lt;/code&gt; 함수에서 계속 사용할 수있는 새로운 로컬 변수 &lt;code&gt;n&lt;/code&gt; 이 만들어집니다.</target>
        </trans-unit>
        <trans-unit id="c2f004a18b07e1ba3d927ea9c5aa182e662f6312" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The whole point is to ensure that if the inner function wants to access an outer variable in the future, it is able to do so.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;요점은 내부 함수가 나중에 외부 변수에 액세스하려는 경우 그렇게 할 수 있는지 확인하는 것입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9289561f1d2c7006a3223c749a580963260ce102" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;*A C# question&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;* AC # 질문&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="2907f5d699e83f056b74043078bdbf321536087f" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;sup&gt;**&lt;/sup&gt; Any outer function, if several are nested, or even in the global context, as &lt;a href=&quot;https://stackoverflow.com/a/5099447/706054&quot;&gt;this answer&lt;/a&gt; points out clearly.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;sup&gt;**&lt;/sup&gt; &lt;a href=&quot;https://stackoverflow.com/a/5099447/706054&quot;&gt;이 답변이&lt;/a&gt; 명확하게 지적하기 때문에 여러 외부 함수가 중첩되거나 전역 컨텍스트 인 경우 외부 함수.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="841613276b73dfb7dcf3075c43173d44d03601fb" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;sup&gt;*&lt;/sup&gt; For example, it covers all the points in the &quot;Closures for Dummies&quot; article given in &lt;a href=&quot;https://stackoverflow.com/a/111111/706054&quot;&gt;another answer&lt;/a&gt;, except example 6, which simply shows that variables can be used before they are declared, a nice fact to know but completely unrelated to closures. It also covers all the points in &lt;a href=&quot;https://stackoverflow.com/a/111200/706054&quot;&gt;the accepted answer&lt;/a&gt;, except for the points (1) that functions copy their arguments into local variables (the named function arguments), and (2) that copying numbers creates a new number, but copying an object reference gives you another reference to the same object. These are also good to know but again completely unrelated to closures. It is also very similar to the example in &lt;a href=&quot;https://stackoverflow.com/a/111114/706054&quot;&gt;this answer&lt;/a&gt; but a bit shorter and less abstract. It does not cover the point of &lt;a href=&quot;https://stackoverflow.com/a/17200991/706054&quot;&gt;this answer&lt;/a&gt; or &lt;a href=&quot;https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17308587?noredirect=1#comment26377355_111111&quot;&gt;this comment&lt;/a&gt;, which is that JavaScript makes it difficult to plug the &lt;em&gt;current&lt;/em&gt; value of a loop variable into your inner function: The &quot;plugging in&quot; step can only be done with a helper function that encloses your inner function and is invoked on each loop iteration. (Strictly speaking, the inner function accesses the helper function's copy of the variable, rather than having anything plugged in.) Again, very useful when creating closures, but not part of what a closure is or how it works. There is additional confusion due to closures working differently in functional languages like ML, where variables are bound to values rather than to storage space, providing a constant stream of people who understand closures in a way (namely the &quot;plugging in&quot; way) that is simply incorrect for JavaScript, where variables are always bound to storage space, and never to values. &lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;sup&gt;*&lt;/sup&gt; 예를 들어, 변수 6은 변수가 선언되기 전에 사용될 수 있다는 것을 보여주는 예제 6을 제외하고는 &lt;a href=&quot;https://stackoverflow.com/a/111111/706054&quot;&gt;다른 답변&lt;/a&gt; 에서 제공된 &quot;모두에 대한 클로저&quot;기사의 모든 요점을 다룹니다. 변수는 선언되기 전에 변수를 사용할 수 있다는 것을 보여줍니다.&lt;/sup&gt; &lt;sup&gt;또한 함수가 인수를 로컬 변수 (명명 된 함수 인수)에 복사하는 점 (2), 숫자를 복사하면 새로운 숫자가 생성되지만 객체 참조는 복사한다는 점을 제외하고 &lt;a href=&quot;https://stackoverflow.com/a/111200/706054&quot;&gt;는 허용 된 답변의&lt;/a&gt; 모든 점을 다룹니다. 동일한 객체에 대한 다른 참조를 제공합니다.&lt;/sup&gt; &lt;sup&gt;이것도 알고 있지만 클로저와는 전혀 관련이 없습니다.&lt;/sup&gt; &lt;sup&gt;또한 &lt;a href=&quot;https://stackoverflow.com/a/111114/706054&quot;&gt;이 답변&lt;/a&gt; 의 예와 매우 유사하지만 약간 짧고 덜 추상적입니다.&lt;/sup&gt; &lt;sup&gt;&lt;a href=&quot;https://stackoverflow.com/a/17200991/706054&quot;&gt;이 답변&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/questions/111102/how-do-javascript-closures-work/17308587?noredirect=1#comment26377355_111111&quot;&gt;이나이 의견&lt;/a&gt; 의 요점을 다루지 않습니다. JavaScript는 루프 변수의 &lt;em&gt;현재&lt;/em&gt; 값을 내부 함수에 연결하는 것을 어렵게합니다. &quot;플러그인&quot;단계는 묶는 도우미 함수로만 수행 할 수 있습니다. 내부 함수이며 각 루프 반복에서 호출됩니다.&lt;/sup&gt; &lt;sup&gt;엄밀히 말하면, 내부 함수는 무언가를 연결하지 않고 도우미 함수의 변수 복사본에 액세스합니다. 클로저를 만들 때 매우 유용하지만 클로저의 작동 방식이나 작동 방식의 일부는 아닙니다.&lt;/sup&gt; &lt;sup&gt;ML과 같은 기능적 언어에서 클로저가 다르게 작동하는 클로저로 인해 변수가 저장 공간이 아닌 값에 바인딩되어 클로저를 이해하는 사람들에게 일정한 방식으로 (즉, &quot;플러그인&quot;방식으로) 변수가 항상 저장 공간에 바인딩되고 값에 바인딩되지 않는 JavaScript의 경우에는 정확하지 않습니다.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="eb8e6848b2572e4d1686265bf069ed036b474a37" translate="yes" xml:space="preserve">
          <source>A closure in JavaScript is like keeping a reference (&lt;strong&gt;NOT&lt;/strong&gt; a copy) to the scope at the point of function declaration... plus a link to all the scopes nested outside that scope.</source>
          <target state="translated">JavaScript에서 클로저는 함수 선언 시점에서 범위에 대한 참조 (사본이 아님)를 유지하는 것과 같습니다. 그 범위 밖에 중첩 된 모든 범위에 대한 링크도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9374176e6956e9c55a03f208ff3b626b273cf5dc" translate="yes" xml:space="preserve">
          <source>A closure is a function that has access to another function's scope (its variables and functions). The easiest way to create a closure is with a function within a function; the reason being that in JavaScript a function always has access to its containing function&amp;rsquo;s scope.</source>
          <target state="translated">클로저는 다른 함수의 범위 (변수 및 함수)에 액세스 할 수있는 함수입니다. 클로저를 만드는 가장 쉬운 방법은 함수 내에 함수를 사용하는 것입니다. JavaScript에서 함수는 항상 포함하는 함수의 범위에 액세스 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="fd2d062c668410ccdcd9af34cc85522e6c1afaa2" translate="yes" xml:space="preserve">
          <source>A closure is a link between a function and its outer lexical (ie. as-written) environment, such that the identifiers (variables, parameters, function declarations etc) defined within that environment are visible from within the function, regardless of when or from where the function is invoked.</source>
          <target state="translated">클로저는 함수와 외부 어휘 (즉, 작성된 그대로) 환경 사이의 링크로서, 해당 환경 내에 정의 된 식별자 (변수, 매개 변수, 함수 선언 등)가 언제 또는 어디서든 함수 내에서 볼 수 있습니다. 함수가 호출되는 곳.</target>
        </trans-unit>
        <trans-unit id="cec926b0cb259356a86639e657b14e8e1b4d0b58" translate="yes" xml:space="preserve">
          <source>A closure is created when a function is declared; this closure is used to configure the execution context when the function is invoked.</source>
          <target state="translated">함수가 선언되면 클로저가 생성됩니다. 이 클로저는 함수가 호출 될 때 실행 컨텍스트를 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="88f672a9df48ba5975f39c3937c757038142dc61" translate="yes" xml:space="preserve">
          <source>A closure is not only created when you return an inner function. In fact, the enclosing function does not need to return at all. You might instead assign your inner function to a variable in an outer scope, or pass it as an argument to another function where it could be used immediately. Therefore, the closure of the enclosing function probably already exists at the time that enclosing function was called since any inner function has access to it as soon as it is called.</source>
          <target state="translated">내부 함수를 반환 할 때 클로저가 만들어지는 것은 아닙니다. 실제로, 둘러싸는 함수는 전혀 리턴 할 필요가 없습니다. 대신 내부 함수를 외부 범위의 변수에 할당하거나 즉시 사용할 수있는 다른 함수에 인수로 전달할 수 있습니다. 따라서, 내부 함수가 호출 되 자마자 내부 함수에 액세스 할 수 있으므로 둘러싸 기 함수가 닫 혔을 때 둘러싸는 함수의 클로저가 이미 존재할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfc70bbb817358717b49d080b1eca649757aa359" translate="yes" xml:space="preserve">
          <source>A closure is one way of supporting &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;first-class functions&lt;/a&gt;; it is an expression that can reference variables within its scope (when it was first declared), be assigned to a variable, be passed as an argument to a function, or be returned as a function result.</source>
          <target state="translated">클로저는 &lt;a href=&quot;https://en.wikipedia.org/wiki/First-class_function&quot;&gt;일급 함수&lt;/a&gt; 를 지원하는 한 가지 방법입니다. 해당 범위 내에서 변수를 참조 (처음 선언 된 경우)하거나 변수에 지정하거나 함수에 인수로 전달하거나 함수 결과로 리턴 할 수있는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="0ef763764e04164186e2a1ceb3806cf6d8f2b116" translate="yes" xml:space="preserve">
          <source>A closure is where an inner function has access to variables in its outer function. That's probably the simplest one-line explanation you can get for closures.</source>
          <target state="translated">클로저는 내부 함수가 외부 함수의 변수에 액세스 할 수있는 곳입니다. 아마도 폐쇄에 대해 얻을 수있는 가장 간단한 단선 설명 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="3259e0c90916fb0e4045b771243c259d5847d8f6" translate="yes" xml:space="preserve">
          <source>A function doesn't have to &lt;em&gt;return&lt;/em&gt; in order to create a closure. Simply by virtue of its declaration, every function closes over its enclosing lexical environment, forming a closure.</source>
          <target state="translated">클로저를 만들기 위해 함수를 &lt;em&gt;반환&lt;/em&gt; 할 필요는 없습니다. 선언으로 간단히 말해서 모든 함수는 닫는 어휘 환경을 닫아 폐쇄를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="026c5616609e62af2f61992526a7c3f75658b65c" translate="yes" xml:space="preserve">
          <source>A function in JavaScript is not just a reference to a set of instructions (as in C language), but it also includes a hidden data structure which is composed of references to all nonlocal variables it uses (captured variables). Such two-piece functions are called closures. Every function in JavaScript can be considered a closure.</source>
          <target state="translated">JavaScript의 함수는 C 언어에서와 같이 명령어 집합에 대한 참조 일뿐 아니라 사용하는 모든 비 로컬 변수 (캡처 된 변수)에 대한 참조로 구성된 숨겨진 데이터 구조도 포함합니다. 이러한 2 피스 기능을 클로저라고합니다. JavaScript의 모든 함수는 클로저로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ae534cf02a5858b2d840f1a7673a1afe06d7bfc" translate="yes" xml:space="preserve">
          <source>A function normally has a name, parentheses and braces. Like this:</source>
          <target state="translated">함수에는 일반적으로 이름, 괄호 및 중괄호가 있습니다. 이처럼 :</target>
        </trans-unit>
        <trans-unit id="99a4243b87430cefe6f1afae7fcb4af6221200d0" translate="yes" xml:space="preserve">
          <source>A great explanation of how closures can &lt;a href=&quot;https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited&quot;&gt;cause memory leaks in IE&lt;/a&gt; if you are not careful.</source>
          <target state="translated">조심하지 않으면 &lt;a href=&quot;https://www.codeproject.com/Articles/12231/Memory-Leakage-in-Internet-Explorer-revisited&quot;&gt;IE에서&lt;/a&gt; 클로저가 메모리 누수를 일으키는 방법에 대한 훌륭한 설명.</target>
        </trans-unit>
        <trans-unit id="c46e219fc09ff6a6e30c8ecd75a04e05369c3ec3" translate="yes" xml:space="preserve">
          <source>A nested function may continue to live after the outer function has finished:</source>
          <target state="translated">외부 함수가 완료된 후에 중첩 함수가 계속 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ab1874227fa89cd67efbb317da32d2f6c6a64fd" translate="yes" xml:space="preserve">
          <source>A new set of local variables is kept every time a function is called (given that the function contains a function declaration inside it, and a reference to that inside function is either returned or an external reference is kept for it in some way).</source>
          <target state="translated">함수가 호출 될 때마다 새로운 로컬 변수 세트가 유지됩니다 (함수에 함수 선언이 포함되어 있고 내부 함수에 대한 참조가 리턴되거나 외부 참조가 어떤 방식 으로든 유지됨).</target>
        </trans-unit>
        <trans-unit id="5efdcbea95121298d3ad2d07cbbe7dcf0db4867d" translate="yes" xml:space="preserve">
          <source>ALERT: gorilla</source>
          <target state="translated">경고 : 고릴라</target>
        </trans-unit>
        <trans-unit id="2d25aee06019d734098a42118e386bcd1cb56358" translate="yes" xml:space="preserve">
          <source>ALERT: monkey</source>
          <target state="translated">경고 : monkey</target>
        </trans-unit>
        <trans-unit id="cd6c81ca63b69c9246d861c2e95db5f815d2ca1c" translate="yes" xml:space="preserve">
          <source>ALERT: monkey
ALERT: monkey</source>
          <target state="translated">경고 : 원숭이 경고 : 원숭이</target>
        </trans-unit>
        <trans-unit id="37b0eb534510d977f89353bc69e9f62a4b8877f3" translate="yes" xml:space="preserve">
          <source>After the closures come the lines</source>
          <target state="translated">폐쇄 후 라인</target>
        </trans-unit>
        <trans-unit id="473797be1179e97465610490a5af19283b615cbe" translate="yes" xml:space="preserve">
          <source>After the loop finished and &lt;code&gt;index&lt;/code&gt; was done being modified the end value was 10, therefore every function added to the array returns the value of the single &lt;code&gt;index&lt;/code&gt; variable which is now set to 10.</source>
          <target state="translated">루프가 완료되고 &lt;code&gt;index&lt;/code&gt; 가 수정 된 후에는 최종 값이 10이되었으므로 배열에 추가 된 모든 함수는 이제 단일 &lt;code&gt;index&lt;/code&gt; 변수의 값을 반환하며 이제는 10으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0c5c53c9b406b802e8050cdcb2d55f485bc7eae0" translate="yes" xml:space="preserve">
          <source>After this we have the line</source>
          <target state="translated">이 후 우리는 라인을 가지고</target>
        </trans-unit>
        <trans-unit id="b1283dc7aa9afa2d62e552768aa61cc0797578c6" translate="yes" xml:space="preserve">
          <source>All four of these functions are closures as they all access their environment.</source>
          <target state="translated">이 네 가지 기능은 모두 환경에 액세스 할 때 클로저입니다.</target>
        </trans-unit>
        <trans-unit id="e97e0f50a5e629695aedee5a89cca10ea6b0cb28" translate="yes" xml:space="preserve">
          <source>All of the functions added to the array return the SAME &lt;code&gt;index&lt;/code&gt; variable from the parent scope where it was defined instead of 10 different ones from 10 different scopes like the first example. The end result is that all 10 functions return the same variable from the same scope.</source>
          <target state="translated">배열에 추가 된 모든 함수는 첫 번째 예제와 같이 10 개의 다른 범위에서 10 개의 다른 변수 대신 정의 된 상위 범위에서 SAME &lt;code&gt;index&lt;/code&gt; 변수를 반환합니다. 결과적으로 10 개의 모든 함수가 동일한 범위에서 동일한 변수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e254452976bf3a1139922787e1c255443f069708" translate="yes" xml:space="preserve">
          <source>All this data stuff sounds a bit boring, but it is really very cool; we might have a function that tells a robot what to make for dinner. Let's say I invite you and your friend to my house. You like chicken legs best, I like sausages, your friend always wants what you want and my friend does not eat meat.</source>
          <target state="translated">이 모든 데이터는 약간 지루한 것처럼 들리지만 정말 멋지다. 우리는 저녁 식사를 위해 무엇을 만들어야하는지 로봇에게 알려주는 기능을 가지고있을 것입니다. 내가 당신과 당신의 친구를 내 집에 초대한다고 가정 해 봅시다. 당신은 닭 다리를 가장 좋아하고, 소시지를 좋아하고, 친구는 항상 당신이 원하는 것을 원하고 내 친구는 고기를 먹지 않습니다.</target>
        </trans-unit>
        <trans-unit id="86693ebc04e6080838a0974d1c5fdd94dcf0851e" translate="yes" xml:space="preserve">
          <source>All three global functions have a common reference to the &lt;em&gt;same&lt;/em&gt; closure because they are all declared within a single call to &lt;code&gt;setupSomeGlobals()&lt;/code&gt;.</source>
          <target state="translated">세 개의 전역 함수는 모두 &lt;code&gt;setupSomeGlobals()&lt;/code&gt; 대한 단일 호출 내에서 선언되므로 &lt;em&gt;동일한&lt;/em&gt; 클로저에 대한 공통 참조를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="010ea26c09769d3f5e5a4fa466cb6c5456b66f63" translate="yes" xml:space="preserve">
          <source>All variables outside the returned function are available to the returned function, but they are not directly available to the returned function object...</source>
          <target state="translated">반환 된 함수 외부의 모든 변수는 반환 된 함수에서 사용할 수 있지만 반환 된 함수 개체에서 직접 사용할 수는 없습니다 ...</target>
        </trans-unit>
        <trans-unit id="c4594b92814cb252202666c4d92f85aa73ea246b" translate="yes" xml:space="preserve">
          <source>Also, it must be understood that local variables in JavaScript are created not on the stack frame, but on the heap and destroyed only when no one is referencing them. When a function returns, references to its local variables are decremented, but they can still be non-null if during the current execution they became part of a closure and are still referenced by its lexically nested functions (which can happen only if the references to these nested functions were returned or otherwise transferred to some external code).</source>
          <target state="translated">또한 JavaScript의 로컬 변수는 스택 프레임이 아니라 힙에 작성되며 아무도 참조하지 않는 경우에만 파괴됩니다. 함수가 반환되면 로컬 변수에 대한 참조는 감소하지만 현재 실행 중에 클로저의 일부가되고 어휘 중첩 함수에 의해 여전히 참조되는 경우 여전히 null이 아닐 수 있습니다. 이러한 중첩 함수는 반환되었거나 다른 외부 코드로 전송되었습니다.</target>
        </trans-unit>
        <trans-unit id="3bce66ad1af625b4de8c481a747409bc48008eb0" translate="yes" xml:space="preserve">
          <source>Also, this private variable state is &lt;strong&gt;fully&lt;/strong&gt; accessible, for both readings and assigning to its private scoped variables.</source>
          <target state="translated">또한이 개인용 변수 상태는 개인용 범위 변수를 읽고 할당하는 데 모두 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f230a19f88726fa9de2c57f5cbfa8e8e4472abd" translate="yes" xml:space="preserve">
          <source>An answer for a six-year-old (assuming he knows what a function is and what a variable is, and what data is):</source>
          <target state="translated">6 살짜리에 대한 답 (함수가 무엇인지, 변수가 무엇인지, 데이터가 무엇인지 알고 있다고 가정) :</target>
        </trans-unit>
        <trans-unit id="d7b09515b9865b30af6b3fa920a76512708611e1" translate="yes" xml:space="preserve">
          <source>An example of a closure</source>
          <target state="translated">폐쇄의 예</target>
        </trans-unit>
        <trans-unit id="f481ad49809e7c27b79d2e6d830283b22c04c1f7" translate="yes" xml:space="preserve">
          <source>An example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="819beada86acdf2bbd115d5e1db66e6b0bee2da8" translate="yes" xml:space="preserve">
          <source>And even though the grown-ups knew of real princesses, they would never believe in the unicorns or dragons because they could never see them. The grown-ups said that they only existed inside the little girl's imagination.</source>
          <target state="translated">어른들은 실제 공주를 알고 있지만 유니콘이나 용을 절대 믿지 않을 것입니다. 어른들은 어린 소녀의 상상 속에 만 존재한다고 말했다.</target>
        </trans-unit>
        <trans-unit id="57dfb708e06183c8ecb1f0c30e96af35afaf50ba" translate="yes" xml:space="preserve">
          <source>And here is where things get really interesting. If we were to get rid of outerFunction, say set it to null, you might think that referenceToInnerFunction would loose its access to the value of outerVar. But this is not the case.</source>
          <target state="translated">그리고 여기에 정말 흥미로운 일이 있습니다. outerFunction을 제거하려면 null로 설정하면 referenceToInnerFunction이 outerVar 값에 대한 액세스 권한을 잃을 것이라고 생각할 수 있습니다. 그러나 이것은 사실이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="435fb8d87e8d248469850188da7e2ad10deaaf3b" translate="yes" xml:space="preserve">
          <source>And if you remember, when &lt;code&gt;this.say&lt;/code&gt; is created, it (as every function) gets an internal reference &lt;code&gt;this.say.[[Scope]]&lt;/code&gt; to the current LexicalEnvironment. So, the LexicalEnvironment of the current User execution stays in memory. All variables of User also are its properties, so they are also carefully kept, not junked as usually.</source>
          <target state="translated">그리고 여러분이 &lt;code&gt;this.say&lt;/code&gt; 가 생성 될 때 (모든 함수로서) 현재 LexicalEnvironment에 대한 &lt;code&gt;this.say.[[Scope]]&lt;/code&gt; 내부 참조를 얻습니다 . 따라서 현재 사용자 실행의 LexicalEnvironment는 메모리에 남아 있습니다. User의 모든 변수는 속성이므로 일반적으로 정크가 아닌 신중하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="625ff0ae825173e464152e82b8c8264f2701a52a" translate="yes" xml:space="preserve">
          <source>And now, even though Mary is &quot;no longer running&quot;, the memory of her is not lost and her child will always remember her name and other secrets they shared during their time together.</source>
          <target state="translated">그리고 지금, 마리아가 더 이상 달리지 않더라도, 그녀의 기억은 상실되지 않으며 그녀의 아이는 그들의 시간 동안 함께 공유 한 그녀의 이름과 다른 비밀들을 항상 기억할 것입니다.</target>
        </trans-unit>
        <trans-unit id="dd1dc01a62936ce68f2808899afc6036354d1594" translate="yes" xml:space="preserve">
          <source>And she would often tell them of her latest amazing adventure as a princess.</source>
          <target state="translated">그리고 그녀는 종종 공주로서 그녀의 최신 놀라운 모험에 대해 이야기 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="b4380f96cc0e7a3c2e34bc8ce6205c32c2126439" translate="yes" xml:space="preserve">
          <source>And yes, I'd even recommend it to a 6-year old -- if the 6-year old is learning about closures, then it's logical they're ready to comprehend the &lt;em&gt;concise and simple explanation&lt;/em&gt; provided in the article.</source>
          <target state="translated">그렇습니다. 6 살짜리 아이에게도 권하고 싶습니다. 6 살짜리 아이가 클로저에 대해 배우면 기사에 제공된 &lt;em&gt;간결하고 간단한 설명&lt;/em&gt; 을 이해할 준비가 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="174ee1c1a9c452a97f5a4e71705d3ba0633128b2" translate="yes" xml:space="preserve">
          <source>Another really simple way to explain it is in terms of scope:</source>
          <target state="translated">그것을 설명하는 또 다른 간단한 방법은 범위 측면입니다.</target>
        </trans-unit>
        <trans-unit id="efcadf61fe3fe42ed34cfdd66b0ecbf1ed3408ef" translate="yes" xml:space="preserve">
          <source>Any time you create a smaller scope inside of a larger scope, the smaller scope will always be able to see what is in the larger scope.</source>
          <target state="translated">더 큰 범위 내에서 더 작은 범위를 만들 때마다 더 작은 범위는 항상 더 큰 범위의 내용을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="d5593bba6625e12152d79d70e57424cdd0e4f606" translate="yes" xml:space="preserve">
          <source>As a father of a 6-year-old, currently teaching young children (and a relative novice to coding with no formal education so corrections will be required), I think the lesson would stick best through hands-on play. If the 6-year-old is ready to understand what a closure is, then they are old enough to have a go themselves. I'd suggest pasting the code into jsfiddle.net, explaining a bit, and leaving them alone to concoct a unique song. The explanatory text below is probably more appropriate for a 10 year old.</source>
          <target state="translated">6 살짜리의 아버지로서 현재 어린 아이들을 가르치고 있으며 (정식 교육을받지 않고 코딩을하는 상대적인 초보자이므로 수정이 필요할 것입니다), 수업은 실습을 통해 가장 잘 진행될 것이라고 생각합니다. 6 살짜리가 폐쇄가 무엇인지 이해할 준비가되면, 그들은 스스로 갈 수있을 정도로 오래되었습니다. 코드를 jsfiddle.net에 붙여 넣고 조금 설명하고 독창적 인 노래를 만들기 위해 혼자 남겨 두는 것이 좋습니다. 아래 설명 텍스트는 아마도 10 살짜리 어린이에게 더 적합 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="6568100bffff0b20e0c37f88a640e7173cdcd704" translate="yes" xml:space="preserve">
          <source>As we see, &lt;code&gt;this.say&lt;/code&gt; is a property in the user object, so it continues to live after User completed.</source>
          <target state="translated">보시다시피 &lt;code&gt;this.say&lt;/code&gt; 는 사용자 객체의 속성이므로 User가 완료된 후에도 계속 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="e1626c59ebd74e38dd52b09e3c12153695d67816" translate="yes" xml:space="preserve">
          <source>As you can see, the toys left in the room are still accessible via the brother and no matter if the room is locked. Here is &lt;a href=&quot;http://jsbin.com/ubakor/9/edit&quot;&gt;a jsbin&lt;/a&gt; to play around with it.</source>
          <target state="translated">보시다시피, 방에 남겨진 장난감은 방이 잠겨 있더라도 형제를 통해 여전히 액세스 할 수 있습니다. 여기 &lt;a href=&quot;http://jsbin.com/ubakor/9/edit&quot;&gt;에 jsbin&lt;/a&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="890df09169ac0377be2b819d1f924abc0cd10e89" translate="yes" xml:space="preserve">
          <source>As you may guess, because the variables are re-created every time the function is called, and nobody else will know them, there must be a secret place where they are stored. It could be called &lt;strong&gt;Chamber of Secrets&lt;/strong&gt; or &lt;strong&gt;stack&lt;/strong&gt; or &lt;strong&gt;local scope&lt;/strong&gt; but it doesn't really matter. We know they are there, somewhere, hidden in the memory.</source>
          <target state="translated">짐작할 수 있듯이, 함수가 호출 될 때마다 변수가 다시 작성되므로 아무도 알 수 없으므로 변수가 저장되는 비밀 장소가 있어야합니다. &lt;strong&gt;비밀 회의소&lt;/strong&gt; 또는 &lt;strong&gt;스택&lt;/strong&gt; 또는 &lt;strong&gt;로컬 범위&lt;/strong&gt; 라고 할 수 있지만 실제로는 중요하지 않습니다. 우리는 그들이 어딘가에 기억 속에 숨겨져 있다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="986da2f4d4b325d9fb2c07a7e2b3897081cd863a" translate="yes" xml:space="preserve">
          <source>BRACES: &quot;Braces&quot; which look like this &lt;code&gt;{}&lt;/code&gt; are the tinted windows of our factory. From inside the factory you can see out, but from the outside you can't see in.</source>
          <target state="translated">중괄호 : &lt;code&gt;{}&lt;/code&gt; 처럼 보이는 &quot;중괄호&quot;는 공장의 색조 창입니다. 공장 내부에서는 볼 수 있지만 외부에서는 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3575d07a466999847f383f17914159e3dbdd22b0" translate="yes" xml:space="preserve">
          <source>BROWSER: When you connect to the Internet on a computer, tablet or phone to visit a website, you use a browser. Examples you may know are Internet Explorer, Chrome, Firefox and Safari. The browser can understand JavaScript and tell the computer what it needs to do. The JavaScript instructions are called functions.</source>
          <target state="translated">브라우저 : 컴퓨터, 태블릿 또는 휴대폰에서 인터넷에 연결하여 웹 사이트를 방문 할 때 브라우저를 사용합니다. Internet Explorer, Chrome, Firefox 및 Safari가 있습니다. 브라우저는 JavaScript를 이해하고 컴퓨터에 필요한 것을 알려줍니다. JavaScript 명령어를 함수라고합니다.</target>
        </trans-unit>
        <trans-unit id="0419e91da10b803e76b92f8dffe5555643e1dd03" translate="yes" xml:space="preserve">
          <source>Because all these external variables referenced by a lexically nested function are actually local variables in the chain of its lexically enclosing functions (global variables can be assumed to be local variables of some root function), and every single execution of a function creates new instances of its local variables, it follows that every execution of a function returning (or otherwise transferring it out, such as registering it as a callback) a nested function creates a new closure (with its own potentially unique set of referenced nonlocal variables which represent its execution context).</source>
          <target state="translated">어휘 중첩 함수가 참조하는 이러한 모든 외부 변수는 실제로 어휘 포함 함수 체인에있는 로컬 변수이므로 (글로벌 변수는 일부 루트 함수의 로컬 변수라고 가정 할 수 있음) 함수를 실행할 때마다 새 인스턴스가 작성됩니다. 지역 변수에 따라, 함수를 반환하거나 콜백으로 등록하는 등 함수를 전달할 때마다 함수가 실행될 때마다 새로운 클로저가 생성됩니다. 문맥).</target>
        </trans-unit>
        <trans-unit id="42668682fc7dcf2769407c41fc937cdbf7dd8025" translate="yes" xml:space="preserve">
          <source>Because there was only one scope within the &lt;code&gt;createClosureArray()&lt;/code&gt; function, &lt;code&gt;index&lt;/code&gt; is only bound to a value within that scope. In other words, each time the loop changes the value of &lt;code&gt;index&lt;/code&gt;, it changes it for everything that references it within that scope.</source>
          <target state="translated">&lt;code&gt;createClosureArray()&lt;/code&gt; 함수 내에 하나의 범위 만 있기 때문에 &lt;code&gt;index&lt;/code&gt; 는 해당 범위 내의 값에만 바인드됩니다. 즉, 루프가 &lt;code&gt;index&lt;/code&gt; 값을 변경할 때마다 해당 범위 내에서이를 참조하는 모든 항목에 대해 값이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="14c3a147917bc6f80510553c690b0ab8c8718635" translate="yes" xml:space="preserve">
          <source>But all they would see is a little girl...</source>
          <target state="translated">하지만 그들이 볼 수있는 것은 어린 소녀 일뿐입니다 ...</target>
        </trans-unit>
        <trans-unit id="bb8c57c634a563056b164f5aeb01e4ac8232dc6d" translate="yes" xml:space="preserve">
          <source>But how is this so? How can referenceToInnerFunction still know the value of outerVar now that outerFunction has been set to null?</source>
          <target state="translated">그러나 이것은 어떻습니까? outerFunction이 null로 설정되었으므로 referenceToInnerFunction이 어떻게 여전히 outerVar의 값을 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="146180db52e416274e24ed731f90ff6fc5ad3201" translate="yes" xml:space="preserve">
          <source>But she would always have to return back to her dull world of chores and grown-ups.</source>
          <target state="translated">그러나 그녀는 항상 그녀의 무성한 집안일과 어른들로 돌아 가야했습니다.</target>
        </trans-unit>
        <trans-unit id="866ff54f49d509edc499efd08ef16cd5aed44ee7" translate="yes" xml:space="preserve">
          <source>But the sad thing is, if the child is also a private variable of its parent function, it would also die when the parent ends, and the secrets would die with them.</source>
          <target state="translated">그러나 슬픈 것은 아이가 부모 기능의 개인 변수 인 경우 부모가 끝날 때 죽을 것이고 비밀은 그들과 함께 죽을 것이라는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dbf03411a9d8f9c4e1de5345b3a10c168dfc2df8" translate="yes" xml:space="preserve">
          <source>But we know the real truth; that the little girl with the princess inside...</source>
          <target state="translated">그러나 우리는 진실을 알고 있습니다. 공주님과 함께있는 어린 소녀가</target>
        </trans-unit>
        <trans-unit id="a343ea5602007ce993e1966d841864424094a57f" translate="yes" xml:space="preserve">
          <source>But, in JavaScript there is this very special thing that functions which are created inside other functions, can also know the local variables of their parents and keep them as long as they live.</source>
          <target state="translated">그러나 JavaScript에는 다른 함수 내에서 작성된 함수가 부모의 로컬 변수를 알고 수명이 유지되는 한 유지할 수있는 매우 특별한 것이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5d22ad9eb11c8d7544b41c9fd9c72490630172cd" translate="yes" xml:space="preserve">
          <source>CLOSURES DONE RIGHT</source>
          <target state="translated">마감은 옳았다</target>
        </trans-unit>
        <trans-unit id="b8c469b8120b44b5dd72fc632091339193c9122a" translate="yes" xml:space="preserve">
          <source>CLOSURES DONE WRONG</source>
          <target state="translated">마감이 잘못됨</target>
        </trans-unit>
        <trans-unit id="3344264f6f33fcb6fbcf186f0b6ad57482d348ae" translate="yes" xml:space="preserve">
          <source>CLOSURES: The closures are the smaller functions that are inside the big &lt;em&gt;sing()&lt;/em&gt; function. The little factories inside the big factory. They each have their own braces which mean that the variables inside them can't be seen from the outside. That's why the names of the variables (&lt;em&gt;creature&lt;/em&gt; and &lt;em&gt;result&lt;/em&gt;) can be repeated in the closures but with different values. If you type these variable names in the console window, you won't get its value because it's hidden by two layers of tinted windows.</source>
          <target state="translated">클로저 : 클로저는 큰 &lt;em&gt;sing ()&lt;/em&gt; 함수 안에있는 더 작은 함수입니다. 큰 공장 안에있는 작은 공장들. 그들은 각각 자신의 중괄호를 가지고 있으며, 이는 내부의 변수가 외부에서 볼 수 없음을 의미합니다. 그렇기 때문에 변수 이름 ( &lt;em&gt;생물체&lt;/em&gt; 및 &lt;em&gt;결과&lt;/em&gt; )을 클로저에서 반복 할 수 있지만 다른 값으로 반복 할 수 있습니다. 콘솔 창에 이러한 변수 이름을 입력하면 색조가 지정된 두 레이어로 숨겨져 있기 때문에 값을 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="76ad173357129e5535c24cd674bddfaff61e8338" translate="yes" xml:space="preserve">
          <source>CODE: All the writing above is called &lt;em&gt;code&lt;/em&gt;. It is written in JavaScript.</source>
          <target state="translated">코드 : 위의 모든 글을 &lt;em&gt;code&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . JavaScript로 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="a0c7bc52b3fa8bb1b47ad931aa67baef1da44403" translate="yes" xml:space="preserve">
          <source>Can anybody consider that I am 6 and strangely interested in that subject ?</source>
          <target state="translated">아무도 내가 6 살이고 그 주제에 이상하게 관심이 있다고 생각할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="0754a0ac49d4de7ab61d6c51b9280396aeeb0c9d" translate="yes" xml:space="preserve">
          <source>Can you explain closures to a 5-year-old?*</source>
          <target state="translated">5 살짜리의 폐쇄에 대해 설명해 주시겠습니까? *</target>
        </trans-unit>
        <trans-unit id="c6abb0edfb41f4eed3192a92b93e8777584cfbc6" translate="yes" xml:space="preserve">
          <source>Closures are &lt;em&gt;not hard&lt;/em&gt; to understand once the core concept is grokked. However, they are impossible to understand by reading any theoretical or academically oriented explanations!</source>
          <target state="translated">핵심 개념이 이해되면 클로저는 이해하기 &lt;em&gt;어렵지 않습니다&lt;/em&gt; . 그러나 이론적이거나 학문적 인 설명을 읽음으로써 이해하는 것은 불가능합니다!</target>
        </trans-unit>
        <trans-unit id="473e3864991bcdfffaa54377115d58425884b1de" translate="yes" xml:space="preserve">
          <source>Closures are a way to let a function
  have &lt;strong&gt;persistent, private variables&lt;/strong&gt; -
  that is, variables that only one
  function knows about, where it can
  keep track of info from previous times
  that it was run.</source>
          <target state="translated">클로저는 함수에 &lt;strong&gt;영구적 인 개인 변수&lt;/strong&gt; , 즉 한 함수 만 알고있는 변수를 갖도록하는 방법으로, 이전에 실행 된 시간으로부터 정보를 추적 할 수있는 위치입니다.</target>
        </trans-unit>
        <trans-unit id="2dab57988b39942ebe3792aab7459b19fb524730" translate="yes" xml:space="preserve">
          <source>Closures are functions with a state. It is somewhat similar to &quot;this&quot; in the sense that &quot;this&quot; also provides state for a function but function and &quot;this&quot; are separate objects (&quot;this&quot; is just a fancy parameter, and the only way to bind it permanently to a function is to create a closure). While &quot;this&quot; and function always live separately, a function cannot be separated from its closure and the language provides no means to access captured variables.</source>
          <target state="translated">클로저는 상태가있는 함수입니다. &quot;this&quot;는 함수에 상태를 제공하지만 함수와 &quot;this&quot;는 별도의 객체라는 점에서 &quot;this&quot;와 다소 유사합니다 ( &quot;this&quot;는 단지 멋진 매개 변수이며이를 영구적으로 바인딩하는 유일한 방법입니다). 함수는 클로저를 만드는 것입니다). &quot;this&quot;와 함수는 항상 별도로 존재하지만 함수를 클로저에서 분리 할 수 ​​없으며 언어는 캡처 된 변수에 액세스 할 수단을 제공하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9a8fe763a050a9c6f2b9d029f15de875acec4c6c" translate="yes" xml:space="preserve">
          <source>Closures are hard to explain because they are used to make some behaviour work that everybody intuitively expects to work anyway. I find the best way to explain them (and the way that &lt;em&gt;I&lt;/em&gt; learned what they do) is to imagine the situation without them:</source>
          <target state="translated">클로저는 모든 사람이 어쨌든 직관적으로 작동 할 것으로 예상되는 동작을 만드는 데 사용되기 때문에 설명하기가 어렵습니다. 나는 그것들을 설명하는 가장 좋은 방법 (그리고 그들이하는 &lt;em&gt;것을&lt;/em&gt; 배운 방법)은 그들없이 상황을 상상하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="13cd6611b47d0c0e96535f2857655ffbc4aec970" translate="yes" xml:space="preserve">
          <source>Closures are not magic</source>
          <target state="translated">폐쇄는 마법이 아니다</target>
        </trans-unit>
        <trans-unit id="81857059bb8f6b3c5d16c47af8818ad9c8d4ef06" translate="yes" xml:space="preserve">
          <source>Closures are often used for creating functions with some hidden private data (but it's not always the case).</source>
          <target state="translated">클로저는 종종 숨겨진 개인 데이터로 함수를 만드는 데 사용됩니다 (그러나 항상 그런 것은 아닙니다).</target>
        </trans-unit>
        <trans-unit id="f1f2dd80b45193a64a6fed6f703fea1610ee7907" translate="yes" xml:space="preserve">
          <source>Closures done right:</source>
          <target state="translated">마감은 올바르게 완료되었습니다.</target>
        </trans-unit>
        <trans-unit id="2b5870c633c063933016ddcafff1a5b85221b713" translate="yes" xml:space="preserve">
          <source>Closures done wrong:</source>
          <target state="translated">폐쇄가 잘못되었습니다 :</target>
        </trans-unit>
        <trans-unit id="65f3c9fe79ec9c90973a968f76051ad6208d1eff" translate="yes" xml:space="preserve">
          <source>Compare with a situation when a door was locked by draft and nobody inside (general function execution), and then some local fire occur and burn down the room (garbage collector:D), and then a new room was build and now you may leave another toys there (new function instance), but never get the same toys which were left in the first room instance.</source>
          <target state="translated">초안으로 문을 잠그고 내부에 아무도없는 일반 상황 (일반 기능 실행)과 비교 한 후 일부 지역 화재가 발생하여 방을 태우고 (쓰레기 수집기 : D) 새 방이 만들어져 이제 떠날 수 있습니다 다른 장난감 (새로운 기능 인스턴스)이 있지만 첫 번째 실 인스턴스에 남은 동일한 장난감을 얻지 마십시오.</target>
        </trans-unit>
        <trans-unit id="895fc54743a0a38a6edff320b747a9f3e67aa96b" translate="yes" xml:space="preserve">
          <source>Consider this option</source>
          <target state="translated">이 옵션을 고려하십시오</target>
        </trans-unit>
        <trans-unit id="d29543a41f8e03fb1f0ca60d30879d8d14612042" translate="yes" xml:space="preserve">
          <source>DATA: Data is a collection of facts. It can be numbers, words, measurements, observations or even just descriptions of things. You can't touch it, smell it or taste it. You can write it down, speak it and hear it. You could use it to &lt;em&gt;create&lt;/em&gt; touch smell and taste using a computer. It can be made useful by a computer using code.</source>
          <target state="translated">DATA : 데이터는 사실의 모음입니다. 숫자, 단어, 측정, 관찰 또는 사물의 설명 일 수도 있습니다. 만지거나 냄새를 맡거나 맛볼 수 없습니다. 당신은 그것을 적고 말하고들을 수 있습니다. 컴퓨터를 사용하여 터치 냄새와 맛을 &lt;em&gt;내기 위해&lt;/em&gt; 사용할 수 있습니다. 코드를 사용하여 컴퓨터에서 유용하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1386ebeed6520345b3b7b8e117496e328fb4ca5d" translate="yes" xml:space="preserve">
          <source>Dan invites Paul.
Dan asks Paul to bring one controller. How many controllers were brought to the party?</source>
          <target state="translated">댄은 폴을 초대합니다. 댄은 폴에게 컨트롤러 하나를 가져 오라고 요청합니다. 파티에 몇 명의 컨트롤러를 가져 왔습니까?</target>
        </trans-unit>
        <trans-unit id="ec2a42fc389ecb1dc4b9d0c461e02170df77d766" translate="yes" xml:space="preserve">
          <source>Douglas Crockford's simulated &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;private attributes and private methods&lt;/a&gt; for an object, using closures.</source>
          <target state="translated">클로저를 사용하여 개체에 대한 Douglas Crockford의 시뮬레이션 된 &lt;a href=&quot;http://www.crockford.com/javascript/private.html&quot;&gt;개인 속성 및 개인 메서드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f5d96dd43fe4410f4d7bee1eb9596663a115a2d" translate="yes" xml:space="preserve">
          <source>Each time &lt;code&gt;makeKitchen()&lt;/code&gt; is called, a new closure is created with its own separate &lt;code&gt;trashBags&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;makeKitchen()&lt;/code&gt; 이 호출 될 때마다 별도의 &lt;code&gt;trashBags&lt;/code&gt; 를 사용하여 새 클로저가 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="be4a4610d526a11fb6ad4a43add51b702b4757b8" translate="yes" xml:space="preserve">
          <source>Environment, which includes:</source>
          <target state="translated">환경 :</target>
        </trans-unit>
        <trans-unit id="d753a72a73e7b9b72686150b4751eec2271aff2d" translate="yes" xml:space="preserve">
          <source>Every function call creates a closure, but there would be no need to keep the closure around unless an inner function, which has access to the inside of the closure, can be called from outside the closure.  Returning the object with the &lt;code&gt;getTrashBag&lt;/code&gt; function does that here.</source>
          <target state="translated">모든 함수 호출은 클로저를 생성하지만 클로저 내부에 액세스 할 수있는 내부 함수를 클로저 외부에서 호출 할 수 없다면 클로저를 유지할 필요는 없습니다. &lt;code&gt;getTrashBag&lt;/code&gt; 함수를 사용하여 객체를 반환하면 여기서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2df597c03eb2e94c01cea766bc9c9a3fbe100af1" translate="yes" xml:space="preserve">
          <source>Every function creates a closure because every function has a link to its outer lexical environment.</source>
          <target state="translated">모든 함수에는 외부 어휘 환경에 대한 링크가 있으므로 모든 함수는 클로저를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="859b310d2eaece93608e0e89cc61e86978cb69a4" translate="yes" xml:space="preserve">
          <source>Every function in JavaScript maintains a link to its outer lexical environment. A lexical environment is a map of all the names (eg. variables, parameters) within a scope, with their values.</source>
          <target state="translated">JavaScript의 모든 함수는 외부 어휘 환경에 대한 링크를 유지합니다. 어휘 환경은 범위 내 모든 이름 (예 : 변수, 매개 변수)과 해당 값을 가진 맵입니다.</target>
        </trans-unit>
        <trans-unit id="45ace4e4578d45cf9975840a42650a40883c1e4a" translate="yes" xml:space="preserve">
          <source>Every time you call it, local variable &quot;name&quot; is created and given name &quot;Mary&quot;. And every time the function exits the variable is lost and the name is forgotten.</source>
          <target state="translated">호출 할 때마다 로컬 변수 &quot;name&quot;이 생성되고 이름은 &quot;Mary&quot;입니다. 그리고 함수가 종료 될 때마다 변수가 손실되고 이름이 잊혀집니다.</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="translated">실시 예 3</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="translated">실시 예 4</target>
        </trans-unit>
        <trans-unit id="dcb2a7f833e9a3ee29881cf3f00069ceeab20571" translate="yes" xml:space="preserve">
          <source>Example 5</source>
          <target state="translated">실시 예 5</target>
        </trans-unit>
        <trans-unit id="69126e599801a8577cf34e537a3e5b119797d966" translate="yes" xml:space="preserve">
          <source>Example 6</source>
          <target state="translated">실시 예 6</target>
        </trans-unit>
        <trans-unit id="5da743f6856f59f85c81f30e766731f5631a39c2" translate="yes" xml:space="preserve">
          <source>Example 7</source>
          <target state="translated">실시 예 7</target>
        </trans-unit>
        <trans-unit id="6f1ddb45d4ea126c3c0d9697dd3671172ae3bca1" translate="yes" xml:space="preserve">
          <source>Example for the first point by dlaliberte:</source>
          <target state="translated">dlaliberte의 첫 번째 포인트 예 :</target>
        </trans-unit>
        <trans-unit id="9726b2f5643205ff1a7ab0c75e5e5eb34bbe5072" translate="yes" xml:space="preserve">
          <source>Example of a closure that uses the global environment:</source>
          <target state="translated">글로벌 환경을 사용하는 클로저의 예 :</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="e262aa4c560f1ae35fd6e5cf5ac45462ea46ecc8" translate="yes" xml:space="preserve">
          <source>F12</source>
          <target state="translated">F12</target>
        </trans-unit>
        <trans-unit id="770cc5fbad4b752ed78f4565ed7a44533e740e5d" translate="yes" xml:space="preserve">
          <source>FOREWORD: this answer was written when the question was:</source>
          <target state="translated">서문 :이 답변은 질문이 다음과 같은 경우에 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="23ddff2ba060d9ccf1c6bed76f90cfb75043258a" translate="yes" xml:space="preserve">
          <source>FUNCTION: A function in JavaScript is like a factory. It might be a little factory with only one machine inside. Or it might contain many other little factories, each with many machines doing different jobs. In a real life clothes factory you might have reams of cloth and bobbins of thread going in and T-shirts and jeans coming out. Our JavaScript factory only processes data, it can't sew, drill a hole or melt metal. In our JavaScript factory data goes in and data comes out.</source>
          <target state="translated">기능 : JavaScript의 함수는 팩토리와 같습니다. 내부에 기계가 하나만있는 작은 공장 일 수 있습니다. 또는 여러 다른 작은 공장이있을 수 있으며 각 공장마다 다른 작업을 수행합니다. 실제 의류 공장에서는 옷감과 실 보빈이 들어가고 티셔츠와 청바지가 나올 수 있습니다. 우리의 JavaScript 팩토리는 데이터 만 처리하며, 꿰매거나 구멍을 뚫거나 금속을 녹일 수 없습니다. JavaScript 팩토리에서 데이터가 들어오고 데이터가 나옵니다.</target>
        </trans-unit>
        <trans-unit id="8084a292fef2035ee22a2314d1fd8d2ea5ef70cc" translate="yes" xml:space="preserve">
          <source>Fairly Obvious Solution</source>
          <target state="translated">상당히 명백한 해결책</target>
        </trans-unit>
        <trans-unit id="8d7ca8f60d208999584a7667dd568dbdc67e89aa" translate="yes" xml:space="preserve">
          <source>Final points:</source>
          <target state="translated">최종 포인트 :</target>
        </trans-unit>
        <trans-unit id="0db6ddf1596c4847d4487ff8d0eb1324a650d77c" translate="yes" xml:space="preserve">
          <source>First, when a function f is created, it is not created in an empty
space. There is a current LexicalEnvironment object. In the case
above, it&amp;rsquo;s window (a is undefined at the time of function
creation).</source>
          <target state="translated">먼저, 함수 f가 작성 될 때 빈 공간에 작성되지 않습니다. 현재 LexicalEnvironment 오브젝트가 있습니다. 위의 경우에는 창입니다 (a는 함수 작성시 정의되지 않음).</target>
        </trans-unit>
        <trans-unit id="2a73ef77ff6936404496b87ca2548febfdec5ccf" translate="yes" xml:space="preserve">
          <source>For an advanced child I would put something like the following. It is not perfect, but it makes you feel about what it is:</source>
          <target state="translated">상급자에게는 다음과 같은 것을 넣을 것입니다. 완벽하지는 않지만 그것이 무엇인지 느끼게합니다.</target>
        </trans-unit>
        <trans-unit id="ea9adb725d4b9bd42aa2bf3daca3985abf217214" translate="yes" xml:space="preserve">
          <source>For some reason, closures seem really hard to understand when you read about them, but when you see some examples, it becomes clear how they work (it took me a while).
I recommend working through the examples carefully until you understand how they work. If you start using closures without fully understanding how they work, you would soon create some very weird bugs!</source>
          <target state="translated">어떤 이유로, 클로저를 읽을 때 클로저를 이해하기가 정말로 어려워 보이지만 몇 가지 예를 볼 때 클로저가 어떻게 작동하는지 분명해집니다 (시간이 걸렸습니다). 작동 방식을 이해할 때까지 예제를 신중하게 검토하는 것이 좋습니다. 작동 방식을 완전히 이해하지 않고 클로저를 사용하기 시작하면 곧 매우 이상한 버그가 발생합니다!</target>
        </trans-unit>
        <trans-unit id="a6457c5f7670ec3d5b6eba35695e935bfa1d35af" translate="yes" xml:space="preserve">
          <source>Full post:</source>
          <target state="translated">전체 게시물 :</target>
        </trans-unit>
        <trans-unit id="086a1f90a0a0f91e7d5f1400d0b9f2eaa0c70efd" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;bar&lt;/code&gt;, together with its link with the lexical environment of function &lt;code&gt;foo&lt;/code&gt; is a closure.</source>
          <target state="translated">&lt;code&gt;foo&lt;/code&gt; 함수의 어휘 환경과의 링크와 함께 function &lt;code&gt;bar&lt;/code&gt; 는 클로저입니다.</target>
        </trans-unit>
        <trans-unit id="df465d5385e7a5492e6da9185d4edd6ca0741d1e" translate="yes" xml:space="preserve">
          <source>Functions can be nested one inside another, forming a chain of LexicalEnvironments which can also be called a scope chain.</source>
          <target state="translated">함수는 다른 함수 안에 중첩되어 범위 체인이라고도하는 LexicalEnvironments 체인을 형성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="735a10dcfecac98bd4863f42c020b050d39de8ff" translate="yes" xml:space="preserve">
          <source>Functions can return data. One kind of data you can return from a function is another function. When that new function gets returned, all the variables and arguments used in the function that created it don't go away. Instead, that parent function &quot;closes.&quot; In other words, nothing can look inside of it and see the variables it used except for the function it returned. That new function has a special ability to look back inside the function that created it and see the data inside of it.</source>
          <target state="translated">함수는 데이터를 반환 할 수 있습니다. 함수에서 반환 할 수있는 한 종류의 데이터는 다른 함수입니다. 새 함수가 반환되면 함수를 만든 함수에 사용 된 모든 변수와 인수가 사라지지 않습니다. 대신, 그 부모 함수는 &quot;닫힙니다.&quot; 즉, 내부를 볼 수 없으며 반환 된 함수를 제외하고 사용한 변수를 볼 수 없습니다. 이 새로운 함수에는 함수를 만든 함수 내부를 되돌아보고 그 안의 데이터를 볼 수있는 특별한 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6e834997432ff006f3ca11dc3e560bb2b2db750" translate="yes" xml:space="preserve">
          <source>Functions define actions  - the main function is about singing. It contains a variable called &lt;em&gt;firstPart&lt;/em&gt; which applies to the singing about the person that applies to each of the verses of the song: &quot;There was &quot; + person + &quot; who swallowed&quot;. If you type &lt;em&gt;firstPart&lt;/em&gt; into the console, you won't get an answer because the variable is locked up in a function - the browser can't see inside the tinted windows of the braces.</source>
          <target state="translated">함수는 동작을 정의합니다. 주요 기능은 노래에 관한 것입니다. 여기에는 노래의 각 구절에 적용되는 사람에 대한 노래에 적용되는 &lt;em&gt;firstPart&lt;/em&gt; 라는 변수가 포함되어 있습니다. &quot;&quot;+ person + &quot;was swallowed&quot; 콘솔에 &lt;em&gt;firstPart&lt;/em&gt; 를 입력하면 변수가 함수에 잠겨 있기 때문에 답을 얻지 못합니다. 브라우저는 괄호의 색조 창 내부를 볼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="3ddedd19f21650712b05b0d15a1aaf5ed1d17916" translate="yes" xml:space="preserve">
          <source>Further points that explain why closures are interesting:</source>
          <target state="translated">클로저가 흥미로운 이유를 설명하는 추가 사항 :</target>
        </trans-unit>
        <trans-unit id="09cf114b1e0fe4fe38544c7a0d90cf0e556abc15" translate="yes" xml:space="preserve">
          <source>GLOBAL VARIABLE: &lt;em&gt;person&lt;/em&gt; is a global variable, meaning that if you change its value from &quot;an old lady&quot; to &quot;a young man&quot;, the &lt;em&gt;person&lt;/em&gt; will keep being a young man until you decide to change it again and that any other function in the code can see that it's a young man. Press the</source>
          <target state="translated">GLOBAL VARIABLE : &lt;em&gt;person&lt;/em&gt; 은 전역 변수입니다. 즉, 값을 &quot;노인&quot;에서 &quot;청년&quot;으로 변경하면 해당 값을 다시 변경하고 다른 기능을 수행 할 때까지 계속 청년이됩니다. 코드는 젊은이임을 알 수 있습니다. 눌러</target>
        </trans-unit>
        <trans-unit id="25334edab2e807f8912b0462c0c1d557fdc5ebe8" translate="yes" xml:space="preserve">
          <source>Get it? So in our primary example, the count variable is contained within the closure and always available to the event handler, so it retains its state from click to click.</source>
          <target state="translated">알 겠어요? 따라서 기본 예제에서 count 변수는 클로저 내에 포함되어 있으며 항상 이벤트 핸들러에서 사용할 수 있으므로 클릭 간 상태를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="2a0bf64067ba96e19feb251aca269629de4b6291" translate="yes" xml:space="preserve">
          <source>Here is a closure:</source>
          <target state="translated">폐쇄는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bcaab99f4090d108eb398f8a65a144183fe65bee" translate="yes" xml:space="preserve">
          <source>Here is a factory that produces calculators that can add and multiply:</source>
          <target state="translated">다음은 더하고 곱할 수있는 계산기를 생산하는 공장입니다.</target>
        </trans-unit>
        <trans-unit id="26c03c6b51995ce3cc45717ecfc54ea15182bfb0" translate="yes" xml:space="preserve">
          <source>Here is how I can convert my plane story into the code.</source>
          <target state="translated">비행기 이야기를 코드로 변환하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="542541ad020f39c0dd65066d67e5d1be86126656" translate="yes" xml:space="preserve">
          <source>Here is the summary:</source>
          <target state="translated">요약은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="880f763de0c8735d3a294c36e5df6df573d7c52c" translate="yes" xml:space="preserve">
          <source>Here's one of the examples:</source>
          <target state="translated">예제 중 하나는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f5bf51aa2f2759a4b08230274e714f3e06de685" translate="yes" xml:space="preserve">
          <source>How I'd explain it to a six-year-old:</source>
          <target state="translated">6 살짜리 아이에게 설명하는 방법 :</target>
        </trans-unit>
        <trans-unit id="2e459856108a5cecf40e139f74b817f2e5e4faa0" translate="yes" xml:space="preserve">
          <source>How do JavaScript closures work</source>
          <target state="translated">JavaScript 클로저 작동 방식</target>
        </trans-unit>
        <trans-unit id="31c4f787c21a33dcc90753d93c735b54274f39d7" translate="yes" xml:space="preserve">
          <source>How would you explain JavaScript closures to someone with a knowledge of the concepts they consist of (for example functions, variables and the like), but does not understand closures themselves?</source>
          <target state="translated">함수, 변수 등으로 구성된 개념을 알고 있지만 클로저 자체를 이해하지 못하는 사람에게 JavaScript 클로저를 어떻게 설명 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="d0b12b69fd5500aab9c9d2b4a9addddfd30dacaf" translate="yes" xml:space="preserve">
          <source>However, since &lt;code&gt;tmp&lt;/code&gt; is still hanging around inside &lt;code&gt;bar&lt;/code&gt;'s closure, it is available to be incremented. It will be incremented each time you call &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;tmp&lt;/code&gt; 가 여전히 &lt;code&gt;bar&lt;/code&gt; 의 클로저 내부에 매달려 있기 때문에 증가시킬 수 있습니다. &lt;code&gt;bar&lt;/code&gt; 를 호출 할 때마다 증가 합니다 .</target>
        </trans-unit>
        <trans-unit id="be9d4d94dd6f35953099bde147c591bdd84ed51a" translate="yes" xml:space="preserve">
          <source>I have seen &lt;a href=&quot;http://en.wikipedia.org/wiki/Scheme_%28programming_language%29&quot;&gt;the Scheme example&lt;/a&gt; given on Wikipedia, but unfortunately it did not help.</source>
          <target state="translated">Wikipedia에 제공된 &lt;a href=&quot;http://en.wikipedia.org/wiki/Scheme_%28programming_language%29&quot;&gt;Scheme 예제를&lt;/a&gt; 보았지만 불행히도 도움이되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="c32c4a2db55c3bb615ab0b8d8acc3b66dadcac7d" translate="yes" xml:space="preserve">
          <source>I haven't got time to go shopping, so the function needs to know what we have in the fridge to make decisions. Each ingredient has a different cooking time and we want everything to be served hot by the robot at the same time. We need to provide the function with the data about what we like, the function could 'talk' to the fridge, and the function could control the robot.</source>
          <target state="translated">쇼핑하러 갈 시간이 없어서, 그 기능은 냉장고에있는 것들을 알아야 결정을 내릴 수 있어야합니다. 각 재료는 요리 시간이 다르므로 로봇이 모든 것을 동시에 뜨거운 음식을 원합니다. 우리는 원하는 것에 대한 데이터를 함수에 제공해야하며, 함수는 냉장고에 '말할'수 있으며, 함수는 로봇을 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f67fa89b4f0fa9a4f122d225bd2121614d8b9416" translate="yes" xml:space="preserve">
          <source>I know there are plenty of solutions already, but I guess that this small and simple script can be useful to demonstrate the concept:</source>
          <target state="translated">이미 많은 솔루션이 있다는 것을 알고 있지만이 작고 간단한 스크립트가 개념을 설명하는 데 유용 할 수 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="68c15dba4a700bb7a32cb7aad9a30cdd109d35e6" translate="yes" xml:space="preserve">
          <source>I need to know how many times a button has been clicked and do something on every third click...</source>
          <target state="translated">버튼을 몇 번 클릭했는지 알고 세 번째 클릭마다 무언가를해야합니다 ...</target>
        </trans-unit>
        <trans-unit id="1729e172673bb9af9294d6a61fc1a00e839e1311" translate="yes" xml:space="preserve">
          <source>I put together an interactive JavaScript tutorial to explain how closures work.
&lt;a href=&quot;http://nathansjslessons.appspot.com&quot;&gt;What's a Closure?&lt;/a&gt;</source>
          <target state="translated">대화식 JavaScript 자습서를 작성하여 클로저 작동 방식을 설명했습니다. &lt;a href=&quot;http://nathansjslessons.appspot.com&quot;&gt;폐쇄 란 무엇입니까?&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="123fc03a330a7c38723bf7555ca4ff7a80024826" translate="yes" xml:space="preserve">
          <source>I still think &lt;a href=&quot;http://code.google.com/apis/ajax/playground/?exp=maps#closure_simple&quot;&gt;Google's explanation&lt;/a&gt; works very well and is concise:</source>
          <target state="translated">나는 여전히 &lt;a href=&quot;http://code.google.com/apis/ajax/playground/?exp=maps#closure_simple&quot;&gt;구글의 설명&lt;/a&gt; 이 잘 작동하고 간결하다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="0b506f3eb42bcf394c48e9df2a2bec6ef476dbaa" translate="yes" xml:space="preserve">
          <source>I suspect that closures in JavaScript differ from those normally found in functional languages.</source>
          <target state="translated">JavaScript의 클로저는 기능적 언어에서 일반적으로 발견되는 것과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="24dbc47ee46dbf67b52513fbd1c704c76d217b00" translate="yes" xml:space="preserve">
          <source>I tend to learn better by GOOD/BAD comparisons. I like to see working code followed by non-working code that someone is likely to encounter. I put together &lt;a href=&quot;http://jsfiddle.net/KMQZK/&quot;&gt;a jsFiddle&lt;/a&gt; that does a comparison and tries to boil down the differences to the simplest explanations I could come up with.</source>
          <target state="translated">GOOD / BAD 비교를 통해 더 잘 배우는 경향이 있습니다. 나는 누군가가 겪을 가능성이있는 작동 코드와 작동하지 않는 코드를보고 싶다. 나는 비교를하고 내가 생각 해낼 수있는 가장 간단한 설명의 차이점을 정리하려고 &lt;a href=&quot;http://jsfiddle.net/KMQZK/&quot;&gt;하는 jsFiddle&lt;/a&gt; 을 모았습니다.</target>
        </trans-unit>
        <trans-unit id="4b2d52788d16d1aed76a99b2962dd7f9b814a6e8" translate="yes" xml:space="preserve">
          <source>I think normally a closure is a term for both the function along with a captured variable environment. Note that I do not use that definition in this article!</source>
          <target state="translated">필자는 일반적으로 클로저는 캡처 된 변수 환경과 함께 기능 모두에 대한 용어라고 생각합니다. 이 기사에서는 그 정의를 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="96ede599b6969e1b90d8c62ab4084c1f1b9581b8" translate="yes" xml:space="preserve">
          <source>I wrote a blog post a while back explaining closures. Here's what I said about closures in terms of &lt;strong&gt;why&lt;/strong&gt; you'd want one.</source>
          <target state="translated">나는 폐쇄를 설명하는 블로그 게시물을 잠시 썼다. 다음은 내가 &lt;strong&gt;왜&lt;/strong&gt; 원하는지에 대한 폐쇄에 대해 말한 것입니다.</target>
        </trans-unit>
        <trans-unit id="1f893746796fe79900cf9caf10941e2bdc53f26f" translate="yes" xml:space="preserve">
          <source>I'd simply point them to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures&quot;&gt;Mozilla Closures page&lt;/a&gt;. It's the best, most &lt;strong&gt;concise and simple explanation&lt;/strong&gt; of closure basics and practical usage that I've found. It is highly recommended to anyone learning JavaScript.</source>
          <target state="translated">간단히 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide/Closures&quot;&gt;Mozilla Closures 페이지&lt;/a&gt; 를 가리 킵니다. 내가 찾은 클로저 기본 및 실제 사용법에 &lt;strong&gt;대한&lt;/strong&gt; 가장 &lt;strong&gt;정확하고 간결하고 간단한 설명&lt;/strong&gt; 입니다. JavaScript를 배우는 모든 사람에게 적극 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="11877a1bd39d64fe0945ea5ee068c0234e433657" translate="yes" xml:space="preserve">
          <source>I'm a big fan of analogy and metaphor when explaining difficult concepts, so let me try my hand with a story.</source>
          <target state="translated">나는 어려운 개념을 설명 할 때 비유와 은유의 열렬한 팬이므로 이야기로 손을 시험해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6b990bce01318ec63bef46aec64d8b6ab67c944d" translate="yes" xml:space="preserve">
          <source>I'm pretty sure I was one of the only people that attempted to take the initial question literally. Since then, the question has mutated several times, so my answer may now seem incredibly silly &amp;amp; out of place. Hopefully the general idea of the story remains fun for some.</source>
          <target state="translated">나는 처음 질문을 문자 그대로 받아들이려고 시도한 유일한 사람들 중 하나라고 확신합니다. 그 이후로 그 질문은 여러 번 변했다. 그래서 나의 대답은 이제 매우 어리 석고 어리석은 것처럼 보일 수있다. 이 이야기의 일반적인 아이디어가 여전히 재미 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="4f6b0992401487db0a126fe9e7ad6b66cdcca276" translate="yes" xml:space="preserve">
          <source>If a function accesses its environment, then the function is a closure.</source>
          <target state="translated">함수가 환경에 액세스하면 해당 함수가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="f330a42bf372ed8fefe90c64085c3c7240fecf76" translate="yes" xml:space="preserve">
          <source>If a variable is read, but can not be found anywhere, an error is generated.</source>
          <target state="translated">변수를 읽지 만 어디에서나 찾을 수 없으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3cbc5f197b9dd09fc614b45e91092d33f7f9c144" translate="yes" xml:space="preserve">
          <source>If an inner function is returned by an outer, then the outer lexical environment will persist after the outer function has returned. This is because the outer lexical environment needs to be available if the inner function is eventually invoked.</source>
          <target state="translated">내부 함수가 외부 함수에 의해 리턴되면 외부 함수가 리턴 된 후에 외부 어휘 환경이 지속됩니다. 내부 함수가 결국 호출되면 외부 어휘 환경을 사용할 수 있어야하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="dc578583b34a4a34bae69d350c3dfa0573e54e50" translate="yes" xml:space="preserve">
          <source>If everything seems completely unclear, then the best thing to do is to play with the examples. Reading an explanation is much harder than understanding examples.
My explanations of closures and stack-frames, etc. are not technically correct &amp;mdash; they are gross simplifications intended to help to understand. Once the basic idea is grokked, you can pick up the details later.</source>
          <target state="translated">모든 것이 완전히 불분명 해 보이면 가장 좋은 방법은 예제를 가지고 노는 것입니다. 설명을 읽는 것은 예제를 이해하는 것보다 훨씬 어렵습니다. 클로저 및 스택 프레임 등에 대한 나의 설명은 기술적으로 정확하지 않습니다. 이해를 돕기 위해 크게 단순화 된 것입니다. 기본 아이디어가 정리되면 나중에 세부 정보를 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f08569e7c3d79200141ddddd7958d6b1ded5e4e" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;i&lt;/code&gt; is also defined using &lt;code&gt;let&lt;/code&gt; instead of &lt;code&gt;var&lt;/code&gt;, then the output is:</source>
          <target state="translated">변수 &lt;code&gt;i&lt;/code&gt; 가 &lt;code&gt;var&lt;/code&gt; 대신 &lt;code&gt;let&lt;/code&gt; 을 사용하여 정의 된 경우 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="460b9688bda10bbf35ef9d0c1b98952a76ebb3ed" translate="yes" xml:space="preserve">
          <source>If you are trying to do any dynamic source code modifications (for example: &lt;code&gt;myFunction = Function(myFunction.toString().replace(/Hello/,'Hola'));&lt;/code&gt;), it won't work if &lt;code&gt;myFunction&lt;/code&gt; is a closure (of course, you would never even think of doing source code string substitution at runtime, but...).</source>
          <target state="translated">동적 소스 코드 수정 (예 : &lt;code&gt;myFunction = Function(myFunction.toString().replace(/Hello/,'Hola'));&lt;/code&gt; )을 수행하려는 경우 &lt;code&gt;myFunction&lt;/code&gt; 이 클로저 인 경우 작동하지 않습니다 ( 물론 런타임에 소스 코드 문자열 대체를 생각조차하지 않지만 ...).</target>
        </trans-unit>
        <trans-unit id="f246fbc5dfee71350f8d01e881e3e75375300e1a" translate="yes" xml:space="preserve">
          <source>If you have &lt;em&gt;just&lt;/em&gt; learned closures (here or elsewhere!), then I am interested in any feedback from you about any changes you might suggest that could make this article clearer. Send an email to morrisjohns.com (morris_closure @). Please note that I am not a guru on JavaScript &amp;mdash; nor on closures.</source>
          <target state="translated">클로저 (여기 또는 다른 곳에서)를 배운 적이 있다면이 기사를 더 명확하게 해 줄 수있는 변경 사항에 대한 의견을 듣고 싶습니다. morrisjohns.com (morris_closure @)에게 이메일을 보내십시오. 저는 JavaScript 나 클로저를 좋아하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6a8ed7866e246c92cf6dd70deac29290fa039a64" translate="yes" xml:space="preserve">
          <source>Imagine - you are playing with your little brothers and sisters in the entire house, and you are moving around with your toys and brought some of them into your older brother's room. After a while your brother returned from the school and went to his room, and he locked inside it, so now you could not access toys left there anymore in a direct way. But you could knock the door and ask your brother for that toys. This is called toy's &lt;em&gt;closure&lt;/em&gt;; your brother made it up for you, and he is now into outer &lt;em&gt;scope&lt;/em&gt;.</source>
          <target state="translated">당신은 온 집안에서 남동생들과 놀면서 장난감으로 움직여서 그 중 일부를 오빠의 방으로 가져 왔다고 상상해보십시오. 잠시 후, 당신의 형제는 학교에서 돌아와서 그의 방으로갔습니다. 그리고 그는 그 안에 들어갔습니다. 그래서 이제는 더 이상 직접적인 방법으로 거기에 남아있는 장난감에 접근 할 수 없었습니다. 그러나 문을 두드리고 형에게 그 장난감을 요구할 수 있습니다. 이것을 장난감 &lt;em&gt;폐쇄&lt;/em&gt; 라고합니다. 당신의 형제가 당신을 위해 그것을 만들었고, 그는 이제 바깥 &lt;em&gt;범위에&lt;/em&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="fabf25061406e8ca355bbb62da26e81c7a773acf" translate="yes" xml:space="preserve">
          <source>Imagine that the Stack Overflow Vote-Up and Vote-Down button events are implemented as closures, voteUp_click and voteDown_click, that have access to external variables isVotedUp and isVotedDown, which are defined globally. (For simplicity's sake, I am referring to StackOverflow's Question Vote buttons, not the array of Answer Vote buttons.)</source>
          <target state="translated">Stack Overflow Vote-Up 및 Vote-Down 버튼 이벤트가 클로저, voteUp_click 및 voteDown_click으로 구현되어 외부 변수 isVotedUp 및 isVotedDown에 액세스 할 수 있으며, 이는 전 세계적으로 정의되어 있다고 상상해보십시오. (간단하게하기 위해 응답 투표 단추 배열이 아닌 StackOverflow의 질문 투표 단추를 참조하고 있습니다.)</target>
        </trans-unit>
        <trans-unit id="34fbb45dfd31d8c76706f4846facff1223ce9ab3" translate="yes" xml:space="preserve">
          <source>In C and most other common languages, &lt;em&gt;after&lt;/em&gt; a function returns, all the local variables are no longer accessible because the stack-frame is destroyed.</source>
          <target state="translated">C 및 대부분의 다른 일반 언어에서 함수가 반환 된 &lt;em&gt;후&lt;/em&gt; 스택 프레임이 손상되어 모든 로컬 변수에 더 이상 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bde892a91769451e6aae5176cd04fd8bb3c261d1" translate="yes" xml:space="preserve">
          <source>In JavaScript, if you declare a function within another function, then the local variables of the outer function can remain accessible after returning from it. This is demonstrated above, because we call the function &lt;code&gt;say2()&lt;/code&gt; after we have returned from &lt;code&gt;sayHello2()&lt;/code&gt;. Notice that the code that we call references the variable &lt;code&gt;text&lt;/code&gt;, which was a &lt;em&gt;local variable&lt;/em&gt; of the function &lt;code&gt;sayHello2()&lt;/code&gt;.</source>
          <target state="translated">JavaScript에서 다른 함수 내에 함수를 선언하면 외부 함수의 로컬 변수는 반환 된 후에도 계속 액세스 할 수 있습니다. &lt;code&gt;sayHello2()&lt;/code&gt; 에서 반환 된 후 &lt;code&gt;say2()&lt;/code&gt; 함수를 호출하기 때문에 위에서 설명했습니다. 우리가 호출하는 코드는 &lt;code&gt;sayHello2()&lt;/code&gt; 함수의 &lt;em&gt;로컬 변수&lt;/em&gt; 인 변수 &lt;code&gt;text&lt;/code&gt; 를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="66588c3a466a757d86d3ce97ab53a9423b323372" translate="yes" xml:space="preserve">
          <source>In a closure, the variables in the outer lexical environment &lt;em&gt;themselves&lt;/em&gt; are available, &lt;em&gt;not&lt;/em&gt; copies.</source>
          <target state="translated">클로저에서 외부 어휘 환경 &lt;em&gt;자체&lt;/em&gt; 의 변수는 사본이 &lt;em&gt;아닌&lt;/em&gt; 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="be9e7184ed47abdf916495732c707da00b0bef5c" translate="yes" xml:space="preserve">
          <source>In computer science, a closure is a function together with a referencing environment for the nonlocal names (free variables) of that function.</source>
          <target state="translated">컴퓨터 과학에서 클로저는 해당 함수의 로컬이 아닌 이름 (자유 변수)에 대한 참조 환경과 함께 사용되는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="7f7dd1aaa3a43450511e179ef4935d2bfcf91e9f" translate="yes" xml:space="preserve">
          <source>In that sense, they let a function act a bit like an object with private attributes.</source>
          <target state="translated">그런 의미에서 함수는 개인 속성을 가진 객체처럼 작동하도록합니다.</target>
        </trans-unit>
        <trans-unit id="0c18c47099c91026c3cd731edf3696ce2d7f9082" translate="yes" xml:space="preserve">
          <source>In the above code &lt;code&gt;createClosure(n)&lt;/code&gt; is invoked in every iteration of the loop. Note that I named the variable &lt;code&gt;n&lt;/code&gt; to highlight that it is a &lt;strong&gt;new&lt;/strong&gt; variable created in a new function scope and is not the same variable as &lt;code&gt;index&lt;/code&gt; which is bound to the outer scope.</source>
          <target state="translated">위의 코드에서 &lt;code&gt;createClosure(n)&lt;/code&gt; 은 루프의 모든 반복에서 호출됩니다. 새 함수 범위에서 만든 &lt;strong&gt;새&lt;/strong&gt; 변수이며 외부 범위에 바인딩 된 &lt;code&gt;index&lt;/code&gt; 와 같은 변수가 아님을 강조하기 위해 변수 &lt;code&gt;n&lt;/code&gt; 의 이름을 지정했습니다.</target>
        </trans-unit>
        <trans-unit id="64ccd305f21918c690c8faf2eee3f539cb44d848" translate="yes" xml:space="preserve">
          <source>In the above code the loop was moved within the &lt;code&gt;createClosureArray()&lt;/code&gt; function and the function now just returns the completed array, which at first glance seems more intuitive.</source>
          <target state="translated">위의 코드에서 루프는 &lt;code&gt;createClosureArray()&lt;/code&gt; 함수 내에서 이동했으며 함수는 이제 완성 된 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b564dadb6ceca4494d7653f8c5e95bc5a27eaf2b" translate="yes" xml:space="preserve">
          <source>In the above example, I am using the closure behavior of JavaScript. &lt;strong&gt;This behavior allows any function to have access to the scope in which it was created, indefinitely.&lt;/strong&gt; To practically apply this, I immediately invoke a function that returns another function, and because the function I'm returning has access to the internal count variable (because of the closure behavior explained above) this results in a private scope for usage by the resulting function... Not so simple? Let's dilute it down...</source>
          <target state="translated">위의 예에서는 JavaScript의 닫기 동작을 사용하고 있습니다. &lt;strong&gt;이 동작을 통해 모든 함수가 작성된 범위에 무기한으로 액세스 할 수 있습니다.&lt;/strong&gt; 실제로 이것을 적용하기 위해 즉시 다른 함수를 반환하는 함수를 호출하고 반환하는 함수가 내부 카운트 변수에 액세스 할 수 있기 때문에 (위에서 설명한 클로저 동작 때문에) 결과에 의한 사용을위한 개인 범위가됩니다. 기능 ... 그렇게 간단하지 않습니까? 희석 시키자 ...</target>
        </trans-unit>
        <trans-unit id="52291f67af5b2a395aa91f417749282ffa321ce5" translate="yes" xml:space="preserve">
          <source>In the above example, outerFunction is called which in turn calls innerFunction. Note how outerVar is available to innerFunction, evidenced by its correctly alerting the value of outerVar.</source>
          <target state="translated">위의 예제에서 outerFunction이 호출되어 innerFunction이 호출됩니다. outerVar의 값을 올바르게 경고하여 innerFunction에서 outerVar를 사용할 수있는 방법에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="9accb51a40f9456dfff0b9b647c4adc451c98ff8" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;f&lt;/code&gt; closes over the lexical environment of the global execution context:</source>
          <target state="translated">다음 예제에서 함수 &lt;code&gt;f&lt;/code&gt; 는 전역 실행 컨텍스트의 어휘 환경을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="79e7feaad903ac12e4a4780516074d3c8e273603" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;h&lt;/code&gt; closes over the lexical environment of function &lt;code&gt;g&lt;/code&gt;, which, in turn, closes over the lexical environment of the global execution context.</source>
          <target state="translated">다음 예제에서 함수 &lt;code&gt;h&lt;/code&gt; 는 함수 &lt;code&gt;g&lt;/code&gt; 의 어휘 환경을 닫고, 전역 실행 컨텍스트의 어휘 환경을 닫습니다.</target>
        </trans-unit>
        <trans-unit id="d208e23250c79929b1202ec211a36dbeb87b68f9" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;j&lt;/code&gt; closes over the lexical environment of function &lt;code&gt;i&lt;/code&gt;, meaning that variable &lt;code&gt;x&lt;/code&gt; is visible from inside function &lt;code&gt;j&lt;/code&gt;, long after function &lt;code&gt;i&lt;/code&gt; has completed execution:</source>
          <target state="translated">다음 예제에서 함수 &lt;code&gt;j&lt;/code&gt; 는 함수 &lt;code&gt;i&lt;/code&gt; 의 어휘 환경을 닫습니다. 즉 , 함수 &lt;code&gt;i&lt;/code&gt; 가 실행을 완료 한 후에도 변수 &lt;code&gt;x&lt;/code&gt; 는 함수 &lt;code&gt;j&lt;/code&gt; 내부에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a42d2846a79c733d7b14604fa1cb2c0c4772121" translate="yes" xml:space="preserve">
          <source>In the terminology of the ECMAScript specification, a closure can be said to be implemented by the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt;&lt;code&gt;[[Environment]]&lt;/code&gt;&lt;/a&gt; reference of every function-object, which points to the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;lexical environment&lt;/a&gt; within which the function is defined.</source>
          <target state="translated">ECMAScript 사양의 용어에서 클로저는 함수가 정의 된 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-lexical-environments&quot;&gt;어휘 환경&lt;/a&gt; 을 가리키는 모든 함수 객체의 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt; &lt;code&gt;[[Environment]]&lt;/code&gt; &lt;/a&gt; 참조에 의해 구현된다고 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="88a0303f59536ee17cc71dcac48a7690fb59fb0b" translate="yes" xml:space="preserve">
          <source>In this case, the interpreter finds the variable in the
outer &lt;a href=&quot;http://javascript.info/tutorial/initialization&quot;&gt;&lt;code&gt;LexicalEnvironment&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">이 경우 인터프리터는 외부 &lt;a href=&quot;http://javascript.info/tutorial/initialization&quot;&gt; &lt;code&gt;LexicalEnvironment&lt;/code&gt; &lt;/a&gt; 객체에서 변수를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="517b1409687da9d9fcb673e99fbcc8dd23f7ee52" translate="yes" xml:space="preserve">
          <source>In this final example, each call to the main function creates a separate closure.</source>
          <target state="translated">이 마지막 예에서 기본 함수를 호출 할 때마다 별도의 클로저가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="c7149ac43259f5072dae076e7d470d21214d7c4c" translate="yes" xml:space="preserve">
          <source>Inner functions like &lt;code&gt;add&lt;/code&gt; and &lt;code&gt;multiply&lt;/code&gt;, which access variables declared in an outer function&lt;sup&gt;**&lt;/sup&gt;, are called &lt;em&gt;closures&lt;/em&gt;.</source>
          <target state="translated">외부 함수 &lt;sup&gt;**에&lt;/sup&gt; 선언 된 변수에 액세스하는 &lt;code&gt;add&lt;/code&gt; 및 &lt;code&gt;multiply&lt;/code&gt; 와 같은 내부 함수를 &lt;em&gt;클로저&lt;/em&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="c535437331e2cd1ff0b52dab323b734568fde96b" translate="yes" xml:space="preserve">
          <source>It is possible to nest function declarations within function declarations within function declarations&amp;hellip;; you can get closures at more than one level.</source>
          <target state="translated">함수 선언 내에 함수 선언 내에 함수 선언을 중첩시킬 수 있습니다&amp;hellip;; 여러 레벨에서 클로저를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd8a1c5b969fb5ce6751ab00fdc753d6fe50bc42" translate="yes" xml:space="preserve">
          <source>It may be helpful to see what happens when a block-level declaration of the variable &lt;code&gt;item&lt;/code&gt; is used (via the &lt;code&gt;let&lt;/code&gt; keyword) instead of a function-scoped variable declaration via the &lt;code&gt;var&lt;/code&gt; keyword. If that change is made, then each anonymous function in the array &lt;code&gt;result&lt;/code&gt; has its own closure; when the example is run the output is as follows:</source>
          <target state="translated">&lt;code&gt;var&lt;/code&gt; 키워드를 통한 함수 범위 변수 선언 대신 &lt;code&gt;let&lt;/code&gt; 키워드를 통해 변수 &lt;code&gt;item&lt;/code&gt; 의 블록 수준 선언을 사용할 때 발생하는 상황을 확인하는 것이 도움이 될 수 있습니다. 이러한 변경이 이루어지면 배열 &lt;code&gt;result&lt;/code&gt; 의 각 익명 함수는 자체 폐쇄를 갖습니다. 예제가 실행될 때 출력은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3f6d29d5da52be16dfb12c7815fe37a9ce3fcf16" translate="yes" xml:space="preserve">
          <source>JAVASCRIPT: JavaScript is a language. Like English or French or Chinese are languages. There are lots of languages that are understood by computers and other electronic processors. For JavaScript to be understood by a computer it needs an interpreter. Imagine if a teacher who only speaks Russian comes to teach your class at school. When the teacher says &quot;все садятся&quot;, the class would not understand. But luckily you have a Russian pupil in your class who tells everyone this means &quot;everybody sit down&quot; - so you all do. The class is like a computer and the Russian pupil is the interpreter. For JavaScript the most common interpreter is called a browser.</source>
          <target state="translated">자바 : JavaScript는 언어입니다. 영어와 같이 프랑스어 나 중국어는 언어입니다. 컴퓨터 및 기타 전자 프로세서에서 이해하는 언어가 많이 있습니다. 컴퓨터가 JavaScript를 이해하려면 통역사가 필요합니다. 러시아어 만 할 줄 아는 선생님이 학교에서 수업을 가르 치러 온다고 상상해보십시오. 교사가 &quot;все садятся&quot;라고 말하면 수업이 이해되지 않을 것입니다. 그러나 운 좋게도 모든 사람에게 &quot;모든 사람이 앉는다&quot;는 말을하는 러시아 학생이 있습니다. 수업은 컴퓨터와 같고 러시아 학생은 통역사입니다. JavaScript의 경우 가장 일반적인 통역을 브라우저라고합니다.</target>
        </trans-unit>
        <trans-unit id="f15fd20b3b607a06e5de7b00b5c8829cba54783d" translate="yes" xml:space="preserve">
          <source>JavaScript closures for beginners</source>
          <target state="translated">초보자를위한 JavaScript 클로저</target>
        </trans-unit>
        <trans-unit id="a4ad1062dbb50a6179be99978ca0015111394d54" translate="yes" xml:space="preserve">
          <source>JavaScript functions can access their:</source>
          <target state="translated">JavaScript 함수는 다음에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18356dc7f56408ba6d488b26a212e8a89b8f9645" translate="yes" xml:space="preserve">
          <source>Let's imagine the next situation: a driver is sitting in a car. That car is inside a plane. Plane is in the airport. The ability of driver to access things outside his car, but inside the plane, even if that plane leaves an airport, is a closure. That's it. When you turn 27, look at the &lt;a href=&quot;https://stackoverflow.com/a/111200/1393791&quot;&gt;more detailed explanation&lt;/a&gt; or at the example below.</source>
          <target state="translated">다음 상황을 상상해 봅시다 : 운전자가 차에 앉아 있습니다. 그 차는 비행기 안에 있습니다. 비행기가 공항에 있습니다. 운전자가 자동차 외부의 물건에 접근 할 수 있지만 비행기 내부가 공항을 떠나더라도 비행기 내부에서는 접근 할 수 없습니다. 그게 다야. 27 세가되면 &lt;a href=&quot;https://stackoverflow.com/a/111200/1393791&quot;&gt;더 자세한 설명&lt;/a&gt; 이나 아래 예를보십시오.</target>
        </trans-unit>
        <trans-unit id="09b200c5ade4b1cb4a297a00afe3d45be8c9d80e" translate="yes" xml:space="preserve">
          <source>Like the old Albert said : &quot;If you can't explain it to a six-year old, you really don't understand it yourself.&amp;rdquo;. Well I tried to explain JS closures to a 27 years old friend and completely failed.</source>
          <target state="translated">알버트가 말한 것처럼 &quot;만약 당신이 6 살짜리 아이에게 설명 할 수 없다면, 당신은 그것을 스스로 이해하지 못합니다.&quot;27 세의 친구에게 JS 폐쇄를 설명하려고했지만 완전히 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="f4346c3dbf21e346a2dead6609d901d087e13650" translate="yes" xml:space="preserve">
          <source>Locals (that is, their local variables and local functions)</source>
          <target state="translated">지역 (즉, 지역 변수 및 지역 기능)</target>
        </trans-unit>
        <trans-unit id="2b0aed7bf52a8c5e0e0cefef3f3b339f8c820a34" translate="yes" xml:space="preserve">
          <source>Looking at the output of &lt;code&gt;say2.toString()&lt;/code&gt;, we can see that the code refers to the variable &lt;code&gt;text&lt;/code&gt;. The anonymous function can reference &lt;code&gt;text&lt;/code&gt; which holds the value &lt;code&gt;'Hello Bob'&lt;/code&gt; because the local variables of &lt;code&gt;sayHello2()&lt;/code&gt; have been secretly kept alive in a closure.</source>
          <target state="translated">&lt;code&gt;say2.toString()&lt;/code&gt; 의 출력을 보면 코드가 변수 &lt;code&gt;text&lt;/code&gt; 를 참조 함을 알 수 있습니다. 익명 함수는 &lt;code&gt;sayHello2()&lt;/code&gt; 의 로컬 변수가 비밀리에 폐쇄 상태로 유지 되었기 때문에 값이 &lt;code&gt;'Hello Bob'&lt;/code&gt; 인 &lt;code&gt;text&lt;/code&gt; 를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5628f8a6b5fea1b9beca93e689568ae4c8efb6d1" translate="yes" xml:space="preserve">
          <source>Marking up LexicalEnvironments:</source>
          <target state="translated">Lexical 환경 마크 업 :</target>
        </trans-unit>
        <trans-unit id="383f0e0e882a4dc2683b66372e6aa52e3a75f04b" translate="yes" xml:space="preserve">
          <source>More examples</source>
          <target state="translated">더 많은 예</target>
        </trans-unit>
        <trans-unit id="6f01bda547a9bb9e65d7ba349d7f92d2d69752b9" translate="yes" xml:space="preserve">
          <source>Most JavaScript programmers will understand how a reference to a function is returned to a variable (&lt;code&gt;say2&lt;/code&gt;) in the above code. If you don't, then you need to look at that before you can learn closures. A programmer using C would think of the function as returning a pointer to a function, and that the variables &lt;code&gt;say&lt;/code&gt; and &lt;code&gt;say2&lt;/code&gt; were each a pointer to a function.</source>
          <target state="translated">대부분의 JavaScript 프로그래머는 함수에 대한 참조가 위의 코드에서 변수 ( &lt;code&gt;say2&lt;/code&gt; )로 리턴되는 방법을 이해합니다. 그렇지 않은 경우 클로저를 배우기 전에 먼저 살펴 봐야합니다. C를 사용하는 프로그래머는 함수를 함수에 대한 포인터를 반환하는 것으로 생각하고 변수 &lt;code&gt;say&lt;/code&gt; 와 &lt;code&gt;say2&lt;/code&gt; 는 각각 함수에 대한 포인터 라고 생각 합니다.</target>
        </trans-unit>
        <trans-unit id="fd66b2800310560a1ce2ba5a794b44747c843f0e" translate="yes" xml:space="preserve">
          <source>NAME: You can call a function just about whatever word you want. The example &quot;cookMeal&quot; is typical in joining two words together and giving the second one a capital letter at the beginning - but this is not necessary. It can't have a space in it, and it can't be a number on its own.</source>
          <target state="translated">NAME : 원하는 단어에 관계없이 함수를 호출 할 수 있습니다. 예를 들어 &quot;cookMeal&quot;은 두 단어를 함께 연결하고 두 번째 단어를 처음에 대문자로 표시하는 데 일반적입니다. 그러나 이것은 필요하지 않습니다. 그 안에 공백을 넣을 수 없으며 그 자체로는 숫자가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="40c3e770c196ccb030cf74232292c69eb60717a3" translate="yes" xml:space="preserve">
          <source>Note that in the above example, if you call &lt;code&gt;setupSomeGlobals()&lt;/code&gt; again, then a new closure (stack-frame!) is created. The old &lt;code&gt;gLogNumber&lt;/code&gt;, &lt;code&gt;gIncreaseNumber&lt;/code&gt;, &lt;code&gt;gSetNumber&lt;/code&gt; variables are overwritten with &lt;em&gt;new&lt;/em&gt; functions that have the new closure. (In JavaScript, whenever you declare a function inside another function, the inside function(s) is/are recreated again &lt;em&gt;each&lt;/em&gt; time the outside function is called.)</source>
          <target state="translated">위의 예에서 &lt;code&gt;setupSomeGlobals()&lt;/code&gt; 다시 호출하면 새 클로저 (스택 프레임!)가 생성됩니다. 이전 &lt;code&gt;gLogNumber&lt;/code&gt; , &lt;code&gt;gIncreaseNumber&lt;/code&gt; , &lt;code&gt;gSetNumber&lt;/code&gt; 변수는 새로운 클로저가있는 새로운 함수로 덮어 씁니다. JavaScript에서 다른 함수 내에 함수를 선언 할 때마다 외부 함수가 호출 될 때마다 내부 함수가 다시 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7dc2f9bd9efd8d1e52cbf8c35413ba1f4105f5a9" translate="yes" xml:space="preserve">
          <source>Note that outer functions are not required, though they do offer benefits I don't discuss here. By accessing data in its environment, a closure keeps that data alive. In the subcase of outer/inner functions, an outer function can create local data and eventually exit, and yet, if any inner function(s) survive after the outer function exits, then the inner function(s) keep the outer function's local data alive.</source>
          <target state="translated">외부 기능은 필요하지 않지만 여기서는 설명하지 않는 이점을 제공합니다. 클로저는 해당 환경의 데이터에 액세스하여 해당 데이터를 유지합니다. 외부 / 내부 함수의 하위 사례에서 외부 함수는 로컬 데이터를 생성하고 결국 종료 할 수 있지만 외부 함수가 종료 된 후에 내부 함수가 남아 있으면 내부 함수는 외부 함수의 로컬 데이터를 유지합니다 살아 있는.</target>
        </trans-unit>
        <trans-unit id="4b7d6be3be4533ef766e4ba6b6589adcce7bd0a0" translate="yes" xml:space="preserve">
          <source>Note that variables &lt;em&gt;themselves&lt;/em&gt; are visible from within a closure, &lt;em&gt;not&lt;/em&gt; copies.</source>
          <target state="translated">변수 &lt;em&gt;자체&lt;/em&gt; 는 복사본이 &lt;em&gt;아닌&lt;/em&gt; 클로저 내에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dccaff8b91f1ebe851d8b10d10b8abb4daae146" translate="yes" xml:space="preserve">
          <source>Note that when you run the example, &lt;code&gt;&quot;item2 undefined&quot;&lt;/code&gt; is logged three times! This is because just like previous examples, there is only one closure for the local variables for &lt;code&gt;buildList&lt;/code&gt; (which are &lt;code&gt;result&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;item&lt;/code&gt;). When the anonymous functions are called on the line &lt;code&gt;fnlist[j]()&lt;/code&gt;; they all use the same single closure, and they use the current value for &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;item&lt;/code&gt; within that one closure (where &lt;code&gt;i&lt;/code&gt; has a value of &lt;code&gt;3&lt;/code&gt; because the loop had completed, and &lt;code&gt;item&lt;/code&gt; has a value of &lt;code&gt;'item2'&lt;/code&gt;). Note we are indexing from 0 hence &lt;code&gt;item&lt;/code&gt; has a value of &lt;code&gt;item2&lt;/code&gt;. And the i++ will increment &lt;code&gt;i&lt;/code&gt; to the value &lt;code&gt;3&lt;/code&gt;.</source>
          <target state="translated">예제를 실행하면 &lt;code&gt;&quot;item2 undefined&quot;&lt;/code&gt; 가 세 번 기록됩니다! 이는 이전 예제와 마찬가지로 &lt;code&gt;buildList&lt;/code&gt; 의 로컬 변수 ( &lt;code&gt;result&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;list&lt;/code&gt; 및 &lt;code&gt;item&lt;/code&gt; )에 대한 클로저가 하나뿐이기 때문입니다. 익명 함수가 라인에서 호출 될 때 &lt;code&gt;fnlist[j]()&lt;/code&gt; ; 그들은 모두 동일한 단일 클로저를 사용하고, &lt;code&gt;i&lt;/code&gt; 와 그 하나의 클로저 내 &lt;code&gt;item&lt;/code&gt; 의 현재 값을 사용합니다 (여기서 루프가 완료 되었기 때문에 &lt;code&gt;i&lt;/code&gt; 의 값은 &lt;code&gt;3&lt;/code&gt; 이고 &lt;code&gt;item&lt;/code&gt; 의 값은 &lt;code&gt;'item2'&lt;/code&gt; ). 우리는 0에서 색인을 생성하므로 &lt;code&gt;item&lt;/code&gt; 의 값은 &lt;code&gt;item2&lt;/code&gt; 입니다. 그리고 i ++는 &lt;code&gt;i&lt;/code&gt; 를 값 &lt;code&gt;3&lt;/code&gt; 으로 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="2632a4becd02c75c95693519f5cf180b44a90456" translate="yes" xml:space="preserve">
          <source>Notice a few things here.</source>
          <target state="translated">여기 몇 가지를 주목하십시오.</target>
        </trans-unit>
        <trans-unit id="3393c390f2f8f559d4a2a520da1ec907eaeea621" translate="yes" xml:space="preserve">
          <source>Now consider the following:</source>
          <target state="translated">이제 다음을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8495e70502d881bdf9b4145e67ce317efd57faac" translate="yes" xml:space="preserve">
          <source>Now this will work, but it does encroach into the outer scope by adding a variable, whose sole purpose is to keep track of the count. In some situations, this would be preferable as your outer application might need access to this information. But in this case, we are only changing every third click's behavior, so it is preferable to &lt;strong&gt;enclose this functionality inside the event handler&lt;/strong&gt;.</source>
          <target state="translated">이제는 작동하지만 카운트를 추적하는 유일한 목적을 가진 변수를 추가하여 외부 범위로 침입합니다. 경우에 따라 외부 응용 프로그램에서이 정보에 액세스해야 할 수도 있으므로이 방법이 더 좋습니다. 그러나이 경우에는 세 번째 클릭의 행동 만 변경 &lt;strong&gt;하므로이 기능을 이벤트 핸들러 안에 포함하는&lt;/strong&gt; 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="edc821fed74b8a83207ffcc4a681c6656cb0dbd9" translate="yes" xml:space="preserve">
          <source>Now what it &lt;em&gt;allows&lt;/em&gt; you to do can be more spectacular, see other answers.</source>
          <target state="translated">이제 당신이 할 수있는 일은 더 장관이 될 수 있습니다. 다른 답변을보십시오.</target>
        </trans-unit>
        <trans-unit id="37b00465e1d26162d39a6df745e20f2e4e1c3722" translate="yes" xml:space="preserve">
          <source>Now, after the function &lt;em&gt;sing()&lt;/em&gt;, near the end of the code is the line</source>
          <target state="translated">이제 &lt;em&gt;sing ()&lt;/em&gt; 함수 다음에 코드 끝 근처에 줄이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b6292f13ea61f03e46a26b717197499baebf90b" translate="yes" xml:space="preserve">
          <source>Now, where's the definition of &lt;code&gt;x&lt;/code&gt;? We didn't define it in the current scope. The only solution is to let &lt;code&gt;plus5&lt;/code&gt;&lt;em&gt;carry&lt;/em&gt; its scope (or rather, its parent's scope) around. This way, &lt;code&gt;x&lt;/code&gt; is well-defined and it is bound to the value 5.</source>
          <target state="translated">이제 &lt;code&gt;x&lt;/code&gt; 의 정의는 어디에 있습니까? 현재 범위에서 정의하지 않았습니다. 유일한 해결책은 &lt;code&gt;plus5&lt;/code&gt; 가 범위 (또는 부모의 범위)를 &lt;em&gt;옮기는&lt;/em&gt; 것입니다. 이런 식으로 &lt;code&gt;x&lt;/code&gt; 는 잘 정의되어 있으며 값 5에 바인딩됩니다.</target>
        </trans-unit>
        <trans-unit id="9e15ed596afd3bc19fd5d61a060bb2a47cddef9b" translate="yes" xml:space="preserve">
          <source>OK, 6-year-old closures fan. Do you want to hear the simplest example of closure?</source>
          <target state="translated">좋아, 6 살짜리 클로저 팬. 가장 간단한 폐쇄 예를 듣고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="d722330a80b9bc2dfce4ab9f7b615cda1f5e4764" translate="yes" xml:space="preserve">
          <source>Okay, talking with a 6-year old child, I would possibly use following associations.</source>
          <target state="translated">6 살짜리 아이와 이야기를 나누면 다음과 같은 협회를 이용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="148abbffcf1d27e45f3fc36604ef1e94841e9e4b" translate="yes" xml:space="preserve">
          <source>On  &lt;a href=&quot;http://www.howkidsdevelop.com/5-7years.html&quot;&gt;Childhood Development: 5 to 7 Years &lt;/a&gt; it says:</source>
          <target state="translated">&lt;a href=&quot;http://www.howkidsdevelop.com/5-7years.html&quot;&gt;아동기 개발 : 5 ~ 7 년&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="34b3df084cbf5c7a669b26ff1aacf3c99a1d1dc8" translate="yes" xml:space="preserve">
          <source>Original post by Morris can be found in the &lt;a href=&quot;http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies&quot;&gt;Internet Archive&lt;/a&gt;.</source>
          <target state="translated">Morris의 원본 게시물은 &lt;a href=&quot;http://web.archive.org/web/20080209105120/http:/blog.morrisjohns.com/javascript_closures_for_dummies&quot;&gt;인터넷 아카이브&lt;/a&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="681216b5a1437efa0ee50e426313a7fe8126153e" translate="yes" xml:space="preserve">
          <source>Our code begins with the word &lt;em&gt;function&lt;/em&gt;, so we know that it is one! Then the name of the function &lt;em&gt;sing&lt;/em&gt; - that's my own description of what the function is about. Then parentheses &lt;em&gt;()&lt;/em&gt;. The parentheses are always there for a function. Sometimes they are empty, and sometimes they have something in. This one has a word in: &lt;code&gt;(person)&lt;/code&gt;. After this there is a brace like this &lt;code&gt;{&lt;/code&gt; . This marks the start of the function &lt;em&gt;sing()&lt;/em&gt;. It has a partner which marks the end of &lt;em&gt;sing()&lt;/em&gt; like this &lt;code&gt;}&lt;/code&gt;</source>
          <target state="translated">우리 코드는 &lt;em&gt;function&lt;/em&gt; 이라는 단어로 시작하므로 그것이 하나라는 것을 알고 있습니다! 그런 다음 함수의 이름은 &lt;em&gt;노래입니다&lt;/em&gt; -그것은 함수에 관한 나의 설명입니다. 그런 다음 괄호 &lt;em&gt;()&lt;/em&gt; . 괄호는 항상 함수를 위해 존재합니다. 때때로 그들은 비어 있고 때로는 무언가를 가지고 있습니다. 이것은 &lt;code&gt;(person)&lt;/code&gt; 이라는 단어를 가지고 있습니다. 이 후 &lt;code&gt;{&lt;/code&gt; 와 같은 중괄호가 있습니다. 이것은 &lt;em&gt;sing ()&lt;/em&gt; 함수의 시작을 나타냅니다. 여기에 &lt;em&gt;sing ()&lt;/em&gt; 의 끝을 표시하는 파트너가 있습니다. &lt;code&gt;}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="05c242ba6271e12b61564339fb6644d07e822a54" translate="yes" xml:space="preserve">
          <source>PARENTHESES: &quot;Parentheses&quot; or &lt;code&gt;()&lt;/code&gt; are the letter box on the JavaScript function factory's door or a post box in the street for sending packets of information to the factory. Sometimes the postbox might be marked &lt;em&gt;for example&lt;/em&gt;&lt;code&gt;cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime)&lt;/code&gt;, in which case you know what data you have to give it.</source>
          <target state="translated">부모 : &quot;Parentheses&quot;또는 &lt;code&gt;()&lt;/code&gt; 는 JavaScript 기능 팩토리 도어의 레터 박스 또는 거리에있는 정보 박스로 팩토리에 정보 패킷을 보내기위한 것입니다. 때때로 우편함이 &lt;code&gt;cookMeal(you, me, yourFriend, myFriend, fridge, dinnerTime)&lt;/code&gt; 과 같이 표시 될 수 있으며,이 경우 어떤 데이터를 제공해야하는지 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9144b2a7d95b704078de888cf37d60fe67becfb9" translate="yes" xml:space="preserve">
          <source>Perhaps a little beyond all but the most precocious of six-year-olds, but a few examples that helped make the concept of closure in JavaScript click for me.</source>
          <target state="translated">아마도 가장 조잡한 6 살짜리 아이들을 약간 넘어서지 만 JavaScript에서 폐쇄라는 개념을 만드는 데 도움이 된 몇 가지 예가 나를 위해 클릭합니다.</target>
        </trans-unit>
        <trans-unit id="5faa59d4bc3756040b8ce9e673c09f929e6ee9ba" translate="yes" xml:space="preserve">
          <source>Result</source>
          <target state="translated">Result</target>
        </trans-unit>
        <trans-unit id="bcd4102717d8891f8d496a43ec74da14fa94f69e" translate="yes" xml:space="preserve">
          <source>Returning a &lt;code&gt;function&lt;/code&gt; from inside another function is the classic example of a closure, because the state inside the outer function is implicitly available to the returned inner function, even after the outer function has completed execution. This has a number of use-cases, including simulating private variables.</source>
          <target state="translated">외부 함수 내부에서 상태를 암시 적으로 사용할 수 있기 때문에 외부 함수 내부에서 &lt;code&gt;function&lt;/code&gt; 를 반환하는 것이 클로저의 전형적인 예입니다. 여기에는 개인 변수 시뮬레이션을 포함하여 많은 유스 케이스가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ada6589cf526d0c74d239a16a5730f12743a8388" translate="yes" xml:space="preserve">
          <source>Second, when a closure is created, it retains a reference to all of its enclosing function&amp;rsquo;s variables and functions; it doesn&amp;rsquo;t get to pick and choose. And but so, closures should be used sparingly, or at least carefully, as they can be memory intensive; a lot of variables can be kept in memory long after a containing function has finished executing.</source>
          <target state="translated">둘째, 클로저가 만들어 질 때 모든 클로저 함수의 변수와 함수에 대한 참조를 유지합니다. 선택하고 선택할 수 없습니다. 그러나 클로저는 메모리를 많이 사용할 수 있으므로 드물게 또는 적어도주의해서 사용해야합니다. 포함 함수가 실행 된 후에도 많은 변수를 메모리에 보관할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67fe596a436afe4d7599b96bf46b1977ec2e0ef6" translate="yes" xml:space="preserve">
          <source>She lived in a wonderful world full of adventures. She met her Prince Charming, rode around her world on a unicorn, battled dragons, encountered talking animals, and many other fantastical things.</source>
          <target state="translated">그녀는 모험으로 가득 찬 멋진 세상에서 살았습니다. 그녀는 그녀의 왕자님을 만났고, 유니콘을 타고 전 세계를 탔으며, 용과 싸우고, 동물 이야기와 다른 환상적인 것들을 만났습니다.</target>
        </trans-unit>
        <trans-unit id="07573b573651a019027237d961cc61054b6bec94" translate="yes" xml:space="preserve">
          <source>Since &lt;strong&gt;scope-defining construction in JavaScript is a function&lt;/strong&gt;, not a code block like in many other languages, &lt;strong&gt;what we usually mean by &lt;em&gt;closure&lt;/em&gt; in JavaScript&lt;/strong&gt; is a &lt;strong&gt;function working with nonlocal variables defined in already executed surrounding function&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;JavaScript에서 범위 정의 구성은&lt;/strong&gt; 다른 많은 언어에서와 같이 코드 블록이 아닌 &lt;strong&gt;함수&lt;/strong&gt; 이기 때문에 &lt;strong&gt;JavaScript&lt;/strong&gt; 에서 &lt;strong&gt;&lt;em&gt;클로저&lt;/em&gt; 는 일반적으로&lt;/strong&gt; &lt;strong&gt;이미 실행 된 주변 함수에 정의 된 비 로컬 변수로 작업하는 함수&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e95fed48c1d8fabe097fc454c7b9211faa3636be" translate="yes" xml:space="preserve">
          <source>So this function might have something to do with singing, and might need some data about a person. It has instructions inside to do something with that data.</source>
          <target state="translated">따라서이 기능은 노래와 관련이있을 수 있으며 사람에 대한 데이터가 필요할 수 있습니다. 내부에는 해당 데이터로 무언가를 수행하기위한 지침이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a50b97914eb409961a9c50a5aaf62d55c22e4149" translate="yes" xml:space="preserve">
          <source>So to live, the child has to leave before it's too late</source>
          <target state="translated">그래서 살려면 아이가 너무 늦기 전에 떠나야합니다</target>
        </trans-unit>
        <trans-unit id="a2d88110733edd016cbeae6a733e1b0d67a3f3ba" translate="yes" xml:space="preserve">
          <source>So what are these closure thingys?</source>
          <target state="translated">이 폐쇄 물건은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="454c8a36400b7eb57a810440ce57394bfb5816b7" translate="yes" xml:space="preserve">
          <source>So, as long as we are in the parent -function, it can create one or more child functions which do share the secret variables from the secret place.</source>
          <target state="translated">따라서 부모 함수에있는 한 비밀 장소에서 비밀 변수를 공유하는 하나 이상의 자식 함수를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a89e976c7abc12da557c349bfa0ca485f347c7a" translate="yes" xml:space="preserve">
          <source>So, function g has access to g, a and f.</source>
          <target state="translated">따라서 함수 g는 g, a 및 f에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9cca5aab093ddbfc4f01dcf36fc37ee09f0ff12" translate="yes" xml:space="preserve">
          <source>So, if you call the child &quot;Alice&quot;, she will respond</source>
          <target state="translated">따라서 자녀를 &quot;Alice&quot;라고 부르면 응답합니다.</target>
        </trans-unit>
        <trans-unit id="dbc77889f79e6ba70a51ccdd7b1d469ad3fe2209" translate="yes" xml:space="preserve">
          <source>So, whenever you see the &lt;code&gt;function&lt;/code&gt; keyword, code inside that function has access to variables declared outside the function.</source>
          <target state="translated">따라서 &lt;code&gt;function&lt;/code&gt; 키워드가 표시 될 때마다 해당 함수 내부의 코드는 함수 외부에서 선언 된 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="32a5b0910ff15915067cd48d69073b7ed24d5e07" translate="yes" xml:space="preserve">
          <source>Submitted by Morris on Tue, 2006-02-21 10:19.  Community-edited since.</source>
          <target state="translated">투고자 : 2006-02-21 10:19 이후 커뮤니티 편집.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="9025c4cc6a8af6eb5f548366877eea00d17ba2f8" translate="yes" xml:space="preserve">
          <source>Taking the question seriously, we should find out what a typical 6-year-old is capable of cognitively, though admittedly, one who is interested in JavaScript is not so typical.</source>
          <target state="translated">질문을 진지하게 받아들이면, 전형적인 6 살짜리가인지 적으로인지 할 수있는 것이 무엇인지 알아 내야하지만, JavaScript에 관심이있는 사람은 그렇게 일반적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67cecda122884bfa553becae4c5685cfae2cbb5f" translate="yes" xml:space="preserve">
          <source>Technically, in &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt;, &lt;strong&gt;every function is a closure&lt;/strong&gt;. It always has an access to variables defined in the surrounding scope.</source>
          <target state="translated">기술적으로 &lt;a href=&quot;http://en.wikipedia.org/wiki/JavaScript&quot;&gt;JavaScript&lt;/a&gt; 에서 &lt;strong&gt;모든 함수는 클로저&lt;/strong&gt; 입니다. 항상 주변 범위에 정의 된 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97cba4858411c435e526dd651157aac20178222c" translate="yes" xml:space="preserve">
          <source>Thanks</source>
          <target state="translated">Thanks</target>
        </trans-unit>
        <trans-unit id="30a5f96f9b652a33887df9866bf824d883055acd" translate="yes" xml:space="preserve">
          <source>That's all there is to tell.</source>
          <target state="translated">그게 다야.</target>
        </trans-unit>
        <trans-unit id="ab6ae4b470ffe5a3279c44a289c97ea3536b0044" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;trashBags&lt;/code&gt; variable is local to the inside of each kitchen and is not accessible outside, but the inner function on the &lt;code&gt;getTrashBag&lt;/code&gt; property does have access to it.</source>
          <target state="translated">&lt;code&gt;trashBags&lt;/code&gt; 변수는 각 부엌의 내부에 있으며 외부에서는 액세스 할 수 없지만 &lt;code&gt;getTrashBag&lt;/code&gt; 특성의 내부 함수는 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4b0fe233c7b64030a0dc17c446f53a7aea9634c" translate="yes" xml:space="preserve">
          <source>The Straw Man</source>
          <target state="translated">밀짚 맨</target>
        </trans-unit>
        <trans-unit id="2ac247e683af2d84a6d9660b577f04e07e7d50da" translate="yes" xml:space="preserve">
          <source>The above code has a closure because the anonymous function &lt;code&gt;function() { console.log(text); }&lt;/code&gt; is declared &lt;em&gt;inside&lt;/em&gt; another function, &lt;code&gt;sayHello2()&lt;/code&gt; in this example. In JavaScript, if you use the &lt;code&gt;function&lt;/code&gt; keyword inside another function, you are creating a closure.</source>
          <target state="translated">익명 함수 &lt;code&gt;function() { console.log(text); }&lt;/code&gt; } 는이 예제에서 다른 함수 &lt;code&gt;sayHello2()&lt;/code&gt; &lt;em&gt;안에&lt;/em&gt; 선언 &lt;em&gt;되어&lt;/em&gt; 있습니다. JavaScript에서 다른 함수 안에 &lt;code&gt;function&lt;/code&gt; 키워드를 사용하면 클로저가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7604834deb6d4981f78e51cc66d18c9e17faae70" translate="yes" xml:space="preserve">
          <source>The above function will also log 16, because the code inside &lt;code&gt;bar&lt;/code&gt; can still refer to argument &lt;code&gt;x&lt;/code&gt; and variable &lt;code&gt;tmp&lt;/code&gt;, even though they are no longer directly in scope.</source>
          <target state="translated">위의 함수는 16을 기록합니다. &lt;code&gt;bar&lt;/code&gt; 내부의 코드는 더 이상 직접 범위 내에 있지 않더라도 인수 &lt;code&gt;x&lt;/code&gt; 및 변수 &lt;code&gt;tmp&lt;/code&gt; 를 여전히 참조 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="246fdc56b891ef8cd6ddc925b1d907069e7fc98a" translate="yes" xml:space="preserve">
          <source>The author of &lt;em&gt;&lt;a href=&quot;http://javascript.info/tutorial/closures&quot;&gt;Closures&lt;/a&gt;&lt;/em&gt; has explained closures pretty well, explaining the reason why we need them and also explaining LexicalEnvironment which is necessary to understanding closures.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://javascript.info/tutorial/closures&quot;&gt;Closures&lt;/a&gt;&lt;/em&gt; 의 저자는 &lt;em&gt;클로저&lt;/em&gt; 를 꽤 잘 설명했으며, 클로저가 필요한 이유를 설명하고 클로저를 이해하는 데 필요한 LexicalEnvironment도 설명했습니다.</target>
        </trans-unit>
        <trans-unit id="c13d0c83e1140ef05df23d7d967fd539e97fac2a" translate="yes" xml:space="preserve">
          <source>The browser keeps the LexicalEnvironment and all its properties (variables) in memory until there is an inner function which references it.</source>
          <target state="translated">브라우저는이를 참조하는 내부 함수가있을 때까지 LexicalEnvironment 및 모든 특성 (변수)을 메모리에 유지합니다.</target>
        </trans-unit>
        <trans-unit id="ebab32e0d02219305bce1886d9e8f64ed8614c91" translate="yes" xml:space="preserve">
          <source>The chain of lexical environments, linked between execution contexts via outer environment references, forms a &lt;em&gt;scope chain&lt;/em&gt; and defines the identifiers visible from any given function.</source>
          <target state="translated">외부 환경 참조를 통해 실행 컨텍스트간에 연결된 어휘 환경 체인은 &lt;em&gt;범위 체인을&lt;/em&gt; 형성하고 지정된 함수에서 볼 수있는 식별자를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1f0b658a23c022351d31c0bee4a00408b17ba821" translate="yes" xml:space="preserve">
          <source>The children will always remember the secrets they have shared with their parents, even after their parents are
  gone. This is what closures are for functions.</source>
          <target state="translated">아이들은 부모가 떠난 후에도 부모와 공유 한 비밀을 항상 기억합니다. 이것이 함수에 대한 클로저입니다.</target>
        </trans-unit>
        <trans-unit id="d142ef727404c57948941e5ea1a82a1476684d84" translate="yes" xml:space="preserve">
          <source>The closures all know what the &lt;em&gt;sing()&lt;/em&gt; function's variable called &lt;em&gt;firstPart&lt;/em&gt; is, because they can see out from their tinted windows.</source>
          <target state="translated">클로저는 틴트 창에서 볼 수 있기 때문에 &lt;em&gt;firstPart&lt;/em&gt; 라는 &lt;em&gt;sing ()&lt;/em&gt; 함수의 변수가 무엇인지 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb0d2327de1953161942f2ab9fa838498aa1dbcb" translate="yes" xml:space="preserve">
          <source>The example above is using an anonymous function, which was executed once. But it does not have to be. It can be named (e.g. &lt;code&gt;mkdb&lt;/code&gt;) and executed later, generating a database function each time it is invoked. Every generated function will have its own hidden database object. Another usage example of closures is when we don't return a function, but an object containing multiple functions for different purposes, each of those function having access to the same data.</source>
          <target state="translated">위의 예는 한 번 실행 된 익명 함수를 사용하고 있습니다. 그러나 반드시 그럴 필요는 없습니다. &lt;code&gt;mkdb&lt;/code&gt; 와 같이 이름을 지정하고 나중에 실행될 수 있으며 호출 될 때마다 데이터베이스 함수를 생성합니다. 생성 된 모든 함수에는 고유 한 숨겨진 데이터베이스 개체가 있습니다. 클로저의 또 다른 사용 예는 함수를 반환하지 않고 서로 다른 목적을 위해 여러 함수를 포함하는 객체로 각 함수가 동일한 데이터에 액세스하는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="d752ad30dcb07b4bf12c76bcaf1fd95663e1c173" translate="yes" xml:space="preserve">
          <source>The following code returns a reference to a function:</source>
          <target state="translated">다음 코드는 함수에 대한 참조를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5215171b8fbe41f294967978f22f5060d88ee251" translate="yes" xml:space="preserve">
          <source>The following simple example covers all the main points of JavaScript closures.&lt;sup&gt;*&lt;/sup&gt;</source>
          <target state="translated">다음 간단한 예제는 JavaScript 클로저의 모든 주요 요점을 다룹니다. &lt;sup&gt;*&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="ad531efca548a3919fa24597ab10762db1c48acd" translate="yes" xml:space="preserve">
          <source>The genius is that in JavaScript a function reference also has a secret reference to the closure it was created in &amp;mdash; similar to how delegates are a method pointer plus a secret reference to an object.</source>
          <target state="translated">천재는 JavaScript에서 함수 참조는 또한 델리게이트가 메소드 포인터와 객체에 대한 비밀 참조와 비슷한 방식으로 작성된 클로저에 대한 비밀 참조를 가지고 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="45e0685cacab3e797413836c0a3b3870f011cdba" translate="yes" xml:space="preserve">
          <source>The inner function keeps a reference to the outer
LexicalEnvironment.</source>
          <target state="translated">내부 함수는 외부 LexicalEnvironment에 대한 참조를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="1222b712516a600e2c63dde997d35b726a9bade9" translate="yes" xml:space="preserve">
          <source>The inner function may access variables from it
any time even if the outer function is finished.</source>
          <target state="translated">내부 함수는 외부 함수가 완료 되더라도 언제든지 변수에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f440ed8885caea2f6a4de181d02ca1ce2bfd985" translate="yes" xml:space="preserve">
          <source>The kitchen is a closure that has a local variable, called &lt;code&gt;trashBags&lt;/code&gt;.  There is a function inside the kitchen called &lt;code&gt;getTrashBag&lt;/code&gt; that gets one trash bag and returns it.</source>
          <target state="translated">부엌은 &lt;code&gt;trashBags&lt;/code&gt; 라는 지역 변수가있는 클로저입니다. 부엌 &lt;code&gt;getTrashBag&lt;/code&gt; 하나의 쓰레기 봉투를 가져 와서 돌려주는 getTrashBag 라는 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9eb91337dbe1342ddf4236b7c7460d616e8d494" translate="yes" xml:space="preserve">
          <source>The line &lt;code&gt;result.push( function() {console.log(item + ' ' + list[i])}&lt;/code&gt; adds a reference to an anonymous function three times to the result array. If you are not so familiar with anonymous functions think of it like:</source>
          <target state="translated">&lt;code&gt;result.push( function() {console.log(item + ' ' + list[i])}&lt;/code&gt; 줄은 익명 함수에 대한 참조를 결과 배열에 세 번 추가합니다. 익명 함수에 익숙하지 않은 경우 그것은 좋아한다 :</target>
        </trans-unit>
        <trans-unit id="3719fe577c00cbcfb269ebde253db1c8de6cf36a" translate="yes" xml:space="preserve">
          <source>The process consists of two steps:</source>
          <target state="translated">프로세스는 두 단계로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="a6b75fac7979ad9def4158f7b987a3aa8e383e53" translate="yes" xml:space="preserve">
          <source>The reason that referenceToInnerFunction can still access the value of outerVar is because when the closure was first created by placing innerFunction inside of outerFunction, innerFunction added a reference to outerFunction&amp;rsquo;s scope (its variables and functions) to its scope chain. What this means is that innerFunction has a pointer or reference to all of outerFunction&amp;rsquo;s variables, including outerVar. So even when outerFunction has finished executing, or even if it is deleted or set to null, the variables in its scope, like outerVar, stick around in memory because of the outstanding reference to them on the part of the innerFunction that has been returned to referenceToInnerFunction. To truly release outerVar and the rest of outerFunction&amp;rsquo;s variables from memory you would have to get rid of this outstanding reference to them, say by setting referenceToInnerFunction to null as well.</source>
          <target state="translated">referenceToInnerFunction이 여전히 outerVar의 값에 액세스 할 수있는 이유는 outerFunction 내부에 innerFunction을 배치하여 클로저를 처음 작성할 때 innerFunction이 outerFunction의 범위 (변수 및 함수)에 대한 참조를 범위 체인에 추가했기 때문입니다. 이것이 의미하는 것은 innerFunction에 outerVar를 포함한 모든 outerFunction 변수에 대한 포인터 또는 참조가 있다는 것입니다. 따라서 outerFunction이 실행을 마치거나 삭제하거나 null로 설정 한 경우에도 outerVar와 같이 해당 범위의 변수는 반환 된 innerFunction의 일부에 대한 뛰어난 참조로 인해 메모리에 고정됩니다. referenceToInnerFunction. outerVar와 나머지 outerFunction 변수를 메모리에서 실제로 해제하려면 referenceToInnerFunction을 null로 설정하여 이러한 뛰어난 참조를 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="a52ec855c305cdd424a0acec2f16c794668d3e11" translate="yes" xml:space="preserve">
          <source>The secrets for JavaScript functions are the private variables</source>
          <target state="translated">JavaScript 함수의 비밀은 개인 변수입니다</target>
        </trans-unit>
        <trans-unit id="c8048ace855f36cfe6ec5f055971d3ab6080b70b" translate="yes" xml:space="preserve">
          <source>The simplest example of a closure is this:</source>
          <target state="translated">클로저의 가장 간단한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="758516d667c0ca64ba31d36b4aa304b7d45c8074" translate="yes" xml:space="preserve">
          <source>The sing() function will call each of these functions in the order they are given. Then the sing() function's work will be done.</source>
          <target state="translated">sing () 함수는 주어진 순서대로 각 함수를 호출합니다. 그러면 sing () 함수의 작업이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="b2bfe35512d67b1120c27f2759f79e721a38d640" translate="yes" xml:space="preserve">
          <source>The three functions have shared access to the same closure &amp;mdash; the local variables of &lt;code&gt;setupSomeGlobals()&lt;/code&gt; when the three functions were defined.</source>
          <target state="translated">세 함수는 같은 클로저 &lt;code&gt;setupSomeGlobals()&lt;/code&gt; 세 개의 함수가 정의되었을 때 setupSomeGlobals () 의 로컬 변수)에 대한 액세스 권한을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="1683c5c3fdaabb276940a6471aab76eac2921b0e" translate="yes" xml:space="preserve">
          <source>There is a critical difference between a C pointer to a function and a JavaScript reference to a function. In JavaScript, you can think of a function reference variable as having both a pointer to a function &lt;em&gt;as well&lt;/em&gt; as a hidden pointer to a closure.</source>
          <target state="translated">함수에 대한 C 포인터와 함수에 대한 JavaScript 참조 간에는 중요한 차이점이 있습니다. JavaScript에서 함수 참조 변수는 함수에 대한 포인터와 클로저에 대한 숨겨진 포인터를 모두 갖는 것으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="04637ad8e1b34b4d45e60aaea6b490192d004b6f" translate="yes" xml:space="preserve">
          <source>There is no reason to believe closures are a complex design hack to address specific problems. No, closures are just about using a variable that comes from a higher scope &lt;strong&gt;from the perspective of where the function was declared (not run)&lt;/strong&gt;.</source>
          <target state="translated">클로저가 특정 문제를 해결하기위한 복잡한 디자인 해킹이라고 믿을 이유가 없습니다. 아니요, 클로저는 &lt;strong&gt;함수가 선언 된 위치 (실행되지 않음)의 관점에서&lt;/strong&gt; 더 높은 범위 &lt;strong&gt;에서&lt;/strong&gt; 오는 변수를 사용하려고합니다.</target>
        </trans-unit>
        <trans-unit id="dc8da2d96ff3de796d0c72436a2ccd3f4dc18e12" translate="yes" xml:space="preserve">
          <source>There was a princess...</source>
          <target state="translated">공주가 있었다 ...</target>
        </trans-unit>
        <trans-unit id="7ee59ebacfd9d93a5dadb09b49abe5ed01b3d0c0" translate="yes" xml:space="preserve">
          <source>There you go; you're now fully encapsulating this behavior.</source>
          <target state="translated">당신은 간다; 이제이 동작을 완전히 캡슐화했습니다.</target>
        </trans-unit>
        <trans-unit id="f2e330c9ca939e298d2b5965f2b6b3e1b37e408b" translate="yes" xml:space="preserve">
          <source>This article is intended for programmers with some programming experience in a mainstream language, and who can read the following JavaScript function:</source>
          <target state="translated">이 기사는 주요 언어로 프로그래밍 경험이 있고 다음 JavaScript 함수를 읽을 수있는 프로그래머를 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="4dd1925d9c601a5cbe75680ad2654c7234add57a" translate="yes" xml:space="preserve">
          <source>This creates a new scope and &lt;code&gt;n&lt;/code&gt; is bound to that scope; this means we have 10 separate scopes, one for each iteration.</source>
          <target state="translated">이것은 새로운 범위를 만들고 &lt;code&gt;n&lt;/code&gt; 은 그 범위에 바인딩됩니다; 즉, 각 반복마다 하나씩 10 개의 개별 범위가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7552ddbeac58a09947a400d7a7ab0c7823e95f06" translate="yes" xml:space="preserve">
          <source>This example shows that the closure contains any local variables that were declared inside the outer function before it exited. Note that the variable &lt;code&gt;alice&lt;/code&gt; is actually declared after the anonymous function. The anonymous function is declared first and when that function is called it can access the &lt;code&gt;alice&lt;/code&gt; variable because &lt;code&gt;alice&lt;/code&gt; is in the same scope (JavaScript does &lt;a href=&quot;https://stackoverflow.com/a/3725763/1269037&quot;&gt;variable hoisting&lt;/a&gt;).
Also &lt;code&gt;sayAlice()()&lt;/code&gt; just directly calls the function reference returned from &lt;code&gt;sayAlice()&lt;/code&gt; &amp;mdash; it is exactly the same as what was done previously but without the temporary variable.</source>
          <target state="translated">이 예제는 클로저에 외부 함수가 종료되기 전에 선언 된 로컬 변수가 포함되어 있음을 보여줍니다. &lt;code&gt;alice&lt;/code&gt; 변수는 실제로 익명 함수 다음에 선언됩니다. 익명 함수가 먼저 선언되고 해당 함수가 호출 될 때 &lt;code&gt;alice&lt;/code&gt; 가 동일한 범위에 있기 때문에 alice 변수에 액세스 할 수 있습니다 (JavaScript는 &lt;a href=&quot;https://stackoverflow.com/a/3725763/1269037&quot;&gt;변수 게양&lt;/a&gt; ). 또한 &lt;code&gt;sayAlice()()&lt;/code&gt; 는 &lt;code&gt;sayAlice()&lt;/code&gt; 에서 반환 된 함수 참조를 직접 호출합니다. 이전 변수와 동일하지만 임시 변수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="d1bbfb6c03415d46436720884428eece40742855" translate="yes" xml:space="preserve">
          <source>This example shows that the local variables are not copied &amp;mdash; they are kept by reference. It is as though the stack-frame stays alive in memory even after the outer function exits!</source>
          <target state="translated">이 예는 지역 변수가 복사되지 않고 참조로 유지됨을 보여줍니다. 마치 외부 함수가 종료 된 후에도 스택 프레임이 메모리에 살아있는 것처럼 보입니다!</target>
        </trans-unit>
        <trans-unit id="cd052212f50f2244a372f8c3023bb7e1c19cf13f" translate="yes" xml:space="preserve">
          <source>This is an attempt to clear up several (possible) misunderstandings about closures that appear in some of the other answers.</source>
          <target state="translated">이것은 다른 답변 중 일부에 나타나는 폐쇄에 대한 여러 가지 오해를 해결하려는 시도입니다.</target>
        </trans-unit>
        <trans-unit id="789cc6e4df4d97f5dde344c2fdb9c85a7781a6d9" translate="yes" xml:space="preserve">
          <source>This is called a closure.</source>
          <target state="translated">이를 폐쇄라고합니다.</target>
        </trans-unit>
        <trans-unit id="d2b023972a185beed0da123eeebf515f35e6bed3" translate="yes" xml:space="preserve">
          <source>This line is calling the function, as if it were calling a dog</source>
          <target state="translated">이 라인은 마치 개를 호출하는 것처럼 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2e4d80d915cf259f32a4c6b7797dea00eab65b84" translate="yes" xml:space="preserve">
          <source>This one is a real gotcha for many people, so you need to understand it. Be very careful if you are defining a function within a loop: the local variables from the closure may not act as you might first think.</source>
          <target state="translated">이것은 많은 사람들에게있어 실제적인 문제이므로 이해해야합니다. 루프 내에서 함수를 정의하는 경우 매우주의하십시오. 클로저의 로컬 변수는 처음 생각한대로 작동하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da5cb87fcafafecdacdfe6ed51e0a0d4f98b7585" translate="yes" xml:space="preserve">
          <source>This page explains closures so that a programmer can understand them &amp;mdash; using working JavaScript code. It is not for gurus or functional programmers.</source>
          <target state="translated">이 페이지는 프로그래머가 작동하는 JavaScript 코드를 사용하여이를 이해할 수 있도록 클로저를 설명합니다. 전문가 나 기능 프로그래머에게는 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8a6c734fbaac2d3b867fa1c453a226b28d630cf7" translate="yes" xml:space="preserve">
          <source>This will log &lt;code&gt;16&lt;/code&gt; because function &lt;code&gt;bar&lt;/code&gt; closes over the parameter &lt;code&gt;x&lt;/code&gt; and the variable &lt;code&gt;tmp&lt;/code&gt;, both of which exist in the lexical environment of outer function &lt;code&gt;foo&lt;/code&gt;.</source>
          <target state="translated">함수 &lt;code&gt;bar&lt;/code&gt; 매개 변수 &lt;code&gt;x&lt;/code&gt; 와 변수 &lt;code&gt;tmp&lt;/code&gt; 를 모두 닫고, 둘 다 외부 함수 &lt;code&gt;foo&lt;/code&gt; 의 어휘 환경에 존재하기 때문에 &lt;code&gt;16&lt;/code&gt; 이 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="4e28adc0562a325e3e096fedb43aec2bcfc26cc2" translate="yes" xml:space="preserve">
          <source>To summarize:</source>
          <target state="translated">요약:</target>
        </trans-unit>
        <trans-unit id="185cffe022e026a4122cc13897f61794b5e49d80" translate="yes" xml:space="preserve">
          <source>Tricky: note the &lt;code&gt;say&lt;/code&gt; variable is also inside the closure and could be accessed by any other function that might be declared within &lt;code&gt;sayAlice()&lt;/code&gt;, or it could be accessed recursively within the inside function.</source>
          <target state="translated">까다로운 : &lt;code&gt;say&lt;/code&gt; 변수도 클로저 안에 있으며 &lt;code&gt;sayAlice()&lt;/code&gt; 내에서 선언 될 수있는 다른 함수로 액세스하거나 내부 함수 내에서 재귀 적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7738f68d43c61aa58c8d9b9546acdd53ba567dbc" translate="yes" xml:space="preserve">
          <source>Two brief summaries</source>
          <target state="translated">두 가지 간단한 요약</target>
        </trans-unit>
        <trans-unit id="43a5562bc755854b701217c3e2cea0041b6a10df" translate="yes" xml:space="preserve">
          <source>Two functions might look like they have the same source text, but have completely different behavior because of their 'hidden' closure. I don't think JavaScript code can actually find out if a function reference has a closure or not.</source>
          <target state="translated">두 개의 함수는 소스 텍스트는 같지만 '숨겨진'폐쇄 때문에 동작이 완전히 다른 것처럼 보일 수 있습니다. JavaScript 코드가 함수 참조에 클로저가 있는지 실제로 알 수 있다고 생각하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b6e33fa589c38cb3d120879b99ebe9f6503bd521" translate="yes" xml:space="preserve">
          <source>Two other things about closures to note. First, the closure will always have access to the last values of its containing function.</source>
          <target state="translated">클로저에 관한 두 가지 다른 점. 첫째, 클로저는 항상 포함 함수의 마지막 값에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c977033015ef8f81efe5ec1a386949630df27f5" translate="yes" xml:space="preserve">
          <source>VARIABLE: The letters &lt;em&gt;var&lt;/em&gt; stand for &quot;variable&quot;. A variable is like an envelope. On the outside this envelope is marked &quot;person&quot;. On the inside it contains a slip of paper with the information our function needs, some letters and spaces joined together like a piece of string (it's called a string) that make a phrase reading &quot;an old lady&quot;. Our envelope could contain other kinds of things like numbers (called integers), instructions (called functions), lists (called &lt;em&gt;arrays&lt;/em&gt;). Because this variable is written outside of all the braces &lt;code&gt;{}&lt;/code&gt;, and because you can see out through the tinted windows when you are inside the braces, this variable can be seen from anywhere in the code. We call this a 'global variable'.</source>
          <target state="translated">변수 : 문자 &lt;em&gt;var&lt;/em&gt; 는 &quot;변수&quot;를 나타냅니다. 변수는 봉투와 같습니다. 이 봉투의 바깥쪽에는 &quot;사람&quot;이라고 표시되어 있습니다. 내부에는 함수에 필요한 정보가 담긴 종이 한 장이 들어 있습니다. 일부 글자와 공백은 &quot;노인&quot;이라는 문구를 만드는 문자열 조각 (문자열이라고 함)과 같이 합쳐졌습니다. 우리의 엔벨로프는 숫자 (정수), 명령어 (함수),리스트 ( &lt;em&gt;배열&lt;/em&gt; )와 같은 다른 종류의 것들을 포함 할 수 있습니다. 이 변수는 모든 중괄호 &lt;code&gt;{}&lt;/code&gt; 외부에 작성되고 중괄호 안에있을 때 색조 창을 통해 볼 수 있기 때문에이 변수는 코드의 어느 곳에서나 볼 수 있습니다. 우리는 이것을 '전역 변수'라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="0a3b4dd6c2b81d0408e62dc4b0c7d9aa719858b8" translate="yes" xml:space="preserve">
          <source>We can code this in JavaScript like this:</source>
          <target state="translated">우리는 이것을 JavaScript로 다음과 같이 코딩 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0dd5ca9fc457449d5a7438bfa95e87b689ade82a" translate="yes" xml:space="preserve">
          <source>We can use this example to explain closures, as follows:</source>
          <target state="translated">이 예제를 사용하여 다음과 같이 클로저를 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb7d9f151f2ce139f3a16a6d13ee0a6d6a9272b" translate="yes" xml:space="preserve">
          <source>What if a variable is accessed, but it isn&amp;rsquo;t local? Like here:</source>
          <target state="translated">변수에 액세스했지만 지역 변수가 아닌 경우 어떻게합니까? 여기처럼 :</target>
        </trans-unit>
        <trans-unit id="1e8f90f12d65d0d31eedfa442526261ad87df2b7" translate="yes" xml:space="preserve">
          <source>What might not be obvious is that since &lt;code&gt;createClosureArray()&lt;/code&gt; is only invoked once only one scope is created for this function instead of one for every iteration of the loop.</source>
          <target state="translated">명확하지 않을 수도있는 것은 &lt;code&gt;createClosureArray()&lt;/code&gt; 가 루프의 모든 반복마다 하나가 아니라이 함수에 대해 하나의 범위 만 작성된 후에 만 ​​호출되므로,</target>
        </trans-unit>
        <trans-unit id="082f7b2b11f91eb896764f16c3c56d45e4ee7ca7" translate="yes" xml:space="preserve">
          <source>What would happen here if JavaScript &lt;em&gt;didn't&lt;/em&gt; know closures? Just replace the call in the last line by its method body (which is basically what function calls do) and you get:</source>
          <target state="translated">JavaScript &lt;em&gt;가&lt;/em&gt; 클로저를 &lt;em&gt;알지 못하면&lt;/em&gt; 어떻게됩니까? 마지막 줄의 호출을 메소드 본문 (기본적으로 함수 호출이 수행하는 것)으로 바꾸면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="0d4abbfdfc801f0827fc6f8072079568d1427247" translate="yes" xml:space="preserve">
          <source>When a JavaScript function is invoked, a new execution context &lt;code&gt;ec&lt;/code&gt; is created. Together with the function arguments and the target object, this execution context also receives a link to the lexical environment of the calling execution context, meaning the variables declared in the outer lexical environment (in the above example, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;) are available from &lt;code&gt;ec&lt;/code&gt;.</source>
          <target state="translated">JavaScript 함수가 호출되면 새로운 실행 컨텍스트 &lt;code&gt;ec&lt;/code&gt; 가 작성됩니다. 함수 인수 및 대상 객체와 함께이 실행 컨텍스트는 호출 실행 컨텍스트의 어휘 환경에 대한 링크도 수신합니다. 이는 외부 어휘 환경에서 선언 된 변수 (위의 예에서 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 모두)를 사용할 수 있음을 의미합니다. &lt;code&gt;ec&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7551a120ee1e0a45d0b5cf36770825ae08a23f1" translate="yes" xml:space="preserve">
          <source>When a function (&lt;code&gt;foo&lt;/code&gt;) declares other functions (bar and baz), the family of local variables created in &lt;code&gt;foo&lt;/code&gt; is &lt;em&gt;not destroyed&lt;/em&gt; when the function exits. The variables merely become invisible to the outside world. &lt;code&gt;foo&lt;/code&gt; can therefore cunningly return the functions &lt;code&gt;bar&lt;/code&gt; and &lt;code&gt;baz&lt;/code&gt;, and they can continue to read, write and communicate with each other through this closed-off family of variables (&quot;the closure&quot;) that nobody else can meddle with, not even someone who calls &lt;code&gt;foo&lt;/code&gt; again in future.</source>
          <target state="translated">함수 ( &lt;code&gt;foo&lt;/code&gt; )가 다른 함수 (bar 및 baz)를 선언하면 foo 에서 작성된 로컬 변수 패밀리는 함수가 종료 될 때 &lt;em&gt;소멸되지 않습니다&lt;/em&gt; . 변수는 단지 외부 세계에 보이지 않게됩니다. 따라서 &lt;code&gt;foo&lt;/code&gt; 는 교대로 함수 &lt;code&gt;bar&lt;/code&gt; 및 &lt;code&gt;baz&lt;/code&gt; 를 리턴 할 수 있으며, 아무도 호출 할 수있는 사람이 아니라 아무도 방해 할 수없는이 폐쇄 된 변수 계열 ( &quot;클로즈&quot;)을 통해 서로 계속 읽고 쓰고 통신 할 수 있습니다. 앞으로 다시 &lt;code&gt;foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a14a687cf5a4767a5c232cb3c825bc777cc5955b" translate="yes" xml:space="preserve">
          <source>When a function is created, it gets a hidden property, named [[Scope]], which references the current LexicalEnvironment.</source>
          <target state="translated">함수를 만들면 현재 LexicalEnvironment를 참조하는 [[Scope]]라는 숨겨진 속성이 나타납니다.</target>
        </trans-unit>
        <trans-unit id="af97d2eb165c46e20d5beb31d9f67783d9ae76ed" translate="yes" xml:space="preserve">
          <source>When a function is invoked via the internal &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist&quot;&gt;&lt;code&gt;[[Call]]&lt;/code&gt;&lt;/a&gt; method, the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt;&lt;code&gt;[[Environment]]&lt;/code&gt;&lt;/a&gt; reference on the function-object is copied into the &lt;em&gt;outer environment reference&lt;/em&gt; of the &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records&quot;&gt;environment record&lt;/a&gt; of the newly-created &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;execution context&lt;/a&gt; (stack frame).</source>
          <target state="translated">내부 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-ecmascript-function-objects-call-thisargument-argumentslist&quot;&gt; &lt;code&gt;[[Call]]&lt;/code&gt; &lt;/a&gt; 메소드를 통해 함수를 호출하면 함수 객체의 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-functioninitialize&quot;&gt; &lt;code&gt;[[Environment]]&lt;/code&gt; &lt;/a&gt; 참조가 새로 작성된 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-execution-contexts&quot;&gt;실행 컨텍스트&lt;/a&gt; (스택 프레임)의 &lt;a href=&quot;https://www.ecma-international.org/ecma-262/10.0/index.html#sec-environment-records&quot;&gt;환경 레코드&lt;/a&gt; 의 &lt;em&gt;외부 환경 참조&lt;/em&gt; 에 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="eda8d0ba8c86f2bcc7f89824f85d577c09f72064" translate="yes" xml:space="preserve">
          <source>When the browser has loaded the JavaScript code an reached this line, it will start the function. I put the line at the end to make sure that the browser has all the information it needs to run it.</source>
          <target state="translated">브라우저가 JavaScript 코드를로드하면이 줄에 도달하면 기능이 시작됩니다. 브라우저를 실행하는 데 필요한 모든 정보가 브라우저에 있는지 확인하기 위해 끝에 줄을 넣었습니다.</target>
        </trans-unit>
        <trans-unit id="656c8142287a1690f7f3625f825e5d62a85448e1" translate="yes" xml:space="preserve">
          <source>When the user clicks the VoteUp button, the voteUp_click function checks whether isVotedDown == true to determine whether to vote up or merely cancel a down vote. Function voteUp_click is a closure because it is accessing its environment.</source>
          <target state="translated">사용자가 VoteUp 버튼을 클릭하면 voteUp_click 함수는 isVotedDown == true인지 여부를 확인하여 투표를 할 것인지 아니면 단순히 투표를 취소 할 것인지를 결정합니다. voteUp_click 함수는 환경에 액세스하고 있기 때문에 클로저입니다.</target>
        </trans-unit>
        <trans-unit id="6df579e2161f6eb523745bff56a56ef486a46f72" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;new Function(&amp;hellip;)&lt;/code&gt; (the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function&quot;&gt;Function constructor&lt;/a&gt;) inside a function, it does not close over its lexical environment: it closes over the global context instead. (The new function cannot reference the local variables of the outer function.)</source>
          <target state="translated">&lt;code&gt;new Function(&amp;hellip;)&lt;/code&gt; ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function&quot;&gt;함수 생성자&lt;/a&gt; )을 사용하면 어휘 환경을 닫지 않고 전역 컨텍스트를 닫습니다. 새 함수는 외부 함수의 로컬 변수를 참조 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="fc1b188972939bb322463b13d9e6d79ec73b22c6" translate="yes" xml:space="preserve">
          <source>Whenever a function is declared in JavaScript a closure is created.</source>
          <target state="translated">함수가 JavaScript로 선언 될 때마다 클로저가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="42d771d468376a7581a6ea18362bea86ddcf67ad" translate="yes" xml:space="preserve">
          <source>Whenever you use &lt;code&gt;eval()&lt;/code&gt; inside a function, a closure is used. The text you &lt;code&gt;eval&lt;/code&gt; can reference local variables of the function, and within &lt;code&gt;eval&lt;/code&gt; you can even create new local variables by using &lt;code&gt;eval('var foo = &amp;hellip;')&lt;/code&gt;</source>
          <target state="translated">함수 내에서 &lt;code&gt;eval()&lt;/code&gt; 을 사용할 때마다 클로저가 사용됩니다. &lt;code&gt;eval&lt;/code&gt; 한 텍스트는 함수의 지역 변수를 참조 할 수 있으며 &lt;code&gt;eval('var foo = &amp;hellip;')&lt;/code&gt; 을 사용하여 새로운 지역 변수를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="68b3446fbf7d6fb0e4c451a7d1ae63e9f388e484" translate="yes" xml:space="preserve">
          <source>Within each scope &lt;code&gt;n&lt;/code&gt; is bound to whatever value it had when &lt;code&gt;createClosure(n)&lt;/code&gt; was invoked so the nested function that gets returned will always return the value of &lt;code&gt;n&lt;/code&gt; that it had when &lt;code&gt;createClosure(n)&lt;/code&gt; was invoked.</source>
          <target state="translated">각 범위 내에서 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;createClosure(n)&lt;/code&gt; 가 호출 될 때의 값에 바인딩되므로 리턴되는 중첩 함수는 항상 &lt;code&gt;createClosure(n)&lt;/code&gt; 가 호출되었을 때의 &lt;code&gt;n&lt;/code&gt; 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="f3685d63e9253161c4b5418f6dbd94db0b7b6fc6" translate="yes" xml:space="preserve">
          <source>Within this function a variable named &lt;code&gt;index&lt;/code&gt; is defined. The loop runs and adds functions to the array that return &lt;code&gt;index&lt;/code&gt;. Note that &lt;code&gt;index&lt;/code&gt; is defined within the &lt;code&gt;createClosureArray&lt;/code&gt; function which only ever gets invoked one time.</source>
          <target state="translated">이 함수 내에서 &lt;code&gt;index&lt;/code&gt; 라는 변수가 정의됩니다. 루프가 실행되어 &lt;code&gt;index&lt;/code&gt; 를 반환하는 함수를 배열에 추가합니다. &lt;code&gt;index&lt;/code&gt; 는 &lt;code&gt;createClosureArray&lt;/code&gt; 함수 내에 정의되며 한 번만 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="6930e04d92d01fa662d11df5aa5d0e9bd5d8f5f8" translate="yes" xml:space="preserve">
          <source>Yes. You probably use that many times a day.</source>
          <target state="translated">예. 아마 하루에 여러 번 사용할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d579fab7eac666a9836aa39e6b35da201bfec6ea" translate="yes" xml:space="preserve">
          <source>You know how grown-ups can own a house, and they call it home? When a mom has a child, the child doesn't really own anything, right? But its parents own a house, so whenever someone asks the child &quot;Where's your home?&quot;, he/she can answer &quot;that house!&quot;, and point to the house of its parents. A &quot;Closure&quot; is the ability of the child to always (even if abroad) be able to say it has a home, even though it's really the parent's who own the house.</source>
          <target state="translated">어른들이 집을 소유 할 수있는 방법을 알고 집이라고 부릅니다. 엄마가 아이를 가질 때 아이는 실제로 아무것도 소유하지 않습니다. 그러나 부모는 집을 소유하고 있기 때문에 누군가 &quot;자녀의 집은 어디입니까?&quot;라고 물을 때마다 &quot;그 집은!&quot;라고 대답하고 부모의 집을 가리킬 수 있습니다. &quot;클로저 (Closure)&quot;는 아이가 집을 소유하고 있다고해도 항상 (해외에도) 집이 있다고 말할 수있는 능력입니다.</target>
        </trans-unit>
        <trans-unit id="f95a097c531667e7c2a6ae971917615f399a2b1d" translate="yes" xml:space="preserve">
          <source>You need to understand the &quot;variable hoisting&quot; feature in Javascript in order to understand this example.</source>
          <target state="translated">이 예제를 이해하려면 Javascript의 &quot;가변 호이 스팅&quot;기능을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="12fa562f7e0a2d3533b4af8a1d5c7d14b86a0f78" translate="yes" xml:space="preserve">
          <source>You're having a sleep over and you invite Dan.
You tell Dan to bring one XBox controller.</source>
          <target state="translated">잠을 자고 Dan을 초대합니다. Dan에게 하나의 XBox 컨트롤러를 가져 오라고 지시합니다.</target>
        </trans-unit>
        <trans-unit id="0a0db21e6a13f3e33a5d7e7ef217b86c21a634c3" translate="yes" xml:space="preserve">
          <source>Your child will be able to follow two-step directions. For example, if you say to your child, &quot;Go to the kitchen and get me a trash bag&quot; they will be able to remember that direction.</source>
          <target state="translated">자녀는 2 단계 지시를 따를 수 있습니다. 예를 들어, 자녀에게 &quot;부엌에 가서 쓰레기 봉투를 가져 오십시오&quot;라고하면 그 방향을 기억할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65d09cbca9a2110fcca151e4c7f0c0fb68f6c5eb" translate="yes" xml:space="preserve">
          <source>anything in outer functions</source>
          <target state="translated">외부 기능의 모든 것</target>
        </trans-unit>
        <trans-unit id="ebf5cf1386d90514706786d86faa965c625f69a5" translate="yes" xml:space="preserve">
          <source>button or look at the Options settings to open the developer console of a browser and type &quot;person&quot; to see what this value is. Type &lt;code&gt;person=&quot;a young man&quot;&lt;/code&gt; to change it and then type &quot;person&quot; again to see that it has changed.</source>
          <target state="translated">버튼을 클릭하거나 옵션 설정을보고 브라우저의 개발자 콘솔을 열고 &quot;person&quot;을 입력하여이 값이 무엇인지 확인하십시오. &lt;code&gt;person=&quot;a young man&quot;&lt;/code&gt; 을 입력하여 변경 한 다음 &quot;person&quot;을 다시 입력하여 변경되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a253f2310ab98afd2ae5163409dd162753885015" translate="yes" xml:space="preserve">
          <source>ems</source>
          <target state="translated">ems</target>
        </trans-unit>
        <trans-unit id="18c4aadf416cf320b65098f9eaf67f9101b6b90e" translate="yes" xml:space="preserve">
          <source>globals, including the DOM</source>
          <target state="translated">DOM을 포함한 글로벌</target>
        </trans-unit>
        <trans-unit id="4f7d81389762366c131edcfc1778acc037b192e4" translate="yes" xml:space="preserve">
          <source>n = 0</source>
          <target state="translated">n = 0</target>
        </trans-unit>
        <trans-unit id="92ee913214330816c21ed1490df01843b5cb2075" translate="yes" xml:space="preserve">
          <source>n = 1</source>
          <target state="translated">n = 1</target>
        </trans-unit>
        <trans-unit id="ac48f9f7795484b3747139f0e4cb0790db58945a" translate="yes" xml:space="preserve">
          <source>n = 10</source>
          <target state="translated">n = 10</target>
        </trans-unit>
        <trans-unit id="9a3240ad86b2b1d076825686aaf98565beeaac04" translate="yes" xml:space="preserve">
          <source>n = 2</source>
          <target state="translated">n = 2</target>
        </trans-unit>
        <trans-unit id="5c515985c0cd23c7519d06977a9d6767394ced82" translate="yes" xml:space="preserve">
          <source>n = 3</source>
          <target state="translated">n = 3</target>
        </trans-unit>
        <trans-unit id="83402797555a7a7885fe6185251ac997c92f242d" translate="yes" xml:space="preserve">
          <source>n = 4</source>
          <target state="translated">n = 4</target>
        </trans-unit>
        <trans-unit id="adb8f164b2e9a9a073815a5580b5848dc5c47b6f" translate="yes" xml:space="preserve">
          <source>n = 5</source>
          <target state="translated">n = 5</target>
        </trans-unit>
        <trans-unit id="6fec459a8cd8a34f975e728d91238f3f70ad3b48" translate="yes" xml:space="preserve">
          <source>n = 6</source>
          <target state="translated">n = 6</target>
        </trans-unit>
        <trans-unit id="fd8cf86ee6124bea277fbfcdf77a50b8452d4005" translate="yes" xml:space="preserve">
          <source>n = 7</source>
          <target state="translated">n = 7</target>
        </trans-unit>
        <trans-unit id="f0f1184215b3e3a06534b7ea7b8d947bb19c606d" translate="yes" xml:space="preserve">
          <source>n = 8</source>
          <target state="translated">n = 8</target>
        </trans-unit>
        <trans-unit id="2cdacf2d84f0a2faf20a870a9028c14e3ea19dd0" translate="yes" xml:space="preserve">
          <source>n = 9</source>
          <target state="translated">n = 9</target>
        </trans-unit>
        <trans-unit id="435cb10a0d15e1b9ac626e4505828ceeac244444" translate="yes" xml:space="preserve">
          <source>referenceToInnerFunction is set to outerFunction(), which simply returns a reference to innerFunction. When referenceToInnerFunction is called, it returns outerVar. Again, as above, this demonstrates that innerFunction has access to outerVar, a variable of outerFunction. Furthermore, it is interesting to note that it retains this access even after outerFunction has finished executing.</source>
          <target state="translated">referenceToInnerFunction은 outerFunction ()으로 설정되어 innerFunction에 대한 참조를 반환합니다. referenceToInnerFunction이 호출되면 outerVar이 반환됩니다. 다시 말하지만, 이것은 innerFunction이 outerFunction 변수 인 outerVar에 액세스 할 수 있음을 보여줍니다. 또한 outerFunction이 실행을 마친 후에도이 액세스 권한을 유지한다는 점에 흥미가 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
