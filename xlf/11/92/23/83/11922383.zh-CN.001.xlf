<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/11922383">
    <body>
      <group id="11922383">
        <trans-unit id="b9d7ae0596fa1b6e804b7403306ad6e7b605efaa" translate="yes" xml:space="preserve">
          <source>(Plain) Objects have the form</source>
          <target state="translated">普通)物体的形式是</target>
        </trans-unit>
        <trans-unit id="5a44941be43e076ddb71539916eacc34663abeff" translate="yes" xml:space="preserve">
          <source>1. Oliver Steele's nested object access pattern</source>
          <target state="translated">1.Oliver Steele的嵌套对象访问模式</target>
        </trans-unit>
        <trans-unit id="ed8b403487c125d1961eab9ebb74e25ab570a5a1" translate="yes" xml:space="preserve">
          <source>2. Access Nested Objects Using Array Reduce</source>
          <target state="translated">2.使用 Array Reduce 访问嵌套对象</target>
        </trans-unit>
        <trans-unit id="ad74c01cfd52ca2cf56ce6a6598aa7ac314201eb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://api.jquery.com/jQuery.grep/&quot;&gt;jQuery's grep&lt;/a&gt; function lets you filter through an array:</source>
          <target state="translated">&lt;a href=&quot;https://api.jquery.com/jQuery.grep/&quot;&gt;jQuery的grep&lt;/a&gt;函数可让您过滤数组：</target>
        </trans-unit>
        <trans-unit id="be0ce6e993ffb8eff08543817b70124c314607a2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every&quot;&gt;&lt;code&gt;Array.prototype.every()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;&lt;code&gt;Array.prototype.some()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every&quot;&gt; &lt;code&gt;Array.prototype.every()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt; &lt;code&gt;Array.prototype.some()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2ec576c3eb3b38eee1c21db4e00aaa38a6217f1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt;&lt;code&gt;Array.prototype.find()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt;&lt;code&gt;Array.prototype.filter()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt; &lt;code&gt;Array.prototype.find()&lt;/code&gt; &lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt; &lt;code&gt;Array.prototype.filter()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="556ef4bccc10401c80f3faacf4016eec1e577dda" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;&lt;code&gt;Object.keys()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values&quot;&gt;&lt;code&gt;Object.values()&lt;/code&gt;&lt;/a&gt; (ES 2017) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt;&lt;code&gt;Object.entries()&lt;/code&gt;&lt;/a&gt; (ES 2017)</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt; &lt;code&gt;Object.keys()&lt;/code&gt; &lt;/a&gt; ， &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values&quot;&gt; &lt;code&gt;Object.values()&lt;/code&gt; &lt;/a&gt; （ES 2017）和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt; &lt;code&gt;Object.entries()&lt;/code&gt; &lt;/a&gt; （ES 2017）</target>
        </trans-unit>
        <trans-unit id="111884d6e8ac53f873a2d04671b8f49d0bca3d45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.entries()&lt;/code&gt; with a for-of loop and destructuring assignment</source>
          <target state="translated">具有for-of循环和销毁分配的 &lt;code&gt;Object.entries()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4def2b05926df9dbc0358ffc483d09a93c29d777" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.keys()&lt;/code&gt; returns an array of object's keys, &lt;code&gt;Object.values()&lt;/code&gt; returns an array of object's values, and &lt;code&gt;Object.entries()&lt;/code&gt; returns an array of object's keys and corresponding values in a format &lt;code&gt;[key, value]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Object.keys()&lt;/code&gt; 返回对象的键数组， &lt;code&gt;Object.values()&lt;/code&gt; 返回对象的值数组， &lt;code&gt;Object.entries()&lt;/code&gt; 返回对象的键和相应值的数组，格式为 &lt;code&gt;[key, value]&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="4fb5d351b0ef54c549d915337ae5b658f2a714d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var obj=JSON.parse(stringjson);&lt;/code&gt; 
so after that i get &lt;code&gt;message&lt;/code&gt; obj and show in alert box then I get &lt;code&gt;data&lt;/code&gt; which is json array and store in one varible &lt;code&gt;ArrObj&lt;/code&gt; then i read first object of that array with key value like this &lt;code&gt;ArrObj[0].id&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;var obj=JSON.parse(stringjson);&lt;/code&gt; 所以在那之后我得到 &lt;code&gt;message&lt;/code&gt; obj并显示在警报框中，然后我得到的是json数组的 &lt;code&gt;data&lt;/code&gt; 并存储在一个变量 &lt;code&gt;ArrObj&lt;/code&gt; 中,然后我用该 &lt;code&gt;ArrObj[0].id&lt;/code&gt; 这样的键值读取了该数组的第一个对象</target>
        </trans-unit>
        <trans-unit id="070baa4293f4df5a2e7819f8e151c13553b4cf63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Cannot read property 'foo' of undefined&lt;/em&gt; error</source>
          <target state="translated">&lt;em&gt;无法读取未定义&lt;/em&gt;错误的&lt;em&gt;属性&amp;ldquo; foo&amp;rdquo;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f506e37dc0630fb98bd6b1ce619c7a3a830b1c8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Cannot read property 'name' of undefined&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;无法读取undefined的属性&amp;ldquo;名称&amp;rdquo;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="f04b39aa9e617f5727bbea03e1c5dcbc50d15900" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Arrays&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa0a7c98ac6e1fb3f4f08f9978cf161c1556d0de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Objects&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7383b9e7b2d0d2accbf17b8da579fecc7fcac42f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Opt 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;选项1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a563acfca1a6fd144c9efcd226f8991db8016ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Opt 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;选项2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9daf94b0dddd46befa283cfcbbe9c25a98f3329e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using lodash would be good solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;使用lodash将是一个很好的解决方案&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="816a9c6c3ff8b608fc4422ee03bed6a523957af9" translate="yes" xml:space="preserve">
          <source>A more generic way to access a nested data structure with unknown keys and depth is to test the type of the value and act accordingly.</source>
          <target state="translated">访问具有未知键和深度的嵌套数据结构的一个比较通用的方法是测试值的类型并采取相应的行动。</target>
        </trans-unit>
        <trans-unit id="f39295fd4534982211264eee2ad1c31977f1c84d" translate="yes" xml:space="preserve">
          <source>A nested data structure is an array or object which refers to other arrays or objects, i.e. its values are arrays or objects. Such structures can be accessed by consecutively applying dot or bracket notation.</source>
          <target state="translated">嵌套数据结构是指一个数组或对象,它的值是指其他数组或对象,即它的值是数组或对象。这种结构可以通过连续应用点或括号符号来访问。</target>
        </trans-unit>
        <trans-unit id="afddb60a392d86e966d777e444f6d6456fe9e388" translate="yes" xml:space="preserve">
          <source>A pythonic, recursive and functional approach to unravel arbitrary JSON trees:</source>
          <target state="translated">拟态的、递归的和函数式的方法来解开任意的JSON树。</target>
        </trans-unit>
        <trans-unit id="4cc2f66e7372b97d6294942a2e488694268c58fd" translate="yes" xml:space="preserve">
          <source>Accessing dynamically multi levels object.</source>
          <target state="translated">动态访问多级对象。</target>
        </trans-unit>
        <trans-unit id="28db033c076db7cbec4550f7d75c73b992db4b1c" translate="yes" xml:space="preserve">
          <source>Accessing nested data structures</source>
          <target state="translated">访问嵌套数据结构</target>
        </trans-unit>
        <trans-unit id="9161e0e95a7f4324a52451db1abf9bc546febaf6" translate="yes" xml:space="preserve">
          <source>Alternatively, we could have used bracket notation for any of the properties, especially if the name contained characters that would have made it invalid for dot notation usage:</source>
          <target state="translated">另外,我们还可以对任何属性使用括号符号,特别是当名称中包含的字符对点符号的使用无效时。</target>
        </trans-unit>
        <trans-unit id="fe486bc1dc5fa2c8ed6de19ba7d46122f46fbdaf" translate="yes" xml:space="preserve">
          <source>And you know you want to get the first result of the array in the object, perhaps you would like to use</source>
          <target state="translated">而你知道你想得到对象中的数组的第一个结果,也许你想用</target>
        </trans-unit>
        <trans-unit id="ace6ce8ebfeb347b804bad250d4e5995ef0f42f2" translate="yes" xml:space="preserve">
          <source>Another more useful document depicting the situation above: 
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&quot;&gt;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&lt;/a&gt;</source>
          <target state="translated">另一个描述上述情况的有用文档： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&quot;&gt;https&lt;/a&gt; : //developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="41dda5572bc7dcd447232d111646168caca0a537" translate="yes" xml:space="preserve">
          <source>Arrays have the form</source>
          <target state="translated">阵列的形式是</target>
        </trans-unit>
        <trans-unit id="9c633aa3bac6977948ff0408055fe2896e6370e1" translate="yes" xml:space="preserve">
          <source>As alternative to &lt;code&gt;for...in&lt;/code&gt; with &lt;code&gt;hasOwnProperty&lt;/code&gt;, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;&lt;code&gt;Object.keys&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; to get an &lt;em&gt;array of property names&lt;/em&gt;:</source>
          <target state="translated">作为 &lt;code&gt;hasOwnProperty&lt;/code&gt; 中 &lt;code&gt;for...in&lt;/code&gt; 替代方法，可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt; &lt;code&gt;Object.keys&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;获取&lt;em&gt;属性名称数组&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="fbe0dbbc73fe9040a9866aed9948b4db98994376" translate="yes" xml:space="preserve">
          <source>As we can see &lt;code&gt;data&lt;/code&gt; is an object, hence we can access its properties using dot notation. The &lt;code&gt;items&lt;/code&gt; property is accessed as follows:</source>
          <target state="translated">如我们所见， &lt;code&gt;data&lt;/code&gt; 是一个对象，因此我们可以使用点表示法访问其属性。 &lt;code&gt;items&lt;/code&gt; 属性的访问方式如下：</target>
        </trans-unit>
        <trans-unit id="fdec08a847a97bcd4c07dcbb2caf3c16dcf80b54" translate="yes" xml:space="preserve">
          <source>As you can see, destructuring makes this a lot simpler.</source>
          <target state="translated">正如你所看到的,解构让这一切变得简单了许多。</target>
        </trans-unit>
        <trans-unit id="f772e09632917ff307133b29957a65855dd122d7" translate="yes" xml:space="preserve">
          <source>At times, accessing a nested object using a string can be desirable. The simple approach is the first level, for example</source>
          <target state="translated">有时,使用字符串访问一个嵌套的对象可能是可取的。简单的方法是第一层,比如说</target>
        </trans-unit>
        <trans-unit id="3ca8a39547fd839bf865328c29404e1afe375865" translate="yes" xml:space="preserve">
          <source>Basically, use a dot between each descendant that unfolds underneath it and when you have object names made out of two strings, you must use the [&quot;obj Name&quot;] notation. Otherwise, just a dot would suffice;</source>
          <target state="translated">基本上,在每一个展开在它下面的子代之间使用一个点,当你有两个字符串组成的对象名时,必须使用[&quot;obj Name&quot;]符号。否则,只用一个圆点就足够了。</target>
        </trans-unit>
        <trans-unit id="b101422364275a2e30072a8796b25a5d9cf9af98" translate="yes" xml:space="preserve">
          <source>Both arrays and objects expose a &lt;code&gt;key -&amp;gt; value&lt;/code&gt; structure. Keys in an array must be numeric, whereas any string can be used as key in objects. The key-value pairs are also called the &lt;strong&gt;&quot;properties&quot;&lt;/strong&gt;.</source>
          <target state="translated">数组和对象都公开 &lt;code&gt;key -&amp;gt; value&lt;/code&gt; 结构。 数组中的键必须是数字，而任何字符串都可以用作对象中的键。 键值对也称为&lt;strong&gt;&amp;ldquo;属性&amp;rdquo;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc5a260ab7f1841e1aba3a2ebbfd1f3271fcf519" translate="yes" xml:space="preserve">
          <source>Both ways are equal.</source>
          <target state="translated">两种方式都是平等的。</target>
        </trans-unit>
        <trans-unit id="fdd103fb4c1dabaa12e40a9fcdc5f9af7f3c871a" translate="yes" xml:space="preserve">
          <source>But if the data structure contains repeating patterns, e.g. the representation of a binary tree, the solution typically includes to &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29&quot;&gt;&lt;strong&gt;recursively&lt;/strong&gt; &lt;em&gt;&lt;sup&gt;[Wikipedia]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; access each level of the data structure.</source>
          <target state="translated">但是，如果数据结构包含重复模式，例如二叉树的表示形式，则解决方案通常包括&lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29&quot;&gt;&lt;strong&gt;递归&lt;/strong&gt; &lt;em&gt;&lt;sup&gt;[Wikipedia]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;访问数据结构的每个级别。</target>
        </trans-unit>
        <trans-unit id="4d8f4d28d7d10eb511ab35f3d5ff0db1a6e70ca1" translate="yes" xml:space="preserve">
          <source>But this is often not the case with complex json. As json becomes more complex, the approaches for finding values inside of the json also become complex. A recursive approach for navigating the json is best, and how that recursion is leveraged will depend on the type of data being searched for. If there are conditional statements involved, a &lt;a href=&quot;https://stackoverflow.com/a/11657379/1026459&quot;&gt;json search&lt;/a&gt; can be a good tool to use.</source>
          <target state="translated">但这对于复杂的json通常不是这种情况。 随着json变得越来越复杂，在json内部查找值的方法也变得复杂。 导航json的递归方法最好，而如何利用递归将取决于要搜索的数据类型。 如果涉及条件语句，那么使用&lt;a href=&quot;https://stackoverflow.com/a/11657379/1026459&quot;&gt;json搜索&lt;/a&gt;可能是一个很好的工具。</target>
        </trans-unit>
        <trans-unit id="7d269dca449b2b51321c86807f7284ab602821d8" translate="yes" xml:space="preserve">
          <source>Depending on where the object comes from (and what you want to do), you might have to test in each iteration whether the property is really a property of the object, or it is an inherited property. You can do this with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;&lt;code&gt;Object#hasOwnProperty&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">根据对象的来源（以及您要执行的操作），您可能必须在每次迭代中测试该属性是否确实是该对象的属性，还是它是继承的属性。 您可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt; &lt;code&gt;Object#hasOwnProperty&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]进行此操作&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="64569aad96916652199eeb6b944efa9a5c953da7" translate="yes" xml:space="preserve">
          <source>Destructuring assignment lets you extract values from an array or an object and assign them to variables. In this case &lt;code&gt;const [key, value]&lt;/code&gt; means that instead of assigning the &lt;code&gt;[key, value]&lt;/code&gt; array to &lt;code&gt;element&lt;/code&gt;, we assign the first element of that array to &lt;code&gt;key&lt;/code&gt; and the second element to &lt;code&gt;value&lt;/code&gt;. It is equivalent to this:</source>
          <target state="translated">通过解构分配，您可以从数组或对象中提取值并将其分配给变量。 在这种情况下， &lt;code&gt;const [key, value]&lt;/code&gt; 意味着我们没有将 &lt;code&gt;[key, value]&lt;/code&gt; 数组分配给 &lt;code&gt;element&lt;/code&gt; ，而是将该数组的第一个元素分配给 &lt;code&gt;key&lt;/code&gt; ，将第二个元素分配给 &lt;code&gt;value&lt;/code&gt; 。 等效于：</target>
        </trans-unit>
        <trans-unit id="02dc9a66286816111e66fbe036cefc9f91ca21cc" translate="yes" xml:space="preserve">
          <source>Dynamic approach</source>
          <target state="translated">动态的方法</target>
        </trans-unit>
        <trans-unit id="0d2de250773511a1ad80d3f98de046259307b9a4" translate="yes" xml:space="preserve">
          <source>Eloquent JavaScript - Data Structures</source>
          <target state="translated">Eloquent JavaScript-数据结构</target>
        </trans-unit>
        <trans-unit id="2ede17026a66f2bb53f3b6978daa3529c4d3bc25" translate="yes" xml:space="preserve">
          <source>Ex:</source>
          <target state="translated">Ex:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="3b9c2a54ba734b7b8b4978d83e1db213972ac579" translate="yes" xml:space="preserve">
          <source>For array filter lodash has &lt;code&gt;_.find()&lt;/code&gt; but I'd rather use the regular &lt;code&gt;filter()&lt;/code&gt;. But I still think the above method &lt;code&gt;_.get()&lt;/code&gt; is super useful when working with really complex data. I faced in the past really complex APIs and it was handy!</source>
          <target state="translated">对于数组过滤器，lodash具有 &lt;code&gt;_.find()&lt;/code&gt; ,但我宁愿使用常规的 &lt;code&gt;filter()&lt;/code&gt; 。 但是我仍然认为上述方法 &lt;code&gt;_.get()&lt;/code&gt; 在处理非常复杂的数据时超级有用。 我过去曾经面对过非常复杂的API，这很方便！</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="445d1e6104f5820cabec109fcf1319f71f1065d0" translate="yes" xml:space="preserve">
          <source>For that reason, array elements can only be accessed using bracket notation:</source>
          <target state="translated">为此,数组元素只能使用括号符号进行访问。</target>
        </trans-unit>
        <trans-unit id="d5a825881321ee3e4e37abb15f70df07dcb95713" translate="yes" xml:space="preserve">
          <source>For your use case the json path would be:</source>
          <target state="translated">对于你的用例来说,json路径是这样的。</target>
        </trans-unit>
        <trans-unit id="9eef871033ae2b01fb1362a850c9adfc85cc8ebf" translate="yes" xml:space="preserve">
          <source>For-of loop lets you iterate array elements. The syntax is &lt;code&gt;for (const element of array)&lt;/code&gt; (we can replace &lt;code&gt;const&lt;/code&gt; with &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;, but it's better to use &lt;code&gt;const&lt;/code&gt; if we don't intend to modify &lt;code&gt;element&lt;/code&gt;).</source>
          <target state="translated">For-of循环使您可以迭代数组元素。 语法适用 &lt;code&gt;for (const element of array)&lt;/code&gt; （我们可以将 &lt;code&gt;const&lt;/code&gt; 替换为 &lt;code&gt;var&lt;/code&gt; 或 &lt;code&gt;let&lt;/code&gt; ，但如果我们不打算修改 &lt;code&gt;element&lt;/code&gt; ，则最好使用 &lt;code&gt;const&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="0ef664dc5e993d8e597a3f0029cd45095dd4cd66" translate="yes" xml:space="preserve">
          <source>From my experience, using higher order functions instead of &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;for..in&lt;/code&gt; loops results in code that is easier to reason about, and hence more maintainable.</source>
          <target state="translated">根据我的经验，使用高阶函数代替 &lt;code&gt;for&lt;/code&gt; 或 &lt;code&gt;for..in&lt;/code&gt; 循环会导致代码更易于推理，因此更易于维护。</target>
        </trans-unit>
        <trans-unit id="cf1d3d2922bc105f006fa87beed0df0abfa99f76" translate="yes" xml:space="preserve">
          <source>Further reading material</source>
          <target state="translated">进一步的阅读材料</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="605f0dfa014b0cfc9478e06cb6929a44ac4b18c5" translate="yes" xml:space="preserve">
          <source>Here are the code examples to access various values to give you the idea.</source>
          <target state="translated">下面是访问各种值的代码示例,给大家介绍一下。</target>
        </trans-unit>
        <trans-unit id="c1c24498af84d309f0cd97effacb306f537abc11" translate="yes" xml:space="preserve">
          <source>Here is a &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://jsfiddle.net/73172hr0/&quot;&gt;&lt;code&gt;jsFiddle Demo&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; of this approach being used.</source>
          <target state="translated">这是正在使用的这种方法的&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://jsfiddle.net/73172hr0/&quot;&gt; &lt;code&gt;jsFiddle Demo&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="eea516510b57f9617ec45edfa85521334718d617" translate="yes" xml:space="preserve">
          <source>Here is an example to get the first leaf node of a binary tree:</source>
          <target state="translated">这里有一个例子,可以得到二进制树的第一个叶子节点。</target>
        </trans-unit>
        <trans-unit id="8a6cd511416c318ce3118af57082c98e3c27c850" translate="yes" xml:space="preserve">
          <source>Here is an example which adds all primitive values inside a nested data structure into an array (assuming it does not contain any functions). If we encounter an object (or array) we simply call &lt;code&gt;toArray&lt;/code&gt; again on that value (recursive call).</source>
          <target state="translated">这是一个将嵌套数据结构内的所有原始值添加到数组中的示例（假设它不包含任何函数）。 如果遇到一个对象（或数组），我们只需对该值再次调用 &lt;code&gt;toArray&lt;/code&gt; （递归调用）。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="925217328e8c6e1d64c87ab4f4335bf5fbdb54c3" translate="yes" xml:space="preserve">
          <source>Here is how we can do it step-by-step:</source>
          <target state="translated">下面我们就按部就班地做。</target>
        </trans-unit>
        <trans-unit id="d207069b46269857b00213ef7930f472a4c79665" translate="yes" xml:space="preserve">
          <source>Here we see that that &lt;code&gt;data.items&lt;/code&gt; is an array with two elements which are both objects. In Chrome console the objects can even be expanded and inspected immediately.</source>
          <target state="translated">在这里，我们看到 &lt;code&gt;data.items&lt;/code&gt; 是一个包含两个元素的数组，这两个元素都是对象。 在Chrome控制台中，对象甚至可以立即展开和检查。</target>
        </trans-unit>
        <trans-unit id="7af11a5669687094fc9c73e62819006759babfc9" translate="yes" xml:space="preserve">
          <source>How can I access and process nested objects, arrays or JSON</source>
          <target state="translated">如何访问和处理嵌套对象、数组或JSON?</target>
        </trans-unit>
        <trans-unit id="7c724edbaf2dc46e497eee6c123b2325a46b6a71" translate="yes" xml:space="preserve">
          <source>How could I access the &lt;code&gt;name&lt;/code&gt; of the second item in &lt;code&gt;items&lt;/code&gt;?</source>
          <target state="translated">如何访问项中第二项的 &lt;code&gt;name&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="505b1723179035f7490a5348f8afb6ed7fe15dc8" translate="yes" xml:space="preserve">
          <source>How to access arrays and objects is fundamental JavaScript knowledge and therefore it is advisable to read the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide&quot;&gt;MDN JavaScript Guide&lt;/a&gt;, especially the sections</source>
          <target state="translated">如何访问数组和对象是JavaScript的基本知识，因此建议您阅读《 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide&quot;&gt;MDN JavaScript指南》&lt;/a&gt; ，尤其是本节中的内容。</target>
        </trans-unit>
        <trans-unit id="eb0d89c8fcff212602dcd6e7fc04c0868e952391" translate="yes" xml:space="preserve">
          <source>However, that will cause an exception as there is no property of object with that name. The solution to be able to use this would be to flatten the tree aspect of the object. This can be done recursively.</source>
          <target state="translated">但是,这将导致一个异常,因为没有这个名称的对象的属性。能够使用这个方法的解决方案是将对象的树形方面扁平化。这可以通过递归来完成。</target>
        </trans-unit>
        <trans-unit id="1d40fcba2ecc0667c34ad4970d750807180f7fa4" translate="yes" xml:space="preserve">
          <source>I don't think questioner just only concern one level nested object, so I present the following demo to demonstrate how to access the node of deeply nested json object. All right, let's find the node with id '5'.</source>
          <target state="translated">我不认为提问者只关注一层层嵌套对象,所以下面我介绍一下演示如何访问深度嵌套的json对象的节点。好了,让我们找到id'5'的节点。</target>
        </trans-unit>
        <trans-unit id="7166a8fbe1b1257a300a599c03346689e3d076f9" translate="yes" xml:space="preserve">
          <source>I have a nested data structure containing objects and arrays. How can I extract the information, i.e. access a specific or multiple values (or keys)?</source>
          <target state="translated">我有一个包含对象和数组的嵌套数据结构。我如何提取信息,即访问一个特定的或多个值(或键)?</target>
        </trans-unit>
        <trans-unit id="594c7197f24e01cab50a8fbc4fbff277875b36a9" translate="yes" xml:space="preserve">
          <source>I hope it can be useful for who's looking for options to manipulate really complex data which the title implies.</source>
          <target state="translated">我希望它能对那些正在寻找操作真正复杂数据的选项的人有用。</target>
        </trans-unit>
        <trans-unit id="296fb090ea76c582b0388c3ac82a7e3be47e1379" translate="yes" xml:space="preserve">
          <source>I prefer JQuery. It's cleaner and easy to read.</source>
          <target state="translated">我更喜欢JQuery。它更干净,更容易阅读。</target>
        </trans-unit>
        <trans-unit id="3f0e47884848a0f215b6b29d1c59ca91e00210de" translate="yes" xml:space="preserve">
          <source>I'm trying to access a property but I get only &lt;code&gt;undefined&lt;/code&gt; back?</source>
          <target state="translated">我正在尝试访问属性，但只得到 &lt;code&gt;undefined&lt;/code&gt; 返回？</target>
        </trans-unit>
        <trans-unit id="98da6135d533ae58636b970eb90d9ba4730fc07c" translate="yes" xml:space="preserve">
          <source>If the property being accessed is already known, but the path is complex, for example in this object</source>
          <target state="translated">如果被访问的属性已经知道,但路径很复杂,例如在这个对象中</target>
        </trans-unit>
        <trans-unit id="724f6164854c1dac5164b9dfe3bd016bf11ede2c" translate="yes" xml:space="preserve">
          <source>If the property names are unknown or we want to access all properties of an object / elements of an array, we can use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;code&gt;for...in&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; loop for objects and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for&quot;&gt;&lt;code&gt;for&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; loop for arrays to iterate over all properties / elements.</source>
          <target state="translated">如果属性名称未知，或者我们要访问对象/数组元素的所有属性，则可以&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for...in&quot;&gt; &lt;code&gt;for...in&lt;/code&gt; &lt;/a&gt;对象的&lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;循环中使用for ... in ，在数组的&lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;循环中使用for ... in属性/元素。</target>
        </trans-unit>
        <trans-unit id="bb53041818a7cd5cefb1a698d8c5cf31a6bcdd25" translate="yes" xml:space="preserve">
          <source>If you already know the exact path, then you can hardcode it in your script like so:</source>
          <target state="translated">如果你已经知道确切的路径,那么你可以在你的脚本中硬编码,就像这样。</target>
        </trans-unit>
        <trans-unit id="0860a5a97f7c2d0da5833e9fe22ae22b8354c139" translate="yes" xml:space="preserve">
          <source>If you are looking for one or more objects that meets certain criteria you have a few options using &lt;a href=&quot;https://www.npmjs.com/package/query-js&quot;&gt;query-js&lt;/a&gt;</source>
          <target state="translated">如果您正在寻找一个或多个满足特定条件的对象，则可以使用&lt;a href=&quot;https://www.npmjs.com/package/query-js&quot;&gt;query-js&lt;/a&gt;进行一些选择</target>
        </trans-unit>
        <trans-unit id="1e3bacf63ad2da6ad497c062e83ee1deb7143a5e" translate="yes" xml:space="preserve">
          <source>If you have a very long path, you might even use &lt;code&gt;String.split&lt;/code&gt; to make all of this easier -</source>
          <target state="translated">如果您的路径很长，甚至可以使用 &lt;code&gt;String.split&lt;/code&gt; 简化所有操作-</target>
        </trans-unit>
        <trans-unit id="9c57867c2390b8a7a47e20ec0c1f1a52c4e1c717" translate="yes" xml:space="preserve">
          <source>In 2020, you can use @babel/plugin-proposal-optional-chaining it is very easy to access nested values in an object.</source>
          <target state="translated">2020年,你可以使用@babelplugin-proposal-optional-chaining它是非常容易访问对象中的嵌套值的。</target>
        </trans-unit>
        <trans-unit id="6eb25090a01eb8f321fc42bfc0d70eaff8d9d9a6" translate="yes" xml:space="preserve">
          <source>In addition to unknown keys, the &quot;depth&quot; of the data structure (i.e. how many nested objects) it has, might be unknown as well. How to access deeply nested properties usually depends on the exact data structure.</source>
          <target state="translated">除了未知的键外,数据结构的 &quot;深度&quot;(即有多少个嵌套对象)也可能是未知的。如何访问深度嵌套的属性通常取决于具体的数据结构。</target>
        </trans-unit>
        <trans-unit id="f62878da4abd5200fcc9c37ddc894fac250f513c" translate="yes" xml:space="preserve">
          <source>In below &lt;code&gt;deep(data,key)&lt;/code&gt; function, you can use arbitrary &lt;code&gt;key&lt;/code&gt; string - in your case &lt;code&gt;items[1].name&lt;/code&gt; (you can use array notation &lt;code&gt;[i]&lt;/code&gt; at any level) - if key is invalid then undefined is return.</source>
          <target state="translated">在下面的 &lt;code&gt;deep(data,key)&lt;/code&gt; 函数中，可以使用任意 &lt;code&gt;key&lt;/code&gt; 字符串-在您的情况下， &lt;code&gt;items[1].name&lt;/code&gt; （可以在任何级别使用数组符号 &lt;code&gt;[i]&lt;/code&gt; ）-如果键无效，则返回undefined。</target>
        </trans-unit>
        <trans-unit id="ad27c437934b9b2b1645bf081b9a50483d122ac0" translate="yes" xml:space="preserve">
          <source>In case you are already using lodash in your project, I think an elegant way to do this in a complex example:</source>
          <target state="translated">如果你已经在你的项目中使用了lodash,我认为有一种优雅的方法可以在一个复杂的例子中做到这一点。</target>
        </trans-unit>
        <trans-unit id="f33e9b91084a439b4cb911f507dd3f9d0cd299c8" translate="yes" xml:space="preserve">
          <source>In case you're trying to access an &lt;code&gt;item&lt;/code&gt; from the example structure by &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt;, without knowing it's position in the array, the easiest way to do it would be to use &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; library:</source>
          <target state="translated">如果您试图通过 &lt;code&gt;id&lt;/code&gt; 或 &lt;code&gt;name&lt;/code&gt; 从示例结构中访问 &lt;code&gt;item&lt;/code&gt; ，而又不知道它在数组中的位置，那么最简单的方法是使用&lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt;库：</target>
        </trans-unit>
        <trans-unit id="0605dd9a6ef3a81e1e32ed89e65d051905a18d0b" translate="yes" xml:space="preserve">
          <source>In each iteration, &lt;code&gt;for...of&lt;/code&gt; directly gives us the next element of the iterable, there is no &quot;index&quot; to access or use.</source>
          <target state="translated">在每次迭代中， &lt;code&gt;for...of&lt;/code&gt; 直接为我们提供了可迭代的下一个元素，没有&amp;ldquo;索引&amp;rdquo;可供访问或使用。</target>
        </trans-unit>
        <trans-unit id="17dc34a7d73c6685088f5609dc9773446daecdd4" translate="yes" xml:space="preserve">
          <source>In environments supporting ES2015 (ES6), you can also use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;em&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; loop, which not only works for arrays, but for any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;&lt;em&gt;iterable&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">在支持ES2015（ES6）的环境中，您还可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;em&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/em&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;循环，它不仅适用于数组，而且适用于任何&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;&lt;em&gt;可迭代的方法&lt;/em&gt;&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="e25c3f7d1a9be63d64a7b43f756eced2a48efc4a" translate="yes" xml:space="preserve">
          <source>It's very convenient to iterate the result of &lt;code&gt;Object.entries()&lt;/code&gt; with a &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;for-of loop&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;destructuring assignment&lt;/a&gt;.</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;for-of循环&lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;解构赋值&lt;/a&gt;来迭代 &lt;code&gt;Object.entries()&lt;/code&gt; 的结果非常方便。</target>
        </trans-unit>
        <trans-unit id="9a44b231f533fa321446e7f3e3baee1f38de9626" translate="yes" xml:space="preserve">
          <source>JSON is a textual representation of data, just like XML, YAML, CSV, and others. To work with such data, it first has to be converted to JavaScript data types, i.e. arrays and objects (and how to work with those was just explained). How to parse JSON is explained in the question &lt;a href=&quot;https://stackoverflow.com/questions/4935632/how-to-parse-json-in-javascript&quot;&gt;Parse JSON in JavaScript?&lt;/a&gt; .</source>
          <target state="translated">JSON是数据的文本表示形式，就像XML，YAML，CSV和其他形式一样。 要使用此类数据，首先必须将其转换为JavaScript数据类型，即数组和对象（以及如何使用它们）。 如何&lt;a href=&quot;https://stackoverflow.com/questions/4935632/how-to-parse-json-in-javascript&quot;&gt;在JavaScript中解析JSON&lt;/a&gt;问题中说明了如何解析JSON ？ 。</target>
        </trans-unit>
        <trans-unit id="273c9ca1c021891558d65d83fde8a56bd31c05c7" translate="yes" xml:space="preserve">
          <source>JavaScript has only one data type which can contain multiple values: &lt;strong&gt;Object&lt;/strong&gt;. An &lt;strong&gt;Array&lt;/strong&gt; is a special form of object.</source>
          <target state="translated">JavaScript只有一种可以包含多个值的数据类型： &lt;strong&gt;Object&lt;/strong&gt; 。 &lt;strong&gt;数组&lt;/strong&gt;是对象的一种特殊形式。</target>
        </trans-unit>
        <trans-unit id="f23bb5a89e2f0742d38b7b367e3f1f2f13e2d9df" translate="yes" xml:space="preserve">
          <source>Just in case, anyone's visiting this question in 2017 or later and looking for an &lt;strong&gt;easy-to-remember&lt;/strong&gt; way, here's an elaborate blog post on &lt;a href=&quot;https://dev.to/flexdinesh/accessing-nested-objects-in-javascript--9m4&quot;&gt;Accessing Nested Objects in JavaScript&lt;/a&gt; without being bamboozled by</source>
          <target state="translated">为了以防万一，有人在2017年或以后访问此问题并寻找一种&lt;strong&gt;易于记忆的&lt;/strong&gt;方式，这是一篇有关&lt;a href=&quot;https://dev.to/flexdinesh/accessing-nested-objects-in-javascript--9m4&quot;&gt;在JavaScript中访问嵌套对象&lt;/a&gt;的精心撰写的博客文章，</target>
        </trans-unit>
        <trans-unit id="1498e370fa8a872e5cb603da9a26b604ef260bf7" translate="yes" xml:space="preserve">
          <source>Just my 2 cents.</source>
          <target state="translated">只是我的两分钱。</target>
        </trans-unit>
        <trans-unit id="0aee5af72f84d80641498878ee5470711b7f59fe" translate="yes" xml:space="preserve">
          <source>Let's assume we want to access the &lt;code&gt;name&lt;/code&gt; of the second item.</source>
          <target state="translated">假设我们要访问第二项的 &lt;code&gt;name&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="56cc118b3be66a1cdf6909977e8abfc677c26f6c" translate="yes" xml:space="preserve">
          <source>Most of the time when you are getting &lt;code&gt;undefined&lt;/code&gt;, the object/array simply doesn't have a property with that name.</source>
          <target state="translated">在大多数情况下，当您 &lt;code&gt;undefined&lt;/code&gt; ，对象/数组根本没有具有该名称的属性。</target>
        </trans-unit>
        <trans-unit id="14486d9ed447554cbe361c938230a2a79b049782" translate="yes" xml:space="preserve">
          <source>My &lt;code&gt;stringjson&lt;/code&gt; is coming from PHP file but still, I indicate here in &lt;code&gt;var&lt;/code&gt;. When i directly take my json into &lt;code&gt;obj&lt;/code&gt; it will nothing show thats why i put my json file as</source>
          <target state="translated">我的 &lt;code&gt;stringjson&lt;/code&gt; 来自PHP文件，但仍然在 &lt;code&gt;var&lt;/code&gt; 中指出。 当我直接将json放入 &lt;code&gt;obj&lt;/code&gt; 时 ，不会显示这就是为什么我将json文件作为</target>
        </trans-unit>
        <trans-unit id="5a1c62cd71522c8e4b7755fe9dd24ecfec16d454" translate="yes" xml:space="preserve">
          <source>Notably it's probably overkill for this example, as simple array acccess is easier to read, but it comes in useful when breaking apart objects in general.</source>
          <target state="translated">值得注意的是,这个例子可能是矫枉过正,因为简单的数组ACCESS更容易读懂,但在一般情况下,它在拆分对象时很有用。</target>
        </trans-unit>
        <trans-unit id="8b85e6dbf0cb61793e767f18d29b4ef20f9d454b" translate="yes" xml:space="preserve">
          <source>Note: in many of the examples I'm using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt;. They are similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;function expressions&lt;/a&gt;, but they bind the &lt;code&gt;this&lt;/code&gt; value lexically.</source>
          <target state="translated">注意：在许多示例中，我都使用了&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;箭头功能&lt;/a&gt; 。 它们类似于&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;函数表达式&lt;/a&gt; ，但是它们在词法上绑定了 &lt;code&gt;this&lt;/code&gt; 值。</target>
        </trans-unit>
        <trans-unit id="4e833b435a215bc1ca1b9332c795269cd1fd5a55" translate="yes" xml:space="preserve">
          <source>Now, the complex object can be flattened</source>
          <target state="translated">现在,复杂的对象可以被扁平化了</target>
        </trans-unit>
        <trans-unit id="fe8955a6c02557382cff4dc6d58daa1174562e1f" translate="yes" xml:space="preserve">
          <source>Objects and arrays has a lot of built-in methods that can help you with processing data.</source>
          <target state="translated">对象和数组有很多内置的方法可以帮助你处理数据。</target>
        </trans-unit>
        <trans-unit id="79392da7a65cfe5eb93b63e66e9a83980b1e81ed" translate="yes" xml:space="preserve">
          <source>Old question but as nobody mentioned lodash (just underscore).</source>
          <target state="translated">老问题,但由于没有人提到lodash(只是下划线)。</target>
        </trans-unit>
        <trans-unit id="fd959ba8c2d8fcf60e6cbbb63192e46ae580a4f9" translate="yes" xml:space="preserve">
          <source>One could also use &lt;code&gt;for...in&lt;/code&gt; to iterate over arrays, but there are reasons why this should be avoided: &lt;a href=&quot;https://stackoverflow.com/questions/2265167/why-is-forvar-item-in-list-with-arrays-considered-bad-practice-in-javascript&quot;&gt;Why is 'for(var item in list)' with arrays considered bad practice in JavaScript?&lt;/a&gt;.</source>
          <target state="translated">也可以使用 &lt;code&gt;for...in&lt;/code&gt; 遍历数组，但是有理由应避免这种情况： &lt;a href=&quot;https://stackoverflow.com/questions/2265167/why-is-forvar-item-in-list-with-arrays-considered-bad-practice-in-javascript&quot;&gt;为什么在JavaScript中将数组的'for（var item in list）'视为不好的做法？&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="68a57fd3726c085ce337dc259dc3b2499a35efce" translate="yes" xml:space="preserve">
          <source>Preliminaries</source>
          <target state="translated">Preliminaries</target>
        </trans-unit>
        <trans-unit id="90ea2c98223eddf63e1721f90f66c3bdd52c50dd" translate="yes" xml:space="preserve">
          <source>Properties can be accessed either using &lt;strong&gt;dot notation&lt;/strong&gt;</source>
          <target state="translated">可以使用&lt;strong&gt;点表示法&lt;/strong&gt;来访问属性</target>
        </trans-unit>
        <trans-unit id="12d45975709c333703d3231272e38bf942b4c555" translate="yes" xml:space="preserve">
          <source>Property access via dot walking: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&lt;/a&gt;</source>
          <target state="translated">通过点走进行属性访问： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&quot;&gt;https&lt;/a&gt; : //developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">显示代码片段</target>
        </trans-unit>
        <trans-unit id="8741e75c1937a688fb16ac5022f3942e1c98839c" translate="yes" xml:space="preserve">
          <source>Since the structure of a complex object or array is not necessarily obvious, we can inspect the value at each step to decide how to move further. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt;&lt;code&gt;console.log&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt;&lt;code&gt;console.dir&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; help us doing this. For example (output of the Chrome console):</source>
          <target state="translated">由于复杂对象或数组的结构不一定很明显，因此我们可以检查每个步骤的值来决定如何进一步移动。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt; &lt;code&gt;console.log&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;和&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt; &lt;code&gt;console.dir&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]可以&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;帮助我们做到这一点。 例如（Chrome控制台的输出）：</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="f3b25614481a1e4857e6b5bdfaba4287e94bd50a" translate="yes" xml:space="preserve">
          <source>Source:  &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&quot;&gt;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&lt;/a&gt;</source>
          <target state="translated">来源： &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&quot;&gt;https&lt;/a&gt; : //learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects</target>
        </trans-unit>
        <trans-unit id="d7234880ccd53ae12304b04417b0d7fa7c1a4472" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&quot;&gt;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&lt;/a&gt;</source>
          <target state="translated">来源： &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&quot;&gt;https&lt;/a&gt; : //learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/</target>
        </trans-unit>
        <trans-unit id="68900ed6da7ee888a1cd51e372b1c1ff4e107fc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;every()&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; if the specified callback function returns &lt;code&gt;true&lt;/code&gt; for &lt;em&gt;every&lt;/em&gt; element of the array. The &lt;code&gt;some()&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; if the specified callback function returns &lt;code&gt;true&lt;/code&gt; for &lt;em&gt;some&lt;/em&gt; (at least one) element.</source>
          <target state="translated">如果指定的回调函数为数组的&lt;em&gt;每个&lt;/em&gt;元素返回 &lt;code&gt;true&lt;/code&gt; ,则 &lt;code&gt;every()&lt;/code&gt; 方法返回true 。 如果指定的回调函数对&lt;em&gt;某些&lt;/em&gt; （至少一个）元素返回 &lt;code&gt;true&lt;/code&gt; ,则 &lt;code&gt;some()&lt;/code&gt; 方法返回true 。</target>
        </trans-unit>
        <trans-unit id="33d1029fc615078c793b267f4041434365372c89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find()&lt;/code&gt; methods returns &lt;em&gt;the first&lt;/em&gt; element which satisfies the provided callback function. The &lt;code&gt;filter()&lt;/code&gt; method returns an array of &lt;em&gt;all&lt;/em&gt; elements which satisfies the provided callback function.</source>
          <target state="translated">&lt;code&gt;find()&lt;/code&gt; 方法返回满足所提供的回调函数&lt;em&gt;的第一个&lt;/em&gt;元素。 &lt;code&gt;filter()&lt;/code&gt; 方法返回一个满足所提供的回调函数的&lt;em&gt;所有&lt;/em&gt;元素的数组。</target>
        </trans-unit>
        <trans-unit id="d5f79fd90ddeb2f0dad8e8b89f8687120668cbbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map()&lt;/code&gt; method returns an array with the results of calling a provided callback function on the array elements.</source>
          <target state="translated">&lt;code&gt;map()&lt;/code&gt; 方法返回一个数组，该数组具有在数组元素上调用提供的回调函数的结果。</target>
        </trans-unit>
        <trans-unit id="1faa15edac26d9a809a6705e2ec6c7d7b680ece1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reduce()&lt;/code&gt; method reduces an array to a single value by calling the provided callback function with two elements.</source>
          <target state="translated">&lt;code&gt;reduce()&lt;/code&gt; 方法通过使用两个元素调用提供的回调函数，将数组减小为单个值。</target>
        </trans-unit>
        <trans-unit id="0520f04f746ae9cf357ff8349cf95d6d07dfac04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reduce()&lt;/code&gt; method takes an optional second parameter, which is the initial value. This is useful when the array on which you call &lt;code&gt;reduce()&lt;/code&gt; can has zero or one elements. For example, if we wanted to create a function &lt;code&gt;sum()&lt;/code&gt; which takes an array as an argument and returns the sum of all elements, we could write it like that:</source>
          <target state="translated">&lt;code&gt;reduce()&lt;/code&gt; 方法采用可选的第二个参数，它是初始值。 当您在其上调用 &lt;code&gt;reduce()&lt;/code&gt; 的数组可以具有零个或一个元素时，这很有用。 例如，如果我们要创建一个函数 &lt;code&gt;sum()&lt;/code&gt; ，该函数将数组作为参数并返回所有元素的和，则可以这样编写：</target>
        </trans-unit>
        <trans-unit id="87baea849532b922b02e9b36d55dcf711039c24a" translate="yes" xml:space="preserve">
          <source>The Underscore js Way</source>
          <target state="translated">Underscore js方式</target>
        </trans-unit>
        <trans-unit id="02b44d265370739617a71ecd63227d93c6676625" translate="yes" xml:space="preserve">
          <source>The above example creates a variable called &lt;code&gt;secondName&lt;/code&gt; from the &lt;code&gt;name&lt;/code&gt; key from an array called &lt;code&gt;items&lt;/code&gt;, the lonely &lt;code&gt;,&lt;/code&gt; says skip the first object in the array.</source>
          <target state="translated">上面的示例从名为 &lt;code&gt;items&lt;/code&gt; 的数组的 &lt;code&gt;name&lt;/code&gt; 关键字 &lt;code&gt;secondName&lt;/code&gt; 创建一个名为secondName的变量 &lt;code&gt;,&lt;/code&gt; 表示跳过数组中的第一个对象。</target>
        </trans-unit>
        <trans-unit id="f564d08e3ef27ff8ec50b9e4201c532b7f5ead34" translate="yes" xml:space="preserve">
          <source>The difference between the first and second option is that in the &lt;strong&gt;Opt 1&lt;/strong&gt; if you have one of the properties missing (undefined) in the path you don't get an error, it returns you the third parameter.</source>
          <target state="translated">第一个选项和第二个选项的区别在于，在&lt;strong&gt;选项1中，&lt;/strong&gt;如果路径中缺少一个属性（未定义），则不会出错，它将返回第三个参数。</target>
        </trans-unit>
        <trans-unit id="ce5f176bd08d85341c79d5a125f2aa823648c1d8" translate="yes" xml:space="preserve">
          <source>The easiest and the cleanest way is to use Oliver Steele's nested object access pattern</source>
          <target state="translated">最简单、最干净的方法是使用Oliver Steele的嵌套对象访问模式。</target>
        </trans-unit>
        <trans-unit id="d78353eefe17d2875f09374f4d098adbece8da68" translate="yes" xml:space="preserve">
          <source>The path is a way to say: First take the object with key &lt;code&gt;items&lt;/code&gt;, which happens to be an array. Then take the &lt;code&gt;1&lt;/code&gt;-st element (0 index arrays). Last take the object with key &lt;code&gt;name&lt;/code&gt; in that array element, which happens to be the string &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">该路径是一种表达方式：首先将带有关键 &lt;code&gt;items&lt;/code&gt; 的对象作为对象，而该对象恰好是一个数组。 然后采用第 &lt;code&gt;1&lt;/code&gt; 个元素（0个索引数组）。 最后，将具有键 &lt;code&gt;name&lt;/code&gt; 的对象放在该数组元素中，该对象恰好是字符串 &lt;code&gt;bar&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="f60727501ed0b0f71f29309fe28174d990a1a9da" translate="yes" xml:space="preserve">
          <source>The value is an array, to access its second element, we have to use bracket notation:</source>
          <target state="translated">值是一个数组,要访问它的第二个元素,我们必须使用括号符号。</target>
        </trans-unit>
        <trans-unit id="0de40644ab3a8659c7ba0625cf4b76fa463b082b" translate="yes" xml:space="preserve">
          <source>There is also an excellent type handling minimal library &lt;a href=&quot;https://www.npmjs.com/package/typy&quot;&gt;typy&lt;/a&gt; that does all this for you.</source>
          <target state="translated">还有一个出色的类型处理最小的库类型错误，可以为您完成所有这些工作。</target>
        </trans-unit>
        <trans-unit id="c2a997c0df5cc6afc6f8f4bc954c694fb5e330ab" translate="yes" xml:space="preserve">
          <source>There's also a &lt;code&gt;single&lt;/code&gt; and a &lt;code&gt;singleOrDefault&lt;/code&gt; they work much like &lt;code&gt;first&lt;/code&gt;and &lt;code&gt;firstOrDefault&lt;/code&gt;respectively. The only difference is that they will throw if &lt;em&gt;more&lt;/em&gt; than one match is found.</source>
          <target state="translated">还有一个 &lt;code&gt;single&lt;/code&gt; 和 &lt;code&gt;singleOrDefault&lt;/code&gt; ,它们的工作 &lt;code&gt;firstOrDefault&lt;/code&gt; 分别类似于 &lt;code&gt;first&lt;/code&gt; 和firstOrDefault 。 唯一的区别是，如果发现&lt;em&gt;多个&lt;/em&gt;匹配项，它们将抛出。</target>
        </trans-unit>
        <trans-unit id="cdca53564527cc4c83a547761777bdaaefd265a9" translate="yes" xml:space="preserve">
          <source>This is just plain JavaScript, without using any third party libraries like jQuery or lodash.</source>
          <target state="translated">这只是普通的JavaScript,没有使用任何第三方库,如jQuery或lodash。</target>
        </trans-unit>
        <trans-unit id="613d7e71a59cf49fd334373087cf8a7f7d514dbc" translate="yes" xml:space="preserve">
          <source>This is very brief intro to your specific use case, destructuring can be an unusual syntax to get used to at first. I'd recommend reading &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;Mozilla's Destructuring Assignment documentation&lt;/a&gt; to learn more.</source>
          <target state="translated">这是您的特定用例的非常简短的介绍，解构可能是一开始不习惯的不寻常语法。 我建议阅读&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;Mozilla的Destructuring Assignment文档&lt;/a&gt;以了解更多信息。</target>
        </trans-unit>
        <trans-unit id="ca207417a9a4489be238e24e5dc9eee14df4e603" translate="yes" xml:space="preserve">
          <source>This question is quite old, so as a contemporary update. With the onset of ES2015 there are alternatives to get a hold of the data you require. There is now a feature called &lt;strong&gt;object destructuring&lt;/strong&gt; for accessing nested objects.</source>
          <target state="translated">这个问题已经很老了，因此是一个当代更新。 随着ES2015的出现，还有一些替代方法可以保留您所需的数据。 现在有一个称为&lt;strong&gt;对象解构&lt;/strong&gt;的功能，用于访问嵌套对象。</target>
        </trans-unit>
        <trans-unit id="0b859db7c9baac7342be4c399fa4268d64580a50" translate="yes" xml:space="preserve">
          <source>This tells us that &lt;code&gt;data.items[1]&lt;/code&gt; is an object, and after expanding it we see that it has three properties, &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;__proto__&lt;/code&gt;. The latter is an internal property used for the prototype chain of the object. The prototype chain and inheritance is out of scope for this answer, though.</source>
          <target state="translated">这告诉我们 &lt;code&gt;data.items[1]&lt;/code&gt; 是一个对象，展开它后，我们看到它具有三个属性， &lt;code&gt;id&lt;/code&gt; ， &lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;__proto__&lt;/code&gt; 。 后者是用于对象原型链的内部属性。 但是，原型链和继承超出了此答案的范围。</target>
        </trans-unit>
        <trans-unit id="664137228398b0d17707a75bb9baa1603f7c4873" translate="yes" xml:space="preserve">
          <source>This value is an object and we use dot notation again to access the &lt;code&gt;name&lt;/code&gt; property. So we eventually get:</source>
          <target state="translated">该值是一个对象，我们再次使用点符号来访问 &lt;code&gt;name&lt;/code&gt; 属性。 因此，我们最终得到：</target>
        </trans-unit>
        <trans-unit id="9768ca2740c20ae8117706d5dc8fead7bf0b3e46" translate="yes" xml:space="preserve">
          <source>To access a nested attribute, you need to specify its name and then search through the object.</source>
          <target state="translated">要访问一个嵌套属性,需要指定其名称,然后通过对象进行搜索。</target>
        </trans-unit>
        <trans-unit id="56e3fdff87ae9f0ae61a5a84dce9e283d8be9946" translate="yes" xml:space="preserve">
          <source>To be able to access nested arrays, you can write your own array reduce util.</source>
          <target state="translated">为了能够访问嵌套的数组,可以编写自己的数组reduce util。</target>
        </trans-unit>
        <trans-unit id="49f8a91e4cfa2d6b3229f29def0311f69307f574" translate="yes" xml:space="preserve">
          <source>To iterate over all elements of the &lt;code&gt;data.items&lt;/code&gt;&lt;strong&gt;array&lt;/strong&gt;, we use a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">要遍历 &lt;code&gt;data.items&lt;/code&gt; &lt;strong&gt;数组的&lt;/strong&gt;所有元素，我们使用一个 &lt;code&gt;for&lt;/code&gt; 循环：</target>
        </trans-unit>
        <trans-unit id="6c1ce5587a33fa10b3413df43f4e8e8a4dae0d1e" translate="yes" xml:space="preserve">
          <source>To iterate over all properties of &lt;code&gt;data&lt;/code&gt;, we can iterate over the &lt;strong&gt;object&lt;/strong&gt; like so:</source>
          <target state="translated">要遍历 &lt;code&gt;data&lt;/code&gt; 所有属性，我们可以像这样遍历&lt;strong&gt;对象&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="7b2df20f42b29bf3e20fea1c0b9e55f35846c2b6" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt;&lt;code&gt;console.log&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt;&lt;code&gt;console.dir&lt;/code&gt;&lt;/a&gt; and inspect the structure of object / array. The property you are trying to access might be actually defined on a nested object / array.</source>
          <target state="translated">使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt; &lt;code&gt;console.log&lt;/code&gt; &lt;/a&gt;或&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt; &lt;code&gt;console.dir&lt;/code&gt; &lt;/a&gt;并检查对象/数组的结构。 您尝试访问的属性可能实际上是在嵌套对象/数组上定义的。</target>
        </trans-unit>
        <trans-unit id="72f0f0ca7535a2f887b045ea5d0ca8f48ce694a9" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;JSONPath&lt;/strong&gt; would be one of the most flexible solutions if you are willing to include a library:
&lt;a href=&quot;https://github.com/s3u/JSONPath&quot;&gt;https://github.com/s3u/JSONPath&lt;/a&gt; (node and browser)</source>
          <target state="translated">如果您愿意包含一个库，那么使用&lt;strong&gt;JSONPath&lt;/strong&gt;将是最灵活的解决方案之一： &lt;a href=&quot;https://github.com/s3u/JSONPath&quot;&gt;https&lt;/a&gt; : //github.com/s3u/JSONPath （节点和浏览器）</target>
        </trans-unit>
        <trans-unit id="dd203328bc98a927636df7b5efb2d4b1ffa6e6f4" translate="yes" xml:space="preserve">
          <source>Wait... what about JSON?</source>
          <target state="translated">等等...........那JSON呢?</target>
        </trans-unit>
        <trans-unit id="3e274725ac7462274d545e66a9e93ca5ef1df972" translate="yes" xml:space="preserve">
          <source>What if the &quot;depth&quot; of the data structure is unknown to me?</source>
          <target state="translated">如果数据结构的 &quot;深度 &quot;对我来说是未知的呢?</target>
        </trans-unit>
        <trans-unit id="0fff2ae2dbc525ac2a28a45db0cb87ff3327df68" translate="yes" xml:space="preserve">
          <source>What if the property names are dynamic and I don't know them beforehand?</source>
          <target state="translated">如果属性名称是动态的,我事先不知道怎么办?</target>
        </trans-unit>
        <trans-unit id="33d729be609d12f4e50fd456f76e8b7cce6707b0" translate="yes" xml:space="preserve">
          <source>When you don't know the exact name before hand, or a user is the one who provides the name for you. Then dynamically searching through the data structure is required. Some suggested here that the search can be done using a &lt;code&gt;for&lt;/code&gt; loop, but there is a very simple way to traverse a path using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt;&lt;code&gt;Array.reduce&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">如果您事先不知道确切的名称，或者用户是为您提供名称的人。 然后需要动态搜索数据结构。 这里有人建议可以使用 &lt;code&gt;for&lt;/code&gt; 循环进行搜索，但是有一种非常简单的方法可以使用&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt; &lt;code&gt;Array.reduce&lt;/code&gt; &lt;/a&gt;遍历路径。</target>
        </trans-unit>
        <trans-unit id="afd41e005ac69d70994393c4db3fa04d17c51a06" translate="yes" xml:space="preserve">
          <source>Which is a JavaScript library that provides a whole mess of useful &lt;code&gt;functional programming&lt;/code&gt; helpers without extending any built-in objects.</source>
          <target state="translated">这是一个JavaScript库，提供了很多有用的 &lt;code&gt;functional programming&lt;/code&gt; 助手，而无需扩展任何内置对象。</target>
        </trans-unit>
        <trans-unit id="426bb082ff6e5896064dd959ec8bae3683981cd9" translate="yes" xml:space="preserve">
          <source>With the increasing browser support of ECMAScript 5, the array method &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;forEach&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; becomes an interesting alternative as well:</source>
          <target state="translated">随着对ECMAScript 5的浏览器支持的增加，针对每个&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;的数组方法也成为一种有趣的替代方法：</target>
        </trans-unit>
        <trans-unit id="6e0bb43e7e58f1dccb01b724584c7e815f5113e7" translate="yes" xml:space="preserve">
          <source>With this notation, you'll never run into</source>
          <target state="translated">有了这个记号,你永远不会遇到</target>
        </trans-unit>
        <trans-unit id="23f0d329dcf4a9e1c2a145121c1a0c7cebda6e99" translate="yes" xml:space="preserve">
          <source>Working fiddle: &lt;a href=&quot;https://jsfiddle.net/andreitodorut/3mws3kjL/&quot;&gt;https://jsfiddle.net/andreitodorut/3mws3kjL/&lt;/a&gt;</source>
          <target state="translated">工作提琴： &lt;a href=&quot;https://jsfiddle.net/andreitodorut/3mws3kjL/&quot;&gt;https&lt;/a&gt; : //jsfiddle.net/andreitodorut/3mws3kjL/</target>
        </trans-unit>
        <trans-unit id="df5a94f92bfe3900361a91260e60682f362b48ec" translate="yes" xml:space="preserve">
          <source>Working with Objects</source>
          <target state="translated">使用对象</target>
        </trans-unit>
        <trans-unit id="4497254d63e510893ef09f0c7afb22fec75a65de" translate="yes" xml:space="preserve">
          <source>You basically check if user exists, if not, you create an empty object on the fly. This way, the next level key will &lt;strong&gt;always be accessed from an object that exists or an empty object&lt;/strong&gt;, but never from undefined.</source>
          <target state="translated">您基本上检查用户是否存在，如果不存在，则动态创建一个空对象。 这样，将&lt;strong&gt;始终从存在的对象或空对象访问&lt;/strong&gt;下一级密钥，而永远不会从未定义&lt;strong&gt;的对象访问&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="17f3f05296a9f74d4837489378560984a26833b0" translate="yes" xml:space="preserve">
          <source>You can access it this way</source>
          <target state="translated">你可以通过以下方式访问它</target>
        </trans-unit>
        <trans-unit id="cfa469e890d94b193d15281607d34ec28b836ae7" translate="yes" xml:space="preserve">
          <source>You can use the syntax &lt;code&gt;jsonObject.key&lt;/code&gt; to access the the value. And if you want access a value from an array, then you can use the syntax &lt;code&gt;jsonObjectArray[index].key&lt;/code&gt;.</source>
          <target state="translated">您可以使用语法 &lt;code&gt;jsonObject.key&lt;/code&gt; 来访问该值。 而且，如果要访问数组中的值，则可以使用语法 &lt;code&gt;jsonObjectArray[index].key&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="1c57e8d7f2d3c9338d66a6c78ba4fcafd728a6f7" translate="yes" xml:space="preserve">
          <source>You could use &lt;code&gt;lodash _get&lt;/code&gt; function:</source>
          <target state="translated">您可以使用 &lt;code&gt;lodash _get&lt;/code&gt; 函数：</target>
        </trans-unit>
        <trans-unit id="4a87503c2fa7c97664a81fd80a5702f7d91e2b3b" translate="yes" xml:space="preserve">
          <source>for further explanation of query-js you can start with this &lt;a href=&quot;http://runefs.com/2015/06/04/working-with-data-in-javascript/&quot;&gt;post&lt;/a&gt;</source>
          <target state="translated">有关query-js的进一步说明，您可以从本文开始</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="7ac01203eeb458726d789e7d2607af95159fd2ed" translate="yes" xml:space="preserve">
          <source>or &lt;strong&gt;bracket notation&lt;/strong&gt;, if the property name would not be a valid JavaScript &lt;a href=&quot;http://es5.github.com/#x7.6&quot;&gt;identifier name &lt;em&gt;&lt;sup&gt;[spec]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;, or the name is the value of a variable:</source>
          <target state="translated">或&lt;strong&gt;括号表示法&lt;/strong&gt; ，如果属性名称不是有效的JavaScript &lt;a href=&quot;http://es5.github.com/#x7.6&quot;&gt;标识符名称&lt;em&gt;&lt;sup&gt;[spec]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; ，或者名称是变量的值：</target>
        </trans-unit>
        <trans-unit id="af3ec5b75c689d26309f57c2989dae794c7b17cd" translate="yes" xml:space="preserve">
          <source>same as:</source>
          <target state="translated">如同。</target>
        </trans-unit>
        <trans-unit id="3bdb8452054fa2b577dec841756010a549232d09" translate="yes" xml:space="preserve">
          <source>so:</source>
          <target state="translated">so:</target>
        </trans-unit>
        <trans-unit id="560572a782680d5c66f76b07c8f3ba5b61030e77" translate="yes" xml:space="preserve">
          <source>these also work -</source>
          <target state="translated">这些也可以</target>
        </trans-unit>
        <trans-unit id="c86c30365c1ce95f0ba082ac38ab0704ccf05de4" translate="yes" xml:space="preserve">
          <source>to add to this, accessing nested Arrays would happen like so:</source>
          <target state="translated">为了补充这一点,访问嵌套的数组会像这样进行。</target>
        </trans-unit>
        <trans-unit id="612f40ac9069ed110eabdcfa125d119cd7f891bf" translate="yes" xml:space="preserve">
          <source>where &lt;em&gt;data&lt;/em&gt; is a python list (parsed from a JSON text string):</source>
          <target state="translated">其中&lt;em&gt;data&lt;/em&gt;是一个python列表（从JSON文本字符串解析）：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
