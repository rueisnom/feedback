<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/11922383">
    <body>
      <group id="11922383">
        <trans-unit id="b9d7ae0596fa1b6e804b7403306ad6e7b605efaa" translate="yes" xml:space="preserve">
          <source>(Plain) Objects have the form</source>
          <target state="translated">(일반) 물체의 형태는</target>
        </trans-unit>
        <trans-unit id="5a44941be43e076ddb71539916eacc34663abeff" translate="yes" xml:space="preserve">
          <source>1. Oliver Steele's nested object access pattern</source>
          <target state="translated">1. Oliver Steele의 중첩 된 객체 액세스 패턴</target>
        </trans-unit>
        <trans-unit id="ed8b403487c125d1961eab9ebb74e25ab570a5a1" translate="yes" xml:space="preserve">
          <source>2. Access Nested Objects Using Array Reduce</source>
          <target state="translated">2. Array Reduce를 사용하여 중첩 된 객체에 액세스</target>
        </trans-unit>
        <trans-unit id="ad74c01cfd52ca2cf56ce6a6598aa7ac314201eb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://api.jquery.com/jQuery.grep/&quot;&gt;jQuery's grep&lt;/a&gt; function lets you filter through an array:</source>
          <target state="translated">&lt;a href=&quot;https://api.jquery.com/jQuery.grep/&quot;&gt;jQuery의 grep&lt;/a&gt; 함수를 사용하면 배열을 통해 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be0ce6e993ffb8eff08543817b70124c314607a2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every&quot;&gt;&lt;code&gt;Array.prototype.every()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;&lt;code&gt;Array.prototype.some()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every&quot;&gt; &lt;code&gt;Array.prototype.every()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt; &lt;code&gt;Array.prototype.some()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2ec576c3eb3b38eee1c21db4e00aaa38a6217f1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt;&lt;code&gt;Array.prototype.find()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt;&lt;code&gt;Array.prototype.filter()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt; &lt;code&gt;Array.prototype.find()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt; &lt;code&gt;Array.prototype.filter()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="556ef4bccc10401c80f3faacf4016eec1e577dda" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;&lt;code&gt;Object.keys()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values&quot;&gt;&lt;code&gt;Object.values()&lt;/code&gt;&lt;/a&gt; (ES 2017) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt;&lt;code&gt;Object.entries()&lt;/code&gt;&lt;/a&gt; (ES 2017)</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt; &lt;code&gt;Object.keys()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values&quot;&gt; &lt;code&gt;Object.values()&lt;/code&gt; &lt;/a&gt; (ES 2017) 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt; &lt;code&gt;Object.entries()&lt;/code&gt; &lt;/a&gt; (ES 2017)</target>
        </trans-unit>
        <trans-unit id="111884d6e8ac53f873a2d04671b8f49d0bca3d45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.entries()&lt;/code&gt; with a for-of loop and destructuring assignment</source>
          <target state="translated">for-of 루프와 파괴 할당이있는 &lt;code&gt;Object.entries()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4def2b05926df9dbc0358ffc483d09a93c29d777" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.keys()&lt;/code&gt; returns an array of object's keys, &lt;code&gt;Object.values()&lt;/code&gt; returns an array of object's values, and &lt;code&gt;Object.entries()&lt;/code&gt; returns an array of object's keys and corresponding values in a format &lt;code&gt;[key, value]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Object.keys()&lt;/code&gt; 는 객체의 키 배열을 반환하고 &lt;code&gt;Object.values()&lt;/code&gt; 는 객체의 값 배열을 반환하며 &lt;code&gt;Object.entries()&lt;/code&gt; 는 객체의 키 배열과 해당 값을 &lt;code&gt;[key, value]&lt;/code&gt; 형식으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4fb5d351b0ef54c549d915337ae5b658f2a714d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var obj=JSON.parse(stringjson);&lt;/code&gt; 
so after that i get &lt;code&gt;message&lt;/code&gt; obj and show in alert box then I get &lt;code&gt;data&lt;/code&gt; which is json array and store in one varible &lt;code&gt;ArrObj&lt;/code&gt; then i read first object of that array with key value like this &lt;code&gt;ArrObj[0].id&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;var obj=JSON.parse(stringjson);&lt;/code&gt; 그래서 그 후 &lt;code&gt;message&lt;/code&gt; obj가 표시되고 경고 상자에 표시되면 json 배열 인 &lt;code&gt;data&lt;/code&gt; 를 가져 &lt;code&gt;ArrObj&lt;/code&gt; 하나의 varible ArrObj에 저장 한 다음이 &lt;code&gt;ArrObj[0].id&lt;/code&gt; 와 같은 키 값으로 해당 배열의 첫 번째 객체를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="070baa4293f4df5a2e7819f8e151c13553b4cf63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Cannot read property 'foo' of undefined&lt;/em&gt; error</source>
          <target state="translated">&lt;em&gt;정의되지 않은&lt;/em&gt; 오류 &lt;em&gt;의 'foo'속성을 읽을 수 없습니다&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f506e37dc0630fb98bd6b1ce619c7a3a830b1c8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Cannot read property 'name' of undefined&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;undefined의 'name'속성을 읽을 수 없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f04b39aa9e617f5727bbea03e1c5dcbc50d15900" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Arrays&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa0a7c98ac6e1fb3f4f08f9978cf161c1556d0de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Objects&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7383b9e7b2d0d2accbf17b8da579fecc7fcac42f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Opt 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;선택 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a563acfca1a6fd144c9efcd226f8991db8016ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Opt 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;선택 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9daf94b0dddd46befa283cfcbbe9c25a98f3329e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using lodash would be good solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;lodash를 사용하는 것이 좋습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="816a9c6c3ff8b608fc4422ee03bed6a523957af9" translate="yes" xml:space="preserve">
          <source>A more generic way to access a nested data structure with unknown keys and depth is to test the type of the value and act accordingly.</source>
          <target state="translated">알 수없는 키와 깊이로 중첩 된 데이터 구조에 액세스하는보다 일반적인 방법은 값의 유형을 테스트하고 그에 따라 조치하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f39295fd4534982211264eee2ad1c31977f1c84d" translate="yes" xml:space="preserve">
          <source>A nested data structure is an array or object which refers to other arrays or objects, i.e. its values are arrays or objects. Such structures can be accessed by consecutively applying dot or bracket notation.</source>
          <target state="translated">중첩 된 데이터 구조는 다른 배열 또는 객체를 참조하는 배열 또는 객체입니다. 즉, 값은 배열 또는 객체입니다. 도트 또는 괄호 표기법을 연속적으로 적용하여 이러한 구조에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afddb60a392d86e966d777e444f6d6456fe9e388" translate="yes" xml:space="preserve">
          <source>A pythonic, recursive and functional approach to unravel arbitrary JSON trees:</source>
          <target state="translated">임의의 JSON 트리를 풀기위한 파이썬적이고 재귀 적이며 기능적인 접근 방식 :</target>
        </trans-unit>
        <trans-unit id="4cc2f66e7372b97d6294942a2e488694268c58fd" translate="yes" xml:space="preserve">
          <source>Accessing dynamically multi levels object.</source>
          <target state="translated">다단계 객체에 동적으로 액세스</target>
        </trans-unit>
        <trans-unit id="28db033c076db7cbec4550f7d75c73b992db4b1c" translate="yes" xml:space="preserve">
          <source>Accessing nested data structures</source>
          <target state="translated">중첩 된 데이터 구조에 액세스</target>
        </trans-unit>
        <trans-unit id="9161e0e95a7f4324a52451db1abf9bc546febaf6" translate="yes" xml:space="preserve">
          <source>Alternatively, we could have used bracket notation for any of the properties, especially if the name contained characters that would have made it invalid for dot notation usage:</source>
          <target state="translated">또는 이름에 점 표기법 사용에 유효하지 않은 문자가 포함 된 경우 속성에 대괄호 표기법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe486bc1dc5fa2c8ed6de19ba7d46122f46fbdaf" translate="yes" xml:space="preserve">
          <source>And you know you want to get the first result of the array in the object, perhaps you would like to use</source>
          <target state="translated">그리고 객체에서 배열의 첫 번째 결과를 얻고 싶다는 것을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="ace6ce8ebfeb347b804bad250d4e5995ef0f42f2" translate="yes" xml:space="preserve">
          <source>Another more useful document depicting the situation above: 
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&quot;&gt;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&lt;/a&gt;</source>
          <target state="translated">위 상황을 묘사하는 또 다른 유용한 문서 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&quot;&gt;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="41dda5572bc7dcd447232d111646168caca0a537" translate="yes" xml:space="preserve">
          <source>Arrays have the form</source>
          <target state="translated">배열의 형태는</target>
        </trans-unit>
        <trans-unit id="9c633aa3bac6977948ff0408055fe2896e6370e1" translate="yes" xml:space="preserve">
          <source>As alternative to &lt;code&gt;for...in&lt;/code&gt; with &lt;code&gt;hasOwnProperty&lt;/code&gt;, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;&lt;code&gt;Object.keys&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; to get an &lt;em&gt;array of property names&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;hasOwnProperty&lt;/code&gt; 와 함께 &lt;code&gt;for...in&lt;/code&gt; 대신에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt; &lt;code&gt;Object.keys&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 을 사용 &lt;em&gt;하여 속성 이름 배열&lt;/em&gt; 을 얻을 수 &lt;em&gt;있습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fbe0dbbc73fe9040a9866aed9948b4db98994376" translate="yes" xml:space="preserve">
          <source>As we can see &lt;code&gt;data&lt;/code&gt; is an object, hence we can access its properties using dot notation. The &lt;code&gt;items&lt;/code&gt; property is accessed as follows:</source>
          <target state="translated">우리가 볼 수 있듯이 &lt;code&gt;data&lt;/code&gt; 는 객체이므로 점 표기법을 사용하여 속성에 액세스 할 수 있습니다. &lt;code&gt;items&lt;/code&gt; 속성은 다음과 같이 액세스됩니다 :</target>
        </trans-unit>
        <trans-unit id="fdec08a847a97bcd4c07dcbb2caf3c16dcf80b54" translate="yes" xml:space="preserve">
          <source>As you can see, destructuring makes this a lot simpler.</source>
          <target state="translated">보시다시피, 파괴는 이것을 훨씬 간단하게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f772e09632917ff307133b29957a65855dd122d7" translate="yes" xml:space="preserve">
          <source>At times, accessing a nested object using a string can be desirable. The simple approach is the first level, for example</source>
          <target state="translated">때로는 문자열을 사용하여 중첩 객체에 액세스하는 것이 바람직 할 수 있습니다. 간단한 접근 방식이 첫 번째 수준입니다 (예 :</target>
        </trans-unit>
        <trans-unit id="3ca8a39547fd839bf865328c29404e1afe375865" translate="yes" xml:space="preserve">
          <source>Basically, use a dot between each descendant that unfolds underneath it and when you have object names made out of two strings, you must use the [&quot;obj Name&quot;] notation. Otherwise, just a dot would suffice;</source>
          <target state="translated">기본적으로 그 아래에 펼쳐지는 각 자손 사이에 점을 사용하고 두 문자열로 만들어진 오브젝트 이름이있는 경우 [ &quot;obj Name&quot;] 표기법을 사용해야합니다. 그렇지 않으면 점만으로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="b101422364275a2e30072a8796b25a5d9cf9af98" translate="yes" xml:space="preserve">
          <source>Both arrays and objects expose a &lt;code&gt;key -&amp;gt; value&lt;/code&gt; structure. Keys in an array must be numeric, whereas any string can be used as key in objects. The key-value pairs are also called the &lt;strong&gt;&quot;properties&quot;&lt;/strong&gt;.</source>
          <target state="translated">배열과 객체는 모두 &lt;code&gt;key -&amp;gt; value&lt;/code&gt; 구조를 나타냅니다. 배열의 키는 숫자 여야하지만 모든 문자열은 객체의 키로 사용할 수 있습니다. 키-값 쌍은 &lt;strong&gt;&quot;properties&quot;&lt;/strong&gt; 라고도합니다.</target>
        </trans-unit>
        <trans-unit id="cc5a260ab7f1841e1aba3a2ebbfd1f3271fcf519" translate="yes" xml:space="preserve">
          <source>Both ways are equal.</source>
          <target state="translated">두 가지 방법이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="fdd103fb4c1dabaa12e40a9fcdc5f9af7f3c871a" translate="yes" xml:space="preserve">
          <source>But if the data structure contains repeating patterns, e.g. the representation of a binary tree, the solution typically includes to &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29&quot;&gt;&lt;strong&gt;recursively&lt;/strong&gt; &lt;em&gt;&lt;sup&gt;[Wikipedia]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; access each level of the data structure.</source>
          <target state="translated">그러나 데이터 구조에 반복 패턴 (예 : 이진 트리 표현)이 포함 된 경우 솔루션에는 일반적으로 각 레벨의 데이터 구조에 &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29&quot;&gt;&lt;strong&gt;재귀 적&lt;/strong&gt;&lt;/a&gt; 으로 액세스하는 것이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4d8f4d28d7d10eb511ab35f3d5ff0db1a6e70ca1" translate="yes" xml:space="preserve">
          <source>But this is often not the case with complex json. As json becomes more complex, the approaches for finding values inside of the json also become complex. A recursive approach for navigating the json is best, and how that recursion is leveraged will depend on the type of data being searched for. If there are conditional statements involved, a &lt;a href=&quot;https://stackoverflow.com/a/11657379/1026459&quot;&gt;json search&lt;/a&gt; can be a good tool to use.</source>
          <target state="translated">그러나 복잡한 json의 경우에는 종종 그렇지 않습니다. json이 더 복잡해지면 json 내부의 값을 찾는 방법도 복잡해집니다. json을 탐색하는 재귀 적 접근 방식이 가장 좋으며 재귀를 활용하는 방법은 검색되는 데이터 유형에 따라 다릅니다. 조건문이 관련된 경우 &lt;a href=&quot;https://stackoverflow.com/a/11657379/1026459&quot;&gt;json 검색&lt;/a&gt; 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7d269dca449b2b51321c86807f7284ab602821d8" translate="yes" xml:space="preserve">
          <source>Depending on where the object comes from (and what you want to do), you might have to test in each iteration whether the property is really a property of the object, or it is an inherited property. You can do this with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;&lt;code&gt;Object#hasOwnProperty&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">객체의 위치와 수행하려는 작업에 따라 각 반복에서 속성이 실제로 객체의 속성인지 아니면 상속 된 속성인지 테스트해야 할 수 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt; &lt;code&gt;Object#hasOwnProperty&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]으로&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 이를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64569aad96916652199eeb6b944efa9a5c953da7" translate="yes" xml:space="preserve">
          <source>Destructuring assignment lets you extract values from an array or an object and assign them to variables. In this case &lt;code&gt;const [key, value]&lt;/code&gt; means that instead of assigning the &lt;code&gt;[key, value]&lt;/code&gt; array to &lt;code&gt;element&lt;/code&gt;, we assign the first element of that array to &lt;code&gt;key&lt;/code&gt; and the second element to &lt;code&gt;value&lt;/code&gt;. It is equivalent to this:</source>
          <target state="translated">구조 지정 할당을 사용하면 배열 또는 객체에서 값을 추출하여 변수에 할당 할 수 있습니다. 이 경우 &lt;code&gt;const [key, value]&lt;/code&gt; 는 &lt;code&gt;[key, value]&lt;/code&gt; 배열을 &lt;code&gt;element&lt;/code&gt; 에 할당하는 대신 해당 배열의 첫 번째 요소를 &lt;code&gt;key&lt;/code&gt; 에, 두 번째 요소를 &lt;code&gt;value&lt;/code&gt; 에 할당 함을 의미 합니다 . 다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="02dc9a66286816111e66fbe036cefc9f91ca21cc" translate="yes" xml:space="preserve">
          <source>Dynamic approach</source>
          <target state="translated">동적 접근</target>
        </trans-unit>
        <trans-unit id="0d2de250773511a1ad80d3f98de046259307b9a4" translate="yes" xml:space="preserve">
          <source>Eloquent JavaScript - Data Structures</source>
          <target state="translated">Eloquent JavaScript-데이터 구조</target>
        </trans-unit>
        <trans-unit id="2ede17026a66f2bb53f3b6978daa3529c4d3bc25" translate="yes" xml:space="preserve">
          <source>Ex:</source>
          <target state="translated">Ex:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="3b9c2a54ba734b7b8b4978d83e1db213972ac579" translate="yes" xml:space="preserve">
          <source>For array filter lodash has &lt;code&gt;_.find()&lt;/code&gt; but I'd rather use the regular &lt;code&gt;filter()&lt;/code&gt;. But I still think the above method &lt;code&gt;_.get()&lt;/code&gt; is super useful when working with really complex data. I faced in the past really complex APIs and it was handy!</source>
          <target state="translated">배열 필터의 경우 lodash에는 &lt;code&gt;_.find()&lt;/code&gt; 있지만 오히려 일반 &lt;code&gt;filter()&lt;/code&gt; 사용하고 싶습니다. 그러나 여전히 위의 메소드 &lt;code&gt;_.get()&lt;/code&gt; 은 정말 복잡한 데이터로 작업 할 때 매우 유용하다고 생각합니다. 나는 과거에 정말 복잡한 API에 직면했으며 편리했습니다!</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="445d1e6104f5820cabec109fcf1319f71f1065d0" translate="yes" xml:space="preserve">
          <source>For that reason, array elements can only be accessed using bracket notation:</source>
          <target state="translated">따라서 배열 요소는 대괄호 표기법을 사용해서 만 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5a825881321ee3e4e37abb15f70df07dcb95713" translate="yes" xml:space="preserve">
          <source>For your use case the json path would be:</source>
          <target state="translated">사용 사례의 경우 json 경로는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9eef871033ae2b01fb1362a850c9adfc85cc8ebf" translate="yes" xml:space="preserve">
          <source>For-of loop lets you iterate array elements. The syntax is &lt;code&gt;for (const element of array)&lt;/code&gt; (we can replace &lt;code&gt;const&lt;/code&gt; with &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;, but it's better to use &lt;code&gt;const&lt;/code&gt; if we don't intend to modify &lt;code&gt;element&lt;/code&gt;).</source>
          <target state="translated">For-of 루프를 사용하면 배열 요소를 반복 할 수 있습니다. 구문은 &lt;code&gt;for (const element of array)&lt;/code&gt; ( &lt;code&gt;const&lt;/code&gt; 를 &lt;code&gt;var&lt;/code&gt; 또는 &lt;code&gt;let&lt;/code&gt; 으로 바꿀 수 있지만 &lt;code&gt;element&lt;/code&gt; 를 수정하지 않으려는 경우 &lt;code&gt;const&lt;/code&gt; 를 사용하는 것이 좋습니다).</target>
        </trans-unit>
        <trans-unit id="0ef664dc5e993d8e597a3f0029cd45095dd4cd66" translate="yes" xml:space="preserve">
          <source>From my experience, using higher order functions instead of &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;for..in&lt;/code&gt; loops results in code that is easier to reason about, and hence more maintainable.</source>
          <target state="translated">내 경험상 &lt;code&gt;for&lt;/code&gt; 또는 &lt;code&gt;for..in&lt;/code&gt; 루프 대신 고차 함수를 사용하면 추론하기 쉽고 코드를 유지 관리하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="cf1d3d2922bc105f006fa87beed0df0abfa99f76" translate="yes" xml:space="preserve">
          <source>Further reading material</source>
          <target state="translated">추가 자료</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="605f0dfa014b0cfc9478e06cb6929a44ac4b18c5" translate="yes" xml:space="preserve">
          <source>Here are the code examples to access various values to give you the idea.</source>
          <target state="translated">아이디어를 제공하기 위해 다양한 값에 액세스하는 코드 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1c24498af84d309f0cd97effacb306f537abc11" translate="yes" xml:space="preserve">
          <source>Here is a &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://jsfiddle.net/73172hr0/&quot;&gt;&lt;code&gt;jsFiddle Demo&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; of this approach being used.</source>
          <target state="translated">다음은이 접근 방식의 &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://jsfiddle.net/73172hr0/&quot;&gt; &lt;code&gt;jsFiddle Demo&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="eea516510b57f9617ec45edfa85521334718d617" translate="yes" xml:space="preserve">
          <source>Here is an example to get the first leaf node of a binary tree:</source>
          <target state="translated">다음은 이진 트리의 첫 번째 리프 노드를 가져 오는 예입니다.</target>
        </trans-unit>
        <trans-unit id="8a6cd511416c318ce3118af57082c98e3c27c850" translate="yes" xml:space="preserve">
          <source>Here is an example which adds all primitive values inside a nested data structure into an array (assuming it does not contain any functions). If we encounter an object (or array) we simply call &lt;code&gt;toArray&lt;/code&gt; again on that value (recursive call).</source>
          <target state="translated">다음은 중첩 된 데이터 구조 내의 모든 기본 값을 배열에 추가하는 예입니다 (함수를 포함하지 않는다고 가정). 객체 (또는 배열)가 발생하면 해당 값 (재귀 호출)으로 &lt;code&gt;toArray&lt;/code&gt; 를 다시 호출하면됩니다.</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="925217328e8c6e1d64c87ab4f4335bf5fbdb54c3" translate="yes" xml:space="preserve">
          <source>Here is how we can do it step-by-step:</source>
          <target state="translated">다음은 단계별로 수행 할 수있는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="d207069b46269857b00213ef7930f472a4c79665" translate="yes" xml:space="preserve">
          <source>Here we see that that &lt;code&gt;data.items&lt;/code&gt; is an array with two elements which are both objects. In Chrome console the objects can even be expanded and inspected immediately.</source>
          <target state="translated">여기서 &lt;code&gt;data.items&lt;/code&gt; 는 두 객체 인 두 요소를 가진 배열임을 알 수 있습니다. Chrome 콘솔에서 개체를 즉시 확장하고 검사 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7af11a5669687094fc9c73e62819006759babfc9" translate="yes" xml:space="preserve">
          <source>How can I access and process nested objects, arrays or JSON</source>
          <target state="translated">중첩 된 객체, 배열 또는 JSON에 액세스하고 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="7c724edbaf2dc46e497eee6c123b2325a46b6a71" translate="yes" xml:space="preserve">
          <source>How could I access the &lt;code&gt;name&lt;/code&gt; of the second item in &lt;code&gt;items&lt;/code&gt;?</source>
          <target state="translated">아이템의 두 번째 아이템 &lt;code&gt;name&lt;/code&gt; 에 어떻게 액세스 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="505b1723179035f7490a5348f8afb6ed7fe15dc8" translate="yes" xml:space="preserve">
          <source>How to access arrays and objects is fundamental JavaScript knowledge and therefore it is advisable to read the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide&quot;&gt;MDN JavaScript Guide&lt;/a&gt;, especially the sections</source>
          <target state="translated">배열과 객체에 액세스하는 방법은 기본적인 JavaScript 지식이므로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide&quot;&gt;MDN JavaScript 안내서&lt;/a&gt; , 특히 섹션을 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="eb0d89c8fcff212602dcd6e7fc04c0868e952391" translate="yes" xml:space="preserve">
          <source>However, that will cause an exception as there is no property of object with that name. The solution to be able to use this would be to flatten the tree aspect of the object. This can be done recursively.</source>
          <target state="translated">그러나 해당 이름을 가진 객체의 속성이 없으므로 예외가 발생합니다. 이것을 사용할 수있는 해결책은 객체의 트리 측면을 평평하게하는 것입니다. 이것은 재귀 적으로 수행 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d40fcba2ecc0667c34ad4970d750807180f7fa4" translate="yes" xml:space="preserve">
          <source>I don't think questioner just only concern one level nested object, so I present the following demo to demonstrate how to access the node of deeply nested json object. All right, let's find the node with id '5'.</source>
          <target state="translated">나는 질문자가 단지 하나의 레벨 중첩 객체에만 관심이 있다고 생각하지 않으므로 다음 중첩 데모를 제시하여 깊이 중첩 된 json 객체의 노드에 액세스하는 방법을 보여줍니다. 자, ID가 '5'인 노드를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="7166a8fbe1b1257a300a599c03346689e3d076f9" translate="yes" xml:space="preserve">
          <source>I have a nested data structure containing objects and arrays. How can I extract the information, i.e. access a specific or multiple values (or keys)?</source>
          <target state="translated">객체와 배열을 포함하는 중첩 된 데이터 구조가 있습니다. 정보를 추출하는 방법, 즉 특정 또는 여러 값 (또는 키)에 액세스하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="594c7197f24e01cab50a8fbc4fbff277875b36a9" translate="yes" xml:space="preserve">
          <source>I hope it can be useful for who's looking for options to manipulate really complex data which the title implies.</source>
          <target state="translated">제목이 암시하는 정말 복잡한 데이터를 조작하는 옵션을 찾는 사람에게 유용 할 수 있기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="296fb090ea76c582b0388c3ac82a7e3be47e1379" translate="yes" xml:space="preserve">
          <source>I prefer JQuery. It's cleaner and easy to read.</source>
          <target state="translated">JQuery를 선호합니다. 더 깨끗하고 읽기 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="3f0e47884848a0f215b6b29d1c59ca91e00210de" translate="yes" xml:space="preserve">
          <source>I'm trying to access a property but I get only &lt;code&gt;undefined&lt;/code&gt; back?</source>
          <target state="translated">속성에 액세스하려고하는데 다시 &lt;code&gt;undefined&lt;/code&gt; 입니까?</target>
        </trans-unit>
        <trans-unit id="98da6135d533ae58636b970eb90d9ba4730fc07c" translate="yes" xml:space="preserve">
          <source>If the property being accessed is already known, but the path is complex, for example in this object</source>
          <target state="translated">액세스중인 속성이 이미 알려져 있지만이 개체와 같이 경로가 복잡한 경우</target>
        </trans-unit>
        <trans-unit id="724f6164854c1dac5164b9dfe3bd016bf11ede2c" translate="yes" xml:space="preserve">
          <source>If the property names are unknown or we want to access all properties of an object / elements of an array, we can use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;code&gt;for...in&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; loop for objects and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for&quot;&gt;&lt;code&gt;for&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; loop for arrays to iterate over all properties / elements.</source>
          <target state="translated">속성 이름을 알 수 없거나 배열의 객체 / 요소에 대한 모든 속성에 액세스하려는 경우 객체에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for...in&quot;&gt; &lt;code&gt;for...in&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 루프를 사용하고 배열에 대해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 루프를 사용하여 모든 항목을 반복 할 수 있습니다 속성 / 요소.</target>
        </trans-unit>
        <trans-unit id="bb53041818a7cd5cefb1a698d8c5cf31a6bcdd25" translate="yes" xml:space="preserve">
          <source>If you already know the exact path, then you can hardcode it in your script like so:</source>
          <target state="translated">정확한 경로를 이미 알고 있다면 다음과 같이 스크립트로 하드 코딩 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0860a5a97f7c2d0da5833e9fe22ae22b8354c139" translate="yes" xml:space="preserve">
          <source>If you are looking for one or more objects that meets certain criteria you have a few options using &lt;a href=&quot;https://www.npmjs.com/package/query-js&quot;&gt;query-js&lt;/a&gt;</source>
          <target state="translated">특정 기준에 맞는 하나 이상의 객체를 찾고 있다면 &lt;a href=&quot;https://www.npmjs.com/package/query-js&quot;&gt;query-js를&lt;/a&gt; 사용하는 몇 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e3bacf63ad2da6ad497c062e83ee1deb7143a5e" translate="yes" xml:space="preserve">
          <source>If you have a very long path, you might even use &lt;code&gt;String.split&lt;/code&gt; to make all of this easier -</source>
          <target state="translated">경로가 너무 길면 &lt;code&gt;String.split&lt;/code&gt; 을 사용하여이 모든 것을 쉽게 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c57867c2390b8a7a47e20ec0c1f1a52c4e1c717" translate="yes" xml:space="preserve">
          <source>In 2020, you can use @babel/plugin-proposal-optional-chaining it is very easy to access nested values in an object.</source>
          <target state="translated">2020 년에 @ babel / plugin-proposal-optional-chaining을 사용하면 객체의 중첩 값에 쉽게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eb25090a01eb8f321fc42bfc0d70eaff8d9d9a6" translate="yes" xml:space="preserve">
          <source>In addition to unknown keys, the &quot;depth&quot; of the data structure (i.e. how many nested objects) it has, might be unknown as well. How to access deeply nested properties usually depends on the exact data structure.</source>
          <target state="translated">알 수없는 키 외에도 데이터 구조의 &quot;깊이&quot;(예 : 중첩 된 개체 수)도 알 수 없습니다. 깊이 중첩 된 속성에 액세스하는 방법은 일반적으로 정확한 데이터 구조에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f62878da4abd5200fcc9c37ddc894fac250f513c" translate="yes" xml:space="preserve">
          <source>In below &lt;code&gt;deep(data,key)&lt;/code&gt; function, you can use arbitrary &lt;code&gt;key&lt;/code&gt; string - in your case &lt;code&gt;items[1].name&lt;/code&gt; (you can use array notation &lt;code&gt;[i]&lt;/code&gt; at any level) - if key is invalid then undefined is return.</source>
          <target state="translated">아래 &lt;code&gt;deep(data,key)&lt;/code&gt; 함수에서 임의의 &lt;code&gt;key&lt;/code&gt; 문자열을 사용할 수 있습니다. 경우에 따라 &lt;code&gt;items[1].name&lt;/code&gt; (어느 수준에서나 배열 표기법 &lt;code&gt;[i]&lt;/code&gt; 을 사용할 수 있습니다)-키가 유효하지 않으면 undefined가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ad27c437934b9b2b1645bf081b9a50483d122ac0" translate="yes" xml:space="preserve">
          <source>In case you are already using lodash in your project, I think an elegant way to do this in a complex example:</source>
          <target state="translated">프로젝트에서 이미 lodash를 사용하는 경우 복잡한 예에서이를 수행하는 우아한 방법이 있다고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="f33e9b91084a439b4cb911f507dd3f9d0cd299c8" translate="yes" xml:space="preserve">
          <source>In case you're trying to access an &lt;code&gt;item&lt;/code&gt; from the example structure by &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt;, without knowing it's position in the array, the easiest way to do it would be to use &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; library:</source>
          <target state="translated">배열의 위치를 ​​모르고 &lt;code&gt;id&lt;/code&gt; 또는 &lt;code&gt;name&lt;/code&gt; 으로 예제 구조에서 &lt;code&gt;item&lt;/code&gt; 에 액세스하려고하는 경우 가장 쉬운 방법은 &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; 라이브러리를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0605dd9a6ef3a81e1e32ed89e65d051905a18d0b" translate="yes" xml:space="preserve">
          <source>In each iteration, &lt;code&gt;for...of&lt;/code&gt; directly gives us the next element of the iterable, there is no &quot;index&quot; to access or use.</source>
          <target state="translated">각 반복에서 &lt;code&gt;for...of&lt;/code&gt; 는 iterable의 다음 요소 를 직접 제공하므로 액세스하거나 사용할 &quot;인덱스&quot;가 없습니다.</target>
        </trans-unit>
        <trans-unit id="17dc34a7d73c6685088f5609dc9773446daecdd4" translate="yes" xml:space="preserve">
          <source>In environments supporting ES2015 (ES6), you can also use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;em&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; loop, which not only works for arrays, but for any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;&lt;em&gt;iterable&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">ES2015 (ES6)를 지원하는 환경에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;em&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/em&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 루프 &lt;em&gt;를&lt;/em&gt; 사용할 수 있습니다 &lt;em&gt;&lt;sup&gt;.이&lt;/sup&gt;&lt;/em&gt; 루프는 배열뿐만 아니라 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;&lt;em&gt;반복 가능한&lt;/em&gt;&lt;/a&gt; 작업에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e25c3f7d1a9be63d64a7b43f756eced2a48efc4a" translate="yes" xml:space="preserve">
          <source>It's very convenient to iterate the result of &lt;code&gt;Object.entries()&lt;/code&gt; with a &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;for-of loop&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;destructuring assignment&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;for-of 루프&lt;/a&gt; 와 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;소멸 할당&lt;/a&gt; 으로 &lt;code&gt;Object.entries()&lt;/code&gt; 의 결과를 반복하는 것이 매우 편리 합니다 .</target>
        </trans-unit>
        <trans-unit id="9a44b231f533fa321446e7f3e3baee1f38de9626" translate="yes" xml:space="preserve">
          <source>JSON is a textual representation of data, just like XML, YAML, CSV, and others. To work with such data, it first has to be converted to JavaScript data types, i.e. arrays and objects (and how to work with those was just explained). How to parse JSON is explained in the question &lt;a href=&quot;https://stackoverflow.com/questions/4935632/how-to-parse-json-in-javascript&quot;&gt;Parse JSON in JavaScript?&lt;/a&gt; .</source>
          <target state="translated">JSON은 XML, YAML, CSV 등과 같은 데이터의 텍스트 표현입니다. 이러한 데이터로 작업하려면 먼저 배열 및 객체와 같은 JavaScript 데이터 형식으로 변환해야합니다 (그리고 이러한 작업을 수행하는 방법은 방금 설명했습니다). JSON을 구문 분석하는 방법 &lt;a href=&quot;https://stackoverflow.com/questions/4935632/how-to-parse-json-in-javascript&quot;&gt;은 JavaScript에서 JSON 구문 분석&lt;/a&gt; 질문에 설명되어 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="273c9ca1c021891558d65d83fde8a56bd31c05c7" translate="yes" xml:space="preserve">
          <source>JavaScript has only one data type which can contain multiple values: &lt;strong&gt;Object&lt;/strong&gt;. An &lt;strong&gt;Array&lt;/strong&gt; is a special form of object.</source>
          <target state="translated">JavaScript에는 여러 값을 포함 할 수있는 하나의 데이터 유형 ( &lt;strong&gt;Object) 만&lt;/strong&gt; 있습니다. &lt;strong&gt;배열&lt;/strong&gt; 은 특별한 형태의 객체입니다.</target>
        </trans-unit>
        <trans-unit id="f23bb5a89e2f0742d38b7b367e3f1f2f13e2d9df" translate="yes" xml:space="preserve">
          <source>Just in case, anyone's visiting this question in 2017 or later and looking for an &lt;strong&gt;easy-to-remember&lt;/strong&gt; way, here's an elaborate blog post on &lt;a href=&quot;https://dev.to/flexdinesh/accessing-nested-objects-in-javascript--9m4&quot;&gt;Accessing Nested Objects in JavaScript&lt;/a&gt; without being bamboozled by</source>
          <target state="translated">2017 년 이후 에이 질문을 방문하고 &lt;strong&gt;기억하기 쉬운&lt;/strong&gt; 방법 &lt;strong&gt;을&lt;/strong&gt; 찾는 사람을 위해, &lt;a href=&quot;https://dev.to/flexdinesh/accessing-nested-objects-in-javascript--9m4&quot;&gt;JavaScript로 중첩 된 객체&lt;/a&gt; 에 액세스 하는 방법에 대한 정교한 블로그 게시물이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1498e370fa8a872e5cb603da9a26b604ef260bf7" translate="yes" xml:space="preserve">
          <source>Just my 2 cents.</source>
          <target state="translated">그냥 내 2 센트.</target>
        </trans-unit>
        <trans-unit id="0aee5af72f84d80641498878ee5470711b7f59fe" translate="yes" xml:space="preserve">
          <source>Let's assume we want to access the &lt;code&gt;name&lt;/code&gt; of the second item.</source>
          <target state="translated">두 번째 항목의 &lt;code&gt;name&lt;/code&gt; 에 액세스하려고한다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="56cc118b3be66a1cdf6909977e8abfc677c26f6c" translate="yes" xml:space="preserve">
          <source>Most of the time when you are getting &lt;code&gt;undefined&lt;/code&gt;, the object/array simply doesn't have a property with that name.</source>
          <target state="translated">&lt;code&gt;undefined&lt;/code&gt; 를 얻는 대부분의 경우 객체 / 배열에는 단순히 해당 이름의 속성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="14486d9ed447554cbe361c938230a2a79b049782" translate="yes" xml:space="preserve">
          <source>My &lt;code&gt;stringjson&lt;/code&gt; is coming from PHP file but still, I indicate here in &lt;code&gt;var&lt;/code&gt;. When i directly take my json into &lt;code&gt;obj&lt;/code&gt; it will nothing show thats why i put my json file as</source>
          <target state="translated">내 &lt;code&gt;stringjson&lt;/code&gt; 은 PHP 파일에서 왔지만 여전히 &lt;code&gt;var&lt;/code&gt; 로 표시합니다. 내가 직접 json을 &lt;code&gt;obj&lt;/code&gt; 로 가져 가면 json 파일을 다음과 같이 넣는 이유가 아무것도 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a1c62cd71522c8e4b7755fe9dd24ecfec16d454" translate="yes" xml:space="preserve">
          <source>Notably it's probably overkill for this example, as simple array acccess is easier to read, but it comes in useful when breaking apart objects in general.</source>
          <target state="translated">특히 간단한 배열 접근이 읽기 쉽기 때문에이 예제에서는 너무 과잉 일 수 있지만 일반적으로 객체를 분리 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8b85e6dbf0cb61793e767f18d29b4ef20f9d454b" translate="yes" xml:space="preserve">
          <source>Note: in many of the examples I'm using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt;. They are similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;function expressions&lt;/a&gt;, but they bind the &lt;code&gt;this&lt;/code&gt; value lexically.</source>
          <target state="translated">참고 : 많은 예제에서 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;화살표 함수를&lt;/a&gt; 사용하고 있습니다 . &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;함수 표현식&lt;/a&gt; 과 비슷하지만 &lt;code&gt;this&lt;/code&gt; 값을 어휘 적으로 바인딩합니다.</target>
        </trans-unit>
        <trans-unit id="4e833b435a215bc1ca1b9332c795269cd1fd5a55" translate="yes" xml:space="preserve">
          <source>Now, the complex object can be flattened</source>
          <target state="translated">이제 복잡한 물체를 평평하게 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="fe8955a6c02557382cff4dc6d58daa1174562e1f" translate="yes" xml:space="preserve">
          <source>Objects and arrays has a lot of built-in methods that can help you with processing data.</source>
          <target state="translated">객체와 배열에는 데이터 처리에 도움이되는 내장 메서드가 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="79392da7a65cfe5eb93b63e66e9a83980b1e81ed" translate="yes" xml:space="preserve">
          <source>Old question but as nobody mentioned lodash (just underscore).</source>
          <target state="translated">오래된 질문이지만 아무도 lodash를 언급하지 않았으므로 (밑줄).</target>
        </trans-unit>
        <trans-unit id="fd959ba8c2d8fcf60e6cbbb63192e46ae580a4f9" translate="yes" xml:space="preserve">
          <source>One could also use &lt;code&gt;for...in&lt;/code&gt; to iterate over arrays, but there are reasons why this should be avoided: &lt;a href=&quot;https://stackoverflow.com/questions/2265167/why-is-forvar-item-in-list-with-arrays-considered-bad-practice-in-javascript&quot;&gt;Why is 'for(var item in list)' with arrays considered bad practice in JavaScript?&lt;/a&gt;.</source>
          <target state="translated">배열을 반복하기 &lt;code&gt;for...in&lt;/code&gt; 을 사용할 수도 있지만 이것을 피해야하는 &lt;a href=&quot;https://stackoverflow.com/questions/2265167/why-is-forvar-item-in-list-with-arrays-considered-bad-practice-in-javascript&quot;&gt;이유가&lt;/a&gt; 있습니다. 배열에서 'for (var item in list)'가 JavaScript에서 나쁜 습관으로 간주되는 이유는 무엇입니까? .</target>
        </trans-unit>
        <trans-unit id="68a57fd3726c085ce337dc259dc3b2499a35efce" translate="yes" xml:space="preserve">
          <source>Preliminaries</source>
          <target state="translated">Preliminaries</target>
        </trans-unit>
        <trans-unit id="90ea2c98223eddf63e1721f90f66c3bdd52c50dd" translate="yes" xml:space="preserve">
          <source>Properties can be accessed either using &lt;strong&gt;dot notation&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;점 표기법을&lt;/strong&gt; 사용하여 속성에 액세스 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="12d45975709c333703d3231272e38bf942b4c555" translate="yes" xml:space="preserve">
          <source>Property access via dot walking: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&lt;/a&gt;</source>
          <target state="translated">도트 워킹을 통한 속성 액세스 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">코드 스 니펫 표시</target>
        </trans-unit>
        <trans-unit id="8741e75c1937a688fb16ac5022f3942e1c98839c" translate="yes" xml:space="preserve">
          <source>Since the structure of a complex object or array is not necessarily obvious, we can inspect the value at each step to decide how to move further. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt;&lt;code&gt;console.log&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt;&lt;code&gt;console.dir&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; help us doing this. For example (output of the Chrome console):</source>
          <target state="translated">복잡한 객체 또는 배열의 구조가 반드시 명확하지는 않기 때문에 각 단계에서 값을 검사하여 추가 이동 방법을 결정할 수 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt; &lt;code&gt;console.log&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt; &lt;code&gt;console.dir&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 이이 작업을 도와줍니다. 예를 들어 (Chrome 콘솔의 출력) :</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="f3b25614481a1e4857e6b5bdfaba4287e94bd50a" translate="yes" xml:space="preserve">
          <source>Source:  &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&quot;&gt;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&quot;&gt;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7234880ccd53ae12304b04417b0d7fa7c1a4472" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&quot;&gt;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&lt;/a&gt;</source>
          <target state="translated">출처 : &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&quot;&gt;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68900ed6da7ee888a1cd51e372b1c1ff4e107fc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;every()&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; if the specified callback function returns &lt;code&gt;true&lt;/code&gt; for &lt;em&gt;every&lt;/em&gt; element of the array. The &lt;code&gt;some()&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; if the specified callback function returns &lt;code&gt;true&lt;/code&gt; for &lt;em&gt;some&lt;/em&gt; (at least one) element.</source>
          <target state="translated">지정된 콜백 함수가 배열의 &lt;em&gt;모든&lt;/em&gt; 요소에 대해 &lt;code&gt;true&lt;/code&gt; 를 반환하면 &lt;code&gt;every()&lt;/code&gt; 메서드가 &lt;code&gt;true&lt;/code&gt; 를 반환 합니다 . &lt;code&gt;some()&lt;/code&gt; 메소드는 지정된 콜백 함수가 &lt;em&gt;일부&lt;/em&gt; (적어도 하나의) 요소에 대해 &lt;code&gt;true&lt;/code&gt; 를 리턴하면 true 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="33d1029fc615078c793b267f4041434365372c89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find()&lt;/code&gt; methods returns &lt;em&gt;the first&lt;/em&gt; element which satisfies the provided callback function. The &lt;code&gt;filter()&lt;/code&gt; method returns an array of &lt;em&gt;all&lt;/em&gt; elements which satisfies the provided callback function.</source>
          <target state="translated">&lt;code&gt;find()&lt;/code&gt; 메소드는 제공된 콜백 함수를 만족시키는 &lt;em&gt;첫 번째&lt;/em&gt; 요소를 리턴 &lt;em&gt;합니다&lt;/em&gt; . &lt;code&gt;filter()&lt;/code&gt; 메소드는 제공된 콜백 함수를 충족시키는 &lt;em&gt;모든&lt;/em&gt; 요소의 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="d5f79fd90ddeb2f0dad8e8b89f8687120668cbbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map()&lt;/code&gt; method returns an array with the results of calling a provided callback function on the array elements.</source>
          <target state="translated">&lt;code&gt;map()&lt;/code&gt; 메소드는 배열 요소에서 제공된 콜백 함수를 호출 한 결과와 함께 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="1faa15edac26d9a809a6705e2ec6c7d7b680ece1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reduce()&lt;/code&gt; method reduces an array to a single value by calling the provided callback function with two elements.</source>
          <target state="translated">&lt;code&gt;reduce()&lt;/code&gt; 메소드는 두 개의 요소로 제공된 콜백 함수를 호출하여 배열을 단일 값으로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="0520f04f746ae9cf357ff8349cf95d6d07dfac04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reduce()&lt;/code&gt; method takes an optional second parameter, which is the initial value. This is useful when the array on which you call &lt;code&gt;reduce()&lt;/code&gt; can has zero or one elements. For example, if we wanted to create a function &lt;code&gt;sum()&lt;/code&gt; which takes an array as an argument and returns the sum of all elements, we could write it like that:</source>
          <target state="translated">&lt;code&gt;reduce()&lt;/code&gt; 메소드는 선택적인 두 번째 매개 변수 (초기 값)를 사용합니다. 이것은 &lt;code&gt;reduce()&lt;/code&gt; 를 호출하는 배열에 0 개 또는 1 개의 요소가있을 수있는 경우에 유용합니다. 예를 들어 배열을 인수로 사용하고 모든 요소의 합계를 반환하는 sum &lt;code&gt;sum()&lt;/code&gt; 함수를 만들려면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="87baea849532b922b02e9b36d55dcf711039c24a" translate="yes" xml:space="preserve">
          <source>The Underscore js Way</source>
          <target state="translated">밑줄 js 방법</target>
        </trans-unit>
        <trans-unit id="02b44d265370739617a71ecd63227d93c6676625" translate="yes" xml:space="preserve">
          <source>The above example creates a variable called &lt;code&gt;secondName&lt;/code&gt; from the &lt;code&gt;name&lt;/code&gt; key from an array called &lt;code&gt;items&lt;/code&gt;, the lonely &lt;code&gt;,&lt;/code&gt; says skip the first object in the array.</source>
          <target state="translated">위의 예제는 &lt;code&gt;items&lt;/code&gt; 라는 배열의 배열에서 &lt;code&gt;name&lt;/code&gt; 키에서 &lt;code&gt;secondName&lt;/code&gt; 이라는 변수를 만듭니다. 배열은 배열의 첫 번째 객체를 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="f564d08e3ef27ff8ec50b9e4201c532b7f5ead34" translate="yes" xml:space="preserve">
          <source>The difference between the first and second option is that in the &lt;strong&gt;Opt 1&lt;/strong&gt; if you have one of the properties missing (undefined) in the path you don't get an error, it returns you the third parameter.</source>
          <target state="translated">첫 번째 옵션과 두 번째 옵션의 차이점은 &lt;strong&gt;옵션 1&lt;/strong&gt; 에서 오류가 발생하지 않은 경로에 누락 된 (정의되지 않은) 속성 중 하나가 있으면 세 번째 매개 변수를 반환한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ce5f176bd08d85341c79d5a125f2aa823648c1d8" translate="yes" xml:space="preserve">
          <source>The easiest and the cleanest way is to use Oliver Steele's nested object access pattern</source>
          <target state="translated">가장 쉽고 깨끗한 방법은 Oliver Steele의 중첩 된 객체 액세스 패턴을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d78353eefe17d2875f09374f4d098adbece8da68" translate="yes" xml:space="preserve">
          <source>The path is a way to say: First take the object with key &lt;code&gt;items&lt;/code&gt;, which happens to be an array. Then take the &lt;code&gt;1&lt;/code&gt;-st element (0 index arrays). Last take the object with key &lt;code&gt;name&lt;/code&gt; in that array element, which happens to be the string &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">경로는 말할 수있는 방법입니다. 먼저 키 &lt;code&gt;items&lt;/code&gt; 이있는 객체를 가져 오십시오. 그런 다음 &lt;code&gt;1&lt;/code&gt; 번째 요소 (0 개의 인덱스 배열)를 가져옵니다. 마지막으로 해당 배열 요소에서 키 &lt;code&gt;name&lt;/code&gt; 을 가진 객체를 가져옵니다.이 문자열은 string &lt;code&gt;bar&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f60727501ed0b0f71f29309fe28174d990a1a9da" translate="yes" xml:space="preserve">
          <source>The value is an array, to access its second element, we have to use bracket notation:</source>
          <target state="translated">값은 배열이며, 두 번째 요소에 액세스하려면 대괄호 표기법을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="0de40644ab3a8659c7ba0625cf4b76fa463b082b" translate="yes" xml:space="preserve">
          <source>There is also an excellent type handling minimal library &lt;a href=&quot;https://www.npmjs.com/package/typy&quot;&gt;typy&lt;/a&gt; that does all this for you.</source>
          <target state="translated">또한이 모든 것을 수행하는 최소한의 라이브러리 &lt;a href=&quot;https://www.npmjs.com/package/typy&quot;&gt;typy&lt;/a&gt; 를 처리하는 훌륭한 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a997c0df5cc6afc6f8f4bc954c694fb5e330ab" translate="yes" xml:space="preserve">
          <source>There's also a &lt;code&gt;single&lt;/code&gt; and a &lt;code&gt;singleOrDefault&lt;/code&gt; they work much like &lt;code&gt;first&lt;/code&gt;and &lt;code&gt;firstOrDefault&lt;/code&gt;respectively. The only difference is that they will throw if &lt;em&gt;more&lt;/em&gt; than one match is found.</source>
          <target state="translated">또한 &lt;code&gt;single&lt;/code&gt; 및 &lt;code&gt;firstOrDefault&lt;/code&gt; 각각 &lt;code&gt;first&lt;/code&gt; 및 firstOrDefault 와 매우 유사합니다. 유일한 차이점은 &lt;em&gt;둘&lt;/em&gt; 이상의 일치하는 것이 발견되면 던질 것입니다.</target>
        </trans-unit>
        <trans-unit id="cdca53564527cc4c83a547761777bdaaefd265a9" translate="yes" xml:space="preserve">
          <source>This is just plain JavaScript, without using any third party libraries like jQuery or lodash.</source>
          <target state="translated">이것은 jQuery 또는 lodash와 같은 타사 라이브러리를 사용하지 않고 일반 JavaScript입니다.</target>
        </trans-unit>
        <trans-unit id="613d7e71a59cf49fd334373087cf8a7f7d514dbc" translate="yes" xml:space="preserve">
          <source>This is very brief intro to your specific use case, destructuring can be an unusual syntax to get used to at first. I'd recommend reading &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;Mozilla's Destructuring Assignment documentation&lt;/a&gt; to learn more.</source>
          <target state="translated">이것은 특정 유스 케이스에 대한 매우 간단한 소개이며, 처음에는 파괴적인 구문이 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;Mozilla의 Destructuring Assignment 문서&lt;/a&gt; 를 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ca207417a9a4489be238e24e5dc9eee14df4e603" translate="yes" xml:space="preserve">
          <source>This question is quite old, so as a contemporary update. With the onset of ES2015 there are alternatives to get a hold of the data you require. There is now a feature called &lt;strong&gt;object destructuring&lt;/strong&gt; for accessing nested objects.</source>
          <target state="translated">이 질문은 현대의 업데이트로 꽤 오래되었습니다. ES2015가 시작되면서 필요한 데이터를 확보 할 수있는 대안이 있습니다. 중첩 된 객체에 액세스하기위한 &lt;strong&gt;객체&lt;/strong&gt; 구조 해제 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b859db7c9baac7342be4c399fa4268d64580a50" translate="yes" xml:space="preserve">
          <source>This tells us that &lt;code&gt;data.items[1]&lt;/code&gt; is an object, and after expanding it we see that it has three properties, &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;__proto__&lt;/code&gt;. The latter is an internal property used for the prototype chain of the object. The prototype chain and inheritance is out of scope for this answer, though.</source>
          <target state="translated">이것은 &lt;code&gt;data.items[1]&lt;/code&gt; 가 객체라는 것을 알려주고 , 그것을 확장 한 후에는 &lt;code&gt;id&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; 및 &lt;code&gt;__proto__&lt;/code&gt; 의 세 가지 속성이 있음을 알 수 있습니다. 후자는 객체의 프로토 타입 체인에 사용되는 내부 속성입니다. 그러나 프로토 타입 체인과 상속은이 답변의 범위를 벗어납니다.</target>
        </trans-unit>
        <trans-unit id="664137228398b0d17707a75bb9baa1603f7c4873" translate="yes" xml:space="preserve">
          <source>This value is an object and we use dot notation again to access the &lt;code&gt;name&lt;/code&gt; property. So we eventually get:</source>
          <target state="translated">이 값은 객체이며 점 속성을 다시 사용하여 &lt;code&gt;name&lt;/code&gt; 속성에 액세스합니다. 결국 우리는 다음을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="9768ca2740c20ae8117706d5dc8fead7bf0b3e46" translate="yes" xml:space="preserve">
          <source>To access a nested attribute, you need to specify its name and then search through the object.</source>
          <target state="translated">중첩 된 속성에 액세스하려면 이름을 지정한 다음 객체를 검색해야합니다.</target>
        </trans-unit>
        <trans-unit id="56e3fdff87ae9f0ae61a5a84dce9e283d8be9946" translate="yes" xml:space="preserve">
          <source>To be able to access nested arrays, you can write your own array reduce util.</source>
          <target state="translated">중첩 배열에 액세스하려면 자신의 array reduce util을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49f8a91e4cfa2d6b3229f29def0311f69307f574" translate="yes" xml:space="preserve">
          <source>To iterate over all elements of the &lt;code&gt;data.items&lt;/code&gt;&lt;strong&gt;array&lt;/strong&gt;, we use a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">&lt;code&gt;data.items&lt;/code&gt; &lt;strong&gt;배열&lt;/strong&gt; 의 모든 요소를 ​​반복하기 위해 &lt;code&gt;for&lt;/code&gt; 루프를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6c1ce5587a33fa10b3413df43f4e8e8a4dae0d1e" translate="yes" xml:space="preserve">
          <source>To iterate over all properties of &lt;code&gt;data&lt;/code&gt;, we can iterate over the &lt;strong&gt;object&lt;/strong&gt; like so:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 의 모든 속성을 반복하기 위해 다음과 같이 &lt;strong&gt;객체를&lt;/strong&gt; 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b2df20f42b29bf3e20fea1c0b9e55f35846c2b6" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt;&lt;code&gt;console.log&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt;&lt;code&gt;console.dir&lt;/code&gt;&lt;/a&gt; and inspect the structure of object / array. The property you are trying to access might be actually defined on a nested object / array.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt; &lt;code&gt;console.log&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt; &lt;code&gt;console.dir&lt;/code&gt; 을&lt;/a&gt; 사용하여 객체 / 배열의 구조를 검사하십시오. 액세스하려는 속성이 실제로 중첩 된 객체 / 배열에 정의되어있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="72f0f0ca7535a2f887b045ea5d0ca8f48ce694a9" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;JSONPath&lt;/strong&gt; would be one of the most flexible solutions if you are willing to include a library:
&lt;a href=&quot;https://github.com/s3u/JSONPath&quot;&gt;https://github.com/s3u/JSONPath&lt;/a&gt; (node and browser)</source>
          <target state="translated">라이브러리를 포함 &lt;strong&gt;시키려는 경우 JSONPath를&lt;/strong&gt; 사용 &lt;strong&gt;하는&lt;/strong&gt; 것이 가장 유연한 솔루션 중 하나입니다. &lt;a href=&quot;https://github.com/s3u/JSONPath&quot;&gt;https://github.com/s3u/JSONPath&lt;/a&gt; (노드 및 브라우저)</target>
        </trans-unit>
        <trans-unit id="dd203328bc98a927636df7b5efb2d4b1ffa6e6f4" translate="yes" xml:space="preserve">
          <source>Wait... what about JSON?</source>
          <target state="translated">잠깐만 ... JSON은 어떻습니까?</target>
        </trans-unit>
        <trans-unit id="3e274725ac7462274d545e66a9e93ca5ef1df972" translate="yes" xml:space="preserve">
          <source>What if the &quot;depth&quot; of the data structure is unknown to me?</source>
          <target state="translated">데이터 구조의 &quot;깊이&quot;를 모르면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="0fff2ae2dbc525ac2a28a45db0cb87ff3327df68" translate="yes" xml:space="preserve">
          <source>What if the property names are dynamic and I don't know them beforehand?</source>
          <target state="translated">속성 이름이 동적이고 미리 알 수 없으면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="33d729be609d12f4e50fd456f76e8b7cce6707b0" translate="yes" xml:space="preserve">
          <source>When you don't know the exact name before hand, or a user is the one who provides the name for you. Then dynamically searching through the data structure is required. Some suggested here that the search can be done using a &lt;code&gt;for&lt;/code&gt; loop, but there is a very simple way to traverse a path using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt;&lt;code&gt;Array.reduce&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사전에 정확한 이름을 모르거나 사용자가 이름을 제공 한 사람인 경우. 그런 다음 데이터 구조를 통한 동적 검색이 필요합니다. 여기에서는 &lt;code&gt;for&lt;/code&gt; 루프를 사용하여 검색을 수행 할 수 있다고 제안했지만 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt; &lt;code&gt;Array.reduce&lt;/code&gt; &lt;/a&gt; 사용하여 경로를 탐색하는 매우 간단한 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="afd41e005ac69d70994393c4db3fa04d17c51a06" translate="yes" xml:space="preserve">
          <source>Which is a JavaScript library that provides a whole mess of useful &lt;code&gt;functional programming&lt;/code&gt; helpers without extending any built-in objects.</source>
          <target state="translated">기본 제공 객체를 확장하지 않고도 유용한 &lt;code&gt;functional programming&lt;/code&gt; 도우미를 완전히 엉망으로 만드는 JavaScript 라이브러리입니다.</target>
        </trans-unit>
        <trans-unit id="426bb082ff6e5896064dd959ec8bae3683981cd9" translate="yes" xml:space="preserve">
          <source>With the increasing browser support of ECMAScript 5, the array method &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;forEach&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; becomes an interesting alternative as well:</source>
          <target state="translated">ECMAScript 5의 브라우저 지원이 증가함에 따라 각 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;em&gt;&lt;sup&gt;[MDN]에&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 대한 배열 방법도 흥미로운 대안이되었습니다.</target>
        </trans-unit>
        <trans-unit id="6e0bb43e7e58f1dccb01b724584c7e815f5113e7" translate="yes" xml:space="preserve">
          <source>With this notation, you'll never run into</source>
          <target state="translated">이 표기법으로, 당신은 절대로 실행되지 않습니다</target>
        </trans-unit>
        <trans-unit id="23f0d329dcf4a9e1c2a145121c1a0c7cebda6e99" translate="yes" xml:space="preserve">
          <source>Working fiddle: &lt;a href=&quot;https://jsfiddle.net/andreitodorut/3mws3kjL/&quot;&gt;https://jsfiddle.net/andreitodorut/3mws3kjL/&lt;/a&gt;</source>
          <target state="translated">일 바이올린 : &lt;a href=&quot;https://jsfiddle.net/andreitodorut/3mws3kjL/&quot;&gt;https://jsfiddle.net/andreitodorut/3mws3kjL/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df5a94f92bfe3900361a91260e60682f362b48ec" translate="yes" xml:space="preserve">
          <source>Working with Objects</source>
          <target state="translated">객체 작업</target>
        </trans-unit>
        <trans-unit id="4497254d63e510893ef09f0c7afb22fec75a65de" translate="yes" xml:space="preserve">
          <source>You basically check if user exists, if not, you create an empty object on the fly. This way, the next level key will &lt;strong&gt;always be accessed from an object that exists or an empty object&lt;/strong&gt;, but never from undefined.</source>
          <target state="translated">기본적으로 사용자가 존재하는지 확인하고 그렇지 않은 경우 즉시 빈 개체를 만듭니다. 이런 식으로 다음 레벨 키는 &lt;strong&gt;항상 존재하는 객체 또는 빈 객체&lt;/strong&gt; 에서 액세스되지만 정의되지 않은 &lt;strong&gt;객체&lt;/strong&gt; 에서는 &lt;strong&gt;액세스&lt;/strong&gt; 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17f3f05296a9f74d4837489378560984a26833b0" translate="yes" xml:space="preserve">
          <source>You can access it this way</source>
          <target state="translated">이 방법으로 액세스 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="cfa469e890d94b193d15281607d34ec28b836ae7" translate="yes" xml:space="preserve">
          <source>You can use the syntax &lt;code&gt;jsonObject.key&lt;/code&gt; to access the the value. And if you want access a value from an array, then you can use the syntax &lt;code&gt;jsonObjectArray[index].key&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;jsonObject.key&lt;/code&gt; 구문을 사용하여 값에 액세스 할 수 있습니다. 배열에서 값에 액세스하려면 &lt;code&gt;jsonObjectArray[index].key&lt;/code&gt; 구문을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c57e8d7f2d3c9338d66a6c78ba4fcafd728a6f7" translate="yes" xml:space="preserve">
          <source>You could use &lt;code&gt;lodash _get&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;lodash _get&lt;/code&gt; 함수를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a87503c2fa7c97664a81fd80a5702f7d91e2b3b" translate="yes" xml:space="preserve">
          <source>for further explanation of query-js you can start with this &lt;a href=&quot;http://runefs.com/2015/06/04/working-with-data-in-javascript/&quot;&gt;post&lt;/a&gt;</source>
          <target state="translated">query-js에 대한 자세한 설명은이 &lt;a href=&quot;http://runefs.com/2015/06/04/working-with-data-in-javascript/&quot;&gt;게시물로&lt;/a&gt; 시작할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="7ac01203eeb458726d789e7d2607af95159fd2ed" translate="yes" xml:space="preserve">
          <source>or &lt;strong&gt;bracket notation&lt;/strong&gt;, if the property name would not be a valid JavaScript &lt;a href=&quot;http://es5.github.com/#x7.6&quot;&gt;identifier name &lt;em&gt;&lt;sup&gt;[spec]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;, or the name is the value of a variable:</source>
          <target state="translated">속성 이름이 유효한 JavaScript &lt;a href=&quot;http://es5.github.com/#x7.6&quot;&gt;식별자 이름 &lt;em&gt;&lt;sup&gt;[spec]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; 이 아니거나 이름이 변수의 값인 경우 &lt;strong&gt;대괄호 표기법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="af3ec5b75c689d26309f57c2989dae794c7b17cd" translate="yes" xml:space="preserve">
          <source>same as:</source>
          <target state="translated">다음과 동일</target>
        </trans-unit>
        <trans-unit id="3bdb8452054fa2b577dec841756010a549232d09" translate="yes" xml:space="preserve">
          <source>so:</source>
          <target state="translated">so:</target>
        </trans-unit>
        <trans-unit id="560572a782680d5c66f76b07c8f3ba5b61030e77" translate="yes" xml:space="preserve">
          <source>these also work -</source>
          <target state="translated">이것들도 작동합니다-</target>
        </trans-unit>
        <trans-unit id="c86c30365c1ce95f0ba082ac38ab0704ccf05de4" translate="yes" xml:space="preserve">
          <source>to add to this, accessing nested Arrays would happen like so:</source>
          <target state="translated">이것에 추가하려면 중첩 배열에 액세스하면 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="612f40ac9069ed110eabdcfa125d119cd7f891bf" translate="yes" xml:space="preserve">
          <source>where &lt;em&gt;data&lt;/em&gt; is a python list (parsed from a JSON text string):</source>
          <target state="translated">여기서 &lt;em&gt;데이터&lt;/em&gt; 는 파이썬 목록입니다 (JSON 텍스트 문자열에서 구문 분석 됨).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
