<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/11922383">
    <body>
      <group id="11922383">
        <trans-unit id="b9d7ae0596fa1b6e804b7403306ad6e7b605efaa" translate="yes" xml:space="preserve">
          <source>(Plain) Objects have the form</source>
          <target state="translated">Объекты имеют форму</target>
        </trans-unit>
        <trans-unit id="5a44941be43e076ddb71539916eacc34663abeff" translate="yes" xml:space="preserve">
          <source>1. Oliver Steele's nested object access pattern</source>
          <target state="translated">1.Вложенный шаблон доступа Оливера Стила к объектам.</target>
        </trans-unit>
        <trans-unit id="ed8b403487c125d1961eab9ebb74e25ab570a5a1" translate="yes" xml:space="preserve">
          <source>2. Access Nested Objects Using Array Reduce</source>
          <target state="translated">2.Доступ к вложенным объектам с помощью массива Сократить</target>
        </trans-unit>
        <trans-unit id="ad74c01cfd52ca2cf56ce6a6598aa7ac314201eb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://api.jquery.com/jQuery.grep/&quot;&gt;jQuery's grep&lt;/a&gt; function lets you filter through an array:</source>
          <target state="translated">Функция &lt;a href=&quot;https://api.jquery.com/jQuery.grep/&quot;&gt;grep в jQuery&lt;/a&gt; позволяет фильтровать массив:</target>
        </trans-unit>
        <trans-unit id="be0ce6e993ffb8eff08543817b70124c314607a2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every&quot;&gt;&lt;code&gt;Array.prototype.every()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;&lt;code&gt;Array.prototype.some()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every&quot;&gt; &lt;code&gt;Array.prototype.every()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt; &lt;code&gt;Array.prototype.some()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2ec576c3eb3b38eee1c21db4e00aaa38a6217f1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt;&lt;code&gt;Array.prototype.find()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt;&lt;code&gt;Array.prototype.filter()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt; &lt;code&gt;Array.prototype.find()&lt;/code&gt; &lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt; &lt;code&gt;Array.prototype.filter()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="556ef4bccc10401c80f3faacf4016eec1e577dda" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;&lt;code&gt;Object.keys()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values&quot;&gt;&lt;code&gt;Object.values()&lt;/code&gt;&lt;/a&gt; (ES 2017) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt;&lt;code&gt;Object.entries()&lt;/code&gt;&lt;/a&gt; (ES 2017)</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt; &lt;code&gt;Object.keys()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values&quot;&gt; &lt;code&gt;Object.values()&lt;/code&gt; &lt;/a&gt; (ES 2017) и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt; &lt;code&gt;Object.entries()&lt;/code&gt; &lt;/a&gt; (ES 2017)</target>
        </trans-unit>
        <trans-unit id="111884d6e8ac53f873a2d04671b8f49d0bca3d45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.entries()&lt;/code&gt; with a for-of loop and destructuring assignment</source>
          <target state="translated">&lt;code&gt;Object.entries()&lt;/code&gt; с циклом for и назначением деструктурирования</target>
        </trans-unit>
        <trans-unit id="4def2b05926df9dbc0358ffc483d09a93c29d777" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.keys()&lt;/code&gt; returns an array of object's keys, &lt;code&gt;Object.values()&lt;/code&gt; returns an array of object's values, and &lt;code&gt;Object.entries()&lt;/code&gt; returns an array of object's keys and corresponding values in a format &lt;code&gt;[key, value]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Object.keys()&lt;/code&gt; возвращает массив ключей объекта, &lt;code&gt;Object.values()&lt;/code&gt; возвращает массив значений объекта, а &lt;code&gt;Object.entries()&lt;/code&gt; возвращает массив ключей объекта и соответствующих значений в формате &lt;code&gt;[key, value]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fb5d351b0ef54c549d915337ae5b658f2a714d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var obj=JSON.parse(stringjson);&lt;/code&gt; 
so after that i get &lt;code&gt;message&lt;/code&gt; obj and show in alert box then I get &lt;code&gt;data&lt;/code&gt; which is json array and store in one varible &lt;code&gt;ArrObj&lt;/code&gt; then i read first object of that array with key value like this &lt;code&gt;ArrObj[0].id&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;var obj=JSON.parse(stringjson);&lt;/code&gt; поэтому после этого я получаю &lt;code&gt;message&lt;/code&gt; obj и показываю в окне предупреждения, затем я получаю &lt;code&gt;data&lt;/code&gt; которые являются массивом json, и сохраняю их в одну переменную &lt;code&gt;ArrObj&lt;/code&gt; , затем я читаю первый объект этого массива со значением ключа, таким как &lt;code&gt;ArrObj[0].id&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="070baa4293f4df5a2e7819f8e151c13553b4cf63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Cannot read property 'foo' of undefined&lt;/em&gt; error</source>
          <target state="translated">&lt;em&gt;Невозможно прочитать свойство 'foo' с неопределенной&lt;/em&gt; ошибкой</target>
        </trans-unit>
        <trans-unit id="8f506e37dc0630fb98bd6b1ce619c7a3a830b1c8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Cannot read property 'name' of undefined&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;Невозможно прочитать свойство 'имя' из неопределенного&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="f04b39aa9e617f5727bbea03e1c5dcbc50d15900" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Arrays&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa0a7c98ac6e1fb3f4f08f9978cf161c1556d0de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Objects&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7383b9e7b2d0d2accbf17b8da579fecc7fcac42f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Opt 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Опция 1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a563acfca1a6fd144c9efcd226f8991db8016ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Opt 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Опция 2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9daf94b0dddd46befa283cfcbbe9c25a98f3329e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using lodash would be good solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Использование lodash было бы хорошим решением&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="816a9c6c3ff8b608fc4422ee03bed6a523957af9" translate="yes" xml:space="preserve">
          <source>A more generic way to access a nested data structure with unknown keys and depth is to test the type of the value and act accordingly.</source>
          <target state="translated">Более общим способом доступа к вложенной структуре данных с неизвестными ключами и глубиной является проверка типа значения и соответствующие действия.</target>
        </trans-unit>
        <trans-unit id="f39295fd4534982211264eee2ad1c31977f1c84d" translate="yes" xml:space="preserve">
          <source>A nested data structure is an array or object which refers to other arrays or objects, i.e. its values are arrays or objects. Such structures can be accessed by consecutively applying dot or bracket notation.</source>
          <target state="translated">Вложенная структура данных-это массив или объект,который относится к другим массивам или объектам,т.е.его значения-это массивы или объекты.Доступ к таким структурам можно получить,последовательно применяя нотацию в виде точки или скобки.</target>
        </trans-unit>
        <trans-unit id="afddb60a392d86e966d777e444f6d6456fe9e388" translate="yes" xml:space="preserve">
          <source>A pythonic, recursive and functional approach to unravel arbitrary JSON trees:</source>
          <target state="translated">Питонический,рекурсивный и функциональный подход к распутыванию произвольных JSON-деревьев:</target>
        </trans-unit>
        <trans-unit id="4cc2f66e7372b97d6294942a2e488694268c58fd" translate="yes" xml:space="preserve">
          <source>Accessing dynamically multi levels object.</source>
          <target state="translated">Доступ к динамическому многоуровневому объекту.</target>
        </trans-unit>
        <trans-unit id="28db033c076db7cbec4550f7d75c73b992db4b1c" translate="yes" xml:space="preserve">
          <source>Accessing nested data structures</source>
          <target state="translated">Доступ к вложенным структурам данных</target>
        </trans-unit>
        <trans-unit id="9161e0e95a7f4324a52451db1abf9bc546febaf6" translate="yes" xml:space="preserve">
          <source>Alternatively, we could have used bracket notation for any of the properties, especially if the name contained characters that would have made it invalid for dot notation usage:</source>
          <target state="translated">Кроме того,мы могли бы использовать нотацию в скобках для любого из свойств,особенно если имя содержало символы,которые делали бы его недействительным для использования точечной нотации:</target>
        </trans-unit>
        <trans-unit id="fe486bc1dc5fa2c8ed6de19ba7d46122f46fbdaf" translate="yes" xml:space="preserve">
          <source>And you know you want to get the first result of the array in the object, perhaps you would like to use</source>
          <target state="translated">И вы знаете,что хотите получить первый результат массива в объекте,возможно,вы захотите использовать</target>
        </trans-unit>
        <trans-unit id="ace6ce8ebfeb347b804bad250d4e5995ef0f42f2" translate="yes" xml:space="preserve">
          <source>Another more useful document depicting the situation above: 
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&quot;&gt;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&lt;/a&gt;</source>
          <target state="translated">Еще один полезный документ, описывающий ситуацию выше: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&quot;&gt;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="41dda5572bc7dcd447232d111646168caca0a537" translate="yes" xml:space="preserve">
          <source>Arrays have the form</source>
          <target state="translated">Массивы имеют форму</target>
        </trans-unit>
        <trans-unit id="9c633aa3bac6977948ff0408055fe2896e6370e1" translate="yes" xml:space="preserve">
          <source>As alternative to &lt;code&gt;for...in&lt;/code&gt; with &lt;code&gt;hasOwnProperty&lt;/code&gt;, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;&lt;code&gt;Object.keys&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; to get an &lt;em&gt;array of property names&lt;/em&gt;:</source>
          <target state="translated">В качестве альтернативы &lt;code&gt;for...in&lt;/code&gt; с &lt;code&gt;hasOwnProperty&lt;/code&gt; вы можете использовать &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt; &lt;code&gt;Object.keys&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; для получения &lt;em&gt;массива имен свойств&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="fbe0dbbc73fe9040a9866aed9948b4db98994376" translate="yes" xml:space="preserve">
          <source>As we can see &lt;code&gt;data&lt;/code&gt; is an object, hence we can access its properties using dot notation. The &lt;code&gt;items&lt;/code&gt; property is accessed as follows:</source>
          <target state="translated">Как мы видим, &lt;code&gt;data&lt;/code&gt; - это объект, поэтому мы можем получить доступ к его свойствам, используя точечную запись. Свойство &lt;code&gt;items&lt;/code&gt; доступно следующим образом:</target>
        </trans-unit>
        <trans-unit id="fdec08a847a97bcd4c07dcbb2caf3c16dcf80b54" translate="yes" xml:space="preserve">
          <source>As you can see, destructuring makes this a lot simpler.</source>
          <target state="translated">Как видите,разрушение делает это намного проще.</target>
        </trans-unit>
        <trans-unit id="f772e09632917ff307133b29957a65855dd122d7" translate="yes" xml:space="preserve">
          <source>At times, accessing a nested object using a string can be desirable. The simple approach is the first level, for example</source>
          <target state="translated">Иногда бывает желательно получить доступ к вложенному объекту с помощью строки.Простой подход-это первый уровень,например.</target>
        </trans-unit>
        <trans-unit id="3ca8a39547fd839bf865328c29404e1afe375865" translate="yes" xml:space="preserve">
          <source>Basically, use a dot between each descendant that unfolds underneath it and when you have object names made out of two strings, you must use the [&quot;obj Name&quot;] notation. Otherwise, just a dot would suffice;</source>
          <target state="translated">В основном,используйте точку между каждым потомком,которая разворачивается под ним,и когда у вас есть имена объектов,сделанные из двух строк,вы должны использовать нотацию [&quot;Объект Имя&quot;].В противном случае,достаточно просто поставить точку;</target>
        </trans-unit>
        <trans-unit id="b101422364275a2e30072a8796b25a5d9cf9af98" translate="yes" xml:space="preserve">
          <source>Both arrays and objects expose a &lt;code&gt;key -&amp;gt; value&lt;/code&gt; structure. Keys in an array must be numeric, whereas any string can be used as key in objects. The key-value pairs are also called the &lt;strong&gt;&quot;properties&quot;&lt;/strong&gt;.</source>
          <target state="translated">И массивы, и объекты предоставляют структуру &lt;code&gt;key -&amp;gt; value&lt;/code&gt; . Ключи в массиве должны быть числовыми, тогда как любая строка может использоваться в качестве ключа в объектах. Пары ключ-значение также называются &lt;strong&gt;&amp;laquo;свойствами&amp;raquo;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="cc5a260ab7f1841e1aba3a2ebbfd1f3271fcf519" translate="yes" xml:space="preserve">
          <source>Both ways are equal.</source>
          <target state="translated">Оба пути равны.</target>
        </trans-unit>
        <trans-unit id="fdd103fb4c1dabaa12e40a9fcdc5f9af7f3c871a" translate="yes" xml:space="preserve">
          <source>But if the data structure contains repeating patterns, e.g. the representation of a binary tree, the solution typically includes to &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29&quot;&gt;&lt;strong&gt;recursively&lt;/strong&gt; &lt;em&gt;&lt;sup&gt;[Wikipedia]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; access each level of the data structure.</source>
          <target state="translated">Но если структура данных содержит повторяющиеся шаблоны, например, представление двоичного дерева, решение обычно включает в себя &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29&quot;&gt;&lt;strong&gt;рекурсивный&lt;/strong&gt;&lt;/a&gt; доступ к каждому уровню структуры данных.</target>
        </trans-unit>
        <trans-unit id="4d8f4d28d7d10eb511ab35f3d5ff0db1a6e70ca1" translate="yes" xml:space="preserve">
          <source>But this is often not the case with complex json. As json becomes more complex, the approaches for finding values inside of the json also become complex. A recursive approach for navigating the json is best, and how that recursion is leveraged will depend on the type of data being searched for. If there are conditional statements involved, a &lt;a href=&quot;https://stackoverflow.com/a/11657379/1026459&quot;&gt;json search&lt;/a&gt; can be a good tool to use.</source>
          <target state="translated">Но это часто не так со сложным JSON. Поскольку json становится все более сложным, подходы для нахождения значений внутри json также становятся сложными. Рекурсивный подход для навигации по json лучше всего, и то, как эта рекурсия будет использоваться, будет зависеть от типа данных, которые ищутся. Если есть условные операторы, &lt;a href=&quot;https://stackoverflow.com/a/11657379/1026459&quot;&gt;поиск json&lt;/a&gt; может быть хорошим инструментом для использования.</target>
        </trans-unit>
        <trans-unit id="7d269dca449b2b51321c86807f7284ab602821d8" translate="yes" xml:space="preserve">
          <source>Depending on where the object comes from (and what you want to do), you might have to test in each iteration whether the property is really a property of the object, or it is an inherited property. You can do this with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;&lt;code&gt;Object#hasOwnProperty&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">В зависимости от того, откуда берется объект (и что вы хотите сделать), вам может потребоваться проверить на каждой итерации, является ли свойство действительно свойством объекта или унаследованным свойством. Вы можете сделать это с &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt; &lt;code&gt;Object#hasOwnProperty&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64569aad96916652199eeb6b944efa9a5c953da7" translate="yes" xml:space="preserve">
          <source>Destructuring assignment lets you extract values from an array or an object and assign them to variables. In this case &lt;code&gt;const [key, value]&lt;/code&gt; means that instead of assigning the &lt;code&gt;[key, value]&lt;/code&gt; array to &lt;code&gt;element&lt;/code&gt;, we assign the first element of that array to &lt;code&gt;key&lt;/code&gt; and the second element to &lt;code&gt;value&lt;/code&gt;. It is equivalent to this:</source>
          <target state="translated">Разрушающее присваивание позволяет извлекать значения из массива или объекта и назначать их переменным. В этом случае &lt;code&gt;const [key, value]&lt;/code&gt; означает, что вместо назначения массива &lt;code&gt;[key, value]&lt;/code&gt; &lt;code&gt;element&lt;/code&gt; мы присваиваем первый элемент этого массива &lt;code&gt;key&lt;/code&gt; а второй элемент - &lt;code&gt;value&lt;/code&gt; . Это эквивалентно этому:</target>
        </trans-unit>
        <trans-unit id="02dc9a66286816111e66fbe036cefc9f91ca21cc" translate="yes" xml:space="preserve">
          <source>Dynamic approach</source>
          <target state="translated">Динамичный подход</target>
        </trans-unit>
        <trans-unit id="0d2de250773511a1ad80d3f98de046259307b9a4" translate="yes" xml:space="preserve">
          <source>Eloquent JavaScript - Data Structures</source>
          <target state="translated">Eloquent JavaScript-Структуры данных</target>
        </trans-unit>
        <trans-unit id="2ede17026a66f2bb53f3b6978daa3529c4d3bc25" translate="yes" xml:space="preserve">
          <source>Ex:</source>
          <target state="translated">Ex:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="3b9c2a54ba734b7b8b4978d83e1db213972ac579" translate="yes" xml:space="preserve">
          <source>For array filter lodash has &lt;code&gt;_.find()&lt;/code&gt; but I'd rather use the regular &lt;code&gt;filter()&lt;/code&gt;. But I still think the above method &lt;code&gt;_.get()&lt;/code&gt; is super useful when working with really complex data. I faced in the past really complex APIs and it was handy!</source>
          <target state="translated">Для фильтра массива в lodash есть &lt;code&gt;_.find()&lt;/code&gt; но я бы лучше использовал обычный &lt;code&gt;filter()&lt;/code&gt; . Но я все еще думаю, что приведенный выше метод &lt;code&gt;_.get()&lt;/code&gt; очень полезен при работе с действительно сложными данными. В прошлом я сталкивался с действительно сложными API, и это было удобно!</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="445d1e6104f5820cabec109fcf1319f71f1065d0" translate="yes" xml:space="preserve">
          <source>For that reason, array elements can only be accessed using bracket notation:</source>
          <target state="translated">По этой причине доступ к элементам массива возможен только с помощью нотации в скобках:</target>
        </trans-unit>
        <trans-unit id="d5a825881321ee3e4e37abb15f70df07dcb95713" translate="yes" xml:space="preserve">
          <source>For your use case the json path would be:</source>
          <target state="translated">В вашем случае,это будет путь Джсона:</target>
        </trans-unit>
        <trans-unit id="9eef871033ae2b01fb1362a850c9adfc85cc8ebf" translate="yes" xml:space="preserve">
          <source>For-of loop lets you iterate array elements. The syntax is &lt;code&gt;for (const element of array)&lt;/code&gt; (we can replace &lt;code&gt;const&lt;/code&gt; with &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;, but it's better to use &lt;code&gt;const&lt;/code&gt; if we don't intend to modify &lt;code&gt;element&lt;/code&gt;).</source>
          <target state="translated">Цикл For-of позволяет перебирать элементы массива. Синтаксис &lt;code&gt;for (const element of array)&lt;/code&gt; (мы можем заменить &lt;code&gt;const&lt;/code&gt; на &lt;code&gt;var&lt;/code&gt; или &lt;code&gt;let&lt;/code&gt; , но лучше использовать &lt;code&gt;const&lt;/code&gt; , если мы не собираемся изменять &lt;code&gt;element&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0ef664dc5e993d8e597a3f0029cd45095dd4cd66" translate="yes" xml:space="preserve">
          <source>From my experience, using higher order functions instead of &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;for..in&lt;/code&gt; loops results in code that is easier to reason about, and hence more maintainable.</source>
          <target state="translated">Исходя из моего опыта, использование функций более высокого порядка вместо циклов &lt;code&gt;for&lt;/code&gt; или &lt;code&gt;for..in&lt;/code&gt; приводит к коду, который легче рассуждать и, следовательно, более легко обслуживать.</target>
        </trans-unit>
        <trans-unit id="cf1d3d2922bc105f006fa87beed0df0abfa99f76" translate="yes" xml:space="preserve">
          <source>Further reading material</source>
          <target state="translated">Дополнительный материал для чтения</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="605f0dfa014b0cfc9478e06cb6929a44ac4b18c5" translate="yes" xml:space="preserve">
          <source>Here are the code examples to access various values to give you the idea.</source>
          <target state="translated">Приведем примеры кода для доступа к различным значениям,чтобы дать вам идею.</target>
        </trans-unit>
        <trans-unit id="c1c24498af84d309f0cd97effacb306f537abc11" translate="yes" xml:space="preserve">
          <source>Here is a &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://jsfiddle.net/73172hr0/&quot;&gt;&lt;code&gt;jsFiddle Demo&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; of this approach being used.</source>
          <target state="translated">Вот &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://jsfiddle.net/73172hr0/&quot;&gt; &lt;code&gt;jsFiddle Demo&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; для этого подхода.</target>
        </trans-unit>
        <trans-unit id="eea516510b57f9617ec45edfa85521334718d617" translate="yes" xml:space="preserve">
          <source>Here is an example to get the first leaf node of a binary tree:</source>
          <target state="translated">Приведем пример,чтобы получить первый узел листа двоичного дерева:</target>
        </trans-unit>
        <trans-unit id="8a6cd511416c318ce3118af57082c98e3c27c850" translate="yes" xml:space="preserve">
          <source>Here is an example which adds all primitive values inside a nested data structure into an array (assuming it does not contain any functions). If we encounter an object (or array) we simply call &lt;code&gt;toArray&lt;/code&gt; again on that value (recursive call).</source>
          <target state="translated">Вот пример, который добавляет все примитивные значения внутри вложенной структуры данных в массив (при условии, что он не содержит никаких функций). Если мы сталкиваемся с объектом (или массивом), мы просто снова вызываем &lt;code&gt;toArray&lt;/code&gt; для этого значения (рекурсивный вызов).</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">Вот пример:</target>
        </trans-unit>
        <trans-unit id="925217328e8c6e1d64c87ab4f4335bf5fbdb54c3" translate="yes" xml:space="preserve">
          <source>Here is how we can do it step-by-step:</source>
          <target state="translated">Вот как мы можем сделать это шаг за шагом:</target>
        </trans-unit>
        <trans-unit id="d207069b46269857b00213ef7930f472a4c79665" translate="yes" xml:space="preserve">
          <source>Here we see that that &lt;code&gt;data.items&lt;/code&gt; is an array with two elements which are both objects. In Chrome console the objects can even be expanded and inspected immediately.</source>
          <target state="translated">Здесь мы видим, что этот &lt;code&gt;data.items&lt;/code&gt; является массивом с двумя элементами, которые оба являются объектами. В консоли Chrome объекты могут быть даже расширены и проверены немедленно.</target>
        </trans-unit>
        <trans-unit id="7af11a5669687094fc9c73e62819006759babfc9" translate="yes" xml:space="preserve">
          <source>How can I access and process nested objects, arrays or JSON</source>
          <target state="translated">Как я могу получить доступ и обработать вложенные объекты,массивы или JSON</target>
        </trans-unit>
        <trans-unit id="7c724edbaf2dc46e497eee6c123b2325a46b6a71" translate="yes" xml:space="preserve">
          <source>How could I access the &lt;code&gt;name&lt;/code&gt; of the second item in &lt;code&gt;items&lt;/code&gt;?</source>
          <target state="translated">Как я могу получить доступ к &lt;code&gt;name&lt;/code&gt; второго элемента в &lt;code&gt;items&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="505b1723179035f7490a5348f8afb6ed7fe15dc8" translate="yes" xml:space="preserve">
          <source>How to access arrays and objects is fundamental JavaScript knowledge and therefore it is advisable to read the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide&quot;&gt;MDN JavaScript Guide&lt;/a&gt;, especially the sections</source>
          <target state="translated">Как получить доступ к массивам и объектам, это фундаментальное знание JavaScript, и поэтому желательно прочитать руководство по &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide&quot;&gt;MDN JavaScript&lt;/a&gt; , особенно разделы</target>
        </trans-unit>
        <trans-unit id="eb0d89c8fcff212602dcd6e7fc04c0868e952391" translate="yes" xml:space="preserve">
          <source>However, that will cause an exception as there is no property of object with that name. The solution to be able to use this would be to flatten the tree aspect of the object. This can be done recursively.</source>
          <target state="translated">Однако,это вызовет исключение,так как не существует свойства объекта с таким именем.Решением,которое можно было бы использовать,было бы сгладить древовидный аспект объекта.Это можно сделать рекурсивно.</target>
        </trans-unit>
        <trans-unit id="1d40fcba2ecc0667c34ad4970d750807180f7fa4" translate="yes" xml:space="preserve">
          <source>I don't think questioner just only concern one level nested object, so I present the following demo to demonstrate how to access the node of deeply nested json object. All right, let's find the node with id '5'.</source>
          <target state="translated">Я не думаю,что вопроситель касается только одного уровня вложенного объекта,поэтому я представляю следующую демонстрацию,чтобы продемонстрировать,как получить доступ к узлу глубоко вложенного объекта json.Хорошо,давайте найдем узел с id '5'.</target>
        </trans-unit>
        <trans-unit id="7166a8fbe1b1257a300a599c03346689e3d076f9" translate="yes" xml:space="preserve">
          <source>I have a nested data structure containing objects and arrays. How can I extract the information, i.e. access a specific or multiple values (or keys)?</source>
          <target state="translated">У меня есть вложенная структура данных,содержащая объекты и массивы.Как я могу извлечь информацию,т.е.получить доступ к определенным или множественным значениям (или ключам)?</target>
        </trans-unit>
        <trans-unit id="594c7197f24e01cab50a8fbc4fbff277875b36a9" translate="yes" xml:space="preserve">
          <source>I hope it can be useful for who's looking for options to manipulate really complex data which the title implies.</source>
          <target state="translated">Надеюсь,это может быть полезно для тех,кто ищет опции для манипулирования действительно сложными данными,которые подразумевает название.</target>
        </trans-unit>
        <trans-unit id="296fb090ea76c582b0388c3ac82a7e3be47e1379" translate="yes" xml:space="preserve">
          <source>I prefer JQuery. It's cleaner and easy to read.</source>
          <target state="translated">Я предпочитаю JQuery.Она чище и легче читается.</target>
        </trans-unit>
        <trans-unit id="3f0e47884848a0f215b6b29d1c59ca91e00210de" translate="yes" xml:space="preserve">
          <source>I'm trying to access a property but I get only &lt;code&gt;undefined&lt;/code&gt; back?</source>
          <target state="translated">Я пытаюсь получить доступ к свойству, но получаю только &lt;code&gt;undefined&lt;/code&gt; обратно?</target>
        </trans-unit>
        <trans-unit id="98da6135d533ae58636b970eb90d9ba4730fc07c" translate="yes" xml:space="preserve">
          <source>If the property being accessed is already known, but the path is complex, for example in this object</source>
          <target state="translated">Если доступное свойство уже известно,но путь сложен,например,в этом объекте</target>
        </trans-unit>
        <trans-unit id="724f6164854c1dac5164b9dfe3bd016bf11ede2c" translate="yes" xml:space="preserve">
          <source>If the property names are unknown or we want to access all properties of an object / elements of an array, we can use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;code&gt;for...in&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; loop for objects and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for&quot;&gt;&lt;code&gt;for&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; loop for arrays to iterate over all properties / elements.</source>
          <target state="translated">Если имена свойств неизвестны или мы хотим получить доступ ко всем свойствам объекта / элементов массива, мы можем использовать цикл for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for...in&quot;&gt; &lt;code&gt;for...in&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; для объектов и цикл &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for&quot;&gt; &lt;code&gt;for&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; для массивов, чтобы перебирать все свойства / элементы.</target>
        </trans-unit>
        <trans-unit id="bb53041818a7cd5cefb1a698d8c5cf31a6bcdd25" translate="yes" xml:space="preserve">
          <source>If you already know the exact path, then you can hardcode it in your script like so:</source>
          <target state="translated">Если вы уже знаете точный путь,то можете закодировать его в своем скрипте таким образом:</target>
        </trans-unit>
        <trans-unit id="0860a5a97f7c2d0da5833e9fe22ae22b8354c139" translate="yes" xml:space="preserve">
          <source>If you are looking for one or more objects that meets certain criteria you have a few options using &lt;a href=&quot;https://www.npmjs.com/package/query-js&quot;&gt;query-js&lt;/a&gt;</source>
          <target state="translated">Если вы ищете один или несколько объектов, которые соответствуют определенным критериям, у вас есть несколько вариантов, используя &lt;a href=&quot;https://www.npmjs.com/package/query-js&quot;&gt;query-js&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e3bacf63ad2da6ad497c062e83ee1deb7143a5e" translate="yes" xml:space="preserve">
          <source>If you have a very long path, you might even use &lt;code&gt;String.split&lt;/code&gt; to make all of this easier -</source>
          <target state="translated">Если у вас очень длинный путь, вы можете даже использовать &lt;code&gt;String.split&lt;/code&gt; , чтобы сделать все это проще -</target>
        </trans-unit>
        <trans-unit id="9c57867c2390b8a7a47e20ec0c1f1a52c4e1c717" translate="yes" xml:space="preserve">
          <source>In 2020, you can use @babel/plugin-proposal-optional-chaining it is very easy to access nested values in an object.</source>
          <target state="translated">В 2020 году можно использовать @babelplugin-предложение-опционально-цепочки это очень легко получить доступ к вложенным значениям в объекте.</target>
        </trans-unit>
        <trans-unit id="6eb25090a01eb8f321fc42bfc0d70eaff8d9d9a6" translate="yes" xml:space="preserve">
          <source>In addition to unknown keys, the &quot;depth&quot; of the data structure (i.e. how many nested objects) it has, might be unknown as well. How to access deeply nested properties usually depends on the exact data structure.</source>
          <target state="translated">Кроме неизвестных ключей,может быть неизвестна и &quot;глубина&quot; структуры данных (т.е.сколько вложенных объектов).Как получить доступ к глубоко вложенным свойствам обычно зависит от точной структуры данных.</target>
        </trans-unit>
        <trans-unit id="f62878da4abd5200fcc9c37ddc894fac250f513c" translate="yes" xml:space="preserve">
          <source>In below &lt;code&gt;deep(data,key)&lt;/code&gt; function, you can use arbitrary &lt;code&gt;key&lt;/code&gt; string - in your case &lt;code&gt;items[1].name&lt;/code&gt; (you can use array notation &lt;code&gt;[i]&lt;/code&gt; at any level) - if key is invalid then undefined is return.</source>
          <target state="translated">В более &lt;code&gt;deep(data,key)&lt;/code&gt; вы можете использовать произвольную строку &lt;code&gt;key&lt;/code&gt; - в вашем случае &lt;code&gt;items[1].name&lt;/code&gt; (вы можете использовать обозначение массива &lt;code&gt;[i]&lt;/code&gt; на любом уровне) - если ключ недействителен, то возвращается undefined.</target>
        </trans-unit>
        <trans-unit id="ad27c437934b9b2b1645bf081b9a50483d122ac0" translate="yes" xml:space="preserve">
          <source>In case you are already using lodash in your project, I think an elegant way to do this in a complex example:</source>
          <target state="translated">В случае,если вы уже используете жилье в вашем проекте,я думаю,элегантный способ сделать это в сложном примере:</target>
        </trans-unit>
        <trans-unit id="f33e9b91084a439b4cb911f507dd3f9d0cd299c8" translate="yes" xml:space="preserve">
          <source>In case you're trying to access an &lt;code&gt;item&lt;/code&gt; from the example structure by &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt;, without knowing it's position in the array, the easiest way to do it would be to use &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; library:</source>
          <target state="translated">Если вы пытаетесь получить доступ к &lt;code&gt;item&lt;/code&gt; из структуры примера по &lt;code&gt;id&lt;/code&gt; или &lt;code&gt;name&lt;/code&gt; , не зная его положения в массиве, самый простой способ сделать это - использовать библиотеку &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0605dd9a6ef3a81e1e32ed89e65d051905a18d0b" translate="yes" xml:space="preserve">
          <source>In each iteration, &lt;code&gt;for...of&lt;/code&gt; directly gives us the next element of the iterable, there is no &quot;index&quot; to access or use.</source>
          <target state="translated">В каждой итерации &lt;code&gt;for...of&lt;/code&gt; напрямую дает нам следующий элемент итерируемого, нет &amp;laquo;индекса&amp;raquo; для доступа или использования.</target>
        </trans-unit>
        <trans-unit id="17dc34a7d73c6685088f5609dc9773446daecdd4" translate="yes" xml:space="preserve">
          <source>In environments supporting ES2015 (ES6), you can also use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;em&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; loop, which not only works for arrays, but for any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;&lt;em&gt;iterable&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">В средах, поддерживающих ES2015 (ES6), вы также можете использовать цикл &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;em&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/em&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; , который работает не только для массивов, но и для любых &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;&lt;em&gt;итераций&lt;/em&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e25c3f7d1a9be63d64a7b43f756eced2a48efc4a" translate="yes" xml:space="preserve">
          <source>It's very convenient to iterate the result of &lt;code&gt;Object.entries()&lt;/code&gt; with a &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;for-of loop&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;destructuring assignment&lt;/a&gt;.</source>
          <target state="translated">Очень удобно повторять результат &lt;code&gt;Object.entries()&lt;/code&gt; с &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;циклом for&lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;назначением деструктуризации&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a44b231f533fa321446e7f3e3baee1f38de9626" translate="yes" xml:space="preserve">
          <source>JSON is a textual representation of data, just like XML, YAML, CSV, and others. To work with such data, it first has to be converted to JavaScript data types, i.e. arrays and objects (and how to work with those was just explained). How to parse JSON is explained in the question &lt;a href=&quot;https://stackoverflow.com/questions/4935632/how-to-parse-json-in-javascript&quot;&gt;Parse JSON in JavaScript?&lt;/a&gt; .</source>
          <target state="translated">JSON - это текстовое представление данных, как XML, YAML, CSV и другие. Для работы с такими данными их сначала необходимо преобразовать в типы данных JavaScript, то есть массивы и объекты (и как работать с ними только что объяснено). Как разобрать JSON объясняется в вопросе &lt;a href=&quot;https://stackoverflow.com/questions/4935632/how-to-parse-json-in-javascript&quot;&gt;Parse JSON в JavaScript?&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="273c9ca1c021891558d65d83fde8a56bd31c05c7" translate="yes" xml:space="preserve">
          <source>JavaScript has only one data type which can contain multiple values: &lt;strong&gt;Object&lt;/strong&gt;. An &lt;strong&gt;Array&lt;/strong&gt; is a special form of object.</source>
          <target state="translated">JavaScript имеет только один тип данных, который может содержать несколько значений: &lt;strong&gt;Object&lt;/strong&gt; . &lt;strong&gt;Массив&lt;/strong&gt; - это особая форма объекта.</target>
        </trans-unit>
        <trans-unit id="f23bb5a89e2f0742d38b7b367e3f1f2f13e2d9df" translate="yes" xml:space="preserve">
          <source>Just in case, anyone's visiting this question in 2017 or later and looking for an &lt;strong&gt;easy-to-remember&lt;/strong&gt; way, here's an elaborate blog post on &lt;a href=&quot;https://dev.to/flexdinesh/accessing-nested-objects-in-javascript--9m4&quot;&gt;Accessing Nested Objects in JavaScript&lt;/a&gt; without being bamboozled by</source>
          <target state="translated">На всякий случай, если кто-нибудь посетит этот вопрос в 2017 году или позже и ищет &lt;strong&gt;легкий для запоминания&lt;/strong&gt; способ, вот подробный пост в блоге о &lt;a href=&quot;https://dev.to/flexdinesh/accessing-nested-objects-in-javascript--9m4&quot;&gt;доступе к вложенным объектам в JavaScript&lt;/a&gt; без обмана со стороны</target>
        </trans-unit>
        <trans-unit id="1498e370fa8a872e5cb603da9a26b604ef260bf7" translate="yes" xml:space="preserve">
          <source>Just my 2 cents.</source>
          <target state="translated">Только мои 2 цента.</target>
        </trans-unit>
        <trans-unit id="0aee5af72f84d80641498878ee5470711b7f59fe" translate="yes" xml:space="preserve">
          <source>Let's assume we want to access the &lt;code&gt;name&lt;/code&gt; of the second item.</source>
          <target state="translated">Давайте предположим, что мы хотим получить доступ к &lt;code&gt;name&lt;/code&gt; второго элемента.</target>
        </trans-unit>
        <trans-unit id="56cc118b3be66a1cdf6909977e8abfc677c26f6c" translate="yes" xml:space="preserve">
          <source>Most of the time when you are getting &lt;code&gt;undefined&lt;/code&gt;, the object/array simply doesn't have a property with that name.</source>
          <target state="translated">В большинстве случаев, когда вы получаете &lt;code&gt;undefined&lt;/code&gt; , у объекта / массива просто нет свойства с таким именем.</target>
        </trans-unit>
        <trans-unit id="14486d9ed447554cbe361c938230a2a79b049782" translate="yes" xml:space="preserve">
          <source>My &lt;code&gt;stringjson&lt;/code&gt; is coming from PHP file but still, I indicate here in &lt;code&gt;var&lt;/code&gt;. When i directly take my json into &lt;code&gt;obj&lt;/code&gt; it will nothing show thats why i put my json file as</source>
          <target state="translated">Мой &lt;code&gt;stringjson&lt;/code&gt; происходит из PHP-файла, но все же, я указываю здесь, в &lt;code&gt;var&lt;/code&gt; . Когда я напрямую беру свой json в &lt;code&gt;obj&lt;/code&gt; , это ничего не показывает, поэтому я помещаю свой файл json как</target>
        </trans-unit>
        <trans-unit id="5a1c62cd71522c8e4b7755fe9dd24ecfec16d454" translate="yes" xml:space="preserve">
          <source>Notably it's probably overkill for this example, as simple array acccess is easier to read, but it comes in useful when breaking apart objects in general.</source>
          <target state="translated">Примечательно,что для данного примера это,скорее всего,излишество,так как простой доступ к массиву легче читается,но он бывает полезен при разбиении объектов в целом.</target>
        </trans-unit>
        <trans-unit id="8b85e6dbf0cb61793e767f18d29b4ef20f9d454b" translate="yes" xml:space="preserve">
          <source>Note: in many of the examples I'm using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt;. They are similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;function expressions&lt;/a&gt;, but they bind the &lt;code&gt;this&lt;/code&gt; value lexically.</source>
          <target state="translated">Примечание: во многих примерах я использую &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;функции стрелок&lt;/a&gt; . Они похожи на &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;выражения функций&lt;/a&gt; , но они связывают значение &lt;code&gt;this&lt;/code&gt; лексически.</target>
        </trans-unit>
        <trans-unit id="4e833b435a215bc1ca1b9332c795269cd1fd5a55" translate="yes" xml:space="preserve">
          <source>Now, the complex object can be flattened</source>
          <target state="translated">Теперь сложный объект можно сравнять с землей.</target>
        </trans-unit>
        <trans-unit id="fe8955a6c02557382cff4dc6d58daa1174562e1f" translate="yes" xml:space="preserve">
          <source>Objects and arrays has a lot of built-in methods that can help you with processing data.</source>
          <target state="translated">Объекты и массивы имеют множество встроенных методов,которые могут помочь вам с обработкой данных.</target>
        </trans-unit>
        <trans-unit id="79392da7a65cfe5eb93b63e66e9a83980b1e81ed" translate="yes" xml:space="preserve">
          <source>Old question but as nobody mentioned lodash (just underscore).</source>
          <target state="translated">Старый вопрос,но,как никто не упомянул о доме (просто подчеркните).</target>
        </trans-unit>
        <trans-unit id="fd959ba8c2d8fcf60e6cbbb63192e46ae580a4f9" translate="yes" xml:space="preserve">
          <source>One could also use &lt;code&gt;for...in&lt;/code&gt; to iterate over arrays, but there are reasons why this should be avoided: &lt;a href=&quot;https://stackoverflow.com/questions/2265167/why-is-forvar-item-in-list-with-arrays-considered-bad-practice-in-javascript&quot;&gt;Why is 'for(var item in list)' with arrays considered bad practice in JavaScript?&lt;/a&gt;.</source>
          <target state="translated">Можно также использовать &lt;code&gt;for...in&lt;/code&gt; для итерации массивов, но есть причины, по которым этого следует избегать: &lt;a href=&quot;https://stackoverflow.com/questions/2265167/why-is-forvar-item-in-list-with-arrays-considered-bad-practice-in-javascript&quot;&gt;почему &amp;laquo;for (var item in list)&amp;raquo; с массивами считается плохой практикой в ​​JavaScript?&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="68a57fd3726c085ce337dc259dc3b2499a35efce" translate="yes" xml:space="preserve">
          <source>Preliminaries</source>
          <target state="translated">Preliminaries</target>
        </trans-unit>
        <trans-unit id="90ea2c98223eddf63e1721f90f66c3bdd52c50dd" translate="yes" xml:space="preserve">
          <source>Properties can be accessed either using &lt;strong&gt;dot notation&lt;/strong&gt;</source>
          <target state="translated">Свойства могут быть доступны либо с использованием &lt;strong&gt;точечной нотации&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="12d45975709c333703d3231272e38bf942b4c555" translate="yes" xml:space="preserve">
          <source>Property access via dot walking: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&lt;/a&gt;</source>
          <target state="translated">Доступ к собственности с помощью точечного хождения: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">Показать фрагмент кода</target>
        </trans-unit>
        <trans-unit id="8741e75c1937a688fb16ac5022f3942e1c98839c" translate="yes" xml:space="preserve">
          <source>Since the structure of a complex object or array is not necessarily obvious, we can inspect the value at each step to decide how to move further. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt;&lt;code&gt;console.log&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt;&lt;code&gt;console.dir&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; help us doing this. For example (output of the Chrome console):</source>
          <target state="translated">Поскольку структура сложного объекта или массива не обязательно очевидна, мы можем проверять значение на каждом шаге, чтобы решить, как двигаться дальше. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt; &lt;code&gt;console.log&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; и &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt; &lt;code&gt;console.dir&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; помогают нам в этом. Например (вывод консоли Chrome):</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="f3b25614481a1e4857e6b5bdfaba4287e94bd50a" translate="yes" xml:space="preserve">
          <source>Source:  &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&quot;&gt;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&lt;/a&gt;</source>
          <target state="translated">Источник: &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&quot;&gt;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7234880ccd53ae12304b04417b0d7fa7c1a4472" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&quot;&gt;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&lt;/a&gt;</source>
          <target state="translated">Источник: &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&quot;&gt;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="68900ed6da7ee888a1cd51e372b1c1ff4e107fc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;every()&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; if the specified callback function returns &lt;code&gt;true&lt;/code&gt; for &lt;em&gt;every&lt;/em&gt; element of the array. The &lt;code&gt;some()&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; if the specified callback function returns &lt;code&gt;true&lt;/code&gt; for &lt;em&gt;some&lt;/em&gt; (at least one) element.</source>
          <target state="translated">Метод &lt;code&gt;every()&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , если указанная функция обратного вызова возвращает &lt;code&gt;true&lt;/code&gt; для &lt;em&gt;каждого&lt;/em&gt; элемента массива. Метод &lt;code&gt;some()&lt;/code&gt; возвращает &lt;code&gt;true&lt;/code&gt; , если указанная функция обратного вызова возвращает &lt;code&gt;true&lt;/code&gt; для &lt;em&gt;некоторого&lt;/em&gt; (хотя бы одного) элемента.</target>
        </trans-unit>
        <trans-unit id="33d1029fc615078c793b267f4041434365372c89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find()&lt;/code&gt; methods returns &lt;em&gt;the first&lt;/em&gt; element which satisfies the provided callback function. The &lt;code&gt;filter()&lt;/code&gt; method returns an array of &lt;em&gt;all&lt;/em&gt; elements which satisfies the provided callback function.</source>
          <target state="translated">Методы &lt;code&gt;find()&lt;/code&gt; возвращают &lt;em&gt;первый&lt;/em&gt; элемент, который удовлетворяет предоставленной функции обратного вызова. Метод &lt;code&gt;filter()&lt;/code&gt; возвращает массив &lt;em&gt;всех&lt;/em&gt; элементов, который удовлетворяет предоставленной функции обратного вызова.</target>
        </trans-unit>
        <trans-unit id="d5f79fd90ddeb2f0dad8e8b89f8687120668cbbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map()&lt;/code&gt; method returns an array with the results of calling a provided callback function on the array elements.</source>
          <target state="translated">Метод &lt;code&gt;map()&lt;/code&gt; возвращает массив с результатами вызова предоставленной функции обратного вызова для элементов массива.</target>
        </trans-unit>
        <trans-unit id="1faa15edac26d9a809a6705e2ec6c7d7b680ece1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reduce()&lt;/code&gt; method reduces an array to a single value by calling the provided callback function with two elements.</source>
          <target state="translated">Метод &lt;code&gt;reduce()&lt;/code&gt; уменьшает массив до одного значения, вызывая предоставленную функцию обратного вызова с двумя элементами.</target>
        </trans-unit>
        <trans-unit id="0520f04f746ae9cf357ff8349cf95d6d07dfac04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reduce()&lt;/code&gt; method takes an optional second parameter, which is the initial value. This is useful when the array on which you call &lt;code&gt;reduce()&lt;/code&gt; can has zero or one elements. For example, if we wanted to create a function &lt;code&gt;sum()&lt;/code&gt; which takes an array as an argument and returns the sum of all elements, we could write it like that:</source>
          <target state="translated">Метод &lt;code&gt;reduce()&lt;/code&gt; принимает необязательный второй параметр, который является начальным значением. Это полезно, когда массив, для которого вы вызываете &lt;code&gt;reduce()&lt;/code&gt; может содержать ноль или один элемент. Например, если мы хотим создать функцию &lt;code&gt;sum()&lt;/code&gt; которая принимает массив в качестве аргумента и возвращает сумму всех элементов, мы могли бы написать это так:</target>
        </trans-unit>
        <trans-unit id="87baea849532b922b02e9b36d55dcf711039c24a" translate="yes" xml:space="preserve">
          <source>The Underscore js Way</source>
          <target state="translated">The Underscore js Way</target>
        </trans-unit>
        <trans-unit id="02b44d265370739617a71ecd63227d93c6676625" translate="yes" xml:space="preserve">
          <source>The above example creates a variable called &lt;code&gt;secondName&lt;/code&gt; from the &lt;code&gt;name&lt;/code&gt; key from an array called &lt;code&gt;items&lt;/code&gt;, the lonely &lt;code&gt;,&lt;/code&gt; says skip the first object in the array.</source>
          <target state="translated">В приведенном выше примере создается переменная с именем &lt;code&gt;secondName&lt;/code&gt; из ключа &lt;code&gt;name&lt;/code&gt; из массива с именем &lt;code&gt;items&lt;/code&gt; , lonely &lt;code&gt;,&lt;/code&gt; который пропускает первый объект в массиве.</target>
        </trans-unit>
        <trans-unit id="f564d08e3ef27ff8ec50b9e4201c532b7f5ead34" translate="yes" xml:space="preserve">
          <source>The difference between the first and second option is that in the &lt;strong&gt;Opt 1&lt;/strong&gt; if you have one of the properties missing (undefined) in the path you don't get an error, it returns you the third parameter.</source>
          <target state="translated">Разница между первым и вторым вариантом заключается в том, что в опции &lt;strong&gt;1,&lt;/strong&gt; если у вас отсутствует одно из (отсутствующих) свойств в пути, вы не получите ошибку, он возвращает вам третий параметр.</target>
        </trans-unit>
        <trans-unit id="ce5f176bd08d85341c79d5a125f2aa823648c1d8" translate="yes" xml:space="preserve">
          <source>The easiest and the cleanest way is to use Oliver Steele's nested object access pattern</source>
          <target state="translated">Самый простой и чистый способ-использовать вложенный шаблон доступа к объектам Оливера Стила.</target>
        </trans-unit>
        <trans-unit id="d78353eefe17d2875f09374f4d098adbece8da68" translate="yes" xml:space="preserve">
          <source>The path is a way to say: First take the object with key &lt;code&gt;items&lt;/code&gt;, which happens to be an array. Then take the &lt;code&gt;1&lt;/code&gt;-st element (0 index arrays). Last take the object with key &lt;code&gt;name&lt;/code&gt; in that array element, which happens to be the string &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">Путь - это способ сказать: сначала возьмите объект с ключевыми &lt;code&gt;items&lt;/code&gt; , который оказывается массивом. Затем возьмите &lt;code&gt;1&lt;/code&gt; -й элемент (0 индексных массивов). Последнее, возьмите объект с &lt;code&gt;name&lt;/code&gt; ключа в этом элементе массива, который является строкой &lt;code&gt;bar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f60727501ed0b0f71f29309fe28174d990a1a9da" translate="yes" xml:space="preserve">
          <source>The value is an array, to access its second element, we have to use bracket notation:</source>
          <target state="translated">Значение представляет собой массив,для доступа ко второму его элементу мы должны использовать нотацию в скобках:</target>
        </trans-unit>
        <trans-unit id="0de40644ab3a8659c7ba0625cf4b76fa463b082b" translate="yes" xml:space="preserve">
          <source>There is also an excellent type handling minimal library &lt;a href=&quot;https://www.npmjs.com/package/typy&quot;&gt;typy&lt;/a&gt; that does all this for you.</source>
          <target state="translated">Существует также превосходная обработка типов минимальной библиотеки &lt;a href=&quot;https://www.npmjs.com/package/typy&quot;&gt;типов,&lt;/a&gt; которая сделает все это за вас.</target>
        </trans-unit>
        <trans-unit id="c2a997c0df5cc6afc6f8f4bc954c694fb5e330ab" translate="yes" xml:space="preserve">
          <source>There's also a &lt;code&gt;single&lt;/code&gt; and a &lt;code&gt;singleOrDefault&lt;/code&gt; they work much like &lt;code&gt;first&lt;/code&gt;and &lt;code&gt;firstOrDefault&lt;/code&gt;respectively. The only difference is that they will throw if &lt;em&gt;more&lt;/em&gt; than one match is found.</source>
          <target state="translated">Также есть &lt;code&gt;single&lt;/code&gt; и &lt;code&gt;singleOrDefault&lt;/code&gt; , они работают так же, как &lt;code&gt;first&lt;/code&gt; и &lt;code&gt;firstOrDefault&lt;/code&gt; соответственно. Разница лишь в том, что они будут бросать, если найдено более одного совпадения.</target>
        </trans-unit>
        <trans-unit id="cdca53564527cc4c83a547761777bdaaefd265a9" translate="yes" xml:space="preserve">
          <source>This is just plain JavaScript, without using any third party libraries like jQuery or lodash.</source>
          <target state="translated">Это простой JavaScript,без использования сторонних библиотек,таких как jQuery или lodash.</target>
        </trans-unit>
        <trans-unit id="613d7e71a59cf49fd334373087cf8a7f7d514dbc" translate="yes" xml:space="preserve">
          <source>This is very brief intro to your specific use case, destructuring can be an unusual syntax to get used to at first. I'd recommend reading &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;Mozilla's Destructuring Assignment documentation&lt;/a&gt; to learn more.</source>
          <target state="translated">Это очень краткое введение в ваш конкретный вариант использования, деструктуризация может быть необычным синтаксисом, к которому нужно сначала привыкнуть. Я бы порекомендовал прочитать документацию &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;Mozilla's Destructuring Assignment,&lt;/a&gt; чтобы узнать больше.</target>
        </trans-unit>
        <trans-unit id="ca207417a9a4489be238e24e5dc9eee14df4e603" translate="yes" xml:space="preserve">
          <source>This question is quite old, so as a contemporary update. With the onset of ES2015 there are alternatives to get a hold of the data you require. There is now a feature called &lt;strong&gt;object destructuring&lt;/strong&gt; for accessing nested objects.</source>
          <target state="translated">Этот вопрос довольно старый, так что современное обновление. С началом ES2015 есть альтернативы, чтобы получить данные, которые вам нужны. Теперь существует функция, называемая &lt;strong&gt;деструктуризацией объектов,&lt;/strong&gt; для доступа к вложенным объектам.</target>
        </trans-unit>
        <trans-unit id="0b859db7c9baac7342be4c399fa4268d64580a50" translate="yes" xml:space="preserve">
          <source>This tells us that &lt;code&gt;data.items[1]&lt;/code&gt; is an object, and after expanding it we see that it has three properties, &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;__proto__&lt;/code&gt;. The latter is an internal property used for the prototype chain of the object. The prototype chain and inheritance is out of scope for this answer, though.</source>
          <target state="translated">Это говорит нам о том, что &lt;code&gt;data.items[1]&lt;/code&gt; является объектом, и после его расширения мы видим, что у него есть три свойства: &lt;code&gt;id&lt;/code&gt; , &lt;code&gt;name&lt;/code&gt; и &lt;code&gt;__proto__&lt;/code&gt; . Последнее является внутренним свойством, используемым для цепочки прототипов объекта. Тем не менее, цепочка прототипов и наследование выходят за рамки этого ответа.</target>
        </trans-unit>
        <trans-unit id="664137228398b0d17707a75bb9baa1603f7c4873" translate="yes" xml:space="preserve">
          <source>This value is an object and we use dot notation again to access the &lt;code&gt;name&lt;/code&gt; property. So we eventually get:</source>
          <target state="translated">Это значение является объектом, и мы снова используем точечную запись для доступа к свойству &lt;code&gt;name&lt;/code&gt; . Итак, мы в итоге получаем:</target>
        </trans-unit>
        <trans-unit id="9768ca2740c20ae8117706d5dc8fead7bf0b3e46" translate="yes" xml:space="preserve">
          <source>To access a nested attribute, you need to specify its name and then search through the object.</source>
          <target state="translated">Для доступа к вложенному атрибуту необходимо указать его имя,а затем выполнить поиск по объекту.</target>
        </trans-unit>
        <trans-unit id="56e3fdff87ae9f0ae61a5a84dce9e283d8be9946" translate="yes" xml:space="preserve">
          <source>To be able to access nested arrays, you can write your own array reduce util.</source>
          <target state="translated">Чтобы иметь доступ к вложенным массивам,вы можете записать свой собственный массив,что уменьшит использование.</target>
        </trans-unit>
        <trans-unit id="49f8a91e4cfa2d6b3229f29def0311f69307f574" translate="yes" xml:space="preserve">
          <source>To iterate over all elements of the &lt;code&gt;data.items&lt;/code&gt;&lt;strong&gt;array&lt;/strong&gt;, we use a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">Чтобы перебрать все элементы &lt;strong&gt;массива&lt;/strong&gt; &lt;code&gt;data.items&lt;/code&gt; , мы используем цикл &lt;code&gt;for&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6c1ce5587a33fa10b3413df43f4e8e8a4dae0d1e" translate="yes" xml:space="preserve">
          <source>To iterate over all properties of &lt;code&gt;data&lt;/code&gt;, we can iterate over the &lt;strong&gt;object&lt;/strong&gt; like so:</source>
          <target state="translated">Чтобы перебрать все свойства &lt;code&gt;data&lt;/code&gt; , мы можем перебрать &lt;strong&gt;объект&lt;/strong&gt; так:</target>
        </trans-unit>
        <trans-unit id="7b2df20f42b29bf3e20fea1c0b9e55f35846c2b6" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt;&lt;code&gt;console.log&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt;&lt;code&gt;console.dir&lt;/code&gt;&lt;/a&gt; and inspect the structure of object / array. The property you are trying to access might be actually defined on a nested object / array.</source>
          <target state="translated">Используйте &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt; &lt;code&gt;console.log&lt;/code&gt; &lt;/a&gt; или &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt; &lt;code&gt;console.dir&lt;/code&gt; &lt;/a&gt; и проверьте структуру объекта / массива. Свойство, к которому вы пытаетесь обратиться, может быть фактически определено для вложенного объекта / массива.</target>
        </trans-unit>
        <trans-unit id="72f0f0ca7535a2f887b045ea5d0ca8f48ce694a9" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;JSONPath&lt;/strong&gt; would be one of the most flexible solutions if you are willing to include a library:
&lt;a href=&quot;https://github.com/s3u/JSONPath&quot;&gt;https://github.com/s3u/JSONPath&lt;/a&gt; (node and browser)</source>
          <target state="translated">Использование &lt;strong&gt;JSONPath&lt;/strong&gt; будет одним из наиболее гибких решений, если вы захотите включить библиотеку: &lt;a href=&quot;https://github.com/s3u/JSONPath&quot;&gt;https://github.com/s3u/JSONPath&lt;/a&gt; (узел и браузер)</target>
        </trans-unit>
        <trans-unit id="dd203328bc98a927636df7b5efb2d4b1ffa6e6f4" translate="yes" xml:space="preserve">
          <source>Wait... what about JSON?</source>
          <target state="translated">Подожди...а как же JSON?</target>
        </trans-unit>
        <trans-unit id="3e274725ac7462274d545e66a9e93ca5ef1df972" translate="yes" xml:space="preserve">
          <source>What if the &quot;depth&quot; of the data structure is unknown to me?</source>
          <target state="translated">Что,если &quot;глубина&quot; структуры данных мне неизвестна?</target>
        </trans-unit>
        <trans-unit id="0fff2ae2dbc525ac2a28a45db0cb87ff3327df68" translate="yes" xml:space="preserve">
          <source>What if the property names are dynamic and I don't know them beforehand?</source>
          <target state="translated">Что,если названия собственности динамичны,а я не знаю их заранее?</target>
        </trans-unit>
        <trans-unit id="33d729be609d12f4e50fd456f76e8b7cce6707b0" translate="yes" xml:space="preserve">
          <source>When you don't know the exact name before hand, or a user is the one who provides the name for you. Then dynamically searching through the data structure is required. Some suggested here that the search can be done using a &lt;code&gt;for&lt;/code&gt; loop, but there is a very simple way to traverse a path using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt;&lt;code&gt;Array.reduce&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Если вы не знаете точного имени заранее, или пользователь предоставляет вам имя. Затем требуется динамический поиск по структуре данных. Некоторые предположили, что поиск может быть выполнен с использованием цикла &lt;code&gt;for&lt;/code&gt; , но существует очень простой способ обхода пути с использованием &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt; &lt;code&gt;Array.reduce&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="afd41e005ac69d70994393c4db3fa04d17c51a06" translate="yes" xml:space="preserve">
          <source>Which is a JavaScript library that provides a whole mess of useful &lt;code&gt;functional programming&lt;/code&gt; helpers without extending any built-in objects.</source>
          <target state="translated">Это библиотека JavaScript, которая предоставляет целый набор полезных помощников по &lt;code&gt;functional programming&lt;/code&gt; без расширения каких-либо встроенных объектов.</target>
        </trans-unit>
        <trans-unit id="426bb082ff6e5896064dd959ec8bae3683981cd9" translate="yes" xml:space="preserve">
          <source>With the increasing browser support of ECMAScript 5, the array method &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;forEach&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; becomes an interesting alternative as well:</source>
          <target state="translated">С увеличением поддержки браузером ECMAScript 5, метод массива &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;forEach&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN] также&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; становится интересной альтернативой:</target>
        </trans-unit>
        <trans-unit id="6e0bb43e7e58f1dccb01b724584c7e815f5113e7" translate="yes" xml:space="preserve">
          <source>With this notation, you'll never run into</source>
          <target state="translated">С этой нотацией,ты никогда не столкнешься с</target>
        </trans-unit>
        <trans-unit id="23f0d329dcf4a9e1c2a145121c1a0c7cebda6e99" translate="yes" xml:space="preserve">
          <source>Working fiddle: &lt;a href=&quot;https://jsfiddle.net/andreitodorut/3mws3kjL/&quot;&gt;https://jsfiddle.net/andreitodorut/3mws3kjL/&lt;/a&gt;</source>
          <target state="translated">Рабочая скрипка: &lt;a href=&quot;https://jsfiddle.net/andreitodorut/3mws3kjL/&quot;&gt;https://jsfiddle.net/andreitodorut/3mws3kjL/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="df5a94f92bfe3900361a91260e60682f362b48ec" translate="yes" xml:space="preserve">
          <source>Working with Objects</source>
          <target state="translated">Работа с объектами</target>
        </trans-unit>
        <trans-unit id="4497254d63e510893ef09f0c7afb22fec75a65de" translate="yes" xml:space="preserve">
          <source>You basically check if user exists, if not, you create an empty object on the fly. This way, the next level key will &lt;strong&gt;always be accessed from an object that exists or an empty object&lt;/strong&gt;, but never from undefined.</source>
          <target state="translated">Вы в основном проверяете, существует ли пользователь, если нет, вы создаете пустой объект на лету. Таким образом, ключ следующего уровня будет &lt;strong&gt;всегда доступен из существующего объекта или пустого объекта&lt;/strong&gt; , но никогда из неопределенного.</target>
        </trans-unit>
        <trans-unit id="17f3f05296a9f74d4837489378560984a26833b0" translate="yes" xml:space="preserve">
          <source>You can access it this way</source>
          <target state="translated">Вы можете получить доступ к нему таким образом.</target>
        </trans-unit>
        <trans-unit id="cfa469e890d94b193d15281607d34ec28b836ae7" translate="yes" xml:space="preserve">
          <source>You can use the syntax &lt;code&gt;jsonObject.key&lt;/code&gt; to access the the value. And if you want access a value from an array, then you can use the syntax &lt;code&gt;jsonObjectArray[index].key&lt;/code&gt;.</source>
          <target state="translated">Вы можете использовать синтаксис &lt;code&gt;jsonObject.key&lt;/code&gt; для доступа к значению. И если вы хотите получить доступ к значению из массива, вы можете использовать синтаксис &lt;code&gt;jsonObjectArray[index].key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c57e8d7f2d3c9338d66a6c78ba4fcafd728a6f7" translate="yes" xml:space="preserve">
          <source>You could use &lt;code&gt;lodash _get&lt;/code&gt; function:</source>
          <target state="translated">Вы можете использовать функцию &lt;code&gt;lodash _get&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4a87503c2fa7c97664a81fd80a5702f7d91e2b3b" translate="yes" xml:space="preserve">
          <source>for further explanation of query-js you can start with this &lt;a href=&quot;http://runefs.com/2015/06/04/working-with-data-in-javascript/&quot;&gt;post&lt;/a&gt;</source>
          <target state="translated">для дальнейшего объяснения query-js вы можете начать с этого &lt;a href=&quot;http://runefs.com/2015/06/04/working-with-data-in-javascript/&quot;&gt;поста&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="7ac01203eeb458726d789e7d2607af95159fd2ed" translate="yes" xml:space="preserve">
          <source>or &lt;strong&gt;bracket notation&lt;/strong&gt;, if the property name would not be a valid JavaScript &lt;a href=&quot;http://es5.github.com/#x7.6&quot;&gt;identifier name &lt;em&gt;&lt;sup&gt;[spec]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;, or the name is the value of a variable:</source>
          <target state="translated">или &lt;strong&gt;обозначение в скобках&lt;/strong&gt; , если имя свойства не будет допустимым &lt;a href=&quot;http://es5.github.com/#x7.6&quot;&gt;именем идентификатора&lt;/a&gt; JavaScript &lt;em&gt;&lt;sup&gt;[spec]&lt;/sup&gt;&lt;/em&gt; , или имя является значением переменной:</target>
        </trans-unit>
        <trans-unit id="af3ec5b75c689d26309f57c2989dae794c7b17cd" translate="yes" xml:space="preserve">
          <source>same as:</source>
          <target state="translated">как и..:</target>
        </trans-unit>
        <trans-unit id="3bdb8452054fa2b577dec841756010a549232d09" translate="yes" xml:space="preserve">
          <source>so:</source>
          <target state="translated">so:</target>
        </trans-unit>
        <trans-unit id="560572a782680d5c66f76b07c8f3ba5b61030e77" translate="yes" xml:space="preserve">
          <source>these also work -</source>
          <target state="translated">это тоже работает -</target>
        </trans-unit>
        <trans-unit id="c86c30365c1ce95f0ba082ac38ab0704ccf05de4" translate="yes" xml:space="preserve">
          <source>to add to this, accessing nested Arrays would happen like so:</source>
          <target state="translated">чтобы добавить к этому,доступ к вложенным массивам будет таким:</target>
        </trans-unit>
        <trans-unit id="612f40ac9069ed110eabdcfa125d119cd7f891bf" translate="yes" xml:space="preserve">
          <source>where &lt;em&gt;data&lt;/em&gt; is a python list (parsed from a JSON text string):</source>
          <target state="translated">где &lt;em&gt;данные&lt;/em&gt; - это список Python (анализируется из текстовой строки JSON):</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
