<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/11922383">
    <body>
      <group id="11922383">
        <trans-unit id="b9d7ae0596fa1b6e804b7403306ad6e7b605efaa" translate="yes" xml:space="preserve">
          <source>(Plain) Objects have the form</source>
          <target state="translated">平野)オブジェクトは形を持っています。</target>
        </trans-unit>
        <trans-unit id="5a44941be43e076ddb71539916eacc34663abeff" translate="yes" xml:space="preserve">
          <source>1. Oliver Steele's nested object access pattern</source>
          <target state="translated">1.オリバー・スティールの入れ子になったオブジェクトのアクセスパターン</target>
        </trans-unit>
        <trans-unit id="ed8b403487c125d1961eab9ebb74e25ab570a5a1" translate="yes" xml:space="preserve">
          <source>2. Access Nested Objects Using Array Reduce</source>
          <target state="translated">2.配列の削減を使って入れ子になったオブジェクトにアクセスする</target>
        </trans-unit>
        <trans-unit id="ad74c01cfd52ca2cf56ce6a6598aa7ac314201eb" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://api.jquery.com/jQuery.grep/&quot;&gt;jQuery's grep&lt;/a&gt; function lets you filter through an array:</source>
          <target state="translated">&lt;a href=&quot;https://api.jquery.com/jQuery.grep/&quot;&gt;jQueryのgrep&lt;/a&gt;関数を使用すると、配列をフィルタリングできます。</target>
        </trans-unit>
        <trans-unit id="be0ce6e993ffb8eff08543817b70124c314607a2" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every&quot;&gt;&lt;code&gt;Array.prototype.every()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt;&lt;code&gt;Array.prototype.some()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every&quot;&gt; &lt;code&gt;Array.prototype.every()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some&quot;&gt; &lt;code&gt;Array.prototype.some()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e2ec576c3eb3b38eee1c21db4e00aaa38a6217f1" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt;&lt;code&gt;Array.prototype.find()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt;&lt;code&gt;Array.prototype.filter()&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find&quot;&gt; &lt;code&gt;Array.prototype.find()&lt;/code&gt; &lt;/a&gt;および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt; &lt;code&gt;Array.prototype.filter()&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="556ef4bccc10401c80f3faacf4016eec1e577dda" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;&lt;code&gt;Object.keys()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values&quot;&gt;&lt;code&gt;Object.values()&lt;/code&gt;&lt;/a&gt; (ES 2017) and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt;&lt;code&gt;Object.entries()&lt;/code&gt;&lt;/a&gt; (ES 2017)</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt; &lt;code&gt;Object.keys()&lt;/code&gt; &lt;/a&gt; 、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values&quot;&gt; &lt;code&gt;Object.values()&lt;/code&gt; &lt;/a&gt; （ES 2017）および&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/entries&quot;&gt; &lt;code&gt;Object.entries()&lt;/code&gt; &lt;/a&gt; （ES 2017）</target>
        </trans-unit>
        <trans-unit id="111884d6e8ac53f873a2d04671b8f49d0bca3d45" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.entries()&lt;/code&gt; with a for-of loop and destructuring assignment</source>
          <target state="translated">&lt;code&gt;Object.entries()&lt;/code&gt; ループと構造化割り当てを含むObject.entries（）</target>
        </trans-unit>
        <trans-unit id="4def2b05926df9dbc0358ffc483d09a93c29d777" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;Object.keys()&lt;/code&gt; returns an array of object's keys, &lt;code&gt;Object.values()&lt;/code&gt; returns an array of object's values, and &lt;code&gt;Object.entries()&lt;/code&gt; returns an array of object's keys and corresponding values in a format &lt;code&gt;[key, value]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Object.keys()&lt;/code&gt; はオブジェクトのキーの配列を返し、 &lt;code&gt;Object.values()&lt;/code&gt; はオブジェクトの値の配列を返し、 &lt;code&gt;Object.entries()&lt;/code&gt; は &lt;code&gt;[key, value]&lt;/code&gt; 形式でオブジェクトのキーと対応する値の配列を返します。</target>
        </trans-unit>
        <trans-unit id="4fb5d351b0ef54c549d915337ae5b658f2a714d0" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;var obj=JSON.parse(stringjson);&lt;/code&gt; 
so after that i get &lt;code&gt;message&lt;/code&gt; obj and show in alert box then I get &lt;code&gt;data&lt;/code&gt; which is json array and store in one varible &lt;code&gt;ArrObj&lt;/code&gt; then i read first object of that array with key value like this &lt;code&gt;ArrObj[0].id&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;var obj=JSON.parse(stringjson);&lt;/code&gt; その後、 &lt;code&gt;message&lt;/code&gt; objを取得してアラートボックスに表示し、json配列である &lt;code&gt;data&lt;/code&gt; を取得して1つの変数 &lt;code&gt;ArrObj&lt;/code&gt; に格納します。次に、この &lt;code&gt;ArrObj[0].id&lt;/code&gt; ようなキー値を持つその配列の最初のオブジェクトを読み取ります</target>
        </trans-unit>
        <trans-unit id="070baa4293f4df5a2e7819f8e151c13553b4cf63" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Cannot read property 'foo' of undefined&lt;/em&gt; error</source>
          <target state="translated">&lt;em&gt;未定義&lt;/em&gt;エラーの&lt;em&gt;プロパティ 'foo'を読み取れません&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8f506e37dc0630fb98bd6b1ce619c7a3a830b1c8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Cannot read property 'name' of undefined&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;undefinedのプロパティ 'name'を読み取れません&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="f04b39aa9e617f5727bbea03e1c5dcbc50d15900" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arrays&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Arrays&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa0a7c98ac6e1fb3f4f08f9978cf161c1556d0de" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Objects&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Objects&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7383b9e7b2d0d2accbf17b8da579fecc7fcac42f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Opt 1&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;オプション1&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a563acfca1a6fd144c9efcd226f8991db8016ef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Opt 2&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;オプション2&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9daf94b0dddd46befa283cfcbbe9c25a98f3329e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Using lodash would be good solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;lodashの使用は良い解決策です&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="816a9c6c3ff8b608fc4422ee03bed6a523957af9" translate="yes" xml:space="preserve">
          <source>A more generic way to access a nested data structure with unknown keys and depth is to test the type of the value and act accordingly.</source>
          <target state="translated">不明なキーと深さを持つネストされたデータ構造にアクセスするより一般的な方法は、値の型をテストし、それに応じて行動することです。</target>
        </trans-unit>
        <trans-unit id="f39295fd4534982211264eee2ad1c31977f1c84d" translate="yes" xml:space="preserve">
          <source>A nested data structure is an array or object which refers to other arrays or objects, i.e. its values are arrays or objects. Such structures can be accessed by consecutively applying dot or bracket notation.</source>
          <target state="translated">入れ子になったデータ構造は、他の配列やオブジェクトを参照する配列やオブジェクト、つまりその値が配列やオブジェクトであることを意味します。このような構造体は、ドット表記やカッコ表記を連続して適用することでアクセスすることができます。</target>
        </trans-unit>
        <trans-unit id="afddb60a392d86e966d777e444f6d6456fe9e388" translate="yes" xml:space="preserve">
          <source>A pythonic, recursive and functional approach to unravel arbitrary JSON trees:</source>
          <target state="translated">任意のJSONツリーを解くためのパイソン的、再帰的、関数的なアプローチ。</target>
        </trans-unit>
        <trans-unit id="4cc2f66e7372b97d6294942a2e488694268c58fd" translate="yes" xml:space="preserve">
          <source>Accessing dynamically multi levels object.</source>
          <target state="translated">動的に複数レベルのオブジェクトにアクセスします。</target>
        </trans-unit>
        <trans-unit id="28db033c076db7cbec4550f7d75c73b992db4b1c" translate="yes" xml:space="preserve">
          <source>Accessing nested data structures</source>
          <target state="translated">入れ子になったデータ構造へのアクセス</target>
        </trans-unit>
        <trans-unit id="9161e0e95a7f4324a52451db1abf9bc546febaf6" translate="yes" xml:space="preserve">
          <source>Alternatively, we could have used bracket notation for any of the properties, especially if the name contained characters that would have made it invalid for dot notation usage:</source>
          <target state="translated">また、特に名前にドット表記では無効になるような文字が含まれている場合には、プロパティのいずれかに大括弧表記を使用することもできました。</target>
        </trans-unit>
        <trans-unit id="fe486bc1dc5fa2c8ed6de19ba7d46122f46fbdaf" translate="yes" xml:space="preserve">
          <source>And you know you want to get the first result of the array in the object, perhaps you would like to use</source>
          <target state="translated">そして、オブジェクト内の配列の最初の結果を取得したいことを知っています。</target>
        </trans-unit>
        <trans-unit id="ace6ce8ebfeb347b804bad250d4e5995ef0f42f2" translate="yes" xml:space="preserve">
          <source>Another more useful document depicting the situation above: 
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&quot;&gt;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&lt;/a&gt;</source>
          <target state="translated">上記の状況を描いたさらに便利なドキュメント： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation&quot;&gt;https&lt;/a&gt; : //developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Basics#Bracket_notation</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="41dda5572bc7dcd447232d111646168caca0a537" translate="yes" xml:space="preserve">
          <source>Arrays have the form</source>
          <target state="translated">配列の形式は</target>
        </trans-unit>
        <trans-unit id="9c633aa3bac6977948ff0408055fe2896e6370e1" translate="yes" xml:space="preserve">
          <source>As alternative to &lt;code&gt;for...in&lt;/code&gt; with &lt;code&gt;hasOwnProperty&lt;/code&gt;, you can use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt;&lt;code&gt;Object.keys&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; to get an &lt;em&gt;array of property names&lt;/em&gt;:</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; で &lt;code&gt;hasOwnProperty&lt;/code&gt; を使用する&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys&quot;&gt; &lt;code&gt;Object.keys&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;を使用して&lt;em&gt;プロパティ名の配列&lt;/em&gt;を取得でき&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbe0dbbc73fe9040a9866aed9948b4db98994376" translate="yes" xml:space="preserve">
          <source>As we can see &lt;code&gt;data&lt;/code&gt; is an object, hence we can access its properties using dot notation. The &lt;code&gt;items&lt;/code&gt; property is accessed as follows:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; がオブジェクトであることを確認できるので、ドット表記を使用してそのプロパティにアクセスできます。 &lt;code&gt;items&lt;/code&gt; プロパティには次のようにアクセスします。</target>
        </trans-unit>
        <trans-unit id="fdec08a847a97bcd4c07dcbb2caf3c16dcf80b54" translate="yes" xml:space="preserve">
          <source>As you can see, destructuring makes this a lot simpler.</source>
          <target state="translated">ご覧のように、破壊することで、これは非常にシンプルになります。</target>
        </trans-unit>
        <trans-unit id="f772e09632917ff307133b29957a65855dd122d7" translate="yes" xml:space="preserve">
          <source>At times, accessing a nested object using a string can be desirable. The simple approach is the first level, for example</source>
          <target state="translated">時には、文字列を使用して入れ子になったオブジェクトにアクセスすることが望ましい場合もあります。シンプルなアプローチとしては、第一階層で、例えば</target>
        </trans-unit>
        <trans-unit id="3ca8a39547fd839bf865328c29404e1afe375865" translate="yes" xml:space="preserve">
          <source>Basically, use a dot between each descendant that unfolds underneath it and when you have object names made out of two strings, you must use the [&quot;obj Name&quot;] notation. Otherwise, just a dot would suffice;</source>
          <target state="translated">基本的には、その下に展開する子孫の間にはドットを使用し、オブジェクト名が2つの文字列で構成されている場合は[&quot;obj Name&quot;]表記を使用しなければなりません。それ以外の場合はドットだけで十分です。</target>
        </trans-unit>
        <trans-unit id="b101422364275a2e30072a8796b25a5d9cf9af98" translate="yes" xml:space="preserve">
          <source>Both arrays and objects expose a &lt;code&gt;key -&amp;gt; value&lt;/code&gt; structure. Keys in an array must be numeric, whereas any string can be used as key in objects. The key-value pairs are also called the &lt;strong&gt;&quot;properties&quot;&lt;/strong&gt;.</source>
          <target state="translated">配列とオブジェクトの両方が、 &lt;code&gt;key -&amp;gt; value&lt;/code&gt; 構造を公開します 。 配列のキーは数値である必要がありますが、オブジェクトのキーとして任意の文字列を使用できます。 キーと値のペアは&lt;strong&gt;「プロパティ」&lt;/strong&gt;とも呼ばれ&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="cc5a260ab7f1841e1aba3a2ebbfd1f3271fcf519" translate="yes" xml:space="preserve">
          <source>Both ways are equal.</source>
          <target state="translated">どちらの方法も平等です。</target>
        </trans-unit>
        <trans-unit id="fdd103fb4c1dabaa12e40a9fcdc5f9af7f3c871a" translate="yes" xml:space="preserve">
          <source>But if the data structure contains repeating patterns, e.g. the representation of a binary tree, the solution typically includes to &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29&quot;&gt;&lt;strong&gt;recursively&lt;/strong&gt; &lt;em&gt;&lt;sup&gt;[Wikipedia]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; access each level of the data structure.</source>
          <target state="translated">しかし、データ構造に繰り返しパターン、たとえばバイナリツリーの表現が含まれている場合、ソリューションには通常、データ構造の各レベルに&lt;a href=&quot;https://en.wikipedia.org/wiki/Recursion_%28computer_science%29&quot;&gt;&lt;strong&gt;再帰的に&lt;/strong&gt;&lt;/a&gt;アクセスする&lt;em&gt;&lt;sup&gt;[Wikipedia]ことが&lt;/sup&gt;&lt;/em&gt;含まれます。</target>
        </trans-unit>
        <trans-unit id="4d8f4d28d7d10eb511ab35f3d5ff0db1a6e70ca1" translate="yes" xml:space="preserve">
          <source>But this is often not the case with complex json. As json becomes more complex, the approaches for finding values inside of the json also become complex. A recursive approach for navigating the json is best, and how that recursion is leveraged will depend on the type of data being searched for. If there are conditional statements involved, a &lt;a href=&quot;https://stackoverflow.com/a/11657379/1026459&quot;&gt;json search&lt;/a&gt; can be a good tool to use.</source>
          <target state="translated">しかし、これは複雑なjsonには当てはまりません。 jsonがより複雑になるにつれて、json内の値を見つけるためのアプローチも複雑になります。 jsonをナビゲートするための再帰的なアプローチが最適であり、その再帰がどのように活用されるかは、検索されるデータのタイプによって異なります。 条件付きステートメントが含まれている場合は、 &lt;a href=&quot;https://stackoverflow.com/a/11657379/1026459&quot;&gt;json検索&lt;/a&gt;を使用することをお勧めします。</target>
        </trans-unit>
        <trans-unit id="7d269dca449b2b51321c86807f7284ab602821d8" translate="yes" xml:space="preserve">
          <source>Depending on where the object comes from (and what you want to do), you might have to test in each iteration whether the property is really a property of the object, or it is an inherited property. You can do this with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt;&lt;code&gt;Object#hasOwnProperty&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;.</source>
          <target state="translated">オブジェクトがどこから来たか（そして何をしたいか）に応じて、プロパティが実際にオブジェクトのプロパティであるか、継承されたプロパティであるかを各反復でテストする必要がある場合があります。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Object/hasOwnProperty&quot;&gt; &lt;code&gt;Object#hasOwnProperty&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]で&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;これを行うことができます。</target>
        </trans-unit>
        <trans-unit id="64569aad96916652199eeb6b944efa9a5c953da7" translate="yes" xml:space="preserve">
          <source>Destructuring assignment lets you extract values from an array or an object and assign them to variables. In this case &lt;code&gt;const [key, value]&lt;/code&gt; means that instead of assigning the &lt;code&gt;[key, value]&lt;/code&gt; array to &lt;code&gt;element&lt;/code&gt;, we assign the first element of that array to &lt;code&gt;key&lt;/code&gt; and the second element to &lt;code&gt;value&lt;/code&gt;. It is equivalent to this:</source>
          <target state="translated">構造化代入では、配列またはオブジェクトから値を抽出して、変数に代入できます。 この場合、 &lt;code&gt;const [key, value]&lt;/code&gt; は、 &lt;code&gt;[key, value]&lt;/code&gt; 配列を &lt;code&gt;element&lt;/code&gt; に割り当てる代わりに、その配列の最初の要素を &lt;code&gt;key&lt;/code&gt; に割り当て、2番目の要素を &lt;code&gt;value&lt;/code&gt; に割り当てることを意味します 。 これはこれと同等です：</target>
        </trans-unit>
        <trans-unit id="02dc9a66286816111e66fbe036cefc9f91ca21cc" translate="yes" xml:space="preserve">
          <source>Dynamic approach</source>
          <target state="translated">ダイナミックアプローチ</target>
        </trans-unit>
        <trans-unit id="0d2de250773511a1ad80d3f98de046259307b9a4" translate="yes" xml:space="preserve">
          <source>Eloquent JavaScript - Data Structures</source>
          <target state="translated">Eloquent JavaScript-データ構造</target>
        </trans-unit>
        <trans-unit id="2ede17026a66f2bb53f3b6978daa3529c4d3bc25" translate="yes" xml:space="preserve">
          <source>Ex:</source>
          <target state="translated">Ex:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="3b9c2a54ba734b7b8b4978d83e1db213972ac579" translate="yes" xml:space="preserve">
          <source>For array filter lodash has &lt;code&gt;_.find()&lt;/code&gt; but I'd rather use the regular &lt;code&gt;filter()&lt;/code&gt;. But I still think the above method &lt;code&gt;_.get()&lt;/code&gt; is super useful when working with really complex data. I faced in the past really complex APIs and it was handy!</source>
          <target state="translated">配列フィルターの場合、lodashには &lt;code&gt;_.find()&lt;/code&gt; がありますが、通常の &lt;code&gt;filter()&lt;/code&gt; を使用します。 しかし、上記のメソッド &lt;code&gt;_.get()&lt;/code&gt; は、本当に複雑なデータを処理する場合に非常に便利だと思います。 私は過去に本当に複雑なAPIに直面し、それは便利でした！</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="445d1e6104f5820cabec109fcf1319f71f1065d0" translate="yes" xml:space="preserve">
          <source>For that reason, array elements can only be accessed using bracket notation:</source>
          <target state="translated">そのため、配列の要素には括弧記法でしかアクセスできません。</target>
        </trans-unit>
        <trans-unit id="d5a825881321ee3e4e37abb15f70df07dcb95713" translate="yes" xml:space="preserve">
          <source>For your use case the json path would be:</source>
          <target state="translated">あなたのユースケースでは、jsonのパスは次のようになります。</target>
        </trans-unit>
        <trans-unit id="9eef871033ae2b01fb1362a850c9adfc85cc8ebf" translate="yes" xml:space="preserve">
          <source>For-of loop lets you iterate array elements. The syntax is &lt;code&gt;for (const element of array)&lt;/code&gt; (we can replace &lt;code&gt;const&lt;/code&gt; with &lt;code&gt;var&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;, but it's better to use &lt;code&gt;const&lt;/code&gt; if we don't intend to modify &lt;code&gt;element&lt;/code&gt;).</source>
          <target state="translated">for-ofループを使用すると、配列要素を反復できます。 構文は &lt;code&gt;for (const element of array)&lt;/code&gt; （ &lt;code&gt;const&lt;/code&gt; を &lt;code&gt;var&lt;/code&gt; または &lt;code&gt;let&lt;/code&gt; で置き換えることができますが、elementを変更するつもりがない場合は &lt;code&gt;const&lt;/code&gt; を使用することをお勧めします）。</target>
        </trans-unit>
        <trans-unit id="0ef664dc5e993d8e597a3f0029cd45095dd4cd66" translate="yes" xml:space="preserve">
          <source>From my experience, using higher order functions instead of &lt;code&gt;for&lt;/code&gt; or &lt;code&gt;for..in&lt;/code&gt; loops results in code that is easier to reason about, and hence more maintainable.</source>
          <target state="translated">私の経験で &lt;code&gt;for&lt;/code&gt; 、 &lt;code&gt;for..in&lt;/code&gt; ループまたはfor..inループの代わりに高次関数を使用すると、コードの推論が容易になり、保守が容易になります。</target>
        </trans-unit>
        <trans-unit id="cf1d3d2922bc105f006fa87beed0df0abfa99f76" translate="yes" xml:space="preserve">
          <source>Further reading material</source>
          <target state="translated">その他の読み物</target>
        </trans-unit>
        <trans-unit id="3c9b3433e6f225e4ae00ef2041d44d91bfbf7113" translate="yes" xml:space="preserve">
          <source>Helpers</source>
          <target state="translated">Helpers</target>
        </trans-unit>
        <trans-unit id="605f0dfa014b0cfc9478e06cb6929a44ac4b18c5" translate="yes" xml:space="preserve">
          <source>Here are the code examples to access various values to give you the idea.</source>
          <target state="translated">ここでは、アイデアを与えるために様々な値にアクセスするためのコード例を示します。</target>
        </trans-unit>
        <trans-unit id="c1c24498af84d309f0cd97effacb306f537abc11" translate="yes" xml:space="preserve">
          <source>Here is a &lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://jsfiddle.net/73172hr0/&quot;&gt;&lt;code&gt;jsFiddle Demo&lt;/code&gt;&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt; of this approach being used.</source>
          <target state="translated">これは、使用されているこのアプローチの&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://jsfiddle.net/73172hr0/&quot;&gt; &lt;code&gt;jsFiddle Demo&lt;/code&gt; &lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;です。</target>
        </trans-unit>
        <trans-unit id="eea516510b57f9617ec45edfa85521334718d617" translate="yes" xml:space="preserve">
          <source>Here is an example to get the first leaf node of a binary tree:</source>
          <target state="translated">ここでは、バイナリツリーの最初のリーフノードを取得する例を示します。</target>
        </trans-unit>
        <trans-unit id="8a6cd511416c318ce3118af57082c98e3c27c850" translate="yes" xml:space="preserve">
          <source>Here is an example which adds all primitive values inside a nested data structure into an array (assuming it does not contain any functions). If we encounter an object (or array) we simply call &lt;code&gt;toArray&lt;/code&gt; again on that value (recursive call).</source>
          <target state="translated">ネストされたデータ構造内のすべてのプリミティブ値を配列に追加する例を次に示します（関数が含まれていないと想定）。 オブジェクト（または配列）が &lt;code&gt;toArray&lt;/code&gt; た場合は、その値に対してtoArrayを再度呼び出すだけです（再帰呼び出し）。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">ここでは一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="925217328e8c6e1d64c87ab4f4335bf5fbdb54c3" translate="yes" xml:space="preserve">
          <source>Here is how we can do it step-by-step:</source>
          <target state="translated">ステップバイステップでできる方法をご紹介します。</target>
        </trans-unit>
        <trans-unit id="d207069b46269857b00213ef7930f472a4c79665" translate="yes" xml:space="preserve">
          <source>Here we see that that &lt;code&gt;data.items&lt;/code&gt; is an array with two elements which are both objects. In Chrome console the objects can even be expanded and inspected immediately.</source>
          <target state="translated">ここでは、 &lt;code&gt;data.items&lt;/code&gt; が、両方ともオブジェクトである2つの要素を持つ配列であることがわかります。 Chromeコンソールでは、オブジェクトを展開してすぐに検査することもできます。</target>
        </trans-unit>
        <trans-unit id="7af11a5669687094fc9c73e62819006759babfc9" translate="yes" xml:space="preserve">
          <source>How can I access and process nested objects, arrays or JSON</source>
          <target state="translated">入れ子になったオブジェクト、配列、または JSON にアクセスして処理するにはどうすればよいですか?</target>
        </trans-unit>
        <trans-unit id="7c724edbaf2dc46e497eee6c123b2325a46b6a71" translate="yes" xml:space="preserve">
          <source>How could I access the &lt;code&gt;name&lt;/code&gt; of the second item in &lt;code&gt;items&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;items&lt;/code&gt; の 2番目のアイテムの &lt;code&gt;name&lt;/code&gt; にアクセスするにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="505b1723179035f7490a5348f8afb6ed7fe15dc8" translate="yes" xml:space="preserve">
          <source>How to access arrays and objects is fundamental JavaScript knowledge and therefore it is advisable to read the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide&quot;&gt;MDN JavaScript Guide&lt;/a&gt;, especially the sections</source>
          <target state="translated">配列とオブジェクトにアクセスする方法は、JavaScriptの基本的な知識であるため、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Guide&quot;&gt;MDN JavaScriptガイド&lt;/a&gt; 、特にセクションを読むことをお勧めします</target>
        </trans-unit>
        <trans-unit id="eb0d89c8fcff212602dcd6e7fc04c0868e952391" translate="yes" xml:space="preserve">
          <source>However, that will cause an exception as there is no property of object with that name. The solution to be able to use this would be to flatten the tree aspect of the object. This can be done recursively.</source>
          <target state="translated">しかし、その名前を持つオブジェクトのプロパティが存在しないため、例外が発生します。これを使えるようにするための解決策は、オブジェクトの木の側面を平らにすることです。これは再帰的に行うことができます。</target>
        </trans-unit>
        <trans-unit id="1d40fcba2ecc0667c34ad4970d750807180f7fa4" translate="yes" xml:space="preserve">
          <source>I don't think questioner just only concern one level nested object, so I present the following demo to demonstrate how to access the node of deeply nested json object. All right, let's find the node with id '5'.</source>
          <target state="translated">質問者は1レベルのネストされたオブジェクトだけを気にしているわけではないと思うので、以下のデモでは、深くネストされたjsonオブジェクトのノードにアクセスする方法をデモしています。それでは、idが'5'のノードを探してみましょう。</target>
        </trans-unit>
        <trans-unit id="7166a8fbe1b1257a300a599c03346689e3d076f9" translate="yes" xml:space="preserve">
          <source>I have a nested data structure containing objects and arrays. How can I extract the information, i.e. access a specific or multiple values (or keys)?</source>
          <target state="translated">オブジェクトと配列を含む入れ子になったデータ構造を持っています。情報を抽出して、特定の値や複数の値(またはキー)にアクセスするにはどうしたらいいですか?</target>
        </trans-unit>
        <trans-unit id="594c7197f24e01cab50a8fbc4fbff277875b36a9" translate="yes" xml:space="preserve">
          <source>I hope it can be useful for who's looking for options to manipulate really complex data which the title implies.</source>
          <target state="translated">タイトルが暗示している本当に複雑なデータを操作するためのオプションを探している人の参考になれば幸いです。</target>
        </trans-unit>
        <trans-unit id="296fb090ea76c582b0388c3ac82a7e3be47e1379" translate="yes" xml:space="preserve">
          <source>I prefer JQuery. It's cleaner and easy to read.</source>
          <target state="translated">私はJQueryの方が好きです。スッキリしていて読みやすいです。</target>
        </trans-unit>
        <trans-unit id="3f0e47884848a0f215b6b29d1c59ca91e00210de" translate="yes" xml:space="preserve">
          <source>I'm trying to access a property but I get only &lt;code&gt;undefined&lt;/code&gt; back?</source>
          <target state="translated">プロパティにアクセスしようとしていますが、 &lt;code&gt;undefined&lt;/code&gt; のみが返されますか？</target>
        </trans-unit>
        <trans-unit id="98da6135d533ae58636b970eb90d9ba4730fc07c" translate="yes" xml:space="preserve">
          <source>If the property being accessed is already known, but the path is complex, for example in this object</source>
          <target state="translated">アクセスされるプロパティがすでにわかっているが、パスが複雑な場合、例えばこのオブジェクトの場合は</target>
        </trans-unit>
        <trans-unit id="724f6164854c1dac5164b9dfe3bd016bf11ede2c" translate="yes" xml:space="preserve">
          <source>If the property names are unknown or we want to access all properties of an object / elements of an array, we can use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for...in&quot;&gt;&lt;code&gt;for...in&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; loop for objects and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for&quot;&gt;&lt;code&gt;for&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; loop for arrays to iterate over all properties / elements.</source>
          <target state="translated">プロパティ名が不明であるか、オブジェクトまたは配列の要素のすべてのプロパティにアクセスする場合は、オブジェクトの&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for...in&quot;&gt; &lt;code&gt;for...in&lt;/code&gt; &lt;/a&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Statements/for&quot;&gt;&lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;ループと配列の &lt;code&gt;for&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;ループを使用して、すべてを繰り返すことができます。プロパティ/要素。</target>
        </trans-unit>
        <trans-unit id="bb53041818a7cd5cefb1a698d8c5cf31a6bcdd25" translate="yes" xml:space="preserve">
          <source>If you already know the exact path, then you can hardcode it in your script like so:</source>
          <target state="translated">もし正確なパスがわかっているのであれば、スクリプトの中で以下のようにハードコードしてください。</target>
        </trans-unit>
        <trans-unit id="0860a5a97f7c2d0da5833e9fe22ae22b8354c139" translate="yes" xml:space="preserve">
          <source>If you are looking for one or more objects that meets certain criteria you have a few options using &lt;a href=&quot;https://www.npmjs.com/package/query-js&quot;&gt;query-js&lt;/a&gt;</source>
          <target state="translated">特定の基準を満たす1つ以上のオブジェクトを探している場合は、 &lt;a href=&quot;https://www.npmjs.com/package/query-js&quot;&gt;query-js&lt;/a&gt;を使用するいくつかのオプションがあります</target>
        </trans-unit>
        <trans-unit id="1e3bacf63ad2da6ad497c062e83ee1deb7143a5e" translate="yes" xml:space="preserve">
          <source>If you have a very long path, you might even use &lt;code&gt;String.split&lt;/code&gt; to make all of this easier -</source>
          <target state="translated">パスが非常に長い場合は、 &lt;code&gt;String.split&lt;/code&gt; を使用してこれらすべてを簡単にすることもできます-</target>
        </trans-unit>
        <trans-unit id="9c57867c2390b8a7a47e20ec0c1f1a52c4e1c717" translate="yes" xml:space="preserve">
          <source>In 2020, you can use @babel/plugin-proposal-optional-chaining it is very easy to access nested values in an object.</source>
          <target state="translated">2020年には、@babelplugin-proposal-optional-chainを使用することができますそれはオブジェクト内のネストされた値にアクセスすることは非常に簡単です。</target>
        </trans-unit>
        <trans-unit id="6eb25090a01eb8f321fc42bfc0d70eaff8d9d9a6" translate="yes" xml:space="preserve">
          <source>In addition to unknown keys, the &quot;depth&quot; of the data structure (i.e. how many nested objects) it has, might be unknown as well. How to access deeply nested properties usually depends on the exact data structure.</source>
          <target state="translated">不明なキーに加えて、データ構造の「深さ」(つまり入れ子になっているオブジェクトの数)も不明な場合があります。通常、深く入れ子になったプロパティにどのようにアクセスするかは、正確なデータ構造に依存します。</target>
        </trans-unit>
        <trans-unit id="f62878da4abd5200fcc9c37ddc894fac250f513c" translate="yes" xml:space="preserve">
          <source>In below &lt;code&gt;deep(data,key)&lt;/code&gt; function, you can use arbitrary &lt;code&gt;key&lt;/code&gt; string - in your case &lt;code&gt;items[1].name&lt;/code&gt; (you can use array notation &lt;code&gt;[i]&lt;/code&gt; at any level) - if key is invalid then undefined is return.</source>
          <target state="translated">以下の &lt;code&gt;deep(data,key)&lt;/code&gt; 関数では、任意の &lt;code&gt;key&lt;/code&gt; 文字列を使用できます。この場合、 &lt;code&gt;items[1].name&lt;/code&gt; （任意のレベルで配列表記 &lt;code&gt;[i]&lt;/code&gt; を使用できます）-キーが無効な場合、undefinedが返されます。</target>
        </trans-unit>
        <trans-unit id="ad27c437934b9b2b1645bf081b9a50483d122ac0" translate="yes" xml:space="preserve">
          <source>In case you are already using lodash in your project, I think an elegant way to do this in a complex example:</source>
          <target state="translated">すでにプロジェクトでlodashを使用している場合、複雑な例ではエレガントな方法だと思います。</target>
        </trans-unit>
        <trans-unit id="f33e9b91084a439b4cb911f507dd3f9d0cd299c8" translate="yes" xml:space="preserve">
          <source>In case you're trying to access an &lt;code&gt;item&lt;/code&gt; from the example structure by &lt;code&gt;id&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt;, without knowing it's position in the array, the easiest way to do it would be to use &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt; library:</source>
          <target state="translated">配列内の位置を知らずに、例の構造から &lt;code&gt;item&lt;/code&gt; &lt;code&gt;id&lt;/code&gt; または &lt;code&gt;name&lt;/code&gt; でアクセスしようとしている場合、それを行う最も簡単な方法は、 &lt;a href=&quot;http://underscorejs.org/&quot;&gt;underscore.js&lt;/a&gt;ライブラリを使用することです。</target>
        </trans-unit>
        <trans-unit id="0605dd9a6ef3a81e1e32ed89e65d051905a18d0b" translate="yes" xml:space="preserve">
          <source>In each iteration, &lt;code&gt;for...of&lt;/code&gt; directly gives us the next element of the iterable, there is no &quot;index&quot; to access or use.</source>
          <target state="translated">各反復で、 &lt;code&gt;for...of&lt;/code&gt; は反復可能オブジェクトの次の要素を直接提供するため、アクセスまたは使用する「インデックス」はありません。</target>
        </trans-unit>
        <trans-unit id="17dc34a7d73c6685088f5609dc9773446daecdd4" translate="yes" xml:space="preserve">
          <source>In environments supporting ES2015 (ES6), you can also use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;em&gt;&lt;code&gt;for...of&lt;/code&gt;&lt;/em&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; loop, which not only works for arrays, but for any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;&lt;em&gt;iterable&lt;/em&gt;&lt;/a&gt;:</source>
          <target state="translated">ES2015（ES6）をサポートする環境では、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;&lt;em&gt; &lt;code&gt;for...of&lt;/code&gt; &lt;/em&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;ループ&lt;em&gt;を&lt;/em&gt;使用することもできます。これは、配列だけでなく、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable&quot;&gt;&lt;em&gt;反復可能な&lt;/em&gt;&lt;/a&gt;場合にも機能します。</target>
        </trans-unit>
        <trans-unit id="e25c3f7d1a9be63d64a7b43f756eced2a48efc4a" translate="yes" xml:space="preserve">
          <source>It's very convenient to iterate the result of &lt;code&gt;Object.entries()&lt;/code&gt; with a &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;for-of loop&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;destructuring assignment&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;Object.entries()&lt;/code&gt; の結果を&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of&quot;&gt;for-ofループ&lt;/a&gt;と構造化&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;代入で&lt;/a&gt;反復処理すると非常に便利です。</target>
        </trans-unit>
        <trans-unit id="9a44b231f533fa321446e7f3e3baee1f38de9626" translate="yes" xml:space="preserve">
          <source>JSON is a textual representation of data, just like XML, YAML, CSV, and others. To work with such data, it first has to be converted to JavaScript data types, i.e. arrays and objects (and how to work with those was just explained). How to parse JSON is explained in the question &lt;a href=&quot;https://stackoverflow.com/questions/4935632/how-to-parse-json-in-javascript&quot;&gt;Parse JSON in JavaScript?&lt;/a&gt; .</source>
          <target state="translated">JSONは、XML、YAML、CSVなどと同様に、データのテキスト表現です。 このようなデータを操作するには、まず配列とオブジェクトなどのJavaScriptデータ型に変換する必要があります（これらの操作方法については先ほど説明しました）。 JSONを解析する方法は&lt;a href=&quot;https://stackoverflow.com/questions/4935632/how-to-parse-json-in-javascript&quot;&gt;、JavaScriptでのJSONの解析&lt;/a&gt;の質問で説明されていますか？ 。</target>
        </trans-unit>
        <trans-unit id="273c9ca1c021891558d65d83fde8a56bd31c05c7" translate="yes" xml:space="preserve">
          <source>JavaScript has only one data type which can contain multiple values: &lt;strong&gt;Object&lt;/strong&gt;. An &lt;strong&gt;Array&lt;/strong&gt; is a special form of object.</source>
          <target state="translated">JavaScriptには、複数の値を含むことができる1つのデータ型のみがあります： &lt;strong&gt;Object&lt;/strong&gt; 。 &lt;strong&gt;配列&lt;/strong&gt;はオブジェクトの特殊な形式です。</target>
        </trans-unit>
        <trans-unit id="f23bb5a89e2f0742d38b7b367e3f1f2f13e2d9df" translate="yes" xml:space="preserve">
          <source>Just in case, anyone's visiting this question in 2017 or later and looking for an &lt;strong&gt;easy-to-remember&lt;/strong&gt; way, here's an elaborate blog post on &lt;a href=&quot;https://dev.to/flexdinesh/accessing-nested-objects-in-javascript--9m4&quot;&gt;Accessing Nested Objects in JavaScript&lt;/a&gt; without being bamboozled by</source>
          <target state="translated">念のため、2017年以降にこの質問に&lt;a href=&quot;https://dev.to/flexdinesh/accessing-nested-objects-in-javascript--9m4&quot;&gt;アクセスし&lt;/a&gt; 、 &lt;strong&gt;覚えやすい&lt;/strong&gt;方法&lt;strong&gt;を&lt;/strong&gt;探している人は誰でも、JavaScriptでのネストされたオブジェクトへのアクセスに関する入念なブログ記事を公開しています。</target>
        </trans-unit>
        <trans-unit id="1498e370fa8a872e5cb603da9a26b604ef260bf7" translate="yes" xml:space="preserve">
          <source>Just my 2 cents.</source>
          <target state="translated">私の2セントだ</target>
        </trans-unit>
        <trans-unit id="0aee5af72f84d80641498878ee5470711b7f59fe" translate="yes" xml:space="preserve">
          <source>Let's assume we want to access the &lt;code&gt;name&lt;/code&gt; of the second item.</source>
          <target state="translated">2番目のアイテムの &lt;code&gt;name&lt;/code&gt; にアクセスしたいとします。</target>
        </trans-unit>
        <trans-unit id="56cc118b3be66a1cdf6909977e8abfc677c26f6c" translate="yes" xml:space="preserve">
          <source>Most of the time when you are getting &lt;code&gt;undefined&lt;/code&gt;, the object/array simply doesn't have a property with that name.</source>
          <target state="translated">ほとんどの場合、 &lt;code&gt;undefined&lt;/code&gt; になるのは、オブジェクト/配列にその名前のプロパティがない場合だけです。</target>
        </trans-unit>
        <trans-unit id="14486d9ed447554cbe361c938230a2a79b049782" translate="yes" xml:space="preserve">
          <source>My &lt;code&gt;stringjson&lt;/code&gt; is coming from PHP file but still, I indicate here in &lt;code&gt;var&lt;/code&gt;. When i directly take my json into &lt;code&gt;obj&lt;/code&gt; it will nothing show thats why i put my json file as</source>
          <target state="translated">私の &lt;code&gt;stringjson&lt;/code&gt; はPHPファイルからのものですが、それでも、ここでは &lt;code&gt;var&lt;/code&gt; で示しています。 私がjsonを直接 &lt;code&gt;obj&lt;/code&gt; に取り込むと、jsonファイルを次のように配置した理由は何も表示されません</target>
        </trans-unit>
        <trans-unit id="5a1c62cd71522c8e4b7755fe9dd24ecfec16d454" translate="yes" xml:space="preserve">
          <source>Notably it's probably overkill for this example, as simple array acccess is easier to read, but it comes in useful when breaking apart objects in general.</source>
          <target state="translated">この例では、単純な配列のアクセスの方が読みやすいので、特筆すべきはやりすぎかもしれませんが、一般的にオブジェクトを分解するときには便利です。</target>
        </trans-unit>
        <trans-unit id="8b85e6dbf0cb61793e767f18d29b4ef20f9d454b" translate="yes" xml:space="preserve">
          <source>Note: in many of the examples I'm using &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;arrow functions&lt;/a&gt;. They are similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;function expressions&lt;/a&gt;, but they bind the &lt;code&gt;this&lt;/code&gt; value lexically.</source>
          <target state="translated">注：多くの例では、 &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions&quot;&gt;矢印関数&lt;/a&gt;を使用しています 。 これらは&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function&quot;&gt;関数式&lt;/a&gt;に似ていますが、 &lt;code&gt;this&lt;/code&gt; 値を字句的にバインドします。</target>
        </trans-unit>
        <trans-unit id="4e833b435a215bc1ca1b9332c795269cd1fd5a55" translate="yes" xml:space="preserve">
          <source>Now, the complex object can be flattened</source>
          <target state="translated">これで、複雑なオブジェクトを平らにすることができるようになりました。</target>
        </trans-unit>
        <trans-unit id="fe8955a6c02557382cff4dc6d58daa1174562e1f" translate="yes" xml:space="preserve">
          <source>Objects and arrays has a lot of built-in methods that can help you with processing data.</source>
          <target state="translated">オブジェクトと配列には、データの処理に役立つメソッドがたくさん組み込まれています。</target>
        </trans-unit>
        <trans-unit id="79392da7a65cfe5eb93b63e66e9a83980b1e81ed" translate="yes" xml:space="preserve">
          <source>Old question but as nobody mentioned lodash (just underscore).</source>
          <target state="translated">古い質問ですが、誰もロダッシュに言及していないように(ちょうどアンダースコア)。</target>
        </trans-unit>
        <trans-unit id="fd959ba8c2d8fcf60e6cbbb63192e46ae580a4f9" translate="yes" xml:space="preserve">
          <source>One could also use &lt;code&gt;for...in&lt;/code&gt; to iterate over arrays, but there are reasons why this should be avoided: &lt;a href=&quot;https://stackoverflow.com/questions/2265167/why-is-forvar-item-in-list-with-arrays-considered-bad-practice-in-javascript&quot;&gt;Why is 'for(var item in list)' with arrays considered bad practice in JavaScript?&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;for...in&lt;/code&gt; を使用して配列を反復処理することもできますが、これを回避する必要がある理由があります。JavaScriptで配列の&lt;a href=&quot;https://stackoverflow.com/questions/2265167/why-is-forvar-item-in-list-with-arrays-considered-bad-practice-in-javascript&quot;&gt;'for（var item in list）'が配列の悪い習慣と見なさ&lt;/a&gt;れるのはなぜですか？ 。</target>
        </trans-unit>
        <trans-unit id="68a57fd3726c085ce337dc259dc3b2499a35efce" translate="yes" xml:space="preserve">
          <source>Preliminaries</source>
          <target state="translated">Preliminaries</target>
        </trans-unit>
        <trans-unit id="90ea2c98223eddf63e1721f90f66c3bdd52c50dd" translate="yes" xml:space="preserve">
          <source>Properties can be accessed either using &lt;strong&gt;dot notation&lt;/strong&gt;</source>
          <target state="translated">プロパティは、 &lt;strong&gt;ドット表記&lt;/strong&gt;を使用してアクセスできます</target>
        </trans-unit>
        <trans-unit id="12d45975709c333703d3231272e38bf942b4c555" translate="yes" xml:space="preserve">
          <source>Property access via dot walking: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&quot;&gt;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&lt;/a&gt;</source>
          <target state="translated">ドットウォーキングによるプロパティアクセス： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation&quot;&gt;https&lt;/a&gt; : //developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Property_Accessors#Dot_notation</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">コードスニペットを表示</target>
        </trans-unit>
        <trans-unit id="8741e75c1937a688fb16ac5022f3942e1c98839c" translate="yes" xml:space="preserve">
          <source>Since the structure of a complex object or array is not necessarily obvious, we can inspect the value at each step to decide how to move further. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt;&lt;code&gt;console.log&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt;&lt;code&gt;console.dir&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; help us doing this. For example (output of the Chrome console):</source>
          <target state="translated">複雑なオブジェクトや配列の構造は必ずしも明確ではないため、各ステップで値を調べて、さらに進む方法を決定できます。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt; &lt;code&gt;console.log&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;と&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt; &lt;code&gt;console.dir&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]は、&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;これを行うのに役立ちます。 例（Chromeコンソールの出力）：</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="f3b25614481a1e4857e6b5bdfaba4287e94bd50a" translate="yes" xml:space="preserve">
          <source>Source:  &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&quot;&gt;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&lt;/a&gt;</source>
          <target state="translated">ソース： &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects&quot;&gt;https&lt;/a&gt; : //learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-objects</target>
        </trans-unit>
        <trans-unit id="d7234880ccd53ae12304b04417b0d7fa7c1a4472" translate="yes" xml:space="preserve">
          <source>Source: &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&quot;&gt;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&lt;/a&gt;</source>
          <target state="translated">ソース： &lt;a href=&quot;https://learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/&quot;&gt;https&lt;/a&gt; : //learn.freecodecamp.org/javascript-algorithms-and-data-structures/basic-javascript/accessing-nested-arrays/</target>
        </trans-unit>
        <trans-unit id="68900ed6da7ee888a1cd51e372b1c1ff4e107fc5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;every()&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; if the specified callback function returns &lt;code&gt;true&lt;/code&gt; for &lt;em&gt;every&lt;/em&gt; element of the array. The &lt;code&gt;some()&lt;/code&gt; method returns &lt;code&gt;true&lt;/code&gt; if the specified callback function returns &lt;code&gt;true&lt;/code&gt; for &lt;em&gt;some&lt;/em&gt; (at least one) element.</source>
          <target state="translated">指定されたコールバック関数が配列の&lt;em&gt;すべての&lt;/em&gt;要素に対して &lt;code&gt;true&lt;/code&gt; を返す場合、 &lt;code&gt;every()&lt;/code&gt; メソッドは &lt;code&gt;true&lt;/code&gt; を返します 。 指定されたコールバック関数が&lt;em&gt;一部&lt;/em&gt; （少なくとも1つ）の要素に対して &lt;code&gt;true&lt;/code&gt; を返す場合、 &lt;code&gt;some()&lt;/code&gt; メソッドは &lt;code&gt;true&lt;/code&gt; を返します 。</target>
        </trans-unit>
        <trans-unit id="33d1029fc615078c793b267f4041434365372c89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;find()&lt;/code&gt; methods returns &lt;em&gt;the first&lt;/em&gt; element which satisfies the provided callback function. The &lt;code&gt;filter()&lt;/code&gt; method returns an array of &lt;em&gt;all&lt;/em&gt; elements which satisfies the provided callback function.</source>
          <target state="translated">&lt;code&gt;find()&lt;/code&gt; メソッドは、提供されたコールバック関数を満たす&lt;em&gt;最初の&lt;/em&gt;要素を返します。 &lt;code&gt;filter()&lt;/code&gt; メソッドは、提供されたコールバック関数を満たす&lt;em&gt;すべての&lt;/em&gt;要素の配列を返します。</target>
        </trans-unit>
        <trans-unit id="d5f79fd90ddeb2f0dad8e8b89f8687120668cbbb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;map()&lt;/code&gt; method returns an array with the results of calling a provided callback function on the array elements.</source>
          <target state="translated">&lt;code&gt;map()&lt;/code&gt; メソッドは、配列要素に対して提供されたコールバック関数を呼び出した結果の配列を返します。</target>
        </trans-unit>
        <trans-unit id="1faa15edac26d9a809a6705e2ec6c7d7b680ece1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reduce()&lt;/code&gt; method reduces an array to a single value by calling the provided callback function with two elements.</source>
          <target state="translated">&lt;code&gt;reduce()&lt;/code&gt; メソッドは、提供されたコールバック関数を2つの要素で呼び出すことにより、配列を単一の値に縮小します。</target>
        </trans-unit>
        <trans-unit id="0520f04f746ae9cf357ff8349cf95d6d07dfac04" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;reduce()&lt;/code&gt; method takes an optional second parameter, which is the initial value. This is useful when the array on which you call &lt;code&gt;reduce()&lt;/code&gt; can has zero or one elements. For example, if we wanted to create a function &lt;code&gt;sum()&lt;/code&gt; which takes an array as an argument and returns the sum of all elements, we could write it like that:</source>
          <target state="translated">&lt;code&gt;reduce()&lt;/code&gt; メソッドは、オプションの2番目のパラメーター（初期値）を取ります。 これは、 &lt;code&gt;reduce()&lt;/code&gt; を呼び出す配列にゼロまたは1つの要素がある場合に役立ちます。 たとえば、配列を引数として取り、すべての要素の合計を返す関数 &lt;code&gt;sum()&lt;/code&gt; を作成する場合は、次のように記述できます。</target>
        </trans-unit>
        <trans-unit id="87baea849532b922b02e9b36d55dcf711039c24a" translate="yes" xml:space="preserve">
          <source>The Underscore js Way</source>
          <target state="translated">アンダースコアjsのやり方</target>
        </trans-unit>
        <trans-unit id="02b44d265370739617a71ecd63227d93c6676625" translate="yes" xml:space="preserve">
          <source>The above example creates a variable called &lt;code&gt;secondName&lt;/code&gt; from the &lt;code&gt;name&lt;/code&gt; key from an array called &lt;code&gt;items&lt;/code&gt;, the lonely &lt;code&gt;,&lt;/code&gt; says skip the first object in the array.</source>
          <target state="translated">上記の例では、 &lt;code&gt;secondName&lt;/code&gt; という配列の &lt;code&gt;name&lt;/code&gt; キーから、 secondlyという変数を作成します。これは、孤独です。配列の最初のオブジェクトをスキップします。</target>
        </trans-unit>
        <trans-unit id="f564d08e3ef27ff8ec50b9e4201c532b7f5ead34" translate="yes" xml:space="preserve">
          <source>The difference between the first and second option is that in the &lt;strong&gt;Opt 1&lt;/strong&gt; if you have one of the properties missing (undefined) in the path you don't get an error, it returns you the third parameter.</source>
          <target state="translated">1番目と2番目のオプションの違いは、 &lt;strong&gt;オプション1&lt;/strong&gt;では、パスにプロパティの1つが欠落している（未定義の）場合にエラーが発生せず、3番目のパラメーターが返されるということです。</target>
        </trans-unit>
        <trans-unit id="ce5f176bd08d85341c79d5a125f2aa823648c1d8" translate="yes" xml:space="preserve">
          <source>The easiest and the cleanest way is to use Oliver Steele's nested object access pattern</source>
          <target state="translated">最も簡単でクリーンな方法は、オリバー・スティールの入れ子になったオブジェクトのアクセスパターンを使用することです。</target>
        </trans-unit>
        <trans-unit id="d78353eefe17d2875f09374f4d098adbece8da68" translate="yes" xml:space="preserve">
          <source>The path is a way to say: First take the object with key &lt;code&gt;items&lt;/code&gt;, which happens to be an array. Then take the &lt;code&gt;1&lt;/code&gt;-st element (0 index arrays). Last take the object with key &lt;code&gt;name&lt;/code&gt; in that array element, which happens to be the string &lt;code&gt;bar&lt;/code&gt;.</source>
          <target state="translated">パスは言い方です：最初にキー &lt;code&gt;items&lt;/code&gt; を含むオブジェクトを取得します。これはたまたま配列です。 次に、 &lt;code&gt;1&lt;/code&gt; 番目の要素（0のインデックス配列）を取得します。 最後に、配列要素のキー &lt;code&gt;name&lt;/code&gt; を持つオブジェクトを取得します。これはたまたま文字列 &lt;code&gt;bar&lt;/code&gt; です。</target>
        </trans-unit>
        <trans-unit id="f60727501ed0b0f71f29309fe28174d990a1a9da" translate="yes" xml:space="preserve">
          <source>The value is an array, to access its second element, we have to use bracket notation:</source>
          <target state="translated">値は配列で、2 番目の要素にアクセスするには大括弧表記を使用しなければなりません。</target>
        </trans-unit>
        <trans-unit id="0de40644ab3a8659c7ba0625cf4b76fa463b082b" translate="yes" xml:space="preserve">
          <source>There is also an excellent type handling minimal library &lt;a href=&quot;https://www.npmjs.com/package/typy&quot;&gt;typy&lt;/a&gt; that does all this for you.</source>
          <target state="translated">これをすべて行う、最小限のライブラリタイプを処理する優れたタイプもあります。</target>
        </trans-unit>
        <trans-unit id="c2a997c0df5cc6afc6f8f4bc954c694fb5e330ab" translate="yes" xml:space="preserve">
          <source>There's also a &lt;code&gt;single&lt;/code&gt; and a &lt;code&gt;singleOrDefault&lt;/code&gt; they work much like &lt;code&gt;first&lt;/code&gt;and &lt;code&gt;firstOrDefault&lt;/code&gt;respectively. The only difference is that they will throw if &lt;em&gt;more&lt;/em&gt; than one match is found.</source>
          <target state="translated">&lt;code&gt;single&lt;/code&gt; と &lt;code&gt;singleOrDefault&lt;/code&gt; もあり、それぞれ &lt;code&gt;first&lt;/code&gt; と &lt;code&gt;firstOrDefault&lt;/code&gt; のように機能します。 唯一の違いは、 &lt;em&gt;複数の&lt;/em&gt;一致が見つかった場合にスローすることです。</target>
        </trans-unit>
        <trans-unit id="cdca53564527cc4c83a547761777bdaaefd265a9" translate="yes" xml:space="preserve">
          <source>This is just plain JavaScript, without using any third party libraries like jQuery or lodash.</source>
          <target state="translated">これは、jQueryやlodashのようなサードパーティのライブラリを使用せずに、ただのシンプルなJavaScriptです。</target>
        </trans-unit>
        <trans-unit id="613d7e71a59cf49fd334373087cf8a7f7d514dbc" translate="yes" xml:space="preserve">
          <source>This is very brief intro to your specific use case, destructuring can be an unusual syntax to get used to at first. I'd recommend reading &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;Mozilla's Destructuring Assignment documentation&lt;/a&gt; to learn more.</source>
          <target state="translated">これは特定のユースケースのごく簡単な紹介です。構造化は、最初は慣れていない珍しい構文になる可能性があります。 詳細&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment&quot;&gt;については&lt;/a&gt; 、 MozillaのDestructuring Assignmentのドキュメントを読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="ca207417a9a4489be238e24e5dc9eee14df4e603" translate="yes" xml:space="preserve">
          <source>This question is quite old, so as a contemporary update. With the onset of ES2015 there are alternatives to get a hold of the data you require. There is now a feature called &lt;strong&gt;object destructuring&lt;/strong&gt; for accessing nested objects.</source>
          <target state="translated">この質問はかなり古いので、最新の更新として。 ES2015の開始に伴い、必要なデータを保持するための代替手段があります。 ネストされたオブジェクトにアクセスするためのオブジェクトのデストラクチャリングと呼ばれる機能があります。</target>
        </trans-unit>
        <trans-unit id="0b859db7c9baac7342be4c399fa4268d64580a50" translate="yes" xml:space="preserve">
          <source>This tells us that &lt;code&gt;data.items[1]&lt;/code&gt; is an object, and after expanding it we see that it has three properties, &lt;code&gt;id&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;__proto__&lt;/code&gt;. The latter is an internal property used for the prototype chain of the object. The prototype chain and inheritance is out of scope for this answer, though.</source>
          <target state="translated">これは、 &lt;code&gt;data.items[1]&lt;/code&gt; がオブジェクトであることを示しており、展開すると、 &lt;code&gt;id&lt;/code&gt; 、 &lt;code&gt;name&lt;/code&gt; 、および &lt;code&gt;__proto__&lt;/code&gt; の 3つのプロパティがあることがわかります。 後者は、オブジェクトのプロトタイプチェーンに使用される内部プロパティです。 ただし、プロトタイプチェーンと継承はこの回答の範囲外です。</target>
        </trans-unit>
        <trans-unit id="664137228398b0d17707a75bb9baa1603f7c4873" translate="yes" xml:space="preserve">
          <source>This value is an object and we use dot notation again to access the &lt;code&gt;name&lt;/code&gt; property. So we eventually get:</source>
          <target state="translated">この値はオブジェクトであり、再びドット表記を使用して &lt;code&gt;name&lt;/code&gt; プロパティにアクセスします。 したがって、最終的には次のようになります。</target>
        </trans-unit>
        <trans-unit id="9768ca2740c20ae8117706d5dc8fead7bf0b3e46" translate="yes" xml:space="preserve">
          <source>To access a nested attribute, you need to specify its name and then search through the object.</source>
          <target state="translated">入れ子になった属性にアクセスするには、その名前を指定してからオブジェクトを検索する必要があります。</target>
        </trans-unit>
        <trans-unit id="56e3fdff87ae9f0ae61a5a84dce9e283d8be9946" translate="yes" xml:space="preserve">
          <source>To be able to access nested arrays, you can write your own array reduce util.</source>
          <target state="translated">入れ子になった配列にアクセスできるようにするには、独自の配列reduce utilを書くことができます。</target>
        </trans-unit>
        <trans-unit id="49f8a91e4cfa2d6b3229f29def0311f69307f574" translate="yes" xml:space="preserve">
          <source>To iterate over all elements of the &lt;code&gt;data.items&lt;/code&gt;&lt;strong&gt;array&lt;/strong&gt;, we use a &lt;code&gt;for&lt;/code&gt; loop:</source>
          <target state="translated">&lt;code&gt;data.items&lt;/code&gt; &lt;strong&gt;配列の&lt;/strong&gt;すべての要素を反復処理するには、 &lt;code&gt;for&lt;/code&gt; ループを使用します。</target>
        </trans-unit>
        <trans-unit id="6c1ce5587a33fa10b3413df43f4e8e8a4dae0d1e" translate="yes" xml:space="preserve">
          <source>To iterate over all properties of &lt;code&gt;data&lt;/code&gt;, we can iterate over the &lt;strong&gt;object&lt;/strong&gt; like so:</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; のすべてのプロパティを反復処理するには、次のように&lt;strong&gt;オブジェクトを&lt;/strong&gt;反復処理し&lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b2df20f42b29bf3e20fea1c0b9e55f35846c2b6" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt;&lt;code&gt;console.log&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt;&lt;code&gt;console.dir&lt;/code&gt;&lt;/a&gt; and inspect the structure of object / array. The property you are trying to access might be actually defined on a nested object / array.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.log&quot;&gt; &lt;code&gt;console.log&lt;/code&gt; &lt;/a&gt;または&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/DOM/console.dir&quot;&gt; &lt;code&gt;console.dir&lt;/code&gt; &lt;/a&gt;を使用して、オブジェクト/配列の構造を調べます。 アクセスしようとしているプロパティは、ネストされたオブジェクト/配列で実際に定義されている可能性があります。</target>
        </trans-unit>
        <trans-unit id="72f0f0ca7535a2f887b045ea5d0ca8f48ce694a9" translate="yes" xml:space="preserve">
          <source>Using &lt;strong&gt;JSONPath&lt;/strong&gt; would be one of the most flexible solutions if you are willing to include a library:
&lt;a href=&quot;https://github.com/s3u/JSONPath&quot;&gt;https://github.com/s3u/JSONPath&lt;/a&gt; (node and browser)</source>
          <target state="translated">ライブラリを含める場合は、 &lt;strong&gt;JSONPath&lt;/strong&gt;を使用することが最も柔軟なソリューションの1つになり&lt;a href=&quot;https://github.com/s3u/JSONPath&quot;&gt;ます。https&lt;/a&gt; ： //github.com/s3u/JSONPath （ノードとブラウザー）</target>
        </trans-unit>
        <trans-unit id="dd203328bc98a927636df7b5efb2d4b1ffa6e6f4" translate="yes" xml:space="preserve">
          <source>Wait... what about JSON?</source>
          <target state="translated">待って、JSONはどうなの?</target>
        </trans-unit>
        <trans-unit id="3e274725ac7462274d545e66a9e93ca5ef1df972" translate="yes" xml:space="preserve">
          <source>What if the &quot;depth&quot; of the data structure is unknown to me?</source>
          <target state="translated">データ構造の「深さ」が自分ではわからない場合はどうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="0fff2ae2dbc525ac2a28a45db0cb87ff3327df68" translate="yes" xml:space="preserve">
          <source>What if the property names are dynamic and I don't know them beforehand?</source>
          <target state="translated">プロパティ名が動的で、事前にわからない場合はどうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="33d729be609d12f4e50fd456f76e8b7cce6707b0" translate="yes" xml:space="preserve">
          <source>When you don't know the exact name before hand, or a user is the one who provides the name for you. Then dynamically searching through the data structure is required. Some suggested here that the search can be done using a &lt;code&gt;for&lt;/code&gt; loop, but there is a very simple way to traverse a path using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt;&lt;code&gt;Array.reduce&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">正確な名前が事前にわからない場合、またはユーザーが名前を提供するユーザーである場合。 次に、データ構造全体を動的に検索する必要があります。 &lt;code&gt;for&lt;/code&gt; ループを使用して検索を実行できるとここで提案している人もいますが、 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce&quot;&gt; &lt;code&gt;Array.reduce&lt;/code&gt; &lt;/a&gt;を使用してパスをトラバースする非常に簡単な方法があります。</target>
        </trans-unit>
        <trans-unit id="afd41e005ac69d70994393c4db3fa04d17c51a06" translate="yes" xml:space="preserve">
          <source>Which is a JavaScript library that provides a whole mess of useful &lt;code&gt;functional programming&lt;/code&gt; helpers without extending any built-in objects.</source>
          <target state="translated">これは、組み込みオブジェクトを拡張せずに、便利な &lt;code&gt;functional programming&lt;/code&gt; ヘルパーをすべて提供するJavaScriptライブラリです。</target>
        </trans-unit>
        <trans-unit id="426bb082ff6e5896064dd959ec8bae3683981cd9" translate="yes" xml:space="preserve">
          <source>With the increasing browser support of ECMAScript 5, the array method &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt;&lt;code&gt;forEach&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt; becomes an interesting alternative as well:</source>
          <target state="translated">ECMAScript 5のブラウザーサポートの増加に伴い、配列メソッド&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach&quot;&gt; &lt;code&gt;forEach&lt;/code&gt; &lt;em&gt;&lt;sup&gt;[MDN]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;も興味深い代替手段になります。</target>
        </trans-unit>
        <trans-unit id="6e0bb43e7e58f1dccb01b724584c7e815f5113e7" translate="yes" xml:space="preserve">
          <source>With this notation, you'll never run into</source>
          <target state="translated">この表記法を使えば</target>
        </trans-unit>
        <trans-unit id="23f0d329dcf4a9e1c2a145121c1a0c7cebda6e99" translate="yes" xml:space="preserve">
          <source>Working fiddle: &lt;a href=&quot;https://jsfiddle.net/andreitodorut/3mws3kjL/&quot;&gt;https://jsfiddle.net/andreitodorut/3mws3kjL/&lt;/a&gt;</source>
          <target state="translated">作業フィドル： &lt;a href=&quot;https://jsfiddle.net/andreitodorut/3mws3kjL/&quot;&gt;https&lt;/a&gt; : //jsfiddle.net/andreitodorut/3mws3kjL/</target>
        </trans-unit>
        <trans-unit id="df5a94f92bfe3900361a91260e60682f362b48ec" translate="yes" xml:space="preserve">
          <source>Working with Objects</source>
          <target state="translated">オブジェクトの操作</target>
        </trans-unit>
        <trans-unit id="4497254d63e510893ef09f0c7afb22fec75a65de" translate="yes" xml:space="preserve">
          <source>You basically check if user exists, if not, you create an empty object on the fly. This way, the next level key will &lt;strong&gt;always be accessed from an object that exists or an empty object&lt;/strong&gt;, but never from undefined.</source>
          <target state="translated">基本的に、ユーザーが存在するかどうかを確認し、存在しない場合は、その場で空のオブジェクトを作成します。 このように、次のレベルのキーは&lt;strong&gt;常に、存在するオブジェクトまたは空のオブジェクトからアクセスされます&lt;/strong&gt;が、未定義から&lt;strong&gt;アクセスされる&lt;/strong&gt;ことはありません。</target>
        </trans-unit>
        <trans-unit id="17f3f05296a9f74d4837489378560984a26833b0" translate="yes" xml:space="preserve">
          <source>You can access it this way</source>
          <target state="translated">この方法でアクセスできます。</target>
        </trans-unit>
        <trans-unit id="cfa469e890d94b193d15281607d34ec28b836ae7" translate="yes" xml:space="preserve">
          <source>You can use the syntax &lt;code&gt;jsonObject.key&lt;/code&gt; to access the the value. And if you want access a value from an array, then you can use the syntax &lt;code&gt;jsonObjectArray[index].key&lt;/code&gt;.</source>
          <target state="translated">値 &lt;code&gt;jsonObject.key&lt;/code&gt; を使用して値にアクセスできます。 また、配列から値にアクセスする場合は、構文 &lt;code&gt;jsonObjectArray[index].key&lt;/code&gt; 使用できます 。</target>
        </trans-unit>
        <trans-unit id="1c57e8d7f2d3c9338d66a6c78ba4fcafd728a6f7" translate="yes" xml:space="preserve">
          <source>You could use &lt;code&gt;lodash _get&lt;/code&gt; function:</source>
          <target state="translated">&lt;code&gt;lodash _get&lt;/code&gt; 関数を使用できます。</target>
        </trans-unit>
        <trans-unit id="4a87503c2fa7c97664a81fd80a5702f7d91e2b3b" translate="yes" xml:space="preserve">
          <source>for further explanation of query-js you can start with this &lt;a href=&quot;http://runefs.com/2015/06/04/working-with-data-in-javascript/&quot;&gt;post&lt;/a&gt;</source>
          <target state="translated">query-jsの詳細については、この&lt;a href=&quot;http://runefs.com/2015/06/04/working-with-data-in-javascript/&quot;&gt;投稿&lt;/a&gt;から始めることができます</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="7ac01203eeb458726d789e7d2607af95159fd2ed" translate="yes" xml:space="preserve">
          <source>or &lt;strong&gt;bracket notation&lt;/strong&gt;, if the property name would not be a valid JavaScript &lt;a href=&quot;http://es5.github.com/#x7.6&quot;&gt;identifier name &lt;em&gt;&lt;sup&gt;[spec]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;, or the name is the value of a variable:</source>
          <target state="translated">または&lt;strong&gt;ブラケット表記&lt;/strong&gt; （プロパティ名が有効なJavaScript &lt;a href=&quot;http://es5.github.com/#x7.6&quot;&gt;識別子名&lt;em&gt;&lt;sup&gt;[spec]&lt;/sup&gt;&lt;/em&gt;&lt;/a&gt;ではない場合、または名前が変数の値である場合）：</target>
        </trans-unit>
        <trans-unit id="af3ec5b75c689d26309f57c2989dae794c7b17cd" translate="yes" xml:space="preserve">
          <source>same as:</source>
          <target state="translated">と同じです。</target>
        </trans-unit>
        <trans-unit id="3bdb8452054fa2b577dec841756010a549232d09" translate="yes" xml:space="preserve">
          <source>so:</source>
          <target state="translated">so:</target>
        </trans-unit>
        <trans-unit id="560572a782680d5c66f76b07c8f3ba5b61030e77" translate="yes" xml:space="preserve">
          <source>these also work -</source>
          <target state="translated">これらも動作します。</target>
        </trans-unit>
        <trans-unit id="c86c30365c1ce95f0ba082ac38ab0704ccf05de4" translate="yes" xml:space="preserve">
          <source>to add to this, accessing nested Arrays would happen like so:</source>
          <target state="translated">これに加えて、ネストされた配列にアクセスすると、次のようになります。</target>
        </trans-unit>
        <trans-unit id="612f40ac9069ed110eabdcfa125d119cd7f891bf" translate="yes" xml:space="preserve">
          <source>where &lt;em&gt;data&lt;/em&gt; is a python list (parsed from a JSON text string):</source>
          <target state="translated">ここで、 &lt;em&gt;データ&lt;/em&gt;はpythonリストです（JSONテキスト文字列から解析）：</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
