<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1125968">
    <body>
      <group id="1125968">
        <trans-unit id="5afb90bc1680715416282876077bc225842cbc96" translate="yes" xml:space="preserve">
          <source>&quot;-X&quot; is an option name, and &quot;theirs&quot; is the value for that option. You're choosing to use &quot;their&quot; changes, instead of &quot;your&quot; changes if there is a conflict.</source>
          <target state="translated">&quot;-X&quot;는 옵션 이름이고 &quot;-그들의&quot;는 해당 옵션의 값입니다. 충돌이있는 경우 &quot;자신의&quot;변경 사항 대신 &quot;자신의&quot;변경 사항을 사용하도록 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="70ecf3b9a626c0d63016862459beb96a7cd9fd04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; downloads the latest from remote without trying to merge or rebase anything.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 는 아무것도 병합하거나 리베이스하지 않고 원격에서 최신 버전을 다운로드합니다.</target>
        </trans-unit>
        <trans-unit id="bc940fd283a79b9e47237dc19b00c61dd5539710" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard origin/master&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git reset --hard origin/master&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8b77648ec75a644255f4be7f9dd3cb5598cd48b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git pull --rebase&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git pull --rebase&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f4dc4e310800c0b0a13a28965d7a56a3b773f32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fetch&lt;/strong&gt; with a &lt;strong&gt;clean&lt;/strong&gt; of &lt;strong&gt;files&lt;/strong&gt; and &lt;strong&gt;directories&lt;/strong&gt; ignoring &lt;strong&gt;.gitignore&lt;/strong&gt; and &lt;strong&gt;hard reset&lt;/strong&gt; to &lt;strong&gt;origin&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;.gitignore를&lt;/strong&gt; 무시하고 &lt;strong&gt;원본으로&lt;/strong&gt; &lt;strong&gt;강제 재설정&lt;/strong&gt; 하여 &lt;strong&gt;파일&lt;/strong&gt; 과 &lt;strong&gt;디렉토리를&lt;/strong&gt; &lt;strong&gt;정리&lt;/strong&gt; 하여 &lt;strong&gt;가져&lt;/strong&gt; &lt;strong&gt;옵니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6031888574223bffc84d9cd8bf2d9a79f815c173" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stash&lt;/strong&gt; the local changes.</source>
          <target state="translated">로컬 변경 사항을 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="dcc197827149be97581e309fb6dce7a656af78bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The scenario is the following:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;시나리오는 다음과 같습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3c42a8134f0739a17a678e3e0dcb0771efa7cdb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the error I'm getting:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이것은 내가 얻는 오류입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4a7132acfa00c3c71261b610b730a413f758186" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING: &lt;code&gt;git clean&lt;/code&gt; deletes all your untracked files/directories and can't be undone.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;경고 : &lt;code&gt;git clean&lt;/code&gt; 은 추적되지 않은 모든 파일 / 디렉토리를 삭제하며 취소 할 수 없습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="967b8bcb08e168bba241f9faffbb234be29aee97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning, doing this will permanently delete your files if you have any directory/* entries in your gitignore file.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;경고, gitignore 파일에 디렉토리 / * 항목이 있으면 파일을 영구적으로 삭제합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c62d7e7d52d9e8d8a3e0ab4fcbe742a08c5a51f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This script is very powerful, so you could lose your changes.</source>
          <target state="translated">&lt;strong&gt;경고&lt;/strong&gt; :이 스크립트는 매우 강력하여 변경 사항을 잃을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c5e0c503728653826db9fcefc33c40057e4a0cf" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;strong&gt;Warning&lt;/strong&gt;: Above commands can results in data/files loss only if you don't have them committed! If you're not sure, make the backup first of your whole repository folder.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;strong&gt;경고&lt;/strong&gt; : 위의 명령은 커밋하지 않은 경우에만 데이터 / 파일이 손실 될 수 있습니다!&lt;/sup&gt; &lt;sup&gt;확실하지 않으면 먼저 전체 저장소 폴더를 백업하십시오.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1ed6e68c2afe2cc46a2ddfb7b88e004a4df0bc59" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[*]&lt;/sup&gt;: It's worth noting that it is possible to maintain current local commits by creating a branch from &lt;code&gt;master&lt;/code&gt; before resetting:</source>
          <target state="translated">&lt;sup&gt;[*]&lt;/sup&gt; : 재설정하기 전에 &lt;code&gt;master&lt;/code&gt; 에서 분기를 작성하여 현재 로컬 커밋을 유지할 수 있다는 점에 주목할 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="36038a15055095eee9da18058a5e2c67e12a05ad" translate="yes" xml:space="preserve">
          <source>A team member is modifying the templates for a website we are working on</source>
          <target state="translated">팀원이 작업중인 웹 사이트의 템플릿을 수정하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="a180c1f257cadb94780423f139159de8269da2c0" translate="yes" xml:space="preserve">
          <source>After this, all of the old commits will be kept in &lt;code&gt;new-branch-to-save-current-commits&lt;/code&gt;.</source>
          <target state="translated">그 후, 모든 이전 커밋은 &lt;code&gt;new-branch-to-save-current-commits&lt;/code&gt; 에 유지 됩니다.</target>
        </trans-unit>
        <trans-unit id="36c034e52a3013a7eb18bd0e736106a3162dc9b7" translate="yes" xml:space="preserve">
          <source>An easier way would be to:</source>
          <target state="translated">더 쉬운 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a7eccdc85e1d8fab375e2e045e94fc4580337ef4" translate="yes" xml:space="preserve">
          <source>And then do a cleanup (removes untracked files from the working tree):</source>
          <target state="translated">그런 다음 정리를 수행하십시오 (작업 트리에서 추적되지 않은 파일을 제거합니다).</target>
        </trans-unit>
        <trans-unit id="78daf6f4dc00ac5359931b14a322206862bd8d53" translate="yes" xml:space="preserve">
          <source>And then to reapply these uncommitted changes:</source>
          <target state="translated">그런 다음 커밋되지 않은 변경 사항을 다시 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="3dbb2aa68555e791ab4d7fde77f19d2a5b2a8a25" translate="yes" xml:space="preserve">
          <source>As you notice, there are two different kind of file systems, so the one which doesn't support Unix permissions basically can't reset file permissions on system which doesn't support that kind of permissions, so no matter how &lt;code&gt;--hard&lt;/code&gt; you try, git always detect some &quot;changes&quot;.</source>
          <target state="translated">아시다시피, 두 종류의 파일 시스템이 있으므로 Unix 권한을 지원하지 않는 시스템은 기본적으로 해당 권한을 지원하지 않는 시스템에서 파일 권한을 재설정 할 수 없습니다. git은 항상 &quot;변화&quot;를 감지합니다.</target>
        </trans-unit>
        <trans-unit id="176ed3df07c6cab12f3824cd3af53a19fe5a4ac5" translate="yes" xml:space="preserve">
          <source>Based on a combination of &lt;a href=&quot;https://stackoverflow.com/a/8888015/1103543&quot;&gt;RNA's answer&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/19961461/1103543&quot;&gt;torek's answer to a similar question&lt;/a&gt;, I've come up with this which works splendidly:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/8888015/1103543&quot;&gt;RNA의 대답&lt;/a&gt; 과 &lt;a href=&quot;https://stackoverflow.com/a/19961461/1103543&quot;&gt;비슷한 질문에 대한 torek의 대답&lt;/a&gt; 의 조합을 바탕으로, 나는 훌륭하게 작동하는 이것을 생각해 냈습니다.</target>
        </trans-unit>
        <trans-unit id="5c86cd4334fa80da1de659e41c3792751d28a710" translate="yes" xml:space="preserve">
          <source>Based on my own similar experiences, the solution offered by Strahinja Kustudic above is by far the best.  As others have pointed out, simply doing hard reset will remove &lt;strong&gt;all&lt;/strong&gt; the untracked files which could include lots of things that you don't want removed, such as config files.  What is safer, is to remove only the files that are about to be added, and for that matter, you'd likely also want to checkout any locally-modified files that are about to be updated.</source>
          <target state="translated">내 자신의 비슷한 경험을 기반으로 위의 Strahinja Kustudic에서 제공하는 솔루션이 훨씬 좋습니다. 다른 사람들이 지적했듯이 하드 재설정을 수행하면 구성 파일과 같이 제거하고 싶지 않은 많은 항목을 포함 할 수있는 &lt;strong&gt;모든&lt;/strong&gt; 추적되지 않은 파일이 제거됩니다. 더 안전한 방법은 추가 할 파일 만 제거하는 것입니다.이 문제로 인해 업데이트 될 로컬에서 수정 된 파일도 체크 아웃하고 싶을 것입니다.</target>
        </trans-unit>
        <trans-unit id="66fd03594a2c157f1cc4300404f810b1d6f6ef22" translate="yes" xml:space="preserve">
          <source>Before pushing your newly commit to server, try this command and it will automatically synchronise the latest server changes (with a fetch + merge) and will place your commit at the top in the Git log. There isn't any need to worry about manual pull/merge.</source>
          <target state="translated">새로 커밋을 서버로 푸시하기 전에이 명령을 시도하면 최신 서버 변경 사항 (페치 + 병합)을 자동으로 동기화하고 커밋을 Git 로그의 맨 위에 배치합니다. 수동 당김 / 병합에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5763578555f814c96231de97e5710d397db26670" translate="yes" xml:space="preserve">
          <source>Bonus:</source>
          <target state="translated">Bonus:</target>
        </trans-unit>
        <trans-unit id="3c246aca15204187cf5403a724bf7c4ed1f89f75" translate="yes" xml:space="preserve">
          <source>Brutally, all-at-once:</source>
          <target state="translated">잔인하게, 한 번에 :</target>
        </trans-unit>
        <trans-unit id="0f3d70d10152b31329fca6d57c58dd5a7548905c" translate="yes" xml:space="preserve">
          <source>Consider using &lt;code&gt;-n&lt;/code&gt; (&lt;code&gt;--dry-run&lt;/code&gt;) flag first. This will show you what will be deleted without actually deleting anything:</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; ( &lt;code&gt;--dry-run&lt;/code&gt; ) 플래그를 먼저 사용하십시오. 실제로 아무것도 삭제하지 않고 삭제할 내용이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="27a5712e08f3ae4b6c16fa9dbe1f57b88d828e9d" translate="yes" xml:space="preserve">
          <source>Custom rules in &lt;code&gt;.gitattributes file&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.gitattributes file&lt;/code&gt; 사용자 정의 규칙</target>
        </trans-unit>
        <trans-unit id="5969bf1b4e4687ca1fb9f6fc009150bef42d135f" translate="yes" xml:space="preserve">
          <source>Delete all the files. Leave just the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">모든 파일을 삭제하십시오. &lt;code&gt;.git&lt;/code&gt; 디렉토리 만 남겨 두십시오.</target>
        </trans-unit>
        <trans-unit id="1ac1711535c3631326eb072df130168ba61081aa" translate="yes" xml:space="preserve">
          <source>Despite the original question, the top answers can cause problems for people who have a similar problem, but don't want to lose their local files. For example, see Al-Punk and crizCraig's comments.</source>
          <target state="translated">원래의 질문에도 불구하고, 최상위 답변은 비슷한 문제가 있지만 로컬 파일을 잃고 싶지 않은 사람들에게 문제를 일으킬 수 있습니다. 예를 들어 Al-Punk 및 crizCraig의 의견을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f5169c84497de3aea74f7da9e7e177d1427e736b" translate="yes" xml:space="preserve">
          <source>Enjoy!</source>
          <target state="translated">Enjoy!</target>
        </trans-unit>
        <trans-unit id="2e4ccc244461fd2a12825ef96a60da2329e2ce3c" translate="yes" xml:space="preserve">
          <source>Example output:</source>
          <target state="translated">출력 예 :</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="633b8ed4341c493911bcdea67fbf3a7e52e105ed" translate="yes" xml:space="preserve">
          <source>File system incompability</source>
          <target state="translated">파일 시스템 비 호환</target>
        </trans-unit>
        <trans-unit id="ac51316d6159411acf5b3f583c8d9c8a8d26ccdc" translate="yes" xml:space="preserve">
          <source>Finally we do a pull to update to the newest version, but this time without any conflicts, since untracked files which are in the repo don't exist anymore and all the locally modified files are already the same as in the repository.</source>
          <target state="translated">마지막으로 우리는 최신 버전으로 업데이트를 시도하지만 이번에는 충돌이 발생하지 않습니다. 저장소에있는 추적되지 않은 파일이 더 이상 존재하지 않으며 로컬에서 수정 된 모든 파일이 이미 저장소와 동일하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="733954012af2f88caae800ae8ecbbdd4f2b12025" translate="yes" xml:space="preserve">
          <source>Find details in &lt;em&gt;&lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;What does &quot;git pull --rebase&quot; do?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;&quot;git pull --rebase&quot;의 기능은 무엇입니까?&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6dc0d8358e432ef94381d4e39acde5f09ef69da0" translate="yes" xml:space="preserve">
          <source>First do a commit of your changes</source>
          <target state="translated">먼저 변경 사항을 커밋하십시오.</target>
        </trans-unit>
        <trans-unit id="b3e145b7648ef683eaac2a7805b4e4b762bbad1f" translate="yes" xml:space="preserve">
          <source>First of all, try the standard way:</source>
          <target state="translated">우선 표준 방법을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="e91bc256ad13d894ea5b4b99e3446667f554a6a2" translate="yes" xml:space="preserve">
          <source>For next time, you can probably handle this in a cleaner way by looking up &quot;git stash branch&quot; though stash is likely to cause you trouble on the first few tries, so do first experiment on a non-critical project...</source>
          <target state="translated">다음 시간에는 &quot;git stash branch&quot;를 찾아서 더 깔끔하게 처리 할 수 ​​있지만 stash는 처음 몇 번의 시도에서 문제를 일으킬 수 있으므로 중요하지 않은 프로젝트를 먼저 실험하십시오 ...</target>
        </trans-unit>
        <trans-unit id="c89f6341c557881ef5a26399ed1653fe3ebdf78e" translate="yes" xml:space="preserve">
          <source>Having &lt;code&gt;eol=lf&lt;/code&gt; rule in .gitattributes could cause git to modify some file changes by converting CRLF line-endings into LF in some text files.</source>
          <target state="translated">.gitattributes에 &lt;code&gt;eol=lf&lt;/code&gt; 규칙이 있으면 git이 일부 텍스트 파일에서 CRLF 줄 끝을 LF로 변환하여 일부 파일 변경 사항을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93154f89378492cd0c83e1aab6e6159f0de9d7ea" translate="yes" xml:space="preserve">
          <source>Here is the cleanest solution which we are using:</source>
          <target state="translated">우리가 사용하는 가장 깨끗한 솔루션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1f637bf42e756c960767eb126fdd9d9bebbd7a74" translate="yes" xml:space="preserve">
          <source>How do I force Git to overwrite them? The person is a designer - usually, I resolve all the conflicts by hand, so the server has the most recent version that they just need to update on their computer.</source>
          <target state="translated">힘내 강제로 그들을 덮어 쓰려면 어떻게합니까? 사람은 디자이너입니다-일반적으로 모든 충돌을 수동으로 해결하므로 서버는 컴퓨터에서 업데이트 해야하는 최신 버전을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3a2f47cc14d50df3baa2c14a0ddf658114561df" translate="yes" xml:space="preserve">
          <source>How do I force an overwrite of local files on a &lt;code&gt;git pull&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 에서 로컬 파일을 강제로 덮어 쓰려면 어떻게합니까?</target>
        </trans-unit>
        <trans-unit id="022b126cf5d96f5acd5353613e02e8e093951fcf" translate="yes" xml:space="preserve">
          <source>How do I force “git pull” to overwrite local files</source>
          <target state="translated">&amp;ldquo;git pull&amp;rdquo;을 사용하여 로컬 파일을 덮어 쓰는 방법</target>
        </trans-unit>
        <trans-unit id="dea1758cfb7d54073565d160ed1da9d3735d7d43" translate="yes" xml:space="preserve">
          <source>I believe there are two possible causes of conflict, which must be solved separately, and as far as I can tell none of the above answers deals with both:</source>
          <target state="translated">나는 두 가지 가능한 갈등의 원인이 있다고 생각합니다.이 원인은 별도로 해결해야하며 위의 답변 중 어느 것도 두 가지를 다룰 수 없다고 말할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="9d39e53821ce6f629f48322aff08f227653eb992" translate="yes" xml:space="preserve">
          <source>I found that by looking up &lt;a href=&quot;https://stackoverflow.com/questions/2389361/git-undo-a-merge&quot;&gt;how to undo a Git merge&lt;/a&gt;.</source>
          <target state="translated">나는 &lt;a href=&quot;https://stackoverflow.com/questions/2389361/git-undo-a-merge&quot;&gt;Git 병합을 취소하는 방법을&lt;/a&gt; 찾는 것을 발견했다.</target>
        </trans-unit>
        <trans-unit id="95f170181b4a919a57346c13c88eae271970ecf3" translate="yes" xml:space="preserve">
          <source>I had a similar problem.  I had to do this:</source>
          <target state="translated">나는 비슷한 문제가 있었다. 나는 이것을해야했다.</target>
        </trans-unit>
        <trans-unit id="8628e6103828b4e62119bb52d8a10ca6f0446469" translate="yes" xml:space="preserve">
          <source>I had the same problem and for some reason, even a &lt;code&gt;git clean -f -d&lt;/code&gt; would not do it. Here is why: For some reason, if your file is ignored by Git (via a .gitignore entry, I assume), it still bothers about overwriting this with a later &lt;em&gt;pull&lt;/em&gt;, but a &lt;em&gt;clean&lt;/em&gt; will not remove it, unless you add &lt;code&gt;-x&lt;/code&gt;.</source>
          <target state="translated">나는 같은 문제가 있었고 어떤 이유로 든 &lt;code&gt;git clean -f -d&lt;/code&gt; 조차도 그렇게하지 않을 것입니다. 이유는 다음과 같습니다. 어떤 이유로 파일이 Git에 의해 무시되면 (.gitignore 항목을 통해) 나중에 &lt;em&gt;pull으로 파일을&lt;/em&gt; 덮어 쓰지 않아도되지만 &lt;code&gt;-x&lt;/code&gt; 를 추가하지 않으면 파일을 제거하지 않습니다. .</target>
        </trans-unit>
        <trans-unit id="cfc7e1dda03c9f91868de6432e4c926b6660c9cf" translate="yes" xml:space="preserve">
          <source>I had the same problem. No one gave me this solution, but it worked for me.</source>
          <target state="translated">나는 같은 문제가 있었다. 아무도 나 에게이 해결책을주지 않았지만 그것은 나를 위해 일했다.</target>
        </trans-unit>
        <trans-unit id="649a0254690bae34aa046e5cb6817593ddfefee6" translate="yes" xml:space="preserve">
          <source>I have a strange situation that neither &lt;code&gt;git clean&lt;/code&gt; or &lt;code&gt;git reset&lt;/code&gt; works. I have to remove the conflicting file from &lt;code&gt;git index&lt;/code&gt; by using the following script on every untracked file:</source>
          <target state="translated">&lt;code&gt;git clean&lt;/code&gt; 또는 &lt;code&gt;git reset&lt;/code&gt; 이 작동하지 않는 이상한 상황이 있습니다. 추적되지 않은 모든 파일에서 다음 스크립트를 사용하여 &lt;code&gt;git index&lt;/code&gt; 에서 충돌하는 파일을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="7e8500eb1046100f489050b284eb5714559dccd2" translate="yes" xml:space="preserve">
          <source>I just solved this myself by:</source>
          <target state="translated">방금이 문제를 직접 해결했습니다.</target>
        </trans-unit>
        <trans-unit id="128a6bbe4bbca0ef46a7429b3fb884d19161c0cc" translate="yes" xml:space="preserve">
          <source>I know of a much easier and less painful method:</source>
          <target state="translated">나는 훨씬 쉽고 덜 고통스러운 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b59f82b60de1a26b35593dc01675e5a909ba8a5f" translate="yes" xml:space="preserve">
          <source>I solved it by:</source>
          <target state="translated">나는 그것을 해결했다 :</target>
        </trans-unit>
        <trans-unit id="2bc8f27b388abdf40501aac72fdc18de4a394cc6" translate="yes" xml:space="preserve">
          <source>I summarized other answers. You can execute &lt;code&gt;git pull&lt;/code&gt; without errors:</source>
          <target state="translated">다른 답변을 요약했습니다. 오류없이 &lt;code&gt;git pull&lt;/code&gt; 을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e9c607f31072847a38c9b05a9259fd67e496517" translate="yes" xml:space="preserve">
          <source>I think this is the right way:</source>
          <target state="translated">이것이 올바른 방법이라고 생각합니다.</target>
        </trans-unit>
        <trans-unit id="5d91bb70a6390c473190410afcd9036e5f327d4f" translate="yes" xml:space="preserve">
          <source>I tried a lot but finally got success with these commands.</source>
          <target state="translated">나는 많은 것을 시도했지만 마침내이 명령으로 성공했습니다.</target>
        </trans-unit>
        <trans-unit id="ce04259de425930a4afb9a04ea73259e98934d7d" translate="yes" xml:space="preserve">
          <source>I'd advise doing the following:</source>
          <target state="translated">다음을 수행하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="879f21df929422d62c19c054033c719da6cc86cc" translate="yes" xml:space="preserve">
          <source>I'm adding the images under the source control and pushing them to GitHub together with other changes</source>
          <target state="translated">소스 컨트롤 아래에 이미지를 추가하고 다른 변경 사항과 함께 이미지를 GitHub에 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="c0389297bccd119cc2155df40b7245a9b6d8ef46" translate="yes" xml:space="preserve">
          <source>If above won't help and you don't care about your untracked files/directories (make the backup first just in case), try the following simple steps:</source>
          <target state="translated">위의 방법으로도 도움이되지 않고 추적되지 않은 파일 / 디렉토리에 신경 쓰지 않으면 다음과 같은 간단한 단계를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e1164cfe9b4363ab446a620bf0fe7eb973b2d2fd" translate="yes" xml:space="preserve">
          <source>If that's the case, you've to commit these CRLF/LF changes (by reviewing them in &lt;code&gt;git status&lt;/code&gt;), or try: &lt;code&gt;git config core.autcrlf false&lt;/code&gt; to temporary ignore them.</source>
          <target state="translated">이 경우 이러한 CRLF / LF 변경 사항을 커밋하거나 ( &lt;code&gt;git status&lt;/code&gt; 에서 변경 사항을 검토하여) 일시적으로 무시하려면 &lt;code&gt;git config core.autcrlf false&lt;/code&gt; 를 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="be99b3701dbfa1ea6069b28872598c9af0eaf225" translate="yes" xml:space="preserve">
          <source>If you have any files that are &lt;em&gt;not&lt;/em&gt; tracked by Git (e.g. uploaded user content), these files will not be affected.</source>
          <target state="translated">Git에 의해 추적 &lt;em&gt;되지 않는&lt;/em&gt; 파일 (예 : 업로드 된 사용자 컨텐츠)이있는 경우 해당 파일은 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e7742626a2af9a263481a2ea42184887d357916" translate="yes" xml:space="preserve">
          <source>If you want to remove untracked directories in addition to untracked files:</source>
          <target state="translated">추적되지 않은 파일 외에 추적되지 않은 디렉토리를 제거하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="a180e327b58926ff442a586df94b1875f83ddd5f" translate="yes" xml:space="preserve">
          <source>Important: If you have any local changes, they will be lost. With or without &lt;code&gt;--hard&lt;/code&gt; option, any local commits that haven't been pushed will be lost.&lt;sup&gt;[*]&lt;/sup&gt;</source>
          <target state="translated">중요 사항 : 로컬 변경 사항이 있으면 손실됩니다. &lt;code&gt;--hard&lt;/code&gt; 옵션을 사용하거나 사용하지 않으면 푸시되지 않은 로컬 커밋이 손실됩니다. &lt;sup&gt;[*]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="03fc06a673c3bef7b930cdf312a4a24d568ded9b" translate="yes" xml:space="preserve">
          <source>In speaking of pull/fetch/merge in the previous answers, I would like to share an interesting and productive trick,</source>
          <target state="translated">이전 답변에서 끌어 오기 / 가져 오기 / 병합에 대해 흥미롭고 생산적인 트릭을 공유하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="ad81e97b3a770037ed684784fde0a5c8ef87d732" translate="yes" xml:space="preserve">
          <source>Instead of doing:</source>
          <target state="translated">대신에 :</target>
        </trans-unit>
        <trans-unit id="dcb313addf8398324b6dbe730aabe7eb8934c8e2" translate="yes" xml:space="preserve">
          <source>Instead of merging with &lt;code&gt;git pull&lt;/code&gt;, try this:</source>
          <target state="translated">&lt;code&gt;git pull&lt;/code&gt; 과 병합하는 대신 다음을 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="2cd313911aabf555c754ba83cda398a218f8f5a4" translate="yes" xml:space="preserve">
          <source>It looks like the best way is to first do:</source>
          <target state="translated">가장 좋은 방법은 먼저하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e06b597f22a2c59eaa962116cc249a03f1662a8" translate="yes" xml:space="preserve">
          <source>It seems like most answers here are focused on the &lt;code&gt;master&lt;/code&gt; branch; however, there are times when I'm working on the same feature branch in two different places and I want a rebase in one to be reflected in the other without a lot of jumping through hoops.</source>
          <target state="translated">여기서 대부분의 답변은 &lt;code&gt;master&lt;/code&gt; 브랜치에 초점을 둔 것 같습니다. 그러나 두 개의 다른 위치에서 동일한 기능 분기를 작업하고 있으며 후프를 많이 뛰어 넘지 않고 다른 하나에 리베이스가 반영되기를 원합니다.</target>
        </trans-unit>
        <trans-unit id="7d8089aa0bbee09dd16c70b9dd88c5b319c9169f" translate="yes" xml:space="preserve">
          <source>It should do what you want.</source>
          <target state="translated">원하는대로해야합니다.</target>
        </trans-unit>
        <trans-unit id="f9e5e58435cb3bab1134eff5bbfd984a13e46944" translate="yes" xml:space="preserve">
          <source>Just do</source>
          <target state="translated">그냥 해</target>
        </trans-unit>
        <trans-unit id="bac005d3d83ada4449ef9cc4568c9cab8c7db381" translate="yes" xml:space="preserve">
          <source>Later you can clean the stash history.</source>
          <target state="translated">나중에 숨김 기록을 정리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ccb58cd1657aff4b8d5f6d44aa0ce72cd0f5cd5" translate="yes" xml:space="preserve">
          <source>Like Hedgehog I think the answers are terrible. But though Hedgehog's answer might be better, I don't think it is as elegant as it could be.  The way I found to do this is by using &quot;fetch&quot; and &quot;merge&quot; with a defined strategy. Which should make it so that your local changes are preserved as long as they are not one of the files that you are trying to force an overwrite with.</source>
          <target state="translated">고슴도치처럼 나는 대답이 끔찍하다고 생각합니다. 그러나 Hedgehog의 답변이 더 나을지 모르지만, 그것이 그것이 우아하다고 생각하지는 않습니다. 내가 찾은 방법은 정의 된 전략과 함께 &quot;fetch&quot;와 &quot;merge&quot;를 사용하는 것입니다. 덮어 쓰려는 파일 중 하나가 아닌 한 로컬 변경 내용이 유지되도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="57db7f84faa1518fd0d5c9bcdbb54d789e40298b" translate="yes" xml:space="preserve">
          <source>Local commits that are not on the remote branch need to be deleted as well. IMO the easiest way to achieve this is with: &lt;code&gt;git reset --hard origin/master&lt;/code&gt; (replace 'master' by whatever branch you are working on, and run a &lt;code&gt;git fetch origin&lt;/code&gt; first)</source>
          <target state="translated">원격 브랜치에없는 로컬 커밋도 삭제해야합니다. IMO는 이것을 달성하는 가장 쉬운 방법은 다음과 같습니다 : &lt;code&gt;git reset --hard origin/master&lt;/code&gt; (작업중 인 분기에 따라 'master'를 대체하고 &lt;code&gt;git fetch origin&lt;/code&gt; 을 먼저 실행하십시오)</target>
        </trans-unit>
        <trans-unit id="902b1994ebdb1a49c25d1e1bcdd7120a07310fa8" translate="yes" xml:space="preserve">
          <source>Local files that are untracked need to be deleted, either manually (safer) or as suggested in other answers, by &lt;code&gt;git clean -f -d&lt;/code&gt;</source>
          <target state="translated">추적되지 않은 로컬 파일은 &lt;code&gt;git clean -f -d&lt;/code&gt; 에 의해 수동으로 (safer) 또는 다른 답변에서 제안한대로 삭제해야합니다.</target>
        </trans-unit>
        <trans-unit id="ebf666caa78cad721786be145be564955ec4d13f" translate="yes" xml:space="preserve">
          <source>Maintain current local commits</source>
          <target state="translated">현재 지역 커밋 유지</target>
        </trans-unit>
        <trans-unit id="27d3c0eecb54773d9a2bf6562cb66eb7114e4a4d" translate="yes" xml:space="preserve">
          <source>Make the local repository match the remote origin repository.</source>
          <target state="translated">로컬 저장소를 원격 오리진 저장소와 일치 시키십시오.</target>
        </trans-unit>
        <trans-unit id="c44115da474d910d5bd67d5010c093acb30dad91" translate="yes" xml:space="preserve">
          <source>Manually, one-by-one:</source>
          <target state="translated">수동으로 하나씩 :</target>
        </trans-unit>
        <trans-unit id="1f9d21224178a8ed1cca77caf291eba184ae786b" translate="yes" xml:space="preserve">
          <source>No need to fetch all remotes and branches if you're going to reset to the origin/master branch right?</source>
          <target state="translated">원산지 / 마스터 지점으로 재설정하려는 경우 모든 리모컨과 지점을 가져올 필요가 없습니까?</target>
        </trans-unit>
        <trans-unit id="36d03b9af07b5eaff018766e46d322d377dc6f23" translate="yes" xml:space="preserve">
          <source>Now it works.</source>
          <target state="translated">이제 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bf662c7bf7c1229391af4012d4ab4979da22561f" translate="yes" xml:space="preserve">
          <source>OR If you are on some other branch:</source>
          <target state="translated">또는 다른 지사에있는 경우 :</target>
        </trans-unit>
        <trans-unit id="33b6a45ba92ca30383f55274e41f4e14184846bf" translate="yes" xml:space="preserve">
          <source>Of course if you want to go back to what you stashed:</source>
          <target state="translated">물론 당신이 말한 것으로 돌아가고 싶다면 :</target>
        </trans-unit>
        <trans-unit id="11be4c8b5293489e43dade05c7b3663d51f1211e" translate="yes" xml:space="preserve">
          <source>Or, in your &lt;code&gt;.gitconfig&lt;/code&gt; file:</source>
          <target state="translated">또는 &lt;code&gt;.gitconfig&lt;/code&gt; 파일에서 :</target>
        </trans-unit>
        <trans-unit id="42da08286231f6c3d657f652d649f572c9396d4c" translate="yes" xml:space="preserve">
          <source>Rather (git &amp;gt; v1.7.6):</source>
          <target state="translated">오히려 (git&amp;gt; v1.7.6) :</target>
        </trans-unit>
        <trans-unit id="475ffa14014bb463965306813410e4afd01a7039" translate="yes" xml:space="preserve">
          <source>Requirements:</source>
          <target state="translated">Requirements:</target>
        </trans-unit>
        <trans-unit id="915317e7edd24055b8e04b2d411caa7b7533153c" translate="yes" xml:space="preserve">
          <source>Reset the index and the head to &lt;code&gt;origin/master&lt;/code&gt;, but do not reset the working tree:</source>
          <target state="translated">색인과 헤드를 &lt;code&gt;origin/master&lt;/code&gt; 로 재설정하지만 작업 트리는 재설정하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9ab708d6bf11eb7eae1427bfc4104732844213b0" translate="yes" xml:space="preserve">
          <source>Run this from a branch and it'll only reset your local branch to the upstream version.</source>
          <target state="translated">지점에서이를 실행하면 로컬 지점 만 업스트림 버전으로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="807398f22444dcc53d6db811aebb6cd9cc2291af" translate="yes" xml:space="preserve">
          <source>So you avoid all unwanted side effects, like deleting files or directories you wanted to keep, etc.</source>
          <target state="translated">따라서 유지하려는 파일이나 디렉토리 삭제와 같은 원치 않는 부작용을 피하십시오.</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="9587d887b8a5d76ff8f5b3ca6941e7eae087b881" translate="yes" xml:space="preserve">
          <source>Some answers seem to be terrible. Terrible in the sense of what happened to @Lauri by following David Avsajanishvili suggestion.</source>
          <target state="translated">일부 답변은 끔찍한 것 같습니다. David Avsajanishvili 제안에 따라 @Lauri에게 일어난 일에 대해 끔찍한 일입니다.</target>
        </trans-unit>
        <trans-unit id="0d28dcfeeae68b49b63a4e472f2f8328b5fdd4e3" translate="yes" xml:space="preserve">
          <source>Sometimes just &lt;code&gt;clean -f&lt;/code&gt; does not help. In case you have untracked DIRECTORIES, -d option also needed:</source>
          <target state="translated">때로는 &lt;code&gt;clean -f&lt;/code&gt; 만 도움이되지 않습니다. DIRECTORIES를 추적하지 않은 경우 -d 옵션도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="8631c9b28f153fae2e2fef4e1316c5b69bbe8cfd" translate="yes" xml:space="preserve">
          <source>That in mind, I updated Kustudic's script to do just that.  I also fixed a typo (a missing ' in the original).</source>
          <target state="translated">그 점을 염두에두고 Kustudic의 스크립트를 업데이트했습니다. 또한 오타를 수정했습니다 (원본에서 누락 된 ').</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">그게 다야!</target>
        </trans-unit>
        <trans-unit id="25600d3a9892efcd21d9b4cfc94b0ab9748ed9b2" translate="yes" xml:space="preserve">
          <source>The first command fetches newest data.</source>
          <target state="translated">첫 번째 명령은 최신 데이터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="253df425511692a7988571c26edb1c772b59d386" translate="yes" xml:space="preserve">
          <source>The following version commits your local changes to a temporary branch (&lt;code&gt;tmp&lt;/code&gt;), checks out the original branch (which I'm assuming is &lt;code&gt;master&lt;/code&gt;) and merges the updates. You could do this with &lt;code&gt;stash&lt;/code&gt;, but I've found it's usually easier to simply use the branch / merge approach.</source>
          <target state="translated">다음 버전은 로컬 변경 사항을 임시 분기 ( &lt;code&gt;tmp&lt;/code&gt; )로 커밋하고 원래 분기 ( &lt;code&gt;master&lt;/code&gt; 라고 가정)를 확인하고 업데이트를 병합합니다. &lt;code&gt;stash&lt;/code&gt; 으로이 작업을 수행 할 수 있지만 일반적으로 분기 / 병합 접근법을 사용하는 것이 더 쉽다는 것을 알았습니다.</target>
        </trans-unit>
        <trans-unit id="6bde0e00397fa4ee9171ff863ee7e069991bf8f0" translate="yes" xml:space="preserve">
          <source>The only thing that worked for me was:</source>
          <target state="translated">나를 위해 일한 유일한 것은 :</target>
        </trans-unit>
        <trans-unit id="b8d26d09bd803d962c0ffdc7865ca8eded89d169" translate="yes" xml:space="preserve">
          <source>The problem with all these solutions is that they are all either too complex, or, an even bigger problem, is that they remove all untracked files from the web server, which we don't want since there are always needed configuration files which are on the server and not in the Git repository.</source>
          <target state="translated">이 모든 솔루션의 문제점은 모두 너무 복잡하거나 더 큰 문제는 웹 서버에서 추적되지 않은 모든 파일을 제거한다는 것입니다.이 파일은 항상 필요한 구성 파일이 필요하기 때문에 원하지 않습니다. Git 저장소가 아닌 서버.</target>
        </trans-unit>
        <trans-unit id="c3c10cc0d5a31ff5783080c9bd9635741b253fc8" translate="yes" xml:space="preserve">
          <source>The second command checks if there are any files which are being added to the repository and deletes those untracked files from the local repository which would cause conflicts.</source>
          <target state="translated">두 번째 명령은 저장소에 추가중인 파일이 있는지 확인하고 추적되지 않은 파일을 로컬 저장소에서 삭제하여 충돌을 일으 킵니다.</target>
        </trans-unit>
        <trans-unit id="678000075b4d6cd38269dac48c4b8d87c1fca462" translate="yes" xml:space="preserve">
          <source>The third command checks-out all the files which were locally modified.</source>
          <target state="translated">세 번째 명령은 로컬로 수정 된 모든 파일을 체크 아웃합니다.</target>
        </trans-unit>
        <trans-unit id="21267f318079f6774b177821837cc891b20ba5c7" translate="yes" xml:space="preserve">
          <source>Then I am able to pull just fine.</source>
          <target state="translated">그런 다음 잘 잡아 당길 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f21d45c01e403eb57b1b5827ca4047a372a4082" translate="yes" xml:space="preserve">
          <source>Then fetch the changes and overwrite if there is a conflict</source>
          <target state="translated">그런 다음 변경 사항을 가져 와서 충돌이 있으면 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="c676bc4481885bfedae0258dc14ccea8e8999c8a" translate="yes" xml:space="preserve">
          <source>Then pull it again.</source>
          <target state="translated">그런 다음 다시 당기십시오.</target>
        </trans-unit>
        <trans-unit id="ee4ca7fba794f3af9d4fb46b93e0453c258d261c" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;git reset&lt;/code&gt; resets the master branch to what you just fetched. The &lt;code&gt;--hard&lt;/code&gt; option changes all the files in your working tree to match the files in &lt;code&gt;origin/master&lt;/code&gt;</source>
          <target state="translated">그런 다음 &lt;code&gt;git reset&lt;/code&gt; 은 마스터 브랜치를 방금 가져온 것으로 재설정 합니다. &lt;code&gt;--hard&lt;/code&gt; 옵션은 작업 트리의 모든 파일을 &lt;code&gt;origin/master&lt;/code&gt; 의 파일과 일치하도록 변경합니다.</target>
        </trans-unit>
        <trans-unit id="d81ef5f48f166e14f75ad40236c0c9df9e4a75e1" translate="yes" xml:space="preserve">
          <source>Then, you have two options:</source>
          <target state="translated">그런 다음 두 가지 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7798b87989a4d7b4641302aaed49212a7fe8c801" translate="yes" xml:space="preserve">
          <source>These four commands work for me.</source>
          <target state="translated">이 네 가지 명령이 저에게 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="ff127378bb08dc1448022a9641654c494f565c1d" translate="yes" xml:space="preserve">
          <source>They are adding some images to the images directory (but forgets to add them under source control)</source>
          <target state="translated">그들은 이미지 디렉토리에 이미지를 추가하고 있습니다 (그러나 소스 제어하에 이미지를 추가하는 것을 잊어 버립니다)</target>
        </trans-unit>
        <trans-unit id="03b8bbdb6eb2cf69f8cb249139cd7ce228faaecf" translate="yes" xml:space="preserve">
          <source>They are sending the images by mail, later, to me</source>
          <target state="translated">그들은 나중에 나에게 우편으로 이미지를 보내고 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cd7a4110beebad617002342d669e523a4966903" translate="yes" xml:space="preserve">
          <source>They cannot pull updates from GitHub because Git doesn't want to overwrite their files.</source>
          <target state="translated">Git이 파일을 덮어 쓰고 싶지 않기 때문에 GitHub에서 업데이트를 가져올 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0c0bc2340a056214e8100c82b907cb176343ebc8" translate="yes" xml:space="preserve">
          <source>This above command is the most useful command in my Git life which saved a lot of time.</source>
          <target state="translated">이 명령은 내 Git 생활에서 가장 유용한 명령으로 많은 시간을 절약했습니다.</target>
        </trans-unit>
        <trans-unit id="2e784adb16c7ed518925195e69f1ed074a41fa47" translate="yes" xml:space="preserve">
          <source>This can be nicely put into a git alias (&lt;code&gt;git forcepull&lt;/code&gt;) as well:</source>
          <target state="translated">이것은 git alias ( &lt;code&gt;git forcepull&lt;/code&gt; )에도 잘 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7fa72933f59b96fd34b4e375dec6861fc0377acd" translate="yes" xml:space="preserve">
          <source>This will REMOVE all git files (excempt &lt;code&gt;.git/&lt;/code&gt; dir, where you have all commits) and pull it again.</source>
          <target state="translated">이렇게하면 모든 자식 파일 (모든 커밋이있는 &lt;code&gt;.git/&lt;/code&gt; dir 제외)을 제거하고 다시 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1913d306d1a42c1564720a4d705c73b9650593f6" translate="yes" xml:space="preserve">
          <source>This will override your local file with the file on git</source>
          <target state="translated">이것은 로컬 파일을 git의 파일로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="947b34a00d726c657b12cdbaccdf65e09fd25d8d" translate="yes" xml:space="preserve">
          <source>This will take you back five commits and then with</source>
          <target state="translated">이렇게하면 5 개의 커밋을 다시 가져 와서</target>
        </trans-unit>
        <trans-unit id="01731cd723b90256eccc7d0a8072853bf68d619c" translate="yes" xml:space="preserve">
          <source>To check/pull after executing these commands</source>
          <target state="translated">이 명령을 실행 한 후 확인 / 풀링하려면</target>
        </trans-unit>
        <trans-unit id="792990822a55aacc5ab96839f6879d0ab135b670" translate="yes" xml:space="preserve">
          <source>To delete all untracked files and then continue with the usual &lt;code&gt;git pull&lt;/code&gt;...</source>
          <target state="translated">추적되지 않은 모든 파일을 삭제하고 일반적인 &lt;code&gt;git pull&lt;/code&gt; 을 계속하려면 ...</target>
        </trans-unit>
        <trans-unit id="2e97c37f66bbb352cb86c890973bbee6dd9264e4" translate="yes" xml:space="preserve">
          <source>Track local changes so no-one here ever loses them.</source>
          <target state="translated">로컬 변경 사항을 추적하면 아무도 잃어 버리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">이 시도:</target>
        </trans-unit>
        <trans-unit id="79d1acaccc53be854e44cb88d8a731ca26725f61" translate="yes" xml:space="preserve">
          <source>Uncommitted changes</source>
          <target state="translated">커밋되지 않은 변경</target>
        </trans-unit>
        <trans-unit id="35d60c13f1637f01f05b6c59bfb6bb4fbae9aac4" translate="yes" xml:space="preserve">
          <source>Uncommitted changes, however (even staged), will be lost. Make sure to stash and commit anything you need. For that you can run the following:</source>
          <target state="translated">그러나 커밋되지 않은 변경 사항 (단계별)은 손실됩니다. 필요한 것을 숨기고 커밋하십시오. 이를 위해 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a04a85b4f229d1ba1c004f1d7dfc9dad4ba95354" translate="yes" xml:space="preserve">
          <source>When you're using file-system which doesn't support permission attributes.
In example you have two repositories, one on Linux/Mac (&lt;code&gt;ext3&lt;/code&gt;/&lt;code&gt;hfs+&lt;/code&gt;) and another one on FAT32/NTFS based file-system.</source>
          <target state="translated">권한 속성을 지원하지 않는 파일 시스템을 사용하는 경우 예를 들어 Linux / Mac ( &lt;code&gt;ext3&lt;/code&gt; / &lt;code&gt;hfs+&lt;/code&gt; )과 FAT32 / NTFS 기반 파일 시스템에 각각 하나씩 두 개의 저장소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b59d9f65f3bfd048d61e29b69d244223b5fd2b4d" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;git reset HEAD --hard&lt;/code&gt; could fail in some cases?</source>
          <target state="translated">왜 &lt;code&gt;git reset HEAD --hard&lt;/code&gt; 가 실패 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="e676bf6f98187f56702c31f2b2f0568c7e63be07" translate="yes" xml:space="preserve">
          <source>You might find this command helpful to throw away local changes:</source>
          <target state="translated">이 명령은 로컬 변경 사항을 버리는 데 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f68fbd4c89d37bb92c0eccd976bc907b757552a" translate="yes" xml:space="preserve">
          <source>error: Untracked working tree file 'public/images/icon.gif' would be overwritten by merge</source>
          <target state="translated">오류 : 추적되지 않은 작업 트리 파일 'public / images / icon.gif'를 병합으로 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="9351bd81e6470b3b0902ff748b289a7935609351" translate="yes" xml:space="preserve">
          <source>followed by:</source>
          <target state="translated">뒤에 :</target>
        </trans-unit>
        <trans-unit id="ddea56ff50be6923b4fcf019f86bdb93636ef9b3" translate="yes" xml:space="preserve">
          <source>where the last command gives a list of what your local changes were. Keep modifying the &quot;tmp&quot; branch until it is acceptable and then merge back onto master with:</source>
          <target state="translated">여기서 마지막 명령은 로컬 변경 내용 목록을 제공합니다. &quot;tmp&quot;브랜치를 허용 될 때까지 계속 수정 한 후 다음을 사용하여 마스터로 다시 병합하십시오.</target>
        </trans-unit>
        <trans-unit id="016dc548ba6ea5dc4ca066fa1aaacbe2d5292693" translate="yes" xml:space="preserve">
          <source>where we assume the &lt;strong&gt;other repository&lt;/strong&gt; is &lt;code&gt;origin master&lt;/code&gt;.</source>
          <target state="translated">여기서 우리는 &lt;strong&gt;다른 저장소&lt;/strong&gt; 가 &lt;code&gt;origin master&lt;/code&gt; 라고 가정합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
