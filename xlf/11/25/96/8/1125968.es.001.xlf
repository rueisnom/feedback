<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1125968">
    <body>
      <group id="1125968">
        <trans-unit id="5afb90bc1680715416282876077bc225842cbc96" translate="yes" xml:space="preserve">
          <source>&quot;-X&quot; is an option name, and &quot;theirs&quot; is the value for that option. You're choosing to use &quot;their&quot; changes, instead of &quot;your&quot; changes if there is a conflict.</source>
          <target state="translated">&quot;-X&quot; es un nombre de opción,y &quot;suyo&quot; es el valor de esa opción.Estás eligiendo usar &quot;sus&quot; cambios,en lugar de &quot;tus&quot; cambios si hay un conflicto.</target>
        </trans-unit>
        <trans-unit id="70ecf3b9a626c0d63016862459beb96a7cd9fd04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; downloads the latest from remote without trying to merge or rebase anything.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; descarga lo &amp;uacute;ltimo desde el control remoto sin intentar fusionar o volver a crear nada.</target>
        </trans-unit>
        <trans-unit id="bc940fd283a79b9e47237dc19b00c61dd5539710" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard origin/master&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git reset --hard origin/master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b77648ec75a644255f4be7f9dd3cb5598cd48b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git pull --rebase&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git pull --rebase&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f4dc4e310800c0b0a13a28965d7a56a3b773f32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fetch&lt;/strong&gt; with a &lt;strong&gt;clean&lt;/strong&gt; of &lt;strong&gt;files&lt;/strong&gt; and &lt;strong&gt;directories&lt;/strong&gt; ignoring &lt;strong&gt;.gitignore&lt;/strong&gt; and &lt;strong&gt;hard reset&lt;/strong&gt; to &lt;strong&gt;origin&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Obtenga&lt;/strong&gt; una &lt;strong&gt;limpieza&lt;/strong&gt; de &lt;strong&gt;archivos&lt;/strong&gt; y &lt;strong&gt;directorios&lt;/strong&gt; ignorando &lt;strong&gt;.gitignore&lt;/strong&gt; y &lt;strong&gt;restablecimiento&lt;/strong&gt; &lt;strong&gt;completo&lt;/strong&gt; al &lt;strong&gt;origen&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6031888574223bffc84d9cd8bf2d9a79f815c173" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stash&lt;/strong&gt; the local changes.</source>
          <target state="translated">&lt;strong&gt;Guarda&lt;/strong&gt; los cambios locales.</target>
        </trans-unit>
        <trans-unit id="dcc197827149be97581e309fb6dce7a656af78bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The scenario is the following:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;El escenario es el siguiente:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3c42a8134f0739a17a678e3e0dcb0771efa7cdb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the error I'm getting:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Este es el error que recibo:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4a7132acfa00c3c71261b610b730a413f758186" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING: &lt;code&gt;git clean&lt;/code&gt; deletes all your untracked files/directories and can't be undone.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ADVERTENCIA: &lt;code&gt;git clean&lt;/code&gt; elimina todos sus archivos / directorios no rastreados y no se puede deshacer.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="967b8bcb08e168bba241f9faffbb234be29aee97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning, doing this will permanently delete your files if you have any directory/* entries in your gitignore file.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Advertencia, hacer esto eliminar&amp;aacute; permanentemente sus archivos si tiene alguna entrada de directorio / * en su archivo gitignore.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c62d7e7d52d9e8d8a3e0ab4fcbe742a08c5a51f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This script is very powerful, so you could lose your changes.</source>
          <target state="translated">&lt;strong&gt;Advertencia&lt;/strong&gt; : este script es muy poderoso, por lo que podr&amp;iacute;a perder sus cambios.</target>
        </trans-unit>
        <trans-unit id="6c5e0c503728653826db9fcefc33c40057e4a0cf" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;strong&gt;Warning&lt;/strong&gt;: Above commands can results in data/files loss only if you don't have them committed! If you're not sure, make the backup first of your whole repository folder.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;strong&gt;Advertencia&lt;/strong&gt; : &amp;iexcl;Los comandos anteriores pueden provocar la p&amp;eacute;rdida de datos / archivos solo si no los ha confirmado!&lt;/sup&gt; &lt;sup&gt;Si no est&amp;aacute; seguro, haga la copia de seguridad primero de toda su carpeta de repositorio.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1ed6e68c2afe2cc46a2ddfb7b88e004a4df0bc59" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[*]&lt;/sup&gt;: It's worth noting that it is possible to maintain current local commits by creating a branch from &lt;code&gt;master&lt;/code&gt; before resetting:</source>
          <target state="translated">&lt;sup&gt;[*]&lt;/sup&gt; : Vale la pena se&amp;ntilde;alar que es posible mantener los compromisos locales actuales creando una rama desde el &lt;code&gt;master&lt;/code&gt; antes de reiniciar:</target>
        </trans-unit>
        <trans-unit id="36038a15055095eee9da18058a5e2c67e12a05ad" translate="yes" xml:space="preserve">
          <source>A team member is modifying the templates for a website we are working on</source>
          <target state="translated">Un miembro del equipo está modificando las plantillas de un sitio web en el que estamos trabajando</target>
        </trans-unit>
        <trans-unit id="a180c1f257cadb94780423f139159de8269da2c0" translate="yes" xml:space="preserve">
          <source>After this, all of the old commits will be kept in &lt;code&gt;new-branch-to-save-current-commits&lt;/code&gt;.</source>
          <target state="translated">Despu&amp;eacute;s de esto, todos los commits antiguos se mantendr&amp;aacute;n en &lt;code&gt;new-branch-to-save-current-commits&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36c034e52a3013a7eb18bd0e736106a3162dc9b7" translate="yes" xml:space="preserve">
          <source>An easier way would be to:</source>
          <target state="translated">Una forma más fácil sería hacerlo:</target>
        </trans-unit>
        <trans-unit id="a7eccdc85e1d8fab375e2e045e94fc4580337ef4" translate="yes" xml:space="preserve">
          <source>And then do a cleanup (removes untracked files from the working tree):</source>
          <target state="translated">Y luego hacer una limpieza (elimina los archivos no rastreados del árbol de trabajo):</target>
        </trans-unit>
        <trans-unit id="78daf6f4dc00ac5359931b14a322206862bd8d53" translate="yes" xml:space="preserve">
          <source>And then to reapply these uncommitted changes:</source>
          <target state="translated">Y luego para volver a aplicar estos cambios no comprometidos:</target>
        </trans-unit>
        <trans-unit id="3dbb2aa68555e791ab4d7fde77f19d2a5b2a8a25" translate="yes" xml:space="preserve">
          <source>As you notice, there are two different kind of file systems, so the one which doesn't support Unix permissions basically can't reset file permissions on system which doesn't support that kind of permissions, so no matter how &lt;code&gt;--hard&lt;/code&gt; you try, git always detect some &quot;changes&quot;.</source>
          <target state="translated">Como notar&amp;aacute;, hay dos tipos diferentes de sistemas de archivos, por lo que el que no admite permisos de Unix b&amp;aacute;sicamente no puede restablecer los permisos de archivos en el sistema que no admite ese tipo de permisos, as&amp;iacute; que no importa qu&amp;eacute; tan &lt;code&gt;--hard&lt;/code&gt; intenta, git siempre detecta algunos &quot;cambios&quot;.</target>
        </trans-unit>
        <trans-unit id="176ed3df07c6cab12f3824cd3af53a19fe5a4ac5" translate="yes" xml:space="preserve">
          <source>Based on a combination of &lt;a href=&quot;https://stackoverflow.com/a/8888015/1103543&quot;&gt;RNA's answer&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/19961461/1103543&quot;&gt;torek's answer to a similar question&lt;/a&gt;, I've come up with this which works splendidly:</source>
          <target state="translated">Basado en una combinaci&amp;oacute;n de &lt;a href=&quot;https://stackoverflow.com/a/8888015/1103543&quot;&gt;la respuesta&lt;/a&gt; de ARN y la respuesta de &lt;a href=&quot;https://stackoverflow.com/a/19961461/1103543&quot;&gt;torek a una pregunta similar&lt;/a&gt; , se me ocurri&amp;oacute; esto que funciona de manera espl&amp;eacute;ndida:</target>
        </trans-unit>
        <trans-unit id="5c86cd4334fa80da1de659e41c3792751d28a710" translate="yes" xml:space="preserve">
          <source>Based on my own similar experiences, the solution offered by Strahinja Kustudic above is by far the best.  As others have pointed out, simply doing hard reset will remove &lt;strong&gt;all&lt;/strong&gt; the untracked files which could include lots of things that you don't want removed, such as config files.  What is safer, is to remove only the files that are about to be added, and for that matter, you'd likely also want to checkout any locally-modified files that are about to be updated.</source>
          <target state="translated">Basado en mis propias experiencias similares, la soluci&amp;oacute;n ofrecida por Strahinja Kustudic es la mejor con diferencia. Como otros han se&amp;ntilde;alado, simplemente haciendo un restablecimiento &lt;strong&gt;completo&lt;/strong&gt; eliminar&amp;aacute; &lt;strong&gt;todos&lt;/strong&gt; los archivos no rastreados que podr&amp;iacute;an incluir muchas cosas que no desea eliminar, como los archivos de configuraci&amp;oacute;n. Lo que es m&amp;aacute;s seguro es eliminar solo los archivos que est&amp;aacute;n a punto de agregarse, y para el caso, es probable que tambi&amp;eacute;n desee verificar cualquier archivo modificado localmente que est&amp;eacute; a punto de actualizarse.</target>
        </trans-unit>
        <trans-unit id="66fd03594a2c157f1cc4300404f810b1d6f6ef22" translate="yes" xml:space="preserve">
          <source>Before pushing your newly commit to server, try this command and it will automatically synchronise the latest server changes (with a fetch + merge) and will place your commit at the top in the Git log. There isn't any need to worry about manual pull/merge.</source>
          <target state="translated">Antes de enviar tu nueva confirmación al servidor,prueba este comando,que sincronizará automáticamente los últimos cambios en el servidor (con un fetch+merge)y colocará tu confirmación en la parte superior del registro de Git.No hay necesidad de preocuparse por el pullmerge manual.</target>
        </trans-unit>
        <trans-unit id="5763578555f814c96231de97e5710d397db26670" translate="yes" xml:space="preserve">
          <source>Bonus:</source>
          <target state="translated">Bonus:</target>
        </trans-unit>
        <trans-unit id="3c246aca15204187cf5403a724bf7c4ed1f89f75" translate="yes" xml:space="preserve">
          <source>Brutally, all-at-once:</source>
          <target state="translated">Brutalmente,todo de una vez:</target>
        </trans-unit>
        <trans-unit id="0f3d70d10152b31329fca6d57c58dd5a7548905c" translate="yes" xml:space="preserve">
          <source>Consider using &lt;code&gt;-n&lt;/code&gt; (&lt;code&gt;--dry-run&lt;/code&gt;) flag first. This will show you what will be deleted without actually deleting anything:</source>
          <target state="translated">Considere usar el &lt;code&gt;--dry-run&lt;/code&gt; &lt;code&gt;-n&lt;/code&gt; ( --dry-run ) primero. Esto le mostrar&amp;aacute; lo que se eliminar&amp;aacute; sin eliminar nada:</target>
        </trans-unit>
        <trans-unit id="27a5712e08f3ae4b6c16fa9dbe1f57b88d828e9d" translate="yes" xml:space="preserve">
          <source>Custom rules in &lt;code&gt;.gitattributes file&lt;/code&gt;</source>
          <target state="translated">Reglas personalizadas en el &lt;code&gt;.gitattributes file&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5969bf1b4e4687ca1fb9f6fc009150bef42d135f" translate="yes" xml:space="preserve">
          <source>Delete all the files. Leave just the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">Eliminar todos los archivos. Deje solo el directorio &lt;code&gt;.git&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ac1711535c3631326eb072df130168ba61081aa" translate="yes" xml:space="preserve">
          <source>Despite the original question, the top answers can cause problems for people who have a similar problem, but don't want to lose their local files. For example, see Al-Punk and crizCraig's comments.</source>
          <target state="translated">A pesar de la pregunta original,las respuestas superiores pueden causar problemas a las personas que tienen un problema similar,pero no quieren perder sus archivos locales.Por ejemplo,ver los comentarios de Al-Punk y CrizCraig.</target>
        </trans-unit>
        <trans-unit id="f5169c84497de3aea74f7da9e7e177d1427e736b" translate="yes" xml:space="preserve">
          <source>Enjoy!</source>
          <target state="translated">Enjoy!</target>
        </trans-unit>
        <trans-unit id="2e4ccc244461fd2a12825ef96a60da2329e2ce3c" translate="yes" xml:space="preserve">
          <source>Example output:</source>
          <target state="translated">Ejemplo de salida:</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="633b8ed4341c493911bcdea67fbf3a7e52e105ed" translate="yes" xml:space="preserve">
          <source>File system incompability</source>
          <target state="translated">Incompatibilidad del sistema de archivos</target>
        </trans-unit>
        <trans-unit id="ac51316d6159411acf5b3f583c8d9c8a8d26ccdc" translate="yes" xml:space="preserve">
          <source>Finally we do a pull to update to the newest version, but this time without any conflicts, since untracked files which are in the repo don't exist anymore and all the locally modified files are already the same as in the repository.</source>
          <target state="translated">Finalmente hacemos un tirón para actualizarnos a la última versión,pero esta vez sin conflictos,ya que los archivos sin rastrear que están en el repositorio ya no existen y todos los archivos modificados localmente son ya los mismos que en el repositorio.</target>
        </trans-unit>
        <trans-unit id="733954012af2f88caae800ae8ecbbdd4f2b12025" translate="yes" xml:space="preserve">
          <source>Find details in &lt;em&gt;&lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;What does &quot;git pull --rebase&quot; do?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Encuentre detalles en &lt;em&gt;&lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;&amp;iquest;Qu&amp;eacute; hace &quot;git pull --rebase&quot;?&lt;/a&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6dc0d8358e432ef94381d4e39acde5f09ef69da0" translate="yes" xml:space="preserve">
          <source>First do a commit of your changes</source>
          <target state="translated">Primero haga un compromiso de sus cambios</target>
        </trans-unit>
        <trans-unit id="b3e145b7648ef683eaac2a7805b4e4b762bbad1f" translate="yes" xml:space="preserve">
          <source>First of all, try the standard way:</source>
          <target state="translated">Primero que nada,intenta la manera estándar:</target>
        </trans-unit>
        <trans-unit id="e91bc256ad13d894ea5b4b99e3446667f554a6a2" translate="yes" xml:space="preserve">
          <source>For next time, you can probably handle this in a cleaner way by looking up &quot;git stash branch&quot; though stash is likely to cause you trouble on the first few tries, so do first experiment on a non-critical project...</source>
          <target state="translated">Para la próxima vez,probablemente puedas manejar esto de una manera más limpia buscando la &quot;rama del escondite&quot; aunque el escondite probablemente te cause problemas en los primeros intentos,así que haz el primer experimento en un proyecto no crítico...</target>
        </trans-unit>
        <trans-unit id="c89f6341c557881ef5a26399ed1653fe3ebdf78e" translate="yes" xml:space="preserve">
          <source>Having &lt;code&gt;eol=lf&lt;/code&gt; rule in .gitattributes could cause git to modify some file changes by converting CRLF line-endings into LF in some text files.</source>
          <target state="translated">Tener una regla &lt;code&gt;eol=lf&lt;/code&gt; en .gitattributes podr&amp;iacute;a hacer que git modifique algunos cambios de archivo al convertir las terminaciones de l&amp;iacute;nea CRLF en LF en algunos archivos de texto.</target>
        </trans-unit>
        <trans-unit id="93154f89378492cd0c83e1aab6e6159f0de9d7ea" translate="yes" xml:space="preserve">
          <source>Here is the cleanest solution which we are using:</source>
          <target state="translated">Aquí está la solución más limpia que estamos usando:</target>
        </trans-unit>
        <trans-unit id="1f637bf42e756c960767eb126fdd9d9bebbd7a74" translate="yes" xml:space="preserve">
          <source>How do I force Git to overwrite them? The person is a designer - usually, I resolve all the conflicts by hand, so the server has the most recent version that they just need to update on their computer.</source>
          <target state="translated">¿Cómo puedo forzar a Git a sobrescribirlos? Normalmente,resuelvo todos los conflictos a mano,así que el servidor tiene la versión más reciente que sólo necesita actualizar en su ordenador.</target>
        </trans-unit>
        <trans-unit id="e3a2f47cc14d50df3baa2c14a0ddf658114561df" translate="yes" xml:space="preserve">
          <source>How do I force an overwrite of local files on a &lt;code&gt;git pull&lt;/code&gt;?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo fuerzo una sobrescritura de archivos locales en un &lt;code&gt;git pull&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="022b126cf5d96f5acd5353613e02e8e093951fcf" translate="yes" xml:space="preserve">
          <source>How do I force “git pull” to overwrite local files</source>
          <target state="translated">¿Cómo puedo forzar a &quot;git pull&quot; a sobrescribir los archivos locales</target>
        </trans-unit>
        <trans-unit id="dea1758cfb7d54073565d160ed1da9d3735d7d43" translate="yes" xml:space="preserve">
          <source>I believe there are two possible causes of conflict, which must be solved separately, and as far as I can tell none of the above answers deals with both:</source>
          <target state="translated">Creo que hay dos posibles causas de conflicto,que deben ser resueltas por separado,y por lo que puedo decir ninguna de las respuestas anteriores trata de ambas:</target>
        </trans-unit>
        <trans-unit id="9d39e53821ce6f629f48322aff08f227653eb992" translate="yes" xml:space="preserve">
          <source>I found that by looking up &lt;a href=&quot;https://stackoverflow.com/questions/2389361/git-undo-a-merge&quot;&gt;how to undo a Git merge&lt;/a&gt;.</source>
          <target state="translated">Descubr&amp;iacute; que al buscar &lt;a href=&quot;https://stackoverflow.com/questions/2389361/git-undo-a-merge&quot;&gt;c&amp;oacute;mo deshacer una fusi&amp;oacute;n Git&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="95f170181b4a919a57346c13c88eae271970ecf3" translate="yes" xml:space="preserve">
          <source>I had a similar problem.  I had to do this:</source>
          <target state="translated">Yo tenía un problema similar.Tuve que hacer esto:</target>
        </trans-unit>
        <trans-unit id="8628e6103828b4e62119bb52d8a10ca6f0446469" translate="yes" xml:space="preserve">
          <source>I had the same problem and for some reason, even a &lt;code&gt;git clean -f -d&lt;/code&gt; would not do it. Here is why: For some reason, if your file is ignored by Git (via a .gitignore entry, I assume), it still bothers about overwriting this with a later &lt;em&gt;pull&lt;/em&gt;, but a &lt;em&gt;clean&lt;/em&gt; will not remove it, unless you add &lt;code&gt;-x&lt;/code&gt;.</source>
          <target state="translated">Tuve el mismo problema y por alguna raz&amp;oacute;n, incluso un &lt;code&gt;git clean -f -d&lt;/code&gt; no lo har&amp;iacute;a. Aqu&amp;iacute; est&amp;aacute; la raz&amp;oacute;n: por alguna raz&amp;oacute;n, si Git ignora su archivo (a trav&amp;eacute;s de una entrada .gitignore, supongo), todav&amp;iacute;a se molesta en sobrescribir esto con una &lt;em&gt;extracci&amp;oacute;n&lt;/em&gt; posterior, pero una &lt;em&gt;limpieza&lt;/em&gt; no lo eliminar&amp;aacute;, a menos que agregue &lt;code&gt;-x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfc7e1dda03c9f91868de6432e4c926b6660c9cf" translate="yes" xml:space="preserve">
          <source>I had the same problem. No one gave me this solution, but it worked for me.</source>
          <target state="translated">Yo tuve el mismo problema.Nadie me dio esta solución,pero funcionó para mí.</target>
        </trans-unit>
        <trans-unit id="649a0254690bae34aa046e5cb6817593ddfefee6" translate="yes" xml:space="preserve">
          <source>I have a strange situation that neither &lt;code&gt;git clean&lt;/code&gt; or &lt;code&gt;git reset&lt;/code&gt; works. I have to remove the conflicting file from &lt;code&gt;git index&lt;/code&gt; by using the following script on every untracked file:</source>
          <target state="translated">Tengo una situaci&amp;oacute;n extra&amp;ntilde;a en la que ni &lt;code&gt;git clean&lt;/code&gt; ni &lt;code&gt;git reset&lt;/code&gt; funcionan. Tengo que eliminar el archivo en conflicto del &lt;code&gt;git index&lt;/code&gt; usando el siguiente script en cada archivo sin seguimiento:</target>
        </trans-unit>
        <trans-unit id="7e8500eb1046100f489050b284eb5714559dccd2" translate="yes" xml:space="preserve">
          <source>I just solved this myself by:</source>
          <target state="translated">Acabo de resolver esto yo mismo:</target>
        </trans-unit>
        <trans-unit id="128a6bbe4bbca0ef46a7429b3fb884d19161c0cc" translate="yes" xml:space="preserve">
          <source>I know of a much easier and less painful method:</source>
          <target state="translated">Conozco un método mucho más fácil y menos doloroso:</target>
        </trans-unit>
        <trans-unit id="b59f82b60de1a26b35593dc01675e5a909ba8a5f" translate="yes" xml:space="preserve">
          <source>I solved it by:</source>
          <target state="translated">Lo resolví por:</target>
        </trans-unit>
        <trans-unit id="2bc8f27b388abdf40501aac72fdc18de4a394cc6" translate="yes" xml:space="preserve">
          <source>I summarized other answers. You can execute &lt;code&gt;git pull&lt;/code&gt; without errors:</source>
          <target state="translated">Resum&amp;iacute; otras respuestas. Puede ejecutar &lt;code&gt;git pull&lt;/code&gt; sin errores:</target>
        </trans-unit>
        <trans-unit id="9e9c607f31072847a38c9b05a9259fd67e496517" translate="yes" xml:space="preserve">
          <source>I think this is the right way:</source>
          <target state="translated">Creo que este es el camino correcto:</target>
        </trans-unit>
        <trans-unit id="5d91bb70a6390c473190410afcd9036e5f327d4f" translate="yes" xml:space="preserve">
          <source>I tried a lot but finally got success with these commands.</source>
          <target state="translated">Lo intenté mucho pero finalmente tuve éxito con estos comandos.</target>
        </trans-unit>
        <trans-unit id="ce04259de425930a4afb9a04ea73259e98934d7d" translate="yes" xml:space="preserve">
          <source>I'd advise doing the following:</source>
          <target state="translated">Aconsejaría hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="879f21df929422d62c19c054033c719da6cc86cc" translate="yes" xml:space="preserve">
          <source>I'm adding the images under the source control and pushing them to GitHub together with other changes</source>
          <target state="translated">Estoy agregando las imágenes bajo el control de la fuente y empujándolas a GitHub junto con otros cambios</target>
        </trans-unit>
        <trans-unit id="c0389297bccd119cc2155df40b7245a9b6d8ef46" translate="yes" xml:space="preserve">
          <source>If above won't help and you don't care about your untracked files/directories (make the backup first just in case), try the following simple steps:</source>
          <target state="translated">Si lo anterior no te ayuda y no te preocupas por los directorios de archivos no rastreados (haz primero la copia de seguridad por si acaso),intenta los siguientes pasos sencillos:</target>
        </trans-unit>
        <trans-unit id="e1164cfe9b4363ab446a620bf0fe7eb973b2d2fd" translate="yes" xml:space="preserve">
          <source>If that's the case, you've to commit these CRLF/LF changes (by reviewing them in &lt;code&gt;git status&lt;/code&gt;), or try: &lt;code&gt;git config core.autcrlf false&lt;/code&gt; to temporary ignore them.</source>
          <target state="translated">Si ese es el caso, debe confirmar estos cambios de CRLF / LF ( &lt;code&gt;git config core.autcrlf false&lt;/code&gt; en el &lt;code&gt;git status&lt;/code&gt; ), o intente: git config core.autcrlf false para ignorarlos temporalmente.</target>
        </trans-unit>
        <trans-unit id="be99b3701dbfa1ea6069b28872598c9af0eaf225" translate="yes" xml:space="preserve">
          <source>If you have any files that are &lt;em&gt;not&lt;/em&gt; tracked by Git (e.g. uploaded user content), these files will not be affected.</source>
          <target state="translated">Si tiene archivos que Git &lt;em&gt;no&lt;/em&gt; rastrea (por ejemplo, contenido de usuario cargado), estos archivos no se ver&amp;aacute;n afectados.</target>
        </trans-unit>
        <trans-unit id="0e7742626a2af9a263481a2ea42184887d357916" translate="yes" xml:space="preserve">
          <source>If you want to remove untracked directories in addition to untracked files:</source>
          <target state="translated">Si quieres eliminar los directorios no rastreados además de los archivos no rastreados:</target>
        </trans-unit>
        <trans-unit id="a180e327b58926ff442a586df94b1875f83ddd5f" translate="yes" xml:space="preserve">
          <source>Important: If you have any local changes, they will be lost. With or without &lt;code&gt;--hard&lt;/code&gt; option, any local commits that haven't been pushed will be lost.&lt;sup&gt;[*]&lt;/sup&gt;</source>
          <target state="translated">Importante: si tiene cambios locales, se perder&amp;aacute;n. Con o sin la opci&amp;oacute;n &lt;code&gt;--hard&lt;/code&gt; , se perder&amp;aacute;n todos los commits locales que no se hayan presionado. &lt;sup&gt;[*]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="03fc06a673c3bef7b930cdf312a4a24d568ded9b" translate="yes" xml:space="preserve">
          <source>In speaking of pull/fetch/merge in the previous answers, I would like to share an interesting and productive trick,</source>
          <target state="translated">Al hablar de pullfetchmerge en las respuestas anteriores,me gustaría compartir un truco interesante y productivo,</target>
        </trans-unit>
        <trans-unit id="ad81e97b3a770037ed684784fde0a5c8ef87d732" translate="yes" xml:space="preserve">
          <source>Instead of doing:</source>
          <target state="translated">En lugar de hacer:</target>
        </trans-unit>
        <trans-unit id="dcb313addf8398324b6dbe730aabe7eb8934c8e2" translate="yes" xml:space="preserve">
          <source>Instead of merging with &lt;code&gt;git pull&lt;/code&gt;, try this:</source>
          <target state="translated">En lugar de fusionarse con &lt;code&gt;git pull&lt;/code&gt; , intente esto:</target>
        </trans-unit>
        <trans-unit id="2cd313911aabf555c754ba83cda398a218f8f5a4" translate="yes" xml:space="preserve">
          <source>It looks like the best way is to first do:</source>
          <target state="translated">Parece que la mejor manera es hacerlo primero:</target>
        </trans-unit>
        <trans-unit id="0e06b597f22a2c59eaa962116cc249a03f1662a8" translate="yes" xml:space="preserve">
          <source>It seems like most answers here are focused on the &lt;code&gt;master&lt;/code&gt; branch; however, there are times when I'm working on the same feature branch in two different places and I want a rebase in one to be reflected in the other without a lot of jumping through hoops.</source>
          <target state="translated">Parece que la mayor&amp;iacute;a de las respuestas aqu&amp;iacute; se centran en la rama &lt;code&gt;master&lt;/code&gt; ; Sin embargo, hay momentos en los que estoy trabajando en la misma rama de caracter&amp;iacute;sticas en dos lugares diferentes y quiero que un rebase en uno se refleje en el otro sin tener que saltar muchos obst&amp;aacute;culos.</target>
        </trans-unit>
        <trans-unit id="7d8089aa0bbee09dd16c70b9dd88c5b319c9169f" translate="yes" xml:space="preserve">
          <source>It should do what you want.</source>
          <target state="translated">Debería hacer lo que tú quieres.</target>
        </trans-unit>
        <trans-unit id="f9e5e58435cb3bab1134eff5bbfd984a13e46944" translate="yes" xml:space="preserve">
          <source>Just do</source>
          <target state="translated">Sólo hazlo.</target>
        </trans-unit>
        <trans-unit id="bac005d3d83ada4449ef9cc4568c9cab8c7db381" translate="yes" xml:space="preserve">
          <source>Later you can clean the stash history.</source>
          <target state="translated">Más tarde puedes limpiar la historia del escondite.</target>
        </trans-unit>
        <trans-unit id="2ccb58cd1657aff4b8d5f6d44aa0ce72cd0f5cd5" translate="yes" xml:space="preserve">
          <source>Like Hedgehog I think the answers are terrible. But though Hedgehog's answer might be better, I don't think it is as elegant as it could be.  The way I found to do this is by using &quot;fetch&quot; and &quot;merge&quot; with a defined strategy. Which should make it so that your local changes are preserved as long as they are not one of the files that you are trying to force an overwrite with.</source>
          <target state="translated">Como Erizo,creo que las respuestas son terribles.Pero aunque la respuesta de Erizo podría ser mejor,no creo que sea tan elegante como podría ser.La forma en que encontré para hacer esto es usando &quot;buscar&quot; y &quot;fusionar&quot; con una estrategia definida.Lo que debería hacer que tus cambios locales se conserven siempre y cuando no sean uno de los archivos con los que intentas forzar una sobreescritura.</target>
        </trans-unit>
        <trans-unit id="57db7f84faa1518fd0d5c9bcdbb54d789e40298b" translate="yes" xml:space="preserve">
          <source>Local commits that are not on the remote branch need to be deleted as well. IMO the easiest way to achieve this is with: &lt;code&gt;git reset --hard origin/master&lt;/code&gt; (replace 'master' by whatever branch you are working on, and run a &lt;code&gt;git fetch origin&lt;/code&gt; first)</source>
          <target state="translated">Las confirmaciones locales que no est&amp;aacute;n en la rama remota tambi&amp;eacute;n deben eliminarse. En mi opini&amp;oacute;n, la forma m&amp;aacute;s f&amp;aacute;cil de lograr esto es con: &lt;code&gt;git reset --hard origin/master&lt;/code&gt; (reemplace 'master' por cualquier rama en la que est&amp;eacute; trabajando, y ejecute primero un &lt;code&gt;git fetch origin&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="902b1994ebdb1a49c25d1e1bcdd7120a07310fa8" translate="yes" xml:space="preserve">
          <source>Local files that are untracked need to be deleted, either manually (safer) or as suggested in other answers, by &lt;code&gt;git clean -f -d&lt;/code&gt;</source>
          <target state="translated">Los archivos locales que no se siguen deben eliminarse, ya sea manualmente (m&amp;aacute;s seguro) o como se sugiere en otras respuestas, mediante &lt;code&gt;git clean -f -d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebf666caa78cad721786be145be564955ec4d13f" translate="yes" xml:space="preserve">
          <source>Maintain current local commits</source>
          <target state="translated">Mantener los compromisos locales actuales</target>
        </trans-unit>
        <trans-unit id="27d3c0eecb54773d9a2bf6562cb66eb7114e4a4d" translate="yes" xml:space="preserve">
          <source>Make the local repository match the remote origin repository.</source>
          <target state="translated">Hacer que el repositorio local coincida con el repositorio de origen remoto.</target>
        </trans-unit>
        <trans-unit id="c44115da474d910d5bd67d5010c093acb30dad91" translate="yes" xml:space="preserve">
          <source>Manually, one-by-one:</source>
          <target state="translated">Manualmente,uno por uno:</target>
        </trans-unit>
        <trans-unit id="1f9d21224178a8ed1cca77caf291eba184ae786b" translate="yes" xml:space="preserve">
          <source>No need to fetch all remotes and branches if you're going to reset to the origin/master branch right?</source>
          <target state="translated">No hay necesidad de ir a buscar todos los mandos y ramas si vas a resetear la rama original,¿verdad?</target>
        </trans-unit>
        <trans-unit id="36d03b9af07b5eaff018766e46d322d377dc6f23" translate="yes" xml:space="preserve">
          <source>Now it works.</source>
          <target state="translated">Ahora funciona.</target>
        </trans-unit>
        <trans-unit id="bf662c7bf7c1229391af4012d4ab4979da22561f" translate="yes" xml:space="preserve">
          <source>OR If you are on some other branch:</source>
          <target state="translated">O si estás en alguna otra rama:</target>
        </trans-unit>
        <trans-unit id="33b6a45ba92ca30383f55274e41f4e14184846bf" translate="yes" xml:space="preserve">
          <source>Of course if you want to go back to what you stashed:</source>
          <target state="translated">Por supuesto,si quieres volver a lo que has escondido:</target>
        </trans-unit>
        <trans-unit id="11be4c8b5293489e43dade05c7b3663d51f1211e" translate="yes" xml:space="preserve">
          <source>Or, in your &lt;code&gt;.gitconfig&lt;/code&gt; file:</source>
          <target state="translated">O, en su archivo &lt;code&gt;.gitconfig&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="42da08286231f6c3d657f652d649f572c9396d4c" translate="yes" xml:space="preserve">
          <source>Rather (git &amp;gt; v1.7.6):</source>
          <target state="translated">M&amp;aacute;s bien (git&amp;gt; v1.7.6):</target>
        </trans-unit>
        <trans-unit id="475ffa14014bb463965306813410e4afd01a7039" translate="yes" xml:space="preserve">
          <source>Requirements:</source>
          <target state="translated">Requirements:</target>
        </trans-unit>
        <trans-unit id="915317e7edd24055b8e04b2d411caa7b7533153c" translate="yes" xml:space="preserve">
          <source>Reset the index and the head to &lt;code&gt;origin/master&lt;/code&gt;, but do not reset the working tree:</source>
          <target state="translated">Restablezca el &amp;iacute;ndice y la cabeza a &lt;code&gt;origin/master&lt;/code&gt; , pero no restablezca el &amp;aacute;rbol de trabajo:</target>
        </trans-unit>
        <trans-unit id="9ab708d6bf11eb7eae1427bfc4104732844213b0" translate="yes" xml:space="preserve">
          <source>Run this from a branch and it'll only reset your local branch to the upstream version.</source>
          <target state="translated">Ejecuta esto desde una rama y sólo reiniciará tu rama local a la versión upstream.</target>
        </trans-unit>
        <trans-unit id="807398f22444dcc53d6db811aebb6cd9cc2291af" translate="yes" xml:space="preserve">
          <source>So you avoid all unwanted side effects, like deleting files or directories you wanted to keep, etc.</source>
          <target state="translated">Así que evitas todos los efectos secundarios no deseados,como borrar archivos o directorios que querías conservar,etc.</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="9587d887b8a5d76ff8f5b3ca6941e7eae087b881" translate="yes" xml:space="preserve">
          <source>Some answers seem to be terrible. Terrible in the sense of what happened to @Lauri by following David Avsajanishvili suggestion.</source>
          <target state="translated">Algunas respuestas parecen ser terribles.Terribles en el sentido de lo que le pasó a @Lauri siguiendo la sugerencia de David Avsajanishvili.</target>
        </trans-unit>
        <trans-unit id="0d28dcfeeae68b49b63a4e472f2f8328b5fdd4e3" translate="yes" xml:space="preserve">
          <source>Sometimes just &lt;code&gt;clean -f&lt;/code&gt; does not help. In case you have untracked DIRECTORIES, -d option also needed:</source>
          <target state="translated">A veces solo &lt;code&gt;clean -f&lt;/code&gt; no ayuda. En caso de que haya rastreado DIRECTORIOS, tambi&amp;eacute;n se necesita la opci&amp;oacute;n -d:</target>
        </trans-unit>
        <trans-unit id="8631c9b28f153fae2e2fef4e1316c5b69bbe8cfd" translate="yes" xml:space="preserve">
          <source>That in mind, I updated Kustudic's script to do just that.  I also fixed a typo (a missing ' in the original).</source>
          <target state="translated">Teniendo eso en cuenta,actualicé el guión de Kustudic para hacer justamente eso.También arreglé un error de imprenta (un &quot;missing&quot; en el original).</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">¡Eso es!</target>
        </trans-unit>
        <trans-unit id="25600d3a9892efcd21d9b4cfc94b0ab9748ed9b2" translate="yes" xml:space="preserve">
          <source>The first command fetches newest data.</source>
          <target state="translated">El primer comando obtiene los datos más recientes.</target>
        </trans-unit>
        <trans-unit id="253df425511692a7988571c26edb1c772b59d386" translate="yes" xml:space="preserve">
          <source>The following version commits your local changes to a temporary branch (&lt;code&gt;tmp&lt;/code&gt;), checks out the original branch (which I'm assuming is &lt;code&gt;master&lt;/code&gt;) and merges the updates. You could do this with &lt;code&gt;stash&lt;/code&gt;, but I've found it's usually easier to simply use the branch / merge approach.</source>
          <target state="translated">La siguiente versi&amp;oacute;n confirma los cambios locales en una rama temporal ( &lt;code&gt;tmp&lt;/code&gt; ), comprueba la rama original (que supongo que es &lt;code&gt;master&lt;/code&gt; ) y combina las actualizaciones. Podr&amp;iacute;as hacer esto con &lt;code&gt;stash&lt;/code&gt; , pero he descubierto que generalmente es m&amp;aacute;s f&amp;aacute;cil simplemente usar el enfoque de ramificaci&amp;oacute;n / fusi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6bde0e00397fa4ee9171ff863ee7e069991bf8f0" translate="yes" xml:space="preserve">
          <source>The only thing that worked for me was:</source>
          <target state="translated">La única cosa que funcionó para mí fue:</target>
        </trans-unit>
        <trans-unit id="b8d26d09bd803d962c0ffdc7865ca8eded89d169" translate="yes" xml:space="preserve">
          <source>The problem with all these solutions is that they are all either too complex, or, an even bigger problem, is that they remove all untracked files from the web server, which we don't want since there are always needed configuration files which are on the server and not in the Git repository.</source>
          <target state="translated">El problema con todas estas soluciones es que son demasiado complejas,o,un problema aún mayor,es que eliminan todos los archivos no rastreados del servidor web,lo cual no queremos ya que siempre hay archivos de configuración necesarios que están en el servidor y no en el repositorio de Git.</target>
        </trans-unit>
        <trans-unit id="c3c10cc0d5a31ff5783080c9bd9635741b253fc8" translate="yes" xml:space="preserve">
          <source>The second command checks if there are any files which are being added to the repository and deletes those untracked files from the local repository which would cause conflicts.</source>
          <target state="translated">El segundo comando comprueba si hay algún archivo que se esté añadiendo al repositorio y elimina del repositorio local los archivos no rastreados que podrían causar conflictos.</target>
        </trans-unit>
        <trans-unit id="678000075b4d6cd38269dac48c4b8d87c1fca462" translate="yes" xml:space="preserve">
          <source>The third command checks-out all the files which were locally modified.</source>
          <target state="translated">El tercer comando comprueba todos los archivos que fueron modificados localmente.</target>
        </trans-unit>
        <trans-unit id="21267f318079f6774b177821837cc891b20ba5c7" translate="yes" xml:space="preserve">
          <source>Then I am able to pull just fine.</source>
          <target state="translated">Entonces soy capaz de tirar bien.</target>
        </trans-unit>
        <trans-unit id="5f21d45c01e403eb57b1b5827ca4047a372a4082" translate="yes" xml:space="preserve">
          <source>Then fetch the changes and overwrite if there is a conflict</source>
          <target state="translated">Entonces busca los cambios y sobrescribe si hay un conflicto</target>
        </trans-unit>
        <trans-unit id="c676bc4481885bfedae0258dc14ccea8e8999c8a" translate="yes" xml:space="preserve">
          <source>Then pull it again.</source>
          <target state="translated">Entonces tira de él otra vez.</target>
        </trans-unit>
        <trans-unit id="ee4ca7fba794f3af9d4fb46b93e0453c258d261c" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;git reset&lt;/code&gt; resets the master branch to what you just fetched. The &lt;code&gt;--hard&lt;/code&gt; option changes all the files in your working tree to match the files in &lt;code&gt;origin/master&lt;/code&gt;</source>
          <target state="translated">Luego, el &lt;code&gt;git reset&lt;/code&gt; restablece la rama maestra a lo que acaba de obtener. La opci&amp;oacute;n &lt;code&gt;--hard&lt;/code&gt; cambia todos los archivos en su &amp;aacute;rbol de trabajo para que coincidan con los archivos en &lt;code&gt;origin/master&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d81ef5f48f166e14f75ad40236c0c9df9e4a75e1" translate="yes" xml:space="preserve">
          <source>Then, you have two options:</source>
          <target state="translated">Entonces,tienes dos opciones:</target>
        </trans-unit>
        <trans-unit id="7798b87989a4d7b4641302aaed49212a7fe8c801" translate="yes" xml:space="preserve">
          <source>These four commands work for me.</source>
          <target state="translated">Estos cuatro comandos trabajan para mí.</target>
        </trans-unit>
        <trans-unit id="ff127378bb08dc1448022a9641654c494f565c1d" translate="yes" xml:space="preserve">
          <source>They are adding some images to the images directory (but forgets to add them under source control)</source>
          <target state="translated">Están agregando algunas imágenes al directorio de imágenes (pero se olvida de agregarlas bajo el control de la fuente)</target>
        </trans-unit>
        <trans-unit id="03b8bbdb6eb2cf69f8cb249139cd7ce228faaecf" translate="yes" xml:space="preserve">
          <source>They are sending the images by mail, later, to me</source>
          <target state="translated">Están enviando las imágenes por correo,más tarde,a mí.</target>
        </trans-unit>
        <trans-unit id="7cd7a4110beebad617002342d669e523a4966903" translate="yes" xml:space="preserve">
          <source>They cannot pull updates from GitHub because Git doesn't want to overwrite their files.</source>
          <target state="translated">No pueden sacar actualizaciones de GitHub porque Git no quiere sobrescribir sus archivos.</target>
        </trans-unit>
        <trans-unit id="0c0bc2340a056214e8100c82b907cb176343ebc8" translate="yes" xml:space="preserve">
          <source>This above command is the most useful command in my Git life which saved a lot of time.</source>
          <target state="translated">Este comando es el más útil de mi vida en Git y me ha ahorrado mucho tiempo.</target>
        </trans-unit>
        <trans-unit id="2e784adb16c7ed518925195e69f1ed074a41fa47" translate="yes" xml:space="preserve">
          <source>This can be nicely put into a git alias (&lt;code&gt;git forcepull&lt;/code&gt;) as well:</source>
          <target state="translated">Esto tambi&amp;eacute;n se puede poner muy bien en un git alias ( &lt;code&gt;git forcepull&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="7fa72933f59b96fd34b4e375dec6861fc0377acd" translate="yes" xml:space="preserve">
          <source>This will REMOVE all git files (excempt &lt;code&gt;.git/&lt;/code&gt; dir, where you have all commits) and pull it again.</source>
          <target state="translated">Esto eliminar&amp;aacute; todos los archivos git (excede &lt;code&gt;.git/&lt;/code&gt; dir, donde tiene todos los commits) y lo volver&amp;aacute; a extraer.</target>
        </trans-unit>
        <trans-unit id="1913d306d1a42c1564720a4d705c73b9650593f6" translate="yes" xml:space="preserve">
          <source>This will override your local file with the file on git</source>
          <target state="translated">Esto anulará tu archivo local con el archivo en git</target>
        </trans-unit>
        <trans-unit id="947b34a00d726c657b12cdbaccdf65e09fd25d8d" translate="yes" xml:space="preserve">
          <source>This will take you back five commits and then with</source>
          <target state="translated">Esto te hará retroceder cinco compromisos y luego con</target>
        </trans-unit>
        <trans-unit id="01731cd723b90256eccc7d0a8072853bf68d619c" translate="yes" xml:space="preserve">
          <source>To check/pull after executing these commands</source>
          <target state="translated">Para comprobar el tirón después de ejecutar estos comandos</target>
        </trans-unit>
        <trans-unit id="792990822a55aacc5ab96839f6879d0ab135b670" translate="yes" xml:space="preserve">
          <source>To delete all untracked files and then continue with the usual &lt;code&gt;git pull&lt;/code&gt;...</source>
          <target state="translated">Para eliminar todos los archivos no rastreados y luego continuar con el &lt;code&gt;git pull&lt;/code&gt; habitual ...</target>
        </trans-unit>
        <trans-unit id="2e97c37f66bbb352cb86c890973bbee6dd9264e4" translate="yes" xml:space="preserve">
          <source>Track local changes so no-one here ever loses them.</source>
          <target state="translated">Rastrea los cambios locales para que nadie aquí los pierda.</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">Pruebe esto:</target>
        </trans-unit>
        <trans-unit id="79d1acaccc53be854e44cb88d8a731ca26725f61" translate="yes" xml:space="preserve">
          <source>Uncommitted changes</source>
          <target state="translated">Cambios no comprometidos</target>
        </trans-unit>
        <trans-unit id="35d60c13f1637f01f05b6c59bfb6bb4fbae9aac4" translate="yes" xml:space="preserve">
          <source>Uncommitted changes, however (even staged), will be lost. Make sure to stash and commit anything you need. For that you can run the following:</source>
          <target state="translated">Sin embargo,los cambios no comprometidos (incluso los escenificados),se perderán.Asegúrate de guardar y comprometer todo lo que necesites.Para ello puedes ejecutar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="a04a85b4f229d1ba1c004f1d7dfc9dad4ba95354" translate="yes" xml:space="preserve">
          <source>When you're using file-system which doesn't support permission attributes.
In example you have two repositories, one on Linux/Mac (&lt;code&gt;ext3&lt;/code&gt;/&lt;code&gt;hfs+&lt;/code&gt;) and another one on FAT32/NTFS based file-system.</source>
          <target state="translated">Cuando usa un sistema de archivos que no admite atributos de permiso. Por ejemplo, tiene dos repositorios, uno en Linux / Mac ( &lt;code&gt;ext3&lt;/code&gt; / &lt;code&gt;hfs+&lt;/code&gt; ) y otro en el sistema de archivos basado en FAT32 / NTFS.</target>
        </trans-unit>
        <trans-unit id="b59d9f65f3bfd048d61e29b69d244223b5fd2b4d" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;git reset HEAD --hard&lt;/code&gt; could fail in some cases?</source>
          <target state="translated">&amp;iquest;Por qu&amp;eacute; &lt;code&gt;git reset HEAD --hard&lt;/code&gt; podr&amp;iacute;a fallar en algunos casos?</target>
        </trans-unit>
        <trans-unit id="e676bf6f98187f56702c31f2b2f0568c7e63be07" translate="yes" xml:space="preserve">
          <source>You might find this command helpful to throw away local changes:</source>
          <target state="translated">Puede que encuentres este comando útil para desechar los cambios locales:</target>
        </trans-unit>
        <trans-unit id="6f68fbd4c89d37bb92c0eccd976bc907b757552a" translate="yes" xml:space="preserve">
          <source>error: Untracked working tree file 'public/images/icon.gif' would be overwritten by merge</source>
          <target state="translated">error:Un archivo de árbol de trabajo no rastreado 'publimagesicon.gif' sería sobrescrito por la fusión</target>
        </trans-unit>
        <trans-unit id="9351bd81e6470b3b0902ff748b289a7935609351" translate="yes" xml:space="preserve">
          <source>followed by:</source>
          <target state="translated">seguido de:</target>
        </trans-unit>
        <trans-unit id="ddea56ff50be6923b4fcf019f86bdb93636ef9b3" translate="yes" xml:space="preserve">
          <source>where the last command gives a list of what your local changes were. Keep modifying the &quot;tmp&quot; branch until it is acceptable and then merge back onto master with:</source>
          <target state="translated">donde el último comando da una lista de cuáles fueron sus cambios locales.Sigue modificando la rama &quot;tmp&quot; hasta que sea aceptable y luego vuelve a fusionarse con el maestro:</target>
        </trans-unit>
        <trans-unit id="016dc548ba6ea5dc4ca066fa1aaacbe2d5292693" translate="yes" xml:space="preserve">
          <source>where we assume the &lt;strong&gt;other repository&lt;/strong&gt; is &lt;code&gt;origin master&lt;/code&gt;.</source>
          <target state="translated">donde asumimos que el &lt;strong&gt;otro repositorio&lt;/strong&gt; es &lt;code&gt;origin master&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
