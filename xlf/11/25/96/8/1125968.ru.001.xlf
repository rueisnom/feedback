<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1125968">
    <body>
      <group id="1125968">
        <trans-unit id="5afb90bc1680715416282876077bc225842cbc96" translate="yes" xml:space="preserve">
          <source>&quot;-X&quot; is an option name, and &quot;theirs&quot; is the value for that option. You're choosing to use &quot;their&quot; changes, instead of &quot;your&quot; changes if there is a conflict.</source>
          <target state="translated">&quot;-X&quot;-название опции,а &quot;их&quot;-значение для этой опции.Вы выбираете использовать &quot;их&quot; изменения,а не &quot;ваши&quot;,если есть конфликт.</target>
        </trans-unit>
        <trans-unit id="70ecf3b9a626c0d63016862459beb96a7cd9fd04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; downloads the latest from remote without trying to merge or rebase anything.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; загружает последние данные с удаленного компьютера, не пытаясь объединить или переместить что-либо.</target>
        </trans-unit>
        <trans-unit id="bc940fd283a79b9e47237dc19b00c61dd5539710" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard origin/master&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git reset --hard origin/master&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b77648ec75a644255f4be7f9dd3cb5598cd48b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git pull --rebase&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git pull --rebase&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f4dc4e310800c0b0a13a28965d7a56a3b773f32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fetch&lt;/strong&gt; with a &lt;strong&gt;clean&lt;/strong&gt; of &lt;strong&gt;files&lt;/strong&gt; and &lt;strong&gt;directories&lt;/strong&gt; ignoring &lt;strong&gt;.gitignore&lt;/strong&gt; and &lt;strong&gt;hard reset&lt;/strong&gt; to &lt;strong&gt;origin&lt;/strong&gt;.</source>
          <target state="translated">&lt;strong&gt;Получить&lt;/strong&gt; с &lt;strong&gt;чистыми&lt;/strong&gt; &lt;strong&gt;файлами&lt;/strong&gt; и &lt;strong&gt;каталогами,&lt;/strong&gt; игнорируя &lt;strong&gt;.gitignore&lt;/strong&gt; и &lt;strong&gt;полный&lt;/strong&gt; &lt;strong&gt;сброс&lt;/strong&gt; к &lt;strong&gt;исходному&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="6031888574223bffc84d9cd8bf2d9a79f815c173" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stash&lt;/strong&gt; the local changes.</source>
          <target state="translated">&lt;strong&gt;Копите&lt;/strong&gt; местные изменения.</target>
        </trans-unit>
        <trans-unit id="dcc197827149be97581e309fb6dce7a656af78bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The scenario is the following:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Сценарий следующий:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3c42a8134f0739a17a678e3e0dcb0771efa7cdb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the error I'm getting:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Это ошибка, которую я получаю:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4a7132acfa00c3c71261b610b730a413f758186" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING: &lt;code&gt;git clean&lt;/code&gt; deletes all your untracked files/directories and can't be undone.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ВНИМАНИЕ: &lt;code&gt;git clean&lt;/code&gt; удаляет все ваши неотслеживаемые файлы / каталоги и не может быть отменен.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="967b8bcb08e168bba241f9faffbb234be29aee97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning, doing this will permanently delete your files if you have any directory/* entries in your gitignore file.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Внимание, это навсегда удалит ваши файлы, если в вашем файле gitignore есть записи каталога / *.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c62d7e7d52d9e8d8a3e0ab4fcbe742a08c5a51f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This script is very powerful, so you could lose your changes.</source>
          <target state="translated">&lt;strong&gt;Предупреждение&lt;/strong&gt; : этот скрипт очень мощный, поэтому вы можете потерять свои изменения.</target>
        </trans-unit>
        <trans-unit id="6c5e0c503728653826db9fcefc33c40057e4a0cf" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;strong&gt;Warning&lt;/strong&gt;: Above commands can results in data/files loss only if you don't have them committed! If you're not sure, make the backup first of your whole repository folder.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;strong&gt;Предупреждение&lt;/strong&gt; : вышеуказанные команды могут привести к потере данных / файлов, только если вы их не зафиксировали!&lt;/sup&gt; &lt;sup&gt;Если вы не уверены, сначала сделайте резервную копию всей вашей папки репозитория.&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1ed6e68c2afe2cc46a2ddfb7b88e004a4df0bc59" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[*]&lt;/sup&gt;: It's worth noting that it is possible to maintain current local commits by creating a branch from &lt;code&gt;master&lt;/code&gt; before resetting:</source>
          <target state="translated">&lt;sup&gt;[*]&lt;/sup&gt; : Стоит отметить, что можно сохранить текущие локальные коммиты, создав ветку от &lt;code&gt;master&lt;/code&gt; перед сбросом:</target>
        </trans-unit>
        <trans-unit id="36038a15055095eee9da18058a5e2c67e12a05ad" translate="yes" xml:space="preserve">
          <source>A team member is modifying the templates for a website we are working on</source>
          <target state="translated">Один из членов команды модифицирует шаблоны для сайта,над которым мы работаем.</target>
        </trans-unit>
        <trans-unit id="a180c1f257cadb94780423f139159de8269da2c0" translate="yes" xml:space="preserve">
          <source>After this, all of the old commits will be kept in &lt;code&gt;new-branch-to-save-current-commits&lt;/code&gt;.</source>
          <target state="translated">После этого все старые коммиты будут храниться в &lt;code&gt;new-branch-to-save-current-commits&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36c034e52a3013a7eb18bd0e736106a3162dc9b7" translate="yes" xml:space="preserve">
          <source>An easier way would be to:</source>
          <target state="translated">Проще было бы:</target>
        </trans-unit>
        <trans-unit id="a7eccdc85e1d8fab375e2e045e94fc4580337ef4" translate="yes" xml:space="preserve">
          <source>And then do a cleanup (removes untracked files from the working tree):</source>
          <target state="translated">А затем выполните очистку (удалит неотслеживаемые файлы из рабочего дерева):</target>
        </trans-unit>
        <trans-unit id="78daf6f4dc00ac5359931b14a322206862bd8d53" translate="yes" xml:space="preserve">
          <source>And then to reapply these uncommitted changes:</source>
          <target state="translated">А затем повторно применить эти нефиксированные изменения:</target>
        </trans-unit>
        <trans-unit id="3dbb2aa68555e791ab4d7fde77f19d2a5b2a8a25" translate="yes" xml:space="preserve">
          <source>As you notice, there are two different kind of file systems, so the one which doesn't support Unix permissions basically can't reset file permissions on system which doesn't support that kind of permissions, so no matter how &lt;code&gt;--hard&lt;/code&gt; you try, git always detect some &quot;changes&quot;.</source>
          <target state="translated">Как вы заметили, существует два разных типа файловых систем, поэтому та, которая не поддерживает разрешения Unix, в основном не может сбросить разрешения для файлов в системе, которая не поддерживает такие разрешения, поэтому независимо от того, &lt;code&gt;--hard&lt;/code&gt; попробуйте, git всегда обнаруживает некоторые &quot;изменения&quot;.</target>
        </trans-unit>
        <trans-unit id="176ed3df07c6cab12f3824cd3af53a19fe5a4ac5" translate="yes" xml:space="preserve">
          <source>Based on a combination of &lt;a href=&quot;https://stackoverflow.com/a/8888015/1103543&quot;&gt;RNA's answer&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/19961461/1103543&quot;&gt;torek's answer to a similar question&lt;/a&gt;, I've come up with this which works splendidly:</source>
          <target state="translated">Основываясь на комбинации &lt;a href=&quot;https://stackoverflow.com/a/8888015/1103543&quot;&gt;ответа РНК и ответа&lt;/a&gt; &lt;a href=&quot;https://stackoverflow.com/a/19961461/1103543&quot;&gt;Торека на похожий вопрос&lt;/a&gt; , я пришел к такому, который прекрасно работает:</target>
        </trans-unit>
        <trans-unit id="5c86cd4334fa80da1de659e41c3792751d28a710" translate="yes" xml:space="preserve">
          <source>Based on my own similar experiences, the solution offered by Strahinja Kustudic above is by far the best.  As others have pointed out, simply doing hard reset will remove &lt;strong&gt;all&lt;/strong&gt; the untracked files which could include lots of things that you don't want removed, such as config files.  What is safer, is to remove only the files that are about to be added, and for that matter, you'd likely also want to checkout any locally-modified files that are about to be updated.</source>
          <target state="translated">Исходя из моего собственного подобного опыта, решение, предложенное Страхиной Кустудич, выше, безусловно, является лучшим. Как уже отмечали другие, простой сброс настроек удалит &lt;strong&gt;все&lt;/strong&gt; неотслеживаемые файлы, которые могут включать в себя множество вещей, которые вы не хотите удалять, например файлы конфигурации. Более безопасным является удаление только тех файлов, которые будут добавлены, и в этом отношении вы, вероятно, также захотите извлечь любые локально-модифицированные файлы, которые будут обновлены.</target>
        </trans-unit>
        <trans-unit id="66fd03594a2c157f1cc4300404f810b1d6f6ef22" translate="yes" xml:space="preserve">
          <source>Before pushing your newly commit to server, try this command and it will automatically synchronise the latest server changes (with a fetch + merge) and will place your commit at the top in the Git log. There isn't any need to worry about manual pull/merge.</source>
          <target state="translated">Перед тем,как нажать на ваш новый коммит на сервере,попробуйте эту команду,и он автоматически синхронизирует последние изменения на сервере (с помощью fetch+слияние)и поместит ваш коммит вверх в Git-журнал.Нет необходимости беспокоиться о ручном вытаскивании.</target>
        </trans-unit>
        <trans-unit id="5763578555f814c96231de97e5710d397db26670" translate="yes" xml:space="preserve">
          <source>Bonus:</source>
          <target state="translated">Bonus:</target>
        </trans-unit>
        <trans-unit id="3c246aca15204187cf5403a724bf7c4ed1f89f75" translate="yes" xml:space="preserve">
          <source>Brutally, all-at-once:</source>
          <target state="translated">Жестоко,все-в-одном:</target>
        </trans-unit>
        <trans-unit id="0f3d70d10152b31329fca6d57c58dd5a7548905c" translate="yes" xml:space="preserve">
          <source>Consider using &lt;code&gt;-n&lt;/code&gt; (&lt;code&gt;--dry-run&lt;/code&gt;) flag first. This will show you what will be deleted without actually deleting anything:</source>
          <target state="translated">Попробуйте &lt;code&gt;--dry-run&lt;/code&gt; флаг &lt;code&gt;-n&lt;/code&gt; ( --dry-run ). Это покажет вам, что будет удалено, фактически ничего не удаляя:</target>
        </trans-unit>
        <trans-unit id="27a5712e08f3ae4b6c16fa9dbe1f57b88d828e9d" translate="yes" xml:space="preserve">
          <source>Custom rules in &lt;code&gt;.gitattributes file&lt;/code&gt;</source>
          <target state="translated">Пользовательские правила в &lt;code&gt;.gitattributes file&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5969bf1b4e4687ca1fb9f6fc009150bef42d135f" translate="yes" xml:space="preserve">
          <source>Delete all the files. Leave just the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">Удалить все файлы. Оставьте только каталог &lt;code&gt;.git&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ac1711535c3631326eb072df130168ba61081aa" translate="yes" xml:space="preserve">
          <source>Despite the original question, the top answers can cause problems for people who have a similar problem, but don't want to lose their local files. For example, see Al-Punk and crizCraig's comments.</source>
          <target state="translated">Несмотря на исходный вопрос,лучшие ответы могут вызвать проблемы у людей,у которых есть похожая проблема,но которые не хотят потерять свои локальные файлы.Например,см.комментарии Al-Punk и crizCraig.</target>
        </trans-unit>
        <trans-unit id="f5169c84497de3aea74f7da9e7e177d1427e736b" translate="yes" xml:space="preserve">
          <source>Enjoy!</source>
          <target state="translated">Enjoy!</target>
        </trans-unit>
        <trans-unit id="2e4ccc244461fd2a12825ef96a60da2329e2ce3c" translate="yes" xml:space="preserve">
          <source>Example output:</source>
          <target state="translated">Пример вывода:</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="633b8ed4341c493911bcdea67fbf3a7e52e105ed" translate="yes" xml:space="preserve">
          <source>File system incompability</source>
          <target state="translated">Несоответствие файловой системы</target>
        </trans-unit>
        <trans-unit id="ac51316d6159411acf5b3f583c8d9c8a8d26ccdc" translate="yes" xml:space="preserve">
          <source>Finally we do a pull to update to the newest version, but this time without any conflicts, since untracked files which are in the repo don't exist anymore and all the locally modified files are already the same as in the repository.</source>
          <target state="translated">Наконец,мы делаем подтягивание для обновления до новейшей версии,но на этот раз без конфликтов,так как неотслеживаемых файлов,которые находятся в репозитории,больше не существует,и все локально измененные файлы уже такие же,как и в репозитории.</target>
        </trans-unit>
        <trans-unit id="733954012af2f88caae800ae8ecbbdd4f2b12025" translate="yes" xml:space="preserve">
          <source>Find details in &lt;em&gt;&lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;What does &quot;git pull --rebase&quot; do?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">Найти детали в &lt;em&gt;&lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;Что делает &quot;git pull --rebase&quot;?&lt;/a&gt;&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="6dc0d8358e432ef94381d4e39acde5f09ef69da0" translate="yes" xml:space="preserve">
          <source>First do a commit of your changes</source>
          <target state="translated">Сначала сделайте фиксацию ваших изменений</target>
        </trans-unit>
        <trans-unit id="b3e145b7648ef683eaac2a7805b4e4b762bbad1f" translate="yes" xml:space="preserve">
          <source>First of all, try the standard way:</source>
          <target state="translated">Прежде всего,попробуй стандартный способ:</target>
        </trans-unit>
        <trans-unit id="e91bc256ad13d894ea5b4b99e3446667f554a6a2" translate="yes" xml:space="preserve">
          <source>For next time, you can probably handle this in a cleaner way by looking up &quot;git stash branch&quot; though stash is likely to cause you trouble on the first few tries, so do first experiment on a non-critical project...</source>
          <target state="translated">В следующий раз,вероятно,вы сможете справиться с этим более чистым способом,заглянув в &quot;git-заначку&quot;,хотя заначка,скорее всего,доставит вам неприятности при первых нескольких попытках,так что сначала поэкспериментируйте с некритическим проектом...</target>
        </trans-unit>
        <trans-unit id="c89f6341c557881ef5a26399ed1653fe3ebdf78e" translate="yes" xml:space="preserve">
          <source>Having &lt;code&gt;eol=lf&lt;/code&gt; rule in .gitattributes could cause git to modify some file changes by converting CRLF line-endings into LF in some text files.</source>
          <target state="translated">Наличие правила eol &lt;code&gt;eol=lf&lt;/code&gt; в .gitattributes может привести к тому, что git изменит некоторые изменения файла, преобразовав окончания строк CRLF в LF в некоторых текстовых файлах.</target>
        </trans-unit>
        <trans-unit id="93154f89378492cd0c83e1aab6e6159f0de9d7ea" translate="yes" xml:space="preserve">
          <source>Here is the cleanest solution which we are using:</source>
          <target state="translated">Вот самое чистое решение,которое мы используем:</target>
        </trans-unit>
        <trans-unit id="1f637bf42e756c960767eb126fdd9d9bebbd7a74" translate="yes" xml:space="preserve">
          <source>How do I force Git to overwrite them? The person is a designer - usually, I resolve all the conflicts by hand, so the server has the most recent version that they just need to update on their computer.</source>
          <target state="translated">Как заставить Гита перезаписать их? Человек является дизайнером-обычно я разрешаю все конфликты вручную,поэтому на сервере есть самая последняя версия,которую нужно просто обновить на компьютере.</target>
        </trans-unit>
        <trans-unit id="e3a2f47cc14d50df3baa2c14a0ddf658114561df" translate="yes" xml:space="preserve">
          <source>How do I force an overwrite of local files on a &lt;code&gt;git pull&lt;/code&gt;?</source>
          <target state="translated">Как принудительно перезаписать локальные файлы в &lt;code&gt;git pull&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="022b126cf5d96f5acd5353613e02e8e093951fcf" translate="yes" xml:space="preserve">
          <source>How do I force “git pull” to overwrite local files</source>
          <target state="translated">Как заставить &quot;git pull&quot; перезаписать локальные файлы.</target>
        </trans-unit>
        <trans-unit id="dea1758cfb7d54073565d160ed1da9d3735d7d43" translate="yes" xml:space="preserve">
          <source>I believe there are two possible causes of conflict, which must be solved separately, and as far as I can tell none of the above answers deals with both:</source>
          <target state="translated">Я считаю,что есть две возможные причины конфликта,которые должны быть решены отдельно,и,насколько я могу судить,ни один из вышеперечисленных ответов не касается обеих:</target>
        </trans-unit>
        <trans-unit id="9d39e53821ce6f629f48322aff08f227653eb992" translate="yes" xml:space="preserve">
          <source>I found that by looking up &lt;a href=&quot;https://stackoverflow.com/questions/2389361/git-undo-a-merge&quot;&gt;how to undo a Git merge&lt;/a&gt;.</source>
          <target state="translated">Я нашел это, посмотрев, &lt;a href=&quot;https://stackoverflow.com/questions/2389361/git-undo-a-merge&quot;&gt;как отменить слияние Git&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="95f170181b4a919a57346c13c88eae271970ecf3" translate="yes" xml:space="preserve">
          <source>I had a similar problem.  I had to do this:</source>
          <target state="translated">У меня была похожая проблема.Я должен был это сделать:</target>
        </trans-unit>
        <trans-unit id="8628e6103828b4e62119bb52d8a10ca6f0446469" translate="yes" xml:space="preserve">
          <source>I had the same problem and for some reason, even a &lt;code&gt;git clean -f -d&lt;/code&gt; would not do it. Here is why: For some reason, if your file is ignored by Git (via a .gitignore entry, I assume), it still bothers about overwriting this with a later &lt;em&gt;pull&lt;/em&gt;, but a &lt;em&gt;clean&lt;/em&gt; will not remove it, unless you add &lt;code&gt;-x&lt;/code&gt;.</source>
          <target state="translated">У меня была та же проблема, и по какой-то причине, даже &lt;code&gt;git clean -f -d&lt;/code&gt; этого не сделал. И вот почему: по какой-то причине, если Git игнорирует ваш файл (я полагаю, через запись .gitignore), он все еще беспокоится о перезаписи этого с более поздним &lt;em&gt;извлечением&lt;/em&gt; , но &lt;em&gt;очистка&lt;/em&gt; не удалит его, если вы не добавите &lt;code&gt;-x&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="cfc7e1dda03c9f91868de6432e4c926b6660c9cf" translate="yes" xml:space="preserve">
          <source>I had the same problem. No one gave me this solution, but it worked for me.</source>
          <target state="translated">У меня была та же проблема.Никто не дал мне это решение,но оно сработало на меня.</target>
        </trans-unit>
        <trans-unit id="649a0254690bae34aa046e5cb6817593ddfefee6" translate="yes" xml:space="preserve">
          <source>I have a strange situation that neither &lt;code&gt;git clean&lt;/code&gt; or &lt;code&gt;git reset&lt;/code&gt; works. I have to remove the conflicting file from &lt;code&gt;git index&lt;/code&gt; by using the following script on every untracked file:</source>
          <target state="translated">У меня странная ситуация, что ни &lt;code&gt;git clean&lt;/code&gt; , ни &lt;code&gt;git reset&lt;/code&gt; не работают. Я должен удалить конфликтующий файл из &lt;code&gt;git index&lt;/code&gt; , используя следующий скрипт для каждого неотслеживаемого файла:</target>
        </trans-unit>
        <trans-unit id="7e8500eb1046100f489050b284eb5714559dccd2" translate="yes" xml:space="preserve">
          <source>I just solved this myself by:</source>
          <target state="translated">Я только что сам разобрался с этим:</target>
        </trans-unit>
        <trans-unit id="128a6bbe4bbca0ef46a7429b3fb884d19161c0cc" translate="yes" xml:space="preserve">
          <source>I know of a much easier and less painful method:</source>
          <target state="translated">Я знаю о гораздо более легком и менее болезненном методе:</target>
        </trans-unit>
        <trans-unit id="b59f82b60de1a26b35593dc01675e5a909ba8a5f" translate="yes" xml:space="preserve">
          <source>I solved it by:</source>
          <target state="translated">Я разобрался с этим:</target>
        </trans-unit>
        <trans-unit id="2bc8f27b388abdf40501aac72fdc18de4a394cc6" translate="yes" xml:space="preserve">
          <source>I summarized other answers. You can execute &lt;code&gt;git pull&lt;/code&gt; without errors:</source>
          <target state="translated">Я суммировал другие ответы. Вы можете выполнить &lt;code&gt;git pull&lt;/code&gt; без ошибок:</target>
        </trans-unit>
        <trans-unit id="9e9c607f31072847a38c9b05a9259fd67e496517" translate="yes" xml:space="preserve">
          <source>I think this is the right way:</source>
          <target state="translated">Я думаю,это правильный путь:</target>
        </trans-unit>
        <trans-unit id="5d91bb70a6390c473190410afcd9036e5f327d4f" translate="yes" xml:space="preserve">
          <source>I tried a lot but finally got success with these commands.</source>
          <target state="translated">Я много пробовал,но в конце концов добился успеха с этими командами.</target>
        </trans-unit>
        <trans-unit id="ce04259de425930a4afb9a04ea73259e98934d7d" translate="yes" xml:space="preserve">
          <source>I'd advise doing the following:</source>
          <target state="translated">Я бы посоветовал сделать следующее:</target>
        </trans-unit>
        <trans-unit id="879f21df929422d62c19c054033c719da6cc86cc" translate="yes" xml:space="preserve">
          <source>I'm adding the images under the source control and pushing them to GitHub together with other changes</source>
          <target state="translated">Я добавляю изображения под управлением источника и проталкиваю их на GitHub вместе с другими изменениями.</target>
        </trans-unit>
        <trans-unit id="c0389297bccd119cc2155df40b7245a9b6d8ef46" translate="yes" xml:space="preserve">
          <source>If above won't help and you don't care about your untracked files/directories (make the backup first just in case), try the following simple steps:</source>
          <target state="translated">Если вышеизложенное не поможет,и вас не волнуют ваши неотслеживаемые каталоги файлов (сделайте резервную копию первой на всякий случай),попробуйте следующие простые шаги:</target>
        </trans-unit>
        <trans-unit id="e1164cfe9b4363ab446a620bf0fe7eb973b2d2fd" translate="yes" xml:space="preserve">
          <source>If that's the case, you've to commit these CRLF/LF changes (by reviewing them in &lt;code&gt;git status&lt;/code&gt;), or try: &lt;code&gt;git config core.autcrlf false&lt;/code&gt; to temporary ignore them.</source>
          <target state="translated">Если это так, вы должны зафиксировать эти изменения CRLF / LF (просмотрев их в &lt;code&gt;git status&lt;/code&gt; ) или попробуйте: &lt;code&gt;git config core.autcrlf false&lt;/code&gt; , чтобы временно игнорировать их.</target>
        </trans-unit>
        <trans-unit id="be99b3701dbfa1ea6069b28872598c9af0eaf225" translate="yes" xml:space="preserve">
          <source>If you have any files that are &lt;em&gt;not&lt;/em&gt; tracked by Git (e.g. uploaded user content), these files will not be affected.</source>
          <target state="translated">Если у вас есть файлы, которые &lt;em&gt;не&lt;/em&gt; отслеживаются Git (например, загруженный пользовательский контент), эти файлы не будут затронуты.</target>
        </trans-unit>
        <trans-unit id="0e7742626a2af9a263481a2ea42184887d357916" translate="yes" xml:space="preserve">
          <source>If you want to remove untracked directories in addition to untracked files:</source>
          <target state="translated">Если вы хотите удалить неотслеживаемые каталоги в дополнение к неотслеживаемым файлам:</target>
        </trans-unit>
        <trans-unit id="a180e327b58926ff442a586df94b1875f83ddd5f" translate="yes" xml:space="preserve">
          <source>Important: If you have any local changes, they will be lost. With or without &lt;code&gt;--hard&lt;/code&gt; option, any local commits that haven't been pushed will be lost.&lt;sup&gt;[*]&lt;/sup&gt;</source>
          <target state="translated">Важно: если у вас есть какие-либо локальные изменения, они будут потеряны. С параметром &lt;code&gt;--hard&lt;/code&gt; или без него все локальные коммиты, которые не были переданы, будут потеряны. &lt;sup&gt;[*]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="03fc06a673c3bef7b930cdf312a4a24d568ded9b" translate="yes" xml:space="preserve">
          <source>In speaking of pull/fetch/merge in the previous answers, I would like to share an interesting and productive trick,</source>
          <target state="translated">Говоря о pulfetchmerge в предыдущих ответах,я хотел бы поделиться интересным и продуктивным трюком,</target>
        </trans-unit>
        <trans-unit id="ad81e97b3a770037ed684784fde0a5c8ef87d732" translate="yes" xml:space="preserve">
          <source>Instead of doing:</source>
          <target state="translated">Вместо того,чтобы делать:</target>
        </trans-unit>
        <trans-unit id="dcb313addf8398324b6dbe730aabe7eb8934c8e2" translate="yes" xml:space="preserve">
          <source>Instead of merging with &lt;code&gt;git pull&lt;/code&gt;, try this:</source>
          <target state="translated">Вместо слияния с &lt;code&gt;git pull&lt;/code&gt; попробуйте это:</target>
        </trans-unit>
        <trans-unit id="2cd313911aabf555c754ba83cda398a218f8f5a4" translate="yes" xml:space="preserve">
          <source>It looks like the best way is to first do:</source>
          <target state="translated">Похоже,лучше всего сначала сделать это:</target>
        </trans-unit>
        <trans-unit id="0e06b597f22a2c59eaa962116cc249a03f1662a8" translate="yes" xml:space="preserve">
          <source>It seems like most answers here are focused on the &lt;code&gt;master&lt;/code&gt; branch; however, there are times when I'm working on the same feature branch in two different places and I want a rebase in one to be reflected in the other without a lot of jumping through hoops.</source>
          <target state="translated">Кажется, что большинство ответов здесь сосредоточены на &lt;code&gt;master&lt;/code&gt; ветке; однако бывают случаи, когда я работаю над одной и той же веткой функций в двух разных местах, и я хочу, чтобы ребаз в одном отражался в другом, не перепрыгивая через обручи.</target>
        </trans-unit>
        <trans-unit id="7d8089aa0bbee09dd16c70b9dd88c5b319c9169f" translate="yes" xml:space="preserve">
          <source>It should do what you want.</source>
          <target state="translated">Оно должно делать то,что ты хочешь.</target>
        </trans-unit>
        <trans-unit id="f9e5e58435cb3bab1134eff5bbfd984a13e46944" translate="yes" xml:space="preserve">
          <source>Just do</source>
          <target state="translated">Просто делай</target>
        </trans-unit>
        <trans-unit id="bac005d3d83ada4449ef9cc4568c9cab8c7db381" translate="yes" xml:space="preserve">
          <source>Later you can clean the stash history.</source>
          <target state="translated">Позже ты сможешь вычистить историю тайника.</target>
        </trans-unit>
        <trans-unit id="2ccb58cd1657aff4b8d5f6d44aa0ce72cd0f5cd5" translate="yes" xml:space="preserve">
          <source>Like Hedgehog I think the answers are terrible. But though Hedgehog's answer might be better, I don't think it is as elegant as it could be.  The way I found to do this is by using &quot;fetch&quot; and &quot;merge&quot; with a defined strategy. Which should make it so that your local changes are preserved as long as they are not one of the files that you are trying to force an overwrite with.</source>
          <target state="translated">Как Ежик,я думаю,что ответы ужасны.Но хотя ответ Ежика может быть лучше,я не думаю,что он настолько элегантен,насколько это возможно.Я нашел способ сделать это,используя &quot;принести&quot; и &quot;слиться&quot; с определенной стратегией.Что должно сделать так,чтобы ваши локальные изменения сохранялись до тех пор,пока они не являются одним из файлов,которые вы пытаетесь заставить перезаписать.</target>
        </trans-unit>
        <trans-unit id="57db7f84faa1518fd0d5c9bcdbb54d789e40298b" translate="yes" xml:space="preserve">
          <source>Local commits that are not on the remote branch need to be deleted as well. IMO the easiest way to achieve this is with: &lt;code&gt;git reset --hard origin/master&lt;/code&gt; (replace 'master' by whatever branch you are working on, and run a &lt;code&gt;git fetch origin&lt;/code&gt; first)</source>
          <target state="translated">Локальные коммиты, которые не находятся в удаленной ветке, также должны быть удалены. IMO самый простой способ добиться этого с помощью: &lt;code&gt;git reset --hard origin/master&lt;/code&gt; (замените 'master' на ту ветку, с которой вы работаете, и сначала запустите &lt;code&gt;git fetch origin&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="902b1994ebdb1a49c25d1e1bcdd7120a07310fa8" translate="yes" xml:space="preserve">
          <source>Local files that are untracked need to be deleted, either manually (safer) or as suggested in other answers, by &lt;code&gt;git clean -f -d&lt;/code&gt;</source>
          <target state="translated">Локальные файлы, которые не были отслежены, необходимо удалить вручную (безопаснее) или, как предлагается в других ответах, с помощью &lt;code&gt;git clean -f -d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ebf666caa78cad721786be145be564955ec4d13f" translate="yes" xml:space="preserve">
          <source>Maintain current local commits</source>
          <target state="translated">Поддержание текущих локальных обязательств</target>
        </trans-unit>
        <trans-unit id="27d3c0eecb54773d9a2bf6562cb66eb7114e4a4d" translate="yes" xml:space="preserve">
          <source>Make the local repository match the remote origin repository.</source>
          <target state="translated">Сделайте локальный репозиторий соответствующим репозиторию удаленного происхождения.</target>
        </trans-unit>
        <trans-unit id="c44115da474d910d5bd67d5010c093acb30dad91" translate="yes" xml:space="preserve">
          <source>Manually, one-by-one:</source>
          <target state="translated">Вручную,один за другим:</target>
        </trans-unit>
        <trans-unit id="1f9d21224178a8ed1cca77caf291eba184ae786b" translate="yes" xml:space="preserve">
          <source>No need to fetch all remotes and branches if you're going to reset to the origin/master branch right?</source>
          <target state="translated">Нет необходимости забирать все пульты и ветки,если вы собираетесь перезагрузить на ветку оригинала,правильно?</target>
        </trans-unit>
        <trans-unit id="36d03b9af07b5eaff018766e46d322d377dc6f23" translate="yes" xml:space="preserve">
          <source>Now it works.</source>
          <target state="translated">Теперь это работает.</target>
        </trans-unit>
        <trans-unit id="bf662c7bf7c1229391af4012d4ab4979da22561f" translate="yes" xml:space="preserve">
          <source>OR If you are on some other branch:</source>
          <target state="translated">ИЛИ если вы находитесь на каком-то другом филиале:</target>
        </trans-unit>
        <trans-unit id="33b6a45ba92ca30383f55274e41f4e14184846bf" translate="yes" xml:space="preserve">
          <source>Of course if you want to go back to what you stashed:</source>
          <target state="translated">Конечно,если ты хочешь вернуться к тому,что припрятал:</target>
        </trans-unit>
        <trans-unit id="11be4c8b5293489e43dade05c7b3663d51f1211e" translate="yes" xml:space="preserve">
          <source>Or, in your &lt;code&gt;.gitconfig&lt;/code&gt; file:</source>
          <target state="translated">Или в вашем файле &lt;code&gt;.gitconfig&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="42da08286231f6c3d657f652d649f572c9396d4c" translate="yes" xml:space="preserve">
          <source>Rather (git &amp;gt; v1.7.6):</source>
          <target state="translated">Скорее (git&amp;gt; v1.7.6):</target>
        </trans-unit>
        <trans-unit id="475ffa14014bb463965306813410e4afd01a7039" translate="yes" xml:space="preserve">
          <source>Requirements:</source>
          <target state="translated">Requirements:</target>
        </trans-unit>
        <trans-unit id="915317e7edd24055b8e04b2d411caa7b7533153c" translate="yes" xml:space="preserve">
          <source>Reset the index and the head to &lt;code&gt;origin/master&lt;/code&gt;, but do not reset the working tree:</source>
          <target state="translated">Сбросьте индекс и заголовок на &lt;code&gt;origin/master&lt;/code&gt; , но не сбрасывайте рабочее дерево:</target>
        </trans-unit>
        <trans-unit id="9ab708d6bf11eb7eae1427bfc4104732844213b0" translate="yes" xml:space="preserve">
          <source>Run this from a branch and it'll only reset your local branch to the upstream version.</source>
          <target state="translated">Запустите его из ветки,и он сбросит вашу локальную версию ветки только на восходящую.</target>
        </trans-unit>
        <trans-unit id="807398f22444dcc53d6db811aebb6cd9cc2291af" translate="yes" xml:space="preserve">
          <source>So you avoid all unwanted side effects, like deleting files or directories you wanted to keep, etc.</source>
          <target state="translated">Таким образом,вы избегаете всех нежелательных побочных эффектов,таких как удаление файлов или каталогов,которые вы хотели бы сохранить,и т.д.</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="9587d887b8a5d76ff8f5b3ca6941e7eae087b881" translate="yes" xml:space="preserve">
          <source>Some answers seem to be terrible. Terrible in the sense of what happened to @Lauri by following David Avsajanishvili suggestion.</source>
          <target state="translated">Некоторые ответы кажутся ужасными.Ужасно в смысле того,что случилось с @Lauri,следуя предложению Давида Авсаджанишвили.</target>
        </trans-unit>
        <trans-unit id="0d28dcfeeae68b49b63a4e472f2f8328b5fdd4e3" translate="yes" xml:space="preserve">
          <source>Sometimes just &lt;code&gt;clean -f&lt;/code&gt; does not help. In case you have untracked DIRECTORIES, -d option also needed:</source>
          <target state="translated">Иногда просто &lt;code&gt;clean -f&lt;/code&gt; не помогает. Если у вас нет отслеживаемых каталогов, опция -d также необходима:</target>
        </trans-unit>
        <trans-unit id="8631c9b28f153fae2e2fef4e1316c5b69bbe8cfd" translate="yes" xml:space="preserve">
          <source>That in mind, I updated Kustudic's script to do just that.  I also fixed a typo (a missing ' in the original).</source>
          <target state="translated">Учитывая это,я обновил сценарий Кустудича,чтобы сделать именно это.Я также исправил опечатку (отсутствующую в оригинале).</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">Вот так!</target>
        </trans-unit>
        <trans-unit id="25600d3a9892efcd21d9b4cfc94b0ab9748ed9b2" translate="yes" xml:space="preserve">
          <source>The first command fetches newest data.</source>
          <target state="translated">Первая команда получает новейшие данные.</target>
        </trans-unit>
        <trans-unit id="253df425511692a7988571c26edb1c772b59d386" translate="yes" xml:space="preserve">
          <source>The following version commits your local changes to a temporary branch (&lt;code&gt;tmp&lt;/code&gt;), checks out the original branch (which I'm assuming is &lt;code&gt;master&lt;/code&gt;) and merges the updates. You could do this with &lt;code&gt;stash&lt;/code&gt;, but I've found it's usually easier to simply use the branch / merge approach.</source>
          <target state="translated">Следующая версия фиксирует ваши локальные изменения во временной ветке ( &lt;code&gt;tmp&lt;/code&gt; ), проверяет исходную ветку (я предполагаю, что это &lt;code&gt;master&lt;/code&gt; ) и объединяет обновления. Вы можете сделать это с помощью &lt;code&gt;stash&lt;/code&gt; , но я обнаружил, что обычно проще использовать подход ветвления / слияния.</target>
        </trans-unit>
        <trans-unit id="6bde0e00397fa4ee9171ff863ee7e069991bf8f0" translate="yes" xml:space="preserve">
          <source>The only thing that worked for me was:</source>
          <target state="translated">Единственное,что работало на меня:</target>
        </trans-unit>
        <trans-unit id="b8d26d09bd803d962c0ffdc7865ca8eded89d169" translate="yes" xml:space="preserve">
          <source>The problem with all these solutions is that they are all either too complex, or, an even bigger problem, is that they remove all untracked files from the web server, which we don't want since there are always needed configuration files which are on the server and not in the Git repository.</source>
          <target state="translated">Проблема всех этих решений заключается в том,что они либо слишком сложны,либо,что ещё более важно,они удаляют все неотслеживаемые файлы с веб-сервера,чего мы не хотим,так как всегда есть нужные конфигурационные файлы,которые находятся на сервере,а не в Git-репозитории.</target>
        </trans-unit>
        <trans-unit id="c3c10cc0d5a31ff5783080c9bd9635741b253fc8" translate="yes" xml:space="preserve">
          <source>The second command checks if there are any files which are being added to the repository and deletes those untracked files from the local repository which would cause conflicts.</source>
          <target state="translated">Вторая команда проверяет наличие файлов,которые добавляются в репозиторий,и удаляет эти неотслеживаемые файлы из локального репозитория,что может привести к конфликтам.</target>
        </trans-unit>
        <trans-unit id="678000075b4d6cd38269dac48c4b8d87c1fca462" translate="yes" xml:space="preserve">
          <source>The third command checks-out all the files which were locally modified.</source>
          <target state="translated">Третья команда проверяет все файлы,которые были локально изменены.</target>
        </trans-unit>
        <trans-unit id="21267f318079f6774b177821837cc891b20ba5c7" translate="yes" xml:space="preserve">
          <source>Then I am able to pull just fine.</source>
          <target state="translated">Тогда я смогу отлично потянуть.</target>
        </trans-unit>
        <trans-unit id="5f21d45c01e403eb57b1b5827ca4047a372a4082" translate="yes" xml:space="preserve">
          <source>Then fetch the changes and overwrite if there is a conflict</source>
          <target state="translated">Тогда принеси изменения и перезапиши,если есть конфликт.</target>
        </trans-unit>
        <trans-unit id="c676bc4481885bfedae0258dc14ccea8e8999c8a" translate="yes" xml:space="preserve">
          <source>Then pull it again.</source>
          <target state="translated">Тогда потяни еще раз.</target>
        </trans-unit>
        <trans-unit id="ee4ca7fba794f3af9d4fb46b93e0453c258d261c" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;git reset&lt;/code&gt; resets the master branch to what you just fetched. The &lt;code&gt;--hard&lt;/code&gt; option changes all the files in your working tree to match the files in &lt;code&gt;origin/master&lt;/code&gt;</source>
          <target state="translated">Затем &lt;code&gt;git reset&lt;/code&gt; сбрасывает основную ветку к тому, что вы только что получили. Опция &lt;code&gt;--hard&lt;/code&gt; изменяет все файлы в вашем рабочем дереве в соответствии с файлами в &lt;code&gt;origin/master&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d81ef5f48f166e14f75ad40236c0c9df9e4a75e1" translate="yes" xml:space="preserve">
          <source>Then, you have two options:</source>
          <target state="translated">Тогда у тебя есть два варианта:</target>
        </trans-unit>
        <trans-unit id="7798b87989a4d7b4641302aaed49212a7fe8c801" translate="yes" xml:space="preserve">
          <source>These four commands work for me.</source>
          <target state="translated">Эти четыре команды работают на меня.</target>
        </trans-unit>
        <trans-unit id="ff127378bb08dc1448022a9641654c494f565c1d" translate="yes" xml:space="preserve">
          <source>They are adding some images to the images directory (but forgets to add them under source control)</source>
          <target state="translated">Они добавляют некоторые изображения в каталог изображений (но забывают добавлять их под контролем источника).</target>
        </trans-unit>
        <trans-unit id="03b8bbdb6eb2cf69f8cb249139cd7ce228faaecf" translate="yes" xml:space="preserve">
          <source>They are sending the images by mail, later, to me</source>
          <target state="translated">Они посылают изображения по почте,позже,ко мне.</target>
        </trans-unit>
        <trans-unit id="7cd7a4110beebad617002342d669e523a4966903" translate="yes" xml:space="preserve">
          <source>They cannot pull updates from GitHub because Git doesn't want to overwrite their files.</source>
          <target state="translated">Они не могут вытаскивать обновления из GitHub'а,потому что Git не хочет перезаписывать их файлы.</target>
        </trans-unit>
        <trans-unit id="0c0bc2340a056214e8100c82b907cb176343ebc8" translate="yes" xml:space="preserve">
          <source>This above command is the most useful command in my Git life which saved a lot of time.</source>
          <target state="translated">Эта вышеприведённая команда-самая полезная в жизни Git'а,которая сэкономила много времени.</target>
        </trans-unit>
        <trans-unit id="2e784adb16c7ed518925195e69f1ed074a41fa47" translate="yes" xml:space="preserve">
          <source>This can be nicely put into a git alias (&lt;code&gt;git forcepull&lt;/code&gt;) as well:</source>
          <target state="translated">Это также можно добавить в псевдоним &lt;code&gt;git forcepull&lt;/code&gt; ( git forcepull ):</target>
        </trans-unit>
        <trans-unit id="7fa72933f59b96fd34b4e375dec6861fc0377acd" translate="yes" xml:space="preserve">
          <source>This will REMOVE all git files (excempt &lt;code&gt;.git/&lt;/code&gt; dir, where you have all commits) and pull it again.</source>
          <target state="translated">Это удалит все файлы git (за исключением &lt;code&gt;.git/&lt;/code&gt; dir, где у вас есть все коммиты) и извлечет его снова.</target>
        </trans-unit>
        <trans-unit id="1913d306d1a42c1564720a4d705c73b9650593f6" translate="yes" xml:space="preserve">
          <source>This will override your local file with the file on git</source>
          <target state="translated">Это переопределит ваш локальный файл с файлом на git.</target>
        </trans-unit>
        <trans-unit id="947b34a00d726c657b12cdbaccdf65e09fd25d8d" translate="yes" xml:space="preserve">
          <source>This will take you back five commits and then with</source>
          <target state="translated">Это вернёт тебе пять обязательств,а затем с</target>
        </trans-unit>
        <trans-unit id="01731cd723b90256eccc7d0a8072853bf68d619c" translate="yes" xml:space="preserve">
          <source>To check/pull after executing these commands</source>
          <target state="translated">Чтобы checkpull после выполнения этих команд</target>
        </trans-unit>
        <trans-unit id="792990822a55aacc5ab96839f6879d0ab135b670" translate="yes" xml:space="preserve">
          <source>To delete all untracked files and then continue with the usual &lt;code&gt;git pull&lt;/code&gt;...</source>
          <target state="translated">Чтобы удалить все неотслеживаемые файлы, а затем продолжить с обычным &lt;code&gt;git pull&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="2e97c37f66bbb352cb86c890973bbee6dd9264e4" translate="yes" xml:space="preserve">
          <source>Track local changes so no-one here ever loses them.</source>
          <target state="translated">Отслеживайте местные изменения,чтобы никто здесь их не терял.</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">Попробуй это:</target>
        </trans-unit>
        <trans-unit id="79d1acaccc53be854e44cb88d8a731ca26725f61" translate="yes" xml:space="preserve">
          <source>Uncommitted changes</source>
          <target state="translated">Нефиксированные изменения</target>
        </trans-unit>
        <trans-unit id="35d60c13f1637f01f05b6c59bfb6bb4fbae9aac4" translate="yes" xml:space="preserve">
          <source>Uncommitted changes, however (even staged), will be lost. Make sure to stash and commit anything you need. For that you can run the following:</source>
          <target state="translated">Нефиксированные изменения,однако (даже инсценированные),будут потеряны.Убедитесь,что вы спрятали и зафиксировали все,что вам нужно.Для этого вы можете запустить следующее:</target>
        </trans-unit>
        <trans-unit id="a04a85b4f229d1ba1c004f1d7dfc9dad4ba95354" translate="yes" xml:space="preserve">
          <source>When you're using file-system which doesn't support permission attributes.
In example you have two repositories, one on Linux/Mac (&lt;code&gt;ext3&lt;/code&gt;/&lt;code&gt;hfs+&lt;/code&gt;) and another one on FAT32/NTFS based file-system.</source>
          <target state="translated">Когда вы используете файловую систему, которая не поддерживает атрибуты разрешений. Например, у вас есть два репозитория, один для Linux / Mac ( &lt;code&gt;ext3&lt;/code&gt; / &lt;code&gt;hfs+&lt;/code&gt; ) и другой для файловой системы на основе FAT32 / NTFS.</target>
        </trans-unit>
        <trans-unit id="b59d9f65f3bfd048d61e29b69d244223b5fd2b4d" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;git reset HEAD --hard&lt;/code&gt; could fail in some cases?</source>
          <target state="translated">Почему &lt;code&gt;git reset HEAD --hard&lt;/code&gt; может не работать в некоторых случаях?</target>
        </trans-unit>
        <trans-unit id="e676bf6f98187f56702c31f2b2f0568c7e63be07" translate="yes" xml:space="preserve">
          <source>You might find this command helpful to throw away local changes:</source>
          <target state="translated">Эта команда может оказаться полезной для выброса локальных изменений:</target>
        </trans-unit>
        <trans-unit id="6f68fbd4c89d37bb92c0eccd976bc907b757552a" translate="yes" xml:space="preserve">
          <source>error: Untracked working tree file 'public/images/icon.gif' would be overwritten by merge</source>
          <target state="translated">ошибка:Неопознанный файл рабочего дерева 'publicimagesicon.gif' будет перезаписан при слиянии.</target>
        </trans-unit>
        <trans-unit id="9351bd81e6470b3b0902ff748b289a7935609351" translate="yes" xml:space="preserve">
          <source>followed by:</source>
          <target state="translated">за ним:</target>
        </trans-unit>
        <trans-unit id="ddea56ff50be6923b4fcf019f86bdb93636ef9b3" translate="yes" xml:space="preserve">
          <source>where the last command gives a list of what your local changes were. Keep modifying the &quot;tmp&quot; branch until it is acceptable and then merge back onto master with:</source>
          <target state="translated">где последняя команда дает список ваших локальных изменений.Продолжайте модифицировать ветку &quot;tmp&quot; до тех пор,пока она не станет приемлемой,а затем снова слияние с ведущим:</target>
        </trans-unit>
        <trans-unit id="016dc548ba6ea5dc4ca066fa1aaacbe2d5292693" translate="yes" xml:space="preserve">
          <source>where we assume the &lt;strong&gt;other repository&lt;/strong&gt; is &lt;code&gt;origin master&lt;/code&gt;.</source>
          <target state="translated">где мы предполагаем, что &lt;strong&gt;другой репозиторий&lt;/strong&gt; является &lt;code&gt;origin master&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
