<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1125968">
    <body>
      <group id="1125968">
        <trans-unit id="5afb90bc1680715416282876077bc225842cbc96" translate="yes" xml:space="preserve">
          <source>&quot;-X&quot; is an option name, and &quot;theirs&quot; is the value for that option. You're choosing to use &quot;their&quot; changes, instead of &quot;your&quot; changes if there is a conflict.</source>
          <target state="translated">&quot;-X &quot;是一个选项名称,&quot;他们的 &quot;是该选项的值。你选择使用 &quot;他们的 &quot;更改,而不是 &quot;你的 &quot;更改,如果有冲突的话,就用 &quot;他们的 &quot;更改。</target>
        </trans-unit>
        <trans-unit id="70ecf3b9a626c0d63016862459beb96a7cd9fd04" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git fetch&lt;/code&gt; downloads the latest from remote without trying to merge or rebase anything.</source>
          <target state="translated">&lt;code&gt;git fetch&lt;/code&gt; 从远程下载最新版本，而无需尝试合并或重新设置任何内容。</target>
        </trans-unit>
        <trans-unit id="bc940fd283a79b9e47237dc19b00c61dd5539710" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset --hard origin/master&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git reset --hard origin/master&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="8b77648ec75a644255f4be7f9dd3cb5598cd48b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;git pull --rebase&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;git pull --rebase&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6f4dc4e310800c0b0a13a28965d7a56a3b773f32" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Fetch&lt;/strong&gt; with a &lt;strong&gt;clean&lt;/strong&gt; of &lt;strong&gt;files&lt;/strong&gt; and &lt;strong&gt;directories&lt;/strong&gt; ignoring &lt;strong&gt;.gitignore&lt;/strong&gt; and &lt;strong&gt;hard reset&lt;/strong&gt; to &lt;strong&gt;origin&lt;/strong&gt;.</source>
          <target state="translated">使用&lt;strong&gt;干净&lt;/strong&gt;的&lt;strong&gt;文件&lt;/strong&gt;和&lt;strong&gt;目录来&lt;/strong&gt;忽略&lt;strong&gt;.gitignore&lt;/strong&gt;并&lt;strong&gt;硬重置&lt;/strong&gt;为&lt;strong&gt;origin&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="6031888574223bffc84d9cd8bf2d9a79f815c173" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Stash&lt;/strong&gt; the local changes.</source>
          <target state="translated">&lt;strong&gt;隐藏&lt;/strong&gt;本地更改。</target>
        </trans-unit>
        <trans-unit id="dcc197827149be97581e309fb6dce7a656af78bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The scenario is the following:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;该方案如下：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e3c42a8134f0739a17a678e3e0dcb0771efa7cdb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;This is the error I'm getting:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这是我得到的错误：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f4a7132acfa00c3c71261b610b730a413f758186" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING: &lt;code&gt;git clean&lt;/code&gt; deletes all your untracked files/directories and can't be undone.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;警告： &lt;code&gt;git clean&lt;/code&gt; 会删除所有未跟踪的文件/目录，并且无法撤消。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="967b8bcb08e168bba241f9faffbb234be29aee97" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning, doing this will permanently delete your files if you have any directory/* entries in your gitignore file.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;警告，如果您在gitignore文件中有任何目录/ *条目，这样做将永久删除您的文件。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8c62d7e7d52d9e8d8a3e0ab4fcbe742a08c5a51f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning&lt;/strong&gt;: This script is very powerful, so you could lose your changes.</source>
          <target state="translated">&lt;strong&gt;警告&lt;/strong&gt; ：此脚本非常强大，因此您可能会丢失所做的更改。</target>
        </trans-unit>
        <trans-unit id="6c5e0c503728653826db9fcefc33c40057e4a0cf" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;&lt;strong&gt;Warning&lt;/strong&gt;: Above commands can results in data/files loss only if you don't have them committed! If you're not sure, make the backup first of your whole repository folder.&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;strong&gt;警告&lt;/strong&gt; ：仅当您未提交上述命令时，它们才会导致数据/文件丢失！&lt;/sup&gt; &lt;sup&gt;如果不确定，请首先备份整个存储库文件夹。&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="1ed6e68c2afe2cc46a2ddfb7b88e004a4df0bc59" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;[*]&lt;/sup&gt;: It's worth noting that it is possible to maintain current local commits by creating a branch from &lt;code&gt;master&lt;/code&gt; before resetting:</source>
          <target state="translated">&lt;sup&gt;[*]&lt;/sup&gt; ：值得注意的是，可以通过在重置之前从 &lt;code&gt;master&lt;/code&gt; 创建分支来维护当前的本地提交：</target>
        </trans-unit>
        <trans-unit id="36038a15055095eee9da18058a5e2c67e12a05ad" translate="yes" xml:space="preserve">
          <source>A team member is modifying the templates for a website we are working on</source>
          <target state="translated">一名团队成员正在为我们正在开发的一个网站修改模板。</target>
        </trans-unit>
        <trans-unit id="a180c1f257cadb94780423f139159de8269da2c0" translate="yes" xml:space="preserve">
          <source>After this, all of the old commits will be kept in &lt;code&gt;new-branch-to-save-current-commits&lt;/code&gt;.</source>
          <target state="translated">此后，所有旧提交将保存在 &lt;code&gt;new-branch-to-save-current-commits&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="36c034e52a3013a7eb18bd0e736106a3162dc9b7" translate="yes" xml:space="preserve">
          <source>An easier way would be to:</source>
          <target state="translated">一个简单的方法是:</target>
        </trans-unit>
        <trans-unit id="a7eccdc85e1d8fab375e2e045e94fc4580337ef4" translate="yes" xml:space="preserve">
          <source>And then do a cleanup (removes untracked files from the working tree):</source>
          <target state="translated">然后做一个清理(从工作树中删除未被跟踪的文件)。</target>
        </trans-unit>
        <trans-unit id="78daf6f4dc00ac5359931b14a322206862bd8d53" translate="yes" xml:space="preserve">
          <source>And then to reapply these uncommitted changes:</source>
          <target state="translated">然后再把这些没有承诺的改变重新应用。</target>
        </trans-unit>
        <trans-unit id="3dbb2aa68555e791ab4d7fde77f19d2a5b2a8a25" translate="yes" xml:space="preserve">
          <source>As you notice, there are two different kind of file systems, so the one which doesn't support Unix permissions basically can't reset file permissions on system which doesn't support that kind of permissions, so no matter how &lt;code&gt;--hard&lt;/code&gt; you try, git always detect some &quot;changes&quot;.</source>
          <target state="translated">如您所见，有两种不同类型的文件系统，因此，一种不支持Unix权限的文件系统基本上无法在不支持这种权限的系统上重置文件权限，因此无论您如何努力，尝试一下，git总是检测到一些&amp;ldquo;变化&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="176ed3df07c6cab12f3824cd3af53a19fe5a4ac5" translate="yes" xml:space="preserve">
          <source>Based on a combination of &lt;a href=&quot;https://stackoverflow.com/a/8888015/1103543&quot;&gt;RNA's answer&lt;/a&gt; and &lt;a href=&quot;https://stackoverflow.com/a/19961461/1103543&quot;&gt;torek's answer to a similar question&lt;/a&gt;, I've come up with this which works splendidly:</source>
          <target state="translated">基于&lt;a href=&quot;https://stackoverflow.com/a/8888015/1103543&quot;&gt;RNA的答案&lt;/a&gt;和&lt;a href=&quot;https://stackoverflow.com/a/19961461/1103543&quot;&gt;torek的类似问题&lt;/a&gt; 的答案的结合，我提出了一个出色的方法：</target>
        </trans-unit>
        <trans-unit id="5c86cd4334fa80da1de659e41c3792751d28a710" translate="yes" xml:space="preserve">
          <source>Based on my own similar experiences, the solution offered by Strahinja Kustudic above is by far the best.  As others have pointed out, simply doing hard reset will remove &lt;strong&gt;all&lt;/strong&gt; the untracked files which could include lots of things that you don't want removed, such as config files.  What is safer, is to remove only the files that are about to be added, and for that matter, you'd likely also want to checkout any locally-modified files that are about to be updated.</source>
          <target state="translated">根据我自己的类似经验，上述Strahinja Kustudic提供的解决方案是迄今为止最好的。 正如其他人指出的那样，仅执行硬重置将删除&lt;strong&gt;所有&lt;/strong&gt;未跟踪的文件，这些文件可能包含许多您不想删除的内容，例如配置文件。 更为安全的是仅删除将要添加的文件，因此，您可能还希望检出将要更新的所有本地修改的文件。</target>
        </trans-unit>
        <trans-unit id="66fd03594a2c157f1cc4300404f810b1d6f6ef22" translate="yes" xml:space="preserve">
          <source>Before pushing your newly commit to server, try this command and it will automatically synchronise the latest server changes (with a fetch + merge) and will place your commit at the top in the Git log. There isn't any need to worry about manual pull/merge.</source>
          <target state="translated">在将新提交推送到服务器上之前,请尝试一下这个命令,它将自动同步服务器上的最新修改(带取+合并),并将您的提交放在 Git 日志的最上面。不需要担心手动pullmerge。</target>
        </trans-unit>
        <trans-unit id="5763578555f814c96231de97e5710d397db26670" translate="yes" xml:space="preserve">
          <source>Bonus:</source>
          <target state="translated">Bonus:</target>
        </trans-unit>
        <trans-unit id="3c246aca15204187cf5403a724bf7c4ed1f89f75" translate="yes" xml:space="preserve">
          <source>Brutally, all-at-once:</source>
          <target state="translated">粗暴地,一气呵成。</target>
        </trans-unit>
        <trans-unit id="0f3d70d10152b31329fca6d57c58dd5a7548905c" translate="yes" xml:space="preserve">
          <source>Consider using &lt;code&gt;-n&lt;/code&gt; (&lt;code&gt;--dry-run&lt;/code&gt;) flag first. This will show you what will be deleted without actually deleting anything:</source>
          <target state="translated">考虑先使用 &lt;code&gt;-n&lt;/code&gt; （-- &lt;code&gt;--dry-run&lt;/code&gt; ）标志。 这将向您显示在不实际删除任何内容的情况下将删除的内容：</target>
        </trans-unit>
        <trans-unit id="27a5712e08f3ae4b6c16fa9dbe1f57b88d828e9d" translate="yes" xml:space="preserve">
          <source>Custom rules in &lt;code&gt;.gitattributes file&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.gitattributes file&lt;/code&gt; 自定义规则</target>
        </trans-unit>
        <trans-unit id="5969bf1b4e4687ca1fb9f6fc009150bef42d135f" translate="yes" xml:space="preserve">
          <source>Delete all the files. Leave just the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">删除所有文件。 仅保留 &lt;code&gt;.git&lt;/code&gt; 目录。</target>
        </trans-unit>
        <trans-unit id="1ac1711535c3631326eb072df130168ba61081aa" translate="yes" xml:space="preserve">
          <source>Despite the original question, the top answers can cause problems for people who have a similar problem, but don't want to lose their local files. For example, see Al-Punk and crizCraig's comments.</source>
          <target state="translated">尽管有原问题,但对于有类似问题的人来说,上面的答案会给他们带来麻烦,但又不想丢失本地文件。例如,请看Al-Punk和crizCraig的评论。</target>
        </trans-unit>
        <trans-unit id="f5169c84497de3aea74f7da9e7e177d1427e736b" translate="yes" xml:space="preserve">
          <source>Enjoy!</source>
          <target state="translated">Enjoy!</target>
        </trans-unit>
        <trans-unit id="2e4ccc244461fd2a12825ef96a60da2329e2ce3c" translate="yes" xml:space="preserve">
          <source>Example output:</source>
          <target state="translated">输出示例:</target>
        </trans-unit>
        <trans-unit id="844a18267f7570ccd804466117309648571134db" translate="yes" xml:space="preserve">
          <source>Explanation:</source>
          <target state="translated">Explanation:</target>
        </trans-unit>
        <trans-unit id="633b8ed4341c493911bcdea67fbf3a7e52e105ed" translate="yes" xml:space="preserve">
          <source>File system incompability</source>
          <target state="translated">文件系统的不适应性</target>
        </trans-unit>
        <trans-unit id="ac51316d6159411acf5b3f583c8d9c8a8d26ccdc" translate="yes" xml:space="preserve">
          <source>Finally we do a pull to update to the newest version, but this time without any conflicts, since untracked files which are in the repo don't exist anymore and all the locally modified files are already the same as in the repository.</source>
          <target state="translated">最后我们做一个拉动更新到最新版本,但这一次没有任何冲突,因为在repo中未被跟踪的文件已经不存在了,所有本地修改过的文件都已经和版本库中的一样。</target>
        </trans-unit>
        <trans-unit id="733954012af2f88caae800ae8ecbbdd4f2b12025" translate="yes" xml:space="preserve">
          <source>Find details in &lt;em&gt;&lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;What does &quot;git pull --rebase&quot; do?&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">在&lt;em&gt;&lt;a href=&quot;http://gitolite.com/git-pull--rebase&quot;&gt;&amp;ldquo; git pull --rebase&amp;rdquo;做什么中&lt;/a&gt;&lt;/em&gt;找到详细信息&lt;em&gt;？&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="6dc0d8358e432ef94381d4e39acde5f09ef69da0" translate="yes" xml:space="preserve">
          <source>First do a commit of your changes</source>
          <target state="translated">首先对你的更改做一个提交</target>
        </trans-unit>
        <trans-unit id="b3e145b7648ef683eaac2a7805b4e4b762bbad1f" translate="yes" xml:space="preserve">
          <source>First of all, try the standard way:</source>
          <target state="translated">首先,尝试标准的方式。</target>
        </trans-unit>
        <trans-unit id="e91bc256ad13d894ea5b4b99e3446667f554a6a2" translate="yes" xml:space="preserve">
          <source>For next time, you can probably handle this in a cleaner way by looking up &quot;git stash branch&quot; though stash is likely to cause you trouble on the first few tries, so do first experiment on a non-critical project...</source>
          <target state="translated">下次,你也许可以通过查找 &quot;git stash分支 &quot;来处理这个问题,虽然stash很可能在第一次尝试时给你带来麻烦,所以先在非关键项目上做实验。</target>
        </trans-unit>
        <trans-unit id="c89f6341c557881ef5a26399ed1653fe3ebdf78e" translate="yes" xml:space="preserve">
          <source>Having &lt;code&gt;eol=lf&lt;/code&gt; rule in .gitattributes could cause git to modify some file changes by converting CRLF line-endings into LF in some text files.</source>
          <target state="translated">在.gitattributes中使用 &lt;code&gt;eol=lf&lt;/code&gt; 规则可能会导致git通过将某些文本文件中的CRLF行尾转换为LF来修改某些文件更改。</target>
        </trans-unit>
        <trans-unit id="93154f89378492cd0c83e1aab6e6159f0de9d7ea" translate="yes" xml:space="preserve">
          <source>Here is the cleanest solution which we are using:</source>
          <target state="translated">以下是我们正在使用的最干净的解决方案。</target>
        </trans-unit>
        <trans-unit id="1f637bf42e756c960767eb126fdd9d9bebbd7a74" translate="yes" xml:space="preserve">
          <source>How do I force Git to overwrite them? The person is a designer - usually, I resolve all the conflicts by hand, so the server has the most recent version that they just need to update on their computer.</source>
          <target state="translated">如何强制Git覆盖他们?这个人是个设计师--通常情况下,我用手解决所有的冲突,所以服务器上有最新的版本,他们只需要在电脑上更新就可以了。</target>
        </trans-unit>
        <trans-unit id="e3a2f47cc14d50df3baa2c14a0ddf658114561df" translate="yes" xml:space="preserve">
          <source>How do I force an overwrite of local files on a &lt;code&gt;git pull&lt;/code&gt;?</source>
          <target state="translated">如何在 &lt;code&gt;git pull&lt;/code&gt; 上强制覆盖本地文件？</target>
        </trans-unit>
        <trans-unit id="022b126cf5d96f5acd5353613e02e8e093951fcf" translate="yes" xml:space="preserve">
          <source>How do I force “git pull” to overwrite local files</source>
          <target state="translated">如何强制 &quot;git pull &quot;覆盖本地文件?</target>
        </trans-unit>
        <trans-unit id="dea1758cfb7d54073565d160ed1da9d3735d7d43" translate="yes" xml:space="preserve">
          <source>I believe there are two possible causes of conflict, which must be solved separately, and as far as I can tell none of the above answers deals with both:</source>
          <target state="translated">我相信有两个可能的冲突原因,必须分别解决,据我所知,上述答案都没有涉及到这两个问题。</target>
        </trans-unit>
        <trans-unit id="9d39e53821ce6f629f48322aff08f227653eb992" translate="yes" xml:space="preserve">
          <source>I found that by looking up &lt;a href=&quot;https://stackoverflow.com/questions/2389361/git-undo-a-merge&quot;&gt;how to undo a Git merge&lt;/a&gt;.</source>
          <target state="translated">通过查找&lt;a href=&quot;https://stackoverflow.com/questions/2389361/git-undo-a-merge&quot;&gt;如何撤消Git合并&lt;/a&gt; ，我发现了这一点。</target>
        </trans-unit>
        <trans-unit id="95f170181b4a919a57346c13c88eae271970ecf3" translate="yes" xml:space="preserve">
          <source>I had a similar problem.  I had to do this:</source>
          <target state="translated">我也遇到过类似的问题。我不得不这样做。</target>
        </trans-unit>
        <trans-unit id="8628e6103828b4e62119bb52d8a10ca6f0446469" translate="yes" xml:space="preserve">
          <source>I had the same problem and for some reason, even a &lt;code&gt;git clean -f -d&lt;/code&gt; would not do it. Here is why: For some reason, if your file is ignored by Git (via a .gitignore entry, I assume), it still bothers about overwriting this with a later &lt;em&gt;pull&lt;/em&gt;, but a &lt;em&gt;clean&lt;/em&gt; will not remove it, unless you add &lt;code&gt;-x&lt;/code&gt;.</source>
          <target state="translated">我遇到了同样的问题，由于某种原因，即使是 &lt;code&gt;git clean -f -d&lt;/code&gt; 也不会这样做。 这是为什么：由于某种原因，如果您的文件被Git忽略（我认为是通过.gitignore条目），它仍然会为以后的&lt;em&gt;pull&lt;/em&gt;重写而烦恼，但是除非您添加 &lt;code&gt;-x&lt;/code&gt; ，否则&lt;em&gt;干净&lt;/em&gt;不会删除它。</target>
        </trans-unit>
        <trans-unit id="cfc7e1dda03c9f91868de6432e4c926b6660c9cf" translate="yes" xml:space="preserve">
          <source>I had the same problem. No one gave me this solution, but it worked for me.</source>
          <target state="translated">我也有同样的问题。没有人给我这个办法,但它对我很有效。</target>
        </trans-unit>
        <trans-unit id="649a0254690bae34aa046e5cb6817593ddfefee6" translate="yes" xml:space="preserve">
          <source>I have a strange situation that neither &lt;code&gt;git clean&lt;/code&gt; or &lt;code&gt;git reset&lt;/code&gt; works. I have to remove the conflicting file from &lt;code&gt;git index&lt;/code&gt; by using the following script on every untracked file:</source>
          <target state="translated">我有一个奇怪的情况，无论是 &lt;code&gt;git clean&lt;/code&gt; 还是 &lt;code&gt;git reset&lt;/code&gt; 都不起作用 。 我必须通过在每个未跟踪的文件上使用以下脚本从 &lt;code&gt;git index&lt;/code&gt; 删除冲突的文件：</target>
        </trans-unit>
        <trans-unit id="7e8500eb1046100f489050b284eb5714559dccd2" translate="yes" xml:space="preserve">
          <source>I just solved this myself by:</source>
          <target state="translated">我只是自己解决了这个问题。</target>
        </trans-unit>
        <trans-unit id="128a6bbe4bbca0ef46a7429b3fb884d19161c0cc" translate="yes" xml:space="preserve">
          <source>I know of a much easier and less painful method:</source>
          <target state="translated">我知道有一个更简单、更少痛苦的方法。</target>
        </trans-unit>
        <trans-unit id="b59f82b60de1a26b35593dc01675e5a909ba8a5f" translate="yes" xml:space="preserve">
          <source>I solved it by:</source>
          <target state="translated">我解决了它。</target>
        </trans-unit>
        <trans-unit id="2bc8f27b388abdf40501aac72fdc18de4a394cc6" translate="yes" xml:space="preserve">
          <source>I summarized other answers. You can execute &lt;code&gt;git pull&lt;/code&gt; without errors:</source>
          <target state="translated">我总结了其他答案。 您可以执行 &lt;code&gt;git pull&lt;/code&gt; 而不会出现错误：</target>
        </trans-unit>
        <trans-unit id="9e9c607f31072847a38c9b05a9259fd67e496517" translate="yes" xml:space="preserve">
          <source>I think this is the right way:</source>
          <target state="translated">我认为这才是正确的方法。</target>
        </trans-unit>
        <trans-unit id="5d91bb70a6390c473190410afcd9036e5f327d4f" translate="yes" xml:space="preserve">
          <source>I tried a lot but finally got success with these commands.</source>
          <target state="translated">我尝试了很多,但终于用这些命令成功了。</target>
        </trans-unit>
        <trans-unit id="ce04259de425930a4afb9a04ea73259e98934d7d" translate="yes" xml:space="preserve">
          <source>I'd advise doing the following:</source>
          <target state="translated">我建议做以下几点。</target>
        </trans-unit>
        <trans-unit id="879f21df929422d62c19c054033c719da6cc86cc" translate="yes" xml:space="preserve">
          <source>I'm adding the images under the source control and pushing them to GitHub together with other changes</source>
          <target state="translated">我将在源码控制下添加图片,并将其与其他修改一起推送到GitHub上。</target>
        </trans-unit>
        <trans-unit id="c0389297bccd119cc2155df40b7245a9b6d8ef46" translate="yes" xml:space="preserve">
          <source>If above won't help and you don't care about your untracked files/directories (make the backup first just in case), try the following simple steps:</source>
          <target state="translated">如果上面的步骤对你没有帮助,而且你也不关心你的未被跟踪的文件目录(先做备份,以防万一),请尝试以下简单的步骤。</target>
        </trans-unit>
        <trans-unit id="e1164cfe9b4363ab446a620bf0fe7eb973b2d2fd" translate="yes" xml:space="preserve">
          <source>If that's the case, you've to commit these CRLF/LF changes (by reviewing them in &lt;code&gt;git status&lt;/code&gt;), or try: &lt;code&gt;git config core.autcrlf false&lt;/code&gt; to temporary ignore them.</source>
          <target state="translated">如果是这样，您必须提交这些CRLF / LF更改（通过在 &lt;code&gt;git status&lt;/code&gt; 中查看它们），或尝试： &lt;code&gt;git config core.autcrlf false&lt;/code&gt; 以暂时忽略它们。</target>
        </trans-unit>
        <trans-unit id="be99b3701dbfa1ea6069b28872598c9af0eaf225" translate="yes" xml:space="preserve">
          <source>If you have any files that are &lt;em&gt;not&lt;/em&gt; tracked by Git (e.g. uploaded user content), these files will not be affected.</source>
          <target state="translated">如果您有Git &lt;em&gt;不能&lt;/em&gt;跟踪的任何文件（例如，上载的用户内容），这些文件将不会受到影响。</target>
        </trans-unit>
        <trans-unit id="0e7742626a2af9a263481a2ea42184887d357916" translate="yes" xml:space="preserve">
          <source>If you want to remove untracked directories in addition to untracked files:</source>
          <target state="translated">如果你想删除未跟踪的目录,除了未跟踪的文件外,还想删除未跟踪的目录。</target>
        </trans-unit>
        <trans-unit id="a180e327b58926ff442a586df94b1875f83ddd5f" translate="yes" xml:space="preserve">
          <source>Important: If you have any local changes, they will be lost. With or without &lt;code&gt;--hard&lt;/code&gt; option, any local commits that haven't been pushed will be lost.&lt;sup&gt;[*]&lt;/sup&gt;</source>
          <target state="translated">重要提示：如果您进行任何本地更改，它们将会丢失。 无论是否使用 &lt;code&gt;--hard&lt;/code&gt; 选项，所有尚未推送的本地提交都将丢失。 &lt;sup&gt;[*]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="03fc06a673c3bef7b930cdf312a4a24d568ded9b" translate="yes" xml:space="preserve">
          <source>In speaking of pull/fetch/merge in the previous answers, I would like to share an interesting and productive trick,</source>
          <target state="translated">说到前面的答案中的拉菲奇merge,我想和大家分享一个有趣又有成效的小技巧。</target>
        </trans-unit>
        <trans-unit id="ad81e97b3a770037ed684784fde0a5c8ef87d732" translate="yes" xml:space="preserve">
          <source>Instead of doing:</source>
          <target state="translated">而不是做。</target>
        </trans-unit>
        <trans-unit id="dcb313addf8398324b6dbe730aabe7eb8934c8e2" translate="yes" xml:space="preserve">
          <source>Instead of merging with &lt;code&gt;git pull&lt;/code&gt;, try this:</source>
          <target state="translated">而不是与 &lt;code&gt;git pull&lt;/code&gt; 合并，请尝试以下操作：</target>
        </trans-unit>
        <trans-unit id="2cd313911aabf555c754ba83cda398a218f8f5a4" translate="yes" xml:space="preserve">
          <source>It looks like the best way is to first do:</source>
          <target state="translated">看来,最好的办法是先做。</target>
        </trans-unit>
        <trans-unit id="0e06b597f22a2c59eaa962116cc249a03f1662a8" translate="yes" xml:space="preserve">
          <source>It seems like most answers here are focused on the &lt;code&gt;master&lt;/code&gt; branch; however, there are times when I'm working on the same feature branch in two different places and I want a rebase in one to be reflected in the other without a lot of jumping through hoops.</source>
          <target state="translated">似乎大多数答案都集中在 &lt;code&gt;master&lt;/code&gt; 分支上。 但是，有时候我在两个不同的地方处理同一个功能分支，并且我希望其中一个的基础能够在另一个中得到反映，而不会造成很大的麻烦。</target>
        </trans-unit>
        <trans-unit id="7d8089aa0bbee09dd16c70b9dd88c5b319c9169f" translate="yes" xml:space="preserve">
          <source>It should do what you want.</source>
          <target state="translated">它应该能满足你的要求。</target>
        </trans-unit>
        <trans-unit id="f9e5e58435cb3bab1134eff5bbfd984a13e46944" translate="yes" xml:space="preserve">
          <source>Just do</source>
          <target state="translated">只要做</target>
        </trans-unit>
        <trans-unit id="bac005d3d83ada4449ef9cc4568c9cab8c7db381" translate="yes" xml:space="preserve">
          <source>Later you can clean the stash history.</source>
          <target state="translated">以后你可以清理藏书楼的历史记录。</target>
        </trans-unit>
        <trans-unit id="2ccb58cd1657aff4b8d5f6d44aa0ce72cd0f5cd5" translate="yes" xml:space="preserve">
          <source>Like Hedgehog I think the answers are terrible. But though Hedgehog's answer might be better, I don't think it is as elegant as it could be.  The way I found to do this is by using &quot;fetch&quot; and &quot;merge&quot; with a defined strategy. Which should make it so that your local changes are preserved as long as they are not one of the files that you are trying to force an overwrite with.</source>
          <target state="translated">和刺猬一样,我认为答案很糟糕。不过,虽然Hedgehog的答案可能更好,但我觉得这个答案并没有那么优雅。我找到的方法是使用 &quot;取 &quot;和 &quot;合并 &quot;的策略。这应该可以使你的本地更改被保留下来,只要它们不是你要强行覆盖的文件之一。</target>
        </trans-unit>
        <trans-unit id="57db7f84faa1518fd0d5c9bcdbb54d789e40298b" translate="yes" xml:space="preserve">
          <source>Local commits that are not on the remote branch need to be deleted as well. IMO the easiest way to achieve this is with: &lt;code&gt;git reset --hard origin/master&lt;/code&gt; (replace 'master' by whatever branch you are working on, and run a &lt;code&gt;git fetch origin&lt;/code&gt; first)</source>
          <target state="translated">不在远程分支上的本地提交也需要删除。 IMO实现此目的的最简单方法是： &lt;code&gt;git reset --hard origin/master&lt;/code&gt; （用正在处理的任何分支替换&amp;ldquo; master&amp;rdquo;，然后首先运行 &lt;code&gt;git fetch origin&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="902b1994ebdb1a49c25d1e1bcdd7120a07310fa8" translate="yes" xml:space="preserve">
          <source>Local files that are untracked need to be deleted, either manually (safer) or as suggested in other answers, by &lt;code&gt;git clean -f -d&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git clean -f -d&lt;/code&gt; 需要手动删除（更安全）或按照其他答案中的建议删除未跟踪的本地文件。</target>
        </trans-unit>
        <trans-unit id="ebf666caa78cad721786be145be564955ec4d13f" translate="yes" xml:space="preserve">
          <source>Maintain current local commits</source>
          <target state="translated">维持当前的本地承诺</target>
        </trans-unit>
        <trans-unit id="27d3c0eecb54773d9a2bf6562cb66eb7114e4a4d" translate="yes" xml:space="preserve">
          <source>Make the local repository match the remote origin repository.</source>
          <target state="translated">使本地存储库与远程源存储库相匹配。</target>
        </trans-unit>
        <trans-unit id="c44115da474d910d5bd67d5010c093acb30dad91" translate="yes" xml:space="preserve">
          <source>Manually, one-by-one:</source>
          <target state="translated">人工,一对一。</target>
        </trans-unit>
        <trans-unit id="1f9d21224178a8ed1cca77caf291eba184ae786b" translate="yes" xml:space="preserve">
          <source>No need to fetch all remotes and branches if you're going to reset to the origin/master branch right?</source>
          <target state="translated">如果你要重置到 originmaster 分支,就不需要提取所有的远程和分支了吧?</target>
        </trans-unit>
        <trans-unit id="36d03b9af07b5eaff018766e46d322d377dc6f23" translate="yes" xml:space="preserve">
          <source>Now it works.</source>
          <target state="translated">现在可以了。</target>
        </trans-unit>
        <trans-unit id="bf662c7bf7c1229391af4012d4ab4979da22561f" translate="yes" xml:space="preserve">
          <source>OR If you are on some other branch:</source>
          <target state="translated">或者,如果你在其他部门,</target>
        </trans-unit>
        <trans-unit id="33b6a45ba92ca30383f55274e41f4e14184846bf" translate="yes" xml:space="preserve">
          <source>Of course if you want to go back to what you stashed:</source>
          <target state="translated">当然,如果你想回到你所藏的东西。</target>
        </trans-unit>
        <trans-unit id="11be4c8b5293489e43dade05c7b3663d51f1211e" translate="yes" xml:space="preserve">
          <source>Or, in your &lt;code&gt;.gitconfig&lt;/code&gt; file:</source>
          <target state="translated">或者，在您的 &lt;code&gt;.gitconfig&lt;/code&gt; 文件中：</target>
        </trans-unit>
        <trans-unit id="42da08286231f6c3d657f652d649f572c9396d4c" translate="yes" xml:space="preserve">
          <source>Rather (git &amp;gt; v1.7.6):</source>
          <target state="translated">而是（git&amp;gt; v1.7.6）：</target>
        </trans-unit>
        <trans-unit id="475ffa14014bb463965306813410e4afd01a7039" translate="yes" xml:space="preserve">
          <source>Requirements:</source>
          <target state="translated">Requirements:</target>
        </trans-unit>
        <trans-unit id="915317e7edd24055b8e04b2d411caa7b7533153c" translate="yes" xml:space="preserve">
          <source>Reset the index and the head to &lt;code&gt;origin/master&lt;/code&gt;, but do not reset the working tree:</source>
          <target state="translated">将索引和标头重置为 &lt;code&gt;origin/master&lt;/code&gt; ，但不要重置工作树：</target>
        </trans-unit>
        <trans-unit id="9ab708d6bf11eb7eae1427bfc4104732844213b0" translate="yes" xml:space="preserve">
          <source>Run this from a branch and it'll only reset your local branch to the upstream version.</source>
          <target state="translated">从分支中运行这个,它只会将你的本地分支重置为上游版本。</target>
        </trans-unit>
        <trans-unit id="807398f22444dcc53d6db811aebb6cd9cc2291af" translate="yes" xml:space="preserve">
          <source>So you avoid all unwanted side effects, like deleting files or directories you wanted to keep, etc.</source>
          <target state="translated">所以你可以避免所有不想要的副作用,比如删除你想保留的文件或目录等。</target>
        </trans-unit>
        <trans-unit id="4190ac35a0d65d8420cd953993197fee2c185752" translate="yes" xml:space="preserve">
          <source>Solution:</source>
          <target state="translated">Solution:</target>
        </trans-unit>
        <trans-unit id="9587d887b8a5d76ff8f5b3ca6941e7eae087b881" translate="yes" xml:space="preserve">
          <source>Some answers seem to be terrible. Terrible in the sense of what happened to @Lauri by following David Avsajanishvili suggestion.</source>
          <target state="translated">有些答案似乎是可怕的。可怕的是@Lauri通过听从David Avsajanishvili的建议而发生的事情。</target>
        </trans-unit>
        <trans-unit id="0d28dcfeeae68b49b63a4e472f2f8328b5fdd4e3" translate="yes" xml:space="preserve">
          <source>Sometimes just &lt;code&gt;clean -f&lt;/code&gt; does not help. In case you have untracked DIRECTORIES, -d option also needed:</source>
          <target state="translated">有时只执行 &lt;code&gt;clean -f&lt;/code&gt; 并没有帮助。 如果您有未跟踪的目录，还需要-d选项：</target>
        </trans-unit>
        <trans-unit id="8631c9b28f153fae2e2fef4e1316c5b69bbe8cfd" translate="yes" xml:space="preserve">
          <source>That in mind, I updated Kustudic's script to do just that.  I also fixed a typo (a missing ' in the original).</source>
          <target state="translated">考虑到这一点,我更新了Kustudic的脚本来做。我还修复了一个错字(原文中缺少的')。</target>
        </trans-unit>
        <trans-unit id="e93f4cf2c16977aa0828b84202ee64df60519c65" translate="yes" xml:space="preserve">
          <source>That's it!</source>
          <target state="translated">就这样!</target>
        </trans-unit>
        <trans-unit id="25600d3a9892efcd21d9b4cfc94b0ab9748ed9b2" translate="yes" xml:space="preserve">
          <source>The first command fetches newest data.</source>
          <target state="translated">第一个命令获取最新的数据。</target>
        </trans-unit>
        <trans-unit id="253df425511692a7988571c26edb1c772b59d386" translate="yes" xml:space="preserve">
          <source>The following version commits your local changes to a temporary branch (&lt;code&gt;tmp&lt;/code&gt;), checks out the original branch (which I'm assuming is &lt;code&gt;master&lt;/code&gt;) and merges the updates. You could do this with &lt;code&gt;stash&lt;/code&gt;, but I've found it's usually easier to simply use the branch / merge approach.</source>
          <target state="translated">以下版本将您的本地更改提交到临时分支（ &lt;code&gt;tmp&lt;/code&gt; ），签出原始分支（我​​假设是 &lt;code&gt;master&lt;/code&gt; ）并合并更新。 您可以使用 &lt;code&gt;stash&lt;/code&gt; 进行此操作，但是我发现通常简单地使用分支/合并方法会更容易。</target>
        </trans-unit>
        <trans-unit id="6bde0e00397fa4ee9171ff863ee7e069991bf8f0" translate="yes" xml:space="preserve">
          <source>The only thing that worked for me was:</source>
          <target state="translated">唯一对我有用的是:</target>
        </trans-unit>
        <trans-unit id="b8d26d09bd803d962c0ffdc7865ca8eded89d169" translate="yes" xml:space="preserve">
          <source>The problem with all these solutions is that they are all either too complex, or, an even bigger problem, is that they remove all untracked files from the web server, which we don't want since there are always needed configuration files which are on the server and not in the Git repository.</source>
          <target state="translated">所有这些解决方案的问题是,它们都太复杂了,或者说,更大的问题是,它们会把所有未被跟踪的文件从web服务器上删除,而这是我们不希望看到的,因为总是有需要的配置文件,而这些文件都在服务器上,而不是在Git仓库里。</target>
        </trans-unit>
        <trans-unit id="c3c10cc0d5a31ff5783080c9bd9635741b253fc8" translate="yes" xml:space="preserve">
          <source>The second command checks if there are any files which are being added to the repository and deletes those untracked files from the local repository which would cause conflicts.</source>
          <target state="translated">第二个命令检查是否有任何文件被添加到存储库中,并从本地存储库中删除那些会引起冲突的未被跟踪的文件。</target>
        </trans-unit>
        <trans-unit id="678000075b4d6cd38269dac48c4b8d87c1fca462" translate="yes" xml:space="preserve">
          <source>The third command checks-out all the files which were locally modified.</source>
          <target state="translated">第三条命令检查出所有被本地修改的文件。</target>
        </trans-unit>
        <trans-unit id="21267f318079f6774b177821837cc891b20ba5c7" translate="yes" xml:space="preserve">
          <source>Then I am able to pull just fine.</source>
          <target state="translated">然后,我就能拉得很好。</target>
        </trans-unit>
        <trans-unit id="5f21d45c01e403eb57b1b5827ca4047a372a4082" translate="yes" xml:space="preserve">
          <source>Then fetch the changes and overwrite if there is a conflict</source>
          <target state="translated">然后获取更改,如果有冲突的话,再进行覆盖。</target>
        </trans-unit>
        <trans-unit id="c676bc4481885bfedae0258dc14ccea8e8999c8a" translate="yes" xml:space="preserve">
          <source>Then pull it again.</source>
          <target state="translated">然后再拉一次。</target>
        </trans-unit>
        <trans-unit id="ee4ca7fba794f3af9d4fb46b93e0453c258d261c" translate="yes" xml:space="preserve">
          <source>Then the &lt;code&gt;git reset&lt;/code&gt; resets the master branch to what you just fetched. The &lt;code&gt;--hard&lt;/code&gt; option changes all the files in your working tree to match the files in &lt;code&gt;origin/master&lt;/code&gt;</source>
          <target state="translated">然后 &lt;code&gt;git reset&lt;/code&gt; 将master分支重置为您刚获取的分支。 &lt;code&gt;--hard&lt;/code&gt; 选项更改工作树中的所有文件以匹配 &lt;code&gt;origin/master&lt;/code&gt; 文件/主文件中的文件</target>
        </trans-unit>
        <trans-unit id="d81ef5f48f166e14f75ad40236c0c9df9e4a75e1" translate="yes" xml:space="preserve">
          <source>Then, you have two options:</source>
          <target state="translated">那么,你有两个选择。</target>
        </trans-unit>
        <trans-unit id="7798b87989a4d7b4641302aaed49212a7fe8c801" translate="yes" xml:space="preserve">
          <source>These four commands work for me.</source>
          <target state="translated">这四个命令对我来说是有效的。</target>
        </trans-unit>
        <trans-unit id="ff127378bb08dc1448022a9641654c494f565c1d" translate="yes" xml:space="preserve">
          <source>They are adding some images to the images directory (but forgets to add them under source control)</source>
          <target state="translated">他们正在将一些图片添加到图片目录中(但忘了在源码控制下添加图片)。</target>
        </trans-unit>
        <trans-unit id="03b8bbdb6eb2cf69f8cb249139cd7ce228faaecf" translate="yes" xml:space="preserve">
          <source>They are sending the images by mail, later, to me</source>
          <target state="translated">他们会把图片通过邮件寄给我</target>
        </trans-unit>
        <trans-unit id="7cd7a4110beebad617002342d669e523a4966903" translate="yes" xml:space="preserve">
          <source>They cannot pull updates from GitHub because Git doesn't want to overwrite their files.</source>
          <target state="translated">他们无法从GitHub中拉出更新,因为Git不想覆盖他们的文件。</target>
        </trans-unit>
        <trans-unit id="0c0bc2340a056214e8100c82b907cb176343ebc8" translate="yes" xml:space="preserve">
          <source>This above command is the most useful command in my Git life which saved a lot of time.</source>
          <target state="translated">上面这条命令是我Git生活中最有用的命令,节省了很多时间。</target>
        </trans-unit>
        <trans-unit id="2e784adb16c7ed518925195e69f1ed074a41fa47" translate="yes" xml:space="preserve">
          <source>This can be nicely put into a git alias (&lt;code&gt;git forcepull&lt;/code&gt;) as well:</source>
          <target state="translated">也可以将其很好地放入git别名（ &lt;code&gt;git forcepull&lt;/code&gt; ）：</target>
        </trans-unit>
        <trans-unit id="7fa72933f59b96fd34b4e375dec6861fc0377acd" translate="yes" xml:space="preserve">
          <source>This will REMOVE all git files (excempt &lt;code&gt;.git/&lt;/code&gt; dir, where you have all commits) and pull it again.</source>
          <target state="translated">这将删除所有git文件（不包括 &lt;code&gt;.git/&lt;/code&gt; dir，您拥有所有提交），然后再次将其拉出。</target>
        </trans-unit>
        <trans-unit id="1913d306d1a42c1564720a4d705c73b9650593f6" translate="yes" xml:space="preserve">
          <source>This will override your local file with the file on git</source>
          <target state="translated">这将用git上的文件覆盖你的本地文件。</target>
        </trans-unit>
        <trans-unit id="947b34a00d726c657b12cdbaccdf65e09fd25d8d" translate="yes" xml:space="preserve">
          <source>This will take you back five commits and then with</source>
          <target state="translated">这将带你回到五次承诺,然后用</target>
        </trans-unit>
        <trans-unit id="01731cd723b90256eccc7d0a8072853bf68d619c" translate="yes" xml:space="preserve">
          <source>To check/pull after executing these commands</source>
          <target state="translated">执行这些命令后要检查拉线</target>
        </trans-unit>
        <trans-unit id="792990822a55aacc5ab96839f6879d0ab135b670" translate="yes" xml:space="preserve">
          <source>To delete all untracked files and then continue with the usual &lt;code&gt;git pull&lt;/code&gt;...</source>
          <target state="translated">要删除所有未跟踪的文件，然后继续执行常规的 &lt;code&gt;git pull&lt;/code&gt; ...</target>
        </trans-unit>
        <trans-unit id="2e97c37f66bbb352cb86c890973bbee6dd9264e4" translate="yes" xml:space="preserve">
          <source>Track local changes so no-one here ever loses them.</source>
          <target state="translated">追踪当地的变化,所以这里没有人会失去它们。</target>
        </trans-unit>
        <trans-unit id="b21480ff457e048e3c7a6593bfb52719279e1f05" translate="yes" xml:space="preserve">
          <source>Try this:</source>
          <target state="translated">试试这个。</target>
        </trans-unit>
        <trans-unit id="79d1acaccc53be854e44cb88d8a731ca26725f61" translate="yes" xml:space="preserve">
          <source>Uncommitted changes</source>
          <target state="translated">未承诺的变动</target>
        </trans-unit>
        <trans-unit id="35d60c13f1637f01f05b6c59bfb6bb4fbae9aac4" translate="yes" xml:space="preserve">
          <source>Uncommitted changes, however (even staged), will be lost. Make sure to stash and commit anything you need. For that you can run the following:</source>
          <target state="translated">然而,未提交的修改(即使是阶段性的),也会丢失。请确保将你需要的任何东西都存储并提交。为此,你可以运行以下程序。</target>
        </trans-unit>
        <trans-unit id="a04a85b4f229d1ba1c004f1d7dfc9dad4ba95354" translate="yes" xml:space="preserve">
          <source>When you're using file-system which doesn't support permission attributes.
In example you have two repositories, one on Linux/Mac (&lt;code&gt;ext3&lt;/code&gt;/&lt;code&gt;hfs+&lt;/code&gt;) and another one on FAT32/NTFS based file-system.</source>
          <target state="translated">当您使用不支持权限属性的文件系统时。 在示例中，您有两个存储库，一个在Linux / Mac（ &lt;code&gt;ext3&lt;/code&gt; / &lt;code&gt;hfs+&lt;/code&gt; ）上，另一个在基于FAT32 / NTFS的文件系统上。</target>
        </trans-unit>
        <trans-unit id="b59d9f65f3bfd048d61e29b69d244223b5fd2b4d" translate="yes" xml:space="preserve">
          <source>Why &lt;code&gt;git reset HEAD --hard&lt;/code&gt; could fail in some cases?</source>
          <target state="translated">为什么 &lt;code&gt;git reset HEAD --hard&lt;/code&gt; 在某些情况下会失败？</target>
        </trans-unit>
        <trans-unit id="e676bf6f98187f56702c31f2b2f0568c7e63be07" translate="yes" xml:space="preserve">
          <source>You might find this command helpful to throw away local changes:</source>
          <target state="translated">你可能会发现这个命令对扔掉本地更改有帮助。</target>
        </trans-unit>
        <trans-unit id="6f68fbd4c89d37bb92c0eccd976bc907b757552a" translate="yes" xml:space="preserve">
          <source>error: Untracked working tree file 'public/images/icon.gif' would be overwritten by merge</source>
          <target state="translated">错误。未跟踪的工作树文件'publicimagesicon.gif'将被合并覆盖。</target>
        </trans-unit>
        <trans-unit id="9351bd81e6470b3b0902ff748b289a7935609351" translate="yes" xml:space="preserve">
          <source>followed by:</source>
          <target state="translated">其次是:</target>
        </trans-unit>
        <trans-unit id="ddea56ff50be6923b4fcf019f86bdb93636ef9b3" translate="yes" xml:space="preserve">
          <source>where the last command gives a list of what your local changes were. Keep modifying the &quot;tmp&quot; branch until it is acceptable and then merge back onto master with:</source>
          <target state="translated">最后一条命令给出了一个本地修改的列表。继续修改 &quot;tmp &quot;分支,直到可以接受,然后用 &quot;tmp &quot;合并回主站。</target>
        </trans-unit>
        <trans-unit id="016dc548ba6ea5dc4ca066fa1aaacbe2d5292693" translate="yes" xml:space="preserve">
          <source>where we assume the &lt;strong&gt;other repository&lt;/strong&gt; is &lt;code&gt;origin master&lt;/code&gt;.</source>
          <target state="translated">我们假设&lt;strong&gt;另一个存储库&lt;/strong&gt;是 &lt;code&gt;origin master&lt;/code&gt; 。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
