<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1129216">
    <body>
      <group id="1129216">
        <trans-unit id="eaf05f38df1e96b1e29758bb7fe11f67f45b3238" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://lodash.com/docs/4.17.10#orderBy&quot;&gt;https://lodash.com/docs/4.17.10#orderBy&lt;/a&gt;)</source>
          <target state="translated">(&lt;a href=&quot;https://lodash.com/docs/4.17.10#orderBy&quot;&gt;https://lodash.com/docs/4.17.10#orderBy&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="0790bb335f7e76d0fc0cbae8da7900ffe6d0e869" translate="yes" xml:space="preserve">
          <source>(Array): Returns the new sorted array.</source>
          <target state="translated">(배열) : 새로운 정렬 된 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5be6a3762f19b74cbbb70dc39b4a2ed96cda2b8b" translate="yes" xml:space="preserve">
          <source>...and it will work when you do:</source>
          <target state="translated">... 그리고 당신이 할 때 작동합니다 :</target>
        </trans-unit>
        <trans-unit id="408d5dc1c2e5d3cc3cfc29c9c02f09ec45157ced" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://lodash.com&quot;&gt;Lodash.js&lt;/a&gt; (superset of &lt;a href=&quot;http://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://lodash.com&quot;&gt;Lodash.js&lt;/a&gt; ( &lt;a href=&quot;http://underscorejs.org&quot;&gt;Underscore.js의&lt;/a&gt; 상위 집합)</target>
        </trans-unit>
        <trans-unit id="2fbb80ca28b5ca5da68cfdc28258d11b3e76b0ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.localeCompare(b)&lt;/code&gt; is &lt;a href=&quot;https://caniuse.com/#feat=localecompare&quot;&gt;universally supported&lt;/a&gt; and returns -1,0,1 if &lt;code&gt;a&amp;lt;b&lt;/code&gt;,&lt;code&gt;a==b&lt;/code&gt;,&lt;code&gt;a&amp;gt;b&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;a.localeCompare(b)&lt;/code&gt; 는 &lt;a href=&quot;https://caniuse.com/#feat=localecompare&quot;&gt;보편적으로 지원&lt;/a&gt; 되며 &lt;code&gt;a&amp;lt;b&lt;/code&gt; , &lt;code&gt;a==b&lt;/code&gt; , &lt;code&gt;a&amp;gt;b&lt;/code&gt; 인 경우 각각 -1,0,1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d2b655557e5811bc33a49b582a01a2785e6e0481" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortBy()&lt;/code&gt; accepts a &lt;code&gt;fn&lt;/code&gt; that selects what value from an object to use as comparison, and returns a function that can be passed directly to &lt;code&gt;Array.prototype.sort()&lt;/code&gt;. In this example, we're using &lt;code&gt;o.last_nom&lt;/code&gt; as the value for comparison, so whenever we receive two objects through &lt;code&gt;Array.prototype.sort()&lt;/code&gt; such as</source>
          <target state="translated">&lt;code&gt;sortBy()&lt;/code&gt; 는 객체에서 비교로 사용할 값을 선택하는 &lt;code&gt;fn&lt;/code&gt; 을 받아들이고 &lt;code&gt;Array.prototype.sort()&lt;/code&gt; 직접 전달할 수있는 함수를 반환합니다. 이 예제에서는 &lt;code&gt;o.last_nom&lt;/code&gt; 을 비교 값으로 사용하므로 &lt;code&gt;Array.prototype.sort()&lt;/code&gt; 통해 두 객체를받을 때마다</target>
        </trans-unit>
        <trans-unit id="8d69f20040f5417a3026a30cd8ea8fd591b92b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;||&lt;/code&gt; in the last line gives &lt;code&gt;last_nom&lt;/code&gt; priority over &lt;code&gt;first_nom&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt; 마지막 줄에서 &lt;code&gt;last_nom&lt;/code&gt; 보다 &lt;code&gt;first_nom&lt;/code&gt; 우선권을 부여 합니다.</target>
        </trans-unit>
        <trans-unit id="685e1c5e75fb15c812f0b257c14cb0fdc409a39f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A generic comparision function&lt;/strong&gt; could be something like this:</source>
          <target state="translated">&lt;strong&gt;일반적인 비교 함수&lt;/strong&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56e775da82b01487c7f6ddf6c7ff16cd7c53673d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Arguments&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06987eb9f0a91d213c532d8530bc7493f4b21909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example / Usage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예 / 사용법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b23cf99ce5b83818e9d5ef595e650e2420ebc090" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Returns&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3b5280a037ea15a0211f841003278d82fb7548a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The simplest form&lt;/strong&gt; has only one inlined function like this:</source>
          <target state="translated">&lt;strong&gt;가장 간단한 양식&lt;/strong&gt; 에는 다음과 같은 인라인 함수가 하나만 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08701bdc2f148d3c876ad1f088849e6bab353367" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; No longer modifies original array.</source>
          <target state="translated">&lt;strong&gt;업데이트 :&lt;/strong&gt; 더 이상 원래 배열을 수정하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="22efa9ea9cd26617deceabed98baab042f532ac6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;npm install ramda&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;npm 설치 람다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deadfc786056b1159b1820f2c0a8d6f4c1fdbc62" translate="yes" xml:space="preserve">
          <source>A simple function that sort an array of object by a property</source>
          <target state="translated">속성으로 객체 배열을 정렬하는 간단한 함수</target>
        </trans-unit>
        <trans-unit id="e659c76ad7390f47c77fa0c7812bd1f6685ca69a" translate="yes" xml:space="preserve">
          <source>A simple sort function (based on &lt;strong&gt;quick-sort&lt;/strong&gt; algorithm):</source>
          <target state="translated">간단한 정렬 기능 ( &lt;strong&gt;빠른 정렬&lt;/strong&gt; 알고리즘 기반) :</target>
        </trans-unit>
        <trans-unit id="3f05dcbec3e472873d916b9f87770e17bd0e6655" translate="yes" xml:space="preserve">
          <source>A simple way:</source>
          <target state="translated">간단한 방법 :</target>
        </trans-unit>
        <trans-unit id="685fbc533bb200a572c948ebc9776967065b1366" translate="yes" xml:space="preserve">
          <source>Acording your example, you need to sort by two fields (last name, first name), rather then one. You can use &lt;a href=&quot;http://github.com/agershun/alasql&quot;&gt;Alasql&lt;/a&gt; library to make this sort in one line:</source>
          <target state="translated">예를 들어 두 개의 필드 (성, 이름)가 아닌 하나의 필드로 정렬해야합니다. &lt;a href=&quot;http://github.com/agershun/alasql&quot;&gt;Alasql&lt;/a&gt; 라이브러리를 사용하여 한 줄로 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afb583ef1819a5e62dc5b6a9ddb084833c571128" translate="yes" xml:space="preserve">
          <source>Actually this already answers the question. Below part is written because many people contacted me, complaining that &lt;a href=&quot;https://stackoverflow.com/questions/11379361&quot;&gt;it doesn't work with multiple parameters&lt;/a&gt;.</source>
          <target state="translated">실제로 이것은 이미 질문에 대답합니다. 아래 부분은 많은 사람들이 저에게 연락 &lt;a href=&quot;https://stackoverflow.com/questions/11379361&quot;&gt;하여 여러 매개 변수로 작동하지 않는다고&lt;/a&gt; 불평했기 때문에 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="faf258efe8955c8bef8669c5d530323dfa07aab3" translate="yes" xml:space="preserve">
          <source>And now you can sort by &lt;strong&gt;a.a.&lt;/strong&gt; this way:</source>
          <target state="translated">이제 다음과 같이 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d4ffa4fbc463d1f4c84aa72ef5b4bd48e76e580" translate="yes" xml:space="preserve">
          <source>Are more pluggable version based on &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/users/300011/ege-%C3%96zcan&quot;&gt;@ege-&amp;Ouml;zcan&lt;/a&gt;&lt;/strong&gt;'s very lovely &lt;a href=&quot;https://stackoverflow.com/a/4760279/3580261&quot;&gt;answer&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/users/300011/ege-%C3%96zcan&quot;&gt;@ ege-&amp;Ouml;zcan&lt;/a&gt;&lt;/strong&gt; 의 매우 멋진 &lt;a href=&quot;https://stackoverflow.com/a/4760279/3580261&quot;&gt;답변을&lt;/a&gt; 기반으로 한 플러그 가능한 버전이 있습니까?</target>
        </trans-unit>
        <trans-unit id="2666ae133c768dd72d8cf52ff198d969577f7a8a" translate="yes" xml:space="preserve">
          <source>As an added bonus, here's the equivalent in ECMAScript 5 without arrow functions, which is unfortunately more verbose:</source>
          <target state="translated">추가 된 보너스로, 여기에 화살표 기능이없는 ECMAScript 5와 동등한 기능이 있습니다. 불행히도 더 자세한 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="01b5196235994cc09856af607292d53c4f28d84a" translate="yes" xml:space="preserve">
          <source>As of 2018 there is a much shorter and elegant solution. Just use. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort&quot;&gt;Array.prototype.sort()&lt;/a&gt;.</source>
          <target state="translated">2018 년 현재 훨씬 더 짧고 우아한 솔루션이 있습니다. 그냥 사용하십시오. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort&quot;&gt;Array.prototype.sort ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="456c2ee19dd778e84e853719ba56200915177c7e" translate="yes" xml:space="preserve">
          <source>Combining Ege's dynamic solution with Vinay's idea, you get a nice robust solution:</source>
          <target state="translated">Ege의 동적 솔루션과 Vinay의 아이디어를 결합하면 다음과 같은 강력한 솔루션을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce98bea7e1a501ce976cc1218cb3ef55962e86cc" translate="yes" xml:space="preserve">
          <source>Don't get why people make it so complicated:</source>
          <target state="translated">사람들이 왜 그렇게 복잡하게 만드는지 이해하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="d2864d98334ee8c93f0f6b1e3ea43bc60c2262c2" translate="yes" xml:space="preserve">
          <source>Easiest Way: &lt;em&gt;Lodash&lt;/em&gt;</source>
          <target state="translated">가장 쉬운 방법 : &lt;em&gt;Lodash&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="30d9e9e6f4ce5ea49de6402830c224a348be7a83" translate="yes" xml:space="preserve">
          <source>Example Usage:</source>
          <target state="translated">사용법 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="a6646b9e4fb32dfe65aae73cdc7b36ce845efbbb" translate="yes" xml:space="preserve">
          <source>Explanation: &lt;code&gt;Number()&lt;/code&gt; will cast &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">설명 : &lt;code&gt;Number()&lt;/code&gt; 는 &lt;code&gt;true&lt;/code&gt; 를 &lt;code&gt;1&lt;/code&gt; 로 캐스트하고 &lt;code&gt;false&lt;/code&gt; 를 &lt;code&gt;0&lt;/code&gt; 으로 캐스트 합니다 .</target>
        </trans-unit>
        <trans-unit id="8c9084f8bf17308954515f726d9aa2ab360371fc" translate="yes" xml:space="preserve">
          <source>For stricter engines:</source>
          <target state="translated">보다 엄격한 엔진의 경우 :</target>
        </trans-unit>
        <trans-unit id="29914a14e4783736af4edcbc897367dc32baec6f" translate="yes" xml:space="preserve">
          <source>For the lucky among us who can use ES6, which allows extending the native objects:</source>
          <target state="translated">기본 객체를 확장 할 수있는 ES6을 사용할 수있는 사용자에게는 운이 좋을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f5f064cab7823d7f1af5bb658e354f5fbacef208" translate="yes" xml:space="preserve">
          <source>From Beauchamp's comment:</source>
          <target state="translated">Beauchamp의 의견에서 :</target>
        </trans-unit>
        <trans-unit id="b5244b39f418aae4ec7e158ecde66ac93b5bed47" translate="yes" xml:space="preserve">
          <source>Given the original example:</source>
          <target state="translated">원래 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9fe00acebc106e4dba1611cdd1d7dc308a244991" translate="yes" xml:space="preserve">
          <source>Goal</source>
          <target state="translated">Goal</target>
        </trans-unit>
        <trans-unit id="ec77c96f2ea6de7752b19589a9c7854150babc9c" translate="yes" xml:space="preserve">
          <source>Having two steps with  &lt;code&gt;last_nom&lt;/code&gt;,&lt;code&gt;first_nom&lt;/code&gt; sort order would look like this:</source>
          <target state="translated">&lt;code&gt;last_nom&lt;/code&gt; 으로 두 단계를 수행 하면 &lt;code&gt;first_nom&lt;/code&gt; 정렬 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36021a2a2d56e070889a084872be9cddb9dea599" translate="yes" xml:space="preserve">
          <source>Here's an example how to use it:</source>
          <target state="translated">사용 방법의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d4671d139bae00bf1fd9c9025be736bc9475a2f" translate="yes" xml:space="preserve">
          <source>Here's an explanation of &lt;code&gt;sortBy()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;sortBy()&lt;/code&gt; 대한 설명은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="920de43dceff485c0a2a304489399c01e63d4469" translate="yes" xml:space="preserve">
          <source>How can I sort them by the value of &lt;code&gt;last_nom&lt;/code&gt; in JavaScript?</source>
          <target state="translated">JavaScript에서 &lt;code&gt;last_nom&lt;/code&gt; 값으로 정렬하려면 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="0695135cf1588e47d94043db05a76659514ee112" translate="yes" xml:space="preserve">
          <source>I Just enhanced &lt;a href=&quot;https://stackoverflow.com/users/300011&quot;&gt;Ege &amp;Ouml;zcan&lt;/a&gt;'s dynamic sort to dive deep inside objects. 
If Data looks like this:</source>
          <target state="translated">방금 &lt;a href=&quot;https://stackoverflow.com/users/300011&quot;&gt;Ege &amp;Ouml;zcan&lt;/a&gt; 의 다이내믹 정렬을 향상시켜 깊숙한 내부의 물체를 뛰어 넘었습니다 . 데이터가 다음과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="deb98bae67998bc28426378d56c1ba385d0c50fe" translate="yes" xml:space="preserve">
          <source>I encountered the below and couldn't change it. I also did not want to flatten the object temporarily. Nor did I want to use underscore / lodash, mainly for performance reasons and the fun to implement it myself.</source>
          <target state="translated">아래에서 발생하여 변경할 수 없습니다. 또한 객체를 일시적으로 평평하게하고 싶지 않았습니다. 주로 성능상의 이유와 직접 구현하는 재미 때문에 밑줄 / lodash를 사용하고 싶지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="37de85c49081f9b0188ef6e799c866a4ffb94a49" translate="yes" xml:space="preserve">
          <source>I have an array of JavaScript objects:</source>
          <target state="translated">JavaScript 객체 배열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ccfae868d44dc0f2309722b194930082a3e07ba" translate="yes" xml:space="preserve">
          <source>I haven't seen this particular approach suggested, so here's a terse comparison method I like to use that works for both &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;number&lt;/code&gt;:</source>
          <target state="translated">나는이 특정 접근법이 제안 된 것을 보지 못했기 때문에 &lt;code&gt;string&lt;/code&gt; 과 &lt;code&gt;number&lt;/code&gt; 모두에서 작동하는 간결한 비교 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e8a344759f3534cd3101c2256dd217071e4142d" translate="yes" xml:space="preserve">
          <source>I know about &lt;code&gt;sort(a,b)&lt;/code&gt;, but that only seems to work on strings and numbers. Do I need to add a &lt;code&gt;toString()&lt;/code&gt; method to my objects?</source>
          <target state="translated">&lt;code&gt;sort(a,b)&lt;/code&gt; 에 대해 알고 있지만 문자열과 숫자에서만 작동하는 것 같습니다. 객체에 &lt;code&gt;toString()&lt;/code&gt; 메소드를 추가해야합니까?</target>
        </trans-unit>
        <trans-unit id="566e004b73b9018eb725b5fdc9b8d3360d31a45b" translate="yes" xml:space="preserve">
          <source>I know this question is too old, but I didn't see any implementation similar to mine.</source>
          <target state="translated">이 질문이 너무 오래되었지만 내 구현과 비슷한 구현을 보지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="a1d0c8f6643e4ddc30d0b0123a0a896879200493" translate="yes" xml:space="preserve">
          <source>If you have duplicate last names you might sort those by first name-</source>
          <target state="translated">성이 중복되는 경우 이름별로 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d35b04aa4945989fb22d68c7ff3bc7cf3e4a90b5" translate="yes" xml:space="preserve">
          <source>In ES6/ES2015 or later you can do this way:</source>
          <target state="translated">ES6 / ES2015 이상에서 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="961f8b9db6ec89bd40419165049dd198b8de05d3" translate="yes" xml:space="preserve">
          <source>Instead of using a custom comparison function, you could also create an object type with custom &lt;code&gt;toString()&lt;/code&gt; method (which is invoked by the default comparison function):</source>
          <target state="translated">사용자 정의 비교 함수를 사용하는 대신 사용자 정의 &lt;code&gt;toString()&lt;/code&gt; 메소드 (기본 비교 함수에 의해 호출 됨 )를 사용하여 오브젝트 유형을 작성할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c479a7c903cc8488af2afc7efd5943796202691f" translate="yes" xml:space="preserve">
          <source>It's easy enough to write your own comparison function:</source>
          <target state="translated">자체 비교 함수를 작성하는 것은 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="cbc249ea4e7a82a7ec0919b9ad1d670f290a6811" translate="yes" xml:space="preserve">
          <source>It's good not to add a framework for every simple piece of logic, but relying on well tested utility frameworks can speed up development and reduce the amount of bugs.</source>
          <target state="translated">모든 간단한 로직에 프레임 워크를 추가하지 않는 것이 좋지만 테스트를 거친 유틸리티 프레임 워크를 사용하면 개발 속도를 높이고 버그 양을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0fa28edf6be4ffbdd5ff729f4a7b7c4758875b5f" translate="yes" xml:space="preserve">
          <source>Lodash produces very clean code and promotes a more &lt;em&gt;functional programming&lt;/em&gt; style. In one glimpse it becomes clear what the intent of the code is.</source>
          <target state="translated">Lodash는 매우 깨끗한 코드를 생성하고보다 &lt;em&gt;기능적인 프로그래밍&lt;/em&gt; 스타일을 장려합니다. 한 번 엿볼 때 코드의 의도가 무엇인지 분명해집니다.</target>
        </trans-unit>
        <trans-unit id="9eaf61c467f14ad9ffb044dec015f58caf257257" translate="yes" xml:space="preserve">
          <source>More info? E.g. we have following nested object:</source>
          <target state="translated">더 많은 정보? 예를 들어 다음과 같은 중첩 객체가 있습니다.</target>
        </trans-unit>
        <trans-unit id="87c1be79d606b3383dbdf93122bd561431d64cc5" translate="yes" xml:space="preserve">
          <source>More readable format:</source>
          <target state="translated">더 읽기 쉬운 형식 :</target>
        </trans-unit>
        <trans-unit id="7edee346283fe35e96e795f35ff5de152f58755b" translate="yes" xml:space="preserve">
          <source>Multiple Parameters</source>
          <target state="translated">여러 매개 변수</target>
        </trans-unit>
        <trans-unit id="32d560375c769eb987267a8ce3ab1529b45b7910" translate="yes" xml:space="preserve">
          <source>Negate to reverse order, &lt;code&gt;return -last_nom_order || -first_nom_order || -age_order;&lt;/code&gt;</source>
          <target state="translated">역순으로 &lt;code&gt;return -last_nom_order || -first_nom_order || -age_order;&lt;/code&gt; -first_nom_order || -연령 _ 주문;</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="bcad6173433b52e269afa6bc77fb168e67f86b43" translate="yes" xml:space="preserve">
          <source>Now, in the base solution uses bracket notation to compute the properties to sort for dynamically. Here, though, we would have to construct the bracket notation dynamically also, since you would expect some like &lt;code&gt;People['Name.name']&lt;/code&gt; would work - which doesn't.</source>
          <target state="translated">이제 기본 솔루션에서는 대괄호 표기법을 사용하여 동적으로 정렬 할 속성을 계산합니다. 그러나 여기서는 &lt;code&gt;People['Name.name']&lt;/code&gt; 과 같은 일부는 작동하지 않을 것으로 예상하므로 대괄호 표기법을 동적으로 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="b6d5ee0e5ac2a920d1c93c741329108491c8da3b" translate="yes" xml:space="preserve">
          <source>OP's issue can simply be solved as:</source>
          <target state="translated">OP의 문제는 다음과 같이 간단하게 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30850acd7e09351894b8aa2a56a72e2f817539ce" translate="yes" xml:space="preserve">
          <source>Obstacles</source>
          <target state="translated">Obstacles</target>
        </trans-unit>
        <trans-unit id="498de8681b478a786108557a1ace1eb28f1d9afa" translate="yes" xml:space="preserve">
          <source>Old answer that is not correct:</source>
          <target state="translated">틀린 정답 :</target>
        </trans-unit>
        <trans-unit id="1fefd0bb4d6f3f3a8e89940a2cb000599c0c0c07" translate="yes" xml:space="preserve">
          <source>One more option:</source>
          <target state="translated">하나 더 옵션 :</target>
        </trans-unit>
        <trans-unit id="ef939c1b74a04cdc71de1b2c3f68069f2fe5b389" translate="yes" xml:space="preserve">
          <source>Or inline (c/o Marco Demaio):</source>
          <target state="translated">또는 인라인 (c / o Marco Demaio) :</target>
        </trans-unit>
        <trans-unit id="948128b010a72605e2fbf78fd74c54260e051ab0" translate="yes" xml:space="preserve">
          <source>Or when do you prefer &lt;a href=&quot;https://lodash.com/docs/4.17.15#flow&quot;&gt;flow&lt;/a&gt; over chain</source>
          <target state="translated">또는 언제 체인을 통한 &lt;a href=&quot;https://lodash.com/docs/4.17.15#flow&quot;&gt;흐름&lt;/a&gt; 을 선호합니까</target>
        </trans-unit>
        <trans-unit id="4e2821849d9c08e68ccd665bf930d3ee092da12e" translate="yes" xml:space="preserve">
          <source>Prior to ES6/ES2015</source>
          <target state="translated">ES6 / ES2015 이전</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="c58dd6bb45a2f9ac6a218c5b7185c3d34c81b4e8" translate="yes" xml:space="preserve">
          <source>Remembering that &lt;code&gt;fn = o =&amp;gt; o.last_nom&lt;/code&gt;, we can expand the compare function to the equivalent</source>
          <target state="translated">&lt;code&gt;fn = o =&amp;gt; o.last_nom&lt;/code&gt; 이라는 것을 기억하면 compare 함수를 동등한 것으로 확장 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="5822e1abe08b294040c03f0f3ce044677629caa2" translate="yes" xml:space="preserve">
          <source>Script:</source>
          <target state="translated">Script:</target>
        </trans-unit>
        <trans-unit id="2e98d736969feca005890fc917b8627988a081b3" translate="yes" xml:space="preserve">
          <source>See Commplete script in &lt;a href=&quot;http://jsfiddle.net/Gigapedia/ofd0a1nd/1/&quot;&gt;JSFiddle&lt;/a&gt;</source>
          <target state="translated">JSFiddle에서 완료 스크립트를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="751a745af1f2295e108ecd4014fcd7b3a221ad08" translate="yes" xml:space="preserve">
          <source>See that &lt;code&gt;'.toLowerCase()'&lt;/code&gt; is necessary to prevent erros 
in comparing strings.</source>
          <target state="translated">문자열을 비교할 때 오류를 방지하려면 &lt;code&gt;'.toLowerCase()'&lt;/code&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="49c7e143edcc42258a2f85d00fb2f5795d1a53eb" translate="yes" xml:space="preserve">
          <source>Simple and quick solution to this problem using prototype inheritance:</source>
          <target state="translated">프로토 타입 상속을 사용하여이 문제에 대한 간단하고 빠른 솔루션 :</target>
        </trans-unit>
        <trans-unit id="3df7de60d412e815cc56b44e99351d0f6ffc3257" translate="yes" xml:space="preserve">
          <source>Simply doing &lt;code&gt;People['Name']['name']&lt;/code&gt;, on the other hand, is static and only allows you to go down the &lt;em&gt;n&lt;/em&gt;-th level.</source>
          <target state="translated">반면에 &lt;code&gt;People['Name']['name']&lt;/code&gt; 을 수행하는 것은 정적이며 &lt;em&gt;n&lt;/em&gt; 레벨까지만 내려갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e4ab52faf107ee7c0249a954a4ed3dd4cff785d" translate="yes" xml:space="preserve">
          <source>Since you probably encounter more complex data structures like this array, I would expand the solution.</source>
          <target state="translated">이 배열과 같이 더 복잡한 데이터 구조가 발생할 수 있으므로 솔루션을 확장 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="7d686476427025af3329f7d68422a05f50b1bcb2" translate="yes" xml:space="preserve">
          <source>So you can have an array of objects like this:</source>
          <target state="translated">따라서 다음과 같은 객체 배열을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="109909121526dfa21cfc07a8f678954b7329a7ed" translate="yes" xml:space="preserve">
          <source>Sort array of objects by string property value</source>
          <target state="translated">문자열 속성 값으로 객체 배열 정렬</target>
        </trans-unit>
        <trans-unit id="dc4d28dec474ab397c30be8f3db0103e8f0c364c" translate="yes" xml:space="preserve">
          <source>Sort by multiple fields:</source>
          <target state="translated">여러 필드로 정렬 :</target>
        </trans-unit>
        <trans-unit id="f3502d6e64d1a7822b2b62f5b927220903c45ba7" translate="yes" xml:space="preserve">
          <source>Sorting (more) Complex Arrays of Objects</source>
          <target state="translated">복잡한 객체 배열 정렬 (추가)</target>
        </trans-unit>
        <trans-unit id="59c9e0733121e83769900d1cba9c0d364484136b" translate="yes" xml:space="preserve">
          <source>Subclassing Array</source>
          <target state="translated">서브 클래 싱 배열</target>
        </trans-unit>
        <trans-unit id="55a8cf52465cdc91b6aab717d8f7d031a34fc9d5" translate="yes" xml:space="preserve">
          <source>Subtraction works on numeric fields: &lt;code&gt;var age_order = left.age - right.age;&lt;/code&gt;</source>
          <target state="translated">빼기는 숫자 필드에서 작동합니다. &lt;code&gt;var age_order = left.age - right.age;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97e39b6af24502016b3d55f9dc3afd1f7213fc53" translate="yes" xml:space="preserve">
          <source>Swap the operator to have it sorted by reverse alphabetical order.</source>
          <target state="translated">알파벳 역순으로 정렬되도록 연산자를 교체하십시오.</target>
        </trans-unit>
        <trans-unit id="5ff57f4185e884322f43c9c59da60f12f41285ea" translate="yes" xml:space="preserve">
          <source>TL;DR</source>
          <target state="translated">TL;DR</target>
        </trans-unit>
        <trans-unit id="df8a4e60130779519de7ad68f7d5180c53c0743b" translate="yes" xml:space="preserve">
          <source>That would enable this:</source>
          <target state="translated">그것은 이것을 가능하게 할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="94d79b95d0c489e5bbcb12f8d364863f7a362261" translate="yes" xml:space="preserve">
          <source>The goal is to sort it primarily by &lt;code&gt;People.Name.name&lt;/code&gt; and secondarily by &lt;code&gt;People.Name.surname&lt;/code&gt;</source>
          <target state="translated">목표는 주로 &lt;code&gt;People.Name.name&lt;/code&gt; 을 기준으로 정렬하고 두 번째는 &lt;code&gt;People.Name.surname&lt;/code&gt; 을 기준으로 정렬하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="082acbdad9772f5f5be439c6315685ecc4157047" translate="yes" xml:space="preserve">
          <source>The logical OR &lt;code&gt;||&lt;/code&gt; operator has a short-circuiting functionality that's very useful here. Because of how it works, the body of the function above means</source>
          <target state="translated">논리 OR &lt;code&gt;||&lt;/code&gt; 연산자에는 단락 기능이있어 여기서 매우 유용합니다. 작동 방식으로 인해 위의 함수 본문은</target>
        </trans-unit>
        <trans-unit id="9609c6d9ea33fa99a452cd0c94aa46eb50331dfe" translate="yes" xml:space="preserve">
          <source>The main addition here will be to walk down the object tree and determine the value of the last leaf, you have to specify, as well as any intermediary leaf.</source>
          <target state="translated">여기에 주요 추가 사항은 객체 트리를 따라 내려 가고 마지막 잎의 값을 결정하는 것입니다. 중간 잎뿐만 아니라 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="a021612bae9941142ad365b346f4d4f2e54d2228" translate="yes" xml:space="preserve">
          <source>The point here is that pure JavaScript with functional approach can take you a long way without external libraries or complex code. It is also very effective, since no string parsing have to be done</source>
          <target state="translated">여기서 중요한 점은 기능적 접근 방식을 갖춘 순수 JavaScript는 외부 라이브러리 나 복잡한 코드 없이도 먼 길을 갈 수 있다는 것입니다. 문자열 구문 분석을 수행 할 필요가 없으므로 매우 효과적입니다.</target>
        </trans-unit>
        <trans-unit id="3f3da28278b977bb99aab14aa8c822c9b8400fd4" translate="yes" xml:space="preserve">
          <source>There are many good answers here, but I would like to point out that they can be extended very simply to achieve a lot more complex sorting. The only thing you have to do is to use the OR operator to chain comparision functions like this:</source>
          <target state="translated">여기에는 많은 좋은 답변이 있지만 훨씬 더 복잡한 정렬을 달성하기 위해 매우 간단하게 확장 할 수 있음을 지적하고 싶습니다. OR 연산자를 사용하여 비교 함수를 다음과 같이 연결하면됩니다.</target>
        </trans-unit>
        <trans-unit id="89bef63538bc26f3472cb4e1de8788758df3a06b" translate="yes" xml:space="preserve">
          <source>This function could be extended to support numeric fields, case sensitity, arbitary datatypes etc.</source>
          <target state="translated">이 기능은 숫자 필드, 대소 문자 구분, 임의 데이터 유형 등을 지원하도록 확장 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afa086a2b78cf51cf24d0b8a68e401404e3c4c1f" translate="yes" xml:space="preserve">
          <source>This is a simple problem, don't know why people have such complex solution.</source>
          <target state="translated">이것은 단순한 문제이며 사람들이 왜 그렇게 복잡한 해결책을 가지고 있는지 모릅니다.</target>
        </trans-unit>
        <trans-unit id="7b6c936e71d894731b069593df937870837eca90" translate="yes" xml:space="preserve">
          <source>This method is like _.sortBy except that it allows specifying the sort orders of the iteratees to sort by. If orders is unspecified, all values are sorted in ascending order. Otherwise, specify an order of &quot;desc&quot; for descending or &quot;asc&quot; for ascending sort order of corresponding values.</source>
          <target state="translated">이 메소드는 _.sortBy와 유사하지만 반복 할 정렬 순서를 지정하여 정렬 할 수 있습니다. 주문을 지정하지 않으면 모든 값이 오름차순으로 정렬됩니다. 그렇지 않으면, 내림차순은 &quot;desc&quot;, 해당 값의 오름차순 정렬은 &quot;asc&quot;순서를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="f951f5d768047fe6faaa6c8d66ca0dc5ebe9f893" translate="yes" xml:space="preserve">
          <source>This solution is based on the behaviour of &lt;code&gt;||&lt;/code&gt; operator which evaluates to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Logical_operators&quot;&gt;first evaluated expression which can be converted to true&lt;/a&gt;.</source>
          <target state="translated">이 솔루션은 &lt;code&gt;||&lt;/code&gt; 의 동작을 기반으로합니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Logical_operators&quot;&gt;true로 변환 될 수있는 첫 번째 평가 식으로&lt;/a&gt; 평가되는 연산자 입니다 .</target>
        </trans-unit>
        <trans-unit id="b7f248cb4e5c51d10f2cf342d2205f0fa91120cd" translate="yes" xml:space="preserve">
          <source>This version is based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Schwartzian transform idiom&lt;/a&gt;.</source>
          <target state="translated">이 버전은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Schwartzian 변환 관용구를&lt;/a&gt; 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="22ac867f198bbe668d95c95b88030a5c57f55991" translate="yes" xml:space="preserve">
          <source>Try this example &lt;a href=&quot;http://jsfiddle.net/agershun/4f4Lr9ss/1/&quot;&gt;at jsFiddle&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://jsfiddle.net/agershun/4f4Lr9ss/1/&quot;&gt;jsFiddle&lt;/a&gt; 에서이 예제 를 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="c4ec0e92ea2bb00ad4f3298da1ca66ad3ac5bf51" translate="yes" xml:space="preserve">
          <source>Use example:</source>
          <target state="translated">사용 예 :</target>
        </trans-unit>
        <trans-unit id="080aea69ed0585f6c9c95ab405ff44fbeb0fb543" translate="yes" xml:space="preserve">
          <source>Using Ramda,</source>
          <target state="translated">Ramda를 사용하여</target>
        </trans-unit>
        <trans-unit id="a18e4f510ee6d8aeee1db615bda7fa45c9e3e333" translate="yes" xml:space="preserve">
          <source>Want it reversed? No problem. Use &lt;a href=&quot;https://lodash.com/docs/4.17.15#reverse&quot;&gt;_.reverse&lt;/a&gt;.</source>
          <target state="translated">역전을 원하십니까? 문제 없어요. &lt;a href=&quot;https://lodash.com/docs/4.17.15#reverse&quot;&gt;_.reverse를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7fbd54bfb0efab47f14ced5f46b0a92322af15cd" translate="yes" xml:space="preserve">
          <source>Want to combine both using &lt;a href=&quot;https://lodash.com/docs/4.17.15#chain&quot;&gt;chain&lt;/a&gt;?</source>
          <target state="translated">&lt;a href=&quot;https://lodash.com/docs/4.17.15#chain&quot;&gt;체인을&lt;/a&gt; 사용하여 둘 다 결합하고 싶습니까?</target>
        </trans-unit>
        <trans-unit id="7f5038cff32d1a4e74bb009ed2f4b5fff77c22c4" translate="yes" xml:space="preserve">
          <source>We now can use the &lt;a href=&quot;https://lodash.com/docs/4.17.15#property&quot;&gt;_.property&lt;/a&gt; shorthand &lt;code&gt;user.age&lt;/code&gt; to specify the path to the property that should be matched. We will sort the user objects by the nested age property. Yes, it allows for nested property matching!</source>
          <target state="translated">이제 &lt;a href=&quot;https://lodash.com/docs/4.17.15#property&quot;&gt;_.property&lt;/a&gt; 속기 &lt;code&gt;user.age&lt;/code&gt; 를 사용하여 일치해야 할 속성의 경로를 지정할 수 있습니다. 중첩 된 연령 속성을 기준으로 사용자 개체를 정렬합니다. 예, 중첩 속성 일치가 가능합니다!</target>
        </trans-unit>
        <trans-unit id="19b758444752a4dcb43c1647fa85e1bff81f02f1" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;fn1&lt;/code&gt;, &lt;code&gt;fn2&lt;/code&gt;, ... are the sort functions which return [-1,0,1]. This results in &quot;sorting by fn1&quot;, &quot;sorting by fn2&quot; which is pretty much equal to ORDER BY in SQL.</source>
          <target state="translated">여기서 &lt;code&gt;fn1&lt;/code&gt; , &lt;code&gt;fn2&lt;/code&gt; , ...은 [-1,0,1]을 반환하는 정렬 함수입니다. 결과적으로 &quot;fn1로 정렬&quot;, &quot;fn2로 정렬&quot;은 SQL의 ORDER BY와 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="690becf4a80f0f5937c7bc25b8d202728a7a121c" translate="yes" xml:space="preserve">
          <source>Which would enable you to do something like this:</source>
          <target state="translated">다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e097110f8fbf6f7e12eb57ff825177af95ad6701" translate="yes" xml:space="preserve">
          <source>Without nested ternaries:</source>
          <target state="translated">중첩 된 삼항이없는 경우 :</target>
        </trans-unit>
        <trans-unit id="1f3a8961cc3c0dfbac1f833f2f6ab188fb0ae542" translate="yes" xml:space="preserve">
          <source>Working example &lt;a href=&quot;http://jsbin.com/lotifa/2/edit?js,console&quot;&gt;on JSBin&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://jsbin.com/lotifa/2/edit?js,console&quot;&gt;JSBin의 실례&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0a34fb6db23fd9ae9f6ec32649177b251cff0df" translate="yes" xml:space="preserve">
          <source>You can also create a dynamic sort function that sorts objects by their value that you pass:</source>
          <target state="translated">전달한 값을 기준으로 객체를 정렬하는 동적 정렬 함수를 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="da067ddfca6e878291ec7eaf398f4688e75afb77" translate="yes" xml:space="preserve">
          <source>You can them use it with chaining them by sort priority:</source>
          <target state="translated">정렬 우선 순위에 따라 연결하여 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">당신이 사용할 수있는</target>
        </trans-unit>
        <trans-unit id="8aaf0966ca9de88ed00423893c6750e302bc72b1" translate="yes" xml:space="preserve">
          <source>You can use the function below to generate sort functions with multiple sort parameters.</source>
          <target state="translated">아래 함수를 사용하여 여러 정렬 매개 변수가있는 정렬 함수를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eaa79b08656dd826605fddb4561d504870a33325" translate="yes" xml:space="preserve">
          <source>You may need to convert them to the lower case in order to prevent from confusion.</source>
          <target state="translated">혼동을 막기 위해 소문자로 변환해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc7c5e2dd156919b34965a95a543881ff61e72e7" translate="yes" xml:space="preserve">
          <source>additional desc params for &lt;strong&gt;Ege &amp;Ouml;zcan&lt;/strong&gt; code</source>
          <target state="translated">&lt;strong&gt;Ege &amp;Ouml;zcan&lt;/strong&gt; 코드에 대한 추가 설명 매개 변수</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="14d76e0ea677b53536f0e1bcd8e4402905430049" translate="yes" xml:space="preserve">
          <source>and changed &lt;strong&gt;_dynamicSort&lt;/strong&gt;'s &lt;em&gt;return&lt;/em&gt; function:</source>
          <target state="translated">&lt;strong&gt;_dynamicSort&lt;/strong&gt; 의 &lt;em&gt;반환&lt;/em&gt; 함수를 변경 &lt;strong&gt;했습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="583c8146c0fd7636650ae88381ba9b1747e52ec5" translate="yes" xml:space="preserve">
          <source>and if you want to sort it over &lt;strong&gt;a.a&lt;/strong&gt; property I think my enhancement helps very well. I add new functionality to objects like this:</source>
          <target state="translated">그리고 속성을 기준으로 정렬하려면 개선 사항이 매우 도움이된다고 생각합니다. 다음과 같은 객체에 새로운 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="1f59fa9a439467f6503baeffe55c3ea31faf4f52" translate="yes" xml:space="preserve">
          <source>collection (Array|Object): The collection to iterate over.
[iteratees=[_.identity]] (Array[]|Function[]|Object[]|string[]): The iteratees to sort by.
[orders] (string[]): The sort orders of iteratees.</source>
          <target state="translated">collection (Array | Object) : 반복 할 컬렉션. [iteratees = [_. identity]] (Array [] | 함수 [] | Object [] | string []) : 정렬을 반복합니다. [orders] (string []) : 반복 순서입니다.</target>
        </trans-unit>
        <trans-unit id="d6423b40a11bcee12314b6ccef031813c2cdb209" translate="yes" xml:space="preserve">
          <source>sortBy_.sortBy(list, iterator, [context])  Returns a sorted copy of
  list, ranked in ascending order by the results of running each value
  through iterator. Iterator may also be the string name of the property
  to sort by (eg. length).</source>
          <target state="translated">sortBy_.sortBy (list, iterator, [context]) 반복자를 통해 각 값을 실행 한 결과에 따라 오름차순으로 정렬 된 목록의 정렬 된 사본을 리턴합니다. 반복자는 정렬 할 속성의 문자열 이름 일 수도 있습니다 (예 : 길이).</target>
        </trans-unit>
        <trans-unit id="6e6af4a6f6b8dd020ff1ccc161165eca878ae248" translate="yes" xml:space="preserve">
          <source>sorts ascending by default.</source>
          <target state="translated">기본적으로 오름차순으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="bce3a219b7462cbfc0c0086b83fd33ffe4a24372" translate="yes" xml:space="preserve">
          <source>to compare them.</source>
          <target state="translated">그들을 비교합니다.</target>
        </trans-unit>
        <trans-unit id="e20673804c9f90b32d81557d7cd06d6ac501919d" translate="yes" xml:space="preserve">
          <source>underscore.js</source>
          <target state="translated">underscore.js</target>
        </trans-unit>
        <trans-unit id="c285e07a2de39b6fbee1c5def3798517aaa7efe1" translate="yes" xml:space="preserve">
          <source>use underscore, its small and awesome...</source>
          <target state="translated">작고 멋진 밑줄을 사용하십시오 ...</target>
        </trans-unit>
        <trans-unit id="18cbf375a546dc39d742dd985d70e5999b401a29" translate="yes" xml:space="preserve">
          <source>we use</source>
          <target state="translated">우리는 사용</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
