<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1129216">
    <body>
      <group id="1129216">
        <trans-unit id="eaf05f38df1e96b1e29758bb7fe11f67f45b3238" translate="yes" xml:space="preserve">
          <source>(&lt;a href=&quot;https://lodash.com/docs/4.17.10#orderBy&quot;&gt;https://lodash.com/docs/4.17.10#orderBy&lt;/a&gt;)</source>
          <target state="translated">(&lt;a href=&quot;https://lodash.com/docs/4.17.10#orderBy&quot;&gt;https://lodash.com/docs/4.17.10#orderBy&lt;/a&gt;)</target>
        </trans-unit>
        <trans-unit id="0790bb335f7e76d0fc0cbae8da7900ffe6d0e869" translate="yes" xml:space="preserve">
          <source>(Array): Returns the new sorted array.</source>
          <target state="translated">(Array)を返します。ソートされた新しい配列を返します。</target>
        </trans-unit>
        <trans-unit id="5be6a3762f19b74cbbb70dc39b4a2ed96cda2b8b" translate="yes" xml:space="preserve">
          <source>...and it will work when you do:</source>
          <target state="translated">...そして、それはあなたがするときに動作します。</target>
        </trans-unit>
        <trans-unit id="408d5dc1c2e5d3cc3cfc29c9c02f09ec45157ced" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://lodash.com&quot;&gt;Lodash.js&lt;/a&gt; (superset of &lt;a href=&quot;http://underscorejs.org&quot;&gt;Underscore.js&lt;/a&gt;)</source>
          <target state="translated">&lt;a href=&quot;https://lodash.com&quot;&gt;Lodash.js&lt;/a&gt; （ &lt;a href=&quot;http://underscorejs.org&quot;&gt;Underscore.jsの&lt;/a&gt;スーパーセット）</target>
        </trans-unit>
        <trans-unit id="2fbb80ca28b5ca5da68cfdc28258d11b3e76b0ab" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a.localeCompare(b)&lt;/code&gt; is &lt;a href=&quot;https://caniuse.com/#feat=localecompare&quot;&gt;universally supported&lt;/a&gt; and returns -1,0,1 if &lt;code&gt;a&amp;lt;b&lt;/code&gt;,&lt;code&gt;a==b&lt;/code&gt;,&lt;code&gt;a&amp;gt;b&lt;/code&gt; respectively.</source>
          <target state="translated">&lt;code&gt;a.localeCompare(b)&lt;/code&gt; は&lt;a href=&quot;https://caniuse.com/#feat=localecompare&quot;&gt;普遍的にサポートされて&lt;/a&gt;おり、それぞれ &lt;code&gt;a==b&lt;/code&gt; &lt;code&gt;a&amp;lt;b&lt;/code&gt; 、 a == b 、 &lt;code&gt;a&amp;gt;b&lt;/code&gt; の場合は-1,0,1を返します。</target>
        </trans-unit>
        <trans-unit id="d2b655557e5811bc33a49b582a01a2785e6e0481" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;sortBy()&lt;/code&gt; accepts a &lt;code&gt;fn&lt;/code&gt; that selects what value from an object to use as comparison, and returns a function that can be passed directly to &lt;code&gt;Array.prototype.sort()&lt;/code&gt;. In this example, we're using &lt;code&gt;o.last_nom&lt;/code&gt; as the value for comparison, so whenever we receive two objects through &lt;code&gt;Array.prototype.sort()&lt;/code&gt; such as</source>
          <target state="translated">&lt;code&gt;sortBy()&lt;/code&gt; は、オブジェクトからどの値を比較として使用するかを選択する &lt;code&gt;fn&lt;/code&gt; を受け入れ、 &lt;code&gt;Array.prototype.sort()&lt;/code&gt; に直接渡すことができる関数を返します。 この例では、比較の値として &lt;code&gt;o.last_nom&lt;/code&gt; を使用しているため、次のような &lt;code&gt;Array.prototype.sort()&lt;/code&gt; を介して2つのオブジェクトを受け取るたびに</target>
        </trans-unit>
        <trans-unit id="8d69f20040f5417a3026a30cd8ea8fd591b92b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;||&lt;/code&gt; in the last line gives &lt;code&gt;last_nom&lt;/code&gt; priority over &lt;code&gt;first_nom&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;||&lt;/code&gt; 最後の行では、 &lt;code&gt;last_nom&lt;/code&gt; よりも &lt;code&gt;first_nom&lt;/code&gt; 優先されます 。</target>
        </trans-unit>
        <trans-unit id="685e1c5e75fb15c812f0b257c14cb0fdc409a39f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;A generic comparision function&lt;/strong&gt; could be something like this:</source>
          <target state="translated">&lt;strong&gt;一般的な比較関数&lt;/strong&gt;は次のようになります。</target>
        </trans-unit>
        <trans-unit id="56e775da82b01487c7f6ddf6c7ff16cd7c53673d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Arguments&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="06987eb9f0a91d213c532d8530bc7493f4b21909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example / Usage&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例/使い方&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b23cf99ce5b83818e9d5ef595e650e2420ebc090" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Returns&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Returns&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3b5280a037ea15a0211f841003278d82fb7548a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The simplest form&lt;/strong&gt; has only one inlined function like this:</source>
          <target state="translated">&lt;strong&gt;最も単純なフォームに&lt;/strong&gt;は、次のようなインライン関数が1つだけあります。</target>
        </trans-unit>
        <trans-unit id="0a648cd0606cca5d79438d4f156e8c36af2fbb7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;UPDATE&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;UPDATE&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08701bdc2f148d3c876ad1f088849e6bab353367" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt; No longer modifies original array.</source>
          <target state="translated">&lt;strong&gt;更新：&lt;/strong&gt;元の配列を変更しなくなりました。</target>
        </trans-unit>
        <trans-unit id="22efa9ea9cd26617deceabed98baab042f532ac6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;npm install ramda&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;npmインストールramda&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="deadfc786056b1159b1820f2c0a8d6f4c1fdbc62" translate="yes" xml:space="preserve">
          <source>A simple function that sort an array of object by a property</source>
          <target state="translated">オブジェクトの配列をプロパティでソートするシンプルな関数</target>
        </trans-unit>
        <trans-unit id="e659c76ad7390f47c77fa0c7812bd1f6685ca69a" translate="yes" xml:space="preserve">
          <source>A simple sort function (based on &lt;strong&gt;quick-sort&lt;/strong&gt; algorithm):</source>
          <target state="translated">シンプルなソート関数（ &lt;strong&gt;クイックソート&lt;/strong&gt;アルゴリズムに基づく）：</target>
        </trans-unit>
        <trans-unit id="3f05dcbec3e472873d916b9f87770e17bd0e6655" translate="yes" xml:space="preserve">
          <source>A simple way:</source>
          <target state="translated">簡単な方法です。</target>
        </trans-unit>
        <trans-unit id="685fbc533bb200a572c948ebc9776967065b1366" translate="yes" xml:space="preserve">
          <source>Acording your example, you need to sort by two fields (last name, first name), rather then one. You can use &lt;a href=&quot;http://github.com/agershun/alasql&quot;&gt;Alasql&lt;/a&gt; library to make this sort in one line:</source>
          <target state="translated">例によると、1つではなく2つのフィールド（姓、名）で並べ替える必要があります。 &lt;a href=&quot;http://github.com/agershun/alasql&quot;&gt;Alasql&lt;/a&gt;ライブラリを使用して、この並べ替えを1行で行うことができます。</target>
        </trans-unit>
        <trans-unit id="afb583ef1819a5e62dc5b6a9ddb084833c571128" translate="yes" xml:space="preserve">
          <source>Actually this already answers the question. Below part is written because many people contacted me, complaining that &lt;a href=&quot;https://stackoverflow.com/questions/11379361&quot;&gt;it doesn't work with multiple parameters&lt;/a&gt;.</source>
          <target state="translated">実際、これはすでに質問に答えています。 以下の部分は、多くの人が私に連絡して、 &lt;a href=&quot;https://stackoverflow.com/questions/11379361&quot;&gt;複数のパラメーターでは機能しない&lt;/a&gt;と不平を言っているために書かれています 。</target>
        </trans-unit>
        <trans-unit id="faf258efe8955c8bef8669c5d530323dfa07aab3" translate="yes" xml:space="preserve">
          <source>And now you can sort by &lt;strong&gt;a.a.&lt;/strong&gt; this way:</source>
          <target state="translated">そして今、あなたは&lt;strong&gt;aaで&lt;/strong&gt;このようにソートすることができます：</target>
        </trans-unit>
        <trans-unit id="2d4ffa4fbc463d1f4c84aa72ef5b4bd48e76e580" translate="yes" xml:space="preserve">
          <source>Are more pluggable version based on &lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/users/300011/ege-%C3%96zcan&quot;&gt;@ege-&amp;Ouml;zcan&lt;/a&gt;&lt;/strong&gt;'s very lovely &lt;a href=&quot;https://stackoverflow.com/a/4760279/3580261&quot;&gt;answer&lt;/a&gt;.</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;https://stackoverflow.com/users/300011/ege-%C3%96zcan&quot;&gt;@ege-&amp;Ouml;zcan&lt;/a&gt;&lt;/strong&gt;の非常に美しい&lt;a href=&quot;https://stackoverflow.com/a/4760279/3580261&quot;&gt;答えに&lt;/a&gt;基づいた、よりプラグ可能なバージョンです。</target>
        </trans-unit>
        <trans-unit id="2666ae133c768dd72d8cf52ff198d969577f7a8a" translate="yes" xml:space="preserve">
          <source>As an added bonus, here's the equivalent in ECMAScript 5 without arrow functions, which is unfortunately more verbose:</source>
          <target state="translated">おまけとして、以下は ECMAScript 5 で矢印関数を使用しない場合の等価なもので、残念ながらより冗長になっています。</target>
        </trans-unit>
        <trans-unit id="01b5196235994cc09856af607292d53c4f28d84a" translate="yes" xml:space="preserve">
          <source>As of 2018 there is a much shorter and elegant solution. Just use. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort&quot;&gt;Array.prototype.sort()&lt;/a&gt;.</source>
          <target state="translated">2018年の時点で、はるかに短くてエレガントなソリューションがあります。 使うだけ。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort&quot;&gt;Array.prototype.sort（）&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="456c2ee19dd778e84e853719ba56200915177c7e" translate="yes" xml:space="preserve">
          <source>Combining Ege's dynamic solution with Vinay's idea, you get a nice robust solution:</source>
          <target state="translated">エゲのダイナミックソリューションとヴィネイのアイデアを組み合わせると、素晴らしい堅牢なソリューションが得られます。</target>
        </trans-unit>
        <trans-unit id="ce98bea7e1a501ce976cc1218cb3ef55962e86cc" translate="yes" xml:space="preserve">
          <source>Don't get why people make it so complicated:</source>
          <target state="translated">人が複雑にする理由を理解していない。</target>
        </trans-unit>
        <trans-unit id="d2864d98334ee8c93f0f6b1e3ea43bc60c2262c2" translate="yes" xml:space="preserve">
          <source>Easiest Way: &lt;em&gt;Lodash&lt;/em&gt;</source>
          <target state="translated">最も簡単な方法： &lt;em&gt;ロダッシュ&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="30d9e9e6f4ce5ea49de6402830c224a348be7a83" translate="yes" xml:space="preserve">
          <source>Example Usage:</source>
          <target state="translated">使用例。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="a6646b9e4fb32dfe65aae73cdc7b36ce845efbbb" translate="yes" xml:space="preserve">
          <source>Explanation: &lt;code&gt;Number()&lt;/code&gt; will cast &lt;code&gt;true&lt;/code&gt; to &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">説明： &lt;code&gt;Number()&lt;/code&gt; は &lt;code&gt;true&lt;/code&gt; を &lt;code&gt;1&lt;/code&gt; に 、 &lt;code&gt;false&lt;/code&gt; を &lt;code&gt;0&lt;/code&gt; にキャストします 。</target>
        </trans-unit>
        <trans-unit id="8c9084f8bf17308954515f726d9aa2ab360371fc" translate="yes" xml:space="preserve">
          <source>For stricter engines:</source>
          <target state="translated">より厳格なエンジンのために。</target>
        </trans-unit>
        <trans-unit id="29914a14e4783736af4edcbc897367dc32baec6f" translate="yes" xml:space="preserve">
          <source>For the lucky among us who can use ES6, which allows extending the native objects:</source>
          <target state="translated">ネイティブオブジェクトの拡張が可能なES6を使える幸運な私たちのために。</target>
        </trans-unit>
        <trans-unit id="f5f064cab7823d7f1af5bb658e354f5fbacef208" translate="yes" xml:space="preserve">
          <source>From Beauchamp's comment:</source>
          <target state="translated">ボーシャンのコメントより</target>
        </trans-unit>
        <trans-unit id="b5244b39f418aae4ec7e158ecde66ac93b5bed47" translate="yes" xml:space="preserve">
          <source>Given the original example:</source>
          <target state="translated">元の例を考えると</target>
        </trans-unit>
        <trans-unit id="9fe00acebc106e4dba1611cdd1d7dc308a244991" translate="yes" xml:space="preserve">
          <source>Goal</source>
          <target state="translated">Goal</target>
        </trans-unit>
        <trans-unit id="ec77c96f2ea6de7752b19589a9c7854150babc9c" translate="yes" xml:space="preserve">
          <source>Having two steps with  &lt;code&gt;last_nom&lt;/code&gt;,&lt;code&gt;first_nom&lt;/code&gt; sort order would look like this:</source>
          <target state="translated">&lt;code&gt;last_nom&lt;/code&gt; で2つのステップがある場合 、 &lt;code&gt;first_nom&lt;/code&gt; のソート順は次のようになります。</target>
        </trans-unit>
        <trans-unit id="36021a2a2d56e070889a084872be9cddb9dea599" translate="yes" xml:space="preserve">
          <source>Here's an example how to use it:</source>
          <target state="translated">使い方の一例をご紹介します。</target>
        </trans-unit>
        <trans-unit id="2d4671d139bae00bf1fd9c9025be736bc9475a2f" translate="yes" xml:space="preserve">
          <source>Here's an explanation of &lt;code&gt;sortBy()&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;sortBy()&lt;/code&gt; の説明は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="920de43dceff485c0a2a304489399c01e63d4469" translate="yes" xml:space="preserve">
          <source>How can I sort them by the value of &lt;code&gt;last_nom&lt;/code&gt; in JavaScript?</source>
          <target state="translated">JavaScriptの &lt;code&gt;last_nom&lt;/code&gt; の値で並べ替えるにはどうすればよいですか？</target>
        </trans-unit>
        <trans-unit id="0695135cf1588e47d94043db05a76659514ee112" translate="yes" xml:space="preserve">
          <source>I Just enhanced &lt;a href=&quot;https://stackoverflow.com/users/300011&quot;&gt;Ege &amp;Ouml;zcan&lt;/a&gt;'s dynamic sort to dive deep inside objects. 
If Data looks like this:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/300011&quot;&gt;Ege&amp;Ouml;zcan&lt;/a&gt;の動的ソートを強化して、オブジェクトの内部を深く掘り下げました。 データが次のようになっている場合：</target>
        </trans-unit>
        <trans-unit id="deb98bae67998bc28426378d56c1ba385d0c50fe" translate="yes" xml:space="preserve">
          <source>I encountered the below and couldn't change it. I also did not want to flatten the object temporarily. Nor did I want to use underscore / lodash, mainly for performance reasons and the fun to implement it myself.</source>
          <target state="translated">以下に遭遇し、変更できませんでした。また、一時的にオブジェクトを平らにしたくなかった。また、主に性能面と自分で実装する楽しみのために、アンダースコアのロダッシュを使いたいとも思いませんでした。</target>
        </trans-unit>
        <trans-unit id="37de85c49081f9b0188ef6e799c866a4ffb94a49" translate="yes" xml:space="preserve">
          <source>I have an array of JavaScript objects:</source>
          <target state="translated">JavaScriptオブジェクトの配列を持っています。</target>
        </trans-unit>
        <trans-unit id="5ccfae868d44dc0f2309722b194930082a3e07ba" translate="yes" xml:space="preserve">
          <source>I haven't seen this particular approach suggested, so here's a terse comparison method I like to use that works for both &lt;code&gt;string&lt;/code&gt; and &lt;code&gt;number&lt;/code&gt;:</source>
          <target state="translated">この特定のアプローチが提案されたのを見たことがないので、 &lt;code&gt;string&lt;/code&gt; と &lt;code&gt;number&lt;/code&gt; 両方で機能する、簡単に使用できる比較方法を次に示します 。</target>
        </trans-unit>
        <trans-unit id="1e8a344759f3534cd3101c2256dd217071e4142d" translate="yes" xml:space="preserve">
          <source>I know about &lt;code&gt;sort(a,b)&lt;/code&gt;, but that only seems to work on strings and numbers. Do I need to add a &lt;code&gt;toString()&lt;/code&gt; method to my objects?</source>
          <target state="translated">&lt;code&gt;sort(a,b)&lt;/code&gt; については知っていますが、それは文字列と数値に対してのみ機能するようです。 オブジェクトに &lt;code&gt;toString()&lt;/code&gt; メソッドを追加する必要がありますか？</target>
        </trans-unit>
        <trans-unit id="566e004b73b9018eb725b5fdc9b8d3360d31a45b" translate="yes" xml:space="preserve">
          <source>I know this question is too old, but I didn't see any implementation similar to mine.</source>
          <target state="translated">この質問が古すぎるのは承知していますが、私のと似たような実装は見当たりませんでした。</target>
        </trans-unit>
        <trans-unit id="a1d0c8f6643e4ddc30d0b0123a0a896879200493" translate="yes" xml:space="preserve">
          <source>If you have duplicate last names you might sort those by first name-</source>
          <target state="translated">名字が重複している場合は、姓名判断でソートすることができます。</target>
        </trans-unit>
        <trans-unit id="d35b04aa4945989fb22d68c7ff3bc7cf3e4a90b5" translate="yes" xml:space="preserve">
          <source>In ES6/ES2015 or later you can do this way:</source>
          <target state="translated">ES6ES2015以降では、このような方法で行うことができます。</target>
        </trans-unit>
        <trans-unit id="961f8b9db6ec89bd40419165049dd198b8de05d3" translate="yes" xml:space="preserve">
          <source>Instead of using a custom comparison function, you could also create an object type with custom &lt;code&gt;toString()&lt;/code&gt; method (which is invoked by the default comparison function):</source>
          <target state="translated">カスタム比較関数を使用する代わりに、カスタム &lt;code&gt;toString()&lt;/code&gt; メソッド（デフォルトの比較関数によって呼び出される）を使用してオブジェクトタイプを作成することもできます。</target>
        </trans-unit>
        <trans-unit id="c479a7c903cc8488af2afc7efd5943796202691f" translate="yes" xml:space="preserve">
          <source>It's easy enough to write your own comparison function:</source>
          <target state="translated">自作の比較関数を書けば十分簡単です。</target>
        </trans-unit>
        <trans-unit id="cbc249ea4e7a82a7ec0919b9ad1d670f290a6811" translate="yes" xml:space="preserve">
          <source>It's good not to add a framework for every simple piece of logic, but relying on well tested utility frameworks can speed up development and reduce the amount of bugs.</source>
          <target state="translated">単純なロジックのすべてにフレームワークを追加しないのは良いことですが、よくテストされたユーティリティフレームワークに頼ることで、開発を迅速化し、バグの量を減らすことができます。</target>
        </trans-unit>
        <trans-unit id="0fa28edf6be4ffbdd5ff729f4a7b7c4758875b5f" translate="yes" xml:space="preserve">
          <source>Lodash produces very clean code and promotes a more &lt;em&gt;functional programming&lt;/em&gt; style. In one glimpse it becomes clear what the intent of the code is.</source>
          <target state="translated">Lodashは非常にクリーンなコードを生成し、より&lt;em&gt;機能的なプログラミング&lt;/em&gt;スタイルを促進します。 一見すると、コードの目的が何であるかが明らかになります。</target>
        </trans-unit>
        <trans-unit id="9eaf61c467f14ad9ffb044dec015f58caf257257" translate="yes" xml:space="preserve">
          <source>More info? E.g. we have following nested object:</source>
          <target state="translated">詳細は?例えば、次のような入れ子になったオブジェクトがあります。</target>
        </trans-unit>
        <trans-unit id="87c1be79d606b3383dbdf93122bd561431d64cc5" translate="yes" xml:space="preserve">
          <source>More readable format:</source>
          <target state="translated">より読みやすいフォーマット。</target>
        </trans-unit>
        <trans-unit id="7edee346283fe35e96e795f35ff5de152f58755b" translate="yes" xml:space="preserve">
          <source>Multiple Parameters</source>
          <target state="translated">複数のパラメータ</target>
        </trans-unit>
        <trans-unit id="32d560375c769eb987267a8ce3ab1529b45b7910" translate="yes" xml:space="preserve">
          <source>Negate to reverse order, &lt;code&gt;return -last_nom_order || -first_nom_order || -age_order;&lt;/code&gt;</source>
          <target state="translated">順序を逆にして、 &lt;code&gt;return -last_nom_order || -first_nom_order || -age_order;&lt;/code&gt; -first_nom_order || -age_order;</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="bcad6173433b52e269afa6bc77fb168e67f86b43" translate="yes" xml:space="preserve">
          <source>Now, in the base solution uses bracket notation to compute the properties to sort for dynamically. Here, though, we would have to construct the bracket notation dynamically also, since you would expect some like &lt;code&gt;People['Name.name']&lt;/code&gt; would work - which doesn't.</source>
          <target state="translated">現在、基本ソリューションでは、ブラケット表記を使用して、動的にソートするプロパティを計算しています。 ただし、ここでは、 &lt;code&gt;People['Name.name']&lt;/code&gt; ようなものが機能することを期待しているため、ブラケット表記も動的に構築する必要がありますが、機能しません。</target>
        </trans-unit>
        <trans-unit id="b6d5ee0e5ac2a920d1c93c741329108491c8da3b" translate="yes" xml:space="preserve">
          <source>OP's issue can simply be solved as:</source>
          <target state="translated">OPの問題は単純に次のように解けます。</target>
        </trans-unit>
        <trans-unit id="30850acd7e09351894b8aa2a56a72e2f817539ce" translate="yes" xml:space="preserve">
          <source>Obstacles</source>
          <target state="translated">Obstacles</target>
        </trans-unit>
        <trans-unit id="498de8681b478a786108557a1ace1eb28f1d9afa" translate="yes" xml:space="preserve">
          <source>Old answer that is not correct:</source>
          <target state="translated">正解のない古い答え。</target>
        </trans-unit>
        <trans-unit id="1fefd0bb4d6f3f3a8e89940a2cb000599c0c0c07" translate="yes" xml:space="preserve">
          <source>One more option:</source>
          <target state="translated">もう一つの選択肢</target>
        </trans-unit>
        <trans-unit id="ef939c1b74a04cdc71de1b2c3f68069f2fe5b389" translate="yes" xml:space="preserve">
          <source>Or inline (c/o Marco Demaio):</source>
          <target state="translated">またはインライン(coマルコ・デマイオ)。</target>
        </trans-unit>
        <trans-unit id="948128b010a72605e2fbf78fd74c54260e051ab0" translate="yes" xml:space="preserve">
          <source>Or when do you prefer &lt;a href=&quot;https://lodash.com/docs/4.17.15#flow&quot;&gt;flow&lt;/a&gt; over chain</source>
          <target state="translated">または、チェーンよりも&lt;a href=&quot;https://lodash.com/docs/4.17.15#flow&quot;&gt;フロー&lt;/a&gt;を好む場合</target>
        </trans-unit>
        <trans-unit id="4e2821849d9c08e68ccd665bf930d3ee092da12e" translate="yes" xml:space="preserve">
          <source>Prior to ES6/ES2015</source>
          <target state="translated">ES6ES2015の前に</target>
        </trans-unit>
        <trans-unit id="1baa06b4c8bc2d63f9db4d4cc86a2e2b12a7e893" translate="yes" xml:space="preserve">
          <source>Problem</source>
          <target state="translated">Problem</target>
        </trans-unit>
        <trans-unit id="c58dd6bb45a2f9ac6a218c5b7185c3d34c81b4e8" translate="yes" xml:space="preserve">
          <source>Remembering that &lt;code&gt;fn = o =&amp;gt; o.last_nom&lt;/code&gt;, we can expand the compare function to the equivalent</source>
          <target state="translated">&lt;code&gt;fn = o =&amp;gt; o.last_nom&lt;/code&gt; であることを思い出して 、compare関数を同等の関数に拡張できます。</target>
        </trans-unit>
        <trans-unit id="5822e1abe08b294040c03f0f3ce044677629caa2" translate="yes" xml:space="preserve">
          <source>Script:</source>
          <target state="translated">Script:</target>
        </trans-unit>
        <trans-unit id="2e98d736969feca005890fc917b8627988a081b3" translate="yes" xml:space="preserve">
          <source>See Commplete script in &lt;a href=&quot;http://jsfiddle.net/Gigapedia/ofd0a1nd/1/&quot;&gt;JSFiddle&lt;/a&gt;</source>
          <target state="translated">JSFiddleのCommpleteスクリプトを参照してください</target>
        </trans-unit>
        <trans-unit id="751a745af1f2295e108ecd4014fcd7b3a221ad08" translate="yes" xml:space="preserve">
          <source>See that &lt;code&gt;'.toLowerCase()'&lt;/code&gt; is necessary to prevent erros 
in comparing strings.</source>
          <target state="translated">&lt;code&gt;'.toLowerCase()'&lt;/code&gt; が文字列の比較でエラーを防ぐために必要であることを確認してください。</target>
        </trans-unit>
        <trans-unit id="49c7e143edcc42258a2f85d00fb2f5795d1a53eb" translate="yes" xml:space="preserve">
          <source>Simple and quick solution to this problem using prototype inheritance:</source>
          <target state="translated">プロトタイプの継承を利用したシンプルかつ迅速な解決策。</target>
        </trans-unit>
        <trans-unit id="3df7de60d412e815cc56b44e99351d0f6ffc3257" translate="yes" xml:space="preserve">
          <source>Simply doing &lt;code&gt;People['Name']['name']&lt;/code&gt;, on the other hand, is static and only allows you to go down the &lt;em&gt;n&lt;/em&gt;-th level.</source>
          <target state="translated">一方、 &lt;code&gt;People['Name']['name']&lt;/code&gt; 実行するだけでは静的であり、 &lt;em&gt;n&lt;/em&gt;番目のレベルにのみ進むことができます。</target>
        </trans-unit>
        <trans-unit id="1e4ab52faf107ee7c0249a954a4ed3dd4cff785d" translate="yes" xml:space="preserve">
          <source>Since you probably encounter more complex data structures like this array, I would expand the solution.</source>
          <target state="translated">おそらく、この配列のようなより複雑なデータ構造に遭遇すると思いますので、私はこのソリューションを拡張します。</target>
        </trans-unit>
        <trans-unit id="7d686476427025af3329f7d68422a05f50b1bcb2" translate="yes" xml:space="preserve">
          <source>So you can have an array of objects like this:</source>
          <target state="translated">このようにオブジェクトの配列を持つことができるわけですね。</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="109909121526dfa21cfc07a8f678954b7329a7ed" translate="yes" xml:space="preserve">
          <source>Sort array of objects by string property value</source>
          <target state="translated">オブジェクトの配列を文字列プロパティの値でソートします。</target>
        </trans-unit>
        <trans-unit id="dc4d28dec474ab397c30be8f3db0103e8f0c364c" translate="yes" xml:space="preserve">
          <source>Sort by multiple fields:</source>
          <target state="translated">複数のフィールドでソートします。</target>
        </trans-unit>
        <trans-unit id="f3502d6e64d1a7822b2b62f5b927220903c45ba7" translate="yes" xml:space="preserve">
          <source>Sorting (more) Complex Arrays of Objects</source>
          <target state="translated">オブジェクトの複雑な配列の並べ替え</target>
        </trans-unit>
        <trans-unit id="59c9e0733121e83769900d1cba9c0d364484136b" translate="yes" xml:space="preserve">
          <source>Subclassing Array</source>
          <target state="translated">配列のサブクラス化</target>
        </trans-unit>
        <trans-unit id="55a8cf52465cdc91b6aab717d8f7d031a34fc9d5" translate="yes" xml:space="preserve">
          <source>Subtraction works on numeric fields: &lt;code&gt;var age_order = left.age - right.age;&lt;/code&gt;</source>
          <target state="translated">減算は数値フィールドで機能します &lt;code&gt;var age_order = left.age - right.age;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97e39b6af24502016b3d55f9dc3afd1f7213fc53" translate="yes" xml:space="preserve">
          <source>Swap the operator to have it sorted by reverse alphabetical order.</source>
          <target state="translated">演算子を入れ替えて、アルファベットの逆順でソートさせる。</target>
        </trans-unit>
        <trans-unit id="5ff57f4185e884322f43c9c59da60f12f41285ea" translate="yes" xml:space="preserve">
          <source>TL;DR</source>
          <target state="translated">TL;DR</target>
        </trans-unit>
        <trans-unit id="df8a4e60130779519de7ad68f7d5180c53c0743b" translate="yes" xml:space="preserve">
          <source>That would enable this:</source>
          <target state="translated">それが可能になる</target>
        </trans-unit>
        <trans-unit id="94d79b95d0c489e5bbcb12f8d364863f7a362261" translate="yes" xml:space="preserve">
          <source>The goal is to sort it primarily by &lt;code&gt;People.Name.name&lt;/code&gt; and secondarily by &lt;code&gt;People.Name.surname&lt;/code&gt;</source>
          <target state="translated">目標は、主に &lt;code&gt;People.Name.name&lt;/code&gt; でソートし、 次にPeople.Name.surnameでソートすること &lt;code&gt;People.Name.surname&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="082acbdad9772f5f5be439c6315685ecc4157047" translate="yes" xml:space="preserve">
          <source>The logical OR &lt;code&gt;||&lt;/code&gt; operator has a short-circuiting functionality that's very useful here. Because of how it works, the body of the function above means</source>
          <target state="translated">論理OR &lt;code&gt;||&lt;/code&gt; 演算子には、ここで非常に役立つ短絡機能があります。 それがどのように機能するかにより、上記の関数の本体は</target>
        </trans-unit>
        <trans-unit id="9609c6d9ea33fa99a452cd0c94aa46eb50331dfe" translate="yes" xml:space="preserve">
          <source>The main addition here will be to walk down the object tree and determine the value of the last leaf, you have to specify, as well as any intermediary leaf.</source>
          <target state="translated">ここでの主な追加は、オブジェクトツリーを歩いて、最後のリーフの値を決定することになります、あなたが指定しなければならない、任意の中間リーフと同様に。</target>
        </trans-unit>
        <trans-unit id="a021612bae9941142ad365b346f4d4f2e54d2228" translate="yes" xml:space="preserve">
          <source>The point here is that pure JavaScript with functional approach can take you a long way without external libraries or complex code. It is also very effective, since no string parsing have to be done</source>
          <target state="translated">ここでのポイントは、機能的なアプローチを持つ純粋なJavaScriptであれば、外部ライブラリや複雑なコードがなくても、長い道のりを歩むことができるということです。また、文字列の解析を行う必要がないので、非常に効果的です。</target>
        </trans-unit>
        <trans-unit id="3f3da28278b977bb99aab14aa8c822c9b8400fd4" translate="yes" xml:space="preserve">
          <source>There are many good answers here, but I would like to point out that they can be extended very simply to achieve a lot more complex sorting. The only thing you have to do is to use the OR operator to chain comparision functions like this:</source>
          <target state="translated">ここには多くの良い答えがありますが、私が指摘したいのは、それらを非常に簡単に拡張して、より複雑なソートを実現することができるということです。このようにOR演算子を使って比較関数を連鎖させるだけです。</target>
        </trans-unit>
        <trans-unit id="89bef63538bc26f3472cb4e1de8788758df3a06b" translate="yes" xml:space="preserve">
          <source>This function could be extended to support numeric fields, case sensitity, arbitary datatypes etc.</source>
          <target state="translated">この関数は、数値フィールド、大文字小文字の区別、任意のデータ型などをサポートするように拡張することができます。</target>
        </trans-unit>
        <trans-unit id="afa086a2b78cf51cf24d0b8a68e401404e3c4c1f" translate="yes" xml:space="preserve">
          <source>This is a simple problem, don't know why people have such complex solution.</source>
          <target state="translated">これは単純な問題ですが、なぜ人々はそのような複雑な解決策を持っているかわからない。</target>
        </trans-unit>
        <trans-unit id="7b6c936e71d894731b069593df937870837eca90" translate="yes" xml:space="preserve">
          <source>This method is like _.sortBy except that it allows specifying the sort orders of the iteratees to sort by. If orders is unspecified, all values are sorted in ascending order. Otherwise, specify an order of &quot;desc&quot; for descending or &quot;asc&quot; for ascending sort order of corresponding values.</source>
          <target state="translated">このメソッドは _.sortBy と似ていますが、ソートするイテレータのソート順を指定できる点が異なります。ordersが指定されていない場合は、すべての値が昇順でソートされます。それ以外の場合は、値の降順には &quot;desc&quot;、昇順には &quot;asc &quot;を指定します。</target>
        </trans-unit>
        <trans-unit id="f951f5d768047fe6faaa6c8d66ca0dc5ebe9f893" translate="yes" xml:space="preserve">
          <source>This solution is based on the behaviour of &lt;code&gt;||&lt;/code&gt; operator which evaluates to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Logical_operators&quot;&gt;first evaluated expression which can be converted to true&lt;/a&gt;.</source>
          <target state="translated">このソリューションは、 &lt;code&gt;||&lt;/code&gt; の動作に基づいています。 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Logical_operators&quot;&gt;trueに変換できる最初に評価された式に&lt;/a&gt;評価される演算子。</target>
        </trans-unit>
        <trans-unit id="b7f248cb4e5c51d10f2cf342d2205f0fa91120cd" translate="yes" xml:space="preserve">
          <source>This version is based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartzian_transform&quot;&gt;Schwartzian transform idiom&lt;/a&gt;.</source>
          <target state="translated">このバージョンは、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Schwartzian_transform&quot;&gt;シュワルツ変換イディオムに&lt;/a&gt;基づいています。</target>
        </trans-unit>
        <trans-unit id="22ac867f198bbe668d95c95b88030a5c57f55991" translate="yes" xml:space="preserve">
          <source>Try this example &lt;a href=&quot;http://jsfiddle.net/agershun/4f4Lr9ss/1/&quot;&gt;at jsFiddle&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://jsfiddle.net/agershun/4f4Lr9ss/1/&quot;&gt;jsFiddleで&lt;/a&gt;この例を試してください。</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="c4ec0e92ea2bb00ad4f3298da1ca66ad3ac5bf51" translate="yes" xml:space="preserve">
          <source>Use example:</source>
          <target state="translated">例を使ってください。</target>
        </trans-unit>
        <trans-unit id="080aea69ed0585f6c9c95ab405ff44fbeb0fb543" translate="yes" xml:space="preserve">
          <source>Using Ramda,</source>
          <target state="translated">ラムダを使って</target>
        </trans-unit>
        <trans-unit id="a18e4f510ee6d8aeee1db615bda7fa45c9e3e333" translate="yes" xml:space="preserve">
          <source>Want it reversed? No problem. Use &lt;a href=&quot;https://lodash.com/docs/4.17.15#reverse&quot;&gt;_.reverse&lt;/a&gt;.</source>
          <target state="translated">逆にしたいですか？ 問題ない。 &lt;a href=&quot;https://lodash.com/docs/4.17.15#reverse&quot;&gt;_.reverseを&lt;/a&gt;使用します 。</target>
        </trans-unit>
        <trans-unit id="7fbd54bfb0efab47f14ced5f46b0a92322af15cd" translate="yes" xml:space="preserve">
          <source>Want to combine both using &lt;a href=&quot;https://lodash.com/docs/4.17.15#chain&quot;&gt;chain&lt;/a&gt;?</source>
          <target state="translated">&lt;a href=&quot;https://lodash.com/docs/4.17.15#chain&quot;&gt;チェーン&lt;/a&gt;を使用して両方を組み合わせたいですか？</target>
        </trans-unit>
        <trans-unit id="7f5038cff32d1a4e74bb009ed2f4b5fff77c22c4" translate="yes" xml:space="preserve">
          <source>We now can use the &lt;a href=&quot;https://lodash.com/docs/4.17.15#property&quot;&gt;_.property&lt;/a&gt; shorthand &lt;code&gt;user.age&lt;/code&gt; to specify the path to the property that should be matched. We will sort the user objects by the nested age property. Yes, it allows for nested property matching!</source>
          <target state="translated">これで、 &lt;a href=&quot;https://lodash.com/docs/4.17.15#property&quot;&gt;_。property&lt;/a&gt;省略形 &lt;code&gt;user.age&lt;/code&gt; を使用して、 照合するプロパティへのパスを指定できます。 ネストされたageプロパティでユーザーオブジェクトを並べ替えます。 はい、ネストされたプロパティマッチングが可能です！</target>
        </trans-unit>
        <trans-unit id="19b758444752a4dcb43c1647fa85e1bff81f02f1" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;fn1&lt;/code&gt;, &lt;code&gt;fn2&lt;/code&gt;, ... are the sort functions which return [-1,0,1]. This results in &quot;sorting by fn1&quot;, &quot;sorting by fn2&quot; which is pretty much equal to ORDER BY in SQL.</source>
          <target state="translated">ここで、 &lt;code&gt;fn1&lt;/code&gt; 、 &lt;code&gt;fn2&lt;/code&gt; 、...は[-1,0,1]を返すソート関数です。 これにより、「fn1によるソート」、「fn2によるソート」が発生します。これは、SQLのORDER BYとほぼ同じです。</target>
        </trans-unit>
        <trans-unit id="690becf4a80f0f5937c7bc25b8d202728a7a121c" translate="yes" xml:space="preserve">
          <source>Which would enable you to do something like this:</source>
          <target state="translated">これでこんなことが可能になります。</target>
        </trans-unit>
        <trans-unit id="e097110f8fbf6f7e12eb57ff825177af95ad6701" translate="yes" xml:space="preserve">
          <source>Without nested ternaries:</source>
          <target state="translated">入れ子になった三項演算子なし。</target>
        </trans-unit>
        <trans-unit id="1f3a8961cc3c0dfbac1f833f2f6ab188fb0ae542" translate="yes" xml:space="preserve">
          <source>Working example &lt;a href=&quot;http://jsbin.com/lotifa/2/edit?js,console&quot;&gt;on JSBin&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://jsbin.com/lotifa/2/edit?js,console&quot;&gt;JSBinの&lt;/a&gt;作業例</target>
        </trans-unit>
        <trans-unit id="c0a34fb6db23fd9ae9f6ec32649177b251cff0df" translate="yes" xml:space="preserve">
          <source>You can also create a dynamic sort function that sorts objects by their value that you pass:</source>
          <target state="translated">また、渡した値によってオブジェクトをソートする動的なソート関数を作成することもできます。</target>
        </trans-unit>
        <trans-unit id="da067ddfca6e878291ec7eaf398f4688e75afb77" translate="yes" xml:space="preserve">
          <source>You can them use it with chaining them by sort priority:</source>
          <target state="translated">ソートの優先順位で連鎖させて使うことができます。</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">を使用することができます。</target>
        </trans-unit>
        <trans-unit id="8aaf0966ca9de88ed00423893c6750e302bc72b1" translate="yes" xml:space="preserve">
          <source>You can use the function below to generate sort functions with multiple sort parameters.</source>
          <target state="translated">以下の関数を使用して、複数のソートパラメータを持つソート関数を生成することができます。</target>
        </trans-unit>
        <trans-unit id="eaa79b08656dd826605fddb4561d504870a33325" translate="yes" xml:space="preserve">
          <source>You may need to convert them to the lower case in order to prevent from confusion.</source>
          <target state="translated">混乱を防ぐため、小文字に変換する必要があるかもしれません。</target>
        </trans-unit>
        <trans-unit id="bc7c5e2dd156919b34965a95a543881ff61e72e7" translate="yes" xml:space="preserve">
          <source>additional desc params for &lt;strong&gt;Ege &amp;Ouml;zcan&lt;/strong&gt; code</source>
          <target state="translated">&lt;strong&gt;Ege&amp;Ouml;zcan&lt;/strong&gt;コードの追加のdescパラメータ</target>
        </trans-unit>
        <trans-unit id="cffa50a32cb13a240d705317bcec65dd1f31b6ad" translate="yes" xml:space="preserve">
          <source>and</source>
          <target state="translated">and</target>
        </trans-unit>
        <trans-unit id="14d76e0ea677b53536f0e1bcd8e4402905430049" translate="yes" xml:space="preserve">
          <source>and changed &lt;strong&gt;_dynamicSort&lt;/strong&gt;'s &lt;em&gt;return&lt;/em&gt; function:</source>
          <target state="translated">&lt;strong&gt;_dynamicSort&lt;/strong&gt;の&lt;em&gt;戻り&lt;/em&gt;関数を変更し&lt;strong&gt;ました&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="583c8146c0fd7636650ae88381ba9b1747e52ec5" translate="yes" xml:space="preserve">
          <source>and if you want to sort it over &lt;strong&gt;a.a&lt;/strong&gt; property I think my enhancement helps very well. I add new functionality to objects like this:</source>
          <target state="translated">プロパティで並べ替える場合は、私の拡張機能が非常に役立つと思います。 このようなオブジェクトに新しい機能を追加します。</target>
        </trans-unit>
        <trans-unit id="1f59fa9a439467f6503baeffe55c3ea31faf4f52" translate="yes" xml:space="preserve">
          <source>collection (Array|Object): The collection to iterate over.
[iteratees=[_.identity]] (Array[]|Function[]|Object[]|string[]): The iteratees to sort by.
[orders] (string[]): The sort orders of iteratees.</source>
          <target state="translated">Object):The collection to iterate over.[iteratees=[_.identity]](Array[]</target>
        </trans-unit>
        <trans-unit id="d6423b40a11bcee12314b6ccef031813c2cdb209" translate="yes" xml:space="preserve">
          <source>sortBy_.sortBy(list, iterator, [context])  Returns a sorted copy of
  list, ranked in ascending order by the results of running each value
  through iterator. Iterator may also be the string name of the property
  to sort by (eg. length).</source>
          <target state="translated">sortBy_.sortBy(list,iterator,[context])リストのソート済みコピーを返します。イテレータには、ソートするプロパティの文字列名 (例えば length)を指定することもできます。</target>
        </trans-unit>
        <trans-unit id="6e6af4a6f6b8dd020ff1ccc161165eca878ae248" translate="yes" xml:space="preserve">
          <source>sorts ascending by default.</source>
          <target state="translated">はデフォルトでは昇順にソートします。</target>
        </trans-unit>
        <trans-unit id="bce3a219b7462cbfc0c0086b83fd33ffe4a24372" translate="yes" xml:space="preserve">
          <source>to compare them.</source>
          <target state="translated">で比較してみてください。</target>
        </trans-unit>
        <trans-unit id="e20673804c9f90b32d81557d7cd06d6ac501919d" translate="yes" xml:space="preserve">
          <source>underscore.js</source>
          <target state="translated">underscore.js</target>
        </trans-unit>
        <trans-unit id="c285e07a2de39b6fbee1c5def3798517aaa7efe1" translate="yes" xml:space="preserve">
          <source>use underscore, its small and awesome...</source>
          <target state="translated">アンダースコアを使用して、その小さくて素晴らしい...</target>
        </trans-unit>
        <trans-unit id="18cbf375a546dc39d742dd985d70e5999b401a29" translate="yes" xml:space="preserve">
          <source>we use</source>
          <target state="translated">使う</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
