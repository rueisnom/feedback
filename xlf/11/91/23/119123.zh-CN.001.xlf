<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/119123">
    <body>
      <group id="119123">
        <trans-unit id="ea7c1d190a3bb5944cb0b253e4ec0b66b24d634d" translate="yes" xml:space="preserve">
          <source>&quot;memory holes&quot; size included in the result of sizeof operator. The sizeof only doesn't include size of the flexible array, which is available in C/C++</source>
          <target state="translated">&quot;内存孔 &quot;大小包含在sizeof操作符的结果中。仅sizeof不包括灵活数组的大小,在CC++中,灵活数组的大小是可用的。</target>
        </trans-unit>
        <trans-unit id="5e2a1eeaafd0038588279f1b10325b005bf97c7f" translate="yes" xml:space="preserve">
          <source>13 ... There may be unnamed
  padding within a structure object, but not at its beginning.</source>
          <target state="translated">13......结构对象内可能有未命名的填充物,但在结构对象的起始处没有。</target>
        </trans-unit>
        <trans-unit id="3a613654ca642a6d6767394e0d27f74611b755db" translate="yes" xml:space="preserve">
          <source>15 There may be unnamed padding at the end of a structure or union.</source>
          <target state="translated">15 在结构或联合体末端可能有未命名的填充物。</target>
        </trans-unit>
        <trans-unit id="e2d0e33ec380d07996b4f8bc86ea785141c22b59" translate="yes" xml:space="preserve">
          <source>16 As a special case, the last element of a structure with more than one named member may
  have an incomplete array type; this is called a flexible array member. In most situations,
  the flexible array member is ignored. In particular, the size of the structure is as if the
  flexible array member were omitted except that it may have more trailing padding than
  the omission would imply.</source>
          <target state="translated">16 作为一种特殊情况,一个有多个命名成员的结构的最后一个元素可能有一个不完整的数组类型;这被称为弹性数组成员。在大多数情况下,弹性数组成员被忽略。特别是,结构的大小就像省略了弹性数组成员一样,只是它的尾部填充量可能比省略的时候多。</target>
        </trans-unit>
        <trans-unit id="414bb92964f7ecfad2604e92821062f2dac17ee9" translate="yes" xml:space="preserve">
          <source>2 When applied
  to a class, the result is the number of bytes in an object of that class including any padding required for
  placing objects of that type in an array.</source>
          <target state="translated">2 当应用到一个类时,结果是该类的对象中的字节数,包括将该类型的对象放在数组中所需的填充量。</target>
        </trans-unit>
        <trans-unit id="6486cec944fa9f9b2c41ecd5df485da4ac35f4f6" translate="yes" xml:space="preserve">
          <source>3 When applied to an operand that has structure or union type,
  the result is the total number of bytes in such an object,
  including internal and trailing padding.</source>
          <target state="translated">3 当应用于具有结构类型或联合类型的操作条时,结果是这样一个对象的总字节数,包括内部和尾部填充。</target>
        </trans-unit>
        <trans-unit id="aaf36019e7beaa5a1dc4358651e76a80f0f859e0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;5.3.3 Sizeof&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;5.3.3 Sizeof&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f80c22edb72b0170a8c7a0c869a36093f9988bf4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;6.5.3.4 The sizeof operator&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;6.5.3.4 sizeof运算符&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="21a6950949f9380e1a80fd038021e59aace62bc7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;6.7.2.1 Structure and union specifiers&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;6.7.2.1结构和联合说明符&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c188ad2443c540567c7c8daa7cb2648fb19b97d4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;9.2 Class members&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;9.2班级成员&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abf975a1f9f225f38e7cef1f183b3da09c979010" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Annex J Portability Issues&lt;/em&gt; reiterates:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;附件J可移植性问题&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重申：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="377bd7d244fc6b72e96059fb9cb766841edd1758" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;TL;DR:&lt;/em&gt; alignment is important.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TL; DR：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对齐很重要。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9fa5697a62922f95e3c60e9368cd06101ac9527b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C language leaves compiler some freedom about the location of the structural elements in the memory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C语言为编译器提供了一些有关内存中结构元素位置的自由度：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a886700572b9c57d6d491254156f6437d6d04fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11 N3337 standard draft&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11 N3337标准草案&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fd7453bed259332b62ae40bd66abc3750697afe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C99 N1256 standard draft&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99 N1256标准草案&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d146a42b33f5eb7eee5f1ff1d6e895f68382d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How alignment works:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对齐方式如何工作：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee4d41c0c55cf4eaa96f769b13f7cb0313a1edf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problems related to the elements alignment:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与元素对齐有关的问题：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="26078666e7e6283d98fb3cd8206541206faed3f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The C language provides some assurance to the programmer of the elements layout in the structure:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C语言为程序员提供了结构中元素布局的一些保证：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08001831948aa1e7c2fcc0fae1677699501a9e43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You need to have good reasons to change it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您需要有充分的理由进行更改。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc6c36591832366db6e1e320835a5a82435c7f21" translate="yes" xml:space="preserve">
          <source>A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its
  initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note:
  There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning,
  as necessary to achieve appropriate alignment. &amp;mdash; end note ]</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指向标准布局结构对象的指针（使用reinterpret_cast进行了适当的转换）指向其初始成员（或者，如果该成员是位字段，则指向其驻留的单元），反之亦然。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;[注意：因此，在标准布局结构对象中可能会存在未命名的填充，但在其开始处可能没有，这是实现适当对齐所必需的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;mdash;尾注]&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d0aab459ec3221328ef34032b641bed6c8e7308" translate="yes" xml:space="preserve">
          <source>Address of the first component coincides with the start address of the structure</source>
          <target state="translated">第一个组件的地址与结构的起始地址一致。</target>
        </trans-unit>
        <trans-unit id="ccbd2e21cfcc46e0e9d663d870a070b41c7d2362" translate="yes" xml:space="preserve">
          <source>Also a library may be compiled under x86 with 32-bit ints and you may be comparing its components on a 64-bit process would would give you a different result if you were doing this by hand.</source>
          <target state="translated">另外,一个库可能是在x86下用32位ints编译的,你可能会在64位进程上比较它的组件,如果你用手来做的话,会得到不同的结果。</target>
        </trans-unit>
        <trans-unit id="4f7afdabaf1875c8c3d894b087ea225e9b39d84e" translate="yes" xml:space="preserve">
          <source>But it's much, much easier on the processor if the compiler arranges
  it like this:</source>
          <target state="translated">但如果编译器是这样安排的,对处理器来说就容易多了。</target>
        </trans-unit>
        <trans-unit id="942fdac75ab408f0da705c35d5ba37390764f845" translate="yes" xml:space="preserve">
          <source>Computers differ on how to store the bytes in a word (Intel 80x86 and Motorola 68000)</source>
          <target state="translated">计算机在存储字节的方式上存在差异(英特尔80x86和摩托罗拉68000)。</target>
        </trans-unit>
        <trans-unit id="604bde069a55581721b9d22581417c64232f332a" translate="yes" xml:space="preserve">
          <source>Different computers line the edges of objects in different ways</source>
          <target state="translated">不同的计算机以不同的方式对物体的边缘划线</target>
        </trans-unit>
        <trans-unit id="9d956ba7ff3840f2bab2c9e6daeb95400655a424" translate="yes" xml:space="preserve">
          <source>Different restrictions on the width of the bit field</source>
          <target state="translated">对位域宽度的不同限制</target>
        </trans-unit>
        <trans-unit id="4fab0d756aeaaafa4d8a6d6e1128251336f7627d" translate="yes" xml:space="preserve">
          <source>Either corrected in hardware, for a modest performance-degradation.</source>
          <target state="translated">要么在硬件上进行修正,适度的性能降级。</target>
        </trans-unit>
        <trans-unit id="d95360439bed52475c90194b8b2cbab73ee89644" translate="yes" xml:space="preserve">
          <source>Finally, note that cache lines can be arbitrarily large, and the compiler doesn't attempt to guess at those or make a space-vs-speed tradeoff. Instead, the alignment decisions are part of the ABI and represent the minimum alignment that will eventually evenly fill up a cache line.</source>
          <target state="translated">最后,请注意,缓存行可以是任意大的,编译器不会试图去猜测这些行,也不会去做空间与速度的权衡。相反,对齐决定是ABI的一部分,代表了最终会均匀填满缓存线的最小对齐方式。</target>
        </trans-unit>
        <trans-unit id="ce0b0e3b463737dec1f994b52eb1aa91d0e6fd2d" translate="yes" xml:space="preserve">
          <source>For example.  Consider the simple structure:</source>
          <target state="translated">比如说。考虑简单的结构。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="016c76e5c39673125f64e48a16c383be180081f4" translate="yes" xml:space="preserve">
          <source>Have members who's sizes (in bytes) are 4 bytes (32 bits), 8 bytes (2x 32 bits) and 1 byte (2+6 bits) respectively.  The above program (on Linux using gcc) prints the sizes as 4, 8, and 4 - where the last structure is padded so that it is a single word (4 x 8 bit bytes on my 32bit platform).</source>
          <target state="translated">有一个成员的大小(以字节为单位)分别是4字节(32位)、8字节(2x32位)和1字节(2+6位)。上面的程序(在Linux上使用gcc)将大小打印为4,8,和4--其中最后一个结构被填充,所以它是一个单字(在我的32位平台上是4 x 8位字节)。</target>
        </trans-unit>
        <trans-unit id="16e342eef65fa14dd4d6fc2bf54314327cdc559a" translate="yes" xml:space="preserve">
          <source>Here's an example using typical settings for an x86 processor (all used 32 and 64 bit modes):</source>
          <target state="translated">下面是一个使用x86处理器的典型设置的例子(均为32位和64位模式)。</target>
        </trans-unit>
        <trans-unit id="b8e72a837533fa3fdedba99cab0b561c4d002f62" translate="yes" xml:space="preserve">
          <source>I only know enough C++ to understand the note :-)</source>
          <target state="translated">我只知道足够多的C++来理解注释:-)</target>
        </trans-unit>
        <trans-unit id="f3e48a60aeb815a325f337b288e38ee3446848a4" translate="yes" xml:space="preserve">
          <source>I should now have the length of 11.  Without the pragma, I could be anything from 11 to 14 (and for some systems, as much as 32), depending on the default packing of the compiler.</source>
          <target state="translated">我现在的长度应该是11,如果没有了这个pragma,我可以从11到14(对于某些系统来说,可以达到32),这取决于编译器的默认打包。</target>
        </trans-unit>
        <trans-unit id="e2ec884c97791749c41744efb39836e58381495c" translate="yes" xml:space="preserve">
          <source>I'm quite sure &lt;strong&gt;member-order &lt;em&gt;is&lt;/em&gt; guaranteed in C&lt;/strong&gt;, but I wouldn't count on it, when writing a cross-platform or cross-compiler program.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我非常确定&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C中&lt;/font&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以&lt;/font&gt;&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;保证&lt;/font&gt;&lt;/strong&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;成员顺序&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，但是在编写跨平台或交叉编译器程序时，我不会指望它。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="294eaa44c9c9070356fdb5156a7a6c6f5c27332e" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: Both the C and C++ standards state that structure alignment is implementation-defined.  Therefore each compiler may choose to align data differently, resulting in different and incompatible data layouts.  For this reason, when dealing with libraries that will be used by different compilers, it is important to understand how the compilers align data.  Some compilers have command-line settings and/or special &lt;code&gt;#pragma&lt;/code&gt; statements to change the structure alignment settings.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重要说明：C和C ++标准均声明结构对齐方式是实现定义的。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，每个编译器可能选择不同地对齐数据，从而导致不同且不兼容的数据布局。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，在处理将由不同编译器使用的库时，了解编译器如何对齐数据非常重要。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一些编译器具有命令行设置和/或特殊的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;#pragma&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;语句以更改结构对齐设置。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8f55e5a98bbf66b8be5db53541346322d59f2a53" translate="yes" xml:space="preserve">
          <source>If the machine is a 32-bit machine and data is aligned on a 32-bit boundary, we see an immediate problem (assuming no structure alignment).  In this example, let us assume that the structure data starts at address 1024 (0x400 - note that the lowest 2 bits are zero, so the data is aligned to a 32-bit boundary).  The access to data.a will work fine because it starts on a boundary - 0x400.  The access to data.b will also work fine, because it is at address 0x404 - another 32-bit boundary.  But an unaligned structure would put data.c at address 0x405.  The 4 bytes of data.c are at 0x405, 0x406, 0x407, 0x408.  On a 32-bit machine, the system would read data.c during one memory cycle, but would only get 3 of the 4 bytes (the 4th byte is on the next boundary).  So, the system would have to do a second memory access to get the 4th byte,</source>
          <target state="translated">如果机器是32位的机器,数据在32位边界上对齐,我们看到一个直接的问题(假设没有结构对齐)。在这个例子中,让我们假设结构数据从地址1024开始(0x400--注意,最低的2位是0,所以数据对齐到32位边界)。对data.a的访问可以正常工作,因为它从一个边界--0x400开始。对data.b的访问也可以正常工作,因为它位于地址0x404---另一个32位边界。但是一个不对齐的结构会把data.c放在地址0x405。data.c的4个字节分别位于0x405、0x406、0x406、0x407、0x408。在32位机器上,系统将在一个内存周期内读取data.c,但只能得到4个字节中的3个字节(第4个字节在下一个边界)。因此,系统必须进行第二次内存访问才能得到第4个字节。</target>
        </trans-unit>
        <trans-unit id="bccaf1969a6bb184c03be12d89b4357316a42879" translate="yes" xml:space="preserve">
          <source>If you want the structure to have a certain size with GCC for example use &lt;a href=&quot;http://digitalvampire.org/blog/index.php/2006/07/31/why-you-shouldnt-use-__attribute__packed/&quot;&gt;&lt;code&gt;__attribute__((packed))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，如果要让GCC具有特定大小的结构，请使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://digitalvampire.org/blog/index.php/2006/07/31/why-you-shouldnt-use-__attribute__packed/&quot;&gt; &lt;code&gt;__attribute__((packed))&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="deb7d9021009a9e869a35d0946526f7b0aeab08c" translate="yes" xml:space="preserve">
          <source>In addition to the other answers, a struct can (but usually doesn't) have virtual functions, in which case the size of the struct will also include the space for the vtbl.</source>
          <target state="translated">除了其他答案外,一个结构可以(但通常不会)有虚拟函数,在这种情况下,结构的大小也将包括vtbl的空间。</target>
        </trans-unit>
        <trans-unit id="ecdc60512add6ea34f6cbca0736e5590bbeb5481" translate="yes" xml:space="preserve">
          <source>In addition to the previous answers, please note that regardless the packaging, &lt;strong&gt;there is no members-order-guarantee in C++&lt;/strong&gt;. Compilers may (and certainly do) add virtual table pointer and base structures' members to the structure. Even the existence of virtual table is not ensured by the standard (virtual mechanism implementation is not specified) and therefore one can conclude that such guarantee is just impossible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;除了前面的答案外，请注意，无论包装如何&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，C ++中都没有member-order-guarantee&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编译器可以（当然可以）将虚拟表指针和基本结构的成员添加到该结构中。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该标准甚至无法确保虚拟表的存在（未指定虚拟机制的实现），因此可以得出这样的保证是根本不可能的。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1165438f2f662510c6a05ae168ff5e92e07c7d9" translate="yes" xml:space="preserve">
          <source>In addition, atomicity and other concurrency-guarantees might be broken, leading to subtle errors.</source>
          <target state="translated">此外,原子性和其他并发保证可能会被打破,导致微妙的错误。</target>
        </trans-unit>
        <trans-unit id="ace871547625d99f1b3513de67ddbf1ecd1ed28f" translate="yes" xml:space="preserve">
          <source>In the packed version, notice how it's at least a little bit hard for
  you and me to see how the b and c fields wrap around? In a nutshell,
  it's hard for the processor, too. Therefore, most compilers will pad
  the structure (as if with extra, invisible fields) like this:</source>
          <target state="translated">在打包的版本中,注意到了吗,至少你和我看B字段和C字段是怎么包起来的,至少有点难?一言以蔽之,这对处理器来说也很难。因此,大多数编译器都会像这样在结构中填充(好像是用额外的、不可见的字段)。</target>
        </trans-unit>
        <trans-unit id="6387af3b2046a0f60a53cd633291987de3402796" translate="yes" xml:space="preserve">
          <source>It can do so if you have implicitly or explicitly set the alignment of the struct. A struct that is aligned 4 will always be a multiple of 4 bytes even if the size of its members would be something that's not a multiple of 4 bytes.</source>
          <target state="translated">如果你隐式或显式地设置了结构的对齐方式,它就可以这样做。一个对齐为 4 的结构,即使其成员的大小不是 4 字节的倍数,也永远是 4 字节的倍数。</target>
        </trans-unit>
        <trans-unit id="3ebd1a765829877290c265b234786e66158f299f" translate="yes" xml:space="preserve">
          <source>It's for alignment. Many processors can't access 2- and 4-byte
  quantities (e.g. ints and long ints) if they're crammed in
  every-which-way.</source>
          <target state="translated">这是为了对齐。很多处理器无法访问2字节和4字节的量(如ints和长ints),如果它们被挤在每一个which-way中,就无法访问。</target>
        </trans-unit>
        <trans-unit id="c2689f2719ba1b44a9adf74baccfccbd020a7e67" translate="yes" xml:space="preserve">
          <source>Mis-aligned access might be a hard error (often &lt;code&gt;SIGBUS&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对齐错误的访问可能是一个硬错误（通常是&lt;/font&gt;&lt;/font&gt; &lt;code&gt;SIGBUS&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3a118237ea1794dca6417aa40286dd801d9cf4ae" translate="yes" xml:space="preserve">
          <source>Mis-aligned access might be a soft error.</source>
          <target state="translated">错位访问可能是软性错误。</target>
        </trans-unit>
        <trans-unit id="513a0a6fb061f5730b3144ab01c46ffceaf5a848" translate="yes" xml:space="preserve">
          <source>Now, if instead of putting data.c at address 0x405, the compiler padded the structure by 3 bytes and put data.c at address 0x408, then the system would only need 1 cycle to read the data, cutting access time to that data element by 50%.  Padding swaps memory efficiency for processing efficiency.  Given that computers can have huge amounts of memory (many gigabytes), the compilers feel that the swap (speed over size) is a reasonable one.</source>
          <target state="translated">现在,如果编译器不将data.c放在地址0x405,而是将结构中的数据填充3个字节,并将data.c放在地址0x408,那么系统只需要1个周期来读取数据,这样可以减少50%的访问时间。Padding以内存效率换取了处理效率。考虑到计算机可以拥有大量的内存(很多千兆字节),编译器觉得交换(速度大于大小)是一个合理的交换。</target>
        </trans-unit>
        <trans-unit id="c02ec6a18a5ab1ca633a0e2b2293f779e6729575" translate="yes" xml:space="preserve">
          <source>Now, you might think that it ought to be possible to pack this
  structure into memory like this:</source>
          <target state="translated">现在,你可能会想,应该可以把这种结构打包成这样的记忆。</target>
        </trans-unit>
        <trans-unit id="32a8824f2732921a3dc9ac7db52b26ca85ce9b0d" translate="yes" xml:space="preserve">
          <source>On Windows you can set the alignment to one byte when using the cl.exe compier with the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xh3e3fd0(VS.80).aspx&quot;&gt;/Zp option&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在Windows上，将cl.exe编译器与&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xh3e3fd0(VS.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;/ Zp选项&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一起使用时，可以将对齐方式设置为一个字节&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a3668a1ac342860ec9ca845b4c68d75816f250d2" translate="yes" xml:space="preserve">
          <source>On the other hand, different compilers have different abilities to manage data structure packing.  For example, in Visual C/C++ the compiler supports the #pragma pack command.  This will allow you to adjust data packing and alignment.</source>
          <target state="translated">另一方面,不同的编译器在管理数据结构打包方面有不同的能力。例如,在Visual CC++中,编译器支持#pragma pack命令。这将允许你调整数据打包和对齐。</target>
        </trans-unit>
        <trans-unit id="88ee5aad6a5759dd6df5e6b7f54b322f1e3d1a19" translate="yes" xml:space="preserve">
          <source>One can minimize the size of structures by sorting members by alignment (sorting by size suffices for that in basic types) (like structure &lt;code&gt;Z&lt;/code&gt; in the example above).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以通过按对齐方式对成员进行排序（按基本类型中的大小进行排序）来最小化结构的大小（类似于&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上面示例中的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;结构&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Z&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b2051d9503bb13db117acc5804d15184f6ad617" translate="yes" xml:space="preserve">
          <source>Or corrected by emulation in software, for a severe performance-degradation.</source>
          <target state="translated">或者通过软件中的仿真修正,对于严重的性能下降,。</target>
        </trans-unit>
        <trans-unit id="1a61f3cc584a463a50abd933541448f7a1510020" translate="yes" xml:space="preserve">
          <source>Packing and byte alignment, as described in the C FAQ &lt;a href=&quot;http://www.c-faq.com/struct/align.html&quot;&gt;here&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包装和字节对齐，如在C FAQ描述&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.c-faq.com/struct/align.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">也见。</target>
        </trans-unit>
        <trans-unit id="e51388dd1717e14df9b26e7234fe77926f42a0cc" translate="yes" xml:space="preserve">
          <source>So it is a matter of alignment basically.</source>
          <target state="translated">所以说,基本上是走线的问题。</target>
        </trans-unit>
        <trans-unit id="fc509e8f6989fc2315b358c504ab268f0ae96c3b" translate="yes" xml:space="preserve">
          <source>Some architectures actually have to trap on misaligned reads and writes, and early versions of the ARM architecture (the one that evolved into all of today's mobile CPUs) ... well, they actually just returned bad data on for those. (They ignored the low-order bits.)</source>
          <target state="translated">有些架构实际上必须对错位的读写进行陷阱,而ARM架构的早期版本(也就是演化成今天所有的移动CPU的架构)...........好吧,它们实际上只是返回了错误的数据。他们忽略了低阶位)。</target>
        </trans-unit>
        <trans-unit id="2d46e21969464a09e749253c1f1ceb8893528076" translate="yes" xml:space="preserve">
          <source>Some implementations of the language allow you to control the memory layout of structures through the pragma and compiler options</source>
          <target state="translated">有些语言的实现允许你通过 pragma 和编译器选项来控制结构的内存布局。</target>
        </trans-unit>
        <trans-unit id="0d5376a9dd3697fd748da016e1a1e6878df4b2bc" translate="yes" xml:space="preserve">
          <source>Suppose you have this structure:</source>
          <target state="translated">假设你有这样的结构。</target>
        </trans-unit>
        <trans-unit id="ddaf43b8dd1e7ca463e43724a0c0b99e17c1da5d" translate="yes" xml:space="preserve">
          <source>The following are unspecified: ...</source>
          <target state="translated">以下是未说明的。...</target>
        </trans-unit>
        <trans-unit id="557fb633b2d3a651a208a4c56f8be2abf1811a85" translate="yes" xml:space="preserve">
          <source>The idea is that for speed and cache considerations, operands should be read from addresses aligned to their natural size. To make this happen, the compiler pads structure members so the following member or following struct will be aligned.</source>
          <target state="translated">我们的想法是,出于速度和缓存的考虑,操作数应该从地址对齐的地址中读取。为了做到这一点,编译器会对结构成员进行焊盘,这样下面的成员或下面的结构就会被对齐。</target>
        </trans-unit>
        <trans-unit id="4ac87bc7429d319da13ae1718721e8b3300d3b44" translate="yes" xml:space="preserve">
          <source>The new C99 &lt;a href=&quot;https://en.wikipedia.org/wiki/Flexible_array_member&quot;&gt;flexible array member feature&lt;/a&gt; (&lt;code&gt;struct S {int is[];};&lt;/code&gt;) may also affect padding:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;新的C99 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Flexible_array_member&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;灵活数组成员功能&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct S {int is[];};&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）也可能会影响填充：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae22a4d57fbaa7519083255dde796c5c49ce9e0c" translate="yes" xml:space="preserve">
          <source>The size of a structure is greater than the sum of its parts because of what is called packing.  A particular processor has a preferred data size that it works with.  Most modern processors' preferred size if 32-bits (4 bytes).  Accessing the memory when data is on this kind of boundary is more efficient than things that straddle that size boundary.</source>
          <target state="translated">一个结构的大小大于其各部分的总和,这是因为所谓的打包。一个特定的处理器有一个它所使用的首选数据大小。大多数现代处理器的首选大小如果是32位(4字节)。当数据在这种边界上时,访问内存比跨越这种大小边界的东西更有效率。</target>
        </trans-unit>
        <trans-unit id="ca97b0953d30171167667ce55c7fadde376f89bc" translate="yes" xml:space="preserve">
          <source>The value of padding bytes when storing values in structures or unions (6.2.6.1)</source>
          <target state="translated">在结构或联合中存储值时的padding字节值(6.2.6.1)</target>
        </trans-unit>
        <trans-unit id="f1f5f526e00e194bf748da381444f712f26f309c" translate="yes" xml:space="preserve">
          <source>The volume occupied by the structure is calculated as the size of the aligned single element of an array of such structures. The structure should
end so that the first element of the next following structure does not  the violate requirements of alignment</source>
          <target state="translated">结构所占的体积是以此类结构阵列中对齐的单元素的大小来计算的。结构结束时,应使下一个结构的第一个元素不违反对齐要求。</target>
        </trans-unit>
        <trans-unit id="406a67a4fa9005324820eb336336121fd7305573" translate="yes" xml:space="preserve">
          <source>The x86 architecture has always been able to fetch misaligned addresses. However, it's slower and when the misalignment overlaps two different cache lines, then it evicts two cache lines when an aligned access would only evict one.</source>
          <target state="translated">x86架构一直以来都可以提取错位地址。但是,它的速度比较慢,当错位时,当错位重叠了两条不同的缓存线时,它就会驱逐两条缓存线,而对齐后的访问只会驱逐一条。</target>
        </trans-unit>
        <trans-unit id="fb8544544c4807c55180a86a810e88b25115025a" translate="yes" xml:space="preserve">
          <source>This can be due to byte alignment and padding so that the structure comes out to an even number of bytes (or words) on your platform.  For example in C on Linux, the following 3 structures:</source>
          <target state="translated">这可能是由于字节对齐和padding的原因,所以在你的平台上,结构出来的字节数(或字数)是均匀的。例如在Linux上的C语言中,有以下3种结构。</target>
        </trans-unit>
        <trans-unit id="e336f18147602a9e44b58d1d7ec400b46830669b" translate="yes" xml:space="preserve">
          <source>This is because of padding added to satisfy alignment constraints. &lt;a href=&quot;http://en.wikipedia.org/wiki/Data_structure_alignment&quot;&gt;Data structure alignment&lt;/a&gt; impacts both performance and correctness of programs:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是因为添加了填充以满足对齐约束。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Data_structure_alignment&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;数据结构对齐会&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;影响程序的性能和正确性：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b9def9e505b956b3d279e42e0805991573c33ec" translate="yes" xml:space="preserve">
          <source>Unfortunately, this problem becomes a killer when you attempt to send structures over a network or even write the binary data to a binary file.  The padding inserted between elements of a structure or class can disrupt the data sent to the file or network.  In order to write portable code (one that will go to several different compilers), you will probably have to access each element of the structure separately to ensure the proper &quot;packing&quot;.</source>
          <target state="translated">不幸的是,当你试图通过网络发送结构,甚至将二进制数据写入二进制文件时,这个问题就成了杀手锏。在结构或类的元素之间插入的padding会破坏发送到文件或网络的数据。为了写出可移植的代码(一个将转到多个不同的编译器中的代码),你可能必须分别访问结构的每个元素,以确保正确的 &quot;打包&quot;。</target>
        </trans-unit>
        <trans-unit id="9165e18e12f4d78ce348dd02fe45f9811c84f27c" translate="yes" xml:space="preserve">
          <source>Usually it is easier for the CPU to access data that is a multiple of 4 (or 8), depending platform and also on the compiler.</source>
          <target state="translated">通常情况下,CPU访问4的倍数(或8的倍数)的数据更容易,这取决于平台,也取决于编译器。</target>
        </trans-unit>
        <trans-unit id="72869ecb22c8d2fdf1241784ec34500810b4e780" translate="yes" xml:space="preserve">
          <source>Why does the &lt;code&gt;sizeof&lt;/code&gt; operator return a size larger for a structure than the total sizes of the structure's members?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为什么&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;运算符返回的结构大小大于结构成员的总大小？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="efe745f9a67d720491c39c539175db72ee5c6ff1" translate="yes" xml:space="preserve">
          <source>Why isn't sizeof for a struct equal to the sum of sizeof of each member</source>
          <target state="translated">为什么一个结构的sizeof不等于每个成员的sizeof之和?</target>
        </trans-unit>
        <trans-unit id="bd737ee4afc1c36b62b054b4187c4c65a756473c" translate="yes" xml:space="preserve">
          <source>and GCC claim compatibility with Microsoft's compiler.:</source>
          <target state="translated">和GCC声称与微软的编译器兼容。</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="c2ce592b3a7afb19f38698f51ee6c23405bc1dd2" translate="yes" xml:space="preserve">
          <source>compilers required to assign a sequence of components increasing memory addresses</source>
          <target state="translated">编译器需要分配一串元件,增加内存地址的顺序</target>
        </trans-unit>
        <trans-unit id="b4941e95d6969cbd6a59124474f4bf102b829bf0" translate="yes" xml:space="preserve">
          <source>for Microsoft Visual C:</source>
          <target state="translated">适用于Microsoft Visual C。</target>
        </trans-unit>
        <trans-unit id="60684e9bc6c2d2147799fb30975595f09663af5b" translate="yes" xml:space="preserve">
          <source>memory holes may appear between any two components, and after the last component. It was due to the fact that certain types of objects on the target computer may be limited by the boundaries of addressing</source>
          <target state="translated">内存孔可能出现在任意两个组件之间,以及最后一个组件之后。这是由于目标计算机上的某些类型的对象可能会受到寻址边界的限制而造成的。</target>
        </trans-unit>
        <trans-unit id="485d42c3c1cc52f4609fde614c3f8a2bcc9d8359" translate="yes" xml:space="preserve">
          <source>p.s More detailed info are available here: &quot;Samuel P.Harbison, Guy L.Steele C A Reference, (5.6.2 - 5.6.7)&quot;</source>
          <target state="translated">p.s 更多详细的信息可以在这里找到。&quot;Samuel P.Harbison,Guy L.Steele C A参考资料,(5.6.2-5.6.7)&quot;</target>
        </trans-unit>
        <trans-unit id="89c2cc66d89a575cb42b6a1dca58093a04f698d4" translate="yes" xml:space="preserve">
          <source>unnamed bit fields may be included in the structure to the required address alignments of adjacent elements</source>
          <target state="translated">未命名的位字段可以包含在结构中,以相邻元素的所需地址对齐的结构中</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
