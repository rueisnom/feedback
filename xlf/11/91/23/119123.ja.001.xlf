<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/119123">
    <body>
      <group id="119123">
        <trans-unit id="ea7c1d190a3bb5944cb0b253e4ec0b66b24d634d" translate="yes" xml:space="preserve">
          <source>&quot;memory holes&quot; size included in the result of sizeof operator. The sizeof only doesn't include size of the flexible array, which is available in C/C++</source>
          <target state="translated">sizeof演算子の結果に含まれる &quot;メモリホール &quot;サイズ。sizeofだけでは、CC++で利用可能なフレキシブル配列のサイズは含まれません。</target>
        </trans-unit>
        <trans-unit id="5e2a1eeaafd0038588279f1b10325b005bf97c7f" translate="yes" xml:space="preserve">
          <source>13 ... There may be unnamed
  padding within a structure object, but not at its beginning.</source>
          <target state="translated">13 ...構造体オブジェクト内には名前のないパディングがあるかもしれませんが、その先頭にはありません。</target>
        </trans-unit>
        <trans-unit id="3a613654ca642a6d6767394e0d27f74611b755db" translate="yes" xml:space="preserve">
          <source>15 There may be unnamed padding at the end of a structure or union.</source>
          <target state="translated">15 構造体やユニオンの最後に名前のないパディングがある場合があります。</target>
        </trans-unit>
        <trans-unit id="e2d0e33ec380d07996b4f8bc86ea785141c22b59" translate="yes" xml:space="preserve">
          <source>16 As a special case, the last element of a structure with more than one named member may
  have an incomplete array type; this is called a flexible array member. In most situations,
  the flexible array member is ignored. In particular, the size of the structure is as if the
  flexible array member were omitted except that it may have more trailing padding than
  the omission would imply.</source>
          <target state="translated">16 特別なケースとして、複数の名前付きメンバを持つ構造体の最後の要素は、不完全な配列型を持つことがあります。ほとんどの状況では、フレキシブル配列メンバは無視されます。特に,構造体のサイズは,フレキシブル配列メンバが省略された場合と同じですが,省略された場合よりも末尾のパディングが多くなる可能性があります.</target>
        </trans-unit>
        <trans-unit id="414bb92964f7ecfad2604e92821062f2dac17ee9" translate="yes" xml:space="preserve">
          <source>2 When applied
  to a class, the result is the number of bytes in an object of that class including any padding required for
  placing objects of that type in an array.</source>
          <target state="translated">2 クラスに適用した場合、結果は、そのクラスのオブジェクトのバイト数と、その型のオブジェクトを配列に配置するために必要なパディングを含みます。</target>
        </trans-unit>
        <trans-unit id="6486cec944fa9f9b2c41ecd5df485da4ac35f4f6" translate="yes" xml:space="preserve">
          <source>3 When applied to an operand that has structure or union type,
  the result is the total number of bytes in such an object,
  including internal and trailing padding.</source>
          <target state="translated">3 構造体型または組合わせ型を持つオペランドに適用した場合、結果は、そのようなオブジェクトの内部パディングと末尾のパディングを含めたバイト数の合計となります。</target>
        </trans-unit>
        <trans-unit id="aaf36019e7beaa5a1dc4358651e76a80f0f859e0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;5.3.3 Sizeof&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;5.3.3サイズ&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f80c22edb72b0170a8c7a0c869a36093f9988bf4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;6.5.3.4 The sizeof operator&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;6.5.3.4 sizeof演算子&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="21a6950949f9380e1a80fd038021e59aace62bc7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;6.7.2.1 Structure and union specifiers&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;6.7.2.1構造体と共用体の指定子&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c188ad2443c540567c7c8daa7cb2648fb19b97d4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;9.2 Class members&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;9.2クラスのメンバー&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abf975a1f9f225f38e7cef1f183b3da09c979010" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Annex J Portability Issues&lt;/em&gt; reiterates:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;附属書Jの移植性の問題&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、繰り返し述べます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="377bd7d244fc6b72e96059fb9cb766841edd1758" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;TL;DR:&lt;/em&gt; alignment is important.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TL; DR：&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;アラインメントは重要です。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9fa5697a62922f95e3c60e9368cd06101ac9527b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C language leaves compiler some freedom about the location of the structural elements in the memory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C言語では、メモリ内の構造要素の場所についてコンパイラにある程度の自由を与えています。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a886700572b9c57d6d491254156f6437d6d04fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11 N3337 standard draft&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11 N3337標準ドラフト&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fd7453bed259332b62ae40bd66abc3750697afe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C99 N1256 standard draft&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99 N1256標準ドラフト&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d146a42b33f5eb7eee5f1ff1d6e895f68382d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How alignment works:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;配置の仕組み：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee4d41c0c55cf4eaa96f769b13f7cb0313a1edf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problems related to the elements alignment:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;要素の配置に関連する問題：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="26078666e7e6283d98fb3cd8206541206faed3f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The C language provides some assurance to the programmer of the elements layout in the structure:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C言語は、構造内の要素のレイアウトをプログラマに保証します。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08001831948aa1e7c2fcc0fae1677699501a9e43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You need to have good reasons to change it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;それを変更するには、十分な理由が必要です。&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc6c36591832366db6e1e320835a5a82435c7f21" translate="yes" xml:space="preserve">
          <source>A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its
  initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note:
  There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning,
  as necessary to achieve appropriate alignment. &amp;mdash; end note ]</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;reinterpret_castを使用して適切に変換された、標準レイアウト構造体オブジェクトへのポインターは、その初期メンバー（またはそのメンバーがビットフィールドの場合は、それが存在するユニットを指す）を指し、その逆も同様です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;[注：したがって、適切な配置を実現するために必要に応じて、標準レイアウトの構造体オブジェクト内には名前のないパディングが存在する可能性がありますが、最初はそうではありません。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;mdash;エンドノート]&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d0aab459ec3221328ef34032b641bed6c8e7308" translate="yes" xml:space="preserve">
          <source>Address of the first component coincides with the start address of the structure</source>
          <target state="translated">最初のコンポーネントのアドレスは、構造体の開始アドレスと一致します。</target>
        </trans-unit>
        <trans-unit id="ccbd2e21cfcc46e0e9d663d870a070b41c7d2362" translate="yes" xml:space="preserve">
          <source>Also a library may be compiled under x86 with 32-bit ints and you may be comparing its components on a 64-bit process would would give you a different result if you were doing this by hand.</source>
          <target state="translated">また、ライブラリはx86で32ビットのINTでコンパイルされているかもしれませんし、64ビットのプロセスでそのコンポーネントを比較しても、手作業で行った場合には異なる結果が得られるかもしれません。</target>
        </trans-unit>
        <trans-unit id="4f7afdabaf1875c8c3d894b087ea225e9b39d84e" translate="yes" xml:space="preserve">
          <source>But it's much, much easier on the processor if the compiler arranges
  it like this:</source>
          <target state="translated">しかし、コンパイラがこのように配置した方が、プロセッサにとってははるかに、はるかに楽になります。</target>
        </trans-unit>
        <trans-unit id="942fdac75ab408f0da705c35d5ba37390764f845" translate="yes" xml:space="preserve">
          <source>Computers differ on how to store the bytes in a word (Intel 80x86 and Motorola 68000)</source>
          <target state="translated">コンピュータは、単語内のバイトを格納する方法が異なります(インテル80x86とモトローラ68000</target>
        </trans-unit>
        <trans-unit id="604bde069a55581721b9d22581417c64232f332a" translate="yes" xml:space="preserve">
          <source>Different computers line the edges of objects in different ways</source>
          <target state="translated">コンピュータによって異なる方法でオブジェクトのエッジを並べる</target>
        </trans-unit>
        <trans-unit id="9d956ba7ff3840f2bab2c9e6daeb95400655a424" translate="yes" xml:space="preserve">
          <source>Different restrictions on the width of the bit field</source>
          <target state="translated">ビットフィールドの幅の異なる制限</target>
        </trans-unit>
        <trans-unit id="4fab0d756aeaaafa4d8a6d6e1128251336f7627d" translate="yes" xml:space="preserve">
          <source>Either corrected in hardware, for a modest performance-degradation.</source>
          <target state="translated">ハードウェアで修正されても、性能が低下しても、それなりの性能にはなります。</target>
        </trans-unit>
        <trans-unit id="d95360439bed52475c90194b8b2cbab73ee89644" translate="yes" xml:space="preserve">
          <source>Finally, note that cache lines can be arbitrarily large, and the compiler doesn't attempt to guess at those or make a space-vs-speed tradeoff. Instead, the alignment decisions are part of the ABI and represent the minimum alignment that will eventually evenly fill up a cache line.</source>
          <target state="translated">最後に、キャッシュラインは任意に大きくなる可能性があり、コンパイラはキャッシュラインを推測したり、スペースとスピードのトレードオフを行ったりしないことに注意してください。その代わり、アラインメントの決定は ABI の一部であり、最終的にキャッシュラインを均等に埋めるための最小のアラインメントを表します。</target>
        </trans-unit>
        <trans-unit id="ce0b0e3b463737dec1f994b52eb1aa91d0e6fd2d" translate="yes" xml:space="preserve">
          <source>For example.  Consider the simple structure:</source>
          <target state="translated">例えば シンプルな構造を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="016c76e5c39673125f64e48a16c383be180081f4" translate="yes" xml:space="preserve">
          <source>Have members who's sizes (in bytes) are 4 bytes (32 bits), 8 bytes (2x 32 bits) and 1 byte (2+6 bits) respectively.  The above program (on Linux using gcc) prints the sizes as 4, 8, and 4 - where the last structure is padded so that it is a single word (4 x 8 bit bytes on my 32bit platform).</source>
          <target state="translated">メンバーのサイズ(バイト数)がそれぞれ4バイト(32ビット)、8バイト(2x32ビット)、1バイト(2+6ビット)であるとします。上記のプログラム(Linuxでgccを使用)は、サイズを4,8,4で表示します-最後の構造体は1つの単語(私の32ビットプラットフォームでは4 x 8ビットバイト)になるようにパディングされています。</target>
        </trans-unit>
        <trans-unit id="16e342eef65fa14dd4d6fc2bf54314327cdc559a" translate="yes" xml:space="preserve">
          <source>Here's an example using typical settings for an x86 processor (all used 32 and 64 bit modes):</source>
          <target state="translated">ここでは、x86プロセッサの典型的な設定を使用した例を示します(すべて32ビットと64ビットのモードを使用しています)。</target>
        </trans-unit>
        <trans-unit id="b8e72a837533fa3fdedba99cab0b561c4d002f62" translate="yes" xml:space="preserve">
          <source>I only know enough C++ to understand the note :-)</source>
          <target state="translated">私はC++しか知らないので、ノートを理解するには :-)</target>
        </trans-unit>
        <trans-unit id="f3e48a60aeb815a325f337b288e38ee3446848a4" translate="yes" xml:space="preserve">
          <source>I should now have the length of 11.  Without the pragma, I could be anything from 11 to 14 (and for some systems, as much as 32), depending on the default packing of the compiler.</source>
          <target state="translated">プラグマがなければ、コンパイラのデフォルトパッキンにもよりますが、11から14まで(システムによっては32まで)の長さになります。</target>
        </trans-unit>
        <trans-unit id="e2ec884c97791749c41744efb39836e58381495c" translate="yes" xml:space="preserve">
          <source>I'm quite sure &lt;strong&gt;member-order &lt;em&gt;is&lt;/em&gt; guaranteed in C&lt;/strong&gt;, but I wouldn't count on it, when writing a cross-platform or cross-compiler program.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メンバーの順序&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;が&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; C&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;保証され&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ていると確信&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;していますが、クロスプラットフォームまたはクロスコンパイラーのプログラムを作成するときは、それを当てにしません。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="294eaa44c9c9070356fdb5156a7a6c6f5c27332e" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: Both the C and C++ standards state that structure alignment is implementation-defined.  Therefore each compiler may choose to align data differently, resulting in different and incompatible data layouts.  For this reason, when dealing with libraries that will be used by different compilers, it is important to understand how the compilers align data.  Some compilers have command-line settings and/or special &lt;code&gt;#pragma&lt;/code&gt; statements to change the structure alignment settings.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;重要な注意：CとC ++の両方の標準では、構造の整列は実装定義であると述べています。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;したがって、各コンパイラーはデータを異なる方法で位置合わせすることを選択し、その結果、データ・レイアウトが異なり、互換性がなくなります。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;このため、さまざまなコンパイラーで使用されるライブラリーを扱う場合、コンパイラーがデータを調整する方法を理解することが重要です。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一部のコンパイラには、コマンドライン設定や特殊な&lt;/font&gt;&lt;/font&gt; &lt;code&gt;#pragma&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ステートメントがあり、構造体の配置設定を変更できます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8f55e5a98bbf66b8be5db53541346322d59f2a53" translate="yes" xml:space="preserve">
          <source>If the machine is a 32-bit machine and data is aligned on a 32-bit boundary, we see an immediate problem (assuming no structure alignment).  In this example, let us assume that the structure data starts at address 1024 (0x400 - note that the lowest 2 bits are zero, so the data is aligned to a 32-bit boundary).  The access to data.a will work fine because it starts on a boundary - 0x400.  The access to data.b will also work fine, because it is at address 0x404 - another 32-bit boundary.  But an unaligned structure would put data.c at address 0x405.  The 4 bytes of data.c are at 0x405, 0x406, 0x407, 0x408.  On a 32-bit machine, the system would read data.c during one memory cycle, but would only get 3 of the 4 bytes (the 4th byte is on the next boundary).  So, the system would have to do a second memory access to get the 4th byte,</source>
          <target state="translated">マシンが32ビットマシンで、データが32ビット境界にアラインメントされている場合、(構造体のアラインメントがないと仮定して)すぐに問題が発生します。この例では、構造体データがアドレス 1024(0x400-最下位 2 ビットはゼロであることに注意してください。data.aへのアクセスは、0x400という境界線から始まるので問題なく動作します。data.bへのアクセスも、アドレス0x404、つまりもう一つの32ビット境界にあるため、正常に動作します。しかし、アラインメントされていない構造体の場合、data.c はアドレス 0x405 に置かれます。data.cの4バイトは0x405、0x406、0x407、0x408にあります。32ビットマシンの場合、システムは1回のメモリサイクルでdata.cを読み込んでも、4バイトのうち3バイトしか読み込めません(4バイト目は次の境界にあります)。そのため、4 バイト目を取得するためには、2 回目のメモリアクセスを行う必要があります。</target>
        </trans-unit>
        <trans-unit id="bccaf1969a6bb184c03be12d89b4357316a42879" translate="yes" xml:space="preserve">
          <source>If you want the structure to have a certain size with GCC for example use &lt;a href=&quot;http://digitalvampire.org/blog/index.php/2006/07/31/why-you-shouldnt-use-__attribute__packed/&quot;&gt;&lt;code&gt;__attribute__((packed))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;たとえばGCCで特定のサイズの構造にしたい場合は、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://digitalvampire.org/blog/index.php/2006/07/31/why-you-shouldnt-use-__attribute__packed/&quot;&gt; &lt;code&gt;__attribute__((packed))&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="deb7d9021009a9e869a35d0946526f7b0aeab08c" translate="yes" xml:space="preserve">
          <source>In addition to the other answers, a struct can (but usually doesn't) have virtual functions, in which case the size of the struct will also include the space for the vtbl.</source>
          <target state="translated">他の回答に加えて、構造体は仮想関数を持つことができます(通常はありません)。</target>
        </trans-unit>
        <trans-unit id="ecdc60512add6ea34f6cbca0736e5590bbeb5481" translate="yes" xml:space="preserve">
          <source>In addition to the previous answers, please note that regardless the packaging, &lt;strong&gt;there is no members-order-guarantee in C++&lt;/strong&gt;. Compilers may (and certainly do) add virtual table pointer and base structures' members to the structure. Even the existence of virtual table is not ensured by the standard (virtual mechanism implementation is not specified) and therefore one can conclude that such guarantee is just impossible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以前の回答に加えて、パッケージに関係なく、&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++にはメンバー注文保証がない&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ことに注意してください&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;コンパイラーは、仮想テーブルポインターと基本構造体のメンバーを構造体に追加する可能性があります（確かに追加します）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;標準では仮想テーブルの存在さえ保証されていません（仮想メカニズムの実装は指定されていません）。したがって、そのような保証はまったく不可能であると結論付けることができます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1165438f2f662510c6a05ae168ff5e92e07c7d9" translate="yes" xml:space="preserve">
          <source>In addition, atomicity and other concurrency-guarantees might be broken, leading to subtle errors.</source>
          <target state="translated">また、アトミック性や他の同時実行性保証が壊れて、微妙なエラーが発生する可能性があります。</target>
        </trans-unit>
        <trans-unit id="ace871547625d99f1b3513de67ddbf1ecd1ed28f" translate="yes" xml:space="preserve">
          <source>In the packed version, notice how it's at least a little bit hard for
  you and me to see how the b and c fields wrap around? In a nutshell,
  it's hard for the processor, too. Therefore, most compilers will pad
  the structure (as if with extra, invisible fields) like this:</source>
          <target state="translated">パック版では、bとcのフィールドがどのように折り重なっているのか、あなたと私には少なくとも少しわかりづらいことにお気づきでしょうか?一言で言えば、プロセッサにとっても難しいということです。そのため、ほとんどのコンパイラはこのように構造体に(見えないフィールドを追加するかのように)パッドを入れます。</target>
        </trans-unit>
        <trans-unit id="6387af3b2046a0f60a53cd633291987de3402796" translate="yes" xml:space="preserve">
          <source>It can do so if you have implicitly or explicitly set the alignment of the struct. A struct that is aligned 4 will always be a multiple of 4 bytes even if the size of its members would be something that's not a multiple of 4 bytes.</source>
          <target state="translated">構造体のアラインメントを暗黙的または明示的に設定している場合は、そうすることができます。アラインメント 4 の構造体は、そのメンバのサイズが 4 バイトの倍数ではないものであっても、常に 4 バイトの倍数になります。</target>
        </trans-unit>
        <trans-unit id="3ebd1a765829877290c265b234786e66158f299f" translate="yes" xml:space="preserve">
          <source>It's for alignment. Many processors can't access 2- and 4-byte
  quantities (e.g. ints and long ints) if they're crammed in
  every-which-way.</source>
          <target state="translated">アラインメントのためです。多くのプロセッサは、2バイトや4バイトの量(例えば、イントやロングイントなど)をあらゆる方法で詰め込んでしまうと、アクセスできなくなってしまいます。</target>
        </trans-unit>
        <trans-unit id="c2689f2719ba1b44a9adf74baccfccbd020a7e67" translate="yes" xml:space="preserve">
          <source>Mis-aligned access might be a hard error (often &lt;code&gt;SIGBUS&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不整合なアクセスは、ハードエラー（多くの場合、&lt;/font&gt;&lt;/font&gt; &lt;code&gt;SIGBUS&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）である&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可能性があります&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3a118237ea1794dca6417aa40286dd801d9cf4ae" translate="yes" xml:space="preserve">
          <source>Mis-aligned access might be a soft error.</source>
          <target state="translated">アクセスのずれはソフトエラーの可能性があります。</target>
        </trans-unit>
        <trans-unit id="513a0a6fb061f5730b3144ab01c46ffceaf5a848" translate="yes" xml:space="preserve">
          <source>Now, if instead of putting data.c at address 0x405, the compiler padded the structure by 3 bytes and put data.c at address 0x408, then the system would only need 1 cycle to read the data, cutting access time to that data element by 50%.  Padding swaps memory efficiency for processing efficiency.  Given that computers can have huge amounts of memory (many gigabytes), the compilers feel that the swap (speed over size) is a reasonable one.</source>
          <target state="translated">ここで、data.cをアドレス0x405に置く代わりに、コンパイラが構造体を3バイトパディングしてdata.cをアドレス0x408に置くと、システムは1サイクルでデータを読み出すことができ、そのデータ要素へのアクセス時間を50%短縮することができます。パディングはメモリ効率と処理効率を入れ替えています。コンピュータが膨大な量のメモリ(数ギガバイト)を持つことができることを考えると、コンパイラはこのスワップ(サイズよりも速度を優先すること)を合理的なものだと考えています。</target>
        </trans-unit>
        <trans-unit id="c02ec6a18a5ab1ca633a0e2b2293f779e6729575" translate="yes" xml:space="preserve">
          <source>Now, you might think that it ought to be possible to pack this
  structure into memory like this:</source>
          <target state="translated">さて、この構造をこのようにメモリに詰め込むことができるはずだと思うかもしれません。</target>
        </trans-unit>
        <trans-unit id="32a8824f2732921a3dc9ac7db52b26ca85ce9b0d" translate="yes" xml:space="preserve">
          <source>On Windows you can set the alignment to one byte when using the cl.exe compier with the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xh3e3fd0(VS.80).aspx&quot;&gt;/Zp option&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Windowsでは、&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xh3e3fd0(VS.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;/ Zpオプションを&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;指定してcl.exeコンパイラーを使用するときに、配置を1バイトに設定でき&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ます&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a3668a1ac342860ec9ca845b4c68d75816f250d2" translate="yes" xml:space="preserve">
          <source>On the other hand, different compilers have different abilities to manage data structure packing.  For example, in Visual C/C++ the compiler supports the #pragma pack command.  This will allow you to adjust data packing and alignment.</source>
          <target state="translated">一方、コンパイラによってデータ構造のパッキングを管理する能力が異なります。例えば、Visual CC++では、コンパイラは#pragma packコマンドをサポートしています。これにより、データのパッキングとアラインメントを調整することができます。</target>
        </trans-unit>
        <trans-unit id="88ee5aad6a5759dd6df5e6b7f54b322f1e3d1a19" translate="yes" xml:space="preserve">
          <source>One can minimize the size of structures by sorting members by alignment (sorting by size suffices for that in basic types) (like structure &lt;code&gt;Z&lt;/code&gt; in the example above).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上記の例の&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;構造&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Z&lt;/code&gt; の&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ように）配置によってメンバーを並べ替えることにより、構造のサイズを最小限に抑えることができます（基本タイプではサイズで並べ替えれば十分です&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b2051d9503bb13db117acc5804d15184f6ad617" translate="yes" xml:space="preserve">
          <source>Or corrected by emulation in software, for a severe performance-degradation.</source>
          <target state="translated">あるいは、ソフトウェアのエミュレーションで修正して、ひどい性能低下のために。</target>
        </trans-unit>
        <trans-unit id="1a61f3cc584a463a50abd933541448f7a1510020" translate="yes" xml:space="preserve">
          <source>Packing and byte alignment, as described in the C FAQ &lt;a href=&quot;http://www.c-faq.com/struct/align.html&quot;&gt;here&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;a href=&quot;http://www.c-faq.com/struct/align.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ここ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;のC FAQ &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;で&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;説明されているパッキングとバイトアライメント&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">も参照してください。</target>
        </trans-unit>
        <trans-unit id="e51388dd1717e14df9b26e7234fe77926f42a0cc" translate="yes" xml:space="preserve">
          <source>So it is a matter of alignment basically.</source>
          <target state="translated">ですから、基本的にはアライメントの問題です。</target>
        </trans-unit>
        <trans-unit id="fc509e8f6989fc2315b358c504ab268f0ae96c3b" translate="yes" xml:space="preserve">
          <source>Some architectures actually have to trap on misaligned reads and writes, and early versions of the ARM architecture (the one that evolved into all of today's mobile CPUs) ... well, they actually just returned bad data on for those. (They ignored the low-order bits.)</source>
          <target state="translated">いくつかのアーキテクチャでは、実際には読み書きのずれをトラップする必要があり、ARMアーキテクチャの初期バージョン(今日のすべてのモバイルCPUに進化したもの)......まあ、実際には悪いデータを返していました。(低次ビットを無視していました)。</target>
        </trans-unit>
        <trans-unit id="2d46e21969464a09e749253c1f1ceb8893528076" translate="yes" xml:space="preserve">
          <source>Some implementations of the language allow you to control the memory layout of structures through the pragma and compiler options</source>
          <target state="translated">この言語のいくつかの実装では、構造体のメモリレイアウトを pragma とコンパイラオプションで制御することができます。</target>
        </trans-unit>
        <trans-unit id="0d5376a9dd3697fd748da016e1a1e6878df4b2bc" translate="yes" xml:space="preserve">
          <source>Suppose you have this structure:</source>
          <target state="translated">このような構造になっているとします。</target>
        </trans-unit>
        <trans-unit id="ddaf43b8dd1e7ca463e43724a0c0b99e17c1da5d" translate="yes" xml:space="preserve">
          <source>The following are unspecified: ...</source>
          <target state="translated">以下は不特定多数です。...</target>
        </trans-unit>
        <trans-unit id="557fb633b2d3a651a208a4c56f8be2abf1811a85" translate="yes" xml:space="preserve">
          <source>The idea is that for speed and cache considerations, operands should be read from addresses aligned to their natural size. To make this happen, the compiler pads structure members so the following member or following struct will be aligned.</source>
          <target state="translated">これは、速度とキャッシュを考慮して、オペランドは自然なサイズに整列したアドレスから読み込むべきだという考えです。これを実現するために、コンパイラは構造体のメンバをパッドして、次のメンバまたは次の構造体がアラインメントされるようにします。</target>
        </trans-unit>
        <trans-unit id="4ac87bc7429d319da13ae1718721e8b3300d3b44" translate="yes" xml:space="preserve">
          <source>The new C99 &lt;a href=&quot;https://en.wikipedia.org/wiki/Flexible_array_member&quot;&gt;flexible array member feature&lt;/a&gt; (&lt;code&gt;struct S {int is[];};&lt;/code&gt;) may also affect padding:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;新しいC99 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Flexible_array_member&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;フレキシブル配列メンバー機能&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct S {int is[];};&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）もパディングに影響する可能性があります。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae22a4d57fbaa7519083255dde796c5c49ce9e0c" translate="yes" xml:space="preserve">
          <source>The size of a structure is greater than the sum of its parts because of what is called packing.  A particular processor has a preferred data size that it works with.  Most modern processors' preferred size if 32-bits (4 bytes).  Accessing the memory when data is on this kind of boundary is more efficient than things that straddle that size boundary.</source>
          <target state="translated">構造体のサイズは、パッキングと呼ばれるもののため、その部分の合計よりも大きくなります。特定のプロセッサには、そのプロセッサが動作するデータサイズが設定されています。32ビット(4バイト)であれば、ほとんどの現代のプロセッサの好ましいサイズです。データがこの種の境界線上にあるときにメモリにアクセスすることは、そのサイズの境界線にまたがっているものよりも効率的です。</target>
        </trans-unit>
        <trans-unit id="ca97b0953d30171167667ce55c7fadde376f89bc" translate="yes" xml:space="preserve">
          <source>The value of padding bytes when storing values in structures or unions (6.2.6.1)</source>
          <target state="translated">構造体やユニオンに値を格納する際のパディングバイトの値(6.2.6.1</target>
        </trans-unit>
        <trans-unit id="f1f5f526e00e194bf748da381444f712f26f309c" translate="yes" xml:space="preserve">
          <source>The volume occupied by the structure is calculated as the size of the aligned single element of an array of such structures. The structure should
end so that the first element of the next following structure does not  the violate requirements of alignment</source>
          <target state="translated">構造体が占有する体積は、そのような構造体の配列の整列された単一要素のサイズとして計算される。構造体は,次の構造体の最初の要素が整列の要件に違反しないように終了しなければならない。</target>
        </trans-unit>
        <trans-unit id="406a67a4fa9005324820eb336336121fd7305573" translate="yes" xml:space="preserve">
          <source>The x86 architecture has always been able to fetch misaligned addresses. However, it's slower and when the misalignment overlaps two different cache lines, then it evicts two cache lines when an aligned access would only evict one.</source>
          <target state="translated">x86アーキテクチャは、常にミスアラインメントされたアドレスをフェッチすることができます。しかし、それはより遅く、誤ったアラインメントが2つの異なるキャッシュラインに重なっている場合、アラインメントされたアクセスが1つのキャッシュラインしか取り出せないときに、2つのキャッシュラインを取り出せるようになっています。</target>
        </trans-unit>
        <trans-unit id="fb8544544c4807c55180a86a810e88b25115025a" translate="yes" xml:space="preserve">
          <source>This can be due to byte alignment and padding so that the structure comes out to an even number of bytes (or words) on your platform.  For example in C on Linux, the following 3 structures:</source>
          <target state="translated">これは、お使いのプラットフォーム上で構造体が偶数バイト(またはワード)になるように、バイトアライメントとパディングが原因である可能性があります。例えば、Linux上のC言語では、以下の3つの構造体があります。</target>
        </trans-unit>
        <trans-unit id="e336f18147602a9e44b58d1d7ec400b46830669b" translate="yes" xml:space="preserve">
          <source>This is because of padding added to satisfy alignment constraints. &lt;a href=&quot;http://en.wikipedia.org/wiki/Data_structure_alignment&quot;&gt;Data structure alignment&lt;/a&gt; impacts both performance and correctness of programs:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;これは、位置合わせの制約を満たすためにパディングが追加されたためです。&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Data_structure_alignment&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;データ構造の整列&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;は、プログラムのパフォーマンスと正確性の両方に影響を与えます。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b9def9e505b956b3d279e42e0805991573c33ec" translate="yes" xml:space="preserve">
          <source>Unfortunately, this problem becomes a killer when you attempt to send structures over a network or even write the binary data to a binary file.  The padding inserted between elements of a structure or class can disrupt the data sent to the file or network.  In order to write portable code (one that will go to several different compilers), you will probably have to access each element of the structure separately to ensure the proper &quot;packing&quot;.</source>
          <target state="translated">残念ながら、ネットワーク経由で構造体を送信しようとしたり、バイナリファイルにバイナリデータを書き込もうとすると、この問題は致命的なものになります。構造体やクラスの要素間に挿入されたパディングは、ファイルやネットワークに送られたデータを混乱させる可能性があります。移植性のあるコード(複数の異なるコンパイラで動作するコード)を書くためには、おそらく構造体の各要素に個別にアクセスして、適切な「パッキング」を行う必要があるでしょう。</target>
        </trans-unit>
        <trans-unit id="9165e18e12f4d78ce348dd02fe45f9811c84f27c" translate="yes" xml:space="preserve">
          <source>Usually it is easier for the CPU to access data that is a multiple of 4 (or 8), depending platform and also on the compiler.</source>
          <target state="translated">通常、4の倍数(または8の倍数)のデータにアクセスするのは、プラットフォームやコンパイラにもよりますが、CPUの方が簡単です。</target>
        </trans-unit>
        <trans-unit id="72869ecb22c8d2fdf1241784ec34500810b4e780" translate="yes" xml:space="preserve">
          <source>Why does the &lt;code&gt;sizeof&lt;/code&gt; operator return a size larger for a structure than the total sizes of the structure's members?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;演算子は、構造体のメンバーの合計サイズよりも大きい構造体のサイズを返すの&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;はなぜ&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ですか？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="efe745f9a67d720491c39c539175db72ee5c6ff1" translate="yes" xml:space="preserve">
          <source>Why isn't sizeof for a struct equal to the sum of sizeof of each member</source>
          <target state="translated">構造体の sizeof が各メンバの sizeof の合計と等しくないのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="bd737ee4afc1c36b62b054b4187c4c65a756473c" translate="yes" xml:space="preserve">
          <source>and GCC claim compatibility with Microsoft's compiler.:</source>
          <target state="translated">とGCCはマイクロソフトのコンパイラとの互換性を主張しています。</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="c2ce592b3a7afb19f38698f51ee6c23405bc1dd2" translate="yes" xml:space="preserve">
          <source>compilers required to assign a sequence of components increasing memory addresses</source>
          <target state="translated">メモリアドレスを増やすコンポーネントのシーケンスを割り当てる必要があるコンパイラ</target>
        </trans-unit>
        <trans-unit id="b4941e95d6969cbd6a59124474f4bf102b829bf0" translate="yes" xml:space="preserve">
          <source>for Microsoft Visual C:</source>
          <target state="translated">for Microsoft Visual C.</target>
        </trans-unit>
        <trans-unit id="60684e9bc6c2d2147799fb30975595f09663af5b" translate="yes" xml:space="preserve">
          <source>memory holes may appear between any two components, and after the last component. It was due to the fact that certain types of objects on the target computer may be limited by the boundaries of addressing</source>
          <target state="translated">メモリホールは、任意の2つのコンポーネントの間に、最後のコンポーネントの後に現れる可能性がある。これは、ターゲットコンピュータ上の特定のタイプのオブジェクトが、アドレス指定の境界によって制限される可能性があるという事実に起因していた。</target>
        </trans-unit>
        <trans-unit id="485d42c3c1cc52f4609fde614c3f8a2bcc9d8359" translate="yes" xml:space="preserve">
          <source>p.s More detailed info are available here: &quot;Samuel P.Harbison, Guy L.Steele C A Reference, (5.6.2 - 5.6.7)&quot;</source>
          <target state="translated">p.s より詳細な情報はこちらにあります。&quot;サミュエル・P・ハービソン、ガイ・L・スティールC・A・リファレンス、(5.6.2〜5.6.7)&quot;</target>
        </trans-unit>
        <trans-unit id="89c2cc66d89a575cb42b6a1dca58093a04f698d4" translate="yes" xml:space="preserve">
          <source>unnamed bit fields may be included in the structure to the required address alignments of adjacent elements</source>
          <target state="translated">無名ビットフィールドは、隣接する要素の必要なアドレス配列に構造体に含まれてもよい。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
