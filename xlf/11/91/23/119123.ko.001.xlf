<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/119123">
    <body>
      <group id="119123">
        <trans-unit id="ea7c1d190a3bb5944cb0b253e4ec0b66b24d634d" translate="yes" xml:space="preserve">
          <source>&quot;memory holes&quot; size included in the result of sizeof operator. The sizeof only doesn't include size of the flexible array, which is available in C/C++</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&quot;메모리 홀&quot;크기는 sizeof 연산자의 결과에 포함됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;sizeof에는 C / C ++에서 사용할 수있는 유연한 배열의 크기 만 포함되지 않습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5e2a1eeaafd0038588279f1b10325b005bf97c7f" translate="yes" xml:space="preserve">
          <source>13 ... There may be unnamed
  padding within a structure object, but not at its beginning.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;13 ... 구조 객체 내에 이름없는 패딩이있을 수 있지만 시작 부분에는 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3a613654ca642a6d6767394e0d27f74611b755db" translate="yes" xml:space="preserve">
          <source>15 There may be unnamed padding at the end of a structure or union.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;15 구조체 나 공용체 끝에 이름없는 패딩이있을 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2d0e33ec380d07996b4f8bc86ea785141c22b59" translate="yes" xml:space="preserve">
          <source>16 As a special case, the last element of a structure with more than one named member may
  have an incomplete array type; this is called a flexible array member. In most situations,
  the flexible array member is ignored. In particular, the size of the structure is as if the
  flexible array member were omitted except that it may have more trailing padding than
  the omission would imply.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특별한 경우, 하나 이상의 명명 된 멤버를 가진 구조의 마지막 요소는 불완전한 배열 유형을 가질 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것을 유연한 배열 구성원이라고합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분의 경우 가변 배열 멤버는 무시됩니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특히, 구조의 크기는가요 성 어레이 부재가 생략되는 것보다 더 많은 후미 패딩을 가질 수 있다는 것을 제외하고는가요 성 어레이 부재가 생략 된 것과 같다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="414bb92964f7ecfad2604e92821062f2dac17ee9" translate="yes" xml:space="preserve">
          <source>2 When applied
  to a class, the result is the number of bytes in an object of that class including any padding required for
  placing objects of that type in an array.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2 클래스에 적용하면 결과는 해당 유형의 객체를 배열에 배치하는 데 필요한 패딩을 포함하여 해당 클래스의 객체에있는 바이트 수입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6486cec944fa9f9b2c41ecd5df485da4ac35f4f6" translate="yes" xml:space="preserve">
          <source>3 When applied to an operand that has structure or union type,
  the result is the total number of bytes in such an object,
  including internal and trailing padding.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;3 구조 또는 공용체 유형을 가진 피연산자에 적용되면 결과는 내부 및 후행 패딩을 포함하여 이러한 오브젝트의 총 바이트 수입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aaf36019e7beaa5a1dc4358651e76a80f0f859e0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;5.3.3 Sizeof&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;5.3.3 크기&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f80c22edb72b0170a8c7a0c869a36093f9988bf4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;6.5.3.4 The sizeof operator&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;6.5.3.4 연산자의 크기&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="21a6950949f9380e1a80fd038021e59aace62bc7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;6.7.2.1 Structure and union specifiers&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;6.7.2.1 구조 및 공용체 지정자&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c188ad2443c540567c7c8daa7cb2648fb19b97d4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;9.2 Class members&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;9.2 반원&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abf975a1f9f225f38e7cef1f183b3da09c979010" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Annex J Portability Issues&lt;/em&gt; reiterates:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;부속서 J 이식성 문제는 다음을&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 반복한다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="377bd7d244fc6b72e96059fb9cb766841edd1758" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;TL;DR:&lt;/em&gt; alignment is important.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TL; DR :&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 정렬이 중요합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9fa5697a62922f95e3c60e9368cd06101ac9527b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C language leaves compiler some freedom about the location of the structural elements in the memory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C 언어는 메모리에서 구조적 요소의 위치에 대해 컴파일러에게 약간의 자유를 남깁니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a886700572b9c57d6d491254156f6437d6d04fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11 N3337 standard draft&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11 N3337 표준 초안&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fd7453bed259332b62ae40bd66abc3750697afe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C99 N1256 standard draft&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99 N1256 표준 초안&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d146a42b33f5eb7eee5f1ff1d6e895f68382d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How alignment works:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정렬 작동 방식 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee4d41c0c55cf4eaa96f769b13f7cb0313a1edf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problems related to the elements alignment:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;요소 정렬과 관련된 문제 :&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="26078666e7e6283d98fb3cd8206541206faed3f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The C language provides some assurance to the programmer of the elements layout in the structure:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C 언어는 프로그래머가 구조의 요소 레이아웃을 확실하게 보장합니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08001831948aa1e7c2fcc0fae1677699501a9e43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You need to have good reasons to change it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;변경해야 할 이유가 충분해야합니다.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc6c36591832366db6e1e320835a5a82435c7f21" translate="yes" xml:space="preserve">
          <source>A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its
  initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note:
  There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning,
  as necessary to achieve appropriate alignment. &amp;mdash; end note ]</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;reinterpret_cast를 사용하여 적절히 변환 된 표준 레이아웃 구조체 객체에 대한 포인터는 초기 멤버 (또는 해당 멤버가 비트 필드 인 경우 해당 필드가있는 단위)를 가리키고 그 반대도 마찬가지입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;[참고 : 표준 레이아웃 구조체 안에는 이름이없는 패딩이있을 수 있지만, 적절한 정렬을 위해 필요한만큼 시작 부분에는 없습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;mdash; 끝 참고]&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d0aab459ec3221328ef34032b641bed6c8e7308" translate="yes" xml:space="preserve">
          <source>Address of the first component coincides with the start address of the structure</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;첫 번째 구성 요소의 주소는 구조의 시작 주소와 일치합니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ccbd2e21cfcc46e0e9d663d870a070b41c7d2362" translate="yes" xml:space="preserve">
          <source>Also a library may be compiled under x86 with 32-bit ints and you may be comparing its components on a 64-bit process would would give you a different result if you were doing this by hand.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 라이브러리는 32 비트 정수로 x86에서 컴파일 될 수 있으며 64 비트 프로세스에서 해당 구성 요소를 비교하면 수동으로 수행하는 경우 다른 결과를 얻을 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4f7afdabaf1875c8c3d894b087ea225e9b39d84e" translate="yes" xml:space="preserve">
          <source>But it's much, much easier on the processor if the compiler arranges
  it like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 컴파일러가 다음과 같이 정렬하면 프로세서에서 훨씬 더 쉽습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="942fdac75ab408f0da705c35d5ba37390764f845" translate="yes" xml:space="preserve">
          <source>Computers differ on how to store the bytes in a word (Intel 80x86 and Motorola 68000)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴퓨터는 바이트를 단어로 저장하는 방법이 다릅니다 (Intel 80x86 및 Motorola 68000)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="604bde069a55581721b9d22581417c64232f332a" translate="yes" xml:space="preserve">
          <source>Different computers line the edges of objects in different ways</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 컴퓨터는 다른 방식으로 개체의 가장자리를 따라&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9d956ba7ff3840f2bab2c9e6daeb95400655a424" translate="yes" xml:space="preserve">
          <source>Different restrictions on the width of the bit field</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;비트 필드의 너비에 대한 다른 제한&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4fab0d756aeaaafa4d8a6d6e1128251336f7627d" translate="yes" xml:space="preserve">
          <source>Either corrected in hardware, for a modest performance-degradation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;적당한 성능 저하를 위해 하드웨어에서 수정되었습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d95360439bed52475c90194b8b2cbab73ee89644" translate="yes" xml:space="preserve">
          <source>Finally, note that cache lines can be arbitrarily large, and the compiler doesn't attempt to guess at those or make a space-vs-speed tradeoff. Instead, the alignment decisions are part of the ABI and represent the minimum alignment that will eventually evenly fill up a cache line.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;마지막으로 캐시 라인은 임의로 커질 수 있으며 컴파일러는이를 추측하거나 공간 대 속도를 절충하지 않습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대신, 정렬 결정은 ABI의 일부이며 결국 캐시 라인을 균일하게 채울 최소 정렬을 나타냅니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ce0b0e3b463737dec1f994b52eb1aa91d0e6fd2d" translate="yes" xml:space="preserve">
          <source>For example.  Consider the simple structure:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단한 구조를 고려하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="016c76e5c39673125f64e48a16c383be180081f4" translate="yes" xml:space="preserve">
          <source>Have members who's sizes (in bytes) are 4 bytes (32 bits), 8 bytes (2x 32 bits) and 1 byte (2+6 bits) respectively.  The above program (on Linux using gcc) prints the sizes as 4, 8, and 4 - where the last structure is padded so that it is a single word (4 x 8 bit bytes on my 32bit platform).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;크기 (바이트)의 멤버는 각각 4 바이트 (32 비트), 8 바이트 (2x 32 비트) 및 1 바이트 (2 + 6 비트)입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위의 프로그램 (gcc를 사용하는 Linux에서)은 4, 8 및 4로 크기를 인쇄합니다. 여기서 마지막 구조는 단일 단어 (32 비트 플랫폼에서 4 x 8 비트 바이트)가되도록 채워집니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="16e342eef65fa14dd4d6fc2bf54314327cdc559a" translate="yes" xml:space="preserve">
          <source>Here's an example using typical settings for an x86 processor (all used 32 and 64 bit modes):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 x86 프로세서 (모든 32 및 64 비트 모드 사용)에 대한 일반적인 설정을 사용하는 예입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8e72a837533fa3fdedba99cab0b561c4d002f62" translate="yes" xml:space="preserve">
          <source>I only know enough C++ to understand the note :-)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 메모를 이해하기에 충분한 C ++ 만 알고 있습니다 :-)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f3e48a60aeb815a325f337b288e38ee3446848a4" translate="yes" xml:space="preserve">
          <source>I should now have the length of 11.  Without the pragma, I could be anything from 11 to 14 (and for some systems, as much as 32), depending on the default packing of the compiler.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제는 길이가 11이되어야합니다. pragma가 없으면 컴파일러의 기본 패킹에 따라 11에서 14까지 (그리고 일부 시스템에서는 32까지) 될 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e2ec884c97791749c41744efb39836e58381495c" translate="yes" xml:space="preserve">
          <source>I'm quite sure &lt;strong&gt;member-order &lt;em&gt;is&lt;/em&gt; guaranteed in C&lt;/strong&gt;, but I wouldn't count on it, when writing a cross-platform or cross-compiler program.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;나는 &lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C에서 &lt;/font&gt;&lt;/strong&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;멤버 순서 &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 보장된다고&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 확신 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;하지만 크로스 플랫폼 또는 크로스 컴파일러 프로그램을 작성할 때 그것을 믿을 수는 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="294eaa44c9c9070356fdb5156a7a6c6f5c27332e" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: Both the C and C++ standards state that structure alignment is implementation-defined.  Therefore each compiler may choose to align data differently, resulting in different and incompatible data layouts.  For this reason, when dealing with libraries that will be used by different compilers, it is important to understand how the compilers align data.  Some compilers have command-line settings and/or special &lt;code&gt;#pragma&lt;/code&gt; statements to change the structure alignment settings.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;중요 참고 사항 : C 및 C ++ 표준은 구조 정렬이 구현 정의되어 있다고 명시하고 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 각 컴파일러는 데이터를 다르게 정렬하여 서로 다른 호환되지 않는 데이터 레이아웃을 만들 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이러한 이유로 다른 컴파일러에서 사용할 라이브러리를 처리 할 때 컴파일러가 데이터를 정렬하는 방법을 이해하는 것이 중요합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일부 컴파일러에는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구조 정렬 설정을 변경하기위한 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;명령 줄 설정 및 / 또는 특수한 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;#pragma&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 문이 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8f55e5a98bbf66b8be5db53541346322d59f2a53" translate="yes" xml:space="preserve">
          <source>If the machine is a 32-bit machine and data is aligned on a 32-bit boundary, we see an immediate problem (assuming no structure alignment).  In this example, let us assume that the structure data starts at address 1024 (0x400 - note that the lowest 2 bits are zero, so the data is aligned to a 32-bit boundary).  The access to data.a will work fine because it starts on a boundary - 0x400.  The access to data.b will also work fine, because it is at address 0x404 - another 32-bit boundary.  But an unaligned structure would put data.c at address 0x405.  The 4 bytes of data.c are at 0x405, 0x406, 0x407, 0x408.  On a 32-bit machine, the system would read data.c during one memory cycle, but would only get 3 of the 4 bytes (the 4th byte is on the next boundary).  So, the system would have to do a second memory access to get the 4th byte,</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;머신이 32 비트 머신이고 데이터가 32 비트 경계에 정렬되면 즉각적인 문제가 발생합니다 (구조 정렬이 없다고 가정). 이 예에서는 구조 데이터가 주소 1024에서 시작한다고 가정합니다 (0x400-가장 낮은 2 비트가 0이므로 데이터가 32 비트 경계에 정렬 됨). data.a에 대한 액세스는 0x400 경계에서 시작하기 때문에 제대로 작동합니다. data.b에 대한 액세스는 또 다른 32 비트 경계인 주소 0x404에 있기 때문에 제대로 작동합니다. 그러나 정렬되지 않은 구조는 data.c를 주소 0x405에 넣습니다. data.c의 4 바이트는 0x405, 0x406, 0x407, 0x408에 있습니다. 32 비트 시스템에서 시스템은 한 메모리주기 동안 data.c를 읽지 만 4 바이트 중 3 바이트 만 가져옵니다 (4 번째 바이트는 다음 경계에 있음). 따라서 시스템은 4 번째 바이트를 얻기 위해 두 번째 메모리 액세스를 수행해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bccaf1969a6bb184c03be12d89b4357316a42879" translate="yes" xml:space="preserve">
          <source>If you want the structure to have a certain size with GCC for example use &lt;a href=&quot;http://digitalvampire.org/blog/index.php/2006/07/31/why-you-shouldnt-use-__attribute__packed/&quot;&gt;&lt;code&gt;__attribute__((packed))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 GCC를 사용하여 구조체의 특정 크기를 가지려면 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://digitalvampire.org/blog/index.php/2006/07/31/why-you-shouldnt-use-__attribute__packed/&quot;&gt; &lt;code&gt;__attribute__((packed))&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="deb7d9021009a9e869a35d0946526f7b0aeab08c" translate="yes" xml:space="preserve">
          <source>In addition to the other answers, a struct can (but usually doesn't) have virtual functions, in which case the size of the struct will also include the space for the vtbl.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다른 답변 외에도 구조체는 가상 함수를 가질 수 있지만 일반적으로 구조체의 크기는 vtbl의 공간을 포함합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ecdc60512add6ea34f6cbca0736e5590bbeb5481" translate="yes" xml:space="preserve">
          <source>In addition to the previous answers, please note that regardless the packaging, &lt;strong&gt;there is no members-order-guarantee in C++&lt;/strong&gt;. Compilers may (and certainly do) add virtual table pointer and base structures' members to the structure. Even the existence of virtual table is not ensured by the standard (virtual mechanism implementation is not specified) and therefore one can conclude that such guarantee is just impossible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이전 답변 외에도 포장에 관계없이 &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++에는 멤버 주문 보증이 없습니다&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;컴파일러는 가상 테이블 포인터와 기본 구조의 멤버를 구조에 추가 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가상 테이블의 존재조차 표준 (가상 메커니즘 구현이 지정되지 않음)에 의해 보장되지 않으므로 그러한 보장이 불가능하다는 결론을 내릴 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1165438f2f662510c6a05ae168ff5e92e07c7d9" translate="yes" xml:space="preserve">
          <source>In addition, atomicity and other concurrency-guarantees might be broken, leading to subtle errors.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또한 원 자성 및 기타 동시성 보증이 손상되어 미묘한 오류가 발생할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ace871547625d99f1b3513de67ddbf1ecd1ed28f" translate="yes" xml:space="preserve">
          <source>In the packed version, notice how it's at least a little bit hard for
  you and me to see how the b and c fields wrap around? In a nutshell,
  it's hard for the processor, too. Therefore, most compilers will pad
  the structure (as if with extra, invisible fields) like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;압축 버전에서 b와 c 필드가 어떻게 감싸 지는지 당신과 내가 조금 어려워하는 것을 보아라. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;간단히 말해서 프로세서도 어렵습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;따라서 대부분의 컴파일러는 다음과 같이 구조를 채 웁니다 (추가의 보이지 않는 필드가있는 것처럼).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6387af3b2046a0f60a53cd633291987de3402796" translate="yes" xml:space="preserve">
          <source>It can do so if you have implicitly or explicitly set the alignment of the struct. A struct that is aligned 4 will always be a multiple of 4 bytes even if the size of its members would be something that's not a multiple of 4 bytes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구조체의 정렬을 암시 적으로 또는 명시 적으로 설정 한 경우 그렇게 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;4로 정렬 된 구조체는 멤버의 크기가 4 바이트의 배수가 아닌 경우에도 항상 4 바이트의 배수입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3ebd1a765829877290c265b234786e66158f299f" translate="yes" xml:space="preserve">
          <source>It's for alignment. Many processors can't access 2- and 4-byte
  quantities (e.g. ints and long ints) if they're crammed in
  every-which-way.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정렬을위한 것입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대부분의 프로세서는 2 바이트 및 4 바이트 수량 (예 : int 및 long int)에 액세스 할 수 없습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c2689f2719ba1b44a9adf74baccfccbd020a7e67" translate="yes" xml:space="preserve">
          <source>Mis-aligned access might be a hard error (often &lt;code&gt;SIGBUS&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;잘못 정렬 된 액세스는 어려운 오류 일 수 있습니다 (종종 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;SIGBUS&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3a118237ea1794dca6417aa40286dd801d9cf4ae" translate="yes" xml:space="preserve">
          <source>Mis-aligned access might be a soft error.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;잘못 정렬 된 액세스는 소프트 오류 일 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="513a0a6fb061f5730b3144ab01c46ffceaf5a848" translate="yes" xml:space="preserve">
          <source>Now, if instead of putting data.c at address 0x405, the compiler padded the structure by 3 bytes and put data.c at address 0x408, then the system would only need 1 cycle to read the data, cutting access time to that data element by 50%.  Padding swaps memory efficiency for processing efficiency.  Given that computers can have huge amounts of memory (many gigabytes), the compilers feel that the swap (speed over size) is a reasonable one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제 data.c를 주소 0x405에 넣는 대신 컴파일러가 구조를 3 바이트로 채우고 data.c를 주소 0x408에 놓으면 시스템은 데이터를 읽는 데 1 주기만 필요하므로 해당 데이터 요소에 대한 액세스 시간이 줄어 듭니다. 50 %까지 패딩은 처리 효율성을 위해 메모리 효율성을 교체합니다. 컴퓨터가 엄청난 양의 메모리 (수 기가 바이트)를 가질 수 있다고 가정하면 컴파일러는 스왑 (크기 초과 속도)이 합리적이라고 생각합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c02ec6a18a5ab1ca633a0e2b2293f779e6729575" translate="yes" xml:space="preserve">
          <source>Now, you might think that it ought to be possible to pack this
  structure into memory like this:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이제이 구조를 다음과 같이 메모리에 묶을 수 있다고 생각할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="32a8824f2732921a3dc9ac7db52b26ca85ce9b0d" translate="yes" xml:space="preserve">
          <source>On Windows you can set the alignment to one byte when using the cl.exe compier with the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xh3e3fd0(VS.80).aspx&quot;&gt;/Zp option&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Windows에서는 cl.exe compier를 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xh3e3fd0(VS.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;/ Zp 옵션&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 과 함께 사용할 때 정렬을 1 바이트로 설정할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a3668a1ac342860ec9ca845b4c68d75816f250d2" translate="yes" xml:space="preserve">
          <source>On the other hand, different compilers have different abilities to manage data structure packing.  For example, in Visual C/C++ the compiler supports the #pragma pack command.  This will allow you to adjust data packing and alignment.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;반면에, 컴파일러마다 데이터 구조 패킹을 관리하는 능력이 다릅니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 Visual C / C ++에서 컴파일러는 #pragma pack 명령을 지원합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 통해 데이터 패킹 및 정렬을 조정할 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="88ee5aad6a5759dd6df5e6b7f54b322f1e3d1a19" translate="yes" xml:space="preserve">
          <source>One can minimize the size of structures by sorting members by alignment (sorting by size suffices for that in basic types) (like structure &lt;code&gt;Z&lt;/code&gt; in the example above).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정렬 (기본 유형의 경우 충분한 크기로 정렬) ( &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;위의 예에서 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구조 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Z&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 와 같은)로 멤버를 정렬하여 구조의 크기를 최소화 할 수 있습니다 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b2051d9503bb13db117acc5804d15184f6ad617" translate="yes" xml:space="preserve">
          <source>Or corrected by emulation in software, for a severe performance-degradation.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;또는 심각한 성능 저하를 위해 소프트웨어의 에뮬레이션으로 수정합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a61f3cc584a463a50abd933541448f7a1510020" translate="yes" xml:space="preserve">
          <source>Packing and byte alignment, as described in the C FAQ &lt;a href=&quot;http://www.c-faq.com/struct/align.html&quot;&gt;here&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;패킹 및 바이트 정렬은 FAQ C에 설명 된대로 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.c-faq.com/struct/align.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;여기서&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">또한보십시오:</target>
        </trans-unit>
        <trans-unit id="e51388dd1717e14df9b26e7234fe77926f42a0cc" translate="yes" xml:space="preserve">
          <source>So it is a matter of alignment basically.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;기본적으로 정렬 문제입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fc509e8f6989fc2315b358c504ab268f0ae96c3b" translate="yes" xml:space="preserve">
          <source>Some architectures actually have to trap on misaligned reads and writes, and early versions of the ARM architecture (the one that evolved into all of today's mobile CPUs) ... well, they actually just returned bad data on for those. (They ignored the low-order bits.)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일부 아키텍처는 실제로 잘못 정렬 된 읽기 및 쓰기와 ARM 아키텍처의 초기 버전 (오늘날 모든 모바일 CPU로 발전한 아키텍처)을 포착해야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;(그들은 하위 비트를 무시했습니다.)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2d46e21969464a09e749253c1f1ceb8893528076" translate="yes" xml:space="preserve">
          <source>Some implementations of the language allow you to control the memory layout of structures through the pragma and compiler options</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;언어의 일부 구현을 통해 pragma 및 컴파일러 옵션을 통해 구조의 메모리 레이아웃을 제어 할 수 있습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0d5376a9dd3697fd748da016e1a1e6878df4b2bc" translate="yes" xml:space="preserve">
          <source>Suppose you have this structure:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이 구조가 있다고 가정하십시오.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ddaf43b8dd1e7ca463e43724a0c0b99e17c1da5d" translate="yes" xml:space="preserve">
          <source>The following are unspecified: ...</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음은 지정되지 않았습니다 : ...&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="557fb633b2d3a651a208a4c56f8be2abf1811a85" translate="yes" xml:space="preserve">
          <source>The idea is that for speed and cache considerations, operands should be read from addresses aligned to their natural size. To make this happen, the compiler pads structure members so the following member or following struct will be aligned.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;속도와 캐시를 고려할 때는 피연산자를 원래 크기로 정렬 된 주소에서 읽어야합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이를 위해 컴파일러는 구조체 멤버를 패딩하여 다음 멤버 또는 다음 구조체가 정렬되도록합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ac87bc7429d319da13ae1718721e8b3300d3b44" translate="yes" xml:space="preserve">
          <source>The new C99 &lt;a href=&quot;https://en.wikipedia.org/wiki/Flexible_array_member&quot;&gt;flexible array member feature&lt;/a&gt; (&lt;code&gt;struct S {int is[];};&lt;/code&gt;) may also affect padding:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;새로운 C99 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Flexible_array_member&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;가변 배열 멤버 기능&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct S {int is[];};&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; )도 패딩에 영향을 줄 수 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae22a4d57fbaa7519083255dde796c5c49ce9e0c" translate="yes" xml:space="preserve">
          <source>The size of a structure is greater than the sum of its parts because of what is called packing.  A particular processor has a preferred data size that it works with.  Most modern processors' preferred size if 32-bits (4 bytes).  Accessing the memory when data is on this kind of boundary is more efficient than things that straddle that size boundary.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구조의 크기는 소위 패킹 (packing)으로 인해 부분의 합보다 큽니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;특정 프로세서는 선호하는 데이터 크기를 가지고 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;32 비트 (4 바이트) 인 경우 최신 프로세서의 기본 크기입니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터가 이런 종류의 경계에있을 때 메모리에 액세스하는 것이 해당 크기 경계를 넘는 것보다 효율적입니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ca97b0953d30171167667ce55c7fadde376f89bc" translate="yes" xml:space="preserve">
          <source>The value of padding bytes when storing values in structures or unions (6.2.6.1)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구조체 또는 공용체에 값을 저장할 때 패딩 바이트 값 (6.2.6.1)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f1f5f526e00e194bf748da381444f712f26f309c" translate="yes" xml:space="preserve">
          <source>The volume occupied by the structure is calculated as the size of the aligned single element of an array of such structures. The structure should
end so that the first element of the next following structure does not  the violate requirements of alignment</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구조가 차지하는 부피는 그러한 구조의 어레이의 정렬 된 단일 요소의 크기로서 계산된다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;다음 구조의 첫 번째 요소가 정렬 요구 사항을 위반하지 않도록 구조를 종료해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="406a67a4fa9005324820eb336336121fd7305573" translate="yes" xml:space="preserve">
          <source>The x86 architecture has always been able to fetch misaligned addresses. However, it's slower and when the misalignment overlaps two different cache lines, then it evicts two cache lines when an aligned access would only evict one.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;x86 아키텍처는 항상 잘못 정렬 된 주소를 가져올 수있었습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;그러나 속도가 느리고 정렬 불량이 두 개의 다른 캐시 라인과 겹치면 정렬 된 액세스가 하나만 제거 할 때 두 개의 캐시 라인을 제거합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fb8544544c4807c55180a86a810e88b25115025a" translate="yes" xml:space="preserve">
          <source>This can be due to byte alignment and padding so that the structure comes out to an even number of bytes (or words) on your platform.  For example in C on Linux, the following 3 structures:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이것은 바이트 정렬 및 패딩으로 인해 구조가 플랫폼의 짝수 바이트 (또는 단어)로 나올 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;예를 들어 Linux의 C에서는 다음 3 가지 구조가 있습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e336f18147602a9e44b58d1d7ec400b46830669b" translate="yes" xml:space="preserve">
          <source>This is because of padding added to satisfy alignment constraints. &lt;a href=&quot;http://en.wikipedia.org/wiki/Data_structure_alignment&quot;&gt;Data structure alignment&lt;/a&gt; impacts both performance and correctness of programs:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;정렬 제약 조건을 만족시키기 위해 추가 된 패딩 때문입니다. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Data_structure_alignment&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;데이터 구조 정렬&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 은 프로그램의 성능과 정확성에 모두 영향을줍니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b9def9e505b956b3d279e42e0805991573c33ec" translate="yes" xml:space="preserve">
          <source>Unfortunately, this problem becomes a killer when you attempt to send structures over a network or even write the binary data to a binary file.  The padding inserted between elements of a structure or class can disrupt the data sent to the file or network.  In order to write portable code (one that will go to several different compilers), you will probably have to access each element of the structure separately to ensure the proper &quot;packing&quot;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;불행히도 네트워크를 통해 구조를 보내거나 이진 데이터를 이진 파일에 쓰려고 할 때이 문제가 발생합니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구조 또는 클래스의 요소 사이에 삽입 된 패딩은 파일 또는 네트워크로 전송 된 데이터를 방해 할 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이식 가능한 코드 (여러 개의 다른 컴파일러로 이동하는 코드)를 작성하려면 적절한 &quot;패킹&quot;을 보장하기 위해 구조의 각 요소에 개별적으로 액세스해야합니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9165e18e12f4d78ce348dd02fe45f9811c84f27c" translate="yes" xml:space="preserve">
          <source>Usually it is easier for the CPU to access data that is a multiple of 4 (or 8), depending platform and also on the compiler.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;일반적으로 CPU는 플랫폼 및 컴파일러에 따라 4 (또는 8)의 배수 인 데이터에 액세스하는 것이 더 쉽습니다.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="72869ecb22c8d2fdf1241784ec34500810b4e780" translate="yes" xml:space="preserve">
          <source>Why does the &lt;code&gt;sizeof&lt;/code&gt; operator return a size larger for a structure than the total sizes of the structure's members?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; 연산자가 구조체의 전체 크기보다 구조체에 대해 더 큰 크기를 반환하는 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;이유는 무엇 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;입니까?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="efe745f9a67d720491c39c539175db72ee5c6ff1" translate="yes" xml:space="preserve">
          <source>Why isn't sizeof for a struct equal to the sum of sizeof of each member</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;구조체의 sizeof가 각 멤버의 sizeof의 합과 같지 않은 이유&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bd737ee4afc1c36b62b054b4187c4c65a756473c" translate="yes" xml:space="preserve">
          <source>and GCC claim compatibility with Microsoft's compiler.:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;GCC는 Microsoft 컴파일러와의 호환성을 주장합니다. :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="c2ce592b3a7afb19f38698f51ee6c23405bc1dd2" translate="yes" xml:space="preserve">
          <source>compilers required to assign a sequence of components increasing memory addresses</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 주소를 증가시키는 일련의 구성 요소를 할당하는 데 필요한 컴파일러&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b4941e95d6969cbd6a59124474f4bf102b829bf0" translate="yes" xml:space="preserve">
          <source>for Microsoft Visual C:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Microsoft Visual C의 경우 :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="60684e9bc6c2d2147799fb30975595f09663af5b" translate="yes" xml:space="preserve">
          <source>memory holes may appear between any two components, and after the last component. It was due to the fact that certain types of objects on the target computer may be limited by the boundaries of addressing</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;메모리 구멍은 두 구성 요소 사이와 마지막 구성 요소 뒤에 나타날 수 있습니다. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;대상 컴퓨터의 특정 유형의 개체는 주소 지정의 경계에 의해 제한 될 수 있기 때문입니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="485d42c3c1cc52f4609fde614c3f8a2bcc9d8359" translate="yes" xml:space="preserve">
          <source>p.s More detailed info are available here: &quot;Samuel P.Harbison, Guy L.Steele C A Reference, (5.6.2 - 5.6.7)&quot;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ps 더 자세한 정보는 여기에 있습니다 : &quot;Samuel P.Harbison, Guy L.Steele CA Reference, (5.6.2-5.6.7)&quot;&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="89c2cc66d89a575cb42b6a1dca58093a04f698d4" translate="yes" xml:space="preserve">
          <source>unnamed bit fields may be included in the structure to the required address alignments of adjacent elements</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;명명되지 않은 비트 필드는 인접한 요소의 필요한 주소 정렬에 대한 구조에 포함될 수 있습니다&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
