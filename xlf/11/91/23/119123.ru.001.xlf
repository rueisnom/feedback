<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/119123">
    <body>
      <group id="119123">
        <trans-unit id="ea7c1d190a3bb5944cb0b253e4ec0b66b24d634d" translate="yes" xml:space="preserve">
          <source>&quot;memory holes&quot; size included in the result of sizeof operator. The sizeof only doesn't include size of the flexible array, which is available in C/C++</source>
          <target state="translated">размер &quot;отверстий в памяти&quot;,включенный в результат sizeof оператора.В sizeof не включен только размер гибкого массива,который доступен в CC++</target>
        </trans-unit>
        <trans-unit id="5e2a1eeaafd0038588279f1b10325b005bf97c7f" translate="yes" xml:space="preserve">
          <source>13 ... There may be unnamed
  padding within a structure object, but not at its beginning.</source>
          <target state="translated">13 ...Внутри объекта структуры может быть безымянная подкладка,но не в его начале.</target>
        </trans-unit>
        <trans-unit id="3a613654ca642a6d6767394e0d27f74611b755db" translate="yes" xml:space="preserve">
          <source>15 There may be unnamed padding at the end of a structure or union.</source>
          <target state="translated">15 В конце структуры или союза может быть безымянная набивка.</target>
        </trans-unit>
        <trans-unit id="e2d0e33ec380d07996b4f8bc86ea785141c22b59" translate="yes" xml:space="preserve">
          <source>16 As a special case, the last element of a structure with more than one named member may
  have an incomplete array type; this is called a flexible array member. In most situations,
  the flexible array member is ignored. In particular, the size of the structure is as if the
  flexible array member were omitted except that it may have more trailing padding than
  the omission would imply.</source>
          <target state="translated">16 В особом случае последний элемент структуры с более чем одним именованным членом может иметь неполный тип массива;это называется гибким членом массива.В большинстве ситуаций член гибкого массива игнорируется.В частности,размер структуры выглядит так,как будто член гибкого массива опущен,за исключением того,что он может иметь большее количество трейлингов,чем это может означать пропущение.</target>
        </trans-unit>
        <trans-unit id="414bb92964f7ecfad2604e92821062f2dac17ee9" translate="yes" xml:space="preserve">
          <source>2 When applied
  to a class, the result is the number of bytes in an object of that class including any padding required for
  placing objects of that type in an array.</source>
          <target state="translated">2 При применении к классу,результатом является количество байт в объекте этого класса,включая любую подкладку,необходимую для размещения объектов этого типа в массиве.</target>
        </trans-unit>
        <trans-unit id="6486cec944fa9f9b2c41ecd5df485da4ac35f4f6" translate="yes" xml:space="preserve">
          <source>3 When applied to an operand that has structure or union type,
  the result is the total number of bytes in such an object,
  including internal and trailing padding.</source>
          <target state="translated">3 При применении к операнду,имеющему структуру или союзный тип,результатом является общее количество байтов в таком объекте,включая внутреннюю и замыкающую прокладку.</target>
        </trans-unit>
        <trans-unit id="aaf36019e7beaa5a1dc4358651e76a80f0f859e0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;5.3.3 Sizeof&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;5.3.3 Размер&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f80c22edb72b0170a8c7a0c869a36093f9988bf4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;6.5.3.4 The sizeof operator&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;6.5.3.4 Размер оператора&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="21a6950949f9380e1a80fd038021e59aace62bc7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;6.7.2.1 Structure and union specifiers&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;6.7.2.1 Структура и объединение спецификаторов&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c188ad2443c540567c7c8daa7cb2648fb19b97d4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;9.2 Class members&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;9.2 Члены класса&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abf975a1f9f225f38e7cef1f183b3da09c979010" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Annex J Portability Issues&lt;/em&gt; reiterates:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Приложение J &amp;laquo;Проблемы переносимости&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; повторяет:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="377bd7d244fc6b72e96059fb9cb766841edd1758" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;TL;DR:&lt;/em&gt; alignment is important.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TL; DR:&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; выравнивание важно.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9fa5697a62922f95e3c60e9368cd06101ac9527b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C language leaves compiler some freedom about the location of the structural elements in the memory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Язык Си оставляет компилятору некоторую свободу относительно расположения структурных элементов в памяти:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a886700572b9c57d6d491254156f6437d6d04fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11 N3337 standard draft&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11 N3337 стандартная версия&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fd7453bed259332b62ae40bd66abc3750697afe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C99 N1256 standard draft&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99 N1256 стандартная тяга&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d146a42b33f5eb7eee5f1ff1d6e895f68382d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How alignment works:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Как работает выравнивание:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee4d41c0c55cf4eaa96f769b13f7cb0313a1edf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problems related to the elements alignment:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Проблемы, связанные с выравниванием элементов:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="26078666e7e6283d98fb3cd8206541206faed3f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The C language provides some assurance to the programmer of the elements layout in the structure:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Язык Си обеспечивает некоторую уверенность программиста в расположении элементов в структуре:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08001831948aa1e7c2fcc0fae1677699501a9e43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You need to have good reasons to change it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;У вас должны быть веские причины, чтобы изменить это.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc6c36591832366db6e1e320835a5a82435c7f21" translate="yes" xml:space="preserve">
          <source>A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its
  initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note:
  There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning,
  as necessary to achieve appropriate alignment. &amp;mdash; end note ]</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Указатель на объект структуры стандартной компоновки, соответствующим образом преобразованный с использованием reinterpret_cast, указывает на его начальный элемент (или, если этот элемент является битовым полем, то на модуль, в котором он находится), и наоборот. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;[Примечание: Поэтому в объекте структуры стандартной компоновки может быть безымянный отступ, но не в его начале, что необходимо для достижения соответствующего выравнивания. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;- конец примечания]&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d0aab459ec3221328ef34032b641bed6c8e7308" translate="yes" xml:space="preserve">
          <source>Address of the first component coincides with the start address of the structure</source>
          <target state="translated">Адрес первого компонента совпадает с адресом начала структуры</target>
        </trans-unit>
        <trans-unit id="ccbd2e21cfcc46e0e9d663d870a070b41c7d2362" translate="yes" xml:space="preserve">
          <source>Also a library may be compiled under x86 with 32-bit ints and you may be comparing its components on a 64-bit process would would give you a different result if you were doing this by hand.</source>
          <target state="translated">Также библиотека может быть скомпилирована под x86 с 32-битными инъекциями,и сравнение ее компонентов на 64-битном процессе дало бы другой результат,если бы вы делали это вручную.</target>
        </trans-unit>
        <trans-unit id="4f7afdabaf1875c8c3d894b087ea225e9b39d84e" translate="yes" xml:space="preserve">
          <source>But it's much, much easier on the processor if the compiler arranges
  it like this:</source>
          <target state="translated">Но гораздо,гораздо проще на процессоре,если компилятор его так организует:</target>
        </trans-unit>
        <trans-unit id="942fdac75ab408f0da705c35d5ba37390764f845" translate="yes" xml:space="preserve">
          <source>Computers differ on how to store the bytes in a word (Intel 80x86 and Motorola 68000)</source>
          <target state="translated">Компьютеры различаются тем,как хранить байты в одном слове (Intel 80x86 и Motorola 68000).</target>
        </trans-unit>
        <trans-unit id="604bde069a55581721b9d22581417c64232f332a" translate="yes" xml:space="preserve">
          <source>Different computers line the edges of objects in different ways</source>
          <target state="translated">Разные компьютеры по-разному выстраивают края объектов</target>
        </trans-unit>
        <trans-unit id="9d956ba7ff3840f2bab2c9e6daeb95400655a424" translate="yes" xml:space="preserve">
          <source>Different restrictions on the width of the bit field</source>
          <target state="translated">Различные ограничения на ширину битового поля</target>
        </trans-unit>
        <trans-unit id="4fab0d756aeaaafa4d8a6d6e1128251336f7627d" translate="yes" xml:space="preserve">
          <source>Either corrected in hardware, for a modest performance-degradation.</source>
          <target state="translated">Либо скорректировано в аппаратном обеспечении,для скромного падения производительности.</target>
        </trans-unit>
        <trans-unit id="d95360439bed52475c90194b8b2cbab73ee89644" translate="yes" xml:space="preserve">
          <source>Finally, note that cache lines can be arbitrarily large, and the compiler doesn't attempt to guess at those or make a space-vs-speed tradeoff. Instead, the alignment decisions are part of the ABI and represent the minimum alignment that will eventually evenly fill up a cache line.</source>
          <target state="translated">Наконец,обратите внимание,что строки кэша могут быть произвольно большими,и компилятор не пытается угадать на них или сделать компромисс между пространством и скоростью.Вместо этого,решения по выравниванию являются частью ABI и представляют собой минимальное выравнивание,которое в конечном итоге равномерно заполнит кэш-строку.</target>
        </trans-unit>
        <trans-unit id="ce0b0e3b463737dec1f994b52eb1aa91d0e6fd2d" translate="yes" xml:space="preserve">
          <source>For example.  Consider the simple structure:</source>
          <target state="translated">Например.Рассмотрим простую структуру:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="016c76e5c39673125f64e48a16c383be180081f4" translate="yes" xml:space="preserve">
          <source>Have members who's sizes (in bytes) are 4 bytes (32 bits), 8 bytes (2x 32 bits) and 1 byte (2+6 bits) respectively.  The above program (on Linux using gcc) prints the sizes as 4, 8, and 4 - where the last structure is padded so that it is a single word (4 x 8 bit bytes on my 32bit platform).</source>
          <target state="translated">Имеют члены с размерами (в байтах)4 байта (32 бита),8 байтов (2x 32 бита)и 1 байт (2+6 бит)соответственно.Вышеуказанная программа (на Linux,использующая gcc)печатает размеры как 4,8 и 4-где последняя структура пробита так,что это одно слово (4 x 8 байт на моей 32-битной платформе).</target>
        </trans-unit>
        <trans-unit id="16e342eef65fa14dd4d6fc2bf54314327cdc559a" translate="yes" xml:space="preserve">
          <source>Here's an example using typical settings for an x86 processor (all used 32 and 64 bit modes):</source>
          <target state="translated">Приведем пример,использующий типичные настройки для процессора x86 (все используемые 32 и 64-битные режимы):</target>
        </trans-unit>
        <trans-unit id="b8e72a837533fa3fdedba99cab0b561c4d002f62" translate="yes" xml:space="preserve">
          <source>I only know enough C++ to understand the note :-)</source>
          <target state="translated">Я знаю достаточно Си++только для того,чтобы понять ноту :-).</target>
        </trans-unit>
        <trans-unit id="f3e48a60aeb815a325f337b288e38ee3446848a4" translate="yes" xml:space="preserve">
          <source>I should now have the length of 11.  Without the pragma, I could be anything from 11 to 14 (and for some systems, as much as 32), depending on the default packing of the compiler.</source>
          <target state="translated">Теперь у меня должна быть длина 11.Без прагмы я мог бы быть чем угодно от 11 до 14 (а для некоторых систем-целых 32),в зависимости от стандартной упаковки компилятора.</target>
        </trans-unit>
        <trans-unit id="e2ec884c97791749c41744efb39836e58381495c" translate="yes" xml:space="preserve">
          <source>I'm quite sure &lt;strong&gt;member-order &lt;em&gt;is&lt;/em&gt; guaranteed in C&lt;/strong&gt;, but I wouldn't count on it, when writing a cross-platform or cross-compiler program.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я совершенно уверен , &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;член порядка &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;будет&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; гарантировано в C&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , но я бы не рассчитывал на это, при написании кросс-платформенных или кросс-компилятор программы.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="294eaa44c9c9070356fdb5156a7a6c6f5c27332e" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: Both the C and C++ standards state that structure alignment is implementation-defined.  Therefore each compiler may choose to align data differently, resulting in different and incompatible data layouts.  For this reason, when dealing with libraries that will be used by different compilers, it is important to understand how the compilers align data.  Some compilers have command-line settings and/or special &lt;code&gt;#pragma&lt;/code&gt; statements to change the structure alignment settings.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ВАЖНОЕ ПРИМЕЧАНИЕ. В стандартах C и C ++ указано, что выравнивание структуры определяется реализацией. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поэтому каждый компилятор может по-разному выравнивать данные, что приводит к разным и несовместимым макетам данных. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;По этой причине при работе с библиотеками, которые будут использоваться разными компиляторами, важно понимать, как компиляторы выравнивают данные. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Некоторые компиляторы имеют параметры командной строки и / или специальные &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;операторы &lt;/font&gt;&lt;/font&gt; &lt;code&gt;#pragma&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; для изменения настроек выравнивания структуры.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8f55e5a98bbf66b8be5db53541346322d59f2a53" translate="yes" xml:space="preserve">
          <source>If the machine is a 32-bit machine and data is aligned on a 32-bit boundary, we see an immediate problem (assuming no structure alignment).  In this example, let us assume that the structure data starts at address 1024 (0x400 - note that the lowest 2 bits are zero, so the data is aligned to a 32-bit boundary).  The access to data.a will work fine because it starts on a boundary - 0x400.  The access to data.b will also work fine, because it is at address 0x404 - another 32-bit boundary.  But an unaligned structure would put data.c at address 0x405.  The 4 bytes of data.c are at 0x405, 0x406, 0x407, 0x408.  On a 32-bit machine, the system would read data.c during one memory cycle, but would only get 3 of the 4 bytes (the 4th byte is on the next boundary).  So, the system would have to do a second memory access to get the 4th byte,</source>
          <target state="translated">Если машина является 32-битной и данные выравниваются по 32-битной границе,то мы видим непосредственную проблему (предполагая отсутствие выравнивания структуры).В данном примере предположим,что данные структуры начинаются по адресу 1024 (0x400-обратите внимание,что младшие 2 бита равны нулю,поэтому данные выравниваются по 32-битной границе).Доступ к data.a будет работать нормально,так как начинается на границе-0x400.Доступ к data.b также будет работать нормально,так как он находится по адресу 0x404-еще одна 32-битная граница.Но не выровненная структура поместит data.c по адресу 0x405.Четыре байта data.c находятся по адресам 0x405,0x406,0x407,0x408.На 32-битной машине система будет читать data.c в течение одного цикла памяти,но получит только 3 из 4 байт (4-й байт находится на следующей границе).Таким образом,для получения 4-го байта системе пришлось бы делать второй доступ к памяти,</target>
        </trans-unit>
        <trans-unit id="bccaf1969a6bb184c03be12d89b4357316a42879" translate="yes" xml:space="preserve">
          <source>If you want the structure to have a certain size with GCC for example use &lt;a href=&quot;http://digitalvampire.org/blog/index.php/2006/07/31/why-you-shouldnt-use-__attribute__packed/&quot;&gt;&lt;code&gt;__attribute__((packed))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы хотите, чтобы структура имела определенный размер с GCC, например, используйте &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://digitalvampire.org/blog/index.php/2006/07/31/why-you-shouldnt-use-__attribute__packed/&quot;&gt; &lt;code&gt;__attribute__((packed))&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="deb7d9021009a9e869a35d0946526f7b0aeab08c" translate="yes" xml:space="preserve">
          <source>In addition to the other answers, a struct can (but usually doesn't) have virtual functions, in which case the size of the struct will also include the space for the vtbl.</source>
          <target state="translated">В дополнение к другим ответам,структура может (но обычно не имеет)иметь виртуальные функции,и в этом случае размер структуры будет также включать пространство для vtbl.</target>
        </trans-unit>
        <trans-unit id="ecdc60512add6ea34f6cbca0736e5590bbeb5481" translate="yes" xml:space="preserve">
          <source>In addition to the previous answers, please note that regardless the packaging, &lt;strong&gt;there is no members-order-guarantee in C++&lt;/strong&gt;. Compilers may (and certainly do) add virtual table pointer and base structures' members to the structure. Even the existence of virtual table is not ensured by the standard (virtual mechanism implementation is not specified) and therefore one can conclude that such guarantee is just impossible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В дополнение к предыдущим ответам, пожалуйста, обратите внимание, что независимо от упаковки, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;в C ++ нет гарантии заказа членов&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Компиляторы могут (и, безусловно, делают) добавлять в структуру указатель виртуальной таблицы и члены базовых структур. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Даже существование виртуальной таблицы не обеспечивается стандартом (реализация виртуального механизма не указана), и поэтому можно сделать вывод, что такая гарантия просто невозможна.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1165438f2f662510c6a05ae168ff5e92e07c7d9" translate="yes" xml:space="preserve">
          <source>In addition, atomicity and other concurrency-guarantees might be broken, leading to subtle errors.</source>
          <target state="translated">Кроме того,атомарность и другие гарантии совпадения могут быть нарушены,что приведет к тонким ошибкам.</target>
        </trans-unit>
        <trans-unit id="ace871547625d99f1b3513de67ddbf1ecd1ed28f" translate="yes" xml:space="preserve">
          <source>In the packed version, notice how it's at least a little bit hard for
  you and me to see how the b and c fields wrap around? In a nutshell,
  it's hard for the processor, too. Therefore, most compilers will pad
  the structure (as if with extra, invisible fields) like this:</source>
          <target state="translated">В упакованной версии,заметьте,как это по крайней мере немного трудно для нас с вами,чтобы увидеть,как поля b и c обернулись вокруг? В двух словах,для процессора это тоже тяжело.Поэтому большинство компиляторов будут так набивать структуру (как будто с дополнительными,невидимыми полями):</target>
        </trans-unit>
        <trans-unit id="6387af3b2046a0f60a53cd633291987de3402796" translate="yes" xml:space="preserve">
          <source>It can do so if you have implicitly or explicitly set the alignment of the struct. A struct that is aligned 4 will always be a multiple of 4 bytes even if the size of its members would be something that's not a multiple of 4 bytes.</source>
          <target state="translated">Это можно сделать,если вы неявно или явно задали выравнивание структуры.Структура,выровненная по 4,всегда будет кратна 4 байтам,даже если размер ее членов будет не кратен 4 байтам.</target>
        </trans-unit>
        <trans-unit id="3ebd1a765829877290c265b234786e66158f299f" translate="yes" xml:space="preserve">
          <source>It's for alignment. Many processors can't access 2- and 4-byte
  quantities (e.g. ints and long ints) if they're crammed in
  every-which-way.</source>
          <target state="translated">Это для выравнивания.Многие процессоры не могут получить доступ к 2-и 4-байтовым количествам (например,чернила и длинные чернила),если они забиты во все стороны.</target>
        </trans-unit>
        <trans-unit id="c2689f2719ba1b44a9adf74baccfccbd020a7e67" translate="yes" xml:space="preserve">
          <source>Mis-aligned access might be a hard error (often &lt;code&gt;SIGBUS&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Неправильный доступ может быть серьезной ошибкой (часто &lt;/font&gt;&lt;/font&gt; &lt;code&gt;SIGBUS&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3a118237ea1794dca6417aa40286dd801d9cf4ae" translate="yes" xml:space="preserve">
          <source>Mis-aligned access might be a soft error.</source>
          <target state="translated">Неправильный доступ может быть мягкой ошибкой.</target>
        </trans-unit>
        <trans-unit id="513a0a6fb061f5730b3144ab01c46ffceaf5a848" translate="yes" xml:space="preserve">
          <source>Now, if instead of putting data.c at address 0x405, the compiler padded the structure by 3 bytes and put data.c at address 0x408, then the system would only need 1 cycle to read the data, cutting access time to that data element by 50%.  Padding swaps memory efficiency for processing efficiency.  Given that computers can have huge amounts of memory (many gigabytes), the compilers feel that the swap (speed over size) is a reasonable one.</source>
          <target state="translated">Теперь,если вместо того,чтобы поместить data.c по адресу 0x405,компилятор разбавил структуру на 3 байта и поместил data.c по адресу 0x408,то системе понадобился бы всего 1 цикл для чтения данных,сократив время доступа к этому элементу данных на 50%.Паддинг подменяет эффективность памяти на эффективность обработки.Учитывая,что компьютеры могут иметь огромный объем памяти (много гигабайт),компиляторы считают подкачку (скорость больше размера)разумной.</target>
        </trans-unit>
        <trans-unit id="c02ec6a18a5ab1ca633a0e2b2293f779e6729575" translate="yes" xml:space="preserve">
          <source>Now, you might think that it ought to be possible to pack this
  structure into memory like this:</source>
          <target state="translated">Теперь вы можете подумать,что эту структуру можно упаковать в память вот так:</target>
        </trans-unit>
        <trans-unit id="32a8824f2732921a3dc9ac7db52b26ca85ce9b0d" translate="yes" xml:space="preserve">
          <source>On Windows you can set the alignment to one byte when using the cl.exe compier with the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xh3e3fd0(VS.80).aspx&quot;&gt;/Zp option&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В Windows вы можете установить выравнивание в один байт при использовании компилятора cl.exe с параметром &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xh3e3fd0(VS.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;/ Zp&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a3668a1ac342860ec9ca845b4c68d75816f250d2" translate="yes" xml:space="preserve">
          <source>On the other hand, different compilers have different abilities to manage data structure packing.  For example, in Visual C/C++ the compiler supports the #pragma pack command.  This will allow you to adjust data packing and alignment.</source>
          <target state="translated">С другой стороны,разные компиляторы обладают разными возможностями по управлению упаковкой структуры данных.Например,в Visual CC++компилятор поддерживает команду #pragma pack.Это позволит настроить упаковку и выравнивание данных.</target>
        </trans-unit>
        <trans-unit id="88ee5aad6a5759dd6df5e6b7f54b322f1e3d1a19" translate="yes" xml:space="preserve">
          <source>One can minimize the size of structures by sorting members by alignment (sorting by size suffices for that in basic types) (like structure &lt;code&gt;Z&lt;/code&gt; in the example above).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Можно минимизировать размер структур путем сортировки элементов путем выравнивания (для базовых типов сортировки по размеру достаточно) (например, структура &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Z&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в приведенном выше примере).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b2051d9503bb13db117acc5804d15184f6ad617" translate="yes" xml:space="preserve">
          <source>Or corrected by emulation in software, for a severe performance-degradation.</source>
          <target state="translated">Или скорректировано эмуляцией в программном обеспечении,для серьезного снижения производительности.</target>
        </trans-unit>
        <trans-unit id="1a61f3cc584a463a50abd933541448f7a1510020" translate="yes" xml:space="preserve">
          <source>Packing and byte alignment, as described in the C FAQ &lt;a href=&quot;http://www.c-faq.com/struct/align.html&quot;&gt;here&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Упаковка и выравнивание байтов, как описано в C FAQ &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.c-faq.com/struct/align.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;здесь&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">См.также:</target>
        </trans-unit>
        <trans-unit id="e51388dd1717e14df9b26e7234fe77926f42a0cc" translate="yes" xml:space="preserve">
          <source>So it is a matter of alignment basically.</source>
          <target state="translated">Так что в основном это вопрос выравнивания.</target>
        </trans-unit>
        <trans-unit id="fc509e8f6989fc2315b358c504ab268f0ae96c3b" translate="yes" xml:space="preserve">
          <source>Some architectures actually have to trap on misaligned reads and writes, and early versions of the ARM architecture (the one that evolved into all of today's mobile CPUs) ... well, they actually just returned bad data on for those. (They ignored the low-order bits.)</source>
          <target state="translated">Некоторые архитектуры на самом деле оказались в ловушке неверно настроенных чтений и записей,а ранние версии архитектуры ARM (которая эволюционировала во все современные мобильные процессоры)...ну,на самом деле,они просто возвращали плохие данные за них.(Они проигнорировали биты низкого порядка).</target>
        </trans-unit>
        <trans-unit id="2d46e21969464a09e749253c1f1ceb8893528076" translate="yes" xml:space="preserve">
          <source>Some implementations of the language allow you to control the memory layout of structures through the pragma and compiler options</source>
          <target state="translated">Некоторые реализации языка позволяют контролировать расположение структур в памяти с помощью прагмы и опций компилятора</target>
        </trans-unit>
        <trans-unit id="0d5376a9dd3697fd748da016e1a1e6878df4b2bc" translate="yes" xml:space="preserve">
          <source>Suppose you have this structure:</source>
          <target state="translated">Предположим,у тебя есть эта структура:</target>
        </trans-unit>
        <trans-unit id="ddaf43b8dd1e7ca463e43724a0c0b99e17c1da5d" translate="yes" xml:space="preserve">
          <source>The following are unspecified: ...</source>
          <target state="translated">Следующее не указано:...</target>
        </trans-unit>
        <trans-unit id="557fb633b2d3a651a208a4c56f8be2abf1811a85" translate="yes" xml:space="preserve">
          <source>The idea is that for speed and cache considerations, operands should be read from addresses aligned to their natural size. To make this happen, the compiler pads structure members so the following member or following struct will be aligned.</source>
          <target state="translated">Идея заключается в том,что из соображений скорости и кэширования операндов следует читать с адресов,выровненных в соответствии с их естественным размером.Чтобы это произошло,компилятор структурирует членов структуры так,чтобы следующий член или следующая структура была выровнена.</target>
        </trans-unit>
        <trans-unit id="4ac87bc7429d319da13ae1718721e8b3300d3b44" translate="yes" xml:space="preserve">
          <source>The new C99 &lt;a href=&quot;https://en.wikipedia.org/wiki/Flexible_array_member&quot;&gt;flexible array member feature&lt;/a&gt; (&lt;code&gt;struct S {int is[];};&lt;/code&gt;) may also affect padding:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Новая &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Flexible_array_member&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;функция члена гибкого массива&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; C99 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct S {int is[];};&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) также может влиять на заполнение:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae22a4d57fbaa7519083255dde796c5c49ce9e0c" translate="yes" xml:space="preserve">
          <source>The size of a structure is greater than the sum of its parts because of what is called packing.  A particular processor has a preferred data size that it works with.  Most modern processors' preferred size if 32-bits (4 bytes).  Accessing the memory when data is on this kind of boundary is more efficient than things that straddle that size boundary.</source>
          <target state="translated">Размер структуры больше,чем сумма ее частей из-за того,что называется упаковкой.Определенный процессор имеет предпочтительный размер данных,с которыми он работает.Большинство современных процессоров предпочитают размер в 32 бита (4 байта).Доступ к памяти,когда данные находятся на такой границе,более эффективен,чем то,что находится на этой границе размера.</target>
        </trans-unit>
        <trans-unit id="ca97b0953d30171167667ce55c7fadde376f89bc" translate="yes" xml:space="preserve">
          <source>The value of padding bytes when storing values in structures or unions (6.2.6.1)</source>
          <target state="translated">Значение байтов набивки при хранении значений в конструкциях или соединениях (6.2.6.1)</target>
        </trans-unit>
        <trans-unit id="f1f5f526e00e194bf748da381444f712f26f309c" translate="yes" xml:space="preserve">
          <source>The volume occupied by the structure is calculated as the size of the aligned single element of an array of such structures. The structure should
end so that the first element of the next following structure does not  the violate requirements of alignment</source>
          <target state="translated">Объем,занимаемый структурой,рассчитывается как размер выровненного одиночного элемента массива таких структур.Структура должна заканчиваться таким образом,чтобы первый элемент следующей структуры не нарушал требований выравнивания</target>
        </trans-unit>
        <trans-unit id="406a67a4fa9005324820eb336336121fd7305573" translate="yes" xml:space="preserve">
          <source>The x86 architecture has always been able to fetch misaligned addresses. However, it's slower and when the misalignment overlaps two different cache lines, then it evicts two cache lines when an aligned access would only evict one.</source>
          <target state="translated">Архитектура x86 всегда была способна получать неправильно выровненные адреса.Однако,это происходит медленнее,и когда неправильное выравнивание пересекает две разные строки кэша,то она выселяет две строки кэша,когда выровненный доступ выселяет только одну.</target>
        </trans-unit>
        <trans-unit id="fb8544544c4807c55180a86a810e88b25115025a" translate="yes" xml:space="preserve">
          <source>This can be due to byte alignment and padding so that the structure comes out to an even number of bytes (or words) on your platform.  For example in C on Linux, the following 3 structures:</source>
          <target state="translated">Это может быть связано с выравниванием байтов и подкладкой так,чтобы структура выходила на четное количество байтов (или слов)на вашей платформе.Например,в C на Linux следующие 3 структуры:</target>
        </trans-unit>
        <trans-unit id="e336f18147602a9e44b58d1d7ec400b46830669b" translate="yes" xml:space="preserve">
          <source>This is because of padding added to satisfy alignment constraints. &lt;a href=&quot;http://en.wikipedia.org/wiki/Data_structure_alignment&quot;&gt;Data structure alignment&lt;/a&gt; impacts both performance and correctness of programs:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Это связано с добавлением отступов для удовлетворения ограничений выравнивания. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Data_structure_alignment&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Согласование структуры данных&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; влияет как на производительность, так и на правильность программ:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b9def9e505b956b3d279e42e0805991573c33ec" translate="yes" xml:space="preserve">
          <source>Unfortunately, this problem becomes a killer when you attempt to send structures over a network or even write the binary data to a binary file.  The padding inserted between elements of a structure or class can disrupt the data sent to the file or network.  In order to write portable code (one that will go to several different compilers), you will probably have to access each element of the structure separately to ensure the proper &quot;packing&quot;.</source>
          <target state="translated">К сожалению,эта проблема становится убийственной,когда вы пытаетесь отправить структуры по сети или даже записать двоичные данные в двоичный файл.Набивка,вставляемая между элементами структуры или класса,может нарушить целостность данных,посылаемых в файл или сеть.Для того,чтобы написать переносимый код (тот,который пойдет в нескольких разных компиляторах),вам,вероятно,придется обращаться к каждому элементу структуры отдельно,чтобы обеспечить правильную &quot;упаковку&quot;.</target>
        </trans-unit>
        <trans-unit id="9165e18e12f4d78ce348dd02fe45f9811c84f27c" translate="yes" xml:space="preserve">
          <source>Usually it is easier for the CPU to access data that is a multiple of 4 (or 8), depending platform and also on the compiler.</source>
          <target state="translated">Обычно процессору проще получить доступ к данным,кратным 4 (или 8),в зависимости от платформы,а также от компилятора.</target>
        </trans-unit>
        <trans-unit id="72869ecb22c8d2fdf1241784ec34500810b4e780" translate="yes" xml:space="preserve">
          <source>Why does the &lt;code&gt;sizeof&lt;/code&gt; operator return a size larger for a structure than the total sizes of the structure's members?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Почему &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;оператор &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; возвращает размер, больший для структуры, чем общий размер элементов структуры?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="efe745f9a67d720491c39c539175db72ee5c6ff1" translate="yes" xml:space="preserve">
          <source>Why isn't sizeof for a struct equal to the sum of sizeof of each member</source>
          <target state="translated">Почему размер структуры не равен сумме размера каждого участника</target>
        </trans-unit>
        <trans-unit id="bd737ee4afc1c36b62b054b4187c4c65a756473c" translate="yes" xml:space="preserve">
          <source>and GCC claim compatibility with Microsoft's compiler.:</source>
          <target state="translated">и GCC заявляют о совместимости с компилятором Microsoft..:</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="c2ce592b3a7afb19f38698f51ee6c23405bc1dd2" translate="yes" xml:space="preserve">
          <source>compilers required to assign a sequence of components increasing memory addresses</source>
          <target state="translated">компиляторы,необходимые для назначения последовательности компонентов,увеличивающих адреса памяти</target>
        </trans-unit>
        <trans-unit id="b4941e95d6969cbd6a59124474f4bf102b829bf0" translate="yes" xml:space="preserve">
          <source>for Microsoft Visual C:</source>
          <target state="translated">для Microsoft Visual C:</target>
        </trans-unit>
        <trans-unit id="60684e9bc6c2d2147799fb30975595f09663af5b" translate="yes" xml:space="preserve">
          <source>memory holes may appear between any two components, and after the last component. It was due to the fact that certain types of objects on the target computer may be limited by the boundaries of addressing</source>
          <target state="translated">Между любыми двумя компонентами могут появиться отверстия в памяти,а также после последнего компонента.Это связано с тем,что определенные типы объектов на целевом компьютере могут быть ограничены границами адресации</target>
        </trans-unit>
        <trans-unit id="485d42c3c1cc52f4609fde614c3f8a2bcc9d8359" translate="yes" xml:space="preserve">
          <source>p.s More detailed info are available here: &quot;Samuel P.Harbison, Guy L.Steele C A Reference, (5.6.2 - 5.6.7)&quot;</source>
          <target state="translated">p.s Более подробная информация доступна здесь:&quot;Сэмюэль П.Харбисон,Гай Л.Стил С.Справочник,(5.6.2-5.6.7)&quot;.</target>
        </trans-unit>
        <trans-unit id="89c2cc66d89a575cb42b6a1dca58093a04f698d4" translate="yes" xml:space="preserve">
          <source>unnamed bit fields may be included in the structure to the required address alignments of adjacent elements</source>
          <target state="translated">безымянные битовые поля могут быть включены в структуру для требуемого адресного выравнивания смежных элементов</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
