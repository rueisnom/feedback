<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/119123">
    <body>
      <group id="119123">
        <trans-unit id="ea7c1d190a3bb5944cb0b253e4ec0b66b24d634d" translate="yes" xml:space="preserve">
          <source>&quot;memory holes&quot; size included in the result of sizeof operator. The sizeof only doesn't include size of the flexible array, which is available in C/C++</source>
          <target state="translated">El tamaño de los &quot;agujeros de memoria&quot; se incluye en el resultado del tamaño del operador.El tamaño del operador no incluye el tamaño de la matriz flexible,que está disponible en CC++.</target>
        </trans-unit>
        <trans-unit id="5e2a1eeaafd0038588279f1b10325b005bf97c7f" translate="yes" xml:space="preserve">
          <source>13 ... There may be unnamed
  padding within a structure object, but not at its beginning.</source>
          <target state="translated">13 ...Puede haber un acolchado sin nombre dentro de un objeto de estructura,pero no en su comienzo.</target>
        </trans-unit>
        <trans-unit id="3a613654ca642a6d6767394e0d27f74611b755db" translate="yes" xml:space="preserve">
          <source>15 There may be unnamed padding at the end of a structure or union.</source>
          <target state="translated">15 Puede haber un acolchado sin nombre al final de una estructura o unión.</target>
        </trans-unit>
        <trans-unit id="e2d0e33ec380d07996b4f8bc86ea785141c22b59" translate="yes" xml:space="preserve">
          <source>16 As a special case, the last element of a structure with more than one named member may
  have an incomplete array type; this is called a flexible array member. In most situations,
  the flexible array member is ignored. In particular, the size of the structure is as if the
  flexible array member were omitted except that it may have more trailing padding than
  the omission would imply.</source>
          <target state="translated">16 Como caso especial,el último elemento de una estructura con más de un miembro nombrado puede tener un tipo de matriz incompleta;esto se denomina miembro de matriz flexible.En la mayoría de las situaciones,el miembro de la matriz flexible es ignorado.En particular,el tamaño de la estructura es como si se omitiera el miembro del conjunto flexible,salvo que puede tener más relleno de arrastre de lo que implicaría la omisión.</target>
        </trans-unit>
        <trans-unit id="414bb92964f7ecfad2604e92821062f2dac17ee9" translate="yes" xml:space="preserve">
          <source>2 When applied
  to a class, the result is the number of bytes in an object of that class including any padding required for
  placing objects of that type in an array.</source>
          <target state="translated">2 Cuando se aplica a una clase,el resultado es el número de bytes de un objeto de esa clase,incluido el relleno necesario para colocar los objetos de ese tipo en un conjunto.</target>
        </trans-unit>
        <trans-unit id="6486cec944fa9f9b2c41ecd5df485da4ac35f4f6" translate="yes" xml:space="preserve">
          <source>3 When applied to an operand that has structure or union type,
  the result is the total number of bytes in such an object,
  including internal and trailing padding.</source>
          <target state="translated">3 Cuando se aplica a un operando que tiene estructura o tipo de unión,el resultado es el número total de bytes en tal objeto,incluyendo el relleno interno y el de arrastre.</target>
        </trans-unit>
        <trans-unit id="aaf36019e7beaa5a1dc4358651e76a80f0f859e0" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;5.3.3 Sizeof&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;5.3.3 Tama&amp;ntilde;o de&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f80c22edb72b0170a8c7a0c869a36093f9988bf4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;6.5.3.4 The sizeof operator&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;6.5.3.4 El tama&amp;ntilde;o del operador&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="21a6950949f9380e1a80fd038021e59aace62bc7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;6.7.2.1 Structure and union specifiers&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;6.7.2.1 Especificadores de estructura y uni&amp;oacute;n&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c188ad2443c540567c7c8daa7cb2648fb19b97d4" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;9.2 Class members&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;9.2 Miembros de la clase&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="abf975a1f9f225f38e7cef1f183b3da09c979010" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Annex J Portability Issues&lt;/em&gt; reiterates:</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El Anexo J Cuestiones de portabilidad&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; reitera:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="377bd7d244fc6b72e96059fb9cb766841edd1758" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;TL;DR:&lt;/em&gt; alignment is important.</source>
          <target state="translated">&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TL; DR: la&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; alineaci&amp;oacute;n es importante.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9fa5697a62922f95e3c60e9368cd06101ac9527b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C language leaves compiler some freedom about the location of the structural elements in the memory:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El lenguaje C deja al compilador cierta libertad sobre la ubicaci&amp;oacute;n de los elementos estructurales en la memoria:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8a886700572b9c57d6d491254156f6437d6d04fe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C++11 N3337 standard draft&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C ++ 11 N3337 borrador est&amp;aacute;ndar&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fd7453bed259332b62ae40bd66abc3750697afe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;C99 N1256 standard draft&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C99 N1256 borrador est&amp;aacute;ndar&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d146a42b33f5eb7eee5f1ff1d6e895f68382d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How alignment works:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;C&amp;oacute;mo funciona la alineaci&amp;oacute;n:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee4d41c0c55cf4eaa96f769b13f7cb0313a1edf4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Problems related to the elements alignment:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Problemas relacionados con la alineaci&amp;oacute;n de los elementos:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="26078666e7e6283d98fb3cd8206541206faed3f4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The C language provides some assurance to the programmer of the elements layout in the structure:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El lenguaje C proporciona cierta seguridad al programador del dise&amp;ntilde;o de elementos en la estructura:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="08001831948aa1e7c2fcc0fae1677699501a9e43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You need to have good reasons to change it.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Necesitas tener buenas razones para cambiarlo.&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fc6c36591832366db6e1e320835a5a82435c7f21" translate="yes" xml:space="preserve">
          <source>A pointer to a standard-layout struct object, suitably converted using a reinterpret_cast, points to its
  initial member (or if that member is a bit-field, then to the unit in which it resides) and vice versa. [ Note:
  There might therefore be unnamed padding within a standard-layout struct object, but not at its beginning,
  as necessary to achieve appropriate alignment. &amp;mdash; end note ]</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Un puntero a un objeto de estructura de dise&amp;ntilde;o est&amp;aacute;ndar, convertido adecuadamente usando un reinterpret_cast, apunta a su miembro inicial (o si ese miembro es un campo de bits, luego a la unidad en la que reside) y viceversa. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;[Nota: Por lo tanto, puede haber relleno sin nombre dentro de un objeto de estructura de dise&amp;ntilde;o est&amp;aacute;ndar, pero no al principio, seg&amp;uacute;n sea necesario para lograr la alineaci&amp;oacute;n adecuada. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;- nota final]&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8d0aab459ec3221328ef34032b641bed6c8e7308" translate="yes" xml:space="preserve">
          <source>Address of the first component coincides with the start address of the structure</source>
          <target state="translated">La dirección del primer componente coincide con la dirección de inicio de la estructura</target>
        </trans-unit>
        <trans-unit id="ccbd2e21cfcc46e0e9d663d870a070b41c7d2362" translate="yes" xml:space="preserve">
          <source>Also a library may be compiled under x86 with 32-bit ints and you may be comparing its components on a 64-bit process would would give you a different result if you were doing this by hand.</source>
          <target state="translated">También una biblioteca puede ser compilada bajo x86 con ints de 32 bits y usted puede estar comparando sus componentes en un proceso de 64 bits le daría un resultado diferente si estuviera haciendo esto a mano.</target>
        </trans-unit>
        <trans-unit id="4f7afdabaf1875c8c3d894b087ea225e9b39d84e" translate="yes" xml:space="preserve">
          <source>But it's much, much easier on the processor if the compiler arranges
  it like this:</source>
          <target state="translated">Pero es mucho,mucho más fácil para el procesador si el compilador lo organiza así:</target>
        </trans-unit>
        <trans-unit id="942fdac75ab408f0da705c35d5ba37390764f845" translate="yes" xml:space="preserve">
          <source>Computers differ on how to store the bytes in a word (Intel 80x86 and Motorola 68000)</source>
          <target state="translated">Los ordenadores difieren en cómo almacenar los bytes en una palabra (Intel 80x86 y Motorola 68000)</target>
        </trans-unit>
        <trans-unit id="604bde069a55581721b9d22581417c64232f332a" translate="yes" xml:space="preserve">
          <source>Different computers line the edges of objects in different ways</source>
          <target state="translated">Diferentes computadoras alinean los bordes de los objetos de diferentes maneras</target>
        </trans-unit>
        <trans-unit id="9d956ba7ff3840f2bab2c9e6daeb95400655a424" translate="yes" xml:space="preserve">
          <source>Different restrictions on the width of the bit field</source>
          <target state="translated">Diferentes restricciones en el ancho del campo de bits</target>
        </trans-unit>
        <trans-unit id="4fab0d756aeaaafa4d8a6d6e1128251336f7627d" translate="yes" xml:space="preserve">
          <source>Either corrected in hardware, for a modest performance-degradation.</source>
          <target state="translated">O corregido en el hardware,para una modesta degradación del rendimiento.</target>
        </trans-unit>
        <trans-unit id="d95360439bed52475c90194b8b2cbab73ee89644" translate="yes" xml:space="preserve">
          <source>Finally, note that cache lines can be arbitrarily large, and the compiler doesn't attempt to guess at those or make a space-vs-speed tradeoff. Instead, the alignment decisions are part of the ABI and represent the minimum alignment that will eventually evenly fill up a cache line.</source>
          <target state="translated">Por último,tenga en cuenta que las líneas de caché pueden ser arbitrariamente grandes,y el compilador no intenta adivinarlas ni hacer un intercambio de velocidad entre el espacio y la velocidad.En su lugar,las decisiones de alineación son parte de la ABI y representan la alineación mínima que eventualmente llenará uniformemente una línea de caché.</target>
        </trans-unit>
        <trans-unit id="ce0b0e3b463737dec1f994b52eb1aa91d0e6fd2d" translate="yes" xml:space="preserve">
          <source>For example.  Consider the simple structure:</source>
          <target state="translated">Por ejemplo.Considere la estructura simple:</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="016c76e5c39673125f64e48a16c383be180081f4" translate="yes" xml:space="preserve">
          <source>Have members who's sizes (in bytes) are 4 bytes (32 bits), 8 bytes (2x 32 bits) and 1 byte (2+6 bits) respectively.  The above program (on Linux using gcc) prints the sizes as 4, 8, and 4 - where the last structure is padded so that it is a single word (4 x 8 bit bytes on my 32bit platform).</source>
          <target state="translated">Tienen miembros cuyo tamaño (en bytes)es de 4 bytes (32 bits),8 bytes (2x 32 bits)y 1 byte (2+6 bits)respectivamente.El programa anterior (en Linux usando gcc)imprime los tamaños como 4,8 y 4-donde la última estructura se rellena para que sea una sola palabra (4 x 8 bytes de bits en mi plataforma de 32 bits).</target>
        </trans-unit>
        <trans-unit id="16e342eef65fa14dd4d6fc2bf54314327cdc559a" translate="yes" xml:space="preserve">
          <source>Here's an example using typical settings for an x86 processor (all used 32 and 64 bit modes):</source>
          <target state="translated">Aquí hay un ejemplo usando los ajustes típicos para un procesador x86 (todos usaron los modos de 32 y 64 bits):</target>
        </trans-unit>
        <trans-unit id="b8e72a837533fa3fdedba99cab0b561c4d002f62" translate="yes" xml:space="preserve">
          <source>I only know enough C++ to understand the note :-)</source>
          <target state="translated">Sólo sé suficiente C++para entender la nota :-)</target>
        </trans-unit>
        <trans-unit id="f3e48a60aeb815a325f337b288e38ee3446848a4" translate="yes" xml:space="preserve">
          <source>I should now have the length of 11.  Without the pragma, I could be anything from 11 to 14 (and for some systems, as much as 32), depending on the default packing of the compiler.</source>
          <target state="translated">Ahora debería tener la longitud de 11.Sin la pragmática,podría ser cualquier cosa entre 11 y 14 (y para algunos sistemas,hasta 32),dependiendo del empaquetado por defecto del compilador.</target>
        </trans-unit>
        <trans-unit id="e2ec884c97791749c41744efb39836e58381495c" translate="yes" xml:space="preserve">
          <source>I'm quite sure &lt;strong&gt;member-order &lt;em&gt;is&lt;/em&gt; guaranteed in C&lt;/strong&gt;, but I wouldn't count on it, when writing a cross-platform or cross-compiler program.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Estoy bastante seguro &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;de que el orden de los miembros &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;est&amp;aacute;&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; garantizado en C&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , pero no contar&amp;iacute;a con &amp;eacute;l al escribir un programa multiplataforma o compilador cruzado.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="294eaa44c9c9070356fdb5156a7a6c6f5c27332e" translate="yes" xml:space="preserve">
          <source>IMPORTANT NOTE: Both the C and C++ standards state that structure alignment is implementation-defined.  Therefore each compiler may choose to align data differently, resulting in different and incompatible data layouts.  For this reason, when dealing with libraries that will be used by different compilers, it is important to understand how the compilers align data.  Some compilers have command-line settings and/or special &lt;code&gt;#pragma&lt;/code&gt; statements to change the structure alignment settings.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;NOTA IMPORTANTE: Los est&amp;aacute;ndares C y C ++ establecen que la alineaci&amp;oacute;n de la estructura est&amp;aacute; definida por la implementaci&amp;oacute;n. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por lo tanto, cada compilador puede elegir alinear los datos de manera diferente, lo que da como resultado dise&amp;ntilde;os de datos diferentes e incompatibles. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Por esta raz&amp;oacute;n, cuando se trata de bibliotecas que ser&amp;aacute;n utilizadas por diferentes compiladores, es importante comprender c&amp;oacute;mo los compiladores alinean los datos. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Algunos compiladores tienen configuraciones de l&amp;iacute;nea de comandos y / o &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;declaraciones &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;especiales &lt;/font&gt;&lt;/font&gt; &lt;code&gt;#pragma&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; para cambiar las configuraciones de alineaci&amp;oacute;n de la estructura.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8f55e5a98bbf66b8be5db53541346322d59f2a53" translate="yes" xml:space="preserve">
          <source>If the machine is a 32-bit machine and data is aligned on a 32-bit boundary, we see an immediate problem (assuming no structure alignment).  In this example, let us assume that the structure data starts at address 1024 (0x400 - note that the lowest 2 bits are zero, so the data is aligned to a 32-bit boundary).  The access to data.a will work fine because it starts on a boundary - 0x400.  The access to data.b will also work fine, because it is at address 0x404 - another 32-bit boundary.  But an unaligned structure would put data.c at address 0x405.  The 4 bytes of data.c are at 0x405, 0x406, 0x407, 0x408.  On a 32-bit machine, the system would read data.c during one memory cycle, but would only get 3 of the 4 bytes (the 4th byte is on the next boundary).  So, the system would have to do a second memory access to get the 4th byte,</source>
          <target state="translated">Si la máquina es de 32 bits y los datos están alineados en un límite de 32 bits,vemos un problema inmediato (suponiendo que no haya una alineación de la estructura).En este ejemplo,asumamos que los datos de la estructura comienzan en la dirección 1024 (0x400-note que los 2 bits más bajos son cero,por lo que los datos están alineados en un límite de 32 bits).El acceso a data.a funcionará bien porque comienza en un límite-0x400.El acceso a data.b también funcionará bien,porque está en la dirección 0x404-otro límite de 32 bits.Pero una estructura no alineada pondría data.c en la dirección 0x405.Los 4 bytes de data.c están en 0x405,0x406,0x407,0x408.En una máquina de 32 bits,el sistema leería data.c durante un ciclo de memoria,pero sólo obtendría 3 de los 4 bytes (el 4º byte está en el siguiente límite).Por lo tanto,el sistema tendría que hacer un segundo acceso a la memoria para obtener el 4º byte,</target>
        </trans-unit>
        <trans-unit id="bccaf1969a6bb184c03be12d89b4357316a42879" translate="yes" xml:space="preserve">
          <source>If you want the structure to have a certain size with GCC for example use &lt;a href=&quot;http://digitalvampire.org/blog/index.php/2006/07/31/why-you-shouldnt-use-__attribute__packed/&quot;&gt;&lt;code&gt;__attribute__((packed))&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Si desea que la estructura tenga un cierto tama&amp;ntilde;o con GCC, por ejemplo, use &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://digitalvampire.org/blog/index.php/2006/07/31/why-you-shouldnt-use-__attribute__packed/&quot;&gt; &lt;code&gt;__attribute__((packed))&lt;/code&gt; &lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="deb7d9021009a9e869a35d0946526f7b0aeab08c" translate="yes" xml:space="preserve">
          <source>In addition to the other answers, a struct can (but usually doesn't) have virtual functions, in which case the size of the struct will also include the space for the vtbl.</source>
          <target state="translated">Además de las otras respuestas,una estructura puede (pero normalmente no)tener funciones virtuales,en cuyo caso el tamaño de la estructura también incluirá el espacio para el vtbl.</target>
        </trans-unit>
        <trans-unit id="ecdc60512add6ea34f6cbca0736e5590bbeb5481" translate="yes" xml:space="preserve">
          <source>In addition to the previous answers, please note that regardless the packaging, &lt;strong&gt;there is no members-order-guarantee in C++&lt;/strong&gt;. Compilers may (and certainly do) add virtual table pointer and base structures' members to the structure. Even the existence of virtual table is not ensured by the standard (virtual mechanism implementation is not specified) and therefore one can conclude that such guarantee is just impossible.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Adem&amp;aacute;s de las respuestas anteriores, tenga en cuenta que, independientemente del paquete, &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;no hay garant&amp;iacute;a de pedido de miembros en C ++&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Los compiladores pueden (y ciertamente lo hacen) agregar puntero de tabla virtual y miembros de estructuras base a la estructura. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Incluso la existencia de una tabla virtual no est&amp;aacute; garantizada por el est&amp;aacute;ndar (la implementaci&amp;oacute;n del mecanismo virtual no est&amp;aacute; especificada) y, por lo tanto, se puede concluir que dicha garant&amp;iacute;a es simplemente imposible.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e1165438f2f662510c6a05ae168ff5e92e07c7d9" translate="yes" xml:space="preserve">
          <source>In addition, atomicity and other concurrency-guarantees might be broken, leading to subtle errors.</source>
          <target state="translated">Además,la atomicidad y otras garantías de concurrencia podrían romperse,lo que daría lugar a sutiles errores.</target>
        </trans-unit>
        <trans-unit id="ace871547625d99f1b3513de67ddbf1ecd1ed28f" translate="yes" xml:space="preserve">
          <source>In the packed version, notice how it's at least a little bit hard for
  you and me to see how the b and c fields wrap around? In a nutshell,
  it's hard for the processor, too. Therefore, most compilers will pad
  the structure (as if with extra, invisible fields) like this:</source>
          <target state="translated">En la versión empaquetada,¿notan que es al menos un poco difícil para ti y para mí ver cómo se envuelven los campos b y c? En pocas palabras,es difícil para el procesador,también.Por lo tanto,la mayoría de los compiladores rellenan la estructura (como si se tratara de campos extra,invisibles)de esta manera:</target>
        </trans-unit>
        <trans-unit id="6387af3b2046a0f60a53cd633291987de3402796" translate="yes" xml:space="preserve">
          <source>It can do so if you have implicitly or explicitly set the alignment of the struct. A struct that is aligned 4 will always be a multiple of 4 bytes even if the size of its members would be something that's not a multiple of 4 bytes.</source>
          <target state="translated">Puede hacerlo si ha establecido implícita o explícitamente la alineación de la estructura.Una estructura que está alineada 4 siempre será un múltiplo de 4 bytes,incluso si el tamaño de sus miembros es algo que no es un múltiplo de 4 bytes.</target>
        </trans-unit>
        <trans-unit id="3ebd1a765829877290c265b234786e66158f299f" translate="yes" xml:space="preserve">
          <source>It's for alignment. Many processors can't access 2- and 4-byte
  quantities (e.g. ints and long ints) if they're crammed in
  every-which-way.</source>
          <target state="translated">Es para la alineación.Muchos procesadores no pueden acceder a cantidades de 2 y 4 bytes (por ejemplo,ints y long ints)si están atestados en cada vía.</target>
        </trans-unit>
        <trans-unit id="c2689f2719ba1b44a9adf74baccfccbd020a7e67" translate="yes" xml:space="preserve">
          <source>Mis-aligned access might be a hard error (often &lt;code&gt;SIGBUS&lt;/code&gt;).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;El acceso mal alineado puede ser un error dif&amp;iacute;cil (a menudo &lt;/font&gt;&lt;/font&gt; &lt;code&gt;SIGBUS&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3a118237ea1794dca6417aa40286dd801d9cf4ae" translate="yes" xml:space="preserve">
          <source>Mis-aligned access might be a soft error.</source>
          <target state="translated">Un acceso mal alineado podría ser un error suave.</target>
        </trans-unit>
        <trans-unit id="513a0a6fb061f5730b3144ab01c46ffceaf5a848" translate="yes" xml:space="preserve">
          <source>Now, if instead of putting data.c at address 0x405, the compiler padded the structure by 3 bytes and put data.c at address 0x408, then the system would only need 1 cycle to read the data, cutting access time to that data element by 50%.  Padding swaps memory efficiency for processing efficiency.  Given that computers can have huge amounts of memory (many gigabytes), the compilers feel that the swap (speed over size) is a reasonable one.</source>
          <target state="translated">Ahora,si en lugar de poner data.c en la dirección 0x405,el compilador rellenara la estructura en 3 bytes y pusiera data.c en la dirección 0x408,entonces el sistema sólo necesitaría 1 ciclo para leer los datos,reduciendo el tiempo de acceso a ese elemento de datos en un 50%.El relleno intercambia la eficiencia de la memoria por la eficiencia del procesamiento.Dado que las computadoras pueden tener grandes cantidades de memoria (muchos gigabytes),los compiladores creen que el intercambio (velocidad sobre el tamaño)es razonable.</target>
        </trans-unit>
        <trans-unit id="c02ec6a18a5ab1ca633a0e2b2293f779e6729575" translate="yes" xml:space="preserve">
          <source>Now, you might think that it ought to be possible to pack this
  structure into memory like this:</source>
          <target state="translated">Se podría pensar que debería ser posible guardar esta estructura en la memoria de esta manera:</target>
        </trans-unit>
        <trans-unit id="32a8824f2732921a3dc9ac7db52b26ca85ce9b0d" translate="yes" xml:space="preserve">
          <source>On Windows you can set the alignment to one byte when using the cl.exe compier with the &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xh3e3fd0(VS.80).aspx&quot;&gt;/Zp option&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;En Windows, puede establecer la alineaci&amp;oacute;n en un byte cuando utiliza el compilador cl.exe con la &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/xh3e3fd0(VS.80).aspx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;opci&amp;oacute;n / Zp&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a3668a1ac342860ec9ca845b4c68d75816f250d2" translate="yes" xml:space="preserve">
          <source>On the other hand, different compilers have different abilities to manage data structure packing.  For example, in Visual C/C++ the compiler supports the #pragma pack command.  This will allow you to adjust data packing and alignment.</source>
          <target state="translated">Por otro lado,los diferentes compiladores tienen diferentes habilidades para manejar el empaquetamiento de la estructura de datos.Por ejemplo,en Visual CC++el compilador soporta el comando #pragma pack.Esto le permitirá ajustar el empaquetado y la alineación de los datos.</target>
        </trans-unit>
        <trans-unit id="88ee5aad6a5759dd6df5e6b7f54b322f1e3d1a19" translate="yes" xml:space="preserve">
          <source>One can minimize the size of structures by sorting members by alignment (sorting by size suffices for that in basic types) (like structure &lt;code&gt;Z&lt;/code&gt; in the example above).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Se puede minimizar el tama&amp;ntilde;o de las estructuras clasificando los miembros por alineaci&amp;oacute;n (la clasificaci&amp;oacute;n por tama&amp;ntilde;o es suficiente para eso en los tipos b&amp;aacute;sicos) (como la estructura &lt;/font&gt;&lt;/font&gt; &lt;code&gt;Z&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; en el ejemplo anterior).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1b2051d9503bb13db117acc5804d15184f6ad617" translate="yes" xml:space="preserve">
          <source>Or corrected by emulation in software, for a severe performance-degradation.</source>
          <target state="translated">O corregido por emulación en el software,para una severa degradación del rendimiento.</target>
        </trans-unit>
        <trans-unit id="1a61f3cc584a463a50abd933541448f7a1510020" translate="yes" xml:space="preserve">
          <source>Packing and byte alignment, as described in the C FAQ &lt;a href=&quot;http://www.c-faq.com/struct/align.html&quot;&gt;here&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Empaque y alineaci&amp;oacute;n de bytes, como se describe en las preguntas frecuentes de C &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.c-faq.com/struct/align.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;aqu&amp;iacute;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; :&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="371a87eafb4de078ff674d69a5a89c186532eb49" translate="yes" xml:space="preserve">
          <source>See also:</source>
          <target state="translated">Ver también:</target>
        </trans-unit>
        <trans-unit id="e51388dd1717e14df9b26e7234fe77926f42a0cc" translate="yes" xml:space="preserve">
          <source>So it is a matter of alignment basically.</source>
          <target state="translated">Así que es una cuestión de alineación básicamente.</target>
        </trans-unit>
        <trans-unit id="fc509e8f6989fc2315b358c504ab268f0ae96c3b" translate="yes" xml:space="preserve">
          <source>Some architectures actually have to trap on misaligned reads and writes, and early versions of the ARM architecture (the one that evolved into all of today's mobile CPUs) ... well, they actually just returned bad data on for those. (They ignored the low-order bits.)</source>
          <target state="translated">Algunas arquitecturas tienen que atraparse en lecturas y escrituras desalineadas,y las primeras versiones de la arquitectura ARM (la que evolucionó en todas las CPU móviles de hoy en día)...bueno,en realidad sólo devolvían malos datos para esas.(Ignoraron los bits de bajo orden).</target>
        </trans-unit>
        <trans-unit id="2d46e21969464a09e749253c1f1ceb8893528076" translate="yes" xml:space="preserve">
          <source>Some implementations of the language allow you to control the memory layout of structures through the pragma and compiler options</source>
          <target state="translated">Algunas implementaciones del lenguaje permiten controlar la disposición de la memoria de las estructuras a través de las opciones pragmáticas y del compilador</target>
        </trans-unit>
        <trans-unit id="0d5376a9dd3697fd748da016e1a1e6878df4b2bc" translate="yes" xml:space="preserve">
          <source>Suppose you have this structure:</source>
          <target state="translated">Supongamos que tienes esta estructura:</target>
        </trans-unit>
        <trans-unit id="ddaf43b8dd1e7ca463e43724a0c0b99e17c1da5d" translate="yes" xml:space="preserve">
          <source>The following are unspecified: ...</source>
          <target state="translated">No se especifica lo siguiente:...</target>
        </trans-unit>
        <trans-unit id="557fb633b2d3a651a208a4c56f8be2abf1811a85" translate="yes" xml:space="preserve">
          <source>The idea is that for speed and cache considerations, operands should be read from addresses aligned to their natural size. To make this happen, the compiler pads structure members so the following member or following struct will be aligned.</source>
          <target state="translated">La idea es que por consideraciones de velocidad y caché,los operandos deben ser leídos desde direcciones alineadas a su tamaño natural.Para que esto suceda,los pads del compilador estructuran los miembros de manera que el siguiente miembro o la siguiente estructura se alinee.</target>
        </trans-unit>
        <trans-unit id="4ac87bc7429d319da13ae1718721e8b3300d3b44" translate="yes" xml:space="preserve">
          <source>The new C99 &lt;a href=&quot;https://en.wikipedia.org/wiki/Flexible_array_member&quot;&gt;flexible array member feature&lt;/a&gt; (&lt;code&gt;struct S {int is[];};&lt;/code&gt;) may also affect padding:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La nueva &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Flexible_array_member&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;caracter&amp;iacute;stica de miembro de matriz flexible&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; C99 &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;( &lt;/font&gt;&lt;/font&gt; &lt;code&gt;struct S {int is[];};&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ) tambi&amp;eacute;n puede afectar el relleno:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae22a4d57fbaa7519083255dde796c5c49ce9e0c" translate="yes" xml:space="preserve">
          <source>The size of a structure is greater than the sum of its parts because of what is called packing.  A particular processor has a preferred data size that it works with.  Most modern processors' preferred size if 32-bits (4 bytes).  Accessing the memory when data is on this kind of boundary is more efficient than things that straddle that size boundary.</source>
          <target state="translated">El tamaño de una estructura es mayor que la suma de sus partes debido a lo que se llama empaquetamiento.Un procesador en particular tiene un tamaño de datos preferido con el que trabaja.El tamaño preferido de la mayoría de los procesadores modernos es de 32 bits (4 bytes).Acceder a la memoria cuando los datos están en este tipo de límite es más eficiente que las cosas que se encuentran a caballo de ese tamaño.</target>
        </trans-unit>
        <trans-unit id="ca97b0953d30171167667ce55c7fadde376f89bc" translate="yes" xml:space="preserve">
          <source>The value of padding bytes when storing values in structures or unions (6.2.6.1)</source>
          <target state="translated">El valor de los bytes de relleno cuando se almacenan valores en estructuras o uniones (6.2.6.1)</target>
        </trans-unit>
        <trans-unit id="f1f5f526e00e194bf748da381444f712f26f309c" translate="yes" xml:space="preserve">
          <source>The volume occupied by the structure is calculated as the size of the aligned single element of an array of such structures. The structure should
end so that the first element of the next following structure does not  the violate requirements of alignment</source>
          <target state="translated">El volumen ocupado por la estructura se calcula como el tamaño del elemento individual alineado de un conjunto de tales estructuras.La estructura debe terminar de modo que el primer elemento de la siguiente estructura no viole los requisitos de alineación</target>
        </trans-unit>
        <trans-unit id="406a67a4fa9005324820eb336336121fd7305573" translate="yes" xml:space="preserve">
          <source>The x86 architecture has always been able to fetch misaligned addresses. However, it's slower and when the misalignment overlaps two different cache lines, then it evicts two cache lines when an aligned access would only evict one.</source>
          <target state="translated">La arquitectura x86 siempre ha sido capaz de obtener direcciones mal alineadas.Sin embargo,es más lenta y cuando la desalineación se superpone a dos líneas de caché diferentes,entonces desaloja dos líneas de caché cuando un acceso alineado sólo desalojaría una.</target>
        </trans-unit>
        <trans-unit id="fb8544544c4807c55180a86a810e88b25115025a" translate="yes" xml:space="preserve">
          <source>This can be due to byte alignment and padding so that the structure comes out to an even number of bytes (or words) on your platform.  For example in C on Linux, the following 3 structures:</source>
          <target state="translated">Esto puede deberse a la alineación de los bytes y al relleno para que la estructura salga a un número par de bytes (o palabras)en su plataforma.Por ejemplo en C en Linux,las siguientes 3 estructuras:</target>
        </trans-unit>
        <trans-unit id="e336f18147602a9e44b58d1d7ec400b46830669b" translate="yes" xml:space="preserve">
          <source>This is because of padding added to satisfy alignment constraints. &lt;a href=&quot;http://en.wikipedia.org/wiki/Data_structure_alignment&quot;&gt;Data structure alignment&lt;/a&gt; impacts both performance and correctness of programs:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Esto se debe al relleno agregado para satisfacer las restricciones de alineaci&amp;oacute;n. &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Data_structure_alignment&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;La alineaci&amp;oacute;n de la estructura de datos&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; afecta tanto el rendimiento como la correcci&amp;oacute;n de los programas:&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3b9def9e505b956b3d279e42e0805991573c33ec" translate="yes" xml:space="preserve">
          <source>Unfortunately, this problem becomes a killer when you attempt to send structures over a network or even write the binary data to a binary file.  The padding inserted between elements of a structure or class can disrupt the data sent to the file or network.  In order to write portable code (one that will go to several different compilers), you will probably have to access each element of the structure separately to ensure the proper &quot;packing&quot;.</source>
          <target state="translated">Desafortunadamente,este problema se convierte en un asesino cuando se intenta enviar estructuras a través de una red o incluso escribir los datos binarios en un archivo binario.El relleno insertado entre los elementos de una estructura o clase puede interrumpir los datos enviados al archivo o a la red.Para escribir código portátil (uno que irá a varios compiladores diferentes),probablemente tendrá que acceder a cada elemento de la estructura por separado para asegurar el &quot;relleno&quot; adecuado.</target>
        </trans-unit>
        <trans-unit id="9165e18e12f4d78ce348dd02fe45f9811c84f27c" translate="yes" xml:space="preserve">
          <source>Usually it is easier for the CPU to access data that is a multiple of 4 (or 8), depending platform and also on the compiler.</source>
          <target state="translated">Normalmente es más fácil para la CPU acceder a los datos que son un múltiplo de 4 (u 8),dependiendo de la plataforma y también del compilador.</target>
        </trans-unit>
        <trans-unit id="72869ecb22c8d2fdf1241784ec34500810b4e780" translate="yes" xml:space="preserve">
          <source>Why does the &lt;code&gt;sizeof&lt;/code&gt; operator return a size larger for a structure than the total sizes of the structure's members?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;iquest;Por qu&amp;eacute; el &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;operador &lt;/font&gt;&lt;/font&gt; &lt;code&gt;sizeof&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; devuelve un tama&amp;ntilde;o mayor para una estructura que el tama&amp;ntilde;o total de los miembros de la estructura?&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="efe745f9a67d720491c39c539175db72ee5c6ff1" translate="yes" xml:space="preserve">
          <source>Why isn't sizeof for a struct equal to the sum of sizeof of each member</source>
          <target state="translated">¿Por qué el tamaño de una estructura no es igual a la suma del tamaño de cada miembro</target>
        </trans-unit>
        <trans-unit id="bd737ee4afc1c36b62b054b4187c4c65a756473c" translate="yes" xml:space="preserve">
          <source>and GCC claim compatibility with Microsoft's compiler.:</source>
          <target state="translated">y GCC afirman ser compatibles con el compilador de Microsoft..:</target>
        </trans-unit>
        <trans-unit id="a5230bf3ac1fc697c044aa12dc9e2fb2c6ea3dcf" translate="yes" xml:space="preserve">
          <source>and:</source>
          <target state="translated">and:</target>
        </trans-unit>
        <trans-unit id="c2ce592b3a7afb19f38698f51ee6c23405bc1dd2" translate="yes" xml:space="preserve">
          <source>compilers required to assign a sequence of components increasing memory addresses</source>
          <target state="translated">los compiladores necesarios para asignar una secuencia de componentes que aumenten las direcciones de memoria</target>
        </trans-unit>
        <trans-unit id="b4941e95d6969cbd6a59124474f4bf102b829bf0" translate="yes" xml:space="preserve">
          <source>for Microsoft Visual C:</source>
          <target state="translated">para Microsoft Visual C:</target>
        </trans-unit>
        <trans-unit id="60684e9bc6c2d2147799fb30975595f09663af5b" translate="yes" xml:space="preserve">
          <source>memory holes may appear between any two components, and after the last component. It was due to the fact that certain types of objects on the target computer may be limited by the boundaries of addressing</source>
          <target state="translated">pueden aparecer agujeros de memoria entre dos componentes cualesquiera,y después del último componente.Se debe al hecho de que ciertos tipos de objetos en el ordenador objetivo pueden estar limitados por los límites de la dirección</target>
        </trans-unit>
        <trans-unit id="485d42c3c1cc52f4609fde614c3f8a2bcc9d8359" translate="yes" xml:space="preserve">
          <source>p.s More detailed info are available here: &quot;Samuel P.Harbison, Guy L.Steele C A Reference, (5.6.2 - 5.6.7)&quot;</source>
          <target state="translated">p.s Información más detallada está disponible aquí:&quot;Samuel P.Harbison,Guy L.Steele C A Reference,(5.6.2-5.6.7)&quot;</target>
        </trans-unit>
        <trans-unit id="89c2cc66d89a575cb42b6a1dca58093a04f698d4" translate="yes" xml:space="preserve">
          <source>unnamed bit fields may be included in the structure to the required address alignments of adjacent elements</source>
          <target state="translated">Pueden incluirse en la estructura campos de bits sin nombre hasta las alineaciones de dirección requeridas de los elementos adyacentes</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
