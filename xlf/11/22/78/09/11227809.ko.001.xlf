<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/11227809">
    <body>
      <group id="11227809">
        <trans-unit id="b53667fac1b1818f469635cd98c1992443873e79" translate="yes" xml:space="preserve">
          <source>(Or somewhat fast: for the already-sorted case, &lt;code&gt;cmov&lt;/code&gt; can be slower especially if GCC puts it on the critical path instead of just &lt;code&gt;add&lt;/code&gt;, especially on Intel before Broadwell where &lt;code&gt;cmov&lt;/code&gt; has 2 cycle latency: &lt;a href=&quot;https://stackoverflow.com/questions/28875325/gcc-optimization-flag-o3-makes-code-slower-than-o2&quot;&gt;gcc optimization flag -O3 makes code slower than -O2&lt;/a&gt;)</source>
          <target state="translated">(또는 다소 빠름 : 이미 정렬 된 경우, 특히 GCC가 &lt;code&gt;add&lt;/code&gt; 대신 대신 중요한 경로에 &lt;code&gt;cmov&lt;/code&gt; 를 넣으면 가 느려질 수 있습니다. 특히 &lt;code&gt;cmov&lt;/code&gt; 가 2주기 대기 시간을 갖는 Broadwell 이전의 Intel에서는 &lt;a href=&quot;https://stackoverflow.com/questions/28875325/gcc-optimization-flag-o3-makes-code-slower-than-o2&quot;&gt;gcc 최적화 플래그 -O3로 인해 코드가 느려집니다 -O2보다&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d1ea744eaff022b9ec4d3d58be32b719619a16de" translate="yes" xml:space="preserve">
          <source>// Declare and then fill in the lookup table</source>
          <target state="translated">// 룩업 테이블을 선언하고 채운다</target>
        </trans-unit>
        <trans-unit id="439750f5cd724a86cdb0b90f611fcdf4d601b584" translate="yes" xml:space="preserve">
          <source>// Test</source>
          <target state="translated">// 테스트</target>
        </trans-unit>
        <trans-unit id="22e070d61d4ac5f3e0981ca4d20241ae99b358d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler&quot;&gt;Intel C++ Compiler&lt;/a&gt; (ICC) 11 does something miraculous. It &lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_interchange&quot;&gt;interchanges the two loops&lt;/a&gt;, thereby hoisting the unpredictable branch to the outer loop. So not only is it immune to the mispredictions, it is also twice as fast as whatever VC++ and GCC can generate! In other words, ICC took advantage of the test-loop to defeat the benchmark...</source>
          <target state="translated">ICC ( &lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler&quot;&gt;Intel C ++ Compiler&lt;/a&gt; ) 11은 기적적인 일을합니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_interchange&quot;&gt;두 루프를 서로 교환하여&lt;/a&gt; 예측할 수없는 분기를 외부 루프로 들어 올립니다. 따라서 오해에 대한 내성이있을뿐만 아니라 VC ++ 및 GCC가 생성 할 수있는 것보다 두 배 빠릅니다! 다시 말해 ICC는 벤치 마크를 물리 치기 위해 테스트 루프를 활용했습니다.</target>
        </trans-unit>
        <trans-unit id="637937a9b16b61115d58b45cd478f01d51765e8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADD R1, R2, R3&lt;/code&gt; performs &lt;code&gt;R1 = R2 + R3&lt;/code&gt; without updating any status bits.</source>
          <target state="translated">&lt;code&gt;ADD R1, R2, R3&lt;/code&gt; 은 상태 비트를 업데이트하지 않고 &lt;code&gt;R1 = R2 + R3&lt;/code&gt; 을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="87d9034703b27f8b1421db3174bb0a89354e4fdd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDGE R1, R2, R3&lt;/code&gt; performs the same operation only if a previous instruction that affected the status bits resulted in a Greater than or Equal condition.</source>
          <target state="translated">&lt;code&gt;ADDGE R1, R2, R3&lt;/code&gt; 은 상태 비트에 영향을 미치는 이전 명령이보다 크거나 같음 조건 인 경우에만 동일한 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="23f6fd5b0c8ae0b7004305abd5527096f2e1cd0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDS R1, R2, R3&lt;/code&gt; performs the addition and then updates the &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; flags in the Processor Status Register based on whether the result was Negative, Zero, Carried (for unsigned addition), or oVerflowed (for signed addition).</source>
          <target state="translated">&lt;code&gt;ADDS R1, R2, R3&lt;/code&gt; 은 추가를 수행 한 다음 결과가 음수, 0, 캐리 (서명되지 않은 추가) 또는 oVerflowed (서명 된 추가)인지에 따라 프로세서 상태 레지스터에서 &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 플래그를 업데이트합니다. .</target>
        </trans-unit>
        <trans-unit id="9dc9f762599510b8def52bb6b16ab86d5b605418" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDSGE R1, R2, R3&lt;/code&gt; performs the addition only if the &lt;code&gt;GE&lt;/code&gt; test is true, and then subsequently updates the status bits based on the result of the addition.</source>
          <target state="translated">&lt;code&gt;ADDSGE R1, R2, R3&lt;/code&gt; 은 &lt;code&gt;GE&lt;/code&gt; 테스트가 참인 경우에만 덧셈을 수행 한 다음 덧셈 결과에 따라 상태 비트를 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="6c4200c52c77a8809e0c28b82431a4fcd7fb0319" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CMP&lt;/code&gt; opcodes always update the status bits in the Processor Status Register (PSR), because that is their purpose, but most other instructions do not touch the PSR unless you add an optional &lt;code&gt;S&lt;/code&gt; suffix to the instruction, specifying that the PSR should be updated based on the result of the instruction. &lt;strong&gt;Just like the 4-bit condition suffix, being able to execute instructions without affecting the PSR is a mechanism that reduces the need for branches on ARM, and also facilitates out of order dispatch at the hardware level&lt;/strong&gt;, because after performing some operation X that updates the status bits, subsequently (or in parallel) you can do a bunch of other work that explicitly should not affect the status bits, then you can test the state of the status bits set earlier by X.</source>
          <target state="translated">&lt;code&gt;CMP&lt;/code&gt; opcode는 항상 PSR (Processor Status Register)의 상태 비트를 업데이트합니다. 왜냐하면 그 목적이기 때문입니다. 그러나 명령에 선택적 &lt;code&gt;S&lt;/code&gt; 접미사를 추가하지 않고 PSR을 기반으로 업데이트하도록 지정하지 않으면 대부분의 다른 명령은 PSR에 닿지 않습니다. 지시의 결과에. &lt;strong&gt;4 비트 조건 접미사와 마찬가지로 PSR에 영향을주지 않고 명령어를 실행할 수 있다는 것은 ARM의 분기가 필요하지 않으며 하드웨어 수준에서 순서가 잘못된 디스패치를 ​​용이하게하는 메커니즘입니다.&lt;/strong&gt; 상태 비트는 이후에 (또는 병렬로) 상태 비트에 명시 적으로 영향을 미치지 않아야하는 여러 가지 다른 작업을 수행 할 수 있습니다. 그런 다음 X로 미리 설정된 상태 비트의 상태를 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="391873c374a8ded8013438f8a2663a8948bf98aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; cannot be replaced with &lt;code&gt;a &amp;amp; b&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is an expression that should not be evaluated if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will not evaluate &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; will). Likewise, &lt;code&gt;a || b&lt;/code&gt; can not be replaced with &lt;code&gt;a | b&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is an expression that should not be evaluated if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;false&lt;/code&gt; 인 경우 평가되지 않아야하는 표현식 인 경우 &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 로 대체 할 수 없습니다 ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 는 &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; will을 평가하지 않음). 마찬가지로 &lt;code&gt;a || b&lt;/code&gt; b 는 &lt;code&gt;a | b&lt;/code&gt; b 가 &lt;code&gt;b&lt;/code&gt; 이면 &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;true&lt;/code&gt; 이면 평가해서는 안되는 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="3da7ae3851d0cb07b784c1504abb04501c97c690" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; is used instead of &lt;code&gt;bool&lt;/code&gt; in order to make it possible to use the bitwise operators (&lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) instead of the Boolean operators (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;). The bitwise operators are single instructions that take only one clock cycle. The OR operator (&lt;code&gt;|&lt;/code&gt;) works even if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have other values than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. The AND operator (&lt;code&gt;&amp;amp;&lt;/code&gt;) and the EXCLUSIVE OR operator (&lt;code&gt;^&lt;/code&gt;) may give inconsistent results if the operands have other values than &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">부울 연산자 ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;||&lt;/code&gt; ) 대신 비트 연산자 ( &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; )를 사용할 수 있도록 &lt;code&gt;bool&lt;/code&gt; 대신 &lt;code&gt;char&lt;/code&gt; 이 사용됩니다. 비트 연산자는 하나의 클럭 주기만 수행하는 단일 명령어입니다. &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 에 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 이외의 다른 값이 있어도 OR 연산자 ( &lt;code&gt;|&lt;/code&gt; )가 작동합니다. 피연산자가 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 이외의 다른 값을 갖는 경우 AND 연산자 ( &lt;code&gt;&amp;amp;&lt;/code&gt; )와 EXCLUSIVE OR 연산자 ( &lt;code&gt;^&lt;/code&gt; )는 일치하지 않는 결과를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2116c486e51bc36c5ea4f4ea724a4decd73ddf80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max1&lt;/code&gt; uses the conditional branch &lt;code&gt;if... else ...&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;max1&lt;/code&gt; 은 &lt;code&gt;if... else ...&lt;/code&gt; : 조건부 분기를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5c4a2ff8aabdb7de009ae921d3d149a4fd4a3981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max2&lt;/code&gt; uses much less code due to the usage of instruction &lt;code&gt;cmovge&lt;/code&gt;. But the real gain is that &lt;code&gt;max2&lt;/code&gt; does not involve branch jumps, &lt;code&gt;jmp&lt;/code&gt;, which would have a significant performance penalty if the predicted result is not right.</source>
          <target state="translated">&lt;code&gt;max2&lt;/code&gt; 명령 &lt;code&gt;cmovge&lt;/code&gt; 의 사용으로 인해 훨씬 ​​적은 코드를 사용합니다. 그러나 실제 이득은 &lt;code&gt;max2&lt;/code&gt; 가 지점 점프 &lt;code&gt;jmp&lt;/code&gt; 를 포함하지 않는다는 것입니다. 예상 결과가 정확 하지 않으면 상당한 성능 저하가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a816aa9d54ebe21437fa8cb172a780bbab33269" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max2&lt;/code&gt; uses the ternary operator &lt;code&gt;... ? ... : ...&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;max2&lt;/code&gt; 는 삼항 연산자를 사용합니다 &lt;code&gt;... ? ... : ...&lt;/code&gt; ... : ... :</target>
        </trans-unit>
        <trans-unit id="562cd5fce1e7b6dcbe296f9206498ac8e7ed271a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt; can not be used for NOT. Instead, you can make a Boolean NOT on a variable which is known to be &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; by XOR'ing it with &lt;code&gt;1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; NOT에 사용할 수 없습니다. 대신, &lt;code&gt;1&lt;/code&gt; 로 XOR하여 변수 &lt;code&gt;0&lt;/code&gt; 또는 1 로 알려진 변수에 부울 NOT을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86968cc91f6395ac3372778b6f3bd6927c8f9854" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;A Demonstration of Self-Profiling&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;자체 프로파일 링 시연&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62a5257803ca2425233ddd03c4d7d207b6867e4a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://courses.cs.washington.edu/courses/csep548/06au/lectures/branchPred.pdf&quot;&gt;Branch Prediction Review&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://courses.cs.washington.edu/courses/csep548/06au/lectures/branchPred.pdf&quot;&gt;지점 예측 검토&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e83995c1786dac19461a4d31bc4d8b9cde96f71d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Branch predictor&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;분기 예측기&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17ca7e4d199635bbed9dd553888d82060ea8e587" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://stackoverflow.blog/2019/10/11/c-creator-bjarne-stroustrup-answers-our-top-five-c-questions/&quot;&gt;Bjarne Stroustrup's Answer&lt;/a&gt; to this question:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 질문에 대한 &lt;a href=&quot;https://stackoverflow.blog/2019/10/11/c-creator-bjarne-stroustrup-answers-our-top-five-c-questions/&quot;&gt;Bjarne Stroustrup의 답변&lt;/a&gt; :&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6999c55f1112ac2522394d373dcc92bf8ba35d17" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://web.njit.edu/~rlopes/Mod5.3.pdf&quot;&gt;Branch Prediction&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://web.njit.edu/~rlopes/Mod5.3.pdf&quot;&gt;지점 예측&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2567a75f2917b4cf19219547a29e45cd68bfc50" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Modern processors are complicated and have long pipelines. So they take forever to &quot;warm up&quot; and &quot;slow down&quot;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;최신 프로세서는 복잡하고 파이프 라인이 길다.&lt;/em&gt; &lt;em&gt;그래서 그들은 &quot;온난화&quot;하고 &quot;느리게&quot;하는데 영원히 걸립니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c4e8b34981c89b9e7eadedce54ab4bf99abb400" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Trains are heavy and have a lot of inertia. So they take forever to start up and slow down.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;열차는 무겁고 많은 관성이 있습니다.&lt;/em&gt; &lt;em&gt;그래서 그들은 시작하고 느리게 영원히 걸립니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dfd2a9e0eebface4570f5726ff229d9f7239571" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Static&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. 정적&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec921c20fc92beab445f0b65b62aac1dc30fda89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Dynamic&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. 동적&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7070b983b9e682ffd47dc61eb8173e377437895" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;4-stage pipeline in general for 2 instructions.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;2 가지 명령에 대한 일반적인 4 단계 파이프 라인.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7c0dc2f57cc914145b6b0624cff97eb77959909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;But this is actually part of a bigger picture:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;그러나 이것은 실제로 더 큰 그림의 일부입니다.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a57d022fefdf1a6dc6fb7aff0b41a4c5a3d4191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;In case of a correct guess, the pipeline looks something like this:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;정확한 추측의 경우 파이프 라인은 다음과 같습니다.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="059ec29570653df3139916923c59df324c15a8f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;In other words, you try to identify a pattern and follow it.&lt;/em&gt;&lt;/strong&gt; This is more or less how branch predictors work.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;다시 말해, 패턴을 식별하고 따라갑니다.&lt;/em&gt;&lt;/strong&gt; 이것은 분기 예측자가 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="e2c23a7d4a1b5f910c13dc8dd8d34c2b4feb4d6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When if condition returns false:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;조건이 false를 반환하는 경우 :&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4757bf44b2540d4c3544fbd8ed736018934b59c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;when if condition returns true:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;조건이 true를 반환하는 경우 :&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a145133a463629536767d61372777b3b15514477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Background and why&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;배경과 이유&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="03ac7fc31e2558f71e7c0316cacb5b6078717e4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Backward conditional branches&lt;/strong&gt; - the PC is changed to point backward in the instruction stream. The branch is based on some condition, such as branching backwards to the beginning of a program loop when a test at the end of the loop states the loop should be executed again.</source>
          <target state="translated">&lt;strong&gt;뒤로 조건부 분기&lt;/strong&gt; -PC가 명령 스트림에서 뒤로 향하도록 변경되었습니다. 분기는 루프의 끝에서 테스트 할 때 루프를 다시 실행해야 할 때 프로그램 루프의 시작으로 뒤로 분기하는 것과 같은 일부 조건을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="88725d83d10b621a1197929903db27ce4176d85e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Benchmarks: Core i7 920 @ 3.5 GHz&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;벤치 마크 : Core i7 920 @ 3.5 GHz&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29e42a036c1d0c70cc19beaa407c40f6950cdef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch prediction.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;지점 예측.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c55e466ed2fc88a1e76e953db7f49f1fd3730ab3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch prediction&lt;/strong&gt; makes the logic run slower, because of the switching which happens in your code! It's like you are going a straight street or a street with a lot of turnings, for sure the straight one is going to be done quicker!...</source>
          <target state="translated">&lt;strong&gt;분기 예측&lt;/strong&gt; 은 코드에서 발생하는 전환으로 인해 로직 실행을 느리게 만듭니다! 그것은 당신이 직선 거리 또는 많은 터닝과 거리를 가고있는 것처럼, 직선이 빨리 끝나는 것을 확신합니다! ...</target>
        </trans-unit>
        <trans-unit id="d218041da74b681266dd3bc64ecbec4c36a29624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch-prediction gain!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;분기 예측 이득!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e98dec0bd0a7e8e2059d13e9a8c88d55b96ae930" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Consider an if-statement:&lt;/strong&gt; At the processor level, it is a branch instruction:</source>
          <target state="translated">&lt;strong&gt;if 문을 고려하십시오&lt;/strong&gt; . 프로세서 레벨에서 이는 분기 명령입니다.</target>
        </trans-unit>
        <trans-unit id="c1e69093a905a8b010540753c555aae1f8e36d3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructing a table&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;테이블 구성&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="130a0bfbd8fc444b6379d249ad5d24a0e69aaf6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Forward conditional branches&lt;/strong&gt; - based on a run-time condition, the PC (program counter) is changed to point to an address forward in the instruction stream.</source>
          <target state="translated">&lt;strong&gt;순방향 조건부 분기&lt;/strong&gt; -런타임 조건에 따라 PC (프로그램 카운터)가 명령 스트림에서 주소 순방향을 가리 키도록 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="5bb5d1ddff4f6d3eb81208ce3786e0186300f35b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess right every time&lt;/strong&gt;, the execution will never have to stop.</source>
          <target state="translated">&lt;strong&gt;매번 올바르게 추측&lt;/strong&gt; 하면 실행을 중지 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5c443327b64ce0afa013e0a8c686cce4fcb25e64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess right every time&lt;/strong&gt;, the train will never have to stop.</source>
          <target state="translated">&lt;strong&gt;당신이 매번 올바르게 추측한다면&lt;/strong&gt; , 기차는 결코 멈출 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="43854ebdaaaf1f8914276249ab523b2bf804d1c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess wrong too often&lt;/strong&gt;, the train will spend a lot of time stopping, backing up, and restarting.</source>
          <target state="translated">&lt;strong&gt;너무 자주 잘못 추측&lt;/strong&gt; 하면 기차가 멈추고 백업하고 다시 시작하는 데 많은 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="ff48f0bff759820faca0dc4ce0d054010aa2a369" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess wrong too often&lt;/strong&gt;, you spend a lot of time stalling, rolling back, and restarting.</source>
          <target state="translated">&lt;strong&gt;너무 자주 잘못 추측&lt;/strong&gt; 하면 실속, 롤백 및 다시 시작하는 데 많은 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="29e3b2963af7a82c74a39140e23e664c8aa6638f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Increasing the Instruction Fetch Rate via Multiple Branch Prediction and a Branch Address Cache&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다중 브랜치 예측 및 브랜치 주소 캐시를 통한 명령 페치 비율 증가&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80ce9cf0a86a6ef1b733fbee4d9e322ccb10c80d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's do some bench marking to understand it better&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;더 잘 이해하기 위해 벤치 마킹을 해 봅시다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6ddf289b433253c5925b3f9813d36a0537be7c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Managed languages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;관리되는 언어&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a1b89da59705a9d2d5291d59ff4a51ef12d08c3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Quick visualization:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;빠른 시각화 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5270a251ef82abdcf7f4c1527f163a3cea8e0e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what can be done?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그래서 무엇을 할 수 있습니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ab826d0d5faf44d4a7a8a7aad1ef803be005faf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what is branch prediction?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그렇다면 분기 예측이란 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d285155e760355be2f39c1257c5821d5da261a1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorted:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sorted:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd9c2da2ee8d01be5229516e95ec725d64e3f165" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static/dynamic Branch Prediction&lt;/strong&gt;: Static branch prediction is used by the microprocessor the first time a conditional branch is encountered, and dynamic branch prediction is used for succeeding executions of the conditional branch code.</source>
          <target state="translated">&lt;strong&gt;정적 / 동적 분기 예측&lt;/strong&gt; : 정적 분기 예측은 조건부 분기가 처음 발생할 때 마이크로 프로세서에 의해 사용되며 동적 분기 예측은 조건부 분기 코드의 후속 실행에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="078fac8f79d7e758f85f3007634fdc8cb9777688" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result of this case&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;이 사건의 결과&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6315a32d6eff633cf664b3192d3c2b8360df6c43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unconditional branches&lt;/strong&gt; - this includes jumps, procedure calls and returns that have no specific condition. For example, an unconditional jump instruction might be coded in assembly language as simply &quot;jmp&quot;, and the instruction stream must immediately be directed to the target location pointed to by the jump instruction, whereas a conditional jump that might be coded as &quot;jmpne&quot; would redirect the instruction stream only if the result of a comparison of two values in a previous &quot;compare&quot; instructions shows the values to not be equal. (The segmented addressing scheme used by the x86 architecture adds extra complexity, since jumps can be either &quot;near&quot; (within a segment) or &quot;far&quot; (outside the segment). Each type has different effects on branch prediction algorithms.)</source>
          <target state="translated">&lt;strong&gt;무조건 분기&lt;/strong&gt; -여기에는 특정 조건이없는 점프, 프로 시저 호출 및 리턴이 포함됩니다. 예를 들어, 무조건 점프 명령은 어셈블리 언어에서 단순히 &quot;jmp&quot;로 코딩 될 수 있으며, 명령 스트림은 점프 명령이 가리키는 대상 위치로 즉시 지정되어야하지만 &quot;jmpne&quot;으로 코딩 될 수있는 조건부 점프는 이전 &quot;비교&quot;명령어에서 두 값을 비교 한 결과 값이 같지 않은 경우에만 명령어 스트림을 리디렉션합니다. (x86 아키텍처에서 사용되는 세그먼트 화 된 주소 지정 체계는 점프가 &quot;세그먼트 내에서&quot;또는 &quot;far&quot;(세그먼트 외부에서)가 될 수 있기 때문에 복잡성을 증가시킵니다. 각 유형은 분기 예측 알고리즘에 다른 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="d1721438d4fa087c689f86212f2138f7505dcb3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unsorted:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Unsorted:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8dfd8a5f8f4a830eea9365b9b460097fbbe4381" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With the Branch:&lt;/strong&gt; There is a huge difference between the sorted and unsorted data.</source>
          <target state="translated">&lt;strong&gt;분기 사용 :&lt;/strong&gt; 정렬 된 데이터와 정렬되지 않은 데이터 간에는 큰 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="03b5fb42d9ac84ced19e05a65a21ee596d5d6f7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With the Hack:&lt;/strong&gt; There is no difference between sorted and unsorted data.</source>
          <target state="translated">&lt;strong&gt;해킹 사용 :&lt;/strong&gt; 정렬 된 데이터와 정렬되지 않은 데이터 사이에는 차이가 없습니다.</target>
        </trans-unit>
        <trans-unit id="b16311ddb39aa62e4ad47e876353ac768d1b5d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You are a victim of &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;branch prediction&lt;/a&gt; fail.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;분기 예측&lt;/a&gt; 실패의 희생자입니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c786fafb5f8da23c331a0d7afceac4aae6e0c19e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;x64&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;x64&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b2f35b1567a33263e752a9bf7e298fd26bd105c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;x86&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;x86&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56bb00227cc3f2c966ad0c07a94c169bef8507ca" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Note that this hack is not strictly equivalent to the original if-statement. But in this case, it's valid for all the input values of &lt;code&gt;data[]&lt;/code&gt;.)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;(이 핵은 원래 if 문과 완전히 동일하지는 않지만 &lt;code&gt;data[]&lt;/code&gt; 의 모든 입력 값에 유효합니다.)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="daf1c2db057b9141218780bbe961c3fb9781bf1a" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;a href=&quot;//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG&quot;&gt;Image&lt;/a&gt; by Mecanismo, via Wikimedia Commons. Used under the &lt;a href=&quot;//creativecommons.org/licenses/by-sa/3.0/deed.en&quot;&gt;CC-By-SA 3.0&lt;/a&gt; license.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;위키 미디어 공용어를 통한 Mecanismo의 &lt;a href=&quot;//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG&quot;&gt;이미지&lt;/a&gt; .&lt;/sub&gt; &lt;sub&gt;&lt;a href=&quot;//creativecommons.org/licenses/by-sa/3.0/deed.en&quot;&gt;CC-By-SA 3.0&lt;/a&gt; 라이센스에 따라 사용됩니다.&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="85f4f86517c13577daac8db1438bfa704a81d1f5" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;strong&gt;bad&lt;/strong&gt;&amp;rdquo; true-false pattern can make an &lt;code&gt;if&lt;/code&gt;-statement up to six times slower than a &amp;ldquo;&lt;strong&gt;good&lt;/strong&gt;&amp;rdquo; pattern! Of course, which pattern is good and which is bad depends on the exact instructions generated by the compiler and on the specific processor.</source>
          <target state="translated">&quot; &lt;strong&gt;나쁜&lt;/strong&gt; &quot;참-거짓 패턴은 &lt;code&gt;if&lt;/code&gt; 문을 &quot; &lt;strong&gt;좋은&lt;/strong&gt; &quot;패턴보다 최대 6 배 느리게 만들 수 있습니다! 물론 어떤 패턴이 좋고 나쁜지는 컴파일러와 특정 프로세서에서 생성 한 정확한 명령에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="fa9002e4deffeb589b075bfcdf8a5cf9a18e318c" translate="yes" xml:space="preserve">
          <source>A branch instruction can cause a computer to begin executing a different instruction sequence and thus deviate from its default behavior of executing instructions in order (i.e. if the expression is false, the program skips the code of the &lt;code&gt;if&lt;/code&gt; block) depending on some condition, which is the expression evaluation in our case.</source>
          <target state="translated">분기 명령어는 컴퓨터가 다른 명령어 시퀀스를 실행하기 시작하여 어떤 조건에 따라 명령어를 실행하는 기본 동작 (예 : 표현식이 false 인 경우 프로그램은 &lt;code&gt;if&lt;/code&gt; 블록의 코드를 건너 뜁니다)에서 벗어 납니다. 우리의 경우 표현 평가입니다.</target>
        </trans-unit>
        <trans-unit id="dea845d0a945ad214f5fefb6c4b0e6c1e6051bc4" translate="yes" xml:space="preserve">
          <source>A branch predictor is one of the ancient performance improving techniques which still finds relevance into modern architectures. While the simple prediction techniques provide fast lookup and power efficiency they suffer from a high misprediction rate.</source>
          <target state="translated">브랜치 예측기는 현대 아키텍처와의 관련성을 여전히 찾아내는 고대 성능 개선 기술 중 하나입니다. 간단한 예측 기술은 빠른 조회 및 전력 효율을 제공하지만 높은 오 탐률로 인해 어려움을 겪습니다.</target>
        </trans-unit>
        <trans-unit id="37fb85f91b43ff03464a3ace5cd03f2e7b1d689f" translate="yes" xml:space="preserve">
          <source>A common way to eliminate branch prediction that I've found to work particularly good in managed languages is a table lookup instead of using a branch (although I haven't tested it in this case).</source>
          <target state="translated">관리되는 언어에서 특히 잘 작동하는 것으로 확인 된 분기 예측을 제거하는 일반적인 방법은 분기를 사용하는 대신 테이블 조회입니다 (이 경우 테스트하지는 않았지만).</target>
        </trans-unit>
        <trans-unit id="2d5382f7f97d599d6c1c60ae36b7533c1e391142" translate="yes" xml:space="preserve">
          <source>A general rule of thumb is to avoid data-dependent branching in critical loops (such as in this example).</source>
          <target state="translated">일반적인 경험 법칙은 중요한 루프에서 데이터 종속 분기를 피하는 것입니다 (이 예와 같이).</target>
        </trans-unit>
        <trans-unit id="2a0c61937b135599b6110466d59da1b10f3e69cc" translate="yes" xml:space="preserve">
          <source>A yet faster approach, that gives an &lt;strong&gt;approximate&lt;/strong&gt; solution for both sorted or unsorted is: &lt;code&gt;sum= 3137536;&lt;/code&gt; (assuming a truly uniform distribution, 16384 samples with expected value 191.5) &lt;strong&gt;:-)&lt;/strong&gt;</source>
          <target state="translated">정렬되거나 정렬되지 않은 솔루션에 대한 &lt;strong&gt;대략적인&lt;/strong&gt; 솔루션을 제공하는보다 빠른 접근 방식은 다음과 같습니다. &lt;code&gt;sum= 3137536;&lt;/code&gt; (정확히 분포를 가정하면, 예상 값이 191.5 인 16384 개의 샘플을 가정) &lt;strong&gt;:-)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f443462e3c594cabbf5f71234fac4ceb6009a988" translate="yes" xml:space="preserve">
          <source>All the elements are greater than 128</source>
          <target state="translated">모든 요소가 128보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="60b7feee5533f80829de14d53e01cb5cd2f55c48" translate="yes" xml:space="preserve">
          <source>All the elements are less than 128</source>
          <target state="translated">모든 요소는 128보다 작습니다</target>
        </trans-unit>
        <trans-unit id="0529f5c0c9474ccd9e39a30f16e35b00bb471784" translate="yes" xml:space="preserve">
          <source>Also I want to cite &lt;a href=&quot;https://stackoverflow.com/users/16940/simon-weaver&quot;&gt;@Simon_Weaver&lt;/a&gt; from the comments:</source>
          <target state="translated">또한 의견에서 &lt;a href=&quot;https://stackoverflow.com/users/16940/simon-weaver&quot;&gt;@Simon_Weaver&lt;/a&gt; 를 인용하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="fed9e7e89414aa4f62ee84308b32e6df6a42784c" translate="yes" xml:space="preserve">
          <source>Also at the end, it's good to know we have two kinds of branch predictions that each is going to affect your code differently:</source>
          <target state="translated">또한 마지막에는 각각 코드에 다르게 영향을 줄 두 가지 유형의 분기 예측이 있다는 것을 아는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="118e6e8352ef9219f30b284c2eec943d64cac174" translate="yes" xml:space="preserve">
          <source>Alternatively, on Linux you can use the performance counters subsystem to accomplish the same task, but with native performance using CPU counters.</source>
          <target state="translated">또는 Linux에서 성능 카운터 하위 시스템을 사용하여 동일한 작업을 수행 할 수 있지만 CPU 카운터를 사용하는 기본 성능을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="407d8227038ebf4c70f4b17f8cbd8db2e0cf6ac0" translate="yes" xml:space="preserve">
          <source>Although both the roads reach the same destination, the straight road is shorter, and the other is longer. If then you choose the other by mistake, there is no turning back, and so you will waste some extra time if you choose the longer road. This is similar to what happens in the computer, and I hope this helped you understand better.</source>
          <target state="translated">두 도로가 같은 목적지에 도달하지만 직선 도로는 더 짧고 다른 도로는 더 깁니다. 실수로 다른 사람을 선택하면 돌아갈 필요가 없으므로 더 긴 도로를 선택하면 시간이 더 소요됩니다. 이것은 컴퓨터에서 발생하는 것과 유사하며 이것이 더 잘 이해하는 데 도움이 되었기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="72b615d954c685d03dbd988b02705d36339eea5d" translate="yes" xml:space="preserve">
          <source>An official answer would be from</source>
          <target state="translated">공식 답변은</target>
        </trans-unit>
        <trans-unit id="e16854241a2d65fb883d369651da41390d02fcc0" translate="yes" xml:space="preserve">
          <source>Another reason is that when the vector is already sorted, we never need to move elements to their correct position. The effect of these little details is the factor of five or six that we saw.</source>
          <target state="translated">또 다른 이유는 벡터가 이미 정렬되었을 때 요소를 올바른 위치로 옮길 필요가 없기 때문입니다. 이 작은 세부 사항의 효과는 우리가 본 5 또는 6의 요소입니다.</target>
        </trans-unit>
        <trans-unit id="18b72662db383a9f75e385af80ee82d4f1ad5ed5" translate="yes" xml:space="preserve">
          <source>Any instruction is broken into a sequence of steps so that different steps can be executed concurrently in parallel. This technique is known as instruction pipeline and this is used to increase throughput in modern processors. To understand this better please see this &lt;a href=&quot;https://en.wikipedia.org/wiki/Pipeline_(computing)#Concept_and_motivation&quot;&gt;example on Wikipedia&lt;/a&gt;.</source>
          <target state="translated">모든 명령은 일련의 단계로 나뉘어 서로 다른 단계를 동시에 실행할 수 있습니다. 이 기술을 명령 파이프 라인이라고하며 최신 프로세서의 처리량을 높이는 데 사용됩니다. 이것을 더 잘 이해하려면 &lt;a href=&quot;https://en.wikipedia.org/wiki/Pipeline_(computing)#Concept_and_motivation&quot;&gt;Wikipedia&lt;/a&gt; 에서이 예제 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="bcb1019315b39b373530b7c1baab0d26a3114719" translate="yes" xml:space="preserve">
          <source>Articles in scientific publications: T.Y. Yeh, Y.N. Patt made a lot of these on branch predictions.</source>
          <target state="translated">과학 간행물에 실린 기사 : TY Yeh, YN Patt는 분기 예측에 대해 많은 것들을 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="0a92cf5f4b626666fbf175648e0a6f274113a6f6" translate="yes" xml:space="preserve">
          <source>As a result of waiting for the result of instruction A, the total CPU cycles spent in the above case (without branch prediction; for both true and false) is 7.</source>
          <target state="translated">명령어 A의 결과를 기다린 결과, 위의 경우에 사용 된 총 CPU주기 (분기 예측없이, 참과 거짓 모두)는 7입니다.</target>
        </trans-unit>
        <trans-unit id="91b190f8f20d90d506eb2a535168aaeb504cbac3" translate="yes" xml:space="preserve">
          <source>As data is distributed between 0 and 255 when the array is sorted, around the first half of the iterations will not enter the &lt;code&gt;if&lt;/code&gt;-statement (the &lt;code&gt;if&lt;/code&gt; statement is shared below).</source>
          <target state="translated">배열이 정렬 될 때 데이터가 0에서 255 사이로 분산되므로 반복의 절반이 &lt;code&gt;if&lt;/code&gt; -statement ( &lt;code&gt;if&lt;/code&gt; 문이 아래에서 공유 됨)를 입력하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cb7653dba96134a9f8b8386b70f0dd6cac24bb0a" translate="yes" xml:space="preserve">
          <source>As hinted from above, the culprit is this if-statement:</source>
          <target state="translated">위에서 암시 한 바와 같이 범인은이 if 문입니다.</target>
        </trans-unit>
        <trans-unit id="485df5143cbc2b24d62743d36ee8956b76546eb1" translate="yes" xml:space="preserve">
          <source>As what has already been mentioned by others, what behind the mystery is &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Branch Predictor&lt;/a&gt;.</source>
          <target state="translated">다른 사람들이 이미 언급했듯이, 미스터리의 배후에는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Branch Predictor가&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b08e517362c42b5803f28e7adc40496f99cf8e9" translate="yes" xml:space="preserve">
          <source>As you can see, it seems we don't have a reason not to use Branch Predictor.</source>
          <target state="translated">보시다시피, 분기 예측기를 사용하지 않는 이유는 없습니다.</target>
        </trans-unit>
        <trans-unit id="4f55d0a62def8f894343508ecf5fe4ae7cfbc922" translate="yes" xml:space="preserve">
          <source>At least the phenomenon is real with this compiler, standard library, and optimizer settings. Different implementations can and do give different answers. In fact, someone did do a more systematic study (a quick web search will find it) and most implementations show that effect.</source>
          <target state="translated">적어도이 현상은이 컴파일러, 표준 라이브러리 및 옵티 마이저 설정에서 실제입니다. 다른 구현은 다른 답변을 줄 수 있습니다. 사실, 누군가는 좀 더 체계적인 연구 (빠른 웹 검색으로 찾아 낼 수 있음)를 수행했으며 대부분의 구현에서는 그 효과를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="fd41bc2c6095914eb987318731cbb8136aa88df0" translate="yes" xml:space="preserve">
          <source>Based on the described scenario, I have written an animation demo to show how instructions are executed in a pipeline in different situations.</source>
          <target state="translated">설명 된 시나리오를 기반으로 다양한 상황에서 파이프 라인에서 명령이 실행되는 방법을 보여주는 애니메이션 데모를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="f227c3a03a7731e12cfd0e90cd5a61346155ae8b" translate="yes" xml:space="preserve">
          <source>Based on this, it looks MATLAB is almost &lt;em&gt;175 times&lt;/em&gt; slower than the C implementation without sorting and &lt;em&gt;350 times&lt;/em&gt; slower with sorting. In other words, the effect (of branch prediction) is &lt;em&gt;1.46x&lt;/em&gt; for MATLAB implementation and &lt;em&gt;2.7x&lt;/em&gt; for the C implementation.</source>
          <target state="translated">이를 바탕으로 MATLAB은 정렬없이 C 구현보다 거의 &lt;em&gt;175 배&lt;/em&gt; 느리고 정렬에서는 &lt;em&gt;350 배&lt;/em&gt; 느립니다. 즉, 분기 예측의 효과는 MATLAB 구현의 경우 &lt;em&gt;1.46x&lt;/em&gt; 이고 C 구현의 경우 &lt;em&gt;2.7x&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7f0b96f3c9bc5eedd14fbfce8ae4e5637fcd2f88" translate="yes" xml:space="preserve">
          <source>Besides the fact that the branch prediction may slow you down, a sorted array has another advantage:</source>
          <target state="translated">분기 예측이 속도를 늦출 수 있다는 사실 외에도 정렬 된 배열에는 또 다른 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbfea8990261f42832136208062c8c674500cbb0" translate="yes" xml:space="preserve">
          <source>Books: J.L. Hennessy, D.A. Patterson: Computer architecture: a quantitative approach</source>
          <target state="translated">책 : JL Hennessy, DA Patterson : 컴퓨터 아키텍처 : 정량적 접근</target>
        </trans-unit>
        <trans-unit id="829b3fb58a7b85f64a37f8e20d7ec7596c0db7f0" translate="yes" xml:space="preserve">
          <source>Boolean variables are overdetermined in the sense that all operators that have Boolean variables as input check if the inputs have any other value than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, but operators that have Booleans as output can produce no other value than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. This makes operations with Boolean variables as input less efficient than necessary.
Consider example:</source>
          <target state="translated">부울 변수는 입력으로 부울 변수가있는 모든 연산자가 입력에 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 이외의 다른 값이 있는지 확인하지만 부울이 출력 인 연산자는 &lt;code&gt;0&lt;/code&gt; 또는 &lt;code&gt;1&lt;/code&gt; 이외의 다른 값을 생성 할 수 없다는 점에서 과도하게 결정됩니다. 따라서 부울 변수를 입력으로 사용하여 필요한 것보다 효율성이 떨어집니다. 예를 들어 보자.</target>
        </trans-unit>
        <trans-unit id="0f586453c8b155549182d123a0dddc7e7cafdb04" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;likely()&lt;/code&gt; and &lt;code&gt;unlikely()&lt;/code&gt; are in fact macros that are defined by using something like the GCC's &lt;code&gt;__builtin_expect&lt;/code&gt; to help the compiler insert prediction code to favour the condition taking into account the information provided by the user. GCC supports other builtins that could change the behavior of the running program or emit low level instructions like clearing the cache, etc. See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html&quot;&gt;this documentation&lt;/a&gt; that goes through the available GCC's builtins.</source>
          <target state="translated">Possible &lt;code&gt;likely()&lt;/code&gt; 과 &lt;code&gt;unlikely()&lt;/code&gt; 는 실제로 GCC의 &lt;code&gt;__builtin_expect&lt;/code&gt; 와 같은 것을 사용하여 정의 된 매크로로, 컴파일러가 사용자가 제공 한 정보를 고려하여 조건을 선호하도록 예측 코드를 삽입하도록 도와줍니다. GCC는 실행중인 프로그램의 동작을 변경하거나 캐시 지우기 등과 같은 저수준 명령어를 생성 할 수있는 다른 내장 기능을 지원합니다. 사용 가능한 GCC 내장 기능을 &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html&quot;&gt;통해이 문서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e3be8498fb9bc40fab8d29adec6459c84941f461" translate="yes" xml:space="preserve">
          <source>Branch prediction is essentially an optimization (minimization) problem where the emphasis is on to achieve lowest possible miss rate, low power consumption, and low complexity with minimum resources.</source>
          <target state="translated">브랜치 예측은 기본적으로 가능한 최소 미스 레이트, 낮은 전력 소비 및 최소의 리소스로 낮은 복잡성을 달성하기 위해 강조되는 최적화 (최소화) 문제입니다.</target>
        </trans-unit>
        <trans-unit id="ce09fc1b6a54ba26385b7dcf3dc61b849d981bdb" translate="yes" xml:space="preserve">
          <source>Branch prediction: Guessing/predicting which road is straight and following it without checking</source>
          <target state="translated">지점 예측 : 어떤 도로가 똑 바르고 점검하지 않고 따라 가는지 추측 / 예측</target>
        </trans-unit>
        <trans-unit id="bf6354b6953e28aa0b0401d2ab4cdf0bab9f9a80" translate="yes" xml:space="preserve">
          <source>Branch predictor will try to guess which way a branch (an if-then-else structure) will go before this is known for sure. It will not wait for the instruction A to reach the EX stage of the pipeline, but it will guess the decision and go to that instruction (B or C in case of our example).</source>
          <target state="translated">브랜치 예측기는 브랜치 (if-then-else 구조)가이 방법을 확실히하기 전에 어느 방향으로 갈지 추측하려고합니다. 명령 A가 파이프 라인의 EX 단계에 도달 할 때까지 기다리지는 않지만 결정을 추측하고 해당 명령으로 이동합니다 (이 예에서는 B 또는 C).</target>
        </trans-unit>
        <trans-unit id="167e8ac318227dcb55522a65e67d450259397b78" translate="yes" xml:space="preserve">
          <source>But in case of a random unsorted array, the prediction will need to discard the partially executed instructions and start over with the correct branch most of the time and result in more CPU cycles compared to the sorted array.</source>
          <target state="translated">그러나 임의의 정렬되지 않은 배열의 경우 예측은 부분적으로 실행 된 명령어를 버리고 대부분의 올바른 분기로 다시 시작하여 정렬 된 배열에 비해 더 많은 CPU주기를 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="dbc576af53dd6fb3f0dc64893d4fed7f4cc4366f" translate="yes" xml:space="preserve">
          <source>But in my testing, an explicit lookup table was slightly faster than this, probably because indexing into a lookup table was slightly faster than bit shifting.  This shows how my code sets up and uses the lookup table (unimaginatively called &lt;code&gt;lut&lt;/code&gt; for &quot;LookUp Table&quot; in the code).  Here's the C++ code:</source>
          <target state="translated">그러나 테스트에서 명시 룩업 테이블이 이것보다 약간 빠르 았습니다. 아마 룩업 테이블에 대한 인덱싱이 비트 이동보다 약간 빠르기 때문일 수 있습니다. 이것은 코드가 룩업 테이블 (코드에서 &quot;LookUp Table&quot;에 대한 &lt;code&gt;lut&lt;/code&gt; 라고 함)을 설정하고 사용하는 방법을 보여줍니다. C ++ 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="556743da1a16719ba282399e5ea0e47a985396e0" translate="yes" xml:space="preserve">
          <source>But in my testing, an explicit lookup table was slightly faster than this, probably because indexing into a lookup table was slightly faster than bit shifting. This shows how my code sets up and uses the lookup table (unimaginatively called lut for &quot;LookUp Table&quot; in the code). Here's the C++ code:</source>
          <target state="translated">그러나 테스트에서 명시 룩업 테이블이 이것보다 약간 빠르 았습니다. 아마 룩업 테이블에 대한 인덱싱이 비트 이동보다 약간 빠르기 때문일 수 있습니다. 이것은 코드가 룩업 테이블 (코드에서 &quot;LookUp Table&quot;에 대한 lut라고 함)을 설정하고 사용하는 방법을 보여줍니다. C ++ 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a09b475c5d193e2a2ef480d8477ce7319209e1cd" translate="yes" xml:space="preserve">
          <source>But in this case, we know values are in the range [0, 255] and we only care about values &amp;gt;= 128. That means we can easily extract a single bit that will tell us whether we want a value or not: by shifting the data to the right 7 bits, we are left with a 0 bit or a 1 bit, and we only want to add the value when we have a 1 bit. Let's call this bit the &quot;decision bit&quot;.</source>
          <target state="translated">그러나이 경우 값이 [0, 255] 범위에 있고 값&amp;gt; = 128에만 관심이 있다는 것을 알고 있습니다. 즉, 값을 원하는지 여부를 알려주는 단일 비트를 쉽게 추출 할 수 있습니다. 오른쪽 7 비트의 데이터는 0 비트 또는 1 비트로 남겨두고 1 비트가있는 경우에만 값을 추가하려고합니다. 이 비트를 &quot;결정 비트&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="58cee47e25522bb2e607e044796956fc2d95746f" translate="yes" xml:space="preserve">
          <source>By using the 0/1 value of the decision bit as an index into an array, we can make code that will be equally fast whether the data is sorted or not sorted. Our code will always add a value, but when the decision bit is 0, we will add the value somewhere we don't care about. Here's the code:</source>
          <target state="translated">결정 비트의 0/1 값을 배열의 인덱스로 사용하여 데이터 정렬 여부에 상관없이 동일하게 빠른 코드를 만들 수 있습니다. 코드는 항상 값을 추가하지만 결정 비트가 0이면 관심이없는 곳에 값을 추가합니다. 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="56bb3ef2fb6bcc14eb09093062d52086eb734f83" translate="yes" xml:space="preserve">
          <source>C++ - Visual Studio 2010 - x64 Release</source>
          <target state="translated">C ++-Visual Studio 2010-x64 릴리스</target>
        </trans-unit>
        <trans-unit id="907dc42739003087cf41fc698a5aef43e56b2716" translate="yes" xml:space="preserve">
          <source>Consider a railroad junction:</source>
          <target state="translated">철도 교차점을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0008f55380e54b1390ff08936a649b5378e8d33b" translate="yes" xml:space="preserve">
          <source>Drilling down into the line-by-line output produced by &lt;code&gt;cg_annotate&lt;/code&gt; we see for the loop in question:</source>
          <target state="translated">&lt;code&gt;cg_annotate&lt;/code&gt; 에 의해 생성 된 라인 별 출력으로 드릴 다운하면 해당 루프에 대해 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e84c032993f25d05ec7cbf44965cf42d501894a7" translate="yes" xml:space="preserve">
          <source>EX -- Execute the instruction</source>
          <target state="translated">EX-명령 실행</target>
        </trans-unit>
        <trans-unit id="91b7378edbcc8a2dcbc0578b242232b9f0edf9c0" translate="yes" xml:space="preserve">
          <source>Each element in the original code is a random value</source>
          <target state="translated">원래 코드의 각 요소는 임의의 값입니다</target>
        </trans-unit>
        <trans-unit id="5b31068fcc3d6c11d6243f6f58c031a60e4fe724" translate="yes" xml:space="preserve">
          <source>Fortunately for us, if the memory access pattern is predictable, the processor will load it in its fast cache and all is well.</source>
          <target state="translated">다행스럽게도 메모리 액세스 패턴을 예측할 수 있으면 프로세서는 빠른 캐시에이를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96d1b40b361ab03cd656fc01b084e5d379dd61ce" translate="yes" xml:space="preserve">
          <source>Frequently used Boolean operations in C++ produce many branches in the compiled program. If these branches are inside loops and are hard to predict they can slow down execution significantly. Boolean variables are stored as 8-bit integers with the value &lt;code&gt;0&lt;/code&gt; for &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">C ++에서 자주 사용되는 부울 연산은 컴파일 된 프로그램에서 많은 분기를 생성합니다. 이러한 분기가 루프 내부에 있고 예측하기 어려운 경우 실행 속도가 크게 느려질 수 있습니다. 부울 변수는 값이 &lt;code&gt;false&lt;/code&gt; 인 경우 &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; 인 경우 &lt;code&gt;1&lt;/code&gt; 의 8 비트 정수로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="fbb5582021303c8d664e2d578e2f2f31b983748c" translate="yes" xml:space="preserve">
          <source>From a processor perspective, your memory is slow. To compensate for the difference in speed, a couple of caches are built into your processor (L1/L2 cache). So imagine that you're doing your nice calculations and figure out that you need a piece of memory. The processor will get its 'load' operation and loads the piece of memory into cache -- and then uses the cache to do the rest of the calculations. Because memory is relatively slow, this 'load' will slow down your program.</source>
          <target state="translated">프로세서 관점에서 볼 때 메모리가 느립니다. 속도의 차이를 보상하기 위해 프로세서에 두 개의 캐시가 내장되어 있습니다 (L1 / L2 캐시). 당신이 멋진 계산을하고 있다고 생각하고 메모리가 필요하다는 것을 알아 내십시오. 프로세서는 '로드'작업을 수행하고 메모리 조각을 캐시에로드 한 다음 캐시를 사용하여 나머지 계산을 수행합니다. 메모리가 상대적으로 느리기 때문에이 '로드'로 인해 프로그램 속도가 느려집니다.</target>
        </trans-unit>
        <trans-unit id="a69eb648a593eb899c67ee00a5913154aebeadb2" translate="yes" xml:space="preserve">
          <source>Further reading: &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;&quot;Branch predictor&quot; article on Wikipedia&lt;/a&gt;.</source>
          <target state="translated">더 읽을 거리 : &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Wikipedia의 &quot;지점 예측기&quot;기사&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cb4ec23cd0f11546771882b0c409bbbd82fc5ea" translate="yes" xml:space="preserve">
          <source>GCC 4.6.1 with &lt;code&gt;-O3&lt;/code&gt; or &lt;code&gt;-ftree-vectorize&lt;/code&gt; on x64 is able to generate a conditional move. So there is no difference between the sorted and unsorted data - both are fast.</source>
          <target state="translated">x64에서 &lt;code&gt;-O3&lt;/code&gt; 또는 &lt;code&gt;-ftree-vectorize&lt;/code&gt; 를 사용 하는 GCC 4.6.1은 조건부 이동을 생성 할 수 있습니다. 따라서 정렬 된 데이터와 정렬되지 않은 데이터 사이에는 차이가 없습니다. 둘 다 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="f53bd842ecd4d4a9f495f435523c9cf23aa6a57c" translate="yes" xml:space="preserve">
          <source>Generally, modern processors have quite long pipelines, but for ease let's consider these 4 steps only.</source>
          <target state="translated">일반적으로 최신 프로세서에는 파이프 라인이 상당히 길지만 쉽게 4 단계 만 고려해 봅시다.</target>
        </trans-unit>
        <trans-unit id="38465cba940858cd4732031697c429623f9115b7" translate="yes" xml:space="preserve">
          <source>Here are the timings of the loop with different true-false patterns:</source>
          <target state="translated">서로 다른 참 거짓 패턴을 가진 루프의 타이밍은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6a74c4bde413f0664d97478a9af05dc6dec1968a" translate="yes" xml:space="preserve">
          <source>Here is a piece of C++ code that shows some very peculiar behavior. For some strange reason, sorting the data miraculously makes the code almost six times faster:</source>
          <target state="translated">다음은 매우 독특한 동작을 보여주는 C ++ 코드입니다. 이상한 이유로 데이터를 기적적으로 정렬하면 코드가 거의 6 배 빨라집니다.</target>
        </trans-unit>
        <trans-unit id="9540c640283f5095fcffbc3e62196fc4a354f281" translate="yes" xml:space="preserve">
          <source>Here's a link to this code: &lt;a href=&quot;http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx&quot;&gt;Red Black Trees&lt;/a&gt;, &lt;em&gt;Eternally Confuzzled&lt;/em&gt;</source>
          <target state="translated">이 코드에 대한 링크는 다음과 같습니다. &lt;a href=&quot;http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx&quot;&gt;Red Black Trees&lt;/a&gt; , &lt;em&gt;Eternally Confuzzled&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65bc35b8db256ec9378ffd563e6d314c0f419d53" translate="yes" xml:space="preserve">
          <source>However, when the data is completely random, the branch predictor is rendered useless, because it can't predict random data. Thus there will probably be around 50% misprediction (no better than random guessing).</source>
          <target state="translated">그러나 데이터가 완전히 임의 인 경우 분기 예측기는 임의 데이터를 예측할 수 없으므로 쓸모가 없게됩니다. 따라서 약 50 %의 오해가있을 것입니다 (임의 추측보다 낫지 않음).</target>
        </trans-unit>
        <trans-unit id="923101f6e2254ddc269c719e6877f55af0932907" translate="yes" xml:space="preserve">
          <source>I just read up on this question and its answers, and I feel an answer is missing.</source>
          <target state="translated">나는이 질문과 그 대답을 읽었으며 대답이 빠졌다고 느낍니다.</target>
        </trans-unit>
        <trans-unit id="6155d3cc9d0a0b68582ccdde2e81aba3a8812eb0" translate="yes" xml:space="preserve">
          <source>I ran that a few times to be sure. Yes, the phenomenon is real. My key code was:</source>
          <target state="translated">확실하게 몇 번 실행했습니다. 예, 현상은 실제입니다. 내 키 코드는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="411b77367cb6a07a9e121aa06f74b175e40b6fd6" translate="yes" xml:space="preserve">
          <source>I tried the same code with MATLAB 2011b with my MacBook Pro (Intel i7, 64 bit, 2.4 GHz) for the following MATLAB code:</source>
          <target state="translated">다음 MATLAB 코드에 대해 MacBook Pro (Intel i7, 64 비트, 2.4GHz)에서 MATLAB 2011b와 동일한 코드를 시도했습니다.</target>
        </trans-unit>
        <trans-unit id="51e91a54cf2fc822fbf81bdee0af955af2b6ea97" translate="yes" xml:space="preserve">
          <source>I'm not trying to add something but explaining the concept in another way. 
There is a concise introduction on the wiki which contains text and diagram.
I do like the explanation below which uses a diagram to elaborate the Branch Predictor intuitively.</source>
          <target state="translated">나는 무언가를 추가하지 않고 다른 방법으로 개념을 설명하려고합니다. 위키에는 텍스트와 다이어그램이 포함 된 간결한 소개가 있습니다. 아래의 설명을 통해 다이어그램을 사용하여 지점 예측자를 직관적으로 정교하게 설명합니다.</target>
        </trans-unit>
        <trans-unit id="065592acf6ecacc9b012a59339edcc7416aa6239" translate="yes" xml:space="preserve">
          <source>ID -- Decode the instruction</source>
          <target state="translated">ID-명령어 해독</target>
        </trans-unit>
        <trans-unit id="42c1b1564597619cb2c77349430882a2580c741c" translate="yes" xml:space="preserve">
          <source>IF -- Fetch the instruction from memory</source>
          <target state="translated">IF-메모리에서 명령어를 가져옵니다</target>
        </trans-unit>
        <trans-unit id="88eb4395003cb412e7661165f4ce4cf1f486289e" translate="yes" xml:space="preserve">
          <source>If it is later detected that the guess was wrong then the partially executed instructions are discarded and the pipeline starts over with the correct branch, incurring a delay. 
The time that is wasted in case of a branch misprediction is equal to the number of stages in the pipeline from the fetch stage to the execute stage. Modern microprocessors tend to have quite long pipelines so that the misprediction delay is between 10 and 20 clock cycles. The longer the pipeline the greater the need for a good &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;branch predictor&lt;/a&gt;.</source>
          <target state="translated">나중에 추측이 잘못되었다는 것이 감지되면 부분적으로 실행 된 명령이 삭제되고 파이프 라인이 올바른 분기로 시작하여 지연이 발생합니다. 분기 잘못 예측 된 경우 낭비되는 시간은 파이프 라인의 페치 단계에서 실행 단계까지의 단계 수와 같습니다. 최신 마이크로 프로세서는 파이프 라인이 매우 길기 때문에 오 탐지 지연이 10 ~ 20 클럭주기입니다. 파이프 라인이 길수록 좋은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;분기 예측 변수&lt;/a&gt; 가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="fd7de5e20eb6affc18989173e9a7fbd64cfc3a64" translate="yes" xml:space="preserve">
          <source>If the array is sorted, your condition is false at the first step: &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt;, then becomes a true value for the whole way to the end of the street. That's how you get to the end of the logic faster. On the other hand, using an unsorted array, you need a lot of turning and processing which make your code run slower for sure...</source>
          <target state="translated">배열이 정렬 된 경우 첫 번째 단계에서 &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; 이면 조건이 false가되고 도로 끝까지 전체 값이 참값이됩니다. 그것이 당신이 논리를 더 빨리 끝내는 방법입니다. 반면에 정렬되지 않은 배열을 사용하려면 코드를 느리게 실행하기 위해 많은 회전 및 처리가 필요합니다 ...</target>
        </trans-unit>
        <trans-unit id="56d4fd733b97267a72ee645f98fa635e9b8c6ce9" translate="yes" xml:space="preserve">
          <source>If the compiler isn't able to optimize the branch into a conditional move, you can try some hacks if you are willing to sacrifice readability for performance.</source>
          <target state="translated">컴파일러가 분기를 조건부 이동으로 최적화 할 수없는 경우 성능에 대한 가독성을 기꺼이 희생하려는 경우 해킹을 시도 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1824e7d45369351e72c6eb590133dd9e21d010ed" translate="yes" xml:space="preserve">
          <source>If you are curious about even more optimizations that can be done to this code, consider this:</source>
          <target state="translated">이 코드에 대해 더 많은 최적화가 필요한 경우 다음 사항을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="5ceebbf643b622dd844b59e8bd85fc4f5ede90be" translate="yes" xml:space="preserve">
          <source>If you give the Intel compiler the branchless code, it just out-right vectorizes it... and is just as fast as with the branch (with the loop interchange).</source>
          <target state="translated">인텔 컴파일러에 분기없는 코드를 제공하면 코드를 벡터화하여 분기와 마찬가지로 (루프 인터체인지) 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ae88c41ed067d722d464020e7a9f55e02d32fddc" translate="yes" xml:space="preserve">
          <source>If you guessed right, it continues on.</source>
          <target state="translated">당신이 올바르게 추측하면 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="bbb6c6bc29b605454dbfe7f8781ef7cdb2c270f2" translate="yes" xml:space="preserve">
          <source>If you guessed right, you continue executing.</source>
          <target state="translated">올바르게 추측하면 계속 실행합니다.</target>
        </trans-unit>
        <trans-unit id="1898647ae8c929024233a50359541e7af7814ea2" translate="yes" xml:space="preserve">
          <source>If you guessed wrong, the captain will stop, back up, and yell at you to flip the switch. Then it can restart down the other path.</source>
          <target state="translated">당신이 틀렸다고 생각하면, 선장이 멈추고, 백업하고, 스위치를 뒤집으라고 소리 칠 것입니다. 그런 다음 다른 경로를 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b46e462a942895bb7f6e7d844e7730c6d70136b" translate="yes" xml:space="preserve">
          <source>If you guessed wrong, you need to flush the pipeline and roll back to the branch. Then you can restart down the other path.</source>
          <target state="translated">잘못 추측 한 경우 파이프 라인을 플러시하고 분기로 롤백해야합니다. 그런 다음 다른 경로를 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23319b8aed03d58e34f2b56f4949401e859e197b" translate="yes" xml:space="preserve">
          <source>If you have ever wondered why ARM has been so phenomenally successful, the brilliant effectiveness and interplay of these two mechanisms are a big part of the story, because they are one of the greatest sources of the ARM architecture's efficiency. The brilliance of the original designers of the ARM ISA back in 1983, Steve Furber and Roger (now Sophie) Wilson, cannot be overstated.</source>
          <target state="translated">ARM이 왜 대단한 성공을 거둔 지 궁금한 적이 있다면이 두 메커니즘의 뛰어난 효과와 상호 작용은 ARM 아키텍처 효율성의 가장 큰 원인 중 하나이기 때문에 이야기의 큰 부분입니다. 1983 년 당시 ARM ISA의 최초 디자이너 인 Steve Furber와 Roger (현재 Sophie) Wilson의 광채는 과장 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="20223b3b9842562860c0883dd004a561d3dec19d" translate="yes" xml:space="preserve">
          <source>If you run into trouble with lookups in managed languages -- the key is to add a &lt;code&gt;&amp;amp; 0x[something]FFF&lt;/code&gt; to your lookup function to make the boundary check predictable -- and watch it going faster.</source>
          <target state="translated">관리되는 언어로 조회 할 때 문제가 발생하는 경우 핵심은 경계 검사를 예측할 수 있도록 조회 기능에 &lt;code&gt;&amp;amp; 0x[something]FFF&lt;/code&gt; 를 추가하여 더 빠르게 진행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fcbae46e5b1ed263a398fd8853f1c323c42dd17c" translate="yes" xml:space="preserve">
          <source>If you want to write efficient code, you need to know a bit about machine architecture.</source>
          <target state="translated">효율적인 코드를 작성하려면 머신 아키텍처에 대해 약간 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="4906cf640b371d74701a3bb36c48ac95ee90c060" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;C&lt;/code&gt;, thus &lt;code&gt;C++&lt;/code&gt;, the statement, which would compile directly (without any optimization) into the conditional move instruction in &lt;code&gt;x86&lt;/code&gt;, is the ternary operator &lt;code&gt;... ? ... : ...&lt;/code&gt;. So we rewrite the above statement into an equivalent one:</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; , 따라서 &lt;code&gt;C++&lt;/code&gt; 에서 &lt;code&gt;x86&lt;/code&gt; 의 조건부 이동 명령으로 직접 (최적화없이) 컴파일되는 명령문은 삼항 연산자입니다 &lt;code&gt;... ? ... : ...&lt;/code&gt; ... : .... 따라서 위의 문장을 동등한 문장으로 다시 작성합니다.</target>
        </trans-unit>
        <trans-unit id="ab040f6c0d47f49db7c9db520be83759c461ffc9" translate="yes" xml:space="preserve">
          <source>In a branch case, the following instruction is determined by the preceding one, so we cannot do pipelining. We have to either wait or predict.</source>
          <target state="translated">분기의 경우 다음 명령이 이전 명령에 의해 결정되므로 파이프 라이닝을 수행 할 수 없습니다. 기다리거나 예측해야합니다.</target>
        </trans-unit>
        <trans-unit id="0025791b5e0267a182817044a5ed2c8007195575" translate="yes" xml:space="preserve">
          <source>In a conditional move case, the execution conditional move instruction is divided into several stages, but the earlier stages like &lt;code&gt;Fetch&lt;/code&gt; and &lt;code&gt;Decode&lt;/code&gt; does not depend on the result of the previous instruction; only latter stages need the result. Thus, we wait a fraction of one instruction's execution time. This is why the conditional move version is slower than the branch when prediction is easy.</source>
          <target state="translated">조건부 이동의 경우, 실행 조건부 이동 명령은 여러 단계로 나누어 지지만 &lt;code&gt;Fetch&lt;/code&gt; 및 &lt;code&gt;Decode&lt;/code&gt; 와 같은 초기 단계는 이전 명령의 결과에 의존하지 않습니다. 후자의 단계 만 결과가 필요합니다. 따라서 하나의 명령 실행 시간의 일부를 기다립니다. 이것이 예측이 쉬운 경우 조건부 이동 버전이 분기보다 느린 이유입니다.</target>
        </trans-unit>
        <trans-unit id="79ae345e2bd1b8124d296ba39b3ea113c5193f48" translate="yes" xml:space="preserve">
          <source>In a typical &lt;code&gt;x86&lt;/code&gt; processor, the execution of an instruction is divided into several stages. Roughly, we have different hardware to deal with different stages. So we do not have to wait for one instruction to finish to start a new one. This is called &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Pipeline_%28computing%29&quot;&gt;pipelining&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">일반적인 &lt;code&gt;x86&lt;/code&gt; 프로세서에서 명령 실행은 여러 단계로 나뉩니다. 대략, 우리는 다른 단계를 다루는 다른 하드웨어를 가지고 있습니다. 따라서 새로운 명령어를 시작하기 위해 하나의 명령어가 완료 될 때까지 기다릴 필요가 없습니다. 이것을 &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Pipeline_%28computing%29&quot;&gt;파이프 라이닝&lt;/a&gt;&lt;/strong&gt; 이라고합니다.</target>
        </trans-unit>
        <trans-unit id="0a827bd7aeac65573a68ed989955da0af9f32542" translate="yes" xml:space="preserve">
          <source>In addition to this, in complex prediction techniques the time taken to predict the branches is itself very high &amp;ndash;ranging from 2 to 5 cycles &amp;ndash;which is comparable to the execution time of actual branches.</source>
          <target state="translated">이 외에도 복잡한 예측 기술에서 분기를 예측하는 데 걸리는 시간은 2 ~ 5 사이클 범위에서 매우 높아 실제 분기의 실행 시간과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="0fa50c75a9a67268a4a229ac38ceeff7cb07714a" translate="yes" xml:space="preserve">
          <source>In all these cases the failure will be too less in number and as a result, only a few times it will need to discard the partially executed instructions and start over with the correct branch, resulting in fewer CPU cycles.</source>
          <target state="translated">이 모든 경우에 실패 횟수가 너무 적으므로 결과적으로 부분적으로 실행 된 명령어를 버리고 올바른 분기로 다시 시작하면 CPU주기가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="fa58046848c4821f342e1d54d795534223e063ff" translate="yes" xml:space="preserve">
          <source>In an unsorted array, the computer makes multiple predictions, leading to an increased chance of errors.
Whereas, in a sorted array, the computer makes fewer predictions, reducing the chance of errors.
Making more predictions requires more time.</source>
          <target state="translated">정렬되지 않은 배열에서 컴퓨터는 여러 번 예측하여 오류 가능성을 높입니다. 반면, 정렬 된 배열에서 컴퓨터는 예측 횟수를 줄여 오류 발생 가능성을 줄입니다. 더 많은 예측을하려면 더 많은 시간이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d548e9f8042a97cedfb594f9ea9edf3b28dedc70" translate="yes" xml:space="preserve">
          <source>In computer architecture, a branch predictor is a
  digital circuit that tries to guess which way a branch (e.g. an
  if-then-else structure) will go before this is known for sure. The
  purpose of the branch predictor is to improve the flow in the
  instruction pipeline. Branch predictors play a critical role in
  achieving high effective performance in many modern pipelined
  microprocessor architectures such as x86.</source>
          <target state="translated">컴퓨터 아키텍처에서 브랜치 예측기는 브랜치 (예를 들어 if-then-else 구조)가 어떤 방식으로 진행 될지 추측하는 디지털 회로입니다. 분기 예측기의 목적은 명령 파이프 라인의 흐름을 개선하는 것입니다. 지점 예측자는 x86과 같은 많은 최신 파이프 라인 마이크로 프로세서 아키텍처에서 높은 효과적인 성능을 달성하는 데 중요한 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="286bceae83a4fe4b1c8bf9719f0595eb063192a3" translate="yes" xml:space="preserve">
          <source>In order to effectively write your code to take advantage of these
  rules, when writing &lt;strong&gt;if-else&lt;/strong&gt; or &lt;strong&gt;switch&lt;/strong&gt; statements, check the most
  common cases first and work progressively down to the least common.
  Loops do not necessarily require any special ordering of code for
  static branch prediction, as only the condition of the loop iterator
  is normally used.</source>
          <target state="translated">&lt;strong&gt;if-else&lt;/strong&gt; 또는 &lt;strong&gt;switch&lt;/strong&gt; 문을 작성할 때 이러한 규칙을 활용하기 위해 코드를 효과적으로 작성하려면 가장 일반적인 경우를 먼저 확인하고 가장 일반적인 경우까지 점차 진행하십시오. 루프 반복자의 조건 만 일반적으로 사용되므로 루프는 정적 분기 예측을 위해 특별한 코드 순서를 필요로하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ecaad1e9fa8c85b19d9f8a2205db2cbf9519dd8c" translate="yes" xml:space="preserve">
          <source>In the C++ case, the hack is actually a tad slower than with the branch when the data is sorted.</source>
          <target state="translated">C ++의 경우, 데이터가 정렬 될 때 해킹은 실제로 분기보다 느립니다.</target>
        </trans-unit>
        <trans-unit id="27ce65e9b9e70aa80a48ce10e7dd18a40e62a14f" translate="yes" xml:space="preserve">
          <source>In the OP's code, the first time when the conditional, the branch predictor does not have any information to base up prediction, so the first time it will randomly choose the next instruction. Later in the for loop, it can base the prediction on the history. 
For an array sorted in ascending order, there are three possibilities:</source>
          <target state="translated">OP의 코드에서 조건부, 분기 예측기는 처음으로 예측을 기반으로 할 정보가 없으므로 처음으로 다음 명령을 임의로 선택합니다. 나중에 for 루프에서 히스토리를 기반으로 예측할 수 있습니다. 오름차순으로 정렬 된 배열의 경우 세 가지 가능성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfb2e6fc90f9bfd7c318bca3b56e7b9b3254c2b4" translate="yes" xml:space="preserve">
          <source>In the same line (I think this was not highlighted by any answer) it's good to mention that sometimes (specially in software where the performance matters&amp;mdash;like in the Linux kernel) you can find some if statements like the following:</source>
          <target state="translated">같은 줄에서 (이것은 대답으로 강조되지 않았다고 생각합니다) 때로는 (특히 Linux 커널과 같이 성능이 중요한 소프트웨어에서) 다음과 같은 if 문을 찾을 수 있다고 언급하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9d109a99d8c4326a6576d4732479edf2a6cedc39" translate="yes" xml:space="preserve">
          <source>In the sorted case, you can do better than relying on successful branch prediction or any branchless comparison trick: completely remove the branch.</source>
          <target state="translated">정렬 된 경우 성공적인 분기 예측 또는 분기없는 비교 트릭에 의존하는 것보다 분기를 완전히 제거하는 것보다 낫습니다.</target>
        </trans-unit>
        <trans-unit id="a4e4e6b119a5c6f74ced74230250afdbfb631f5a" translate="yes" xml:space="preserve">
          <source>In this case, it's obvious to the compiler that the boundary condition will never be hit. At least the Microsoft JIT compiler (but I expect Java does similar things) will notice this and remove the check altogether. WOW, that means no branch. Similarly, it will deal with other obvious cases.</source>
          <target state="translated">이 경우 경계 조건이 절대로 맞지 않는 것은 컴파일러에게 명백합니다. 적어도 Microsoft JIT 컴파일러 (하지만 Java가 비슷한 작업을 수행한다고 생각합니다)는이를 확인하고 검사를 모두 제거합니다. 와우, 그것은 지점이 없다는 것을 의미합니다. 마찬가지로 다른 명백한 경우를 처리합니다.</target>
        </trans-unit>
        <trans-unit id="fd70319a87ba55ceb8c46ef0dfb0b5cd4e2bf481" translate="yes" xml:space="preserve">
          <source>In this case, the lookup table was only 256 bytes, so it fits nicely in a cache and all was fast. This technique wouldn't work well if the data was 24-bit values and we only wanted half of them... the lookup table would be far too big to be practical. On the other hand, we can combine the two techniques shown above: first shift the bits over, then index a lookup table. For a 24-bit value that we only want the top half value, we could potentially shift the data right by 12 bits, and be left with a 12-bit value for a table index. A 12-bit table index implies a table of 4096 values, which might be practical.</source>
          <target state="translated">이 경우 조회 테이블은 256 바이트에 불과하므로 캐시에 잘 맞고 모두 빠릅니다. 데이터가 24 비트 값이고 절반 만 원할 경우이 기술은 제대로 작동하지 않습니다. 조회 테이블이 너무 커서 실용적이지 않습니다. 다른 한편으로, 우리는 위에 표시된 두 가지 기술을 결합 할 수 있습니다. 먼저 비트를 이동 한 다음 조회 테이블을 인덱싱합니다. 상위 절반 값만 원하는 24 비트 값의 경우 데이터를 12 비트만큼 오른쪽으로 이동하고 테이블 인덱스에 대해 12 비트 값을 남겨 둘 수 있습니다. 12 비트 테이블 인덱스는 4096 값의 테이블을 의미하며 이는 실용적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58ac7147fe158d09fb0dcd5d9a2419af351ceee2" translate="yes" xml:space="preserve">
          <source>In this case: &amp;gt;= 128 means we can keep the value, &amp;lt; 128 means we get rid of it. The easiest way to do that is by using an 'AND': if we keep it, we AND it with 7FFFFFFF; if we want to get rid of it, we AND it with 0. Notice also that 128 is a power of 2 -- so we can go ahead and make a table of 32768/128 integers and fill it with one zero and a lot of 7FFFFFFFF's.</source>
          <target state="translated">이 경우 :&amp;gt; = 128은 값을 유지할 수 있음을 의미하고 &amp;lt;128은 값을 제거함을 의미합니다. 가장 쉬운 방법은 'AND'를 사용하는 것입니다. 유지하면 7FFFFFFF로 AND합니다. 128을 2의 거듭 제곱으로하여 32768/128 정수의 테이블을 만들어 0과 1로 채울 수 있습니다. 7FFFFFFFF.</target>
        </trans-unit>
        <trans-unit id="05909b2541b3e02aeda1080cefdfed9bf8d3fb41" translate="yes" xml:space="preserve">
          <source>Indeed, the array is partitioned in a contiguous zone with &lt;code&gt;data &amp;lt; 128&lt;/code&gt; and another with &lt;code&gt;data &amp;gt;= 128&lt;/code&gt;. So you should find the partition point with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Dichotomic_search&quot;&gt;dichotomic search&lt;/a&gt; (using &lt;code&gt;Lg(arraySize) = 15&lt;/code&gt; comparisons), then do a straight accumulation from that point.</source>
          <target state="translated">실제로, 배열은 &lt;code&gt;data &amp;lt; 128&lt;/code&gt; 연속 영역과 &lt;code&gt;data &amp;gt;= 128&lt;/code&gt; 연속 영역으로 분할됩니다. 따라서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Dichotomic_search&quot;&gt;이분법 검색&lt;/a&gt; ( &lt;code&gt;Lg(arraySize) = 15&lt;/code&gt; 비교 사용)을 사용하여 분할 지점을 찾은 다음 해당 지점에서 직선 누적을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="511459d1219dae84b5739744e2330bbd39562f3c" translate="yes" xml:space="preserve">
          <source>Initially, I thought this might be just a language or compiler anomaly, so I tried Java:</source>
          <target state="translated">처음에는 이것이 언어 또는 컴파일러 이상일 수 있다고 생각했기 때문에 Java를 사용해 보았습니다.</target>
        </trans-unit>
        <trans-unit id="b7ea0a495929d20edeb96560f38ad10f605c64c3" translate="yes" xml:space="preserve">
          <source>Intel - Avoiding the Cost of Branch Misprediction</source>
          <target state="translated">인텔-지점 오해 방지</target>
        </trans-unit>
        <trans-unit id="77db291a450702d5439477d5645b64a6a25dcb27" translate="yes" xml:space="preserve">
          <source>Intel - Branch and Loop Reorganization to Prevent Mispredicts</source>
          <target state="translated">인텔-잘못된 예측을 방지하기위한 분기 및 루프 재구성</target>
        </trans-unit>
        <trans-unit id="59f94bde7099ca1379cdd1147d7f4529386efe43" translate="yes" xml:space="preserve">
          <source>Is there a better way? You guess which direction the branch will go!</source>
          <target state="translated">더 좋은 방법이 있습니까? 당신은 지점이 어느 방향으로 갈지 추측합니다!</target>
        </trans-unit>
        <trans-unit id="9ce53cf70b1162457580560ead6c5cf7c26bf416" translate="yes" xml:space="preserve">
          <source>Is there a better way? You guess which direction the train will go!</source>
          <target state="translated">더 좋은 방법이 있습니까? 당신은 기차가 어느 방향으로 갈지 추측합니다!</target>
        </trans-unit>
        <trans-unit id="2b7c4e9ff8bccc2bf1d5615ac7198435e8f85617" translate="yes" xml:space="preserve">
          <source>It can also do source code annotation with dissassembly.</source>
          <target state="translated">또한 디스 어셈블리로 소스 코드 주석을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d889c96e7c80c6d5564b275e9ce3e1dcf34879de" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t make fewer predictions - it makes fewer incorrect predictions. It still has to predict for each time through the loop...</source>
          <target state="translated">예측이 적지 않습니다. 틀린 예측이 줄어 듭니다. 여전히 루프를 통해 매번 예측해야합니다 ...</target>
        </trans-unit>
        <trans-unit id="08fc45b9de518283718984bcfb1e9ac8e6ae1278" translate="yes" xml:space="preserve">
          <source>It is important to understand that branch misprediction doesn't slow down programs. The cost of a missed prediction is just as if branch prediction didn't exist and you waited for the evaluation of the expression to decide what code to run (further explanation in the next paragraph).</source>
          <target state="translated">분기 오해가 프로그램 속도를 늦추지 않는다는 것을 이해하는 것이 중요합니다. 누락 된 예측 비용은 분기 예측이 존재하지 않는 것과 같으며 실행할 코드를 결정하기 위해 표현식 평가를 기다렸습니다 (다음 단락에서 자세히 설명).</target>
        </trans-unit>
        <trans-unit id="6fc4b764667806eaf36f9b084c8cc41649bfd6ed" translate="yes" xml:space="preserve">
          <source>It will take 7 clock cycles for 3 instructions to be completed.</source>
          <target state="translated">3 개의 명령이 완료 되려면 7 클럭주기가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="7e692acc3118ecaa2f6cab194a17621924826a7b" translate="yes" xml:space="preserve">
          <source>It will take 9 clock cycles for 3 instructions to be completed.</source>
          <target state="translated">3 개의 명령이 완료 되려면 9 클럭주기가 걸립니다.</target>
        </trans-unit>
        <trans-unit id="76778e3295cf8f4fb34c2e009919d81130807662" translate="yes" xml:space="preserve">
          <source>It's about branch prediction. What is it?</source>
          <target state="translated">분기 예측에 관한 것입니다. 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5ce025460eef942a5746a29f6fff2639b7a4f0ea" translate="yes" xml:space="preserve">
          <source>It's quite a simple demo that clarifies the very basic part of Branch Predictor. If those gifs are annoying, please feel free to remove them from the answer and visitors can also get the live demo source code from &lt;a href=&quot;https://github.com/Eugene-Mark/BranchPredictorDemo&quot;&gt;BranchPredictorDemo&lt;/a&gt;</source>
          <target state="translated">Branch Predictor의 매우 기본적인 부분을 설명하는 매우 간단한 데모입니다. 해당 GIF가 성가신 경우 답변에서 자유롭게 제거하고 방문자는 &lt;a href=&quot;https://github.com/Eugene-Mark/BranchPredictorDemo&quot;&gt;BranchPredictorDemo&lt;/a&gt; 에서 라이브 데모 소스 코드를 얻을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1800ac2cc348d512d31d6a4d1e9d7c3834e153d" translate="yes" xml:space="preserve">
          <source>Java - NetBeans 7.1.1 JDK 7 - x64</source>
          <target state="translated">Java-NetBeans 7.1.1 JDK 7-x64</target>
        </trans-unit>
        <trans-unit id="f3f0214447bd9b96e0f2a7febf49ceace8c3c918" translate="yes" xml:space="preserve">
          <source>Let us assume that the predictor will always assume the true branch on the first run.</source>
          <target state="translated">예측자가 항상 첫 번째 실행에서 실제 분기를 가정한다고 가정합시다.</target>
        </trans-unit>
        <trans-unit id="0626fcdc6685d5777030cccc407cda27d5a5dbe6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s measure the performance of this loop with different conditions:</source>
          <target state="translated">다른 조건에서이 루프의 성능을 측정 해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="78c58416698b00e2911ee8edf6ff28c7aa28b3f5" translate="yes" xml:space="preserve">
          <source>Let's say you need to pick route 1 or route 2. Waiting for your partner to check the map, you have stopped at ## and waited, or you could just pick route1 and if you were lucky (route 1 is the correct route), then great you didn't have to wait for your partner to check the map (you saved the time it would have taken him to check the map), otherwise you will just turn back.</source>
          <target state="translated">경로 1 또는 경로 2를 선택해야한다고합시다. 파트너가지도를 확인하기를 기다리거나 ##에서 멈추고 기다렸거나 route1을 선택하고 운이 좋으면 (1 번 경로가 올바른 경로), 파트너가지도를 확인할 때까지 기다릴 필요가 없습니다 (지도를 확인하는 데 걸리는 시간을 절약했습니다). 그렇지 않으면 다시 돌아옵니다.</target>
        </trans-unit>
        <trans-unit id="2722634189f24bf6fb4d65af5b80948093b029bf" translate="yes" xml:space="preserve">
          <source>Like branch prediction, this was optimized in the Pentium processors: the processor predicts that it needs to load a piece of data and attempts to load that into the cache before the operation actually hits the cache. As we've already seen, branch prediction sometimes goes horribly wrong -- in the worst case scenario you need to go back and actually wait for a memory load, which will take forever (&lt;strong&gt;in other words: failing branch prediction is bad, a memory load after a branch prediction fail is just horrible!&lt;/strong&gt;).</source>
          <target state="translated">브랜치 예측과 마찬가지로 Pentium 프로세서에서 최적화되었습니다. 프로세서는 데이터 조각을로드해야한다고 예측하고 작업이 실제로 캐시에 도달하기 전에이를 캐시에로드하려고 시도합니다. 우리가 이미 보았 듯이, 분기 예측은 때때로 끔찍하게 잘못됩니다. 최악의 시나리오에서는 되돌아 가서 실제로 메모리로드를 기다려야합니다. 이는 영원히 걸릴 것입니다 ( &lt;strong&gt;즉, 분기 예측 실패가 잘못되었습니다, 메모리 분기 예측 실패 후로드는 끔찍합니다!&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="7511e6163f79984c1b9da8abd1a9c44be298fc50" translate="yes" xml:space="preserve">
          <source>Look at the image I created for you below. Which street is going to be finished faster?</source>
          <target state="translated">내가 당신을 위해 만든 이미지를 아래에서보십시오. 어느 거리가 더 빨리 끝날 것입니까?</target>
        </trans-unit>
        <trans-unit id="87b5594f2643cba7d46d5fb490ed0d38e2cf1230" translate="yes" xml:space="preserve">
          <source>Making a wrong prediction leads to going back to the previous step, and executing with another prediction. Assuming the prediction is correct, the code will continue to the next step. A wrong prediction results in repeating the same step, until a correct prediction occurs.</source>
          <target state="translated">잘못된 예측을하면 이전 단계로 돌아가 다른 예측으로 실행됩니다. 예측이 정확하다고 가정하면 코드는 다음 단계로 계속 진행됩니다. 잘못된 예측은 올바른 예측이 발생할 때까지 동일한 단계를 반복합니다.</target>
        </trans-unit>
        <trans-unit id="a1ebbba208d4225ea0cbac50fe08bb6ace4451a3" translate="yes" xml:space="preserve">
          <source>Most applications have well-behaved branches. So modern branch predictors will typically achieve &amp;gt;90% hit rates. But when faced with unpredictable branches with no recognizable patterns, branch predictors are virtually useless.</source>
          <target state="translated">대부분의 응용 프로그램에는 올바르게 동작하는 분기가 있습니다. 따라서 최신 지점 예측자는 일반적으로 90 % 이상의 적중률을 달성합니다. 그러나 인식 할 수있는 패턴이없는 예측할 수없는 분기에 직면 할 때 분기 예측기는 사실상 쓸모가 없습니다.</target>
        </trans-unit>
        <trans-unit id="edc45563f2af123495a6f4d5820e01d67e592ac5" translate="yes" xml:space="preserve">
          <source>Most processor architectures do not have this ability to specify whether or not the status bits should be updated for a given operation, which can necessitate writing additional code to save and later restore status bits, or may require additional branches, or may limit the processor's out of order execution efficiency: one of the side effects of most CPU instruction set architectures forcibly updating status bits after most instructions is that it is much harder to tease apart which instructions can be run in parallel without interfering with each other. Updating status bits has side effects, therefore has a linearizing effect on code. &lt;strong&gt;ARM's ability to mix and match branch-free condition testing on any instruction with the option to either update or not update the status bits after any instruction is extremely powerful, for both assembly language programmers and compilers, and produces very efficient code.&lt;/strong&gt;</source>
          <target state="translated">대부분의 프로세서 아키텍처에는 주어진 작업에 대해 상태 비트를 업데이트해야하는지 여부를 지정하는이 기능이 없으므로 상태 비트를 저장 한 후 나중에 복원하기 위해 추가 코드를 작성해야하거나 추가 분기가 필요하거나 프로세서가 제한 될 수 있습니다 대부분의 명령 후에 상태 비트를 강제로 업데이트하는 대부분의 CPU 명령 세트 아키텍처의 부작용 중 하나는 명령을 서로 방해하지 않고 병렬로 실행할 수 있다는 점을 구분하기가 훨씬 어렵다는 것입니다. 상태 비트를 업데이트하면 부작용이 있으므로 코드에 선형화 효과가 있습니다. &lt;strong&gt;ARM은 모든 명령어에서 분기없는 조건 테스트를 조합하고 조합하여 명령어가 완료된 후 상태 비트를 업데이트하거나 업데이트하지 않는 옵션을 사용하여 어셈블리 언어 프로그래머와 컴파일러 모두에게 매우 강력하며 매우 효율적인 코드를 생성 할 수 있습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6714e326ddf3827a45bf7845db0659793dffdc78" translate="yes" xml:space="preserve">
          <source>Moving back to the above question let's consider the following instructions:</source>
          <target state="translated">위의 질문으로 돌아가서 다음 지침을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8f2f5f3a519901e55e81a2564329640471c74d81" translate="yes" xml:space="preserve">
          <source>My first thought was that sorting brings the data into the cache, but then I thought how silly that was because the array was just generated.</source>
          <target state="translated">첫 번째 생각은 정렬이 데이터를 캐시로 가져 오는 것이라고 생각했지만 배열이 방금 생성 되었기 때문에 얼마나 바보 같은지 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="5b798bfc3b15b4fc93876532bf774c937ef4d1cc" translate="yes" xml:space="preserve">
          <source>No doubt some of us would be interested in ways of identifying code that is problematic for the CPU's branch-predictor. The Valgrind tool &lt;code&gt;cachegrind&lt;/code&gt; has a branch-predictor simulator, enabled by using the &lt;code&gt;--branch-sim=yes&lt;/code&gt; flag. Running it over the examples in this question, with the number of outer loops reduced to 10000 and compiled with &lt;code&gt;g++&lt;/code&gt;, gives these results:</source>
          <target state="translated">의심 할 여지없이 우리 중 일부는 CPU의 분기 예측기에 문제가되는 코드를 식별하는 방법에 관심이있을 것입니다. Valgrind 도구 &lt;code&gt;cachegrind&lt;/code&gt; 에는 &lt;code&gt;--branch-sim=yes&lt;/code&gt; 플래그를 사용하여 활성화되는 분기 예측기 시뮬레이터가 있습니다. 외부 루프 수를 10000으로 줄이고 &lt;code&gt;g++&lt;/code&gt; 컴파일 한이 질문의 예제를 통해 실행하면 다음과 같은 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="7fe6472f78792531c23c2701179111bf8fe3d611" translate="yes" xml:space="preserve">
          <source>Normally this kind of optimizations are mainly found in hard-real time applications or embedded systems where execution time matters and it's critical. For example, if you are checking for some error condition that only happens 1/10000000 times, then why not inform the compiler about this? This way, by default, the branch prediction would assume that the condition is false.</source>
          <target state="translated">일반적으로 이러한 종류의 최적화는 주로 실행 시간이 중요하고 중요한 실시간 응용 프로그램 또는 임베디드 시스템에서 발견됩니다. 예를 들어 1/10000000 번만 발생하는 오류 조건을 확인하는 경우 컴파일러에 알리지 않는 이유는 무엇입니까? 이런 식으로 기본적으로 분기 예측은 조건이 거짓이라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2687a67b9058fe9e6fd551f4fb695501d7a3f7de" translate="yes" xml:space="preserve">
          <source>Notice that the data is evenly distributed between 0 and 255. When the data is sorted, roughly the first half of the iterations will not enter the if-statement. After that, they will all enter the if-statement.</source>
          <target state="translated">데이터는 0과 255 사이에 균등하게 분배됩니다. 데이터가 정렬 될 때 대략 절반의 반복이 if 문에 들어 가지 않습니다. 그 후, 그들은 모두 if 문으로 들어갑니다.</target>
        </trans-unit>
        <trans-unit id="8e169f52da1ac65f0d59b6b1c4ec6bd5bf878be5" translate="yes" xml:space="preserve">
          <source>Now for the sake of argument, suppose this is back in the 1800s - before long distance or radio communication.</source>
          <target state="translated">이제 논란을 위해, 이것이 장거리 또는 무선 통신 이전에 1800 년대에 다시 시작되었다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="30312bef68cebc5f38e57e727b2135cfb377fc89" translate="yes" xml:space="preserve">
          <source>Now let's look more closely by investigating the &lt;code&gt;x86&lt;/code&gt; assembly they generate. For simplicity, we use two functions &lt;code&gt;max1&lt;/code&gt; and &lt;code&gt;max2&lt;/code&gt;.</source>
          <target state="translated">이제 생성 한 &lt;code&gt;x86&lt;/code&gt; 어셈블리를 조사하여보다 자세히 살펴 보겠습니다. 편의상 &lt;code&gt;max1&lt;/code&gt; 과 &lt;code&gt;max2&lt;/code&gt; 의 두 함수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c330fcd6ba152c362d1fcd57661782df403680f7" translate="yes" xml:space="preserve">
          <source>Now, if we look at the code</source>
          <target state="translated">이제 코드를 보면</target>
        </trans-unit>
        <trans-unit id="580a776c6b642fccec58ff95f40d16a839dd873b" translate="yes" xml:space="preserve">
          <source>Observations:</source>
          <target state="translated">Observations:</target>
        </trans-unit>
        <trans-unit id="c497da8cabdb633d3a209eb10a05a6e8a8479a34" translate="yes" xml:space="preserve">
          <source>On ARM, there is no branch needed, because every instruction has a 4-bit condition field, which tests (at zero cost) any of &lt;a href=&quot;https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/condition-codes-1-condition-flags-and-codes&quot;&gt;16 different different conditions&lt;/a&gt; that may arise in the Processor Status Register, and if the condition on an instruction is false, the instruction is skipped. This eliminates the need for short branches, and there would be no branch prediction hit for this algorithm. &lt;b&gt;Therefore, the sorted version of this algorithm would run slower than the unsorted version on ARM, because of the extra overhead of sorting.&lt;/b&gt;</source>
          <target state="translated">ARM에서는 분기마다 필요하지 않습니다. 모든 명령어에는 프로세서 상태 레지스터에서 발생할 수있는 &lt;a href=&quot;https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/condition-codes-1-condition-flags-and-codes&quot;&gt;16 가지의 다른 조건&lt;/a&gt; 중 하나를 테스트하는 4 비트 조건 필드가 있으며 명령어의 조건이 false이면 명령을 건너 뜁니다. 따라서 짧은 분기가 필요하지 않으며이 알고리즘에는 분기 예측이 발생하지 않습니다. &lt;b&gt;따라서 정렬의 추가 오버 헤드로 인해이 알고리즘의 정렬 된 버전이 ARM의 정렬되지 않은 버전보다 느리게 실행됩니다.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97e13959d4711e37195fe7ecfc6a86c5fe97b99f" translate="yes" xml:space="preserve">
          <source>On a x86-64 machine, &lt;code&gt;GCC -S&lt;/code&gt; generates the assembly below.</source>
          <target state="translated">x86-64 시스템에서 &lt;code&gt;GCC -S&lt;/code&gt; 는 아래 어셈블리를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="af5b27c4a00930aafb30d96f562d6210ddf9267b" translate="yes" xml:space="preserve">
          <source>On an Intel &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core i7&lt;/a&gt;-2600K @ 3.4&amp;nbsp;GHz and Visual Studio 2010 Release Mode, the benchmark is (format copied from Mysticial):</source>
          <target state="translated">Intel &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core i7&lt;/a&gt; -2600K @ 3.4GHz 및 Visual Studio 2010 릴리스 모드에서 벤치 마크는 다음과 같습니다 (Mysticial에서 복사 한 형식).</target>
        </trans-unit>
        <trans-unit id="c46e9d0de821ff22c14c3a97f36bb4c970b4b164" translate="yes" xml:space="preserve">
          <source>On the other hand, complex branch predictions &amp;ndash;either neural based or variants of two-level branch prediction &amp;ndash;provide better prediction accuracy, but they consume more power and complexity increases exponentially.</source>
          <target state="translated">반면에 신경 기반 또는 2 단계 분기 예측의 변형 인 복잡한 분기 예측은 더 나은 예측 정확도를 제공하지만 더 많은 전력을 소비하고 기하 급수적으로 기하 급수적으로 증가합니다.</target>
        </trans-unit>
        <trans-unit id="a5e809f1e268fe28804313bc9194b78b811d96b5" translate="yes" xml:space="preserve">
          <source>On the other hand, once it's sorted, the predictor will first move into a state of strongly not taken and when the values change to the high value the predictor will in three runs through change all the way from strongly not taken to strongly taken.</source>
          <target state="translated">반면에 일단 정렬되면 예측자는 먼저 강력하게 취하지 않은 상태로 이동하고 값이 높은 값으로 변경되면 예측자는 세 번의 실행으로 강하게 취하지 않은 것에서 강하게 취한 것으로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="3bbefccbf2bee10e9954cc81b62c16f44204ba33" translate="yes" xml:space="preserve">
          <source>One reason is branch prediction: the key operation in the sort algorithm is &lt;code&gt;&amp;ldquo;if(v[i] &amp;lt; pivot]) &amp;hellip;&amp;rdquo;&lt;/code&gt; or equivalent. For a sorted sequence that test is always true whereas, for a random sequence, the branch chosen varies randomly.</source>
          <target state="translated">한 가지 이유는 분기 예측입니다. 정렬 알고리즘의 주요 작업은 &lt;code&gt;&amp;ldquo;if(v[i] &amp;lt; pivot]) &amp;hellip;&amp;rdquo;&lt;/code&gt; 또는 이와 동등한 것입니다. 정렬 된 시퀀스의 테스트는 항상 참인 반면, 랜덤 시퀀스의 경우 선택한 분기는 임의로 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="6f83347c5969b82a1f9ad38db3d4941619744366" translate="yes" xml:space="preserve">
          <source>One way to avoid branch prediction errors is to build a lookup table, and index it using the data. Stefan de Bruijn discussed that in his answer.</source>
          <target state="translated">분기 예측 오류를 피하는 한 가지 방법은 조회 테이블을 작성하고 데이터를 사용하여 색인화하는 것입니다. Stefan de Bruijn은 그의 답변에서 이에 대해 논의했습니다.</target>
        </trans-unit>
        <trans-unit id="dba85fca15da0466e912cf6f28584da718edda4e" translate="yes" xml:space="preserve">
          <source>Quicksort (and sorting in general) is a complex study that has attracted some of the greatest minds of computer science. A good sort function is a result of both choosing a good algorithm and paying attention to hardware performance in its implementation.</source>
          <target state="translated">Quicksort (및 일반적으로 정렬)는 컴퓨터 과학의 가장 위대한 마음을 끄는 복잡한 연구입니다. 좋은 정렬 기능은 좋은 알고리즘을 선택하고 구현시 하드웨어 성능에주의를 기울인 결과입니다.</target>
        </trans-unit>
        <trans-unit id="7eee27983091e8186d6b5fbbd3abab850ed0e885" translate="yes" xml:space="preserve">
          <source>Recently this example (modified very slightly) was also used as a way to demonstrate how a piece of code can be profiled within the program itself on Windows. Along the way, the author also shows how to use the results to determine where the code is spending most of its time in both the sorted &amp;amp; unsorted case. Finally the piece also shows how to use a little known feature of the HAL (Hardware Abstraction Layer) to determine just how much branch misprediction is happening in the unsorted case.</source>
          <target state="translated">최근에이 예제 (매우 약간 수정 됨)도 Windows에서 프로그램 자체 내에서 코드 조각을 프로파일 링하는 방법을 보여주는 방법으로 사용되었습니다. 그 과정에서 저자는 결과를 사용하여 코드가 정렬 및 정렬되지 않은 경우에 가장 많은 시간을 소비하는 위치를 결정하는 방법도 보여줍니다. 마지막으로이 기사에서는 HAL (Hardware Abstraction Layer)의 일부 알려진 기능을 사용하여 분류되지 않은 사례에서 발생하는 분기 오해의 정도를 결정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="2e26f7f81e11c144071f07013d00802556dd33b0" translate="yes" xml:space="preserve">
          <source>Replace:</source>
          <target state="translated">Replace:</target>
        </trans-unit>
        <trans-unit id="5b332ccd041103419a2ad666b47b236d919bc4c8" translate="yes" xml:space="preserve">
          <source>Scientific papers - branch prediction computer architecture</source>
          <target state="translated">과학 논문-지점 예측 컴퓨터 아키텍처</target>
        </trans-unit>
        <trans-unit id="b01f405d3c10919c3c94fd65f54c0af170284f84" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://perf.wiki.kernel.org/index.php/Tutorial&quot;&gt;the performance tutorial&lt;/a&gt; for more details.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;https://perf.wiki.kernel.org/index.php/Tutorial&quot;&gt;은 성능 자습서&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3a298d21d0b3c80ce2982ea32ba8a81f978c30f0" translate="yes" xml:space="preserve">
          <source>So how would you strategically guess to minimize the number of times that the train must back up and go down the other path? You look at the past history! If the train goes left 99% of the time, then you guess left. If it alternates, then you alternate your guesses. If it goes one way every three times, you guess the same...</source>
          <target state="translated">그렇다면 열차가 백업하고 다른 경로로 내려가는 횟수를 최소화하기 위해 어떻게 전략적으로 추측 할 것입니까? 당신은 과거의 역사를 봅니다! 기차가 시간의 99 %를 왼쪽으로 가면 왼쪽으로 추측됩니다. 그것이 번갈아 가면 추측을 번갈아 가며 바꿉니다. 세 번마다 한 가지 방법으로 진행된다면 같은 생각입니다.</target>
        </trans-unit>
        <trans-unit id="9ebfa04f718206d91431f0015c26f1b42906f312" translate="yes" xml:space="preserve">
          <source>So in the first case, it will always take the true branch since historically all its predictions are correct.
In the 2nd case, initially it will predict wrong, but after a few iterations, it will predict correctly.
In the 3rd case, it will initially predict correctly till the elements are less than 128. After which it will fail for some time and the correct itself when it sees branch prediction failure in history.</source>
          <target state="translated">따라서 첫 번째 경우 역사적으로 모든 예측이 정확하기 때문에 항상 진정한 분기를 취합니다. 두 번째 경우 처음에는 잘못 예측하지만 몇 번의 반복 후에 올바르게 예측합니다. 세 번째 경우에는 요소가 128보다 작을 때까지 처음에 정확하게 예측합니다. 그 후 일정 시간 동안 실패하고 히스토리에서 분기 예측 실패를 볼 때 자체가 올바른 것입니다.</target>
        </trans-unit>
        <trans-unit id="351943fae2a5bec40c06462d38700c5db13e382c" translate="yes" xml:space="preserve">
          <source>So programmatically, &lt;strong&gt;branch prediction&lt;/strong&gt; causes the process to be slower...</source>
          <target state="translated">프로그래밍 방식으로 &lt;strong&gt;분기 예측으로&lt;/strong&gt; 인해 프로세스가 느려집니다 ...</target>
        </trans-unit>
        <trans-unit id="5ccec79adc1d899a1de0448aec6cd2999ea646b6" translate="yes" xml:space="preserve">
          <source>So there is no doubt about the impact of branch prediction on performance!</source>
          <target state="translated">따라서 분기 예측이 성능에 미치는 영향에 대해서는 의심의 여지가 없습니다!</target>
        </trans-unit>
        <trans-unit id="3ae2891b971dd8487010889269aa73c34566377f" translate="yes" xml:space="preserve">
          <source>So we've figured out that we can create a small table. Next thing to do is get a lookup function in place. Lookup functions are usually small functions that use a couple of basic integer operations (and, or, xor, shift, add, remove and perhaps multiply). You want to have your input translated by the lookup function to some kind of 'unique key' in your table, which then simply gives you the answer of all the work you wanted it to do.</source>
          <target state="translated">우리는 작은 테이블을 만들 수 있다는 것을 알아 냈습니다. 다음으로해야 할 일은 찾아보기 기능을 사용하는 것입니다. 조회 함수는 일반적으로 몇 가지 기본 정수 연산 (또는 xor, shift, 더하기, 제거 및 곱하기)을 사용하는 작은 함수입니다. 조회 기능에 의해 입력 내용을 테이블의 일종의 '고유 키'로 변환하여 원하는 모든 작업에 대한 답변을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e2fc4b8592d275115019311dc1f64056ef857314" translate="yes" xml:space="preserve">
          <source>So why does a conditional move perform better?</source>
          <target state="translated">그렇다면 조건부 이동이 더 나은 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="8862694fc5020ea843e75148ff60c38a99455cbf" translate="yes" xml:space="preserve">
          <source>So, I tried with a vector of a million integers and got:</source>
          <target state="translated">그래서 나는 백만 개의 정수로 구성된 벡터로 시도하고 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="26f99fe80efafd6fc68424aeeb2c6cf0ad1eb0fd" translate="yes" xml:space="preserve">
          <source>Some starting new elements are less than 128 and later it become greater than 128</source>
          <target state="translated">일부 새로운 시작 요소는 128보다 작으며 나중에 128보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="0e167763d050d2cb6ded113f3e9064040103e166" translate="yes" xml:space="preserve">
          <source>Something like (unchecked)</source>
          <target state="translated">같은 (체크되지 않은)</target>
        </trans-unit>
        <trans-unit id="a88df12411d4a67fd1c80b6258959d001907e55b" translate="yes" xml:space="preserve">
          <source>Sometimes, some modern compilers can optimize our code to assembly with better performance, sometimes some compilers can't (the code in question is using Visual Studio's native compiler). Knowing the performance difference between branch and conditional move when unpredictable can help us write code with better performance when the scenario gets so complex that the compiler can not optimize them automatically.</source>
          <target state="translated">때로는 일부 최신 컴파일러가 더 나은 성능으로 어셈블리에 맞게 코드를 최적화 할 수 있고 때로는 일부 컴파일러에서는 그렇지 않을 수도 있습니다 (문제의 코드는 Visual Studio의 기본 컴파일러를 사용하고 있음). 예측할 수 없을 때 분기 및 조건부 이동 간의 성능 차이를 알면 시나리오가 너무 복잡해 컴파일러가 자동으로 최적화 할 수 없을 때 더 나은 성능으로 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96ecd96ca3304ca88eb06e8a00937b5c4b49d3ed" translate="yes" xml:space="preserve">
          <source>Sorted Array: Straight Road
    ____________________________________________________________________________________
    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT</source>
          <target state="translated">정렬 된 배열 : 직선 도로 ____________________________________________________________________________________----------------------------------------------------------------TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT</target>
        </trans-unit>
        <trans-unit id="417b7a8c229714395078ea87b358994e172876b0" translate="yes" xml:space="preserve">
          <source>Sorted arrays are processed faster than an unsorted array, due to a phenomena called branch prediction.</source>
          <target state="translated">정렬 된 배열은 분기 예측이라는 현상으로 인해 정렬되지 않은 배열보다 빠르게 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="12a86072c1d6226f21fdf1c483e322e5674a52e2" translate="yes" xml:space="preserve">
          <source>Sorting only k-element sections completes the pre-processing in linear time, &lt;code&gt;O(n)&lt;/code&gt;, rather than the &lt;code&gt;O(n.log(n))&lt;/code&gt; time needed to sort the entire array.</source>
          <target state="translated">k- 요소 섹션 만 정렬하면 전체 배열을 정렬하는 데 필요한 &lt;code&gt;O(n.log(n))&lt;/code&gt; 시간이 아닌 선형 시간 &lt;code&gt;O(n)&lt;/code&gt; 사전 처리가 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="911567da4c21b2d8b0b479e0b036b07488a7f699" translate="yes" xml:space="preserve">
          <source>Starting with the original loop:</source>
          <target state="translated">원래 루프로 시작 :</target>
        </trans-unit>
        <trans-unit id="b289c5eb6b8d96218afa396493007fb0c5566528" translate="yes" xml:space="preserve">
          <source>Static branch prediction is used by the microprocessor the first time
  a conditional branch is encountered, and dynamic branch prediction is
  used for succeeding executions of the conditional branch code.</source>
          <target state="translated">정적 분기 예측은 조건부 분기가 처음 발생할 때 마이크로 프로세서에 의해 사용되며 동적 분기 예측은 조건부 분기 코드의 후속 실행에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0f6ae2e9812cde1bb50890188a75301caf057eb4" translate="yes" xml:space="preserve">
          <source>That being said, the compiler tries to predict the outcome prior to it being actually evaluated. It will fetch instructions from the &lt;code&gt;if&lt;/code&gt; block, and if the expression turns out to be true, then wonderful! We gained the time it took to evaluate it and made progress in the code; if not then we are running the wrong code, the pipeline is flushed, and the correct block is run.</source>
          <target state="translated">즉, 컴파일러는 실제로 평가되기 전에 결과를 예측하려고합니다. &lt;code&gt;if&lt;/code&gt; 블록에서 명령어를 가져오고 표현식이 참이면 훌륭합니다! 우리는 그것을 평가하고 코드에서 진보하는 데 걸리는 시간을 얻었습니다. 그렇지 않으면 잘못된 코드를 실행하고 파이프 라인이 플러시되고 올바른 블록이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="35261a879de9858385098dadcc5581d89b2d609f" translate="yes" xml:space="preserve">
          <source>That one is 100,000 times faster than before.</source>
          <target state="translated">그것은 이전보다 100,000 배 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="08f10e7e1256e6e98ddd64a702e8dc6f1d8014d5" translate="yes" xml:space="preserve">
          <source>That sounds like an interview question. Is it true? How would you know? It is a bad idea to answer questions about efficiency without first doing some measurements, so it is important to know how to measure.</source>
          <target state="translated">인터뷰 질문처럼 들립니다. 사실인가요? 당신은 어떻게 알겠습니까? 먼저 일부 측정을 수행하지 않고 효율성에 대한 질문에 대답하는 것은 좋지 않으므로 측정 방법을 아는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="508b04c27cc3f2089b5ea384a8ad1dd729afae1a" translate="yes" xml:space="preserve">
          <source>That's for sure!...</source>
          <target state="translated">그건 확실합니다!...</target>
        </trans-unit>
        <trans-unit id="0cde2413f2853914209f8169d7f3210951656de9" translate="yes" xml:space="preserve">
          <source>The above behavior is happening because of Branch prediction.</source>
          <target state="translated">위의 동작은 분기 예측으로 인해 발생합니다.</target>
        </trans-unit>
        <trans-unit id="76fff62130dd99e863f74fb23823d0e6b58d4f70" translate="yes" xml:space="preserve">
          <source>The answer to your question is very simple.</source>
          <target state="translated">귀하의 질문에 대한 답변은 매우 간단합니다.</target>
        </trans-unit>
        <trans-unit id="429f9a89629f65eb36edfe9122d197b4a3ab1462" translate="yes" xml:space="preserve">
          <source>The assumption by other answers that one needs to sort the data is not correct.</source>
          <target state="translated">다른 답변에 따르면 데이터를 정렬해야한다고 가정하는 것은 올바르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="14fca0f59106880a0be992b705d52d3aeb245c06" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0136108040&quot;&gt;Computer Systems: A Programmer's Perspective, second edition&lt;/a&gt;&lt;/em&gt; explains this in detail. You can check Section 3.6.6 for &lt;em&gt;Conditional Move Instructions&lt;/em&gt;, entire Chapter 4 for &lt;em&gt;Processor Architecture&lt;/em&gt;, and Section 5.11.2 for a special treatment for &lt;em&gt;Branch Prediction and Misprediction Penalties&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0136108040&quot;&gt;Computer Systems : A Programmer 's Perspective, second edition 책에서 이에&lt;/a&gt;&lt;/em&gt; 대해 자세히 설명합니다. &lt;em&gt;조건부 이동 명령어에&lt;/em&gt; 대해서는 3.6.6 절, &lt;em&gt;프로세서 아키텍처에&lt;/em&gt; 대해서는 4 장, &lt;em&gt;분기 예측 및 오해에&lt;/em&gt; 대한 특별 처리에 대해서는 5.11.2 절을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="01c31d56c186a6ecf1549609412d42ba9d45ea61" translate="yes" xml:space="preserve">
          <source>The branch prediction will miss only once.</source>
          <target state="translated">분기 예측은 한 번만 누락됩니다.</target>
        </trans-unit>
        <trans-unit id="29c1be7f24497d0ee26471ab9535a6a90d257408" translate="yes" xml:space="preserve">
          <source>The branch predictor is a digital circuit (in computer architecture) trying to predict which way a branch will go, improving the flow in the instruction pipeline. The circuit/computer predicts the next step and executes it.</source>
          <target state="translated">브랜치 예측기는 브랜치가 어떤 방식으로 진행될지를 예측하여 명령 파이프 라인의 흐름을 개선하려는 디지털 회로 (컴퓨터 아키텍처)입니다. 회로 / 컴퓨터는 다음 단계를 예측하고 실행합니다.</target>
        </trans-unit>
        <trans-unit id="b7d588a1c5460542b96d8b0baf1bab136cf8c2f6" translate="yes" xml:space="preserve">
          <source>The code is summing up some independent terms, so the order should not matter.</source>
          <target state="translated">코드는 독립적 인 용어를 요약하므로 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="861f94790ecfa967155e62be104ac537e52a5f3a" translate="yes" xml:space="preserve">
          <source>The condition testing field and the optional &quot;set status bit&quot; field can be combined, for example:</source>
          <target state="translated">조건 테스트 필드와 선택적 &quot;상태 비트 설정&quot;필드는 다음과 같이 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fc938b02ae6f7028fe10706590f459d70027752" translate="yes" xml:space="preserve">
          <source>The example contains three instructions and the first one is a conditional jump instruction. The latter two instructions can go into the pipeline until the conditional jump instruction is executed.</source>
          <target state="translated">이 예제에는 세 개의 명령어가 포함되어 있으며 첫 번째 명령어는 조건부 점프 명령어입니다. 후자의 두 명령어는 조건부 점프 명령어가 실행될 때까지 파이프 라인으로 들어갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="366e9cefdfc7cf84268b4baae54481cba492ad51" translate="yes" xml:space="preserve">
          <source>The first thing we need to know is what is &lt;em&gt;small&lt;/em&gt;? While smaller is generally better, a rule of thumb is to stick to lookup tables that are &amp;lt;= 4096 bytes in size. As an upper limit: if your lookup table is larger than 64K it's probably worth reconsidering.</source>
          <target state="translated">가장 먼저 알아야 할 것은 &lt;em&gt;작은 것&lt;/em&gt; 입니까? 일반적으로 크기가 작을수록 좋지만 4096 바이트 미만의 조회 테이블을 사용하는 것이 좋습니다. 상한선으로 : 조회 테이블이 64K보다 크면 다시 고려해 볼 가치가 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ba638444517f57a3c3d8cf6edb54711b632d388" translate="yes" xml:space="preserve">
          <source>The following code does not sort the entire array, but only 200-element segments of it, and thereby runs the fastest.</source>
          <target state="translated">다음 코드는 전체 배열을 정렬하지 않고 200 요소 세그먼트 만 정렬하므로 가장 빠르게 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7983685e650d0c0a12e46c770cad6a3ca1107dcd" translate="yes" xml:space="preserve">
          <source>The inner loop for this algorithm would look something like the following in ARM assembly language:</source>
          <target state="translated">이 알고리즘의 내부 루프는 ARM 어셈블리 언어에서 다음과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="28885d236427f0638d59b0c11dc0c5a23a6555c9" translate="yes" xml:space="preserve">
          <source>The link is here:
&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&lt;/a&gt;</source>
          <target state="translated">링크는 다음과 같습니다 : &lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88c912641d7171878bede0b6532896dc83279c69" translate="yes" xml:space="preserve">
          <source>The performance of an &lt;code&gt;if&lt;/code&gt;-statement depends on whether its condition has a predictable pattern. If the condition is always true or always false, the branch prediction logic in the processor will pick up the pattern. On the other hand, if the pattern is unpredictable, the &lt;code&gt;if&lt;/code&gt;-statement will be much more expensive.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; -statement의 성능은 조건에 예측 가능한 패턴이 있는지 여부에 따라 다릅니다. 조건이 항상 참 또는 항상 거짓이면 프로세서의 분기 예측 논리가 패턴을 선택합니다. 반면, 패턴을 예측할 수없는 &lt;code&gt;if&lt;/code&gt; if-문이 훨씬 비쌉니다.</target>
        </trans-unit>
        <trans-unit id="f012bd762d6379e8ee89682917865e46bdb77c96" translate="yes" xml:space="preserve">
          <source>The question is: What makes the above statement not execute in certain cases as in case of sorted data? Here comes the &quot;branch predictor&quot;. A branch predictor is a digital circuit that tries to guess which way a branch (e.g. an &lt;code&gt;if-then-else&lt;/code&gt; structure) will go before this is known for sure. The purpose of the branch predictor is to improve the flow in the instruction pipeline. Branch predictors play a critical role in achieving high effective performance!</source>
          <target state="translated">문제는 정렬 된 데이터의 경우와 같이 특정 경우에 위의 문을 실행하지 못하게하는 이유는 무엇입니까? 여기에 &quot;분기 예측기&quot;가 있습니다. 브랜치 예측기는 브랜치 (예를 들어 &lt;code&gt;if-then-else&lt;/code&gt; 구조)가 어떤 방식으로 진행 될지 추측하려고 시도하는 디지털 회로입니다. 분기 예측기의 목적은 명령 파이프 라인의 흐름을 개선하는 것입니다. 브랜치 예측자는 높은 효과적인 성능을 달성하는 데 중요한 역할을합니다!</target>
        </trans-unit>
        <trans-unit id="23c9a538a1ef4688c167a88337fa568b94155241" translate="yes" xml:space="preserve">
          <source>The reason why performance improves drastically when the data is sorted is that the branch prediction penalty is removed, as explained beautifully in &lt;a href=&quot;https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902&quot;&gt;Mysticial's answer&lt;/a&gt;.</source>
          <target state="translated">데이터를 정렬 할 때 성능이 크게 향상되는 이유는 &lt;a href=&quot;https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902&quot;&gt;Mysticial의 답변&lt;/a&gt; 에서 아름답게 설명 된대로 분기 예측 패널티가 제거 되었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="243cce3d654c2e7e3d82b9ec0fc8b02ca07456a2" translate="yes" xml:space="preserve">
          <source>The result is robust in multiple tests. We get a great speedup when the branch result is unpredictable, but we suffer a little bit when it is predictable. In fact, when using a conditional move, the performance is the same regardless of the data pattern.</source>
          <target state="translated">결과는 여러 테스트에서 강력합니다. 분기 결과를 예측할 수 없을 때 속도가 크게 향상되지만 예측 가능할 때 약간의 어려움을 겪습니다. 실제로 조건부 이동을 사용하는 경우 데이터 패턴에 관계없이 성능이 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8b2b071beeb1c27797d622cdfe18d46550e595b8" translate="yes" xml:space="preserve">
          <source>The results for the above MATLAB code are as follows:</source>
          <target state="translated">위의 MATLAB 코드의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c621c1518421a4f9a5e82a55048d9d384c6117a" translate="yes" xml:space="preserve">
          <source>The results of the C code as in @GManNickG I get:</source>
          <target state="translated">@GManNickG와 같은 C 코드의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c51e81726485eb1f77e86bce9119907916de64b6" translate="yes" xml:space="preserve">
          <source>The technique of indexing into an array, instead of using an &lt;code&gt;if&lt;/code&gt; statement, can be used for deciding which pointer to use.  I saw a library that implemented binary trees, and instead of having two named pointers (&lt;code&gt;pLeft&lt;/code&gt; and &lt;code&gt;pRight&lt;/code&gt; or whatever) had a length-2 array of pointers and used the &quot;decision bit&quot; technique to decide which one to follow.  For example, instead of:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 문을 사용하는 대신 배열로 인덱싱하는 기술을 사용하여 사용할 포인터를 결정할 수 있습니다. 이진 트리를 구현하는 라이브러리를 보았고 두 개의 명명 된 포인터 ( &lt;code&gt;pLeft&lt;/code&gt; 및 &lt;code&gt;pRight&lt;/code&gt; 등 )가 길이 2의 포인터 배열을 가지며 &quot;결정 비트&quot;기술을 사용하여 어느 것을 따라야할지 결정했습니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="dfc876aaa5431ea7d4210f0979641e4dbe4d96a9" translate="yes" xml:space="preserve">
          <source>The technique of indexing into an array, instead of using an if statement, can be used for deciding which pointer to use. I saw a library that implemented binary trees, and instead of having two named pointers (pLeft and pRight or whatever) had a length-2 array of pointers and used the &quot;decision bit&quot; technique to decide which one to follow. For example, instead of:</source>
          <target state="translated">if 문을 사용하는 대신 배열로 인덱싱하는 기술을 사용하여 사용할 포인터를 결정할 수 있습니다. 이진 트리를 구현하는 라이브러리를 보았고 두 개의 명명 된 포인터 (pLeft 및 pRight 또는 기타)가 길이 2의 포인터 배열을 가지며 &quot;결정 비트&quot;기술을 사용하여 어느 것을 따라야할지 결정했습니다. 예를 들어,</target>
        </trans-unit>
        <trans-unit id="b6cfe976487000bd1e4d79b8ceec46016b036b7e" translate="yes" xml:space="preserve">
          <source>The time that is wasted in case of a branch misprediction is equal to
  the number of stages in the pipeline from the fetch stage to the
  execute stage. Modern microprocessors tend to have quite long
  pipelines so that the misprediction delay is between 10 and 20 clock
  cycles. As a result, making a pipeline longer increases the need for a
  more advanced branch predictor.</source>
          <target state="translated">분기 잘못 예측 된 경우 낭비되는 시간은 파이프 라인의 페치 단계에서 실행 단계까지의 단계 수와 같습니다. 최신 마이크로 프로세서는 파이프 라인이 매우 길기 때문에 오 탐지 지연이 10 ~ 20 클럭주기입니다. 결과적으로 파이프 라인을 더 길게 만들면 고급 분기 예측기의 필요성이 높아집니다.</target>
        </trans-unit>
        <trans-unit id="146d532a4e98e5f647a42caf674908e8ad82de98" translate="yes" xml:space="preserve">
          <source>Then, you can see that the &lt;code&gt;if&lt;/code&gt; conditional is constant throughout the execution of the &lt;code&gt;i&lt;/code&gt; loop, so you can hoist the &lt;code&gt;if&lt;/code&gt; out:</source>
          <target state="translated">그런 다음 &lt;code&gt;if&lt;/code&gt; 루프가 &lt;code&gt;i&lt;/code&gt; 루프를 실행하는 동안 if 조건이 일정하다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5bc19f51ab3899c2bcbdd21013a0f3ed4bf7a2d" translate="yes" xml:space="preserve">
          <source>Then, you see that the inner loop can be collapsed into one single expression, assuming the floating point model allows it (&lt;code&gt;/fp:fast&lt;/code&gt; is thrown, for example)</source>
          <target state="translated">그런 다음 부동 소수점 모델이 허용한다고 가정하면 내부 루프가 하나의 단일 표현식으로 축소 될 수 있음을 알 수 있습니다 (예 &lt;code&gt;/fp:fast&lt;/code&gt; 가 발생 함).</target>
        </trans-unit>
        <trans-unit id="0fdbaf8dd82a2699c782cb69604fae05291b1fe4" translate="yes" xml:space="preserve">
          <source>There has been quite some work on eliminating this branch for managed languages. For example:</source>
          <target state="translated">관리되는 언어에 대해이 분기를 제거하는 작업이 꽤있었습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7b8c8145d6acbc5bd1d7476826d81337b7799153" translate="yes" xml:space="preserve">
          <source>There really are three different kinds of branches:</source>
          <target state="translated">실제로 세 가지 종류의 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="df08e2eb1f25b5e02231e29ab5a1fabee4d43dce" translate="yes" xml:space="preserve">
          <source>This also &quot;proves&quot; that it has nothing to do with any algorithmic issue such as sort order, and it is indeed branch prediction.</source>
          <target state="translated">이것은 또한 정렬 순서와 같은 알고리즘 문제와 관련이 없으며 실제로 분기 예측이라는 것을 &quot;증명&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="5f5f7d59641cd2d4e5ccd00f97168241ae614777" translate="yes" xml:space="preserve">
          <source>This approach works in general if:</source>
          <target state="translated">이 방법은 다음과 같은 경우에 일반적으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="157ae22157daa30935359fff59ce72e0d87c83f4" translate="yes" xml:space="preserve">
          <source>This code is far from optimal. The branches may take a long time in case of mispredictions. The Boolean operations can be made much more efficient if it is known with certainty that the operands have no other values than &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. The reason why the compiler does not make such an assumption is that the variables might have other values if they are uninitialized or come from unknown sources. The above code can be optimized if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has been initialized to valid values or if they come from operators that produce Boolean output. The optimized code looks like this:</source>
          <target state="translated">이 코드는 최적이 아닙니다. 잘못 예측할 경우 지점에 시간이 오래 걸릴 수 있습니다. 피연산자가 &lt;code&gt;0&lt;/code&gt; 과 &lt;code&gt;1&lt;/code&gt; 이외의 다른 값을 가지고 있지 않다는 것을 확실하게 알고 있으면 부울 연산을 훨씬 효율적으로 만들 수 있습니다. 컴파일러가 이러한 가정을하지 않는 이유는 변수가 초기화되지 않았거나 알 수없는 소스에서 온 경우 다른 값을 가질 수 있기 때문입니다. 위의 코드는 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 유효한 값으로 초기화되었거나 부울 출력을 생성하는 연산자에서 온 경우 최적화 될 수 있습니다. 최적화 된 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad588604ed82a4498c092e23d01a6024f6fd9f5a" translate="yes" xml:space="preserve">
          <source>This code wastes half of the adds but never has a branch prediction failure. It's tremendously faster on random data than the version with an actual if statement.</source>
          <target state="translated">이 코드는 추가의 절반을 낭비하지만 분기 예측 실패는 없습니다. 실제 if 문이있는 버전보다 임의의 데이터에서 훨씬 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="a15071f65ca5442561d11637a382876b2bbe52fb" translate="yes" xml:space="preserve">
          <source>This eliminates the branch and replaces it with some bitwise operations.</source>
          <target state="translated">이렇게하면 분기가 제거되고 일부 비트 단위 작업으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="bfca5608e058cd556c4ac52b23258add44c52119" translate="yes" xml:space="preserve">
          <source>This goes to show that even mature modern compilers can vary wildly in their ability to optimize code...</source>
          <target state="translated">이것은 성숙한 현대 컴파일러조차도 코드를 최적화하는 능력이 크게 다를 수 있음을 보여줍니다 ...</target>
        </trans-unit>
        <trans-unit id="18e2896e8160beec33e159c94bd6ee44deed00cc" translate="yes" xml:space="preserve">
          <source>This is branch prediction. I admit it's not the best analogy since the train could just signal the direction with a flag. But in computers, the processor doesn't know which direction a branch will go until the last moment.</source>
          <target state="translated">이것은 분기 예측입니다. 나는 기차가 깃발로 방향을 알릴 수 있기 때문에 그것이 가장 좋은 비유가 아니라는 것을 인정한다. 그러나 컴퓨터에서 프로세서는 지점이 마지막 순간까지 어느 방향으로 갈지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d0c1d7a998794d7121446abef39a77def740f803" translate="yes" xml:space="preserve">
          <source>This is typically implemented by the compiler in the following way:</source>
          <target state="translated">이것은 일반적으로 다음과 같은 방식으로 컴파일러에 의해 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="2bfa3272ab37710c1267a39900a9e349042c88c7" translate="yes" xml:space="preserve">
          <source>This is very friendly to the branch predictor since the branch consecutively goes the same direction many times. Even a simple saturating counter will correctly predict the branch except for the few iterations after it switches direction.</source>
          <target state="translated">분기가 연속적으로 같은 방향으로 여러 번 이동하기 때문에 분기 예측 변수에 매우 친숙합니다. 간단한 포화 카운터조차도 방향 전환 후 몇 번의 반복을 제외하고 분기를 정확하게 예측합니다.</target>
        </trans-unit>
        <trans-unit id="615c711dbe5df7298f33242a06d07ca902c32379" translate="yes" xml:space="preserve">
          <source>This lets you easily identify the problematic line - in the unsorted version the &lt;code&gt;if (data[c] &amp;gt;= 128)&lt;/code&gt; line is causing 164,050,007 mispredicted conditional branches (&lt;code&gt;Bcm&lt;/code&gt;) under cachegrind's branch-predictor model, whereas it's only causing 10,006 in the sorted version.</source>
          <target state="translated">정렬되지 않은 버전에서 &lt;code&gt;if (data[c] &amp;gt;= 128)&lt;/code&gt; 줄이 cachegrind의 분기 예측기 모델에서 164,050,007의 잘못 예측 된 조건부 분기 (Bcm ) 를 일으키는 반면 정렬 된 버전에서는 10,006 만 발생하는 문제가있는 라인을 쉽게 식별 할 수 있습니다 . .</target>
        </trans-unit>
        <trans-unit id="62a8acf06dc12988abe140d1d1ffb08120df1a06" translate="yes" xml:space="preserve">
          <source>This question has already been answered excellently many times over. Still I'd like to draw the group's attention to yet another interesting analysis.</source>
          <target state="translated">이 질문은 이미 여러 차례 훌륭하게 답변되었습니다. 여전히 나는 또 다른 흥미로운 분석에 그룹의 관심을 끌고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="7ab809ea371604dfeb3647ba6b30215c1eb2398d" translate="yes" xml:space="preserve">
          <source>This question is rooted in Branch Prediction Models on CPUs. I'd recommend reading this paper:</source>
          <target state="translated">이 질문은 CPU의 분기 예측 모델을 기반으로합니다. 이 논문을 읽는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="bda231ceb9d58c33b0e891be602a5fde29542e65" translate="yes" xml:space="preserve">
          <source>To execute instruction B or instruction C the processor will have to wait till the instruction A doesn't reach till EX stage in the pipeline, as the decision to go to instruction B or instruction C depends on the result of instruction A. So the pipeline will look like this.</source>
          <target state="translated">명령어 B 또는 명령어 C를 실행하려면 명령어 B 또는 명령어 C로가는 결정이 명령어 A의 결과에 따라 달라지기 때문에 프로세서는 명령어 A가 파이프 라인에서 EX 스테이지까지 도달하지 않을 때까지 기다려야합니다. 이렇게 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="0b7e892117417fb4b6c49ca103d227fc9f4d1140" translate="yes" xml:space="preserve">
          <source>To understand branch prediction one must first understand &lt;strong&gt;Instruction Pipeline&lt;/strong&gt;:</source>
          <target state="translated">분기 예측을 이해하려면 먼저 &lt;strong&gt;명령 파이프 라인을&lt;/strong&gt; 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="a29c68a2d5e91d86d31480109b1da5bc8e35f407" translate="yes" xml:space="preserve">
          <source>Two-way branching is usually implemented with a conditional jump
  instruction. A conditional jump can either be &quot;not taken&quot; and continue
  execution with the first branch of code which follows immediately
  after the conditional jump, or it can be &quot;taken&quot; and jump to a
  different place in program memory where the second branch of code is
  stored. It is not known for certain whether a conditional jump will be
  taken or not taken until the condition has been calculated and the
  conditional jump has passed the execution stage in the instruction
  pipeline (see fig. 1).</source>
          <target state="translated">양방향 분기는 일반적으로 조건부 점프 명령으로 구현됩니다. 조건부 점프는 &quot;취득되지 않음&quot;일 수 있으며 조건부 점프 직후에 오는 첫 번째 코드 분기로 실행을 계속하거나, &quot;취득&quot;하여 두 번째 코드 분기가있는 프로그램 메모리의 다른 위치로 점프 할 수 있습니다. 저장되었습니다. 조건이 계산되고 조건 파이프가 명령 파이프 라인의 실행 단계를 통과 할 때까지 조건부 점프가 수행되는지 여부는 확실하지 않습니다 (그림 1 참조).</target>
        </trans-unit>
        <trans-unit id="dcb1d0bc5503faffa53fc3453598b0d035a0c897" translate="yes" xml:space="preserve">
          <source>Unsorted Array: Curved Road</source>
          <target state="translated">정렬되지 않은 배열 : 곡선 도로</target>
        </trans-unit>
        <trans-unit id="c006e2b20060032caaabd451e6df6a02a78a5ac3" translate="yes" xml:space="preserve">
          <source>Use Branch Predictor and don't take a conditional jump. Let's assume that the predict is &lt;strong&gt;not&lt;/strong&gt; taking the conditional jump.</source>
          <target state="translated">Branch Predictor를 사용하고 조건부로 점프하지 마십시오. 예측이 조건부 점프를 수행 &lt;strong&gt;하지 않는다고&lt;/strong&gt; 가정합시다.</target>
        </trans-unit>
        <trans-unit id="12c9166e85e51c6ec14fc60d80a7a0f3c7c32568" translate="yes" xml:space="preserve">
          <source>Use Branch Predictor and take a conditional jump. Let's assume that the predict is &lt;strong&gt;not&lt;/strong&gt; taking the conditional jump.</source>
          <target state="translated">Branch Predictor를 사용하고 조건부로 점프하십시오. 예측이 조건부 점프를 수행 &lt;strong&gt;하지 않는다고&lt;/strong&gt; 가정합시다.</target>
        </trans-unit>
        <trans-unit id="a08965e116be4f8dd9b991b5c78c2f2a4953805f" translate="yes" xml:space="preserve">
          <source>Using bitwise operators is more advantageous if the operands are variables than if the operands are comparisons:</source>
          <target state="translated">피연산자가 비교 인 경우보다 피연산자가 변수 인 경우 비트 연산자를 사용하는 것이 더 유리합니다.</target>
        </trans-unit>
        <trans-unit id="753325de5864d63921392f6d1fdfec25be2f1719" translate="yes" xml:space="preserve">
          <source>VC++ 2010 is unable to generate conditional moves for this branch even under &lt;code&gt;/Ox&lt;/code&gt;.</source>
          <target state="translated">VC ++ 2010은 &lt;code&gt;/Ox&lt;/code&gt; 에서도이 분기에 대한 조건부 이동을 생성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d043004e185c7b0efa7dc62df9e481517f2fae51" translate="yes" xml:space="preserve">
          <source>Visualization:</source>
          <target state="translated">Visualization:</target>
        </trans-unit>
        <trans-unit id="a3b2fe94f4750042ee509a40cd1b811c02dcc827" translate="yes" xml:space="preserve">
          <source>WB -- Write back to CPU register</source>
          <target state="translated">WB-CPU 레지스터에 다시 쓰기</target>
        </trans-unit>
        <trans-unit id="6375cff5f915d0ad5739238963ce456b2a75e8c2" translate="yes" xml:space="preserve">
          <source>Well, not exactly... :-)</source>
          <target state="translated">글쎄요, 정확히 ... :-)</target>
        </trans-unit>
        <trans-unit id="a608d088fa8295119cc45125ae05fa9e8da0660e" translate="yes" xml:space="preserve">
          <source>What is Branch Prediction?</source>
          <target state="translated">분기 예측이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="ddc44bd3685ad0a82e462b5b7860aa861536395a" translate="yes" xml:space="preserve">
          <source>What is going on?</source>
          <target state="translated">무슨 일이야?</target>
        </trans-unit>
        <trans-unit id="5079282bb6ac8d8fd7800b70a515ca1a7779ded0" translate="yes" xml:space="preserve">
          <source>When you have sorted elements, IR could not be bothered to fetch all CPU instructions, again and again, It fetches them from cache.</source>
          <target state="translated">요소를 정렬하면 IR이 모든 CPU 명령을 반복해서 페치하도록 귀찮게 할 수 없었으며, 캐시에서이를 페치합니다.</target>
        </trans-unit>
        <trans-unit id="93820c99e002586797e0fc268993184aa2c6be22" translate="yes" xml:space="preserve">
          <source>Whenever there's an &lt;code&gt;if-else&lt;/code&gt; \ &lt;code&gt;switch&lt;/code&gt; statement, the expression has to be evaluated to determine which block should be executed. In the assembly code generated by the compiler, conditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt; instructions are inserted.</source>
          <target state="translated">&lt;code&gt;if-else&lt;/code&gt; \ &lt;code&gt;switch&lt;/code&gt; 문이있을 때마다 어떤 블록을 실행해야하는지 결정하기 위해 식을 평가해야합니다. 컴파일러에서 생성 한 어셈블리 코드에는 조건부 &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;분기&lt;/a&gt; 명령어가 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="467f5fe90dca59bcce184cb76b5258ae0f818f25" translate="yes" xml:space="preserve">
          <source>While flushing pipelines is super fast, nowadays taking this gamble is worth it. Predicting sorted data or a data that changes slowly is always easier and better than predicting fast changes.</source>
          <target state="translated">플러싱 파이프 라인은 매우 빠르지 만 오늘날에는이 도박을하는 것이 가치가 있습니다. 정렬 된 데이터 또는 느리게 변경되는 데이터를 예측하는 것이 빠른 변경을 예측하는 것보다 항상 쉽고 낫습니다.</target>
        </trans-unit>
        <trans-unit id="7a096e98f70b03605f1fd87dee197c0e0dc2d954" translate="yes" xml:space="preserve">
          <source>While maintaining readability, we can check the speedup factor.</source>
          <target state="translated">가독성을 유지하면서 속도 향상 요소를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9792cdf86b1977e88d80d53a5f46d6bb5efa646c" translate="yes" xml:space="preserve">
          <source>Why is processing a sorted array faster than processing an unsorted array</source>
          <target state="translated">정렬되지 않은 배열을 처리하는 것보다 정렬 된 배열을 처리하는 이유</target>
        </trans-unit>
        <trans-unit id="0ecd9604afd7fdf56bd91ee7561b152cde1f8ed3" translate="yes" xml:space="preserve">
          <source>Why is processing a sorted array faster than processing an unsorted array?</source>
          <target state="translated">정렬되지 않은 배열을 처리하는 것이 정렬되지 않은 배열을 처리하는 것보다 빠른 이유는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="45e27afeaa62cf0cccdd3110fde02e47401ff594" translate="yes" xml:space="preserve">
          <source>With a similar but less extreme result.</source>
          <target state="translated">비슷하지만 덜 극단적 인 결과.</target>
        </trans-unit>
        <trans-unit id="00bb7f0f6f10727b9d3a497aec7ad500fc1da108" translate="yes" xml:space="preserve">
          <source>With a sorted array, the condition &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; is first &lt;code&gt;false&lt;/code&gt; for a streak of values, then becomes &lt;code&gt;true&lt;/code&gt; for all later values. That's easy to predict. With an unsorted array, you pay for the branching cost.</source>
          <target state="translated">정렬 된 배열을 사용하면 조건 &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; 이 먼저 일련의 값에 대해 &lt;code&gt;false&lt;/code&gt; 이고 이후의 모든 값에 대해 &lt;code&gt;true&lt;/code&gt; 가됩니다. 예측하기 쉽습니다. 정렬되지 않은 배열을 사용하면 분기 비용을 지불합니다.</target>
        </trans-unit>
        <trans-unit id="9e8a52af2265d491577ac667e610164d2bae82ec" translate="yes" xml:space="preserve">
          <source>With loop interchange, we can safely change this loop to:</source>
          <target state="translated">루프 교환을 사용하면이 루프를 다음과 같이 안전하게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b07d7d0e763b2a76e028689779bd9793c81728e8" translate="yes" xml:space="preserve">
          <source>With the sorted data, the code runs in 1.93 seconds.</source>
          <target state="translated">정렬 된 데이터를 사용하면 코드가 1.93 초 안에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="cdf4ffa875649aacf9a2112d2448609655f91aec" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;std::sort(data, data + arraySize);&lt;/code&gt;, the code runs in 11.54 seconds.</source>
          <target state="translated">&lt;code&gt;std::sort(data, data + arraySize);&lt;/code&gt; 코드는 11.54 초 안에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f595b01765d8ae905ea5e9dd7e62d7a02b4fbe22" translate="yes" xml:space="preserve">
          <source>Without branch prediction, the following would occur:</source>
          <target state="translated">분기 예측이 없으면 다음이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b4764b924495da3570f6397640729704193386e0" translate="yes" xml:space="preserve">
          <source>Without branch prediction, the processor would have to wait until the
  conditional jump instruction has passed the execute stage before the
  next instruction can enter the fetch stage in the pipeline.</source>
          <target state="translated">분기 예측이 없으면 프로세서는 조건부 점프 명령이 실행 단계를 통과 할 때까지 기다려야 다음 명령이 파이프 라인의 페치 단계에 들어갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fa9477c95d3ffecec4695db62b573324832754a" translate="yes" xml:space="preserve">
          <source>Without the Branch Predictor.</source>
          <target state="translated">분기 예측기가 없습니다.</target>
        </trans-unit>
        <trans-unit id="0dee180d4b195226d6d709eb16ec0e42b8a820e7" translate="yes" xml:space="preserve">
          <source>You are a processor and you see a branch. You have no idea which way it will go. What do you do? You halt execution and wait until the previous instructions are complete. Then you continue down the correct path.</source>
          <target state="translated">당신은 프로세서이고 당신은 지점을 볼 수 있습니다. 당신은 어떤 길로 갈지 모른다. 너 뭐하니? 실행을 중단하고 이전 지침이 완료 될 때까지 기다립니다. 그런 다음 올바른 경로를 계속 진행하십시오.</target>
        </trans-unit>
        <trans-unit id="3747acc12d9a8b4eeed31b6769fc516a8c97c9dd" translate="yes" xml:space="preserve">
          <source>You are the operator of a junction and you hear a train coming. You have no idea which way it is supposed to go. You stop the train to ask the driver which direction they want. And then you set the switch appropriately.</source>
          <target state="translated">당신은 정션의 운영자이며 기차가 오는 소리를 듣습니다. 당신은 그것이 어느 방향으로 가야할지 모른다. 열차를 멈 추면 운전자에게 원하는 방향을 묻습니다. 그런 다음 스위치를 적절하게 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a55200fca28b7f0ac1706d86d79e8114433a8b42" translate="yes" xml:space="preserve">
          <source>You can also see from this lovely &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor#/media/File:Branch_prediction_2bit_saturating_counter-dia.svg&quot;&gt;diagram&lt;/a&gt; why the branch predictor gets confused.</source>
          <target state="translated">이 멋진 &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor#/media/File:Branch_prediction_2bit_saturating_counter-dia.svg&quot;&gt;다이어그램&lt;/a&gt; 에서 분기 예측 변수가 왜 혼란스러워하는지 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33b05101ba2f17cb142e08e195f5e37dbb2cf22d" translate="yes" xml:space="preserve">
          <source>You can have a stop condition instead of just checking the value, this way you only loop over the relevant data, and ignore the rest.</source>
          <target state="translated">값을 확인하는 대신 중지 조건을 가질 수 있습니다. 이렇게하면 관련 데이터 만 반복하고 나머지는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="e7cdaed049a36de91bc0b6220dbae638a556dd97" translate="yes" xml:space="preserve">
          <source>You might wonder why this works well in managed languages. After all, managed languages check the boundaries of the arrays with a branch to ensure you don't mess up...</source>
          <target state="translated">왜 이것이 관리 언어에서 잘 작동하는지 궁금 할 것입니다. 결국, 관리되는 언어는 분기로 배열의 경계를 확인하여 엉망이되지 않도록합니다 ...</target>
        </trans-unit>
        <trans-unit id="f6967173a58337d24e84af6ae18adb3fbbae9e11" translate="yes" xml:space="preserve">
          <source>can be optimized to:</source>
          <target state="translated">다음에 최적화 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="576ab25730c6c8fde51cea0123c6a7dd40910123" translate="yes" xml:space="preserve">
          <source>is optimal in most cases (unless you expect the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; expression to generate many branch mispredictions).</source>
          <target state="translated">&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 표현식이 많은 분기 오판을 생성 할 것으로 예상하지 않는 한 대부분의 경우에 최적입니다.</target>
        </trans-unit>
        <trans-unit id="a45d05b730bbc58dc46e14dafb3c0d1d4583c878" translate="yes" xml:space="preserve">
          <source>it's a nice solution maybe it will work</source>
          <target state="translated">그것은 좋은 해결책 일 것입니다.</target>
        </trans-unit>
        <trans-unit id="c3bfc02b43a0aa6f110706cfedc26e042e2f304a" translate="yes" xml:space="preserve">
          <source>it's a small table and is likely to be cached in the processor, and</source>
          <target state="translated">작은 테이블이며 프로세서에 캐시 될 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="651a852c52cc01c89e5ea1bd7793b4460d1de61f" translate="yes" xml:space="preserve">
          <source>or similarly:</source>
          <target state="translated">또는 유사하게 :</target>
        </trans-unit>
        <trans-unit id="495520e358c6efe36183f5f5cfdfb1a5f7540a8b" translate="yes" xml:space="preserve">
          <source>or, slightly more obfuscated</source>
          <target state="translated">또는 약간 더 난독 화</target>
        </trans-unit>
        <trans-unit id="f11d2b737879c47db5e53479b4f6bb83db8e1df9" translate="yes" xml:space="preserve">
          <source>so the predictor will change sides as the &lt;code&gt;std::rand()&lt;/code&gt; blow.</source>
          <target state="translated">그래서 예측자는 &lt;code&gt;std::rand()&lt;/code&gt; 날 때 변을 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="0234c36fd5c76bfa6dcd2e321618d03cb21418f9" translate="yes" xml:space="preserve">
          <source>this library would do something like:</source>
          <target state="translated">이 라이브러리는 다음과 같은 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="46ebea860b14c6c60e10f66281ac11838db11fdf" translate="yes" xml:space="preserve">
          <source>we can find that the meaning of this particular &lt;code&gt;if... else...&lt;/code&gt; branch is to add something when a condition is satisfied. This type of branch can be easily transformed into a &lt;strong&gt;conditional move&lt;/strong&gt; statement, which would be compiled into a conditional move instruction: &lt;code&gt;cmovl&lt;/code&gt;, in an &lt;code&gt;x86&lt;/code&gt; system. The branch and thus the potential branch prediction penalty is removed.</source>
          <target state="translated">우리는이 특별한 &lt;code&gt;if... else...&lt;/code&gt; 의 의미는 ... 조건이 충족되면 무언가를 추가하는 것입니다. 이 유형의 브랜치는 &lt;code&gt;x86&lt;/code&gt; 시스템에서 조건부 이동 명령으로 쉽게 변환 될 수 있으며 조건부 이동 명령 &lt;code&gt;cmovl&lt;/code&gt; 로 컴파일됩니다. 분기 및 잠재적 분기 예측 패널티가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="52e0612303b39c0691e807b9c7a297fa35003367" translate="yes" xml:space="preserve">
          <source>with:</source>
          <target state="translated">with:</target>
        </trans-unit>
        <trans-unit id="4e59d494e29779b82beb957429950a6c38d3846b" translate="yes" xml:space="preserve">
          <source>you are running things in a quite tight loop and/or the processor can preload the data.</source>
          <target state="translated">매우 엄격한 루프로 작업하고 있거나 프로세서가 데이터를 사전로드 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
