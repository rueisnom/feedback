<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/11227809">
    <body>
      <group id="11227809">
        <trans-unit id="b53667fac1b1818f469635cd98c1992443873e79" translate="yes" xml:space="preserve">
          <source>(Or somewhat fast: for the already-sorted case, &lt;code&gt;cmov&lt;/code&gt; can be slower especially if GCC puts it on the critical path instead of just &lt;code&gt;add&lt;/code&gt;, especially on Intel before Broadwell where &lt;code&gt;cmov&lt;/code&gt; has 2 cycle latency: &lt;a href=&quot;https://stackoverflow.com/questions/28875325/gcc-optimization-flag-o3-makes-code-slower-than-o2&quot;&gt;gcc optimization flag -O3 makes code slower than -O2&lt;/a&gt;)</source>
          <target state="translated">(Или несколько быстро: в уже отсортированном случае &lt;code&gt;cmov&lt;/code&gt; может быть медленнее, особенно если GCC ставит его на критический путь вместо простого &lt;code&gt;add&lt;/code&gt; , особенно в Intel до Broadwell, где &lt;code&gt;cmov&lt;/code&gt; имеет задержку в 2 цикла: &lt;a href=&quot;https://stackoverflow.com/questions/28875325/gcc-optimization-flag-o3-makes-code-slower-than-o2&quot;&gt;флаг оптимизации gcc -O3 замедляет код чем -O2&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d1ea744eaff022b9ec4d3d58be32b719619a16de" translate="yes" xml:space="preserve">
          <source>// Declare and then fill in the lookup table</source>
          <target state="translated">/Объявите,а затем заполните поисковую таблицу /</target>
        </trans-unit>
        <trans-unit id="439750f5cd724a86cdb0b90f611fcdf4d601b584" translate="yes" xml:space="preserve">
          <source>// Test</source>
          <target state="translated">/Тест</target>
        </trans-unit>
        <trans-unit id="22e070d61d4ac5f3e0981ca4d20241ae99b358d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler&quot;&gt;Intel C++ Compiler&lt;/a&gt; (ICC) 11 does something miraculous. It &lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_interchange&quot;&gt;interchanges the two loops&lt;/a&gt;, thereby hoisting the unpredictable branch to the outer loop. So not only is it immune to the mispredictions, it is also twice as fast as whatever VC++ and GCC can generate! In other words, ICC took advantage of the test-loop to defeat the benchmark...</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler&quot;&gt;Компилятор Intel C ++&lt;/a&gt; (ICC) 11 совершает чудеса. Он &lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_interchange&quot;&gt;чередует две петли&lt;/a&gt; , тем самым поднимая непредсказуемую ветвь к внешней петле. Таким образом, он не только защищен от неправильных прогнозов, но также в два раза быстрее, чем то, что могут генерировать VC ++ и GCC! Другими словами, ICC воспользовался тестовым циклом, чтобы победить тест ...</target>
        </trans-unit>
        <trans-unit id="637937a9b16b61115d58b45cd478f01d51765e8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADD R1, R2, R3&lt;/code&gt; performs &lt;code&gt;R1 = R2 + R3&lt;/code&gt; without updating any status bits.</source>
          <target state="translated">&lt;code&gt;ADD R1, R2, R3&lt;/code&gt; выполняет &lt;code&gt;R1 = R2 + R3&lt;/code&gt; без обновления каких-либо битов состояния.</target>
        </trans-unit>
        <trans-unit id="87d9034703b27f8b1421db3174bb0a89354e4fdd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDGE R1, R2, R3&lt;/code&gt; performs the same operation only if a previous instruction that affected the status bits resulted in a Greater than or Equal condition.</source>
          <target state="translated">&lt;code&gt;ADDGE R1, R2, R3&lt;/code&gt; выполняет ту же операцию, только если предыдущая инструкция, которая затронула биты состояния, вызвала условие &amp;laquo;Больше чем&amp;raquo; или &amp;laquo;Равно&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="23f6fd5b0c8ae0b7004305abd5527096f2e1cd0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDS R1, R2, R3&lt;/code&gt; performs the addition and then updates the &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; flags in the Processor Status Register based on whether the result was Negative, Zero, Carried (for unsigned addition), or oVerflowed (for signed addition).</source>
          <target state="translated">&lt;code&gt;ADDS R1, R2, R3&lt;/code&gt; выполняет сложение, а затем обновляет флаги &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; и &lt;code&gt;V&lt;/code&gt; в регистре состояния процессора в зависимости от того, был ли результат отрицательным, нулевым, перенесенным (для добавления без знака) или oVerflowed (для сложенного добавления со знаком) ,</target>
        </trans-unit>
        <trans-unit id="9dc9f762599510b8def52bb6b16ab86d5b605418" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDSGE R1, R2, R3&lt;/code&gt; performs the addition only if the &lt;code&gt;GE&lt;/code&gt; test is true, and then subsequently updates the status bits based on the result of the addition.</source>
          <target state="translated">&lt;code&gt;ADDSGE R1, R2, R3&lt;/code&gt; выполняет сложение только в том случае, если проверка &lt;code&gt;GE&lt;/code&gt; является истинной, а затем впоследствии обновляет биты состояния на основе результата сложения.</target>
        </trans-unit>
        <trans-unit id="6c4200c52c77a8809e0c28b82431a4fcd7fb0319" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CMP&lt;/code&gt; opcodes always update the status bits in the Processor Status Register (PSR), because that is their purpose, but most other instructions do not touch the PSR unless you add an optional &lt;code&gt;S&lt;/code&gt; suffix to the instruction, specifying that the PSR should be updated based on the result of the instruction. &lt;strong&gt;Just like the 4-bit condition suffix, being able to execute instructions without affecting the PSR is a mechanism that reduces the need for branches on ARM, and also facilitates out of order dispatch at the hardware level&lt;/strong&gt;, because after performing some operation X that updates the status bits, subsequently (or in parallel) you can do a bunch of other work that explicitly should not affect the status bits, then you can test the state of the status bits set earlier by X.</source>
          <target state="translated">&lt;code&gt;CMP&lt;/code&gt; операций CMP всегда обновляют биты состояния в регистре состояния процессора (PSR), потому что это является их целью, но большинство других инструкций не затрагивают PSR, если в инструкцию не добавлен необязательный суффикс &lt;code&gt;S&lt;/code&gt; , указывающий, что PSR следует обновлять на основе по результату инструкции. &lt;strong&gt;Как и 4-битный суффикс условия, возможность выполнять инструкции без влияния на PSR является механизмом, который уменьшает потребность в ветвях на ARM, а также облегчает неупорядоченную диспетчеризацию на аппаратном уровне&lt;/strong&gt; , поскольку после выполнения некоторой операции X, которая обновляет биты состояния, впоследствии (или параллельно) вы можете выполнять кучу других работ, которые явно не должны влиять на биты состояния, тогда вы можете проверить состояние битов состояния, установленных ранее X.</target>
        </trans-unit>
        <trans-unit id="391873c374a8ded8013438f8a2663a8948bf98aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; cannot be replaced with &lt;code&gt;a &amp;amp; b&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is an expression that should not be evaluated if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will not evaluate &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; will). Likewise, &lt;code&gt;a || b&lt;/code&gt; can not be replaced with &lt;code&gt;a | b&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is an expression that should not be evaluated if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; нельзя заменить на &lt;code&gt;a &amp;amp; b&lt;/code&gt; , если &lt;code&gt;b&lt;/code&gt; является выражением, которое не следует оценивать, если &lt;code&gt;a&lt;/code&gt; равно &lt;code&gt;false&lt;/code&gt; ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; не будет оценивать &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; will). Аналогично, &lt;code&gt;a || b&lt;/code&gt; б не может быть заменен &lt;code&gt;a | b&lt;/code&gt; b, если &lt;code&gt;b&lt;/code&gt; является выражением, которое не должно оцениваться, если &lt;code&gt;a&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3da7ae3851d0cb07b784c1504abb04501c97c690" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; is used instead of &lt;code&gt;bool&lt;/code&gt; in order to make it possible to use the bitwise operators (&lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) instead of the Boolean operators (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;). The bitwise operators are single instructions that take only one clock cycle. The OR operator (&lt;code&gt;|&lt;/code&gt;) works even if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have other values than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. The AND operator (&lt;code&gt;&amp;amp;&lt;/code&gt;) and the EXCLUSIVE OR operator (&lt;code&gt;^&lt;/code&gt;) may give inconsistent results if the operands have other values than &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; используется вместо &lt;code&gt;bool&lt;/code&gt; для того, чтобы можно было использовать битовые операторы ( &lt;code&gt;&amp;amp;&lt;/code&gt; и &lt;code&gt;|&lt;/code&gt; ) вместо логических операторов ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; и &lt;code&gt;||&lt;/code&gt; ). Побитовые операторы - это одиночные инструкции, которые занимают только один такт. Оператор OR ( &lt;code&gt;|&lt;/code&gt; ) работает, даже если &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; имеют значения, отличные от &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;1&lt;/code&gt; . Оператор AND ( &lt;code&gt;&amp;amp;&lt;/code&gt; ) и оператор EXCLUSIVE OR ( &lt;code&gt;^&lt;/code&gt; ) могут давать противоречивые результаты, если операнды имеют значения, отличные от &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2116c486e51bc36c5ea4f4ea724a4decd73ddf80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max1&lt;/code&gt; uses the conditional branch &lt;code&gt;if... else ...&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;max1&lt;/code&gt; использует условную ветвь &lt;code&gt;if... else ...&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5c4a2ff8aabdb7de009ae921d3d149a4fd4a3981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max2&lt;/code&gt; uses much less code due to the usage of instruction &lt;code&gt;cmovge&lt;/code&gt;. But the real gain is that &lt;code&gt;max2&lt;/code&gt; does not involve branch jumps, &lt;code&gt;jmp&lt;/code&gt;, which would have a significant performance penalty if the predicted result is not right.</source>
          <target state="translated">&lt;code&gt;max2&lt;/code&gt; использует намного меньше кода из-за использования инструкции &lt;code&gt;cmovge&lt;/code&gt; . Но реальный выигрыш в том, что &lt;code&gt;max2&lt;/code&gt; не включает переходы по ветвям , &lt;code&gt;jmp&lt;/code&gt; , что может привести к значительному снижению производительности, если прогнозируемый результат неверен .</target>
        </trans-unit>
        <trans-unit id="3a816aa9d54ebe21437fa8cb172a780bbab33269" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max2&lt;/code&gt; uses the ternary operator &lt;code&gt;... ? ... : ...&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;max2&lt;/code&gt; использует троичный оператор &lt;code&gt;... ? ... : ...&lt;/code&gt; ...: ... :</target>
        </trans-unit>
        <trans-unit id="562cd5fce1e7b6dcbe296f9206498ac8e7ed271a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt; can not be used for NOT. Instead, you can make a Boolean NOT on a variable which is known to be &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; by XOR'ing it with &lt;code&gt;1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; нельзя использовать для НЕ. Вместо этого вы можете сделать логическое НЕ для переменной, которая, как известно, равна &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;1&lt;/code&gt; , XOR'ing его с &lt;code&gt;1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="86968cc91f6395ac3372778b6f3bd6927c8f9854" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;A Demonstration of Self-Profiling&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;Демонстрация самопрофилирования&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62a5257803ca2425233ddd03c4d7d207b6867e4a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://courses.cs.washington.edu/courses/csep548/06au/lectures/branchPred.pdf&quot;&gt;Branch Prediction Review&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://courses.cs.washington.edu/courses/csep548/06au/lectures/branchPred.pdf&quot;&gt;Обзор прогноза отрасли&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e83995c1786dac19461a4d31bc4d8b9cde96f71d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Branch predictor&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Предиктор ветвей&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17ca7e4d199635bbed9dd553888d82060ea8e587" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://stackoverflow.blog/2019/10/11/c-creator-bjarne-stroustrup-answers-our-top-five-c-questions/&quot;&gt;Bjarne Stroustrup's Answer&lt;/a&gt; to this question:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.blog/2019/10/11/c-creator-bjarne-stroustrup-answers-our-top-five-c-questions/&quot;&gt;Ответ Бьярна Страуструпа&lt;/a&gt; на этот вопрос:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6999c55f1112ac2522394d373dcc92bf8ba35d17" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://web.njit.edu/~rlopes/Mod5.3.pdf&quot;&gt;Branch Prediction&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://web.njit.edu/~rlopes/Mod5.3.pdf&quot;&gt;Прогнозирование отрасли&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2567a75f2917b4cf19219547a29e45cd68bfc50" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Modern processors are complicated and have long pipelines. So they take forever to &quot;warm up&quot; and &quot;slow down&quot;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Современные процессоры сложны и имеют длинные трубопроводы.&lt;/em&gt; &lt;em&gt;Таким образом, они всегда &quot;разогреваются&quot; и &quot;замедляются&quot;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c4e8b34981c89b9e7eadedce54ab4bf99abb400" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Trains are heavy and have a lot of inertia. So they take forever to start up and slow down.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Поезда тяжелые и обладают большой инерцией.&lt;/em&gt; &lt;em&gt;Таким образом, им требуется вечность для запуска и замедления.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dfd2a9e0eebface4570f5726ff229d9f7239571" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Static&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. Статический&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec921c20fc92beab445f0b65b62aac1dc30fda89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Dynamic&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. Динамический&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7070b983b9e682ffd47dc61eb8173e377437895" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;4-stage pipeline in general for 2 instructions.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;4-х ступенчатый конвейер в целом по 2 инструкции.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7c0dc2f57cc914145b6b0624cff97eb77959909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;But this is actually part of a bigger picture:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Но это на самом деле часть общей картины:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a57d022fefdf1a6dc6fb7aff0b41a4c5a3d4191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;In case of a correct guess, the pipeline looks something like this:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;В случае правильного предположения, конвейер выглядит примерно так:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="059ec29570653df3139916923c59df324c15a8f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;In other words, you try to identify a pattern and follow it.&lt;/em&gt;&lt;/strong&gt; This is more or less how branch predictors work.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Другими словами, вы пытаетесь определить шаблон и следовать ему.&lt;/em&gt;&lt;/strong&gt; Это более или менее то, как работают предсказатели ветвлений.</target>
        </trans-unit>
        <trans-unit id="e2c23a7d4a1b5f910c13dc8dd8d34c2b4feb4d6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When if condition returns false:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Когда условие возвращает ложное:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4757bf44b2540d4c3544fbd8ed736018934b59c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;when if condition returns true:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;когда условие возвращает true:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a145133a463629536767d61372777b3b15514477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Background and why&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Фон и почему&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="03ac7fc31e2558f71e7c0316cacb5b6078717e4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Backward conditional branches&lt;/strong&gt; - the PC is changed to point backward in the instruction stream. The branch is based on some condition, such as branching backwards to the beginning of a program loop when a test at the end of the loop states the loop should be executed again.</source>
          <target state="translated">&lt;strong&gt;Обратные условные ветви&lt;/strong&gt; - ПК изменяется, чтобы указывать назад в потоке команд. Ветвление основано на некотором условии, таком как переход назад к началу цикла программы, когда тест в конце цикла указывает, что цикл должен быть выполнен снова.</target>
        </trans-unit>
        <trans-unit id="88725d83d10b621a1197929903db27ce4176d85e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Benchmarks: Core i7 920 @ 3.5 GHz&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Тесты: Core i7 920 @ 3,5 ГГц&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29e42a036c1d0c70cc19beaa407c40f6950cdef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch prediction.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Отраслевой прогноз.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c55e466ed2fc88a1e76e953db7f49f1fd3730ab3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch prediction&lt;/strong&gt; makes the logic run slower, because of the switching which happens in your code! It's like you are going a straight street or a street with a lot of turnings, for sure the straight one is going to be done quicker!...</source>
          <target state="translated">&lt;strong&gt;Предсказание ветвей&lt;/strong&gt; замедляет работу логики из-за переключения, которое происходит в вашем коде! Как будто вы идете по прямой улице или улице с большим количеством поворотов, наверняка прямая будет сделана быстрее! ...</target>
        </trans-unit>
        <trans-unit id="d218041da74b681266dd3bc64ecbec4c36a29624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch-prediction gain!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Выгода предсказания ветвлений!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e98dec0bd0a7e8e2059d13e9a8c88d55b96ae930" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Consider an if-statement:&lt;/strong&gt; At the processor level, it is a branch instruction:</source>
          <target state="translated">&lt;strong&gt;Рассмотрим оператор if:&lt;/strong&gt; на уровне процессора это инструкция перехода:</target>
        </trans-unit>
        <trans-unit id="c1e69093a905a8b010540753c555aae1f8e36d3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructing a table&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Построение стола&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="130a0bfbd8fc444b6379d249ad5d24a0e69aaf6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Forward conditional branches&lt;/strong&gt; - based on a run-time condition, the PC (program counter) is changed to point to an address forward in the instruction stream.</source>
          <target state="translated">&lt;strong&gt;Пересылка условных переходов&lt;/strong&gt; - в зависимости от времени выполнения ПК (программный счетчик) изменяется, чтобы указывать на адрес пересылки в потоке команд.</target>
        </trans-unit>
        <trans-unit id="5bb5d1ddff4f6d3eb81208ce3786e0186300f35b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess right every time&lt;/strong&gt;, the execution will never have to stop.</source>
          <target state="translated">&lt;strong&gt;Если вы каждый раз угадаете&lt;/strong&gt; , выполнение никогда не остановится.</target>
        </trans-unit>
        <trans-unit id="5c443327b64ce0afa013e0a8c686cce4fcb25e64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess right every time&lt;/strong&gt;, the train will never have to stop.</source>
          <target state="translated">&lt;strong&gt;Если вы угадаете каждый раз&lt;/strong&gt; , поезд никогда не остановится.</target>
        </trans-unit>
        <trans-unit id="43854ebdaaaf1f8914276249ab523b2bf804d1c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess wrong too often&lt;/strong&gt;, the train will spend a lot of time stopping, backing up, and restarting.</source>
          <target state="translated">&lt;strong&gt;Если вы слишком часто угадываете неправильно&lt;/strong&gt; , поезд будет тратить много времени на остановку, резервное копирование и перезапуск.</target>
        </trans-unit>
        <trans-unit id="ff48f0bff759820faca0dc4ce0d054010aa2a369" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess wrong too often&lt;/strong&gt;, you spend a lot of time stalling, rolling back, and restarting.</source>
          <target state="translated">&lt;strong&gt;Если вы слишком часто угадываете неправильно&lt;/strong&gt; , вы тратите много времени на остановку, откат и перезапуск.</target>
        </trans-unit>
        <trans-unit id="29e3b2963af7a82c74a39140e23e664c8aa6638f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Increasing the Instruction Fetch Rate via Multiple Branch Prediction and a Branch Address Cache&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Увеличение скорости получения инструкций с помощью многократного предсказания ветвлений и кэша адресов ветвлений&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80ce9cf0a86a6ef1b733fbee4d9e322ccb10c80d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's do some bench marking to understand it better&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Давайте сделаем несколько тестов, чтобы понять это лучше&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6ddf289b433253c5925b3f9813d36a0537be7c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Managed languages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Управляемые языки&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a1b89da59705a9d2d5291d59ff4a51ef12d08c3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Quick visualization:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Быстрая визуализация:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5270a251ef82abdcf7f4c1527f163a3cea8e0e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what can be done?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Так что можно сделать?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ab826d0d5faf44d4a7a8a7aad1ef803be005faf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what is branch prediction?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Так что же такое прогноз отрасли?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d285155e760355be2f39c1257c5821d5da261a1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorted:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sorted:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd9c2da2ee8d01be5229516e95ec725d64e3f165" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static/dynamic Branch Prediction&lt;/strong&gt;: Static branch prediction is used by the microprocessor the first time a conditional branch is encountered, and dynamic branch prediction is used for succeeding executions of the conditional branch code.</source>
          <target state="translated">&lt;strong&gt;Статическое / динамическое предсказание ветвления&lt;/strong&gt; : Статическое предсказание ветвления используется микропроцессором при первом обнаружении условного перехода, а динамическое предсказание ветвления используется для последующих выполнений кода условного перехода.</target>
        </trans-unit>
        <trans-unit id="078fac8f79d7e758f85f3007634fdc8cb9777688" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result of this case&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Результат этого дела&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6315a32d6eff633cf664b3192d3c2b8360df6c43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unconditional branches&lt;/strong&gt; - this includes jumps, procedure calls and returns that have no specific condition. For example, an unconditional jump instruction might be coded in assembly language as simply &quot;jmp&quot;, and the instruction stream must immediately be directed to the target location pointed to by the jump instruction, whereas a conditional jump that might be coded as &quot;jmpne&quot; would redirect the instruction stream only if the result of a comparison of two values in a previous &quot;compare&quot; instructions shows the values to not be equal. (The segmented addressing scheme used by the x86 architecture adds extra complexity, since jumps can be either &quot;near&quot; (within a segment) or &quot;far&quot; (outside the segment). Each type has different effects on branch prediction algorithms.)</source>
          <target state="translated">&lt;strong&gt;Безусловные ветви&lt;/strong&gt; - это включает переходы, вызовы процедур и возвраты, которые не имеют особых условий. Например, команда безусловного перехода может быть закодирована на языке ассемблера как просто &amp;laquo;jmp&amp;raquo;, и поток команд должен быть немедленно направлен в целевое местоположение, на которое указывает инструкция перехода, тогда как условный переход, который может быть закодирован как &amp;laquo;jmpne&amp;raquo; будет перенаправлять поток команд только в том случае, если результат сравнения двух значений в предыдущих инструкциях &amp;laquo;сравнения&amp;raquo; показывает, что значения не равны. (Схема сегментированной адресации, используемая архитектурой x86, добавляет дополнительную сложность, поскольку переходы могут быть &amp;laquo;ближними&amp;raquo; (внутри сегмента) или &amp;laquo;дальними&amp;raquo; (вне сегмента). Каждый тип по-разному влияет на алгоритмы прогнозирования ветвлений.)</target>
        </trans-unit>
        <trans-unit id="d1721438d4fa087c689f86212f2138f7505dcb3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unsorted:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Unsorted:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8dfd8a5f8f4a830eea9365b9b460097fbbe4381" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With the Branch:&lt;/strong&gt; There is a huge difference between the sorted and unsorted data.</source>
          <target state="translated">&lt;strong&gt;С Ветвью:&lt;/strong&gt; есть огромная разница между отсортированными и несортированными данными.</target>
        </trans-unit>
        <trans-unit id="03b5fb42d9ac84ced19e05a65a21ee596d5d6f7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With the Hack:&lt;/strong&gt; There is no difference between sorted and unsorted data.</source>
          <target state="translated">&lt;strong&gt;С Хаком:&lt;/strong&gt; нет никакой разницы между отсортированными и несортированными данными.</target>
        </trans-unit>
        <trans-unit id="b16311ddb39aa62e4ad47e876353ac768d1b5d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You are a victim of &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;branch prediction&lt;/a&gt; fail.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вы являетесь жертвой неудачного &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;предсказания ветвлений&lt;/a&gt; .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c786fafb5f8da23c331a0d7afceac4aae6e0c19e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;x64&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;x64&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b2f35b1567a33263e752a9bf7e298fd26bd105c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;x86&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;x86&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56bb00227cc3f2c966ad0c07a94c169bef8507ca" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Note that this hack is not strictly equivalent to the original if-statement. But in this case, it's valid for all the input values of &lt;code&gt;data[]&lt;/code&gt;.)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;(Обратите внимание, что этот хак не является строго эквивалентным исходному оператору if. Но в этом случае он действителен для всех входных значений &lt;code&gt;data[]&lt;/code&gt; .)&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="daf1c2db057b9141218780bbe961c3fb9781bf1a" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;a href=&quot;//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG&quot;&gt;Image&lt;/a&gt; by Mecanismo, via Wikimedia Commons. Used under the &lt;a href=&quot;//creativecommons.org/licenses/by-sa/3.0/deed.en&quot;&gt;CC-By-SA 3.0&lt;/a&gt; license.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;a href=&quot;//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG&quot;&gt;Изображение&lt;/a&gt; Mecanismo, через Wikimedia Commons.&lt;/sub&gt; &lt;sub&gt;Используется по &lt;a href=&quot;//creativecommons.org/licenses/by-sa/3.0/deed.en&quot;&gt;лицензии CC-By-SA 3.0&lt;/a&gt; .&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="85f4f86517c13577daac8db1438bfa704a81d1f5" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;strong&gt;bad&lt;/strong&gt;&amp;rdquo; true-false pattern can make an &lt;code&gt;if&lt;/code&gt;-statement up to six times slower than a &amp;ldquo;&lt;strong&gt;good&lt;/strong&gt;&amp;rdquo; pattern! Of course, which pattern is good and which is bad depends on the exact instructions generated by the compiler and on the specific processor.</source>
          <target state="translated">&amp;laquo; &lt;strong&gt;Плохой&lt;/strong&gt; &amp;raquo; истинно-ложный паттерн может сделать &lt;code&gt;if&lt;/code&gt; - утверждение в шесть раз медленнее, чем &amp;laquo; &lt;strong&gt;хороший&lt;/strong&gt; &amp;raquo; паттерн! Конечно, какой шаблон хорош, а какой плох, зависит от точных инструкций, сгенерированных компилятором, и от конкретного процессора.</target>
        </trans-unit>
        <trans-unit id="fa9002e4deffeb589b075bfcdf8a5cf9a18e318c" translate="yes" xml:space="preserve">
          <source>A branch instruction can cause a computer to begin executing a different instruction sequence and thus deviate from its default behavior of executing instructions in order (i.e. if the expression is false, the program skips the code of the &lt;code&gt;if&lt;/code&gt; block) depending on some condition, which is the expression evaluation in our case.</source>
          <target state="translated">Инструкция ветвления может заставить компьютер начать выполнение другой последовательности команд и, таким образом, отклоняться от своего поведения по умолчанию при выполнении инструкций в порядке (т. Е. Если выражение ложно, программа пропускает код блока &lt;code&gt;if&lt;/code&gt; ) в зависимости от некоторого условия, которое является оценкой выражения в нашем случае.</target>
        </trans-unit>
        <trans-unit id="dea845d0a945ad214f5fefb6c4b0e6c1e6051bc4" translate="yes" xml:space="preserve">
          <source>A branch predictor is one of the ancient performance improving techniques which still finds relevance into modern architectures. While the simple prediction techniques provide fast lookup and power efficiency they suffer from a high misprediction rate.</source>
          <target state="translated">Отраслевой прогноз-одна из древнейших методик повышения производительности,которая до сих пор находит применение в современной архитектуре.В то время как простые техники прогнозирования обеспечивают быстрый поиск и энергоэффективность,они страдают от высокой скорости ошибочного прогнозирования.</target>
        </trans-unit>
        <trans-unit id="37fb85f91b43ff03464a3ace5cd03f2e7b1d689f" translate="yes" xml:space="preserve">
          <source>A common way to eliminate branch prediction that I've found to work particularly good in managed languages is a table lookup instead of using a branch (although I haven't tested it in this case).</source>
          <target state="translated">Обычный способ устранить предсказание ветки,который,как мне кажется,особенно хорошо работает в управляемых языках,-это поиск по таблицам вместо использования ветки (хотя в данном случае я его не тестировал).</target>
        </trans-unit>
        <trans-unit id="2d5382f7f97d599d6c1c60ae36b7533c1e391142" translate="yes" xml:space="preserve">
          <source>A general rule of thumb is to avoid data-dependent branching in critical loops (such as in this example).</source>
          <target state="translated">Общее правило заключается в том,чтобы избежать зависящих от данных ветвлений в критических циклах (как в данном примере).</target>
        </trans-unit>
        <trans-unit id="2a0c61937b135599b6110466d59da1b10f3e69cc" translate="yes" xml:space="preserve">
          <source>A yet faster approach, that gives an &lt;strong&gt;approximate&lt;/strong&gt; solution for both sorted or unsorted is: &lt;code&gt;sum= 3137536;&lt;/code&gt; (assuming a truly uniform distribution, 16384 samples with expected value 191.5) &lt;strong&gt;:-)&lt;/strong&gt;</source>
          <target state="translated">Еще более быстрый подход, который дает &lt;strong&gt;приблизительное&lt;/strong&gt; решение как для отсортированных, так и для несортированных: &lt;code&gt;sum= 3137536;&lt;/code&gt; (при условии действительно равномерного распределения, 16384 выборки с ожидаемым значением 191,5) &lt;strong&gt;:-)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f443462e3c594cabbf5f71234fac4ceb6009a988" translate="yes" xml:space="preserve">
          <source>All the elements are greater than 128</source>
          <target state="translated">Все элементы более 128</target>
        </trans-unit>
        <trans-unit id="60b7feee5533f80829de14d53e01cb5cd2f55c48" translate="yes" xml:space="preserve">
          <source>All the elements are less than 128</source>
          <target state="translated">Все элементы менее 128</target>
        </trans-unit>
        <trans-unit id="0529f5c0c9474ccd9e39a30f16e35b00bb471784" translate="yes" xml:space="preserve">
          <source>Also I want to cite &lt;a href=&quot;https://stackoverflow.com/users/16940/simon-weaver&quot;&gt;@Simon_Weaver&lt;/a&gt; from the comments:</source>
          <target state="translated">Также я хочу процитировать &lt;a href=&quot;https://stackoverflow.com/users/16940/simon-weaver&quot;&gt;@Simon_Weaver&lt;/a&gt; из комментариев:</target>
        </trans-unit>
        <trans-unit id="fed9e7e89414aa4f62ee84308b32e6df6a42784c" translate="yes" xml:space="preserve">
          <source>Also at the end, it's good to know we have two kinds of branch predictions that each is going to affect your code differently:</source>
          <target state="translated">Также в конце,приятно знать,что у нас есть два вида предсказаний ветвей,каждый из которых будет по-разному влиять на ваш код:</target>
        </trans-unit>
        <trans-unit id="118e6e8352ef9219f30b284c2eec943d64cac174" translate="yes" xml:space="preserve">
          <source>Alternatively, on Linux you can use the performance counters subsystem to accomplish the same task, but with native performance using CPU counters.</source>
          <target state="translated">Кроме того,на Linux вы можете использовать подсистему счетчиков производительности для выполнения той же задачи,но с собственной производительностью с помощью счетчиков процессора.</target>
        </trans-unit>
        <trans-unit id="407d8227038ebf4c70f4b17f8cbd8db2e0cf6ac0" translate="yes" xml:space="preserve">
          <source>Although both the roads reach the same destination, the straight road is shorter, and the other is longer. If then you choose the other by mistake, there is no turning back, and so you will waste some extra time if you choose the longer road. This is similar to what happens in the computer, and I hope this helped you understand better.</source>
          <target state="translated">Хотя обе дороги достигают одного и того же пункта назначения,прямая дорога короче,а другая длиннее.Если вы выбрали другую дорогу по ошибке,обратного пути нет,и поэтому вы потратите некоторое дополнительное время,если вы выберете более длинную дорогу.Это похоже на то,что происходит в компьютере,и я надеюсь,что это помогло вам лучше понять.</target>
        </trans-unit>
        <trans-unit id="72b615d954c685d03dbd988b02705d36339eea5d" translate="yes" xml:space="preserve">
          <source>An official answer would be from</source>
          <target state="translated">Официальный ответ будет от</target>
        </trans-unit>
        <trans-unit id="e16854241a2d65fb883d369651da41390d02fcc0" translate="yes" xml:space="preserve">
          <source>Another reason is that when the vector is already sorted, we never need to move elements to their correct position. The effect of these little details is the factor of five or six that we saw.</source>
          <target state="translated">Другая причина заключается в том,что когда вектор уже отсортирован,нам никогда не нужно перемещать элементы в их правильное положение.Эффект от этих маленьких деталей-фактор пять или шесть,которые мы видели.</target>
        </trans-unit>
        <trans-unit id="18b72662db383a9f75e385af80ee82d4f1ad5ed5" translate="yes" xml:space="preserve">
          <source>Any instruction is broken into a sequence of steps so that different steps can be executed concurrently in parallel. This technique is known as instruction pipeline and this is used to increase throughput in modern processors. To understand this better please see this &lt;a href=&quot;https://en.wikipedia.org/wiki/Pipeline_(computing)#Concept_and_motivation&quot;&gt;example on Wikipedia&lt;/a&gt;.</source>
          <target state="translated">Любая инструкция разбита на последовательность шагов, так что разные шаги могут выполняться параллельно параллельно. Этот метод известен как конвейер команд и используется для увеличения пропускной способности современных процессоров. Чтобы лучше это понять, посмотрите этот &lt;a href=&quot;https://en.wikipedia.org/wiki/Pipeline_(computing)#Concept_and_motivation&quot;&gt;пример в Википедии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcb1019315b39b373530b7c1baab0d26a3114719" translate="yes" xml:space="preserve">
          <source>Articles in scientific publications: T.Y. Yeh, Y.N. Patt made a lot of these on branch predictions.</source>
          <target state="translated">Статьи в научных публикациях:Т.Я.Да,Ю.Н.Патт много таких статей делал на отраслевых прогнозах.</target>
        </trans-unit>
        <trans-unit id="0a92cf5f4b626666fbf175648e0a6f274113a6f6" translate="yes" xml:space="preserve">
          <source>As a result of waiting for the result of instruction A, the total CPU cycles spent in the above case (without branch prediction; for both true and false) is 7.</source>
          <target state="translated">В результате ожидания результата команды А,общее количество циклов,потраченных CPU в вышеуказанном случае (без прогнозирования ветви;как для верной,так и для ложной)составляет 7.</target>
        </trans-unit>
        <trans-unit id="91b190f8f20d90d506eb2a535168aaeb504cbac3" translate="yes" xml:space="preserve">
          <source>As data is distributed between 0 and 255 when the array is sorted, around the first half of the iterations will not enter the &lt;code&gt;if&lt;/code&gt;-statement (the &lt;code&gt;if&lt;/code&gt; statement is shared below).</source>
          <target state="translated">Поскольку данные распределяются между 0 и 255 при сортировке массива, примерно в первой половине итераций не будет введено условие if (оператор &lt;code&gt;if&lt;/code&gt; используется ниже).</target>
        </trans-unit>
        <trans-unit id="cb7653dba96134a9f8b8386b70f0dd6cac24bb0a" translate="yes" xml:space="preserve">
          <source>As hinted from above, the culprit is this if-statement:</source>
          <target state="translated">Как намекнули сверху,преступник-это &quot;если&quot;:</target>
        </trans-unit>
        <trans-unit id="485df5143cbc2b24d62743d36ee8956b76546eb1" translate="yes" xml:space="preserve">
          <source>As what has already been mentioned by others, what behind the mystery is &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Branch Predictor&lt;/a&gt;.</source>
          <target state="translated">Как и то, что уже было упомянуто другими, то, что скрывается за тайной, - это &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;предсказатель отрасли&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b08e517362c42b5803f28e7adc40496f99cf8e9" translate="yes" xml:space="preserve">
          <source>As you can see, it seems we don't have a reason not to use Branch Predictor.</source>
          <target state="translated">Как видите,похоже,у нас нет причин не использовать Бранч Предиктор.</target>
        </trans-unit>
        <trans-unit id="4f55d0a62def8f894343508ecf5fe4ae7cfbc922" translate="yes" xml:space="preserve">
          <source>At least the phenomenon is real with this compiler, standard library, and optimizer settings. Different implementations can and do give different answers. In fact, someone did do a more systematic study (a quick web search will find it) and most implementations show that effect.</source>
          <target state="translated">По крайней мере,с этим компилятором,стандартной библиотекой и настройками оптимизатора это явление реально.Различные реализации могут давать и дают разные ответы.На самом деле,кто-то сделал более систематическое исследование (быстрый веб-поиск найдет его),и большинство реализаций показывают этот эффект.</target>
        </trans-unit>
        <trans-unit id="fd41bc2c6095914eb987318731cbb8136aa88df0" translate="yes" xml:space="preserve">
          <source>Based on the described scenario, I have written an animation demo to show how instructions are executed in a pipeline in different situations.</source>
          <target state="translated">На основе описанного сценария я написал анимационную демонстрацию,чтобы показать,как выполняются инструкции в трубопроводе в различных ситуациях.</target>
        </trans-unit>
        <trans-unit id="f227c3a03a7731e12cfd0e90cd5a61346155ae8b" translate="yes" xml:space="preserve">
          <source>Based on this, it looks MATLAB is almost &lt;em&gt;175 times&lt;/em&gt; slower than the C implementation without sorting and &lt;em&gt;350 times&lt;/em&gt; slower with sorting. In other words, the effect (of branch prediction) is &lt;em&gt;1.46x&lt;/em&gt; for MATLAB implementation and &lt;em&gt;2.7x&lt;/em&gt; for the C implementation.</source>
          <target state="translated">Исходя из этого, выглядит, что MATLAB почти в &lt;em&gt;175 раз&lt;/em&gt; медленнее, чем реализация C без сортировки, и в &lt;em&gt;350 раз&lt;/em&gt; медленнее с сортировкой. Другими словами, эффект (прогнозирования ветвлений) составляет &lt;em&gt;1.46x&lt;/em&gt; для реализации MATLAB и &lt;em&gt;2.7x&lt;/em&gt; для реализации C.</target>
        </trans-unit>
        <trans-unit id="7f0b96f3c9bc5eedd14fbfce8ae4e5637fcd2f88" translate="yes" xml:space="preserve">
          <source>Besides the fact that the branch prediction may slow you down, a sorted array has another advantage:</source>
          <target state="translated">Кроме того,что предсказание ветки может замедлить работу,у отсортированного массива есть еще одно преимущество:</target>
        </trans-unit>
        <trans-unit id="cbfea8990261f42832136208062c8c674500cbb0" translate="yes" xml:space="preserve">
          <source>Books: J.L. Hennessy, D.A. Patterson: Computer architecture: a quantitative approach</source>
          <target state="translated">Книги:Джей Л.Хеннесси,окружной прокурор Паттерсон:Архитектура компьютера:количественный подход</target>
        </trans-unit>
        <trans-unit id="829b3fb58a7b85f64a37f8e20d7ec7596c0db7f0" translate="yes" xml:space="preserve">
          <source>Boolean variables are overdetermined in the sense that all operators that have Boolean variables as input check if the inputs have any other value than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, but operators that have Booleans as output can produce no other value than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. This makes operations with Boolean variables as input less efficient than necessary.
Consider example:</source>
          <target state="translated">Булевы переменные переопределены в том смысле, что все операторы, которые имеют булевы переменные в качестве входных данных, проверяют, имеют ли входные значения любое другое значение, кроме &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;1&lt;/code&gt; , но операторы, которые имеют логические переменные в качестве выходных данных, не могут производить никаких других значений, кроме &lt;code&gt;0&lt;/code&gt; или &lt;code&gt;1&lt;/code&gt; . Это делает операции с булевыми переменными в качестве входных данных менее эффективными, чем необходимо. Рассмотрим пример:</target>
        </trans-unit>
        <trans-unit id="0f586453c8b155549182d123a0dddc7e7cafdb04" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;likely()&lt;/code&gt; and &lt;code&gt;unlikely()&lt;/code&gt; are in fact macros that are defined by using something like the GCC's &lt;code&gt;__builtin_expect&lt;/code&gt; to help the compiler insert prediction code to favour the condition taking into account the information provided by the user. GCC supports other builtins that could change the behavior of the running program or emit low level instructions like clearing the cache, etc. See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html&quot;&gt;this documentation&lt;/a&gt; that goes through the available GCC's builtins.</source>
          <target state="translated">И &lt;code&gt;likely()&lt;/code&gt; и &lt;code&gt;unlikely()&lt;/code&gt; на самом деле являются макросами, которые определяются с помощью чего-то вроде &lt;code&gt;__builtin_expect&lt;/code&gt; GCC, чтобы помочь компилятору вставить код предсказания для поддержки условия с учетом информации, предоставленной пользователем. GCC поддерживает другие встроенные функции, которые могут изменить поведение работающей программы или выдавать низкоуровневые инструкции, такие как очистка кэша и т. Д. См. &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html&quot;&gt;Эту документацию,&lt;/a&gt; которая просматривает доступные встроенные функции GCC.</target>
        </trans-unit>
        <trans-unit id="e3be8498fb9bc40fab8d29adec6459c84941f461" translate="yes" xml:space="preserve">
          <source>Branch prediction is essentially an optimization (minimization) problem where the emphasis is on to achieve lowest possible miss rate, low power consumption, and low complexity with minimum resources.</source>
          <target state="translated">Прогнозирование отрасли,по сути,является проблемой оптимизации (минимизации),где упор делается на достижение минимально возможного пропуска,низкого энергопотребления и низкой сложности при минимальных ресурсах.</target>
        </trans-unit>
        <trans-unit id="ce09fc1b6a54ba26385b7dcf3dc61b849d981bdb" translate="yes" xml:space="preserve">
          <source>Branch prediction: Guessing/predicting which road is straight and following it without checking</source>
          <target state="translated">Прогноз отделения:Угадывание,какая дорога прямая,и следование по ней без проверки...</target>
        </trans-unit>
        <trans-unit id="bf6354b6953e28aa0b0401d2ab4cdf0bab9f9a80" translate="yes" xml:space="preserve">
          <source>Branch predictor will try to guess which way a branch (an if-then-else structure) will go before this is known for sure. It will not wait for the instruction A to reach the EX stage of the pipeline, but it will guess the decision and go to that instruction (B or C in case of our example).</source>
          <target state="translated">Предсказатель ветки попытается угадать,в какую сторону пойдет ветка (структура if-then-else),прежде чем это станет известно наверняка.Он не будет ждать,пока инструкция A дойдет до EX-стадии трубопровода,но угадает решение и перейдет к этой инструкции (B или C в случае нашего примера).</target>
        </trans-unit>
        <trans-unit id="167e8ac318227dcb55522a65e67d450259397b78" translate="yes" xml:space="preserve">
          <source>But in case of a random unsorted array, the prediction will need to discard the partially executed instructions and start over with the correct branch most of the time and result in more CPU cycles compared to the sorted array.</source>
          <target state="translated">Но в случае случайного несортированного массива прогноз должен будет отказаться от частично выполненных инструкций и большую часть времени начинать все сначала с правильной веткой,что приведет к большему количеству циклов процессора по сравнению с отсортированным массивом.</target>
        </trans-unit>
        <trans-unit id="dbc576af53dd6fb3f0dc64893d4fed7f4cc4366f" translate="yes" xml:space="preserve">
          <source>But in my testing, an explicit lookup table was slightly faster than this, probably because indexing into a lookup table was slightly faster than bit shifting.  This shows how my code sets up and uses the lookup table (unimaginatively called &lt;code&gt;lut&lt;/code&gt; for &quot;LookUp Table&quot; in the code).  Here's the C++ code:</source>
          <target state="translated">Но в моем тестировании явная таблица поиска была немного быстрее, чем эта, вероятно, потому что индексирование в таблицу поиска было немного быстрее, чем битовое смещение. Это показывает, как мой код настраивает и использует таблицу поиска (в &lt;code&gt;lut&lt;/code&gt; невообразимо называемую lut для таблицы поиска). Вот код C ++:</target>
        </trans-unit>
        <trans-unit id="556743da1a16719ba282399e5ea0e47a985396e0" translate="yes" xml:space="preserve">
          <source>But in my testing, an explicit lookup table was slightly faster than this, probably because indexing into a lookup table was slightly faster than bit shifting. This shows how my code sets up and uses the lookup table (unimaginatively called lut for &quot;LookUp Table&quot; in the code). Here's the C++ code:</source>
          <target state="translated">Но в моем тестировании явная таблица поиска была немного быстрее,вероятно,потому что индексация в таблицу поиска была немного быстрее,чем смещение битов.Это показывает,как мой код настраивает и использует таблицу поиска (невообразимо называемую в коде lut для &quot;LookUp Table&quot;).Вот код на Си++:</target>
        </trans-unit>
        <trans-unit id="a09b475c5d193e2a2ef480d8477ce7319209e1cd" translate="yes" xml:space="preserve">
          <source>But in this case, we know values are in the range [0, 255] and we only care about values &amp;gt;= 128. That means we can easily extract a single bit that will tell us whether we want a value or not: by shifting the data to the right 7 bits, we are left with a 0 bit or a 1 bit, and we only want to add the value when we have a 1 bit. Let's call this bit the &quot;decision bit&quot;.</source>
          <target state="translated">Но в этом случае мы знаем, что значения находятся в диапазоне [0, 255], и мы заботимся только о значениях&amp;gt; = 128. Это означает, что мы можем легко извлечь единственный бит, который скажет нам, хотим ли мы значение или нет: сдвигая данные справа 7 бит, у нас осталось 0 бит или 1 бит, и мы хотим добавить значение только тогда, когда у нас есть 1 бит. Давайте назовем этот бит &amp;laquo;битом решения&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="58cee47e25522bb2e607e044796956fc2d95746f" translate="yes" xml:space="preserve">
          <source>By using the 0/1 value of the decision bit as an index into an array, we can make code that will be equally fast whether the data is sorted or not sorted. Our code will always add a value, but when the decision bit is 0, we will add the value somewhere we don't care about. Here's the code:</source>
          <target state="translated">Используя значение 01 бита решения в качестве индекса в массиве,можно сделать код,который будет одинаково быстрым вне зависимости от того,сортируются данные или нет.Наш код всегда будет добавлять значение,но когда бит решения равен 0,мы будем добавлять значение где-то,где нас это не волнует.Вот код:</target>
        </trans-unit>
        <trans-unit id="56bb3ef2fb6bcc14eb09093062d52086eb734f83" translate="yes" xml:space="preserve">
          <source>C++ - Visual Studio 2010 - x64 Release</source>
          <target state="translated">C++-Visual Studio 2010-релиз x64</target>
        </trans-unit>
        <trans-unit id="907dc42739003087cf41fc698a5aef43e56b2716" translate="yes" xml:space="preserve">
          <source>Consider a railroad junction:</source>
          <target state="translated">Рассмотрим железнодорожный узел:</target>
        </trans-unit>
        <trans-unit id="0008f55380e54b1390ff08936a649b5378e8d33b" translate="yes" xml:space="preserve">
          <source>Drilling down into the line-by-line output produced by &lt;code&gt;cg_annotate&lt;/code&gt; we see for the loop in question:</source>
          <target state="translated">&lt;code&gt;cg_annotate&lt;/code&gt; построчном выводе, произведенном cg_annotate, мы видим для рассматриваемого цикла:</target>
        </trans-unit>
        <trans-unit id="e84c032993f25d05ec7cbf44965cf42d501894a7" translate="yes" xml:space="preserve">
          <source>EX -- Execute the instruction</source>
          <target state="translated">EX --Выполнить инструкцию</target>
        </trans-unit>
        <trans-unit id="91b7378edbcc8a2dcbc0578b242232b9f0edf9c0" translate="yes" xml:space="preserve">
          <source>Each element in the original code is a random value</source>
          <target state="translated">Каждый элемент в исходном коде представляет собой случайную величину</target>
        </trans-unit>
        <trans-unit id="5b31068fcc3d6c11d6243f6f58c031a60e4fe724" translate="yes" xml:space="preserve">
          <source>Fortunately for us, if the memory access pattern is predictable, the processor will load it in its fast cache and all is well.</source>
          <target state="translated">К счастью для нас,если шаблон доступа к памяти предсказуем,процессор загрузит его в быстрый кэш,и все будет хорошо.</target>
        </trans-unit>
        <trans-unit id="96d1b40b361ab03cd656fc01b084e5d379dd61ce" translate="yes" xml:space="preserve">
          <source>Frequently used Boolean operations in C++ produce many branches in the compiled program. If these branches are inside loops and are hard to predict they can slow down execution significantly. Boolean variables are stored as 8-bit integers with the value &lt;code&gt;0&lt;/code&gt; for &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Часто используемые логические операции в C ++ создают много веток в скомпилированной программе. Если эти ветви находятся внутри циклов и их трудно предсказать, они могут значительно замедлить выполнение. Булевы переменные хранятся в виде 8-битных целых чисел со значением &lt;code&gt;0&lt;/code&gt; для &lt;code&gt;false&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; для &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbb5582021303c8d664e2d578e2f2f31b983748c" translate="yes" xml:space="preserve">
          <source>From a processor perspective, your memory is slow. To compensate for the difference in speed, a couple of caches are built into your processor (L1/L2 cache). So imagine that you're doing your nice calculations and figure out that you need a piece of memory. The processor will get its 'load' operation and loads the piece of memory into cache -- and then uses the cache to do the rest of the calculations. Because memory is relatively slow, this 'load' will slow down your program.</source>
          <target state="translated">С точки зрения процессора,ваша память работает медленно.Чтобы компенсировать разницу в скорости,в процессор встроено несколько кэшей (L1L2 кэш).Так что представьте,что вы делаете свои приятные вычисления и выясните,что вам нужен кусок памяти.Процессор получит свою &quot;загрузочную&quot; операцию и загрузит фрагмент памяти в кэш --а затем использует кэш для выполнения остальных вычислений.Так как память относительно медленная,эта 'нагрузка' замедлит работу Вашей программы.</target>
        </trans-unit>
        <trans-unit id="a69eb648a593eb899c67ee00a5913154aebeadb2" translate="yes" xml:space="preserve">
          <source>Further reading: &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;&quot;Branch predictor&quot; article on Wikipedia&lt;/a&gt;.</source>
          <target state="translated">Дальнейшее чтение: &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;статья &amp;laquo;Ветка предиктора&amp;raquo; в Википедии&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cb4ec23cd0f11546771882b0c409bbbd82fc5ea" translate="yes" xml:space="preserve">
          <source>GCC 4.6.1 with &lt;code&gt;-O3&lt;/code&gt; or &lt;code&gt;-ftree-vectorize&lt;/code&gt; on x64 is able to generate a conditional move. So there is no difference between the sorted and unsorted data - both are fast.</source>
          <target state="translated">GCC 4.6.1 с &lt;code&gt;-O3&lt;/code&gt; или &lt;code&gt;-ftree-vectorize&lt;/code&gt; на x64 может генерировать условное перемещение. Таким образом, нет никакой разницы между отсортированными и несортированными данными - оба быстры.</target>
        </trans-unit>
        <trans-unit id="f53bd842ecd4d4a9f495f435523c9cf23aa6a57c" translate="yes" xml:space="preserve">
          <source>Generally, modern processors have quite long pipelines, but for ease let's consider these 4 steps only.</source>
          <target state="translated">Вообще,современные процессоры имеют достаточно длинные трубопроводы,но для простоты рассмотрим только эти 4 этапа.</target>
        </trans-unit>
        <trans-unit id="38465cba940858cd4732031697c429623f9115b7" translate="yes" xml:space="preserve">
          <source>Here are the timings of the loop with different true-false patterns:</source>
          <target state="translated">Здесь приведены тайминги цикла с различными истинно фальшивыми моделями:</target>
        </trans-unit>
        <trans-unit id="6a74c4bde413f0664d97478a9af05dc6dec1968a" translate="yes" xml:space="preserve">
          <source>Here is a piece of C++ code that shows some very peculiar behavior. For some strange reason, sorting the data miraculously makes the code almost six times faster:</source>
          <target state="translated">Вот кусок Си++кода,который показывает очень своеобразное поведение.По какой-то странной причине чудесная сортировка данных делает код почти в шесть раз быстрее:</target>
        </trans-unit>
        <trans-unit id="9540c640283f5095fcffbc3e62196fc4a354f281" translate="yes" xml:space="preserve">
          <source>Here's a link to this code: &lt;a href=&quot;http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx&quot;&gt;Red Black Trees&lt;/a&gt;, &lt;em&gt;Eternally Confuzzled&lt;/em&gt;</source>
          <target state="translated">Вот ссылка на этот код: &lt;a href=&quot;http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx&quot;&gt;Красные черные деревья&lt;/a&gt; , &lt;em&gt;вечно сбитые с толку&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65bc35b8db256ec9378ffd563e6d314c0f419d53" translate="yes" xml:space="preserve">
          <source>However, when the data is completely random, the branch predictor is rendered useless, because it can't predict random data. Thus there will probably be around 50% misprediction (no better than random guessing).</source>
          <target state="translated">Однако,когда данные полностью случайны,предсказатель ветви становится бесполезным,так как не может предсказать случайные данные.Таким образом,вероятно,произойдет около 50%-ная ошибка в предсказании (не лучше,чем случайное предположение).</target>
        </trans-unit>
        <trans-unit id="923101f6e2254ddc269c719e6877f55af0932907" translate="yes" xml:space="preserve">
          <source>I just read up on this question and its answers, and I feel an answer is missing.</source>
          <target state="translated">Я только что прочитал этот вопрос и ответы на него,и чувствую,что ответа не хватает.</target>
        </trans-unit>
        <trans-unit id="6155d3cc9d0a0b68582ccdde2e81aba3a8812eb0" translate="yes" xml:space="preserve">
          <source>I ran that a few times to be sure. Yes, the phenomenon is real. My key code was:</source>
          <target state="translated">Я пробежался по этому несколько раз,чтобы быть уверенным.Да,феномен реальный.Мой код ключа был:</target>
        </trans-unit>
        <trans-unit id="411b77367cb6a07a9e121aa06f74b175e40b6fd6" translate="yes" xml:space="preserve">
          <source>I tried the same code with MATLAB 2011b with my MacBook Pro (Intel i7, 64 bit, 2.4 GHz) for the following MATLAB code:</source>
          <target state="translated">Я пробовал тот же код с MATLAB 2011b с моим MacBook Pro (Intel i7,64 бит,2,4 ГГц)для следующего кода MATLAB:</target>
        </trans-unit>
        <trans-unit id="51e91a54cf2fc822fbf81bdee0af955af2b6ea97" translate="yes" xml:space="preserve">
          <source>I'm not trying to add something but explaining the concept in another way. 
There is a concise introduction on the wiki which contains text and diagram.
I do like the explanation below which uses a diagram to elaborate the Branch Predictor intuitively.</source>
          <target state="translated">Я не пытаюсь что-то добавить,но объясняю концепцию по-другому.Есть краткое введение в вики,содержащее текст и диаграмму.Мне действительно нравится объяснение ниже,которое использует диаграмму для интуитивной разработки Branch Predictor.</target>
        </trans-unit>
        <trans-unit id="065592acf6ecacc9b012a59339edcc7416aa6239" translate="yes" xml:space="preserve">
          <source>ID -- Decode the instruction</source>
          <target state="translated">ID --Декодируйте инструкцию</target>
        </trans-unit>
        <trans-unit id="42c1b1564597619cb2c77349430882a2580c741c" translate="yes" xml:space="preserve">
          <source>IF -- Fetch the instruction from memory</source>
          <target state="translated">ЕСЛИ...Возьмите инструкцию из памяти</target>
        </trans-unit>
        <trans-unit id="88eb4395003cb412e7661165f4ce4cf1f486289e" translate="yes" xml:space="preserve">
          <source>If it is later detected that the guess was wrong then the partially executed instructions are discarded and the pipeline starts over with the correct branch, incurring a delay. 
The time that is wasted in case of a branch misprediction is equal to the number of stages in the pipeline from the fetch stage to the execute stage. Modern microprocessors tend to have quite long pipelines so that the misprediction delay is between 10 and 20 clock cycles. The longer the pipeline the greater the need for a good &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;branch predictor&lt;/a&gt;.</source>
          <target state="translated">Если позднее обнаруживается, что предположение было неверным, то частично выполненные инструкции отбрасываются, и конвейер начинается с правильной ветви, что вызывает задержку. Время, которое теряется в случае ошибочного прогнозирования ветвления, равно числу этапов в конвейере от этапа выборки до этапа выполнения. Современные микропроцессоры, как правило, имеют довольно длинные конвейеры, поэтому задержка неверного прогнозирования составляет от 10 до 20 тактов. Чем длиннее конвейер, тем больше потребность в хорошем &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;предсказателе ветвления&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd7de5e20eb6affc18989173e9a7fbd64cfc3a64" translate="yes" xml:space="preserve">
          <source>If the array is sorted, your condition is false at the first step: &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt;, then becomes a true value for the whole way to the end of the street. That's how you get to the end of the logic faster. On the other hand, using an unsorted array, you need a lot of turning and processing which make your code run slower for sure...</source>
          <target state="translated">Если массив отсортирован, ваше условие ложно на первом шаге: &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; , а затем становится истинным значением для всего пути до конца улицы. Вот так вы быстрее доберетесь до конца логики. С другой стороны, используя несортированный массив, вам нужно много переворачивать и обрабатывать, что наверняка замедлит работу вашего кода ...</target>
        </trans-unit>
        <trans-unit id="56d4fd733b97267a72ee645f98fa635e9b8c6ce9" translate="yes" xml:space="preserve">
          <source>If the compiler isn't able to optimize the branch into a conditional move, you can try some hacks if you are willing to sacrifice readability for performance.</source>
          <target state="translated">Если компилятор не в состоянии оптимизировать ветку в условный ход,можно попробовать несколько взломов,если вы готовы пожертвовать читабельность ради производительности.</target>
        </trans-unit>
        <trans-unit id="1824e7d45369351e72c6eb590133dd9e21d010ed" translate="yes" xml:space="preserve">
          <source>If you are curious about even more optimizations that can be done to this code, consider this:</source>
          <target state="translated">Если вас интересует еще больше оптимизаций,которые можно сделать с этим кодом,подумайте об этом:</target>
        </trans-unit>
        <trans-unit id="5ceebbf643b622dd844b59e8bd85fc4f5ede90be" translate="yes" xml:space="preserve">
          <source>If you give the Intel compiler the branchless code, it just out-right vectorizes it... and is just as fast as with the branch (with the loop interchange).</source>
          <target state="translated">Если дать компилятору Intel код без ветки,то он просто прямо-таки векторизует его...и так же быстро,как и с веткой (с обменом циклами).</target>
        </trans-unit>
        <trans-unit id="ae88c41ed067d722d464020e7a9f55e02d32fddc" translate="yes" xml:space="preserve">
          <source>If you guessed right, it continues on.</source>
          <target state="translated">Если ты правильно угадал,то это продолжается.</target>
        </trans-unit>
        <trans-unit id="bbb6c6bc29b605454dbfe7f8781ef7cdb2c270f2" translate="yes" xml:space="preserve">
          <source>If you guessed right, you continue executing.</source>
          <target state="translated">Если ты правильно угадал,то продолжай казнить.</target>
        </trans-unit>
        <trans-unit id="1898647ae8c929024233a50359541e7af7814ea2" translate="yes" xml:space="preserve">
          <source>If you guessed wrong, the captain will stop, back up, and yell at you to flip the switch. Then it can restart down the other path.</source>
          <target state="translated">Если вы неправильно догадались,капитан остановится,отступит и закричит на вас,чтобы вы перевернули рубильник.Тогда он может перезапуститься по другому пути.</target>
        </trans-unit>
        <trans-unit id="9b46e462a942895bb7f6e7d844e7730c6d70136b" translate="yes" xml:space="preserve">
          <source>If you guessed wrong, you need to flush the pipeline and roll back to the branch. Then you can restart down the other path.</source>
          <target state="translated">Если вы неправильно догадались,нужно смыть трубопровод и откатиться обратно к ветке.Тогда ты можешь перезапуститься по другой дорожке.</target>
        </trans-unit>
        <trans-unit id="23319b8aed03d58e34f2b56f4949401e859e197b" translate="yes" xml:space="preserve">
          <source>If you have ever wondered why ARM has been so phenomenally successful, the brilliant effectiveness and interplay of these two mechanisms are a big part of the story, because they are one of the greatest sources of the ARM architecture's efficiency. The brilliance of the original designers of the ARM ISA back in 1983, Steve Furber and Roger (now Sophie) Wilson, cannot be overstated.</source>
          <target state="translated">Если вы когда-нибудь задумывались,почему ARM был так феноменально успешен,то блестящая эффективность и взаимодействие этих двух механизмов-это большая часть истории,потому что они являются одним из величайших источников эффективности архитектуры ARM.Блеск оригинальных дизайнеров ARM ISA еще в 1983 году,Стива Фюрбера и Роджера (ныне Софи)Уилсона,невозможно переоценить.</target>
        </trans-unit>
        <trans-unit id="20223b3b9842562860c0883dd004a561d3dec19d" translate="yes" xml:space="preserve">
          <source>If you run into trouble with lookups in managed languages -- the key is to add a &lt;code&gt;&amp;amp; 0x[something]FFF&lt;/code&gt; to your lookup function to make the boundary check predictable -- and watch it going faster.</source>
          <target state="translated">Если у вас возникли проблемы с поиском на управляемых языках - ключ заключается в том, чтобы добавить &lt;code&gt;&amp;amp; 0x[something]FFF&lt;/code&gt; к вашей функции поиска, чтобы сделать проверку границ предсказуемой, - и наблюдать, как она идет быстрее.</target>
        </trans-unit>
        <trans-unit id="fcbae46e5b1ed263a398fd8853f1c323c42dd17c" translate="yes" xml:space="preserve">
          <source>If you want to write efficient code, you need to know a bit about machine architecture.</source>
          <target state="translated">Если вы хотите писать эффективный код,вам нужно знать немного о машинной архитектуре.</target>
        </trans-unit>
        <trans-unit id="4906cf640b371d74701a3bb36c48ac95ee90c060" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;C&lt;/code&gt;, thus &lt;code&gt;C++&lt;/code&gt;, the statement, which would compile directly (without any optimization) into the conditional move instruction in &lt;code&gt;x86&lt;/code&gt;, is the ternary operator &lt;code&gt;... ? ... : ...&lt;/code&gt;. So we rewrite the above statement into an equivalent one:</source>
          <target state="translated">В &lt;code&gt;C&lt;/code&gt; , то есть в &lt;code&gt;C++&lt;/code&gt; , оператор, который будет напрямую (без какой-либо оптимизации) компилироваться в инструкцию условного перемещения в &lt;code&gt;x86&lt;/code&gt; , является троичным оператором &lt;code&gt;... ? ... : ...&lt;/code&gt; ...: .... Поэтому мы переписываем приведенное выше утверждение в эквивалентное:</target>
        </trans-unit>
        <trans-unit id="ab040f6c0d47f49db7c9db520be83759c461ffc9" translate="yes" xml:space="preserve">
          <source>In a branch case, the following instruction is determined by the preceding one, so we cannot do pipelining. We have to either wait or predict.</source>
          <target state="translated">В случае с ответвлением,следующая инструкция определяется предыдущей,поэтому мы не можем выполнить трубопроводную обвязку.Мы должны либо ждать,либо предсказывать.</target>
        </trans-unit>
        <trans-unit id="0025791b5e0267a182817044a5ed2c8007195575" translate="yes" xml:space="preserve">
          <source>In a conditional move case, the execution conditional move instruction is divided into several stages, but the earlier stages like &lt;code&gt;Fetch&lt;/code&gt; and &lt;code&gt;Decode&lt;/code&gt; does not depend on the result of the previous instruction; only latter stages need the result. Thus, we wait a fraction of one instruction's execution time. This is why the conditional move version is slower than the branch when prediction is easy.</source>
          <target state="translated">В случае условного перемещения выполнение команды условного перемещения делится на несколько этапов, но более ранние этапы, такие как &lt;code&gt;Fetch&lt;/code&gt; и &lt;code&gt;Decode&lt;/code&gt; , не зависят от результата предыдущей инструкции; только последние стадии нуждаются в результате. Таким образом, мы ждем часть времени выполнения одной инструкции. Вот почему версия условного перемещения медленнее, чем ветвь, когда предсказание легко.</target>
        </trans-unit>
        <trans-unit id="79ae345e2bd1b8124d296ba39b3ea113c5193f48" translate="yes" xml:space="preserve">
          <source>In a typical &lt;code&gt;x86&lt;/code&gt; processor, the execution of an instruction is divided into several stages. Roughly, we have different hardware to deal with different stages. So we do not have to wait for one instruction to finish to start a new one. This is called &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Pipeline_%28computing%29&quot;&gt;pipelining&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">В типичном процессоре &lt;code&gt;x86&lt;/code&gt; выполнение инструкции делится на несколько этапов. Грубо говоря, у нас разные аппаратные средства для разных этапов. Поэтому нам не нужно ждать окончания одной инструкции, чтобы начать новую. Это называется &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Pipeline_%28computing%29&quot;&gt;конвейерной обработкой&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0a827bd7aeac65573a68ed989955da0af9f32542" translate="yes" xml:space="preserve">
          <source>In addition to this, in complex prediction techniques the time taken to predict the branches is itself very high &amp;ndash;ranging from 2 to 5 cycles &amp;ndash;which is comparable to the execution time of actual branches.</source>
          <target state="translated">В дополнение к этому, в сложных методах прогнозирования время, затрачиваемое на прогнозирование ветвей, само по себе очень велико - в диапазоне от 2 до 5 циклов - что сравнимо со временем выполнения фактических ветвей.</target>
        </trans-unit>
        <trans-unit id="0fa50c75a9a67268a4a229ac38ceeff7cb07714a" translate="yes" xml:space="preserve">
          <source>In all these cases the failure will be too less in number and as a result, only a few times it will need to discard the partially executed instructions and start over with the correct branch, resulting in fewer CPU cycles.</source>
          <target state="translated">Во всех этих случаях количество отказов будет слишком малым,в результате чего потребуется лишь несколько раз отказаться от частично выполненных инструкций и начать все сначала с правильной ветки,что приведет к меньшему количеству циклов работы процессора.</target>
        </trans-unit>
        <trans-unit id="fa58046848c4821f342e1d54d795534223e063ff" translate="yes" xml:space="preserve">
          <source>In an unsorted array, the computer makes multiple predictions, leading to an increased chance of errors.
Whereas, in a sorted array, the computer makes fewer predictions, reducing the chance of errors.
Making more predictions requires more time.</source>
          <target state="translated">В несортированном массиве компьютер делает несколько прогнозов,что приводит к увеличению вероятности ошибок.В то время как в отсортированном массиве компьютер делает меньше прогнозов,что снижает вероятность ошибок.Для составления большего количества прогнозов требуется больше времени.</target>
        </trans-unit>
        <trans-unit id="d548e9f8042a97cedfb594f9ea9edf3b28dedc70" translate="yes" xml:space="preserve">
          <source>In computer architecture, a branch predictor is a
  digital circuit that tries to guess which way a branch (e.g. an
  if-then-else structure) will go before this is known for sure. The
  purpose of the branch predictor is to improve the flow in the
  instruction pipeline. Branch predictors play a critical role in
  achieving high effective performance in many modern pipelined
  microprocessor architectures such as x86.</source>
          <target state="translated">В компьютерной архитектуре предсказатель ветви-это цифровая цепь,которая пытается угадать,в какую сторону пойдет ветвь (например,структура if-then-else),прежде чем это станет известно наверняка.Назначение предиктора ветви состоит в том,чтобы улучшить поток в учебном трубопроводе.Предсказатели ветвей играют важную роль в достижении высокой эффективной производительности во многих современных архитектурах микропроцессоров,таких как x86.</target>
        </trans-unit>
        <trans-unit id="286bceae83a4fe4b1c8bf9719f0595eb063192a3" translate="yes" xml:space="preserve">
          <source>In order to effectively write your code to take advantage of these
  rules, when writing &lt;strong&gt;if-else&lt;/strong&gt; or &lt;strong&gt;switch&lt;/strong&gt; statements, check the most
  common cases first and work progressively down to the least common.
  Loops do not necessarily require any special ordering of code for
  static branch prediction, as only the condition of the loop iterator
  is normally used.</source>
          <target state="translated">Чтобы эффективно написать свой код, чтобы воспользоваться этими правилами, при написании операторов &lt;strong&gt;if-else&lt;/strong&gt; или &lt;strong&gt;switch&lt;/strong&gt; сначала проверьте наиболее распространенные случаи и постепенно переходите к наименее распространенным. Циклы не обязательно требуют какого-либо специального упорядочения кода для статического предсказания ветвления, поскольку обычно используется только условие итератора цикла.</target>
        </trans-unit>
        <trans-unit id="ecaad1e9fa8c85b19d9f8a2205db2cbf9519dd8c" translate="yes" xml:space="preserve">
          <source>In the C++ case, the hack is actually a tad slower than with the branch when the data is sorted.</source>
          <target state="translated">В случае с C++взлом на самом деле происходит немного медленнее,чем в случае с веткой,когда данные отсортированы.</target>
        </trans-unit>
        <trans-unit id="27ce65e9b9e70aa80a48ce10e7dd18a40e62a14f" translate="yes" xml:space="preserve">
          <source>In the OP's code, the first time when the conditional, the branch predictor does not have any information to base up prediction, so the first time it will randomly choose the next instruction. Later in the for loop, it can base the prediction on the history. 
For an array sorted in ascending order, there are three possibilities:</source>
          <target state="translated">В коде ОП,в первый раз,когда условие,предиктор ветви не имеет никакой информации для базирования предсказания,поэтому в первый раз он случайным образом выберет следующую инструкцию.Позже в цикле for он может основывать предсказание на истории.Для массива,отсортированного по возрастанию,существует три возможности:</target>
        </trans-unit>
        <trans-unit id="cfb2e6fc90f9bfd7c318bca3b56e7b9b3254c2b4" translate="yes" xml:space="preserve">
          <source>In the same line (I think this was not highlighted by any answer) it's good to mention that sometimes (specially in software where the performance matters&amp;mdash;like in the Linux kernel) you can find some if statements like the following:</source>
          <target state="translated">В той же строке (я думаю, что это не было выделено ни одним ответом) хорошо упомянуть, что иногда (особенно в программном обеспечении, где производительность имеет значение - как в ядре Linux) вы можете найти некоторые операторы if, подобные следующим:</target>
        </trans-unit>
        <trans-unit id="9d109a99d8c4326a6576d4732479edf2a6cedc39" translate="yes" xml:space="preserve">
          <source>In the sorted case, you can do better than relying on successful branch prediction or any branchless comparison trick: completely remove the branch.</source>
          <target state="translated">В отсортированном случае вы можете сделать это лучше,чем полагаться на успешное предсказание ветки или любой трюк сравнения без ветки:полностью удалить ветку.</target>
        </trans-unit>
        <trans-unit id="a4e4e6b119a5c6f74ced74230250afdbfb631f5a" translate="yes" xml:space="preserve">
          <source>In this case, it's obvious to the compiler that the boundary condition will never be hit. At least the Microsoft JIT compiler (but I expect Java does similar things) will notice this and remove the check altogether. WOW, that means no branch. Similarly, it will deal with other obvious cases.</source>
          <target state="translated">В этом случае компилятору очевидно,что граничное условие никогда не будет нарушено.По крайней мере,компилятор Microsoft JIT (но я ожидаю,что Java делает подобные вещи)заметит это и полностью удалит проверку.Ого,это значит,что ветки нет.Точно так же он будет работать и с другими очевидными случаями.</target>
        </trans-unit>
        <trans-unit id="fd70319a87ba55ceb8c46ef0dfb0b5cd4e2bf481" translate="yes" xml:space="preserve">
          <source>In this case, the lookup table was only 256 bytes, so it fits nicely in a cache and all was fast. This technique wouldn't work well if the data was 24-bit values and we only wanted half of them... the lookup table would be far too big to be practical. On the other hand, we can combine the two techniques shown above: first shift the bits over, then index a lookup table. For a 24-bit value that we only want the top half value, we could potentially shift the data right by 12 bits, and be left with a 12-bit value for a table index. A 12-bit table index implies a table of 4096 values, which might be practical.</source>
          <target state="translated">В данном случае таблица поиска составляла всего 256 байт,поэтому она хорошо помещается в кэш и все было быстро.Эта техника не сработала бы,если бы данные были 24-битными значениями,а мы хотели только половину из них...таблица поиска была бы слишком большой,чтобы быть практичной.С другой стороны,мы можем объединить две техники,показанные выше:сначала сдвинуть биты,затем индексировать таблицу поиска.Для 24-битного значения,которое нам нужно только для верхней половины,мы могли бы потенциально сдвинуть данные вправо на 12 бит,а для табличного индекса-влево на 12 бит.12-битный табличный индекс подразумевает таблицу из 4096 значений,что может быть практично.</target>
        </trans-unit>
        <trans-unit id="58ac7147fe158d09fb0dcd5d9a2419af351ceee2" translate="yes" xml:space="preserve">
          <source>In this case: &amp;gt;= 128 means we can keep the value, &amp;lt; 128 means we get rid of it. The easiest way to do that is by using an 'AND': if we keep it, we AND it with 7FFFFFFF; if we want to get rid of it, we AND it with 0. Notice also that 128 is a power of 2 -- so we can go ahead and make a table of 32768/128 integers and fill it with one zero and a lot of 7FFFFFFFF's.</source>
          <target state="translated">В этом случае:&amp;gt; = 128 означает, что мы можем сохранить значение, &amp;lt;128 означает, что мы избавимся от него. Самый простой способ сделать это - использовать 'И': если мы сохраняем это, мы И это с 7FFFFFFF; если мы хотим избавиться от него, мы И это с 0. Обратите также внимание, что 128 - это степень 2 - так что мы можем пойти дальше и составить таблицу из 32768/128 целых чисел и заполнить ее одним нулем и большим количеством 7FFFFFFFF годов.</target>
        </trans-unit>
        <trans-unit id="05909b2541b3e02aeda1080cefdfed9bf8d3fb41" translate="yes" xml:space="preserve">
          <source>Indeed, the array is partitioned in a contiguous zone with &lt;code&gt;data &amp;lt; 128&lt;/code&gt; and another with &lt;code&gt;data &amp;gt;= 128&lt;/code&gt;. So you should find the partition point with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Dichotomic_search&quot;&gt;dichotomic search&lt;/a&gt; (using &lt;code&gt;Lg(arraySize) = 15&lt;/code&gt; comparisons), then do a straight accumulation from that point.</source>
          <target state="translated">Действительно, массив разделен на смежные зоны с &lt;code&gt;data &amp;lt; 128&lt;/code&gt; а другая с &lt;code&gt;data &amp;gt;= 128&lt;/code&gt; . Таким образом, вы должны найти точку разделения с помощью &lt;a href=&quot;https://en.wikipedia.org/wiki/Dichotomic_search&quot;&gt;дихотомического поиска&lt;/a&gt; (используя &lt;code&gt;Lg(arraySize) = 15&lt;/code&gt; сравнений), а затем выполнить прямое накопление с этой точки.</target>
        </trans-unit>
        <trans-unit id="511459d1219dae84b5739744e2330bbd39562f3c" translate="yes" xml:space="preserve">
          <source>Initially, I thought this might be just a language or compiler anomaly, so I tried Java:</source>
          <target state="translated">Сначала я подумал,что это может быть просто аномалия языка или компилятора,так что я попробовал Java:</target>
        </trans-unit>
        <trans-unit id="b7ea0a495929d20edeb96560f38ad10f605c64c3" translate="yes" xml:space="preserve">
          <source>Intel - Avoiding the Cost of Branch Misprediction</source>
          <target state="translated">Интел-предотвращение затрат на отраслевые неверные прогнозы.</target>
        </trans-unit>
        <trans-unit id="77db291a450702d5439477d5645b64a6a25dcb27" translate="yes" xml:space="preserve">
          <source>Intel - Branch and Loop Reorganization to Prevent Mispredicts</source>
          <target state="translated">Intel-Реорганизация филиалов и циклов для предотвращения неправильных действий</target>
        </trans-unit>
        <trans-unit id="59f94bde7099ca1379cdd1147d7f4529386efe43" translate="yes" xml:space="preserve">
          <source>Is there a better way? You guess which direction the branch will go!</source>
          <target state="translated">Есть способ получше? Угадай,в каком направлении пойдет ветка!</target>
        </trans-unit>
        <trans-unit id="9ce53cf70b1162457580560ead6c5cf7c26bf416" translate="yes" xml:space="preserve">
          <source>Is there a better way? You guess which direction the train will go!</source>
          <target state="translated">Есть способ получше? Угадай,в каком направлении пойдет поезд!</target>
        </trans-unit>
        <trans-unit id="2b7c4e9ff8bccc2bf1d5615ac7198435e8f85617" translate="yes" xml:space="preserve">
          <source>It can also do source code annotation with dissassembly.</source>
          <target state="translated">Он также может делать аннотацию исходного кода с разборкой.</target>
        </trans-unit>
        <trans-unit id="d889c96e7c80c6d5564b275e9ce3e1dcf34879de" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t make fewer predictions - it makes fewer incorrect predictions. It still has to predict for each time through the loop...</source>
          <target state="translated">Это не делает меньше предсказаний - это делает меньше неправильных предсказаний. Это все еще должно предсказывать для каждого раза через цикл ...</target>
        </trans-unit>
        <trans-unit id="08fc45b9de518283718984bcfb1e9ac8e6ae1278" translate="yes" xml:space="preserve">
          <source>It is important to understand that branch misprediction doesn't slow down programs. The cost of a missed prediction is just as if branch prediction didn't exist and you waited for the evaluation of the expression to decide what code to run (further explanation in the next paragraph).</source>
          <target state="translated">Важно понимать,что неверное предсказание ветвей не замедляет работу программ.Стоимость пропущенного предсказания такая же,как если бы предсказания в ветке не существовало,и вы ждали,когда оценка выражения решит,какой код запускать (подробнее об этом в следующем параграфе).</target>
        </trans-unit>
        <trans-unit id="6fc4b764667806eaf36f9b084c8cc41649bfd6ed" translate="yes" xml:space="preserve">
          <source>It will take 7 clock cycles for 3 instructions to be completed.</source>
          <target state="translated">Для выполнения 3 инструкций потребуется 7 циклов.</target>
        </trans-unit>
        <trans-unit id="7e692acc3118ecaa2f6cab194a17621924826a7b" translate="yes" xml:space="preserve">
          <source>It will take 9 clock cycles for 3 instructions to be completed.</source>
          <target state="translated">Для выполнения 3 инструкций потребуется 9 циклов.</target>
        </trans-unit>
        <trans-unit id="76778e3295cf8f4fb34c2e009919d81130807662" translate="yes" xml:space="preserve">
          <source>It's about branch prediction. What is it?</source>
          <target state="translated">Речь идет о предсказании ветвей.Что это?</target>
        </trans-unit>
        <trans-unit id="5ce025460eef942a5746a29f6fff2639b7a4f0ea" translate="yes" xml:space="preserve">
          <source>It's quite a simple demo that clarifies the very basic part of Branch Predictor. If those gifs are annoying, please feel free to remove them from the answer and visitors can also get the live demo source code from &lt;a href=&quot;https://github.com/Eugene-Mark/BranchPredictorDemo&quot;&gt;BranchPredictorDemo&lt;/a&gt;</source>
          <target state="translated">Это довольно простая демонстрация, которая разъясняет основную часть Branch Predictor. Если эти картинки раздражают, пожалуйста, удалите их из ответа, и посетители могут также получить исходный демонстрационный исходный код из &lt;a href=&quot;https://github.com/Eugene-Mark/BranchPredictorDemo&quot;&gt;BranchPredictorDemo.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1800ac2cc348d512d31d6a4d1e9d7c3834e153d" translate="yes" xml:space="preserve">
          <source>Java - NetBeans 7.1.1 JDK 7 - x64</source>
          <target state="translated">Java-NetBeans 7.1.1 JDK 7-x64</target>
        </trans-unit>
        <trans-unit id="f3f0214447bd9b96e0f2a7febf49ceace8c3c918" translate="yes" xml:space="preserve">
          <source>Let us assume that the predictor will always assume the true branch on the first run.</source>
          <target state="translated">Предположим,что при первом прогоне предсказатель всегда будет считать истинную ветвь.</target>
        </trans-unit>
        <trans-unit id="0626fcdc6685d5777030cccc407cda27d5a5dbe6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s measure the performance of this loop with different conditions:</source>
          <target state="translated">Давайте измерим производительность этого цикла с различными условиями:</target>
        </trans-unit>
        <trans-unit id="78c58416698b00e2911ee8edf6ff28c7aa28b3f5" translate="yes" xml:space="preserve">
          <source>Let's say you need to pick route 1 or route 2. Waiting for your partner to check the map, you have stopped at ## and waited, or you could just pick route1 and if you were lucky (route 1 is the correct route), then great you didn't have to wait for your partner to check the map (you saved the time it would have taken him to check the map), otherwise you will just turn back.</source>
          <target state="translated">Скажем,вам нужно выбрать маршрут 1 или 2.Ждать пока партнер проверит карту,вы остановились на ##и дождались,или можно просто выбрать route1 и если повезет (маршрут 1-правильный маршрут),то отлично,что вам не пришлось ждать пока партнер проверит карту (вы сэкономили время,которое ему понадобилось бы,чтобы проверить карту),иначе вы просто повернете обратно.</target>
        </trans-unit>
        <trans-unit id="2722634189f24bf6fb4d65af5b80948093b029bf" translate="yes" xml:space="preserve">
          <source>Like branch prediction, this was optimized in the Pentium processors: the processor predicts that it needs to load a piece of data and attempts to load that into the cache before the operation actually hits the cache. As we've already seen, branch prediction sometimes goes horribly wrong -- in the worst case scenario you need to go back and actually wait for a memory load, which will take forever (&lt;strong&gt;in other words: failing branch prediction is bad, a memory load after a branch prediction fail is just horrible!&lt;/strong&gt;).</source>
          <target state="translated">Как и прогнозирование ветвлений, это было оптимизировано в процессорах Pentium: процессор предсказывает, что ему нужно загрузить часть данных, и пытается загрузить их в кэш, прежде чем операция действительно попадет в кэш. Как мы уже видели, предсказание ветвления иногда идет ужасно неправильно - в худшем случае вам нужно вернуться назад и фактически ждать загрузки памяти, которая будет длиться вечно ( &lt;strong&gt;другими словами: неудачное предсказание ветвления плохо, память загрузка после сбоя предсказания ветки просто ужасна!&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="7511e6163f79984c1b9da8abd1a9c44be298fc50" translate="yes" xml:space="preserve">
          <source>Look at the image I created for you below. Which street is going to be finished faster?</source>
          <target state="translated">Посмотрите на изображение,которое я создал для вас ниже.Какая улица будет закончена быстрее?</target>
        </trans-unit>
        <trans-unit id="87b5594f2643cba7d46d5fb490ed0d38e2cf1230" translate="yes" xml:space="preserve">
          <source>Making a wrong prediction leads to going back to the previous step, and executing with another prediction. Assuming the prediction is correct, the code will continue to the next step. A wrong prediction results in repeating the same step, until a correct prediction occurs.</source>
          <target state="translated">Сделав неверный прогноз,вы возвращаетесь к предыдущему шагу и выполняете его с другим прогнозом.Предположив,что предсказание верно,код вернется к следующему шагу.Неправильный прогноз приводит к повторению того же самого шага,до тех пор,пока не произойдет правильный прогноз.</target>
        </trans-unit>
        <trans-unit id="a1ebbba208d4225ea0cbac50fe08bb6ace4451a3" translate="yes" xml:space="preserve">
          <source>Most applications have well-behaved branches. So modern branch predictors will typically achieve &amp;gt;90% hit rates. But when faced with unpredictable branches with no recognizable patterns, branch predictors are virtually useless.</source>
          <target state="translated">Большинство приложений имеют хорошо управляемые ветви. Таким образом, современные отраслевые предикторы, как правило, достигают&amp;gt; 90% показателей успеха. Но когда они сталкиваются с непредсказуемыми ветвями без распознаваемых шаблонов, предикторы ветвей практически бесполезны.</target>
        </trans-unit>
        <trans-unit id="edc45563f2af123495a6f4d5820e01d67e592ac5" translate="yes" xml:space="preserve">
          <source>Most processor architectures do not have this ability to specify whether or not the status bits should be updated for a given operation, which can necessitate writing additional code to save and later restore status bits, or may require additional branches, or may limit the processor's out of order execution efficiency: one of the side effects of most CPU instruction set architectures forcibly updating status bits after most instructions is that it is much harder to tease apart which instructions can be run in parallel without interfering with each other. Updating status bits has side effects, therefore has a linearizing effect on code. &lt;strong&gt;ARM's ability to mix and match branch-free condition testing on any instruction with the option to either update or not update the status bits after any instruction is extremely powerful, for both assembly language programmers and compilers, and produces very efficient code.&lt;/strong&gt;</source>
          <target state="translated">Большинство архитектур процессоров не имеют возможности указать, следует ли обновлять биты состояния для данной операции, что может потребовать написания дополнительного кода для сохранения и последующего восстановления битов состояния, или может потребовать дополнительных ветвей, или может ограничить выход процессора эффективности выполнения заказа: одним из побочных эффектов большинства архитектур набора команд ЦП, принудительно обновляющих биты состояния после большинства команд, является то, что гораздо сложнее отделить друг от друга, какие команды могут выполняться параллельно, не мешая друг другу. Обновление битов состояния имеет побочные эффекты, поэтому имеет линеаризующий эффект на код. &lt;strong&gt;Способность ARM смешивать и сопоставлять безусловное тестирование условий для любой инструкции с возможностью либо обновлять, либо не обновлять биты состояния после любой инструкции является чрезвычайно мощной как для программистов на ассемблере, так и для компиляторов, и создает очень эффективный код.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6714e326ddf3827a45bf7845db0659793dffdc78" translate="yes" xml:space="preserve">
          <source>Moving back to the above question let's consider the following instructions:</source>
          <target state="translated">Возвращаясь к вышеуказанному вопросу,рассмотрим следующие инструкции:</target>
        </trans-unit>
        <trans-unit id="8f2f5f3a519901e55e81a2564329640471c74d81" translate="yes" xml:space="preserve">
          <source>My first thought was that sorting brings the data into the cache, but then I thought how silly that was because the array was just generated.</source>
          <target state="translated">Моей первой мыслью было то,что сортировка приносит данные в кэш,но потом я подумал,как глупо это было,потому что массив только что был сгенерирован.</target>
        </trans-unit>
        <trans-unit id="5b798bfc3b15b4fc93876532bf774c937ef4d1cc" translate="yes" xml:space="preserve">
          <source>No doubt some of us would be interested in ways of identifying code that is problematic for the CPU's branch-predictor. The Valgrind tool &lt;code&gt;cachegrind&lt;/code&gt; has a branch-predictor simulator, enabled by using the &lt;code&gt;--branch-sim=yes&lt;/code&gt; flag. Running it over the examples in this question, with the number of outer loops reduced to 10000 and compiled with &lt;code&gt;g++&lt;/code&gt;, gives these results:</source>
          <target state="translated">Несомненно, некоторые из нас будут заинтересованы в способах идентификации кода, который является проблематичным для предсказателя ветвления ЦП. У инструмента Valgrind &lt;code&gt;cachegrind&lt;/code&gt; есть симулятор предсказания ветвлений, который включается с помощью &lt;code&gt;--branch-sim=yes&lt;/code&gt; . Выполнение этого в примерах из этого вопроса с уменьшением числа внешних циклов до 10000 и компиляцией с помощью &lt;code&gt;g++&lt;/code&gt; дает следующие результаты:</target>
        </trans-unit>
        <trans-unit id="7fe6472f78792531c23c2701179111bf8fe3d611" translate="yes" xml:space="preserve">
          <source>Normally this kind of optimizations are mainly found in hard-real time applications or embedded systems where execution time matters and it's critical. For example, if you are checking for some error condition that only happens 1/10000000 times, then why not inform the compiler about this? This way, by default, the branch prediction would assume that the condition is false.</source>
          <target state="translated">Обычно такой тип оптимизации встречается в основном в приложениях с жесткими временными рамками или во встраиваемых системах,где время выполнения имеет значение и является критическим.Например,если вы проверяете на наличие какого-то состояния ошибки,которое случается только 110000000 раз,то почему бы не сообщить об этом компилятору? Таким образом,по умолчанию прогноз ветки будет предполагать,что условие ложно.</target>
        </trans-unit>
        <trans-unit id="2687a67b9058fe9e6fd551f4fb695501d7a3f7de" translate="yes" xml:space="preserve">
          <source>Notice that the data is evenly distributed between 0 and 255. When the data is sorted, roughly the first half of the iterations will not enter the if-statement. After that, they will all enter the if-statement.</source>
          <target state="translated">Обратите внимание,что данные равномерно распределены между 0 и 255.При сортировке данных примерно первая половина итераций не будет вводиться в if-формуляр.После этого все они будут вводить if-формулу.</target>
        </trans-unit>
        <trans-unit id="8e169f52da1ac65f0d59b6b1c4ec6bd5bf878be5" translate="yes" xml:space="preserve">
          <source>Now for the sake of argument, suppose this is back in the 1800s - before long distance or radio communication.</source>
          <target state="translated">Теперь в качестве аргумента предположим,что это было еще в 1800-х годах-до междугородней или радиосвязи.</target>
        </trans-unit>
        <trans-unit id="30312bef68cebc5f38e57e727b2135cfb377fc89" translate="yes" xml:space="preserve">
          <source>Now let's look more closely by investigating the &lt;code&gt;x86&lt;/code&gt; assembly they generate. For simplicity, we use two functions &lt;code&gt;max1&lt;/code&gt; and &lt;code&gt;max2&lt;/code&gt;.</source>
          <target state="translated">Теперь давайте посмотрим более внимательно, исследуя генерируемую ими сборку &lt;code&gt;x86&lt;/code&gt; . Для простоты мы используем две функции &lt;code&gt;max1&lt;/code&gt; и &lt;code&gt;max2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c330fcd6ba152c362d1fcd57661782df403680f7" translate="yes" xml:space="preserve">
          <source>Now, if we look at the code</source>
          <target state="translated">Теперь,если мы посмотрим на код</target>
        </trans-unit>
        <trans-unit id="580a776c6b642fccec58ff95f40d16a839dd873b" translate="yes" xml:space="preserve">
          <source>Observations:</source>
          <target state="translated">Observations:</target>
        </trans-unit>
        <trans-unit id="c497da8cabdb633d3a209eb10a05a6e8a8479a34" translate="yes" xml:space="preserve">
          <source>On ARM, there is no branch needed, because every instruction has a 4-bit condition field, which tests (at zero cost) any of &lt;a href=&quot;https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/condition-codes-1-condition-flags-and-codes&quot;&gt;16 different different conditions&lt;/a&gt; that may arise in the Processor Status Register, and if the condition on an instruction is false, the instruction is skipped. This eliminates the need for short branches, and there would be no branch prediction hit for this algorithm. &lt;b&gt;Therefore, the sorted version of this algorithm would run slower than the unsorted version on ARM, because of the extra overhead of sorting.&lt;/b&gt;</source>
          <target state="translated">В ARM ветвление не требуется, поскольку каждая команда имеет 4-битное поле условия, которое проверяет (при нулевой стоимости) любое из &lt;a href=&quot;https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/condition-codes-1-condition-flags-and-codes&quot;&gt;16 различных условий,&lt;/a&gt; которые могут возникнуть в регистре состояния процессора, и если условие в команде false, инструкция пропущена. Это устраняет необходимость в коротких ветвях, и для этого алгоритма не будет никакого предсказания ветвлений. &lt;b&gt;Поэтому отсортированная версия этого алгоритма будет работать медленнее, чем несортированная версия в ARM, из-за дополнительных издержек сортировки.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97e13959d4711e37195fe7ecfc6a86c5fe97b99f" translate="yes" xml:space="preserve">
          <source>On a x86-64 machine, &lt;code&gt;GCC -S&lt;/code&gt; generates the assembly below.</source>
          <target state="translated">На компьютере с архитектурой x86-64 &lt;code&gt;GCC -S&lt;/code&gt; создает следующую сборку.</target>
        </trans-unit>
        <trans-unit id="af5b27c4a00930aafb30d96f562d6210ddf9267b" translate="yes" xml:space="preserve">
          <source>On an Intel &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core i7&lt;/a&gt;-2600K @ 3.4&amp;nbsp;GHz and Visual Studio 2010 Release Mode, the benchmark is (format copied from Mysticial):</source>
          <target state="translated">В Intel &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core i7&lt;/a&gt; -2600K с частотой 3,4 ГГц и в режиме выпуска Visual Studio 2010 эталонный тест (формат скопирован из Mysticial):</target>
        </trans-unit>
        <trans-unit id="c46e9d0de821ff22c14c3a97f36bb4c970b4b164" translate="yes" xml:space="preserve">
          <source>On the other hand, complex branch predictions &amp;ndash;either neural based or variants of two-level branch prediction &amp;ndash;provide better prediction accuracy, but they consume more power and complexity increases exponentially.</source>
          <target state="translated">С другой стороны, сложные предсказания ветвления - либо нейронные, либо варианты двухуровневого предсказания ветвления - обеспечивают лучшую точность предсказания, но они потребляют больше энергии, а сложность возрастает экспоненциально.</target>
        </trans-unit>
        <trans-unit id="a5e809f1e268fe28804313bc9194b78b811d96b5" translate="yes" xml:space="preserve">
          <source>On the other hand, once it's sorted, the predictor will first move into a state of strongly not taken and when the values change to the high value the predictor will in three runs through change all the way from strongly not taken to strongly taken.</source>
          <target state="translated">С другой стороны,как только он отсортирован,предсказатель сначала перейдет в состояние сильно не взятого,а когда значения изменятся на высокое,предсказатель через три пробежит через изменение на весь путь от сильно не взятого к сильно взятому.</target>
        </trans-unit>
        <trans-unit id="3bbefccbf2bee10e9954cc81b62c16f44204ba33" translate="yes" xml:space="preserve">
          <source>One reason is branch prediction: the key operation in the sort algorithm is &lt;code&gt;&amp;ldquo;if(v[i] &amp;lt; pivot]) &amp;hellip;&amp;rdquo;&lt;/code&gt; or equivalent. For a sorted sequence that test is always true whereas, for a random sequence, the branch chosen varies randomly.</source>
          <target state="translated">Одной из причин является предсказание ветвлений: ключевая операция в алгоритме сортировки - &lt;code&gt;&amp;ldquo;if(v[i] &amp;lt; pivot]) &amp;hellip;&amp;rdquo;&lt;/code&gt; или эквивалентная. Для отсортированной последовательности этот тест всегда верен, тогда как для случайной последовательности выбранная ветвь изменяется случайным образом.</target>
        </trans-unit>
        <trans-unit id="6f83347c5969b82a1f9ad38db3d4941619744366" translate="yes" xml:space="preserve">
          <source>One way to avoid branch prediction errors is to build a lookup table, and index it using the data. Stefan de Bruijn discussed that in his answer.</source>
          <target state="translated">Один из способов избежать ошибок прогнозирования ветвей-построить таблицу поиска и проиндексировать ее по данным.Стефан де Бруйн обсуждал это в своем ответе.</target>
        </trans-unit>
        <trans-unit id="dba85fca15da0466e912cf6f28584da718edda4e" translate="yes" xml:space="preserve">
          <source>Quicksort (and sorting in general) is a complex study that has attracted some of the greatest minds of computer science. A good sort function is a result of both choosing a good algorithm and paying attention to hardware performance in its implementation.</source>
          <target state="translated">Quicksort (и сортировка в целом)-это сложное исследование,которое привлекло некоторые из величайших умов компьютерной науки.Хорошая функция сортировки является результатом как выбора хорошего алгоритма,так и внимания к производительности оборудования при его реализации.</target>
        </trans-unit>
        <trans-unit id="7eee27983091e8186d6b5fbbd3abab850ed0e885" translate="yes" xml:space="preserve">
          <source>Recently this example (modified very slightly) was also used as a way to demonstrate how a piece of code can be profiled within the program itself on Windows. Along the way, the author also shows how to use the results to determine where the code is spending most of its time in both the sorted &amp;amp; unsorted case. Finally the piece also shows how to use a little known feature of the HAL (Hardware Abstraction Layer) to determine just how much branch misprediction is happening in the unsorted case.</source>
          <target state="translated">Недавно этот пример (измененный очень незначительно) также использовался для демонстрации того, как фрагмент кода может быть профилирован в самой программе в Windows. Попутно автор также показывает, как использовать результаты, чтобы определить, где код проводит большую часть своего времени как в отсортированном, так и в несортированном случае. Наконец, в этой части также показано, как использовать малоизвестную функцию HAL (Уровень аппаратной абстракции), чтобы определить, насколько часто происходит неправильное предсказание ветвления в несортированном случае.</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="2e26f7f81e11c144071f07013d00802556dd33b0" translate="yes" xml:space="preserve">
          <source>Replace:</source>
          <target state="translated">Replace:</target>
        </trans-unit>
        <trans-unit id="5b332ccd041103419a2ad666b47b236d919bc4c8" translate="yes" xml:space="preserve">
          <source>Scientific papers - branch prediction computer architecture</source>
          <target state="translated">Научные работы-отраслевая архитектура компьютера для прогнозирования</target>
        </trans-unit>
        <trans-unit id="b01f405d3c10919c3c94fd65f54c0af170284f84" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://perf.wiki.kernel.org/index.php/Tutorial&quot;&gt;the performance tutorial&lt;/a&gt; for more details.</source>
          <target state="translated">Смотрите &lt;a href=&quot;https://perf.wiki.kernel.org/index.php/Tutorial&quot;&gt;руководство&lt;/a&gt; по производительности для более подробной информации.</target>
        </trans-unit>
        <trans-unit id="3a298d21d0b3c80ce2982ea32ba8a81f978c30f0" translate="yes" xml:space="preserve">
          <source>So how would you strategically guess to minimize the number of times that the train must back up and go down the other path? You look at the past history! If the train goes left 99% of the time, then you guess left. If it alternates, then you alternate your guesses. If it goes one way every three times, you guess the same...</source>
          <target state="translated">Итак,как бы вы стратегически догадались,чтобы минимизировать количество раз,когда поезд должен вернуться и пойти по другому пути? Вы смотрите на прошлое! Если поезд уходит 99% времени,то ты угадываешь,что ушел.Если он чередуется,то вы чередуете свои догадки.Если поезд уходит в одну сторону каждые три раза,вы угадываете то же самое...</target>
        </trans-unit>
        <trans-unit id="9ebfa04f718206d91431f0015c26f1b42906f312" translate="yes" xml:space="preserve">
          <source>So in the first case, it will always take the true branch since historically all its predictions are correct.
In the 2nd case, initially it will predict wrong, but after a few iterations, it will predict correctly.
In the 3rd case, it will initially predict correctly till the elements are less than 128. After which it will fail for some time and the correct itself when it sees branch prediction failure in history.</source>
          <target state="translated">Так что в первом случае всегда будет нужна истинная ветвь,так как исторически все ее прогнозы верны.Во втором случае,изначально он будет предсказывать неправильно,но после нескольких итераций,он будет предсказывать правильно.В 3-м случае он изначально будет правильно предсказывать до тех пор,пока элементы не станут меньше 128.После чего некоторое время будет неудачным и правильным,когда увидит в истории сбой в предсказании ветви.</target>
        </trans-unit>
        <trans-unit id="351943fae2a5bec40c06462d38700c5db13e382c" translate="yes" xml:space="preserve">
          <source>So programmatically, &lt;strong&gt;branch prediction&lt;/strong&gt; causes the process to be slower...</source>
          <target state="translated">Таким образом, программно &lt;strong&gt;предсказание ветвлений&lt;/strong&gt; приводит к замедлению процесса ...</target>
        </trans-unit>
        <trans-unit id="5ccec79adc1d899a1de0448aec6cd2999ea646b6" translate="yes" xml:space="preserve">
          <source>So there is no doubt about the impact of branch prediction on performance!</source>
          <target state="translated">Так что нет никаких сомнений в том,как прогнозирование отрасли повлияет на производительность!</target>
        </trans-unit>
        <trans-unit id="3ae2891b971dd8487010889269aa73c34566377f" translate="yes" xml:space="preserve">
          <source>So we've figured out that we can create a small table. Next thing to do is get a lookup function in place. Lookup functions are usually small functions that use a couple of basic integer operations (and, or, xor, shift, add, remove and perhaps multiply). You want to have your input translated by the lookup function to some kind of 'unique key' in your table, which then simply gives you the answer of all the work you wanted it to do.</source>
          <target state="translated">Так что мы придумали,что можем создать маленький столик.Следующее,что нужно сделать,это установить функцию поиска.Функции поиска-это обычно небольшие функции,которые используют пару базовых целочисленных операций (и,или,xor,сдвигают,добавляют,удаляют и,возможно,умножают).Вы хотите,чтобы Ваши данные были переведены поисковой функцией на некий &quot;уникальный ключ&quot; в Вашей таблице,который затем просто даст Вам ответ на все действия,которые Вы хотели,чтобы она выполняла.</target>
        </trans-unit>
        <trans-unit id="e2fc4b8592d275115019311dc1f64056ef857314" translate="yes" xml:space="preserve">
          <source>So why does a conditional move perform better?</source>
          <target state="translated">Так почему условный ход работает лучше?</target>
        </trans-unit>
        <trans-unit id="8862694fc5020ea843e75148ff60c38a99455cbf" translate="yes" xml:space="preserve">
          <source>So, I tried with a vector of a million integers and got:</source>
          <target state="translated">Итак,я попробовал с вектором в миллион целых чисел и получил:</target>
        </trans-unit>
        <trans-unit id="26f99fe80efafd6fc68424aeeb2c6cf0ad1eb0fd" translate="yes" xml:space="preserve">
          <source>Some starting new elements are less than 128 and later it become greater than 128</source>
          <target state="translated">Некоторые начинающие новые элементы составляют менее 128,а затем становятся больше 128.</target>
        </trans-unit>
        <trans-unit id="0e167763d050d2cb6ded113f3e9064040103e166" translate="yes" xml:space="preserve">
          <source>Something like (unchecked)</source>
          <target state="translated">Что-то вроде (бесконтрольно)</target>
        </trans-unit>
        <trans-unit id="a88df12411d4a67fd1c80b6258959d001907e55b" translate="yes" xml:space="preserve">
          <source>Sometimes, some modern compilers can optimize our code to assembly with better performance, sometimes some compilers can't (the code in question is using Visual Studio's native compiler). Knowing the performance difference between branch and conditional move when unpredictable can help us write code with better performance when the scenario gets so complex that the compiler can not optimize them automatically.</source>
          <target state="translated">Иногда некоторые современные компиляторы могут оптимизировать наш код до сборки с лучшей производительностью,иногда некоторые компиляторы не могут (код,о котором идет речь,использует родной компилятор Visual Studio).Знание разницы в производительности между ветвями и условным движением,когда непредсказуемо,может помочь нам писать код с лучшей производительностью,когда сценарий становится настолько сложным,что компилятор не может оптимизировать их автоматически.</target>
        </trans-unit>
        <trans-unit id="96ecd96ca3304ca88eb06e8a00937b5c4b49d3ed" translate="yes" xml:space="preserve">
          <source>Sorted Array: Straight Road
    ____________________________________________________________________________________
    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT</source>
          <target state="translated">Сортированный массив:Прямая дорога ____________________________________________________________________________________-------------------------------------------------------------------------------------------------------------------------</target>
        </trans-unit>
        <trans-unit id="417b7a8c229714395078ea87b358994e172876b0" translate="yes" xml:space="preserve">
          <source>Sorted arrays are processed faster than an unsorted array, due to a phenomena called branch prediction.</source>
          <target state="translated">Сортированные массивы обрабатываются быстрее,чем несортированные массивы,из-за явления,называемого предсказанием ветвей.</target>
        </trans-unit>
        <trans-unit id="12a86072c1d6226f21fdf1c483e322e5674a52e2" translate="yes" xml:space="preserve">
          <source>Sorting only k-element sections completes the pre-processing in linear time, &lt;code&gt;O(n)&lt;/code&gt;, rather than the &lt;code&gt;O(n.log(n))&lt;/code&gt; time needed to sort the entire array.</source>
          <target state="translated">Сортировка только k-элементных разделов завершает предварительную обработку за линейное время &lt;code&gt;O(n)&lt;/code&gt; , а не за время &lt;code&gt;O(n.log(n))&lt;/code&gt; необходимое для сортировки всего массива.</target>
        </trans-unit>
        <trans-unit id="911567da4c21b2d8b0b479e0b036b07488a7f699" translate="yes" xml:space="preserve">
          <source>Starting with the original loop:</source>
          <target state="translated">Начиная с оригинальной петли:</target>
        </trans-unit>
        <trans-unit id="b289c5eb6b8d96218afa396493007fb0c5566528" translate="yes" xml:space="preserve">
          <source>Static branch prediction is used by the microprocessor the first time
  a conditional branch is encountered, and dynamic branch prediction is
  used for succeeding executions of the conditional branch code.</source>
          <target state="translated">Прогнозирование статической ветки используется микропроцессором при первом знакомстве с условной веткой,а динамическое прогнозирование ветки используется для последующего выполнения кода условной ветки.</target>
        </trans-unit>
        <trans-unit id="0f6ae2e9812cde1bb50890188a75301caf057eb4" translate="yes" xml:space="preserve">
          <source>That being said, the compiler tries to predict the outcome prior to it being actually evaluated. It will fetch instructions from the &lt;code&gt;if&lt;/code&gt; block, and if the expression turns out to be true, then wonderful! We gained the time it took to evaluate it and made progress in the code; if not then we are running the wrong code, the pipeline is flushed, and the correct block is run.</source>
          <target state="translated">При этом компилятор пытается предсказать результат до его фактической оценки. Он будет извлекать инструкции из блока &lt;code&gt;if&lt;/code&gt; , и если выражение окажется истинным, тогда замечательно! Мы получили время, необходимое для его оценки, и добились прогресса в коде; если нет, то мы запускаем неправильный код, конвейер сбрасывается и запускается правильный блок.</target>
        </trans-unit>
        <trans-unit id="35261a879de9858385098dadcc5581d89b2d609f" translate="yes" xml:space="preserve">
          <source>That one is 100,000 times faster than before.</source>
          <target state="translated">Этот в 100 000 раз быстрее,чем раньше.</target>
        </trans-unit>
        <trans-unit id="08f10e7e1256e6e98ddd64a702e8dc6f1d8014d5" translate="yes" xml:space="preserve">
          <source>That sounds like an interview question. Is it true? How would you know? It is a bad idea to answer questions about efficiency without first doing some measurements, so it is important to know how to measure.</source>
          <target state="translated">Звучит как вопрос для интервью.Это правда? Откуда ты знаешь? Плохая идея-отвечать на вопросы об эффективности,не проводя сначала некоторые измерения,поэтому важно знать,как измерять.</target>
        </trans-unit>
        <trans-unit id="508b04c27cc3f2089b5ea384a8ad1dd729afae1a" translate="yes" xml:space="preserve">
          <source>That's for sure!...</source>
          <target state="translated">Это точно!...</target>
        </trans-unit>
        <trans-unit id="0cde2413f2853914209f8169d7f3210951656de9" translate="yes" xml:space="preserve">
          <source>The above behavior is happening because of Branch prediction.</source>
          <target state="translated">Вышеупомянутое поведение происходит из-за предсказания Бранша.</target>
        </trans-unit>
        <trans-unit id="76fff62130dd99e863f74fb23823d0e6b58d4f70" translate="yes" xml:space="preserve">
          <source>The answer to your question is very simple.</source>
          <target state="translated">Ответ на ваш вопрос очень прост.</target>
        </trans-unit>
        <trans-unit id="429f9a89629f65eb36edfe9122d197b4a3ab1462" translate="yes" xml:space="preserve">
          <source>The assumption by other answers that one needs to sort the data is not correct.</source>
          <target state="translated">Предположение других ответов о том,что необходимо сортировать данные,неверно.</target>
        </trans-unit>
        <trans-unit id="14fca0f59106880a0be992b705d52d3aeb245c06" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0136108040&quot;&gt;Computer Systems: A Programmer's Perspective, second edition&lt;/a&gt;&lt;/em&gt; explains this in detail. You can check Section 3.6.6 for &lt;em&gt;Conditional Move Instructions&lt;/em&gt;, entire Chapter 4 for &lt;em&gt;Processor Architecture&lt;/em&gt;, and Section 5.11.2 for a special treatment for &lt;em&gt;Branch Prediction and Misprediction Penalties&lt;/em&gt;.</source>
          <target state="translated">Книга &amp;laquo; &lt;em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0136108040&quot;&gt;Компьютерные системы: взгляд программиста&amp;raquo;, второе издание,&lt;/a&gt;&lt;/em&gt; объясняет это подробно. Вы можете проверить Раздел 3.6.6 для &lt;em&gt;Условных Инструкций Перемещения&lt;/em&gt; , всю Главу 4 для &lt;em&gt;Архитектуры процессора&lt;/em&gt; и Раздел 5.11.2 для специальной обработки для &lt;em&gt;Штрафов Предсказания и Неправильного Предсказания&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="01c31d56c186a6ecf1549609412d42ba9d45ea61" translate="yes" xml:space="preserve">
          <source>The branch prediction will miss only once.</source>
          <target state="translated">Прогноз ветки будет пропущен только один раз.</target>
        </trans-unit>
        <trans-unit id="29c1be7f24497d0ee26471ab9535a6a90d257408" translate="yes" xml:space="preserve">
          <source>The branch predictor is a digital circuit (in computer architecture) trying to predict which way a branch will go, improving the flow in the instruction pipeline. The circuit/computer predicts the next step and executes it.</source>
          <target state="translated">Предсказатель ветви представляет собой цифровую схему (в компьютерной архитектуре),пытающуюся предсказать,в какую сторону пойдет ветвь,улучшая поток в учебном трубопроводе.Схемокомпьютер предсказывает следующий шаг и выполняет его.</target>
        </trans-unit>
        <trans-unit id="b7d588a1c5460542b96d8b0baf1bab136cf8c2f6" translate="yes" xml:space="preserve">
          <source>The code is summing up some independent terms, so the order should not matter.</source>
          <target state="translated">Код суммирует некоторые независимые термины,поэтому порядок не должен иметь значения.</target>
        </trans-unit>
        <trans-unit id="861f94790ecfa967155e62be104ac537e52a5f3a" translate="yes" xml:space="preserve">
          <source>The condition testing field and the optional &quot;set status bit&quot; field can be combined, for example:</source>
          <target state="translated">Например,можно комбинировать поле проверки состояния и дополнительное поле &quot;Бит состояния&quot;:</target>
        </trans-unit>
        <trans-unit id="6fc938b02ae6f7028fe10706590f459d70027752" translate="yes" xml:space="preserve">
          <source>The example contains three instructions and the first one is a conditional jump instruction. The latter two instructions can go into the pipeline until the conditional jump instruction is executed.</source>
          <target state="translated">Пример содержит три инструкции,первая из которых является условной инструкцией прыжка.Две последние инструкции могут идти в трубопровод до тех пор,пока не будет выполнена инструкция по условному прыжку.</target>
        </trans-unit>
        <trans-unit id="366e9cefdfc7cf84268b4baae54481cba492ad51" translate="yes" xml:space="preserve">
          <source>The first thing we need to know is what is &lt;em&gt;small&lt;/em&gt;? While smaller is generally better, a rule of thumb is to stick to lookup tables that are &amp;lt;= 4096 bytes in size. As an upper limit: if your lookup table is larger than 64K it's probably worth reconsidering.</source>
          <target state="translated">Первое, что нам нужно знать, это то, что &lt;em&gt;мало&lt;/em&gt; ? Хотя меньший размер обычно лучше, практическое правило - придерживаться таблиц поиска размером &amp;lt;= 4096 байт. В качестве верхнего предела: если ваша таблица поиска больше 64 КБ, то, вероятно, стоит пересмотреть.</target>
        </trans-unit>
        <trans-unit id="6ba638444517f57a3c3d8cf6edb54711b632d388" translate="yes" xml:space="preserve">
          <source>The following code does not sort the entire array, but only 200-element segments of it, and thereby runs the fastest.</source>
          <target state="translated">Следующий код сортирует не весь массив,а только его 200-элементные сегменты,и тем самым запускает самый быстрый.</target>
        </trans-unit>
        <trans-unit id="7983685e650d0c0a12e46c770cad6a3ca1107dcd" translate="yes" xml:space="preserve">
          <source>The inner loop for this algorithm would look something like the following in ARM assembly language:</source>
          <target state="translated">Внутренний цикл для этого алгоритма будет выглядеть следующим образом на ассемблере ARM:</target>
        </trans-unit>
        <trans-unit id="28885d236427f0638d59b0c11dc0c5a23a6555c9" translate="yes" xml:space="preserve">
          <source>The link is here:
&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&lt;/a&gt;</source>
          <target state="translated">Ссылка здесь: &lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88c912641d7171878bede0b6532896dc83279c69" translate="yes" xml:space="preserve">
          <source>The performance of an &lt;code&gt;if&lt;/code&gt;-statement depends on whether its condition has a predictable pattern. If the condition is always true or always false, the branch prediction logic in the processor will pick up the pattern. On the other hand, if the pattern is unpredictable, the &lt;code&gt;if&lt;/code&gt;-statement will be much more expensive.</source>
          <target state="translated">Производительность условия if зависит от того, имеет ли его состояние предсказуемый характер. Если условие всегда истинно или всегда ложно, логика предсказания ветвления в процессоре подберет шаблон. С другой стороны, если шаблон непредсказуем, то &lt;code&gt;if&lt;/code&gt; - утверждение будет намного дороже.</target>
        </trans-unit>
        <trans-unit id="f012bd762d6379e8ee89682917865e46bdb77c96" translate="yes" xml:space="preserve">
          <source>The question is: What makes the above statement not execute in certain cases as in case of sorted data? Here comes the &quot;branch predictor&quot;. A branch predictor is a digital circuit that tries to guess which way a branch (e.g. an &lt;code&gt;if-then-else&lt;/code&gt; structure) will go before this is known for sure. The purpose of the branch predictor is to improve the flow in the instruction pipeline. Branch predictors play a critical role in achieving high effective performance!</source>
          <target state="translated">Вопрос в том, что делает вышеприведенное утверждение не выполненным в некоторых случаях, например, в случае отсортированных данных? Здесь появляется &amp;laquo;предсказатель ветви&amp;raquo;. Предиктор ветвления - это цифровая схема, которая пытается угадать, каким образом пойдет ветвь (например, структура &lt;code&gt;if-then-else&lt;/code&gt; ), прежде чем это станет известно наверняка. Целью предиктора ветвления является улучшение потока в конвейере команд. Предсказатели ветвлений играют решающую роль в достижении высокой эффективности!</target>
        </trans-unit>
        <trans-unit id="23c9a538a1ef4688c167a88337fa568b94155241" translate="yes" xml:space="preserve">
          <source>The reason why performance improves drastically when the data is sorted is that the branch prediction penalty is removed, as explained beautifully in &lt;a href=&quot;https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902&quot;&gt;Mysticial's answer&lt;/a&gt;.</source>
          <target state="translated">Причина, по которой производительность резко улучшается при сортировке данных, заключается в том, что штраф за предсказание ветвлений снят, как прекрасно объясняется в &lt;a href=&quot;https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902&quot;&gt;ответе Mysticial&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="243cce3d654c2e7e3d82b9ec0fc8b02ca07456a2" translate="yes" xml:space="preserve">
          <source>The result is robust in multiple tests. We get a great speedup when the branch result is unpredictable, but we suffer a little bit when it is predictable. In fact, when using a conditional move, the performance is the same regardless of the data pattern.</source>
          <target state="translated">Результат надежный в многократных тестах.Мы получаем большое ускорение,когда результат ветки непредсказуем,но немного страдаем,когда он предсказуем.Фактически,при использовании условного перемещения,производительность остается одинаковой вне зависимости от шаблона данных.</target>
        </trans-unit>
        <trans-unit id="8b2b071beeb1c27797d622cdfe18d46550e595b8" translate="yes" xml:space="preserve">
          <source>The results for the above MATLAB code are as follows:</source>
          <target state="translated">Результаты для вышеуказанного кода MATLAB следующие:</target>
        </trans-unit>
        <trans-unit id="4c621c1518421a4f9a5e82a55048d9d384c6117a" translate="yes" xml:space="preserve">
          <source>The results of the C code as in @GManNickG I get:</source>
          <target state="translated">Результаты C-кода,как в @GManNickG я получаю:</target>
        </trans-unit>
        <trans-unit id="c51e81726485eb1f77e86bce9119907916de64b6" translate="yes" xml:space="preserve">
          <source>The technique of indexing into an array, instead of using an &lt;code&gt;if&lt;/code&gt; statement, can be used for deciding which pointer to use.  I saw a library that implemented binary trees, and instead of having two named pointers (&lt;code&gt;pLeft&lt;/code&gt; and &lt;code&gt;pRight&lt;/code&gt; or whatever) had a length-2 array of pointers and used the &quot;decision bit&quot; technique to decide which one to follow.  For example, instead of:</source>
          <target state="translated">Техника индексации в массив, вместо использования оператора &lt;code&gt;if&lt;/code&gt; , может быть использована для решения, какой указатель использовать. Я увидел библиотеку, в которой реализованы двоичные деревья, и вместо двух именованных указателей ( &lt;code&gt;pLeft&lt;/code&gt; и pRight и т. &lt;code&gt;pRight&lt;/code&gt; ) Имел массив указателей длины 2 и использовал технику &amp;laquo;бит решения&amp;raquo;, чтобы решить, какой из них следовать. Например, вместо:</target>
        </trans-unit>
        <trans-unit id="dfc876aaa5431ea7d4210f0979641e4dbe4d96a9" translate="yes" xml:space="preserve">
          <source>The technique of indexing into an array, instead of using an if statement, can be used for deciding which pointer to use. I saw a library that implemented binary trees, and instead of having two named pointers (pLeft and pRight or whatever) had a length-2 array of pointers and used the &quot;decision bit&quot; technique to decide which one to follow. For example, instead of:</source>
          <target state="translated">Техника индексации в массив,вместо использования оператора if,может быть использована для решения,какой указатель использовать.Я увидел библиотеку,в которой реализованы бинарные деревья,и вместо двух именованных указателей (pLeft и pRight или что-то в этом роде)был массив указателей длиной 2 и использовал технику &quot;бит решения&quot;,чтобы решить,какому из них следовать.Например,вместо:</target>
        </trans-unit>
        <trans-unit id="b6cfe976487000bd1e4d79b8ceec46016b036b7e" translate="yes" xml:space="preserve">
          <source>The time that is wasted in case of a branch misprediction is equal to
  the number of stages in the pipeline from the fetch stage to the
  execute stage. Modern microprocessors tend to have quite long
  pipelines so that the misprediction delay is between 10 and 20 clock
  cycles. As a result, making a pipeline longer increases the need for a
  more advanced branch predictor.</source>
          <target state="translated">Время,которое тратится впустую в случае ошибочного прогноза ответвления,равно количеству стадий в трубопроводе от стадии извлечения до стадии исполнения.Современные микропроцессоры,как правило,имеют достаточно длинные трубопроводы,так что задержка при ошибочном предсказании составляет от 10 до 20 тактов.В результате,увеличение длины трубопровода увеличивает потребность в более совершенном предсказании ответвления.</target>
        </trans-unit>
        <trans-unit id="146d532a4e98e5f647a42caf674908e8ad82de98" translate="yes" xml:space="preserve">
          <source>Then, you can see that the &lt;code&gt;if&lt;/code&gt; conditional is constant throughout the execution of the &lt;code&gt;i&lt;/code&gt; loop, so you can hoist the &lt;code&gt;if&lt;/code&gt; out:</source>
          <target state="translated">Затем вы можете видеть, что условие &lt;code&gt;if&lt;/code&gt; постоянно во время выполнения цикла &lt;code&gt;i&lt;/code&gt; , поэтому вы можете поднять &lt;code&gt;if&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e5bc19f51ab3899c2bcbdd21013a0f3ed4bf7a2d" translate="yes" xml:space="preserve">
          <source>Then, you see that the inner loop can be collapsed into one single expression, assuming the floating point model allows it (&lt;code&gt;/fp:fast&lt;/code&gt; is thrown, for example)</source>
          <target state="translated">Затем вы видите, что внутренний цикл можно свернуть в одно отдельное выражение, предполагая, что это допускает модель с плавающей запятой (например, &lt;code&gt;/fp:fast&lt;/code&gt; выбрасывается)</target>
        </trans-unit>
        <trans-unit id="0fdbaf8dd82a2699c782cb69604fae05291b1fe4" translate="yes" xml:space="preserve">
          <source>There has been quite some work on eliminating this branch for managed languages. For example:</source>
          <target state="translated">Была проделана большая работа по устранению этой ветки для управляемых языков.Например:</target>
        </trans-unit>
        <trans-unit id="7b8c8145d6acbc5bd1d7476826d81337b7799153" translate="yes" xml:space="preserve">
          <source>There really are three different kinds of branches:</source>
          <target state="translated">На самом деле есть три разных вида ветвей:</target>
        </trans-unit>
        <trans-unit id="df08e2eb1f25b5e02231e29ab5a1fabee4d43dce" translate="yes" xml:space="preserve">
          <source>This also &quot;proves&quot; that it has nothing to do with any algorithmic issue such as sort order, and it is indeed branch prediction.</source>
          <target state="translated">Это также &quot;доказывает&quot;,что это не имеет никакого отношения к какому-либо алгоритмическому вопросу,такому как порядок сортировки,и это действительно является предсказанием ветви.</target>
        </trans-unit>
        <trans-unit id="5f5f7d59641cd2d4e5ccd00f97168241ae614777" translate="yes" xml:space="preserve">
          <source>This approach works in general if:</source>
          <target state="translated">Этот подход работает в целом,если:</target>
        </trans-unit>
        <trans-unit id="157ae22157daa30935359fff59ce72e0d87c83f4" translate="yes" xml:space="preserve">
          <source>This code is far from optimal. The branches may take a long time in case of mispredictions. The Boolean operations can be made much more efficient if it is known with certainty that the operands have no other values than &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. The reason why the compiler does not make such an assumption is that the variables might have other values if they are uninitialized or come from unknown sources. The above code can be optimized if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has been initialized to valid values or if they come from operators that produce Boolean output. The optimized code looks like this:</source>
          <target state="translated">Этот код далеко не оптимален. Ветви могут занять много времени в случае неправильных прогнозов. Булевы операции можно сделать гораздо более эффективными, если точно известно, что операнды не имеют других значений, кроме &lt;code&gt;0&lt;/code&gt; и &lt;code&gt;1&lt;/code&gt; . Причина, по которой компилятор не делает такого предположения, заключается в том, что переменные могут иметь другие значения, если они неинициализированы или получены из неизвестных источников. Приведенный выше код можно оптимизировать, если &lt;code&gt;a&lt;/code&gt; и &lt;code&gt;b&lt;/code&gt; были инициализированы для допустимых значений или если они получены от операторов, которые выдают логический вывод. Оптимизированный код выглядит так:</target>
        </trans-unit>
        <trans-unit id="ad588604ed82a4498c092e23d01a6024f6fd9f5a" translate="yes" xml:space="preserve">
          <source>This code wastes half of the adds but never has a branch prediction failure. It's tremendously faster on random data than the version with an actual if statement.</source>
          <target state="translated">Этот код тратит половину добавок,но никогда не приводит к ошибке в предсказании ветки.Он значительно быстрее на случайных данных,чем версия с фактическим &quot;если&quot;.</target>
        </trans-unit>
        <trans-unit id="a15071f65ca5442561d11637a382876b2bbe52fb" translate="yes" xml:space="preserve">
          <source>This eliminates the branch and replaces it with some bitwise operations.</source>
          <target state="translated">Это устраняет ветку и заменяет ее некоторыми побитовыми операциями.</target>
        </trans-unit>
        <trans-unit id="bfca5608e058cd556c4ac52b23258add44c52119" translate="yes" xml:space="preserve">
          <source>This goes to show that even mature modern compilers can vary wildly in their ability to optimize code...</source>
          <target state="translated">Это говорит о том,что даже зрелые современные компиляторы могут сильно различаться в своих возможностях по оптимизации кода...</target>
        </trans-unit>
        <trans-unit id="18e2896e8160beec33e159c94bd6ee44deed00cc" translate="yes" xml:space="preserve">
          <source>This is branch prediction. I admit it's not the best analogy since the train could just signal the direction with a flag. But in computers, the processor doesn't know which direction a branch will go until the last moment.</source>
          <target state="translated">Это предсказание отрасли.Я признаю,что это не лучшая аналогия,так как поезд может просто сигнализировать направление с флагом.Но в компьютерах процессор до последнего момента не знает,в каком направлении пойдет ветка.</target>
        </trans-unit>
        <trans-unit id="d0c1d7a998794d7121446abef39a77def740f803" translate="yes" xml:space="preserve">
          <source>This is typically implemented by the compiler in the following way:</source>
          <target state="translated">Как правило,компилятор реализует это следующим образом:</target>
        </trans-unit>
        <trans-unit id="2bfa3272ab37710c1267a39900a9e349042c88c7" translate="yes" xml:space="preserve">
          <source>This is very friendly to the branch predictor since the branch consecutively goes the same direction many times. Even a simple saturating counter will correctly predict the branch except for the few iterations after it switches direction.</source>
          <target state="translated">Это очень удобно для предсказателя ветки,так как ветка последовательно идет в одном и том же направлении много раз.Даже простой счетчик насыщения будет правильно предсказывать ветку,за исключением нескольких итераций после переключения направления.</target>
        </trans-unit>
        <trans-unit id="615c711dbe5df7298f33242a06d07ca902c32379" translate="yes" xml:space="preserve">
          <source>This lets you easily identify the problematic line - in the unsorted version the &lt;code&gt;if (data[c] &amp;gt;= 128)&lt;/code&gt; line is causing 164,050,007 mispredicted conditional branches (&lt;code&gt;Bcm&lt;/code&gt;) under cachegrind's branch-predictor model, whereas it's only causing 10,006 in the sorted version.</source>
          <target state="translated">Это позволяет легко идентифицировать проблемную строку - в несортированной версии строка &lt;code&gt;if (data[c] &amp;gt;= 128)&lt;/code&gt; вызывает 164 050 007 неправильно предсказанных условных переходов ( &lt;code&gt;Bcm&lt;/code&gt; ) в модели предсказателя переходов cachegrind, тогда как в отсортированной версии она вызывает только 10 006 ,</target>
        </trans-unit>
        <trans-unit id="62a8acf06dc12988abe140d1d1ffb08120df1a06" translate="yes" xml:space="preserve">
          <source>This question has already been answered excellently many times over. Still I'd like to draw the group's attention to yet another interesting analysis.</source>
          <target state="translated">На этот вопрос уже много раз превосходно отвечали.Тем не менее,я хотел бы обратить внимание группы на еще один интересный анализ.</target>
        </trans-unit>
        <trans-unit id="7ab809ea371604dfeb3647ba6b30215c1eb2398d" translate="yes" xml:space="preserve">
          <source>This question is rooted in Branch Prediction Models on CPUs. I'd recommend reading this paper:</source>
          <target state="translated">Этот вопрос коренится в отраслевых моделях прогнозирования на центральных процессорах.Я бы порекомендовал прочитать эту статью:</target>
        </trans-unit>
        <trans-unit id="bda231ceb9d58c33b0e891be602a5fde29542e65" translate="yes" xml:space="preserve">
          <source>To execute instruction B or instruction C the processor will have to wait till the instruction A doesn't reach till EX stage in the pipeline, as the decision to go to instruction B or instruction C depends on the result of instruction A. So the pipeline will look like this.</source>
          <target state="translated">Для выполнения команды B или команды C процессор должен будет подождать,пока команда A не достигнет стадии EX в конвейере,так как решение перейти к команде B или команде C зависит от результата команды A.Таким образом,конвейер будет выглядеть следующим образом.</target>
        </trans-unit>
        <trans-unit id="0b7e892117417fb4b6c49ca103d227fc9f4d1140" translate="yes" xml:space="preserve">
          <source>To understand branch prediction one must first understand &lt;strong&gt;Instruction Pipeline&lt;/strong&gt;:</source>
          <target state="translated">Чтобы понять предсказание ветвления, нужно сначала понять &lt;strong&gt;конвейер инструкций&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="a29c68a2d5e91d86d31480109b1da5bc8e35f407" translate="yes" xml:space="preserve">
          <source>Two-way branching is usually implemented with a conditional jump
  instruction. A conditional jump can either be &quot;not taken&quot; and continue
  execution with the first branch of code which follows immediately
  after the conditional jump, or it can be &quot;taken&quot; and jump to a
  different place in program memory where the second branch of code is
  stored. It is not known for certain whether a conditional jump will be
  taken or not taken until the condition has been calculated and the
  conditional jump has passed the execution stage in the instruction
  pipeline (see fig. 1).</source>
          <target state="translated">Двустороннее разветвление обычно реализуется с помощью команды условного прыжка.Условный прыжок может быть либо &quot;не взята&quot; и продолжить выполнение с первой ветвью кода,которая следует сразу после условного прыжка,либо &quot;взята&quot; и перепрыгнуть в другое место в памяти программы,где хранится вторая ветвь кода.Неизвестно наверняка,будет ли условный прыжок выполнен до тех пор,пока условие не будет вычислено и условный прыжок не пройдет стадию выполнения в конвейере команд (см.рис.1).</target>
        </trans-unit>
        <trans-unit id="dcb1d0bc5503faffa53fc3453598b0d035a0c897" translate="yes" xml:space="preserve">
          <source>Unsorted Array: Curved Road</source>
          <target state="translated">Неотсортированный массив:извилистая дорога</target>
        </trans-unit>
        <trans-unit id="c006e2b20060032caaabd451e6df6a02a78a5ac3" translate="yes" xml:space="preserve">
          <source>Use Branch Predictor and don't take a conditional jump. Let's assume that the predict is &lt;strong&gt;not&lt;/strong&gt; taking the conditional jump.</source>
          <target state="translated">Используйте Branch Predictor и не делайте условный переход. Давайте предположим, что прогноз &lt;strong&gt;не&lt;/strong&gt; принимает условный переход.</target>
        </trans-unit>
        <trans-unit id="12c9166e85e51c6ec14fc60d80a7a0f3c7c32568" translate="yes" xml:space="preserve">
          <source>Use Branch Predictor and take a conditional jump. Let's assume that the predict is &lt;strong&gt;not&lt;/strong&gt; taking the conditional jump.</source>
          <target state="translated">Используйте Branch Predictor и сделайте условный прыжок. Давайте предположим, что прогноз &lt;strong&gt;не&lt;/strong&gt; принимает условный переход.</target>
        </trans-unit>
        <trans-unit id="a08965e116be4f8dd9b991b5c78c2f2a4953805f" translate="yes" xml:space="preserve">
          <source>Using bitwise operators is more advantageous if the operands are variables than if the operands are comparisons:</source>
          <target state="translated">Использование битовых операторов более выгодно,если операнды являются переменными,чем если операнды-это сравнения:</target>
        </trans-unit>
        <trans-unit id="753325de5864d63921392f6d1fdfec25be2f1719" translate="yes" xml:space="preserve">
          <source>VC++ 2010 is unable to generate conditional moves for this branch even under &lt;code&gt;/Ox&lt;/code&gt;.</source>
          <target state="translated">VC ++ 2010 не может генерировать условные ходы для этой ветви даже в &lt;code&gt;/Ox&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d043004e185c7b0efa7dc62df9e481517f2fae51" translate="yes" xml:space="preserve">
          <source>Visualization:</source>
          <target state="translated">Visualization:</target>
        </trans-unit>
        <trans-unit id="a3b2fe94f4750042ee509a40cd1b811c02dcc827" translate="yes" xml:space="preserve">
          <source>WB -- Write back to CPU register</source>
          <target state="translated">WB --Запишите обратно в регистр процессора.</target>
        </trans-unit>
        <trans-unit id="6375cff5f915d0ad5739238963ce456b2a75e8c2" translate="yes" xml:space="preserve">
          <source>Well, not exactly... :-)</source>
          <target state="translated">Ну,не совсем...:-)</target>
        </trans-unit>
        <trans-unit id="a608d088fa8295119cc45125ae05fa9e8da0660e" translate="yes" xml:space="preserve">
          <source>What is Branch Prediction?</source>
          <target state="translated">Что такое &quot;Прогноз отделения&quot;?</target>
        </trans-unit>
        <trans-unit id="ddc44bd3685ad0a82e462b5b7860aa861536395a" translate="yes" xml:space="preserve">
          <source>What is going on?</source>
          <target state="translated">Что происходит?</target>
        </trans-unit>
        <trans-unit id="5079282bb6ac8d8fd7800b70a515ca1a7779ded0" translate="yes" xml:space="preserve">
          <source>When you have sorted elements, IR could not be bothered to fetch all CPU instructions, again and again, It fetches them from cache.</source>
          <target state="translated">Когда вы отсортировали элементы,ИК не мог побеспокоиться,чтобы получить все инструкции процессора,снова и снова,Он получает их из кэша.</target>
        </trans-unit>
        <trans-unit id="93820c99e002586797e0fc268993184aa2c6be22" translate="yes" xml:space="preserve">
          <source>Whenever there's an &lt;code&gt;if-else&lt;/code&gt; \ &lt;code&gt;switch&lt;/code&gt; statement, the expression has to be evaluated to determine which block should be executed. In the assembly code generated by the compiler, conditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt; instructions are inserted.</source>
          <target state="translated">Всякий раз, когда есть оператор &lt;code&gt;if-else&lt;/code&gt; \ &lt;code&gt;switch&lt;/code&gt; , выражение должно быть оценено, чтобы определить, какой блок должен быть выполнен. В коде сборки, сгенерированном компилятором, вставлены инструкции условного &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;перехода&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="467f5fe90dca59bcce184cb76b5258ae0f818f25" translate="yes" xml:space="preserve">
          <source>While flushing pipelines is super fast, nowadays taking this gamble is worth it. Predicting sorted data or a data that changes slowly is always easier and better than predicting fast changes.</source>
          <target state="translated">В то время как промывка трубопроводов происходит очень быстро,в настоящее время рисковать стоит.Прогнозировать отсортированные данные или данные,которые медленно меняются,всегда проще и лучше,чем предсказывать быстрые изменения.</target>
        </trans-unit>
        <trans-unit id="7a096e98f70b03605f1fd87dee197c0e0dc2d954" translate="yes" xml:space="preserve">
          <source>While maintaining readability, we can check the speedup factor.</source>
          <target state="translated">Сохраняя читабельность,можно проверить коэффициент ускорения.</target>
        </trans-unit>
        <trans-unit id="9792cdf86b1977e88d80d53a5f46d6bb5efa646c" translate="yes" xml:space="preserve">
          <source>Why is processing a sorted array faster than processing an unsorted array</source>
          <target state="translated">Почему обработка отсортированного массива происходит быстрее,чем обработка несортированного массива.</target>
        </trans-unit>
        <trans-unit id="0ecd9604afd7fdf56bd91ee7561b152cde1f8ed3" translate="yes" xml:space="preserve">
          <source>Why is processing a sorted array faster than processing an unsorted array?</source>
          <target state="translated">Почему обработка отсортированного массива происходит быстрее,чем обработка несортированного массива?</target>
        </trans-unit>
        <trans-unit id="45e27afeaa62cf0cccdd3110fde02e47401ff594" translate="yes" xml:space="preserve">
          <source>With a similar but less extreme result.</source>
          <target state="translated">С похожим,но менее экстремальным результатом.</target>
        </trans-unit>
        <trans-unit id="00bb7f0f6f10727b9d3a497aec7ad500fc1da108" translate="yes" xml:space="preserve">
          <source>With a sorted array, the condition &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; is first &lt;code&gt;false&lt;/code&gt; for a streak of values, then becomes &lt;code&gt;true&lt;/code&gt; for all later values. That's easy to predict. With an unsorted array, you pay for the branching cost.</source>
          <target state="translated">В отсортированном массиве условие &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; сначала &lt;code&gt;false&lt;/code&gt; для серии значений, а затем становится &lt;code&gt;true&lt;/code&gt; для всех последующих значений. Это легко предсказать. С несортированным массивом вы платите за стоимость ветвления.</target>
        </trans-unit>
        <trans-unit id="9e8a52af2265d491577ac667e610164d2bae82ec" translate="yes" xml:space="preserve">
          <source>With loop interchange, we can safely change this loop to:</source>
          <target state="translated">С заменой петли мы можем безопасно изменить эту петлю:</target>
        </trans-unit>
        <trans-unit id="b07d7d0e763b2a76e028689779bd9793c81728e8" translate="yes" xml:space="preserve">
          <source>With the sorted data, the code runs in 1.93 seconds.</source>
          <target state="translated">С отсортированными данными код выполняется за 1,93 секунды.</target>
        </trans-unit>
        <trans-unit id="cdf4ffa875649aacf9a2112d2448609655f91aec" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;std::sort(data, data + arraySize);&lt;/code&gt;, the code runs in 11.54 seconds.</source>
          <target state="translated">Без &lt;code&gt;std::sort(data, data + arraySize);&lt;/code&gt; код выполняется за 11,54 секунды.</target>
        </trans-unit>
        <trans-unit id="f595b01765d8ae905ea5e9dd7e62d7a02b4fbe22" translate="yes" xml:space="preserve">
          <source>Without branch prediction, the following would occur:</source>
          <target state="translated">Без предсказания ветви произошло бы следующее:</target>
        </trans-unit>
        <trans-unit id="b4764b924495da3570f6397640729704193386e0" translate="yes" xml:space="preserve">
          <source>Without branch prediction, the processor would have to wait until the
  conditional jump instruction has passed the execute stage before the
  next instruction can enter the fetch stage in the pipeline.</source>
          <target state="translated">Без прогнозирования ответвления процессору пришлось бы подождать,пока инструкция условного прыжка пройдет стадию выполнения,прежде чем следующая инструкция сможет войти в стадию извлечения в трубопроводе.</target>
        </trans-unit>
        <trans-unit id="8fa9477c95d3ffecec4695db62b573324832754a" translate="yes" xml:space="preserve">
          <source>Without the Branch Predictor.</source>
          <target state="translated">Без &quot;Бранч Предиктор&quot;.</target>
        </trans-unit>
        <trans-unit id="0dee180d4b195226d6d709eb16ec0e42b8a820e7" translate="yes" xml:space="preserve">
          <source>You are a processor and you see a branch. You have no idea which way it will go. What do you do? You halt execution and wait until the previous instructions are complete. Then you continue down the correct path.</source>
          <target state="translated">Вы процессор и видите ветку.Вы понятия не имеете,в какую сторону она пойдет.Чем вы занимаетесь? Вы останавливаете выполнение и ждёте завершения предыдущих инструкций.Затем вы продолжаете идти по правильному пути.</target>
        </trans-unit>
        <trans-unit id="3747acc12d9a8b4eeed31b6769fc516a8c97c9dd" translate="yes" xml:space="preserve">
          <source>You are the operator of a junction and you hear a train coming. You have no idea which way it is supposed to go. You stop the train to ask the driver which direction they want. And then you set the switch appropriately.</source>
          <target state="translated">Вы-оператор перекрестка и слышите,как приближается поезд.Ты понятия не имеешь,в какую сторону он должен ехать.Вы останавливаете поезд,чтобы спросить машиниста,в какую сторону он хочет ехать.А затем вы устанавливаете переключатель соответствующим образом.</target>
        </trans-unit>
        <trans-unit id="a55200fca28b7f0ac1706d86d79e8114433a8b42" translate="yes" xml:space="preserve">
          <source>You can also see from this lovely &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor#/media/File:Branch_prediction_2bit_saturating_counter-dia.svg&quot;&gt;diagram&lt;/a&gt; why the branch predictor gets confused.</source>
          <target state="translated">Вы также можете увидеть из этой прекрасной &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor#/media/File:Branch_prediction_2bit_saturating_counter-dia.svg&quot;&gt;диаграммы,&lt;/a&gt; почему предсказатель ветвления запутывается.</target>
        </trans-unit>
        <trans-unit id="33b05101ba2f17cb142e08e195f5e37dbb2cf22d" translate="yes" xml:space="preserve">
          <source>You can have a stop condition instead of just checking the value, this way you only loop over the relevant data, and ignore the rest.</source>
          <target state="translated">Вы можете иметь условие стопа,вместо того,чтобы просто проверять значение,таким образом,вы только зацикливаете соответствующие данные,а остальное игнорируете.</target>
        </trans-unit>
        <trans-unit id="e7cdaed049a36de91bc0b6220dbae638a556dd97" translate="yes" xml:space="preserve">
          <source>You might wonder why this works well in managed languages. After all, managed languages check the boundaries of the arrays with a branch to ensure you don't mess up...</source>
          <target state="translated">Вы можете удивиться,почему это хорошо работает на управляемых языках.В конце концов,управляемые языки проверяют границы массивов с помощью ветки,чтобы не испортить...</target>
        </trans-unit>
        <trans-unit id="f6967173a58337d24e84af6ae18adb3fbbae9e11" translate="yes" xml:space="preserve">
          <source>can be optimized to:</source>
          <target state="translated">можно оптимизировать:</target>
        </trans-unit>
        <trans-unit id="576ab25730c6c8fde51cea0123c6a7dd40910123" translate="yes" xml:space="preserve">
          <source>is optimal in most cases (unless you expect the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; expression to generate many branch mispredictions).</source>
          <target state="translated">в большинстве случаев является оптимальным (если только вы не ожидаете, что выражение &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; вызовет много неправильных прогнозов ветвлений).</target>
        </trans-unit>
        <trans-unit id="a45d05b730bbc58dc46e14dafb3c0d1d4583c878" translate="yes" xml:space="preserve">
          <source>it's a nice solution maybe it will work</source>
          <target state="translated">это хорошее решение,может быть,оно сработает.</target>
        </trans-unit>
        <trans-unit id="c3bfc02b43a0aa6f110706cfedc26e042e2f304a" translate="yes" xml:space="preserve">
          <source>it's a small table and is likely to be cached in the processor, and</source>
          <target state="translated">это маленький стол и,скорее всего,будет кэшироваться в процессоре,и</target>
        </trans-unit>
        <trans-unit id="651a852c52cc01c89e5ea1bd7793b4460d1de61f" translate="yes" xml:space="preserve">
          <source>or similarly:</source>
          <target state="translated">или что-то в этом роде:</target>
        </trans-unit>
        <trans-unit id="495520e358c6efe36183f5f5cfdfb1a5f7540a8b" translate="yes" xml:space="preserve">
          <source>or, slightly more obfuscated</source>
          <target state="translated">или,чуть более замысловатый</target>
        </trans-unit>
        <trans-unit id="f11d2b737879c47db5e53479b4f6bb83db8e1df9" translate="yes" xml:space="preserve">
          <source>so the predictor will change sides as the &lt;code&gt;std::rand()&lt;/code&gt; blow.</source>
          <target state="translated">поэтому предиктор будет менять сторону при ударе &lt;code&gt;std::rand()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0234c36fd5c76bfa6dcd2e321618d03cb21418f9" translate="yes" xml:space="preserve">
          <source>this library would do something like:</source>
          <target state="translated">эта библиотека сделала бы что-то вроде:</target>
        </trans-unit>
        <trans-unit id="46ebea860b14c6c60e10f66281ac11838db11fdf" translate="yes" xml:space="preserve">
          <source>we can find that the meaning of this particular &lt;code&gt;if... else...&lt;/code&gt; branch is to add something when a condition is satisfied. This type of branch can be easily transformed into a &lt;strong&gt;conditional move&lt;/strong&gt; statement, which would be compiled into a conditional move instruction: &lt;code&gt;cmovl&lt;/code&gt;, in an &lt;code&gt;x86&lt;/code&gt; system. The branch and thus the potential branch prediction penalty is removed.</source>
          <target state="translated">мы можем обнаружить, что смысл этой конкретной ветви &lt;code&gt;if... else...&lt;/code&gt; состоит в том, чтобы добавить что-то, когда условие выполнено. Этот тип ветки можно легко преобразовать в оператор &lt;strong&gt;условного перемещения&lt;/strong&gt; , который будет скомпилирован в инструкцию условного перемещения: &lt;code&gt;cmovl&lt;/code&gt; , в системе &lt;code&gt;x86&lt;/code&gt; . Ветвление и, следовательно, потенциальное наказание за предсказание ветвления удаляются.</target>
        </trans-unit>
        <trans-unit id="52e0612303b39c0691e807b9c7a297fa35003367" translate="yes" xml:space="preserve">
          <source>with:</source>
          <target state="translated">with:</target>
        </trans-unit>
        <trans-unit id="4e59d494e29779b82beb957429950a6c38d3846b" translate="yes" xml:space="preserve">
          <source>you are running things in a quite tight loop and/or the processor can preload the data.</source>
          <target state="translated">вы работаете в довольно жестком цикле,а процессор может предварительно загрузить данные.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
