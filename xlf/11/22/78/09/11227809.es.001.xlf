<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/11227809">
    <body>
      <group id="11227809">
        <trans-unit id="b53667fac1b1818f469635cd98c1992443873e79" translate="yes" xml:space="preserve">
          <source>(Or somewhat fast: for the already-sorted case, &lt;code&gt;cmov&lt;/code&gt; can be slower especially if GCC puts it on the critical path instead of just &lt;code&gt;add&lt;/code&gt;, especially on Intel before Broadwell where &lt;code&gt;cmov&lt;/code&gt; has 2 cycle latency: &lt;a href=&quot;https://stackoverflow.com/questions/28875325/gcc-optimization-flag-o3-makes-code-slower-than-o2&quot;&gt;gcc optimization flag -O3 makes code slower than -O2&lt;/a&gt;)</source>
          <target state="translated">(O algo r&amp;aacute;pido: para el caso ya ordenado, &lt;code&gt;cmov&lt;/code&gt; puede ser m&amp;aacute;s lento, especialmente si GCC lo coloca en la ruta cr&amp;iacute;tica en lugar de simplemente &lt;code&gt;add&lt;/code&gt; , especialmente en Intel antes de Broadwell, donde &lt;code&gt;cmov&lt;/code&gt; tiene una latencia de 2 ciclos: el &lt;a href=&quot;https://stackoverflow.com/questions/28875325/gcc-optimization-flag-o3-makes-code-slower-than-o2&quot;&gt;indicador de optimizaci&amp;oacute;n de gcc -O3 hace que el c&amp;oacute;digo sea m&amp;aacute;s lento que -O2&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d1ea744eaff022b9ec4d3d58be32b719619a16de" translate="yes" xml:space="preserve">
          <source>// Declare and then fill in the lookup table</source>
          <target state="translated">/Declarar y luego llenar la tabla de b√∫squeda</target>
        </trans-unit>
        <trans-unit id="439750f5cd724a86cdb0b90f611fcdf4d601b584" translate="yes" xml:space="preserve">
          <source>// Test</source>
          <target state="translated">/Prueba</target>
        </trans-unit>
        <trans-unit id="22e070d61d4ac5f3e0981ca4d20241ae99b358d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler&quot;&gt;Intel C++ Compiler&lt;/a&gt; (ICC) 11 does something miraculous. It &lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_interchange&quot;&gt;interchanges the two loops&lt;/a&gt;, thereby hoisting the unpredictable branch to the outer loop. So not only is it immune to the mispredictions, it is also twice as fast as whatever VC++ and GCC can generate! In other words, ICC took advantage of the test-loop to defeat the benchmark...</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler&quot;&gt;Intel C ++ Compiler&lt;/a&gt; (ICC) 11 hace algo milagroso. &lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_interchange&quot;&gt;Intercambia los dos bucles&lt;/a&gt; , elevando as&amp;iacute; la rama impredecible al bucle externo. Por lo tanto, no solo es inmune a las predicciones err&amp;oacute;neas, &amp;iexcl;tambi&amp;eacute;n es dos veces m&amp;aacute;s r&amp;aacute;pido que lo que puedan generar VC ++ y GCC! En otras palabras, ICC aprovech&amp;oacute; el bucle de prueba para vencer el punto de referencia ...</target>
        </trans-unit>
        <trans-unit id="637937a9b16b61115d58b45cd478f01d51765e8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADD R1, R2, R3&lt;/code&gt; performs &lt;code&gt;R1 = R2 + R3&lt;/code&gt; without updating any status bits.</source>
          <target state="translated">&lt;code&gt;ADD R1, R2, R3&lt;/code&gt; realiza &lt;code&gt;R1 = R2 + R3&lt;/code&gt; sin actualizar ning&amp;uacute;n bit de estado.</target>
        </trans-unit>
        <trans-unit id="87d9034703b27f8b1421db3174bb0a89354e4fdd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDGE R1, R2, R3&lt;/code&gt; performs the same operation only if a previous instruction that affected the status bits resulted in a Greater than or Equal condition.</source>
          <target state="translated">&lt;code&gt;ADDGE R1, R2, R3&lt;/code&gt; realiza la misma operaci&amp;oacute;n solo si una instrucci&amp;oacute;n previa que afect&amp;oacute; a los bits de estado result&amp;oacute; en una condici&amp;oacute;n Mayor o Igual.</target>
        </trans-unit>
        <trans-unit id="23f6fd5b0c8ae0b7004305abd5527096f2e1cd0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDS R1, R2, R3&lt;/code&gt; performs the addition and then updates the &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; flags in the Processor Status Register based on whether the result was Negative, Zero, Carried (for unsigned addition), or oVerflowed (for signed addition).</source>
          <target state="translated">&lt;code&gt;ADDS R1, R2, R3&lt;/code&gt; realiza la adici&amp;oacute;n y luego actualiza los indicadores &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;Z&lt;/code&gt; , &lt;code&gt;C&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; en el Registro de estado del procesador en funci&amp;oacute;n de si el resultado fue Negativo, Cero, Llevado (para la adici&amp;oacute;n sin firmar) o OVerflowed (para la adici&amp;oacute;n firmada) .</target>
        </trans-unit>
        <trans-unit id="9dc9f762599510b8def52bb6b16ab86d5b605418" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDSGE R1, R2, R3&lt;/code&gt; performs the addition only if the &lt;code&gt;GE&lt;/code&gt; test is true, and then subsequently updates the status bits based on the result of the addition.</source>
          <target state="translated">&lt;code&gt;ADDSGE R1, R2, R3&lt;/code&gt; realiza la adici&amp;oacute;n solo si la prueba de &lt;code&gt;GE&lt;/code&gt; es verdadera, y luego actualiza los bits de estado en funci&amp;oacute;n del resultado de la adici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6c4200c52c77a8809e0c28b82431a4fcd7fb0319" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CMP&lt;/code&gt; opcodes always update the status bits in the Processor Status Register (PSR), because that is their purpose, but most other instructions do not touch the PSR unless you add an optional &lt;code&gt;S&lt;/code&gt; suffix to the instruction, specifying that the PSR should be updated based on the result of the instruction. &lt;strong&gt;Just like the 4-bit condition suffix, being able to execute instructions without affecting the PSR is a mechanism that reduces the need for branches on ARM, and also facilitates out of order dispatch at the hardware level&lt;/strong&gt;, because after performing some operation X that updates the status bits, subsequently (or in parallel) you can do a bunch of other work that explicitly should not affect the status bits, then you can test the state of the status bits set earlier by X.</source>
          <target state="translated">&lt;code&gt;CMP&lt;/code&gt; operaci&amp;oacute;n CMP siempre actualizan los bits de estado en el Registro de estado del procesador (PSR), porque ese es su prop&amp;oacute;sito, pero la mayor&amp;iacute;a de las otras instrucciones no tocan el PSR a menos que agregue un sufijo &lt;code&gt;S&lt;/code&gt; opcional a la instrucci&amp;oacute;n, especificando que el PSR debe actualizarse seg&amp;uacute;n en el resultado de la instrucci&amp;oacute;n. &lt;strong&gt;Al igual que el sufijo de condici&amp;oacute;n de 4 bits, poder ejecutar instrucciones sin afectar el PSR es un mecanismo que reduce la necesidad de ramificaciones en ARM y tambi&amp;eacute;n facilita el env&amp;iacute;o fuera de servicio a nivel de hardware&lt;/strong&gt; , porque despu&amp;eacute;s de realizar alguna operaci&amp;oacute;n X se actualiza los bits de estado, posteriormente (o en paralelo) puede hacer un mont&amp;oacute;n de otro trabajo que expl&amp;iacute;citamente no deber&amp;iacute;a afectar los bits de estado, luego puede probar el estado de los bits de estado establecidos anteriormente por X.</target>
        </trans-unit>
        <trans-unit id="391873c374a8ded8013438f8a2663a8948bf98aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; cannot be replaced with &lt;code&gt;a &amp;amp; b&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is an expression that should not be evaluated if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will not evaluate &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; will). Likewise, &lt;code&gt;a || b&lt;/code&gt; can not be replaced with &lt;code&gt;a | b&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is an expression that should not be evaluated if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; no se puede reemplazar con &lt;code&gt;a &amp;amp; b&lt;/code&gt; si &lt;code&gt;b&lt;/code&gt; es una expresi&amp;oacute;n que no debe evaluarse si &lt;code&gt;a&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; no evaluar&amp;aacute; &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; will). Del mismo modo, &lt;code&gt;a || b&lt;/code&gt; b no se puede reemplazar con &lt;code&gt;a | b&lt;/code&gt; b si &lt;code&gt;b&lt;/code&gt; es una expresi&amp;oacute;n que no debe evaluarse si &lt;code&gt;a&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3da7ae3851d0cb07b784c1504abb04501c97c690" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; is used instead of &lt;code&gt;bool&lt;/code&gt; in order to make it possible to use the bitwise operators (&lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) instead of the Boolean operators (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;). The bitwise operators are single instructions that take only one clock cycle. The OR operator (&lt;code&gt;|&lt;/code&gt;) works even if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have other values than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. The AND operator (&lt;code&gt;&amp;amp;&lt;/code&gt;) and the EXCLUSIVE OR operator (&lt;code&gt;^&lt;/code&gt;) may give inconsistent results if the operands have other values than &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; se usa en lugar de &lt;code&gt;bool&lt;/code&gt; para que sea posible usar los operadores bit a bit ( &lt;code&gt;&amp;amp;&lt;/code&gt; y &lt;code&gt;|&lt;/code&gt; ) en lugar de los operadores booleanos ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; y &lt;code&gt;||&lt;/code&gt; ). Los operadores bit a bit son instrucciones simples que toman solo un ciclo de reloj. El operador OR ( &lt;code&gt;|&lt;/code&gt; ) funciona incluso si &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; tienen valores distintos de &lt;code&gt;0&lt;/code&gt; o &lt;code&gt;1&lt;/code&gt; . El operador AND ( &lt;code&gt;&amp;amp;&lt;/code&gt; ) y el operador EXCLUSIVO OR ( &lt;code&gt;^&lt;/code&gt; ) pueden dar resultados inconsistentes si los operandos tienen otros valores distintos de &lt;code&gt;0&lt;/code&gt; y &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2116c486e51bc36c5ea4f4ea724a4decd73ddf80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max1&lt;/code&gt; uses the conditional branch &lt;code&gt;if... else ...&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;max1&lt;/code&gt; usa la rama condicional &lt;code&gt;if... else ...&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5c4a2ff8aabdb7de009ae921d3d149a4fd4a3981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max2&lt;/code&gt; uses much less code due to the usage of instruction &lt;code&gt;cmovge&lt;/code&gt;. But the real gain is that &lt;code&gt;max2&lt;/code&gt; does not involve branch jumps, &lt;code&gt;jmp&lt;/code&gt;, which would have a significant performance penalty if the predicted result is not right.</source>
          <target state="translated">&lt;code&gt;max2&lt;/code&gt; usa mucho menos c&amp;oacute;digo debido al uso de la instrucci&amp;oacute;n &lt;code&gt;cmovge&lt;/code&gt; . Pero la ganancia real es que &lt;code&gt;max2&lt;/code&gt; no involucra saltos de rama, &lt;code&gt;jmp&lt;/code&gt; , lo que tendr&amp;iacute;a una penalizaci&amp;oacute;n de rendimiento significativa si el resultado predicho no es correcto.</target>
        </trans-unit>
        <trans-unit id="3a816aa9d54ebe21437fa8cb172a780bbab33269" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max2&lt;/code&gt; uses the ternary operator &lt;code&gt;... ? ... : ...&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;max2&lt;/code&gt; usa el operador ternario &lt;code&gt;... ? ... : ...&lt;/code&gt; ...: ... :</target>
        </trans-unit>
        <trans-unit id="562cd5fce1e7b6dcbe296f9206498ac8e7ed271a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt; can not be used for NOT. Instead, you can make a Boolean NOT on a variable which is known to be &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; by XOR'ing it with &lt;code&gt;1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; no se puede usar para NO. En cambio, puede hacer un NOT booleano en una variable que se sabe que es &lt;code&gt;0&lt;/code&gt; o &lt;code&gt;1&lt;/code&gt; haciendo XOR con &lt;code&gt;1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="86968cc91f6395ac3372778b6f3bd6927c8f9854" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;A Demonstration of Self-Profiling&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;Una demostraci&amp;oacute;n de autoperforaci&amp;oacute;n&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62a5257803ca2425233ddd03c4d7d207b6867e4a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://courses.cs.washington.edu/courses/csep548/06au/lectures/branchPred.pdf&quot;&gt;Branch Prediction Review&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://courses.cs.washington.edu/courses/csep548/06au/lectures/branchPred.pdf&quot;&gt;Revisi&amp;oacute;n de predicci&amp;oacute;n de rama&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e83995c1786dac19461a4d31bc4d8b9cde96f71d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Branch predictor&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Predictor de rama&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17ca7e4d199635bbed9dd553888d82060ea8e587" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://stackoverflow.blog/2019/10/11/c-creator-bjarne-stroustrup-answers-our-top-five-c-questions/&quot;&gt;Bjarne Stroustrup's Answer&lt;/a&gt; to this question:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.blog/2019/10/11/c-creator-bjarne-stroustrup-answers-our-top-five-c-questions/&quot;&gt;La respuesta de Bjarne Stroustrup&lt;/a&gt; a esta pregunta:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6999c55f1112ac2522394d373dcc92bf8ba35d17" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://web.njit.edu/~rlopes/Mod5.3.pdf&quot;&gt;Branch Prediction&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://web.njit.edu/~rlopes/Mod5.3.pdf&quot;&gt;Predicci&amp;oacute;n de rama&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2567a75f2917b4cf19219547a29e45cd68bfc50" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Modern processors are complicated and have long pipelines. So they take forever to &quot;warm up&quot; and &quot;slow down&quot;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Los procesadores modernos son complicados y tienen tuber&amp;iacute;as largas.&lt;/em&gt; &lt;em&gt;Por eso tardan una eternidad en &quot;calentarse&quot; y &quot;reducir la velocidad&quot;.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c4e8b34981c89b9e7eadedce54ab4bf99abb400" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Trains are heavy and have a lot of inertia. So they take forever to start up and slow down.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Los trenes son pesados ‚Äã‚Äãy tienen mucha inercia.&lt;/em&gt; &lt;em&gt;Por eso tardan una eternidad en comenzar y reducir la velocidad.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dfd2a9e0eebface4570f5726ff229d9f7239571" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Static&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. Est&amp;aacute;tica&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec921c20fc92beab445f0b65b62aac1dc30fda89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Dynamic&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. Din&amp;aacute;mico&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7070b983b9e682ffd47dc61eb8173e377437895" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;4-stage pipeline in general for 2 instructions.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Tuber&amp;iacute;a de 4 etapas en general para 2 instrucciones.&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7c0dc2f57cc914145b6b0624cff97eb77959909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;But this is actually part of a bigger picture:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Pero esto es realmente parte de una imagen m&amp;aacute;s grande:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a57d022fefdf1a6dc6fb7aff0b41a4c5a3d4191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;In case of a correct guess, the pipeline looks something like this:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;En caso de una suposici&amp;oacute;n correcta, la tuber&amp;iacute;a se ve as&amp;iacute;:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="059ec29570653df3139916923c59df324c15a8f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;In other words, you try to identify a pattern and follow it.&lt;/em&gt;&lt;/strong&gt; This is more or less how branch predictors work.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;En otras palabras, intenta identificar un patr&amp;oacute;n y seguirlo.&lt;/em&gt;&lt;/strong&gt; As&amp;iacute; es m&amp;aacute;s o menos c&amp;oacute;mo funcionan los predictores de rama.</target>
        </trans-unit>
        <trans-unit id="e2c23a7d4a1b5f910c13dc8dd8d34c2b4feb4d6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When if condition returns false:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Cuando la condici&amp;oacute;n devuelve falso:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4757bf44b2540d4c3544fbd8ed736018934b59c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;when if condition returns true:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;cuando si la condici&amp;oacute;n devuelve verdadero:&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a145133a463629536767d61372777b3b15514477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Background and why&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Antecedentes y por qu&amp;eacute;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="03ac7fc31e2558f71e7c0316cacb5b6078717e4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Backward conditional branches&lt;/strong&gt; - the PC is changed to point backward in the instruction stream. The branch is based on some condition, such as branching backwards to the beginning of a program loop when a test at the end of the loop states the loop should be executed again.</source>
          <target state="translated">&lt;strong&gt;Ramas condicionales hacia atr&amp;aacute;s&lt;/strong&gt; : la PC se cambia para apuntar hacia atr&amp;aacute;s en la secuencia de instrucciones. La bifurcaci&amp;oacute;n se basa en alguna condici&amp;oacute;n, como la bifurcaci&amp;oacute;n hacia atr&amp;aacute;s al comienzo de un bucle de programa cuando una prueba al final del bucle indica que el bucle debe ejecutarse nuevamente.</target>
        </trans-unit>
        <trans-unit id="88725d83d10b621a1197929903db27ce4176d85e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Benchmarks: Core i7 920 @ 3.5 GHz&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Puntos de referencia: Core i7 920 @ 3.5 GHz&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29e42a036c1d0c70cc19beaa407c40f6950cdef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch prediction.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Predicci&amp;oacute;n de rama.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c55e466ed2fc88a1e76e953db7f49f1fd3730ab3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch prediction&lt;/strong&gt; makes the logic run slower, because of the switching which happens in your code! It's like you are going a straight street or a street with a lot of turnings, for sure the straight one is going to be done quicker!...</source>
          <target state="translated">&lt;strong&gt;&amp;iexcl;La predicci&amp;oacute;n de bifurcaci&amp;oacute;n&lt;/strong&gt; hace que la l&amp;oacute;gica funcione m&amp;aacute;s lentamente, debido al cambio que ocurre en su c&amp;oacute;digo! Es como si estuvieras yendo por una calle recta o una calle con muchas curvas, &amp;iexcl;seguro que la recta se har&amp;aacute; m&amp;aacute;s r&amp;aacute;pido! ...</target>
        </trans-unit>
        <trans-unit id="d218041da74b681266dd3bc64ecbec4c36a29624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch-prediction gain!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ganancia de predicci&amp;oacute;n de rama!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e98dec0bd0a7e8e2059d13e9a8c88d55b96ae930" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Consider an if-statement:&lt;/strong&gt; At the processor level, it is a branch instruction:</source>
          <target state="translated">&lt;strong&gt;Considere una declaraci&amp;oacute;n if:&lt;/strong&gt; a nivel de procesador, es una instrucci&amp;oacute;n de bifurcaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="c1e69093a905a8b010540753c555aae1f8e36d3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructing a table&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Construyendo una mesa&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="130a0bfbd8fc444b6379d249ad5d24a0e69aaf6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Forward conditional branches&lt;/strong&gt; - based on a run-time condition, the PC (program counter) is changed to point to an address forward in the instruction stream.</source>
          <target state="translated">&lt;strong&gt;Ramificaciones condicionales de reenv&amp;iacute;o&lt;/strong&gt; : en funci&amp;oacute;n de una condici&amp;oacute;n de tiempo de ejecuci&amp;oacute;n, la PC (contador de programa) se cambia para apuntar a una direcci&amp;oacute;n hacia adelante en la secuencia de instrucciones.</target>
        </trans-unit>
        <trans-unit id="5bb5d1ddff4f6d3eb81208ce3786e0186300f35b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess right every time&lt;/strong&gt;, the execution will never have to stop.</source>
          <target state="translated">&lt;strong&gt;Si acierta siempre&lt;/strong&gt; , la ejecuci&amp;oacute;n nunca tendr&amp;aacute; que detenerse.</target>
        </trans-unit>
        <trans-unit id="5c443327b64ce0afa013e0a8c686cce4fcb25e64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess right every time&lt;/strong&gt;, the train will never have to stop.</source>
          <target state="translated">&lt;strong&gt;Si aciertas siempre&lt;/strong&gt; , el tren nunca tendr&amp;aacute; que detenerse.</target>
        </trans-unit>
        <trans-unit id="43854ebdaaaf1f8914276249ab523b2bf804d1c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess wrong too often&lt;/strong&gt;, the train will spend a lot of time stopping, backing up, and restarting.</source>
          <target state="translated">&lt;strong&gt;Si adivina mal con demasiada frecuencia&lt;/strong&gt; , el tren pasar&amp;aacute; mucho tiempo deteni&amp;eacute;ndose, retrocediendo y reiniciando.</target>
        </trans-unit>
        <trans-unit id="ff48f0bff759820faca0dc4ce0d054010aa2a369" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess wrong too often&lt;/strong&gt;, you spend a lot of time stalling, rolling back, and restarting.</source>
          <target state="translated">&lt;strong&gt;Si adivina mal con demasiada frecuencia&lt;/strong&gt; , pasa mucho tiempo deteni&amp;eacute;ndose, retrocediendo y reiniciando.</target>
        </trans-unit>
        <trans-unit id="29e3b2963af7a82c74a39140e23e664c8aa6638f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Increasing the Instruction Fetch Rate via Multiple Branch Prediction and a Branch Address Cache&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Aumento de la tasa de obtenci&amp;oacute;n de instrucciones a trav&amp;eacute;s de la predicci&amp;oacute;n de m&amp;uacute;ltiples sucursales y un cach&amp;eacute; de direcciones de sucursal&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80ce9cf0a86a6ef1b733fbee4d9e322ccb10c80d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's do some bench marking to understand it better&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Hagamos algunas marcas de banco para entenderlo mejor&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6ddf289b433253c5925b3f9813d36a0537be7c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Managed languages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Idiomas gestionados&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a1b89da59705a9d2d5291d59ff4a51ef12d08c3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Quick visualization:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Visualizaci&amp;oacute;n r&amp;aacute;pida:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5270a251ef82abdcf7f4c1527f163a3cea8e0e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what can be done?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Entonces, &amp;iquest;qu&amp;eacute; puede hacerse?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ab826d0d5faf44d4a7a8a7aad1ef803be005faf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what is branch prediction?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Entonces, &amp;iquest;qu&amp;eacute; es la predicci&amp;oacute;n de rama?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d285155e760355be2f39c1257c5821d5da261a1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorted:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sorted:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd9c2da2ee8d01be5229516e95ec725d64e3f165" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static/dynamic Branch Prediction&lt;/strong&gt;: Static branch prediction is used by the microprocessor the first time a conditional branch is encountered, and dynamic branch prediction is used for succeeding executions of the conditional branch code.</source>
          <target state="translated">&lt;strong&gt;Predicci&amp;oacute;n de&lt;/strong&gt; bifurcaci&amp;oacute;n &lt;strong&gt;est&amp;aacute;tica / din&amp;aacute;mica&lt;/strong&gt; : el microprocesador usa la predicci&amp;oacute;n de bifurcaci&amp;oacute;n est&amp;aacute;tica la primera vez que se encuentra una bifurcaci&amp;oacute;n condicional, y la predicci&amp;oacute;n de bifurcaci&amp;oacute;n din&amp;aacute;mica se usa para ejecutar con &amp;eacute;xito el c&amp;oacute;digo de bifurcaci&amp;oacute;n condicional.</target>
        </trans-unit>
        <trans-unit id="078fac8f79d7e758f85f3007634fdc8cb9777688" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result of this case&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;El resultado de este caso.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6315a32d6eff633cf664b3192d3c2b8360df6c43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unconditional branches&lt;/strong&gt; - this includes jumps, procedure calls and returns that have no specific condition. For example, an unconditional jump instruction might be coded in assembly language as simply &quot;jmp&quot;, and the instruction stream must immediately be directed to the target location pointed to by the jump instruction, whereas a conditional jump that might be coded as &quot;jmpne&quot; would redirect the instruction stream only if the result of a comparison of two values in a previous &quot;compare&quot; instructions shows the values to not be equal. (The segmented addressing scheme used by the x86 architecture adds extra complexity, since jumps can be either &quot;near&quot; (within a segment) or &quot;far&quot; (outside the segment). Each type has different effects on branch prediction algorithms.)</source>
          <target state="translated">&lt;strong&gt;Ramas incondicionales&lt;/strong&gt; : esto incluye saltos, llamadas a procedimientos y devoluciones que no tienen una condici&amp;oacute;n espec&amp;iacute;fica. Por ejemplo, una instrucci&amp;oacute;n de salto incondicional puede codificarse en lenguaje ensamblador simplemente como &quot;jmp&quot;, y la secuencia de instrucciones debe dirigirse inmediatamente a la ubicaci&amp;oacute;n de destino se&amp;ntilde;alada por la instrucci&amp;oacute;n de salto, mientras que un salto condicional que puede codificarse como &quot;jmpne&quot; redirigir&amp;iacute;a el flujo de instrucciones solo si el resultado de una comparaci&amp;oacute;n de dos valores en instrucciones anteriores de &quot;comparaci&amp;oacute;n&quot; muestra que los valores no son iguales. (El esquema de direccionamiento segmentado utilizado por la arquitectura x86 agrega complejidad adicional, ya que los saltos pueden ser &quot;cercanos&quot; (dentro de un segmento) o &quot;lejanos&quot; (fuera del segmento). Cada tipo tiene diferentes efectos en los algoritmos de predicci&amp;oacute;n de ramas.</target>
        </trans-unit>
        <trans-unit id="d1721438d4fa087c689f86212f2138f7505dcb3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unsorted:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Unsorted:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8dfd8a5f8f4a830eea9365b9b460097fbbe4381" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With the Branch:&lt;/strong&gt; There is a huge difference between the sorted and unsorted data.</source>
          <target state="translated">&lt;strong&gt;Con la sucursal:&lt;/strong&gt; existe una gran diferencia entre los datos ordenados y no clasificados.</target>
        </trans-unit>
        <trans-unit id="03b5fb42d9ac84ced19e05a65a21ee596d5d6f7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With the Hack:&lt;/strong&gt; There is no difference between sorted and unsorted data.</source>
          <target state="translated">&lt;strong&gt;Con el Hack:&lt;/strong&gt; no hay diferencia entre los datos ordenados y no clasificados.</target>
        </trans-unit>
        <trans-unit id="b16311ddb39aa62e4ad47e876353ac768d1b5d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You are a victim of &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;branch prediction&lt;/a&gt; fail.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Eres v&amp;iacute;ctima de una falla de &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;predicci&amp;oacute;n&lt;/a&gt; de rama .&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c786fafb5f8da23c331a0d7afceac4aae6e0c19e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;x64&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;x64&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b2f35b1567a33263e752a9bf7e298fd26bd105c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;x86&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;x86&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56bb00227cc3f2c966ad0c07a94c169bef8507ca" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Note that this hack is not strictly equivalent to the original if-statement. But in this case, it's valid for all the input values of &lt;code&gt;data[]&lt;/code&gt;.)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;(Tenga en cuenta que este truco no es estrictamente equivalente a la instrucci&amp;oacute;n if original. Pero en este caso, es v&amp;aacute;lido para todos los valores de entrada de &lt;code&gt;data[]&lt;/code&gt; ).&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="daf1c2db057b9141218780bbe961c3fb9781bf1a" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;a href=&quot;//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG&quot;&gt;Image&lt;/a&gt; by Mecanismo, via Wikimedia Commons. Used under the &lt;a href=&quot;//creativecommons.org/licenses/by-sa/3.0/deed.en&quot;&gt;CC-By-SA 3.0&lt;/a&gt; license.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;a href=&quot;//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG&quot;&gt;Imagen&lt;/a&gt; de Mecanismo, v&amp;iacute;a Wikimedia Commons.&lt;/sub&gt; &lt;sub&gt;Usado bajo la &lt;a href=&quot;//creativecommons.org/licenses/by-sa/3.0/deed.en&quot;&gt;licencia CC-By-SA 3.0&lt;/a&gt; .&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="85f4f86517c13577daac8db1438bfa704a81d1f5" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;strong&gt;bad&lt;/strong&gt;&amp;rdquo; true-false pattern can make an &lt;code&gt;if&lt;/code&gt;-statement up to six times slower than a &amp;ldquo;&lt;strong&gt;good&lt;/strong&gt;&amp;rdquo; pattern! Of course, which pattern is good and which is bad depends on the exact instructions generated by the compiler and on the specific processor.</source>
          <target state="translated">&amp;iexcl;Un patr&amp;oacute;n &quot;falso&quot; verdadero-falso puede hacer que una declaraci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; sea ‚Äã‚Äãhasta seis veces m&amp;aacute;s lenta que un patr&amp;oacute;n &quot; &lt;strong&gt;bueno&lt;/strong&gt; &quot;! Por supuesto, qu&amp;eacute; patr&amp;oacute;n es bueno y cu&amp;aacute;l es malo depende de las instrucciones exactas generadas por el compilador y el procesador espec&amp;iacute;fico.</target>
        </trans-unit>
        <trans-unit id="fa9002e4deffeb589b075bfcdf8a5cf9a18e318c" translate="yes" xml:space="preserve">
          <source>A branch instruction can cause a computer to begin executing a different instruction sequence and thus deviate from its default behavior of executing instructions in order (i.e. if the expression is false, the program skips the code of the &lt;code&gt;if&lt;/code&gt; block) depending on some condition, which is the expression evaluation in our case.</source>
          <target state="translated">Una instrucci&amp;oacute;n de bifurcaci&amp;oacute;n puede hacer que una computadora comience a ejecutar una secuencia de instrucciones diferente y, por lo tanto, se desv&amp;iacute;e de su comportamiento predeterminado de ejecutar instrucciones en orden (es decir, si la expresi&amp;oacute;n es falsa, el programa omite el c&amp;oacute;digo del bloque &lt;code&gt;if&lt;/code&gt; ) dependiendo de alguna condici&amp;oacute;n, que Es la evaluaci&amp;oacute;n de la expresi&amp;oacute;n en nuestro caso.</target>
        </trans-unit>
        <trans-unit id="dea845d0a945ad214f5fefb6c4b0e6c1e6051bc4" translate="yes" xml:space="preserve">
          <source>A branch predictor is one of the ancient performance improving techniques which still finds relevance into modern architectures. While the simple prediction techniques provide fast lookup and power efficiency they suffer from a high misprediction rate.</source>
          <target state="translated">El predictor de ramas es una de las antiguas t√©cnicas de mejora del rendimiento que a√∫n tiene relevancia en las arquitecturas modernas.Mientras que las t√©cnicas de predicci√≥n simples proporcionan una r√°pida b√∫squeda y eficiencia energ√©tica,sufren de una alta tasa de errores de predicci√≥n.</target>
        </trans-unit>
        <trans-unit id="37fb85f91b43ff03464a3ace5cd03f2e7b1d689f" translate="yes" xml:space="preserve">
          <source>A common way to eliminate branch prediction that I've found to work particularly good in managed languages is a table lookup instead of using a branch (although I haven't tested it in this case).</source>
          <target state="translated">Una forma com√∫n de eliminar la predicci√≥n de ramas que he encontrado que funciona particularmente bien en los idiomas administrados es una b√∫squeda en la tabla en lugar de usar una rama (aunque no la he probado en este caso).</target>
        </trans-unit>
        <trans-unit id="2d5382f7f97d599d6c1c60ae36b7533c1e391142" translate="yes" xml:space="preserve">
          <source>A general rule of thumb is to avoid data-dependent branching in critical loops (such as in this example).</source>
          <target state="translated">Una regla general es evitar las ramificaciones dependientes de los datos en los bucles cr√≠ticos (como en este ejemplo).</target>
        </trans-unit>
        <trans-unit id="2a0c61937b135599b6110466d59da1b10f3e69cc" translate="yes" xml:space="preserve">
          <source>A yet faster approach, that gives an &lt;strong&gt;approximate&lt;/strong&gt; solution for both sorted or unsorted is: &lt;code&gt;sum= 3137536;&lt;/code&gt; (assuming a truly uniform distribution, 16384 samples with expected value 191.5) &lt;strong&gt;:-)&lt;/strong&gt;</source>
          <target state="translated">Un enfoque a&amp;uacute;n m&amp;aacute;s r&amp;aacute;pido, que ofrece una soluci&amp;oacute;n &lt;strong&gt;aproximada&lt;/strong&gt; para ambos, ordenados o sin clasificar es: &lt;code&gt;sum= 3137536;&lt;/code&gt; (suponiendo una distribuci&amp;oacute;n verdaderamente uniforme, 16384 muestras con el valor esperado 191.5) &lt;strong&gt;:-)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f443462e3c594cabbf5f71234fac4ceb6009a988" translate="yes" xml:space="preserve">
          <source>All the elements are greater than 128</source>
          <target state="translated">Todos los elementos son mayores que 128</target>
        </trans-unit>
        <trans-unit id="60b7feee5533f80829de14d53e01cb5cd2f55c48" translate="yes" xml:space="preserve">
          <source>All the elements are less than 128</source>
          <target state="translated">Todos los elementos son menos de 128</target>
        </trans-unit>
        <trans-unit id="0529f5c0c9474ccd9e39a30f16e35b00bb471784" translate="yes" xml:space="preserve">
          <source>Also I want to cite &lt;a href=&quot;https://stackoverflow.com/users/16940/simon-weaver&quot;&gt;@Simon_Weaver&lt;/a&gt; from the comments:</source>
          <target state="translated">Tambi&amp;eacute;n quiero citar &lt;a href=&quot;https://stackoverflow.com/users/16940/simon-weaver&quot;&gt;@Simon_Weaver&lt;/a&gt; de los comentarios:</target>
        </trans-unit>
        <trans-unit id="fed9e7e89414aa4f62ee84308b32e6df6a42784c" translate="yes" xml:space="preserve">
          <source>Also at the end, it's good to know we have two kinds of branch predictions that each is going to affect your code differently:</source>
          <target state="translated">Tambi√©n al final,es bueno saber que tenemos dos tipos de predicciones de ramas que cada una va a afectar a tu c√≥digo de forma diferente:</target>
        </trans-unit>
        <trans-unit id="118e6e8352ef9219f30b284c2eec943d64cac174" translate="yes" xml:space="preserve">
          <source>Alternatively, on Linux you can use the performance counters subsystem to accomplish the same task, but with native performance using CPU counters.</source>
          <target state="translated">Alternativamente,en Linux se puede utilizar el subsistema de contadores de rendimiento para realizar la misma tarea,pero con rendimiento nativo utilizando los contadores de la CPU.</target>
        </trans-unit>
        <trans-unit id="407d8227038ebf4c70f4b17f8cbd8db2e0cf6ac0" translate="yes" xml:space="preserve">
          <source>Although both the roads reach the same destination, the straight road is shorter, and the other is longer. If then you choose the other by mistake, there is no turning back, and so you will waste some extra time if you choose the longer road. This is similar to what happens in the computer, and I hope this helped you understand better.</source>
          <target state="translated">Aunque ambos caminos llegan al mismo destino,el camino recto es m√°s corto y el otro es m√°s largo.Si entonces eliges el otro por error,no hay vuelta atr√°s,y as√≠ perder√°s algo de tiempo extra si eliges el camino m√°s largo.Esto es similar a lo que sucede en el ordenador,y espero que esto te haya ayudado a entender mejor.</target>
        </trans-unit>
        <trans-unit id="72b615d954c685d03dbd988b02705d36339eea5d" translate="yes" xml:space="preserve">
          <source>An official answer would be from</source>
          <target state="translated">Una respuesta oficial ser√≠a de</target>
        </trans-unit>
        <trans-unit id="e16854241a2d65fb883d369651da41390d02fcc0" translate="yes" xml:space="preserve">
          <source>Another reason is that when the vector is already sorted, we never need to move elements to their correct position. The effect of these little details is the factor of five or six that we saw.</source>
          <target state="translated">Otra raz√≥n es que cuando el vector ya est√° clasificado,nunca necesitamos mover los elementos a su posici√≥n correcta.El efecto de estos peque√±os detalles es el factor de cinco o seis que vimos.</target>
        </trans-unit>
        <trans-unit id="18b72662db383a9f75e385af80ee82d4f1ad5ed5" translate="yes" xml:space="preserve">
          <source>Any instruction is broken into a sequence of steps so that different steps can be executed concurrently in parallel. This technique is known as instruction pipeline and this is used to increase throughput in modern processors. To understand this better please see this &lt;a href=&quot;https://en.wikipedia.org/wiki/Pipeline_(computing)#Concept_and_motivation&quot;&gt;example on Wikipedia&lt;/a&gt;.</source>
          <target state="translated">Cualquier instrucci&amp;oacute;n se divide en una secuencia de pasos para que se puedan ejecutar diferentes pasos simult&amp;aacute;neamente en paralelo. Esta t&amp;eacute;cnica se conoce como canalizaci&amp;oacute;n de instrucciones y se usa para aumentar el rendimiento en los procesadores modernos. Para entender esto mejor, vea este &lt;a href=&quot;https://en.wikipedia.org/wiki/Pipeline_(computing)#Concept_and_motivation&quot;&gt;ejemplo en Wikipedia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bcb1019315b39b373530b7c1baab0d26a3114719" translate="yes" xml:space="preserve">
          <source>Articles in scientific publications: T.Y. Yeh, Y.N. Patt made a lot of these on branch predictions.</source>
          <target state="translated">Art√≠culos en publicaciones cient√≠ficas:T.Y.Yeh,Y.N.Patt hizo muchos de estos en predicciones de ramas.</target>
        </trans-unit>
        <trans-unit id="0a92cf5f4b626666fbf175648e0a6f274113a6f6" translate="yes" xml:space="preserve">
          <source>As a result of waiting for the result of instruction A, the total CPU cycles spent in the above case (without branch prediction; for both true and false) is 7.</source>
          <target state="translated">Como resultado de la espera del resultado de la instrucci√≥n A,el total de ciclos de CPU gastados en el caso anterior (sin predicci√≥n de rama;tanto para verdadero como para falso)es de 7.</target>
        </trans-unit>
        <trans-unit id="91b190f8f20d90d506eb2a535168aaeb504cbac3" translate="yes" xml:space="preserve">
          <source>As data is distributed between 0 and 255 when the array is sorted, around the first half of the iterations will not enter the &lt;code&gt;if&lt;/code&gt;-statement (the &lt;code&gt;if&lt;/code&gt; statement is shared below).</source>
          <target state="translated">Como los datos se distribuyen entre 0 y 255 cuando se ordena la matriz, alrededor de la primera mitad de las iteraciones no ingresar&amp;aacute;n la declaraci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; (la declaraci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; se comparte a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="cb7653dba96134a9f8b8386b70f0dd6cac24bb0a" translate="yes" xml:space="preserve">
          <source>As hinted from above, the culprit is this if-statement:</source>
          <target state="translated">Como se ha insinuado desde arriba,el culpable es esta afirmaci√≥n:</target>
        </trans-unit>
        <trans-unit id="485df5143cbc2b24d62743d36ee8956b76546eb1" translate="yes" xml:space="preserve">
          <source>As what has already been mentioned by others, what behind the mystery is &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Branch Predictor&lt;/a&gt;.</source>
          <target state="translated">Como lo que ya han mencionado otros, lo que est&amp;aacute; detr&amp;aacute;s del misterio es &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Branch Predictor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b08e517362c42b5803f28e7adc40496f99cf8e9" translate="yes" xml:space="preserve">
          <source>As you can see, it seems we don't have a reason not to use Branch Predictor.</source>
          <target state="translated">Como puedes ver,parece que no tenemos una raz√≥n para no usar el Predictor de Ramas.</target>
        </trans-unit>
        <trans-unit id="4f55d0a62def8f894343508ecf5fe4ae7cfbc922" translate="yes" xml:space="preserve">
          <source>At least the phenomenon is real with this compiler, standard library, and optimizer settings. Different implementations can and do give different answers. In fact, someone did do a more systematic study (a quick web search will find it) and most implementations show that effect.</source>
          <target state="translated">Al menos el fen√≥meno es real con este compilador,la biblioteca est√°ndar y los ajustes del optimizador.Diferentes implementaciones pueden y dan diferentes respuestas.De hecho,alguien hizo un estudio m√°s sistem√°tico (una b√∫squeda r√°pida en la web lo encontrar√°)y la mayor√≠a de las implementaciones muestran ese efecto.</target>
        </trans-unit>
        <trans-unit id="fd41bc2c6095914eb987318731cbb8136aa88df0" translate="yes" xml:space="preserve">
          <source>Based on the described scenario, I have written an animation demo to show how instructions are executed in a pipeline in different situations.</source>
          <target state="translated">Bas√°ndome en el escenario descrito,he escrito una demostraci√≥n de animaci√≥n para mostrar c√≥mo se ejecutan las instrucciones en una tuber√≠a en diferentes situaciones.</target>
        </trans-unit>
        <trans-unit id="f227c3a03a7731e12cfd0e90cd5a61346155ae8b" translate="yes" xml:space="preserve">
          <source>Based on this, it looks MATLAB is almost &lt;em&gt;175 times&lt;/em&gt; slower than the C implementation without sorting and &lt;em&gt;350 times&lt;/em&gt; slower with sorting. In other words, the effect (of branch prediction) is &lt;em&gt;1.46x&lt;/em&gt; for MATLAB implementation and &lt;em&gt;2.7x&lt;/em&gt; for the C implementation.</source>
          <target state="translated">Basado en esto, parece que MATLAB es casi &lt;em&gt;175 veces&lt;/em&gt; m&amp;aacute;s lento que la implementaci&amp;oacute;n de C sin clasificar y &lt;em&gt;350 veces&lt;/em&gt; m&amp;aacute;s lento con la clasificaci&amp;oacute;n. En otras palabras, el efecto (de la predicci&amp;oacute;n de rama) es &lt;em&gt;1.46x&lt;/em&gt; para la implementaci&amp;oacute;n de MATLAB y &lt;em&gt;2.7x&lt;/em&gt; para la implementaci&amp;oacute;n de C.</target>
        </trans-unit>
        <trans-unit id="7f0b96f3c9bc5eedd14fbfce8ae4e5637fcd2f88" translate="yes" xml:space="preserve">
          <source>Besides the fact that the branch prediction may slow you down, a sorted array has another advantage:</source>
          <target state="translated">Adem√°s del hecho de que la predicci√≥n de la rama puede ralentizarte,una matriz ordenada tiene otra ventaja:</target>
        </trans-unit>
        <trans-unit id="cbfea8990261f42832136208062c8c674500cbb0" translate="yes" xml:space="preserve">
          <source>Books: J.L. Hennessy, D.A. Patterson: Computer architecture: a quantitative approach</source>
          <target state="translated">Libros:J.L.Hennessy,D.A.Patterson:Arquitectura de computadoras:un enfoque cuantitativo</target>
        </trans-unit>
        <trans-unit id="829b3fb58a7b85f64a37f8e20d7ec7596c0db7f0" translate="yes" xml:space="preserve">
          <source>Boolean variables are overdetermined in the sense that all operators that have Boolean variables as input check if the inputs have any other value than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, but operators that have Booleans as output can produce no other value than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. This makes operations with Boolean variables as input less efficient than necessary.
Consider example:</source>
          <target state="translated">Las variables booleanas est&amp;aacute;n sobredeterminadas en el sentido de que todos los operadores que tienen variables booleanas como entrada verifican si las entradas tienen cualquier otro valor que no sea &lt;code&gt;0&lt;/code&gt; o &lt;code&gt;1&lt;/code&gt; , pero los operadores que tienen booleanos como salida no pueden producir otro valor que no sea &lt;code&gt;0&lt;/code&gt; o &lt;code&gt;1&lt;/code&gt; . Esto hace que las operaciones con variables booleanas como entrada sean menos eficientes de lo necesario. Considere un ejemplo:</target>
        </trans-unit>
        <trans-unit id="0f586453c8b155549182d123a0dddc7e7cafdb04" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;likely()&lt;/code&gt; and &lt;code&gt;unlikely()&lt;/code&gt; are in fact macros that are defined by using something like the GCC's &lt;code&gt;__builtin_expect&lt;/code&gt; to help the compiler insert prediction code to favour the condition taking into account the information provided by the user. GCC supports other builtins that could change the behavior of the running program or emit low level instructions like clearing the cache, etc. See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html&quot;&gt;this documentation&lt;/a&gt; that goes through the available GCC's builtins.</source>
          <target state="translated">Tanto &lt;code&gt;likely()&lt;/code&gt; como &lt;code&gt;unlikely()&lt;/code&gt; son de hecho macros que se definen usando algo como &lt;code&gt;__builtin_expect&lt;/code&gt; del GCC para ayudar al compilador a insertar el c&amp;oacute;digo de predicci&amp;oacute;n para favorecer la condici&amp;oacute;n teniendo en cuenta la informaci&amp;oacute;n proporcionada por el usuario. GCC admite otras funciones integradas que podr&amp;iacute;an cambiar el comportamiento del programa en ejecuci&amp;oacute;n o emitir instrucciones de bajo nivel, como borrar la memoria cach&amp;eacute;, etc. Consulte &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html&quot;&gt;esta documentaci&amp;oacute;n&lt;/a&gt; que analiza las funciones integradas de GCC disponibles.</target>
        </trans-unit>
        <trans-unit id="e3be8498fb9bc40fab8d29adec6459c84941f461" translate="yes" xml:space="preserve">
          <source>Branch prediction is essentially an optimization (minimization) problem where the emphasis is on to achieve lowest possible miss rate, low power consumption, and low complexity with minimum resources.</source>
          <target state="translated">La predicci√≥n de ramas es esencialmente un problema de optimizaci√≥n (minimizaci√≥n)en el que se hace hincapi√© en lograr la menor tasa de error posible,un bajo consumo de energ√≠a y una baja complejidad con recursos m√≠nimos.</target>
        </trans-unit>
        <trans-unit id="ce09fc1b6a54ba26385b7dcf3dc61b849d981bdb" translate="yes" xml:space="preserve">
          <source>Branch prediction: Guessing/predicting which road is straight and following it without checking</source>
          <target state="translated">Predicci√≥n de la rama:Adivinando-prediciendo qu√© camino es recto y sigui√©ndolo sin comprobar</target>
        </trans-unit>
        <trans-unit id="bf6354b6953e28aa0b0401d2ab4cdf0bab9f9a80" translate="yes" xml:space="preserve">
          <source>Branch predictor will try to guess which way a branch (an if-then-else structure) will go before this is known for sure. It will not wait for the instruction A to reach the EX stage of the pipeline, but it will guess the decision and go to that instruction (B or C in case of our example).</source>
          <target state="translated">El pronosticador de ramas tratar√° de adivinar en qu√© direcci√≥n ir√° una rama (una estructura de &quot;si y luego no&quot;)antes de que esto se sepa con certeza.No esperar√° a que la instrucci√≥n A alcance la etapa EX de la tuber√≠a,sino que adivinar√° la decisi√≥n e ir√° a esa instrucci√≥n (B o C en el caso de nuestro ejemplo).</target>
        </trans-unit>
        <trans-unit id="167e8ac318227dcb55522a65e67d450259397b78" translate="yes" xml:space="preserve">
          <source>But in case of a random unsorted array, the prediction will need to discard the partially executed instructions and start over with the correct branch most of the time and result in more CPU cycles compared to the sorted array.</source>
          <target state="translated">Pero en el caso de un array aleatorio sin clasificar,la predicci√≥n tendr√° que descartar las instrucciones parcialmente ejecutadas y empezar de nuevo con la rama correcta la mayor√≠a de las veces y dar como resultado m√°s ciclos de CPU en comparaci√≥n con el array clasificado.</target>
        </trans-unit>
        <trans-unit id="dbc576af53dd6fb3f0dc64893d4fed7f4cc4366f" translate="yes" xml:space="preserve">
          <source>But in my testing, an explicit lookup table was slightly faster than this, probably because indexing into a lookup table was slightly faster than bit shifting.  This shows how my code sets up and uses the lookup table (unimaginatively called &lt;code&gt;lut&lt;/code&gt; for &quot;LookUp Table&quot; in the code).  Here's the C++ code:</source>
          <target state="translated">Pero en mis pruebas, una tabla de b&amp;uacute;squeda expl&amp;iacute;cita fue ligeramente m&amp;aacute;s r&amp;aacute;pida que esto, probablemente porque la indexaci&amp;oacute;n en una tabla de b&amp;uacute;squeda fue un poco m&amp;aacute;s r&amp;aacute;pida que el desplazamiento de bits. Esto muestra c&amp;oacute;mo mi c&amp;oacute;digo se configura y usa la tabla de b&amp;uacute;squeda (sin imaginaci&amp;oacute;n llamada &lt;code&gt;lut&lt;/code&gt; para &quot;Tabla de b&amp;uacute;squeda&quot; en el c&amp;oacute;digo). Aqu&amp;iacute; est&amp;aacute; el c&amp;oacute;digo C ++:</target>
        </trans-unit>
        <trans-unit id="556743da1a16719ba282399e5ea0e47a985396e0" translate="yes" xml:space="preserve">
          <source>But in my testing, an explicit lookup table was slightly faster than this, probably because indexing into a lookup table was slightly faster than bit shifting. This shows how my code sets up and uses the lookup table (unimaginatively called lut for &quot;LookUp Table&quot; in the code). Here's the C++ code:</source>
          <target state="translated">Pero en mis pruebas,una tabla de b√∫squeda expl√≠cita fue ligeramente m√°s r√°pida que esto,probablemente porque la indexaci√≥n en una tabla de b√∫squeda fue ligeramente m√°s r√°pida que el desplazamiento de bits.Esto muestra c√≥mo mi c√≥digo configura y utiliza la tabla de b√∫squeda (llamada sin imaginaci√≥n lut para &quot;Tabla de b√∫squeda&quot; en el c√≥digo).Aqu√≠ est√° el c√≥digo de C++:</target>
        </trans-unit>
        <trans-unit id="a09b475c5d193e2a2ef480d8477ce7319209e1cd" translate="yes" xml:space="preserve">
          <source>But in this case, we know values are in the range [0, 255] and we only care about values &amp;gt;= 128. That means we can easily extract a single bit that will tell us whether we want a value or not: by shifting the data to the right 7 bits, we are left with a 0 bit or a 1 bit, and we only want to add the value when we have a 1 bit. Let's call this bit the &quot;decision bit&quot;.</source>
          <target state="translated">Pero en este caso, sabemos que los valores est&amp;aacute;n en el rango [0, 255] y solo nos interesan los valores&amp;gt; = 128. Eso significa que podemos extraer f&amp;aacute;cilmente un solo bit que nos dir&amp;aacute; si queremos un valor o no: cambiando los datos a la derecha son de 7 bits, nos quedan 0 bits o 1 bit, y solo queremos agregar el valor cuando tenemos 1 bit. Llamemos a este bit el &quot;bit de decisi&amp;oacute;n&quot;.</target>
        </trans-unit>
        <trans-unit id="58cee47e25522bb2e607e044796956fc2d95746f" translate="yes" xml:space="preserve">
          <source>By using the 0/1 value of the decision bit as an index into an array, we can make code that will be equally fast whether the data is sorted or not sorted. Our code will always add a value, but when the decision bit is 0, we will add the value somewhere we don't care about. Here's the code:</source>
          <target state="translated">Usando el valor 01 del bit de decisi√≥n como √≠ndice en una matriz,podemos hacer un c√≥digo que ser√° igual de r√°pido tanto si los datos est√°n ordenados como si no lo est√°n.Nuestro c√≥digo siempre a√±adir√° un valor,pero cuando el bit de decisi√≥n sea 0,a√±adiremos el valor en alg√∫n lugar que no nos importe.Aqu√≠ est√° el c√≥digo:</target>
        </trans-unit>
        <trans-unit id="56bb3ef2fb6bcc14eb09093062d52086eb734f83" translate="yes" xml:space="preserve">
          <source>C++ - Visual Studio 2010 - x64 Release</source>
          <target state="translated">C++-Visual Studio 2010-Lanzamiento de x64</target>
        </trans-unit>
        <trans-unit id="907dc42739003087cf41fc698a5aef43e56b2716" translate="yes" xml:space="preserve">
          <source>Consider a railroad junction:</source>
          <target state="translated">Considere un cruce de ferrocarril:</target>
        </trans-unit>
        <trans-unit id="0008f55380e54b1390ff08936a649b5378e8d33b" translate="yes" xml:space="preserve">
          <source>Drilling down into the line-by-line output produced by &lt;code&gt;cg_annotate&lt;/code&gt; we see for the loop in question:</source>
          <target state="translated">Profundizando en la salida l&amp;iacute;nea por l&amp;iacute;nea producida por &lt;code&gt;cg_annotate&lt;/code&gt; vemos el ciclo en cuesti&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e84c032993f25d05ec7cbf44965cf42d501894a7" translate="yes" xml:space="preserve">
          <source>EX -- Execute the instruction</source>
          <target state="translated">EX --Ejecutar la instrucci√≥n</target>
        </trans-unit>
        <trans-unit id="91b7378edbcc8a2dcbc0578b242232b9f0edf9c0" translate="yes" xml:space="preserve">
          <source>Each element in the original code is a random value</source>
          <target state="translated">Cada elemento del c√≥digo original es un valor aleatorio</target>
        </trans-unit>
        <trans-unit id="5b31068fcc3d6c11d6243f6f58c031a60e4fe724" translate="yes" xml:space="preserve">
          <source>Fortunately for us, if the memory access pattern is predictable, the processor will load it in its fast cache and all is well.</source>
          <target state="translated">Afortunadamente para nosotros,si el patr√≥n de acceso a la memoria es predecible,el procesador lo cargar√° en su cach√© r√°pido y todo estar√° bien.</target>
        </trans-unit>
        <trans-unit id="96d1b40b361ab03cd656fc01b084e5d379dd61ce" translate="yes" xml:space="preserve">
          <source>Frequently used Boolean operations in C++ produce many branches in the compiled program. If these branches are inside loops and are hard to predict they can slow down execution significantly. Boolean variables are stored as 8-bit integers with the value &lt;code&gt;0&lt;/code&gt; for &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Las operaciones booleanas de uso frecuente en C ++ producen muchas ramas en el programa compilado. Si estas ramas est&amp;aacute;n dentro de bucles y son dif&amp;iacute;ciles de predecir, pueden ralentizar significativamente la ejecuci&amp;oacute;n. Las variables booleanas se almacenan como enteros de 8 bits con el valor &lt;code&gt;0&lt;/code&gt; para &lt;code&gt;false&lt;/code&gt; y &lt;code&gt;1&lt;/code&gt; para &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fbb5582021303c8d664e2d578e2f2f31b983748c" translate="yes" xml:space="preserve">
          <source>From a processor perspective, your memory is slow. To compensate for the difference in speed, a couple of caches are built into your processor (L1/L2 cache). So imagine that you're doing your nice calculations and figure out that you need a piece of memory. The processor will get its 'load' operation and loads the piece of memory into cache -- and then uses the cache to do the rest of the calculations. Because memory is relatively slow, this 'load' will slow down your program.</source>
          <target state="translated">Desde la perspectiva del procesador,tu memoria es lenta.Para compensar la diferencia de velocidad,se han incorporado un par de cach√©s en el procesador (cach√© L1L2).As√≠ que imagina que est√°s haciendo tus bonitos c√°lculos y averigua que necesitas un trozo de memoria.El procesador obtendr√° su operaci√≥n de &quot;carga&quot; y cargar√° el trozo de memoria en la cach√© --y luego usar√° la cach√© para hacer el resto de los c√°lculos.Debido a que la memoria es relativamente lenta,esta &quot;carga&quot; ralentizar√° tu programa.</target>
        </trans-unit>
        <trans-unit id="a69eb648a593eb899c67ee00a5913154aebeadb2" translate="yes" xml:space="preserve">
          <source>Further reading: &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;&quot;Branch predictor&quot; article on Wikipedia&lt;/a&gt;.</source>
          <target state="translated">Lectura adicional: &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;art&amp;iacute;culo &quot;Predictor de rama&quot; en Wikipedia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2cb4ec23cd0f11546771882b0c409bbbd82fc5ea" translate="yes" xml:space="preserve">
          <source>GCC 4.6.1 with &lt;code&gt;-O3&lt;/code&gt; or &lt;code&gt;-ftree-vectorize&lt;/code&gt; on x64 is able to generate a conditional move. So there is no difference between the sorted and unsorted data - both are fast.</source>
          <target state="translated">GCC 4.6.1 con &lt;code&gt;-ftree-vectorize&lt;/code&gt; o -ftree-vectorize en x64 es capaz de generar un movimiento condicional. Por lo tanto, no hay diferencia entre los datos ordenados y no clasificados, ambos son r&amp;aacute;pidos.</target>
        </trans-unit>
        <trans-unit id="f53bd842ecd4d4a9f495f435523c9cf23aa6a57c" translate="yes" xml:space="preserve">
          <source>Generally, modern processors have quite long pipelines, but for ease let's consider these 4 steps only.</source>
          <target state="translated">Generalmente,los procesadores modernos tienen tuber√≠as bastante largas,pero para mayor facilidad consideremos estos 4 pasos solamente.</target>
        </trans-unit>
        <trans-unit id="38465cba940858cd4732031697c429623f9115b7" translate="yes" xml:space="preserve">
          <source>Here are the timings of the loop with different true-false patterns:</source>
          <target state="translated">Aqu√≠ est√°n los tiempos del bucle con diferentes patrones de verdadero y falso:</target>
        </trans-unit>
        <trans-unit id="6a74c4bde413f0664d97478a9af05dc6dec1968a" translate="yes" xml:space="preserve">
          <source>Here is a piece of C++ code that shows some very peculiar behavior. For some strange reason, sorting the data miraculously makes the code almost six times faster:</source>
          <target state="translated">Aqu√≠ hay un pedazo de c√≥digo C++que muestra un comportamiento muy peculiar.Por alguna extra√±a raz√≥n,clasificar los datos hace que el c√≥digo sea casi seis veces m√°s r√°pido:</target>
        </trans-unit>
        <trans-unit id="9540c640283f5095fcffbc3e62196fc4a354f281" translate="yes" xml:space="preserve">
          <source>Here's a link to this code: &lt;a href=&quot;http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx&quot;&gt;Red Black Trees&lt;/a&gt;, &lt;em&gt;Eternally Confuzzled&lt;/em&gt;</source>
          <target state="translated">Aqu&amp;iacute; hay un enlace a este c&amp;oacute;digo: &lt;a href=&quot;http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx&quot;&gt;Red Black Trees&lt;/a&gt; , &lt;em&gt;Eternally Confuzzled&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65bc35b8db256ec9378ffd563e6d314c0f419d53" translate="yes" xml:space="preserve">
          <source>However, when the data is completely random, the branch predictor is rendered useless, because it can't predict random data. Thus there will probably be around 50% misprediction (no better than random guessing).</source>
          <target state="translated">Sin embargo,cuando los datos son completamente aleatorios,el predictor de rama se vuelve in√∫til,porque no puede predecir datos aleatorios.Por lo tanto,probablemente habr√° alrededor de un 50% de errores de predicci√≥n (no es mejor que la adivinaci√≥n aleatoria).</target>
        </trans-unit>
        <trans-unit id="923101f6e2254ddc269c719e6877f55af0932907" translate="yes" xml:space="preserve">
          <source>I just read up on this question and its answers, and I feel an answer is missing.</source>
          <target state="translated">Acabo de leer esta pregunta y sus respuestas,y siento que falta una respuesta.</target>
        </trans-unit>
        <trans-unit id="6155d3cc9d0a0b68582ccdde2e81aba3a8812eb0" translate="yes" xml:space="preserve">
          <source>I ran that a few times to be sure. Yes, the phenomenon is real. My key code was:</source>
          <target state="translated">Lo he comprobado unas cuantas veces para estar seguro.S√≠,el fen√≥meno es real.Mi c√≥digo clave era:</target>
        </trans-unit>
        <trans-unit id="411b77367cb6a07a9e121aa06f74b175e40b6fd6" translate="yes" xml:space="preserve">
          <source>I tried the same code with MATLAB 2011b with my MacBook Pro (Intel i7, 64 bit, 2.4 GHz) for the following MATLAB code:</source>
          <target state="translated">Intent√© el mismo c√≥digo con MATLAB 2011b con mi MacBook Pro (Intel i7,64 bit,2.4 GHz)para el siguiente c√≥digo de MATLAB:</target>
        </trans-unit>
        <trans-unit id="51e91a54cf2fc822fbf81bdee0af955af2b6ea97" translate="yes" xml:space="preserve">
          <source>I'm not trying to add something but explaining the concept in another way. 
There is a concise introduction on the wiki which contains text and diagram.
I do like the explanation below which uses a diagram to elaborate the Branch Predictor intuitively.</source>
          <target state="translated">No estoy tratando de a√±adir algo,sino de explicar el concepto de otra manera.Hay una introducci√≥n concisa en el wiki que contiene texto y diagrama.Me gusta la explicaci√≥n de abajo que utiliza un diagrama para elaborar el Predictor de Rama intuitivamente.</target>
        </trans-unit>
        <trans-unit id="065592acf6ecacc9b012a59339edcc7416aa6239" translate="yes" xml:space="preserve">
          <source>ID -- Decode the instruction</source>
          <target state="translated">ID...Decodificar la instrucci√≥n</target>
        </trans-unit>
        <trans-unit id="42c1b1564597619cb2c77349430882a2580c741c" translate="yes" xml:space="preserve">
          <source>IF -- Fetch the instruction from memory</source>
          <target state="translated">Si...Busca la instrucci√≥n de la memoria</target>
        </trans-unit>
        <trans-unit id="88eb4395003cb412e7661165f4ce4cf1f486289e" translate="yes" xml:space="preserve">
          <source>If it is later detected that the guess was wrong then the partially executed instructions are discarded and the pipeline starts over with the correct branch, incurring a delay. 
The time that is wasted in case of a branch misprediction is equal to the number of stages in the pipeline from the fetch stage to the execute stage. Modern microprocessors tend to have quite long pipelines so that the misprediction delay is between 10 and 20 clock cycles. The longer the pipeline the greater the need for a good &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;branch predictor&lt;/a&gt;.</source>
          <target state="translated">Si luego se detecta que la suposici&amp;oacute;n fue incorrecta, las instrucciones ejecutadas parcialmente se descartan y la tuber&amp;iacute;a comienza de nuevo con la rama correcta, lo que genera un retraso. El tiempo que se desperdicia en caso de una predicci&amp;oacute;n err&amp;oacute;nea de la rama es igual al n&amp;uacute;mero de etapas en la tuber&amp;iacute;a desde la etapa de recuperaci&amp;oacute;n hasta la etapa de ejecuci&amp;oacute;n. Los microprocesadores modernos tienden a tener tuber&amp;iacute;as bastante largas, por lo que el retraso de predicci&amp;oacute;n err&amp;oacute;nea es de entre 10 y 20 ciclos de reloj. Cuanto m&amp;aacute;s larga sea la tuber&amp;iacute;a, mayor ser&amp;aacute; la necesidad de un buen &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;predictor de rama&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd7de5e20eb6affc18989173e9a7fbd64cfc3a64" translate="yes" xml:space="preserve">
          <source>If the array is sorted, your condition is false at the first step: &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt;, then becomes a true value for the whole way to the end of the street. That's how you get to the end of the logic faster. On the other hand, using an unsorted array, you need a lot of turning and processing which make your code run slower for sure...</source>
          <target state="translated">Si se ordena la matriz, su condici&amp;oacute;n es falsa en el primer paso: &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; , luego se convierte en un valor verdadero para todo el camino hasta el final de la calle. As&amp;iacute; es como llegas al final de la l&amp;oacute;gica m&amp;aacute;s r&amp;aacute;pido. Por otro lado, al usar una matriz no ordenada, necesita una gran cantidad de giros y procesamientos que hacen que su c&amp;oacute;digo se ejecute m&amp;aacute;s lento con seguridad ...</target>
        </trans-unit>
        <trans-unit id="56d4fd733b97267a72ee645f98fa635e9b8c6ce9" translate="yes" xml:space="preserve">
          <source>If the compiler isn't able to optimize the branch into a conditional move, you can try some hacks if you are willing to sacrifice readability for performance.</source>
          <target state="translated">Si el compilador no es capaz de optimizar la rama en un movimiento condicional,puede probar algunos hackeos si est√° dispuesto a sacrificar la legibilidad por el rendimiento.</target>
        </trans-unit>
        <trans-unit id="1824e7d45369351e72c6eb590133dd9e21d010ed" translate="yes" xml:space="preserve">
          <source>If you are curious about even more optimizations that can be done to this code, consider this:</source>
          <target state="translated">Si tienes curiosidad por saber m√°s optimizaciones que se pueden hacer a este c√≥digo,considera esto:</target>
        </trans-unit>
        <trans-unit id="5ceebbf643b622dd844b59e8bd85fc4f5ede90be" translate="yes" xml:space="preserve">
          <source>If you give the Intel compiler the branchless code, it just out-right vectorizes it... and is just as fast as with the branch (with the loop interchange).</source>
          <target state="translated">Si le das al compilador Intel el c√≥digo sin ramas,lo vectoriza a la derecha...y es tan r√°pido como con la rama (con el intercambio de bucles).</target>
        </trans-unit>
        <trans-unit id="ae88c41ed067d722d464020e7a9f55e02d32fddc" translate="yes" xml:space="preserve">
          <source>If you guessed right, it continues on.</source>
          <target state="translated">Si adivinaste bien,contin√∫a.</target>
        </trans-unit>
        <trans-unit id="bbb6c6bc29b605454dbfe7f8781ef7cdb2c270f2" translate="yes" xml:space="preserve">
          <source>If you guessed right, you continue executing.</source>
          <target state="translated">Si adivinaste bien,sigues ejecutando.</target>
        </trans-unit>
        <trans-unit id="1898647ae8c929024233a50359541e7af7814ea2" translate="yes" xml:space="preserve">
          <source>If you guessed wrong, the captain will stop, back up, and yell at you to flip the switch. Then it can restart down the other path.</source>
          <target state="translated">Si adivinaste mal,el capit√°n se detendr√°,retroceder√° y te gritar√° para que actives el interruptor.Entonces puede reiniciar por el otro camino.</target>
        </trans-unit>
        <trans-unit id="9b46e462a942895bb7f6e7d844e7730c6d70136b" translate="yes" xml:space="preserve">
          <source>If you guessed wrong, you need to flush the pipeline and roll back to the branch. Then you can restart down the other path.</source>
          <target state="translated">Si adivin√≥ mal,tiene que limpiar la tuber√≠a y volver a la rama.Entonces puedes reiniciar por el otro camino.</target>
        </trans-unit>
        <trans-unit id="23319b8aed03d58e34f2b56f4949401e859e197b" translate="yes" xml:space="preserve">
          <source>If you have ever wondered why ARM has been so phenomenally successful, the brilliant effectiveness and interplay of these two mechanisms are a big part of the story, because they are one of the greatest sources of the ARM architecture's efficiency. The brilliance of the original designers of the ARM ISA back in 1983, Steve Furber and Roger (now Sophie) Wilson, cannot be overstated.</source>
          <target state="translated">Si alguna vez te has preguntado por qu√© ARM ha tenido un √©xito tan fenomenal,la brillante efectividad e interacci√≥n de estos dos mecanismos son una gran parte de la historia,porque son una de las mayores fuentes de la eficiencia de la arquitectura de ARM.La brillantez de los dise√±adores originales del ARM ISA en 1983,Steve Furber y Roger (ahora Sophie)Wilson,no puede ser exagerada.</target>
        </trans-unit>
        <trans-unit id="20223b3b9842562860c0883dd004a561d3dec19d" translate="yes" xml:space="preserve">
          <source>If you run into trouble with lookups in managed languages -- the key is to add a &lt;code&gt;&amp;amp; 0x[something]FFF&lt;/code&gt; to your lookup function to make the boundary check predictable -- and watch it going faster.</source>
          <target state="translated">Si tiene problemas con las b&amp;uacute;squedas en los idiomas administrados, la clave es agregar un &lt;code&gt;&amp;amp; 0x[something]FFF&lt;/code&gt; a su funci&amp;oacute;n de b&amp;uacute;squeda para hacer que la verificaci&amp;oacute;n de l&amp;iacute;mites sea predecible, y ver que va m&amp;aacute;s r&amp;aacute;pido.</target>
        </trans-unit>
        <trans-unit id="fcbae46e5b1ed263a398fd8853f1c323c42dd17c" translate="yes" xml:space="preserve">
          <source>If you want to write efficient code, you need to know a bit about machine architecture.</source>
          <target state="translated">Si quieres escribir c√≥digo eficiente,necesitas saber un poco sobre la arquitectura de las m√°quinas.</target>
        </trans-unit>
        <trans-unit id="4906cf640b371d74701a3bb36c48ac95ee90c060" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;C&lt;/code&gt;, thus &lt;code&gt;C++&lt;/code&gt;, the statement, which would compile directly (without any optimization) into the conditional move instruction in &lt;code&gt;x86&lt;/code&gt;, is the ternary operator &lt;code&gt;... ? ... : ...&lt;/code&gt;. So we rewrite the above statement into an equivalent one:</source>
          <target state="translated">En &lt;code&gt;C&lt;/code&gt; , por lo tanto, &lt;code&gt;C++&lt;/code&gt; , la declaraci&amp;oacute;n, que se compilar&amp;iacute;a directamente (sin ninguna optimizaci&amp;oacute;n) en la instrucci&amp;oacute;n de movimiento condicional en &lt;code&gt;x86&lt;/code&gt; , &amp;iquest;es el operador ternario &lt;code&gt;... ? ... : ...&lt;/code&gt; ...: .... Entonces reescribimos la declaraci&amp;oacute;n anterior en una equivalente:</target>
        </trans-unit>
        <trans-unit id="ab040f6c0d47f49db7c9db520be83759c461ffc9" translate="yes" xml:space="preserve">
          <source>In a branch case, the following instruction is determined by the preceding one, so we cannot do pipelining. We have to either wait or predict.</source>
          <target state="translated">En un caso de rama,la siguiente instrucci√≥n est√° determinada por la precedente,por lo que no podemos hacer pipelines.Tenemos que esperar o predecir.</target>
        </trans-unit>
        <trans-unit id="0025791b5e0267a182817044a5ed2c8007195575" translate="yes" xml:space="preserve">
          <source>In a conditional move case, the execution conditional move instruction is divided into several stages, but the earlier stages like &lt;code&gt;Fetch&lt;/code&gt; and &lt;code&gt;Decode&lt;/code&gt; does not depend on the result of the previous instruction; only latter stages need the result. Thus, we wait a fraction of one instruction's execution time. This is why the conditional move version is slower than the branch when prediction is easy.</source>
          <target state="translated">En un caso de movimiento condicional, la instrucci&amp;oacute;n de movimiento condicional de ejecuci&amp;oacute;n se divide en varias etapas, pero las etapas anteriores como &lt;code&gt;Fetch&lt;/code&gt; y &lt;code&gt;Decode&lt;/code&gt; no dependen del resultado de la instrucci&amp;oacute;n anterior; solo las &amp;uacute;ltimas etapas necesitan el resultado. Por lo tanto, esperamos una fracci&amp;oacute;n del tiempo de ejecuci&amp;oacute;n de una instrucci&amp;oacute;n. Es por eso que la versi&amp;oacute;n de movimiento condicional es m&amp;aacute;s lenta que la rama cuando la predicci&amp;oacute;n es f&amp;aacute;cil.</target>
        </trans-unit>
        <trans-unit id="79ae345e2bd1b8124d296ba39b3ea113c5193f48" translate="yes" xml:space="preserve">
          <source>In a typical &lt;code&gt;x86&lt;/code&gt; processor, the execution of an instruction is divided into several stages. Roughly, we have different hardware to deal with different stages. So we do not have to wait for one instruction to finish to start a new one. This is called &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Pipeline_%28computing%29&quot;&gt;pipelining&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">En un procesador &lt;code&gt;x86&lt;/code&gt; t&amp;iacute;pico, la ejecuci&amp;oacute;n de una instrucci&amp;oacute;n se divide en varias etapas. Aproximadamente, tenemos hardware diferente para lidiar con diferentes etapas. Por lo tanto, no tenemos que esperar a que termine una instrucci&amp;oacute;n para comenzar una nueva. Esto se llama &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Pipeline_%28computing%29&quot;&gt;tuber&amp;iacute;a&lt;/a&gt;&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="0a827bd7aeac65573a68ed989955da0af9f32542" translate="yes" xml:space="preserve">
          <source>In addition to this, in complex prediction techniques the time taken to predict the branches is itself very high &amp;ndash;ranging from 2 to 5 cycles &amp;ndash;which is comparable to the execution time of actual branches.</source>
          <target state="translated">Adem&amp;aacute;s de esto, en las t&amp;eacute;cnicas de predicci&amp;oacute;n complejas, el tiempo necesario para predecir las ramas es en s&amp;iacute; mismo muy alto (rango de 2 a 5 ciclos), que es comparable al tiempo de ejecuci&amp;oacute;n de las ramas reales.</target>
        </trans-unit>
        <trans-unit id="0fa50c75a9a67268a4a229ac38ceeff7cb07714a" translate="yes" xml:space="preserve">
          <source>In all these cases the failure will be too less in number and as a result, only a few times it will need to discard the partially executed instructions and start over with the correct branch, resulting in fewer CPU cycles.</source>
          <target state="translated">En todos estos casos el fallo ser√° demasiado reducido en n√∫mero y,como resultado,s√≥lo unas pocas veces tendr√° que descartar las instrucciones parcialmente ejecutadas y empezar de nuevo con la rama correcta,lo que dar√° lugar a menos ciclos de CPU.</target>
        </trans-unit>
        <trans-unit id="fa58046848c4821f342e1d54d795534223e063ff" translate="yes" xml:space="preserve">
          <source>In an unsorted array, the computer makes multiple predictions, leading to an increased chance of errors.
Whereas, in a sorted array, the computer makes fewer predictions, reducing the chance of errors.
Making more predictions requires more time.</source>
          <target state="translated">En una matriz sin clasificar,la computadora hace m√∫ltiples predicciones,lo que aumenta la posibilidad de errores.Mientras que en una matriz ordenada,la computadora hace menos predicciones,reduciendo la posibilidad de errores.Hacer m√°s predicciones requiere m√°s tiempo.</target>
        </trans-unit>
        <trans-unit id="d548e9f8042a97cedfb594f9ea9edf3b28dedc70" translate="yes" xml:space="preserve">
          <source>In computer architecture, a branch predictor is a
  digital circuit that tries to guess which way a branch (e.g. an
  if-then-else structure) will go before this is known for sure. The
  purpose of the branch predictor is to improve the flow in the
  instruction pipeline. Branch predictors play a critical role in
  achieving high effective performance in many modern pipelined
  microprocessor architectures such as x86.</source>
          <target state="translated">En la arquitectura inform√°tica,un predictor de ramas es un circuito digital que intenta adivinar hacia d√≥nde ir√° una rama (por ejemplo,una estructura de &quot;si luego no&quot;)antes de que esto se sepa con certeza.El prop√≥sito del predictor de rama es mejorar el flujo en la tuber√≠a de instrucci√≥n.Los predictores de ramas juegan un papel cr√≠tico en el logro de un alto rendimiento efectivo en muchas arquitecturas modernas de microprocesadores de tuber√≠as como el x86.</target>
        </trans-unit>
        <trans-unit id="286bceae83a4fe4b1c8bf9719f0595eb063192a3" translate="yes" xml:space="preserve">
          <source>In order to effectively write your code to take advantage of these
  rules, when writing &lt;strong&gt;if-else&lt;/strong&gt; or &lt;strong&gt;switch&lt;/strong&gt; statements, check the most
  common cases first and work progressively down to the least common.
  Loops do not necessarily require any special ordering of code for
  static branch prediction, as only the condition of the loop iterator
  is normally used.</source>
          <target state="translated">Para escribir de manera efectiva su c&amp;oacute;digo para aprovechar estas reglas, cuando escriba sentencias &lt;strong&gt;if-else&lt;/strong&gt; o &lt;strong&gt;switch&lt;/strong&gt; , verifique primero los casos m&amp;aacute;s comunes y trabaje progresivamente hasta los menos comunes. Los bucles no requieren necesariamente ning&amp;uacute;n orden especial de c&amp;oacute;digo para la predicci&amp;oacute;n de rama est&amp;aacute;tica, ya que normalmente solo se usa la condici&amp;oacute;n del iterador de bucle.</target>
        </trans-unit>
        <trans-unit id="ecaad1e9fa8c85b19d9f8a2205db2cbf9519dd8c" translate="yes" xml:space="preserve">
          <source>In the C++ case, the hack is actually a tad slower than with the branch when the data is sorted.</source>
          <target state="translated">En el caso de C++,el hackeo es en realidad un poco m√°s lento que con la rama cuando se clasifican los datos.</target>
        </trans-unit>
        <trans-unit id="27ce65e9b9e70aa80a48ce10e7dd18a40e62a14f" translate="yes" xml:space="preserve">
          <source>In the OP's code, the first time when the conditional, the branch predictor does not have any information to base up prediction, so the first time it will randomly choose the next instruction. Later in the for loop, it can base the prediction on the history. 
For an array sorted in ascending order, there are three possibilities:</source>
          <target state="translated">En el c√≥digo del OP,la primera vez que el condicional,el predictor de la rama no tiene ninguna informaci√≥n para basar la predicci√≥n,as√≠ que la primera vez elegir√° aleatoriamente la siguiente instrucci√≥n.M√°s tarde en el bucle for,puede basar la predicci√≥n en la historia.Para una matriz ordenada en orden ascendente,hay tres posibilidades:</target>
        </trans-unit>
        <trans-unit id="cfb2e6fc90f9bfd7c318bca3b56e7b9b3254c2b4" translate="yes" xml:space="preserve">
          <source>In the same line (I think this was not highlighted by any answer) it's good to mention that sometimes (specially in software where the performance matters&amp;mdash;like in the Linux kernel) you can find some if statements like the following:</source>
          <target state="translated">En la misma l&amp;iacute;nea (creo que esto no fue resaltado por ninguna respuesta) es bueno mencionar que a veces (especialmente en software donde el rendimiento es importante, como en el kernel de Linux) puede encontrar algunas declaraciones if como las siguientes:</target>
        </trans-unit>
        <trans-unit id="9d109a99d8c4326a6576d4732479edf2a6cedc39" translate="yes" xml:space="preserve">
          <source>In the sorted case, you can do better than relying on successful branch prediction or any branchless comparison trick: completely remove the branch.</source>
          <target state="translated">En el caso clasificado,puedes hacer algo mejor que confiar en una predicci√≥n de rama exitosa o cualquier truco de comparaci√≥n sin ramas:eliminar completamente la rama.</target>
        </trans-unit>
        <trans-unit id="a4e4e6b119a5c6f74ced74230250afdbfb631f5a" translate="yes" xml:space="preserve">
          <source>In this case, it's obvious to the compiler that the boundary condition will never be hit. At least the Microsoft JIT compiler (but I expect Java does similar things) will notice this and remove the check altogether. WOW, that means no branch. Similarly, it will deal with other obvious cases.</source>
          <target state="translated">En este caso,es obvio para el compilador que la condici√≥n l√≠mite nunca ser√° alcanzada.Al menos el compilador JIT de Microsoft (pero espero que Java haga cosas similares)se dar√° cuenta de esto y eliminar√° la comprobaci√≥n por completo.WOW,eso significa que no hay rama.Del mismo modo,se ocupar√° de otros casos obvios.</target>
        </trans-unit>
        <trans-unit id="fd70319a87ba55ceb8c46ef0dfb0b5cd4e2bf481" translate="yes" xml:space="preserve">
          <source>In this case, the lookup table was only 256 bytes, so it fits nicely in a cache and all was fast. This technique wouldn't work well if the data was 24-bit values and we only wanted half of them... the lookup table would be far too big to be practical. On the other hand, we can combine the two techniques shown above: first shift the bits over, then index a lookup table. For a 24-bit value that we only want the top half value, we could potentially shift the data right by 12 bits, and be left with a 12-bit value for a table index. A 12-bit table index implies a table of 4096 values, which might be practical.</source>
          <target state="translated">En este caso,la tabla de b√∫squeda s√≥lo ten√≠a 256 bytes,as√≠ que encajaba bien en un cach√© y todo era r√°pido.Esta t√©cnica no funcionar√≠a bien si los datos fueran valores de 24 bits y s√≥lo quer√≠amos la mitad de ellos...la tabla de b√∫squeda ser√≠a demasiado grande para ser pr√°ctica.Por otro lado,podemos combinar las dos t√©cnicas mostradas arriba:primero desplazar los bits y luego indexar la tabla de b√∫squeda.Para un valor de 24 bits que s√≥lo queremos la mitad superior,podr√≠amos desplazar los datos 12 bits a la derecha,y quedarnos con un valor de 12 bits para el √≠ndice de la tabla.Un √≠ndice de tabla de 12 bits implica una tabla de 4096 valores,lo que podr√≠a ser pr√°ctico.</target>
        </trans-unit>
        <trans-unit id="58ac7147fe158d09fb0dcd5d9a2419af351ceee2" translate="yes" xml:space="preserve">
          <source>In this case: &amp;gt;= 128 means we can keep the value, &amp;lt; 128 means we get rid of it. The easiest way to do that is by using an 'AND': if we keep it, we AND it with 7FFFFFFF; if we want to get rid of it, we AND it with 0. Notice also that 128 is a power of 2 -- so we can go ahead and make a table of 32768/128 integers and fill it with one zero and a lot of 7FFFFFFFF's.</source>
          <target state="translated">En este caso:&amp;gt; = 128 significa que podemos mantener el valor, &amp;lt;128 significa que nos deshacemos de &amp;eacute;l. La forma m&amp;aacute;s f&amp;aacute;cil de hacerlo es usando un 'Y': si lo mantenemos, lo hacemos Y con 7FFFFFFF; si queremos deshacernos de &amp;eacute;l, Y lo hacemos con 0. Observe tambi&amp;eacute;n que 128 es una potencia de 2, por lo que podemos seguir adelante y hacer una tabla de enteros 32768/128 y llenarla con un cero y mucho 7FFFFFFFF's.</target>
        </trans-unit>
        <trans-unit id="05909b2541b3e02aeda1080cefdfed9bf8d3fb41" translate="yes" xml:space="preserve">
          <source>Indeed, the array is partitioned in a contiguous zone with &lt;code&gt;data &amp;lt; 128&lt;/code&gt; and another with &lt;code&gt;data &amp;gt;= 128&lt;/code&gt;. So you should find the partition point with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Dichotomic_search&quot;&gt;dichotomic search&lt;/a&gt; (using &lt;code&gt;Lg(arraySize) = 15&lt;/code&gt; comparisons), then do a straight accumulation from that point.</source>
          <target state="translated">De hecho, la matriz se divide en una zona contigua con &lt;code&gt;data &amp;lt; 128&lt;/code&gt; y otra con &lt;code&gt;data &amp;gt;= 128&lt;/code&gt; . Por lo tanto, debe encontrar el punto de partici&amp;oacute;n con una &lt;a href=&quot;https://en.wikipedia.org/wiki/Dichotomic_search&quot;&gt;b&amp;uacute;squeda dicot&amp;oacute;mica&lt;/a&gt; (usando &lt;code&gt;Lg(arraySize) = 15&lt;/code&gt; comparaciones), luego haga una acumulaci&amp;oacute;n directa desde ese punto.</target>
        </trans-unit>
        <trans-unit id="511459d1219dae84b5739744e2330bbd39562f3c" translate="yes" xml:space="preserve">
          <source>Initially, I thought this might be just a language or compiler anomaly, so I tried Java:</source>
          <target state="translated">Inicialmente,pens√© que esto podr√≠a ser s√≥lo una anomal√≠a del lenguaje o del compilador,as√≠ que prob√© con Java:</target>
        </trans-unit>
        <trans-unit id="b7ea0a495929d20edeb96560f38ad10f605c64c3" translate="yes" xml:space="preserve">
          <source>Intel - Avoiding the Cost of Branch Misprediction</source>
          <target state="translated">Intel-Evitar el costo de la mala predicci√≥n de la sucursal</target>
        </trans-unit>
        <trans-unit id="77db291a450702d5439477d5645b64a6a25dcb27" translate="yes" xml:space="preserve">
          <source>Intel - Branch and Loop Reorganization to Prevent Mispredicts</source>
          <target state="translated">Intel-Reorganizaci√≥n de sucursales y bucles para prevenir los errores de predicci√≥n</target>
        </trans-unit>
        <trans-unit id="59f94bde7099ca1379cdd1147d7f4529386efe43" translate="yes" xml:space="preserve">
          <source>Is there a better way? You guess which direction the branch will go!</source>
          <target state="translated">¬øHay una mejor manera? ¬°Adivina en qu√© direcci√≥n ir√° la rama!</target>
        </trans-unit>
        <trans-unit id="9ce53cf70b1162457580560ead6c5cf7c26bf416" translate="yes" xml:space="preserve">
          <source>Is there a better way? You guess which direction the train will go!</source>
          <target state="translated">¬øHay una mejor manera? ¬°Adivina en qu√© direcci√≥n ir√° el tren!</target>
        </trans-unit>
        <trans-unit id="2b7c4e9ff8bccc2bf1d5615ac7198435e8f85617" translate="yes" xml:space="preserve">
          <source>It can also do source code annotation with dissassembly.</source>
          <target state="translated">Tambi√©n puede hacer anotaciones en el c√≥digo fuente con el desmontaje.</target>
        </trans-unit>
        <trans-unit id="d889c96e7c80c6d5564b275e9ce3e1dcf34879de" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t make fewer predictions - it makes fewer incorrect predictions. It still has to predict for each time through the loop...</source>
          <target state="translated">No hace menos predicciones, hace menos predicciones incorrectas. Todav&amp;iacute;a tiene que predecir cada vez a trav&amp;eacute;s del ciclo ...</target>
        </trans-unit>
        <trans-unit id="08fc45b9de518283718984bcfb1e9ac8e6ae1278" translate="yes" xml:space="preserve">
          <source>It is important to understand that branch misprediction doesn't slow down programs. The cost of a missed prediction is just as if branch prediction didn't exist and you waited for the evaluation of the expression to decide what code to run (further explanation in the next paragraph).</source>
          <target state="translated">Es importante entender que la mala predicci√≥n de la rama no ralentiza los programas.El coste de una predicci√≥n fallida es como si la predicci√≥n de rama no existiera y se esperara a la evaluaci√≥n de la expresi√≥n para decidir qu√© c√≥digo ejecutar (m√°s explicaci√≥n en el siguiente p√°rrafo).</target>
        </trans-unit>
        <trans-unit id="6fc4b764667806eaf36f9b084c8cc41649bfd6ed" translate="yes" xml:space="preserve">
          <source>It will take 7 clock cycles for 3 instructions to be completed.</source>
          <target state="translated">Se necesitar√°n 7 ciclos de reloj para completar 3 instrucciones.</target>
        </trans-unit>
        <trans-unit id="7e692acc3118ecaa2f6cab194a17621924826a7b" translate="yes" xml:space="preserve">
          <source>It will take 9 clock cycles for 3 instructions to be completed.</source>
          <target state="translated">Se necesitar√°n 9 ciclos de reloj para completar 3 instrucciones.</target>
        </trans-unit>
        <trans-unit id="76778e3295cf8f4fb34c2e009919d81130807662" translate="yes" xml:space="preserve">
          <source>It's about branch prediction. What is it?</source>
          <target state="translated">Se trata de la predicci√≥n de la rama.¬øQu√© es eso?</target>
        </trans-unit>
        <trans-unit id="5ce025460eef942a5746a29f6fff2639b7a4f0ea" translate="yes" xml:space="preserve">
          <source>It's quite a simple demo that clarifies the very basic part of Branch Predictor. If those gifs are annoying, please feel free to remove them from the answer and visitors can also get the live demo source code from &lt;a href=&quot;https://github.com/Eugene-Mark/BranchPredictorDemo&quot;&gt;BranchPredictorDemo&lt;/a&gt;</source>
          <target state="translated">Es una demostraci&amp;oacute;n bastante simple que aclara la parte muy b&amp;aacute;sica de Branch Predictor. Si esos gifs son molestos, no dude en eliminarlos de la respuesta y los visitantes tambi&amp;eacute;n pueden obtener el c&amp;oacute;digo fuente de demostraci&amp;oacute;n en vivo de &lt;a href=&quot;https://github.com/Eugene-Mark/BranchPredictorDemo&quot;&gt;BranchPredictorDemo&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1800ac2cc348d512d31d6a4d1e9d7c3834e153d" translate="yes" xml:space="preserve">
          <source>Java - NetBeans 7.1.1 JDK 7 - x64</source>
          <target state="translated">Java-NetBeans 7.1.1 JDK 7-x64</target>
        </trans-unit>
        <trans-unit id="f3f0214447bd9b96e0f2a7febf49ceace8c3c918" translate="yes" xml:space="preserve">
          <source>Let us assume that the predictor will always assume the true branch on the first run.</source>
          <target state="translated">Asumamos que el pronosticador siempre asumir√° la verdadera rama en la primera carrera.</target>
        </trans-unit>
        <trans-unit id="0626fcdc6685d5777030cccc407cda27d5a5dbe6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s measure the performance of this loop with different conditions:</source>
          <target state="translated">Midamos el rendimiento de este bucle con diferentes condiciones:</target>
        </trans-unit>
        <trans-unit id="78c58416698b00e2911ee8edf6ff28c7aa28b3f5" translate="yes" xml:space="preserve">
          <source>Let's say you need to pick route 1 or route 2. Waiting for your partner to check the map, you have stopped at ## and waited, or you could just pick route1 and if you were lucky (route 1 is the correct route), then great you didn't have to wait for your partner to check the map (you saved the time it would have taken him to check the map), otherwise you will just turn back.</source>
          <target state="translated">Digamos que tienes que elegir la ruta 1 o la ruta 2.Esperando a que tu compa√±ero compruebe el mapa,te has parado en ##y has esperado,o podr√≠as simplemente elegir la ruta1 y si tienes suerte (la ruta 1 es la correcta),entonces genial que no tengas que esperar a que tu compa√±ero compruebe el mapa (te has ahorrado el tiempo que le habr√≠a llevado comprobar el mapa),de lo contrario simplemente dar√°s la vuelta.</target>
        </trans-unit>
        <trans-unit id="2722634189f24bf6fb4d65af5b80948093b029bf" translate="yes" xml:space="preserve">
          <source>Like branch prediction, this was optimized in the Pentium processors: the processor predicts that it needs to load a piece of data and attempts to load that into the cache before the operation actually hits the cache. As we've already seen, branch prediction sometimes goes horribly wrong -- in the worst case scenario you need to go back and actually wait for a memory load, which will take forever (&lt;strong&gt;in other words: failing branch prediction is bad, a memory load after a branch prediction fail is just horrible!&lt;/strong&gt;).</source>
          <target state="translated">Al igual que la predicci&amp;oacute;n de ramificaci&amp;oacute;n, esto se optimiz&amp;oacute; en los procesadores Pentium: el procesador predice que necesita cargar un dato e intenta cargarlo en el cach&amp;eacute; antes de que la operaci&amp;oacute;n realmente llegue al cach&amp;eacute;. Como ya hemos visto, la predicci&amp;oacute;n de bifurcaci&amp;oacute;n a veces va terriblemente mal: en el peor de los casos, debe retroceder y esperar realmente una carga de memoria, lo que tomar&amp;aacute; una eternidad ( &lt;strong&gt;en otras palabras: la predicci&amp;oacute;n de bifurcaci&amp;oacute;n fallida es mala, un recuerdo &amp;iexcl;cargar despu&amp;eacute;s de que una predicci&amp;oacute;n de rama falle es simplemente horrible!&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="7511e6163f79984c1b9da8abd1a9c44be298fc50" translate="yes" xml:space="preserve">
          <source>Look at the image I created for you below. Which street is going to be finished faster?</source>
          <target state="translated">Mira la imagen que he creado para ti abajo.¬øQu√© calle se va a terminar m√°s r√°pido?</target>
        </trans-unit>
        <trans-unit id="87b5594f2643cba7d46d5fb490ed0d38e2cf1230" translate="yes" xml:space="preserve">
          <source>Making a wrong prediction leads to going back to the previous step, and executing with another prediction. Assuming the prediction is correct, the code will continue to the next step. A wrong prediction results in repeating the same step, until a correct prediction occurs.</source>
          <target state="translated">Hacer una predicci√≥n err√≥nea lleva a volver al paso anterior,y ejecutar con otra predicci√≥n.Asumiendo que la predicci√≥n es correcta,el c√≥digo continuar√° al siguiente paso.Una predicci√≥n err√≥nea resulta en la repetici√≥n del mismo paso,hasta que se produce una predicci√≥n correcta.</target>
        </trans-unit>
        <trans-unit id="a1ebbba208d4225ea0cbac50fe08bb6ace4451a3" translate="yes" xml:space="preserve">
          <source>Most applications have well-behaved branches. So modern branch predictors will typically achieve &amp;gt;90% hit rates. But when faced with unpredictable branches with no recognizable patterns, branch predictors are virtually useless.</source>
          <target state="translated">La mayor&amp;iacute;a de las aplicaciones tienen ramas con buen comportamiento. Por lo tanto, los predictores de sucursales modernos generalmente alcanzar&amp;aacute;n tasas de &amp;eacute;xito&amp;gt; 90%. Pero cuando se enfrentan con ramas impredecibles sin patrones reconocibles, los predictores de ramas son pr&amp;aacute;cticamente in&amp;uacute;tiles.</target>
        </trans-unit>
        <trans-unit id="edc45563f2af123495a6f4d5820e01d67e592ac5" translate="yes" xml:space="preserve">
          <source>Most processor architectures do not have this ability to specify whether or not the status bits should be updated for a given operation, which can necessitate writing additional code to save and later restore status bits, or may require additional branches, or may limit the processor's out of order execution efficiency: one of the side effects of most CPU instruction set architectures forcibly updating status bits after most instructions is that it is much harder to tease apart which instructions can be run in parallel without interfering with each other. Updating status bits has side effects, therefore has a linearizing effect on code. &lt;strong&gt;ARM's ability to mix and match branch-free condition testing on any instruction with the option to either update or not update the status bits after any instruction is extremely powerful, for both assembly language programmers and compilers, and produces very efficient code.&lt;/strong&gt;</source>
          <target state="translated">La mayor&amp;iacute;a de las arquitecturas de procesador no tienen esta capacidad de especificar si los bits de estado deben actualizarse o no para una operaci&amp;oacute;n determinada, lo que puede requerir escribir c&amp;oacute;digo adicional para guardar y luego restaurar bits de estado, o puede requerir ramificaciones adicionales, o puede limitar la salida del procesador de eficiencia de ejecuci&amp;oacute;n de &amp;oacute;rdenes: uno de los efectos secundarios de la mayor&amp;iacute;a de las arquitecturas de conjuntos de instrucciones de CPU que actualizan a la fuerza los bits de estado despu&amp;eacute;s de la mayor&amp;iacute;a de las instrucciones es que es mucho m&amp;aacute;s dif&amp;iacute;cil separar qu&amp;eacute; instrucciones se pueden ejecutar en paralelo sin interferir entre s&amp;iacute;. La actualizaci&amp;oacute;n de bits de estado tiene efectos secundarios, por lo tanto, tiene un efecto de linealizaci&amp;oacute;n en el c&amp;oacute;digo. &lt;strong&gt;La capacidad de ARM de mezclar y combinar pruebas de condici&amp;oacute;n sin ramificaci&amp;oacute;n en cualquier instrucci&amp;oacute;n con la opci&amp;oacute;n de actualizar o no actualizar los bits de estado despu&amp;eacute;s de que cualquier instrucci&amp;oacute;n sea extremadamente poderosa, tanto para los programadores de lenguaje ensamblador como para los compiladores, y produce c&amp;oacute;digo muy eficiente.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6714e326ddf3827a45bf7845db0659793dffdc78" translate="yes" xml:space="preserve">
          <source>Moving back to the above question let's consider the following instructions:</source>
          <target state="translated">Volviendo a la pregunta anterior,consideremos las siguientes instrucciones:</target>
        </trans-unit>
        <trans-unit id="8f2f5f3a519901e55e81a2564329640471c74d81" translate="yes" xml:space="preserve">
          <source>My first thought was that sorting brings the data into the cache, but then I thought how silly that was because the array was just generated.</source>
          <target state="translated">Mi primer pensamiento fue que la clasificaci√≥n trae los datos a la cach√©,pero luego pens√© lo tonto que era porque la matriz acaba de ser generada.</target>
        </trans-unit>
        <trans-unit id="5b798bfc3b15b4fc93876532bf774c937ef4d1cc" translate="yes" xml:space="preserve">
          <source>No doubt some of us would be interested in ways of identifying code that is problematic for the CPU's branch-predictor. The Valgrind tool &lt;code&gt;cachegrind&lt;/code&gt; has a branch-predictor simulator, enabled by using the &lt;code&gt;--branch-sim=yes&lt;/code&gt; flag. Running it over the examples in this question, with the number of outer loops reduced to 10000 and compiled with &lt;code&gt;g++&lt;/code&gt;, gives these results:</source>
          <target state="translated">Sin duda, algunos de nosotros estar&amp;iacute;amos interesados ‚Äã‚Äãen identificar c&amp;oacute;digos que sean problem&amp;aacute;ticos para el predictor de rama de la CPU. La herramienta Valgrind &lt;code&gt;cachegrind&lt;/code&gt; tiene un simulador de predicci&amp;oacute;n de rama, habilitado mediante el uso del &lt;code&gt;--branch-sim=yes&lt;/code&gt; . Ejecutarlo sobre los ejemplos en esta pregunta, con el n&amp;uacute;mero de bucles externos reducidos a 10000 y compilados con &lt;code&gt;g++&lt;/code&gt; , da estos resultados:</target>
        </trans-unit>
        <trans-unit id="7fe6472f78792531c23c2701179111bf8fe3d611" translate="yes" xml:space="preserve">
          <source>Normally this kind of optimizations are mainly found in hard-real time applications or embedded systems where execution time matters and it's critical. For example, if you are checking for some error condition that only happens 1/10000000 times, then why not inform the compiler about this? This way, by default, the branch prediction would assume that the condition is false.</source>
          <target state="translated">Normalmente,este tipo de optimizaciones se encuentran principalmente en aplicaciones en tiempo real o en sistemas empotrados en los que el tiempo de ejecuci√≥n es importante y cr√≠tico.Por ejemplo,si est√°s comprobando alguna condici√≥n de error que s√≥lo ocurre 110000000 veces,entonces ¬øpor qu√© no informar al compilador sobre esto? De esta manera,por defecto,la predicci√≥n de la rama asumir√≠a que la condici√≥n es falsa.</target>
        </trans-unit>
        <trans-unit id="2687a67b9058fe9e6fd551f4fb695501d7a3f7de" translate="yes" xml:space="preserve">
          <source>Notice that the data is evenly distributed between 0 and 255. When the data is sorted, roughly the first half of the iterations will not enter the if-statement. After that, they will all enter the if-statement.</source>
          <target state="translated">F√≠jese que los datos est√°n distribuidos uniformemente entre 0 y 255.Cuando se clasifican los datos,aproximadamente la primera mitad de las iteraciones no entrar√°n en la declaraci√≥n &quot;si&quot;.Despu√©s de eso,todos entrar√°n en el if-statement.</target>
        </trans-unit>
        <trans-unit id="8e169f52da1ac65f0d59b6b1c4ec6bd5bf878be5" translate="yes" xml:space="preserve">
          <source>Now for the sake of argument, suppose this is back in the 1800s - before long distance or radio communication.</source>
          <target state="translated">Ahora,por el bien de la discusi√≥n,supongamos que esto es en el siglo XIX,antes de la comunicaci√≥n a larga distancia o por radio.</target>
        </trans-unit>
        <trans-unit id="30312bef68cebc5f38e57e727b2135cfb377fc89" translate="yes" xml:space="preserve">
          <source>Now let's look more closely by investigating the &lt;code&gt;x86&lt;/code&gt; assembly they generate. For simplicity, we use two functions &lt;code&gt;max1&lt;/code&gt; and &lt;code&gt;max2&lt;/code&gt;.</source>
          <target state="translated">Ahora echemos un vistazo m&amp;aacute;s de cerca al investigar el ensamblado &lt;code&gt;x86&lt;/code&gt; que generan. Para simplificar, utilizamos dos funciones &lt;code&gt;max2&lt;/code&gt; y max2 .</target>
        </trans-unit>
        <trans-unit id="c330fcd6ba152c362d1fcd57661782df403680f7" translate="yes" xml:space="preserve">
          <source>Now, if we look at the code</source>
          <target state="translated">Ahora,si miramos el c√≥digo</target>
        </trans-unit>
        <trans-unit id="580a776c6b642fccec58ff95f40d16a839dd873b" translate="yes" xml:space="preserve">
          <source>Observations:</source>
          <target state="translated">Observations:</target>
        </trans-unit>
        <trans-unit id="c497da8cabdb633d3a209eb10a05a6e8a8479a34" translate="yes" xml:space="preserve">
          <source>On ARM, there is no branch needed, because every instruction has a 4-bit condition field, which tests (at zero cost) any of &lt;a href=&quot;https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/condition-codes-1-condition-flags-and-codes&quot;&gt;16 different different conditions&lt;/a&gt; that may arise in the Processor Status Register, and if the condition on an instruction is false, the instruction is skipped. This eliminates the need for short branches, and there would be no branch prediction hit for this algorithm. &lt;b&gt;Therefore, the sorted version of this algorithm would run slower than the unsorted version on ARM, because of the extra overhead of sorting.&lt;/b&gt;</source>
          <target state="translated">En ARM, no se necesita una bifurcaci&amp;oacute;n, porque cada instrucci&amp;oacute;n tiene un campo de condici&amp;oacute;n de 4 bits, que prueba (a costo cero) cualquiera de las &lt;a href=&quot;https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/condition-codes-1-condition-flags-and-codes&quot;&gt;16 condiciones diferentes&lt;/a&gt; que pueden surgir en el Registro de estado del procesador, y si la condici&amp;oacute;n de una instrucci&amp;oacute;n es falso, se omiten las instrucciones. Esto elimina la necesidad de ramificaciones cortas, y no habr&amp;iacute;a &amp;eacute;xito de predicci&amp;oacute;n de ramificaci&amp;oacute;n para este algoritmo. &lt;b&gt;Por lo tanto, la versi&amp;oacute;n ordenada de este algoritmo ser&amp;iacute;a m&amp;aacute;s lenta que la versi&amp;oacute;n no ordenada en ARM, debido a la sobrecarga adicional de la clasificaci&amp;oacute;n.&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97e13959d4711e37195fe7ecfc6a86c5fe97b99f" translate="yes" xml:space="preserve">
          <source>On a x86-64 machine, &lt;code&gt;GCC -S&lt;/code&gt; generates the assembly below.</source>
          <target state="translated">En una m&amp;aacute;quina x86-64, &lt;code&gt;GCC -S&lt;/code&gt; genera el siguiente ensamblaje.</target>
        </trans-unit>
        <trans-unit id="af5b27c4a00930aafb30d96f562d6210ddf9267b" translate="yes" xml:space="preserve">
          <source>On an Intel &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core i7&lt;/a&gt;-2600K @ 3.4&amp;nbsp;GHz and Visual Studio 2010 Release Mode, the benchmark is (format copied from Mysticial):</source>
          <target state="translated">En un Intel &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core i7&lt;/a&gt; -2600K @ 3.4 GHz y Visual Studio 2010 Release Mode, el punto de referencia es (formato copiado de Mysticial):</target>
        </trans-unit>
        <trans-unit id="c46e9d0de821ff22c14c3a97f36bb4c970b4b164" translate="yes" xml:space="preserve">
          <source>On the other hand, complex branch predictions &amp;ndash;either neural based or variants of two-level branch prediction &amp;ndash;provide better prediction accuracy, but they consume more power and complexity increases exponentially.</source>
          <target state="translated">Por otro lado, las predicciones de ramificaci&amp;oacute;n complejas, ya sean neurales o variantes de predicci&amp;oacute;n de ramificaci&amp;oacute;n de dos niveles, proporcionan una mejor precisi&amp;oacute;n de predicci&amp;oacute;n, pero consumen m&amp;aacute;s potencia y la complejidad aumenta exponencialmente.</target>
        </trans-unit>
        <trans-unit id="a5e809f1e268fe28804313bc9194b78b811d96b5" translate="yes" xml:space="preserve">
          <source>On the other hand, once it's sorted, the predictor will first move into a state of strongly not taken and when the values change to the high value the predictor will in three runs through change all the way from strongly not taken to strongly taken.</source>
          <target state="translated">Por otro lado,una vez clasificado,el pronosticador se mover√° primero a un estado de fuertemente no tomado y cuando los valores cambien al valor alto,el pronosticador en tres recorridos cambiar√° todo el camino de fuertemente no tomado a fuertemente tomado.</target>
        </trans-unit>
        <trans-unit id="3bbefccbf2bee10e9954cc81b62c16f44204ba33" translate="yes" xml:space="preserve">
          <source>One reason is branch prediction: the key operation in the sort algorithm is &lt;code&gt;&amp;ldquo;if(v[i] &amp;lt; pivot]) &amp;hellip;&amp;rdquo;&lt;/code&gt; or equivalent. For a sorted sequence that test is always true whereas, for a random sequence, the branch chosen varies randomly.</source>
          <target state="translated">Una raz&amp;oacute;n es la predicci&amp;oacute;n de bifurcaci&amp;oacute;n: la operaci&amp;oacute;n clave en el algoritmo de ordenaci&amp;oacute;n es &lt;code&gt;&amp;ldquo;if(v[i] &amp;lt; pivot]) &amp;hellip;&amp;rdquo;&lt;/code&gt; o equivalente. Para una secuencia ordenada, esa prueba siempre es verdadera, mientras que, para una secuencia aleatoria, la rama elegida var&amp;iacute;a aleatoriamente.</target>
        </trans-unit>
        <trans-unit id="6f83347c5969b82a1f9ad38db3d4941619744366" translate="yes" xml:space="preserve">
          <source>One way to avoid branch prediction errors is to build a lookup table, and index it using the data. Stefan de Bruijn discussed that in his answer.</source>
          <target state="translated">Una forma de evitar los errores de predicci√≥n de las ramas es construir una tabla de b√∫squeda,e indexarla usando los datos.Stefan de Bruijn discuti√≥ eso en su respuesta.</target>
        </trans-unit>
        <trans-unit id="dba85fca15da0466e912cf6f28584da718edda4e" translate="yes" xml:space="preserve">
          <source>Quicksort (and sorting in general) is a complex study that has attracted some of the greatest minds of computer science. A good sort function is a result of both choosing a good algorithm and paying attention to hardware performance in its implementation.</source>
          <target state="translated">Quicksort (y la clasificaci√≥n en general)es un estudio complejo que ha atra√≠do a algunas de las m√°s grandes mentes de la inform√°tica.Una buena funci√≥n de clasificaci√≥n es el resultado tanto de la elecci√≥n de un buen algoritmo como de prestar atenci√≥n al rendimiento del hardware en su implementaci√≥n.</target>
        </trans-unit>
        <trans-unit id="7eee27983091e8186d6b5fbbd3abab850ed0e885" translate="yes" xml:space="preserve">
          <source>Recently this example (modified very slightly) was also used as a way to demonstrate how a piece of code can be profiled within the program itself on Windows. Along the way, the author also shows how to use the results to determine where the code is spending most of its time in both the sorted &amp;amp; unsorted case. Finally the piece also shows how to use a little known feature of the HAL (Hardware Abstraction Layer) to determine just how much branch misprediction is happening in the unsorted case.</source>
          <target state="translated">Recientemente, este ejemplo (modificado muy ligeramente) tambi&amp;eacute;n se us&amp;oacute; como una forma de demostrar c&amp;oacute;mo se puede perfilar un fragmento de c&amp;oacute;digo dentro del programa en Windows. En el camino, el autor tambi&amp;eacute;n muestra c&amp;oacute;mo usar los resultados para determinar d&amp;oacute;nde pasa la mayor parte del tiempo el c&amp;oacute;digo, tanto en el caso ordenado como en el no ordenado. Finalmente, la pieza tambi&amp;eacute;n muestra c&amp;oacute;mo usar una caracter&amp;iacute;stica poco conocida de la HAL (Capa de abstracci&amp;oacute;n de hardware) para determinar cu&amp;aacute;nta predicci&amp;oacute;n de ramificaci&amp;oacute;n est&amp;aacute; ocurriendo en el caso no ordenado.</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="2e26f7f81e11c144071f07013d00802556dd33b0" translate="yes" xml:space="preserve">
          <source>Replace:</source>
          <target state="translated">Replace:</target>
        </trans-unit>
        <trans-unit id="5b332ccd041103419a2ad666b47b236d919bc4c8" translate="yes" xml:space="preserve">
          <source>Scientific papers - branch prediction computer architecture</source>
          <target state="translated">Art√≠culos cient√≠ficos-arquitectura de la computadora de predicci√≥n de ramas</target>
        </trans-unit>
        <trans-unit id="b01f405d3c10919c3c94fd65f54c0af170284f84" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://perf.wiki.kernel.org/index.php/Tutorial&quot;&gt;the performance tutorial&lt;/a&gt; for more details.</source>
          <target state="translated">Vea &lt;a href=&quot;https://perf.wiki.kernel.org/index.php/Tutorial&quot;&gt;el tutorial de rendimiento&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="3a298d21d0b3c80ce2982ea32ba8a81f978c30f0" translate="yes" xml:space="preserve">
          <source>So how would you strategically guess to minimize the number of times that the train must back up and go down the other path? You look at the past history! If the train goes left 99% of the time, then you guess left. If it alternates, then you alternate your guesses. If it goes one way every three times, you guess the same...</source>
          <target state="translated">Entonces,¬øc√≥mo adivinar√≠as estrat√©gicamente para minimizar el n√∫mero de veces que el tren debe retroceder y bajar por el otro camino? ¬°Mira la historia pasada! Si el tren va a la izquierda el 99% de las veces,entonces adivinas a la izquierda.Si se alterna,entonces alternas tus conjeturas.Si va en una direcci√≥n cada tres veces,adivinas lo mismo...</target>
        </trans-unit>
        <trans-unit id="9ebfa04f718206d91431f0015c26f1b42906f312" translate="yes" xml:space="preserve">
          <source>So in the first case, it will always take the true branch since historically all its predictions are correct.
In the 2nd case, initially it will predict wrong, but after a few iterations, it will predict correctly.
In the 3rd case, it will initially predict correctly till the elements are less than 128. After which it will fail for some time and the correct itself when it sees branch prediction failure in history.</source>
          <target state="translated">As√≠ que en el primer caso,siempre tomar√° la verdadera rama ya que hist√≥ricamente todas sus predicciones son correctas.En el segundo caso,inicialmente predecir√° mal,pero despu√©s de unas pocas iteraciones,predecir√° correctamente.En el tercer caso,inicialmente predecir√° correctamente hasta que los elementos sean menores de 128.Despu√©s de lo cual fallar√° durante alg√∫n tiempo y se corregir√° a s√≠ mismo cuando vea que la predicci√≥n de la rama falla en la historia.</target>
        </trans-unit>
        <trans-unit id="351943fae2a5bec40c06462d38700c5db13e382c" translate="yes" xml:space="preserve">
          <source>So programmatically, &lt;strong&gt;branch prediction&lt;/strong&gt; causes the process to be slower...</source>
          <target state="translated">Entonces, mediante programaci&amp;oacute;n, la &lt;strong&gt;predicci&amp;oacute;n de ramificaci&amp;oacute;n&lt;/strong&gt; hace que el proceso sea m&amp;aacute;s lento ...</target>
        </trans-unit>
        <trans-unit id="5ccec79adc1d899a1de0448aec6cd2999ea646b6" translate="yes" xml:space="preserve">
          <source>So there is no doubt about the impact of branch prediction on performance!</source>
          <target state="translated">¬°As√≠ que no hay duda del impacto de la predicci√≥n de la rama en el rendimiento!</target>
        </trans-unit>
        <trans-unit id="3ae2891b971dd8487010889269aa73c34566377f" translate="yes" xml:space="preserve">
          <source>So we've figured out that we can create a small table. Next thing to do is get a lookup function in place. Lookup functions are usually small functions that use a couple of basic integer operations (and, or, xor, shift, add, remove and perhaps multiply). You want to have your input translated by the lookup function to some kind of 'unique key' in your table, which then simply gives you the answer of all the work you wanted it to do.</source>
          <target state="translated">As√≠ que hemos descubierto que podemos crear una peque√±a mesa.Lo siguiente que hay que hacer es poner una funci√≥n de b√∫squeda en su lugar.Las funciones de b√∫squeda suelen ser peque√±as funciones que utilizan un par de operaciones enteras b√°sicas (y,o,xor,shift,add,remove y quiz√°s multiplicar).Quieres que tu entrada sea traducida por la funci√≥n de b√∫squeda a alg√∫n tipo de &quot;clave √∫nica&quot; en tu tabla,que luego simplemente te d√© la respuesta de todo el trabajo que quer√≠as que hiciera.</target>
        </trans-unit>
        <trans-unit id="e2fc4b8592d275115019311dc1f64056ef857314" translate="yes" xml:space="preserve">
          <source>So why does a conditional move perform better?</source>
          <target state="translated">Entonces,¬øpor qu√© un movimiento condicional funciona mejor?</target>
        </trans-unit>
        <trans-unit id="8862694fc5020ea843e75148ff60c38a99455cbf" translate="yes" xml:space="preserve">
          <source>So, I tried with a vector of a million integers and got:</source>
          <target state="translated">As√≠ que,intent√© con un vector de un mill√≥n de enteros y consegu√≠:</target>
        </trans-unit>
        <trans-unit id="26f99fe80efafd6fc68424aeeb2c6cf0ad1eb0fd" translate="yes" xml:space="preserve">
          <source>Some starting new elements are less than 128 and later it become greater than 128</source>
          <target state="translated">Algunos elementos nuevos iniciales son menores de 128 y m√°s tarde se convierten en mayores de 128</target>
        </trans-unit>
        <trans-unit id="0e167763d050d2cb6ded113f3e9064040103e166" translate="yes" xml:space="preserve">
          <source>Something like (unchecked)</source>
          <target state="translated">Algo as√≠ como (sin marcar)</target>
        </trans-unit>
        <trans-unit id="a88df12411d4a67fd1c80b6258959d001907e55b" translate="yes" xml:space="preserve">
          <source>Sometimes, some modern compilers can optimize our code to assembly with better performance, sometimes some compilers can't (the code in question is using Visual Studio's native compiler). Knowing the performance difference between branch and conditional move when unpredictable can help us write code with better performance when the scenario gets so complex that the compiler can not optimize them automatically.</source>
          <target state="translated">A veces,algunos compiladores modernos pueden optimizar nuestro c√≥digo para ensamblar con un mejor rendimiento,a veces algunos compiladores no pueden (el c√≥digo en cuesti√≥n est√° usando el compilador nativo de Visual Studio).Conocer la diferencia de rendimiento entre el movimiento de rama y el movimiento condicional cuando es impredecible puede ayudarnos a escribir c√≥digo con mejor rendimiento cuando el escenario se vuelve tan complejo que el compilador no puede optimizarlos autom√°ticamente.</target>
        </trans-unit>
        <trans-unit id="96ecd96ca3304ca88eb06e8a00937b5c4b49d3ed" translate="yes" xml:space="preserve">
          <source>Sorted Array: Straight Road
    ____________________________________________________________________________________
    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT</source>
          <target state="translated">Ordenados:Camino recto ____________________________________________________________________________-----------------</target>
        </trans-unit>
        <trans-unit id="417b7a8c229714395078ea87b358994e172876b0" translate="yes" xml:space="preserve">
          <source>Sorted arrays are processed faster than an unsorted array, due to a phenomena called branch prediction.</source>
          <target state="translated">Las matrices clasificadas se procesan m√°s r√°pido que una matriz no clasificada,debido a un fen√≥meno llamado predicci√≥n de ramas.</target>
        </trans-unit>
        <trans-unit id="12a86072c1d6226f21fdf1c483e322e5674a52e2" translate="yes" xml:space="preserve">
          <source>Sorting only k-element sections completes the pre-processing in linear time, &lt;code&gt;O(n)&lt;/code&gt;, rather than the &lt;code&gt;O(n.log(n))&lt;/code&gt; time needed to sort the entire array.</source>
          <target state="translated">La clasificaci&amp;oacute;n de solo secciones de elementos k completa el preprocesamiento en tiempo lineal, &lt;code&gt;O(n)&lt;/code&gt; , en lugar del tiempo &lt;code&gt;O(n.log(n))&lt;/code&gt; necesario para ordenar toda la matriz.</target>
        </trans-unit>
        <trans-unit id="911567da4c21b2d8b0b479e0b036b07488a7f699" translate="yes" xml:space="preserve">
          <source>Starting with the original loop:</source>
          <target state="translated">Empezando por el bucle original:</target>
        </trans-unit>
        <trans-unit id="b289c5eb6b8d96218afa396493007fb0c5566528" translate="yes" xml:space="preserve">
          <source>Static branch prediction is used by the microprocessor the first time
  a conditional branch is encountered, and dynamic branch prediction is
  used for succeeding executions of the conditional branch code.</source>
          <target state="translated">El microprocesador utiliza la predicci√≥n de la rama est√°tica la primera vez que se encuentra una rama condicional,y la predicci√≥n de la rama din√°mica para las ejecuciones sucesivas del c√≥digo de la rama condicional.</target>
        </trans-unit>
        <trans-unit id="0f6ae2e9812cde1bb50890188a75301caf057eb4" translate="yes" xml:space="preserve">
          <source>That being said, the compiler tries to predict the outcome prior to it being actually evaluated. It will fetch instructions from the &lt;code&gt;if&lt;/code&gt; block, and if the expression turns out to be true, then wonderful! We gained the time it took to evaluate it and made progress in the code; if not then we are running the wrong code, the pipeline is flushed, and the correct block is run.</source>
          <target state="translated">Dicho esto, el compilador intenta predecir el resultado antes de que se eval&amp;uacute;e realmente. Obtendr&amp;aacute; instrucciones del bloque &lt;code&gt;if&lt;/code&gt; , y si la expresi&amp;oacute;n resulta ser verdadera, &amp;iexcl;entonces maravilloso! Ganamos el tiempo necesario para evaluarlo y progresamos en el c&amp;oacute;digo; si no, entonces estamos ejecutando el c&amp;oacute;digo incorrecto, la tuber&amp;iacute;a se vac&amp;iacute;a y se ejecuta el bloque correcto.</target>
        </trans-unit>
        <trans-unit id="35261a879de9858385098dadcc5581d89b2d609f" translate="yes" xml:space="preserve">
          <source>That one is 100,000 times faster than before.</source>
          <target state="translated">Ese es 100.000 veces m√°s r√°pido que antes.</target>
        </trans-unit>
        <trans-unit id="08f10e7e1256e6e98ddd64a702e8dc6f1d8014d5" translate="yes" xml:space="preserve">
          <source>That sounds like an interview question. Is it true? How would you know? It is a bad idea to answer questions about efficiency without first doing some measurements, so it is important to know how to measure.</source>
          <target state="translated">Eso suena como una pregunta de entrevista.¬øEs cierto? ¬øC√≥mo lo sabes? Es una mala idea responder a las preguntas sobre la eficiencia sin hacer primero algunas mediciones,por lo que es importante saber c√≥mo medir.</target>
        </trans-unit>
        <trans-unit id="508b04c27cc3f2089b5ea384a8ad1dd729afae1a" translate="yes" xml:space="preserve">
          <source>That's for sure!...</source>
          <target state="translated">¬°Eso es seguro!...</target>
        </trans-unit>
        <trans-unit id="0cde2413f2853914209f8169d7f3210951656de9" translate="yes" xml:space="preserve">
          <source>The above behavior is happening because of Branch prediction.</source>
          <target state="translated">El comportamiento anterior est√° ocurriendo debido a la predicci√≥n de Branch.</target>
        </trans-unit>
        <trans-unit id="76fff62130dd99e863f74fb23823d0e6b58d4f70" translate="yes" xml:space="preserve">
          <source>The answer to your question is very simple.</source>
          <target state="translated">La respuesta a su pregunta es muy simple.</target>
        </trans-unit>
        <trans-unit id="429f9a89629f65eb36edfe9122d197b4a3ab1462" translate="yes" xml:space="preserve">
          <source>The assumption by other answers that one needs to sort the data is not correct.</source>
          <target state="translated">La suposici√≥n de otras respuestas de que hay que clasificar los datos no es correcta.</target>
        </trans-unit>
        <trans-unit id="14fca0f59106880a0be992b705d52d3aeb245c06" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0136108040&quot;&gt;Computer Systems: A Programmer's Perspective, second edition&lt;/a&gt;&lt;/em&gt; explains this in detail. You can check Section 3.6.6 for &lt;em&gt;Conditional Move Instructions&lt;/em&gt;, entire Chapter 4 for &lt;em&gt;Processor Architecture&lt;/em&gt;, and Section 5.11.2 for a special treatment for &lt;em&gt;Branch Prediction and Misprediction Penalties&lt;/em&gt;.</source>
          <target state="translated">El libro &lt;em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0136108040&quot;&gt;Computer Systems: A Programmer's Perspective, segunda edici&amp;oacute;n,&lt;/a&gt;&lt;/em&gt; explica esto en detalle. Puede consultar la Secci&amp;oacute;n 3.6.6 para ver las &lt;em&gt;Instrucciones de movimiento condicional&lt;/em&gt; , el Cap&amp;iacute;tulo 4 completo para la &lt;em&gt;Arquitectura del procesador&lt;/em&gt; y la Secci&amp;oacute;n 5.11.2 para obtener un tratamiento especial para las &lt;em&gt;Penalizaciones de predicci&amp;oacute;n de rama y de predicci&amp;oacute;n err&amp;oacute;nea&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="01c31d56c186a6ecf1549609412d42ba9d45ea61" translate="yes" xml:space="preserve">
          <source>The branch prediction will miss only once.</source>
          <target state="translated">La predicci√≥n de la rama se perder√° s√≥lo una vez.</target>
        </trans-unit>
        <trans-unit id="29c1be7f24497d0ee26471ab9535a6a90d257408" translate="yes" xml:space="preserve">
          <source>The branch predictor is a digital circuit (in computer architecture) trying to predict which way a branch will go, improving the flow in the instruction pipeline. The circuit/computer predicts the next step and executes it.</source>
          <target state="translated">El predictor de ramas es un circuito digital (en arquitectura de ordenador)que intenta predecir en qu√© direcci√≥n ir√° una rama,mejorando el flujo en la tuber√≠a de instrucciones.La computadora del circuito predice el siguiente paso y lo ejecuta.</target>
        </trans-unit>
        <trans-unit id="b7d588a1c5460542b96d8b0baf1bab136cf8c2f6" translate="yes" xml:space="preserve">
          <source>The code is summing up some independent terms, so the order should not matter.</source>
          <target state="translated">El c√≥digo est√° resumiendo algunos t√©rminos independientes,as√≠ que el orden no deber√≠a importar.</target>
        </trans-unit>
        <trans-unit id="861f94790ecfa967155e62be104ac537e52a5f3a" translate="yes" xml:space="preserve">
          <source>The condition testing field and the optional &quot;set status bit&quot; field can be combined, for example:</source>
          <target state="translated">Por ejemplo,se puede combinar el campo de pruebas de condici√≥n y el campo opcional &quot;set status bit&quot;:</target>
        </trans-unit>
        <trans-unit id="6fc938b02ae6f7028fe10706590f459d70027752" translate="yes" xml:space="preserve">
          <source>The example contains three instructions and the first one is a conditional jump instruction. The latter two instructions can go into the pipeline until the conditional jump instruction is executed.</source>
          <target state="translated">El ejemplo contiene tres instrucciones y la primera es una instrucci√≥n de salto condicional.Las dos √∫ltimas instrucciones pueden entrar en la tuber√≠a hasta que se ejecute la instrucci√≥n de salto condicional.</target>
        </trans-unit>
        <trans-unit id="366e9cefdfc7cf84268b4baae54481cba492ad51" translate="yes" xml:space="preserve">
          <source>The first thing we need to know is what is &lt;em&gt;small&lt;/em&gt;? While smaller is generally better, a rule of thumb is to stick to lookup tables that are &amp;lt;= 4096 bytes in size. As an upper limit: if your lookup table is larger than 64K it's probably worth reconsidering.</source>
          <target state="translated">Lo primero que debemos saber es qu&amp;eacute; es &lt;em&gt;peque&amp;ntilde;o&lt;/em&gt; . Mientras m&amp;aacute;s peque&amp;ntilde;o es generalmente mejor, una regla general es apegarse a las tablas de b&amp;uacute;squeda que tienen un tama&amp;ntilde;o &amp;lt;= 4096 bytes. Como l&amp;iacute;mite superior: si su tabla de b&amp;uacute;squeda es mayor a 64K, probablemente valga la pena reconsiderarla.</target>
        </trans-unit>
        <trans-unit id="6ba638444517f57a3c3d8cf6edb54711b632d388" translate="yes" xml:space="preserve">
          <source>The following code does not sort the entire array, but only 200-element segments of it, and thereby runs the fastest.</source>
          <target state="translated">El siguiente c√≥digo no ordena todo el conjunto,sino s√≥lo 200 segmentos de elementos,y por lo tanto es el m√°s r√°pido.</target>
        </trans-unit>
        <trans-unit id="7983685e650d0c0a12e46c770cad6a3ca1107dcd" translate="yes" xml:space="preserve">
          <source>The inner loop for this algorithm would look something like the following in ARM assembly language:</source>
          <target state="translated">El bucle interno de este algoritmo se ver√≠a algo as√≠ como lo siguiente en el lenguaje de ensamblaje ARM:</target>
        </trans-unit>
        <trans-unit id="28885d236427f0638d59b0c11dc0c5a23a6555c9" translate="yes" xml:space="preserve">
          <source>The link is here:
&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&lt;/a&gt;</source>
          <target state="translated">El enlace est&amp;aacute; aqu&amp;iacute;: &lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="88c912641d7171878bede0b6532896dc83279c69" translate="yes" xml:space="preserve">
          <source>The performance of an &lt;code&gt;if&lt;/code&gt;-statement depends on whether its condition has a predictable pattern. If the condition is always true or always false, the branch prediction logic in the processor will pick up the pattern. On the other hand, if the pattern is unpredictable, the &lt;code&gt;if&lt;/code&gt;-statement will be much more expensive.</source>
          <target state="translated">El rendimiento de una declaraci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; depende de si su condici&amp;oacute;n tiene un patr&amp;oacute;n predecible. Si la condici&amp;oacute;n es siempre verdadera o siempre falsa, la l&amp;oacute;gica de predicci&amp;oacute;n de bifurcaci&amp;oacute;n en el procesador recoger&amp;aacute; el patr&amp;oacute;n. Por otro lado, si el patr&amp;oacute;n es impredecible, la declaraci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; ser&amp;aacute; mucho m&amp;aacute;s costosa.</target>
        </trans-unit>
        <trans-unit id="f012bd762d6379e8ee89682917865e46bdb77c96" translate="yes" xml:space="preserve">
          <source>The question is: What makes the above statement not execute in certain cases as in case of sorted data? Here comes the &quot;branch predictor&quot;. A branch predictor is a digital circuit that tries to guess which way a branch (e.g. an &lt;code&gt;if-then-else&lt;/code&gt; structure) will go before this is known for sure. The purpose of the branch predictor is to improve the flow in the instruction pipeline. Branch predictors play a critical role in achieving high effective performance!</source>
          <target state="translated">La pregunta es: &amp;iquest;qu&amp;eacute; hace que la declaraci&amp;oacute;n anterior no se ejecute en ciertos casos como en el caso de los datos ordenados? Aqu&amp;iacute; viene el &quot;predictor de rama&quot;. Un predictor de bifurcaci&amp;oacute;n es un circuito digital que intenta adivinar en qu&amp;eacute; direcci&amp;oacute;n ir&amp;aacute; una bifurcaci&amp;oacute;n (por ejemplo, una estructura &lt;code&gt;if-then-else&lt;/code&gt; ) antes de que esto sea seguro. El prop&amp;oacute;sito del predictor de rama es mejorar el flujo en la tuber&amp;iacute;a de instrucciones. &amp;iexcl;Los predictores de rama juegan un papel fundamental para lograr un alto rendimiento efectivo!</target>
        </trans-unit>
        <trans-unit id="23c9a538a1ef4688c167a88337fa568b94155241" translate="yes" xml:space="preserve">
          <source>The reason why performance improves drastically when the data is sorted is that the branch prediction penalty is removed, as explained beautifully in &lt;a href=&quot;https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902&quot;&gt;Mysticial's answer&lt;/a&gt;.</source>
          <target state="translated">La raz&amp;oacute;n por la cual el rendimiento mejora dr&amp;aacute;sticamente cuando se ordenan los datos es que se elimina la penalizaci&amp;oacute;n de predicci&amp;oacute;n de rama, como se explica maravillosamente en &lt;a href=&quot;https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902&quot;&gt;la respuesta de Mysticial&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="243cce3d654c2e7e3d82b9ec0fc8b02ca07456a2" translate="yes" xml:space="preserve">
          <source>The result is robust in multiple tests. We get a great speedup when the branch result is unpredictable, but we suffer a little bit when it is predictable. In fact, when using a conditional move, the performance is the same regardless of the data pattern.</source>
          <target state="translated">El resultado es robusto en m√∫ltiples pruebas.Conseguimos una gran aceleraci√≥n cuando el resultado de la rama es impredecible,pero sufrimos un poco cuando es predecible.De hecho,cuando se utiliza un movimiento condicional,el rendimiento es el mismo independientemente del patr√≥n de datos.</target>
        </trans-unit>
        <trans-unit id="8b2b071beeb1c27797d622cdfe18d46550e595b8" translate="yes" xml:space="preserve">
          <source>The results for the above MATLAB code are as follows:</source>
          <target state="translated">Los resultados para el c√≥digo MATLAB anterior son los siguientes:</target>
        </trans-unit>
        <trans-unit id="4c621c1518421a4f9a5e82a55048d9d384c6117a" translate="yes" xml:space="preserve">
          <source>The results of the C code as in @GManNickG I get:</source>
          <target state="translated">Los resultados del c√≥digo C como en @GManNickG que obtengo:</target>
        </trans-unit>
        <trans-unit id="c51e81726485eb1f77e86bce9119907916de64b6" translate="yes" xml:space="preserve">
          <source>The technique of indexing into an array, instead of using an &lt;code&gt;if&lt;/code&gt; statement, can be used for deciding which pointer to use.  I saw a library that implemented binary trees, and instead of having two named pointers (&lt;code&gt;pLeft&lt;/code&gt; and &lt;code&gt;pRight&lt;/code&gt; or whatever) had a length-2 array of pointers and used the &quot;decision bit&quot; technique to decide which one to follow.  For example, instead of:</source>
          <target state="translated">La t&amp;eacute;cnica de indexar en una matriz, en lugar de usar una instrucci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; , se puede usar para decidir qu&amp;eacute; puntero usar. Vi una biblioteca que implement&amp;oacute; &amp;aacute;rboles binarios, y en lugar de tener dos punteros con nombre ( &lt;code&gt;pLeft&lt;/code&gt; y &lt;code&gt;pRight&lt;/code&gt; o lo que sea) ten&amp;iacute;a una matriz de punteros de longitud 2 y us&amp;eacute; la t&amp;eacute;cnica de &quot;bit de decisi&amp;oacute;n&quot; para decidir cu&amp;aacute;l seguir. Por ejemplo, en lugar de:</target>
        </trans-unit>
        <trans-unit id="dfc876aaa5431ea7d4210f0979641e4dbe4d96a9" translate="yes" xml:space="preserve">
          <source>The technique of indexing into an array, instead of using an if statement, can be used for deciding which pointer to use. I saw a library that implemented binary trees, and instead of having two named pointers (pLeft and pRight or whatever) had a length-2 array of pointers and used the &quot;decision bit&quot; technique to decide which one to follow. For example, instead of:</source>
          <target state="translated">La t√©cnica de indexaci√≥n en una matriz,en lugar de utilizar una declaraci√≥n if,puede utilizarse para decidir qu√© puntero utilizar.Vi una biblioteca que implementaba √°rboles binarios,y en lugar de tener dos punteros con nombre (pLeft y pRight o lo que sea)ten√≠a una matriz de punteros de longitud 2 y utilizaba la t√©cnica de &quot;bit de decisi√≥n&quot; para decidir cu√°l seguir.Por ejemplo,en lugar de:</target>
        </trans-unit>
        <trans-unit id="b6cfe976487000bd1e4d79b8ceec46016b036b7e" translate="yes" xml:space="preserve">
          <source>The time that is wasted in case of a branch misprediction is equal to
  the number of stages in the pipeline from the fetch stage to the
  execute stage. Modern microprocessors tend to have quite long
  pipelines so that the misprediction delay is between 10 and 20 clock
  cycles. As a result, making a pipeline longer increases the need for a
  more advanced branch predictor.</source>
          <target state="translated">El tiempo que se pierde en caso de un error en la predicci√≥n de una rama es igual al n√∫mero de etapas en la tuber√≠a desde la etapa de b√∫squeda hasta la etapa de ejecuci√≥n.Los microprocesadores modernos tienden a tener tuber√≠as bastante largas,de modo que el retraso de la predicci√≥n err√≥nea es de entre 10 y 20 ciclos de reloj.Como resultado,al alargar una tuber√≠a aumenta la necesidad de un predictor de derivaci√≥n m√°s avanzado.</target>
        </trans-unit>
        <trans-unit id="146d532a4e98e5f647a42caf674908e8ad82de98" translate="yes" xml:space="preserve">
          <source>Then, you can see that the &lt;code&gt;if&lt;/code&gt; conditional is constant throughout the execution of the &lt;code&gt;i&lt;/code&gt; loop, so you can hoist the &lt;code&gt;if&lt;/code&gt; out:</source>
          <target state="translated">Luego, puede ver que el condicional &lt;code&gt;if&lt;/code&gt; es constante durante la ejecuci&amp;oacute;n del ciclo &lt;code&gt;i&lt;/code&gt; , por lo que puede izar el &lt;code&gt;if&lt;/code&gt; fuera:</target>
        </trans-unit>
        <trans-unit id="e5bc19f51ab3899c2bcbdd21013a0f3ed4bf7a2d" translate="yes" xml:space="preserve">
          <source>Then, you see that the inner loop can be collapsed into one single expression, assuming the floating point model allows it (&lt;code&gt;/fp:fast&lt;/code&gt; is thrown, for example)</source>
          <target state="translated">Luego, ver&amp;aacute; que el bucle interno se puede contraer en una sola expresi&amp;oacute;n, suponiendo que el modelo de punto flotante lo permita ( &lt;code&gt;/fp:fast&lt;/code&gt; se lanza, por ejemplo)</target>
        </trans-unit>
        <trans-unit id="0fdbaf8dd82a2699c782cb69604fae05291b1fe4" translate="yes" xml:space="preserve">
          <source>There has been quite some work on eliminating this branch for managed languages. For example:</source>
          <target state="translated">Se ha trabajado bastante en la eliminaci√≥n de esta rama para los idiomas administrados.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="7b8c8145d6acbc5bd1d7476826d81337b7799153" translate="yes" xml:space="preserve">
          <source>There really are three different kinds of branches:</source>
          <target state="translated">Realmente hay tres tipos diferentes de ramas:</target>
        </trans-unit>
        <trans-unit id="df08e2eb1f25b5e02231e29ab5a1fabee4d43dce" translate="yes" xml:space="preserve">
          <source>This also &quot;proves&quot; that it has nothing to do with any algorithmic issue such as sort order, and it is indeed branch prediction.</source>
          <target state="translated">Esto tambi√©n &quot;prueba&quot; que no tiene nada que ver con ninguna cuesti√≥n algor√≠tmica como el orden de clasificaci√≥n,y es de hecho la predicci√≥n de la rama.</target>
        </trans-unit>
        <trans-unit id="5f5f7d59641cd2d4e5ccd00f97168241ae614777" translate="yes" xml:space="preserve">
          <source>This approach works in general if:</source>
          <target state="translated">Este enfoque funciona en general si:</target>
        </trans-unit>
        <trans-unit id="157ae22157daa30935359fff59ce72e0d87c83f4" translate="yes" xml:space="preserve">
          <source>This code is far from optimal. The branches may take a long time in case of mispredictions. The Boolean operations can be made much more efficient if it is known with certainty that the operands have no other values than &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. The reason why the compiler does not make such an assumption is that the variables might have other values if they are uninitialized or come from unknown sources. The above code can be optimized if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has been initialized to valid values or if they come from operators that produce Boolean output. The optimized code looks like this:</source>
          <target state="translated">Este c&amp;oacute;digo est&amp;aacute; lejos de ser &amp;oacute;ptimo. Las ramas pueden tardar mucho tiempo en caso de predicciones err&amp;oacute;neas. Las operaciones booleanas pueden hacerse mucho m&amp;aacute;s eficientes si se sabe con certeza que los operandos no tienen otros valores que &lt;code&gt;0&lt;/code&gt; y &lt;code&gt;1&lt;/code&gt; . La raz&amp;oacute;n por la cual el compilador no hace tal suposici&amp;oacute;n es que las variables pueden tener otros valores si no se inicializan o provienen de fuentes desconocidas. El c&amp;oacute;digo anterior se puede optimizar si &lt;code&gt;b&lt;/code&gt; se ha inicializado a valores v&amp;aacute;lidos o si provienen de operadores que producen una salida booleana. El c&amp;oacute;digo optimizado se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="ad588604ed82a4498c092e23d01a6024f6fd9f5a" translate="yes" xml:space="preserve">
          <source>This code wastes half of the adds but never has a branch prediction failure. It's tremendously faster on random data than the version with an actual if statement.</source>
          <target state="translated">Este c√≥digo desperdicia la mitad de las adiciones pero nunca tiene un fallo de predicci√≥n de rama.Es tremendamente m√°s r√°pido en datos aleatorios que la versi√≥n con una declaraci√≥n de &quot;si&quot; real.</target>
        </trans-unit>
        <trans-unit id="a15071f65ca5442561d11637a382876b2bbe52fb" translate="yes" xml:space="preserve">
          <source>This eliminates the branch and replaces it with some bitwise operations.</source>
          <target state="translated">Esto elimina la rama y la reemplaza con algunas operaciones poco inteligentes.</target>
        </trans-unit>
        <trans-unit id="bfca5608e058cd556c4ac52b23258add44c52119" translate="yes" xml:space="preserve">
          <source>This goes to show that even mature modern compilers can vary wildly in their ability to optimize code...</source>
          <target state="translated">Esto demuestra que incluso los compiladores modernos maduros pueden variar mucho en su capacidad de optimizar el c√≥digo...</target>
        </trans-unit>
        <trans-unit id="18e2896e8160beec33e159c94bd6ee44deed00cc" translate="yes" xml:space="preserve">
          <source>This is branch prediction. I admit it's not the best analogy since the train could just signal the direction with a flag. But in computers, the processor doesn't know which direction a branch will go until the last moment.</source>
          <target state="translated">Esta es la predicci√≥n de la rama.Admito que no es la mejor analog√≠a ya que el tren podr√≠a se√±alar la direcci√≥n con una bandera.Pero en las computadoras,el procesador no sabe en qu√© direcci√≥n ir√° una rama hasta el √∫ltimo momento.</target>
        </trans-unit>
        <trans-unit id="d0c1d7a998794d7121446abef39a77def740f803" translate="yes" xml:space="preserve">
          <source>This is typically implemented by the compiler in the following way:</source>
          <target state="translated">El compilador suele implementarlo de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="2bfa3272ab37710c1267a39900a9e349042c88c7" translate="yes" xml:space="preserve">
          <source>This is very friendly to the branch predictor since the branch consecutively goes the same direction many times. Even a simple saturating counter will correctly predict the branch except for the few iterations after it switches direction.</source>
          <target state="translated">Esto es muy amigable para el pronosticador de ramas,ya que la rama va consecutivamente en la misma direcci√≥n muchas veces.Incluso un simple contador de saturaci√≥n predecir√° correctamente la rama,excepto por las pocas iteraciones despu√©s de que cambia de direcci√≥n.</target>
        </trans-unit>
        <trans-unit id="615c711dbe5df7298f33242a06d07ca902c32379" translate="yes" xml:space="preserve">
          <source>This lets you easily identify the problematic line - in the unsorted version the &lt;code&gt;if (data[c] &amp;gt;= 128)&lt;/code&gt; line is causing 164,050,007 mispredicted conditional branches (&lt;code&gt;Bcm&lt;/code&gt;) under cachegrind's branch-predictor model, whereas it's only causing 10,006 in the sorted version.</source>
          <target state="translated">Esto le permite identificar f&amp;aacute;cilmente la l&amp;iacute;nea problem&amp;aacute;tica: en la versi&amp;oacute;n no ordenada, la l&amp;iacute;nea &lt;code&gt;if (data[c] &amp;gt;= 128)&lt;/code&gt; est&amp;aacute; causando 164,050,007 ramas condicionales ( &lt;code&gt;Bcm&lt;/code&gt; ) mal predichas bajo el modelo predictor de ramas de cachegrind , mientras que solo est&amp;aacute; causando 10,006 en la versi&amp;oacute;n ordenada .</target>
        </trans-unit>
        <trans-unit id="62a8acf06dc12988abe140d1d1ffb08120df1a06" translate="yes" xml:space="preserve">
          <source>This question has already been answered excellently many times over. Still I'd like to draw the group's attention to yet another interesting analysis.</source>
          <target state="translated">Esta pregunta ya ha sido contestada excelentemente muchas veces.A√∫n as√≠,me gustar√≠a llamar la atenci√≥n del grupo sobre otro an√°lisis interesante.</target>
        </trans-unit>
        <trans-unit id="7ab809ea371604dfeb3647ba6b30215c1eb2398d" translate="yes" xml:space="preserve">
          <source>This question is rooted in Branch Prediction Models on CPUs. I'd recommend reading this paper:</source>
          <target state="translated">Esta pregunta tiene sus ra√≠ces en los modelos de predicci√≥n de ramas en las CPU.Recomendar√≠a leer este art√≠culo:</target>
        </trans-unit>
        <trans-unit id="bda231ceb9d58c33b0e891be602a5fde29542e65" translate="yes" xml:space="preserve">
          <source>To execute instruction B or instruction C the processor will have to wait till the instruction A doesn't reach till EX stage in the pipeline, as the decision to go to instruction B or instruction C depends on the result of instruction A. So the pipeline will look like this.</source>
          <target state="translated">Para ejecutar la instrucci√≥n B o la instrucci√≥n C el procesador tendr√° que esperar hasta que la instrucci√≥n A no alcance la etapa EX en el pipeline,ya que la decisi√≥n de ir a la instrucci√≥n B o a la instrucci√≥n C depende del resultado de la instrucci√≥n A.As√≠ que el pipeline tendr√° este aspecto.</target>
        </trans-unit>
        <trans-unit id="0b7e892117417fb4b6c49ca103d227fc9f4d1140" translate="yes" xml:space="preserve">
          <source>To understand branch prediction one must first understand &lt;strong&gt;Instruction Pipeline&lt;/strong&gt;:</source>
          <target state="translated">Para comprender la predicci&amp;oacute;n de ramificaci&amp;oacute;n, primero se debe comprender la &lt;strong&gt;canalizaci&amp;oacute;n de instrucciones&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="a29c68a2d5e91d86d31480109b1da5bc8e35f407" translate="yes" xml:space="preserve">
          <source>Two-way branching is usually implemented with a conditional jump
  instruction. A conditional jump can either be &quot;not taken&quot; and continue
  execution with the first branch of code which follows immediately
  after the conditional jump, or it can be &quot;taken&quot; and jump to a
  different place in program memory where the second branch of code is
  stored. It is not known for certain whether a conditional jump will be
  taken or not taken until the condition has been calculated and the
  conditional jump has passed the execution stage in the instruction
  pipeline (see fig. 1).</source>
          <target state="translated">La ramificaci√≥n bidireccional se suele implementar con una instrucci√≥n de salto condicional.Un salto condicional puede ser &quot;no tomado&quot; y continuar la ejecuci√≥n con la primera rama de c√≥digo que sigue inmediatamente despu√©s del salto condicional,o puede ser &quot;tomado&quot; y saltar a un lugar diferente en la memoria del programa donde se almacena la segunda rama de c√≥digo.No se sabe con certeza si un salto condicional se tomar√° o no se tomar√° hasta que se haya calculado la condici√≥n y el salto condicional haya pasado la etapa de ejecuci√≥n en la tuber√≠a de la instrucci√≥n (v√©ase la figura 1).</target>
        </trans-unit>
        <trans-unit id="dcb1d0bc5503faffa53fc3453598b0d035a0c897" translate="yes" xml:space="preserve">
          <source>Unsorted Array: Curved Road</source>
          <target state="translated">Un conjunto sin clasificar:Camino curvo</target>
        </trans-unit>
        <trans-unit id="c006e2b20060032caaabd451e6df6a02a78a5ac3" translate="yes" xml:space="preserve">
          <source>Use Branch Predictor and don't take a conditional jump. Let's assume that the predict is &lt;strong&gt;not&lt;/strong&gt; taking the conditional jump.</source>
          <target state="translated">Use Branch Predictor y no tome un salto condicional. Supongamos que la predicci&amp;oacute;n &lt;strong&gt;no&lt;/strong&gt; est&amp;aacute; dando el salto condicional.</target>
        </trans-unit>
        <trans-unit id="12c9166e85e51c6ec14fc60d80a7a0f3c7c32568" translate="yes" xml:space="preserve">
          <source>Use Branch Predictor and take a conditional jump. Let's assume that the predict is &lt;strong&gt;not&lt;/strong&gt; taking the conditional jump.</source>
          <target state="translated">Usa el Predictor de rama y da un salto condicional. Supongamos que la predicci&amp;oacute;n &lt;strong&gt;no&lt;/strong&gt; est&amp;aacute; dando el salto condicional.</target>
        </trans-unit>
        <trans-unit id="a08965e116be4f8dd9b991b5c78c2f2a4953805f" translate="yes" xml:space="preserve">
          <source>Using bitwise operators is more advantageous if the operands are variables than if the operands are comparisons:</source>
          <target state="translated">El uso de operadores de bits es m√°s ventajoso si los operandos son variables que si los operandos son comparaciones:</target>
        </trans-unit>
        <trans-unit id="753325de5864d63921392f6d1fdfec25be2f1719" translate="yes" xml:space="preserve">
          <source>VC++ 2010 is unable to generate conditional moves for this branch even under &lt;code&gt;/Ox&lt;/code&gt;.</source>
          <target state="translated">VC ++ 2010 no puede generar movimientos condicionales para esta rama incluso bajo &lt;code&gt;/Ox&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d043004e185c7b0efa7dc62df9e481517f2fae51" translate="yes" xml:space="preserve">
          <source>Visualization:</source>
          <target state="translated">Visualization:</target>
        </trans-unit>
        <trans-unit id="a3b2fe94f4750042ee509a40cd1b811c02dcc827" translate="yes" xml:space="preserve">
          <source>WB -- Write back to CPU register</source>
          <target state="translated">WB...Vuelve a escribir en el registro de la CPU</target>
        </trans-unit>
        <trans-unit id="6375cff5f915d0ad5739238963ce456b2a75e8c2" translate="yes" xml:space="preserve">
          <source>Well, not exactly... :-)</source>
          <target state="translated">Bueno,no exactamente...:-)</target>
        </trans-unit>
        <trans-unit id="a608d088fa8295119cc45125ae05fa9e8da0660e" translate="yes" xml:space="preserve">
          <source>What is Branch Prediction?</source>
          <target state="translated">¬øQu√© es la Predicci√≥n de Rama?</target>
        </trans-unit>
        <trans-unit id="ddc44bd3685ad0a82e462b5b7860aa861536395a" translate="yes" xml:space="preserve">
          <source>What is going on?</source>
          <target state="translated">¬øQu√© es lo que est√° pasando?</target>
        </trans-unit>
        <trans-unit id="5079282bb6ac8d8fd7800b70a515ca1a7779ded0" translate="yes" xml:space="preserve">
          <source>When you have sorted elements, IR could not be bothered to fetch all CPU instructions, again and again, It fetches them from cache.</source>
          <target state="translated">Cuando has clasificado los elementos,IR no pod√≠a molestarse en buscar todas las instrucciones de la CPU,una y otra vez,las busca en la cach√©.</target>
        </trans-unit>
        <trans-unit id="93820c99e002586797e0fc268993184aa2c6be22" translate="yes" xml:space="preserve">
          <source>Whenever there's an &lt;code&gt;if-else&lt;/code&gt; \ &lt;code&gt;switch&lt;/code&gt; statement, the expression has to be evaluated to determine which block should be executed. In the assembly code generated by the compiler, conditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt; instructions are inserted.</source>
          <target state="translated">Siempre que haya una instrucci&amp;oacute;n &lt;code&gt;if-else&lt;/code&gt; \ &lt;code&gt;switch&lt;/code&gt; , la expresi&amp;oacute;n debe evaluarse para determinar qu&amp;eacute; bloque debe ejecutarse. En el c&amp;oacute;digo de ensamblaje generado por el compilador, se insertan instrucciones de &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;ramificaci&amp;oacute;n&lt;/a&gt; condicional.</target>
        </trans-unit>
        <trans-unit id="467f5fe90dca59bcce184cb76b5258ae0f818f25" translate="yes" xml:space="preserve">
          <source>While flushing pipelines is super fast, nowadays taking this gamble is worth it. Predicting sorted data or a data that changes slowly is always easier and better than predicting fast changes.</source>
          <target state="translated">Mientras que limpiar los oleoductos es s√∫per r√°pido,hoy en d√≠a vale la pena hacer esta apuesta.Predecir datos ordenados o un dato que cambia lentamente es siempre m√°s f√°cil y mejor que predecir cambios r√°pidos.</target>
        </trans-unit>
        <trans-unit id="7a096e98f70b03605f1fd87dee197c0e0dc2d954" translate="yes" xml:space="preserve">
          <source>While maintaining readability, we can check the speedup factor.</source>
          <target state="translated">Mientras mantenemos la legibilidad,podemos comprobar el factor de aceleraci√≥n.</target>
        </trans-unit>
        <trans-unit id="9792cdf86b1977e88d80d53a5f46d6bb5efa646c" translate="yes" xml:space="preserve">
          <source>Why is processing a sorted array faster than processing an unsorted array</source>
          <target state="translated">¬øPor qu√© procesar una matriz ordenada es m√°s r√°pido que procesar una matriz no ordenada</target>
        </trans-unit>
        <trans-unit id="0ecd9604afd7fdf56bd91ee7561b152cde1f8ed3" translate="yes" xml:space="preserve">
          <source>Why is processing a sorted array faster than processing an unsorted array?</source>
          <target state="translated">¬øPor qu√© procesar una matriz ordenada es m√°s r√°pido que procesar una matriz no ordenada?</target>
        </trans-unit>
        <trans-unit id="45e27afeaa62cf0cccdd3110fde02e47401ff594" translate="yes" xml:space="preserve">
          <source>With a similar but less extreme result.</source>
          <target state="translated">Con un resultado similar pero menos extremo.</target>
        </trans-unit>
        <trans-unit id="00bb7f0f6f10727b9d3a497aec7ad500fc1da108" translate="yes" xml:space="preserve">
          <source>With a sorted array, the condition &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; is first &lt;code&gt;false&lt;/code&gt; for a streak of values, then becomes &lt;code&gt;true&lt;/code&gt; for all later values. That's easy to predict. With an unsorted array, you pay for the branching cost.</source>
          <target state="translated">Con una matriz ordenada, los &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; condici&amp;oacute;n [c]&amp;gt; = 128 son primero &lt;code&gt;false&lt;/code&gt; para una raya de valores, luego se vuelven &lt;code&gt;true&lt;/code&gt; para todos los valores posteriores. Eso es f&amp;aacute;cil de predecir. Con una matriz sin clasificar, paga el costo de ramificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9e8a52af2265d491577ac667e610164d2bae82ec" translate="yes" xml:space="preserve">
          <source>With loop interchange, we can safely change this loop to:</source>
          <target state="translated">Con el intercambio de bucles,podemos cambiar con seguridad este bucle a:</target>
        </trans-unit>
        <trans-unit id="b07d7d0e763b2a76e028689779bd9793c81728e8" translate="yes" xml:space="preserve">
          <source>With the sorted data, the code runs in 1.93 seconds.</source>
          <target state="translated">Con los datos clasificados,el c√≥digo se ejecuta en 1,93 segundos.</target>
        </trans-unit>
        <trans-unit id="cdf4ffa875649aacf9a2112d2448609655f91aec" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;std::sort(data, data + arraySize);&lt;/code&gt;, the code runs in 11.54 seconds.</source>
          <target state="translated">Sin &lt;code&gt;std::sort(data, data + arraySize);&lt;/code&gt; , el c&amp;oacute;digo se ejecuta en 11.54 segundos.</target>
        </trans-unit>
        <trans-unit id="f595b01765d8ae905ea5e9dd7e62d7a02b4fbe22" translate="yes" xml:space="preserve">
          <source>Without branch prediction, the following would occur:</source>
          <target state="translated">Sin la predicci√≥n de la rama,ocurrir√≠a lo siguiente:</target>
        </trans-unit>
        <trans-unit id="b4764b924495da3570f6397640729704193386e0" translate="yes" xml:space="preserve">
          <source>Without branch prediction, the processor would have to wait until the
  conditional jump instruction has passed the execute stage before the
  next instruction can enter the fetch stage in the pipeline.</source>
          <target state="translated">Sin la predicci√≥n de bifurcaciones,el procesador tendr√≠a que esperar hasta que la instrucci√≥n de salto condicional haya pasado la etapa de ejecuci√≥n antes de que la siguiente instrucci√≥n pueda entrar en la etapa de recuperaci√≥n.</target>
        </trans-unit>
        <trans-unit id="8fa9477c95d3ffecec4695db62b573324832754a" translate="yes" xml:space="preserve">
          <source>Without the Branch Predictor.</source>
          <target state="translated">Sin el Predictor de Rama.</target>
        </trans-unit>
        <trans-unit id="0dee180d4b195226d6d709eb16ec0e42b8a820e7" translate="yes" xml:space="preserve">
          <source>You are a processor and you see a branch. You have no idea which way it will go. What do you do? You halt execution and wait until the previous instructions are complete. Then you continue down the correct path.</source>
          <target state="translated">Eres un procesador y ves una rama.No tienes idea de qu√© camino tomar√°.¬øQu√© es lo que haces? Detienes la ejecuci√≥n y esperas hasta que las instrucciones anteriores se completen.Luego contin√∫as por el camino correcto.</target>
        </trans-unit>
        <trans-unit id="3747acc12d9a8b4eeed31b6769fc516a8c97c9dd" translate="yes" xml:space="preserve">
          <source>You are the operator of a junction and you hear a train coming. You have no idea which way it is supposed to go. You stop the train to ask the driver which direction they want. And then you set the switch appropriately.</source>
          <target state="translated">Eres el operador de un cruce y oyes un tren que viene.No tienes ni idea de hacia d√≥nde se supone que va.Detienes el tren para preguntarle al conductor en qu√© direcci√≥n quiere ir.Y entonces pones el interruptor apropiadamente.</target>
        </trans-unit>
        <trans-unit id="a55200fca28b7f0ac1706d86d79e8114433a8b42" translate="yes" xml:space="preserve">
          <source>You can also see from this lovely &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor#/media/File:Branch_prediction_2bit_saturating_counter-dia.svg&quot;&gt;diagram&lt;/a&gt; why the branch predictor gets confused.</source>
          <target state="translated">Tambi&amp;eacute;n puede ver en este hermoso &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor#/media/File:Branch_prediction_2bit_saturating_counter-dia.svg&quot;&gt;diagrama&lt;/a&gt; por qu&amp;eacute; el predictor de rama se confunde.</target>
        </trans-unit>
        <trans-unit id="33b05101ba2f17cb142e08e195f5e37dbb2cf22d" translate="yes" xml:space="preserve">
          <source>You can have a stop condition instead of just checking the value, this way you only loop over the relevant data, and ignore the rest.</source>
          <target state="translated">Puedes tener una condici√≥n de parada en lugar de s√≥lo comprobar el valor,de esta manera s√≥lo haces un bucle sobre los datos relevantes,e ignoras el resto.</target>
        </trans-unit>
        <trans-unit id="e7cdaed049a36de91bc0b6220dbae638a556dd97" translate="yes" xml:space="preserve">
          <source>You might wonder why this works well in managed languages. After all, managed languages check the boundaries of the arrays with a branch to ensure you don't mess up...</source>
          <target state="translated">Se preguntar√°n por qu√© esto funciona bien en los idiomas administrados.Despu√©s de todo,los idiomas administrados comprueban los l√≠mites de las matrices con una rama...</target>
        </trans-unit>
        <trans-unit id="f6967173a58337d24e84af6ae18adb3fbbae9e11" translate="yes" xml:space="preserve">
          <source>can be optimized to:</source>
          <target state="translated">puede ser optimizado:</target>
        </trans-unit>
        <trans-unit id="576ab25730c6c8fde51cea0123c6a7dd40910123" translate="yes" xml:space="preserve">
          <source>is optimal in most cases (unless you expect the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; expression to generate many branch mispredictions).</source>
          <target state="translated">es &amp;oacute;ptimo en la mayor&amp;iacute;a de los casos (a menos que espere que la expresi&amp;oacute;n &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; genere muchas predicciones err&amp;oacute;neas de rama).</target>
        </trans-unit>
        <trans-unit id="a45d05b730bbc58dc46e14dafb3c0d1d4583c878" translate="yes" xml:space="preserve">
          <source>it's a nice solution maybe it will work</source>
          <target state="translated">es una buena soluci√≥n,tal vez funcione.</target>
        </trans-unit>
        <trans-unit id="c3bfc02b43a0aa6f110706cfedc26e042e2f304a" translate="yes" xml:space="preserve">
          <source>it's a small table and is likely to be cached in the processor, and</source>
          <target state="translated">es una mesa peque√±a y es probable que se almacene en el procesador,y</target>
        </trans-unit>
        <trans-unit id="651a852c52cc01c89e5ea1bd7793b4460d1de61f" translate="yes" xml:space="preserve">
          <source>or similarly:</source>
          <target state="translated">o de forma similar:</target>
        </trans-unit>
        <trans-unit id="495520e358c6efe36183f5f5cfdfb1a5f7540a8b" translate="yes" xml:space="preserve">
          <source>or, slightly more obfuscated</source>
          <target state="translated">o,ligeramente m√°s ofuscado</target>
        </trans-unit>
        <trans-unit id="f11d2b737879c47db5e53479b4f6bb83db8e1df9" translate="yes" xml:space="preserve">
          <source>so the predictor will change sides as the &lt;code&gt;std::rand()&lt;/code&gt; blow.</source>
          <target state="translated">entonces el predictor cambiar&amp;aacute; de lado a medida que sople &lt;code&gt;std::rand()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0234c36fd5c76bfa6dcd2e321618d03cb21418f9" translate="yes" xml:space="preserve">
          <source>this library would do something like:</source>
          <target state="translated">esta biblioteca har√≠a algo como:</target>
        </trans-unit>
        <trans-unit id="46ebea860b14c6c60e10f66281ac11838db11fdf" translate="yes" xml:space="preserve">
          <source>we can find that the meaning of this particular &lt;code&gt;if... else...&lt;/code&gt; branch is to add something when a condition is satisfied. This type of branch can be easily transformed into a &lt;strong&gt;conditional move&lt;/strong&gt; statement, which would be compiled into a conditional move instruction: &lt;code&gt;cmovl&lt;/code&gt;, in an &lt;code&gt;x86&lt;/code&gt; system. The branch and thus the potential branch prediction penalty is removed.</source>
          <target state="translated">podemos encontrar que el significado de este particular &lt;code&gt;if... else...&lt;/code&gt; rama es agregar algo cuando se cumple una condici&amp;oacute;n. Este tipo de rama se puede transformar f&amp;aacute;cilmente en una instrucci&amp;oacute;n de &lt;strong&gt;movimiento condicional&lt;/strong&gt; , que se compilar&amp;iacute;a en una instrucci&amp;oacute;n de movimiento condicional: &lt;code&gt;cmovl&lt;/code&gt; , en un sistema &lt;code&gt;x86&lt;/code&gt; . Se elimina la rama y, por lo tanto, la posible penalizaci&amp;oacute;n de predicci&amp;oacute;n de rama.</target>
        </trans-unit>
        <trans-unit id="52e0612303b39c0691e807b9c7a297fa35003367" translate="yes" xml:space="preserve">
          <source>with:</source>
          <target state="translated">with:</target>
        </trans-unit>
        <trans-unit id="4e59d494e29779b82beb957429950a6c38d3846b" translate="yes" xml:space="preserve">
          <source>you are running things in a quite tight loop and/or the processor can preload the data.</source>
          <target state="translated">...est√°s ejecutando las cosas en un bucle bastante estrecho y o el procesador puede precargar los datos.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
