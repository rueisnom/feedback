<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/11227809">
    <body>
      <group id="11227809">
        <trans-unit id="b53667fac1b1818f469635cd98c1992443873e79" translate="yes" xml:space="preserve">
          <source>(Or somewhat fast: for the already-sorted case, &lt;code&gt;cmov&lt;/code&gt; can be slower especially if GCC puts it on the critical path instead of just &lt;code&gt;add&lt;/code&gt;, especially on Intel before Broadwell where &lt;code&gt;cmov&lt;/code&gt; has 2 cycle latency: &lt;a href=&quot;https://stackoverflow.com/questions/28875325/gcc-optimization-flag-o3-makes-code-slower-than-o2&quot;&gt;gcc optimization flag -O3 makes code slower than -O2&lt;/a&gt;)</source>
          <target state="translated">（或者有点快：对于已经排序的情况， &lt;code&gt;cmov&lt;/code&gt; 可能会变慢，特别是如果GCC将其放在关键路径上而不是仅仅 &lt;code&gt;add&lt;/code&gt; ，尤其是在 &lt;code&gt;cmov&lt;/code&gt; 之前的Intel上， cmov有2个周期延迟： &lt;a href=&quot;https://stackoverflow.com/questions/28875325/gcc-optimization-flag-o3-makes-code-slower-than-o2&quot;&gt;gcc优化标志-O3使代码变慢比-O2&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="d1ea744eaff022b9ec4d3d58be32b719619a16de" translate="yes" xml:space="preserve">
          <source>// Declare and then fill in the lookup table</source>
          <target state="translated">/声明,然后填入查找表。</target>
        </trans-unit>
        <trans-unit id="439750f5cd724a86cdb0b90f611fcdf4d601b584" translate="yes" xml:space="preserve">
          <source>// Test</source>
          <target state="translated">/测试</target>
        </trans-unit>
        <trans-unit id="22e070d61d4ac5f3e0981ca4d20241ae99b358d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler&quot;&gt;Intel C++ Compiler&lt;/a&gt; (ICC) 11 does something miraculous. It &lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_interchange&quot;&gt;interchanges the two loops&lt;/a&gt;, thereby hoisting the unpredictable branch to the outer loop. So not only is it immune to the mispredictions, it is also twice as fast as whatever VC++ and GCC can generate! In other words, ICC took advantage of the test-loop to defeat the benchmark...</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler&quot;&gt;英特尔C ++编译器&lt;/a&gt; （ICC）11发挥了神奇的作用。 它&lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_interchange&quot;&gt;互换两个循环&lt;/a&gt; ，从而将不可预测的分支提升到外部循环。 因此，它不仅可以避免错误预测，而且还比VC ++和GCC生成的速度快两倍！ 换句话说，ICC利用测试循环来击败基准测试&amp;hellip;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="637937a9b16b61115d58b45cd478f01d51765e8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADD R1, R2, R3&lt;/code&gt; performs &lt;code&gt;R1 = R2 + R3&lt;/code&gt; without updating any status bits.</source>
          <target state="translated">&lt;code&gt;ADD R1, R2, R3&lt;/code&gt; 执行 &lt;code&gt;R1 = R2 + R3&lt;/code&gt; 而不更新任何状态位。</target>
        </trans-unit>
        <trans-unit id="87d9034703b27f8b1421db3174bb0a89354e4fdd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDGE R1, R2, R3&lt;/code&gt; performs the same operation only if a previous instruction that affected the status bits resulted in a Greater than or Equal condition.</source>
          <target state="translated">仅当影响状态位的前一条指令导致大于或等于条件时 &lt;code&gt;ADDGE R1, R2, R3&lt;/code&gt; 执行相同的操作。</target>
        </trans-unit>
        <trans-unit id="23f6fd5b0c8ae0b7004305abd5527096f2e1cd0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDS R1, R2, R3&lt;/code&gt; performs the addition and then updates the &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; flags in the Processor Status Register based on whether the result was Negative, Zero, Carried (for unsigned addition), or oVerflowed (for signed addition).</source>
          <target state="translated">&lt;code&gt;ADDS R1, R2, R3&lt;/code&gt; 执行加法运算，然后根据结果是负数，零，进位（无符号加法）还是oVerflowed（有符号加法）更新处理器状态寄存器中的 &lt;code&gt;N&lt;/code&gt; ， &lt;code&gt;Z&lt;/code&gt; ， &lt;code&gt;C&lt;/code&gt; 和 &lt;code&gt;V&lt;/code&gt; 标志。 。</target>
        </trans-unit>
        <trans-unit id="9dc9f762599510b8def52bb6b16ab86d5b605418" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDSGE R1, R2, R3&lt;/code&gt; performs the addition only if the &lt;code&gt;GE&lt;/code&gt; test is true, and then subsequently updates the status bits based on the result of the addition.</source>
          <target state="translated">仅当 &lt;code&gt;GE&lt;/code&gt; 测试为true时， &lt;code&gt;ADDSGE R1, R2, R3&lt;/code&gt; 执行加法运算，然后根据加法结果更新状态位。</target>
        </trans-unit>
        <trans-unit id="6c4200c52c77a8809e0c28b82431a4fcd7fb0319" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CMP&lt;/code&gt; opcodes always update the status bits in the Processor Status Register (PSR), because that is their purpose, but most other instructions do not touch the PSR unless you add an optional &lt;code&gt;S&lt;/code&gt; suffix to the instruction, specifying that the PSR should be updated based on the result of the instruction. &lt;strong&gt;Just like the 4-bit condition suffix, being able to execute instructions without affecting the PSR is a mechanism that reduces the need for branches on ARM, and also facilitates out of order dispatch at the hardware level&lt;/strong&gt;, because after performing some operation X that updates the status bits, subsequently (or in parallel) you can do a bunch of other work that explicitly should not affect the status bits, then you can test the state of the status bits set earlier by X.</source>
          <target state="translated">&lt;code&gt;CMP&lt;/code&gt; 操作码始终会更新处理器状态寄存器（PSR）中的状态位，因为这是它们的用途，但是大多数其他指令都不会触及PSR，除非您在指令中添加了可选的 &lt;code&gt;S&lt;/code&gt; 后缀，指定应基于PSR更新PSR。根据指令的结果。 &lt;strong&gt;就像4位条件后缀一样，能够在不影响PSR的情况下执行指令是一种机制，它减少了ARM上的分支需求，并且还促进了硬件级别的乱序调度&lt;/strong&gt; ，因为在执行了一些更新后的操作X之后状态位，随后（或并行）您可以做其他明显不影响状态位的其他工作，然后可以测试X之前设置的状态位的状态。</target>
        </trans-unit>
        <trans-unit id="391873c374a8ded8013438f8a2663a8948bf98aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; cannot be replaced with &lt;code&gt;a &amp;amp; b&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is an expression that should not be evaluated if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will not evaluate &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; will). Likewise, &lt;code&gt;a || b&lt;/code&gt; can not be replaced with &lt;code&gt;a | b&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is an expression that should not be evaluated if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">如果 &lt;code&gt;b&lt;/code&gt; 是在 &lt;code&gt;a&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt; 不应该求值的表达式（ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 将不求 &lt;code&gt;b&lt;/code&gt; ， &lt;code&gt;&amp;amp;&lt;/code&gt; will），则a &lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; 不能用 &lt;code&gt;a &amp;amp; b&lt;/code&gt; 替换。 同样， &lt;code&gt;a || b&lt;/code&gt; b不能替换 &lt;code&gt;a | b&lt;/code&gt; 如果 &lt;code&gt;b&lt;/code&gt; 是一个表达式，则如果 &lt;code&gt;a&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ，则不应该对其求值 。</target>
        </trans-unit>
        <trans-unit id="3da7ae3851d0cb07b784c1504abb04501c97c690" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; is used instead of &lt;code&gt;bool&lt;/code&gt; in order to make it possible to use the bitwise operators (&lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) instead of the Boolean operators (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;). The bitwise operators are single instructions that take only one clock cycle. The OR operator (&lt;code&gt;|&lt;/code&gt;) works even if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have other values than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. The AND operator (&lt;code&gt;&amp;amp;&lt;/code&gt;) and the EXCLUSIVE OR operator (&lt;code&gt;^&lt;/code&gt;) may give inconsistent results if the operands have other values than &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;char&lt;/code&gt; 代替 &lt;code&gt;bool&lt;/code&gt; 可以使用按位运算符（ &lt;code&gt;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;|&lt;/code&gt; ）代替布尔运算符（ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 和 &lt;code&gt;||&lt;/code&gt; ）。 按位运算符是仅占用一个时钟周期的单个指令。 即使 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 的值不是 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; ，OR运算符（ &lt;code&gt;|&lt;/code&gt; ）也可以工作。 如果操作数的值不是 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; ，则AND运算符（ &lt;code&gt;&amp;amp;&lt;/code&gt; ）和EXCLUSIVE OR运算符（ &lt;code&gt;^&lt;/code&gt; ）的结果可能不一致。</target>
        </trans-unit>
        <trans-unit id="2116c486e51bc36c5ea4f4ea724a4decd73ddf80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max1&lt;/code&gt; uses the conditional branch &lt;code&gt;if... else ...&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;if... else ...&lt;/code&gt; &lt;code&gt;max1&lt;/code&gt; 将使用条件分支：</target>
        </trans-unit>
        <trans-unit id="5c4a2ff8aabdb7de009ae921d3d149a4fd4a3981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max2&lt;/code&gt; uses much less code due to the usage of instruction &lt;code&gt;cmovge&lt;/code&gt;. But the real gain is that &lt;code&gt;max2&lt;/code&gt; does not involve branch jumps, &lt;code&gt;jmp&lt;/code&gt;, which would have a significant performance penalty if the predicted result is not right.</source>
          <target state="translated">由于使用了指令 &lt;code&gt;cmovge&lt;/code&gt; ,因此 &lt;code&gt;max2&lt;/code&gt; 使用更少的代码。 但是真正的好处是 &lt;code&gt;max2&lt;/code&gt; 不涉及分支跳转 &lt;code&gt;jmp&lt;/code&gt; ，如果预测结果不正确，则会对性能造成重大影响。</target>
        </trans-unit>
        <trans-unit id="3a816aa9d54ebe21437fa8cb172a780bbab33269" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max2&lt;/code&gt; uses the ternary operator &lt;code&gt;... ? ... : ...&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;max2&lt;/code&gt; 使用三元运算符 &lt;code&gt;... ? ... : ...&lt;/code&gt; ...：... ：</target>
        </trans-unit>
        <trans-unit id="562cd5fce1e7b6dcbe296f9206498ac8e7ed271a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt; can not be used for NOT. Instead, you can make a Boolean NOT on a variable which is known to be &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; by XOR'ing it with &lt;code&gt;1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; 不能用于NOT。 取而代之的是，您可以通过将变量与 &lt;code&gt;1&lt;/code&gt; 进行XOR运算，对已知为 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; 的变量进行布尔NOT：</target>
        </trans-unit>
        <trans-unit id="86968cc91f6395ac3372778b6f3bd6927c8f9854" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;A Demonstration of Self-Profiling&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;自我分析演示&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62a5257803ca2425233ddd03c4d7d207b6867e4a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://courses.cs.washington.edu/courses/csep548/06au/lectures/branchPred.pdf&quot;&gt;Branch Prediction Review&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://courses.cs.washington.edu/courses/csep548/06au/lectures/branchPred.pdf&quot;&gt;分行预测审查&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e83995c1786dac19461a4d31bc4d8b9cde96f71d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Branch predictor&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;分支预测器&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17ca7e4d199635bbed9dd553888d82060ea8e587" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://stackoverflow.blog/2019/10/11/c-creator-bjarne-stroustrup-answers-our-top-five-c-questions/&quot;&gt;Bjarne Stroustrup's Answer&lt;/a&gt; to this question:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.blog/2019/10/11/c-creator-bjarne-stroustrup-answers-our-top-five-c-questions/&quot;&gt;Bjarne Stroustrup&lt;/a&gt;对这个问题的回答 ：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6999c55f1112ac2522394d373dcc92bf8ba35d17" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://web.njit.edu/~rlopes/Mod5.3.pdf&quot;&gt;Branch Prediction&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://web.njit.edu/~rlopes/Mod5.3.pdf&quot;&gt;分支预测&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2567a75f2917b4cf19219547a29e45cd68bfc50" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Modern processors are complicated and have long pipelines. So they take forever to &quot;warm up&quot; and &quot;slow down&quot;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;现代处理器很复杂，而且流程很长。&lt;/em&gt; &lt;em&gt;因此，他们需要永远&amp;ldquo;热身&amp;rdquo;和&amp;ldquo;放慢脚步&amp;rdquo;。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c4e8b34981c89b9e7eadedce54ab4bf99abb400" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Trains are heavy and have a lot of inertia. So they take forever to start up and slow down.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;火车很重，惯性很大。&lt;/em&gt; &lt;em&gt;因此，它们花了永远的时间来启动和减速。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dfd2a9e0eebface4570f5726ff229d9f7239571" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Static&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.静态的&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec921c20fc92beab445f0b65b62aac1dc30fda89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Dynamic&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.动态&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7070b983b9e682ffd47dc61eb8173e377437895" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;4-stage pipeline in general for 2 instructions.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;4级流水线一般用于2条指令。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7c0dc2f57cc914145b6b0624cff97eb77959909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;But this is actually part of a bigger picture:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;但这实际上是更大范围的一部分：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a57d022fefdf1a6dc6fb7aff0b41a4c5a3d4191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;In case of a correct guess, the pipeline looks something like this:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;在正确猜测的情况下，管道如下所示：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="059ec29570653df3139916923c59df324c15a8f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;In other words, you try to identify a pattern and follow it.&lt;/em&gt;&lt;/strong&gt; This is more or less how branch predictors work.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;换句话说，您尝试识别一个模式并遵循它。&lt;/em&gt;&lt;/strong&gt; 这或多或少是分支预测变量的工作方式。</target>
        </trans-unit>
        <trans-unit id="e2c23a7d4a1b5f910c13dc8dd8d34c2b4feb4d6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When if condition returns false:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;如果条件返回false：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4757bf44b2540d4c3544fbd8ed736018934b59c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;when if condition returns true:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;如果条件返回true：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a145133a463629536767d61372777b3b15514477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Background and why&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;背景以及原因&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="03ac7fc31e2558f71e7c0316cacb5b6078717e4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Backward conditional branches&lt;/strong&gt; - the PC is changed to point backward in the instruction stream. The branch is based on some condition, such as branching backwards to the beginning of a program loop when a test at the end of the loop states the loop should be executed again.</source>
          <target state="translated">&lt;strong&gt;向后条件分支&lt;/strong&gt; -将PC更改为在指令流中指向向后。 该分支基于某种条件，例如，当循环末尾的测试表明该循环应再次执行时，则向后跳转到程序循环的开头。</target>
        </trans-unit>
        <trans-unit id="88725d83d10b621a1197929903db27ce4176d85e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Benchmarks: Core i7 920 @ 3.5 GHz&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;基准：Core i7 920 @ 3.5 GHz&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29e42a036c1d0c70cc19beaa407c40f6950cdef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch prediction.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;分支预测。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c55e466ed2fc88a1e76e953db7f49f1fd3730ab3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch prediction&lt;/strong&gt; makes the logic run slower, because of the switching which happens in your code! It's like you are going a straight street or a street with a lot of turnings, for sure the straight one is going to be done quicker!...</source>
          <target state="translated">由于代码中发生的切换， &lt;strong&gt;分支预测&lt;/strong&gt;使逻辑运行速度变慢！ 就像您要走在一条笔直的街道或拐弯处很多的街道上一样，确保笔直的街道可以更快地完成！...</target>
        </trans-unit>
        <trans-unit id="d218041da74b681266dd3bc64ecbec4c36a29624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch-prediction gain!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;分支预测收益！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e98dec0bd0a7e8e2059d13e9a8c88d55b96ae930" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Consider an if-statement:&lt;/strong&gt; At the processor level, it is a branch instruction:</source>
          <target state="translated">&lt;strong&gt;考虑一个if语句：&lt;/strong&gt;在处理器级别，它是一条分支指令：</target>
        </trans-unit>
        <trans-unit id="c1e69093a905a8b010540753c555aae1f8e36d3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructing a table&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;构造表&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="130a0bfbd8fc444b6379d249ad5d24a0e69aaf6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Forward conditional branches&lt;/strong&gt; - based on a run-time condition, the PC (program counter) is changed to point to an address forward in the instruction stream.</source>
          <target state="translated">&lt;strong&gt;转发条件分支&lt;/strong&gt; -根据运行时条件，将PC（程序计数器）更改为指向指令流中的转发地址。</target>
        </trans-unit>
        <trans-unit id="5bb5d1ddff4f6d3eb81208ce3786e0186300f35b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess right every time&lt;/strong&gt;, the execution will never have to stop.</source>
          <target state="translated">&lt;strong&gt;如果您每次都猜对了&lt;/strong&gt; ，执行将永远不会停止。</target>
        </trans-unit>
        <trans-unit id="5c443327b64ce0afa013e0a8c686cce4fcb25e64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess right every time&lt;/strong&gt;, the train will never have to stop.</source>
          <target state="translated">&lt;strong&gt;如果您每次都猜对了&lt;/strong&gt; ，火车将永远不会停止。</target>
        </trans-unit>
        <trans-unit id="43854ebdaaaf1f8914276249ab523b2bf804d1c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess wrong too often&lt;/strong&gt;, the train will spend a lot of time stopping, backing up, and restarting.</source>
          <target state="translated">&lt;strong&gt;如果您经常猜错&lt;/strong&gt; ，火车将花费大量时间停止，备份和重新启动。</target>
        </trans-unit>
        <trans-unit id="ff48f0bff759820faca0dc4ce0d054010aa2a369" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess wrong too often&lt;/strong&gt;, you spend a lot of time stalling, rolling back, and restarting.</source>
          <target state="translated">&lt;strong&gt;如果您经常猜错&lt;/strong&gt; ，那么您将花费大量时间来拖延，回滚和重新启动。</target>
        </trans-unit>
        <trans-unit id="29e3b2963af7a82c74a39140e23e664c8aa6638f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Increasing the Instruction Fetch Rate via Multiple Branch Prediction and a Branch Address Cache&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;通过多个分支预测和分支地址缓存提高指令提取速率&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80ce9cf0a86a6ef1b733fbee4d9e322ccb10c80d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's do some bench marking to understand it better&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;让我们做一些基准测试以更好地了解它&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6ddf289b433253c5925b3f9813d36a0537be7c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Managed languages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;托管语言&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a1b89da59705a9d2d5291d59ff4a51ef12d08c3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Quick visualization:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;快速可视化：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5270a251ef82abdcf7f4c1527f163a3cea8e0e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what can be done?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;那该怎么办呢？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ab826d0d5faf44d4a7a8a7aad1ef803be005faf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what is branch prediction?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;那么什么是分支预测？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d285155e760355be2f39c1257c5821d5da261a1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorted:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sorted:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd9c2da2ee8d01be5229516e95ec725d64e3f165" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static/dynamic Branch Prediction&lt;/strong&gt;: Static branch prediction is used by the microprocessor the first time a conditional branch is encountered, and dynamic branch prediction is used for succeeding executions of the conditional branch code.</source>
          <target state="translated">&lt;strong&gt;静态/动态分支预测&lt;/strong&gt; ：第一次遇到条件分支时，微处理器会使用静态分支预测，而动态分支预测将用于条件分支代码的后续执行。</target>
        </trans-unit>
        <trans-unit id="078fac8f79d7e758f85f3007634fdc8cb9777688" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result of this case&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;这种情况的结果&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6315a32d6eff633cf664b3192d3c2b8360df6c43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unconditional branches&lt;/strong&gt; - this includes jumps, procedure calls and returns that have no specific condition. For example, an unconditional jump instruction might be coded in assembly language as simply &quot;jmp&quot;, and the instruction stream must immediately be directed to the target location pointed to by the jump instruction, whereas a conditional jump that might be coded as &quot;jmpne&quot; would redirect the instruction stream only if the result of a comparison of two values in a previous &quot;compare&quot; instructions shows the values to not be equal. (The segmented addressing scheme used by the x86 architecture adds extra complexity, since jumps can be either &quot;near&quot; (within a segment) or &quot;far&quot; (outside the segment). Each type has different effects on branch prediction algorithms.)</source>
          <target state="translated">&lt;strong&gt;无条件分支&lt;/strong&gt; -包括没有特定条件的跳转，过程调用和返回。 例如，无条件跳转指令可能用汇编语言编码为简单的&amp;ldquo; jmp&amp;rdquo;，并且指令流必须立即定向到跳转指令指向的目标位置，而条件跳转可能被编码为&amp;ldquo; jmpne&amp;rdquo;仅当前一个&amp;ldquo;比较&amp;rdquo;指令中两个值的比较结果显示这些值不相等时，才会重定向指令流。 （x86体系结构使用的分段寻址方案增加了额外的复杂性，因为跳转可以是&amp;ldquo;近&amp;rdquo;（在段内）或&amp;ldquo;远&amp;rdquo;（在段外）。每种类型对分支预测算法的影响都不同。）</target>
        </trans-unit>
        <trans-unit id="d1721438d4fa087c689f86212f2138f7505dcb3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unsorted:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Unsorted:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8dfd8a5f8f4a830eea9365b9b460097fbbe4381" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With the Branch:&lt;/strong&gt; There is a huge difference between the sorted and unsorted data.</source>
          <target state="translated">&lt;strong&gt;使用分支：&lt;/strong&gt;排序数据和未排序数据之间存在巨大差异。</target>
        </trans-unit>
        <trans-unit id="03b5fb42d9ac84ced19e05a65a21ee596d5d6f7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With the Hack:&lt;/strong&gt; There is no difference between sorted and unsorted data.</source>
          <target state="translated">&lt;strong&gt;使用Hack：&lt;/strong&gt;排序和未排序的数据之间没有区别。</target>
        </trans-unit>
        <trans-unit id="b16311ddb39aa62e4ad47e876353ac768d1b5d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You are a victim of &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;branch prediction&lt;/a&gt; fail.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;您是&lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;分支预测&lt;/a&gt;失败的受害者。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c786fafb5f8da23c331a0d7afceac4aae6e0c19e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;x64&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;x64&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b2f35b1567a33263e752a9bf7e298fd26bd105c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;x86&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;x86&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56bb00227cc3f2c966ad0c07a94c169bef8507ca" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Note that this hack is not strictly equivalent to the original if-statement. But in this case, it's valid for all the input values of &lt;code&gt;data[]&lt;/code&gt;.)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;（请注意，这种破解并不严格等同于原始的if语句。但是在这种情况下，它对 &lt;code&gt;data[]&lt;/code&gt; 所有输入值均有效。）&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="daf1c2db057b9141218780bbe961c3fb9781bf1a" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;a href=&quot;//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG&quot;&gt;Image&lt;/a&gt; by Mecanismo, via Wikimedia Commons. Used under the &lt;a href=&quot;//creativecommons.org/licenses/by-sa/3.0/deed.en&quot;&gt;CC-By-SA 3.0&lt;/a&gt; license.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;Mecanismo的&lt;a href=&quot;//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG&quot;&gt;图片&lt;/a&gt; ，通过Wikimedia Commons。&lt;/sub&gt; &lt;sub&gt;在&lt;a href=&quot;//creativecommons.org/licenses/by-sa/3.0/deed.en&quot;&gt;CC-By-SA 3.0&lt;/a&gt;许可下使用。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="85f4f86517c13577daac8db1438bfa704a81d1f5" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;strong&gt;bad&lt;/strong&gt;&amp;rdquo; true-false pattern can make an &lt;code&gt;if&lt;/code&gt;-statement up to six times slower than a &amp;ldquo;&lt;strong&gt;good&lt;/strong&gt;&amp;rdquo; pattern! Of course, which pattern is good and which is bad depends on the exact instructions generated by the compiler and on the specific processor.</source>
          <target state="translated">一个&amp;ldquo; &lt;strong&gt;坏&lt;/strong&gt; &amp;rdquo;的真假模式会使 &lt;code&gt;if&lt;/code&gt; 语句的速度比&amp;ldquo; &lt;strong&gt;好&lt;/strong&gt; &amp;rdquo;模式慢六倍！ 当然，哪种模式好坏，取决于编译器和特定处理器生成的确切指令。</target>
        </trans-unit>
        <trans-unit id="fa9002e4deffeb589b075bfcdf8a5cf9a18e318c" translate="yes" xml:space="preserve">
          <source>A branch instruction can cause a computer to begin executing a different instruction sequence and thus deviate from its default behavior of executing instructions in order (i.e. if the expression is false, the program skips the code of the &lt;code&gt;if&lt;/code&gt; block) depending on some condition, which is the expression evaluation in our case.</source>
          <target state="translated">分支指令会导致计算机开始执行不同的指令序列，从而偏离计算机按顺序执行指令的默认行为（即，如果表达式为假，则程序将跳过 &lt;code&gt;if&lt;/code&gt; 块的代码），具体取决于某些条件。是本例中的表达评估。</target>
        </trans-unit>
        <trans-unit id="dea845d0a945ad214f5fefb6c4b0e6c1e6051bc4" translate="yes" xml:space="preserve">
          <source>A branch predictor is one of the ancient performance improving techniques which still finds relevance into modern architectures. While the simple prediction techniques provide fast lookup and power efficiency they suffer from a high misprediction rate.</source>
          <target state="translated">分支预测器是古老的性能改进技术之一,至今仍可应用于现代架构中。虽然简单的预测技术提供了快速查找和功率效率,但它们的错误预测率很高。</target>
        </trans-unit>
        <trans-unit id="37fb85f91b43ff03464a3ace5cd03f2e7b1d689f" translate="yes" xml:space="preserve">
          <source>A common way to eliminate branch prediction that I've found to work particularly good in managed languages is a table lookup instead of using a branch (although I haven't tested it in this case).</source>
          <target state="translated">在托管语言中,我发现一个常用的消除分支预测的方法是用表查找而不是使用分支(虽然在这种情况下我还没有测试过)。</target>
        </trans-unit>
        <trans-unit id="2d5382f7f97d599d6c1c60ae36b7533c1e391142" translate="yes" xml:space="preserve">
          <source>A general rule of thumb is to avoid data-dependent branching in critical loops (such as in this example).</source>
          <target state="translated">一般的经验法则是在关键循环中避免数据依赖性的分支(如本例)。</target>
        </trans-unit>
        <trans-unit id="2a0c61937b135599b6110466d59da1b10f3e69cc" translate="yes" xml:space="preserve">
          <source>A yet faster approach, that gives an &lt;strong&gt;approximate&lt;/strong&gt; solution for both sorted or unsorted is: &lt;code&gt;sum= 3137536;&lt;/code&gt; (assuming a truly uniform distribution, 16384 samples with expected value 191.5) &lt;strong&gt;:-)&lt;/strong&gt;</source>
          <target state="translated">还有一种更快的方法，可以为已排序或未排序的对象提供&lt;strong&gt;近似的&lt;/strong&gt;解决方案： &lt;code&gt;sum= 3137536;&lt;/code&gt; （假设分布真正均匀，有16384个样本，预期值为191.5） &lt;strong&gt;：-）&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f443462e3c594cabbf5f71234fac4ceb6009a988" translate="yes" xml:space="preserve">
          <source>All the elements are greater than 128</source>
          <target state="translated">所有元素均大于128</target>
        </trans-unit>
        <trans-unit id="60b7feee5533f80829de14d53e01cb5cd2f55c48" translate="yes" xml:space="preserve">
          <source>All the elements are less than 128</source>
          <target state="translated">所有元素均小于128</target>
        </trans-unit>
        <trans-unit id="0529f5c0c9474ccd9e39a30f16e35b00bb471784" translate="yes" xml:space="preserve">
          <source>Also I want to cite &lt;a href=&quot;https://stackoverflow.com/users/16940/simon-weaver&quot;&gt;@Simon_Weaver&lt;/a&gt; from the comments:</source>
          <target state="translated">我也想从评论中引用&lt;a href=&quot;https://stackoverflow.com/users/16940/simon-weaver&quot;&gt;@Simon_Weaver&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="fed9e7e89414aa4f62ee84308b32e6df6a42784c" translate="yes" xml:space="preserve">
          <source>Also at the end, it's good to know we have two kinds of branch predictions that each is going to affect your code differently:</source>
          <target state="translated">另外在最后,我们有两种分支预测,每一种都会对你的代码产生不同的影响,这一点很好。</target>
        </trans-unit>
        <trans-unit id="118e6e8352ef9219f30b284c2eec943d64cac174" translate="yes" xml:space="preserve">
          <source>Alternatively, on Linux you can use the performance counters subsystem to accomplish the same task, but with native performance using CPU counters.</source>
          <target state="translated">另外,在Linux上,你可以使用性能计数器子系统来完成同样的任务,但使用CPU计数器的原生性能。</target>
        </trans-unit>
        <trans-unit id="407d8227038ebf4c70f4b17f8cbd8db2e0cf6ac0" translate="yes" xml:space="preserve">
          <source>Although both the roads reach the same destination, the straight road is shorter, and the other is longer. If then you choose the other by mistake, there is no turning back, and so you will waste some extra time if you choose the longer road. This is similar to what happens in the computer, and I hope this helped you understand better.</source>
          <target state="translated">虽然两条路都到达同一个目的地,但直路较短,另一条路较长。如果这时你不小心选择了另一条路,那就没有办法回头,所以选择长一点的路,就会浪费一些额外的时间。这和电脑里的情况差不多,希望对你的理解有所帮助。</target>
        </trans-unit>
        <trans-unit id="72b615d954c685d03dbd988b02705d36339eea5d" translate="yes" xml:space="preserve">
          <source>An official answer would be from</source>
          <target state="translated">官方的答案是:</target>
        </trans-unit>
        <trans-unit id="e16854241a2d65fb883d369651da41390d02fcc0" translate="yes" xml:space="preserve">
          <source>Another reason is that when the vector is already sorted, we never need to move elements to their correct position. The effect of these little details is the factor of five or six that we saw.</source>
          <target state="translated">另一个原因是,当向量已经排序后,我们永远不需要将元素移动到正确的位置。这些小细节的效果就是我们看到的五六倍的系数。</target>
        </trans-unit>
        <trans-unit id="18b72662db383a9f75e385af80ee82d4f1ad5ed5" translate="yes" xml:space="preserve">
          <source>Any instruction is broken into a sequence of steps so that different steps can be executed concurrently in parallel. This technique is known as instruction pipeline and this is used to increase throughput in modern processors. To understand this better please see this &lt;a href=&quot;https://en.wikipedia.org/wiki/Pipeline_(computing)#Concept_and_motivation&quot;&gt;example on Wikipedia&lt;/a&gt;.</source>
          <target state="translated">任何指令都分为一系列步骤，以便可以并行并行执行不同的步骤。 该技术称为指令流水线，用于提高现代处理器的吞吐量。 为了更好地理解这一点，请参见&lt;a href=&quot;https://en.wikipedia.org/wiki/Pipeline_(computing)#Concept_and_motivation&quot;&gt;Wikipedia上的示例&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="bcb1019315b39b373530b7c1baab0d26a3114719" translate="yes" xml:space="preserve">
          <source>Articles in scientific publications: T.Y. Yeh, Y.N. Patt made a lot of these on branch predictions.</source>
          <target state="translated">在科学出版物上的文章。T.Y.Y.Y.Y.N.Patt在分支预测上做了很多这样的文章。</target>
        </trans-unit>
        <trans-unit id="0a92cf5f4b626666fbf175648e0a6f274113a6f6" translate="yes" xml:space="preserve">
          <source>As a result of waiting for the result of instruction A, the total CPU cycles spent in the above case (without branch prediction; for both true and false) is 7.</source>
          <target state="translated">由于等待指令A的结果,在上述情况下,等待指令A的结果,因此,在上述情况下,总的CPU周期消耗的CPU周期(不包括分支预测;对于真假都是如此)为7。</target>
        </trans-unit>
        <trans-unit id="91b190f8f20d90d506eb2a535168aaeb504cbac3" translate="yes" xml:space="preserve">
          <source>As data is distributed between 0 and 255 when the array is sorted, around the first half of the iterations will not enter the &lt;code&gt;if&lt;/code&gt;-statement (the &lt;code&gt;if&lt;/code&gt; statement is shared below).</source>
          <target state="translated">当对数组进行排序时，由于数据分布在0到255之间，因此在前半部分迭代中，将不会输入 &lt;code&gt;if&lt;/code&gt; -statement（下面共享 &lt;code&gt;if&lt;/code&gt; 语句）。</target>
        </trans-unit>
        <trans-unit id="cb7653dba96134a9f8b8386b70f0dd6cac24bb0a" translate="yes" xml:space="preserve">
          <source>As hinted from above, the culprit is this if-statement:</source>
          <target state="translated">如上文所暗示的,罪魁祸首就是这个if-statement。</target>
        </trans-unit>
        <trans-unit id="485df5143cbc2b24d62743d36ee8956b76546eb1" translate="yes" xml:space="preserve">
          <source>As what has already been mentioned by others, what behind the mystery is &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Branch Predictor&lt;/a&gt;.</source>
          <target state="translated">正如其他人已经提到的那样，神秘的背后是&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Branch Predictor&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="4b08e517362c42b5803f28e7adc40496f99cf8e9" translate="yes" xml:space="preserve">
          <source>As you can see, it seems we don't have a reason not to use Branch Predictor.</source>
          <target state="translated">可以看到,我们似乎没有理由不使用分支预测器。</target>
        </trans-unit>
        <trans-unit id="4f55d0a62def8f894343508ecf5fe4ae7cfbc922" translate="yes" xml:space="preserve">
          <source>At least the phenomenon is real with this compiler, standard library, and optimizer settings. Different implementations can and do give different answers. In fact, someone did do a more systematic study (a quick web search will find it) and most implementations show that effect.</source>
          <target state="translated">至少在这种编译器、标准库和优化器设置下,这种现象是真实存在的。不同的实现可以也确实给出了不同的答案。事实上,确实有人做过比较系统的研究(在网上快速搜索一下就能找到),大多数实现都显示出了这个效果。</target>
        </trans-unit>
        <trans-unit id="fd41bc2c6095914eb987318731cbb8136aa88df0" translate="yes" xml:space="preserve">
          <source>Based on the described scenario, I have written an animation demo to show how instructions are executed in a pipeline in different situations.</source>
          <target state="translated">根据描述的场景,我写了一个动画演示,展示了不同情况下指令在流水线中的执行情况。</target>
        </trans-unit>
        <trans-unit id="f227c3a03a7731e12cfd0e90cd5a61346155ae8b" translate="yes" xml:space="preserve">
          <source>Based on this, it looks MATLAB is almost &lt;em&gt;175 times&lt;/em&gt; slower than the C implementation without sorting and &lt;em&gt;350 times&lt;/em&gt; slower with sorting. In other words, the effect (of branch prediction) is &lt;em&gt;1.46x&lt;/em&gt; for MATLAB implementation and &lt;em&gt;2.7x&lt;/em&gt; for the C implementation.</source>
          <target state="translated">基于此，MATLAB看上去比不进行排序的C实现慢了&lt;em&gt;175倍，&lt;/em&gt;而进行排序则慢了&lt;em&gt;350倍&lt;/em&gt; 。 换句话说，对于MATLAB实现，效果（分支预测）为&lt;em&gt;1.46x&lt;/em&gt; ，对于C实现，效果为&lt;em&gt;2.7x&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="7f0b96f3c9bc5eedd14fbfce8ae4e5637fcd2f88" translate="yes" xml:space="preserve">
          <source>Besides the fact that the branch prediction may slow you down, a sorted array has another advantage:</source>
          <target state="translated">除了分支预测可能会拖慢你的速度之外,排序阵列还有另一个好处。</target>
        </trans-unit>
        <trans-unit id="cbfea8990261f42832136208062c8c674500cbb0" translate="yes" xml:space="preserve">
          <source>Books: J.L. Hennessy, D.A. Patterson: Computer architecture: a quantitative approach</source>
          <target state="translated">书籍。J.L.Hennessy,D.A.Patterson:计算机结构:定量方法</target>
        </trans-unit>
        <trans-unit id="829b3fb58a7b85f64a37f8e20d7ec7596c0db7f0" translate="yes" xml:space="preserve">
          <source>Boolean variables are overdetermined in the sense that all operators that have Boolean variables as input check if the inputs have any other value than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, but operators that have Booleans as output can produce no other value than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. This makes operations with Boolean variables as input less efficient than necessary.
Consider example:</source>
          <target state="translated">从所有将布尔变量作为输入的运算符检查输入是否具有除 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; 之外的任何其他值的意义上，布尔变量被过分确定，但是以布尔作为输出的运算符不能产生除 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;1&lt;/code&gt; 之外的其他值。 这使得使用布尔变量作为输入的运算的效率比必要的低。 考虑示例：</target>
        </trans-unit>
        <trans-unit id="0f586453c8b155549182d123a0dddc7e7cafdb04" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;likely()&lt;/code&gt; and &lt;code&gt;unlikely()&lt;/code&gt; are in fact macros that are defined by using something like the GCC's &lt;code&gt;__builtin_expect&lt;/code&gt; to help the compiler insert prediction code to favour the condition taking into account the information provided by the user. GCC supports other builtins that could change the behavior of the running program or emit low level instructions like clearing the cache, etc. See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html&quot;&gt;this documentation&lt;/a&gt; that goes through the available GCC's builtins.</source>
          <target state="translated">实际上，approximate &lt;code&gt;likely()&lt;/code&gt; 和 &lt;code&gt;unlikely()&lt;/code&gt; 都是通过使用类似GCC的 &lt;code&gt;__builtin_expect&lt;/code&gt; 的定义的宏，以帮助编译器插入预测代码以考虑到用户提供的信息来满足条件。 GCC支持其他可能会更改正在运行的程序的行为或发出底层指令（例如清除缓存等）的内置插件。请参阅&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html&quot;&gt;此文档&lt;/a&gt; ，其中提供了可用的GCC内置插件。</target>
        </trans-unit>
        <trans-unit id="e3be8498fb9bc40fab8d29adec6459c84941f461" translate="yes" xml:space="preserve">
          <source>Branch prediction is essentially an optimization (minimization) problem where the emphasis is on to achieve lowest possible miss rate, low power consumption, and low complexity with minimum resources.</source>
          <target state="translated">分支预测本质上是一个优化(最小化)问题,其重点在于以最小的资源实现尽可能低的失误率、低功耗和低复杂度。</target>
        </trans-unit>
        <trans-unit id="ce09fc1b6a54ba26385b7dcf3dc61b849d981bdb" translate="yes" xml:space="preserve">
          <source>Branch prediction: Guessing/predicting which road is straight and following it without checking</source>
          <target state="translated">支路预测。猜测预测哪条路是直的,不加检查地沿着这条路走下去</target>
        </trans-unit>
        <trans-unit id="bf6354b6953e28aa0b0401d2ab4cdf0bab9f9a80" translate="yes" xml:space="preserve">
          <source>Branch predictor will try to guess which way a branch (an if-then-else structure) will go before this is known for sure. It will not wait for the instruction A to reach the EX stage of the pipeline, but it will guess the decision and go to that instruction (B or C in case of our example).</source>
          <target state="translated">分支预测器将尝试猜测一个分支(一个if-then-else结构)在确定这一点之前会走哪条路。它不会等待指令A到达流水线的EX阶段,但它会猜测出决定,然后转到该指令(在我们的例子中是B或C)。</target>
        </trans-unit>
        <trans-unit id="167e8ac318227dcb55522a65e67d450259397b78" translate="yes" xml:space="preserve">
          <source>But in case of a random unsorted array, the prediction will need to discard the partially executed instructions and start over with the correct branch most of the time and result in more CPU cycles compared to the sorted array.</source>
          <target state="translated">但在随机无排序数组的情况下,预测器需要丢弃部分执行的指令,大部分时间需要用正确的分支重新开始,结果与排序数组相比,需要花费更多的CPU周期。</target>
        </trans-unit>
        <trans-unit id="dbc576af53dd6fb3f0dc64893d4fed7f4cc4366f" translate="yes" xml:space="preserve">
          <source>But in my testing, an explicit lookup table was slightly faster than this, probably because indexing into a lookup table was slightly faster than bit shifting.  This shows how my code sets up and uses the lookup table (unimaginatively called &lt;code&gt;lut&lt;/code&gt; for &quot;LookUp Table&quot; in the code).  Here's the C++ code:</source>
          <target state="translated">但是在我的测试中，显式查找表的速度稍快于此，这可能是因为索引到查找表中的速度略快于移位。 这显示了我的代码如何设置和使用查找表（在代码中，&amp;ldquo; LookUp Table&amp;rdquo;意为&amp;ldquo; &lt;code&gt;lut&lt;/code&gt; &amp;rdquo;）。 这是C ++代码：</target>
        </trans-unit>
        <trans-unit id="556743da1a16719ba282399e5ea0e47a985396e0" translate="yes" xml:space="preserve">
          <source>But in my testing, an explicit lookup table was slightly faster than this, probably because indexing into a lookup table was slightly faster than bit shifting. This shows how my code sets up and uses the lookup table (unimaginatively called lut for &quot;LookUp Table&quot; in the code). Here's the C++ code:</source>
          <target state="translated">但在我的测试中,显式查找表比这个要快一点,可能是因为索引到查找表的速度比位移位要快一点。这显示了我的代码是如何设置和使用查找表的(在代码中不加思索地将 &quot;LookUp Table &quot;称为lut)。下面是C++代码。</target>
        </trans-unit>
        <trans-unit id="a09b475c5d193e2a2ef480d8477ce7319209e1cd" translate="yes" xml:space="preserve">
          <source>But in this case, we know values are in the range [0, 255] and we only care about values &amp;gt;= 128. That means we can easily extract a single bit that will tell us whether we want a value or not: by shifting the data to the right 7 bits, we are left with a 0 bit or a 1 bit, and we only want to add the value when we have a 1 bit. Let's call this bit the &quot;decision bit&quot;.</source>
          <target state="translated">但是在这种情况下，我们知道值在[0，255]范围内，我们只关心值&amp;gt; =128。这意味着我们可以轻松地提取单个位来告诉我们是否需要一个值：数据右边的7位，剩下的是0位或1位，我们只想在有1位的情况下将值相加。 我们将此位称为&amp;ldquo;决策位&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="58cee47e25522bb2e607e044796956fc2d95746f" translate="yes" xml:space="preserve">
          <source>By using the 0/1 value of the decision bit as an index into an array, we can make code that will be equally fast whether the data is sorted or not sorted. Our code will always add a value, but when the decision bit is 0, we will add the value somewhere we don't care about. Here's the code:</source>
          <target state="translated">通过使用决策位的01值作为数组中的索引,我们可以制作的代码无论数据是否排序,都会同样快速。我们的代码会一直添加一个值,但当决策位为0时,我们会把值添加到我们不关心的地方。下面是这样的代码。</target>
        </trans-unit>
        <trans-unit id="56bb3ef2fb6bcc14eb09093062d52086eb734f83" translate="yes" xml:space="preserve">
          <source>C++ - Visual Studio 2010 - x64 Release</source>
          <target state="translated">C++-Visual Studio 2010-x64 版本</target>
        </trans-unit>
        <trans-unit id="907dc42739003087cf41fc698a5aef43e56b2716" translate="yes" xml:space="preserve">
          <source>Consider a railroad junction:</source>
          <target state="translated">考虑一下铁路道口。</target>
        </trans-unit>
        <trans-unit id="0008f55380e54b1390ff08936a649b5378e8d33b" translate="yes" xml:space="preserve">
          <source>Drilling down into the line-by-line output produced by &lt;code&gt;cg_annotate&lt;/code&gt; we see for the loop in question:</source>
          <target state="translated">深入研究 &lt;code&gt;cg_annotate&lt;/code&gt; 产生的逐行输出，我们看到了所讨论的循环：</target>
        </trans-unit>
        <trans-unit id="e84c032993f25d05ec7cbf44965cf42d501894a7" translate="yes" xml:space="preserve">
          <source>EX -- Execute the instruction</source>
          <target state="translated">EX --执行指令</target>
        </trans-unit>
        <trans-unit id="91b7378edbcc8a2dcbc0578b242232b9f0edf9c0" translate="yes" xml:space="preserve">
          <source>Each element in the original code is a random value</source>
          <target state="translated">原始代码中的每个元素都是一个随机值</target>
        </trans-unit>
        <trans-unit id="5b31068fcc3d6c11d6243f6f58c031a60e4fe724" translate="yes" xml:space="preserve">
          <source>Fortunately for us, if the memory access pattern is predictable, the processor will load it in its fast cache and all is well.</source>
          <target state="translated">幸运的是,对于我们来说,如果内存访问模式是可以预测的,处理器会将其加载到快速缓存中,一切都很顺利。</target>
        </trans-unit>
        <trans-unit id="96d1b40b361ab03cd656fc01b084e5d379dd61ce" translate="yes" xml:space="preserve">
          <source>Frequently used Boolean operations in C++ produce many branches in the compiled program. If these branches are inside loops and are hard to predict they can slow down execution significantly. Boolean variables are stored as 8-bit integers with the value &lt;code&gt;0&lt;/code&gt; for &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">C ++中经常使用的布尔运算会在编译程序中产生许多分支。 如果这些分支位于循环内并且难以预测，则它们可能会大大降低执行速度。 布尔变量存储为8位整数， &lt;code&gt;false&lt;/code&gt; 值为 &lt;code&gt;0&lt;/code&gt; ， true值为 &lt;code&gt;1&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="fbb5582021303c8d664e2d578e2f2f31b983748c" translate="yes" xml:space="preserve">
          <source>From a processor perspective, your memory is slow. To compensate for the difference in speed, a couple of caches are built into your processor (L1/L2 cache). So imagine that you're doing your nice calculations and figure out that you need a piece of memory. The processor will get its 'load' operation and loads the piece of memory into cache -- and then uses the cache to do the rest of the calculations. Because memory is relatively slow, this 'load' will slow down your program.</source>
          <target state="translated">从处理器的角度来说,你的内存很慢。为了弥补速度上的差异,你的处理器中内置了几个缓存(L1L2缓存)。所以想象一下,你在做你的漂亮计算,算出你需要一块内存。处理器会得到它的'加载'操作,并将这块内存加载到缓存中--然后用缓存来进行其余的计算。因为内存是相对较慢的,这种'加载'会使你的程序变慢。</target>
        </trans-unit>
        <trans-unit id="a69eb648a593eb899c67ee00a5913154aebeadb2" translate="yes" xml:space="preserve">
          <source>Further reading: &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;&quot;Branch predictor&quot; article on Wikipedia&lt;/a&gt;.</source>
          <target state="translated">进一步阅读： &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Wikipedia上的&amp;ldquo;分支预测器&amp;rdquo;文章&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2cb4ec23cd0f11546771882b0c409bbbd82fc5ea" translate="yes" xml:space="preserve">
          <source>GCC 4.6.1 with &lt;code&gt;-O3&lt;/code&gt; or &lt;code&gt;-ftree-vectorize&lt;/code&gt; on x64 is able to generate a conditional move. So there is no difference between the sorted and unsorted data - both are fast.</source>
          <target state="translated">在x64上带有 &lt;code&gt;-O3&lt;/code&gt; 或 &lt;code&gt;-ftree-vectorize&lt;/code&gt; 的 GCC 4.6.1能够生成条件移动。 因此，已排序和未排序的数据之间没有区别-两者都很快速。</target>
        </trans-unit>
        <trans-unit id="f53bd842ecd4d4a9f495f435523c9cf23aa6a57c" translate="yes" xml:space="preserve">
          <source>Generally, modern processors have quite long pipelines, but for ease let's consider these 4 steps only.</source>
          <target state="translated">一般来说,现代处理器的流水线相当长,但为了方便起见,我们只考虑这4个步骤。</target>
        </trans-unit>
        <trans-unit id="38465cba940858cd4732031697c429623f9115b7" translate="yes" xml:space="preserve">
          <source>Here are the timings of the loop with different true-false patterns:</source>
          <target state="translated">以下是不同真假模式的循环时序。</target>
        </trans-unit>
        <trans-unit id="6a74c4bde413f0664d97478a9af05dc6dec1968a" translate="yes" xml:space="preserve">
          <source>Here is a piece of C++ code that shows some very peculiar behavior. For some strange reason, sorting the data miraculously makes the code almost six times faster:</source>
          <target state="translated">这里有一段C++代码,显示了一些非常奇特的行为。由于一些奇怪的原因,对数据进行排序,奇迹般地使代码的速度快了近6倍。</target>
        </trans-unit>
        <trans-unit id="9540c640283f5095fcffbc3e62196fc4a354f281" translate="yes" xml:space="preserve">
          <source>Here's a link to this code: &lt;a href=&quot;http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx&quot;&gt;Red Black Trees&lt;/a&gt;, &lt;em&gt;Eternally Confuzzled&lt;/em&gt;</source>
          <target state="translated">这是此代码的链接： &lt;a href=&quot;http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx&quot;&gt;红黑树&lt;/a&gt; ， &lt;em&gt;永远困惑&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65bc35b8db256ec9378ffd563e6d314c0f419d53" translate="yes" xml:space="preserve">
          <source>However, when the data is completely random, the branch predictor is rendered useless, because it can't predict random data. Thus there will probably be around 50% misprediction (no better than random guessing).</source>
          <target state="translated">但是,当数据完全随机时,分支预测器就会变得毫无作用,因为它无法预测随机数据。因此可能会有50%左右的误预测(不比随机猜测好)。</target>
        </trans-unit>
        <trans-unit id="923101f6e2254ddc269c719e6877f55af0932907" translate="yes" xml:space="preserve">
          <source>I just read up on this question and its answers, and I feel an answer is missing.</source>
          <target state="translated">我刚看了一下这个问题和答案,感觉少了一个答案。</target>
        </trans-unit>
        <trans-unit id="6155d3cc9d0a0b68582ccdde2e81aba3a8812eb0" translate="yes" xml:space="preserve">
          <source>I ran that a few times to be sure. Yes, the phenomenon is real. My key code was:</source>
          <target state="translated">我跑了几次才确定。是的,这个现象是真实存在的。我的关键代码是:</target>
        </trans-unit>
        <trans-unit id="411b77367cb6a07a9e121aa06f74b175e40b6fd6" translate="yes" xml:space="preserve">
          <source>I tried the same code with MATLAB 2011b with my MacBook Pro (Intel i7, 64 bit, 2.4 GHz) for the following MATLAB code:</source>
          <target state="translated">我用我的MacBook Pro(英特尔i7,64位,2.4GHz)的MATLAB 2011b尝试了同样的代码,代码如下。</target>
        </trans-unit>
        <trans-unit id="51e91a54cf2fc822fbf81bdee0af955af2b6ea97" translate="yes" xml:space="preserve">
          <source>I'm not trying to add something but explaining the concept in another way. 
There is a concise introduction on the wiki which contains text and diagram.
I do like the explanation below which uses a diagram to elaborate the Branch Predictor intuitively.</source>
          <target state="translated">我不是想补充什么,而是用另一种方式解释这个概念。维基上有一个简明扼要的介绍,里面有文字和图表。我确实喜欢下面的解释,它用一个图来直观地阐述了分支预测器。</target>
        </trans-unit>
        <trans-unit id="065592acf6ecacc9b012a59339edcc7416aa6239" translate="yes" xml:space="preserve">
          <source>ID -- Decode the instruction</source>
          <target state="translated">ID --解码指令</target>
        </trans-unit>
        <trans-unit id="42c1b1564597619cb2c77349430882a2580c741c" translate="yes" xml:space="preserve">
          <source>IF -- Fetch the instruction from memory</source>
          <target state="translated">IF --从内存中获取指令</target>
        </trans-unit>
        <trans-unit id="88eb4395003cb412e7661165f4ce4cf1f486289e" translate="yes" xml:space="preserve">
          <source>If it is later detected that the guess was wrong then the partially executed instructions are discarded and the pipeline starts over with the correct branch, incurring a delay. 
The time that is wasted in case of a branch misprediction is equal to the number of stages in the pipeline from the fetch stage to the execute stage. Modern microprocessors tend to have quite long pipelines so that the misprediction delay is between 10 and 20 clock cycles. The longer the pipeline the greater the need for a good &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;branch predictor&lt;/a&gt;.</source>
          <target state="translated">如果以后检测到猜测是错误的，则将部分执行的指令丢弃，流水线将从正确的分支重新开始，从而导致延迟。 在分支预测错误的情况下浪费的时间等于从获取阶段到执行阶段的流水线中的阶段数。 现代微处理器往往具有很长的流水线，因此误预测延迟在10到20个时钟周期之间。 管道越长，对好的&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;分支预测器&lt;/a&gt;的需求就越大。</target>
        </trans-unit>
        <trans-unit id="fd7de5e20eb6affc18989173e9a7fbd64cfc3a64" translate="yes" xml:space="preserve">
          <source>If the array is sorted, your condition is false at the first step: &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt;, then becomes a true value for the whole way to the end of the street. That's how you get to the end of the logic faster. On the other hand, using an unsorted array, you need a lot of turning and processing which make your code run slower for sure...</source>
          <target state="translated">如果对数组进行了排序，则第一步的条件为false： &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; ，然后到街道尽头的整个过程变为真值。 这样便可以更快地到达逻辑结尾。 另一方面，使用未排序的数组，您需要进行大量的翻转和处理，这肯定会使您的代码运行缓慢。</target>
        </trans-unit>
        <trans-unit id="56d4fd733b97267a72ee645f98fa635e9b8c6ce9" translate="yes" xml:space="preserve">
          <source>If the compiler isn't able to optimize the branch into a conditional move, you can try some hacks if you are willing to sacrifice readability for performance.</source>
          <target state="translated">如果编译器不能将分支优化成有条件的动作,如果你愿意牺牲可读性来换取性能的话,可以尝试一些黑客的方法。</target>
        </trans-unit>
        <trans-unit id="1824e7d45369351e72c6eb590133dd9e21d010ed" translate="yes" xml:space="preserve">
          <source>If you are curious about even more optimizations that can be done to this code, consider this:</source>
          <target state="translated">如果你想知道这段代码可以做更多的优化,可以考虑一下。</target>
        </trans-unit>
        <trans-unit id="5ceebbf643b622dd844b59e8bd85fc4f5ede90be" translate="yes" xml:space="preserve">
          <source>If you give the Intel compiler the branchless code, it just out-right vectorizes it... and is just as fast as with the branch (with the loop interchange).</source>
          <target state="translated">如果你把无分支的代码交给英特尔编译器,它就会直接把它矢量化...........而且速度和使用分支的速度一样快(有了循环互换)。</target>
        </trans-unit>
        <trans-unit id="ae88c41ed067d722d464020e7a9f55e02d32fddc" translate="yes" xml:space="preserve">
          <source>If you guessed right, it continues on.</source>
          <target state="translated">如果你猜对了,那就继续说下去。</target>
        </trans-unit>
        <trans-unit id="bbb6c6bc29b605454dbfe7f8781ef7cdb2c270f2" translate="yes" xml:space="preserve">
          <source>If you guessed right, you continue executing.</source>
          <target state="translated">如果你猜对了,你就继续执行。</target>
        </trans-unit>
        <trans-unit id="1898647ae8c929024233a50359541e7af7814ea2" translate="yes" xml:space="preserve">
          <source>If you guessed wrong, the captain will stop, back up, and yell at you to flip the switch. Then it can restart down the other path.</source>
          <target state="translated">如果你猜错了,船长就会停下来,倒车,然后喊你翻车。然后,它就可以从另一条路重新启动。</target>
        </trans-unit>
        <trans-unit id="9b46e462a942895bb7f6e7d844e7730c6d70136b" translate="yes" xml:space="preserve">
          <source>If you guessed wrong, you need to flush the pipeline and roll back to the branch. Then you can restart down the other path.</source>
          <target state="translated">如果你猜错了,你需要冲刷管道,然后滚回分支。然后就可以沿着另一条路重新开始。</target>
        </trans-unit>
        <trans-unit id="23319b8aed03d58e34f2b56f4949401e859e197b" translate="yes" xml:space="preserve">
          <source>If you have ever wondered why ARM has been so phenomenally successful, the brilliant effectiveness and interplay of these two mechanisms are a big part of the story, because they are one of the greatest sources of the ARM architecture's efficiency. The brilliance of the original designers of the ARM ISA back in 1983, Steve Furber and Roger (now Sophie) Wilson, cannot be overstated.</source>
          <target state="translated">如果你曾想知道ARM为什么会取得如此惊人的成功,那么这两个机制的辉煌功效和相互作用是其中的一大原因,因为它们是ARM架构效率的最大来源之一。早在1983年,ARM ISA的最初设计者Steve Furber和Roger(现在的Sophie)Wilson,其辉煌的成就怎么说都不为过。</target>
        </trans-unit>
        <trans-unit id="20223b3b9842562860c0883dd004a561d3dec19d" translate="yes" xml:space="preserve">
          <source>If you run into trouble with lookups in managed languages -- the key is to add a &lt;code&gt;&amp;amp; 0x[something]FFF&lt;/code&gt; to your lookup function to make the boundary check predictable -- and watch it going faster.</source>
          <target state="translated">如果您在使用托管语言进行查找时遇到麻烦-关键是在查找函数中添加 &lt;code&gt;&amp;amp; 0x[something]FFF&lt;/code&gt; 以使边界检查可预测-并观察其执行速度。</target>
        </trans-unit>
        <trans-unit id="fcbae46e5b1ed263a398fd8853f1c323c42dd17c" translate="yes" xml:space="preserve">
          <source>If you want to write efficient code, you need to know a bit about machine architecture.</source>
          <target state="translated">如果你想写出高效的代码,你需要对机器架构有一定的了解。</target>
        </trans-unit>
        <trans-unit id="4906cf640b371d74701a3bb36c48ac95ee90c060" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;C&lt;/code&gt;, thus &lt;code&gt;C++&lt;/code&gt;, the statement, which would compile directly (without any optimization) into the conditional move instruction in &lt;code&gt;x86&lt;/code&gt;, is the ternary operator &lt;code&gt;... ? ... : ...&lt;/code&gt;. So we rewrite the above statement into an equivalent one:</source>
          <target state="translated">在 &lt;code&gt;C&lt;/code&gt; 中 ，因此在 &lt;code&gt;C++&lt;/code&gt; ，将直接（不进行任何优化）编译为 &lt;code&gt;x86&lt;/code&gt; 中的条件移动指令的语句是三元运算符 &lt;code&gt;... ? ... : ...&lt;/code&gt; &amp;hellip;&amp;hellip;：&amp;hellip;&amp;hellip; 。 因此，我们将上面的语句重写为等效的语句：</target>
        </trans-unit>
        <trans-unit id="ab040f6c0d47f49db7c9db520be83759c461ffc9" translate="yes" xml:space="preserve">
          <source>In a branch case, the following instruction is determined by the preceding one, so we cannot do pipelining. We have to either wait or predict.</source>
          <target state="translated">在分支的情况下,下面的指令是由前面的指令决定的,所以我们不能进行流水线操作。我们只能等待或预测。</target>
        </trans-unit>
        <trans-unit id="0025791b5e0267a182817044a5ed2c8007195575" translate="yes" xml:space="preserve">
          <source>In a conditional move case, the execution conditional move instruction is divided into several stages, but the earlier stages like &lt;code&gt;Fetch&lt;/code&gt; and &lt;code&gt;Decode&lt;/code&gt; does not depend on the result of the previous instruction; only latter stages need the result. Thus, we wait a fraction of one instruction's execution time. This is why the conditional move version is slower than the branch when prediction is easy.</source>
          <target state="translated">在条件移动的情况下，执行条件移动指令分为几个阶段，但较早的阶段（如 &lt;code&gt;Fetch&lt;/code&gt; 和 &lt;code&gt;Decode&lt;/code&gt; )并不取决于前一条指令的结果； 只有后期才需要结果。 因此，我们等待一条指令执行时间的一小部分。 这就是为什么在容易预测的情况下有条件移动版本比分支慢的原因。</target>
        </trans-unit>
        <trans-unit id="79ae345e2bd1b8124d296ba39b3ea113c5193f48" translate="yes" xml:space="preserve">
          <source>In a typical &lt;code&gt;x86&lt;/code&gt; processor, the execution of an instruction is divided into several stages. Roughly, we have different hardware to deal with different stages. So we do not have to wait for one instruction to finish to start a new one. This is called &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Pipeline_%28computing%29&quot;&gt;pipelining&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">在典型的 &lt;code&gt;x86&lt;/code&gt; 处理器中，一条指令的执行分为几个阶段。 大致来说，我们有不同的硬件来处理不同的阶段。 因此，我们不必等待一条指令完成就可以开始一条新指令。 这称为&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Pipeline_%28computing%29&quot;&gt;流水线&lt;/a&gt;&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a827bd7aeac65573a68ed989955da0af9f32542" translate="yes" xml:space="preserve">
          <source>In addition to this, in complex prediction techniques the time taken to predict the branches is itself very high &amp;ndash;ranging from 2 to 5 cycles &amp;ndash;which is comparable to the execution time of actual branches.</source>
          <target state="translated">除此之外，在复杂的预测技术中，预测分支本身所花费的时间非常长-从2到5个周期-与实际分支的执行时间相当。</target>
        </trans-unit>
        <trans-unit id="0fa50c75a9a67268a4a229ac38ceeff7cb07714a" translate="yes" xml:space="preserve">
          <source>In all these cases the failure will be too less in number and as a result, only a few times it will need to discard the partially executed instructions and start over with the correct branch, resulting in fewer CPU cycles.</source>
          <target state="translated">在所有这些情况下,失败的次数都会太少,因此,只需要丢弃部分执行的指令,用正确的分支重新开始,从而减少CPU周期。</target>
        </trans-unit>
        <trans-unit id="fa58046848c4821f342e1d54d795534223e063ff" translate="yes" xml:space="preserve">
          <source>In an unsorted array, the computer makes multiple predictions, leading to an increased chance of errors.
Whereas, in a sorted array, the computer makes fewer predictions, reducing the chance of errors.
Making more predictions requires more time.</source>
          <target state="translated">在未排序的数组中,计算机会进行多次预测,导致错误的几率增加。而在排序的数组中,计算机做的预测次数较少,减少了出错的几率。进行更多的预测需要更多的时间。</target>
        </trans-unit>
        <trans-unit id="d548e9f8042a97cedfb594f9ea9edf3b28dedc70" translate="yes" xml:space="preserve">
          <source>In computer architecture, a branch predictor is a
  digital circuit that tries to guess which way a branch (e.g. an
  if-then-else structure) will go before this is known for sure. The
  purpose of the branch predictor is to improve the flow in the
  instruction pipeline. Branch predictors play a critical role in
  achieving high effective performance in many modern pipelined
  microprocessor architectures such as x86.</source>
          <target state="translated">在计算机体系结构中,分支预测器是一种数字电路,它试图在知道分支(例如if-then-else结构)会走哪条路之前,先猜测出一个分支(例如if-then-else结构)会走哪条路。分支预测器的目的是为了改善指令流水线中的流程。分支预测器在许多现代流水线式微处理器体系结构(如x86)中,在实现高效性能方面发挥着至关重要的作用。</target>
        </trans-unit>
        <trans-unit id="286bceae83a4fe4b1c8bf9719f0595eb063192a3" translate="yes" xml:space="preserve">
          <source>In order to effectively write your code to take advantage of these
  rules, when writing &lt;strong&gt;if-else&lt;/strong&gt; or &lt;strong&gt;switch&lt;/strong&gt; statements, check the most
  common cases first and work progressively down to the least common.
  Loops do not necessarily require any special ordering of code for
  static branch prediction, as only the condition of the loop iterator
  is normally used.</source>
          <target state="translated">为了有效地编写代码以利用这些规则，在编写&lt;strong&gt;if-else&lt;/strong&gt;或&lt;strong&gt;switch&lt;/strong&gt;语句时，请先检查最常见的情况，然后逐步减少到最不常见的情况。 对于静态分支预测，循环不一定需要任何特殊的代码顺序，因为通常仅使用循环迭代器的条件。</target>
        </trans-unit>
        <trans-unit id="ecaad1e9fa8c85b19d9f8a2205db2cbf9519dd8c" translate="yes" xml:space="preserve">
          <source>In the C++ case, the hack is actually a tad slower than with the branch when the data is sorted.</source>
          <target state="translated">在C++的情况下,在数据排序时,黑客的速度其实比用分支的时候要慢一些。</target>
        </trans-unit>
        <trans-unit id="27ce65e9b9e70aa80a48ce10e7dd18a40e62a14f" translate="yes" xml:space="preserve">
          <source>In the OP's code, the first time when the conditional, the branch predictor does not have any information to base up prediction, so the first time it will randomly choose the next instruction. Later in the for loop, it can base the prediction on the history. 
For an array sorted in ascending order, there are three possibilities:</source>
          <target state="translated">在OP的代码中,在第一次提出条件时,分支预测器没有任何信息来进行基础预测,所以第一次会随机选择下一条指令。后面的for循环中,它可以根据历史记录来进行预测。对于一个按升序排序的数组,有三种可能。</target>
        </trans-unit>
        <trans-unit id="cfb2e6fc90f9bfd7c318bca3b56e7b9b3254c2b4" translate="yes" xml:space="preserve">
          <source>In the same line (I think this was not highlighted by any answer) it's good to mention that sometimes (specially in software where the performance matters&amp;mdash;like in the Linux kernel) you can find some if statements like the following:</source>
          <target state="translated">在同一行中（我认为这没有任何答案突出显示），值得一提的是，有时（特别是在性能至关重要的软件中，例如在Linux内核中），您会找到一些if语句，如下所示：</target>
        </trans-unit>
        <trans-unit id="9d109a99d8c4326a6576d4732479edf2a6cedc39" translate="yes" xml:space="preserve">
          <source>In the sorted case, you can do better than relying on successful branch prediction or any branchless comparison trick: completely remove the branch.</source>
          <target state="translated">在排序的情况下,你可以做得比依靠成功的分支预测或任何无分支比较的技巧更好:完全删除分支。</target>
        </trans-unit>
        <trans-unit id="a4e4e6b119a5c6f74ced74230250afdbfb631f5a" translate="yes" xml:space="preserve">
          <source>In this case, it's obvious to the compiler that the boundary condition will never be hit. At least the Microsoft JIT compiler (but I expect Java does similar things) will notice this and remove the check altogether. WOW, that means no branch. Similarly, it will deal with other obvious cases.</source>
          <target state="translated">在这种情况下,编译器很明显,边界条件永远不会被击中。至少微软的JIT编译器(但我预计Java也会做类似的事情)会注意到这一点,并完全删除检查。WOW,这意味着没有分支。同样,它也会处理其他明显的情况。</target>
        </trans-unit>
        <trans-unit id="fd70319a87ba55ceb8c46ef0dfb0b5cd4e2bf481" translate="yes" xml:space="preserve">
          <source>In this case, the lookup table was only 256 bytes, so it fits nicely in a cache and all was fast. This technique wouldn't work well if the data was 24-bit values and we only wanted half of them... the lookup table would be far too big to be practical. On the other hand, we can combine the two techniques shown above: first shift the bits over, then index a lookup table. For a 24-bit value that we only want the top half value, we could potentially shift the data right by 12 bits, and be left with a 12-bit value for a table index. A 12-bit table index implies a table of 4096 values, which might be practical.</source>
          <target state="translated">在这种情况下,查找表只有256个字节,所以它可以很好地放在缓存中,一切都很快。如果数据是24位的值,而我们只想要其中的一半,那么这种技术就不太行得通了...........查找表会大得多,不实用。另一方面,我们可以将上图中的两种技术结合起来:先将位移位,然后在查找表中建立索引。对于一个24位的值,我们可以将数据右移12位,然后留下一个12位的表索引。一个12位的表索引意味着一个4096个值的表,这可能是可行的。</target>
        </trans-unit>
        <trans-unit id="58ac7147fe158d09fb0dcd5d9a2419af351ceee2" translate="yes" xml:space="preserve">
          <source>In this case: &amp;gt;= 128 means we can keep the value, &amp;lt; 128 means we get rid of it. The easiest way to do that is by using an 'AND': if we keep it, we AND it with 7FFFFFFF; if we want to get rid of it, we AND it with 0. Notice also that 128 is a power of 2 -- so we can go ahead and make a table of 32768/128 integers and fill it with one zero and a lot of 7FFFFFFFF's.</source>
          <target state="translated">在这种情况下：&amp;gt; = 128表示我们可以保留该值，&amp;lt;128表示我们可以摆脱它。 最简单的方法是使用&amp;ldquo; AND&amp;rdquo;：如果我们保留它，我们将其与7FFFFFFF进行AND； 如果要删除它，则将其与0进行&amp;ldquo;与&amp;rdquo;运算。还要注意128是2的幂-因此我们可以继续制作一张32768/128整数的表，并用一个零和很多零填充7FFFFFFFF。</target>
        </trans-unit>
        <trans-unit id="05909b2541b3e02aeda1080cefdfed9bf8d3fb41" translate="yes" xml:space="preserve">
          <source>Indeed, the array is partitioned in a contiguous zone with &lt;code&gt;data &amp;lt; 128&lt;/code&gt; and another with &lt;code&gt;data &amp;gt;= 128&lt;/code&gt;. So you should find the partition point with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Dichotomic_search&quot;&gt;dichotomic search&lt;/a&gt; (using &lt;code&gt;Lg(arraySize) = 15&lt;/code&gt; comparisons), then do a straight accumulation from that point.</source>
          <target state="translated">实际上，该数组在 &lt;code&gt;data &amp;lt; 128&lt;/code&gt; 和 &lt;code&gt;data &amp;gt;= 128&lt;/code&gt; 的连续区域中分区。 因此，您应该通过&lt;a href=&quot;https://en.wikipedia.org/wiki/Dichotomic_search&quot;&gt;二分查找&lt;/a&gt; （使用 &lt;code&gt;Lg(arraySize) = 15&lt;/code&gt; 比较）找到分区点，然后从该点开始进行直接累加。</target>
        </trans-unit>
        <trans-unit id="511459d1219dae84b5739744e2330bbd39562f3c" translate="yes" xml:space="preserve">
          <source>Initially, I thought this might be just a language or compiler anomaly, so I tried Java:</source>
          <target state="translated">最初,我认为这可能只是语言或编译器的异常,所以我试了一下Java。</target>
        </trans-unit>
        <trans-unit id="b7ea0a495929d20edeb96560f38ad10f605c64c3" translate="yes" xml:space="preserve">
          <source>Intel - Avoiding the Cost of Branch Misprediction</source>
          <target state="translated">英特尔--避免分支误判的代价</target>
        </trans-unit>
        <trans-unit id="77db291a450702d5439477d5645b64a6a25dcb27" translate="yes" xml:space="preserve">
          <source>Intel - Branch and Loop Reorganization to Prevent Mispredicts</source>
          <target state="translated">英特尔----分支和环路重组,防止误判</target>
        </trans-unit>
        <trans-unit id="59f94bde7099ca1379cdd1147d7f4529386efe43" translate="yes" xml:space="preserve">
          <source>Is there a better way? You guess which direction the branch will go!</source>
          <target state="translated">有没有更好的方法?你来猜一猜树枝会往哪个方向走!</target>
        </trans-unit>
        <trans-unit id="9ce53cf70b1162457580560ead6c5cf7c26bf416" translate="yes" xml:space="preserve">
          <source>Is there a better way? You guess which direction the train will go!</source>
          <target state="translated">有没有更好的方法?你猜火车会开往哪个方向!</target>
        </trans-unit>
        <trans-unit id="2b7c4e9ff8bccc2bf1d5615ac7198435e8f85617" translate="yes" xml:space="preserve">
          <source>It can also do source code annotation with dissassembly.</source>
          <target state="translated">它还可以用反汇编做源码注释。</target>
        </trans-unit>
        <trans-unit id="d889c96e7c80c6d5564b275e9ce3e1dcf34879de" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t make fewer predictions - it makes fewer incorrect predictions. It still has to predict for each time through the loop...</source>
          <target state="translated">它不会做出更少的预测-它会做出更少的错误预测。 它仍然需要对循环中的每次时间进行预测...</target>
        </trans-unit>
        <trans-unit id="08fc45b9de518283718984bcfb1e9ac8e6ae1278" translate="yes" xml:space="preserve">
          <source>It is important to understand that branch misprediction doesn't slow down programs. The cost of a missed prediction is just as if branch prediction didn't exist and you waited for the evaluation of the expression to decide what code to run (further explanation in the next paragraph).</source>
          <target state="translated">需要明白的是,分支误预测不会拖慢程序的速度,这一点很重要。错过预测的代价就像如果分支预测不存在,你等待着对表达式的评估来决定运行什么代码一样(下一段会进一步解释)。</target>
        </trans-unit>
        <trans-unit id="6fc4b764667806eaf36f9b084c8cc41649bfd6ed" translate="yes" xml:space="preserve">
          <source>It will take 7 clock cycles for 3 instructions to be completed.</source>
          <target state="translated">3条指令需要7个时钟周期才能完成。</target>
        </trans-unit>
        <trans-unit id="7e692acc3118ecaa2f6cab194a17621924826a7b" translate="yes" xml:space="preserve">
          <source>It will take 9 clock cycles for 3 instructions to be completed.</source>
          <target state="translated">3条指令需要9个时钟周期才能完成。</target>
        </trans-unit>
        <trans-unit id="76778e3295cf8f4fb34c2e009919d81130807662" translate="yes" xml:space="preserve">
          <source>It's about branch prediction. What is it?</source>
          <target state="translated">是关于分支预测的。是什么?</target>
        </trans-unit>
        <trans-unit id="5ce025460eef942a5746a29f6fff2639b7a4f0ea" translate="yes" xml:space="preserve">
          <source>It's quite a simple demo that clarifies the very basic part of Branch Predictor. If those gifs are annoying, please feel free to remove them from the answer and visitors can also get the live demo source code from &lt;a href=&quot;https://github.com/Eugene-Mark/BranchPredictorDemo&quot;&gt;BranchPredictorDemo&lt;/a&gt;</source>
          <target state="translated">这是一个非常简单的演示，阐明了Branch Predictor的最基本部分。 如果这些gif令人讨厌，请随时将其从答案中删除，访问者还可以从&lt;a href=&quot;https://github.com/Eugene-Mark/BranchPredictorDemo&quot;&gt;BranchPredictorDemo&lt;/a&gt;获取实时演示源代码。</target>
        </trans-unit>
        <trans-unit id="d1800ac2cc348d512d31d6a4d1e9d7c3834e153d" translate="yes" xml:space="preserve">
          <source>Java - NetBeans 7.1.1 JDK 7 - x64</source>
          <target state="translated">Java-NetBeans 7.1.1.1 JDK 7-x64</target>
        </trans-unit>
        <trans-unit id="f3f0214447bd9b96e0f2a7febf49ceace8c3c918" translate="yes" xml:space="preserve">
          <source>Let us assume that the predictor will always assume the true branch on the first run.</source>
          <target state="translated">让我们假设预测器在第一次运行时总是假设真实的分支。</target>
        </trans-unit>
        <trans-unit id="0626fcdc6685d5777030cccc407cda27d5a5dbe6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s measure the performance of this loop with different conditions:</source>
          <target state="translated">让我们在不同条件下测量此循环的性能：</target>
        </trans-unit>
        <trans-unit id="78c58416698b00e2911ee8edf6ff28c7aa28b3f5" translate="yes" xml:space="preserve">
          <source>Let's say you need to pick route 1 or route 2. Waiting for your partner to check the map, you have stopped at ## and waited, or you could just pick route1 and if you were lucky (route 1 is the correct route), then great you didn't have to wait for your partner to check the map (you saved the time it would have taken him to check the map), otherwise you will just turn back.</source>
          <target state="translated">比方说你需要选1号路线或者2号路线。在等你的伙伴查地图的时候,你已经在##处停了下来等着,或者你可以直接选路线1,如果你运气好的话(路线1是正确的路线),那么很好,你就不用等你的伙伴查地图了(你省去了他查地图的时间),否则你就直接掉头回去。</target>
        </trans-unit>
        <trans-unit id="2722634189f24bf6fb4d65af5b80948093b029bf" translate="yes" xml:space="preserve">
          <source>Like branch prediction, this was optimized in the Pentium processors: the processor predicts that it needs to load a piece of data and attempts to load that into the cache before the operation actually hits the cache. As we've already seen, branch prediction sometimes goes horribly wrong -- in the worst case scenario you need to go back and actually wait for a memory load, which will take forever (&lt;strong&gt;in other words: failing branch prediction is bad, a memory load after a branch prediction fail is just horrible!&lt;/strong&gt;).</source>
          <target state="translated">像分支预测一样，它在奔腾处理器中进行了优化：处理器预测它需要加载一条数据，并在操作实际到达缓存之前尝试将其加载到缓存中。 正如我们已经看到的那样，分支预测有时会出现严重错误-在最坏的情况下，您需要返回并实际上等待内存加载，这将花费很长的时间（ &lt;strong&gt;换句话说：失败的分支预测很糟糕，内存不足）分支预测失败后的负载简直太可怕了！&lt;/strong&gt; ）。</target>
        </trans-unit>
        <trans-unit id="7511e6163f79984c1b9da8abd1a9c44be298fc50" translate="yes" xml:space="preserve">
          <source>Look at the image I created for you below. Which street is going to be finished faster?</source>
          <target state="translated">看看下面我为大家制作的图片。哪条街的完成速度会更快?</target>
        </trans-unit>
        <trans-unit id="87b5594f2643cba7d46d5fb490ed0d38e2cf1230" translate="yes" xml:space="preserve">
          <source>Making a wrong prediction leads to going back to the previous step, and executing with another prediction. Assuming the prediction is correct, the code will continue to the next step. A wrong prediction results in repeating the same step, until a correct prediction occurs.</source>
          <target state="translated">进行错误的预测,会导致返回到上一步,用另一个预测执行。假设预测是正确的,代码将继续到下一步。一个错误的预测会导致重复相同的步骤,直到出现一个正确的预测。</target>
        </trans-unit>
        <trans-unit id="a1ebbba208d4225ea0cbac50fe08bb6ace4451a3" translate="yes" xml:space="preserve">
          <source>Most applications have well-behaved branches. So modern branch predictors will typically achieve &amp;gt;90% hit rates. But when faced with unpredictable branches with no recognizable patterns, branch predictors are virtually useless.</source>
          <target state="translated">大多数应用程序具有行为良好的分支。 因此，现代分支预测器通常将达到90％以上的命中率。 但是，当面对没有可识别模式的不可预测分支时，分支预测变量实际上是无用的。</target>
        </trans-unit>
        <trans-unit id="edc45563f2af123495a6f4d5820e01d67e592ac5" translate="yes" xml:space="preserve">
          <source>Most processor architectures do not have this ability to specify whether or not the status bits should be updated for a given operation, which can necessitate writing additional code to save and later restore status bits, or may require additional branches, or may limit the processor's out of order execution efficiency: one of the side effects of most CPU instruction set architectures forcibly updating status bits after most instructions is that it is much harder to tease apart which instructions can be run in parallel without interfering with each other. Updating status bits has side effects, therefore has a linearizing effect on code. &lt;strong&gt;ARM's ability to mix and match branch-free condition testing on any instruction with the option to either update or not update the status bits after any instruction is extremely powerful, for both assembly language programmers and compilers, and produces very efficient code.&lt;/strong&gt;</source>
          <target state="translated">大多数处理器体系结构都没有这种能力来指定是否应为给定操作更新状态位，这可能需要编写额外的代码来保存和稍后恢复状态位，或者可能需要附加的分支，或者可能限制处理器的输出指令执行效率：大多数CPU指令集体系结构在大多数指令之后强制更新状态位的副作用之一是，很难弄清楚哪些指令可以并行运行而不互相干扰。 更新状态位具有副作用，因此对代码具有线性影响。 &lt;strong&gt;对于汇编语言程序员和编译器，ARM的能力非常强大，可以对任意一条指令进行混合和匹配，并且可以选择是否更新状态位，这对汇编语言程序员和编译器都非常有效，并且可以生成非常有效的代码。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6714e326ddf3827a45bf7845db0659793dffdc78" translate="yes" xml:space="preserve">
          <source>Moving back to the above question let's consider the following instructions:</source>
          <target state="translated">回到上面的问题,让我们考虑一下下面的说明。</target>
        </trans-unit>
        <trans-unit id="8f2f5f3a519901e55e81a2564329640471c74d81" translate="yes" xml:space="preserve">
          <source>My first thought was that sorting brings the data into the cache, but then I thought how silly that was because the array was just generated.</source>
          <target state="translated">我的第一个想法是,排序把数据带入缓存,但后来我又想,那是多么愚蠢的事情,因为数组只是生成的。</target>
        </trans-unit>
        <trans-unit id="5b798bfc3b15b4fc93876532bf774c937ef4d1cc" translate="yes" xml:space="preserve">
          <source>No doubt some of us would be interested in ways of identifying code that is problematic for the CPU's branch-predictor. The Valgrind tool &lt;code&gt;cachegrind&lt;/code&gt; has a branch-predictor simulator, enabled by using the &lt;code&gt;--branch-sim=yes&lt;/code&gt; flag. Running it over the examples in this question, with the number of outer loops reduced to 10000 and compiled with &lt;code&gt;g++&lt;/code&gt;, gives these results:</source>
          <target state="translated">毫无疑问，我们中的某些人会对识别对CPU的分支预测器有问题的代码的方式感兴趣。 Valgrind工具 &lt;code&gt;cachegrind&lt;/code&gt; 具有分支预测器模拟器，可通过使用 &lt;code&gt;--branch-sim=yes&lt;/code&gt; 标志启用。 在此问题的示例上运行它，将外部循环数减少到10000并使用 &lt;code&gt;g++&lt;/code&gt; 编译，得出以下结果：</target>
        </trans-unit>
        <trans-unit id="7fe6472f78792531c23c2701179111bf8fe3d611" translate="yes" xml:space="preserve">
          <source>Normally this kind of optimizations are mainly found in hard-real time applications or embedded systems where execution time matters and it's critical. For example, if you are checking for some error condition that only happens 1/10000000 times, then why not inform the compiler about this? This way, by default, the branch prediction would assume that the condition is false.</source>
          <target state="translated">通常情况下,这种优化主要出现在硬实时应用或嵌入式系统中,因为这些应用的执行时间很重要,而且非常关键。例如,如果你要检查某些错误条件只发生了110000000次,那么为什么不通知编译器呢?这样一来,在默认情况下,分支预测就会假设该条件是假的。</target>
        </trans-unit>
        <trans-unit id="2687a67b9058fe9e6fd551f4fb695501d7a3f7de" translate="yes" xml:space="preserve">
          <source>Notice that the data is evenly distributed between 0 and 255. When the data is sorted, roughly the first half of the iterations will not enter the if-statement. After that, they will all enter the if-statement.</source>
          <target state="translated">注意,数据在0到255之间均匀分布。当数据被排序后,大概前一半的迭代不会进入if-statement。之后,它们将全部进入if-statement。</target>
        </trans-unit>
        <trans-unit id="8e169f52da1ac65f0d59b6b1c4ec6bd5bf878be5" translate="yes" xml:space="preserve">
          <source>Now for the sake of argument, suppose this is back in the 1800s - before long distance or radio communication.</source>
          <target state="translated">现在,为了争论,假设这是在19世纪的时候--在远距离或无线电通信之前。</target>
        </trans-unit>
        <trans-unit id="30312bef68cebc5f38e57e727b2135cfb377fc89" translate="yes" xml:space="preserve">
          <source>Now let's look more closely by investigating the &lt;code&gt;x86&lt;/code&gt; assembly they generate. For simplicity, we use two functions &lt;code&gt;max1&lt;/code&gt; and &lt;code&gt;max2&lt;/code&gt;.</source>
          <target state="translated">现在，通过研究它们生成的 &lt;code&gt;x86&lt;/code&gt; 程序集，让我们更加仔细地研究。 为了简单起见，我们使用两个函数 &lt;code&gt;max1&lt;/code&gt; 和 &lt;code&gt;max2&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c330fcd6ba152c362d1fcd57661782df403680f7" translate="yes" xml:space="preserve">
          <source>Now, if we look at the code</source>
          <target state="translated">现在,如果我们看一下代码</target>
        </trans-unit>
        <trans-unit id="580a776c6b642fccec58ff95f40d16a839dd873b" translate="yes" xml:space="preserve">
          <source>Observations:</source>
          <target state="translated">Observations:</target>
        </trans-unit>
        <trans-unit id="c497da8cabdb633d3a209eb10a05a6e8a8479a34" translate="yes" xml:space="preserve">
          <source>On ARM, there is no branch needed, because every instruction has a 4-bit condition field, which tests (at zero cost) any of &lt;a href=&quot;https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/condition-codes-1-condition-flags-and-codes&quot;&gt;16 different different conditions&lt;/a&gt; that may arise in the Processor Status Register, and if the condition on an instruction is false, the instruction is skipped. This eliminates the need for short branches, and there would be no branch prediction hit for this algorithm. &lt;b&gt;Therefore, the sorted version of this algorithm would run slower than the unsorted version on ARM, because of the extra overhead of sorting.&lt;/b&gt;</source>
          <target state="translated">在ARM上，不需要分支，因为每条指令都有一个4位的条件字段，该字段将以零成本测试（可能为零）处理器状态寄存器中可能出现的&lt;a href=&quot;https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/condition-codes-1-condition-flags-and-codes&quot;&gt;16种不同条件&lt;/a&gt;中的任何一种，以及指令中的条件是否为否，指令被跳过。 这消除了对短分支的需求，并且该算法不会对分支预测产生任何影响。 &lt;b&gt;因此，由于排序的额外开销，该算法的排序版本在ARM上的运行速度将比未排序版本慢。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97e13959d4711e37195fe7ecfc6a86c5fe97b99f" translate="yes" xml:space="preserve">
          <source>On a x86-64 machine, &lt;code&gt;GCC -S&lt;/code&gt; generates the assembly below.</source>
          <target state="translated">在x86-64机器上， &lt;code&gt;GCC -S&lt;/code&gt; 生成以下程序集。</target>
        </trans-unit>
        <trans-unit id="af5b27c4a00930aafb30d96f562d6210ddf9267b" translate="yes" xml:space="preserve">
          <source>On an Intel &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core i7&lt;/a&gt;-2600K @ 3.4&amp;nbsp;GHz and Visual Studio 2010 Release Mode, the benchmark is (format copied from Mysticial):</source>
          <target state="translated">在Intel &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core i7&lt;/a&gt; -2600K @ 3.4 GHz和Visual Studio 2010 Release Mode上，基准是（从Mysticial复制的格式）：</target>
        </trans-unit>
        <trans-unit id="c46e9d0de821ff22c14c3a97f36bb4c970b4b164" translate="yes" xml:space="preserve">
          <source>On the other hand, complex branch predictions &amp;ndash;either neural based or variants of two-level branch prediction &amp;ndash;provide better prediction accuracy, but they consume more power and complexity increases exponentially.</source>
          <target state="translated">另一方面，复杂的分支预测（基于神经的预测或两级分支预测的变体）可提供更好的预测精度，但它们消耗的功率更多，并且复杂度呈指数增长。</target>
        </trans-unit>
        <trans-unit id="a5e809f1e268fe28804313bc9194b78b811d96b5" translate="yes" xml:space="preserve">
          <source>On the other hand, once it's sorted, the predictor will first move into a state of strongly not taken and when the values change to the high value the predictor will in three runs through change all the way from strongly not taken to strongly taken.</source>
          <target state="translated">另一方面,一旦排序后,预测器首先会进入强不取的状态,当值变化到高值时,预测器会在三次运行中一路从强不取到强取。</target>
        </trans-unit>
        <trans-unit id="3bbefccbf2bee10e9954cc81b62c16f44204ba33" translate="yes" xml:space="preserve">
          <source>One reason is branch prediction: the key operation in the sort algorithm is &lt;code&gt;&amp;ldquo;if(v[i] &amp;lt; pivot]) &amp;hellip;&amp;rdquo;&lt;/code&gt; or equivalent. For a sorted sequence that test is always true whereas, for a random sequence, the branch chosen varies randomly.</source>
          <target state="translated">原因之一是分支预测：排序算法中的关键操作是 &lt;code&gt;&amp;ldquo;if(v[i] &amp;lt; pivot]) &amp;hellip;&amp;rdquo;&lt;/code&gt; 或等效操作。 对于排序的序列，测试始终为真，而对于随机序列，选择的分支随机变化。</target>
        </trans-unit>
        <trans-unit id="6f83347c5969b82a1f9ad38db3d4941619744366" translate="yes" xml:space="preserve">
          <source>One way to avoid branch prediction errors is to build a lookup table, and index it using the data. Stefan de Bruijn discussed that in his answer.</source>
          <target state="translated">避免分支预测错误的一个方法是建立一个查找表,并使用数据进行索引。Stefan de Bruijn在他的回答中讨论了这个问题。</target>
        </trans-unit>
        <trans-unit id="dba85fca15da0466e912cf6f28584da718edda4e" translate="yes" xml:space="preserve">
          <source>Quicksort (and sorting in general) is a complex study that has attracted some of the greatest minds of computer science. A good sort function is a result of both choosing a good algorithm and paying attention to hardware performance in its implementation.</source>
          <target state="translated">Quicksort(以及一般的排序)是一门复杂的学问,吸引了计算机科学界的一些大师们的研究。一个好的排序函数,既要选择一个好的算法,又要注意算法实现中的硬件性能。</target>
        </trans-unit>
        <trans-unit id="7eee27983091e8186d6b5fbbd3abab850ed0e885" translate="yes" xml:space="preserve">
          <source>Recently this example (modified very slightly) was also used as a way to demonstrate how a piece of code can be profiled within the program itself on Windows. Along the way, the author also shows how to use the results to determine where the code is spending most of its time in both the sorted &amp;amp; unsorted case. Finally the piece also shows how to use a little known feature of the HAL (Hardware Abstraction Layer) to determine just how much branch misprediction is happening in the unsorted case.</source>
          <target state="translated">最近，该示例（略作修改）还用作演示如何在Windows上的程序本身中对一段代码进行概要分析的方法。 在此过程中，作者还展示了如何使用结果来确定代码在排序和未排序情况下大部分时间都花在了哪里。 最后，这篇文章还展示了如何使用HAL（硬件抽象层）的一个鲜为人知的功能来确定在未分类的情况下发生了多少分支错误预测。</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="2e26f7f81e11c144071f07013d00802556dd33b0" translate="yes" xml:space="preserve">
          <source>Replace:</source>
          <target state="translated">Replace:</target>
        </trans-unit>
        <trans-unit id="5b332ccd041103419a2ad666b47b236d919bc4c8" translate="yes" xml:space="preserve">
          <source>Scientific papers - branch prediction computer architecture</source>
          <target state="translated">科技论文--分支预测计算机架构</target>
        </trans-unit>
        <trans-unit id="b01f405d3c10919c3c94fd65f54c0af170284f84" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://perf.wiki.kernel.org/index.php/Tutorial&quot;&gt;the performance tutorial&lt;/a&gt; for more details.</source>
          <target state="translated">有关更多详细信息，请参见&lt;a href=&quot;https://perf.wiki.kernel.org/index.php/Tutorial&quot;&gt;性能教程&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="3a298d21d0b3c80ce2982ea32ba8a81f978c30f0" translate="yes" xml:space="preserve">
          <source>So how would you strategically guess to minimize the number of times that the train must back up and go down the other path? You look at the past history! If the train goes left 99% of the time, then you guess left. If it alternates, then you alternate your guesses. If it goes one way every three times, you guess the same...</source>
          <target state="translated">那么,你会如何从策略上猜测,尽量减少火车必须倒车的次数,从另一条路走下去?你看一下过去的历史! 如果火车99%的时间都是向左走,那么你就猜向左。如果它交替出现,那么你就交替猜测。如果它每三次走一条路,你就猜同样的。</target>
        </trans-unit>
        <trans-unit id="9ebfa04f718206d91431f0015c26f1b42906f312" translate="yes" xml:space="preserve">
          <source>So in the first case, it will always take the true branch since historically all its predictions are correct.
In the 2nd case, initially it will predict wrong, but after a few iterations, it will predict correctly.
In the 3rd case, it will initially predict correctly till the elements are less than 128. After which it will fail for some time and the correct itself when it sees branch prediction failure in history.</source>
          <target state="translated">所以在第一种情况下,它总是会选择真正的分支,因为从历史上看,它的所有预测都是正确的。在第二种情况下,最初它的预测是错误的,但经过几次迭代后,它的预测就会正确。在第三种情况下,它最初的预测是正确的,直到元素小于128为止。在这种情况下,它将会失败一段时间后,当它看到历史上的分支预测失败时,会自行修正。</target>
        </trans-unit>
        <trans-unit id="351943fae2a5bec40c06462d38700c5db13e382c" translate="yes" xml:space="preserve">
          <source>So programmatically, &lt;strong&gt;branch prediction&lt;/strong&gt; causes the process to be slower...</source>
          <target state="translated">因此，以编程方式， &lt;strong&gt;分支预测&lt;/strong&gt;会使流程变慢。</target>
        </trans-unit>
        <trans-unit id="5ccec79adc1d899a1de0448aec6cd2999ea646b6" translate="yes" xml:space="preserve">
          <source>So there is no doubt about the impact of branch prediction on performance!</source>
          <target state="translated">所以分支预测对业绩的影响是毋庸置疑的!</target>
        </trans-unit>
        <trans-unit id="3ae2891b971dd8487010889269aa73c34566377f" translate="yes" xml:space="preserve">
          <source>So we've figured out that we can create a small table. Next thing to do is get a lookup function in place. Lookup functions are usually small functions that use a couple of basic integer operations (and, or, xor, shift, add, remove and perhaps multiply). You want to have your input translated by the lookup function to some kind of 'unique key' in your table, which then simply gives you the answer of all the work you wanted it to do.</source>
          <target state="translated">所以我们已经想好了,可以创建一个小表了。接下来要做的事情是建立一个查找函数。查找函数通常是使用一些基本的整数运算(和、或、xor、移位、加、除、乘)的小函数。你想让查找函数将你的输入转化为你的表中的某种 &quot;唯一键&quot;,然后简单地给出你想要它做的所有工作的答案。</target>
        </trans-unit>
        <trans-unit id="e2fc4b8592d275115019311dc1f64056ef857314" translate="yes" xml:space="preserve">
          <source>So why does a conditional move perform better?</source>
          <target state="translated">那么,为什么有条件的招式会有更好的表现呢?</target>
        </trans-unit>
        <trans-unit id="8862694fc5020ea843e75148ff60c38a99455cbf" translate="yes" xml:space="preserve">
          <source>So, I tried with a vector of a million integers and got:</source>
          <target state="translated">于是,我用一百万个整数的向量试了一下,结果是:</target>
        </trans-unit>
        <trans-unit id="26f99fe80efafd6fc68424aeeb2c6cf0ad1eb0fd" translate="yes" xml:space="preserve">
          <source>Some starting new elements are less than 128 and later it become greater than 128</source>
          <target state="translated">有的开始时新元素小于128,后来就变成了大于128。</target>
        </trans-unit>
        <trans-unit id="0e167763d050d2cb6ded113f3e9064040103e166" translate="yes" xml:space="preserve">
          <source>Something like (unchecked)</source>
          <target state="translated">像(未勾选)的东西</target>
        </trans-unit>
        <trans-unit id="a88df12411d4a67fd1c80b6258959d001907e55b" translate="yes" xml:space="preserve">
          <source>Sometimes, some modern compilers can optimize our code to assembly with better performance, sometimes some compilers can't (the code in question is using Visual Studio's native compiler). Knowing the performance difference between branch and conditional move when unpredictable can help us write code with better performance when the scenario gets so complex that the compiler can not optimize them automatically.</source>
          <target state="translated">有时候,有些现代的编译器可以将我们的代码优化成汇编,性能更好,有时候有些编译器不能(问题代码使用的是Visual Studio的原生编译器)。知道分支和条件移动在不可预知时的性能差异,可以帮助我们写出性能更好的代码,当场景变得非常复杂,以至于编译器无法自动优化它们时,可以帮助我们写出性能更好的代码。</target>
        </trans-unit>
        <trans-unit id="96ecd96ca3304ca88eb06e8a00937b5c4b49d3ed" translate="yes" xml:space="preserve">
          <source>Sorted Array: Straight Road
    ____________________________________________________________________________________
    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT</source>
          <target state="translated">排序阵列。</target>
        </trans-unit>
        <trans-unit id="417b7a8c229714395078ea87b358994e172876b0" translate="yes" xml:space="preserve">
          <source>Sorted arrays are processed faster than an unsorted array, due to a phenomena called branch prediction.</source>
          <target state="translated">排序的数组的处理速度比无排序数组快,这是由于一种叫做分支预测的现象。</target>
        </trans-unit>
        <trans-unit id="12a86072c1d6226f21fdf1c483e322e5674a52e2" translate="yes" xml:space="preserve">
          <source>Sorting only k-element sections completes the pre-processing in linear time, &lt;code&gt;O(n)&lt;/code&gt;, rather than the &lt;code&gt;O(n.log(n))&lt;/code&gt; time needed to sort the entire array.</source>
          <target state="translated">仅对k个元素部分进行排序即可完成线性时间 &lt;code&gt;O(n)&lt;/code&gt; 的预处理，而不是对整个数组进行排序所需的 &lt;code&gt;O(n.log(n))&lt;/code&gt; 时间。</target>
        </trans-unit>
        <trans-unit id="911567da4c21b2d8b0b479e0b036b07488a7f699" translate="yes" xml:space="preserve">
          <source>Starting with the original loop:</source>
          <target state="translated">从原始循环开始。</target>
        </trans-unit>
        <trans-unit id="b289c5eb6b8d96218afa396493007fb0c5566528" translate="yes" xml:space="preserve">
          <source>Static branch prediction is used by the microprocessor the first time
  a conditional branch is encountered, and dynamic branch prediction is
  used for succeeding executions of the conditional branch code.</source>
          <target state="translated">静态分支预测在第一次遇到条件分支时由微处理器使用,动态分支预测用于条件分支代码的后续执行。</target>
        </trans-unit>
        <trans-unit id="0f6ae2e9812cde1bb50890188a75301caf057eb4" translate="yes" xml:space="preserve">
          <source>That being said, the compiler tries to predict the outcome prior to it being actually evaluated. It will fetch instructions from the &lt;code&gt;if&lt;/code&gt; block, and if the expression turns out to be true, then wonderful! We gained the time it took to evaluate it and made progress in the code; if not then we are running the wrong code, the pipeline is flushed, and the correct block is run.</source>
          <target state="translated">话虽如此，编译器会在实际评估结果之前尝试预测结果。 它将从 &lt;code&gt;if&lt;/code&gt; 块中获取指令，并且如果表达式被证明是正确的，那就太好了！ 我们节省了评估时间，并在代码方面取得了进步。 如果不是，那么我们运行的是错误的代码，将刷新管道，并运行正确的块。</target>
        </trans-unit>
        <trans-unit id="35261a879de9858385098dadcc5581d89b2d609f" translate="yes" xml:space="preserve">
          <source>That one is 100,000 times faster than before.</source>
          <target state="translated">那一个比以前快了十万倍。</target>
        </trans-unit>
        <trans-unit id="08f10e7e1256e6e98ddd64a702e8dc6f1d8014d5" translate="yes" xml:space="preserve">
          <source>That sounds like an interview question. Is it true? How would you know? It is a bad idea to answer questions about efficiency without first doing some measurements, so it is important to know how to measure.</source>
          <target state="translated">这听起来像个面试题。是真的吗?你怎么会知道呢?如果不先做一些测量,就回答效率的问题是很不好的,所以知道如何测量是很重要的。</target>
        </trans-unit>
        <trans-unit id="508b04c27cc3f2089b5ea384a8ad1dd729afae1a" translate="yes" xml:space="preserve">
          <source>That's for sure!...</source>
          <target state="translated">那是肯定的!.....</target>
        </trans-unit>
        <trans-unit id="0cde2413f2853914209f8169d7f3210951656de9" translate="yes" xml:space="preserve">
          <source>The above behavior is happening because of Branch prediction.</source>
          <target state="translated">上述行为的发生,是由于Branch的预测。</target>
        </trans-unit>
        <trans-unit id="76fff62130dd99e863f74fb23823d0e6b58d4f70" translate="yes" xml:space="preserve">
          <source>The answer to your question is very simple.</source>
          <target state="translated">你的问题的答案很简单。</target>
        </trans-unit>
        <trans-unit id="429f9a89629f65eb36edfe9122d197b4a3ab1462" translate="yes" xml:space="preserve">
          <source>The assumption by other answers that one needs to sort the data is not correct.</source>
          <target state="translated">通过其他答案的假设,认为需要对数据进行分类,这种假设是不正确的。</target>
        </trans-unit>
        <trans-unit id="14fca0f59106880a0be992b705d52d3aeb245c06" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0136108040&quot;&gt;Computer Systems: A Programmer's Perspective, second edition&lt;/a&gt;&lt;/em&gt; explains this in detail. You can check Section 3.6.6 for &lt;em&gt;Conditional Move Instructions&lt;/em&gt;, entire Chapter 4 for &lt;em&gt;Processor Architecture&lt;/em&gt;, and Section 5.11.2 for a special treatment for &lt;em&gt;Branch Prediction and Misprediction Penalties&lt;/em&gt;.</source>
          <target state="translated">《 &lt;em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0136108040&quot;&gt;计算机系统：程序员的观点》（第二版）一书&lt;/a&gt;&lt;/em&gt;对此进行了详细说明。 您可以检查第3.6.6节中的&amp;ldquo; &lt;em&gt;条件移动指令&amp;rdquo;&lt;/em&gt; ，整个第4章中的&amp;ldquo; &lt;em&gt;处理器体系结构&lt;/em&gt; &amp;rdquo;和第5.11.2节中的&amp;ldquo; &lt;em&gt;分支预测和错误预测惩罚&amp;rdquo;&lt;/em&gt;的特殊处理。</target>
        </trans-unit>
        <trans-unit id="01c31d56c186a6ecf1549609412d42ba9d45ea61" translate="yes" xml:space="preserve">
          <source>The branch prediction will miss only once.</source>
          <target state="translated">分支预测只会错过一次。</target>
        </trans-unit>
        <trans-unit id="29c1be7f24497d0ee26471ab9535a6a90d257408" translate="yes" xml:space="preserve">
          <source>The branch predictor is a digital circuit (in computer architecture) trying to predict which way a branch will go, improving the flow in the instruction pipeline. The circuit/computer predicts the next step and executes it.</source>
          <target state="translated">分支预测器是一个数字电路(在计算机结构中),试图预测一个分支将走哪条路,改善指令流水线中的流程。电路计算机预测下一步,并执行它。</target>
        </trans-unit>
        <trans-unit id="b7d588a1c5460542b96d8b0baf1bab136cf8c2f6" translate="yes" xml:space="preserve">
          <source>The code is summing up some independent terms, so the order should not matter.</source>
          <target state="translated">代码是对一些独立术语的总结,所以顺序应该不重要。</target>
        </trans-unit>
        <trans-unit id="861f94790ecfa967155e62be104ac537e52a5f3a" translate="yes" xml:space="preserve">
          <source>The condition testing field and the optional &quot;set status bit&quot; field can be combined, for example:</source>
          <target state="translated">例如,条件测试字段和可选的 &quot;设置状态位 &quot;字段可以结合起来。</target>
        </trans-unit>
        <trans-unit id="6fc938b02ae6f7028fe10706590f459d70027752" translate="yes" xml:space="preserve">
          <source>The example contains three instructions and the first one is a conditional jump instruction. The latter two instructions can go into the pipeline until the conditional jump instruction is executed.</source>
          <target state="translated">本例包含三条指令,前一条是条件跳转指令。后两条指令可以进入流水线,直到条件跳转指令被执行为止。</target>
        </trans-unit>
        <trans-unit id="366e9cefdfc7cf84268b4baae54481cba492ad51" translate="yes" xml:space="preserve">
          <source>The first thing we need to know is what is &lt;em&gt;small&lt;/em&gt;? While smaller is generally better, a rule of thumb is to stick to lookup tables that are &amp;lt;= 4096 bytes in size. As an upper limit: if your lookup table is larger than 64K it's probably worth reconsidering.</source>
          <target state="translated">我们需要知道的第一件事是&lt;em&gt;小的&lt;/em&gt; ？ 虽然通常较小会更好，但经验法则是坚持使用&amp;lt;= 4096字节大小的查找表。 作为上限：如果您的查找表大于64K，则可能值得重新考虑。</target>
        </trans-unit>
        <trans-unit id="6ba638444517f57a3c3d8cf6edb54711b632d388" translate="yes" xml:space="preserve">
          <source>The following code does not sort the entire array, but only 200-element segments of it, and thereby runs the fastest.</source>
          <target state="translated">下面的代码不对整个数组进行排序,只对其中的200个元素段进行排序,因此运行速度最快。</target>
        </trans-unit>
        <trans-unit id="7983685e650d0c0a12e46c770cad6a3ca1107dcd" translate="yes" xml:space="preserve">
          <source>The inner loop for this algorithm would look something like the following in ARM assembly language:</source>
          <target state="translated">这个算法的内循环在ARM汇编语言中看起来像下面这样。</target>
        </trans-unit>
        <trans-unit id="28885d236427f0638d59b0c11dc0c5a23a6555c9" translate="yes" xml:space="preserve">
          <source>The link is here:
&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&lt;/a&gt;</source>
          <target state="translated">链接在这里： &lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;http&lt;/a&gt; : //www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm</target>
        </trans-unit>
        <trans-unit id="88c912641d7171878bede0b6532896dc83279c69" translate="yes" xml:space="preserve">
          <source>The performance of an &lt;code&gt;if&lt;/code&gt;-statement depends on whether its condition has a predictable pattern. If the condition is always true or always false, the branch prediction logic in the processor will pick up the pattern. On the other hand, if the pattern is unpredictable, the &lt;code&gt;if&lt;/code&gt;-statement will be much more expensive.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; 语句的性能取决于其条件是否具有可预测的模式。 如果条件始终为真或始终为假，则处理器中的分支预测逻辑将选择模式。 另一方面，如果模式是不可预测的，则 &lt;code&gt;if&lt;/code&gt; 语句将更加昂贵。</target>
        </trans-unit>
        <trans-unit id="f012bd762d6379e8ee89682917865e46bdb77c96" translate="yes" xml:space="preserve">
          <source>The question is: What makes the above statement not execute in certain cases as in case of sorted data? Here comes the &quot;branch predictor&quot;. A branch predictor is a digital circuit that tries to guess which way a branch (e.g. an &lt;code&gt;if-then-else&lt;/code&gt; structure) will go before this is known for sure. The purpose of the branch predictor is to improve the flow in the instruction pipeline. Branch predictors play a critical role in achieving high effective performance!</source>
          <target state="translated">问题是：是什么使上述语句在某些情况下（如已排序的数据）无法执行？ 这是&amp;ldquo;分支预测器&amp;rdquo;。 分支预测器是一种数字电路，它试图猜测在确定之前知道分支（例如， &lt;code&gt;if-then-else&lt;/code&gt; 结构）将走哪条路。 分支预测器的目的是改善指令管道中的流程。 分支预测变量在实现高效能方面起着至关重要的作用！</target>
        </trans-unit>
        <trans-unit id="23c9a538a1ef4688c167a88337fa568b94155241" translate="yes" xml:space="preserve">
          <source>The reason why performance improves drastically when the data is sorted is that the branch prediction penalty is removed, as explained beautifully in &lt;a href=&quot;https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902&quot;&gt;Mysticial's answer&lt;/a&gt;.</source>
          <target state="translated">当对数据进行排序时，性能大幅提高的原因是，消除了分支预测损失，如&lt;a href=&quot;https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902&quot;&gt;Mysticial的答案&lt;/a&gt;中详细解释的那样。</target>
        </trans-unit>
        <trans-unit id="243cce3d654c2e7e3d82b9ec0fc8b02ca07456a2" translate="yes" xml:space="preserve">
          <source>The result is robust in multiple tests. We get a great speedup when the branch result is unpredictable, but we suffer a little bit when it is predictable. In fact, when using a conditional move, the performance is the same regardless of the data pattern.</source>
          <target state="translated">在多次测试中,结果是稳健的。当分支结果不可预测时,我们得到了很大的提速,但当分支结果是可预测的时候,我们就有点吃亏了。事实上,在使用条件移动时,无论数据模式如何,性能都是一样的。</target>
        </trans-unit>
        <trans-unit id="8b2b071beeb1c27797d622cdfe18d46550e595b8" translate="yes" xml:space="preserve">
          <source>The results for the above MATLAB code are as follows:</source>
          <target state="translated">上述MATLAB代码的结果如下。</target>
        </trans-unit>
        <trans-unit id="4c621c1518421a4f9a5e82a55048d9d384c6117a" translate="yes" xml:space="preserve">
          <source>The results of the C code as in @GManNickG I get:</source>
          <target state="translated">C代码的结果如@GManNickG我得到的结果。</target>
        </trans-unit>
        <trans-unit id="c51e81726485eb1f77e86bce9119907916de64b6" translate="yes" xml:space="preserve">
          <source>The technique of indexing into an array, instead of using an &lt;code&gt;if&lt;/code&gt; statement, can be used for deciding which pointer to use.  I saw a library that implemented binary trees, and instead of having two named pointers (&lt;code&gt;pLeft&lt;/code&gt; and &lt;code&gt;pRight&lt;/code&gt; or whatever) had a length-2 array of pointers and used the &quot;decision bit&quot; technique to decide which one to follow.  For example, instead of:</source>
          <target state="translated">可以使用索引到数组的技术（而不使用 &lt;code&gt;if&lt;/code&gt; 语句）来确定要使用的指针。 我看到了一个实现二叉树的库，它没有两个命名的指针（ &lt;code&gt;pLeft&lt;/code&gt; 和 &lt;code&gt;pRight&lt;/code&gt; 或其他）， 而是一个长度为2的指针数组，并使用&amp;ldquo;决策位&amp;rdquo;技术来决定遵循哪个。 例如，代替：</target>
        </trans-unit>
        <trans-unit id="dfc876aaa5431ea7d4210f0979641e4dbe4d96a9" translate="yes" xml:space="preserve">
          <source>The technique of indexing into an array, instead of using an if statement, can be used for deciding which pointer to use. I saw a library that implemented binary trees, and instead of having two named pointers (pLeft and pRight or whatever) had a length-2 array of pointers and used the &quot;decision bit&quot; technique to decide which one to follow. For example, instead of:</source>
          <target state="translated">索引到数组中的技术,而不是使用if语句,可以用来决定使用哪个指针。我看到过一个实现二进制树的库,它没有两个命名的指针(pLeft和pRight什么的),而是有一个长度为2的指针数组,并使用 &quot;决定位 &quot;技术来决定哪一个指针。比如说,用 &quot;决定位 &quot;技术决定哪一个。</target>
        </trans-unit>
        <trans-unit id="b6cfe976487000bd1e4d79b8ceec46016b036b7e" translate="yes" xml:space="preserve">
          <source>The time that is wasted in case of a branch misprediction is equal to
  the number of stages in the pipeline from the fetch stage to the
  execute stage. Modern microprocessors tend to have quite long
  pipelines so that the misprediction delay is between 10 and 20 clock
  cycles. As a result, making a pipeline longer increases the need for a
  more advanced branch predictor.</source>
          <target state="translated">在分支误报的情况下,浪费的时间等于管道中从获取阶段到执行阶段的阶段数。现代微处理器往往有相当长的流水线,因此误判延迟在10到20个时钟周期之间。因此,使流水线变长会增加对更高级的分支预测器的需求。</target>
        </trans-unit>
        <trans-unit id="146d532a4e98e5f647a42caf674908e8ad82de98" translate="yes" xml:space="preserve">
          <source>Then, you can see that the &lt;code&gt;if&lt;/code&gt; conditional is constant throughout the execution of the &lt;code&gt;i&lt;/code&gt; loop, so you can hoist the &lt;code&gt;if&lt;/code&gt; out:</source>
          <target state="translated">然后，您可以看到 &lt;code&gt;if&lt;/code&gt; 条件在整个 &lt;code&gt;i&lt;/code&gt; 循环执行期间是恒定的，因此可以将 &lt;code&gt;if&lt;/code&gt; 提升：</target>
        </trans-unit>
        <trans-unit id="e5bc19f51ab3899c2bcbdd21013a0f3ed4bf7a2d" translate="yes" xml:space="preserve">
          <source>Then, you see that the inner loop can be collapsed into one single expression, assuming the floating point model allows it (&lt;code&gt;/fp:fast&lt;/code&gt; is thrown, for example)</source>
          <target state="translated">然后，您将看到内部循环可以折叠为一个表达式，并假设浮点模型允许它（例如，抛出 &lt;code&gt;/fp:fast&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="0fdbaf8dd82a2699c782cb69604fae05291b1fe4" translate="yes" xml:space="preserve">
          <source>There has been quite some work on eliminating this branch for managed languages. For example:</source>
          <target state="translated">在消除管理语言的这个分支方面,已经做了不少工作。例如:</target>
        </trans-unit>
        <trans-unit id="7b8c8145d6acbc5bd1d7476826d81337b7799153" translate="yes" xml:space="preserve">
          <source>There really are three different kinds of branches:</source>
          <target state="translated">真的有三种不同的分支。</target>
        </trans-unit>
        <trans-unit id="df08e2eb1f25b5e02231e29ab5a1fabee4d43dce" translate="yes" xml:space="preserve">
          <source>This also &quot;proves&quot; that it has nothing to do with any algorithmic issue such as sort order, and it is indeed branch prediction.</source>
          <target state="translated">这也 &quot;证明 &quot;了它与排序等任何算法问题无关,确实是分支预测。</target>
        </trans-unit>
        <trans-unit id="5f5f7d59641cd2d4e5ccd00f97168241ae614777" translate="yes" xml:space="preserve">
          <source>This approach works in general if:</source>
          <target state="translated">这种方法一般来说是可行的,如果:</target>
        </trans-unit>
        <trans-unit id="157ae22157daa30935359fff59ce72e0d87c83f4" translate="yes" xml:space="preserve">
          <source>This code is far from optimal. The branches may take a long time in case of mispredictions. The Boolean operations can be made much more efficient if it is known with certainty that the operands have no other values than &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. The reason why the compiler does not make such an assumption is that the variables might have other values if they are uninitialized or come from unknown sources. The above code can be optimized if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has been initialized to valid values or if they come from operators that produce Boolean output. The optimized code looks like this:</source>
          <target state="translated">此代码远非最佳。 万一发生预测错误，分支机构可能会花费很长时间。 如果可以肯定地知道操作数除 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt; 之外没有其他值，则布尔运算可以更加高效。 编译器没有做出这样的假设的原因是，如果变量未初始化或来自未知源，则它们可能具有其他值。 如果 &lt;code&gt;a&lt;/code&gt; 和 &lt;code&gt;b&lt;/code&gt; 已被初始化为有效值，或者它们来自产生布尔输出的运算符，则可以优化上述代码。 优化的代码如下所示：</target>
        </trans-unit>
        <trans-unit id="ad588604ed82a4498c092e23d01a6024f6fd9f5a" translate="yes" xml:space="preserve">
          <source>This code wastes half of the adds but never has a branch prediction failure. It's tremendously faster on random data than the version with an actual if statement.</source>
          <target state="translated">这个代码浪费了一半的加法,但从未出现过分支预测失败。它在随机数据上的速度非常快,比有实际if语句的版本快得多。</target>
        </trans-unit>
        <trans-unit id="a15071f65ca5442561d11637a382876b2bbe52fb" translate="yes" xml:space="preserve">
          <source>This eliminates the branch and replaces it with some bitwise operations.</source>
          <target state="translated">这样就取消了分支,取而代之的是一些bitwise操作。</target>
        </trans-unit>
        <trans-unit id="bfca5608e058cd556c4ac52b23258add44c52119" translate="yes" xml:space="preserve">
          <source>This goes to show that even mature modern compilers can vary wildly in their ability to optimize code...</source>
          <target state="translated">这说明,即使是成熟的现代编译器,其优化代码的能力也会有很大的差异......</target>
        </trans-unit>
        <trans-unit id="18e2896e8160beec33e159c94bd6ee44deed00cc" translate="yes" xml:space="preserve">
          <source>This is branch prediction. I admit it's not the best analogy since the train could just signal the direction with a flag. But in computers, the processor doesn't know which direction a branch will go until the last moment.</source>
          <target state="translated">这就是分支预测。我承认这不是最好的比喻,因为火车可以直接用旗子发出方向信号。但在计算机中,处理器直到最后一刻才知道一个分支会去哪个方向。</target>
        </trans-unit>
        <trans-unit id="d0c1d7a998794d7121446abef39a77def740f803" translate="yes" xml:space="preserve">
          <source>This is typically implemented by the compiler in the following way:</source>
          <target state="translated">这通常是由编译器以下列方式实现的:</target>
        </trans-unit>
        <trans-unit id="2bfa3272ab37710c1267a39900a9e349042c88c7" translate="yes" xml:space="preserve">
          <source>This is very friendly to the branch predictor since the branch consecutively goes the same direction many times. Even a simple saturating counter will correctly predict the branch except for the few iterations after it switches direction.</source>
          <target state="translated">这对分支预测器非常友好,因为分支连续多次走同一个方向。即使是一个简单的饱和计数器也能正确预测分支,除了在分支变换方向后的几次迭代之外。</target>
        </trans-unit>
        <trans-unit id="615c711dbe5df7298f33242a06d07ca902c32379" translate="yes" xml:space="preserve">
          <source>This lets you easily identify the problematic line - in the unsorted version the &lt;code&gt;if (data[c] &amp;gt;= 128)&lt;/code&gt; line is causing 164,050,007 mispredicted conditional branches (&lt;code&gt;Bcm&lt;/code&gt;) under cachegrind's branch-predictor model, whereas it's only causing 10,006 in the sorted version.</source>
          <target state="translated">这使您可以轻松地确定问题行-在未排序版本中， &lt;code&gt;if (data[c] &amp;gt;= 128)&lt;/code&gt; 行在cachegrind的branch-predictor模型下导致164,050,007错误预测的条件分支（ &lt;code&gt;Bcm&lt;/code&gt; ），而在排序版本中仅导致10,006 。</target>
        </trans-unit>
        <trans-unit id="62a8acf06dc12988abe140d1d1ffb08120df1a06" translate="yes" xml:space="preserve">
          <source>This question has already been answered excellently many times over. Still I'd like to draw the group's attention to yet another interesting analysis.</source>
          <target state="translated">这个问题已经多次得到了很好的回答。但我还是想提请大家注意另一个有趣的分析。</target>
        </trans-unit>
        <trans-unit id="7ab809ea371604dfeb3647ba6b30215c1eb2398d" translate="yes" xml:space="preserve">
          <source>This question is rooted in Branch Prediction Models on CPUs. I'd recommend reading this paper:</source>
          <target state="translated">这个问题的根源在于CPU上的分支预测模型。我推荐阅读这篇论文。</target>
        </trans-unit>
        <trans-unit id="bda231ceb9d58c33b0e891be602a5fde29542e65" translate="yes" xml:space="preserve">
          <source>To execute instruction B or instruction C the processor will have to wait till the instruction A doesn't reach till EX stage in the pipeline, as the decision to go to instruction B or instruction C depends on the result of instruction A. So the pipeline will look like this.</source>
          <target state="translated">为了执行指令B或指令C,处理器必须等待指令A在流水线中直到指令A到达EX阶段才会执行,因为转到指令B或指令C的决定取决于指令A的结果。</target>
        </trans-unit>
        <trans-unit id="0b7e892117417fb4b6c49ca103d227fc9f4d1140" translate="yes" xml:space="preserve">
          <source>To understand branch prediction one must first understand &lt;strong&gt;Instruction Pipeline&lt;/strong&gt;:</source>
          <target state="translated">要了解分支预测，首先必须了解&lt;strong&gt;指令流水线&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="a29c68a2d5e91d86d31480109b1da5bc8e35f407" translate="yes" xml:space="preserve">
          <source>Two-way branching is usually implemented with a conditional jump
  instruction. A conditional jump can either be &quot;not taken&quot; and continue
  execution with the first branch of code which follows immediately
  after the conditional jump, or it can be &quot;taken&quot; and jump to a
  different place in program memory where the second branch of code is
  stored. It is not known for certain whether a conditional jump will be
  taken or not taken until the condition has been calculated and the
  conditional jump has passed the execution stage in the instruction
  pipeline (see fig. 1).</source>
          <target state="translated">双向分支通常用条件跳转指令来实现。条件跳转既可以 &quot;不采取&quot;,继续执行紧随条件跳转之后的第一个分支代码,也可以 &quot;采取&quot;,跳转到程序内存中存储第二个分支代码的不同位置。在计算出条件跳转后,条件跳转通过指令流水线中的执行阶段之前,是不能确定是否采取或不采取的(见图1)。</target>
        </trans-unit>
        <trans-unit id="dcb1d0bc5503faffa53fc3453598b0d035a0c897" translate="yes" xml:space="preserve">
          <source>Unsorted Array: Curved Road</source>
          <target state="translated">未分类阵列。弧形路</target>
        </trans-unit>
        <trans-unit id="c006e2b20060032caaabd451e6df6a02a78a5ac3" translate="yes" xml:space="preserve">
          <source>Use Branch Predictor and don't take a conditional jump. Let's assume that the predict is &lt;strong&gt;not&lt;/strong&gt; taking the conditional jump.</source>
          <target state="translated">使用Branch Predictor，不要进行条件跳转。 让我们假设预测&lt;strong&gt;没有&lt;/strong&gt;采取条件转移。</target>
        </trans-unit>
        <trans-unit id="12c9166e85e51c6ec14fc60d80a7a0f3c7c32568" translate="yes" xml:space="preserve">
          <source>Use Branch Predictor and take a conditional jump. Let's assume that the predict is &lt;strong&gt;not&lt;/strong&gt; taking the conditional jump.</source>
          <target state="translated">使用Branch Predictor并进行条件跳转。 让我们假设预测&lt;strong&gt;没有&lt;/strong&gt;采取条件转移。</target>
        </trans-unit>
        <trans-unit id="a08965e116be4f8dd9b991b5c78c2f2a4953805f" translate="yes" xml:space="preserve">
          <source>Using bitwise operators is more advantageous if the operands are variables than if the operands are comparisons:</source>
          <target state="translated">如果操作项是变量,使用位运算符比使用比较运算符更有利。</target>
        </trans-unit>
        <trans-unit id="753325de5864d63921392f6d1fdfec25be2f1719" translate="yes" xml:space="preserve">
          <source>VC++ 2010 is unable to generate conditional moves for this branch even under &lt;code&gt;/Ox&lt;/code&gt;.</source>
          <target state="translated">即使在 &lt;code&gt;/Ox&lt;/code&gt; 下，VC ++ 2010也无法为此分支生成条件移动。</target>
        </trans-unit>
        <trans-unit id="d043004e185c7b0efa7dc62df9e481517f2fae51" translate="yes" xml:space="preserve">
          <source>Visualization:</source>
          <target state="translated">Visualization:</target>
        </trans-unit>
        <trans-unit id="a3b2fe94f4750042ee509a40cd1b811c02dcc827" translate="yes" xml:space="preserve">
          <source>WB -- Write back to CPU register</source>
          <target state="translated">WB --写回CPU寄存器</target>
        </trans-unit>
        <trans-unit id="6375cff5f915d0ad5739238963ce456b2a75e8c2" translate="yes" xml:space="preserve">
          <source>Well, not exactly... :-)</source>
          <target state="translated">嗯,不完全是....)</target>
        </trans-unit>
        <trans-unit id="a608d088fa8295119cc45125ae05fa9e8da0660e" translate="yes" xml:space="preserve">
          <source>What is Branch Prediction?</source>
          <target state="translated">什么是分支预测?</target>
        </trans-unit>
        <trans-unit id="ddc44bd3685ad0a82e462b5b7860aa861536395a" translate="yes" xml:space="preserve">
          <source>What is going on?</source>
          <target state="translated">这是怎么了?</target>
        </trans-unit>
        <trans-unit id="5079282bb6ac8d8fd7800b70a515ca1a7779ded0" translate="yes" xml:space="preserve">
          <source>When you have sorted elements, IR could not be bothered to fetch all CPU instructions, again and again, It fetches them from cache.</source>
          <target state="translated">当你对元素进行了排序后,IR就无暇顾及所有的CPU指令,一遍又一遍,它从缓存中提取。</target>
        </trans-unit>
        <trans-unit id="93820c99e002586797e0fc268993184aa2c6be22" translate="yes" xml:space="preserve">
          <source>Whenever there's an &lt;code&gt;if-else&lt;/code&gt; \ &lt;code&gt;switch&lt;/code&gt; statement, the expression has to be evaluated to determine which block should be executed. In the assembly code generated by the compiler, conditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt; instructions are inserted.</source>
          <target state="translated">每当有 &lt;code&gt;if-else&lt;/code&gt; \ &lt;code&gt;switch&lt;/code&gt; 语句时，都必须对表达式进行求值以确定应该执行哪个块。 在编译器生成的汇编代码中，插入了条件&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;分支&lt;/a&gt;指令。</target>
        </trans-unit>
        <trans-unit id="467f5fe90dca59bcce184cb76b5258ae0f818f25" translate="yes" xml:space="preserve">
          <source>While flushing pipelines is super fast, nowadays taking this gamble is worth it. Predicting sorted data or a data that changes slowly is always easier and better than predicting fast changes.</source>
          <target state="translated">虽然冲洗管道是超级快的,但如今拿这个赌注是值得的。[...]</target>
        </trans-unit>
        <trans-unit id="7a096e98f70b03605f1fd87dee197c0e0dc2d954" translate="yes" xml:space="preserve">
          <source>While maintaining readability, we can check the speedup factor.</source>
          <target state="translated">在保持可读性的同时,我们可以检查一下加速系数。</target>
        </trans-unit>
        <trans-unit id="9792cdf86b1977e88d80d53a5f46d6bb5efa646c" translate="yes" xml:space="preserve">
          <source>Why is processing a sorted array faster than processing an unsorted array</source>
          <target state="translated">为什么处理排序数组比处理无排序数组要快?</target>
        </trans-unit>
        <trans-unit id="0ecd9604afd7fdf56bd91ee7561b152cde1f8ed3" translate="yes" xml:space="preserve">
          <source>Why is processing a sorted array faster than processing an unsorted array?</source>
          <target state="translated">为什么处理一个已排序数组比处理一个未排序数组要快?</target>
        </trans-unit>
        <trans-unit id="45e27afeaa62cf0cccdd3110fde02e47401ff594" translate="yes" xml:space="preserve">
          <source>With a similar but less extreme result.</source>
          <target state="translated">有了类似但不那么极端的结果。</target>
        </trans-unit>
        <trans-unit id="00bb7f0f6f10727b9d3a497aec7ad500fc1da108" translate="yes" xml:space="preserve">
          <source>With a sorted array, the condition &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; is first &lt;code&gt;false&lt;/code&gt; for a streak of values, then becomes &lt;code&gt;true&lt;/code&gt; for all later values. That's easy to predict. With an unsorted array, you pay for the branching cost.</source>
          <target state="translated">对于排序数组，条件 &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; 对于值的条纹首先为 &lt;code&gt;false&lt;/code&gt; ，然后对于所有后续值变为 &lt;code&gt;true&lt;/code&gt; 。 这很容易预测。 使用未排序的数组，您需要支付分支成本。</target>
        </trans-unit>
        <trans-unit id="9e8a52af2265d491577ac667e610164d2bae82ec" translate="yes" xml:space="preserve">
          <source>With loop interchange, we can safely change this loop to:</source>
          <target state="translated">有了循环互换,我们可以放心地把这个循环改成。</target>
        </trans-unit>
        <trans-unit id="b07d7d0e763b2a76e028689779bd9793c81728e8" translate="yes" xml:space="preserve">
          <source>With the sorted data, the code runs in 1.93 seconds.</source>
          <target state="translated">通过排序数据,代码运行时间为1.93秒。</target>
        </trans-unit>
        <trans-unit id="cdf4ffa875649aacf9a2112d2448609655f91aec" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;std::sort(data, data + arraySize);&lt;/code&gt;, the code runs in 11.54 seconds.</source>
          <target state="translated">没有 &lt;code&gt;std::sort(data, data + arraySize);&lt;/code&gt; ，代码将在11.54秒内运行。</target>
        </trans-unit>
        <trans-unit id="f595b01765d8ae905ea5e9dd7e62d7a02b4fbe22" translate="yes" xml:space="preserve">
          <source>Without branch prediction, the following would occur:</source>
          <target state="translated">如果没有分支预测,会出现以下情况:</target>
        </trans-unit>
        <trans-unit id="b4764b924495da3570f6397640729704193386e0" translate="yes" xml:space="preserve">
          <source>Without branch prediction, the processor would have to wait until the
  conditional jump instruction has passed the execute stage before the
  next instruction can enter the fetch stage in the pipeline.</source>
          <target state="translated">在没有分支预测的情况下,处理器必须等待条件跳转指令通过执行阶段后,才能进入下一条指令在流水线中的取值阶段。</target>
        </trans-unit>
        <trans-unit id="8fa9477c95d3ffecec4695db62b573324832754a" translate="yes" xml:space="preserve">
          <source>Without the Branch Predictor.</source>
          <target state="translated">没有分支预测器的情况下。</target>
        </trans-unit>
        <trans-unit id="0dee180d4b195226d6d709eb16ec0e42b8a820e7" translate="yes" xml:space="preserve">
          <source>You are a processor and you see a branch. You have no idea which way it will go. What do you do? You halt execution and wait until the previous instructions are complete. Then you continue down the correct path.</source>
          <target state="translated">你是一个处理者,你看到一个分支。你不知道它会往哪个方向走。你要做什么?你停止执行,等待前面的指令完成。然后,你继续沿着正确的路径走下去。</target>
        </trans-unit>
        <trans-unit id="3747acc12d9a8b4eeed31b6769fc516a8c97c9dd" translate="yes" xml:space="preserve">
          <source>You are the operator of a junction and you hear a train coming. You have no idea which way it is supposed to go. You stop the train to ask the driver which direction they want. And then you set the switch appropriately.</source>
          <target state="translated">你是一个路口的经营者,你听到有火车来了,你不知道它应该往哪个方向走。你不知道它应该往哪个方向走。你把火车停下来,问司机他们想往哪个方向走。然后你再适当的设置一下开关。</target>
        </trans-unit>
        <trans-unit id="a55200fca28b7f0ac1706d86d79e8114433a8b42" translate="yes" xml:space="preserve">
          <source>You can also see from this lovely &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor#/media/File:Branch_prediction_2bit_saturating_counter-dia.svg&quot;&gt;diagram&lt;/a&gt; why the branch predictor gets confused.</source>
          <target state="translated">您还可以从这张可爱的&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor#/media/File:Branch_prediction_2bit_saturating_counter-dia.svg&quot;&gt;图表中&lt;/a&gt;看到分支预测变量为何会感到困惑。</target>
        </trans-unit>
        <trans-unit id="33b05101ba2f17cb142e08e195f5e37dbb2cf22d" translate="yes" xml:space="preserve">
          <source>You can have a stop condition instead of just checking the value, this way you only loop over the relevant data, and ignore the rest.</source>
          <target state="translated">你可以有一个停止条件,而不是只检查值,这样你只循环相关的数据,而忽略了其他的数据。</target>
        </trans-unit>
        <trans-unit id="e7cdaed049a36de91bc0b6220dbae638a556dd97" translate="yes" xml:space="preserve">
          <source>You might wonder why this works well in managed languages. After all, managed languages check the boundaries of the arrays with a branch to ensure you don't mess up...</source>
          <target state="translated">你可能会想知道,为什么这在托管语言中效果很好。毕竟,管理型语言会用分支检查数组的边界,以确保你不会搞砸。</target>
        </trans-unit>
        <trans-unit id="f6967173a58337d24e84af6ae18adb3fbbae9e11" translate="yes" xml:space="preserve">
          <source>can be optimized to:</source>
          <target state="translated">可以优化为:</target>
        </trans-unit>
        <trans-unit id="576ab25730c6c8fde51cea0123c6a7dd40910123" translate="yes" xml:space="preserve">
          <source>is optimal in most cases (unless you expect the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; expression to generate many branch mispredictions).</source>
          <target state="translated">在大多数情况下是最佳选择（除非您期望 &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 表达式会产生许多分支错误预测）。</target>
        </trans-unit>
        <trans-unit id="a45d05b730bbc58dc46e14dafb3c0d1d4583c878" translate="yes" xml:space="preserve">
          <source>it's a nice solution maybe it will work</source>
          <target state="translated">这是个好办法,也许能行得通</target>
        </trans-unit>
        <trans-unit id="c3bfc02b43a0aa6f110706cfedc26e042e2f304a" translate="yes" xml:space="preserve">
          <source>it's a small table and is likely to be cached in the processor, and</source>
          <target state="translated">它是一个小表,很可能被缓存在处理器中,而</target>
        </trans-unit>
        <trans-unit id="651a852c52cc01c89e5ea1bd7793b4460d1de61f" translate="yes" xml:space="preserve">
          <source>or similarly:</source>
          <target state="translated">或类似。</target>
        </trans-unit>
        <trans-unit id="495520e358c6efe36183f5f5cfdfb1a5f7540a8b" translate="yes" xml:space="preserve">
          <source>or, slightly more obfuscated</source>
          <target state="translated">或者说,略显含糊</target>
        </trans-unit>
        <trans-unit id="f11d2b737879c47db5e53479b4f6bb83db8e1df9" translate="yes" xml:space="preserve">
          <source>so the predictor will change sides as the &lt;code&gt;std::rand()&lt;/code&gt; blow.</source>
          <target state="translated">因此，随着 &lt;code&gt;std::rand()&lt;/code&gt; 打击，预测变量将改变方向。</target>
        </trans-unit>
        <trans-unit id="0234c36fd5c76bfa6dcd2e321618d03cb21418f9" translate="yes" xml:space="preserve">
          <source>this library would do something like:</source>
          <target state="translated">这个图书馆会做这样的事情:</target>
        </trans-unit>
        <trans-unit id="46ebea860b14c6c60e10f66281ac11838db11fdf" translate="yes" xml:space="preserve">
          <source>we can find that the meaning of this particular &lt;code&gt;if... else...&lt;/code&gt; branch is to add something when a condition is satisfied. This type of branch can be easily transformed into a &lt;strong&gt;conditional move&lt;/strong&gt; statement, which would be compiled into a conditional move instruction: &lt;code&gt;cmovl&lt;/code&gt;, in an &lt;code&gt;x86&lt;/code&gt; system. The branch and thus the potential branch prediction penalty is removed.</source>
          <target state="translated">我们可以发现， &lt;code&gt;if... else...&lt;/code&gt; 分支的特定含义是在满足条件时添加一些内容。 这种类型的分支可以轻松地转换为&lt;strong&gt;条件移动&lt;/strong&gt;语句，该&lt;strong&gt;条件&lt;/strong&gt;语句将被编译为条件移动指令：在 &lt;code&gt;x86&lt;/code&gt; 系统中为 &lt;code&gt;cmovl&lt;/code&gt; 。 去除分支并因此去除潜在的分支预测损失。</target>
        </trans-unit>
        <trans-unit id="52e0612303b39c0691e807b9c7a297fa35003367" translate="yes" xml:space="preserve">
          <source>with:</source>
          <target state="translated">with:</target>
        </trans-unit>
        <trans-unit id="4e59d494e29779b82beb957429950a6c38d3846b" translate="yes" xml:space="preserve">
          <source>you are running things in a quite tight loop and/or the processor can preload the data.</source>
          <target state="translated">你在一个相当紧密的循环中运行,或者处理器可以预加载数据。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
