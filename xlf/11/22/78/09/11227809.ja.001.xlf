<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/11227809">
    <body>
      <group id="11227809">
        <trans-unit id="b53667fac1b1818f469635cd98c1992443873e79" translate="yes" xml:space="preserve">
          <source>(Or somewhat fast: for the already-sorted case, &lt;code&gt;cmov&lt;/code&gt; can be slower especially if GCC puts it on the critical path instead of just &lt;code&gt;add&lt;/code&gt;, especially on Intel before Broadwell where &lt;code&gt;cmov&lt;/code&gt; has 2 cycle latency: &lt;a href=&quot;https://stackoverflow.com/questions/28875325/gcc-optimization-flag-o3-makes-code-slower-than-o2&quot;&gt;gcc optimization flag -O3 makes code slower than -O2&lt;/a&gt;)</source>
          <target state="translated">（または多少高速：すでにソートされている場合、特に &lt;code&gt;cmov&lt;/code&gt; が &lt;code&gt;add&lt;/code&gt; の代わりにクリティカルパスに置く場合、特に &lt;code&gt;cmov&lt;/code&gt; に2サイクルのレイテンシがあるBroadwellの前のIntelの場合： &lt;a href=&quot;https://stackoverflow.com/questions/28875325/gcc-optimization-flag-o3-makes-code-slower-than-o2&quot;&gt;gcc最適化フラグ-O3はコードを遅くします-O2より&lt;/a&gt; ）</target>
        </trans-unit>
        <trans-unit id="d1ea744eaff022b9ec4d3d58be32b719619a16de" translate="yes" xml:space="preserve">
          <source>// Declare and then fill in the lookup table</source>
          <target state="translated">/宣言してから、ルックアップテーブルに記入してください。</target>
        </trans-unit>
        <trans-unit id="439750f5cd724a86cdb0b90f611fcdf4d601b584" translate="yes" xml:space="preserve">
          <source>// Test</source>
          <target state="translated">/テスト</target>
        </trans-unit>
        <trans-unit id="22e070d61d4ac5f3e0981ca4d20241ae99b358d3" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler&quot;&gt;Intel C++ Compiler&lt;/a&gt; (ICC) 11 does something miraculous. It &lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_interchange&quot;&gt;interchanges the two loops&lt;/a&gt;, thereby hoisting the unpredictable branch to the outer loop. So not only is it immune to the mispredictions, it is also twice as fast as whatever VC++ and GCC can generate! In other words, ICC took advantage of the test-loop to defeat the benchmark...</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Intel_C%2B%2B_Compiler&quot;&gt;Intel C ++ Compiler&lt;/a&gt; （ICC）11は奇跡的なことをします。 &lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_interchange&quot;&gt;2つのループを交換して&lt;/a&gt; 、予測できない分岐を外側のループに巻き上げます。 そのため、予測ミスの影響を受けないだけでなく、VC ++とGCCが生成できるものの2倍の速さになります。 言い換えれば、ICCはテストループを利用してベンチマークを打ち破りました...</target>
        </trans-unit>
        <trans-unit id="637937a9b16b61115d58b45cd478f01d51765e8a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADD R1, R2, R3&lt;/code&gt; performs &lt;code&gt;R1 = R2 + R3&lt;/code&gt; without updating any status bits.</source>
          <target state="translated">&lt;code&gt;ADD R1, R2, R3&lt;/code&gt; は、ステータスビットを更新せずに &lt;code&gt;R1 = R2 + R3&lt;/code&gt; を実行します。</target>
        </trans-unit>
        <trans-unit id="87d9034703b27f8b1421db3174bb0a89354e4fdd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDGE R1, R2, R3&lt;/code&gt; performs the same operation only if a previous instruction that affected the status bits resulted in a Greater than or Equal condition.</source>
          <target state="translated">&lt;code&gt;ADDGE R1, R2, R3&lt;/code&gt; は、ステータスビットに影響を与える前の命令が「より大きい」または「等しい」条件になった場合にのみ、同じ操作を実行します。</target>
        </trans-unit>
        <trans-unit id="23f6fd5b0c8ae0b7004305abd5527096f2e1cd0b" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDS R1, R2, R3&lt;/code&gt; performs the addition and then updates the &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;Z&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; flags in the Processor Status Register based on whether the result was Negative, Zero, Carried (for unsigned addition), or oVerflowed (for signed addition).</source>
          <target state="translated">&lt;code&gt;ADDS R1, R2, R3&lt;/code&gt; は加算を実行し、結果が負、ゼロ、キャリー（符号なし加算の場合）、またはoVerflowed（符号付き加算の場合）に基づいて、プロセッサステータスレジスタの &lt;code&gt;N&lt;/code&gt; 、 &lt;code&gt;Z&lt;/code&gt; 、 &lt;code&gt;C&lt;/code&gt; および &lt;code&gt;V&lt;/code&gt; フラグを更新します。 。</target>
        </trans-unit>
        <trans-unit id="9dc9f762599510b8def52bb6b16ab86d5b605418" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;ADDSGE R1, R2, R3&lt;/code&gt; performs the addition only if the &lt;code&gt;GE&lt;/code&gt; test is true, and then subsequently updates the status bits based on the result of the addition.</source>
          <target state="translated">&lt;code&gt;ADDSGE R1, R2, R3&lt;/code&gt; は、 &lt;code&gt;GE&lt;/code&gt; テストが真の場合にのみ加算を実行し、その後、加算の結果に基づいてステータスビットを更新します。</target>
        </trans-unit>
        <trans-unit id="6c4200c52c77a8809e0c28b82431a4fcd7fb0319" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;CMP&lt;/code&gt; opcodes always update the status bits in the Processor Status Register (PSR), because that is their purpose, but most other instructions do not touch the PSR unless you add an optional &lt;code&gt;S&lt;/code&gt; suffix to the instruction, specifying that the PSR should be updated based on the result of the instruction. &lt;strong&gt;Just like the 4-bit condition suffix, being able to execute instructions without affecting the PSR is a mechanism that reduces the need for branches on ARM, and also facilitates out of order dispatch at the hardware level&lt;/strong&gt;, because after performing some operation X that updates the status bits, subsequently (or in parallel) you can do a bunch of other work that explicitly should not affect the status bits, then you can test the state of the status bits set earlier by X.</source>
          <target state="translated">&lt;code&gt;CMP&lt;/code&gt; オペコードは常に目的のため、プロセッサステータスレジスタ（PSR）のステータスビットを更新しますが、他のほとんどの命令は、オプションの &lt;code&gt;S&lt;/code&gt; サフィックスを命令に追加しない限り、PSRに影響を与えません。命令の結果について。 &lt;strong&gt;4ビットの条件サフィックスと同様に、PSRに影響を与えずに命令を実行できることは、ARMでの分岐の必要性を減らし、ハードウェアレベルでの順不同のディスパッチを容易にするメカニズムです。&lt;/strong&gt;ステータスビット、その後（または並行して）明示的にステータスビットに影響を与えない他の一連の作業を実行できます。その後、Xによって以前に設定されたステータスビットの状態をテストできます。</target>
        </trans-unit>
        <trans-unit id="391873c374a8ded8013438f8a2663a8948bf98aa" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; cannot be replaced with &lt;code&gt;a &amp;amp; b&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is an expression that should not be evaluated if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; will not evaluate &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt; will). Likewise, &lt;code&gt;a || b&lt;/code&gt; can not be replaced with &lt;code&gt;a | b&lt;/code&gt; if &lt;code&gt;b&lt;/code&gt; is an expression that should not be evaluated if &lt;code&gt;a&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a &amp;amp;&amp;amp; b&lt;/code&gt; は、 &lt;code&gt;a&lt;/code&gt; が &lt;code&gt;false&lt;/code&gt; の場合に評価されるべきでない式である場合、 &lt;code&gt;b&lt;/code&gt; &lt;code&gt;a &amp;amp; b&lt;/code&gt; 置き換えることはできません（ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; は &lt;code&gt;b&lt;/code&gt; を評価せず、 &lt;code&gt;&amp;amp;&lt;/code&gt; は評価されません）。 同様に &lt;code&gt;a || b&lt;/code&gt; bをaに置き換えることはできません &lt;code&gt;a | b&lt;/code&gt; bが 、 &lt;code&gt;b&lt;/code&gt; が &lt;code&gt;true&lt;/code&gt; の場合に評価されない式である場合 。</target>
        </trans-unit>
        <trans-unit id="3da7ae3851d0cb07b784c1504abb04501c97c690" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;char&lt;/code&gt; is used instead of &lt;code&gt;bool&lt;/code&gt; in order to make it possible to use the bitwise operators (&lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt;) instead of the Boolean operators (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt;). The bitwise operators are single instructions that take only one clock cycle. The OR operator (&lt;code&gt;|&lt;/code&gt;) works even if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have other values than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. The AND operator (&lt;code&gt;&amp;amp;&lt;/code&gt;) and the EXCLUSIVE OR operator (&lt;code&gt;^&lt;/code&gt;) may give inconsistent results if the operands have other values than &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">ブール演算子（ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; および &lt;code&gt;||&lt;/code&gt; ）の代わりにビット演算子（ &lt;code&gt;&amp;amp;&lt;/code&gt; および &lt;code&gt;|&lt;/code&gt; ）を使用できるようにするために、 &lt;code&gt;bool&lt;/code&gt; の代わりに &lt;code&gt;char&lt;/code&gt; が使用されています。 ビット演算子は、1クロックサイクルしかかからない単一の命令です。 OR演算子（ &lt;code&gt;|&lt;/code&gt; ） &lt;code&gt;a&lt;/code&gt; 、 &lt;code&gt;b&lt;/code&gt; およびbが &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;1&lt;/code&gt; 以外の値であっても機能します。 AND演算子（ &lt;code&gt;&amp;amp;&lt;/code&gt; ）とEXCLUSIVE OR演算子（ &lt;code&gt;^&lt;/code&gt; ）は、オペランドの値が &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;1&lt;/code&gt; 以外の場合、一貫性のない結果になる可能性があります。</target>
        </trans-unit>
        <trans-unit id="2116c486e51bc36c5ea4f4ea724a4decd73ddf80" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max1&lt;/code&gt; uses the conditional branch &lt;code&gt;if... else ...&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;max1&lt;/code&gt; は条件分岐を使用し &lt;code&gt;if... else ...&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="5c4a2ff8aabdb7de009ae921d3d149a4fd4a3981" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max2&lt;/code&gt; uses much less code due to the usage of instruction &lt;code&gt;cmovge&lt;/code&gt;. But the real gain is that &lt;code&gt;max2&lt;/code&gt; does not involve branch jumps, &lt;code&gt;jmp&lt;/code&gt;, which would have a significant performance penalty if the predicted result is not right.</source>
          <target state="translated">&lt;code&gt;max2&lt;/code&gt; は、命令 &lt;code&gt;cmovge&lt;/code&gt; を使用しているため、使用するコードがはるかに少なくなっています。 しかし、実際の &lt;code&gt;max2&lt;/code&gt; は、 max2が分岐ジャンプ &lt;code&gt;jmp&lt;/code&gt; を含まないことです。これは、予測された結果が正しくない場合、パフォーマンスが大幅に低下します。</target>
        </trans-unit>
        <trans-unit id="3a816aa9d54ebe21437fa8cb172a780bbab33269" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;max2&lt;/code&gt; uses the ternary operator &lt;code&gt;... ? ... : ...&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;max2&lt;/code&gt; は三項演算子を使用し &lt;code&gt;... ? ... : ...&lt;/code&gt; ...：... ：</target>
        </trans-unit>
        <trans-unit id="562cd5fce1e7b6dcbe296f9206498ac8e7ed271a" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;~&lt;/code&gt; can not be used for NOT. Instead, you can make a Boolean NOT on a variable which is known to be &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; by XOR'ing it with &lt;code&gt;1&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;~&lt;/code&gt; はNOTに使用できません。 代わりに、 &lt;code&gt;1&lt;/code&gt; でXORすることにより、 &lt;code&gt;0&lt;/code&gt; または1であることがわかっている変数にブールNOTを作成できます。</target>
        </trans-unit>
        <trans-unit id="86968cc91f6395ac3372778b6f3bd6927c8f9854" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;A Demonstration of Self-Profiling&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;自己プロファイリングのデモ&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="62a5257803ca2425233ddd03c4d7d207b6867e4a" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://courses.cs.washington.edu/courses/csep548/06au/lectures/branchPred.pdf&quot;&gt;Branch Prediction Review&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://courses.cs.washington.edu/courses/csep548/06au/lectures/branchPred.pdf&quot;&gt;分岐予測レビュー&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e83995c1786dac19461a4d31bc4d8b9cde96f71d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Branch predictor&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;分岐予測&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="17ca7e4d199635bbed9dd553888d82060ea8e587" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://stackoverflow.blog/2019/10/11/c-creator-bjarne-stroustrup-answers-our-top-five-c-questions/&quot;&gt;Bjarne Stroustrup's Answer&lt;/a&gt; to this question:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;この質問に対する&lt;a href=&quot;https://stackoverflow.blog/2019/10/11/c-creator-bjarne-stroustrup-answers-our-top-five-c-questions/&quot;&gt;Bjarne Stroustrupの回答&lt;/a&gt; ：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6999c55f1112ac2522394d373dcc92bf8ba35d17" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;a href=&quot;https://web.njit.edu/~rlopes/Mod5.3.pdf&quot;&gt;Branch Prediction&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://web.njit.edu/~rlopes/Mod5.3.pdf&quot;&gt;分岐予測&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e2567a75f2917b4cf19219547a29e45cd68bfc50" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Modern processors are complicated and have long pipelines. So they take forever to &quot;warm up&quot; and &quot;slow down&quot;.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;最近のプロセッサは複雑で、パイプラインが長いです。&lt;/em&gt; &lt;em&gt;したがって、彼らは「ウォームアップ」と「スローダウン」に永遠にかかります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2c4e8b34981c89b9e7eadedce54ab4bf99abb400" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Trains are heavy and have a lot of inertia. So they take forever to start up and slow down.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;列車は重く、慣性がたくさんあります。&lt;/em&gt; &lt;em&gt;そのため、起動と速度低下には永遠にかかります。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="3dfd2a9e0eebface4570f5726ff229d9f7239571" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Static&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.静的&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec921c20fc92beab445f0b65b62aac1dc30fda89" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Dynamic&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.ダイナミック&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7070b983b9e682ffd47dc61eb8173e377437895" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;4-stage pipeline in general for 2 instructions.&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;一般に2命令の4ステージパイプライン。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7c0dc2f57cc914145b6b0624cff97eb77959909" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;But this is actually part of a bigger picture:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;しかし、これは実際には全体像の一部です。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3a57d022fefdf1a6dc6fb7aff0b41a4c5a3d4191" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;In case of a correct guess, the pipeline looks something like this:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;正しい推測の場合、パイプラインは次のようになります。&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="059ec29570653df3139916923c59df324c15a8f6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;In other words, you try to identify a pattern and follow it.&lt;/em&gt;&lt;/strong&gt; This is more or less how branch predictors work.</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;言い換えれば、あなたはパターンを特定し、それに従うことを試みます。&lt;/em&gt;&lt;/strong&gt; これは多かれ少なかれ分岐予測子がどのように機能するかです。</target>
        </trans-unit>
        <trans-unit id="e2c23a7d4a1b5f910c13dc8dd8d34c2b4feb4d6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;When if condition returns false:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;if条件がfalseを返す場合：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4757bf44b2540d4c3544fbd8ed736018934b59c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;when if condition returns true:&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;if条件がtrueを返す場合：&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a145133a463629536767d61372777b3b15514477" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Background and why&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;背景と理由&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="03ac7fc31e2558f71e7c0316cacb5b6078717e4e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Backward conditional branches&lt;/strong&gt; - the PC is changed to point backward in the instruction stream. The branch is based on some condition, such as branching backwards to the beginning of a program loop when a test at the end of the loop states the loop should be executed again.</source>
          <target state="translated">&lt;strong&gt;後方条件付き分岐-PC&lt;/strong&gt;は、命令ストリームの後方を指すように変更されます。 分岐は、ループの最後のテストでループを再度実行する必要があると示されているときにプログラムループの先頭に逆方向に分岐するなど、いくつかの条件に基づいています。</target>
        </trans-unit>
        <trans-unit id="88725d83d10b621a1197929903db27ce4176d85e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Benchmarks: Core i7 920 @ 3.5 GHz&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ベンチマーク：Core i7 920 @ 3.5 GHz&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29e42a036c1d0c70cc19beaa407c40f6950cdef1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch prediction.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;分岐予測。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c55e466ed2fc88a1e76e953db7f49f1fd3730ab3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch prediction&lt;/strong&gt; makes the logic run slower, because of the switching which happens in your code! It's like you are going a straight street or a street with a lot of turnings, for sure the straight one is going to be done quicker!...</source>
          <target state="translated">コード内で発生する切り替えのため、 &lt;strong&gt;分岐予測&lt;/strong&gt;はロジックの実行を遅くします！ まっすぐな通りや曲がり角の多い通りに行っているようなものです。まっすぐな方が早く完了します。...</target>
        </trans-unit>
        <trans-unit id="d218041da74b681266dd3bc64ecbec4c36a29624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Branch-prediction gain!&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;分岐予測ゲイン！&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e98dec0bd0a7e8e2059d13e9a8c88d55b96ae930" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Consider an if-statement:&lt;/strong&gt; At the processor level, it is a branch instruction:</source>
          <target state="translated">&lt;strong&gt;ifステートメントについて考えてみましょう。&lt;/strong&gt;プロセッサレベルでは、これは分岐命令です。</target>
        </trans-unit>
        <trans-unit id="c1e69093a905a8b010540753c555aae1f8e36d3a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructing a table&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;テーブルの作成&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="130a0bfbd8fc444b6379d249ad5d24a0e69aaf6f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Forward conditional branches&lt;/strong&gt; - based on a run-time condition, the PC (program counter) is changed to point to an address forward in the instruction stream.</source>
          <target state="translated">&lt;strong&gt;条件分岐の転送&lt;/strong&gt; -ランタイム&lt;strong&gt;条件に&lt;/strong&gt;基づいて、PC（プログラムカウンター）は、命令ストリーム内の転送アドレスを指すように変更されます。</target>
        </trans-unit>
        <trans-unit id="5bb5d1ddff4f6d3eb81208ce3786e0186300f35b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess right every time&lt;/strong&gt;, the execution will never have to stop.</source>
          <target state="translated">&lt;strong&gt;毎回正しく推測すれば&lt;/strong&gt; 、実行を停止する必要はありません。</target>
        </trans-unit>
        <trans-unit id="5c443327b64ce0afa013e0a8c686cce4fcb25e64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess right every time&lt;/strong&gt;, the train will never have to stop.</source>
          <target state="translated">&lt;strong&gt;毎回正解する&lt;/strong&gt;と、電車が止まることはありません。</target>
        </trans-unit>
        <trans-unit id="43854ebdaaaf1f8914276249ab523b2bf804d1c5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess wrong too often&lt;/strong&gt;, the train will spend a lot of time stopping, backing up, and restarting.</source>
          <target state="translated">&lt;strong&gt;間違いが多すぎる&lt;/strong&gt;と、列車は停止、バックアップ、再起動に多くの時間を費やします。</target>
        </trans-unit>
        <trans-unit id="ff48f0bff759820faca0dc4ce0d054010aa2a369" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If you guess wrong too often&lt;/strong&gt;, you spend a lot of time stalling, rolling back, and restarting.</source>
          <target state="translated">&lt;strong&gt;誤解が多すぎると&lt;/strong&gt; 、ストール、ロールバック、再起動に多くの時間を費やします。</target>
        </trans-unit>
        <trans-unit id="29e3b2963af7a82c74a39140e23e664c8aa6638f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Increasing the Instruction Fetch Rate via Multiple Branch Prediction and a Branch Address Cache&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;複数の分岐予測と分岐アドレスキャッシュによる命令フェッチレートの向上&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="80ce9cf0a86a6ef1b733fbee4d9e322ccb10c80d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Let's do some bench marking to understand it better&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;それをよりよく理解するためにいくつかのベンチマーキングをしましょう&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a6ddf289b433253c5925b3f9813d36a0537be7c3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Managed languages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;管理された言語&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a1b89da59705a9d2d5291d59ff4a51ef12d08c3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Quick visualization:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;迅速な視覚化：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5270a251ef82abdcf7f4c1527f163a3cea8e0e1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what can be done?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;では、何ができるでしょうか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ab826d0d5faf44d4a7a8a7aad1ef803be005faf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;So what is branch prediction?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;では、分岐予測とは何ですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d285155e760355be2f39c1257c5821d5da261a1a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Sorted:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Sorted:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd9c2da2ee8d01be5229516e95ec725d64e3f165" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Static/dynamic Branch Prediction&lt;/strong&gt;: Static branch prediction is used by the microprocessor the first time a conditional branch is encountered, and dynamic branch prediction is used for succeeding executions of the conditional branch code.</source>
          <target state="translated">&lt;strong&gt;静的/動的分岐予測&lt;/strong&gt; ：静的分岐予測は、条件付き分岐が初めて発生したときにマイクロプロセッサによって使用され、動的分岐予測は、条件付き分岐コードの後続の実行に使用されます。</target>
        </trans-unit>
        <trans-unit id="078fac8f79d7e758f85f3007634fdc8cb9777688" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result of this case&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;この事件の結果&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6315a32d6eff633cf664b3192d3c2b8360df6c43" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unconditional branches&lt;/strong&gt; - this includes jumps, procedure calls and returns that have no specific condition. For example, an unconditional jump instruction might be coded in assembly language as simply &quot;jmp&quot;, and the instruction stream must immediately be directed to the target location pointed to by the jump instruction, whereas a conditional jump that might be coded as &quot;jmpne&quot; would redirect the instruction stream only if the result of a comparison of two values in a previous &quot;compare&quot; instructions shows the values to not be equal. (The segmented addressing scheme used by the x86 architecture adds extra complexity, since jumps can be either &quot;near&quot; (within a segment) or &quot;far&quot; (outside the segment). Each type has different effects on branch prediction algorithms.)</source>
          <target state="translated">&lt;strong&gt;無条件分岐&lt;/strong&gt; -これには、特定の条件のないジャンプ、プロシージャコール、リターンが含まれます。 たとえば、無条件ジャンプ命令は単に「jmp」としてアセンブリ言語でコーディングでき、命令ストリームはジャンプ命令が指すターゲットの場所にすぐに送られる必要がありますが、「jmpne」としてコーディングされる条件付きジャンプ以前の「比較」命令で2つの値を比較した結果、値が等しくないことが示された場合にのみ、命令ストリームをリダイレクトします。 （x86アーキテクチャで使用されるセグメント化されたアドレッシングスキームは、ジャンプが「セグメント内」または「セグメント外」のいずれかになるため、さらに複雑になります。各タイプは、分岐予測アルゴリズムに異なる影響を与えます。）</target>
        </trans-unit>
        <trans-unit id="d1721438d4fa087c689f86212f2138f7505dcb3c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Unsorted:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Unsorted:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b8dfd8a5f8f4a830eea9365b9b460097fbbe4381" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With the Branch:&lt;/strong&gt; There is a huge difference between the sorted and unsorted data.</source>
          <target state="translated">&lt;strong&gt;ブランチの場合：&lt;/strong&gt;並べ替えられたデータと並べ替えられていないデータには大きな違いがあります。</target>
        </trans-unit>
        <trans-unit id="03b5fb42d9ac84ced19e05a65a21ee596d5d6f7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;With the Hack:&lt;/strong&gt; There is no difference between sorted and unsorted data.</source>
          <target state="translated">&lt;strong&gt;ハックの場合：&lt;/strong&gt;並べ替えられたデータと並べ替えられていないデータに違いはありません。</target>
        </trans-unit>
        <trans-unit id="b16311ddb39aa62e4ad47e876353ac768d1b5d86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;You are a victim of &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;branch prediction&lt;/a&gt; fail.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;あなたは&lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;ブランチ予測の&lt;/a&gt;失敗の犠牲者です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c786fafb5f8da23c331a0d7afceac4aae6e0c19e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;x64&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;x64&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b2f35b1567a33263e752a9bf7e298fd26bd105c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;x86&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;x86&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56bb00227cc3f2c966ad0c07a94c169bef8507ca" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;(Note that this hack is not strictly equivalent to the original if-statement. But in this case, it's valid for all the input values of &lt;code&gt;data[]&lt;/code&gt;.)&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;（このハックは元のifステートメントと厳密に同等ではないことに注意してください。ただし、この場合、 &lt;code&gt;data[]&lt;/code&gt; すべての入力値に対して有効です。）&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="daf1c2db057b9141218780bbe961c3fb9781bf1a" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;&lt;a href=&quot;//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG&quot;&gt;Image&lt;/a&gt; by Mecanismo, via Wikimedia Commons. Used under the &lt;a href=&quot;//creativecommons.org/licenses/by-sa/3.0/deed.en&quot;&gt;CC-By-SA 3.0&lt;/a&gt; license.&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;Mecanismoによる&lt;a href=&quot;//commons.wikimedia.org/wiki/File:Entroncamento_do_Transpraia.JPG&quot;&gt;画像（&lt;/a&gt; Wikimedia Commons経由）。&lt;/sub&gt; &lt;sub&gt;&lt;a href=&quot;//creativecommons.org/licenses/by-sa/3.0/deed.en&quot;&gt;CC-By-SA 3.0&lt;/a&gt;ライセンスの下で使用されます。&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="85f4f86517c13577daac8db1438bfa704a81d1f5" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;&lt;strong&gt;bad&lt;/strong&gt;&amp;rdquo; true-false pattern can make an &lt;code&gt;if&lt;/code&gt;-statement up to six times slower than a &amp;ldquo;&lt;strong&gt;good&lt;/strong&gt;&amp;rdquo; pattern! Of course, which pattern is good and which is bad depends on the exact instructions generated by the compiler and on the specific processor.</source>
          <target state="translated">「 &lt;strong&gt;悪い&lt;/strong&gt; 」true-falseパターンは、「 &lt;strong&gt;良い&lt;/strong&gt; 」パターンより最大6倍遅く &lt;code&gt;if&lt;/code&gt; ステートメントを作成できます。 もちろん、どのパターンが良いか、どちらが悪いかは、コンパイラーによって生成される正確な命令と特定のプロセッサーによって異なります。</target>
        </trans-unit>
        <trans-unit id="fa9002e4deffeb589b075bfcdf8a5cf9a18e318c" translate="yes" xml:space="preserve">
          <source>A branch instruction can cause a computer to begin executing a different instruction sequence and thus deviate from its default behavior of executing instructions in order (i.e. if the expression is false, the program skips the code of the &lt;code&gt;if&lt;/code&gt; block) depending on some condition, which is the expression evaluation in our case.</source>
          <target state="translated">分岐命令は、コンピュータに異なる命令シーケンスの実行を開始させ、その結果、ある条件に応じて、命令を実行するデフォルトの動作から逸脱する可能性があります（つまり、式がfalseの場合、プログラムは &lt;code&gt;if&lt;/code&gt; ブロックのコードをスキップします）。この場合の式の評価です。</target>
        </trans-unit>
        <trans-unit id="dea845d0a945ad214f5fefb6c4b0e6c1e6051bc4" translate="yes" xml:space="preserve">
          <source>A branch predictor is one of the ancient performance improving techniques which still finds relevance into modern architectures. While the simple prediction techniques provide fast lookup and power efficiency they suffer from a high misprediction rate.</source>
          <target state="translated">ブランチ予測器は、パフォーマンスを向上させる古くからある技術の一つで、今でも現代のアーキテクチャに関連性を見いだしています。単純な予測技術は高速なルックアップと電力効率を提供しますが、高い誤予測率に悩まされます。</target>
        </trans-unit>
        <trans-unit id="37fb85f91b43ff03464a3ace5cd03f2e7b1d689f" translate="yes" xml:space="preserve">
          <source>A common way to eliminate branch prediction that I've found to work particularly good in managed languages is a table lookup instead of using a branch (although I haven't tested it in this case).</source>
          <target state="translated">私が管理言語で特にうまくいくと感じたブランチ予測をなくす一般的な方法は、ブランチを使う代わりにテーブルルックアップを使うことです(この場合はテストしていませんが)。</target>
        </trans-unit>
        <trans-unit id="2d5382f7f97d599d6c1c60ae36b7533c1e391142" translate="yes" xml:space="preserve">
          <source>A general rule of thumb is to avoid data-dependent branching in critical loops (such as in this example).</source>
          <target state="translated">一般的な経験則としては、(この例のような)クリティカルループではデータに依存した分岐を避けることです。</target>
        </trans-unit>
        <trans-unit id="2a0c61937b135599b6110466d59da1b10f3e69cc" translate="yes" xml:space="preserve">
          <source>A yet faster approach, that gives an &lt;strong&gt;approximate&lt;/strong&gt; solution for both sorted or unsorted is: &lt;code&gt;sum= 3137536;&lt;/code&gt; (assuming a truly uniform distribution, 16384 samples with expected value 191.5) &lt;strong&gt;:-)&lt;/strong&gt;</source>
          <target state="translated">ソートされたものとソートされていないものの両方の&lt;strong&gt;おおよその&lt;/strong&gt;解決策を提供する、さらに高速なアプローチは次の &lt;code&gt;sum= 3137536;&lt;/code&gt; （真に均一な分布、16384サンプル、期待値191.5と仮定） &lt;strong&gt;:-)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f443462e3c594cabbf5f71234fac4ceb6009a988" translate="yes" xml:space="preserve">
          <source>All the elements are greater than 128</source>
          <target state="translated">すべての要素が128より大きい</target>
        </trans-unit>
        <trans-unit id="60b7feee5533f80829de14d53e01cb5cd2f55c48" translate="yes" xml:space="preserve">
          <source>All the elements are less than 128</source>
          <target state="translated">すべての要素が128以下</target>
        </trans-unit>
        <trans-unit id="0529f5c0c9474ccd9e39a30f16e35b00bb471784" translate="yes" xml:space="preserve">
          <source>Also I want to cite &lt;a href=&quot;https://stackoverflow.com/users/16940/simon-weaver&quot;&gt;@Simon_Weaver&lt;/a&gt; from the comments:</source>
          <target state="translated">また、コメントから&lt;a href=&quot;https://stackoverflow.com/users/16940/simon-weaver&quot;&gt;@Simon_Weaver&lt;/a&gt;を引用したいと思います。</target>
        </trans-unit>
        <trans-unit id="fed9e7e89414aa4f62ee84308b32e6df6a42784c" translate="yes" xml:space="preserve">
          <source>Also at the end, it's good to know we have two kinds of branch predictions that each is going to affect your code differently:</source>
          <target state="translated">また、最後に、それぞれがあなたのコードに異なる影響を与えようとしている2種類のブランチ予測を持っていることを知っているのは良いことです。</target>
        </trans-unit>
        <trans-unit id="118e6e8352ef9219f30b284c2eec943d64cac174" translate="yes" xml:space="preserve">
          <source>Alternatively, on Linux you can use the performance counters subsystem to accomplish the same task, but with native performance using CPU counters.</source>
          <target state="translated">あるいは、Linuxではパフォーマンスカウンタサブシステムを使用して同じタスクを実行することができますが、CPUカウンタを使用してネイティブのパフォーマンスで実行することができます。</target>
        </trans-unit>
        <trans-unit id="407d8227038ebf4c70f4b17f8cbd8db2e0cf6ac0" translate="yes" xml:space="preserve">
          <source>Although both the roads reach the same destination, the straight road is shorter, and the other is longer. If then you choose the other by mistake, there is no turning back, and so you will waste some extra time if you choose the longer road. This is similar to what happens in the computer, and I hope this helped you understand better.</source>
          <target state="translated">どちらの道も目的地は同じですが、まっすぐな道の方が短く、もう一方の道は長いです。間違ってもう一方の道を選んでしまうと、引き返すことができないので、長い方を選んでしまうと余計に時間を浪費してしまうことになります。これはコンピュータの中で起こることと似ているので、少しでも理解していただけたなら幸いです。</target>
        </trans-unit>
        <trans-unit id="72b615d954c685d03dbd988b02705d36339eea5d" translate="yes" xml:space="preserve">
          <source>An official answer would be from</source>
          <target state="translated">公式な答えは</target>
        </trans-unit>
        <trans-unit id="e16854241a2d65fb883d369651da41390d02fcc0" translate="yes" xml:space="preserve">
          <source>Another reason is that when the vector is already sorted, we never need to move elements to their correct position. The effect of these little details is the factor of five or six that we saw.</source>
          <target state="translated">もう一つの理由は、ベクトルがすでにソートされている場合、要素を正しい位置に移動させる必要がないからです。このようなちょっとしたことが効果を発揮するのは、先ほどの5、6倍の倍率です。</target>
        </trans-unit>
        <trans-unit id="18b72662db383a9f75e385af80ee82d4f1ad5ed5" translate="yes" xml:space="preserve">
          <source>Any instruction is broken into a sequence of steps so that different steps can be executed concurrently in parallel. This technique is known as instruction pipeline and this is used to increase throughput in modern processors. To understand this better please see this &lt;a href=&quot;https://en.wikipedia.org/wiki/Pipeline_(computing)#Concept_and_motivation&quot;&gt;example on Wikipedia&lt;/a&gt;.</source>
          <target state="translated">命令は一連のステップに分割されるため、異なるステップを並行して同時に実行できます。 この手法は命令パイプラインと呼ばれ、最新のプロセッサでスループットを向上させるために使用されます。 これをよりよく理解するには&lt;a href=&quot;https://en.wikipedia.org/wiki/Pipeline_(computing)#Concept_and_motivation&quot;&gt;、Wikipediaの&lt;/a&gt;この例を参照してください。</target>
        </trans-unit>
        <trans-unit id="bcb1019315b39b373530b7c1baab0d26a3114719" translate="yes" xml:space="preserve">
          <source>Articles in scientific publications: T.Y. Yeh, Y.N. Patt made a lot of these on branch predictions.</source>
          <target state="translated">科学出版物に掲載された論文。T.Y.Yeh,Y.N.Pattは、枝の予測でこれらの多くを作った。</target>
        </trans-unit>
        <trans-unit id="0a92cf5f4b626666fbf175648e0a6f274113a6f6" translate="yes" xml:space="preserve">
          <source>As a result of waiting for the result of instruction A, the total CPU cycles spent in the above case (without branch prediction; for both true and false) is 7.</source>
          <target state="translated">命令Aの結果を待った結果、上記の場合(分岐予測を行わず、真偽ともに)に費やしたCPUサイクルの合計は7である。</target>
        </trans-unit>
        <trans-unit id="91b190f8f20d90d506eb2a535168aaeb504cbac3" translate="yes" xml:space="preserve">
          <source>As data is distributed between 0 and 255 when the array is sorted, around the first half of the iterations will not enter the &lt;code&gt;if&lt;/code&gt;-statement (the &lt;code&gt;if&lt;/code&gt; statement is shared below).</source>
          <target state="translated">配列のソート時にデータは0から255に分散されるため、反復の前半あたりで &lt;code&gt;if&lt;/code&gt; ステートメントが入力されません（ ifステートメントは以下で共有されます）。</target>
        </trans-unit>
        <trans-unit id="cb7653dba96134a9f8b8386b70f0dd6cac24bb0a" translate="yes" xml:space="preserve">
          <source>As hinted from above, the culprit is this if-statement:</source>
          <target state="translated">上からヒントを得たように、犯人はこのif文です。</target>
        </trans-unit>
        <trans-unit id="485df5143cbc2b24d62743d36ee8956b76546eb1" translate="yes" xml:space="preserve">
          <source>As what has already been mentioned by others, what behind the mystery is &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;Branch Predictor&lt;/a&gt;.</source>
          <target state="translated">他の人がすでに言及しているように、謎の背後にあるのは&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;分岐予測子&lt;/a&gt;です。</target>
        </trans-unit>
        <trans-unit id="4b08e517362c42b5803f28e7adc40496f99cf8e9" translate="yes" xml:space="preserve">
          <source>As you can see, it seems we don't have a reason not to use Branch Predictor.</source>
          <target state="translated">ご覧の通り、Branch Predictorを使わない理由はなさそうです。</target>
        </trans-unit>
        <trans-unit id="4f55d0a62def8f894343508ecf5fe4ae7cfbc922" translate="yes" xml:space="preserve">
          <source>At least the phenomenon is real with this compiler, standard library, and optimizer settings. Different implementations can and do give different answers. In fact, someone did do a more systematic study (a quick web search will find it) and most implementations show that effect.</source>
          <target state="translated">少なくとも、このコンパイラ、標準ライブラリ、オプティマイザの設定では、この現象は現実のものです。異なる実装では、異なる答えが得られる可能性がありますし、異なる答えが得られることもあります。実際、誰かがより体系的な研究を行い(ウェブ検索をすれば見つかります)、ほとんどの実装がその効果を示しています。</target>
        </trans-unit>
        <trans-unit id="fd41bc2c6095914eb987318731cbb8136aa88df0" translate="yes" xml:space="preserve">
          <source>Based on the described scenario, I have written an animation demo to show how instructions are executed in a pipeline in different situations.</source>
          <target state="translated">説明したシナリオをもとに、パイプライン内でどのように命令が実行されるかを様々なシチュエーションで示すアニメーションデモを書いています。</target>
        </trans-unit>
        <trans-unit id="f227c3a03a7731e12cfd0e90cd5a61346155ae8b" translate="yes" xml:space="preserve">
          <source>Based on this, it looks MATLAB is almost &lt;em&gt;175 times&lt;/em&gt; slower than the C implementation without sorting and &lt;em&gt;350 times&lt;/em&gt; slower with sorting. In other words, the effect (of branch prediction) is &lt;em&gt;1.46x&lt;/em&gt; for MATLAB implementation and &lt;em&gt;2.7x&lt;/em&gt; for the C implementation.</source>
          <target state="translated">これに基づいて、MATLABはソートなしのC実装よりもほぼ&lt;em&gt;175倍&lt;/em&gt;遅く、ソートありの場合は&lt;em&gt;350倍&lt;/em&gt;遅いように見えます。 つまり、（分岐予測の）効果は、MATLAB実装の場合は&lt;em&gt;1.46x&lt;/em&gt; 、C実装の場合は&lt;em&gt;2.7x&lt;/em&gt;です。</target>
        </trans-unit>
        <trans-unit id="7f0b96f3c9bc5eedd14fbfce8ae4e5637fcd2f88" translate="yes" xml:space="preserve">
          <source>Besides the fact that the branch prediction may slow you down, a sorted array has another advantage:</source>
          <target state="translated">分岐予測が遅くなる可能性があるという事実の他に、ソートされた配列にはもう一つの利点があります。</target>
        </trans-unit>
        <trans-unit id="cbfea8990261f42832136208062c8c674500cbb0" translate="yes" xml:space="preserve">
          <source>Books: J.L. Hennessy, D.A. Patterson: Computer architecture: a quantitative approach</source>
          <target state="translated">本の紹介。J.L.ヘネシー、D.A.パターソン コンピュータアーキテクチャ:量的アプローチ</target>
        </trans-unit>
        <trans-unit id="829b3fb58a7b85f64a37f8e20d7ec7596c0db7f0" translate="yes" xml:space="preserve">
          <source>Boolean variables are overdetermined in the sense that all operators that have Boolean variables as input check if the inputs have any other value than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;, but operators that have Booleans as output can produce no other value than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt;. This makes operations with Boolean variables as input less efficient than necessary.
Consider example:</source>
          <target state="translated">ブール変数は、ブール変数を入力として持つすべての演算子が、入力に &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;1&lt;/code&gt; 以外の値があるかどうかをチェックしますが、ブールを出力として持つ演算子は、 &lt;code&gt;0&lt;/code&gt; または &lt;code&gt;1&lt;/code&gt; 以外の値を生成できません。 これにより、ブール変数を入力として使用する操作は、必要以上に効率が低下します。 例を考えてみましょう：</target>
        </trans-unit>
        <trans-unit id="0f586453c8b155549182d123a0dddc7e7cafdb04" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;likely()&lt;/code&gt; and &lt;code&gt;unlikely()&lt;/code&gt; are in fact macros that are defined by using something like the GCC's &lt;code&gt;__builtin_expect&lt;/code&gt; to help the compiler insert prediction code to favour the condition taking into account the information provided by the user. GCC supports other builtins that could change the behavior of the running program or emit low level instructions like clearing the cache, etc. See &lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html&quot;&gt;this documentation&lt;/a&gt; that goes through the available GCC's builtins.</source>
          <target state="translated">&lt;code&gt;likely()&lt;/code&gt; と &lt;code&gt;unlikely()&lt;/code&gt; はどちらも、GCCの &lt;code&gt;__builtin_expect&lt;/code&gt; などを使用して定義されたマクロであり、コンパイラーが予測コードを挿入して、ユーザーが提供する情報を考慮した条件を優先するのに役立ちます。 GCCは、実行中のプログラムの動作を変更したり、キャッシュのクリアなどの低レベルの命令を発行したりできる他のビルトインをサポートしています。利用可能なGCCのビルトインを通過する&lt;a href=&quot;https://gcc.gnu.org/onlinedocs/gcc/Other-Builtins.html&quot;&gt;このドキュメント&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="e3be8498fb9bc40fab8d29adec6459c84941f461" translate="yes" xml:space="preserve">
          <source>Branch prediction is essentially an optimization (minimization) problem where the emphasis is on to achieve lowest possible miss rate, low power consumption, and low complexity with minimum resources.</source>
          <target state="translated">分岐予測は基本的に最適化(最小化)問題であり、最小のリソースで可能な限り低いミスレート、低消費電力、低複雑性を達成することに重点が置かれています。</target>
        </trans-unit>
        <trans-unit id="ce09fc1b6a54ba26385b7dcf3dc61b849d981bdb" translate="yes" xml:space="preserve">
          <source>Branch prediction: Guessing/predicting which road is straight and following it without checking</source>
          <target state="translated">分岐予測。どの道がまっすぐなのかを推測し、確認せずに道をたどっていくこと。</target>
        </trans-unit>
        <trans-unit id="bf6354b6953e28aa0b0401d2ab4cdf0bab9f9a80" translate="yes" xml:space="preserve">
          <source>Branch predictor will try to guess which way a branch (an if-then-else structure) will go before this is known for sure. It will not wait for the instruction A to reach the EX stage of the pipeline, but it will guess the decision and go to that instruction (B or C in case of our example).</source>
          <target state="translated">ブランチ予測器は、これが確実に判明する前に、あるブランチ(if-then-else構造)がどちらに行くかを推測しようとします。A命令がパイプラインのEXステージに到達するのを待つのではなく、決定を推測してその命令(この例の場合はBかC)に向かう。</target>
        </trans-unit>
        <trans-unit id="167e8ac318227dcb55522a65e67d450259397b78" translate="yes" xml:space="preserve">
          <source>But in case of a random unsorted array, the prediction will need to discard the partially executed instructions and start over with the correct branch most of the time and result in more CPU cycles compared to the sorted array.</source>
          <target state="translated">しかし、ランダムなソートされていない配列の場合、予測は部分的に実行された命令を破棄して、ほとんどの時間を正しい分岐でやり直す必要があり、結果としてソートされた配列と比較してより多くのCPUサイクルが発生します。</target>
        </trans-unit>
        <trans-unit id="dbc576af53dd6fb3f0dc64893d4fed7f4cc4366f" translate="yes" xml:space="preserve">
          <source>But in my testing, an explicit lookup table was slightly faster than this, probably because indexing into a lookup table was slightly faster than bit shifting.  This shows how my code sets up and uses the lookup table (unimaginatively called &lt;code&gt;lut&lt;/code&gt; for &quot;LookUp Table&quot; in the code).  Here's the C++ code:</source>
          <target state="translated">しかし、私のテストでは、おそらくルックアップテーブルへのインデックス付けがビットシフトよりもわずかに速いため、明示的なルックアップテーブルはこれよりもわずかに高速でした。 これは、私のコードがどのようにルックアップテーブルをセットアップして使用するかを示しています（コードでは「LookUp Table」の場合、想像を超えて &lt;code&gt;lut&lt;/code&gt; と呼ばれています）。 C ++コードは次のとおりです。</target>
        </trans-unit>
        <trans-unit id="556743da1a16719ba282399e5ea0e47a985396e0" translate="yes" xml:space="preserve">
          <source>But in my testing, an explicit lookup table was slightly faster than this, probably because indexing into a lookup table was slightly faster than bit shifting. This shows how my code sets up and uses the lookup table (unimaginatively called lut for &quot;LookUp Table&quot; in the code). Here's the C++ code:</source>
          <target state="translated">しかし、私のテストでは、明示的なルックアップテーブルの方が、ビットシフトよりもルックアップテーブルへのインデックス作成の方がわずかに速かったからでしょう。これは、私のコードがルックアップテーブルをどのように設定し、使用しているかを示しています(コード中では「ルックアップテーブル」のためにlutと呼ばれています)。これがC++のコードです。</target>
        </trans-unit>
        <trans-unit id="a09b475c5d193e2a2ef480d8477ce7319209e1cd" translate="yes" xml:space="preserve">
          <source>But in this case, we know values are in the range [0, 255] and we only care about values &amp;gt;= 128. That means we can easily extract a single bit that will tell us whether we want a value or not: by shifting the data to the right 7 bits, we are left with a 0 bit or a 1 bit, and we only want to add the value when we have a 1 bit. Let's call this bit the &quot;decision bit&quot;.</source>
          <target state="translated">ただし、この場合、値が[0、255]の範囲にあることがわかっており、値が128以上の場合にのみ注意が必要です。つまり、値が必要かどうかを示す単一のビットを簡単に抽出できます。データは右側の7ビットにあり、0ビットまたは1ビットのままであり、1ビットがある場合にのみ値を追加します。 このビットを「決定ビット」と呼びましょう。</target>
        </trans-unit>
        <trans-unit id="58cee47e25522bb2e607e044796956fc2d95746f" translate="yes" xml:space="preserve">
          <source>By using the 0/1 value of the decision bit as an index into an array, we can make code that will be equally fast whether the data is sorted or not sorted. Our code will always add a value, but when the decision bit is 0, we will add the value somewhere we don't care about. Here's the code:</source>
          <target state="translated">決定ビットの01の値を配列のインデックスとして使うことで、データがソートされていても、ソートされていなくても、同じように高速になるコードを作ることができます。私たちのコードは常に値を追加しますが、決定ビットが0の場合、私たちは気にしないどこかに値を追加します。これがそのコードです。</target>
        </trans-unit>
        <trans-unit id="56bb3ef2fb6bcc14eb09093062d52086eb734f83" translate="yes" xml:space="preserve">
          <source>C++ - Visual Studio 2010 - x64 Release</source>
          <target state="translated">C++-Visual Studio 2010-x64 リリース</target>
        </trans-unit>
        <trans-unit id="907dc42739003087cf41fc698a5aef43e56b2716" translate="yes" xml:space="preserve">
          <source>Consider a railroad junction:</source>
          <target state="translated">鉄道の分岐点を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="0008f55380e54b1390ff08936a649b5378e8d33b" translate="yes" xml:space="preserve">
          <source>Drilling down into the line-by-line output produced by &lt;code&gt;cg_annotate&lt;/code&gt; we see for the loop in question:</source>
          <target state="translated">問題のループについて、 &lt;code&gt;cg_annotate&lt;/code&gt; によって生成された行ごとの出力にドリルダウンします。</target>
        </trans-unit>
        <trans-unit id="e84c032993f25d05ec7cbf44965cf42d501894a7" translate="yes" xml:space="preserve">
          <source>EX -- Execute the instruction</source>
          <target state="translated">EX --命令の実行</target>
        </trans-unit>
        <trans-unit id="91b7378edbcc8a2dcbc0578b242232b9f0edf9c0" translate="yes" xml:space="preserve">
          <source>Each element in the original code is a random value</source>
          <target state="translated">元のコードの各要素はランダムな値です。</target>
        </trans-unit>
        <trans-unit id="5b31068fcc3d6c11d6243f6f58c031a60e4fe724" translate="yes" xml:space="preserve">
          <source>Fortunately for us, if the memory access pattern is predictable, the processor will load it in its fast cache and all is well.</source>
          <target state="translated">幸いなことに、メモリアクセスパターンが予測可能であれば、プロセッサはそれを高速キャッシュにロードすれば、すべてがうまくいく。</target>
        </trans-unit>
        <trans-unit id="96d1b40b361ab03cd656fc01b084e5d379dd61ce" translate="yes" xml:space="preserve">
          <source>Frequently used Boolean operations in C++ produce many branches in the compiled program. If these branches are inside loops and are hard to predict they can slow down execution significantly. Boolean variables are stored as 8-bit integers with the value &lt;code&gt;0&lt;/code&gt; for &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">C ++で頻繁に使用されるブール演算は、コンパイルされたプログラムで多くの分岐を生成します。 これらの分岐がループ内にあり、予測が難しい場合、実行が大幅に遅くなる可能性があります。 ブール変数は、値が &lt;code&gt;false&lt;/code&gt; の場合は &lt;code&gt;0&lt;/code&gt; 、 &lt;code&gt;true&lt;/code&gt; の場合は &lt;code&gt;1&lt;/code&gt; の 8ビット整数として格納されます 。</target>
        </trans-unit>
        <trans-unit id="fbb5582021303c8d664e2d578e2f2f31b983748c" translate="yes" xml:space="preserve">
          <source>From a processor perspective, your memory is slow. To compensate for the difference in speed, a couple of caches are built into your processor (L1/L2 cache). So imagine that you're doing your nice calculations and figure out that you need a piece of memory. The processor will get its 'load' operation and loads the piece of memory into cache -- and then uses the cache to do the rest of the calculations. Because memory is relatively slow, this 'load' will slow down your program.</source>
          <target state="translated">プロセッサの観点から見ると、あなたのメモリは遅いです。速度の違いを補うために、プロセッサにはいくつかのキャッシュ(L1L2キャッシュ)が組み込まれています。ですから、あなたが素敵な計算をしていて、メモリの一部が必要だと分かったと想像してみてください。プロセッサは「ロード」操作を行い、メモリの一部をキャッシュにロードし、キャッシュを使って残りの計算を行います。メモリは比較的遅いので、この「ロード」はプログラムを遅くします。</target>
        </trans-unit>
        <trans-unit id="a69eb648a593eb899c67ee00a5913154aebeadb2" translate="yes" xml:space="preserve">
          <source>Further reading: &lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;&quot;Branch predictor&quot; article on Wikipedia&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;//en.wikipedia.org/wiki/Branch_predictor&quot;&gt;参考文献&lt;/a&gt; ： ウィキペディアの「分岐予測」の記事 。</target>
        </trans-unit>
        <trans-unit id="2cb4ec23cd0f11546771882b0c409bbbd82fc5ea" translate="yes" xml:space="preserve">
          <source>GCC 4.6.1 with &lt;code&gt;-O3&lt;/code&gt; or &lt;code&gt;-ftree-vectorize&lt;/code&gt; on x64 is able to generate a conditional move. So there is no difference between the sorted and unsorted data - both are fast.</source>
          <target state="translated">x64で &lt;code&gt;-O3&lt;/code&gt; または &lt;code&gt;-ftree-vectorize&lt;/code&gt; を使用するGCC 4.6.1は、条件付きの移動を生成できます。 したがって、並べ替えられたデータと並べ替えられていないデータに違いはありません。どちらも高速です。</target>
        </trans-unit>
        <trans-unit id="f53bd842ecd4d4a9f495f435523c9cf23aa6a57c" translate="yes" xml:space="preserve">
          <source>Generally, modern processors have quite long pipelines, but for ease let's consider these 4 steps only.</source>
          <target state="translated">一般的に、最近のプロセッサは非常に長いパイプラインを持っていますが、ここでは簡単のためにこの4つのステップだけを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="38465cba940858cd4732031697c429623f9115b7" translate="yes" xml:space="preserve">
          <source>Here are the timings of the loop with different true-false patterns:</source>
          <target state="translated">ここでは、真偽の異なるパターンのループのタイミングをご紹介します。</target>
        </trans-unit>
        <trans-unit id="6a74c4bde413f0664d97478a9af05dc6dec1968a" translate="yes" xml:space="preserve">
          <source>Here is a piece of C++ code that shows some very peculiar behavior. For some strange reason, sorting the data miraculously makes the code almost six times faster:</source>
          <target state="translated">ここに、非常に奇妙な挙動を示す C++コードの一部があります。何らかの奇妙な理由で、データをソートすると、奇跡的にコードが6倍近く速くなります。</target>
        </trans-unit>
        <trans-unit id="9540c640283f5095fcffbc3e62196fc4a354f281" translate="yes" xml:space="preserve">
          <source>Here's a link to this code: &lt;a href=&quot;http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx&quot;&gt;Red Black Trees&lt;/a&gt;, &lt;em&gt;Eternally Confuzzled&lt;/em&gt;</source>
          <target state="translated">これがこのコードへのリンクです： &lt;a href=&quot;http://www.eternallyconfuzzled.com/tuts/datastructures/jsw_tut_rbtree.aspx&quot;&gt;Red Black Trees&lt;/a&gt; 、 &lt;em&gt;Eternally Confuzzled&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65bc35b8db256ec9378ffd563e6d314c0f419d53" translate="yes" xml:space="preserve">
          <source>However, when the data is completely random, the branch predictor is rendered useless, because it can't predict random data. Thus there will probably be around 50% misprediction (no better than random guessing).</source>
          <target state="translated">しかし、データが完全にランダムな場合、ランダムなデータを予測することができないので、分岐予測器は役に立たなくなります。したがって、おそらく50%程度の予測ミスがあるでしょう(ランダムな推測に勝るものはありません)。</target>
        </trans-unit>
        <trans-unit id="923101f6e2254ddc269c719e6877f55af0932907" translate="yes" xml:space="preserve">
          <source>I just read up on this question and its answers, and I feel an answer is missing.</source>
          <target state="translated">この質問とその答えを読んだだけなのに、答えが抜けているような気がします。</target>
        </trans-unit>
        <trans-unit id="6155d3cc9d0a0b68582ccdde2e81aba3a8812eb0" translate="yes" xml:space="preserve">
          <source>I ran that a few times to be sure. Yes, the phenomenon is real. My key code was:</source>
          <target state="translated">念のために何度か実行してみました。はい、現象は本物です。私のキーコードは</target>
        </trans-unit>
        <trans-unit id="411b77367cb6a07a9e121aa06f74b175e40b6fd6" translate="yes" xml:space="preserve">
          <source>I tried the same code with MATLAB 2011b with my MacBook Pro (Intel i7, 64 bit, 2.4 GHz) for the following MATLAB code:</source>
          <target state="translated">私のMacBook Pro(Intel i7,64bit,2.4GHz)でMATLAB 2011bを使って、以下のMATLABコードで同じコードを試してみました。</target>
        </trans-unit>
        <trans-unit id="51e91a54cf2fc822fbf81bdee0af955af2b6ea97" translate="yes" xml:space="preserve">
          <source>I'm not trying to add something but explaining the concept in another way. 
There is a concise introduction on the wiki which contains text and diagram.
I do like the explanation below which uses a diagram to elaborate the Branch Predictor intuitively.</source>
          <target state="translated">何かを付け加えようとしているのではなく、別の方法で概念を説明しています。wikiにはテキストと図を含む簡潔な紹介があります。私は、図を使って分岐予測器を直感的に説明する以下の説明が好きです。</target>
        </trans-unit>
        <trans-unit id="065592acf6ecacc9b012a59339edcc7416aa6239" translate="yes" xml:space="preserve">
          <source>ID -- Decode the instruction</source>
          <target state="translated">ID --命令をデコードする</target>
        </trans-unit>
        <trans-unit id="42c1b1564597619cb2c77349430882a2580c741c" translate="yes" xml:space="preserve">
          <source>IF -- Fetch the instruction from memory</source>
          <target state="translated">IF --メモリから命令をフェッチする</target>
        </trans-unit>
        <trans-unit id="88eb4395003cb412e7661165f4ce4cf1f486289e" translate="yes" xml:space="preserve">
          <source>If it is later detected that the guess was wrong then the partially executed instructions are discarded and the pipeline starts over with the correct branch, incurring a delay. 
The time that is wasted in case of a branch misprediction is equal to the number of stages in the pipeline from the fetch stage to the execute stage. Modern microprocessors tend to have quite long pipelines so that the misprediction delay is between 10 and 20 clock cycles. The longer the pipeline the greater the need for a good &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;branch predictor&lt;/a&gt;.</source>
          <target state="translated">推測が間違っていたことが後で検出された場合、部分的に実行された命令は破棄され、パイプラインは正しい分岐で最初からやり直し、遅延が発生します。 分岐予測ミスの場合に浪費される時間は、フェッチステージから実行ステージまでのパイプラインのステージ数と同じです。 最近のマイクロプロセッサはパイプラインが非常に長くなる傾向があるため、予測ミスの遅延は10〜20クロックサイクルです。 パイプラインが長いほど、優れた&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor&quot;&gt;分岐予測子の&lt;/a&gt;必要性が高くなります。</target>
        </trans-unit>
        <trans-unit id="fd7de5e20eb6affc18989173e9a7fbd64cfc3a64" translate="yes" xml:space="preserve">
          <source>If the array is sorted, your condition is false at the first step: &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt;, then becomes a true value for the whole way to the end of the street. That's how you get to the end of the logic faster. On the other hand, using an unsorted array, you need a lot of turning and processing which make your code run slower for sure...</source>
          <target state="translated">配列がソートされている場合、最初のステップで条件はfalseになります。data &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; 、それから通りの終わりまでの全体の真の値になります。 これにより、ロジックをより早く終了させることができます。 一方、ソートされていない配列を使用すると、コードの実行を確実に遅くする多くの調整と処理が必要になります...</target>
        </trans-unit>
        <trans-unit id="56d4fd733b97267a72ee645f98fa635e9b8c6ce9" translate="yes" xml:space="preserve">
          <source>If the compiler isn't able to optimize the branch into a conditional move, you can try some hacks if you are willing to sacrifice readability for performance.</source>
          <target state="translated">コンパイラが分岐を条件付きの移動に最適化できない場合は、パフォーマンスのために可読性を犠牲にしてもいいのであれば、いくつかのハックを試すことができます。</target>
        </trans-unit>
        <trans-unit id="1824e7d45369351e72c6eb590133dd9e21d010ed" translate="yes" xml:space="preserve">
          <source>If you are curious about even more optimizations that can be done to this code, consider this:</source>
          <target state="translated">もし、このコードにできるさらに多くの最適化に興味があるならば、これを検討してみてください。</target>
        </trans-unit>
        <trans-unit id="5ceebbf643b622dd844b59e8bd85fc4f5ede90be" translate="yes" xml:space="preserve">
          <source>If you give the Intel compiler the branchless code, it just out-right vectorizes it... and is just as fast as with the branch (with the loop interchange).</source>
          <target state="translated">インテルのコンパイラにブランチレスのコードを与えれば、それはただひたすらベクトル化されます...そして、ブランチと同じように高速になります (ループの交換を伴う)。</target>
        </trans-unit>
        <trans-unit id="ae88c41ed067d722d464020e7a9f55e02d32fddc" translate="yes" xml:space="preserve">
          <source>If you guessed right, it continues on.</source>
          <target state="translated">当てはまると続きます。</target>
        </trans-unit>
        <trans-unit id="bbb6c6bc29b605454dbfe7f8781ef7cdb2c270f2" translate="yes" xml:space="preserve">
          <source>If you guessed right, you continue executing.</source>
          <target state="translated">正解を当てた場合は処刑を続行します。</target>
        </trans-unit>
        <trans-unit id="1898647ae8c929024233a50359541e7af7814ea2" translate="yes" xml:space="preserve">
          <source>If you guessed wrong, the captain will stop, back up, and yell at you to flip the switch. Then it can restart down the other path.</source>
          <target state="translated">間違った推測をした場合、船長は停止し、後退し、スイッチを反転するように叫んでくれます。その後、別の経路で再スタートすることができます。</target>
        </trans-unit>
        <trans-unit id="9b46e462a942895bb7f6e7d844e7730c6d70136b" translate="yes" xml:space="preserve">
          <source>If you guessed wrong, you need to flush the pipeline and roll back to the branch. Then you can restart down the other path.</source>
          <target state="translated">間違った推測をした場合は、パイプラインをフラッシュしてブランチにロールバックする必要があります。そうすれば、別のパスで再起動することができます。</target>
        </trans-unit>
        <trans-unit id="23319b8aed03d58e34f2b56f4949401e859e197b" translate="yes" xml:space="preserve">
          <source>If you have ever wondered why ARM has been so phenomenally successful, the brilliant effectiveness and interplay of these two mechanisms are a big part of the story, because they are one of the greatest sources of the ARM architecture's efficiency. The brilliance of the original designers of the ARM ISA back in 1983, Steve Furber and Roger (now Sophie) Wilson, cannot be overstated.</source>
          <target state="translated">なぜARMが驚異的な成功を収めてきたのか疑問に思ったことがある方は、この2つのメカニズムの優れた有効性と相互作用が、ARMアーキテクチャの効率性の最大の源泉の1つであることを知っておいてください。1983年にARM ISAを設計した当初の設計者、スティーブ・ファーバーとロジャー(現ソフィー)・ウィルソンの輝きは、過大評価することはできません。</target>
        </trans-unit>
        <trans-unit id="20223b3b9842562860c0883dd004a561d3dec19d" translate="yes" xml:space="preserve">
          <source>If you run into trouble with lookups in managed languages -- the key is to add a &lt;code&gt;&amp;amp; 0x[something]FFF&lt;/code&gt; to your lookup function to make the boundary check predictable -- and watch it going faster.</source>
          <target state="translated">管理された言語でのルックアップで問題が発生した場合、重要なのは &lt;code&gt;&amp;amp; 0x[something]FFF&lt;/code&gt; をルックアップ関数に追加して、境界チェックを予測可能にし、それがより高速になることを確認することです。</target>
        </trans-unit>
        <trans-unit id="fcbae46e5b1ed263a398fd8853f1c323c42dd17c" translate="yes" xml:space="preserve">
          <source>If you want to write efficient code, you need to know a bit about machine architecture.</source>
          <target state="translated">効率的なコードを書きたいのであれば、マシンアーキテクチャについて少し知っておく必要があります。</target>
        </trans-unit>
        <trans-unit id="4906cf640b371d74701a3bb36c48ac95ee90c060" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;C&lt;/code&gt;, thus &lt;code&gt;C++&lt;/code&gt;, the statement, which would compile directly (without any optimization) into the conditional move instruction in &lt;code&gt;x86&lt;/code&gt;, is the ternary operator &lt;code&gt;... ? ... : ...&lt;/code&gt;. So we rewrite the above statement into an equivalent one:</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; では、つまり &lt;code&gt;C++&lt;/code&gt; 、 &lt;code&gt;x86&lt;/code&gt; の条件付き移動命令に直接（最適化なしで）コンパイルされるステートメントは、3項演算子 &lt;code&gt;... ? ... : ...&lt;/code&gt; ...：...。 したがって、上記のステートメントを同等のステートメントに書き換えます。</target>
        </trans-unit>
        <trans-unit id="ab040f6c0d47f49db7c9db520be83759c461ffc9" translate="yes" xml:space="preserve">
          <source>In a branch case, the following instruction is determined by the preceding one, so we cannot do pipelining. We have to either wait or predict.</source>
          <target state="translated">分岐の場合は、先行する命令で次の命令が決まるので、パイプライン化はできません。待つか予測するしかありません。</target>
        </trans-unit>
        <trans-unit id="0025791b5e0267a182817044a5ed2c8007195575" translate="yes" xml:space="preserve">
          <source>In a conditional move case, the execution conditional move instruction is divided into several stages, but the earlier stages like &lt;code&gt;Fetch&lt;/code&gt; and &lt;code&gt;Decode&lt;/code&gt; does not depend on the result of the previous instruction; only latter stages need the result. Thus, we wait a fraction of one instruction's execution time. This is why the conditional move version is slower than the branch when prediction is easy.</source>
          <target state="translated">条件付き移動の場合、実行条件付き移動命令はいくつかのステージに分割されますが、 &lt;code&gt;Fetch&lt;/code&gt; や &lt;code&gt;Decode&lt;/code&gt; などの初期のステージは前の命令の結果に依存しません。 後のステージだけが結果を必要とします。 したがって、1つの命令の実行時間の一部を待機します。 これが、予測が容易な場合に条件付き移動バージョンがブランチよりも遅い理由です。</target>
        </trans-unit>
        <trans-unit id="79ae345e2bd1b8124d296ba39b3ea113c5193f48" translate="yes" xml:space="preserve">
          <source>In a typical &lt;code&gt;x86&lt;/code&gt; processor, the execution of an instruction is divided into several stages. Roughly, we have different hardware to deal with different stages. So we do not have to wait for one instruction to finish to start a new one. This is called &lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Pipeline_%28computing%29&quot;&gt;pipelining&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">典型的な &lt;code&gt;x86&lt;/code&gt; プロセッサでは、命令の実行はいくつかの段階に分かれています。 大まかに言って、さまざまな段階に対応するためにさまざまなハードウェアがあります。 したがって、新しい命令を開始するために、1つの命令が完了するのを待つ必要はありません。 これは&lt;strong&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Pipeline_%28computing%29&quot;&gt;パイプライン&lt;/a&gt;&lt;/strong&gt;と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="0a827bd7aeac65573a68ed989955da0af9f32542" translate="yes" xml:space="preserve">
          <source>In addition to this, in complex prediction techniques the time taken to predict the branches is itself very high &amp;ndash;ranging from 2 to 5 cycles &amp;ndash;which is comparable to the execution time of actual branches.</source>
          <target state="translated">これに加えて、複雑な予測手法では、分岐の予測にかかる時間自体が非常に長く（2から5サイクル）、実際の分岐の実行時間に匹敵します。</target>
        </trans-unit>
        <trans-unit id="0fa50c75a9a67268a4a229ac38ceeff7cb07714a" translate="yes" xml:space="preserve">
          <source>In all these cases the failure will be too less in number and as a result, only a few times it will need to discard the partially executed instructions and start over with the correct branch, resulting in fewer CPU cycles.</source>
          <target state="translated">これらのケースでは、失敗した命令の数があまりにも少なくなり、その結果、部分的に実行された命令を破棄して、正しいブランチでやり直す必要があり、結果としてCPUサイクルが少なくなります。</target>
        </trans-unit>
        <trans-unit id="fa58046848c4821f342e1d54d795534223e063ff" translate="yes" xml:space="preserve">
          <source>In an unsorted array, the computer makes multiple predictions, leading to an increased chance of errors.
Whereas, in a sorted array, the computer makes fewer predictions, reducing the chance of errors.
Making more predictions requires more time.</source>
          <target state="translated">ソートされていない配列では,コンピュータは複数の予測を行い,エラーが発生する可能性が高くなります.一方,ソートされた配列では,コンピュータが行う予測が少なくなり,エラーの可能性が低くなります.より多くの予測を行うには,より多くの時間が必要です.</target>
        </trans-unit>
        <trans-unit id="d548e9f8042a97cedfb594f9ea9edf3b28dedc70" translate="yes" xml:space="preserve">
          <source>In computer architecture, a branch predictor is a
  digital circuit that tries to guess which way a branch (e.g. an
  if-then-else structure) will go before this is known for sure. The
  purpose of the branch predictor is to improve the flow in the
  instruction pipeline. Branch predictors play a critical role in
  achieving high effective performance in many modern pipelined
  microprocessor architectures such as x86.</source>
          <target state="translated">コンピュータアーキテクチャでは、分岐予測器は、分岐(例えば、if-then-else構造)がどのような方向に進むかが確実に分かる前に推測しようとするデジタル回路です。分岐予測器の目的は、命令パイプラインのフローを改善することです。分岐予測器は、x86のような多くの最新のパイプライン型マイクロプロセッサアーキテクチャにおいて、高い効果的な性能を達成するために重要な役割を果たしています。</target>
        </trans-unit>
        <trans-unit id="286bceae83a4fe4b1c8bf9719f0595eb063192a3" translate="yes" xml:space="preserve">
          <source>In order to effectively write your code to take advantage of these
  rules, when writing &lt;strong&gt;if-else&lt;/strong&gt; or &lt;strong&gt;switch&lt;/strong&gt; statements, check the most
  common cases first and work progressively down to the least common.
  Loops do not necessarily require any special ordering of code for
  static branch prediction, as only the condition of the loop iterator
  is normally used.</source>
          <target state="translated">これらのルールを利用するようにコードを効率的に作成するには、 &lt;strong&gt;if-else&lt;/strong&gt;ステートメントまたは&lt;strong&gt;switch&lt;/strong&gt;ステートメントを作成するときに、最も一般的なケースを最初に確認し、最も一般的でないものまで段階的に作業します。 通常、ループ反復子の条件のみが使用されるため、静的分岐予測では、ループは必ずしもコードの特別な順序付けを必要としません。</target>
        </trans-unit>
        <trans-unit id="ecaad1e9fa8c85b19d9f8a2205db2cbf9519dd8c" translate="yes" xml:space="preserve">
          <source>In the C++ case, the hack is actually a tad slower than with the branch when the data is sorted.</source>
          <target state="translated">C++の場合、データを並べ替えた時に分岐している時よりも、実はハックの方が少し遅いのです。</target>
        </trans-unit>
        <trans-unit id="27ce65e9b9e70aa80a48ce10e7dd18a40e62a14f" translate="yes" xml:space="preserve">
          <source>In the OP's code, the first time when the conditional, the branch predictor does not have any information to base up prediction, so the first time it will randomly choose the next instruction. Later in the for loop, it can base the prediction on the history. 
For an array sorted in ascending order, there are three possibilities:</source>
          <target state="translated">OPのコードでは、最初の条件付きの場合、分岐予測器は予測のベースとなる情報を持っていないので、最初はランダムに次の命令を選択します。後にforループの中で、履歴に基づいて予測を行うことができます。昇順にソートされた配列に対して,3つの可能性があります.</target>
        </trans-unit>
        <trans-unit id="cfb2e6fc90f9bfd7c318bca3b56e7b9b3254c2b4" translate="yes" xml:space="preserve">
          <source>In the same line (I think this was not highlighted by any answer) it's good to mention that sometimes (specially in software where the performance matters&amp;mdash;like in the Linux kernel) you can find some if statements like the following:</source>
          <target state="translated">同じ行（これはどの回答でも強調されていなかったと思います）では、（特にLinuxカーネルのようにパフォーマンスが重要なソフトウェアでは）次のようなifステートメントが見つかることがあることに言及するのは良いことです。</target>
        </trans-unit>
        <trans-unit id="9d109a99d8c4326a6576d4732479edf2a6cedc39" translate="yes" xml:space="preserve">
          <source>In the sorted case, you can do better than relying on successful branch prediction or any branchless comparison trick: completely remove the branch.</source>
          <target state="translated">ソートされたケースでは、成功したブランチ予測やブランチレス比較のトリックに頼るよりも良い方法があります:ブランチを完全に削除します。</target>
        </trans-unit>
        <trans-unit id="a4e4e6b119a5c6f74ced74230250afdbfb631f5a" translate="yes" xml:space="preserve">
          <source>In this case, it's obvious to the compiler that the boundary condition will never be hit. At least the Microsoft JIT compiler (but I expect Java does similar things) will notice this and remove the check altogether. WOW, that means no branch. Similarly, it will deal with other obvious cases.</source>
          <target state="translated">この場合、境界条件がヒットしないことはコンパイラには明らかです。少なくともMicrosoftのJITコンパイラ(しかし、Javaも同じようなことをしていると思います)は、このことに気付き、チェックを完全に削除します。WOW、それはブランチがないことを意味します。同様に、他の明白なケースにも対処します。</target>
        </trans-unit>
        <trans-unit id="fd70319a87ba55ceb8c46ef0dfb0b5cd4e2bf481" translate="yes" xml:space="preserve">
          <source>In this case, the lookup table was only 256 bytes, so it fits nicely in a cache and all was fast. This technique wouldn't work well if the data was 24-bit values and we only wanted half of them... the lookup table would be far too big to be practical. On the other hand, we can combine the two techniques shown above: first shift the bits over, then index a lookup table. For a 24-bit value that we only want the top half value, we could potentially shift the data right by 12 bits, and be left with a 12-bit value for a table index. A 12-bit table index implies a table of 4096 values, which might be practical.</source>
          <target state="translated">この場合、ルックアップテーブルはわずか256バイトだったので、キャッシュにうまく収まり、すべてが高速だった。データが24ビットの値で、その半分しか必要ない場合には、このテクニックはうまくいかないだろう...ルックアップテーブルは実用的には大きすぎる。一方で、上で示した2つのテクニックを組み合わせることができます:最初にビットをシフトし、次にルックアップテーブルをインデックス化します。上半分の値だけが必要な24ビットの値の場合、データを12ビット右にシフトして、12ビットの値をテーブルインデックスとして残すことができます。12ビットのテーブルインデックスは4096個の値のテーブルを意味し、これは実用的かもしれません。</target>
        </trans-unit>
        <trans-unit id="58ac7147fe158d09fb0dcd5d9a2419af351ceee2" translate="yes" xml:space="preserve">
          <source>In this case: &amp;gt;= 128 means we can keep the value, &amp;lt; 128 means we get rid of it. The easiest way to do that is by using an 'AND': if we keep it, we AND it with 7FFFFFFF; if we want to get rid of it, we AND it with 0. Notice also that 128 is a power of 2 -- so we can go ahead and make a table of 32768/128 integers and fill it with one zero and a lot of 7FFFFFFFF's.</source>
          <target state="translated">この場合：&amp;gt; = 128は値を保持できることを意味し、&amp;lt;128は値を削除することを意味します。 これを行う最も簡単な方法は、「AND」を使用することです。それを維持する場合は、7FFFFFFFとANDします。 それを取り除きたい場合は、0とANDします。128は2の累乗であることにも注意してください。32768/ 128整数のテーブルを作成して、1つのゼロと多くの7FFFFFFFFの。</target>
        </trans-unit>
        <trans-unit id="05909b2541b3e02aeda1080cefdfed9bf8d3fb41" translate="yes" xml:space="preserve">
          <source>Indeed, the array is partitioned in a contiguous zone with &lt;code&gt;data &amp;lt; 128&lt;/code&gt; and another with &lt;code&gt;data &amp;gt;= 128&lt;/code&gt;. So you should find the partition point with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Dichotomic_search&quot;&gt;dichotomic search&lt;/a&gt; (using &lt;code&gt;Lg(arraySize) = 15&lt;/code&gt; comparisons), then do a straight accumulation from that point.</source>
          <target state="translated">実際、配列は、 &lt;code&gt;data &amp;lt; 128&lt;/code&gt; 連続したゾーンと、 データが128以上の別のゾーンに分割されています。 したがって、（ &lt;code&gt;Lg(arraySize) = 15&lt;/code&gt; 比較を使用して） &lt;a href=&quot;https://en.wikipedia.org/wiki/Dichotomic_search&quot;&gt;二分検索で&lt;/a&gt;パーティションポイントを見つけ、そのポイントから直接累積する必要があります。</target>
        </trans-unit>
        <trans-unit id="511459d1219dae84b5739744e2330bbd39562f3c" translate="yes" xml:space="preserve">
          <source>Initially, I thought this might be just a language or compiler anomaly, so I tried Java:</source>
          <target state="translated">最初は、これは単なる言語やコンパイラの異常ではないかと思い、Javaを試してみました。</target>
        </trans-unit>
        <trans-unit id="b7ea0a495929d20edeb96560f38ad10f605c64c3" translate="yes" xml:space="preserve">
          <source>Intel - Avoiding the Cost of Branch Misprediction</source>
          <target state="translated">インテル-支店の誤認識のコストを回避する</target>
        </trans-unit>
        <trans-unit id="77db291a450702d5439477d5645b64a6a25dcb27" translate="yes" xml:space="preserve">
          <source>Intel - Branch and Loop Reorganization to Prevent Mispredicts</source>
          <target state="translated">インテル、支店とループの再編で誤報を防ぐ</target>
        </trans-unit>
        <trans-unit id="59f94bde7099ca1379cdd1147d7f4529386efe43" translate="yes" xml:space="preserve">
          <source>Is there a better way? You guess which direction the branch will go!</source>
          <target state="translated">もっと良い方法があるのか?枝がどっちの方向に行くか当ててみてください!</target>
        </trans-unit>
        <trans-unit id="9ce53cf70b1162457580560ead6c5cf7c26bf416" translate="yes" xml:space="preserve">
          <source>Is there a better way? You guess which direction the train will go!</source>
          <target state="translated">もっと良い方法はあるのか?電車がどっちの方向に行くか当ててみてください!</target>
        </trans-unit>
        <trans-unit id="2b7c4e9ff8bccc2bf1d5615ac7198435e8f85617" translate="yes" xml:space="preserve">
          <source>It can also do source code annotation with dissassembly.</source>
          <target state="translated">また、逆アセンブルでソースコードのアノテーションを行うこともできます。</target>
        </trans-unit>
        <trans-unit id="d889c96e7c80c6d5564b275e9ce3e1dcf34879de" translate="yes" xml:space="preserve">
          <source>It doesn&amp;rsquo;t make fewer predictions - it makes fewer incorrect predictions. It still has to predict for each time through the loop...</source>
          <target state="translated">予測が少なくなることはありません-誤った予測が少なくなります。 それでも、ループを通過するたびに予測する必要があります...</target>
        </trans-unit>
        <trans-unit id="08fc45b9de518283718984bcfb1e9ac8e6ae1278" translate="yes" xml:space="preserve">
          <source>It is important to understand that branch misprediction doesn't slow down programs. The cost of a missed prediction is just as if branch prediction didn't exist and you waited for the evaluation of the expression to decide what code to run (further explanation in the next paragraph).</source>
          <target state="translated">ブランチの誤予測がプログラムを遅くしないことを理解しておくことが重要です。予測を見落とした場合のコストは、分岐予測が存在せず、どのコードを実行するかを決定するために式の評価を待っていたのと同じです(次の段落でさらに説明します)。</target>
        </trans-unit>
        <trans-unit id="6fc4b764667806eaf36f9b084c8cc41649bfd6ed" translate="yes" xml:space="preserve">
          <source>It will take 7 clock cycles for 3 instructions to be completed.</source>
          <target state="translated">3つの指示が完了するまでに7回のクロックサイクルが必要になります。</target>
        </trans-unit>
        <trans-unit id="7e692acc3118ecaa2f6cab194a17621924826a7b" translate="yes" xml:space="preserve">
          <source>It will take 9 clock cycles for 3 instructions to be completed.</source>
          <target state="translated">3つの指示が完了するまでに9回のクロックサイクルが必要になります。</target>
        </trans-unit>
        <trans-unit id="76778e3295cf8f4fb34c2e009919d81130807662" translate="yes" xml:space="preserve">
          <source>It's about branch prediction. What is it?</source>
          <target state="translated">分岐予測についてです。それは何ですか?</target>
        </trans-unit>
        <trans-unit id="5ce025460eef942a5746a29f6fff2639b7a4f0ea" translate="yes" xml:space="preserve">
          <source>It's quite a simple demo that clarifies the very basic part of Branch Predictor. If those gifs are annoying, please feel free to remove them from the answer and visitors can also get the live demo source code from &lt;a href=&quot;https://github.com/Eugene-Mark/BranchPredictorDemo&quot;&gt;BranchPredictorDemo&lt;/a&gt;</source>
          <target state="translated">これは、Branch Predictorの非常に基本的な部分を明らかにする非常に単純なデモです。 これらのGIFが煩わしい場合は、回答から自由に削除してください。訪問者は、 &lt;a href=&quot;https://github.com/Eugene-Mark/BranchPredictorDemo&quot;&gt;BranchPredictorDemo&lt;/a&gt;からライブデモのソースコードを取得することもできます。</target>
        </trans-unit>
        <trans-unit id="d1800ac2cc348d512d31d6a4d1e9d7c3834e153d" translate="yes" xml:space="preserve">
          <source>Java - NetBeans 7.1.1 JDK 7 - x64</source>
          <target state="translated">Java-NetBeans 7.1.1.1 JDK 7-x64</target>
        </trans-unit>
        <trans-unit id="f3f0214447bd9b96e0f2a7febf49ceace8c3c918" translate="yes" xml:space="preserve">
          <source>Let us assume that the predictor will always assume the true branch on the first run.</source>
          <target state="translated">予測器が最初の実行で常に真の分岐を仮定すると仮定してみましょう。</target>
        </trans-unit>
        <trans-unit id="0626fcdc6685d5777030cccc407cda27d5a5dbe6" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s measure the performance of this loop with different conditions:</source>
          <target state="translated">さまざまな条件でこのループのパフォーマンスを測定してみましょう。</target>
        </trans-unit>
        <trans-unit id="78c58416698b00e2911ee8edf6ff28c7aa28b3f5" translate="yes" xml:space="preserve">
          <source>Let's say you need to pick route 1 or route 2. Waiting for your partner to check the map, you have stopped at ## and waited, or you could just pick route1 and if you were lucky (route 1 is the correct route), then great you didn't have to wait for your partner to check the map (you saved the time it would have taken him to check the map), otherwise you will just turn back.</source>
          <target state="translated">例えば、ルート1かルート2を選ぶ必要があるとしましょう。地図をチェックするためにあなたのパートナーを待っている、あなたは##で停止して待っている、またはあなただけのルート1を選ぶことができ、あなたが幸運だった場合(ルート1は正しいルートです)、その後偉大なあなたは地図をチェックするためにあなたのパートナーを待つ必要はありませんでした(あなたはそれが彼が地図をチェックするためにかかったであろう時間を節約しました)、そうでなければ、あなただけに戻ってきます。</target>
        </trans-unit>
        <trans-unit id="2722634189f24bf6fb4d65af5b80948093b029bf" translate="yes" xml:space="preserve">
          <source>Like branch prediction, this was optimized in the Pentium processors: the processor predicts that it needs to load a piece of data and attempts to load that into the cache before the operation actually hits the cache. As we've already seen, branch prediction sometimes goes horribly wrong -- in the worst case scenario you need to go back and actually wait for a memory load, which will take forever (&lt;strong&gt;in other words: failing branch prediction is bad, a memory load after a branch prediction fail is just horrible!&lt;/strong&gt;).</source>
          <target state="translated">分岐予測と同様に、これはPentiumプロセッサーで最適化されました。プロセッサーはデータの一部をロードする必要があると予測し、操作が実際にキャッシュにヒットする前にそれをキャッシュにロードしようとします。 すでに見てきたように、分岐予測はひどく間違っていることがあります-最悪のシナリオでは、戻って実際にメモリ負荷を待つ必要があり、これは永遠にかかります（ &lt;strong&gt;つまり、分岐予測の失敗は悪いです、メモリ分岐予測が失敗した後のロードは恐ろしいです！&lt;/strong&gt; ）</target>
        </trans-unit>
        <trans-unit id="7511e6163f79984c1b9da8abd1a9c44be298fc50" translate="yes" xml:space="preserve">
          <source>Look at the image I created for you below. Which street is going to be finished faster?</source>
          <target state="translated">下の画像を見てください。どっちの通りが早く終わるかな?</target>
        </trans-unit>
        <trans-unit id="87b5594f2643cba7d46d5fb490ed0d38e2cf1230" translate="yes" xml:space="preserve">
          <source>Making a wrong prediction leads to going back to the previous step, and executing with another prediction. Assuming the prediction is correct, the code will continue to the next step. A wrong prediction results in repeating the same step, until a correct prediction occurs.</source>
          <target state="translated">予測を間違えると、前のステップに戻り、別の予測で実行することになります。予測が正しければ、コードは次のステップに進みます。予測が間違っていると、正しい予測が発生するまで同じステップを繰り返すことになります。</target>
        </trans-unit>
        <trans-unit id="a1ebbba208d4225ea0cbac50fe08bb6ace4451a3" translate="yes" xml:space="preserve">
          <source>Most applications have well-behaved branches. So modern branch predictors will typically achieve &amp;gt;90% hit rates. But when faced with unpredictable branches with no recognizable patterns, branch predictors are virtually useless.</source>
          <target state="translated">ほとんどのアプリケーションには、適切に動作するブランチがあります。 したがって、最新の分岐予測子は通常、90％を超えるヒット率を達成します。 しかし、認識できないパターンのある予測不可能な分岐に直面すると、分岐予測子は事実上役に立たなくなります。</target>
        </trans-unit>
        <trans-unit id="edc45563f2af123495a6f4d5820e01d67e592ac5" translate="yes" xml:space="preserve">
          <source>Most processor architectures do not have this ability to specify whether or not the status bits should be updated for a given operation, which can necessitate writing additional code to save and later restore status bits, or may require additional branches, or may limit the processor's out of order execution efficiency: one of the side effects of most CPU instruction set architectures forcibly updating status bits after most instructions is that it is much harder to tease apart which instructions can be run in parallel without interfering with each other. Updating status bits has side effects, therefore has a linearizing effect on code. &lt;strong&gt;ARM's ability to mix and match branch-free condition testing on any instruction with the option to either update or not update the status bits after any instruction is extremely powerful, for both assembly language programmers and compilers, and produces very efficient code.&lt;/strong&gt;</source>
          <target state="translated">ほとんどのプロセッサアーキテクチャには、特定の操作でステータスビットを更新する必要があるかどうかを指定する機能がありません。ステータスビットを保存して後で復元するために追加のコードを書く必要がある場合や、追加の分岐が必要な場合や、プロセッサのアウトを制限する場合があります。ほとんどの命令の後でステータスビットを強制的に更新するほとんどのCPU命令セットアーキテクチャの副作用の1つは、互いに干渉することなく並列に実行できる命令を切り離すことがはるかに難しいことです。 ステータスビットの更新には副作用があるため、コードに線形化効果があります。 &lt;strong&gt;命令の分岐なしの条件テストを組み合わせて一致させるARMの機能は、命令の後にステータスビットを更新するかどうかを更新するオプションを備えており、アセンブリ言語のプログラマーとコンパイラーの両方にとって非常に強力で、非常に効率的なコードを生成します。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6714e326ddf3827a45bf7845db0659793dffdc78" translate="yes" xml:space="preserve">
          <source>Moving back to the above question let's consider the following instructions:</source>
          <target state="translated">上記の質問に戻り、以下の手順を考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="8f2f5f3a519901e55e81a2564329640471c74d81" translate="yes" xml:space="preserve">
          <source>My first thought was that sorting brings the data into the cache, but then I thought how silly that was because the array was just generated.</source>
          <target state="translated">最初に思ったのは、ソートするとキャッシュにデータが入るということでしたが、配列が生成されただけなので、それは何と愚かなことなのだろうと思いました。</target>
        </trans-unit>
        <trans-unit id="5b798bfc3b15b4fc93876532bf774c937ef4d1cc" translate="yes" xml:space="preserve">
          <source>No doubt some of us would be interested in ways of identifying code that is problematic for the CPU's branch-predictor. The Valgrind tool &lt;code&gt;cachegrind&lt;/code&gt; has a branch-predictor simulator, enabled by using the &lt;code&gt;--branch-sim=yes&lt;/code&gt; flag. Running it over the examples in this question, with the number of outer loops reduced to 10000 and compiled with &lt;code&gt;g++&lt;/code&gt;, gives these results:</source>
          <target state="translated">私たちの一部は、CPUの分岐予測子にとって問題のあるコードを特定する方法に興味を持っていることは間違いありません。 Valgrindツール &lt;code&gt;cachegrind&lt;/code&gt; には、ブランチ予測シミュレータがあり、 &lt;code&gt;--branch-sim=yes&lt;/code&gt; フラグを使用して有効にします 。 この質問の例で実行すると、外側のループの数が10000に減り、 &lt;code&gt;g++&lt;/code&gt; でコンパイルすると、次の結果が得られます。</target>
        </trans-unit>
        <trans-unit id="7fe6472f78792531c23c2701179111bf8fe3d611" translate="yes" xml:space="preserve">
          <source>Normally this kind of optimizations are mainly found in hard-real time applications or embedded systems where execution time matters and it's critical. For example, if you are checking for some error condition that only happens 1/10000000 times, then why not inform the compiler about this? This way, by default, the branch prediction would assume that the condition is false.</source>
          <target state="translated">通常、この種の最適化は、実行時間が重要で重要なハードリアルタイム・アプリケーションや組み込みシステムで主に見られます。例えば、110000000回しか発生しないエラー条件をチェックしている場合、その旨をコンパイラに通知してはどうでしょうか?このようにすると、デフォルトでは、分岐予測はその条件がfalseであると仮定します。</target>
        </trans-unit>
        <trans-unit id="2687a67b9058fe9e6fd551f4fb695501d7a3f7de" translate="yes" xml:space="preserve">
          <source>Notice that the data is evenly distributed between 0 and 255. When the data is sorted, roughly the first half of the iterations will not enter the if-statement. After that, they will all enter the if-statement.</source>
          <target state="translated">データが0から255までの間で均等に分布していることに注目してください。データがソートされているとき、およそ最初の半分の反復はif文に入りません。その後、すべての反復はif文に入ります。</target>
        </trans-unit>
        <trans-unit id="8e169f52da1ac65f0d59b6b1c4ec6bd5bf878be5" translate="yes" xml:space="preserve">
          <source>Now for the sake of argument, suppose this is back in the 1800s - before long distance or radio communication.</source>
          <target state="translated">さて、議論のために、これが1800年代に戻ってきたとしましょう-長距離通信や無線通信の前の話です。</target>
        </trans-unit>
        <trans-unit id="30312bef68cebc5f38e57e727b2135cfb377fc89" translate="yes" xml:space="preserve">
          <source>Now let's look more closely by investigating the &lt;code&gt;x86&lt;/code&gt; assembly they generate. For simplicity, we use two functions &lt;code&gt;max1&lt;/code&gt; and &lt;code&gt;max2&lt;/code&gt;.</source>
          <target state="translated">ここで、それらが生成する &lt;code&gt;x86&lt;/code&gt; アセンブリを調査して、さらに詳しく見ていきましょう。 簡単にするために、2つの関数 &lt;code&gt;max1&lt;/code&gt; と &lt;code&gt;max2&lt;/code&gt; を使用します 。</target>
        </trans-unit>
        <trans-unit id="c330fcd6ba152c362d1fcd57661782df403680f7" translate="yes" xml:space="preserve">
          <source>Now, if we look at the code</source>
          <target state="translated">さて、コードを見てみると</target>
        </trans-unit>
        <trans-unit id="580a776c6b642fccec58ff95f40d16a839dd873b" translate="yes" xml:space="preserve">
          <source>Observations:</source>
          <target state="translated">Observations:</target>
        </trans-unit>
        <trans-unit id="c497da8cabdb633d3a209eb10a05a6e8a8479a34" translate="yes" xml:space="preserve">
          <source>On ARM, there is no branch needed, because every instruction has a 4-bit condition field, which tests (at zero cost) any of &lt;a href=&quot;https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/condition-codes-1-condition-flags-and-codes&quot;&gt;16 different different conditions&lt;/a&gt; that may arise in the Processor Status Register, and if the condition on an instruction is false, the instruction is skipped. This eliminates the need for short branches, and there would be no branch prediction hit for this algorithm. &lt;b&gt;Therefore, the sorted version of this algorithm would run slower than the unsorted version on ARM, because of the extra overhead of sorting.&lt;/b&gt;</source>
          <target state="translated">ARMでは、すべての命令に4ビットの条件フィールドがあり、プロセッサステータスレジスタで発生する可能性のある&lt;a href=&quot;https://community.arm.com/developer/ip-products/processors/b/processors-ip-blog/posts/condition-codes-1-condition-flags-and-codes&quot;&gt;16の異なる条件の&lt;/a&gt;いずれかを（ゼロコストで）テストするため、分岐の必要はありません。 false、命令はスキップされます。 これにより、短い分岐の必要がなくなり、このアルゴリズムでは分岐予測のヒットはありません。 &lt;b&gt;したがって、ソートのオーバーヘッドが増えるため、このアルゴリズムのソートされたバージョンは、ARMのソートされていないバージョンよりも実行速度が遅くなります。&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="97e13959d4711e37195fe7ecfc6a86c5fe97b99f" translate="yes" xml:space="preserve">
          <source>On a x86-64 machine, &lt;code&gt;GCC -S&lt;/code&gt; generates the assembly below.</source>
          <target state="translated">x86-64マシンでは、 &lt;code&gt;GCC -S&lt;/code&gt; は以下のアセンブリを生成します。</target>
        </trans-unit>
        <trans-unit id="af5b27c4a00930aafb30d96f562d6210ddf9267b" translate="yes" xml:space="preserve">
          <source>On an Intel &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core i7&lt;/a&gt;-2600K @ 3.4&amp;nbsp;GHz and Visual Studio 2010 Release Mode, the benchmark is (format copied from Mysticial):</source>
          <target state="translated">Intel &lt;a href=&quot;http://en.wikipedia.org/wiki/Intel_Core#Core_i7&quot;&gt;Core i7&lt;/a&gt; -2600K @ 3.4 GHzおよびVisual Studio 2010リリースモードでは、ベンチマークは（Mysticialからコピーされた形式）：</target>
        </trans-unit>
        <trans-unit id="c46e9d0de821ff22c14c3a97f36bb4c970b4b164" translate="yes" xml:space="preserve">
          <source>On the other hand, complex branch predictions &amp;ndash;either neural based or variants of two-level branch prediction &amp;ndash;provide better prediction accuracy, but they consume more power and complexity increases exponentially.</source>
          <target state="translated">一方、複雑な分岐予測（ニューラルベースまたは2レベルの分岐予測のバリアント）は予測精度が向上しますが、消費電力が増え、複雑さが指数関数的に増加します。</target>
        </trans-unit>
        <trans-unit id="a5e809f1e268fe28804313bc9194b78b811d96b5" translate="yes" xml:space="preserve">
          <source>On the other hand, once it's sorted, the predictor will first move into a state of strongly not taken and when the values change to the high value the predictor will in three runs through change all the way from strongly not taken to strongly taken.</source>
          <target state="translated">一方、一度ソートされると、まず予測器は強く取られていない状態に移行し、その値が高値に変化すると、3回の実行で予測器は強く取られていない状態から強く取られている状態へと一気に変化します。</target>
        </trans-unit>
        <trans-unit id="3bbefccbf2bee10e9954cc81b62c16f44204ba33" translate="yes" xml:space="preserve">
          <source>One reason is branch prediction: the key operation in the sort algorithm is &lt;code&gt;&amp;ldquo;if(v[i] &amp;lt; pivot]) &amp;hellip;&amp;rdquo;&lt;/code&gt; or equivalent. For a sorted sequence that test is always true whereas, for a random sequence, the branch chosen varies randomly.</source>
          <target state="translated">1つの理由は分岐予測です。並べ替えアルゴリズムの主要な操作は、 &lt;code&gt;&amp;ldquo;if(v[i] &amp;lt; pivot]) &amp;hellip;&amp;rdquo;&lt;/code&gt; または同等のものです。 ソートされたシーケンスの場合、そのテストは常に真ですが、ランダムシーケンスの場合、選択されるブランチはランダムに変化します。</target>
        </trans-unit>
        <trans-unit id="6f83347c5969b82a1f9ad38db3d4941619744366" translate="yes" xml:space="preserve">
          <source>One way to avoid branch prediction errors is to build a lookup table, and index it using the data. Stefan de Bruijn discussed that in his answer.</source>
          <target state="translated">分岐予測エラーを回避する1つの方法は、ルックアップテーブルを構築し、そのデータを使用してインデックスを作成することです。Stefan de Bruijn氏は回答の中でそれを論じています。</target>
        </trans-unit>
        <trans-unit id="dba85fca15da0466e912cf6f28584da718edda4e" translate="yes" xml:space="preserve">
          <source>Quicksort (and sorting in general) is a complex study that has attracted some of the greatest minds of computer science. A good sort function is a result of both choosing a good algorithm and paying attention to hardware performance in its implementation.</source>
          <target state="translated">クイックソート(および一般的なソート)は複雑な研究であり、コンピュータサイエンスの最も偉大な頭脳の一部を集めています。良いソート関数は、良いアルゴリズムを選択し、その実装におけるハードウェア性能に注意を払った結果です。</target>
        </trans-unit>
        <trans-unit id="7eee27983091e8186d6b5fbbd3abab850ed0e885" translate="yes" xml:space="preserve">
          <source>Recently this example (modified very slightly) was also used as a way to demonstrate how a piece of code can be profiled within the program itself on Windows. Along the way, the author also shows how to use the results to determine where the code is spending most of its time in both the sorted &amp;amp; unsorted case. Finally the piece also shows how to use a little known feature of the HAL (Hardware Abstraction Layer) to determine just how much branch misprediction is happening in the unsorted case.</source>
          <target state="translated">最近、この例（ごくわずかに変更）は、Windows上のプログラム自体の中でコードの一部をプロファイルする方法を示す方法としても使用されました。 途中で、作成者は結果を使用して、ソートされた場合とソートされていない場合の両方でコードがほとんどの時間を費やしている場所を判別する方法も示します。 最後に、HAL（ハードウェアアブストラクションレイヤー）のあまり知られていない機能を使用して、並べ替えられていない場合に発生する分岐予測ミスの量を判断する方法についても説明します。</target>
        </trans-unit>
        <trans-unit id="9d1e4e7d27b519b1da3d7266c9c87d7861741080" translate="yes" xml:space="preserve">
          <source>References:</source>
          <target state="translated">References:</target>
        </trans-unit>
        <trans-unit id="2e26f7f81e11c144071f07013d00802556dd33b0" translate="yes" xml:space="preserve">
          <source>Replace:</source>
          <target state="translated">Replace:</target>
        </trans-unit>
        <trans-unit id="5b332ccd041103419a2ad666b47b236d919bc4c8" translate="yes" xml:space="preserve">
          <source>Scientific papers - branch prediction computer architecture</source>
          <target state="translated">科学論文-分岐予測コンピュータアーキテクチャ</target>
        </trans-unit>
        <trans-unit id="b01f405d3c10919c3c94fd65f54c0af170284f84" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://perf.wiki.kernel.org/index.php/Tutorial&quot;&gt;the performance tutorial&lt;/a&gt; for more details.</source>
          <target state="translated">詳細について&lt;a href=&quot;https://perf.wiki.kernel.org/index.php/Tutorial&quot;&gt;は、パフォーマンスのチュートリアル&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="3a298d21d0b3c80ce2982ea32ba8a81f978c30f0" translate="yes" xml:space="preserve">
          <source>So how would you strategically guess to minimize the number of times that the train must back up and go down the other path? You look at the past history! If the train goes left 99% of the time, then you guess left. If it alternates, then you alternate your guesses. If it goes one way every three times, you guess the same...</source>
          <target state="translated">では、どうやって戦略的に推測すると、電車がバックして別の道を通らなければならない回数を最小限に抑えることができるのでしょうか?過去の歴史を見てみましょう。もし列車が99%左に行くのであれば、あなたは左に行くと推測します。列車が交互に行くならば、あなたの推測を交互にします。3回に1回なら 同じように...</target>
        </trans-unit>
        <trans-unit id="9ebfa04f718206d91431f0015c26f1b42906f312" translate="yes" xml:space="preserve">
          <source>So in the first case, it will always take the true branch since historically all its predictions are correct.
In the 2nd case, initially it will predict wrong, but after a few iterations, it will predict correctly.
In the 3rd case, it will initially predict correctly till the elements are less than 128. After which it will fail for some time and the correct itself when it sees branch prediction failure in history.</source>
          <target state="translated">したがって、最初のケースでは、歴史的にすべての予測が正しいので、常に真のブランチを取ることになります。2番目のケースでは、最初は間違った予測をしますが、数回の繰り返しの後、正しく予測します。3番目のケースでは、最初は要素が128以下になるまで正しく予測します。その後、しばらくの間は失敗し、履歴の中で分岐予測の失敗を見たときに自分自身を修正します。</target>
        </trans-unit>
        <trans-unit id="351943fae2a5bec40c06462d38700c5db13e382c" translate="yes" xml:space="preserve">
          <source>So programmatically, &lt;strong&gt;branch prediction&lt;/strong&gt; causes the process to be slower...</source>
          <target state="translated">したがって、プログラム的には、 &lt;strong&gt;分岐予測&lt;/strong&gt;によりプロセスが遅くなります...</target>
        </trans-unit>
        <trans-unit id="5ccec79adc1d899a1de0448aec6cd2999ea646b6" translate="yes" xml:space="preserve">
          <source>So there is no doubt about the impact of branch prediction on performance!</source>
          <target state="translated">なので、分岐予測がパフォーマンスに影響を与えることは間違いありません!</target>
        </trans-unit>
        <trans-unit id="3ae2891b971dd8487010889269aa73c34566377f" translate="yes" xml:space="preserve">
          <source>So we've figured out that we can create a small table. Next thing to do is get a lookup function in place. Lookup functions are usually small functions that use a couple of basic integer operations (and, or, xor, shift, add, remove and perhaps multiply). You want to have your input translated by the lookup function to some kind of 'unique key' in your table, which then simply gives you the answer of all the work you wanted it to do.</source>
          <target state="translated">これで、小さなテーブルを作成できることがわかりました。次にやるべきことは、ルックアップ関数を用意することです。ルックアップ関数は通常、基本的な整数演算(and、or、xor、shift、add、remove、multiply)を使用する小さな関数です。あなたの入力をルックアップ関数でテーブル内のある種の「ユニークキー」に変換してもらいたいと思います。</target>
        </trans-unit>
        <trans-unit id="e2fc4b8592d275115019311dc1f64056ef857314" translate="yes" xml:space="preserve">
          <source>So why does a conditional move perform better?</source>
          <target state="translated">では、なぜ条件付きの手の方がパフォーマンスが良いのでしょうか?</target>
        </trans-unit>
        <trans-unit id="8862694fc5020ea843e75148ff60c38a99455cbf" translate="yes" xml:space="preserve">
          <source>So, I tried with a vector of a million integers and got:</source>
          <target state="translated">そこで、100万個の整数のベクトルで試してみたところ、得られました。</target>
        </trans-unit>
        <trans-unit id="26f99fe80efafd6fc68424aeeb2c6cf0ad1eb0fd" translate="yes" xml:space="preserve">
          <source>Some starting new elements are less than 128 and later it become greater than 128</source>
          <target state="translated">いくつかの開始の新しい要素は128より少なく、後で128より大きくなります。</target>
        </trans-unit>
        <trans-unit id="0e167763d050d2cb6ded113f3e9064040103e166" translate="yes" xml:space="preserve">
          <source>Something like (unchecked)</source>
          <target state="translated">のようなもの(チェックなし</target>
        </trans-unit>
        <trans-unit id="a88df12411d4a67fd1c80b6258959d001907e55b" translate="yes" xml:space="preserve">
          <source>Sometimes, some modern compilers can optimize our code to assembly with better performance, sometimes some compilers can't (the code in question is using Visual Studio's native compiler). Knowing the performance difference between branch and conditional move when unpredictable can help us write code with better performance when the scenario gets so complex that the compiler can not optimize them automatically.</source>
          <target state="translated">最近のコンパイラの中には、アセンブリに最適化してパフォーマンスを向上させることができるものもあれば、そうでないものもあります(問題のコードは Visual Studio のネイティブ・コンパイラを使用しています)。予測不可能な場合の分岐と条件移動のパフォーマンスの違いを知ることで、シナリオが複雑になり、コンパイラが自動的に最適化できなくなった場合に、より良いパフォーマンスでコードを書くことができます。</target>
        </trans-unit>
        <trans-unit id="96ecd96ca3304ca88eb06e8a00937b5c4b49d3ed" translate="yes" xml:space="preserve">
          <source>Sorted Array: Straight Road
    ____________________________________________________________________________________
    - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT</source>
          <target state="translated">ソートされた配列。-ーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーーー</target>
        </trans-unit>
        <trans-unit id="417b7a8c229714395078ea87b358994e172876b0" translate="yes" xml:space="preserve">
          <source>Sorted arrays are processed faster than an unsorted array, due to a phenomena called branch prediction.</source>
          <target state="translated">ソートされた配列は,分岐予測と呼ばれる現象により,ソートされていない配列よりも高速に処理されます.</target>
        </trans-unit>
        <trans-unit id="12a86072c1d6226f21fdf1c483e322e5674a52e2" translate="yes" xml:space="preserve">
          <source>Sorting only k-element sections completes the pre-processing in linear time, &lt;code&gt;O(n)&lt;/code&gt;, rather than the &lt;code&gt;O(n.log(n))&lt;/code&gt; time needed to sort the entire array.</source>
          <target state="translated">k要素セクションのみを並べ替えると、配列全体を並べ替えるのに必要な &lt;code&gt;O(n.log(n))&lt;/code&gt; 時間ではなく、線形時間 &lt;code&gt;O(n)&lt;/code&gt; で前処理が完了します。</target>
        </trans-unit>
        <trans-unit id="911567da4c21b2d8b0b479e0b036b07488a7f699" translate="yes" xml:space="preserve">
          <source>Starting with the original loop:</source>
          <target state="translated">元のループからスタート。</target>
        </trans-unit>
        <trans-unit id="b289c5eb6b8d96218afa396493007fb0c5566528" translate="yes" xml:space="preserve">
          <source>Static branch prediction is used by the microprocessor the first time
  a conditional branch is encountered, and dynamic branch prediction is
  used for succeeding executions of the conditional branch code.</source>
          <target state="translated">静的分岐予測は、条件分岐が最初に発生したときにマイクロプロセッサによって使用され、動的分岐予測は、条件分岐コードの後続の実行に使用されます。</target>
        </trans-unit>
        <trans-unit id="0f6ae2e9812cde1bb50890188a75301caf057eb4" translate="yes" xml:space="preserve">
          <source>That being said, the compiler tries to predict the outcome prior to it being actually evaluated. It will fetch instructions from the &lt;code&gt;if&lt;/code&gt; block, and if the expression turns out to be true, then wonderful! We gained the time it took to evaluate it and made progress in the code; if not then we are running the wrong code, the pipeline is flushed, and the correct block is run.</source>
          <target state="translated">そうは言っても、コンパイラーは実際に評価される前に結果を予測しようとします。 &lt;code&gt;if&lt;/code&gt; ブロックから命令をフェッチし、式がtrueであることが判明した場合は、すばらしいです！ 評価にかかる時間を取得し、コードを進歩させました。 そうでない場合、間違ったコードを実行しており、パイプラインがフラッシュされ、正しいブロックが実行されます。</target>
        </trans-unit>
        <trans-unit id="35261a879de9858385098dadcc5581d89b2d609f" translate="yes" xml:space="preserve">
          <source>That one is 100,000 times faster than before.</source>
          <target state="translated">あれは10万倍は早い。</target>
        </trans-unit>
        <trans-unit id="08f10e7e1256e6e98ddd64a702e8dc6f1d8014d5" translate="yes" xml:space="preserve">
          <source>That sounds like an interview question. Is it true? How would you know? It is a bad idea to answer questions about efficiency without first doing some measurements, so it is important to know how to measure.</source>
          <target state="translated">面接の質問みたいですね。本当ですか?どうやってわかるの?最初にある程度の測定をしないで効率性の質問に答えるのは良くないので、測定方法を知ることが大切です。</target>
        </trans-unit>
        <trans-unit id="508b04c27cc3f2089b5ea384a8ad1dd729afae1a" translate="yes" xml:space="preserve">
          <source>That's for sure!...</source>
          <target state="translated">それは間違いない!...</target>
        </trans-unit>
        <trans-unit id="0cde2413f2853914209f8169d7f3210951656de9" translate="yes" xml:space="preserve">
          <source>The above behavior is happening because of Branch prediction.</source>
          <target state="translated">上記のような行動が起きているのは、ブランチの予測が原因です。</target>
        </trans-unit>
        <trans-unit id="76fff62130dd99e863f74fb23823d0e6b58d4f70" translate="yes" xml:space="preserve">
          <source>The answer to your question is very simple.</source>
          <target state="translated">ご質問の答えはとてもシンプルです。</target>
        </trans-unit>
        <trans-unit id="429f9a89629f65eb36edfe9122d197b4a3ab1462" translate="yes" xml:space="preserve">
          <source>The assumption by other answers that one needs to sort the data is not correct.</source>
          <target state="translated">他の回答者による「データを並べ替える必要がある」という思い込みは正しくありません。</target>
        </trans-unit>
        <trans-unit id="14fca0f59106880a0be992b705d52d3aeb245c06" translate="yes" xml:space="preserve">
          <source>The book &lt;em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0136108040&quot;&gt;Computer Systems: A Programmer's Perspective, second edition&lt;/a&gt;&lt;/em&gt; explains this in detail. You can check Section 3.6.6 for &lt;em&gt;Conditional Move Instructions&lt;/em&gt;, entire Chapter 4 for &lt;em&gt;Processor Architecture&lt;/em&gt;, and Section 5.11.2 for a special treatment for &lt;em&gt;Branch Prediction and Misprediction Penalties&lt;/em&gt;.</source>
          <target state="translated">これについては、 &lt;em&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0136108040&quot;&gt;コンピュータシステム：プログラマの視点の第2版&lt;/a&gt;&lt;/em&gt;で詳しく説明されています。 &lt;em&gt;条件付き移動命令&lt;/em&gt;についてはセクション3.6.6、 &lt;em&gt;プロセッサアーキテクチャ&lt;/em&gt;については第4章全体、 &lt;em&gt;分岐予測と予測ミスペナルティの&lt;/em&gt;特別な扱いについてはセクション5.11.2を確認できます。</target>
        </trans-unit>
        <trans-unit id="01c31d56c186a6ecf1549609412d42ba9d45ea61" translate="yes" xml:space="preserve">
          <source>The branch prediction will miss only once.</source>
          <target state="translated">枝予測は一度だけ外れる。</target>
        </trans-unit>
        <trans-unit id="29c1be7f24497d0ee26471ab9535a6a90d257408" translate="yes" xml:space="preserve">
          <source>The branch predictor is a digital circuit (in computer architecture) trying to predict which way a branch will go, improving the flow in the instruction pipeline. The circuit/computer predicts the next step and executes it.</source>
          <target state="translated">分岐予測器は、命令パイプラインの流れを改善し、分岐がどの方向に進むかを予測しようとするデジタル回路(コンピュータアーキテクチャでは)です。回路コンピュータは、次のステップを予測して実行します。</target>
        </trans-unit>
        <trans-unit id="b7d588a1c5460542b96d8b0baf1bab136cf8c2f6" translate="yes" xml:space="preserve">
          <source>The code is summing up some independent terms, so the order should not matter.</source>
          <target state="translated">このコードはいくつかの独立した項をまとめているので、順序は関係ないはずです。</target>
        </trans-unit>
        <trans-unit id="861f94790ecfa967155e62be104ac537e52a5f3a" translate="yes" xml:space="preserve">
          <source>The condition testing field and the optional &quot;set status bit&quot; field can be combined, for example:</source>
          <target state="translated">条件検査フィールドとオプションの「設定ステータスビット」フィールドは、例えば、組み合わせて使用することができる。</target>
        </trans-unit>
        <trans-unit id="6fc938b02ae6f7028fe10706590f459d70027752" translate="yes" xml:space="preserve">
          <source>The example contains three instructions and the first one is a conditional jump instruction. The latter two instructions can go into the pipeline until the conditional jump instruction is executed.</source>
          <target state="translated">この例には3つの命令が含まれており、最初の命令は条件付きジャンプ命令です。後者の2つの命令は、条件付きジャンプ命令が実行されるまでパイプラインに入ることができます。</target>
        </trans-unit>
        <trans-unit id="366e9cefdfc7cf84268b4baae54481cba492ad51" translate="yes" xml:space="preserve">
          <source>The first thing we need to know is what is &lt;em&gt;small&lt;/em&gt;? While smaller is generally better, a rule of thumb is to stick to lookup tables that are &amp;lt;= 4096 bytes in size. As an upper limit: if your lookup table is larger than 64K it's probably worth reconsidering.</source>
          <target state="translated">最初に知っておくべきことは、何が&lt;em&gt;小さい&lt;/em&gt;かということです。 一般的には小さいほど良いですが、目安として、サイズが4096バイト以下のルックアップテーブルを使用することをお勧めします。 上限として：ルックアップテーブルが64Kより大きい場合、おそらく再検討する価値があります。</target>
        </trans-unit>
        <trans-unit id="6ba638444517f57a3c3d8cf6edb54711b632d388" translate="yes" xml:space="preserve">
          <source>The following code does not sort the entire array, but only 200-element segments of it, and thereby runs the fastest.</source>
          <target state="translated">以下のコードは、配列全体をソートせず、その中の200要素のセグメントのみをソートすることで、最速で実行します。</target>
        </trans-unit>
        <trans-unit id="7983685e650d0c0a12e46c770cad6a3ca1107dcd" translate="yes" xml:space="preserve">
          <source>The inner loop for this algorithm would look something like the following in ARM assembly language:</source>
          <target state="translated">このアルゴリズムの内部ループは、ARM アセンブリ言語では以下のようになります。</target>
        </trans-unit>
        <trans-unit id="28885d236427f0638d59b0c11dc0c5a23a6555c9" translate="yes" xml:space="preserve">
          <source>The link is here:
&lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&lt;/a&gt;</source>
          <target state="translated">リンクはここにあります： &lt;a href=&quot;http://www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm&quot;&gt;http&lt;/a&gt; : //www.geoffchappell.com/studies/windows/km/ntoskrnl/api/ex/profile/demo.htm</target>
        </trans-unit>
        <trans-unit id="88c912641d7171878bede0b6532896dc83279c69" translate="yes" xml:space="preserve">
          <source>The performance of an &lt;code&gt;if&lt;/code&gt;-statement depends on whether its condition has a predictable pattern. If the condition is always true or always false, the branch prediction logic in the processor will pick up the pattern. On the other hand, if the pattern is unpredictable, the &lt;code&gt;if&lt;/code&gt;-statement will be much more expensive.</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; ステートメントのパフォーマンスは、その状態に予測可能なパターンがあるかどうかによって異なります。 条件が常にtrueまたは常にfalseの場合、プロセッサの分岐予測ロジックがパターンを取得します。 一方、パターンが予測できない場合、 &lt;code&gt;if&lt;/code&gt; ステートメントははるかに高価になります。</target>
        </trans-unit>
        <trans-unit id="f012bd762d6379e8ee89682917865e46bdb77c96" translate="yes" xml:space="preserve">
          <source>The question is: What makes the above statement not execute in certain cases as in case of sorted data? Here comes the &quot;branch predictor&quot;. A branch predictor is a digital circuit that tries to guess which way a branch (e.g. an &lt;code&gt;if-then-else&lt;/code&gt; structure) will go before this is known for sure. The purpose of the branch predictor is to improve the flow in the instruction pipeline. Branch predictors play a critical role in achieving high effective performance!</source>
          <target state="translated">問題は、ソートされたデータの場合のように、上記のステートメントが特定のケースで実行されない原因は何ですか？ これが「分岐予測子」です。 分岐予測子は、分岐が確実にわかる前に分岐（たとえば、 &lt;code&gt;if-then-else&lt;/code&gt; 構造）がどの方向に進むかを推測するデジタル回路です。 分岐予測子の目的は、命令パイプラインのフローを改善することです。 分岐予測子は、高い効果的なパフォーマンスを実現する上で重要な役割を果たします。</target>
        </trans-unit>
        <trans-unit id="23c9a538a1ef4688c167a88337fa568b94155241" translate="yes" xml:space="preserve">
          <source>The reason why performance improves drastically when the data is sorted is that the branch prediction penalty is removed, as explained beautifully in &lt;a href=&quot;https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902&quot;&gt;Mysticial's answer&lt;/a&gt;.</source>
          <target state="translated">データがソートされたときにパフォーマンスが大幅に向上する理由は、 &lt;a href=&quot;https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array/11227902#11227902&quot;&gt;Mysticialの回答で&lt;/a&gt;美しく説明されているように、分岐予測ペナルティが削除されているためです。</target>
        </trans-unit>
        <trans-unit id="243cce3d654c2e7e3d82b9ec0fc8b02ca07456a2" translate="yes" xml:space="preserve">
          <source>The result is robust in multiple tests. We get a great speedup when the branch result is unpredictable, but we suffer a little bit when it is predictable. In fact, when using a conditional move, the performance is the same regardless of the data pattern.</source>
          <target state="translated">複数回のテストでロバストな結果が得られます。分岐結果が予測できない場合には大きな高速化が得られますが、予測可能な場合には少し苦戦します。実際、条件付き移動を使用した場合は、データパターンに関係なく性能は同じです。</target>
        </trans-unit>
        <trans-unit id="8b2b071beeb1c27797d622cdfe18d46550e595b8" translate="yes" xml:space="preserve">
          <source>The results for the above MATLAB code are as follows:</source>
          <target state="translated">上記のMATLABコードの結果は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="4c621c1518421a4f9a5e82a55048d9d384c6117a" translate="yes" xml:space="preserve">
          <source>The results of the C code as in @GManNickG I get:</source>
          <target state="translated">Cコードの結果は、@GManNickGのように私が取得します。</target>
        </trans-unit>
        <trans-unit id="c51e81726485eb1f77e86bce9119907916de64b6" translate="yes" xml:space="preserve">
          <source>The technique of indexing into an array, instead of using an &lt;code&gt;if&lt;/code&gt; statement, can be used for deciding which pointer to use.  I saw a library that implemented binary trees, and instead of having two named pointers (&lt;code&gt;pLeft&lt;/code&gt; and &lt;code&gt;pRight&lt;/code&gt; or whatever) had a length-2 array of pointers and used the &quot;decision bit&quot; technique to decide which one to follow.  For example, instead of:</source>
          <target state="translated">&lt;code&gt;if&lt;/code&gt; ステートメントを使用する代わりに、配列にインデックスを付ける手法を使用して、使用するポインターを決定できます。 バイナリツリーを実装したライブラリを見て、2つの名前付きポインター（ &lt;code&gt;pLeft&lt;/code&gt; と &lt;code&gt;pRight&lt;/code&gt; など）の代わりに、長さ2のポインター配列を持ち、「決定ビット」手法を使用して、どちらに従うかを決定しました。 たとえば、次の代わりに：</target>
        </trans-unit>
        <trans-unit id="dfc876aaa5431ea7d4210f0979641e4dbe4d96a9" translate="yes" xml:space="preserve">
          <source>The technique of indexing into an array, instead of using an if statement, can be used for deciding which pointer to use. I saw a library that implemented binary trees, and instead of having two named pointers (pLeft and pRight or whatever) had a length-2 array of pointers and used the &quot;decision bit&quot; technique to decide which one to follow. For example, instead of:</source>
          <target state="translated">配列へのインデキシングのテクニックは、if文を使う代わりに、どちらのポインタを使うかを決めるために使うことができます。バイナリツリーを実装したライブラリを見ましたが、2つの名前付きポインタ(pLeftとpRightか何か)を持つ代わりに、ポインタの長さ2の配列を持ち、どちらに従うかを決定するために &quot;決定ビット &quot;のテクニックを使いました。例えば、代わりに</target>
        </trans-unit>
        <trans-unit id="b6cfe976487000bd1e4d79b8ceec46016b036b7e" translate="yes" xml:space="preserve">
          <source>The time that is wasted in case of a branch misprediction is equal to
  the number of stages in the pipeline from the fetch stage to the
  execute stage. Modern microprocessors tend to have quite long
  pipelines so that the misprediction delay is between 10 and 20 clock
  cycles. As a result, making a pipeline longer increases the need for a
  more advanced branch predictor.</source>
          <target state="translated">分岐の誤予測が発生した場合に無駄になる時間は、フェッチステージから実行ステージまでのパイプラインのステージ数に相当します。最近のマイクロプロセッサでは、誤判定遅延が10~20クロックサイクルになるように、パイプラインが非常に長くなる傾向にあります。その結果、パイプラインを長くすると、より高度な分岐予測器の必要性が高まります。</target>
        </trans-unit>
        <trans-unit id="146d532a4e98e5f647a42caf674908e8ad82de98" translate="yes" xml:space="preserve">
          <source>Then, you can see that the &lt;code&gt;if&lt;/code&gt; conditional is constant throughout the execution of the &lt;code&gt;i&lt;/code&gt; loop, so you can hoist the &lt;code&gt;if&lt;/code&gt; out:</source>
          <target state="translated">次に、 &lt;code&gt;if&lt;/code&gt; 条件が &lt;code&gt;i&lt;/code&gt; ループの実行全体を通して一定であることを確認できるので、 &lt;code&gt;if&lt;/code&gt; を引き上げることができます。</target>
        </trans-unit>
        <trans-unit id="e5bc19f51ab3899c2bcbdd21013a0f3ed4bf7a2d" translate="yes" xml:space="preserve">
          <source>Then, you see that the inner loop can be collapsed into one single expression, assuming the floating point model allows it (&lt;code&gt;/fp:fast&lt;/code&gt; is thrown, for example)</source>
          <target state="translated">次に、浮動小数点モデルで許可されている場合（ &lt;code&gt;/fp:fast&lt;/code&gt; がスローされるなど）、内部ループを1つの式に折りたたむことができることがわかります。</target>
        </trans-unit>
        <trans-unit id="0fdbaf8dd82a2699c782cb69604fae05291b1fe4" translate="yes" xml:space="preserve">
          <source>There has been quite some work on eliminating this branch for managed languages. For example:</source>
          <target state="translated">管理されている言語のために、このブランチを削除するためのかなりの作業が行われています。例えば</target>
        </trans-unit>
        <trans-unit id="7b8c8145d6acbc5bd1d7476826d81337b7799153" translate="yes" xml:space="preserve">
          <source>There really are three different kinds of branches:</source>
          <target state="translated">枝は本当に3種類あります。</target>
        </trans-unit>
        <trans-unit id="df08e2eb1f25b5e02231e29ab5a1fabee4d43dce" translate="yes" xml:space="preserve">
          <source>This also &quot;proves&quot; that it has nothing to do with any algorithmic issue such as sort order, and it is indeed branch prediction.</source>
          <target state="translated">これもまた、ソート順などのアルゴリズムの問題とは何の関係もないことを「証明」しており、確かに枝予測である。</target>
        </trans-unit>
        <trans-unit id="5f5f7d59641cd2d4e5ccd00f97168241ae614777" translate="yes" xml:space="preserve">
          <source>This approach works in general if:</source>
          <target state="translated">このアプローチは、一般的には以下の場合に機能します。</target>
        </trans-unit>
        <trans-unit id="157ae22157daa30935359fff59ce72e0d87c83f4" translate="yes" xml:space="preserve">
          <source>This code is far from optimal. The branches may take a long time in case of mispredictions. The Boolean operations can be made much more efficient if it is known with certainty that the operands have no other values than &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. The reason why the compiler does not make such an assumption is that the variables might have other values if they are uninitialized or come from unknown sources. The above code can be optimized if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has been initialized to valid values or if they come from operators that produce Boolean output. The optimized code looks like this:</source>
          <target state="translated">このコードは最適とはほど遠いものです。 予測ミスの場合、ブランチに長い時間がかかることがあります。 オペランドに &lt;code&gt;0&lt;/code&gt; と &lt;code&gt;1&lt;/code&gt; 以外の値がないことが確実にわかっている場合は、ブール演算をはるかに効率的に行うことができます。 コンパイラーがそのような仮定を行わない理由は、変数が初期化されていないか、未知のソースからのものである場合、変数は他の値を持つ可能性があるためです。 上記のコードは、 &lt;code&gt;b&lt;/code&gt; とbが有効な値に初期化されている場合、またはブール出力を生成する演算子に由来する場合に最適化できます。 最適化されたコードは次のようになります。</target>
        </trans-unit>
        <trans-unit id="ad588604ed82a4498c092e23d01a6024f6fd9f5a" translate="yes" xml:space="preserve">
          <source>This code wastes half of the adds but never has a branch prediction failure. It's tremendously faster on random data than the version with an actual if statement.</source>
          <target state="translated">このコードは加算の半分を無駄にしますが、分岐予測の失敗は一度もありません。実際のif文を使用したバージョンよりも、ランダムなデータでは途方もなく高速です。</target>
        </trans-unit>
        <trans-unit id="a15071f65ca5442561d11637a382876b2bbe52fb" translate="yes" xml:space="preserve">
          <source>This eliminates the branch and replaces it with some bitwise operations.</source>
          <target state="translated">これにより、ブランチを削除し、ビット単位の演算に置き換えることができます。</target>
        </trans-unit>
        <trans-unit id="bfca5608e058cd556c4ac52b23258add44c52119" translate="yes" xml:space="preserve">
          <source>This goes to show that even mature modern compilers can vary wildly in their ability to optimize code...</source>
          <target state="translated">これは、成熟した最新のコンパイラでさえ、コードを最適化する能力に大きな違いがあることを示しています。</target>
        </trans-unit>
        <trans-unit id="18e2896e8160beec33e159c94bd6ee44deed00cc" translate="yes" xml:space="preserve">
          <source>This is branch prediction. I admit it's not the best analogy since the train could just signal the direction with a flag. But in computers, the processor doesn't know which direction a branch will go until the last moment.</source>
          <target state="translated">これは分岐予測です。列車が旗で方向を知らせることができたので、最高の例えではないことは認めますが、コンピュータでは、プロセッサは最後の瞬間まで分岐の方向を知りません。しかし、コンピュータでは、プロセッサは最後の瞬間まで分岐がどの方向に行くかを知りません。</target>
        </trans-unit>
        <trans-unit id="d0c1d7a998794d7121446abef39a77def740f803" translate="yes" xml:space="preserve">
          <source>This is typically implemented by the compiler in the following way:</source>
          <target state="translated">これは通常、コンパイラによって次のように実装されています。</target>
        </trans-unit>
        <trans-unit id="2bfa3272ab37710c1267a39900a9e349042c88c7" translate="yes" xml:space="preserve">
          <source>This is very friendly to the branch predictor since the branch consecutively goes the same direction many times. Even a simple saturating counter will correctly predict the branch except for the few iterations after it switches direction.</source>
          <target state="translated">分岐は何度も同じ方向に連続して進むので、これは分岐予測器にとって非常に親切です。単純な飽和カウンタでさえ、分岐が方向転換した後の数回の反復を除いて、正しく分岐を予測することができます。</target>
        </trans-unit>
        <trans-unit id="615c711dbe5df7298f33242a06d07ca902c32379" translate="yes" xml:space="preserve">
          <source>This lets you easily identify the problematic line - in the unsorted version the &lt;code&gt;if (data[c] &amp;gt;= 128)&lt;/code&gt; line is causing 164,050,007 mispredicted conditional branches (&lt;code&gt;Bcm&lt;/code&gt;) under cachegrind's branch-predictor model, whereas it's only causing 10,006 in the sorted version.</source>
          <target state="translated">これにより、問題のある行を簡単に特定できます-並べ替えられていないバージョンでは、 &lt;code&gt;if (data[c] &amp;gt;= 128)&lt;/code&gt; 行が164,050,007の誤った条件付き分岐（ &lt;code&gt;Bcm&lt;/code&gt; ）をcachegrindのブランチ予測モデルの下で引き起こしていますが、並べ替えられたバージョンでは10,006しか引き起こしていません。</target>
        </trans-unit>
        <trans-unit id="62a8acf06dc12988abe140d1d1ffb08120df1a06" translate="yes" xml:space="preserve">
          <source>This question has already been answered excellently many times over. Still I'd like to draw the group's attention to yet another interesting analysis.</source>
          <target state="translated">この質問はすでに何度も何度も見事に答えられています。それでも、私はグループの注意を引きつけたいと思います 別の興味深い分析に。</target>
        </trans-unit>
        <trans-unit id="7ab809ea371604dfeb3647ba6b30215c1eb2398d" translate="yes" xml:space="preserve">
          <source>This question is rooted in Branch Prediction Models on CPUs. I'd recommend reading this paper:</source>
          <target state="translated">この質問は、CPU上のブランチ予測モデルに根ざしています。この論文を読むことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="bda231ceb9d58c33b0e891be602a5fde29542e65" translate="yes" xml:space="preserve">
          <source>To execute instruction B or instruction C the processor will have to wait till the instruction A doesn't reach till EX stage in the pipeline, as the decision to go to instruction B or instruction C depends on the result of instruction A. So the pipeline will look like this.</source>
          <target state="translated">命令Bや命令Cを実行するためには、プロセッサは命令AがパイプラインのEXステージに到達するまで待つ必要があります。</target>
        </trans-unit>
        <trans-unit id="0b7e892117417fb4b6c49ca103d227fc9f4d1140" translate="yes" xml:space="preserve">
          <source>To understand branch prediction one must first understand &lt;strong&gt;Instruction Pipeline&lt;/strong&gt;:</source>
          <target state="translated">分岐予測を理解するには、まず&lt;strong&gt;命令パイプラインを&lt;/strong&gt;理解する必要があります。</target>
        </trans-unit>
        <trans-unit id="a29c68a2d5e91d86d31480109b1da5bc8e35f407" translate="yes" xml:space="preserve">
          <source>Two-way branching is usually implemented with a conditional jump
  instruction. A conditional jump can either be &quot;not taken&quot; and continue
  execution with the first branch of code which follows immediately
  after the conditional jump, or it can be &quot;taken&quot; and jump to a
  different place in program memory where the second branch of code is
  stored. It is not known for certain whether a conditional jump will be
  taken or not taken until the condition has been calculated and the
  conditional jump has passed the execution stage in the instruction
  pipeline (see fig. 1).</source>
          <target state="translated">双方向分岐は通常、条件付きジャンプ命令で実装されます。条件ジャンプは「取られず」に、条件ジャンプの直後に続くコードの最初のブランチで実行を継続するか、「取られて」プログラムメモリ内の別の場所にジャンプして、コードの2番目のブランチが格納されている場所にジャンプするかのいずれかである。条件が計算され、条件ジャンプが命令パイプラインの実行段階を通過するまでは、条件ジャンプが取られるか取られないかは確実にはわかりません(図1参照)。</target>
        </trans-unit>
        <trans-unit id="dcb1d0bc5503faffa53fc3453598b0d035a0c897" translate="yes" xml:space="preserve">
          <source>Unsorted Array: Curved Road</source>
          <target state="translated">ソートされていない配列。曲がった道</target>
        </trans-unit>
        <trans-unit id="c006e2b20060032caaabd451e6df6a02a78a5ac3" translate="yes" xml:space="preserve">
          <source>Use Branch Predictor and don't take a conditional jump. Let's assume that the predict is &lt;strong&gt;not&lt;/strong&gt; taking the conditional jump.</source>
          <target state="translated">分岐予測子を使用し、条件付きジャンプを行わないでください。 予測が条件付きジャンプをとって&lt;strong&gt;いない&lt;/strong&gt;と仮定しましょう。</target>
        </trans-unit>
        <trans-unit id="12c9166e85e51c6ec14fc60d80a7a0f3c7c32568" translate="yes" xml:space="preserve">
          <source>Use Branch Predictor and take a conditional jump. Let's assume that the predict is &lt;strong&gt;not&lt;/strong&gt; taking the conditional jump.</source>
          <target state="translated">分岐予測子を使用して、条件付きジャンプを実行します。 予測が条件付きジャンプをとって&lt;strong&gt;いない&lt;/strong&gt;と仮定しましょう。</target>
        </trans-unit>
        <trans-unit id="a08965e116be4f8dd9b991b5c78c2f2a4953805f" translate="yes" xml:space="preserve">
          <source>Using bitwise operators is more advantageous if the operands are variables than if the operands are comparisons:</source>
          <target state="translated">オペランドが変数の場合は、オペランドが比較の場合よりもビット演算子を使用した方が有利です。</target>
        </trans-unit>
        <trans-unit id="753325de5864d63921392f6d1fdfec25be2f1719" translate="yes" xml:space="preserve">
          <source>VC++ 2010 is unable to generate conditional moves for this branch even under &lt;code&gt;/Ox&lt;/code&gt;.</source>
          <target state="translated">VC ++ 2010は、 &lt;code&gt;/Ox&lt;/code&gt; の下でも、このブランチの条件付き移動を生成できません。</target>
        </trans-unit>
        <trans-unit id="d043004e185c7b0efa7dc62df9e481517f2fae51" translate="yes" xml:space="preserve">
          <source>Visualization:</source>
          <target state="translated">Visualization:</target>
        </trans-unit>
        <trans-unit id="a3b2fe94f4750042ee509a40cd1b811c02dcc827" translate="yes" xml:space="preserve">
          <source>WB -- Write back to CPU register</source>
          <target state="translated">WB --CPUレジスタへのライトバック</target>
        </trans-unit>
        <trans-unit id="6375cff5f915d0ad5739238963ce456b2a75e8c2" translate="yes" xml:space="preserve">
          <source>Well, not exactly... :-)</source>
          <target state="translated">そうではなくて......)</target>
        </trans-unit>
        <trans-unit id="a608d088fa8295119cc45125ae05fa9e8da0660e" translate="yes" xml:space="preserve">
          <source>What is Branch Prediction?</source>
          <target state="translated">ブランチ予測とは?</target>
        </trans-unit>
        <trans-unit id="ddc44bd3685ad0a82e462b5b7860aa861536395a" translate="yes" xml:space="preserve">
          <source>What is going on?</source>
          <target state="translated">何が起こっているのか?</target>
        </trans-unit>
        <trans-unit id="5079282bb6ac8d8fd7800b70a515ca1a7779ded0" translate="yes" xml:space="preserve">
          <source>When you have sorted elements, IR could not be bothered to fetch all CPU instructions, again and again, It fetches them from cache.</source>
          <target state="translated">要素をソートしていると、CPUの命令を何度も何度も何度も、すべてのCPUの命令をフェッチするのが面倒になって、キャッシュからフェッチしてしまいます。</target>
        </trans-unit>
        <trans-unit id="93820c99e002586797e0fc268993184aa2c6be22" translate="yes" xml:space="preserve">
          <source>Whenever there's an &lt;code&gt;if-else&lt;/code&gt; \ &lt;code&gt;switch&lt;/code&gt; statement, the expression has to be evaluated to determine which block should be executed. In the assembly code generated by the compiler, conditional &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;branch&lt;/a&gt; instructions are inserted.</source>
          <target state="translated">&lt;code&gt;if-else&lt;/code&gt; \ &lt;code&gt;switch&lt;/code&gt; ステートメントがある場合は常に、実行するブロックを決定するために式を評価する必要があります。 コンパイラが生成するアセンブリコードには、条件&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_(computer_science)&quot;&gt;分岐&lt;/a&gt;命令が挿入されています。</target>
        </trans-unit>
        <trans-unit id="467f5fe90dca59bcce184cb76b5258ae0f818f25" translate="yes" xml:space="preserve">
          <source>While flushing pipelines is super fast, nowadays taking this gamble is worth it. Predicting sorted data or a data that changes slowly is always easier and better than predicting fast changes.</source>
          <target state="translated">パイプラインのフラッシングは超高速ですが、最近ではこの賭けをすることは価値があります。ソートされたデータやゆっくりと変化するデータを予測することは、速い変化を予測するよりも、常に簡単で優れています。</target>
        </trans-unit>
        <trans-unit id="7a096e98f70b03605f1fd87dee197c0e0dc2d954" translate="yes" xml:space="preserve">
          <source>While maintaining readability, we can check the speedup factor.</source>
          <target state="translated">読みやすさを維持しつつ、スピードアップの要素を確認することができます。</target>
        </trans-unit>
        <trans-unit id="9792cdf86b1977e88d80d53a5f46d6bb5efa646c" translate="yes" xml:space="preserve">
          <source>Why is processing a sorted array faster than processing an unsorted array</source>
          <target state="translated">ソートされた配列を処理する方が,ソートされていない配列を処理するよりも速いのはなぜか</target>
        </trans-unit>
        <trans-unit id="0ecd9604afd7fdf56bd91ee7561b152cde1f8ed3" translate="yes" xml:space="preserve">
          <source>Why is processing a sorted array faster than processing an unsorted array?</source>
          <target state="translated">ソートされた配列を処理する方が,ソートされていない配列を処理するよりも速いのはなぜですか?</target>
        </trans-unit>
        <trans-unit id="45e27afeaa62cf0cccdd3110fde02e47401ff594" translate="yes" xml:space="preserve">
          <source>With a similar but less extreme result.</source>
          <target state="translated">似ているが極端ではない結果で</target>
        </trans-unit>
        <trans-unit id="00bb7f0f6f10727b9d3a497aec7ad500fc1da108" translate="yes" xml:space="preserve">
          <source>With a sorted array, the condition &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; is first &lt;code&gt;false&lt;/code&gt; for a streak of values, then becomes &lt;code&gt;true&lt;/code&gt; for all later values. That's easy to predict. With an unsorted array, you pay for the branching cost.</source>
          <target state="translated">並べ替えられた配列では、条件 &lt;code&gt;data[c] &amp;gt;= 128&lt;/code&gt; は、値のストリークに対して最初は &lt;code&gt;false&lt;/code&gt; であり、その後のすべての値に対して &lt;code&gt;true&lt;/code&gt; になります。 それは簡単に予測できます。 並べ替えられていない配列では、分岐コストを支払います。</target>
        </trans-unit>
        <trans-unit id="9e8a52af2265d491577ac667e610164d2bae82ec" translate="yes" xml:space="preserve">
          <source>With loop interchange, we can safely change this loop to:</source>
          <target state="translated">ループインターチェンジがあれば、このループを安全に変更することができます。</target>
        </trans-unit>
        <trans-unit id="b07d7d0e763b2a76e028689779bd9793c81728e8" translate="yes" xml:space="preserve">
          <source>With the sorted data, the code runs in 1.93 seconds.</source>
          <target state="translated">ソートされたデータでは、コードは1.93秒で実行されます。</target>
        </trans-unit>
        <trans-unit id="cdf4ffa875649aacf9a2112d2448609655f91aec" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;std::sort(data, data + arraySize);&lt;/code&gt;, the code runs in 11.54 seconds.</source>
          <target state="translated">&lt;code&gt;std::sort(data, data + arraySize);&lt;/code&gt; 、コードは11.54秒で実行されます。</target>
        </trans-unit>
        <trans-unit id="f595b01765d8ae905ea5e9dd7e62d7a02b4fbe22" translate="yes" xml:space="preserve">
          <source>Without branch prediction, the following would occur:</source>
          <target state="translated">枝予測をしないと、次のようなことが起こります。</target>
        </trans-unit>
        <trans-unit id="b4764b924495da3570f6397640729704193386e0" translate="yes" xml:space="preserve">
          <source>Without branch prediction, the processor would have to wait until the
  conditional jump instruction has passed the execute stage before the
  next instruction can enter the fetch stage in the pipeline.</source>
          <target state="translated">分岐予測がなければ、プロセッサは、次の命令がパイプライン内のフェッチステージに入ることができるようになる前に、条件付きジャンプ命令が実行ステージを通過するまで待たなければならない。</target>
        </trans-unit>
        <trans-unit id="8fa9477c95d3ffecec4695db62b573324832754a" translate="yes" xml:space="preserve">
          <source>Without the Branch Predictor.</source>
          <target state="translated">分岐予測器を使わずに</target>
        </trans-unit>
        <trans-unit id="0dee180d4b195226d6d709eb16ec0e42b8a820e7" translate="yes" xml:space="preserve">
          <source>You are a processor and you see a branch. You have no idea which way it will go. What do you do? You halt execution and wait until the previous instructions are complete. Then you continue down the correct path.</source>
          <target state="translated">あなたは加工屋で、枝を見ています。あなたはそれがどちらに行くのか見当がつきません。あなたはどうしますか? 実行を停止して、前の命令が完了するまで待ちます。そして、正しい道を進みます。</target>
        </trans-unit>
        <trans-unit id="3747acc12d9a8b4eeed31b6769fc516a8c97c9dd" translate="yes" xml:space="preserve">
          <source>You are the operator of a junction and you hear a train coming. You have no idea which way it is supposed to go. You stop the train to ask the driver which direction they want. And then you set the switch appropriately.</source>
          <target state="translated">あなたはジャンクションのオペレーターで、列車が来る音が聞こえました。あなたはそれがどっちに行くのか見当がつきません。あなたは列車を止めて運転手にどちらの方向に行きたいのか聞いてみます。そして、あなたは適切にスイッチを設定します。</target>
        </trans-unit>
        <trans-unit id="a55200fca28b7f0ac1706d86d79e8114433a8b42" translate="yes" xml:space="preserve">
          <source>You can also see from this lovely &lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor#/media/File:Branch_prediction_2bit_saturating_counter-dia.svg&quot;&gt;diagram&lt;/a&gt; why the branch predictor gets confused.</source>
          <target state="translated">この美しい&lt;a href=&quot;https://en.wikipedia.org/wiki/Branch_predictor#/media/File:Branch_prediction_2bit_saturating_counter-dia.svg&quot;&gt;図&lt;/a&gt;から、分岐予測子が混乱する理由もわかります。</target>
        </trans-unit>
        <trans-unit id="33b05101ba2f17cb142e08e195f5e37dbb2cf22d" translate="yes" xml:space="preserve">
          <source>You can have a stop condition instead of just checking the value, this way you only loop over the relevant data, and ignore the rest.</source>
          <target state="translated">値をチェックするだけではなく、停止条件を設定することもできます。この方法では、関連するデータのみをループし、残りは無視します。</target>
        </trans-unit>
        <trans-unit id="e7cdaed049a36de91bc0b6220dbae638a556dd97" translate="yes" xml:space="preserve">
          <source>You might wonder why this works well in managed languages. After all, managed languages check the boundaries of the arrays with a branch to ensure you don't mess up...</source>
          <target state="translated">なぜこれがマネージド言語でうまく機能するのか不思議に思うかもしれません。結局のところ、管理された言語では配列の境界をブランチでチェックして、混乱しないようにしています...</target>
        </trans-unit>
        <trans-unit id="f6967173a58337d24e84af6ae18adb3fbbae9e11" translate="yes" xml:space="preserve">
          <source>can be optimized to:</source>
          <target state="translated">に最適化することができます。</target>
        </trans-unit>
        <trans-unit id="576ab25730c6c8fde51cea0123c6a7dd40910123" translate="yes" xml:space="preserve">
          <source>is optimal in most cases (unless you expect the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; expression to generate many branch mispredictions).</source>
          <target state="translated">ほとんどの場合に最適です（ &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; 式が多くの分岐予測ミスを生成することを期待している場合を除く）。</target>
        </trans-unit>
        <trans-unit id="a45d05b730bbc58dc46e14dafb3c0d1d4583c878" translate="yes" xml:space="preserve">
          <source>it's a nice solution maybe it will work</source>
          <target state="translated">いい解決策だと思います。</target>
        </trans-unit>
        <trans-unit id="c3bfc02b43a0aa6f110706cfedc26e042e2f304a" translate="yes" xml:space="preserve">
          <source>it's a small table and is likely to be cached in the processor, and</source>
          <target state="translated">それは小さなテーブルで、プロセッサにキャッシュされている可能性が高いので</target>
        </trans-unit>
        <trans-unit id="651a852c52cc01c89e5ea1bd7793b4460d1de61f" translate="yes" xml:space="preserve">
          <source>or similarly:</source>
          <target state="translated">とか似たようなものです。</target>
        </trans-unit>
        <trans-unit id="495520e358c6efe36183f5f5cfdfb1a5f7540a8b" translate="yes" xml:space="preserve">
          <source>or, slightly more obfuscated</source>
          <target state="translated">というか、もう少し難読化された</target>
        </trans-unit>
        <trans-unit id="f11d2b737879c47db5e53479b4f6bb83db8e1df9" translate="yes" xml:space="preserve">
          <source>so the predictor will change sides as the &lt;code&gt;std::rand()&lt;/code&gt; blow.</source>
          <target state="translated">そのため、予測子は &lt;code&gt;std::rand()&lt;/code&gt; ブローするときにサイドを変更します。</target>
        </trans-unit>
        <trans-unit id="0234c36fd5c76bfa6dcd2e321618d03cb21418f9" translate="yes" xml:space="preserve">
          <source>this library would do something like:</source>
          <target state="translated">このライブラリは次のようなことをするでしょう。</target>
        </trans-unit>
        <trans-unit id="46ebea860b14c6c60e10f66281ac11838db11fdf" translate="yes" xml:space="preserve">
          <source>we can find that the meaning of this particular &lt;code&gt;if... else...&lt;/code&gt; branch is to add something when a condition is satisfied. This type of branch can be easily transformed into a &lt;strong&gt;conditional move&lt;/strong&gt; statement, which would be compiled into a conditional move instruction: &lt;code&gt;cmovl&lt;/code&gt;, in an &lt;code&gt;x86&lt;/code&gt; system. The branch and thus the potential branch prediction penalty is removed.</source>
          <target state="translated">&lt;code&gt;if... else...&lt;/code&gt; this else ... else ...ブランチは、条件が満たされたときに何かを追加することです。 このタイプのブランチは、 &lt;strong&gt;条件付き移動&lt;/strong&gt;ステートメントに簡単に変換でき、 &lt;code&gt;x86&lt;/code&gt; システムでは、条件付き移動命令（ &lt;code&gt;cmovl&lt;/code&gt; ）にコンパイルされます。 分岐、したがって潜在的な分岐予測ペナルティが削除されます。</target>
        </trans-unit>
        <trans-unit id="52e0612303b39c0691e807b9c7a297fa35003367" translate="yes" xml:space="preserve">
          <source>with:</source>
          <target state="translated">with:</target>
        </trans-unit>
        <trans-unit id="4e59d494e29779b82beb957429950a6c38d3846b" translate="yes" xml:space="preserve">
          <source>you are running things in a quite tight loop and/or the processor can preload the data.</source>
          <target state="translated">あなたがかなりタイトなループで物事を実行している場合や、プロセッサがデータをプリロードすることができます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
