<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/115983">
    <body>
      <group id="115983">
        <trans-unit id="a979ef10cc6f6a36df6b8a323307ee3bb2e2db9c" translate="yes" xml:space="preserve">
          <source>+</source>
          <target state="translated">+</target>
        </trans-unit>
        <trans-unit id="54dfe2f7832271935a1233868d84cc1176f6f8c3" translate="yes" xml:space="preserve">
          <source>.gitkeep approach</source>
          <target state="translated">.gitkeep方法</target>
        </trans-unit>
        <trans-unit id="965e73fdd6e46ed980c8bdf03a589adab642edf9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/932982/456814&quot;&gt;The solution of Jamie Flournoy&lt;/a&gt; works great. Here is a bit enhanced version to keep the &lt;code&gt;.htaccess&lt;/code&gt; :</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/932982/456814&quot;&gt;Jamie Flournoy的解决方案&lt;/a&gt;效果很好。 这是保留 &lt;code&gt;.htaccess&lt;/code&gt; 的增强版本：</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a55530aeccb75e9eeb062568b1cd54555a6a784b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit for a better solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;编辑以获得更好的解决方案&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4481ac83b0f3173c1c526133aba6d8184bf1add" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;However&lt;/strong&gt;, I later thought It would be better to make this into a small utility command, so I recreated it using Python and published it to the PyPI &lt;a href=&quot;https://pypi.org/project/gitkeep2/&quot;&gt;here&lt;/a&gt;. You can install it by simply running:</source>
          <target state="translated">&lt;strong&gt;但是&lt;/strong&gt; ，我后来认为最好将它变成一个小的实用程序命令，因此我使用Python重新创建了该命令并将其发布到&lt;a href=&quot;https://pypi.org/project/gitkeep2/&quot;&gt;此处&lt;/a&gt;的PyPI。 您可以通过运行以下命令进行安装：</target>
        </trans-unit>
        <trans-unit id="202469ff83d849ba4804312d74f79bb4ea71ff92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original post below:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;原始帖子如下：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e622355d0c04a203c2ae230ad42e052083e6c1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING: This tweak is not truly working as it turns out.&lt;/strong&gt; Sorry for the inconvenience.</source>
          <target state="translated">&lt;strong&gt;警告：事实证明，这种调整并没有真正起作用。&lt;/strong&gt; 抱歉给你带来不便。</target>
        </trans-unit>
        <trans-unit id="101a20c7c6631be2b36cbef52a2cb2613a6724f4" translate="yes" xml:space="preserve">
          <source>A GIT repository with exactly one commit:</source>
          <target state="translated">一个GIT仓库,正好有一个提交。</target>
        </trans-unit>
        <trans-unit id="5fa8d5d03c6966d644feecd12a13d42641e037f4" translate="yes" xml:space="preserve">
          <source>A file clearly related to Git</source>
          <target state="translated">一个明显与Git相关的文件</target>
        </trans-unit>
        <trans-unit id="1613e56a1fc0205ddfa3ab0bfb1dab82dacc86c1" translate="yes" xml:space="preserve">
          <source>A file unrelated to the code (because of the leading dot and the name)</source>
          <target state="translated">一个与代码无关的文件(因为前导点和名称的关系</target>
        </trans-unit>
        <trans-unit id="f6920857980f2d91e8c0805986b7d6808c9af1ce" translate="yes" xml:space="preserve">
          <source>Add a empty .gitkeep file in there</source>
          <target state="translated">在那里添加一个空的.gitkeep文件。</target>
        </trans-unit>
        <trans-unit id="41f9d35d45a5809f08ddb210d46278bb6f19b01c" translate="yes" xml:space="preserve">
          <source>Add a submodule to any repository (&lt;code&gt;git submodule add path_to_repo&lt;/code&gt;)</source>
          <target state="translated">将子模块添加到任何存储库（ &lt;code&gt;git submodule add path_to_repo&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="7f257395a529eabc4dadeed1ba30bccd729c2da6" translate="yes" xml:space="preserve">
          <source>Add it to the index using a plumbing command and the empty tree &lt;a href=&quot;http://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt;:</source>
          <target state="translated">使用管道命令和空树&lt;a href=&quot;http://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt;将其添加到索引：</target>
        </trans-unit>
        <trans-unit id="94916474ca86f077fbf26f834c5faca8838d0984" translate="yes" xml:space="preserve">
          <source>Adding one more option to the fray.</source>
          <target state="translated">多了一个选项,在战斗中增加了一个选项。</target>
        </trans-unit>
        <trans-unit id="9d9855d155abfb00319d620ad3008e951f075bcb" translate="yes" xml:space="preserve">
          <source>Adoption</source>
          <target state="translated">Adoption</target>
        </trans-unit>
        <trans-unit id="99970754935cc627f1a4d7e256aaac3733fca7f9" translate="yes" xml:space="preserve">
          <source>After the commit you have a broken symbolic link in your index and git creates the directory. The broken link has some advantages, since it is no regular file and points to no regular file. So it even fits to the part of the question &quot;(that contains no files)&quot;, not by the intention but by the meaning, I guess:</source>
          <target state="translated">提交之后,你的索引里有一个破损的符号链接,git创建了这个目录。这个破损的链接有一定的好处,因为它不是正则文件,指向的是没有正则文件。所以它甚至符合问题中&quot;(即不包含任何文件)&quot;的部分,我想,不是从意图上看,而是从意义上看。</target>
        </trans-unit>
        <trans-unit id="b7d6d9bb1e8d27ac23a196714647227815b05a51" translate="yes" xml:space="preserve">
          <source>Alternatively, as noted in another &lt;a href=&quot;https://stackoverflow.com/a/5305908/832230&quot;&gt;answer&lt;/a&gt;, the directory can contain a descriptive &lt;a href=&quot;https://stackoverflow.com/questions/8655937/github-readme-and-readme-md&quot;&gt;&lt;code&gt;README&lt;/code&gt; or &lt;code&gt;README.md&lt;/code&gt; file&lt;/a&gt; instead.</source>
          <target state="translated">或者，如另一个&lt;a href=&quot;https://stackoverflow.com/a/5305908/832230&quot;&gt;答案所述&lt;/a&gt; ，该目录可以包含描述性&lt;a href=&quot;https://stackoverflow.com/questions/8655937/github-readme-and-readme-md&quot;&gt; &lt;code&gt;README&lt;/code&gt; 或 &lt;code&gt;README.md&lt;/code&gt; 文件&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="205e51c8e1ece1ffd2fce77ba495ccd116607ccf" translate="yes" xml:space="preserve">
          <source>Alternatively, you could just exclude &lt;em&gt;every&lt;/em&gt; README file from being ignored:</source>
          <target state="translated">另外，您也可以排除&lt;em&gt;所有&lt;/em&gt;自述文件而忽略它们：</target>
        </trans-unit>
        <trans-unit id="4117f5e31a8f100fe678077742923976451bc72f" translate="yes" xml:space="preserve">
          <source>Although it may seem not such a big difference:</source>
          <target state="translated">虽然看似没有那么大的区别。</target>
        </trans-unit>
        <trans-unit id="1744eb66f2436ca0f0c9f01a0155762ce350072a" translate="yes" xml:space="preserve">
          <source>An easy way to do this is by adding a &lt;code&gt;.gitkeep&lt;/code&gt; file to the directory you wish to (currently) keep empty.</source>
          <target state="translated">一种简单的方法是将 &lt;code&gt;.gitkeep&lt;/code&gt; 文件添加到您希望（当前）保持为空的目录中。</target>
        </trans-unit>
        <trans-unit id="219f59595254577d0c91a349dfa6d30d4e67e595" translate="yes" xml:space="preserve">
          <source>An empty directory &lt;em&gt;cannot be part of a tree under the Git versioning system&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;在Git版本控制系统下，&lt;/em&gt;空目录&lt;em&gt;不能成为树的一部分&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="362f60ebf0e843cd145df3739ab29dfe432e6594" translate="yes" xml:space="preserve">
          <source>Andy Lester is right, but if your directory just needs to be empty, and not &lt;em&gt;empty&lt;/em&gt; empty, you can put an empty &lt;code&gt;.gitignore&lt;/code&gt; file in there as a workaround.</source>
          <target state="translated">安迪&amp;middot;莱斯特（Andy Lester）是对的，但是如果您的目录只需要为空，而不是&lt;em&gt;空&lt;/em&gt;目录，则可以在其中放置一个空的 &lt;code&gt;.gitignore&lt;/code&gt; 文件作为解决方法。</target>
        </trans-unit>
        <trans-unit id="673af2d6ba313c8fac9157b8704d15350b4c0a6d" translate="yes" xml:space="preserve">
          <source>Another idea would be to add a &lt;code&gt;README&lt;/code&gt; file explaining what the directory will be used for.</source>
          <target state="translated">另一个想法是添加一个 &lt;code&gt;README&lt;/code&gt; 文件，解释该目录的用途。</target>
        </trans-unit>
        <trans-unit id="1ec908de3e9396e1c85db9b6afb773449d35d181" translate="yes" xml:space="preserve">
          <source>Another option (in response to a comment by @GreenAsJade), if you want to track an empty folder that &lt;em&gt;MAY&lt;/em&gt; contain tracked files in the future, but will be empty for now, you can ommit the &lt;code&gt;*&lt;/code&gt; from the &lt;code&gt;.gitignore&lt;/code&gt; file, and check &lt;em&gt;that&lt;/em&gt; in.  Basically, all the file is saying is &quot;do not ignore &lt;em&gt;me&lt;/em&gt;&quot;, but otherwise, the directory is empty and tracked.</source>
          <target state="translated">另一个选项（响应@GreenAsJade的评论），如果您想跟踪一个将来&lt;em&gt;可能&lt;/em&gt;包含跟踪文件但现在为空的空文件夹，则&lt;em&gt;可以&lt;/em&gt;从 &lt;code&gt;.gitignore&lt;/code&gt; 文件中省略 &lt;code&gt;*&lt;/code&gt; 并检查基本上，所有文件都在说&amp;ldquo;不要忽略&lt;em&gt;我&lt;/em&gt; &amp;rdquo;，否则，该目录为空并被跟踪。</target>
        </trans-unit>
        <trans-unit id="e3cd64b3958a23e5561c2201ea3cd924a9116ba2" translate="yes" xml:space="preserve">
          <source>Another way to make a directory stay (almost) empty (in the repository) is to create a &lt;code&gt;.gitignore&lt;/code&gt; file inside that directory that contains these four lines:</source>
          <target state="translated">使目录保持（在存储库中）几乎为空的另一种方法是在该目录内创建一个 &lt;code&gt;.gitignore&lt;/code&gt; 文件，该文件包含以下四行：</target>
        </trans-unit>
        <trans-unit id="8ada30d97d2322a43013b97b2132220ba3c00e8a" translate="yes" xml:space="preserve">
          <source>Appendix: Recreating this commit</source>
          <target state="translated">附录:重现这项承诺</target>
        </trans-unit>
        <trans-unit id="dc15c49fe1e32d89a01fe92846b02027eac99394" translate="yes" xml:space="preserve">
          <source>As an aside, this is an implementation issue, not a fundamental Git storage design problem. As has been mentioned many times on the Git mailing list, the reason that this has not been implemented is that no one has cared enough to submit a patch for it, not that it couldn&amp;rsquo;t or shouldn&amp;rsquo;t be done.</source>
          <target state="translated">顺便说一句，这是一个实现问题，而不是基本的Git存储设计问题。 正如在Git邮件列表中多次提到的那样，未实施此操作的原因是，没有人关心提交其补丁程序，而不是不能或不应该这样做。</target>
        </trans-unit>
        <trans-unit id="3239a01b066eacc1ab9371152bfd4916f5f2b8e9" translate="yes" xml:space="preserve">
          <source>As described in other answers, Git is unable to represent empty directories in its staging area. (See the &lt;a href=&quot;https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F&quot;&gt;Git FAQ&lt;/a&gt;.) However, if, for your purposes, a directory is empty enough if it contains a &lt;code&gt;.gitignore&lt;/code&gt; file only, then you can create &lt;code&gt;.gitignore&lt;/code&gt; files in empty directories only via:</source>
          <target state="translated">如其他答案所述，Git无法在其暂存区域中表示空目录。 （请参阅&lt;a href=&quot;https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F&quot;&gt;Git常见问题解答&lt;/a&gt; 。）但是，如果出于您的目的，如果目录仅包含 &lt;code&gt;.gitignore&lt;/code&gt; 文件，则该目录足够空，则只能通过以下方式在空目录中创建 &lt;code&gt;.gitignore&lt;/code&gt; 文件：</target>
        </trans-unit>
        <trans-unit id="b3aa328f227341220383e651bc6b4c7fbf977534" translate="yes" xml:space="preserve">
          <source>As mentioned it's not possible to add empty directories, but here is a one liner that adds empty .gitignore files to all directories.</source>
          <target state="translated">如前所述,无法添加空目录,但这里有一个单行本,可以将空的.gitignore文件添加到所有目录中。</target>
        </trans-unit>
        <trans-unit id="8f582e5d97d10444178705b3520e63053106d73b" translate="yes" xml:space="preserve">
          <source>Assuming you would like to add a directory to &lt;code&gt;git&lt;/code&gt; that, for all purposes related to &lt;code&gt;git&lt;/code&gt;, should remain empty and never have it's contents tracked, a &lt;code&gt;.gitignore&lt;/code&gt; as suggested numerous times here, will do the trick.</source>
          <target state="translated">假设您想在 &lt;code&gt;git&lt;/code&gt; 中添加一个目录，出于与 &lt;code&gt;git&lt;/code&gt; 相关的所有目的，该目录应保持为空，并且永远不要对其内容进行跟踪，这里建议多次使用 &lt;code&gt;.gitignore&lt;/code&gt; 来解决问题。</target>
        </trans-unit>
        <trans-unit id="23613439d97605dcd248fd94d6a238984f2dc5ca" translate="yes" xml:space="preserve">
          <source>But I strongly recommend to use this solution only in special circumstances, a good written &lt;code&gt;README&lt;/code&gt; in an empty directory is usually a better solution. (And I do not know if this works with a windows filesystem...)</source>
          <target state="translated">但是我强烈建议仅在特殊情况下使用此解决方案，在空目录中编写良好的 &lt;code&gt;README&lt;/code&gt; 文件通常是更好的解决方案。 （而且我不知道这是否适用于Windows文件系统...）</target>
        </trans-unit>
        <trans-unit id="204ee4ab94277da69a779db2a898d64b3886bdd5" translate="yes" xml:space="preserve">
          <source>Create an empty file called &lt;code&gt;.gitkeep&lt;/code&gt; in the directory, and add that.</source>
          <target state="translated">在目录中创建一个名为 &lt;code&gt;.gitkeep&lt;/code&gt; 的空文件，并将其添加。</target>
        </trans-unit>
        <trans-unit id="53f860381ebc4d59d1571298edcbb7f65b9e7033" translate="yes" xml:space="preserve">
          <source>Create your empty directory:</source>
          <target state="translated">创建你的空目录。</target>
        </trans-unit>
        <trans-unit id="63c79f01306ce2c1fdcd4302cc3efd54a5fbf20b" translate="yes" xml:space="preserve">
          <source>Creating a &lt;code&gt;.gitignore&lt;/code&gt; file with a sort of &quot;reverse logic&quot; (i.e. to include all the files) which, at the end, serves the same purpose of approach #1.</source>
          <target state="translated">创建具有某种&amp;ldquo;反向逻辑&amp;rdquo;（即包括所有文件）的 &lt;code&gt;.gitignore&lt;/code&gt; 文件，最后，该方法具有与方法1相同的目的。</target>
        </trans-unit>
        <trans-unit id="a40e01a66ccfdfc021d7951d7b2e682524016ace" translate="yes" xml:space="preserve">
          <source>Creating reproducible GIT commits is surprisingly hard&amp;hellip;</source>
          <target state="translated">创建可重现的GIT提交非常困难&amp;hellip;&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="dd6a02a553da4cb247f914011dd67c37487ec082" translate="yes" xml:space="preserve">
          <source>Ctrl</source>
          <target state="translated">Ctrl</target>
        </trans-unit>
        <trans-unit id="f47719f4b93d12245afcb6b378a55e51cb7baab4" translate="yes" xml:space="preserve">
          <source>Currently the design of the git index
  (staging area) only permits files to
  be listed, and nobody competent enough
  to make the change to allow empty
  directories has cared enough about
  this situation to remedy it.</source>
          <target state="translated">目前,git索引(暂存区)的设计只允许列出文件,没有人有能力做出允许空目录的改变,也没有人有足够的能力去纠正这种情况。</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="82e82713359cdaaafb72b46a6e1882670542c2ef" translate="yes" xml:space="preserve">
          <source>Delete &lt;code&gt;.submodules&lt;/code&gt; file and commit the change.</source>
          <target state="translated">删除 &lt;code&gt;.submodules&lt;/code&gt; 文件并提交更改。</target>
        </trans-unit>
        <trans-unit id="30b45d9391fc566055c2446c75bdd98979449a2e" translate="yes" xml:space="preserve">
          <source>Directories are added automatically
  when adding files inside them. That
  is, directories never have to be added
  to the repository, and are not tracked
  on their own.</source>
          <target state="translated">目录是在添加目录内的文件时自动添加的。也就是说,目录从来不需要添加到资源库中,也不会自行跟踪。</target>
        </trans-unit>
        <trans-unit id="2b9eceb7a86a9f577ef80586c5c1d7fde9ff493d" translate="yes" xml:space="preserve">
          <source>Enter</source>
          <target state="translated">Enter</target>
        </trans-unit>
        <trans-unit id="24a34e8586a6fe7adbf4df3b5903f1f20ba96a9d" translate="yes" xml:space="preserve">
          <source>Enter: &lt;a href=&quot;https://gitlab.com/empty-repo/empty.git&quot;&gt;https://gitlab.com/empty-repo/empty.git&lt;/a&gt;</source>
          <target state="translated">输入： &lt;a href=&quot;https://gitlab.com/empty-repo/empty.git&quot;&gt;https&lt;/a&gt; ： //gitlab.com/empty-repo/empty.git</target>
        </trans-unit>
        <trans-unit id="a4812472ded0e1206418736ef926fbf3549ac4b5" translate="yes" xml:space="preserve">
          <source>Find all the empty folders in the directory</source>
          <target state="translated">找到目录中的所有空文件夹</target>
        </trans-unit>
        <trans-unit id="6fc62c55ea835d429e6f2c2649c12b929bdef0d6" translate="yes" xml:space="preserve">
          <source>First create the needed directory:</source>
          <target state="translated">首先创建需要的目录。</target>
        </trans-unit>
        <trans-unit id="4d831780e1be8efe8f863fef86feaa1ec0c4bb58" translate="yes" xml:space="preserve">
          <source>First things first:</source>
          <target state="translated">首先要做的事情是:</target>
        </trans-unit>
        <trans-unit id="388d5fca9cb393c73059a212159a7d23344c109b" translate="yes" xml:space="preserve">
          <source>For instance, you should use READMEs as, well, READMEs with useful information, not as an excuse to keep the folder.</source>
          <target state="translated">例如,你应该把READMEs作为,嗯,READMEs的有用信息,而不是作为保留文件夹的借口。</target>
        </trans-unit>
        <trans-unit id="afd17bd7401c7f01a2081091f425ec0aa178eef9" translate="yes" xml:space="preserve">
          <source>Git does not track empty directories. See the &lt;a href=&quot;https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F&quot;&gt;Git FAQ&lt;/a&gt; for more explanation. The suggested workaround is to put a &lt;code&gt;.gitignore&lt;/code&gt; file in the empty directory. I do not like that solution, because the &lt;code&gt;.gitignore&lt;/code&gt; is &quot;hidden&quot; by Unix convention. Also there is no explanation why the directories are empty.</source>
          <target state="translated">Git不会跟踪空目录。 有关更多说明，请参见&lt;a href=&quot;https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F&quot;&gt;Git FAQ&lt;/a&gt; 。 建议的解决方法是将 &lt;code&gt;.gitignore&lt;/code&gt; 文件放在空目录中。 我不喜欢这种解决方案，因为 &lt;code&gt;.gitignore&lt;/code&gt; 被Unix约定&amp;ldquo;隐藏&amp;rdquo;。 也没有解释为什么目录为空。</target>
        </trans-unit>
        <trans-unit id="abf7a55b985a75376342b4667163ebbc63f5923d" translate="yes" xml:space="preserve">
          <source>Git will store the latest commit hash when creating the submodule reference, so you don't have to worry about me (or GitLab) using this to inject malicious files. Unfortunately I have not found any way to force which commit ID is used during checkout, so you'll have to manually check that the reference commit ID is &lt;code&gt;e84d7b81f0033399e325b8037ed2b801a5c994e0&lt;/code&gt; using &lt;code&gt;git submodule status&lt;/code&gt; after adding the repo.</source>
          <target state="translated">Git在创建子模块引用时将存储最新的提交哈希，因此您不必担心我（或GitLab）使用它来注入恶意文件。 不幸的是，我没有找到任何方法来强制在结帐期间使用哪个提交ID，因此您必须在添加回购后使用 &lt;code&gt;git submodule status&lt;/code&gt; 手动检查引用提交ID是否为 &lt;code&gt;e84d7b81f0033399e325b8037ed2b801a5c994e0&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="db50b939caa3ae7b84670ab53010e4af37c2f3c3" translate="yes" xml:space="preserve">
          <source>Here is a hack, but it's funny that it works (Git 2.2.1). Similar to what @Teka suggested, but easier to remember:</source>
          <target state="translated">这里有一个黑客,但很有趣的是,它的工作原理(Git 2.2.1)。和@Teka建议的类似,但更容易记住。</target>
        </trans-unit>
        <trans-unit id="34f32b59bdf6637082ef61a348b5705dfef7d5f3" translate="yes" xml:space="preserve">
          <source>How can I add an empty directory (that contains no files) to a Git repository?</source>
          <target state="translated">如何在Git仓库中添加一个空目录(不包含任何文件)?</target>
        </trans-unit>
        <trans-unit id="0e45c641df1a90759be618c6e1cdc42dbd52a6aa" translate="yes" xml:space="preserve">
          <source>How can I add an empty directory to a Git repository</source>
          <target state="translated">如何在Git仓库中添加一个空目录?</target>
        </trans-unit>
        <trans-unit id="c56cbbc0db85f25f2cb2b5fed84e8bb724a6cf5c" translate="yes" xml:space="preserve">
          <source>However, if you don't already (and won't) use any Git submodules in your repository, and the &quot;empty&quot; folder will remain empty or if you want Git to know of its existence and ignore its content, you can go with this tweak. Going the usual way with submodules takes more steps that this tweak.</source>
          <target state="translated">但是,如果你已经(也不会)在你的仓库中使用任何 Git 子模块,并且 &quot;空 &quot;文件夹仍然是空的,或者你想让 Git 知道它的存在而忽略它的内容,你可以使用这个调整。如果你想让 Git 知道子模块的存在,你可以使用这个调整。</target>
        </trans-unit>
        <trans-unit id="d7afc7e7ad9e4271b572fcd3ae18972213f21d5e" translate="yes" xml:space="preserve">
          <source>However, only a handful of our developers work on Mac or Linux. A lot work on Windows and I could not find an equivalent simple one-liner to accomplish the same there. Some were lucky enough to have &lt;a href=&quot;http://cygwin.com/&quot;&gt;Cygwin&lt;/a&gt; installed for other reasons, but prescribing Cygwin just for this seemed overkill.</source>
          <target state="translated">但是，只有少数开发人员可以在Mac或Linux上工作。 在Windows上进行了大量工作，我找不到等效的简单一线工具在Windows上完成相同的工作。 有些人很幸运因为其他原因安装了&lt;a href=&quot;http://cygwin.com/&quot;&gt;Cygwin&lt;/a&gt; ，但是仅仅为此开处方Cygwin似乎有些过头。</target>
        </trans-unit>
        <trans-unit id="13f53a1c26556881cd505b26923bea72fd3ab01b" translate="yes" xml:space="preserve">
          <source>I always build a function to check for my desired folder structure and build it for me within the project. This gets around this problem as the empty folders are held in Git by proxy.</source>
          <target state="translated">我总是建立一个函数来检查我所需要的文件夹结构,然后在项目中为我建立。这就解决了这个问题,因为空文件夹是通过代理的方式保存在Git中。</target>
        </trans-unit>
        <trans-unit id="e45fece1abd6f90f892e145a9e915efb5e5cfe68" translate="yes" xml:space="preserve">
          <source>I found &lt;em&gt;&lt;a href=&quot;http://markmail.org/message/4eqjxx73opiswfis&quot;&gt;Re: Empty directories..&lt;/a&gt;&lt;/em&gt;, but maybe there is another one.</source>
          <target state="translated">我发现&lt;em&gt;&lt;a href=&quot;http://markmail.org/message/4eqjxx73opiswfis&quot;&gt;Re：空目录..&lt;/a&gt;&lt;/em&gt; ，但也许还有另一个。</target>
        </trans-unit>
        <trans-unit id="cec4839d0fd9dcd4f41fe6fdf0c182675133d9e8" translate="yes" xml:space="preserve">
          <source>I found a solution while playing with Git internals!</source>
          <target state="translated">我在玩Git内部的时候找到了一个解决方案!</target>
        </trans-unit>
        <trans-unit id="72bc357e57efa0f7705c578621ba96ce18f6e6cd" translate="yes" xml:space="preserve">
          <source>I have stuck this in a Rakefile for easy access.</source>
          <target state="translated">我把它夹在Rakefile里,方便访问。</target>
        </trans-unit>
        <trans-unit id="75374da781eaeff20a4b10d655362c8fc04030b2" translate="yes" xml:space="preserve">
          <source>I hope you find it useful.</source>
          <target state="translated">希望大家觉得有用。</target>
        </trans-unit>
        <trans-unit id="2b5864cd78e42492f8da9b2ebfb0ea04618da5a1" translate="yes" xml:space="preserve">
          <source>I like the answers by @Artur79 and @mjs so I've been using a combination of both and made it a standard for our projects.</source>
          <target state="translated">我喜欢@Artur79和@mjs的回答,所以我一直在使用这两个人的答案,并将其作为我们项目的标准。</target>
        </trans-unit>
        <trans-unit id="68d2ec6eb602fadce9c838e0feee9b9302798d60" translate="yes" xml:space="preserve">
          <source>I suggest to put a README file in the empty directory explaining why the directory is empty and why it needs to be tracked in Git. With the README file in place, as far as Git is concerned, the directory is no longer empty.</source>
          <target state="translated">我建议在空目录中放一个README文件,解释一下为什么这个目录是空的,为什么需要在Git中跟踪。有了README文件,对于Git来说,这个目录就不再是空的了。</target>
        </trans-unit>
        <trans-unit id="a72a8fb57623c0f8806b374760683795900bb699" translate="yes" xml:space="preserve">
          <source>I think it's worth noting that this solution does precisely what the question asked for, but is not perhaps what many people looking at this question will have been looking for. This solution guarantees that the directory remains empty. It says &quot;I truly never want files checked in here&quot;. As opposed to &quot;I don't have any files to check in here, yet, but I need the directory here, files may be coming later&quot;.</source>
          <target state="translated">我认为值得注意的是,这个解决方案恰恰做到了问题的要求,但可能不是很多人看这个问题的人都会找的。这个解决方案保证了目录仍然是空的。它说的是 &quot;我真的不希望这里的文件被检查到&quot;。相对于 &quot;我现在还没有文件要在这里签到,但我需要这里的目录,文件可能以后会来&quot;。</target>
        </trans-unit>
        <trans-unit id="d2300172ae86404895cfc0ad7ea8c4955047cf15" translate="yes" xml:space="preserve">
          <source>I wouldn't encourage to use it though since it may stop working in the future versions of Git. Which may leave your repository corrupted.</source>
          <target state="translated">但我不鼓励使用它,因为它可能会在未来的 Git 版本中停止工作。这可能会导致你的仓库被损坏。</target>
        </trans-unit>
        <trans-unit id="39d2f303154b0d1585f3a6e0af983c9b6b2afbfc" translate="yes" xml:space="preserve">
          <source>I've been facing the issue with empty directories, too. The problem with using placeholder files is that you need to create them, and delete them, if they are not necessary anymore (because later on there were added sub-directories or files. With big source trees managing these placeholder files can be cumbersome and error prone.</source>
          <target state="translated">我也遇到过空目录的问题。使用占位符文件的问题是,你需要创建这些文件,如果不需要了,还要删除它们(因为后来又增加了子目录或文件。对于大的源码树来说,管理这些占位符文件会很麻烦,而且容易出错。</target>
        </trans-unit>
        <trans-unit id="c7601d68ee81f8e120259486e6b1ae12a9ccbac6" translate="yes" xml:space="preserve">
          <source>I've been using this solution since I found it. It appears to work exactly the same way as creating a submodule, except that no module is defined anywhere.
This leads to errors when issuing &lt;code&gt;git submodule init|update&lt;/code&gt;.
The problem is that &lt;code&gt;git update-index&lt;/code&gt; rewrites the &lt;code&gt;040000 tree&lt;/code&gt; part into &lt;code&gt;160000 commit&lt;/code&gt;.</source>
          <target state="translated">自找到以来，我一直在使用此解决方案。 除了没有在任何地方定义模块外，它的工作方式与创建子模块完全相同。 这在发出 &lt;code&gt;git submodule init|update&lt;/code&gt; 时导致错误。 问题是 &lt;code&gt;git update-index&lt;/code&gt; 将 &lt;code&gt;040000 tree&lt;/code&gt; 部分重写为 &lt;code&gt;160000 commit&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="5d351e13a8bcc336ead6a5f1d2d86c50443b1858" translate="yes" xml:space="preserve">
          <source>I've seen the &lt;code&gt;.gitkeep&lt;/code&gt; approach adopted by very important frameworks like &lt;a href=&quot;https://laravel.com/&quot;&gt;Laravel&lt;/a&gt;, &lt;a href=&quot;https://github.com/angular/angular-cli&quot;&gt;Angular-CLI&lt;/a&gt;.</source>
          <target state="translated">我已经看到非常重要的框架（例如&lt;a href=&quot;https://laravel.com/&quot;&gt;Laravel&lt;/a&gt; ， &lt;a href=&quot;https://github.com/angular/angular-cli&quot;&gt;Angular-CLI）&lt;/a&gt;采用了 &lt;code&gt;.gitkeep&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="c8c0e91122ef0e2ff25a3087273b4f747cbc7488" translate="yes" xml:space="preserve">
          <source>If you really need a directory to
  exist in checkouts you should create a
  file in it. .gitignore works well for
  this purpose; you can leave it empty,
  or fill in the names of files you
  expect to show up in the directory.</source>
          <target state="translated">如果你真的需要一个目录存在于checkouts中,你应该在这个目录中创建一个文件,.gitignore可以很好地实现这个目的;你可以让它空着,也可以填上你希望在目录中显示的文件名。</target>
        </trans-unit>
        <trans-unit id="b88b5727e398d6429615a95c050ef00e69f875c5" translate="yes" xml:space="preserve">
          <source>If you take the oft-suggested approach of checking in an almost-empty folder, you have the minor complexity of deleting the contents without also deleting the &quot;.gitignore&quot; file.</source>
          <target state="translated">如果你采取了人们常说的在一个几乎是空的文件夹中检查的方法,那么你就会有一个小麻烦,那就是在不删除&quot;.gitignore &quot;文件的情况下,删除内容而不删除&quot;.gitignore &quot;文件。</target>
        </trans-unit>
        <trans-unit id="166d76c7375556749fc9ca7b90405f0825334d89" translate="yes" xml:space="preserve">
          <source>If you want to add a folder that will house a lot of transient data in multiple semantic directories, then one approach is to add something like this to your root .gitignore...</source>
          <target state="translated">如果你想在多个语义目录中添加一个可以容纳大量瞬时数据的文件夹,那么有一种方法是在你的根目录.gitignore中添加类似这样的东西.....</target>
        </trans-unit>
        <trans-unit id="d5380b667e544ff8a24b9405c725ec14b0995cee" translate="yes" xml:space="preserve">
          <source>In other words, you need to add the .gitignore file to the index before you can tell Git to ignore it (and everything else in the empty directory).</source>
          <target state="translated">换句话说,你需要先把 .gitignore 文件添加到索引中,然后才能告诉 Git 忽略它(以及空目录中的其他东西)。</target>
        </trans-unit>
        <trans-unit id="8b7c46451552b6582259deab5c7ceb320e0fb3a4" translate="yes" xml:space="preserve">
          <source>In this example, you might check in a (broken) symbolic link to the directory so that you can access it without the &quot;.generated&quot; prefix (but this is optional).</source>
          <target state="translated">在这个例子中,你可能会在目录中检查一个(破损的)符号链接,这样你就可以在没有&quot;.generated &quot;前缀的情况下访问它(但这是可选的)。</target>
        </trans-unit>
        <trans-unit id="42e8b8ca648f88055ab3a7f7d1902e80c94e7f59" translate="yes" xml:space="preserve">
          <source>It simply won't be tracked. But there are scenarios in which &quot;versioning&quot; empty directories can be meaningful, for example:</source>
          <target state="translated">它根本不会被追踪。但有些情况下,&quot;版本化 &quot;空目录也是有意义的,比如说。</target>
        </trans-unit>
        <trans-unit id="483f2c3fbd5ff5e3af78d6c8c2adbfae854e7d94" translate="yes" xml:space="preserve">
          <source>It will add README files to all directories that are empty so those directories would be then added to the index.</source>
          <target state="translated">它会将README文件添加到所有空的目录中,这样这些目录就会被添加到索引中。</target>
        </trans-unit>
        <trans-unit id="a7b8e2ca1cdebbdc89287f27d67ef4cbeb716916" translate="yes" xml:space="preserve">
          <source>It will allow you to create and remove &lt;code&gt;.gitkeep&lt;/code&gt; files recursively, and it will also allow you to add messages to them for your peers to understand why those directories are important. This last bit is bonus. I thought it would be nice if the &lt;code&gt;.gitkeep&lt;/code&gt; files could be self-documenting.</source>
          <target state="translated">它将允许您递归地创建和删除 &lt;code&gt;.gitkeep&lt;/code&gt; 文件，还将使您可以向它们添加消息，以供您的同级了解这些目录的重要性。 最后一点是奖金。 我认为 &lt;code&gt;.gitkeep&lt;/code&gt; 文件可以自我记录会很好。</target>
        </trans-unit>
        <trans-unit id="2d06fc8a679b0a64d72b2527f4f092c409690681" translate="yes" xml:space="preserve">
          <source>Its purpose (&lt;strong&gt;keep&lt;/strong&gt;) is clearly stated and consistent and semantically opposed in its meaning to &lt;strong&gt;ignore&lt;/strong&gt;</source>
          <target state="translated">它的目的（ &lt;strong&gt;keep&lt;/strong&gt; ）清楚地说明了，并且在含义上是一致的，在语义上是对立的，可以&lt;strong&gt;忽略&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1fcb5763f6c039d05fea047246e4864f744c352d" translate="yes" xml:space="preserve">
          <source>Just have a look at: &lt;a href=&quot;http://code.google.com/p/markemptydirs&quot;&gt;http://code.google.com/p/markemptydirs&lt;/a&gt;</source>
          <target state="translated">看看： &lt;a href=&quot;http://code.google.com/p/markemptydirs&quot;&gt;http&lt;/a&gt; : //code.google.com/p/markemptydirs</target>
        </trans-unit>
        <trans-unit id="cb69e9e85d861cc1799a2ab90d75e5b238ce6c12" translate="yes" xml:space="preserve">
          <source>Let's say you need an empty directory named &lt;em&gt;tmp&lt;/em&gt; :</source>
          <target state="translated">假设您需要一个名为&lt;em&gt;tmp&lt;/em&gt;的空目录：</target>
        </trans-unit>
        <trans-unit id="dce834c48c9c506ecf25445f132f1074f7c14cdb" translate="yes" xml:space="preserve">
          <source>Making &lt;a href=&quot;https://stackoverflow.com/users/554807/greenasjade&quot;&gt;@GreenAsJade&lt;/a&gt;'s comment persistent:</source>
          <target state="translated">使&lt;a href=&quot;https://stackoverflow.com/users/554807/greenasjade&quot;&gt;@GreenAsJade&lt;/a&gt;的评论持续存在：</target>
        </trans-unit>
        <trans-unit id="6d48ddee3eda342f20f214a0de35f6e8991c5e24" translate="yes" xml:space="preserve">
          <source>Many have already answered this question. Just adding a PowerShell version here.</source>
          <target state="translated">这个问题很多人都已经回答过了。只是在这里增加一个PowerShell版本。</target>
        </trans-unit>
        <trans-unit id="bc06c8663b818722cd6a2623f281d92d7c20ea09" translate="yes" xml:space="preserve">
          <source>Many users suggest:</source>
          <target state="translated">很多网友建议。</target>
        </trans-unit>
        <trans-unit id="718082bfabee7c4536bec0a547e963a64c95428c" translate="yes" xml:space="preserve">
          <source>Maybe adding an empty directory seems like it would be the &lt;em&gt;path of least resistance&lt;/em&gt; because you have scripts that expect that directory to exist (maybe because it is a target for generated binaries).  Another approach would be to &lt;strong&gt;modify your scripts to create the directory as needed&lt;/strong&gt;.</source>
          <target state="translated">也许添加一个空目录似乎是&lt;em&gt;阻力最小&lt;/em&gt;的&lt;em&gt;路径，&lt;/em&gt;因为您有希望该目录存在的脚本（也许因为它是生成的二进制文件的目标）。 另一种方法是根据需要&lt;strong&gt;修改脚本以创建目录&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="72f8680bc8b66e814ab7ca0955e95906b0631a1d" translate="yes" xml:space="preserve">
          <source>Moreover, any file placed under that path won't ever be noticed by Git, as it thinks they belong to some other repository. This is nasty as it can easily be overlooked!</source>
          <target state="translated">此外,任何放在该路径下的文件都不会被Git注意到,因为它认为它们属于其他仓库。这很讨厌,因为它很容易被忽略。</target>
        </trans-unit>
        <trans-unit id="c0df808058afe069050fc4e72ff7757ce6b52a1e" translate="yes" xml:space="preserve">
          <source>Myself, I have a shell script that I use to do this.  Name the script whatever you whish, and either add it somewhere in your include path, or reference it directly:</source>
          <target state="translated">我自己,我有一个shell脚本,我用它来做这个。给脚本起个名字,随便你怎么命名,然后在你的include路径中添加它,或者直接引用它。</target>
        </trans-unit>
        <trans-unit id="d68274ce8fcc52dfb6e43b10d00cf3ff4bf0710d" translate="yes" xml:space="preserve">
          <source>Naming it &lt;code&gt;.gitkeep&lt;/code&gt; makes it very clear and straightforward from the filename itself (and also &lt;em&gt;to other developers&lt;/em&gt;, which is good for a shared project and one of the core purposes of a Git repository) that this file is</source>
          <target state="translated">将其命名为 &lt;code&gt;.gitkeep&lt;/code&gt; 可以使文件名本身（以及&lt;em&gt;其他开发人员）&lt;/em&gt;非常清楚，直接，这对于共享项目和Git存储库的核心目的之一都非常有用，即该文件是</target>
        </trans-unit>
        <trans-unit id="052b70f088afbe4cac5cfcc1c4886118408ce134" translate="yes" xml:space="preserve">
          <source>No message, no committed files.</source>
          <target state="translated">没有消息,没有承诺的文件。</target>
        </trans-unit>
        <trans-unit id="4641e3dd557f4ca80cc44f9bd23b7d1da32610b6" translate="yes" xml:space="preserve">
          <source>Now the log directory will be included in the tree. It is super-useful when deploying, so you won't have to write a routine to make log directories.</source>
          <target state="translated">现在,日志目录将被包含在树中。在部署的时候超级好用,不用再写一个例程来做日志目录了。</target>
        </trans-unit>
        <trans-unit id="1ffbbb66f36c1145f1fd9d30958754c95d2721a4" translate="yes" xml:space="preserve">
          <source>Now, if you want a way to do this at the command line, in one fell swoop, while &lt;em&gt;inside&lt;/em&gt; the directory you want to add, you can execute:</source>
          <target state="translated">现在，如果您想要一种在命令行中执行此操作的方法，只需轻轻一挥，即可在要添加的目录中执行以下操作：</target>
        </trans-unit>
        <trans-unit id="38954e49f281e7ece90f63890439a704cc47c830" translate="yes" xml:space="preserve">
          <source>Now, you have a directory that gets created when commit is checked out. An interesting thing though is that if you look at the content of tree object of this file you'll get:</source>
          <target state="translated">现在,你有一个目录,当提交被签出时就会被创建。一个有趣的事情是,如果你看一下这个文件的树形对象的内容,你会得到:</target>
        </trans-unit>
        <trans-unit id="54207b890566fccf2728625f4f05a22750569061" translate="yes" xml:space="preserve">
          <source>Of course this requires that the presence of the file won't cause your application to break.</source>
          <target state="translated">当然,这就要求文件的存在不会导致你的应用程序崩溃。</target>
        </trans-unit>
        <trans-unit id="d68f11b73fd1a28163d179879538eafbd4057fce" translate="yes" xml:space="preserve">
          <source>On Linux, this creates an empty file named &lt;code&gt;.keep&lt;/code&gt;. For what it's worth, this name is agnostic to Git, whereas &lt;code&gt;.gitkeep&lt;/code&gt; would be specific to Git. Secondly, as another user has noted, the &lt;code&gt;.git&lt;/code&gt; prefix convention should be reserved for files and directories that Git itself uses.</source>
          <target state="translated">在Linux上，这将创建一个名为 &lt;code&gt;.keep&lt;/code&gt; 的空文件。 就其价值而言，此名称与Git无关，而 &lt;code&gt;.gitkeep&lt;/code&gt; 将特定于Git。 其次，正如另一个用户所指出的， &lt;code&gt;.git&lt;/code&gt; 前缀约定应保留给Git本身使用的文件和目录。</target>
        </trans-unit>
        <trans-unit id="b0ad216a803a00613e01c41fc295c139ede68d11" translate="yes" xml:space="preserve">
          <source>Placing a &lt;code&gt;README&lt;/code&gt; file or another file with some content in order to make the directory non-empty, or</source>
          <target state="translated">将 &lt;code&gt;README&lt;/code&gt; 文件或其他文件放入某些内容，以使目录为非空，或者</target>
        </trans-unit>
        <trans-unit id="93eb92fdf4a152028fa81b55f63d32976354d372" translate="yes" xml:space="preserve">
          <source>Rather than &lt;em&gt;hacking a fake submodule into GIT&lt;/em&gt;, just &lt;strong&gt;add an empty real one&lt;/strong&gt;.</source>
          <target state="translated">与其&lt;strong&gt;添加&lt;/strong&gt; &lt;em&gt;一个假的子模块到GIT中&lt;/em&gt; ，不如&lt;strong&gt;添加一个真正的空子&lt;/strong&gt; &lt;em&gt;模块&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="bc6820d0a373db625fb96ec7de8c73508075f0c8" translate="yes" xml:space="preserve">
          <source>Reading &lt;a href=&quot;https://stackoverflow.com/a/8944077/277882&quot;&gt;@ofavre&lt;/a&gt;'s and &lt;a href=&quot;https://stackoverflow.com/a/27635349/277882&quot;&gt;@stanislav-bashkyrtsev&lt;/a&gt;'s answers using broken GIT submodule references to create the GIT directories, I'm surprised that nobody has suggested yet this simple amendment of the idea to make the whole thing sane and safe:</source>
          <target state="translated">使用损坏的GIT子模块引用来阅读&lt;a href=&quot;https://stackoverflow.com/a/8944077/277882&quot;&gt;@ofavre&lt;/a&gt;和&lt;a href=&quot;https://stackoverflow.com/a/27635349/277882&quot;&gt;@ stanislav-bashkyrtsev&lt;/a&gt;的答案来创建GIT目录，我感到惊讶的是，没有人提出这个想法的简单修改，以使整个过程理智而安全：</target>
        </trans-unit>
        <trans-unit id="23cdc9f7361b0d5b570a36dcba55ff9b5cae4bca" translate="yes" xml:space="preserve">
          <source>See this &lt;a href=&quot;https://stackoverflow.com/a/7229996/1882064&quot;&gt;SOF answer&lt;/a&gt; for further info - which also explains why some people find the competing convention of adding a .gitignore file (as stated in many answers here) confusing.</source>
          <target state="translated">请参阅此&lt;a href=&quot;https://stackoverflow.com/a/7229996/1882064&quot;&gt;SOF答案&lt;/a&gt;以获取更多信息-这也解释了为什么有些人发现添加.gitignore文件的竞争惯例（如此处许多答案所述）令人困惑。</target>
        </trans-unit>
        <trans-unit id="d6621ff4ffc0ff6569560bb0a2efc73f49936c0c" translate="yes" xml:space="preserve">
          <source>Separation of concerns is always a good thing, and you can still add a &lt;code&gt;.gitignore&lt;/code&gt; to ignore unwanted files.</source>
          <target state="translated">关注点分离始终是一件好事，您仍然可以添加 &lt;code&gt;.gitignore&lt;/code&gt; 来忽略不需要的文件。</target>
        </trans-unit>
        <trans-unit id="592714d4edcb65cef2e2c3b218225cb036a5b740" translate="yes" xml:space="preserve">
          <source>So you have some reason why you need an empty directory in git. Put that reason in the README file. That way other developers (and future you) know why the empty directory needs to be there. You will also know that you can remove the empty directory when the problem requiring the empty directory has been solved.</source>
          <target state="translated">所以你有一些原因,为什么你需要在git中的空目录。把这个理由写在 README 文件中。这样其他开发者(以及未来的你)就会知道为什么需要空目录。你也会知道,当需要空目录的问题解决后,你可以删除空目录。</target>
        </trans-unit>
        <trans-unit id="f4ddceacd9ef252bd2b26735610de3953bcaf160" translate="yes" xml:space="preserve">
          <source>So, since most of our developers already have &lt;a href=&quot;http://ant.apache.org/&quot;&gt;Ant&lt;/a&gt; installed, the first thing I thought of was to put together an Ant build file to accomplish this independently of the platform. This can still be found &lt;a href=&quot;https://github.com/mig82/gitkeep&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">因此，由于大多数开发人员已经安装了&lt;a href=&quot;http://ant.apache.org/&quot;&gt;Ant&lt;/a&gt; ，因此我想到的第一件事就是将Ant构建文件放在一起以独立于平台来完成此任务。 仍然可以在&lt;a href=&quot;https://github.com/mig82/gitkeep&quot;&gt;这里&lt;/a&gt;找到</target>
        </trans-unit>
        <trans-unit id="f7a7193ce04f935ddcdda5d451f93adfb51ede51" translate="yes" xml:space="preserve">
          <source>Some suggested workarounds</source>
          <target state="translated">建议的一些变通方法</target>
        </trans-unit>
        <trans-unit id="24d48e9605946eaa8d5b15a84c152609ade8789b" translate="yes" xml:space="preserve">
          <source>Sometimes you have to deal with bad written libraries or software, which need a &quot;real&quot; empty and existing directory. Putting a simple &lt;code&gt;.gitignore&lt;/code&gt; or &lt;code&gt;.keep&lt;/code&gt; might break them and cause a bug. The following might help in these cases, but no guarantee...</source>
          <target state="translated">有时，您必须处理不良的书面库或软件，这些库或软件需要&amp;ldquo;真实&amp;rdquo;的空目录和现有目录。 放置简单的 &lt;code&gt;.gitignore&lt;/code&gt; 或 &lt;code&gt;.keep&lt;/code&gt; 可能会破坏它们并导致错误。 在这些情况下，以下内容可能会有所帮助，但不能保证...</target>
        </trans-unit>
        <trans-unit id="cf726d64819da79e232e9449d98f66861477c78f" translate="yes" xml:space="preserve">
          <source>Still not a native solution, but the best we probably can have without somebody getting their hands &lt;em&gt;really&lt;/em&gt;, &lt;em&gt;really&lt;/em&gt; dirty in the GIT codebase.</source>
          <target state="translated">仍然不是本机解决方案，但是最好的解决方案可能是在没有人&lt;em&gt;真正&lt;/em&gt;掌握GIT代码库的前提下提供的。</target>
        </trans-unit>
        <trans-unit id="cf4be5ed3cfbdabce8848b04a368438be916697c" translate="yes" xml:space="preserve">
          <source>Suppose you are in your repository.</source>
          <target state="translated">假设你在你的存储库里。</target>
        </trans-unit>
        <trans-unit id="e9440e7d8743e5013dcfa9058a0b91853acdb142" translate="yes" xml:space="preserve">
          <source>That's it! Your empty folder is in your index. All you have to do is commit.</source>
          <target state="translated">就这样!你的空文件夹就在你的索引中。你所要做的就是提交。</target>
        </trans-unit>
        <trans-unit id="562923af0e1a8d102acfd05b50f5ffe1e3954ed4" translate="yes" xml:space="preserve">
          <source>That's it, check that in, and you have an empty, yet tracked, directory that you can track files in at some later time.</source>
          <target state="translated">就这样,检查进去,你就有了一个空的、但已被跟踪的目录,你可以在以后的某个时间跟踪文件。</target>
        </trans-unit>
        <trans-unit id="a953cbe252f4b95d3c8d893ebb5a8f6698c5ae93" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_on_Rails&quot;&gt;Ruby on Rails&lt;/a&gt; log folder creation way:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_on_Rails&quot;&gt;Ruby on Rails&lt;/a&gt;日志文件夹的创建方式：</target>
        </trans-unit>
        <trans-unit id="a065a9784ab6e7bdd148b461bc6d4ab1e93e44a6" translate="yes" xml:space="preserve">
          <source>The empty tree SHA-1 can be found by creating a new empty Git repository, &lt;code&gt;cd&lt;/code&gt; into it and issue &lt;code&gt;git write-tree&lt;/code&gt;, which outputs the empty tree SHA-1.</source>
          <target state="translated">可以通过创建一个新的空Git存储库，将其插入 &lt;code&gt;cd&lt;/code&gt; 并发出 &lt;code&gt;git write-tree&lt;/code&gt; ，找到空树SHA-1，以输出空树SHA-1。</target>
        </trans-unit>
        <trans-unit id="307e8e768a7cd49c93d468cac94e2255ed611a4f" translate="yes" xml:space="preserve">
          <source>The file can be named and contain anything you want, but most people use an empty file named &lt;code&gt;.gitkeep&lt;/code&gt; (although some people prefer the VCS-agnostic &lt;code&gt;.keep&lt;/code&gt;).</source>
          <target state="translated">可以命名该文件并包含所需的任何内容，但是大多数人都使用一个名为 &lt;code&gt;.gitkeep&lt;/code&gt; 的空文件（尽管有些人更喜欢与VCS无关的 &lt;code&gt;.keep&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="66f448f887e290279d30def41c251c99c2c81784" translate="yes" xml:space="preserve">
          <source>The format, as mentioned, is:</source>
          <target state="translated">格式,如前所述,是。</target>
        </trans-unit>
        <trans-unit id="e742b2cbc27fb33e33cca9e1072fb5dc2e8c6c74" translate="yes" xml:space="preserve">
          <source>The logfiles can be kept out by issuing,</source>
          <target state="translated">签发日志文件,可以将日志文件保存在外面。</target>
        </trans-unit>
        <trans-unit id="bf29dff62fdb5ee3fc2a33b322ef5c3f576f3005" translate="yes" xml:space="preserve">
          <source>The prefixed &lt;code&gt;.&lt;/code&gt; marks it as a hidden file.</source>
          <target state="translated">前缀 &lt;code&gt;.&lt;/code&gt; 将其标记为隐藏文件。</target>
        </trans-unit>
        <trans-unit id="adde9d966c336b6cf829e4ff186e0bdbb1f17fdb" translate="yes" xml:space="preserve">
          <source>The real question is why do you need the empty directory in git? Usually you have some sort of build script that can create the empty directory before compiling/running. If not then make one. That is a far better solution than putting empty directories in git.</source>
          <target state="translated">真正的问题是,你为什么需要git中的空目录?通常情况下,你有一些构建脚本,可以在编译前创建空目录。如果没有,那就创建一个。这比在git中放空目录要好得多。</target>
        </trans-unit>
        <trans-unit id="4e10a5f8b55bf16c877fb4a4db4028d201a75b3d" translate="yes" xml:space="preserve">
          <source>The reason I suggest keeping that one line in the file is that it gives the &lt;code&gt;.gitignore&lt;/code&gt; purpose. Otherwise, some one down the line may think to remove it.  It may help if you place a comment above the line.</source>
          <target state="translated">我建议在文件中保留一行的原因是它提供了 &lt;code&gt;.gitignore&lt;/code&gt; 目的。 否则，某些人可能会考虑将其删除。 如果您将注释放在行上方，则可能会有所帮助。</target>
        </trans-unit>
        <trans-unit id="44dd342bd16c11fefd5f44220831e5efdbe41a34" translate="yes" xml:space="preserve">
          <source>Then do</source>
          <target state="translated">那就去做</target>
        </trans-unit>
        <trans-unit id="271ab51f7d49757a4117bf808028499958faf787" translate="yes" xml:space="preserve">
          <source>Then you add a broken symbolic link to this directory (but on any other case than the described use case above, please use a &lt;code&gt;README&lt;/code&gt; with an explanation):</source>
          <target state="translated">然后，您将一个损坏的符号链接添加到该目录（但是在上述使用案例之外的任何其他情况下，请使用 &lt;code&gt;README&lt;/code&gt; 并附有说明）：</target>
        </trans-unit>
        <trans-unit id="cbe8b088983da206fee5cb9a90a567c09bef564f" translate="yes" xml:space="preserve">
          <source>Then you can commit descriptive README.md files (or blank files, doesn't matter, as long as you can target them uniquely like with the &lt;code&gt;*.md&lt;/code&gt; in this case) in each directory to ensure that the directories all remain part of the repo but the files (with extensions) are kept ignored. LIMITATION: &lt;code&gt;.&lt;/code&gt;'s are not allowed in the directory names!</source>
          <target state="translated">然后，您可以在每个目录中提交描述性的README.md文件（或空白文件，没关系，只要您可以使用 &lt;code&gt;*.md&lt;/code&gt; 进行唯一定位即可），以确保目录都保留在目录中。回购，但文件（带有扩展名）被忽略。 限制： &lt;code&gt;.&lt;/code&gt; 目录名称中不允许使用！</target>
        </trans-unit>
        <trans-unit id="61c9cbd5afc1886a9d4c83796b2f8645d0725617" translate="yes" xml:space="preserve">
          <source>Then you don't have to get the order right the way that you have to do in m104's &lt;a href=&quot;https://stackoverflow.com/a/180917/32453&quot;&gt;solution&lt;/a&gt;.</source>
          <target state="translated">这样，您就不必像m104 &lt;a href=&quot;https://stackoverflow.com/a/180917/32453&quot;&gt;解决方案&lt;/a&gt;中那样正确地获得订单。</target>
        </trans-unit>
        <trans-unit id="4738c75f9da892a390366657d2ab91d093af9b84" translate="yes" xml:space="preserve">
          <source>There is a rant out there somewhere I read once.</source>
          <target state="translated">我曾在某处读到过一句话:&quot;我在外面的某个地方读到过。</target>
        </trans-unit>
        <trans-unit id="26fa8fd7ec96a6040db82979ba4051519106b223" translate="yes" xml:space="preserve">
          <source>There is no need to further alter your &lt;code&gt;.gitignore&lt;/code&gt; or decentralise by creating a new &lt;code&gt;.gitignore&lt;/code&gt; for each new directory. Probably not the smartest solution but is terse gitignore-wise and always works for me. Nice and simple! ;)</source>
          <target state="translated">无需通过为每个新目录创建一个新的 &lt;code&gt;.gitignore&lt;/code&gt; 来进一步更改 &lt;code&gt;.gitignore&lt;/code&gt; 或进行分散化。 可能不是最聪明的解决方案，但简洁明了，始终为我工作。 漂亮又简单！ ;）</target>
        </trans-unit>
        <trans-unit id="e4a770f2fd29b2be505353071c334d0fd6d58785" translate="yes" xml:space="preserve">
          <source>There's no way to get Git to track directories, so the only solution is to add a placeholder file within the directory that you want Git to track.</source>
          <target state="translated">没有办法让Git跟踪目录,所以唯一的解决办法就是在目录中添加一个占位符文件,让Git跟踪。</target>
        </trans-unit>
        <trans-unit id="1ae5f2188a715c59168ab614b7195164558364d0" translate="yes" xml:space="preserve">
          <source>This also gives the benefit that files in that directory won't show up as &quot;untracked&quot; when you do a git status.</source>
          <target state="translated">这样做的好处是,当你做git状态时,该目录下的文件不会显示为 &quot;未追踪&quot;。</target>
        </trans-unit>
        <trans-unit id="1d51a99a1263426f38791134a8084992fd3d9699" translate="yes" xml:space="preserve">
          <source>This commands shows an empty result, since no files are present in this directory. So most applications, which get all files in a directory usually do not see this link, at least if they do a &quot;file exists&quot; or a &quot;is readable&quot;. Even some scripts will not find any files there:</source>
          <target state="translated">这个命令显示的结果是空的,因为这个目录中没有文件存在。所以,大多数程序,获取一个目录中的所有文件,通常不会看到这个链接,至少如果他们做了 &quot;文件存在 &quot;或 &quot;是可读&quot;,也不会看到这个链接。甚至有些脚本也不会在那里找到任何文件。</target>
        </trans-unit>
        <trans-unit id="941a2713b26907b0edfc9326db1fe8fd6d6259ce" translate="yes" xml:space="preserve">
          <source>This is in PHP, but I am sure most languages support the same functionality, and because the creation of the folders is taken care of by the application, the folders will always be there.</source>
          <target state="translated">这是在PHP中,但我相信大多数语言都支持同样的功能,而且由于文件夹的创建是由应用程序负责的,所以文件夹会一直存在。</target>
        </trans-unit>
        <trans-unit id="0231a3e6089a1a461ba784b7f40b45deb15617c7" translate="yes" xml:space="preserve">
          <source>This is why I decided to write an open source tool which can manage the creation/deletion of such placeholder files automatically. It is written for .NET platform and runs under Mono (.NET for Linux) and Windows.</source>
          <target state="translated">这就是为什么我决定写一个开源工具,它可以自动管理这种占位符文件的创建和删除。它是为.NET平台编写的,可以在Mono(.NET for Linux)和Windows下运行。</target>
        </trans-unit>
        <trans-unit id="0ff65b1e79038cf9e8c142a884be4f581f2e90a5" translate="yes" xml:space="preserve">
          <source>This solution is short and apparently works fine (&lt;strong&gt;see the EDIT!&lt;/strong&gt;), but it is not that easy to remember...</source>
          <target state="translated">这个解决方案很短，并且显然可以正常工作（ &lt;strong&gt;请参见EDIT！&lt;/strong&gt; ），但是它并不容易记住...</target>
        </trans-unit>
        <trans-unit id="8669dd39694b308e5b298072467437705670849e" translate="yes" xml:space="preserve">
          <source>This will add a folder and a file &lt;code&gt;.submodules&lt;/code&gt;. Commit a change.</source>
          <target state="translated">这将添加一个文件夹和一个文件 &lt;code&gt;.submodules&lt;/code&gt; 。 提交更改。</target>
        </trans-unit>
        <trans-unit id="447b2024267dea2031844c6f68742d0c73587964" translate="yes" xml:space="preserve">
          <source>To add an empty directory to you GIT repo:</source>
          <target state="translated">要添加一个空的目录到你的GIT repo中,你可以使用以下方法。</target>
        </trans-unit>
        <trans-unit id="490916f50c4d5acc4a001cfc2ae3064c52b31c17" translate="yes" xml:space="preserve">
          <source>To add the ignored file, use a parameter to force it:</source>
          <target state="translated">要添加被忽略的文件,可以使用一个参数来强制添加。</target>
        </trans-unit>
        <trans-unit id="b5b5dd30965da188d3bdbf913bf64ed36eb60fb6" translate="yes" xml:space="preserve">
          <source>To convert all existing empty directories to submodules:</source>
          <target state="translated">将所有现有的空目录转换为子模块。</target>
        </trans-unit>
        <trans-unit id="d8c3c4fd1ad227759ac5eda9bde9680891d85369" translate="yes" xml:space="preserve">
          <source>To create placeholder READMEs in every empty directory:</source>
          <target state="translated">在每个空目录中创建占位符READMEs。</target>
        </trans-unit>
        <trans-unit id="d059071611973c155c1fa728cc1dc8d54a784477" translate="yes" xml:space="preserve">
          <source>To ignore everything in the directory except the README file put the following lines in your &lt;code&gt;.gitignore&lt;/code&gt;:</source>
          <target state="translated">要忽略目录中除README文件以外的所有内容，请在 &lt;code&gt;.gitignore&lt;/code&gt; 中放入以下几行：</target>
        </trans-unit>
        <trans-unit id="8d5ad49ffa75003ce93790e45a213bfc2c5568dc" translate="yes" xml:space="preserve">
          <source>To ignore files in this directory, you can add it in your root &lt;code&gt;.gitignore&lt;/code&gt;:</source>
          <target state="translated">要忽略此目录中的文件，可以将其添加到根 &lt;code&gt;.gitignore&lt;/code&gt; 中 ：</target>
        </trans-unit>
        <trans-unit id="4d28181251c8e026869f72e94fcb9f913bb43572" translate="yes" xml:space="preserve">
          <source>To list every README after they are already created:</source>
          <target state="translated">将每一个README创建完成后再列出。</target>
        </trans-unit>
        <trans-unit id="eb5231ed99174cb588bedfa581b7186849bdd9e4" translate="yes" xml:space="preserve">
          <source>To list every empty directory use the following command:</source>
          <target state="translated">要列出每个空目录,请使用以下命令。</target>
        </trans-unit>
        <trans-unit id="f5fd9c123a60713e27942ff28cd8c0c830fcdd51" translate="yes" xml:space="preserve">
          <source>Type the command and then enter the second line. Press</source>
          <target state="translated">键入该命令,然后输入第二行。按</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="ffd1db763848f4c4472ac7f7473013edf19585c9" translate="yes" xml:space="preserve">
          <source>Use an &lt;em&gt;empty&lt;/em&gt; file called &lt;code&gt;.gitkeep&lt;/code&gt; in order to force the presence of the folder in the versioning system.</source>
          <target state="translated">使用一个名为 &lt;code&gt;.gitkeep&lt;/code&gt; 的&lt;em&gt;空&lt;/em&gt;文件，以强制在版本控制系统中存在该文件夹。</target>
        </trans-unit>
        <trans-unit id="cddf6b9a46a0454ba89ee38e73b711678e2deb70" translate="yes" xml:space="preserve">
          <source>When you add a &lt;code&gt;.gitignore&lt;/code&gt; file, if you are going to put any amount of content in it (that you want Git to ignore) you might want to add a single line with just an asterisk &lt;code&gt;*&lt;/code&gt; to make sure you don't add the ignored content accidentally.</source>
          <target state="translated">添加 &lt;code&gt;.gitignore&lt;/code&gt; 文件时，如果要在其中添加任意数量的内容（您希望Git忽略），则可能需要添加仅带有星号 &lt;code&gt;*&lt;/code&gt; 的一行，以确保您不添加意外地忽略了内容。</target>
        </trans-unit>
        <trans-unit id="fe8fd8f26e88b908b2a3b55d4634c460d8e2a8ec" translate="yes" xml:space="preserve">
          <source>When you want to clean up your source tree you can just:</source>
          <target state="translated">当你想清理你的源头树时,你可以只。</target>
        </trans-unit>
        <trans-unit id="eeadc9a1aaa0db3bc40739107087ee919a727078" translate="yes" xml:space="preserve">
          <source>While &lt;em&gt;both solutions surely work&lt;/em&gt; I find them inconsistent with a meaningful approach to Git versioning.</source>
          <target state="translated">虽然&lt;em&gt;这两种解决方案都能正常工作，但&lt;/em&gt;我发现它们与有意义的Git版本控制方法不一致。</target>
        </trans-unit>
        <trans-unit id="b62d1c6896a552b6058f125d41d2a8a506cf5359" translate="yes" xml:space="preserve">
          <source>Why are you supposed to put bogus files or READMEs that maybe you don't really want in your project?</source>
          <target state="translated">为什么你要在你的项目中放一些假文件或READMEs,也许你真的不想要?</target>
        </trans-unit>
        <trans-unit id="b3cc7336ea3346a09abac426eb677ad323e9fdd1" translate="yes" xml:space="preserve">
          <source>Why use &lt;code&gt;.gitignore&lt;/code&gt; to do a thing (&lt;em&gt;keeping&lt;/em&gt; files) that is the very opposite of what it's meant for (&lt;em&gt;excluding&lt;/em&gt; files), even though it is possible?</source>
          <target state="translated">即使可能，为什么要使用 &lt;code&gt;.gitignore&lt;/code&gt; 做某事（ &lt;em&gt;保留&lt;/em&gt;文件），这与它的意图（ &lt;em&gt;排除&lt;/em&gt;文件）完全相反？</target>
        </trans-unit>
        <trans-unit id="103215cec6138a09084b9458c3ce747f188a10b4" translate="yes" xml:space="preserve">
          <source>Why would we need empty versioned folders</source>
          <target state="translated">为什么我们需要空版本的文件夹?</target>
        </trans-unit>
        <trans-unit id="4ce5d0388c01b6cedd52787992f8c7a955244236" translate="yes" xml:space="preserve">
          <source>With this solution you are able to commit a empty folder, for example &lt;code&gt;/log&lt;/code&gt;, &lt;code&gt;/tmp&lt;/code&gt; or &lt;code&gt;/cache&lt;/code&gt; and the folder will stay empty.</source>
          <target state="translated">使用此解决方案，您可以提交一个空文件夹，例如 &lt;code&gt;/log&lt;/code&gt; ， &lt;code&gt;/tmp&lt;/code&gt; 或 &lt;code&gt;/cache&lt;/code&gt; ,并且该文件夹将保持为空。</target>
        </trans-unit>
        <trans-unit id="f23151da0deaa4d23f72fa98790c48326765298a" translate="yes" xml:space="preserve">
          <source>With this, you can either execute it from within the directory you wish to add, or reference the directory as it's first and only parameter:</source>
          <target state="translated">有了这个,你可以在你想添加的目录中执行,或者引用目录作为它的第一个也是唯一的参数。</target>
        </trans-unit>
        <trans-unit id="4aec0f970702275a4ff389c3481cbd12213f0065" translate="yes" xml:space="preserve">
          <source>You can fill up all of these directories with xml/images files or whatever and add more directories under &lt;code&gt;/app/data/&lt;/code&gt; over time as the storage needs for your app develop (with the README.md files serving to burn in a description of what each storage directory is for exactly).</source>
          <target state="translated">您可以使用xml / images文件或任何其他文件填充所有这些目录，并随着 &lt;code&gt;/app/data/&lt;/code&gt; 存储需求的增长，在/ app / data /下添加更多目录（其中README.md文件用于刻录对什么内容的描述）每个存储目录都是针对的）。</target>
        </trans-unit>
        <trans-unit id="368ecf61c201184ca1eca5a09d4b430bba4475ac" translate="yes" xml:space="preserve">
          <source>You can ignore all of your generated files by adding the following to your root .gitignore:</source>
          <target state="translated">你可以通过在你的根目录.gitignore中添加以下内容来忽略所有生成的文件。</target>
        </trans-unit>
        <trans-unit id="db3768f3cbb474672a2f790a2f3a93556c86a883" translate="yes" xml:space="preserve">
          <source>You can save this code as create_readme.php and run the &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt; code from the root directory of your Git project.</source>
          <target state="translated">您可以将此代码另存为create_readme.php并从Git项目的根目录运行&lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt;代码。</target>
        </trans-unit>
        <trans-unit id="35e7674c15b829e3da47e9c91c17c0b45bbbcbc4" translate="yes" xml:space="preserve">
          <source>You can say &quot;&lt;code&gt;git add &amp;lt;dir&amp;gt;&lt;/code&gt;&quot; and it
  will add files in there.</source>
          <target state="translated">您可以说&amp;ldquo; &lt;code&gt;git add &amp;lt;dir&amp;gt;&lt;/code&gt; &amp;rdquo;，它将在其中添加文件。</target>
        </trans-unit>
        <trans-unit id="6cfdb4128821ccf4042227c42e6a3ce5eff4c3ec" translate="yes" xml:space="preserve">
          <source>You can't and unfortunately will never be able to. This is a decision made by Linus Torvald himself. He knows what's good for us.</source>
          <target state="translated">你不能,也很不幸的是永远不能。这是由莱纳斯-托瓦尔德自己做的决定。他知道什么是对我们有好处的。</target>
        </trans-unit>
        <trans-unit id="96422f8128e7582ea39f5a813f28720ea292d5ce" translate="yes" xml:space="preserve">
          <source>You can't.  See the &lt;a href=&quot;https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F&quot;&gt;Git FAQ&lt;/a&gt;.</source>
          <target state="translated">你不能 请参阅&lt;a href=&quot;https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F&quot;&gt;Git常见问题解答&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="22ca8c67077a960213c9270a133c31b59f499c76" translate="yes" xml:space="preserve">
          <source>You can't. This is an intentional design decision by the Git maintainers. Basically, the purpose of a Source Code Management System like Git is managing source code and empty directories aren't source code. Git is also often described as a content tracker, and again, empty directories aren't content (quite the opposite, actually), so they are not tracked.</source>
          <target state="translated">你不能这样做。这是Git维护者的一个有意的设计决定。基本上,像Git这样的源码管理系统的目的是管理源码,而空目录不是源码。Git也经常被描述为内容跟踪器,同样,空目录也不是内容(其实恰恰相反),所以不会被跟踪。</target>
        </trans-unit>
        <trans-unit id="803b77036ef8698000e9339edcd62fd703594653" translate="yes" xml:space="preserve">
          <source>You could always put a README file in the directory with an explanation of why you want this, otherwise empty, directory in the repository.</source>
          <target state="translated">你可以在目录中放一个README文件,并说明你为什么要这个目录,否则就是空的。</target>
        </trans-unit>
        <trans-unit id="dcee5b95aba60fafa22b894110eb63499a6ee4d7" translate="yes" xml:space="preserve">
          <source>You have to live with the workarounds...unfortunately.</source>
          <target state="translated">不幸的是,你必须得接受变通......不幸的是。</target>
        </trans-unit>
        <trans-unit id="03f9d41dc6b8f480026623afffc50b5a20a7c5da" translate="yes" xml:space="preserve">
          <source>You should be able to recreate this exact commit using (in an empty directory):</source>
          <target state="translated">你应该能够使用(在一个空目录中)重新创建这个确切的提交。</target>
        </trans-unit>
        <trans-unit id="9487aa6e228be403f7931650f0ee33843eff1948" translate="yes" xml:space="preserve">
          <source>You use a file that has the &lt;em&gt;single&lt;/em&gt; purpose of keeping the folder. You don't put there any info you don't want to put.</source>
          <target state="translated">您使用的文件仅具有保留文件夹的目的。 您不会在此处放置任何您不想放置的信息。</target>
        </trans-unit>
        <trans-unit id="50e789a4519a8bfb4201a8cf539afda28392b287" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;.gitignore&lt;/code&gt; file would look like:</source>
          <target state="translated">您的 &lt;code&gt;.gitignore&lt;/code&gt; 文件如下所示：</target>
        </trans-unit>
        <trans-unit id="a357a0b3b6bb01e41a042b584904f6b12375f3f1" translate="yes" xml:space="preserve">
          <source>and then</source>
          <target state="translated">而后</target>
        </trans-unit>
        <trans-unit id="c6f38c96c5ac4615934334f5e2718109ae1691d4" translate="yes" xml:space="preserve">
          <source>but you probably knew that.</source>
          <target state="translated">但你可能知道。</target>
        </trans-unit>
        <trans-unit id="31a8afc956c3b38d471b6f69f007533194f0e239" translate="yes" xml:space="preserve">
          <source>fatal: Not a valid object name
  b64338b90b4209263b50244d18278c0999867193</source>
          <target state="translated">fatal:不是有效的对象名称b64338b90b4209263b50244d18278c0999867193</target>
        </trans-unit>
        <trans-unit id="7ed76119035d1dc7e53e02cf1cd68c1b13efd79d" translate="yes" xml:space="preserve">
          <source>related to the above, some projects &lt;em&gt;won't work without some folders&lt;/em&gt; (which is often a hint of a poorly designed project, but it's a frequent real-world scenario and maybe there could be, say, permission problems to be addressed).</source>
          <target state="translated">与此相关的是，某些项目&lt;em&gt;如果没有某些文件夹将无法工作&lt;/em&gt; （这通常是项目设计不佳的暗示，但这是一个经常在现实世界中出现的场景，也许可能会解决权限问题）。</target>
        </trans-unit>
        <trans-unit id="87b56ec500c49bd553a7cff70a8680d17089dd52" translate="yes" xml:space="preserve">
          <source>scaffolding a &lt;strong&gt;predefined folder structure&lt;/strong&gt;, making it available to every user/contributor of the repository; or, as a specialized case of the above, creating a folder for &lt;strong&gt;temporary files&lt;/strong&gt;, such as a &lt;code&gt;cache/&lt;/code&gt; or &lt;code&gt;logs/&lt;/code&gt; directories, where we want to provide the folder but &lt;code&gt;.gitignore&lt;/code&gt; its contents</source>
          <target state="translated">&lt;strong&gt;搭建预定义的文件夹结构&lt;/strong&gt; ，使其可用于存储库的每个用户/贡献者； 或者，作为上述的一种特殊情况，为&lt;strong&gt;临时文件&lt;/strong&gt; （例如 &lt;code&gt;cache/&lt;/code&gt; 或 &lt;code&gt;logs/&lt;/code&gt; 目录）创建一个文件夹，我们要在其中提供该文件夹，但是 &lt;code&gt;.gitignore&lt;/code&gt; 它的内容</target>
        </trans-unit>
        <trans-unit id="a9dc3140cab3fe6f3324bc773106f6dea351ca23" translate="yes" xml:space="preserve">
          <source>to terminate your input.
Note: the format is &lt;em&gt;mode&lt;/em&gt; [SPACE] &lt;em&gt;type&lt;/em&gt; [SPACE] SHA-1hash &lt;strong&gt;[TAB]&lt;/strong&gt; path (the tab is important, the answer formatting does not preserve it).</source>
          <target state="translated">终止您的输入。 注意：格式为&lt;em&gt;模式&lt;/em&gt; [空格] &lt;em&gt;类型&lt;/em&gt; [空格] SHA-1散列&lt;strong&gt;[TAB]&lt;/strong&gt;路径（选项卡很重要，答案格式不会保留它）。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
