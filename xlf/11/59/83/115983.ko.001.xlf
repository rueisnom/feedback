<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/115983">
    <body>
      <group id="115983">
        <trans-unit id="a979ef10cc6f6a36df6b8a323307ee3bb2e2db9c" translate="yes" xml:space="preserve">
          <source>+</source>
          <target state="translated">+</target>
        </trans-unit>
        <trans-unit id="54dfe2f7832271935a1233868d84cc1176f6f8c3" translate="yes" xml:space="preserve">
          <source>.gitkeep approach</source>
          <target state="translated">.gitkeep 접근 방식</target>
        </trans-unit>
        <trans-unit id="965e73fdd6e46ed980c8bdf03a589adab642edf9" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://stackoverflow.com/a/932982/456814&quot;&gt;The solution of Jamie Flournoy&lt;/a&gt; works great. Here is a bit enhanced version to keep the &lt;code&gt;.htaccess&lt;/code&gt; :</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/a/932982/456814&quot;&gt;Jamie Flournoy의 솔루션은&lt;/a&gt; 훌륭합니다. 다음은 &lt;code&gt;.htaccess&lt;/code&gt; 를 유지하기위한 약간 향상된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="4e021e8096db3c4f40241955870ff1f94ba900d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a55530aeccb75e9eeb062568b1cd54555a6a784b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit for a better solution&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;더 나은 솔루션을 위해 편집&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4481ac83b0f3173c1c526133aba6d8184bf1add" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;However&lt;/strong&gt;, I later thought It would be better to make this into a small utility command, so I recreated it using Python and published it to the PyPI &lt;a href=&quot;https://pypi.org/project/gitkeep2/&quot;&gt;here&lt;/a&gt;. You can install it by simply running:</source>
          <target state="translated">&lt;strong&gt;그러나&lt;/strong&gt; 나중에 이것을 작은 유틸리티 명령으로 만드는 것이 더 좋을 것이라고 생각했기 때문에 파이썬을 사용하여 다시 만들고 PyPI에 게시했습니다. 간단히 다음을 실행하여 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="202469ff83d849ba4804312d74f79bb4ea71ff92" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Original post below:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;아래의 원본 게시물 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2e622355d0c04a203c2ae230ad42e052083e6c1f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;WARNING: This tweak is not truly working as it turns out.&lt;/strong&gt; Sorry for the inconvenience.</source>
          <target state="translated">&lt;strong&gt;경고 :이 조정은 실제로 작동하지 않습니다.&lt;/strong&gt; 불편을 드려 죄송합니다.</target>
        </trans-unit>
        <trans-unit id="101a20c7c6631be2b36cbef52a2cb2613a6724f4" translate="yes" xml:space="preserve">
          <source>A GIT repository with exactly one commit:</source>
          <target state="translated">정확히 하나의 커밋이있는 GIT 저장소 :</target>
        </trans-unit>
        <trans-unit id="5fa8d5d03c6966d644feecd12a13d42641e037f4" translate="yes" xml:space="preserve">
          <source>A file clearly related to Git</source>
          <target state="translated">Git과 관련된 파일</target>
        </trans-unit>
        <trans-unit id="1613e56a1fc0205ddfa3ab0bfb1dab82dacc86c1" translate="yes" xml:space="preserve">
          <source>A file unrelated to the code (because of the leading dot and the name)</source>
          <target state="translated">코드와 관련이없는 파일 (앞의 점과 이름으로 인해)</target>
        </trans-unit>
        <trans-unit id="f6920857980f2d91e8c0805986b7d6808c9af1ce" translate="yes" xml:space="preserve">
          <source>Add a empty .gitkeep file in there</source>
          <target state="translated">거기에 빈 .gitkeep 파일 추가</target>
        </trans-unit>
        <trans-unit id="41f9d35d45a5809f08ddb210d46278bb6f19b01c" translate="yes" xml:space="preserve">
          <source>Add a submodule to any repository (&lt;code&gt;git submodule add path_to_repo&lt;/code&gt;)</source>
          <target state="translated">저장소에 &lt;code&gt;git submodule add path_to_repo&lt;/code&gt; ( git submodule add path_to_repo )</target>
        </trans-unit>
        <trans-unit id="7f257395a529eabc4dadeed1ba30bccd729c2da6" translate="yes" xml:space="preserve">
          <source>Add it to the index using a plumbing command and the empty tree &lt;a href=&quot;http://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt;:</source>
          <target state="translated">배관 명령과 빈 트리 &lt;a href=&quot;http://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1을&lt;/a&gt; 사용하여 색인에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="94916474ca86f077fbf26f834c5faca8838d0984" translate="yes" xml:space="preserve">
          <source>Adding one more option to the fray.</source>
          <target state="translated">전투에 하나 이상의 옵션을 추가.</target>
        </trans-unit>
        <trans-unit id="9d9855d155abfb00319d620ad3008e951f075bcb" translate="yes" xml:space="preserve">
          <source>Adoption</source>
          <target state="translated">Adoption</target>
        </trans-unit>
        <trans-unit id="99970754935cc627f1a4d7e256aaac3733fca7f9" translate="yes" xml:space="preserve">
          <source>After the commit you have a broken symbolic link in your index and git creates the directory. The broken link has some advantages, since it is no regular file and points to no regular file. So it even fits to the part of the question &quot;(that contains no files)&quot;, not by the intention but by the meaning, I guess:</source>
          <target state="translated">커밋 후 인덱스에 깨진 심볼릭 링크가 있고 git은 디렉토리를 만듭니다. 끊어진 링크는 일반 파일이 아니고 일반 파일이 아니기 때문에 몇 가지 장점이 있습니다. 따라서 그것은 의도적으로가 아니라 의미에 의해 &quot;(파일을 포함하지 않는)&quot;이라는 질문의 부분에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b7d6d9bb1e8d27ac23a196714647227815b05a51" translate="yes" xml:space="preserve">
          <source>Alternatively, as noted in another &lt;a href=&quot;https://stackoverflow.com/a/5305908/832230&quot;&gt;answer&lt;/a&gt;, the directory can contain a descriptive &lt;a href=&quot;https://stackoverflow.com/questions/8655937/github-readme-and-readme-md&quot;&gt;&lt;code&gt;README&lt;/code&gt; or &lt;code&gt;README.md&lt;/code&gt; file&lt;/a&gt; instead.</source>
          <target state="translated">또는 다른 &lt;a href=&quot;https://stackoverflow.com/a/5305908/832230&quot;&gt;답변&lt;/a&gt; 에서 언급했듯이 디렉토리에는 설명적인 &lt;a href=&quot;https://stackoverflow.com/questions/8655937/github-readme-and-readme-md&quot;&gt; &lt;code&gt;README&lt;/code&gt; 또는 &lt;code&gt;README.md&lt;/code&gt; 파일이&lt;/a&gt; 대신 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="205e51c8e1ece1ffd2fce77ba495ccd116607ccf" translate="yes" xml:space="preserve">
          <source>Alternatively, you could just exclude &lt;em&gt;every&lt;/em&gt; README file from being ignored:</source>
          <target state="translated">또는 &lt;em&gt;모든&lt;/em&gt; README 파일이 무시되지 않도록 제외시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4117f5e31a8f100fe678077742923976451bc72f" translate="yes" xml:space="preserve">
          <source>Although it may seem not such a big difference:</source>
          <target state="translated">그렇게 큰 차이는 아니지만 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1744eb66f2436ca0f0c9f01a0155762ce350072a" translate="yes" xml:space="preserve">
          <source>An easy way to do this is by adding a &lt;code&gt;.gitkeep&lt;/code&gt; file to the directory you wish to (currently) keep empty.</source>
          <target state="translated">이 작업을 수행하는 쉬운 방법은 &lt;code&gt;.gitkeep&lt;/code&gt; 파일을 현재 디렉토리를 비 우려 는 디렉토리에 추가하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="219f59595254577d0c91a349dfa6d30d4e67e595" translate="yes" xml:space="preserve">
          <source>An empty directory &lt;em&gt;cannot be part of a tree under the Git versioning system&lt;/em&gt;.</source>
          <target state="translated">빈 디렉토리 &lt;em&gt;는 Git 버전 관리 시스템에서 트리의 일부가 될 수 없습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="362f60ebf0e843cd145df3739ab29dfe432e6594" translate="yes" xml:space="preserve">
          <source>Andy Lester is right, but if your directory just needs to be empty, and not &lt;em&gt;empty&lt;/em&gt; empty, you can put an empty &lt;code&gt;.gitignore&lt;/code&gt; file in there as a workaround.</source>
          <target state="translated">Andy Lester가 맞지만 디렉토리가 비어 있고 비어 있지 않아야하는 경우 해결 방법으로 빈 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="673af2d6ba313c8fac9157b8704d15350b4c0a6d" translate="yes" xml:space="preserve">
          <source>Another idea would be to add a &lt;code&gt;README&lt;/code&gt; file explaining what the directory will be used for.</source>
          <target state="translated">또 다른 아이디어는 디렉토리가 사용될 대상을 설명하는 &lt;code&gt;README&lt;/code&gt; 파일을 추가하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1ec908de3e9396e1c85db9b6afb773449d35d181" translate="yes" xml:space="preserve">
          <source>Another option (in response to a comment by @GreenAsJade), if you want to track an empty folder that &lt;em&gt;MAY&lt;/em&gt; contain tracked files in the future, but will be empty for now, you can ommit the &lt;code&gt;*&lt;/code&gt; from the &lt;code&gt;.gitignore&lt;/code&gt; file, and check &lt;em&gt;that&lt;/em&gt; in.  Basically, all the file is saying is &quot;do not ignore &lt;em&gt;me&lt;/em&gt;&quot;, but otherwise, the directory is empty and tracked.</source>
          <target state="translated">다른 옵션 (@GreenAsJade의 의견에 대한 응답)은 나중에 추적 파일을 포함 할 수 있지만 현재 비어있는 빈 폴더를 추적하려는 경우 &lt;code&gt;.gitignore&lt;/code&gt; 파일에서 &lt;code&gt;*&lt;/code&gt; 를 생략 하고 확인할 수 있습니다 기본적으로 모든 파일은 &quot; &lt;em&gt;나를&lt;/em&gt; 무시하지 마십시오&quot;라고 말하지만, 그렇지 않으면 디렉토리가 비어 있고 추적됩니다.</target>
        </trans-unit>
        <trans-unit id="e3cd64b3958a23e5561c2201ea3cd924a9116ba2" translate="yes" xml:space="preserve">
          <source>Another way to make a directory stay (almost) empty (in the repository) is to create a &lt;code&gt;.gitignore&lt;/code&gt; file inside that directory that contains these four lines:</source>
          <target state="translated">디렉토리를 (거의) 빈 상태로 유지하는 또 다른 방법은 다음 네 줄을 포함하는 디렉토리 내에 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8ada30d97d2322a43013b97b2132220ba3c00e8a" translate="yes" xml:space="preserve">
          <source>Appendix: Recreating this commit</source>
          <target state="translated">부록 :이 커밋 재 작성</target>
        </trans-unit>
        <trans-unit id="dc15c49fe1e32d89a01fe92846b02027eac99394" translate="yes" xml:space="preserve">
          <source>As an aside, this is an implementation issue, not a fundamental Git storage design problem. As has been mentioned many times on the Git mailing list, the reason that this has not been implemented is that no one has cared enough to submit a patch for it, not that it couldn&amp;rsquo;t or shouldn&amp;rsquo;t be done.</source>
          <target state="translated">제쳐두고 이것은 기본적인 Git 스토리지 디자인 문제가 아니라 구현 문제입니다. Git 메일 링리스트에서 여러 번 언급 한 것처럼, 이것이 구현되지 않은 이유는 패치를 제출할 수있는 사람이 아무도 없었기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="3239a01b066eacc1ab9371152bfd4916f5f2b8e9" translate="yes" xml:space="preserve">
          <source>As described in other answers, Git is unable to represent empty directories in its staging area. (See the &lt;a href=&quot;https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F&quot;&gt;Git FAQ&lt;/a&gt;.) However, if, for your purposes, a directory is empty enough if it contains a &lt;code&gt;.gitignore&lt;/code&gt; file only, then you can create &lt;code&gt;.gitignore&lt;/code&gt; files in empty directories only via:</source>
          <target state="translated">다른 답변에서 설명했듯이 Git은 준비 영역에서 빈 디렉토리를 나타낼 수 없습니다. ( &lt;a href=&quot;https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F&quot;&gt;Git FAQ&lt;/a&gt; 참조) 그러나 &lt;code&gt;.gitignore&lt;/code&gt; 파일 만 포함 된 디렉토리가 비어있는 경우 다음을 통해서만 빈 디렉토리에 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3aa328f227341220383e651bc6b4c7fbf977534" translate="yes" xml:space="preserve">
          <source>As mentioned it's not possible to add empty directories, but here is a one liner that adds empty .gitignore files to all directories.</source>
          <target state="translated">언급했듯이 빈 디렉토리를 추가 할 수는 없지만 빈 .gitignore 파일을 모든 디렉토리에 추가하는 하나의 라이너가 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f582e5d97d10444178705b3520e63053106d73b" translate="yes" xml:space="preserve">
          <source>Assuming you would like to add a directory to &lt;code&gt;git&lt;/code&gt; that, for all purposes related to &lt;code&gt;git&lt;/code&gt;, should remain empty and never have it's contents tracked, a &lt;code&gt;.gitignore&lt;/code&gt; as suggested numerous times here, will do the trick.</source>
          <target state="translated">&lt;code&gt;git&lt;/code&gt; 과 관련된 모든 목적을 위해 git에 디렉토리를 추가한다고 가정하면 내용을 추적하지 않아야합니다. 여러 번 제안 된 &lt;code&gt;.gitignore&lt;/code&gt; 는 트릭을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="23613439d97605dcd248fd94d6a238984f2dc5ca" translate="yes" xml:space="preserve">
          <source>But I strongly recommend to use this solution only in special circumstances, a good written &lt;code&gt;README&lt;/code&gt; in an empty directory is usually a better solution. (And I do not know if this works with a windows filesystem...)</source>
          <target state="translated">그러나 특별한 상황에서만이 솔루션을 사용하는 것이 좋습니다. 빈 디렉토리에 서면으로 작성된 &lt;code&gt;README&lt;/code&gt; 가 일반적으로 더 나은 솔루션입니다. (그리고 이것이 Windows 파일 시스템에서 작동하는지 모르겠습니다 ...)</target>
        </trans-unit>
        <trans-unit id="204ee4ab94277da69a779db2a898d64b3886bdd5" translate="yes" xml:space="preserve">
          <source>Create an empty file called &lt;code&gt;.gitkeep&lt;/code&gt; in the directory, and add that.</source>
          <target state="translated">디렉토리에 &lt;code&gt;.gitkeep&lt;/code&gt; 이라는 빈 파일을 작성하고 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="53f860381ebc4d59d1571298edcbb7f65b9e7033" translate="yes" xml:space="preserve">
          <source>Create your empty directory:</source>
          <target state="translated">빈 디렉토리를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="63c79f01306ce2c1fdcd4302cc3efd54a5fbf20b" translate="yes" xml:space="preserve">
          <source>Creating a &lt;code&gt;.gitignore&lt;/code&gt; file with a sort of &quot;reverse logic&quot; (i.e. to include all the files) which, at the end, serves the same purpose of approach #1.</source>
          <target state="translated">&quot;역 논리&quot;의 일종 (즉, 모든 파일을 포함하는)으로 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 생성합니다 . 결국, 동일한 접근 방법 # 1을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a40e01a66ccfdfc021d7951d7b2e682524016ace" translate="yes" xml:space="preserve">
          <source>Creating reproducible GIT commits is surprisingly hard&amp;hellip;</source>
          <target state="translated">재현 가능한 GIT 커밋을 만드는 것은 놀랍도록 어렵습니다&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="dd6a02a553da4cb247f914011dd67c37487ec082" translate="yes" xml:space="preserve">
          <source>Ctrl</source>
          <target state="translated">Ctrl</target>
        </trans-unit>
        <trans-unit id="f47719f4b93d12245afcb6b378a55e51cb7baab4" translate="yes" xml:space="preserve">
          <source>Currently the design of the git index
  (staging area) only permits files to
  be listed, and nobody competent enough
  to make the change to allow empty
  directories has cared enough about
  this situation to remedy it.</source>
          <target state="translated">현재 git index (스테이징 영역)의 디자인은 파일을 나열하는 것만 허용하며 빈 디렉토리를 허용하도록 변경 할만 큼 유능한 사람은 아무도이 상황을 해결하기에 충분하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="82e82713359cdaaafb72b46a6e1882670542c2ef" translate="yes" xml:space="preserve">
          <source>Delete &lt;code&gt;.submodules&lt;/code&gt; file and commit the change.</source>
          <target state="translated">&lt;code&gt;.submodules&lt;/code&gt; 파일을 삭제하고 변경 사항을 커밋하십시오.</target>
        </trans-unit>
        <trans-unit id="30b45d9391fc566055c2446c75bdd98979449a2e" translate="yes" xml:space="preserve">
          <source>Directories are added automatically
  when adding files inside them. That
  is, directories never have to be added
  to the repository, and are not tracked
  on their own.</source>
          <target state="translated">디렉토리는 파일을 추가 할 때 자동으로 추가됩니다. 즉, 디렉토리를 저장소에 추가 할 필요가 없으며 자체적으로 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2b9eceb7a86a9f577ef80586c5c1d7fde9ff493d" translate="yes" xml:space="preserve">
          <source>Enter</source>
          <target state="translated">Enter</target>
        </trans-unit>
        <trans-unit id="24a34e8586a6fe7adbf4df3b5903f1f20ba96a9d" translate="yes" xml:space="preserve">
          <source>Enter: &lt;a href=&quot;https://gitlab.com/empty-repo/empty.git&quot;&gt;https://gitlab.com/empty-repo/empty.git&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://gitlab.com/empty-repo/empty.git&quot;&gt;https://gitlab.com/empty-repo/empty.git를&lt;/a&gt; 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="a4812472ded0e1206418736ef926fbf3549ac4b5" translate="yes" xml:space="preserve">
          <source>Find all the empty folders in the directory</source>
          <target state="translated">디렉토리에서 빈 폴더를 모두 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="6fc62c55ea835d429e6f2c2649c12b929bdef0d6" translate="yes" xml:space="preserve">
          <source>First create the needed directory:</source>
          <target state="translated">먼저 필요한 디렉토리를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="4d831780e1be8efe8f863fef86feaa1ec0c4bb58" translate="yes" xml:space="preserve">
          <source>First things first:</source>
          <target state="translated">먼저 첫 번째 것들:</target>
        </trans-unit>
        <trans-unit id="388d5fca9cb393c73059a212159a7d23344c109b" translate="yes" xml:space="preserve">
          <source>For instance, you should use READMEs as, well, READMEs with useful information, not as an excuse to keep the folder.</source>
          <target state="translated">예를 들어, 폴더를 유지하는 데 대한 변명이 아니라 README와 유용한 정보가있는 README를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="afd17bd7401c7f01a2081091f425ec0aa178eef9" translate="yes" xml:space="preserve">
          <source>Git does not track empty directories. See the &lt;a href=&quot;https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F&quot;&gt;Git FAQ&lt;/a&gt; for more explanation. The suggested workaround is to put a &lt;code&gt;.gitignore&lt;/code&gt; file in the empty directory. I do not like that solution, because the &lt;code&gt;.gitignore&lt;/code&gt; is &quot;hidden&quot; by Unix convention. Also there is no explanation why the directories are empty.</source>
          <target state="translated">힘내는 빈 디렉토리를 추적하지 않습니다. 자세한 설명은 &lt;a href=&quot;https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F&quot;&gt;Git FAQ&lt;/a&gt; 를 참조하십시오. 제안 된 해결 방법은 빈 디렉토리에 &lt;code&gt;.gitignore&lt;/code&gt; 파일을 넣는 것입니다. &lt;code&gt;.gitignore&lt;/code&gt; 가 유닉스 규칙에 의해 &quot;숨겨져&quot;있기 때문에 나는 그 해결책을 좋아하지 않는다. 또한 디렉토리가 비어있는 이유에 대한 설명이 없습니다.</target>
        </trans-unit>
        <trans-unit id="abf7a55b985a75376342b4667163ebbc63f5923d" translate="yes" xml:space="preserve">
          <source>Git will store the latest commit hash when creating the submodule reference, so you don't have to worry about me (or GitLab) using this to inject malicious files. Unfortunately I have not found any way to force which commit ID is used during checkout, so you'll have to manually check that the reference commit ID is &lt;code&gt;e84d7b81f0033399e325b8037ed2b801a5c994e0&lt;/code&gt; using &lt;code&gt;git submodule status&lt;/code&gt; after adding the repo.</source>
          <target state="translated">Git은 서브 모듈 참조를 생성 할 때 최신 커밋 해시를 저장하므로 악의적 인 파일을 주입하기 위해 이것을 사용하는 저 (또는 GitLab)에 대해 걱정할 필요가 없습니다. 불행히도 체크 아웃 중에 어떤 커밋 ID가 사용되도록 강제 할 수있는 방법을 찾지 &lt;code&gt;e84d7b81f0033399e325b8037ed2b801a5c994e0&lt;/code&gt; 를 추가 한 후 &lt;code&gt;git submodule status&lt;/code&gt; 사용하여 참조 커밋 ID가 e84d7b81f0033399e325b8037ed2b801a5c994e0인지 수동으로 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="db50b939caa3ae7b84670ab53010e4af37c2f3c3" translate="yes" xml:space="preserve">
          <source>Here is a hack, but it's funny that it works (Git 2.2.1). Similar to what @Teka suggested, but easier to remember:</source>
          <target state="translated">해킹이 있지만 작동하는 것은 재미 있습니다 (Git 2.2.1). @Teka가 제안한 것과 비슷하지만 기억하기 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="34f32b59bdf6637082ef61a348b5705dfef7d5f3" translate="yes" xml:space="preserve">
          <source>How can I add an empty directory (that contains no files) to a Git repository?</source>
          <target state="translated">파일이없는 빈 디렉토리를 Git 저장소에 어떻게 추가 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="0e45c641df1a90759be618c6e1cdc42dbd52a6aa" translate="yes" xml:space="preserve">
          <source>How can I add an empty directory to a Git repository</source>
          <target state="translated">빈 디렉토리를 Git 저장소에 추가하는 방법</target>
        </trans-unit>
        <trans-unit id="c56cbbc0db85f25f2cb2b5fed84e8bb724a6cf5c" translate="yes" xml:space="preserve">
          <source>However, if you don't already (and won't) use any Git submodules in your repository, and the &quot;empty&quot; folder will remain empty or if you want Git to know of its existence and ignore its content, you can go with this tweak. Going the usual way with submodules takes more steps that this tweak.</source>
          <target state="translated">그러나 저장소에서 Git 하위 모듈을 아직 사용하지 않고 사용하지 않는 경우 &quot;empty&quot;폴더는 비어 있거나 Git이 해당 내용을 알고 내용을 무시하도록하려면 이 조정. 서브 모듈을 사용하여 일반적인 방법으로 이동하면 더 많은 단계가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="d7afc7e7ad9e4271b572fcd3ae18972213f21d5e" translate="yes" xml:space="preserve">
          <source>However, only a handful of our developers work on Mac or Linux. A lot work on Windows and I could not find an equivalent simple one-liner to accomplish the same there. Some were lucky enough to have &lt;a href=&quot;http://cygwin.com/&quot;&gt;Cygwin&lt;/a&gt; installed for other reasons, but prescribing Cygwin just for this seemed overkill.</source>
          <target state="translated">그러나 소수의 개발자 만이 Mac 또는 Linux에서 작업합니다. Windows에서 많은 작업을 수행했으며 거기에서 동일한 작업을 수행하는 동등한 간단한 단일 라이너를 찾을 수 없었습니다. 일부는 다른 이유로 &lt;a href=&quot;http://cygwin.com/&quot;&gt;Cygwin을&lt;/a&gt; 설치하기에 운이 좋았지 만 Cygwin을 처방하는 것은 과도한 것으로 보였습니다.</target>
        </trans-unit>
        <trans-unit id="13f53a1c26556881cd505b26923bea72fd3ab01b" translate="yes" xml:space="preserve">
          <source>I always build a function to check for my desired folder structure and build it for me within the project. This gets around this problem as the empty folders are held in Git by proxy.</source>
          <target state="translated">나는 항상 원하는 폴더 구조를 확인하고 프로젝트 내에서 나를 위해 빌드하는 함수를 작성합니다. 빈 폴더가 프록시에 의해 Git에 유지되기 때문에이 문제를 해결합니다.</target>
        </trans-unit>
        <trans-unit id="e45fece1abd6f90f892e145a9e915efb5e5cfe68" translate="yes" xml:space="preserve">
          <source>I found &lt;em&gt;&lt;a href=&quot;http://markmail.org/message/4eqjxx73opiswfis&quot;&gt;Re: Empty directories..&lt;/a&gt;&lt;/em&gt;, but maybe there is another one.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;http://markmail.org/message/4eqjxx73opiswfis&quot;&gt;Re : Empty directory ..를&lt;/a&gt;&lt;/em&gt; 찾았지만 다른 &lt;em&gt;디렉토리&lt;/em&gt; 가있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cec4839d0fd9dcd4f41fe6fdf0c182675133d9e8" translate="yes" xml:space="preserve">
          <source>I found a solution while playing with Git internals!</source>
          <target state="translated">Git 내장을 가지고 노는 동안 해결책을 찾았습니다!</target>
        </trans-unit>
        <trans-unit id="72bc357e57efa0f7705c578621ba96ce18f6e6cd" translate="yes" xml:space="preserve">
          <source>I have stuck this in a Rakefile for easy access.</source>
          <target state="translated">쉽게 액세스 할 수 있도록 이것을 Rakefile에 고정했습니다.</target>
        </trans-unit>
        <trans-unit id="75374da781eaeff20a4b10d655362c8fc04030b2" translate="yes" xml:space="preserve">
          <source>I hope you find it useful.</source>
          <target state="translated">도움이 되셨기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="2b5864cd78e42492f8da9b2ebfb0ea04618da5a1" translate="yes" xml:space="preserve">
          <source>I like the answers by @Artur79 and @mjs so I've been using a combination of both and made it a standard for our projects.</source>
          <target state="translated">나는 @ Artur79와 @mjs의 답변을 좋아하므로 둘 다 조합하여 프로젝트의 표준으로 삼았습니다.</target>
        </trans-unit>
        <trans-unit id="68d2ec6eb602fadce9c838e0feee9b9302798d60" translate="yes" xml:space="preserve">
          <source>I suggest to put a README file in the empty directory explaining why the directory is empty and why it needs to be tracked in Git. With the README file in place, as far as Git is concerned, the directory is no longer empty.</source>
          <target state="translated">디렉토리가 비어있는 이유와 Git에서 추적 해야하는 이유를 설명하는 README 파일을 빈 디렉토리에 넣는 것이 좋습니다. README 파일이 있으면 Git과 관련하여 디렉토리가 더 이상 비어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a72a8fb57623c0f8806b374760683795900bb699" translate="yes" xml:space="preserve">
          <source>I think it's worth noting that this solution does precisely what the question asked for, but is not perhaps what many people looking at this question will have been looking for. This solution guarantees that the directory remains empty. It says &quot;I truly never want files checked in here&quot;. As opposed to &quot;I don't have any files to check in here, yet, but I need the directory here, files may be coming later&quot;.</source>
          <target state="translated">이 솔루션이 질문에서 요구 한 것을 정확하게 수행한다는 점은 주목할 가치가 있지만 아마도이 질문을 보는 많은 사람들이 찾고있는 것은 아닐 것입니다. 이 솔루션은 디렉토리가 비어 있도록 보장합니다. &quot;진짜로 파일을 체크인하고 싶지 않습니다&quot;라고 말합니다. &quot;여기에 체크인 할 파일이 없지만 여기에 디렉토리가 필요합니다. 파일이 나중에 올 수 있습니다&quot;.</target>
        </trans-unit>
        <trans-unit id="d2300172ae86404895cfc0ad7ea8c4955047cf15" translate="yes" xml:space="preserve">
          <source>I wouldn't encourage to use it though since it may stop working in the future versions of Git. Which may leave your repository corrupted.</source>
          <target state="translated">향후 버전의 Git에서 작동을 멈출 수 있기 때문에 사용하지 않는 것이 좋습니다. 저장소가 손상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39d2f303154b0d1585f3a6e0af983c9b6b2afbfc" translate="yes" xml:space="preserve">
          <source>I've been facing the issue with empty directories, too. The problem with using placeholder files is that you need to create them, and delete them, if they are not necessary anymore (because later on there were added sub-directories or files. With big source trees managing these placeholder files can be cumbersome and error prone.</source>
          <target state="translated">빈 디렉토리에서도 문제가 발생했습니다. 플레이스 홀더 파일을 사용할 때의 문제점은 더 이상 필요하지 않은 경우 파일을 작성하고 삭제해야한다는 것입니다 (나중에 서브 디렉토리 또는 파일이 추가 되었기 때문에이 플레이스 홀더 파일을 관리하는 큰 소스 트리를 사용하면 번거롭고 오류가 발생할 수 있습니다) 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7601d68ee81f8e120259486e6b1ae12a9ccbac6" translate="yes" xml:space="preserve">
          <source>I've been using this solution since I found it. It appears to work exactly the same way as creating a submodule, except that no module is defined anywhere.
This leads to errors when issuing &lt;code&gt;git submodule init|update&lt;/code&gt;.
The problem is that &lt;code&gt;git update-index&lt;/code&gt; rewrites the &lt;code&gt;040000 tree&lt;/code&gt; part into &lt;code&gt;160000 commit&lt;/code&gt;.</source>
          <target state="translated">이 솔루션을 찾은 이후로 사용하고 있습니다. 어디에도 모듈이 정의되어 있지 않다는 점을 제외하면 하위 모듈을 만드는 것과 정확히 같은 방식으로 작동합니다. &lt;code&gt;git submodule init|update&lt;/code&gt; 발행 할 때 오류가 발생합니다. 문제는 &lt;code&gt;git update-index&lt;/code&gt; 가 &lt;code&gt;040000 tree&lt;/code&gt; 부분을 &lt;code&gt;160000 commit&lt;/code&gt; 으로 다시 쓴다는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="5d351e13a8bcc336ead6a5f1d2d86c50443b1858" translate="yes" xml:space="preserve">
          <source>I've seen the &lt;code&gt;.gitkeep&lt;/code&gt; approach adopted by very important frameworks like &lt;a href=&quot;https://laravel.com/&quot;&gt;Laravel&lt;/a&gt;, &lt;a href=&quot;https://github.com/angular/angular-cli&quot;&gt;Angular-CLI&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://laravel.com/&quot;&gt;Laravel&lt;/a&gt; , &lt;a href=&quot;https://github.com/angular/angular-cli&quot;&gt;Angular-CLI&lt;/a&gt; 와 같은 매우 중요한 프레임 워크에서 채택 된 &lt;code&gt;.gitkeep&lt;/code&gt; 접근법을 보았습니다.</target>
        </trans-unit>
        <trans-unit id="c8c0e91122ef0e2ff25a3087273b4f747cbc7488" translate="yes" xml:space="preserve">
          <source>If you really need a directory to
  exist in checkouts you should create a
  file in it. .gitignore works well for
  this purpose; you can leave it empty,
  or fill in the names of files you
  expect to show up in the directory.</source>
          <target state="translated">체크 아웃에 디렉토리가 실제로 필요한 경우 파일을 작성해야합니다. .gitignore는이 목적에 적합합니다. 비워 두거나 디렉토리에 표시 될 파일 이름을 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b88b5727e398d6429615a95c050ef00e69f875c5" translate="yes" xml:space="preserve">
          <source>If you take the oft-suggested approach of checking in an almost-empty folder, you have the minor complexity of deleting the contents without also deleting the &quot;.gitignore&quot; file.</source>
          <target state="translated">거의 비어있는 폴더를 체크인하는 데 자주 제안되는 방식을 사용하는 경우 &quot;.gitignore&quot;파일도 삭제하지 않고 내용을 삭제하는 것이 약간 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="166d76c7375556749fc9ca7b90405f0825334d89" translate="yes" xml:space="preserve">
          <source>If you want to add a folder that will house a lot of transient data in multiple semantic directories, then one approach is to add something like this to your root .gitignore...</source>
          <target state="translated">여러 시맨틱 디렉토리에 많은 임시 데이터를 저장할 폴더를 추가하려면 루트 .gitignore에 이와 비슷한 것을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d5380b667e544ff8a24b9405c725ec14b0995cee" translate="yes" xml:space="preserve">
          <source>In other words, you need to add the .gitignore file to the index before you can tell Git to ignore it (and everything else in the empty directory).</source>
          <target state="translated">다시 말해, Git에게 무시하도록 (그리고 빈 디렉토리에있는 다른 모든 것) 인덱스에 .gitignore 파일을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="8b7c46451552b6582259deab5c7ceb320e0fb3a4" translate="yes" xml:space="preserve">
          <source>In this example, you might check in a (broken) symbolic link to the directory so that you can access it without the &quot;.generated&quot; prefix (but this is optional).</source>
          <target state="translated">이 예에서는 &quot;.generated&quot;접두사없이 액세스 할 수 있도록 디렉토리에 (깨진) 기호 링크를 체크인 할 수 있습니다 (그러나 이것은 선택적입니다).</target>
        </trans-unit>
        <trans-unit id="42e8b8ca648f88055ab3a7f7d1902e80c94e7f59" translate="yes" xml:space="preserve">
          <source>It simply won't be tracked. But there are scenarios in which &quot;versioning&quot; empty directories can be meaningful, for example:</source>
          <target state="translated">단순히 추적되지 않습니다. 그러나 빈 버전의 &quot;버전 관리&quot;가 의미가있는 시나리오가 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="483f2c3fbd5ff5e3af78d6c8c2adbfae854e7d94" translate="yes" xml:space="preserve">
          <source>It will add README files to all directories that are empty so those directories would be then added to the index.</source>
          <target state="translated">비어있는 모든 디렉토리에 README 파일을 추가하여 해당 디렉토리가 색인에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="a7b8e2ca1cdebbdc89287f27d67ef4cbeb716916" translate="yes" xml:space="preserve">
          <source>It will allow you to create and remove &lt;code&gt;.gitkeep&lt;/code&gt; files recursively, and it will also allow you to add messages to them for your peers to understand why those directories are important. This last bit is bonus. I thought it would be nice if the &lt;code&gt;.gitkeep&lt;/code&gt; files could be self-documenting.</source>
          <target state="translated">또한 &lt;code&gt;.gitkeep&lt;/code&gt; 파일을 재귀 적으로 생성 및 제거 할 수 있으며 피어가 해당 디렉토리가 중요한 이유를 이해할 수 있도록 메시지를 추가 할 수도 있습니다. 이 마지막 비트는 보너스입니다. &lt;code&gt;.gitkeep&lt;/code&gt; 파일이 자체 문서화 될 수 있다면 좋을 것이라고 생각했습니다.</target>
        </trans-unit>
        <trans-unit id="2d06fc8a679b0a64d72b2527f4f092c409690681" translate="yes" xml:space="preserve">
          <source>Its purpose (&lt;strong&gt;keep&lt;/strong&gt;) is clearly stated and consistent and semantically opposed in its meaning to &lt;strong&gt;ignore&lt;/strong&gt;</source>
          <target state="translated">그것의 목적 ( &lt;strong&gt;계속&lt;/strong&gt; )은 명확하게 언급되고 일관성 있고 의미 적으로 &lt;strong&gt;무시&lt;/strong&gt; 한다는 의미에서 반대된다</target>
        </trans-unit>
        <trans-unit id="1fcb5763f6c039d05fea047246e4864f744c352d" translate="yes" xml:space="preserve">
          <source>Just have a look at: &lt;a href=&quot;http://code.google.com/p/markemptydirs&quot;&gt;http://code.google.com/p/markemptydirs&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://code.google.com/p/markemptydirs&quot;&gt;http://code.google.com/p/markemptydirs를&lt;/a&gt; 살펴보십시오 .</target>
        </trans-unit>
        <trans-unit id="cb69e9e85d861cc1799a2ab90d75e5b238ce6c12" translate="yes" xml:space="preserve">
          <source>Let's say you need an empty directory named &lt;em&gt;tmp&lt;/em&gt; :</source>
          <target state="translated">&lt;em&gt;tmp&lt;/em&gt; 라는 빈 디렉토리가 필요하다고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="dce834c48c9c506ecf25445f132f1074f7c14cdb" translate="yes" xml:space="preserve">
          <source>Making &lt;a href=&quot;https://stackoverflow.com/users/554807/greenasjade&quot;&gt;@GreenAsJade&lt;/a&gt;'s comment persistent:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/554807/greenasjade&quot;&gt;@GreenAsJade&lt;/a&gt; 의 의견을 지속적으로 만들기 :</target>
        </trans-unit>
        <trans-unit id="6d48ddee3eda342f20f214a0de35f6e8991c5e24" translate="yes" xml:space="preserve">
          <source>Many have already answered this question. Just adding a PowerShell version here.</source>
          <target state="translated">많은 사람들이 이미이 질문에 대답했습니다. 여기에 PowerShell 버전을 추가하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="bc06c8663b818722cd6a2623f281d92d7c20ea09" translate="yes" xml:space="preserve">
          <source>Many users suggest:</source>
          <target state="translated">많은 사용자들이 제안합니다 :</target>
        </trans-unit>
        <trans-unit id="718082bfabee7c4536bec0a547e963a64c95428c" translate="yes" xml:space="preserve">
          <source>Maybe adding an empty directory seems like it would be the &lt;em&gt;path of least resistance&lt;/em&gt; because you have scripts that expect that directory to exist (maybe because it is a target for generated binaries).  Another approach would be to &lt;strong&gt;modify your scripts to create the directory as needed&lt;/strong&gt;.</source>
          <target state="translated">빈 디렉토리를 추가하면 해당 디렉토리가 존재할 것으로 예상되는 스크립트가 있기 때문에 &lt;em&gt;가장 저항이 적은 경로 인&lt;/em&gt; 것 같습니다 (아마 생성 된 바이너리의 대상 일 수 있음). 또 다른 방법은 &lt;strong&gt;스크립트&lt;/strong&gt; 를 &lt;strong&gt;수정하여 필요에 따라 디렉토리를 작성하는 것&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="72f8680bc8b66e814ab7ca0955e95906b0631a1d" translate="yes" xml:space="preserve">
          <source>Moreover, any file placed under that path won't ever be noticed by Git, as it thinks they belong to some other repository. This is nasty as it can easily be overlooked!</source>
          <target state="translated">또한 Git는 해당 경로 아래에있는 파일을 다른 저장소에 속한다고 생각하지 않습니다. 쉽게 간과 될 수 있으므로 불쾌합니다!</target>
        </trans-unit>
        <trans-unit id="c0df808058afe069050fc4e72ff7757ce6b52a1e" translate="yes" xml:space="preserve">
          <source>Myself, I have a shell script that I use to do this.  Name the script whatever you whish, and either add it somewhere in your include path, or reference it directly:</source>
          <target state="translated">나 자신, 나는 이것을하기 위해 사용하는 쉘 스크립트를 가지고있다. 원하는대로 스크립트의 이름을 지정하고 포함 경로의 어딘가에 추가하거나 직접 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d68274ce8fcc52dfb6e43b10d00cf3ff4bf0710d" translate="yes" xml:space="preserve">
          <source>Naming it &lt;code&gt;.gitkeep&lt;/code&gt; makes it very clear and straightforward from the filename itself (and also &lt;em&gt;to other developers&lt;/em&gt;, which is good for a shared project and one of the core purposes of a Git repository) that this file is</source>
          <target state="translated">이름을 &lt;code&gt;.gitkeep&lt;/code&gt; 으로 지정하면 파일 이름 자체 (그리고 공유 프로젝트 및 Git 저장소의 핵심 목적 중 하나 인 &lt;em&gt;다른 개발자&lt;/em&gt; 에게도) 에서이 파일이 매우 명확하고 간단합니다.</target>
        </trans-unit>
        <trans-unit id="052b70f088afbe4cac5cfcc1c4886118408ce134" translate="yes" xml:space="preserve">
          <source>No message, no committed files.</source>
          <target state="translated">메시지가없고 커밋 된 파일이 없습니다.</target>
        </trans-unit>
        <trans-unit id="4641e3dd557f4ca80cc44f9bd23b7d1da32610b6" translate="yes" xml:space="preserve">
          <source>Now the log directory will be included in the tree. It is super-useful when deploying, so you won't have to write a routine to make log directories.</source>
          <target state="translated">이제 로그 디렉토리가 트리에 포함됩니다. 배포 할 때 매우 유용하므로 로그 디렉토리를 만들기 위해 루틴을 작성할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="1ffbbb66f36c1145f1fd9d30958754c95d2721a4" translate="yes" xml:space="preserve">
          <source>Now, if you want a way to do this at the command line, in one fell swoop, while &lt;em&gt;inside&lt;/em&gt; the directory you want to add, you can execute:</source>
          <target state="translated">이제 명령 줄 에서이 작업을 수행 할 수있는 방법을 원한다면 추가하려는 디렉토리 &lt;em&gt;안에&lt;/em&gt; 있는 동안 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38954e49f281e7ece90f63890439a704cc47c830" translate="yes" xml:space="preserve">
          <source>Now, you have a directory that gets created when commit is checked out. An interesting thing though is that if you look at the content of tree object of this file you'll get:</source>
          <target state="translated">이제 커밋이 체크 아웃 될 때 생성되는 디렉토리가 있습니다. 흥미로운 점은이 파일의 트리 객체의 내용을 보면 다음과 같은 결과를 얻을 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="54207b890566fccf2728625f4f05a22750569061" translate="yes" xml:space="preserve">
          <source>Of course this requires that the presence of the file won't cause your application to break.</source>
          <target state="translated">물론 파일이 존재하더라도 응용 프로그램이 중단되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="d68f11b73fd1a28163d179879538eafbd4057fce" translate="yes" xml:space="preserve">
          <source>On Linux, this creates an empty file named &lt;code&gt;.keep&lt;/code&gt;. For what it's worth, this name is agnostic to Git, whereas &lt;code&gt;.gitkeep&lt;/code&gt; would be specific to Git. Secondly, as another user has noted, the &lt;code&gt;.git&lt;/code&gt; prefix convention should be reserved for files and directories that Git itself uses.</source>
          <target state="translated">Linux에서는 &lt;code&gt;.keep&lt;/code&gt; 이라는 빈 파일이 작성됩니다. 가치있는 점 에서이 이름은 Git과 &lt;code&gt;.gitkeep&lt;/code&gt; 하지만 .gitkeep 은 Git에만 적용됩니다. 둘째, 다른 사용자가 언급했듯이 &lt;code&gt;.git&lt;/code&gt; 접두어 규칙은 Git 자체가 사용하는 파일과 디렉토리를 위해 예약되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b0ad216a803a00613e01c41fc295c139ede68d11" translate="yes" xml:space="preserve">
          <source>Placing a &lt;code&gt;README&lt;/code&gt; file or another file with some content in order to make the directory non-empty, or</source>
          <target state="translated">디렉토리를 비우기 위해 &lt;code&gt;README&lt;/code&gt; 파일 또는 일부 내용이 포함 된 다른 파일 배치</target>
        </trans-unit>
        <trans-unit id="93eb92fdf4a152028fa81b55f63d32976354d372" translate="yes" xml:space="preserve">
          <source>Rather than &lt;em&gt;hacking a fake submodule into GIT&lt;/em&gt;, just &lt;strong&gt;add an empty real one&lt;/strong&gt;.</source>
          <target state="translated">&lt;em&gt;가짜 하위 모듈을 GIT에 해킹하는&lt;/em&gt; 대신 &lt;strong&gt;빈 실제&lt;/strong&gt; &lt;em&gt;모듈을&lt;/em&gt; &lt;strong&gt;추가하십시오&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bc6820d0a373db625fb96ec7de8c73508075f0c8" translate="yes" xml:space="preserve">
          <source>Reading &lt;a href=&quot;https://stackoverflow.com/a/8944077/277882&quot;&gt;@ofavre&lt;/a&gt;'s and &lt;a href=&quot;https://stackoverflow.com/a/27635349/277882&quot;&gt;@stanislav-bashkyrtsev&lt;/a&gt;'s answers using broken GIT submodule references to create the GIT directories, I'm surprised that nobody has suggested yet this simple amendment of the idea to make the whole thing sane and safe:</source>
          <target state="translated">GIT 디렉토리를 만들기 위해 깨진 GIT 하위 모듈 참조를 사용하여 &lt;a href=&quot;https://stackoverflow.com/a/27635349/277882&quot;&gt;@ofavre&lt;/a&gt; 및 @ stanislav-bashkyrtsev 의 답변을 읽음으로써 아무도 모든 것을 제정신과 안전으로 만들기위한 아이디어의 간단한 수정을 제안하지 않은 것에 놀랐습니다.</target>
        </trans-unit>
        <trans-unit id="23cdc9f7361b0d5b570a36dcba55ff9b5cae4bca" translate="yes" xml:space="preserve">
          <source>See this &lt;a href=&quot;https://stackoverflow.com/a/7229996/1882064&quot;&gt;SOF answer&lt;/a&gt; for further info - which also explains why some people find the competing convention of adding a .gitignore file (as stated in many answers here) confusing.</source>
          <target state="translated">더 자세한 정보는이 &lt;a href=&quot;https://stackoverflow.com/a/7229996/1882064&quot;&gt;SOF 답변&lt;/a&gt; 을 참조하십시오-일부 사람들이 왜 .gitignore 파일을 추가하는 경쟁 관행을 찾는 지 설명합니다 (여기에서 많은 답변에 명시되어 있음).</target>
        </trans-unit>
        <trans-unit id="d6621ff4ffc0ff6569560bb0a2efc73f49936c0c" translate="yes" xml:space="preserve">
          <source>Separation of concerns is always a good thing, and you can still add a &lt;code&gt;.gitignore&lt;/code&gt; to ignore unwanted files.</source>
          <target state="translated">우려의 분리는 항상 좋은 일이며, &lt;code&gt;.gitignore&lt;/code&gt; 를 추가하여 원치 않는 파일을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="592714d4edcb65cef2e2c3b218225cb036a5b740" translate="yes" xml:space="preserve">
          <source>So you have some reason why you need an empty directory in git. Put that reason in the README file. That way other developers (and future you) know why the empty directory needs to be there. You will also know that you can remove the empty directory when the problem requiring the empty directory has been solved.</source>
          <target state="translated">따라서 git에 빈 디렉토리가 필요한 이유가 있습니다. 그 이유를 README 파일에 넣으십시오. 이렇게하면 다른 개발자 (및 미래의 사용자)가 빈 디렉토리가 필요한 이유를 알 수 있습니다. 빈 디렉토리가 필요한 문제가 해결되면 빈 디렉토리를 제거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4ddceacd9ef252bd2b26735610de3953bcaf160" translate="yes" xml:space="preserve">
          <source>So, since most of our developers already have &lt;a href=&quot;http://ant.apache.org/&quot;&gt;Ant&lt;/a&gt; installed, the first thing I thought of was to put together an Ant build file to accomplish this independently of the platform. This can still be found &lt;a href=&quot;https://github.com/mig82/gitkeep&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">따라서 대부분의 개발자가 이미 &lt;a href=&quot;http://ant.apache.org/&quot;&gt;Ant를&lt;/a&gt; 설치했기 때문에 플랫폼을 독립적으로 수행하기 위해 Ant 빌드 파일을 구성하는 것이 가장 먼저 생각되었습니다. 이것은 여전히 &lt;a href=&quot;https://github.com/mig82/gitkeep&quot;&gt;여기&lt;/a&gt; 에서 찾을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f7a7193ce04f935ddcdda5d451f93adfb51ede51" translate="yes" xml:space="preserve">
          <source>Some suggested workarounds</source>
          <target state="translated">몇 가지 제안 된 해결 방법</target>
        </trans-unit>
        <trans-unit id="24d48e9605946eaa8d5b15a84c152609ade8789b" translate="yes" xml:space="preserve">
          <source>Sometimes you have to deal with bad written libraries or software, which need a &quot;real&quot; empty and existing directory. Putting a simple &lt;code&gt;.gitignore&lt;/code&gt; or &lt;code&gt;.keep&lt;/code&gt; might break them and cause a bug. The following might help in these cases, but no guarantee...</source>
          <target state="translated">때로는 &quot;실제&quot;비어 있고 기존 디렉토리가 필요한 잘못된 작성된 라이브러리 또는 소프트웨어를 처리해야합니다. 간단한 &lt;code&gt;.gitignore&lt;/code&gt; 또는 &lt;code&gt;.keep&lt;/code&gt; 을 넣으면 오류 가 발생하여 버그가 발생할 수 있습니다. 이 경우 다음이 도움이 될 수 있지만 보장 할 수는 없습니다 ...</target>
        </trans-unit>
        <trans-unit id="cf726d64819da79e232e9449d98f66861477c78f" translate="yes" xml:space="preserve">
          <source>Still not a native solution, but the best we probably can have without somebody getting their hands &lt;em&gt;really&lt;/em&gt;, &lt;em&gt;really&lt;/em&gt; dirty in the GIT codebase.</source>
          <target state="translated">여전히 네이티브 솔루션은 아니지만 GIT 코드베이스에서 누군가가 &lt;em&gt;실제로&lt;/em&gt; 손을 잡지 않고 가질 수있는 최선의 방법입니다.</target>
        </trans-unit>
        <trans-unit id="cf4be5ed3cfbdabce8848b04a368438be916697c" translate="yes" xml:space="preserve">
          <source>Suppose you are in your repository.</source>
          <target state="translated">저장소에 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="e9440e7d8743e5013dcfa9058a0b91853acdb142" translate="yes" xml:space="preserve">
          <source>That's it! Your empty folder is in your index. All you have to do is commit.</source>
          <target state="translated">그게 다야! 빈 폴더가 색인에 있습니다. 커밋 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="562923af0e1a8d102acfd05b50f5ffe1e3954ed4" translate="yes" xml:space="preserve">
          <source>That's it, check that in, and you have an empty, yet tracked, directory that you can track files in at some later time.</source>
          <target state="translated">그게 다야, 체크인하고, 나중에 파일을 추적 할 수있는 비어 있지만 추적 된 디렉토리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a953cbe252f4b95d3c8d893ebb5a8f6698c5ae93" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_on_Rails&quot;&gt;Ruby on Rails&lt;/a&gt; log folder creation way:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Ruby_on_Rails&quot;&gt;Ruby on Rails&lt;/a&gt; 로그 폴더 생성 방법 :</target>
        </trans-unit>
        <trans-unit id="a065a9784ab6e7bdd148b461bc6d4ab1e93e44a6" translate="yes" xml:space="preserve">
          <source>The empty tree SHA-1 can be found by creating a new empty Git repository, &lt;code&gt;cd&lt;/code&gt; into it and issue &lt;code&gt;git write-tree&lt;/code&gt;, which outputs the empty tree SHA-1.</source>
          <target state="translated">빈 트리 SHA-1은 새로운 빈 Git 리포지토리를 생성하고 &lt;code&gt;cd&lt;/code&gt; 넣고 빈 트리 SHA-1을 출력하는 &lt;code&gt;git write-tree&lt;/code&gt; 를 실행하여 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="307e8e768a7cd49c93d468cac94e2255ed611a4f" translate="yes" xml:space="preserve">
          <source>The file can be named and contain anything you want, but most people use an empty file named &lt;code&gt;.gitkeep&lt;/code&gt; (although some people prefer the VCS-agnostic &lt;code&gt;.keep&lt;/code&gt;).</source>
          <target state="translated">파일 이름을 지정하고 원하는 것을 포함 할 수 있지만 대부분의 사람들은 &lt;code&gt;.gitkeep&lt;/code&gt; 이라는 빈 파일을 사용합니다 (일부 사람들은 VCS-agnostic &lt;code&gt;.keep&lt;/code&gt; 을 선호합니다).</target>
        </trans-unit>
        <trans-unit id="66f448f887e290279d30def41c251c99c2c81784" translate="yes" xml:space="preserve">
          <source>The format, as mentioned, is:</source>
          <target state="translated">언급 된 바와 같이 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e742b2cbc27fb33e33cca9e1072fb5dc2e8c6c74" translate="yes" xml:space="preserve">
          <source>The logfiles can be kept out by issuing,</source>
          <target state="translated">로그 파일은 발행하여 보관할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf29dff62fdb5ee3fc2a33b322ef5c3f576f3005" translate="yes" xml:space="preserve">
          <source>The prefixed &lt;code&gt;.&lt;/code&gt; marks it as a hidden file.</source>
          <target state="translated">접두사 숨겨진 파일로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="adde9d966c336b6cf829e4ff186e0bdbb1f17fdb" translate="yes" xml:space="preserve">
          <source>The real question is why do you need the empty directory in git? Usually you have some sort of build script that can create the empty directory before compiling/running. If not then make one. That is a far better solution than putting empty directories in git.</source>
          <target state="translated">진짜 질문은 왜 git에 빈 디렉토리가 필요합니까? 일반적으로 컴파일 / 실행하기 전에 빈 디렉토리를 만들 수있는 일종의 빌드 스크립트가 있습니다. 그렇지 않다면 하나 만드십시오. 빈 디렉토리를 git에 넣는 것보다 훨씬 나은 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="4e10a5f8b55bf16c877fb4a4db4028d201a75b3d" translate="yes" xml:space="preserve">
          <source>The reason I suggest keeping that one line in the file is that it gives the &lt;code&gt;.gitignore&lt;/code&gt; purpose. Otherwise, some one down the line may think to remove it.  It may help if you place a comment above the line.</source>
          <target state="translated">파일에 한 줄을 유지하는 것이 좋습니다 이유는 &lt;code&gt;.gitignore&lt;/code&gt; 목적을 제공하기 때문입니다. 그렇지 않으면, 줄 아래에있는 일부 줄을 제거하려고 생각할 수 있습니다. 줄 위에 주석을 달면 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44dd342bd16c11fefd5f44220831e5efdbe41a34" translate="yes" xml:space="preserve">
          <source>Then do</source>
          <target state="translated">그런 다음</target>
        </trans-unit>
        <trans-unit id="271ab51f7d49757a4117bf808028499958faf787" translate="yes" xml:space="preserve">
          <source>Then you add a broken symbolic link to this directory (but on any other case than the described use case above, please use a &lt;code&gt;README&lt;/code&gt; with an explanation):</source>
          <target state="translated">그런 다음이 디렉토리에 깨진 심볼릭 링크를 추가하십시오 (그러나 위에서 설명한 유스 케이스가 아닌 다른 경우에는 설명과 함께 &lt;code&gt;README&lt;/code&gt; 를 사용하십시오).</target>
        </trans-unit>
        <trans-unit id="cbe8b088983da206fee5cb9a90a567c09bef564f" translate="yes" xml:space="preserve">
          <source>Then you can commit descriptive README.md files (or blank files, doesn't matter, as long as you can target them uniquely like with the &lt;code&gt;*.md&lt;/code&gt; in this case) in each directory to ensure that the directories all remain part of the repo but the files (with extensions) are kept ignored. LIMITATION: &lt;code&gt;.&lt;/code&gt;'s are not allowed in the directory names!</source>
          <target state="translated">그런 다음 각 디렉토리에 설명이 포함 된 README.md 파일 (또는이 경우 &lt;code&gt;*.md&lt;/code&gt; 를 사용하여 고유하게 대상으로 지정할 수있는 한 빈 파일은 중요하지 않음)을 커밋하여 디렉토리가 모두 repo이지만 파일 (확장자 포함)은 무시됩니다. 제한 사항 : &lt;code&gt;.&lt;/code&gt; 디렉토리 이름에는 사용할 수 없습니다!</target>
        </trans-unit>
        <trans-unit id="61c9cbd5afc1886a9d4c83796b2f8645d0725617" translate="yes" xml:space="preserve">
          <source>Then you don't have to get the order right the way that you have to do in m104's &lt;a href=&quot;https://stackoverflow.com/a/180917/32453&quot;&gt;solution&lt;/a&gt;.</source>
          <target state="translated">그런 다음 m104의 &lt;a href=&quot;https://stackoverflow.com/a/180917/32453&quot;&gt;솔루션&lt;/a&gt; 에서해야 할 방식으로 주문을받을 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="4738c75f9da892a390366657d2ab91d093af9b84" translate="yes" xml:space="preserve">
          <source>There is a rant out there somewhere I read once.</source>
          <target state="translated">내가 한 번 읽은 어딘가에 흠이 있습니다.</target>
        </trans-unit>
        <trans-unit id="26fa8fd7ec96a6040db82979ba4051519106b223" translate="yes" xml:space="preserve">
          <source>There is no need to further alter your &lt;code&gt;.gitignore&lt;/code&gt; or decentralise by creating a new &lt;code&gt;.gitignore&lt;/code&gt; for each new directory. Probably not the smartest solution but is terse gitignore-wise and always works for me. Nice and simple! ;)</source>
          <target state="translated">새로운 디렉토리마다 새로운 &lt;code&gt;.gitignore&lt;/code&gt; 를 생성하여 &lt;code&gt;.gitignore&lt;/code&gt; 를 더 변경하거나 분산시킬 필요가 없습니다. 아마도 가장 똑똑한 해결책은 아니지만 간결한 gitignore 현명하고 항상 나를 위해 일합니다. 좋고 간단합니다! ;)</target>
        </trans-unit>
        <trans-unit id="e4a770f2fd29b2be505353071c334d0fd6d58785" translate="yes" xml:space="preserve">
          <source>There's no way to get Git to track directories, so the only solution is to add a placeholder file within the directory that you want Git to track.</source>
          <target state="translated">Git이 디렉토리를 추적하도록하는 방법은 없으므로 Git이 추적 할 디렉토리 내에 플레이스 홀더 파일을 추가하는 것이 유일한 해결책입니다.</target>
        </trans-unit>
        <trans-unit id="1ae5f2188a715c59168ab614b7195164558364d0" translate="yes" xml:space="preserve">
          <source>This also gives the benefit that files in that directory won't show up as &quot;untracked&quot; when you do a git status.</source>
          <target state="translated">또한 git 상태를 수행 할 때 해당 디렉토리의 파일이 &quot;추적되지 않은&quot;것으로 표시되지 않는 이점도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d51a99a1263426f38791134a8084992fd3d9699" translate="yes" xml:space="preserve">
          <source>This commands shows an empty result, since no files are present in this directory. So most applications, which get all files in a directory usually do not see this link, at least if they do a &quot;file exists&quot; or a &quot;is readable&quot;. Even some scripts will not find any files there:</source>
          <target state="translated">이 디렉토리에 파일이 없으므로이 명령은 빈 결과를 보여줍니다. 따라서 디렉토리에있는 모든 파일을 가져 오는 대부분의 응용 프로그램은 보통 &quot;파일이 존재&quot;하거나 &quot;읽을 수있는&quot;경우에는이 링크를 볼 수 없습니다. 일부 스크립트조차도 파일을 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="941a2713b26907b0edfc9326db1fe8fd6d6259ce" translate="yes" xml:space="preserve">
          <source>This is in PHP, but I am sure most languages support the same functionality, and because the creation of the folders is taken care of by the application, the folders will always be there.</source>
          <target state="translated">이것은 PHP로되어 있지만 대부분의 언어가 동일한 기능을 지원한다고 확신하며 폴더 생성은 응용 프로그램에서 처리하기 때문에 항상 폴더가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0231a3e6089a1a461ba784b7f40b45deb15617c7" translate="yes" xml:space="preserve">
          <source>This is why I decided to write an open source tool which can manage the creation/deletion of such placeholder files automatically. It is written for .NET platform and runs under Mono (.NET for Linux) and Windows.</source>
          <target state="translated">이것이 바로 이러한 자리 표시 자 파일의 생성 / 삭제를 자동으로 관리 할 수있는 오픈 소스 도구를 작성하기로 결정한 이유입니다. .NET 플랫폼 용으로 작성되었으며 Mono (Linux 용 .NET) 및 Windows에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0ff65b1e79038cf9e8c142a884be4f581f2e90a5" translate="yes" xml:space="preserve">
          <source>This solution is short and apparently works fine (&lt;strong&gt;see the EDIT!&lt;/strong&gt;), but it is not that easy to remember...</source>
          <target state="translated">이 솔루션은 짧고 분명히 잘 작동합니다 ( &lt;strong&gt;편집 참조&lt;/strong&gt; ). 그러나 기억하기 쉽지 않습니다 ...</target>
        </trans-unit>
        <trans-unit id="8669dd39694b308e5b298072467437705670849e" translate="yes" xml:space="preserve">
          <source>This will add a folder and a file &lt;code&gt;.submodules&lt;/code&gt;. Commit a change.</source>
          <target state="translated">폴더와 &lt;code&gt;.submodules&lt;/code&gt; 파일이 추가됩니다. 변경을 커밋하십시오.</target>
        </trans-unit>
        <trans-unit id="447b2024267dea2031844c6f68742d0c73587964" translate="yes" xml:space="preserve">
          <source>To add an empty directory to you GIT repo:</source>
          <target state="translated">빈 디렉토리를 GIT 저장소에 추가하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="490916f50c4d5acc4a001cfc2ae3064c52b31c17" translate="yes" xml:space="preserve">
          <source>To add the ignored file, use a parameter to force it:</source>
          <target state="translated">무시 된 파일을 추가하려면 매개 변수를 사용하여 파일을 강제 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="b5b5dd30965da188d3bdbf913bf64ed36eb60fb6" translate="yes" xml:space="preserve">
          <source>To convert all existing empty directories to submodules:</source>
          <target state="translated">기존의 모든 빈 디렉토리를 서브 모듈로 변환하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d8c3c4fd1ad227759ac5eda9bde9680891d85369" translate="yes" xml:space="preserve">
          <source>To create placeholder READMEs in every empty directory:</source>
          <target state="translated">빈 디렉토리마다 플레이스 홀더 README를 작성하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d059071611973c155c1fa728cc1dc8d54a784477" translate="yes" xml:space="preserve">
          <source>To ignore everything in the directory except the README file put the following lines in your &lt;code&gt;.gitignore&lt;/code&gt;:</source>
          <target state="translated">README 파일을 제외한 디렉토리의 모든 것을 무시하려면 &lt;code&gt;.gitignore&lt;/code&gt; 에 다음 행을 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="8d5ad49ffa75003ce93790e45a213bfc2c5568dc" translate="yes" xml:space="preserve">
          <source>To ignore files in this directory, you can add it in your root &lt;code&gt;.gitignore&lt;/code&gt;:</source>
          <target state="translated">이 디렉토리의 파일을 무시하려면 루트 &lt;code&gt;.gitignore&lt;/code&gt; 에 파일을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="4d28181251c8e026869f72e94fcb9f913bb43572" translate="yes" xml:space="preserve">
          <source>To list every README after they are already created:</source>
          <target state="translated">모든 README가 이미 작성된 후 나열하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="eb5231ed99174cb588bedfa581b7186849bdd9e4" translate="yes" xml:space="preserve">
          <source>To list every empty directory use the following command:</source>
          <target state="translated">빈 디렉토리를 모두 나열하려면 다음 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f5fd9c123a60713e27942ff28cd8c0c830fcdd51" translate="yes" xml:space="preserve">
          <source>Type the command and then enter the second line. Press</source>
          <target state="translated">명령을 입력 한 후 두 번째 줄을 입력하십시오. 프레스</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="ffd1db763848f4c4472ac7f7473013edf19585c9" translate="yes" xml:space="preserve">
          <source>Use an &lt;em&gt;empty&lt;/em&gt; file called &lt;code&gt;.gitkeep&lt;/code&gt; in order to force the presence of the folder in the versioning system.</source>
          <target state="translated">버전 관리 시스템에 폴더가 존재하도록하려면 &lt;code&gt;.gitkeep&lt;/code&gt; 이라는 &lt;em&gt;빈&lt;/em&gt; 파일을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cddf6b9a46a0454ba89ee38e73b711678e2deb70" translate="yes" xml:space="preserve">
          <source>When you add a &lt;code&gt;.gitignore&lt;/code&gt; file, if you are going to put any amount of content in it (that you want Git to ignore) you might want to add a single line with just an asterisk &lt;code&gt;*&lt;/code&gt; to make sure you don't add the ignored content accidentally.</source>
          <target state="translated">&lt;code&gt;.gitignore&lt;/code&gt; 파일을 추가 할 때 Git이 무시하고 싶은 양의 컨텐츠를 넣을 경우 별표로 &lt;code&gt;*&lt;/code&gt; 한 줄을 추가하여 * 를 추가하지 않도록 할 수 있습니다 실수로 내용을 무시했습니다.</target>
        </trans-unit>
        <trans-unit id="fe8fd8f26e88b908b2a3b55d4634c460d8e2a8ec" translate="yes" xml:space="preserve">
          <source>When you want to clean up your source tree you can just:</source>
          <target state="translated">소스 트리를 정리하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="eeadc9a1aaa0db3bc40739107087ee919a727078" translate="yes" xml:space="preserve">
          <source>While &lt;em&gt;both solutions surely work&lt;/em&gt; I find them inconsistent with a meaningful approach to Git versioning.</source>
          <target state="translated">&lt;em&gt;두 솔루션&lt;/em&gt; 이 &lt;em&gt;모두 작동&lt;/em&gt; 하지만 Git 버전 관리에 대한 의미있는 접근 방식과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b62d1c6896a552b6058f125d41d2a8a506cf5359" translate="yes" xml:space="preserve">
          <source>Why are you supposed to put bogus files or READMEs that maybe you don't really want in your project?</source>
          <target state="translated">왜 프로젝트에서 원하지 않는 가짜 파일이나 README를 넣어야합니까?</target>
        </trans-unit>
        <trans-unit id="b3cc7336ea3346a09abac426eb677ad323e9fdd1" translate="yes" xml:space="preserve">
          <source>Why use &lt;code&gt;.gitignore&lt;/code&gt; to do a thing (&lt;em&gt;keeping&lt;/em&gt; files) that is the very opposite of what it's meant for (&lt;em&gt;excluding&lt;/em&gt; files), even though it is possible?</source>
          <target state="translated">&lt;code&gt;.gitignore&lt;/code&gt; 를 사용하여 파일을 &lt;em&gt;제외하고&lt;/em&gt; 의도 된 것과는 반대되는 일을하는 데 왜 파일을 &lt;em&gt;유지&lt;/em&gt; 합니까?</target>
        </trans-unit>
        <trans-unit id="103215cec6138a09084b9458c3ce747f188a10b4" translate="yes" xml:space="preserve">
          <source>Why would we need empty versioned folders</source>
          <target state="translated">빈 버전의 폴더가 필요한 이유</target>
        </trans-unit>
        <trans-unit id="4ce5d0388c01b6cedd52787992f8c7a955244236" translate="yes" xml:space="preserve">
          <source>With this solution you are able to commit a empty folder, for example &lt;code&gt;/log&lt;/code&gt;, &lt;code&gt;/tmp&lt;/code&gt; or &lt;code&gt;/cache&lt;/code&gt; and the folder will stay empty.</source>
          <target state="translated">이 솔루션을 사용하면 빈 폴더 (예 : &lt;code&gt;/log&lt;/code&gt; , &lt;code&gt;/tmp&lt;/code&gt; 또는 &lt;code&gt;/cache&lt;/code&gt; ) 를 커밋 할 수 있으며 폴더는 비어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f23151da0deaa4d23f72fa98790c48326765298a" translate="yes" xml:space="preserve">
          <source>With this, you can either execute it from within the directory you wish to add, or reference the directory as it's first and only parameter:</source>
          <target state="translated">이를 통해 추가하려는 디렉토리 내에서 디렉토리를 실행하거나 첫 번째 유일한 매개 변수로 디렉토리를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4aec0f970702275a4ff389c3481cbd12213f0065" translate="yes" xml:space="preserve">
          <source>You can fill up all of these directories with xml/images files or whatever and add more directories under &lt;code&gt;/app/data/&lt;/code&gt; over time as the storage needs for your app develop (with the README.md files serving to burn in a description of what each storage directory is for exactly).</source>
          <target state="translated">xml / images 파일 등으로 모든 디렉토리를 채울 수 있으며 앱 개발에 필요한 스토리지가 필요할 때 시간이 지남에 따라 &lt;code&gt;/app/data/&lt;/code&gt; 아래에 더 많은 디렉토리를 추가 할 수 있습니다 (README.md 파일을 사용하여 각 스토리지 디렉토리는 정확하게 사용됩니다).</target>
        </trans-unit>
        <trans-unit id="368ecf61c201184ca1eca5a09d4b430bba4475ac" translate="yes" xml:space="preserve">
          <source>You can ignore all of your generated files by adding the following to your root .gitignore:</source>
          <target state="translated">루트 .gitignore에 다음을 추가하여 생성 된 모든 파일을 무시할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db3768f3cbb474672a2f790a2f3a93556c86a883" translate="yes" xml:space="preserve">
          <source>You can save this code as create_readme.php and run the &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt; code from the root directory of your Git project.</source>
          <target state="translated">이 코드를 create_readme.php로 저장하고 Git 프로젝트의 루트 디렉토리에서 &lt;a href=&quot;http://en.wikipedia.org/wiki/PHP&quot;&gt;PHP&lt;/a&gt; 코드를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35e7674c15b829e3da47e9c91c17c0b45bbbcbc4" translate="yes" xml:space="preserve">
          <source>You can say &quot;&lt;code&gt;git add &amp;lt;dir&amp;gt;&lt;/code&gt;&quot; and it
  will add files in there.</source>
          <target state="translated">&quot; &lt;code&gt;git add &amp;lt;dir&amp;gt;&lt;/code&gt; &quot;이라고 말하면 거기에 파일이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="6cfdb4128821ccf4042227c42e6a3ce5eff4c3ec" translate="yes" xml:space="preserve">
          <source>You can't and unfortunately will never be able to. This is a decision made by Linus Torvald himself. He knows what's good for us.</source>
          <target state="translated">불행히도 결코 할 수 없을 것입니다. 이것은 Linus Torvald 자신이 내린 결정입니다. 그는 우리에게 좋은 것이 무엇인지 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="96422f8128e7582ea39f5a813f28720ea292d5ce" translate="yes" xml:space="preserve">
          <source>You can't.  See the &lt;a href=&quot;https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F&quot;&gt;Git FAQ&lt;/a&gt;.</source>
          <target state="translated">당신은 할 수 없습니다. &lt;a href=&quot;https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F&quot;&gt;힘내 FAQ를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="22ca8c67077a960213c9270a133c31b59f499c76" translate="yes" xml:space="preserve">
          <source>You can't. This is an intentional design decision by the Git maintainers. Basically, the purpose of a Source Code Management System like Git is managing source code and empty directories aren't source code. Git is also often described as a content tracker, and again, empty directories aren't content (quite the opposite, actually), so they are not tracked.</source>
          <target state="translated">당신은 할 수 없습니다. 이것은 Git 관리자가 의도적으로 디자인 한 결정입니다. 기본적으로 Git과 같은 소스 코드 관리 시스템의 목적은 소스 코드를 관리하는 것이며 빈 디렉토리는 소스 코드가 아닙니다. Git은 종종 컨텐츠 트래커로 설명되며, 빈 디렉토리는 컨텐츠가 아니므로 (실제로는 반대입니다) 추적되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="803b77036ef8698000e9339edcd62fd703594653" translate="yes" xml:space="preserve">
          <source>You could always put a README file in the directory with an explanation of why you want this, otherwise empty, directory in the repository.</source>
          <target state="translated">리포지토리에서이 디렉터리를 원하는 이유 (비어있는 경우)에 대한 설명과 함께 항상 README 파일을 디렉터리에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcee5b95aba60fafa22b894110eb63499a6ee4d7" translate="yes" xml:space="preserve">
          <source>You have to live with the workarounds...unfortunately.</source>
          <target state="translated">불행히도 해결 방법으로 살아야합니다.</target>
        </trans-unit>
        <trans-unit id="03f9d41dc6b8f480026623afffc50b5a20a7c5da" translate="yes" xml:space="preserve">
          <source>You should be able to recreate this exact commit using (in an empty directory):</source>
          <target state="translated">빈 디렉토리에서 다음을 사용하여이 정확한 커밋을 다시 만들 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9487aa6e228be403f7931650f0ee33843eff1948" translate="yes" xml:space="preserve">
          <source>You use a file that has the &lt;em&gt;single&lt;/em&gt; purpose of keeping the folder. You don't put there any info you don't want to put.</source>
          <target state="translated">폴더를 유지하려는 &lt;em&gt;단일&lt;/em&gt; 목적의 파일을 사용합니다. 당신은 당신이 넣고 싶지 않은 정보를 넣지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50e789a4519a8bfb4201a8cf539afda28392b287" translate="yes" xml:space="preserve">
          <source>Your &lt;code&gt;.gitignore&lt;/code&gt; file would look like:</source>
          <target state="translated">&lt;code&gt;.gitignore&lt;/code&gt; 파일은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a357a0b3b6bb01e41a042b584904f6b12375f3f1" translate="yes" xml:space="preserve">
          <source>and then</source>
          <target state="translated">그리고</target>
        </trans-unit>
        <trans-unit id="c6f38c96c5ac4615934334f5e2718109ae1691d4" translate="yes" xml:space="preserve">
          <source>but you probably knew that.</source>
          <target state="translated">그러나 당신은 아마 그것을 알고 있었다.</target>
        </trans-unit>
        <trans-unit id="31a8afc956c3b38d471b6f69f007533194f0e239" translate="yes" xml:space="preserve">
          <source>fatal: Not a valid object name
  b64338b90b4209263b50244d18278c0999867193</source>
          <target state="translated">치명적 : 유효한 개체 이름이 아닙니다. b64338b90b4209263b50244d18278c0999867193</target>
        </trans-unit>
        <trans-unit id="7ed76119035d1dc7e53e02cf1cd68c1b13efd79d" translate="yes" xml:space="preserve">
          <source>related to the above, some projects &lt;em&gt;won't work without some folders&lt;/em&gt; (which is often a hint of a poorly designed project, but it's a frequent real-world scenario and maybe there could be, say, permission problems to be addressed).</source>
          <target state="translated">위와 관련하여 일부 프로젝트 &lt;em&gt;는 일부 폴더가 없으면 작동하지 않습니다&lt;/em&gt; (종종 잘못 설계 된 프로젝트의 힌트이지만 실제로는 빈번한 시나리오이므로 권한 문제가 해결 될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="87b56ec500c49bd553a7cff70a8680d17089dd52" translate="yes" xml:space="preserve">
          <source>scaffolding a &lt;strong&gt;predefined folder structure&lt;/strong&gt;, making it available to every user/contributor of the repository; or, as a specialized case of the above, creating a folder for &lt;strong&gt;temporary files&lt;/strong&gt;, such as a &lt;code&gt;cache/&lt;/code&gt; or &lt;code&gt;logs/&lt;/code&gt; directories, where we want to provide the folder but &lt;code&gt;.gitignore&lt;/code&gt; its contents</source>
          <target state="translated">&lt;strong&gt;미리 정의 된 폴더 구조를&lt;/strong&gt; 스캐 폴딩하여 리포지토리의 모든 사용자 / 기여자가 사용할 수 있도록합니다. 또는 위의 특수한 경우로서 &lt;code&gt;cache/&lt;/code&gt; 또는 &lt;code&gt;logs/&lt;/code&gt; 디렉토리와 같은 &lt;strong&gt;임시 파일&lt;/strong&gt; 용 폴더를 생성하여 폴더를 제공하고 싶지만 그 내용은 &lt;code&gt;.gitignore&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9dc3140cab3fe6f3324bc773106f6dea351ca23" translate="yes" xml:space="preserve">
          <source>to terminate your input.
Note: the format is &lt;em&gt;mode&lt;/em&gt; [SPACE] &lt;em&gt;type&lt;/em&gt; [SPACE] SHA-1hash &lt;strong&gt;[TAB]&lt;/strong&gt; path (the tab is important, the answer formatting does not preserve it).</source>
          <target state="translated">입력을 종료합니다. 참고 : 형식은 &lt;em&gt;모드&lt;/em&gt; [SPACE] &lt;em&gt;유형&lt;/em&gt; [SPACE] SHA-1hash &lt;strong&gt;[TAB]&lt;/strong&gt; 경로입니다 (탭이 중요합니다. 응답 형식은이를 유지하지 않습니다).</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
