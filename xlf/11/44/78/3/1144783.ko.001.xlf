<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/1144783">
    <body>
      <group id="1144783">
        <trans-unit id="d9952330ff36e4f4aeca5f93ac713b20da31fa77" translate="yes" xml:space="preserve">
          <source>//loop it until number occurrences comes to 0. OR simply copy/paste</source>
          <target state="translated">// 숫자가 0이 될 때까지 반복합니다. 또는 단순히 복사 / 붙여 넣기</target>
        </trans-unit>
        <trans-unit id="c8857126cc10f9914e5f38613f237895ee5c6b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/g&lt;/code&gt; means global</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; 는 전역을 의미합니다</target>
        </trans-unit>
        <trans-unit id="bb5c0451b917db9a91e43681457634a56c6655aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Update:&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Update:&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="54d43c52441fb7bd3ed00affd5f9186806533d64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7e2cd0e1a6f716d8fe13350e59d99500575639f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; Clarification about replaceAll availability</source>
          <target state="translated">&lt;strong&gt;편집 :&lt;/strong&gt; replaceAll 가용성에 대한 설명</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f29304ea9cd1982b93d7af334cf0f88bae973ea7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Final addition:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;최종 추가 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d371a375635dead23e71c6018c06fc0b2d6bcf0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;방법 1 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39ba8b2d14f80c96148df898ae74111bfba336f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;방법 2 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72d457e583e8bca3f439a3a897e489de0b498c03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;방법 3 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="529383dcc2e9606a5bb75847be52ba72603eb93a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;방법 4 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0737a49188ce80e8c141eb30d15abad1f570e32c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: Don't use this in performance critical code.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : 성능이 중요한 코드에는이 코드를 사용하지 마십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56781c4490d4641a69cef533a9621281a430d169" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In general, extending the built-in prototypes in JavaScript is generally not recommended. I am providing as extensions on the String prototype simply for purposes of illustration, showing different implementations of a hypothetical standard method on the &lt;code&gt;String&lt;/code&gt; built-in prototype.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 일반적으로 JavaScript에서 내장 프로토 타입을 확장하는 것은 일반적으로 권장되지 않습니다. &lt;code&gt;String&lt;/code&gt; 내장 프로토 타입에 대한 가상 표준 방법의 다양한 구현을 보여주기 위해 단순히 예시 목적으로 String 프로토 타입에 대한 확장을 제공하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9ca3f2973d0dabdd79539f415055d2ed5b22768" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Regular expressions contain special (meta) characters, and as such it is dangerous to blindly pass an argument in the &lt;code&gt;find&lt;/code&gt; function above without pre-processing it to escape those characters.  This is covered in the &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;Mozilla Developer Network&lt;/a&gt;'s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping&quot;&gt;JavaScript Guide on Regular Expressions&lt;/a&gt;, where they present the following utility function (which has changed at least twice since this answer was originally written, so make sure to check the MDN site for potential updates):</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; 정규식에는 특수 (메타) 문자가 포함되어 있으므로 위 문자를 이스케이프 처리하기 위해 사전 처리하지 않고 &lt;code&gt;find&lt;/code&gt; 함수에서 인수를 맹목적으로 전달하는 것은 위험합니다. 이 내용은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping&quot;&gt;정규 표현식&lt;/a&gt; 에 대한 &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;Mozilla 개발자 네트워크&lt;/a&gt; 의 JavaScript 안내서에서 다루며 다음과 같은 유틸리티 기능을 제공합니다 (이 답변이 처음 작성된 이후 최소한 두 번 변경되었으므로 잠재적 인 업데이트가 있는지 MDN 사이트를 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="4cdcd3fdc8587add9d1885342dfb4ded08633670" translate="yes" xml:space="preserve">
          <source>@Mike, check the answer I gave there... regexp isn't the only way to replace multiple occurrences of a subsrting, far from it. Think flexible, think split!</source>
          <target state="translated">@Mike, 내가 준 대답을 확인하십시오 ... regexp가 subsrting의 여러 항목을 대체하는 유일한 방법은 아닙니다. 유연하게 생각하고 분할 생각하십시오!</target>
        </trans-unit>
        <trans-unit id="9f7ff750c8d42bac2d5bf7ded2777806c7bbd646" translate="yes" xml:space="preserve">
          <source>Alternatively, to prevent replacing word parts -which the approved answer will do, too! You can get around this issue using regular expressions that are, I admit, somewhat more complex and as an upshot of that, a tad slower, too:</source>
          <target state="translated">또는 승인 된 답변이 수행하는 단어 부분의 교체를 방지하기 위해! 좀 더 복잡하고 그 결과로 약간 더 느린 정규식을 사용 하여이 문제를 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9abf1f2f157ce45f651d436bf184af77b8adeb5e" translate="yes" xml:space="preserve">
          <source>Although people have mentioned the use of regex but there's a better approach if you want to replace the text irrespective of the case of the text. Like uppercase or lowercase. Use below syntax</source>
          <target state="translated">사람들은 정규식 사용을 언급했지만 텍스트의 경우에 관계없이 텍스트를 바꾸려면 더 나은 방법이 있습니다. 대문자 또는 소문자처럼. 아래 구문 사용</target>
        </trans-unit>
        <trans-unit id="d9e6101a86eec306979f963e9857be885e7245e2" translate="yes" xml:space="preserve">
          <source>As an alternative to regular expressions for a simple literal string, you could use</source>
          <target state="translated">간단한 리터럴 문자열에 대한 정규식의 대안으로 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c152952996b6a5c283c92260257eb9c156c7669e" translate="yes" xml:space="preserve">
          <source>As noted in the comment below by @ThomasLeduc and others, there could be an issue with the regular expression-based implementation if &lt;code&gt;search&lt;/code&gt; contains certain characters which are reserved as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;special characters in regular expressions&lt;/a&gt;. The implementation assumes that the caller will escape the string beforehand or will only pass strings that are without the characters in the table in &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;Regular Expressions&lt;/a&gt;&lt;/em&gt; (MDN).</source>
          <target state="translated">@ThomasLeduc 및 기타의 아래 주석에서 언급했듯이 &lt;code&gt;search&lt;/code&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;에 정규 표현식에서 특수 문자로&lt;/a&gt; 예약 된 특정 문자가 포함 된 경우 정규 표현식 기반 구현에 문제가있을 수 있습니다. 구현에서는 호출자가 미리 문자열을 이스케이프하거나 &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;정규 표현식&lt;/a&gt;&lt;/em&gt; (MDN) 테이블에 문자가없는 문자열 만 전달한다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="63b3d8e8f8a79cd8ec7c3c5683b3642dffed71ed" translate="yes" xml:space="preserve">
          <source>As pointed out in a comment here, this will not work if your &lt;code&gt;omit&lt;/code&gt; variable contains &lt;code&gt;place&lt;/code&gt;, as in: &lt;code&gt;replaceAll(&quot;string&quot;, &quot;s&quot;, &quot;ss&quot;)&lt;/code&gt;, because it will always be able to replace another occurrence of the word.</source>
          <target state="translated">여기 주석에서 지적했듯이 &lt;code&gt;omit&lt;/code&gt; 변수에 &lt;code&gt;place&lt;/code&gt; 가 포함되어 있으면 &lt;code&gt;replaceAll(&quot;string&quot;, &quot;s&quot;, &quot;ss&quot;)&lt;/code&gt; 과 같이 작동하지 않습니다. 왜냐하면 항상 단어의 다른 항목을 바꿀 수 있기 때문입니다. .</target>
        </trans-unit>
        <trans-unit id="2efdbb9e7d89d63a3865b145be18d2985735f425" translate="yes" xml:space="preserve">
          <source>Benchmark: &lt;a href=&quot;https://jsperf.com/replace-all-vs-split-join&quot;&gt;https://jsperf.com/replace-all-vs-split-join&lt;/a&gt;</source>
          <target state="translated">벤치 마크 : &lt;a href=&quot;https://jsperf.com/replace-all-vs-split-join&quot;&gt;https://jsperf.com/replace-all-vs-split-join&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f018edf766c43f923af62d936f6faa226aba148" translate="yes" xml:space="preserve">
          <source>But as I mention earlier, it won't make a huge difference in terms of lines to be written or performance, only caching the function may effect some faster performance on long strings and also a good practice of DRY code if you want to reuse.</source>
          <target state="translated">그러나 앞에서 언급했듯이, 작성되는 줄이나 성능 측면에서 큰 차이는 없지만 함수를 캐싱하는 것만으로 긴 문자열에서 더 빠른 성능을 발휘할 수 있으며 재사용하려는 경우 DRY 코드를 잘 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0e0c00e52a63b53922a63942eb8ba57f073ff62" translate="yes" xml:space="preserve">
          <source>But that runs the replacement twice for each cycle. Perhaps (at risk of being voted down) that can be combined for a slightly more efficient but less readable form:</source>
          <target state="translated">그러나 각 사이클마다 교체가 두 번 실행됩니다. 약간 더 효율적이지만 읽기 어려운 형태로 결합 될 수있는 (투표 될 위험이 있음) :</target>
        </trans-unit>
        <trans-unit id="4781d0025fe7cca970eabbf656f7ad7b779e25ea" translate="yes" xml:space="preserve">
          <source>Check out this &lt;a href=&quot;http://jsben.ch/#/LFfWA&quot;&gt;&lt;strong&gt;benchmark&lt;/strong&gt;&lt;/a&gt; running these two implementations against each other.</source>
          <target state="translated">이 두 가지 구현을 서로 실행하는 &lt;a href=&quot;http://jsben.ch/#/LFfWA&quot;&gt;&lt;strong&gt;벤치 마크를&lt;/strong&gt;&lt;/a&gt; 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="c33ec0466fe646cd010b474e907704e44e7c4bfa" translate="yes" xml:space="preserve">
          <source>Code used in tests</source>
          <target state="translated">테스트에 사용 된 코드</target>
        </trans-unit>
        <trans-unit id="dfa777c69364feec4e5703f84e2ca7d360aff891" translate="yes" xml:space="preserve">
          <source>Conclusion: If you have a performance critical use case (e.g processing hundreds of strings), use the Regexp method. But for most typical use cases, this is well worth not having to worry about special characters.</source>
          <target state="translated">결론 : 성능이 중요한 사용 사례 (예 : 수백 개의 문자열 처리)가있는 경우 Regexp 메서드를 사용하십시오. 그러나 가장 일반적인 사용 사례의 경우 특수 문자에 대해 걱정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="ade2304f2a0ac295b0c79d7fe9ea6df6dc08d89f" translate="yes" xml:space="preserve">
          <source>Doing:</source>
          <target state="translated">Doing:</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="dade7a599b73d04a874d2b0f676893876a891d64" translate="yes" xml:space="preserve">
          <source>Fiddle: &lt;a href=&quot;http://jsfiddle.net/cdbzL/&quot;&gt;http://jsfiddle.net/cdbzL/&lt;/a&gt;</source>
          <target state="translated">피들 : &lt;a href=&quot;http://jsfiddle.net/cdbzL/&quot;&gt;http://jsfiddle.net/cdbzL/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be49c2939db3ee7e866d3291921abff640df9c2e" translate="yes" xml:space="preserve">
          <source>For 1M characters they even break Chrome</source>
          <target state="translated">1M 캐릭터의 경우 Chrome을 손상시킵니다.</target>
        </trans-unit>
        <trans-unit id="b8c42f762938f25c778634ec4aa570773188eb6e" translate="yes" xml:space="preserve">
          <source>For example, if we have 'a,,,b' and we wish to remove all duplicate commas.</source>
          <target state="translated">예를 들어 'a ,,, b'가 있고 모든 중복 쉼표를 제거하려는 경우.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="11e735017335bc0a521dcf44d5eed735e118f9c6" translate="yes" xml:space="preserve">
          <source>For replacing a single time use:</source>
          <target state="translated">한 번만 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="149bb522c45db99a08d6a7b4983aa120a2224b39" translate="yes" xml:space="preserve">
          <source>For replacing multiple times use:</source>
          <target state="translated">여러 번 교체하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="36e472462a8bc791f2ba2aeae075e82051d294fc" translate="yes" xml:space="preserve">
          <source>For the sake of completeness, I got to thinking about which method I should use to do this. There are basically two ways to do this as suggested by the other answers on this page.</source>
          <target state="translated">완벽을 기하기 위해 어떤 방법을 사용해야하는지 생각해야했습니다. 이 페이지의 다른 답변에서 제안한대로 기본적으로 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3edbcc75bd7b794628267175a04820e53edbdd3" translate="yes" xml:space="preserve">
          <source>Given that this question still gets a lot of views, I thought I might add an example of &lt;code&gt;.replace&lt;/code&gt; used with a callback function. In this case, it dramatically simplifies the expression &lt;em&gt;and&lt;/em&gt; provides even more flexibility, like replacing with correct capitalisation or replacing both &lt;code&gt;cat&lt;/code&gt; and &lt;code&gt;cats&lt;/code&gt; in one go:</source>
          <target state="translated">이 질문에 여전히 많은 관점이 있으므로 콜백 함수와 함께 사용되는 &lt;code&gt;.replace&lt;/code&gt; 예제를 추가 할 수 있다고 생각했습니다. 이 경우 표현을 획기적으로 단순화하고 올바른 대문자로 바꾸거나 &lt;code&gt;cat&lt;/code&gt; 와 &lt;code&gt;cats&lt;/code&gt; 를 한 번에 바꾸는 등의 유연성을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b7e3e4b0658ce61581539adf4188d7ebffea28ab" translate="yes" xml:space="preserve">
          <source>Here's a string prototype function based on the accepted answer:</source>
          <target state="translated">허용되는 답변을 기반으로 한 문자열 프로토 타입 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="24794182023bcc1030d2a1378b77bbf20705a2df" translate="yes" xml:space="preserve">
          <source>How can I replace &lt;strong&gt;all&lt;/strong&gt; occurrences of it?</source>
          <target state="translated">&lt;strong&gt;모든&lt;/strong&gt; 발생을 어떻게 교체 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="617a8962b7e2e0f4b9d1343195a5c0af913dde36" translate="yes" xml:space="preserve">
          <source>How to replace all occurrences of a string</source>
          <target state="translated">모든 문자열을 바꾸는 방법</target>
        </trans-unit>
        <trans-unit id="271eda4d77d19f0c8b1efeb10240701ebf85921b" translate="yes" xml:space="preserve">
          <source>I also create my own solution. It looks like currently it is the shortest one which does the question job:</source>
          <target state="translated">나는 또한 내 자신의 솔루션을 만듭니다. 현재 질문 작업을 수행하는 것이 가장 짧은 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="27385f76de96154d8b2e18f8f81576c4eed4be96" translate="yes" xml:space="preserve">
          <source>I have this string:</source>
          <target state="translated">이 문자열이 있습니다.</target>
        </trans-unit>
        <trans-unit id="92d7e77cec099283fa1ca888be9c7bb01adb1197" translate="yes" xml:space="preserve">
          <source>I like this method (it looks a little cleaner):</source>
          <target state="translated">나는이 방법을 좋아한다 (약간 깨끗해 보인다) :</target>
        </trans-unit>
        <trans-unit id="0d74abf0b650c9679eebf5f617351ed153d36de9" translate="yes" xml:space="preserve">
          <source>I try to perform tests for 1M characters for other solutions, but &lt;strong&gt;E,F,G,H&lt;/strong&gt; takes so much time that browser ask me to break script so I shrink test string to 275K characters. You can run tests on your machine &lt;a href=&quot;https://jsperf.com/remove-substring-big/1&quot;&gt;HERE&lt;/a&gt;. Results for Chrome</source>
          <target state="translated">다른 솔루션에 대해 1M 문자에 대한 테스트를 시도하지만 &lt;strong&gt;E, F, G, H&lt;/strong&gt; 는 브라우저가 스크립트를 중단하도록 요청하는 데 많은 시간이 걸리므로 테스트 문자열을 275K 문자로 줄입니다. &lt;a href=&quot;https://jsperf.com/remove-substring-big/1&quot;&gt;여기서&lt;/a&gt; 컴퓨터에서 테스트를 실행할 수 있습니다. Chrome에 대한 결과</target>
        </trans-unit>
        <trans-unit id="571150b46c01207484df0493bc72e22e092ba6fb" translate="yes" xml:space="preserve">
          <source>I was trying to think about something more simple than modifying the string prototype.</source>
          <target state="translated">문자열 프로토 타입을 수정하는 것보다 더 간단한 것을 생각하려고했습니다.</target>
        </trans-unit>
        <trans-unit id="f6f84f4228ff1dc85882fa840346aac31c421b25" translate="yes" xml:space="preserve">
          <source>If the string contain similar pattern like &lt;code&gt;abccc&lt;/code&gt;, you can use this:</source>
          <target state="translated">문자열에 &lt;code&gt;abccc&lt;/code&gt; 와 유사한 패턴이 포함되어 있으면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8889bb9f75193ae0d9d2462502aa8b541a30bf48" translate="yes" xml:space="preserve">
          <source>If what you want to find is already in a string, and you don't have a regex escaper handy, you can use join/split:</source>
          <target state="translated">찾고자하는 문자열이 이미 있고 정규 표현식 이스케이프가없는 경우 join / split을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6426ffa6019405a00629f74abdadd40f6f1fa52f" translate="yes" xml:space="preserve">
          <source>If you are trying to ensure that the string you are looking for won't exist even after the replacement, you need to use a loop.</source>
          <target state="translated">교체 후에도 찾고자하는 문자열이 존재하지 않도록하려면 루프를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8017ab8bc71676e6882e731d96181ecc21dfc1db" translate="yes" xml:space="preserve">
          <source>If you think of reuse, create a function to do that for you, but it's not recommended as it's only one line function, but again if you heavily use this, you can write something like this:</source>
          <target state="translated">재사용을 생각한다면, 그것을 위해 함수를 작성하십시오.하지만 한 줄 함수이므로 권장하지 않지만 다시 이것을 많이 사용하면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a4b3b967221be750b157c4ee9fe1f50d77f67db" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;find&lt;/code&gt; will contain special characters then you need to escape them:</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; 특수 문자가 포함되어 있으면 해당 문자를 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="079c54dc97655e15c06ad5c00768b648932e30cd" translate="yes" xml:space="preserve">
          <source>In response to &lt;a href=&quot;https://stackoverflow.com/users/49153/click-upvote&quot;&gt;Click Upvote&lt;/a&gt;'s comment, you could simplify it even more:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/49153/click-upvote&quot;&gt;Click Upvote&lt;/a&gt; 의 의견에 대한 답변으로 더 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="191216a7395aed5161e4fcfb09478317c8e872a8" translate="yes" xml:space="preserve">
          <source>In response to comment:</source>
          <target state="translated">의견에 대한 답변 :</target>
        </trans-unit>
        <trans-unit id="dbf9ba5ca6006381bcdff40469061e3b7616e9c3" translate="yes" xml:space="preserve">
          <source>It is almost &lt;strong&gt;twice&lt;/strong&gt; as fast as the split and join method.</source>
          <target state="translated">split 및 join 방법 &lt;strong&gt;보다&lt;/strong&gt; 거의 &lt;strong&gt;두 배&lt;/strong&gt; 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="ee38f424d22647b54ca91efb42b2feb4dc705df1" translate="yes" xml:space="preserve">
          <source>It's somewhat late for an update, but since I just stumbled on this question, and noticed that my previous answer is not one I'm happy with. Since the question involved replaceing a single word, it's incredible nobody thought of using word boundaries (&lt;code&gt;\b&lt;/code&gt;)</source>
          <target state="translated">업데이트가 다소 늦었지만 방금이 질문에 걸려서 이전 답변이 내가 만족하지 않는 것으로 나타났습니다. 문제는 한 단어를 바꾸는 것과 관련이 있기 때문에 아무도 단어 경계를 사용한다고 생각하지 않습니다 ( &lt;code&gt;\b&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e330ec23e20bc0e91f1bf5db33cb4dd1a0e02bd4" translate="yes" xml:space="preserve">
          <source>Just add &lt;code&gt;/g&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; 만 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="80e8772aa17b25f69c6e07312344c7020cbbfee3" translate="yes" xml:space="preserve">
          <source>Long string: 275 000 characters</source>
          <target state="translated">긴 문자열 : 275 000 자</target>
        </trans-unit>
        <trans-unit id="2120bdbb22d21b0fe7265d9572081b7ed870ae9f" translate="yes" xml:space="preserve">
          <source>MDN also provides an implementation to escape our strings. It would be nice if this was also standardized as &lt;code&gt;RegExp.escape(str)&lt;/code&gt;, but alas, it does not exist:</source>
          <target state="translated">MDN은 또한 문자열을 이스케이프하기위한 구현을 제공합니다. 이것이 &lt;code&gt;RegExp.escape(str)&lt;/code&gt; 로 표준화되어 있으면 좋겠지 만 아쉽지만 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0225f5723fc9201da4e25ebcb7e68c6bad705b25" translate="yes" xml:space="preserve">
          <source>Match against a global regular expression:</source>
          <target state="translated">전역 정규 표현식과 일치</target>
        </trans-unit>
        <trans-unit id="f76120c1db181b1c8e257b4637f8e39a2280009d" translate="yes" xml:space="preserve">
          <source>My guess is, this meets your needs. It's not fullproof, of course, but it should be enough to get you started. I'd recommend reading some more on these pages. This'll prove useful in perfecting this expression to meet your specific needs.</source>
          <target state="translated">내 생각에, 이것은 당신의 요구를 충족시킵니다. 물론 완전하지는 않지만 시작하기에 충분해야합니다. 이 페이지에서 더 많은 것을 읽는 것이 좋습니다. 이는 특정 요구를 충족하기 위해이 표현을 완성하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b8897d8922350c71545273bfce790fe7e2f72ff0" translate="yes" xml:space="preserve">
          <source>Not knowing too much about how regular expressions work behind the scenes in terms of efficiency, I tended to lean toward the split and join implementation in the past without thinking about performance. When I did wonder which was more efficient, and by what margin, I used it as an excuse to find out.</source>
          <target state="translated">효율성 측면에서 정규 표현식이이면에서 어떻게 작동하는지에 대해 너무 많이 알지 못했지만 성능에 대해 생각하지 않고 과거에 분할 및 구현에 의존하는 경향이있었습니다. 어느 쪽이 더 효율적이고 어떤 마진으로 궁금해했을 때 나는 그것을 핑계로 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="139a05bf0f987bf64fbec5424cb7d5ebc55496a5" translate="yes" xml:space="preserve">
          <source>On my Chrome Windows&amp;nbsp;8 machine, &lt;strong&gt;the regular expression based implementation is the fastest&lt;/strong&gt;, with the &lt;strong&gt;split and join implementation being 53% slower&lt;/strong&gt;. Meaning the regular expressions are twice as fast for the lorem ipsum input I used.</source>
          <target state="translated">Chrome Windows 8 컴퓨터에서는 &lt;strong&gt;정규식 기반 구현이 가장 빠르며&lt;/strong&gt; &lt;strong&gt;split 및 join 구현은 53 % 느립니다&lt;/strong&gt; . 정규 표현식이 내가 사용한 lorem ipsum 입력의 두 배 빠름을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4aeed3d41975990ec44e159a6fdeea976022e55f" translate="yes" xml:space="preserve">
          <source>Oops indeed, this probably isn't what you want. What is, then? IMHO, a regex that only replaces 'cat' conditionally. (ie not part of a word), like so:</source>
          <target state="translated">실제로, 이것은 아마도 당신이 원하는 것이 아닐 것입니다. 그렇다면 무엇입니까? 조건부로 'cat'만 바꾸는 정규식 IMHO (즉, 단어의 일부가 아님)</target>
        </trans-unit>
        <trans-unit id="5bffa97d2b31528d43e65d8a25a71624db09d635" translate="yes" xml:space="preserve">
          <source>Or try the replaceAll function from here:</source>
          <target state="translated">또는 여기에서 replaceAll 함수를 시도하십시오.</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="958af61f062ee06d08e8952efd18380494a6a4d9" translate="yes" xml:space="preserve">
          <source>RangeError: Maximum call stack size exceeded</source>
          <target state="translated">RangeError : 최대 호출 스택 크기를 초과했습니다</target>
        </trans-unit>
        <trans-unit id="516ae82c40ff23ca1cf1e9b09339a27d789eeb76" translate="yes" xml:space="preserve">
          <source>Regular Expression Based Implementation</source>
          <target state="translated">정규식 기반 구현</target>
        </trans-unit>
        <trans-unit id="1927e4338bf5ed5e34ce23c646604727fd370193" translate="yes" xml:space="preserve">
          <source>Replacing single quotes:</source>
          <target state="translated">작은 따옴표 바꾸기 :</target>
        </trans-unit>
        <trans-unit id="8c27bd4109955934b131a097a08e8328d1b30751" translate="yes" xml:space="preserve">
          <source>Revised jsperf</source>
          <target state="translated">수정 된 jsperf</target>
        </trans-unit>
        <trans-unit id="a3ae420dc94cd8628e9445b30f38b89f9b7e87c7" translate="yes" xml:space="preserve">
          <source>Say you want to replace all the 'abc' with 'x':</source>
          <target state="translated">모든 'abc'를 'x'로 바꾸고 싶다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="b3a0ed02924fa9756353d3b2962c9f868b0376eb" translate="yes" xml:space="preserve">
          <source>See here also</source>
          <target state="translated">여기도 참조</target>
        </trans-unit>
        <trans-unit id="238582b8899c43b60945a04bd423c0787fae81fc" translate="yes" xml:space="preserve">
          <source>Short string - 55 characters</source>
          <target state="translated">짧은 문자열-55 자</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">코드 스 니펫 표시</target>
        </trans-unit>
        <trans-unit id="afc3390a44e6d9658b7dbfc2d9192fef4d5122cc" translate="yes" xml:space="preserve">
          <source>So in order to make the &lt;code&gt;replaceAll()&lt;/code&gt; function above safer, it could be modified to the following if you also include &lt;code&gt;escapeRegExp&lt;/code&gt;:</source>
          <target state="translated">따라서 위의 &lt;code&gt;replaceAll()&lt;/code&gt; 함수를보다 안전하게 만들려면 escapeRegExp 도 포함하면 다음과 같이 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="791f26db7f076b3fe806fedb1dfdd01bdfaabb50" translate="yes" xml:space="preserve">
          <source>Solutions based on &lt;code&gt;split-join&lt;/code&gt; (&lt;strong&gt;A,B&lt;/strong&gt;) or &lt;code&gt;replace&lt;/code&gt; (&lt;strong&gt;C,D&lt;/strong&gt;) are fast</source>
          <target state="translated">&lt;code&gt;split-join&lt;/code&gt; ( &lt;strong&gt;A, B&lt;/strong&gt; ) 또는 &lt;code&gt;replace&lt;/code&gt; ( &lt;strong&gt;C, D&lt;/strong&gt; ) 기반 솔루션은 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="64a7df9d3528430f1d064d94dcd7ce12360a8b65" translate="yes" xml:space="preserve">
          <source>Solutions based on &lt;code&gt;while&lt;/code&gt; (&lt;strong&gt;E,F,G,H&lt;/strong&gt;) are slow - usually ~4 times slower for small strings and about ~3000 times (!) slower for long strings</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; ( &lt;strong&gt;E, F, G, H&lt;/strong&gt; ) 기반 솔루션은 느립니다. 일반적으로 작은 줄의 경우 ~ 4 배 느리고 긴 줄의 경우 ~ 3000 배 (!) 느립니다.</target>
        </trans-unit>
        <trans-unit id="c5f617985382ce2f6b1ad5a88716ff377cafb216" translate="yes" xml:space="preserve">
          <source>Split and Join (Functional) Implementation</source>
          <target state="translated">분할 및 결합 (기능) 구현</target>
        </trans-unit>
        <trans-unit id="3f262f9b42c014ce513b61f570042ee408a6ccbe" translate="yes" xml:space="preserve">
          <source>The 'replaceAll' method is added to String's prototype. This means it will be available for all string objects/literals.</source>
          <target state="translated">'replaceAll'메소드가 String의 프로토 타입에 추가됩니다. 이는 모든 문자열 객체 / 리터럴에 사용할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="70a3c41c6145b1073780fd66e0a5961a9f9d085d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str.replace(/abc/g, '');&lt;/code&gt; (&lt;strong&gt;C&lt;/strong&gt;) is a good cross-browser fast solution for all strings.</source>
          <target state="translated">&lt;code&gt;str.replace(/abc/g, '');&lt;/code&gt; ( &lt;strong&gt;C&lt;/strong&gt; )는 모든 문자열에 적합한 브라우저 간 빠른 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="6862722646db89bf527d4db5a4180543b94a8268" translate="yes" xml:space="preserve">
          <source>The general pattern is</source>
          <target state="translated">일반적인 패턴은</target>
        </trans-unit>
        <trans-unit id="ad15bf1a90e5b964105fd6d24685320af721a361" translate="yes" xml:space="preserve">
          <source>The output is the same as the accepted answer, however, using the /cat/g expression on this string:</source>
          <target state="translated">그러나 출력은 다음 문자열에서 / cat / g 표현식을 사용하여 허용되는 답변과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="500d5673e29a623bf205aac14d021c9e4584c6d7" translate="yes" xml:space="preserve">
          <source>The previous answers are way too complicated. Just use the replace function like this:</source>
          <target state="translated">이전 답변은 너무 복잡합니다. 다음과 같이 바꾸기 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3edf210ac416af9397656481643d3200184bbd0a" translate="yes" xml:space="preserve">
          <source>The recurrence solutions (&lt;strong&gt;RA,RB&lt;/strong&gt;) are slow and do not work for long strings</source>
          <target state="translated">반복 솔루션 ( &lt;strong&gt;RA, RB&lt;/strong&gt; )은 느리고 긴 문자열에는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="50bd0e425afb39661b9eb4e9f39fd4b4493a5609" translate="yes" xml:space="preserve">
          <source>The recursive solutions &lt;strong&gt;RA&lt;/strong&gt; and &lt;strong&gt;RB&lt;/strong&gt; gives</source>
          <target state="translated">재귀 솔루션 &lt;strong&gt;RA&lt;/strong&gt; 및 &lt;strong&gt;RB&lt;/strong&gt; 는</target>
        </trans-unit>
        <trans-unit id="369989b3729604fa9987753462bbbf349899d07e" translate="yes" xml:space="preserve">
          <source>The simplest loop to solve this would be:</source>
          <target state="translated">이를 해결하는 가장 간단한 루프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="03772ccff926aef82feb6ee59ca395521b306264" translate="yes" xml:space="preserve">
          <source>The simplest way to this without using any regex is split and join like the code here:</source>
          <target state="translated">정규 표현식을 사용하지 않고이를 수행하는 가장 간단한 방법은 다음 코드와 같이 분할되고 결합됩니다.</target>
        </trans-unit>
        <trans-unit id="e03cd7383682fc6d72d2b9f15ccd635f4298117f" translate="yes" xml:space="preserve">
          <source>The tests were performed on Chrome 79.0, Safari 13.0.4 and Firefox 71.0 (64 bit). The tests &lt;code&gt;RA&lt;/code&gt; and &lt;code&gt;RB&lt;/code&gt; use recursion. Results</source>
          <target state="translated">테스트는 Chrome 79.0, Safari 13.0.4 및 Firefox 71.0 (64 비트)에서 수행되었습니다. &lt;code&gt;RA&lt;/code&gt; 및 &lt;code&gt;RB&lt;/code&gt; 테스트는 재귀를 사용합니다. 결과</target>
        </trans-unit>
        <trans-unit id="a9311a98961911f95ad2bd5e24444545ee47566a" translate="yes" xml:space="preserve">
          <source>There is another jsperf with variants on my recursive replace that go even faster (&lt;a href=&quot;http://jsperf.com/replace-all-vs-split-join/12&quot;&gt;http://jsperf.com/replace-all-vs-split-join/12&lt;/a&gt;)!</source>
          <target state="translated">내 재귀 대체에 변형이있는 또 다른 jsperf가 더 빠릅니다 ( &lt;a href=&quot;http://jsperf.com/replace-all-vs-split-join/12&quot;&gt;http://jsperf.com/replace-all-vs-split-join/12&lt;/a&gt; )!</target>
        </trans-unit>
        <trans-unit id="16225ef62710b40df18181fe23a2e790ba51aaf9" translate="yes" xml:space="preserve">
          <source>These are the most common and readable methods.</source>
          <target state="translated">가장 일반적이고 읽기 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="df35a931ffe321873755cadd3104fa2c6ab5abc1" translate="yes" xml:space="preserve">
          <source>This can be particularly useful when looking for duplicate strings.</source>
          <target state="translated">중복 문자열을 찾을 때 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="367dab6a1825fbf327c5342ee35812bde1eec73e" translate="yes" xml:space="preserve">
          <source>This is a simple regex that avoids replacing parts of words in most cases. However, a dash &lt;code&gt;-&lt;/code&gt; is still considered a word boundary. So conditionals can be used in this case to avoid replacing strings like &lt;code&gt;cool-cat&lt;/code&gt;:</source>
          <target state="translated">이것은 대부분의 경우 단어의 일부를 대체하지 않는 간단한 정규식입니다. 그러나 대시 &lt;code&gt;-&lt;/code&gt; 는 여전히 단어 경계로 간주됩니다. 따라서이 경우 조건부를 사용하여 &lt;code&gt;cool-cat&lt;/code&gt; 과 같은 문자열을 교체하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="c02562e1f6d4a5cbf736a7b0837cb984e69786fd" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;fastest&lt;/strong&gt; version that &lt;em&gt;doesn't use regular expressions&lt;/em&gt;.</source>
          <target state="translated">이것은 &lt;em&gt;정규식을 사용하지 않는&lt;/em&gt; &lt;strong&gt;가장 빠른&lt;/strong&gt; 버전입니다.</target>
        </trans-unit>
        <trans-unit id="ba6f081fdf243a403bac2ba3cf8f0fdee154766a" translate="yes" xml:space="preserve">
          <source>This used to be faster in some cases than using &lt;code&gt;replaceAll&lt;/code&gt; and a regular expression, but that doesn't seem to be the case anymore in modern browsers.</source>
          <target state="translated">이것은 &lt;code&gt;replaceAll&lt;/code&gt; 과 정규 표현식을 사용하는 것보다 더 빠른 경우가 있었지만 현대 브라우저에서는 더 이상 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c06e71ba6500c4e97fef51f00b081079208d8af6" translate="yes" xml:space="preserve">
          <source>Today 27.12.2019 I perform tests on &lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; (High Sierra) for the chosen solutions.</source>
          <target state="translated">오늘 27.12.2019 선택한 솔루션에 대해 &lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; (High Sierra)에서 테스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8f10ddde05bf54e0d639e76139d9d0182eb95a01" translate="yes" xml:space="preserve">
          <source>Update July 27th 2017: It looks like RegExp now has the fastest performance in the recently released Chrome 59.</source>
          <target state="translated">2017 년 7 월 27 일 업데이트 : RegExp가 최근에 출시 된 Chrome 59에서 가장 빠른 성능을 보이는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="4bcac541a8c7f79ba50a38a8988ad2f783681ee0" translate="yes" xml:space="preserve">
          <source>Use a regular expression:</source>
          <target state="translated">정규식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="c2aee7f5722611179e110f5e6d7da49f02ff7c59" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;RegExp&lt;/code&gt; in &lt;strong&gt;JavaScript&lt;/strong&gt; could do the job for you, just simply do something like below code, don't forget the &lt;code&gt;/g&lt;/code&gt; after which standout for &lt;strong&gt;global&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;JavaScript&lt;/strong&gt; 에서 &lt;code&gt;RegExp&lt;/code&gt; 를 사용하면 작업을 수행 할 수 있습니다. 아래 코드와 같은 작업을 수행하고 &lt;strong&gt;전역에&lt;/strong&gt; 대한 &lt;code&gt;/g&lt;/code&gt; 를 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9da6ee93a958af3f2a1cebcc0f2590371d8cb6b8" translate="yes" xml:space="preserve">
          <source>Using a regular expression with the &lt;code&gt;g&lt;/code&gt; flag set will replace all:</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; 플래그가 설정된 정규식을 사용하면 다음이 모두 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="09b3286eff56349c39d102a1b366232dba4e9210" translate="yes" xml:space="preserve">
          <source>We could call &lt;code&gt;escapeRegExp&lt;/code&gt; within our &lt;code&gt;String.prototype.replaceAll&lt;/code&gt; implementation, however, I'm not sure how much this will affect the performance (potentially even for strings for which the escape is not needed, like all alphanumeric strings).</source>
          <target state="translated">&lt;code&gt;String.prototype.replaceAll&lt;/code&gt; 구현 내에서 &lt;code&gt;escapeRegExp&lt;/code&gt; 를 호출 할 수는 있지만 이것이 성능에 얼마나 영향을 미치는지 확실하지 않습니다 (잠재적으로 모든 영숫자 문자열과 같이 이스케이프가 필요하지 않은 문자열의 경우에도).</target>
        </trans-unit>
        <trans-unit id="00df80bf98961b338c936f71eb4491af5d4e6cd7" translate="yes" xml:space="preserve">
          <source>What are useful JavaScript methods that extends built-in objects?</source>
          <target state="translated">내장 객체를 확장하는 유용한 JavaScript 메소드는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="59826ff0dcdf2c8ff1dc7d8cb137e9a83b75e3ba" translate="yes" xml:space="preserve">
          <source>When complete, you will still have 'test abc'!</source>
          <target state="translated">완료되면 여전히 'test abc'가 있습니다!</target>
        </trans-unit>
        <trans-unit id="7413bc6dfd6712412a62d33b6ad98978fda494ef" translate="yes" xml:space="preserve">
          <source>You can refer the detailed example &lt;a href=&quot;http://www.cheezycode.com/2015/08/javascript-hacks-for-html-webpage.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">자세한 예는 &lt;a href=&quot;http://www.cheezycode.com/2015/08/javascript-hacks-for-html-webpage.html&quot;&gt;여기를&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="14612ebec52e07519f5df0000794a2c86ea5a2ed" translate="yes" xml:space="preserve">
          <source>You can run tests on your machine &lt;a href=&quot;https://jsperf.com/remove-substring-small/1&quot;&gt;HERE&lt;/a&gt;. Results for Chrome:</source>
          <target state="translated">&lt;a href=&quot;https://jsperf.com/remove-substring-small/1&quot;&gt;여기서&lt;/a&gt; 컴퓨터에서 테스트를 실행할 수 있습니다. Chrome 결과 :</target>
        </trans-unit>
        <trans-unit id="d80d16d89e43a7516fb2dee5f412114891576996" translate="yes" xml:space="preserve">
          <source>You can simply use below method</source>
          <target state="translated">아래 방법을 간단하게 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="28905875c9209baab59de2b80e072d7fc36fde6e" translate="yes" xml:space="preserve">
          <source>[In that case, one could do .replace(/,+/g,','), but at some point the regex gets complex and slow enough to loop instead.]</source>
          <target state="translated">[이 경우 .replace (/, + / g, ',') 할 수 있지만 어떤 시점에서 정규 표현식은 복잡하고 대신 반복하기에 충분히 느립니다.]</target>
        </trans-unit>
        <trans-unit id="1aecada00183a6ff5ec2d92396d46a8c0ae9f7e9" translate="yes" xml:space="preserve">
          <source>and simply use it in your code over and over like below:</source>
          <target state="translated">아래 코드와 같이 코드에서 반복해서 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cc4acdb915a5e6e90d0ec0a00fa9a185d964911a" translate="yes" xml:space="preserve">
          <source>basically, this question is the same as the question here:
&lt;a href=&quot;https://stackoverflow.com/questions/9499075/javascript-replace-with/9499926&quot;&gt;Javascript replace &quot; ' &quot; with &quot; '' &quot;&lt;/a&gt;</source>
          <target state="translated">기본적으로이 질문은 다음 질문과 동일합니다. &lt;a href=&quot;https://stackoverflow.com/questions/9499075/javascript-replace-with/9499926&quot;&gt;Javascript replace &quot; '&quot; &quot;&quot; &quot;&quot;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0d24cf1b244ef65eac88d415645e906ecf67ee0" translate="yes" xml:space="preserve">
          <source>seems to only remove the first occurrence of &lt;code&gt;abc&lt;/code&gt; in the string above.</source>
          <target state="translated">위의 문자열에서 &lt;code&gt;abc&lt;/code&gt; 의 첫 번째 항목 만 제거하는 것 같습니다.</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="f57ca77c39afa4ad77c7b0cbdd76aaef04834b2b" translate="yes" xml:space="preserve">
          <source>worked better for me than the above answers. so &lt;code&gt;new RegExp(&quot;abc&quot;, 'g')&lt;/code&gt; creates a RegExp what matches all occurence (&lt;code&gt;'g'&lt;/code&gt; flag) of the text (&lt;code&gt;&quot;abc&quot;&lt;/code&gt;). The second part is what gets replaced to, in your case empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;).
&lt;code&gt;str&lt;/code&gt; is the string, and we have to override it, as &lt;code&gt;replace(...)&lt;/code&gt; just returns result, but not overrides. In some cases you might want to use that.</source>
          <target state="translated">위의 답변보다 나를 위해 더 잘 작동했습니다. 따라서 &lt;code&gt;new RegExp(&quot;abc&quot;, 'g')&lt;/code&gt; 는 텍스트 ( &lt;code&gt;&quot;abc&quot;&lt;/code&gt; )의 모든 발생 ( &lt;code&gt;'g'&lt;/code&gt; 플래그)과 일치하는 RegExp를 만듭니다. 두 번째 부분은 빈 문자열 ( &lt;code&gt;&quot;&quot;&lt;/code&gt; )로 대체됩니다. &lt;code&gt;str&lt;/code&gt; 은 문자열이며, &lt;code&gt;replace(...)&lt;/code&gt; 는 결과를 반환하지만 재정의는하지 않기 때문에 재정의해야합니다. 경우에 따라 사용할 수도 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
