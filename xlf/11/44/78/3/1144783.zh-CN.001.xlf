<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/1144783">
    <body>
      <group id="1144783">
        <trans-unit id="d9952330ff36e4f4aeca5f93ac713b20da31fa77" translate="yes" xml:space="preserve">
          <source>//loop it until number occurrences comes to 0. OR simply copy/paste</source>
          <target state="translated">/循环,直到出现的次数为0为止。</target>
        </trans-unit>
        <trans-unit id="c8857126cc10f9914e5f38613f237895ee5c6b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/g&lt;/code&gt; means global</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; 表示全局</target>
        </trans-unit>
        <trans-unit id="bb5c0451b917db9a91e43681457634a56c6655aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Update:&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Update:&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="54d43c52441fb7bd3ed00affd5f9186806533d64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7e2cd0e1a6f716d8fe13350e59d99500575639f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; Clarification about replaceAll availability</source>
          <target state="translated">&lt;strong&gt;编辑：&lt;/strong&gt;有关replaceAll可用性的说明</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f29304ea9cd1982b93d7af334cf0f88bae973ea7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Final addition:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最后添加：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d371a375635dead23e71c6018c06fc0b2d6bcf0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;方法1：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39ba8b2d14f80c96148df898ae74111bfba336f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;方法2：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72d457e583e8bca3f439a3a897e489de0b498c03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;方法3：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="529383dcc2e9606a5bb75847be52ba72603eb93a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;方法4：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0737a49188ce80e8c141eb30d15abad1f570e32c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: Don't use this in performance critical code.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;注意：请勿在对性能有要求的代码中使用此代码。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56781c4490d4641a69cef533a9621281a430d169" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In general, extending the built-in prototypes in JavaScript is generally not recommended. I am providing as extensions on the String prototype simply for purposes of illustration, showing different implementations of a hypothetical standard method on the &lt;code&gt;String&lt;/code&gt; built-in prototype.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;通常，通常不建议在JavaScript中扩展内置原型。 我仅作为说明目的在String原型上提供扩展，展示了 &lt;code&gt;String&lt;/code&gt; 内置原型上假设的标准方法的不同实现。</target>
        </trans-unit>
        <trans-unit id="e9ca3f2973d0dabdd79539f415055d2ed5b22768" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Regular expressions contain special (meta) characters, and as such it is dangerous to blindly pass an argument in the &lt;code&gt;find&lt;/code&gt; function above without pre-processing it to escape those characters.  This is covered in the &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;Mozilla Developer Network&lt;/a&gt;'s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping&quot;&gt;JavaScript Guide on Regular Expressions&lt;/a&gt;, where they present the following utility function (which has changed at least twice since this answer was originally written, so make sure to check the MDN site for potential updates):</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;正则表达式包含特殊的（元）字符，因此危险地在上面的 &lt;code&gt;find&lt;/code&gt; 函数中盲目传递参数，而无需对其进行预处理以转义那些字符。 &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;Mozilla开发人员网络&lt;/a&gt;的&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping&quot;&gt;JavaScript正则表达式指南中&lt;/a&gt;对此进行了介绍，该指南提供了以下实用程序功能（自最初编写此答案以来，该功能至少已更改两次，因此请确保检查MDN站点是否有潜在更新）：</target>
        </trans-unit>
        <trans-unit id="4cdcd3fdc8587add9d1885342dfb4ded08633670" translate="yes" xml:space="preserve">
          <source>@Mike, check the answer I gave there... regexp isn't the only way to replace multiple occurrences of a subsrting, far from it. Think flexible, think split!</source>
          <target state="translated">@Mike,看看我的回答......regexp并不是唯一能替换多个子计算的方法,远非如此。想着灵活,想着分割!</target>
        </trans-unit>
        <trans-unit id="9f7ff750c8d42bac2d5bf7ded2777806c7bbd646" translate="yes" xml:space="preserve">
          <source>Alternatively, to prevent replacing word parts -which the approved answer will do, too! You can get around this issue using regular expressions that are, I admit, somewhat more complex and as an upshot of that, a tad slower, too:</source>
          <target state="translated">你可以使用正则表达式来解决这个问题,我承认,这种表达式比较复杂,而且作为一个结果,它也比较慢。</target>
        </trans-unit>
        <trans-unit id="9abf1f2f157ce45f651d436bf184af77b8adeb5e" translate="yes" xml:space="preserve">
          <source>Although people have mentioned the use of regex but there's a better approach if you want to replace the text irrespective of the case of the text. Like uppercase or lowercase. Use below syntax</source>
          <target state="translated">虽然大家都提到过使用regex,但是如果你想不顾文字的大小写而更换文字,还有一个更好的方法。比如说大写或小写。使用下面的语法</target>
        </trans-unit>
        <trans-unit id="d9e6101a86eec306979f963e9857be885e7245e2" translate="yes" xml:space="preserve">
          <source>As an alternative to regular expressions for a simple literal string, you could use</source>
          <target state="translated">作为一个简单的直译字符串的正则表达式的替代方案,你可以使用</target>
        </trans-unit>
        <trans-unit id="c152952996b6a5c283c92260257eb9c156c7669e" translate="yes" xml:space="preserve">
          <source>As noted in the comment below by @ThomasLeduc and others, there could be an issue with the regular expression-based implementation if &lt;code&gt;search&lt;/code&gt; contains certain characters which are reserved as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;special characters in regular expressions&lt;/a&gt;. The implementation assumes that the caller will escape the string beforehand or will only pass strings that are without the characters in the table in &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;Regular Expressions&lt;/a&gt;&lt;/em&gt; (MDN).</source>
          <target state="translated">如@ThomasLeduc和其他人在下面的注释中所指出的，如果 &lt;code&gt;search&lt;/code&gt; 包含某些保留为&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;正则表达式中特殊字符的字符，则&lt;/a&gt;基于正则表达式的实现可能会出现问题。 该实现假定调用方将预先转义字符串，或仅传递不包含&lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;正则表达式&lt;/a&gt;&lt;/em&gt; （MDN）表中字符的字符串。</target>
        </trans-unit>
        <trans-unit id="63b3d8e8f8a79cd8ec7c3c5683b3642dffed71ed" translate="yes" xml:space="preserve">
          <source>As pointed out in a comment here, this will not work if your &lt;code&gt;omit&lt;/code&gt; variable contains &lt;code&gt;place&lt;/code&gt;, as in: &lt;code&gt;replaceAll(&quot;string&quot;, &quot;s&quot;, &quot;ss&quot;)&lt;/code&gt;, because it will always be able to replace another occurrence of the word.</source>
          <target state="translated">如此处评论中所指出的，如果您的 &lt;code&gt;omit&lt;/code&gt; 变量包含 &lt;code&gt;place&lt;/code&gt; ，则该方法将不起作用，例如： &lt;code&gt;replaceAll(&quot;string&quot;, &quot;s&quot;, &quot;ss&quot;)&lt;/code&gt; ，因为它将始终能够替换该单词的另一个出现位置。</target>
        </trans-unit>
        <trans-unit id="2efdbb9e7d89d63a3865b145be18d2985735f425" translate="yes" xml:space="preserve">
          <source>Benchmark: &lt;a href=&quot;https://jsperf.com/replace-all-vs-split-join&quot;&gt;https://jsperf.com/replace-all-vs-split-join&lt;/a&gt;</source>
          <target state="translated">基准测试： &lt;a href=&quot;https://jsperf.com/replace-all-vs-split-join&quot;&gt;https&lt;/a&gt; ： //jsperf.com/replace-all-vs-split-join</target>
        </trans-unit>
        <trans-unit id="2f018edf766c43f923af62d936f6faa226aba148" translate="yes" xml:space="preserve">
          <source>But as I mention earlier, it won't make a huge difference in terms of lines to be written or performance, only caching the function may effect some faster performance on long strings and also a good practice of DRY code if you want to reuse.</source>
          <target state="translated">但就像我前面提到的那样,在要写的行数和性能上不会有很大的区别,只是缓存功能可能会影响一些长字符串上的性能更快,如果你想重用的话,也是DRY代码的好做法。</target>
        </trans-unit>
        <trans-unit id="d0e0c00e52a63b53922a63942eb8ba57f073ff62" translate="yes" xml:space="preserve">
          <source>But that runs the replacement twice for each cycle. Perhaps (at risk of being voted down) that can be combined for a slightly more efficient but less readable form:</source>
          <target state="translated">但这样一来,每个周期都要进行两次替换。也许(有被否决的风险),可以组合成一个效率稍高但可读性较差的形式。</target>
        </trans-unit>
        <trans-unit id="4781d0025fe7cca970eabbf656f7ad7b779e25ea" translate="yes" xml:space="preserve">
          <source>Check out this &lt;a href=&quot;http://jsben.ch/#/LFfWA&quot;&gt;&lt;strong&gt;benchmark&lt;/strong&gt;&lt;/a&gt; running these two implementations against each other.</source>
          <target state="translated">检验此&lt;a href=&quot;http://jsben.ch/#/LFfWA&quot;&gt;&lt;strong&gt;基准测试&lt;/strong&gt;&lt;/a&gt; ，相互&lt;strong&gt;对照&lt;/strong&gt;运行这两个实现。</target>
        </trans-unit>
        <trans-unit id="c33ec0466fe646cd010b474e907704e44e7c4bfa" translate="yes" xml:space="preserve">
          <source>Code used in tests</source>
          <target state="translated">测试中使用的代码</target>
        </trans-unit>
        <trans-unit id="dfa777c69364feec4e5703f84e2ca7d360aff891" translate="yes" xml:space="preserve">
          <source>Conclusion: If you have a performance critical use case (e.g processing hundreds of strings), use the Regexp method. But for most typical use cases, this is well worth not having to worry about special characters.</source>
          <target state="translated">总结:如果你有一个性能关键的用例(如处理数百个字符串),请使用Regexp方法。如果你有一个性能关键的用例(如处理数百个字符串),请使用Regexp方法。但对于大多数典型的用例来说,这样做是非常值得的,不用担心特殊字符。</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="ade2304f2a0ac295b0c79d7fe9ea6df6dc08d89f" translate="yes" xml:space="preserve">
          <source>Doing:</source>
          <target state="translated">Doing:</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="dade7a599b73d04a874d2b0f676893876a891d64" translate="yes" xml:space="preserve">
          <source>Fiddle: &lt;a href=&quot;http://jsfiddle.net/cdbzL/&quot;&gt;http://jsfiddle.net/cdbzL/&lt;/a&gt;</source>
          <target state="translated">小提琴： &lt;a href=&quot;http://jsfiddle.net/cdbzL/&quot;&gt;http&lt;/a&gt; : //jsfiddle.net/cdbzL/</target>
        </trans-unit>
        <trans-unit id="be49c2939db3ee7e866d3291921abff640df9c2e" translate="yes" xml:space="preserve">
          <source>For 1M characters they even break Chrome</source>
          <target state="translated">对于1M字符,他们甚至打破了Chrome浏览器</target>
        </trans-unit>
        <trans-unit id="b8c42f762938f25c778634ec4aa570773188eb6e" translate="yes" xml:space="preserve">
          <source>For example, if we have 'a,,,b' and we wish to remove all duplicate commas.</source>
          <target state="translated">例如,如果我们有'a,,,,,b',我们希望删除所有重复的逗号。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="11e735017335bc0a521dcf44d5eed735e118f9c6" translate="yes" xml:space="preserve">
          <source>For replacing a single time use:</source>
          <target state="translated">用于更换一次性使用。</target>
        </trans-unit>
        <trans-unit id="149bb522c45db99a08d6a7b4983aa120a2224b39" translate="yes" xml:space="preserve">
          <source>For replacing multiple times use:</source>
          <target state="translated">用于多次更换使用。</target>
        </trans-unit>
        <trans-unit id="36e472462a8bc791f2ba2aeae075e82051d294fc" translate="yes" xml:space="preserve">
          <source>For the sake of completeness, I got to thinking about which method I should use to do this. There are basically two ways to do this as suggested by the other answers on this page.</source>
          <target state="translated">为了完整,我开始思考应该用什么方法来做这个问题。根据本页其他答案的建议,基本上有两种方法。</target>
        </trans-unit>
        <trans-unit id="c3edbcc75bd7b794628267175a04820e53edbdd3" translate="yes" xml:space="preserve">
          <source>Given that this question still gets a lot of views, I thought I might add an example of &lt;code&gt;.replace&lt;/code&gt; used with a callback function. In this case, it dramatically simplifies the expression &lt;em&gt;and&lt;/em&gt; provides even more flexibility, like replacing with correct capitalisation or replacing both &lt;code&gt;cat&lt;/code&gt; and &lt;code&gt;cats&lt;/code&gt; in one go:</source>
          <target state="translated">考虑到这个问题仍然有很多观点，我想我可以添加一个与回调函数一起使用的 &lt;code&gt;.replace&lt;/code&gt; 示例。 在这种情况下，它极大地简化了表达式&lt;em&gt;并&lt;/em&gt;提供了更大的灵活性，例如用正确的大写字母替换或一次替换 &lt;code&gt;cat&lt;/code&gt; 和 &lt;code&gt;cats&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="b7e3e4b0658ce61581539adf4188d7ebffea28ab" translate="yes" xml:space="preserve">
          <source>Here's a string prototype function based on the accepted answer:</source>
          <target state="translated">下面是一个基于接受答案的字符串原型函数。</target>
        </trans-unit>
        <trans-unit id="24794182023bcc1030d2a1378b77bbf20705a2df" translate="yes" xml:space="preserve">
          <source>How can I replace &lt;strong&gt;all&lt;/strong&gt; occurrences of it?</source>
          <target state="translated">如何替换&lt;strong&gt;所有&lt;/strong&gt;出现的内容？</target>
        </trans-unit>
        <trans-unit id="617a8962b7e2e0f4b9d1343195a5c0af913dde36" translate="yes" xml:space="preserve">
          <source>How to replace all occurrences of a string</source>
          <target state="translated">如何替换一个字符串的所有出现的次数</target>
        </trans-unit>
        <trans-unit id="271eda4d77d19f0c8b1efeb10240701ebf85921b" translate="yes" xml:space="preserve">
          <source>I also create my own solution. It looks like currently it is the shortest one which does the question job:</source>
          <target state="translated">我也是自创了自己的解决方案。目前看来,它是最短的那一个做题的方案。</target>
        </trans-unit>
        <trans-unit id="27385f76de96154d8b2e18f8f81576c4eed4be96" translate="yes" xml:space="preserve">
          <source>I have this string:</source>
          <target state="translated">我有这一串。</target>
        </trans-unit>
        <trans-unit id="92d7e77cec099283fa1ca888be9c7bb01adb1197" translate="yes" xml:space="preserve">
          <source>I like this method (it looks a little cleaner):</source>
          <target state="translated">我喜欢这种方法(看起来比较干净)。</target>
        </trans-unit>
        <trans-unit id="0d74abf0b650c9679eebf5f617351ed153d36de9" translate="yes" xml:space="preserve">
          <source>I try to perform tests for 1M characters for other solutions, but &lt;strong&gt;E,F,G,H&lt;/strong&gt; takes so much time that browser ask me to break script so I shrink test string to 275K characters. You can run tests on your machine &lt;a href=&quot;https://jsperf.com/remove-substring-big/1&quot;&gt;HERE&lt;/a&gt;. Results for Chrome</source>
          <target state="translated">我尝试对其他解决方案的1M个字符执行测试，但是&lt;strong&gt;E，F，G，H&lt;/strong&gt;花费了很多时间，浏览器要求我中断脚本，因此我将测试字符串缩小为275K个字符。 您可以在&lt;a href=&quot;https://jsperf.com/remove-substring-big/1&quot;&gt;此处&lt;/a&gt;在计算机上运行测试。 Chrome的搜索结果</target>
        </trans-unit>
        <trans-unit id="571150b46c01207484df0493bc72e22e092ba6fb" translate="yes" xml:space="preserve">
          <source>I was trying to think about something more simple than modifying the string prototype.</source>
          <target state="translated">我一直在想一些比修改字符串原型更简单的东西。</target>
        </trans-unit>
        <trans-unit id="f6f84f4228ff1dc85882fa840346aac31c421b25" translate="yes" xml:space="preserve">
          <source>If the string contain similar pattern like &lt;code&gt;abccc&lt;/code&gt;, you can use this:</source>
          <target state="translated">如果字符串包含类似 &lt;code&gt;abccc&lt;/code&gt; 的模式，则可以使用以下命令：</target>
        </trans-unit>
        <trans-unit id="8889bb9f75193ae0d9d2462502aa8b541a30bf48" translate="yes" xml:space="preserve">
          <source>If what you want to find is already in a string, and you don't have a regex escaper handy, you can use join/split:</source>
          <target state="translated">如果你想找的东西已经在一个字符串中,而你又没有regex转义符,你可以使用joinsplit。</target>
        </trans-unit>
        <trans-unit id="6426ffa6019405a00629f74abdadd40f6f1fa52f" translate="yes" xml:space="preserve">
          <source>If you are trying to ensure that the string you are looking for won't exist even after the replacement, you need to use a loop.</source>
          <target state="translated">如果你想确保你要找的字符串在更换后也不会存在,那么你需要使用循环。</target>
        </trans-unit>
        <trans-unit id="8017ab8bc71676e6882e731d96181ecc21dfc1db" translate="yes" xml:space="preserve">
          <source>If you think of reuse, create a function to do that for you, but it's not recommended as it's only one line function, but again if you heavily use this, you can write something like this:</source>
          <target state="translated">如果你想到了重用,那就创建一个函数来帮你做这个,不过不推荐,因为这只是单行函数,但同样的,如果你大量使用这个,你可以写成这样的东西。</target>
        </trans-unit>
        <trans-unit id="6a4b3b967221be750b157c4ee9fe1f50d77f67db" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;find&lt;/code&gt; will contain special characters then you need to escape them:</source>
          <target state="translated">如果 &lt;code&gt;find&lt;/code&gt; 包含特殊字符，则需要转义它们：</target>
        </trans-unit>
        <trans-unit id="079c54dc97655e15c06ad5c00768b648932e30cd" translate="yes" xml:space="preserve">
          <source>In response to &lt;a href=&quot;https://stackoverflow.com/users/49153/click-upvote&quot;&gt;Click Upvote&lt;/a&gt;'s comment, you could simplify it even more:</source>
          <target state="translated">为了回应&lt;a href=&quot;https://stackoverflow.com/users/49153/click-upvote&quot;&gt;Click Upvote&lt;/a&gt;的评论，您可以进一步简化它：</target>
        </trans-unit>
        <trans-unit id="191216a7395aed5161e4fcfb09478317c8e872a8" translate="yes" xml:space="preserve">
          <source>In response to comment:</source>
          <target state="translated">作为对评论的回应:</target>
        </trans-unit>
        <trans-unit id="dbf9ba5ca6006381bcdff40469061e3b7616e9c3" translate="yes" xml:space="preserve">
          <source>It is almost &lt;strong&gt;twice&lt;/strong&gt; as fast as the split and join method.</source>
          <target state="translated">它的速度几乎是split and join方法的&lt;strong&gt;两倍&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="ee38f424d22647b54ca91efb42b2feb4dc705df1" translate="yes" xml:space="preserve">
          <source>It's somewhat late for an update, but since I just stumbled on this question, and noticed that my previous answer is not one I'm happy with. Since the question involved replaceing a single word, it's incredible nobody thought of using word boundaries (&lt;code&gt;\b&lt;/code&gt;)</source>
          <target state="translated">更新有点晚了，但是由于我偶然发现了这个问题，并注意到我以前的回答不是我满意的答案。 由于问题涉及替换单个单词，所以没有人想到使用单词边界（ &lt;code&gt;\b&lt;/code&gt; ），这真是令人难以置信</target>
        </trans-unit>
        <trans-unit id="e330ec23e20bc0e91f1bf5db33cb4dd1a0e02bd4" translate="yes" xml:space="preserve">
          <source>Just add &lt;code&gt;/g&lt;/code&gt;</source>
          <target state="translated">只需添加 &lt;code&gt;/g&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80e8772aa17b25f69c6e07312344c7020cbbfee3" translate="yes" xml:space="preserve">
          <source>Long string: 275 000 characters</source>
          <target state="translated">长字符串:275 000个字符</target>
        </trans-unit>
        <trans-unit id="2120bdbb22d21b0fe7265d9572081b7ed870ae9f" translate="yes" xml:space="preserve">
          <source>MDN also provides an implementation to escape our strings. It would be nice if this was also standardized as &lt;code&gt;RegExp.escape(str)&lt;/code&gt;, but alas, it does not exist:</source>
          <target state="translated">MDN还提供了一种实现来转义我们的字符串。 如果也将它也标准化为 &lt;code&gt;RegExp.escape(str)&lt;/code&gt; 会很好，但是，它不存在：</target>
        </trans-unit>
        <trans-unit id="0225f5723fc9201da4e25ebcb7e68c6bad705b25" translate="yes" xml:space="preserve">
          <source>Match against a global regular expression:</source>
          <target state="translated">与全局正则表达式匹配。</target>
        </trans-unit>
        <trans-unit id="f76120c1db181b1c8e257b4637f8e39a2280009d" translate="yes" xml:space="preserve">
          <source>My guess is, this meets your needs. It's not fullproof, of course, but it should be enough to get you started. I'd recommend reading some more on these pages. This'll prove useful in perfecting this expression to meet your specific needs.</source>
          <target state="translated">我的猜测是,这个符合你的需求。当然,这并不全面,但应该足够让你入门了。我建议你多读一些这些页面上的内容。这将证明,这对完善这个表达方式,满足你的具体需求是很有帮助的。</target>
        </trans-unit>
        <trans-unit id="b8897d8922350c71545273bfce790fe7e2f72ff0" translate="yes" xml:space="preserve">
          <source>Not knowing too much about how regular expressions work behind the scenes in terms of efficiency, I tended to lean toward the split and join implementation in the past without thinking about performance. When I did wonder which was more efficient, and by what margin, I used it as an excuse to find out.</source>
          <target state="translated">由于不太了解正则表达式背后的效率,我过去往往倾向于采用拆分和联接的方式来实现,而不考虑性能问题。当我想知道哪种方式更有效率时,我就把它作为一个借口来寻找答案。</target>
        </trans-unit>
        <trans-unit id="139a05bf0f987bf64fbec5424cb7d5ebc55496a5" translate="yes" xml:space="preserve">
          <source>On my Chrome Windows&amp;nbsp;8 machine, &lt;strong&gt;the regular expression based implementation is the fastest&lt;/strong&gt;, with the &lt;strong&gt;split and join implementation being 53% slower&lt;/strong&gt;. Meaning the regular expressions are twice as fast for the lorem ipsum input I used.</source>
          <target state="translated">在我的Chrome Windows 8计算机上， &lt;strong&gt;基于正则表达式的实现是最快的&lt;/strong&gt; ，而&lt;strong&gt;split and join实现的速度要慢53％&lt;/strong&gt; 。 这意味着正则表达式的速度是我使用的lorem ipsum输入的两倍。</target>
        </trans-unit>
        <trans-unit id="4aeed3d41975990ec44e159a6fdeea976022e55f" translate="yes" xml:space="preserve">
          <source>Oops indeed, this probably isn't what you want. What is, then? IMHO, a regex that only replaces 'cat' conditionally. (ie not part of a word), like so:</source>
          <target state="translated">哎呀,这可能不是你想要的。那么,是什么呢?IMHO,一个仅有条件地替换 &quot;cat &quot;的regex。(即不是一个词的一部分),就像这样。</target>
        </trans-unit>
        <trans-unit id="5bffa97d2b31528d43e65d8a25a71624db09d635" translate="yes" xml:space="preserve">
          <source>Or try the replaceAll function from here:</source>
          <target state="translated">或者试试这里的replaceAll函数。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="958af61f062ee06d08e8952efd18380494a6a4d9" translate="yes" xml:space="preserve">
          <source>RangeError: Maximum call stack size exceeded</source>
          <target state="translated">RangeError:超过最大调用堆栈大小</target>
        </trans-unit>
        <trans-unit id="516ae82c40ff23ca1cf1e9b09339a27d789eeb76" translate="yes" xml:space="preserve">
          <source>Regular Expression Based Implementation</source>
          <target state="translated">基于常规表达式的实现</target>
        </trans-unit>
        <trans-unit id="1927e4338bf5ed5e34ce23c646604727fd370193" translate="yes" xml:space="preserve">
          <source>Replacing single quotes:</source>
          <target state="translated">取代单引号。</target>
        </trans-unit>
        <trans-unit id="8c27bd4109955934b131a097a08e8328d1b30751" translate="yes" xml:space="preserve">
          <source>Revised jsperf</source>
          <target state="translated">修订后的jsperf</target>
        </trans-unit>
        <trans-unit id="a3ae420dc94cd8628e9445b30f38b89f9b7e87c7" translate="yes" xml:space="preserve">
          <source>Say you want to replace all the 'abc' with 'x':</source>
          <target state="translated">说你想用 &quot;x &quot;代替所有的 &quot;abc&quot;。</target>
        </trans-unit>
        <trans-unit id="b3a0ed02924fa9756353d3b2962c9f868b0376eb" translate="yes" xml:space="preserve">
          <source>See here also</source>
          <target state="translated">另见此处</target>
        </trans-unit>
        <trans-unit id="238582b8899c43b60945a04bd423c0787fae81fc" translate="yes" xml:space="preserve">
          <source>Short string - 55 characters</source>
          <target state="translated">短字符串-55个字符</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">显示代码片段</target>
        </trans-unit>
        <trans-unit id="afc3390a44e6d9658b7dbfc2d9192fef4d5122cc" translate="yes" xml:space="preserve">
          <source>So in order to make the &lt;code&gt;replaceAll()&lt;/code&gt; function above safer, it could be modified to the following if you also include &lt;code&gt;escapeRegExp&lt;/code&gt;:</source>
          <target state="translated">因此，为了使上面的 &lt;code&gt;replaceAll()&lt;/code&gt; 函数更安全，如果还包含 &lt;code&gt;escapeRegExp&lt;/code&gt; ，可以将其修改为以下内容 ：</target>
        </trans-unit>
        <trans-unit id="791f26db7f076b3fe806fedb1dfdd01bdfaabb50" translate="yes" xml:space="preserve">
          <source>Solutions based on &lt;code&gt;split-join&lt;/code&gt; (&lt;strong&gt;A,B&lt;/strong&gt;) or &lt;code&gt;replace&lt;/code&gt; (&lt;strong&gt;C,D&lt;/strong&gt;) are fast</source>
          <target state="translated">基于 &lt;code&gt;split-join&lt;/code&gt; （ &lt;strong&gt;A，B&lt;/strong&gt; ）或 &lt;code&gt;replace&lt;/code&gt; （ &lt;strong&gt;C，D&lt;/strong&gt; ）的解决方案很快</target>
        </trans-unit>
        <trans-unit id="64a7df9d3528430f1d064d94dcd7ce12360a8b65" translate="yes" xml:space="preserve">
          <source>Solutions based on &lt;code&gt;while&lt;/code&gt; (&lt;strong&gt;E,F,G,H&lt;/strong&gt;) are slow - usually ~4 times slower for small strings and about ~3000 times (!) slower for long strings</source>
          <target state="translated">基于 &lt;code&gt;while&lt;/code&gt; （ &lt;strong&gt;E，F，G，H&lt;/strong&gt; ）的解决方案很慢-小字符串通常慢4倍，长字符串通常慢3000倍（！）</target>
        </trans-unit>
        <trans-unit id="c5f617985382ce2f6b1ad5a88716ff377cafb216" translate="yes" xml:space="preserve">
          <source>Split and Join (Functional) Implementation</source>
          <target state="translated">分割和加入(功能)实现</target>
        </trans-unit>
        <trans-unit id="3f262f9b42c014ce513b61f570042ee408a6ccbe" translate="yes" xml:space="preserve">
          <source>The 'replaceAll' method is added to String's prototype. This means it will be available for all string objects/literals.</source>
          <target state="translated">在String的原型中加入了'replaceAll'方法。这意味着,它将对所有的字符串对象的文体都可以使用。</target>
        </trans-unit>
        <trans-unit id="70a3c41c6145b1073780fd66e0a5961a9f9d085d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str.replace(/abc/g, '');&lt;/code&gt; (&lt;strong&gt;C&lt;/strong&gt;) is a good cross-browser fast solution for all strings.</source>
          <target state="translated">&lt;code&gt;str.replace(/abc/g, '');&lt;/code&gt; （ &lt;strong&gt;C&lt;/strong&gt; ）是一种适用于所有字符串的跨浏览器快速解决方案。</target>
        </trans-unit>
        <trans-unit id="6862722646db89bf527d4db5a4180543b94a8268" translate="yes" xml:space="preserve">
          <source>The general pattern is</source>
          <target state="translated">一般的模式是</target>
        </trans-unit>
        <trans-unit id="ad15bf1a90e5b964105fd6d24685320af721a361" translate="yes" xml:space="preserve">
          <source>The output is the same as the accepted answer, however, using the /cat/g expression on this string:</source>
          <target state="translated">但是,在这个字符串上使用catg表达式,输出与接受答案相同。</target>
        </trans-unit>
        <trans-unit id="500d5673e29a623bf205aac14d021c9e4584c6d7" translate="yes" xml:space="preserve">
          <source>The previous answers are way too complicated. Just use the replace function like this:</source>
          <target state="translated">前面的答案太复杂了。就用这样的替换功能就可以了。</target>
        </trans-unit>
        <trans-unit id="3edf210ac416af9397656481643d3200184bbd0a" translate="yes" xml:space="preserve">
          <source>The recurrence solutions (&lt;strong&gt;RA,RB&lt;/strong&gt;) are slow and do not work for long strings</source>
          <target state="translated">递归解决方案（ &lt;strong&gt;RA，RB&lt;/strong&gt; ）缓慢，不适用于长字符串</target>
        </trans-unit>
        <trans-unit id="50bd0e425afb39661b9eb4e9f39fd4b4493a5609" translate="yes" xml:space="preserve">
          <source>The recursive solutions &lt;strong&gt;RA&lt;/strong&gt; and &lt;strong&gt;RB&lt;/strong&gt; gives</source>
          <target state="translated">递归解&lt;strong&gt;RA&lt;/strong&gt;和&lt;strong&gt;RB&lt;/strong&gt;给出</target>
        </trans-unit>
        <trans-unit id="369989b3729604fa9987753462bbbf349899d07e" translate="yes" xml:space="preserve">
          <source>The simplest loop to solve this would be:</source>
          <target state="translated">要解决这个问题,最简单的循环是:。</target>
        </trans-unit>
        <trans-unit id="03772ccff926aef82feb6ee59ca395521b306264" translate="yes" xml:space="preserve">
          <source>The simplest way to this without using any regex is split and join like the code here:</source>
          <target state="translated">最简单的方法是像这里的代码一样,在不使用任何regex的情况下,拆分和加入。</target>
        </trans-unit>
        <trans-unit id="e03cd7383682fc6d72d2b9f15ccd635f4298117f" translate="yes" xml:space="preserve">
          <source>The tests were performed on Chrome 79.0, Safari 13.0.4 and Firefox 71.0 (64 bit). The tests &lt;code&gt;RA&lt;/code&gt; and &lt;code&gt;RB&lt;/code&gt; use recursion. Results</source>
          <target state="translated">测试是在Chrome 79.0，Safari 13.0.4和Firefox 71.0（64位）上进行的。 测试 &lt;code&gt;RA&lt;/code&gt; 和 &lt;code&gt;RB&lt;/code&gt; 使用递归。 结果</target>
        </trans-unit>
        <trans-unit id="a9311a98961911f95ad2bd5e24444545ee47566a" translate="yes" xml:space="preserve">
          <source>There is another jsperf with variants on my recursive replace that go even faster (&lt;a href=&quot;http://jsperf.com/replace-all-vs-split-join/12&quot;&gt;http://jsperf.com/replace-all-vs-split-join/12&lt;/a&gt;)!</source>
          <target state="translated">我的递归替换中还有另一个jsperf，它的变体运行得更快（ &lt;a href=&quot;http://jsperf.com/replace-all-vs-split-join/12&quot;&gt;http://jsperf.com/replace-all-vs-split-join/12&lt;/a&gt; ）！</target>
        </trans-unit>
        <trans-unit id="16225ef62710b40df18181fe23a2e790ba51aaf9" translate="yes" xml:space="preserve">
          <source>These are the most common and readable methods.</source>
          <target state="translated">这些都是最常见的、最易读的方法。</target>
        </trans-unit>
        <trans-unit id="df35a931ffe321873755cadd3104fa2c6ab5abc1" translate="yes" xml:space="preserve">
          <source>This can be particularly useful when looking for duplicate strings.</source>
          <target state="translated">这在寻找重复的字符串时特别有用。</target>
        </trans-unit>
        <trans-unit id="367dab6a1825fbf327c5342ee35812bde1eec73e" translate="yes" xml:space="preserve">
          <source>This is a simple regex that avoids replacing parts of words in most cases. However, a dash &lt;code&gt;-&lt;/code&gt; is still considered a word boundary. So conditionals can be used in this case to avoid replacing strings like &lt;code&gt;cool-cat&lt;/code&gt;:</source>
          <target state="translated">这是一个简单的正则表达式，在大多数情况下避免替换部分单词。 但是，连字符 &lt;code&gt;-&lt;/code&gt; 仍被视为单词边界。 因此在这种情况下可以使用条件语句来避免替换诸如 &lt;code&gt;cool-cat&lt;/code&gt; 之类的字符串：</target>
        </trans-unit>
        <trans-unit id="c02562e1f6d4a5cbf736a7b0837cb984e69786fd" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;fastest&lt;/strong&gt; version that &lt;em&gt;doesn't use regular expressions&lt;/em&gt;.</source>
          <target state="translated">这是&lt;em&gt;不使用正则表达式&lt;/em&gt;的&lt;strong&gt;最快&lt;/strong&gt;版本。</target>
        </trans-unit>
        <trans-unit id="ba6f081fdf243a403bac2ba3cf8f0fdee154766a" translate="yes" xml:space="preserve">
          <source>This used to be faster in some cases than using &lt;code&gt;replaceAll&lt;/code&gt; and a regular expression, but that doesn't seem to be the case anymore in modern browsers.</source>
          <target state="translated">在某些情况下，这过去比使用 &lt;code&gt;replaceAll&lt;/code&gt; 和正则表达式要快，但是在现代浏览器中，情况似乎不再如此。</target>
        </trans-unit>
        <trans-unit id="c06e71ba6500c4e97fef51f00b081079208d8af6" translate="yes" xml:space="preserve">
          <source>Today 27.12.2019 I perform tests on &lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; (High Sierra) for the chosen solutions.</source>
          <target state="translated">今天27.12.2019我将在&lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; （High Sierra）上针对所选解决方案执行测试。</target>
        </trans-unit>
        <trans-unit id="8f10ddde05bf54e0d639e76139d9d0182eb95a01" translate="yes" xml:space="preserve">
          <source>Update July 27th 2017: It looks like RegExp now has the fastest performance in the recently released Chrome 59.</source>
          <target state="translated">2017年7月27日更新。在最近发布的Chrome 59中,RegExp现在看起来性能最快。</target>
        </trans-unit>
        <trans-unit id="4bcac541a8c7f79ba50a38a8988ad2f783681ee0" translate="yes" xml:space="preserve">
          <source>Use a regular expression:</source>
          <target state="translated">使用正则表达式。</target>
        </trans-unit>
        <trans-unit id="c2aee7f5722611179e110f5e6d7da49f02ff7c59" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;RegExp&lt;/code&gt; in &lt;strong&gt;JavaScript&lt;/strong&gt; could do the job for you, just simply do something like below code, don't forget the &lt;code&gt;/g&lt;/code&gt; after which standout for &lt;strong&gt;global&lt;/strong&gt;:</source>
          <target state="translated">在&lt;strong&gt;JavaScript中&lt;/strong&gt;使用 &lt;code&gt;RegExp&lt;/code&gt; 可以为您完成这项工作，只需执行以下代码即可，不要忘记 &lt;code&gt;/g&lt;/code&gt; 之后的&lt;strong&gt;global&lt;/strong&gt;突出之处：</target>
        </trans-unit>
        <trans-unit id="9da6ee93a958af3f2a1cebcc0f2590371d8cb6b8" translate="yes" xml:space="preserve">
          <source>Using a regular expression with the &lt;code&gt;g&lt;/code&gt; flag set will replace all:</source>
          <target state="translated">使用设置了 &lt;code&gt;g&lt;/code&gt; 标志的正则表达式将替换所有：</target>
        </trans-unit>
        <trans-unit id="09b3286eff56349c39d102a1b366232dba4e9210" translate="yes" xml:space="preserve">
          <source>We could call &lt;code&gt;escapeRegExp&lt;/code&gt; within our &lt;code&gt;String.prototype.replaceAll&lt;/code&gt; implementation, however, I'm not sure how much this will affect the performance (potentially even for strings for which the escape is not needed, like all alphanumeric strings).</source>
          <target state="translated">我们可以在 &lt;code&gt;String.prototype.replaceAll&lt;/code&gt; 实现中调用 &lt;code&gt;escapeRegExp&lt;/code&gt; ，但是，我不确定这会对性能有多大的影响（甚至对于不需要转义的字符串（如所有字母数字字符串）也可能有影响）。</target>
        </trans-unit>
        <trans-unit id="00df80bf98961b338c936f71eb4491af5d4e6cd7" translate="yes" xml:space="preserve">
          <source>What are useful JavaScript methods that extends built-in objects?</source>
          <target state="translated">有哪些有用的JavaScript方法可以扩展内置对象?</target>
        </trans-unit>
        <trans-unit id="59826ff0dcdf2c8ff1dc7d8cb137e9a83b75e3ba" translate="yes" xml:space="preserve">
          <source>When complete, you will still have 'test abc'!</source>
          <target state="translated">完成后,你还会有'测试abc'!</target>
        </trans-unit>
        <trans-unit id="7413bc6dfd6712412a62d33b6ad98978fda494ef" translate="yes" xml:space="preserve">
          <source>You can refer the detailed example &lt;a href=&quot;http://www.cheezycode.com/2015/08/javascript-hacks-for-html-webpage.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">您可以在&lt;a href=&quot;http://www.cheezycode.com/2015/08/javascript-hacks-for-html-webpage.html&quot;&gt;此处&lt;/a&gt;参考详细示例。</target>
        </trans-unit>
        <trans-unit id="14612ebec52e07519f5df0000794a2c86ea5a2ed" translate="yes" xml:space="preserve">
          <source>You can run tests on your machine &lt;a href=&quot;https://jsperf.com/remove-substring-small/1&quot;&gt;HERE&lt;/a&gt;. Results for Chrome:</source>
          <target state="translated">您可以在&lt;a href=&quot;https://jsperf.com/remove-substring-small/1&quot;&gt;此处&lt;/a&gt;在计算机上运行测试。 Chrome的结果：</target>
        </trans-unit>
        <trans-unit id="d80d16d89e43a7516fb2dee5f412114891576996" translate="yes" xml:space="preserve">
          <source>You can simply use below method</source>
          <target state="translated">您只需使用以下方法即可</target>
        </trans-unit>
        <trans-unit id="28905875c9209baab59de2b80e072d7fc36fde6e" translate="yes" xml:space="preserve">
          <source>[In that case, one could do .replace(/,+/g,','), but at some point the regex gets complex and slow enough to loop instead.]</source>
          <target state="translated">[在这种情况下,可以做.replace(,+g,',',','),但在某些时候,regex会变得复杂,而且速度很慢,需要循环。]</target>
        </trans-unit>
        <trans-unit id="1aecada00183a6ff5ec2d92396d46a8c0ae9f7e9" translate="yes" xml:space="preserve">
          <source>and simply use it in your code over and over like below:</source>
          <target state="translated">并简单地在你的代码中反复使用它,就像下面这样。</target>
        </trans-unit>
        <trans-unit id="cc4acdb915a5e6e90d0ec0a00fa9a185d964911a" translate="yes" xml:space="preserve">
          <source>basically, this question is the same as the question here:
&lt;a href=&quot;https://stackoverflow.com/questions/9499075/javascript-replace-with/9499926&quot;&gt;Javascript replace &quot; ' &quot; with &quot; '' &quot;&lt;/a&gt;</source>
          <target state="translated">基本上，此问题与此处的问题相同： &lt;a href=&quot;https://stackoverflow.com/questions/9499075/javascript-replace-with/9499926&quot;&gt;Javascript将&amp;ldquo;'&amp;rdquo;替换为&amp;ldquo;&amp;rdquo;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0d24cf1b244ef65eac88d415645e906ecf67ee0" translate="yes" xml:space="preserve">
          <source>seems to only remove the first occurrence of &lt;code&gt;abc&lt;/code&gt; in the string above.</source>
          <target state="translated">似乎只删除上面字符串中的 &lt;code&gt;abc&lt;/code&gt; 第一次出现。</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="f57ca77c39afa4ad77c7b0cbdd76aaef04834b2b" translate="yes" xml:space="preserve">
          <source>worked better for me than the above answers. so &lt;code&gt;new RegExp(&quot;abc&quot;, 'g')&lt;/code&gt; creates a RegExp what matches all occurence (&lt;code&gt;'g'&lt;/code&gt; flag) of the text (&lt;code&gt;&quot;abc&quot;&lt;/code&gt;). The second part is what gets replaced to, in your case empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;).
&lt;code&gt;str&lt;/code&gt; is the string, and we have to override it, as &lt;code&gt;replace(...)&lt;/code&gt; just returns result, but not overrides. In some cases you might want to use that.</source>
          <target state="translated">对我来说比上述答案更好。 因此， &lt;code&gt;new RegExp(&quot;abc&quot;, 'g')&lt;/code&gt; 创建了一个RegExp，该RegExp与文本（ &lt;code&gt;&quot;abc&quot;&lt;/code&gt; ）的所有出现情况（ &lt;code&gt;'g'&lt;/code&gt; 标志）匹配。 第二部分是要替换的内容，在您的情况下为空字符串（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）。 &lt;code&gt;str&lt;/code&gt; 是字符串，我们必须覆盖它，因为 &lt;code&gt;replace(...)&lt;/code&gt; 仅返回结果，而不是覆盖。 在某些情况下，您可能想要使用它。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
