<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/1144783">
    <body>
      <group id="1144783">
        <trans-unit id="d9952330ff36e4f4aeca5f93ac713b20da31fa77" translate="yes" xml:space="preserve">
          <source>//loop it until number occurrences comes to 0. OR simply copy/paste</source>
          <target state="translated">/...hasta que el número de ocurrencias llegue a 0.O simplemente copiando...</target>
        </trans-unit>
        <trans-unit id="c8857126cc10f9914e5f38613f237895ee5c6b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/g&lt;/code&gt; means global</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; significa global</target>
        </trans-unit>
        <trans-unit id="bb5c0451b917db9a91e43681457634a56c6655aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Update:&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Update:&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="54d43c52441fb7bd3ed00affd5f9186806533d64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7e2cd0e1a6f716d8fe13350e59d99500575639f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; Clarification about replaceAll availability</source>
          <target state="translated">&lt;strong&gt;EDITAR:&lt;/strong&gt; Aclaraci&amp;oacute;n sobre reemplazar Toda la disponibilidad</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f29304ea9cd1982b93d7af334cf0f88bae973ea7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Final addition:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Adici&amp;oacute;n final:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d371a375635dead23e71c6018c06fc0b2d6bcf0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todo 1:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39ba8b2d14f80c96148df898ae74111bfba336f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todo 2:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72d457e583e8bca3f439a3a897e489de0b498c03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todo 3:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="529383dcc2e9606a5bb75847be52ba72603eb93a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todo 4:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0737a49188ce80e8c141eb30d15abad1f570e32c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: Don't use this in performance critical code.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Nota: No use esto en el c&amp;oacute;digo cr&amp;iacute;tico de rendimiento.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56781c4490d4641a69cef533a9621281a430d169" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In general, extending the built-in prototypes in JavaScript is generally not recommended. I am providing as extensions on the String prototype simply for purposes of illustration, showing different implementations of a hypothetical standard method on the &lt;code&gt;String&lt;/code&gt; built-in prototype.</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; en general, no se recomienda extender los prototipos incorporados en JavaScript. Proporciono como extensiones en el prototipo de String simplemente con fines ilustrativos, mostrando diferentes implementaciones de un m&amp;eacute;todo est&amp;aacute;ndar hipot&amp;eacute;tico en el prototipo incorporado de &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9ca3f2973d0dabdd79539f415055d2ed5b22768" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Regular expressions contain special (meta) characters, and as such it is dangerous to blindly pass an argument in the &lt;code&gt;find&lt;/code&gt; function above without pre-processing it to escape those characters.  This is covered in the &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;Mozilla Developer Network&lt;/a&gt;'s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping&quot;&gt;JavaScript Guide on Regular Expressions&lt;/a&gt;, where they present the following utility function (which has changed at least twice since this answer was originally written, so make sure to check the MDN site for potential updates):</source>
          <target state="translated">&lt;strong&gt;Nota:&lt;/strong&gt; Las expresiones regulares contienen caracteres especiales (meta) y, como tal, es peligroso pasar ciegamente un argumento en la funci&amp;oacute;n de &lt;code&gt;find&lt;/code&gt; anterior sin procesarlo previamente para escapar de esos caracteres. Esto est&amp;aacute; cubierto en la &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping&quot;&gt;Gu&amp;iacute;a de JavaScript de la&lt;/a&gt; &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;Red de desarrolladores de Mozilla&lt;/a&gt; sobre expresiones regulares , donde presentan la siguiente funci&amp;oacute;n de utilidad (que ha cambiado al menos dos veces desde que esta respuesta se escribi&amp;oacute; originalmente, as&amp;iacute; que aseg&amp;uacute;rese de consultar el sitio de MDN para posibles actualizaciones):</target>
        </trans-unit>
        <trans-unit id="4cdcd3fdc8587add9d1885342dfb4ded08633670" translate="yes" xml:space="preserve">
          <source>@Mike, check the answer I gave there... regexp isn't the only way to replace multiple occurrences of a subsrting, far from it. Think flexible, think split!</source>
          <target state="translated">@Mike,comprueba la respuesta que di allí...regexp no es la única forma de reemplazar las múltiples ocurrencias de una substracción,ni mucho menos.¡Piensa en flexible,piensa en split!</target>
        </trans-unit>
        <trans-unit id="9f7ff750c8d42bac2d5bf7ded2777806c7bbd646" translate="yes" xml:space="preserve">
          <source>Alternatively, to prevent replacing word parts -which the approved answer will do, too! You can get around this issue using regular expressions that are, I admit, somewhat more complex and as an upshot of that, a tad slower, too:</source>
          <target state="translated">Alternativamente,para evitar la sustitución de partes de la palabra,lo que la respuesta aprobada hará,también! Puedes evitar este problema usando expresiones regulares que son,lo admito,algo más complejas y como resultado,un poco más lentas también:</target>
        </trans-unit>
        <trans-unit id="9abf1f2f157ce45f651d436bf184af77b8adeb5e" translate="yes" xml:space="preserve">
          <source>Although people have mentioned the use of regex but there's a better approach if you want to replace the text irrespective of the case of the text. Like uppercase or lowercase. Use below syntax</source>
          <target state="translated">Aunque la gente ha mencionado el uso de regex pero hay un mejor enfoque si se quiere reemplazar el texto independientemente del caso del texto.Como las mayúsculas o las minúsculas.El uso debajo de la sintaxis</target>
        </trans-unit>
        <trans-unit id="d9e6101a86eec306979f963e9857be885e7245e2" translate="yes" xml:space="preserve">
          <source>As an alternative to regular expressions for a simple literal string, you could use</source>
          <target state="translated">Como alternativa a las expresiones regulares para una simple cadena literal,podrías usar</target>
        </trans-unit>
        <trans-unit id="c152952996b6a5c283c92260257eb9c156c7669e" translate="yes" xml:space="preserve">
          <source>As noted in the comment below by @ThomasLeduc and others, there could be an issue with the regular expression-based implementation if &lt;code&gt;search&lt;/code&gt; contains certain characters which are reserved as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;special characters in regular expressions&lt;/a&gt;. The implementation assumes that the caller will escape the string beforehand or will only pass strings that are without the characters in the table in &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;Regular Expressions&lt;/a&gt;&lt;/em&gt; (MDN).</source>
          <target state="translated">Como se se&amp;ntilde;al&amp;oacute; en el comentario a continuaci&amp;oacute;n de @ThomasLeduc y otros, podr&amp;iacute;a haber un problema con la implementaci&amp;oacute;n basada en expresiones regulares si la &lt;code&gt;search&lt;/code&gt; contiene ciertos caracteres que est&amp;aacute;n reservados como &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;caracteres especiales en expresiones regulares&lt;/a&gt; . La implementaci&amp;oacute;n asume que la persona que llama escapar&amp;aacute; de la cadena de antemano o solo pasar&amp;aacute; cadenas que no tengan los caracteres en la tabla en &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;Expresiones regulares&lt;/a&gt;&lt;/em&gt; (MDN).</target>
        </trans-unit>
        <trans-unit id="63b3d8e8f8a79cd8ec7c3c5683b3642dffed71ed" translate="yes" xml:space="preserve">
          <source>As pointed out in a comment here, this will not work if your &lt;code&gt;omit&lt;/code&gt; variable contains &lt;code&gt;place&lt;/code&gt;, as in: &lt;code&gt;replaceAll(&quot;string&quot;, &quot;s&quot;, &quot;ss&quot;)&lt;/code&gt;, because it will always be able to replace another occurrence of the word.</source>
          <target state="translated">Como se se&amp;ntilde;al&amp;oacute; en un comentario aqu&amp;iacute;, esto no funcionar&amp;aacute; si su variable &lt;code&gt;omit&lt;/code&gt; ir contiene &lt;code&gt;place&lt;/code&gt; , como en: &lt;code&gt;replaceAll(&quot;string&quot;, &quot;s&quot;, &quot;ss&quot;)&lt;/code&gt; , porque siempre podr&amp;aacute; reemplazar otra aparici&amp;oacute;n de la palabra .</target>
        </trans-unit>
        <trans-unit id="2efdbb9e7d89d63a3865b145be18d2985735f425" translate="yes" xml:space="preserve">
          <source>Benchmark: &lt;a href=&quot;https://jsperf.com/replace-all-vs-split-join&quot;&gt;https://jsperf.com/replace-all-vs-split-join&lt;/a&gt;</source>
          <target state="translated">Punto de referencia: &lt;a href=&quot;https://jsperf.com/replace-all-vs-split-join&quot;&gt;https://jsperf.com/replace-all-vs-split-join&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f018edf766c43f923af62d936f6faa226aba148" translate="yes" xml:space="preserve">
          <source>But as I mention earlier, it won't make a huge difference in terms of lines to be written or performance, only caching the function may effect some faster performance on long strings and also a good practice of DRY code if you want to reuse.</source>
          <target state="translated">Pero como mencioné antes,no hará una gran diferencia en términos de líneas a escribir o de rendimiento,sólo el almacenamiento en caché de la función puede afectar a un rendimiento más rápido en las cuerdas largas y también una buena práctica del código DRY si quieres reutilizarlo.</target>
        </trans-unit>
        <trans-unit id="d0e0c00e52a63b53922a63942eb8ba57f073ff62" translate="yes" xml:space="preserve">
          <source>But that runs the replacement twice for each cycle. Perhaps (at risk of being voted down) that can be combined for a slightly more efficient but less readable form:</source>
          <target state="translated">Pero eso hace que el reemplazo se haga dos veces por cada ciclo.Tal vez (a riesgo de ser rechazado)que puede ser combinado para una forma ligeramente más eficiente pero menos legible:</target>
        </trans-unit>
        <trans-unit id="4781d0025fe7cca970eabbf656f7ad7b779e25ea" translate="yes" xml:space="preserve">
          <source>Check out this &lt;a href=&quot;http://jsben.ch/#/LFfWA&quot;&gt;&lt;strong&gt;benchmark&lt;/strong&gt;&lt;/a&gt; running these two implementations against each other.</source>
          <target state="translated">Echa un vistazo a este &lt;a href=&quot;http://jsben.ch/#/LFfWA&quot;&gt;&lt;strong&gt;punto de referencia que&lt;/strong&gt;&lt;/a&gt; ejecuta estas dos implementaciones entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="c33ec0466fe646cd010b474e907704e44e7c4bfa" translate="yes" xml:space="preserve">
          <source>Code used in tests</source>
          <target state="translated">Código utilizado en las pruebas</target>
        </trans-unit>
        <trans-unit id="dfa777c69364feec4e5703f84e2ca7d360aff891" translate="yes" xml:space="preserve">
          <source>Conclusion: If you have a performance critical use case (e.g processing hundreds of strings), use the Regexp method. But for most typical use cases, this is well worth not having to worry about special characters.</source>
          <target state="translated">Conclusión:Si tiene un caso de uso crítico de rendimiento (por ejemplo,el procesamiento de cientos de cadenas),utilice el método Regexp.Pero para la mayoría de los casos de uso típicos,vale la pena no tener que preocuparse por los caracteres especiales.</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="ade2304f2a0ac295b0c79d7fe9ea6df6dc08d89f" translate="yes" xml:space="preserve">
          <source>Doing:</source>
          <target state="translated">Doing:</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="dade7a599b73d04a874d2b0f676893876a891d64" translate="yes" xml:space="preserve">
          <source>Fiddle: &lt;a href=&quot;http://jsfiddle.net/cdbzL/&quot;&gt;http://jsfiddle.net/cdbzL/&lt;/a&gt;</source>
          <target state="translated">Viol&amp;iacute;n: &lt;a href=&quot;http://jsfiddle.net/cdbzL/&quot;&gt;http://jsfiddle.net/cdbzL/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be49c2939db3ee7e866d3291921abff640df9c2e" translate="yes" xml:space="preserve">
          <source>For 1M characters they even break Chrome</source>
          <target state="translated">Para los personajes de 1M incluso rompen el cromo</target>
        </trans-unit>
        <trans-unit id="b8c42f762938f25c778634ec4aa570773188eb6e" translate="yes" xml:space="preserve">
          <source>For example, if we have 'a,,,b' and we wish to remove all duplicate commas.</source>
          <target state="translated">Por ejemplo,si tenemos 'a,,,b' y queremos eliminar todas las comas duplicadas.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="11e735017335bc0a521dcf44d5eed735e118f9c6" translate="yes" xml:space="preserve">
          <source>For replacing a single time use:</source>
          <target state="translated">Para reemplazar un uso de una sola vez:</target>
        </trans-unit>
        <trans-unit id="149bb522c45db99a08d6a7b4983aa120a2224b39" translate="yes" xml:space="preserve">
          <source>For replacing multiple times use:</source>
          <target state="translated">Para reemplazar el uso de múltiples veces:</target>
        </trans-unit>
        <trans-unit id="36e472462a8bc791f2ba2aeae075e82051d294fc" translate="yes" xml:space="preserve">
          <source>For the sake of completeness, I got to thinking about which method I should use to do this. There are basically two ways to do this as suggested by the other answers on this page.</source>
          <target state="translated">Para completar,me puse a pensar en qué método debería usar para hacerlo.Hay básicamente dos maneras de hacer esto como sugieren las otras respuestas de esta página.</target>
        </trans-unit>
        <trans-unit id="c3edbcc75bd7b794628267175a04820e53edbdd3" translate="yes" xml:space="preserve">
          <source>Given that this question still gets a lot of views, I thought I might add an example of &lt;code&gt;.replace&lt;/code&gt; used with a callback function. In this case, it dramatically simplifies the expression &lt;em&gt;and&lt;/em&gt; provides even more flexibility, like replacing with correct capitalisation or replacing both &lt;code&gt;cat&lt;/code&gt; and &lt;code&gt;cats&lt;/code&gt; in one go:</source>
          <target state="translated">Dado que esta pregunta a&amp;uacute;n tiene muchas vistas, pens&amp;eacute; que podr&amp;iacute;a agregar un ejemplo de &lt;code&gt;.replace&lt;/code&gt; utilizado con una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada. En este caso, simplifica dr&amp;aacute;sticamente la expresi&amp;oacute;n &lt;em&gt;y&lt;/em&gt; proporciona a&amp;uacute;n m&amp;aacute;s flexibilidad, como reemplazar con may&amp;uacute;sculas correctas o reemplazar tanto &lt;code&gt;cat&lt;/code&gt; como &lt;code&gt;cats&lt;/code&gt; de una vez:</target>
        </trans-unit>
        <trans-unit id="b7e3e4b0658ce61581539adf4188d7ebffea28ab" translate="yes" xml:space="preserve">
          <source>Here's a string prototype function based on the accepted answer:</source>
          <target state="translated">Aquí hay un prototipo de función de cadena basado en la respuesta aceptada:</target>
        </trans-unit>
        <trans-unit id="24794182023bcc1030d2a1378b77bbf20705a2df" translate="yes" xml:space="preserve">
          <source>How can I replace &lt;strong&gt;all&lt;/strong&gt; occurrences of it?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo puedo reemplazar &lt;strong&gt;todas las&lt;/strong&gt; ocurrencias?</target>
        </trans-unit>
        <trans-unit id="617a8962b7e2e0f4b9d1343195a5c0af913dde36" translate="yes" xml:space="preserve">
          <source>How to replace all occurrences of a string</source>
          <target state="translated">Cómo reemplazar todas las ocurrencias de una cadena</target>
        </trans-unit>
        <trans-unit id="271eda4d77d19f0c8b1efeb10240701ebf85921b" translate="yes" xml:space="preserve">
          <source>I also create my own solution. It looks like currently it is the shortest one which does the question job:</source>
          <target state="translated">También creo mi propia solución.Parece que actualmente es la más corta la que hace el trabajo de la pregunta:</target>
        </trans-unit>
        <trans-unit id="27385f76de96154d8b2e18f8f81576c4eed4be96" translate="yes" xml:space="preserve">
          <source>I have this string:</source>
          <target state="translated">Tengo esta cuerda:</target>
        </trans-unit>
        <trans-unit id="92d7e77cec099283fa1ca888be9c7bb01adb1197" translate="yes" xml:space="preserve">
          <source>I like this method (it looks a little cleaner):</source>
          <target state="translated">Me gusta este método (se ve un poco más limpio):</target>
        </trans-unit>
        <trans-unit id="0d74abf0b650c9679eebf5f617351ed153d36de9" translate="yes" xml:space="preserve">
          <source>I try to perform tests for 1M characters for other solutions, but &lt;strong&gt;E,F,G,H&lt;/strong&gt; takes so much time that browser ask me to break script so I shrink test string to 275K characters. You can run tests on your machine &lt;a href=&quot;https://jsperf.com/remove-substring-big/1&quot;&gt;HERE&lt;/a&gt;. Results for Chrome</source>
          <target state="translated">Intento realizar pruebas para 1M caracteres para otras soluciones, pero &lt;strong&gt;E, F, G, H&lt;/strong&gt; toma tanto tiempo que el navegador me pide que rompa el script para reducir la cadena de prueba a 275K caracteres. Puede ejecutar pruebas en su m&amp;aacute;quina &lt;a href=&quot;https://jsperf.com/remove-substring-big/1&quot;&gt;AQU&amp;Iacute;&lt;/a&gt; . Resultados para Chrome</target>
        </trans-unit>
        <trans-unit id="571150b46c01207484df0493bc72e22e092ba6fb" translate="yes" xml:space="preserve">
          <source>I was trying to think about something more simple than modifying the string prototype.</source>
          <target state="translated">Intentaba pensar en algo más simple que modificar el prototipo de la cuerda.</target>
        </trans-unit>
        <trans-unit id="f6f84f4228ff1dc85882fa840346aac31c421b25" translate="yes" xml:space="preserve">
          <source>If the string contain similar pattern like &lt;code&gt;abccc&lt;/code&gt;, you can use this:</source>
          <target state="translated">Si la cadena contiene un patr&amp;oacute;n similar como &lt;code&gt;abccc&lt;/code&gt; , puede usar esto:</target>
        </trans-unit>
        <trans-unit id="8889bb9f75193ae0d9d2462502aa8b541a30bf48" translate="yes" xml:space="preserve">
          <source>If what you want to find is already in a string, and you don't have a regex escaper handy, you can use join/split:</source>
          <target state="translated">Si lo que quieres encontrar ya está en una cadena,y no tienes un escape regex a mano,puedes usar el joinsplit:</target>
        </trans-unit>
        <trans-unit id="6426ffa6019405a00629f74abdadd40f6f1fa52f" translate="yes" xml:space="preserve">
          <source>If you are trying to ensure that the string you are looking for won't exist even after the replacement, you need to use a loop.</source>
          <target state="translated">Si estás intentando asegurarte de que la cuerda que buscas no existirá incluso después de la sustitución,necesitas usar un bucle.</target>
        </trans-unit>
        <trans-unit id="8017ab8bc71676e6882e731d96181ecc21dfc1db" translate="yes" xml:space="preserve">
          <source>If you think of reuse, create a function to do that for you, but it's not recommended as it's only one line function, but again if you heavily use this, you can write something like this:</source>
          <target state="translated">Si piensas en la reutilización,crea una función que lo haga por ti,pero no es recomendable ya que es una función de una sola línea,pero de nuevo si usas mucho esto,puedes escribir algo como esto:</target>
        </trans-unit>
        <trans-unit id="6a4b3b967221be750b157c4ee9fe1f50d77f67db" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;find&lt;/code&gt; will contain special characters then you need to escape them:</source>
          <target state="translated">Si su &lt;code&gt;find&lt;/code&gt; contendr&amp;aacute; caracteres especiales, entonces necesita escapar de ellos:</target>
        </trans-unit>
        <trans-unit id="079c54dc97655e15c06ad5c00768b648932e30cd" translate="yes" xml:space="preserve">
          <source>In response to &lt;a href=&quot;https://stackoverflow.com/users/49153/click-upvote&quot;&gt;Click Upvote&lt;/a&gt;'s comment, you could simplify it even more:</source>
          <target state="translated">En respuesta al comentario de &lt;a href=&quot;https://stackoverflow.com/users/49153/click-upvote&quot;&gt;Click Upvote&lt;/a&gt; , podr&amp;iacute;a simplificarlo a&amp;uacute;n m&amp;aacute;s:</target>
        </trans-unit>
        <trans-unit id="191216a7395aed5161e4fcfb09478317c8e872a8" translate="yes" xml:space="preserve">
          <source>In response to comment:</source>
          <target state="translated">En respuesta a los comentarios:</target>
        </trans-unit>
        <trans-unit id="dbf9ba5ca6006381bcdff40469061e3b7616e9c3" translate="yes" xml:space="preserve">
          <source>It is almost &lt;strong&gt;twice&lt;/strong&gt; as fast as the split and join method.</source>
          <target state="translated">Es casi el &lt;strong&gt;doble de&lt;/strong&gt; r&amp;aacute;pido que el m&amp;eacute;todo de divisi&amp;oacute;n y uni&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ee38f424d22647b54ca91efb42b2feb4dc705df1" translate="yes" xml:space="preserve">
          <source>It's somewhat late for an update, but since I just stumbled on this question, and noticed that my previous answer is not one I'm happy with. Since the question involved replaceing a single word, it's incredible nobody thought of using word boundaries (&lt;code&gt;\b&lt;/code&gt;)</source>
          <target state="translated">Es algo tarde para una actualizaci&amp;oacute;n, pero dado que me top&amp;eacute; con esta pregunta y not&amp;eacute; que mi respuesta anterior no es una con la que estoy contento. Dado que la pregunta implicaba reemplazar una sola palabra, es incre&amp;iacute;ble que nadie haya pensado en usar l&amp;iacute;mites de palabras ( &lt;code&gt;\b&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e330ec23e20bc0e91f1bf5db33cb4dd1a0e02bd4" translate="yes" xml:space="preserve">
          <source>Just add &lt;code&gt;/g&lt;/code&gt;</source>
          <target state="translated">Solo agrega &lt;code&gt;/g&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80e8772aa17b25f69c6e07312344c7020cbbfee3" translate="yes" xml:space="preserve">
          <source>Long string: 275 000 characters</source>
          <target state="translated">Larga cadena:275 000 caracteres</target>
        </trans-unit>
        <trans-unit id="2120bdbb22d21b0fe7265d9572081b7ed870ae9f" translate="yes" xml:space="preserve">
          <source>MDN also provides an implementation to escape our strings. It would be nice if this was also standardized as &lt;code&gt;RegExp.escape(str)&lt;/code&gt;, but alas, it does not exist:</source>
          <target state="translated">MDN tambi&amp;eacute;n proporciona una implementaci&amp;oacute;n para escapar de nuestras cadenas. Ser&amp;iacute;a bueno si esto tambi&amp;eacute;n fuera estandarizado como &lt;code&gt;RegExp.escape(str)&lt;/code&gt; , pero, por desgracia, no existe:</target>
        </trans-unit>
        <trans-unit id="0225f5723fc9201da4e25ebcb7e68c6bad705b25" translate="yes" xml:space="preserve">
          <source>Match against a global regular expression:</source>
          <target state="translated">Coincide con una expresión regular global:</target>
        </trans-unit>
        <trans-unit id="f76120c1db181b1c8e257b4637f8e39a2280009d" translate="yes" xml:space="preserve">
          <source>My guess is, this meets your needs. It's not fullproof, of course, but it should be enough to get you started. I'd recommend reading some more on these pages. This'll prove useful in perfecting this expression to meet your specific needs.</source>
          <target state="translated">Supongo que esto satisface sus necesidades.No es a prueba de fallos,por supuesto,pero debería ser suficiente para empezar.Le recomendaría leer un poco más en estas páginas.Esto será útil para perfeccionar esta expresión para satisfacer sus necesidades específicas.</target>
        </trans-unit>
        <trans-unit id="b8897d8922350c71545273bfce790fe7e2f72ff0" translate="yes" xml:space="preserve">
          <source>Not knowing too much about how regular expressions work behind the scenes in terms of efficiency, I tended to lean toward the split and join implementation in the past without thinking about performance. When I did wonder which was more efficient, and by what margin, I used it as an excuse to find out.</source>
          <target state="translated">Sin saber demasiado sobre cómo funcionan las expresiones regulares entre bastidores en términos de eficiencia,tendí a inclinarme hacia la división y a unirme a la implementación en el pasado sin pensar en la actuación.Cuando me preguntaba qué era más eficiente,y por qué margen,lo usaba como excusa para averiguarlo.</target>
        </trans-unit>
        <trans-unit id="139a05bf0f987bf64fbec5424cb7d5ebc55496a5" translate="yes" xml:space="preserve">
          <source>On my Chrome Windows&amp;nbsp;8 machine, &lt;strong&gt;the regular expression based implementation is the fastest&lt;/strong&gt;, with the &lt;strong&gt;split and join implementation being 53% slower&lt;/strong&gt;. Meaning the regular expressions are twice as fast for the lorem ipsum input I used.</source>
          <target state="translated">En mi m&amp;aacute;quina Chrome con Windows 8, &lt;strong&gt;la implementaci&amp;oacute;n basada en expresiones regulares es la m&amp;aacute;s r&amp;aacute;pida&lt;/strong&gt; , con &lt;strong&gt;una implementaci&amp;oacute;n de divisi&amp;oacute;n y uni&amp;oacute;n un 53% m&amp;aacute;s lenta&lt;/strong&gt; . Lo que significa que las expresiones regulares son dos veces m&amp;aacute;s r&amp;aacute;pidas para la entrada lorem ipsum que utilic&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="4aeed3d41975990ec44e159a6fdeea976022e55f" translate="yes" xml:space="preserve">
          <source>Oops indeed, this probably isn't what you want. What is, then? IMHO, a regex that only replaces 'cat' conditionally. (ie not part of a word), like so:</source>
          <target state="translated">Ups,de hecho,probablemente no es lo que quieres.¿Qué es,entonces? IMHO,un regex que sólo reemplaza a &quot;gato&quot; condicionalmente.(es decir,no es parte de una palabra),así:</target>
        </trans-unit>
        <trans-unit id="5bffa97d2b31528d43e65d8a25a71624db09d635" translate="yes" xml:space="preserve">
          <source>Or try the replaceAll function from here:</source>
          <target state="translated">O intente la función de reemplazar todo desde aquí:</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="958af61f062ee06d08e8952efd18380494a6a4d9" translate="yes" xml:space="preserve">
          <source>RangeError: Maximum call stack size exceeded</source>
          <target state="translated">RangeError:Tamaño máximo de la pila de llamadas excedido</target>
        </trans-unit>
        <trans-unit id="516ae82c40ff23ca1cf1e9b09339a27d789eeb76" translate="yes" xml:space="preserve">
          <source>Regular Expression Based Implementation</source>
          <target state="translated">Aplicación basada en la expresión regular</target>
        </trans-unit>
        <trans-unit id="1927e4338bf5ed5e34ce23c646604727fd370193" translate="yes" xml:space="preserve">
          <source>Replacing single quotes:</source>
          <target state="translated">Reemplazando las citas simples:</target>
        </trans-unit>
        <trans-unit id="8c27bd4109955934b131a097a08e8328d1b30751" translate="yes" xml:space="preserve">
          <source>Revised jsperf</source>
          <target state="translated">Revisado jsperf</target>
        </trans-unit>
        <trans-unit id="a3ae420dc94cd8628e9445b30f38b89f9b7e87c7" translate="yes" xml:space="preserve">
          <source>Say you want to replace all the 'abc' with 'x':</source>
          <target state="translated">Digamos que quieres reemplazar toda la &quot;abc&quot; por la &quot;x&quot;:</target>
        </trans-unit>
        <trans-unit id="b3a0ed02924fa9756353d3b2962c9f868b0376eb" translate="yes" xml:space="preserve">
          <source>See here also</source>
          <target state="translated">Vea aquí también</target>
        </trans-unit>
        <trans-unit id="238582b8899c43b60945a04bd423c0787fae81fc" translate="yes" xml:space="preserve">
          <source>Short string - 55 characters</source>
          <target state="translated">Cadena corta-55 caracteres</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">Mostrar fragmento de código</target>
        </trans-unit>
        <trans-unit id="afc3390a44e6d9658b7dbfc2d9192fef4d5122cc" translate="yes" xml:space="preserve">
          <source>So in order to make the &lt;code&gt;replaceAll()&lt;/code&gt; function above safer, it could be modified to the following if you also include &lt;code&gt;escapeRegExp&lt;/code&gt;:</source>
          <target state="translated">Entonces, para que la funci&amp;oacute;n &lt;code&gt;replaceAll()&lt;/code&gt; anterior sea m&amp;aacute;s segura, podr&amp;iacute;a modificarse a lo siguiente si tambi&amp;eacute;n incluye &lt;code&gt;escapeRegExp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="791f26db7f076b3fe806fedb1dfdd01bdfaabb50" translate="yes" xml:space="preserve">
          <source>Solutions based on &lt;code&gt;split-join&lt;/code&gt; (&lt;strong&gt;A,B&lt;/strong&gt;) or &lt;code&gt;replace&lt;/code&gt; (&lt;strong&gt;C,D&lt;/strong&gt;) are fast</source>
          <target state="translated">Las soluciones basadas en &lt;code&gt;split-join&lt;/code&gt; ( &lt;strong&gt;A, B&lt;/strong&gt; ) o &lt;code&gt;replace&lt;/code&gt; ( &lt;strong&gt;C, D&lt;/strong&gt; ) son r&amp;aacute;pidas</target>
        </trans-unit>
        <trans-unit id="64a7df9d3528430f1d064d94dcd7ce12360a8b65" translate="yes" xml:space="preserve">
          <source>Solutions based on &lt;code&gt;while&lt;/code&gt; (&lt;strong&gt;E,F,G,H&lt;/strong&gt;) are slow - usually ~4 times slower for small strings and about ~3000 times (!) slower for long strings</source>
          <target state="translated">Las soluciones basadas en &lt;code&gt;while&lt;/code&gt; ( &lt;strong&gt;E, F, G, H&lt;/strong&gt; ) son lentas, generalmente ~ 4 veces m&amp;aacute;s lento para cadenas peque&amp;ntilde;as y aproximadamente ~ 3000 veces (!) M&amp;aacute;s lento para cadenas largas</target>
        </trans-unit>
        <trans-unit id="c5f617985382ce2f6b1ad5a88716ff377cafb216" translate="yes" xml:space="preserve">
          <source>Split and Join (Functional) Implementation</source>
          <target state="translated">Implementación de Split and Join (Funcional)</target>
        </trans-unit>
        <trans-unit id="3f262f9b42c014ce513b61f570042ee408a6ccbe" translate="yes" xml:space="preserve">
          <source>The 'replaceAll' method is added to String's prototype. This means it will be available for all string objects/literals.</source>
          <target state="translated">El método &quot;reemplazar todo&quot; se añade al prototipo de String.Esto significa que estará disponible para todos los objetos literarios de la cadena.</target>
        </trans-unit>
        <trans-unit id="70a3c41c6145b1073780fd66e0a5961a9f9d085d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str.replace(/abc/g, '');&lt;/code&gt; (&lt;strong&gt;C&lt;/strong&gt;) is a good cross-browser fast solution for all strings.</source>
          <target state="translated">El &lt;code&gt;str.replace(/abc/g, '');&lt;/code&gt; ( &lt;strong&gt;C&lt;/strong&gt; ) es una buena soluci&amp;oacute;n r&amp;aacute;pida entre navegadores para todas las cadenas.</target>
        </trans-unit>
        <trans-unit id="6862722646db89bf527d4db5a4180543b94a8268" translate="yes" xml:space="preserve">
          <source>The general pattern is</source>
          <target state="translated">El patrón general es</target>
        </trans-unit>
        <trans-unit id="ad15bf1a90e5b964105fd6d24685320af721a361" translate="yes" xml:space="preserve">
          <source>The output is the same as the accepted answer, however, using the /cat/g expression on this string:</source>
          <target state="translated">La salida es la misma que la respuesta aceptada,sin embargo,usando la expresión catg en esta cadena:</target>
        </trans-unit>
        <trans-unit id="500d5673e29a623bf205aac14d021c9e4584c6d7" translate="yes" xml:space="preserve">
          <source>The previous answers are way too complicated. Just use the replace function like this:</source>
          <target state="translated">Las respuestas anteriores son demasiado complicadas.Sólo usa la función de reemplazo de esta manera:</target>
        </trans-unit>
        <trans-unit id="3edf210ac416af9397656481643d3200184bbd0a" translate="yes" xml:space="preserve">
          <source>The recurrence solutions (&lt;strong&gt;RA,RB&lt;/strong&gt;) are slow and do not work for long strings</source>
          <target state="translated">Las soluciones de recurrencia ( &lt;strong&gt;RA, RB&lt;/strong&gt; ) son lentas y no funcionan para cadenas largas</target>
        </trans-unit>
        <trans-unit id="50bd0e425afb39661b9eb4e9f39fd4b4493a5609" translate="yes" xml:space="preserve">
          <source>The recursive solutions &lt;strong&gt;RA&lt;/strong&gt; and &lt;strong&gt;RB&lt;/strong&gt; gives</source>
          <target state="translated">Las soluciones recursivas &lt;strong&gt;RA&lt;/strong&gt; y &lt;strong&gt;RB&lt;/strong&gt; dan</target>
        </trans-unit>
        <trans-unit id="369989b3729604fa9987753462bbbf349899d07e" translate="yes" xml:space="preserve">
          <source>The simplest loop to solve this would be:</source>
          <target state="translated">El bucle más simple para resolver esto sería:</target>
        </trans-unit>
        <trans-unit id="03772ccff926aef82feb6ee59ca395521b306264" translate="yes" xml:space="preserve">
          <source>The simplest way to this without using any regex is split and join like the code here:</source>
          <target state="translated">La forma más simple de hacer esto sin usar ningún regex es dividir y unir como el código de aquí:</target>
        </trans-unit>
        <trans-unit id="e03cd7383682fc6d72d2b9f15ccd635f4298117f" translate="yes" xml:space="preserve">
          <source>The tests were performed on Chrome 79.0, Safari 13.0.4 and Firefox 71.0 (64 bit). The tests &lt;code&gt;RA&lt;/code&gt; and &lt;code&gt;RB&lt;/code&gt; use recursion. Results</source>
          <target state="translated">Las pruebas se realizaron en Chrome 79.0, Safari 13.0.4 y Firefox 71.0 (64 bits). Las pruebas &lt;code&gt;RA&lt;/code&gt; y &lt;code&gt;RB&lt;/code&gt; usan recursividad. Resultados</target>
        </trans-unit>
        <trans-unit id="a9311a98961911f95ad2bd5e24444545ee47566a" translate="yes" xml:space="preserve">
          <source>There is another jsperf with variants on my recursive replace that go even faster (&lt;a href=&quot;http://jsperf.com/replace-all-vs-split-join/12&quot;&gt;http://jsperf.com/replace-all-vs-split-join/12&lt;/a&gt;)!</source>
          <target state="translated">&amp;iexcl;Hay otro jsperf con variantes en mi reemplazo recursivo que va a&amp;uacute;n m&amp;aacute;s r&amp;aacute;pido ( &lt;a href=&quot;http://jsperf.com/replace-all-vs-split-join/12&quot;&gt;http://jsperf.com/replace-all-vs-split-join/12&lt;/a&gt; )!</target>
        </trans-unit>
        <trans-unit id="16225ef62710b40df18181fe23a2e790ba51aaf9" translate="yes" xml:space="preserve">
          <source>These are the most common and readable methods.</source>
          <target state="translated">Estos son los métodos más comunes y legibles.</target>
        </trans-unit>
        <trans-unit id="df35a931ffe321873755cadd3104fa2c6ab5abc1" translate="yes" xml:space="preserve">
          <source>This can be particularly useful when looking for duplicate strings.</source>
          <target state="translated">Esto puede ser particularmente útil cuando se buscan cuerdas duplicadas.</target>
        </trans-unit>
        <trans-unit id="367dab6a1825fbf327c5342ee35812bde1eec73e" translate="yes" xml:space="preserve">
          <source>This is a simple regex that avoids replacing parts of words in most cases. However, a dash &lt;code&gt;-&lt;/code&gt; is still considered a word boundary. So conditionals can be used in this case to avoid replacing strings like &lt;code&gt;cool-cat&lt;/code&gt;:</source>
          <target state="translated">Esta es una expresi&amp;oacute;n regular simple que evita reemplazar partes de palabras en la mayor&amp;iacute;a de los casos. Sin embargo, un gui&amp;oacute;n todav&amp;iacute;a se considera un l&amp;iacute;mite de palabras. Por lo tanto, los condicionales se pueden usar en este caso para evitar reemplazar cadenas como &lt;code&gt;cool-cat&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c02562e1f6d4a5cbf736a7b0837cb984e69786fd" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;fastest&lt;/strong&gt; version that &lt;em&gt;doesn't use regular expressions&lt;/em&gt;.</source>
          <target state="translated">Esta es la versi&amp;oacute;n &lt;strong&gt;m&amp;aacute;s r&amp;aacute;pida&lt;/strong&gt; que &lt;em&gt;no usa expresiones regulares&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ba6f081fdf243a403bac2ba3cf8f0fdee154766a" translate="yes" xml:space="preserve">
          <source>This used to be faster in some cases than using &lt;code&gt;replaceAll&lt;/code&gt; and a regular expression, but that doesn't seem to be the case anymore in modern browsers.</source>
          <target state="translated">Esto sol&amp;iacute;a ser m&amp;aacute;s r&amp;aacute;pido en algunos casos que usar &lt;code&gt;replaceAll&lt;/code&gt; y una expresi&amp;oacute;n regular, pero ese ya no parece ser el caso en los navegadores modernos.</target>
        </trans-unit>
        <trans-unit id="c06e71ba6500c4e97fef51f00b081079208d8af6" translate="yes" xml:space="preserve">
          <source>Today 27.12.2019 I perform tests on &lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; (High Sierra) for the chosen solutions.</source>
          <target state="translated">Hoy 27.12.2019 realizo pruebas en &lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; (High Sierra) para las soluciones elegidas.</target>
        </trans-unit>
        <trans-unit id="8f10ddde05bf54e0d639e76139d9d0182eb95a01" translate="yes" xml:space="preserve">
          <source>Update July 27th 2017: It looks like RegExp now has the fastest performance in the recently released Chrome 59.</source>
          <target state="translated">Actualización 27 de julio de 2017:Parece que RegExp tiene ahora el rendimiento más rápido en el recientemente lanzado Chrome 59.</target>
        </trans-unit>
        <trans-unit id="4bcac541a8c7f79ba50a38a8988ad2f783681ee0" translate="yes" xml:space="preserve">
          <source>Use a regular expression:</source>
          <target state="translated">Use una expresión regular:</target>
        </trans-unit>
        <trans-unit id="c2aee7f5722611179e110f5e6d7da49f02ff7c59" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;RegExp&lt;/code&gt; in &lt;strong&gt;JavaScript&lt;/strong&gt; could do the job for you, just simply do something like below code, don't forget the &lt;code&gt;/g&lt;/code&gt; after which standout for &lt;strong&gt;global&lt;/strong&gt;:</source>
          <target state="translated">El uso de &lt;code&gt;RegExp&lt;/code&gt; en &lt;strong&gt;JavaScript&lt;/strong&gt; podr&amp;iacute;a hacer el trabajo por usted, simplemente haga algo como el siguiente c&amp;oacute;digo, no olvide el &lt;code&gt;/g&lt;/code&gt; , despu&amp;eacute;s del cual se destaca para &lt;strong&gt;global&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="9da6ee93a958af3f2a1cebcc0f2590371d8cb6b8" translate="yes" xml:space="preserve">
          <source>Using a regular expression with the &lt;code&gt;g&lt;/code&gt; flag set will replace all:</source>
          <target state="translated">El uso de una expresi&amp;oacute;n regular con el conjunto de indicadores &lt;code&gt;g&lt;/code&gt; reemplazar&amp;aacute; a todos:</target>
        </trans-unit>
        <trans-unit id="09b3286eff56349c39d102a1b366232dba4e9210" translate="yes" xml:space="preserve">
          <source>We could call &lt;code&gt;escapeRegExp&lt;/code&gt; within our &lt;code&gt;String.prototype.replaceAll&lt;/code&gt; implementation, however, I'm not sure how much this will affect the performance (potentially even for strings for which the escape is not needed, like all alphanumeric strings).</source>
          <target state="translated">Podr&amp;iacute;amos llamar a &lt;code&gt;escapeRegExp&lt;/code&gt; dentro de nuestra implementaci&amp;oacute;n &lt;code&gt;String.prototype.replaceAll&lt;/code&gt; , sin embargo, no estoy seguro de cu&amp;aacute;nto afectar&amp;aacute; esto al rendimiento (potencialmente incluso para cadenas para las que no se necesita el escape, como todas las cadenas alfanum&amp;eacute;ricas).</target>
        </trans-unit>
        <trans-unit id="00df80bf98961b338c936f71eb4491af5d4e6cd7" translate="yes" xml:space="preserve">
          <source>What are useful JavaScript methods that extends built-in objects?</source>
          <target state="translated">¿Cuáles son los métodos útiles de JavaScript que amplían los objetos incorporados?</target>
        </trans-unit>
        <trans-unit id="59826ff0dcdf2c8ff1dc7d8cb137e9a83b75e3ba" translate="yes" xml:space="preserve">
          <source>When complete, you will still have 'test abc'!</source>
          <target state="translated">Cuando esté completo,todavía tendrá el &quot;test abc&quot;!</target>
        </trans-unit>
        <trans-unit id="7413bc6dfd6712412a62d33b6ad98978fda494ef" translate="yes" xml:space="preserve">
          <source>You can refer the detailed example &lt;a href=&quot;http://www.cheezycode.com/2015/08/javascript-hacks-for-html-webpage.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Puede consultar el ejemplo detallado &lt;a href=&quot;http://www.cheezycode.com/2015/08/javascript-hacks-for-html-webpage.html&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14612ebec52e07519f5df0000794a2c86ea5a2ed" translate="yes" xml:space="preserve">
          <source>You can run tests on your machine &lt;a href=&quot;https://jsperf.com/remove-substring-small/1&quot;&gt;HERE&lt;/a&gt;. Results for Chrome:</source>
          <target state="translated">Puede ejecutar pruebas en su m&amp;aacute;quina &lt;a href=&quot;https://jsperf.com/remove-substring-small/1&quot;&gt;AQU&amp;Iacute;&lt;/a&gt; . Resultados para Chrome:</target>
        </trans-unit>
        <trans-unit id="d80d16d89e43a7516fb2dee5f412114891576996" translate="yes" xml:space="preserve">
          <source>You can simply use below method</source>
          <target state="translated">Puede utilizar simplemente el siguiente método</target>
        </trans-unit>
        <trans-unit id="28905875c9209baab59de2b80e072d7fc36fde6e" translate="yes" xml:space="preserve">
          <source>[In that case, one could do .replace(/,+/g,','), but at some point the regex gets complex and slow enough to loop instead.]</source>
          <target state="translated">[En ese caso,se podría hacer .replace(,+g,','),pero en algún momento el regex se vuelve complejo y lo suficientemente lento como para hacer un bucle en su lugar.]</target>
        </trans-unit>
        <trans-unit id="1aecada00183a6ff5ec2d92396d46a8c0ae9f7e9" translate="yes" xml:space="preserve">
          <source>and simply use it in your code over and over like below:</source>
          <target state="translated">y simplemente úsalo en tu código una y otra vez como abajo:</target>
        </trans-unit>
        <trans-unit id="cc4acdb915a5e6e90d0ec0a00fa9a185d964911a" translate="yes" xml:space="preserve">
          <source>basically, this question is the same as the question here:
&lt;a href=&quot;https://stackoverflow.com/questions/9499075/javascript-replace-with/9499926&quot;&gt;Javascript replace &quot; ' &quot; with &quot; '' &quot;&lt;/a&gt;</source>
          <target state="translated">B&amp;aacute;sicamente, esta pregunta es la misma que aqu&amp;iacute;: &lt;a href=&quot;https://stackoverflow.com/questions/9499075/javascript-replace-with/9499926&quot;&gt;Javascript reemplaza &quot;'&quot; con &quot;' '&quot;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0d24cf1b244ef65eac88d415645e906ecf67ee0" translate="yes" xml:space="preserve">
          <source>seems to only remove the first occurrence of &lt;code&gt;abc&lt;/code&gt; in the string above.</source>
          <target state="translated">parece que solo elimina la primera aparici&amp;oacute;n de &lt;code&gt;abc&lt;/code&gt; en la cadena anterior.</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="f57ca77c39afa4ad77c7b0cbdd76aaef04834b2b" translate="yes" xml:space="preserve">
          <source>worked better for me than the above answers. so &lt;code&gt;new RegExp(&quot;abc&quot;, 'g')&lt;/code&gt; creates a RegExp what matches all occurence (&lt;code&gt;'g'&lt;/code&gt; flag) of the text (&lt;code&gt;&quot;abc&quot;&lt;/code&gt;). The second part is what gets replaced to, in your case empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;).
&lt;code&gt;str&lt;/code&gt; is the string, and we have to override it, as &lt;code&gt;replace(...)&lt;/code&gt; just returns result, but not overrides. In some cases you might want to use that.</source>
          <target state="translated">funcion&amp;oacute; mejor para m&amp;iacute; que las respuestas anteriores. as&amp;iacute; que el &lt;code&gt;new RegExp(&quot;abc&quot;, 'g')&lt;/code&gt; crea un RegExp que coincide con todas las ocurrencias ( &lt;code&gt;'g'&lt;/code&gt; flag) del texto ( &lt;code&gt;&quot;abc&quot;&lt;/code&gt; ). La segunda parte es a lo que se reemplaza, en su caso cadena vac&amp;iacute;a ( &lt;code&gt;&quot;&quot;&lt;/code&gt; ). &lt;code&gt;str&lt;/code&gt; es la cadena, y tenemos que anularla, ya que &lt;code&gt;replace(...)&lt;/code&gt; solo devuelve el resultado, pero no anula. En algunos casos, es posible que desee usar eso.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
