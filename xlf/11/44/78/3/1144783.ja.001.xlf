<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/1144783">
    <body>
      <group id="1144783">
        <trans-unit id="d9952330ff36e4f4aeca5f93ac713b20da31fa77" translate="yes" xml:space="preserve">
          <source>//loop it until number occurrences comes to 0. OR simply copy/paste</source>
          <target state="translated">/発生数が0になるまでループします。 または、単にコピペします。</target>
        </trans-unit>
        <trans-unit id="c8857126cc10f9914e5f38613f237895ee5c6b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/g&lt;/code&gt; means global</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; はグローバルを意味します</target>
        </trans-unit>
        <trans-unit id="bb5c0451b917db9a91e43681457634a56c6655aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Update:&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Update:&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="54d43c52441fb7bd3ed00affd5f9186806533d64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7e2cd0e1a6f716d8fe13350e59d99500575639f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; Clarification about replaceAll availability</source>
          <target state="translated">&lt;strong&gt;編集：&lt;/strong&gt; replaceAllの可用性に関する説明</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f29304ea9cd1982b93d7af334cf0f88bae973ea7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Final addition:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;最終追加：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d371a375635dead23e71c6018c06fc0b2d6bcf0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;方法1：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39ba8b2d14f80c96148df898ae74111bfba336f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;方法2：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72d457e583e8bca3f439a3a897e489de0b498c03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;方法3：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="529383dcc2e9606a5bb75847be52ba72603eb93a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;方法4：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0737a49188ce80e8c141eb30d15abad1f570e32c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: Don't use this in performance critical code.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;注：パフォーマンスが重要なコードではこれを使用しないでください。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56781c4490d4641a69cef533a9621281a430d169" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In general, extending the built-in prototypes in JavaScript is generally not recommended. I am providing as extensions on the String prototype simply for purposes of illustration, showing different implementations of a hypothetical standard method on the &lt;code&gt;String&lt;/code&gt; built-in prototype.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;一般に、JavaScriptで組み込みプロトタイプを拡張することは、一般的には推奨されません。 文字列プロトタイプの拡張として、説明のために提供しています。 &lt;code&gt;String&lt;/code&gt; 組み込みプロトタイプでの仮想的な標準メソッドのさまざまな実装を示しています。</target>
        </trans-unit>
        <trans-unit id="e9ca3f2973d0dabdd79539f415055d2ed5b22768" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Regular expressions contain special (meta) characters, and as such it is dangerous to blindly pass an argument in the &lt;code&gt;find&lt;/code&gt; function above without pre-processing it to escape those characters.  This is covered in the &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;Mozilla Developer Network&lt;/a&gt;'s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping&quot;&gt;JavaScript Guide on Regular Expressions&lt;/a&gt;, where they present the following utility function (which has changed at least twice since this answer was originally written, so make sure to check the MDN site for potential updates):</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt;正規表現には特殊な（メタ）文字が含まれているため、これらの文字をエスケープする前処理をせずに、上記の &lt;code&gt;find&lt;/code&gt; 関数で引数を盲目的に渡すことは危険です。 これは、 &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;Mozilla Developer Network&lt;/a&gt;の&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping&quot;&gt;正規表現に関するJavaScriptガイドで説明され&lt;/a&gt;ており、次のユーティリティ関数が示されています（この回答は最初に書かれてから少なくとも2回変更されているため、MDNサイトで更新の可能性を確認してください）。</target>
        </trans-unit>
        <trans-unit id="4cdcd3fdc8587add9d1885342dfb4ded08633670" translate="yes" xml:space="preserve">
          <source>@Mike, check the answer I gave there... regexp isn't the only way to replace multiple occurrences of a subsrting, far from it. Think flexible, think split!</source>
          <target state="translated">@Mike,私の答えを確認してください...正規表現だけでは、複数の部分式を置き換えることはできません。柔軟性を考えて、分割を考えてください。</target>
        </trans-unit>
        <trans-unit id="9f7ff750c8d42bac2d5bf7ded2777806c7bbd646" translate="yes" xml:space="preserve">
          <source>Alternatively, to prevent replacing word parts -which the approved answer will do, too! You can get around this issue using regular expressions that are, I admit, somewhat more complex and as an upshot of that, a tad slower, too:</source>
          <target state="translated">あるいは、単語の部分を置き換えないようにするために -これも承認された解答がそうします!この問題は正規表現を使って回避できます。この問題は正規表現を使用して回避することができますが、これはやや複雑で、その結果、少し遅くなります。</target>
        </trans-unit>
        <trans-unit id="9abf1f2f157ce45f651d436bf184af77b8adeb5e" translate="yes" xml:space="preserve">
          <source>Although people have mentioned the use of regex but there's a better approach if you want to replace the text irrespective of the case of the text. Like uppercase or lowercase. Use below syntax</source>
          <target state="translated">正規表現の使用については言及されていますが、テキストの大文字・小文字に関係なくテキストを置換したい場合には、もっと良い方法があります。大文字か小文字かに関係なく置換したい場合には、以下のような方法があります。以下の構文を使用します。</target>
        </trans-unit>
        <trans-unit id="d9e6101a86eec306979f963e9857be885e7245e2" translate="yes" xml:space="preserve">
          <source>As an alternative to regular expressions for a simple literal string, you could use</source>
          <target state="translated">単純なリテラル文字列の正規表現の代わりに</target>
        </trans-unit>
        <trans-unit id="c152952996b6a5c283c92260257eb9c156c7669e" translate="yes" xml:space="preserve">
          <source>As noted in the comment below by @ThomasLeduc and others, there could be an issue with the regular expression-based implementation if &lt;code&gt;search&lt;/code&gt; contains certain characters which are reserved as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;special characters in regular expressions&lt;/a&gt;. The implementation assumes that the caller will escape the string beforehand or will only pass strings that are without the characters in the table in &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;Regular Expressions&lt;/a&gt;&lt;/em&gt; (MDN).</source>
          <target state="translated">下記の@ThomasLeducなどのコメントで述べたように、正規表現で&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;特殊文字&lt;/a&gt;として予約されている特定の文字が &lt;code&gt;search&lt;/code&gt; 含まれている場合、正規表現ベースの実装で問題が発生する可能性があります 。 実装では、呼び出し元が事前に文字列をエスケープするか、 &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;正規表現&lt;/a&gt;&lt;/em&gt; （MDN）のテーブルに文字がない文字列のみを渡すことを前提としています。</target>
        </trans-unit>
        <trans-unit id="63b3d8e8f8a79cd8ec7c3c5683b3642dffed71ed" translate="yes" xml:space="preserve">
          <source>As pointed out in a comment here, this will not work if your &lt;code&gt;omit&lt;/code&gt; variable contains &lt;code&gt;place&lt;/code&gt;, as in: &lt;code&gt;replaceAll(&quot;string&quot;, &quot;s&quot;, &quot;ss&quot;)&lt;/code&gt;, because it will always be able to replace another occurrence of the word.</source>
          <target state="translated">ここのコメントで指摘されているように、 &lt;code&gt;replaceAll(&quot;string&quot;, &quot;s&quot;, &quot;ss&quot;)&lt;/code&gt; 変数に &lt;code&gt;place&lt;/code&gt; が含まれている場合、 replaceAll（ &quot;string&quot;、 &quot;s&quot;、 &quot;ss&quot;）のようにこれは機能しません。 。</target>
        </trans-unit>
        <trans-unit id="2efdbb9e7d89d63a3865b145be18d2985735f425" translate="yes" xml:space="preserve">
          <source>Benchmark: &lt;a href=&quot;https://jsperf.com/replace-all-vs-split-join&quot;&gt;https://jsperf.com/replace-all-vs-split-join&lt;/a&gt;</source>
          <target state="translated">ベンチマーク： &lt;a href=&quot;https://jsperf.com/replace-all-vs-split-join&quot;&gt;https&lt;/a&gt; : //jsperf.com/replace-all-vs-split-join</target>
        </trans-unit>
        <trans-unit id="2f018edf766c43f923af62d936f6faa226aba148" translate="yes" xml:space="preserve">
          <source>But as I mention earlier, it won't make a huge difference in terms of lines to be written or performance, only caching the function may effect some faster performance on long strings and also a good practice of DRY code if you want to reuse.</source>
          <target state="translated">しかし、先に述べたように、それは記述される行数やパフォーマンスに大きな違いをもたらすことはありません。</target>
        </trans-unit>
        <trans-unit id="d0e0c00e52a63b53922a63942eb8ba57f073ff62" translate="yes" xml:space="preserve">
          <source>But that runs the replacement twice for each cycle. Perhaps (at risk of being voted down) that can be combined for a slightly more efficient but less readable form:</source>
          <target state="translated">しかし、それは各サイクルのために2回の置換を実行します。おそらく(投票される危険性がある)それは少しより効率的な、しかし、より読みやすい形のために組み合わせることができます。</target>
        </trans-unit>
        <trans-unit id="4781d0025fe7cca970eabbf656f7ad7b779e25ea" translate="yes" xml:space="preserve">
          <source>Check out this &lt;a href=&quot;http://jsben.ch/#/LFfWA&quot;&gt;&lt;strong&gt;benchmark&lt;/strong&gt;&lt;/a&gt; running these two implementations against each other.</source>
          <target state="translated">これら2つの実装を相互に実行するこの&lt;a href=&quot;http://jsben.ch/#/LFfWA&quot;&gt;&lt;strong&gt;ベンチマーク&lt;/strong&gt;&lt;/a&gt;を確認してください。</target>
        </trans-unit>
        <trans-unit id="c33ec0466fe646cd010b474e907704e44e7c4bfa" translate="yes" xml:space="preserve">
          <source>Code used in tests</source>
          <target state="translated">テストで使用されるコード</target>
        </trans-unit>
        <trans-unit id="dfa777c69364feec4e5703f84e2ca7d360aff891" translate="yes" xml:space="preserve">
          <source>Conclusion: If you have a performance critical use case (e.g processing hundreds of strings), use the Regexp method. But for most typical use cases, this is well worth not having to worry about special characters.</source>
          <target state="translated">結論。パフォーマンスが重要なユースケース(例えば何百もの文字列を処理するなど)では、Regexpメソッドを使用してください。しかし、ほとんどの典型的なユースケースでは、これは特殊文字を気にしなくて済むだけの価値があります。</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="ade2304f2a0ac295b0c79d7fe9ea6df6dc08d89f" translate="yes" xml:space="preserve">
          <source>Doing:</source>
          <target state="translated">Doing:</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">スニペットを展開</target>
        </trans-unit>
        <trans-unit id="dade7a599b73d04a874d2b0f676893876a891d64" translate="yes" xml:space="preserve">
          <source>Fiddle: &lt;a href=&quot;http://jsfiddle.net/cdbzL/&quot;&gt;http://jsfiddle.net/cdbzL/&lt;/a&gt;</source>
          <target state="translated">フィドル： &lt;a href=&quot;http://jsfiddle.net/cdbzL/&quot;&gt;http&lt;/a&gt; : //jsfiddle.net/cdbzL/</target>
        </trans-unit>
        <trans-unit id="be49c2939db3ee7e866d3291921abff640df9c2e" translate="yes" xml:space="preserve">
          <source>For 1M characters they even break Chrome</source>
          <target state="translated">1Mの文字のために彼らはChromeさえ壊す</target>
        </trans-unit>
        <trans-unit id="b8c42f762938f25c778634ec4aa570773188eb6e" translate="yes" xml:space="preserve">
          <source>For example, if we have 'a,,,b' and we wish to remove all duplicate commas.</source>
          <target state="translated">例えば、'a,,,,b'があり、重複するカンマをすべて削除したい場合。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="11e735017335bc0a521dcf44d5eed735e118f9c6" translate="yes" xml:space="preserve">
          <source>For replacing a single time use:</source>
          <target state="translated">1回分の使用量を置き換えるために。</target>
        </trans-unit>
        <trans-unit id="149bb522c45db99a08d6a7b4983aa120a2224b39" translate="yes" xml:space="preserve">
          <source>For replacing multiple times use:</source>
          <target state="translated">複数回使用する場合の交換用。</target>
        </trans-unit>
        <trans-unit id="36e472462a8bc791f2ba2aeae075e82051d294fc" translate="yes" xml:space="preserve">
          <source>For the sake of completeness, I got to thinking about which method I should use to do this. There are basically two ways to do this as suggested by the other answers on this page.</source>
          <target state="translated">完結させるためには、どの方法を使えばいいのかを考えるようになりました。このページの他の回答が示唆しているように、基本的には2つの方法があります。</target>
        </trans-unit>
        <trans-unit id="c3edbcc75bd7b794628267175a04820e53edbdd3" translate="yes" xml:space="preserve">
          <source>Given that this question still gets a lot of views, I thought I might add an example of &lt;code&gt;.replace&lt;/code&gt; used with a callback function. In this case, it dramatically simplifies the expression &lt;em&gt;and&lt;/em&gt; provides even more flexibility, like replacing with correct capitalisation or replacing both &lt;code&gt;cat&lt;/code&gt; and &lt;code&gt;cats&lt;/code&gt; in one go:</source>
          <target state="translated">この質問でもまだ多くのビューが得られることを考えると、コールバック関数で使用される &lt;code&gt;.replace&lt;/code&gt; の例を追加すると思います。 この場合、式が大幅に簡略化され、正しい大文字で置き換える、または &lt;code&gt;cat&lt;/code&gt; と &lt;code&gt;cats&lt;/code&gt; の両方を一度に置き換えるなどの柔軟性がさらに向上します。</target>
        </trans-unit>
        <trans-unit id="b7e3e4b0658ce61581539adf4188d7ebffea28ab" translate="yes" xml:space="preserve">
          <source>Here's a string prototype function based on the accepted answer:</source>
          <target state="translated">ここでは、受け入れられた答えに基づいて、文字列のプロトタイプ関数を作成します。</target>
        </trans-unit>
        <trans-unit id="24794182023bcc1030d2a1378b77bbf20705a2df" translate="yes" xml:space="preserve">
          <source>How can I replace &lt;strong&gt;all&lt;/strong&gt; occurrences of it?</source>
          <target state="translated">どうすればそれを&lt;strong&gt;すべて&lt;/strong&gt;置き換えることができますか？</target>
        </trans-unit>
        <trans-unit id="617a8962b7e2e0f4b9d1343195a5c0af913dde36" translate="yes" xml:space="preserve">
          <source>How to replace all occurrences of a string</source>
          <target state="translated">文字列のすべての出現箇所を置換する方法</target>
        </trans-unit>
        <trans-unit id="271eda4d77d19f0c8b1efeb10240701ebf85921b" translate="yes" xml:space="preserve">
          <source>I also create my own solution. It looks like currently it is the shortest one which does the question job:</source>
          <target state="translated">また、私は自分のソリューションを作成します。現在は質問の仕事をしてくれる最短のもののようです。</target>
        </trans-unit>
        <trans-unit id="27385f76de96154d8b2e18f8f81576c4eed4be96" translate="yes" xml:space="preserve">
          <source>I have this string:</source>
          <target state="translated">この文字列を持っています。</target>
        </trans-unit>
        <trans-unit id="92d7e77cec099283fa1ca888be9c7bb01adb1197" translate="yes" xml:space="preserve">
          <source>I like this method (it looks a little cleaner):</source>
          <target state="translated">この方法が好きです(少しスッキリした感じがします)。</target>
        </trans-unit>
        <trans-unit id="0d74abf0b650c9679eebf5f617351ed153d36de9" translate="yes" xml:space="preserve">
          <source>I try to perform tests for 1M characters for other solutions, but &lt;strong&gt;E,F,G,H&lt;/strong&gt; takes so much time that browser ask me to break script so I shrink test string to 275K characters. You can run tests on your machine &lt;a href=&quot;https://jsperf.com/remove-substring-big/1&quot;&gt;HERE&lt;/a&gt;. Results for Chrome</source>
          <target state="translated">他のソリューションで100万文字のテストを実行しようとしていますが、 &lt;strong&gt;E、F、G、Hに&lt;/strong&gt;非常に時間がかかるため、ブラウザーがスクリプトを中断するように要求するため、テスト文字列を275K文字に縮小します。 &lt;a href=&quot;https://jsperf.com/remove-substring-big/1&quot;&gt;ここで&lt;/a&gt;マシン上でテストを実行できます。 Chromeの結果</target>
        </trans-unit>
        <trans-unit id="571150b46c01207484df0493bc72e22e092ba6fb" translate="yes" xml:space="preserve">
          <source>I was trying to think about something more simple than modifying the string prototype.</source>
          <target state="translated">文字列のプロトタイプを修正するよりも、もっと簡単なことを考えようと思っていました。</target>
        </trans-unit>
        <trans-unit id="f6f84f4228ff1dc85882fa840346aac31c421b25" translate="yes" xml:space="preserve">
          <source>If the string contain similar pattern like &lt;code&gt;abccc&lt;/code&gt;, you can use this:</source>
          <target state="translated">文字列に &lt;code&gt;abccc&lt;/code&gt; のような同様のパターンが含まれている場合、これを使用できます。</target>
        </trans-unit>
        <trans-unit id="8889bb9f75193ae0d9d2462502aa8b541a30bf48" translate="yes" xml:space="preserve">
          <source>If what you want to find is already in a string, and you don't have a regex escaper handy, you can use join/split:</source>
          <target state="translated">見つけたいものがすでに文字列に含まれていて、regex エスケーパを持っていない場合は、joinsplit を使うことができます。</target>
        </trans-unit>
        <trans-unit id="6426ffa6019405a00629f74abdadd40f6f1fa52f" translate="yes" xml:space="preserve">
          <source>If you are trying to ensure that the string you are looking for won't exist even after the replacement, you need to use a loop.</source>
          <target state="translated">置換してもお目当ての文字列が存在しないようにしようとする場合は、ループを使う必要があります。</target>
        </trans-unit>
        <trans-unit id="8017ab8bc71676e6882e731d96181ecc21dfc1db" translate="yes" xml:space="preserve">
          <source>If you think of reuse, create a function to do that for you, but it's not recommended as it's only one line function, but again if you heavily use this, you can write something like this:</source>
          <target state="translated">再利用を考えるのであれば、そのための関数を作ればいいのですが、一行だけの関数なのでお勧めできませんが、またしても重く使うのであれば、こんな感じで書けばいいと思います。</target>
        </trans-unit>
        <trans-unit id="6a4b3b967221be750b157c4ee9fe1f50d77f67db" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;find&lt;/code&gt; will contain special characters then you need to escape them:</source>
          <target state="translated">&lt;code&gt;find&lt;/code&gt; に特殊文字が含まれる場合は、それらをエスケープする必要があります。</target>
        </trans-unit>
        <trans-unit id="079c54dc97655e15c06ad5c00768b648932e30cd" translate="yes" xml:space="preserve">
          <source>In response to &lt;a href=&quot;https://stackoverflow.com/users/49153/click-upvote&quot;&gt;Click Upvote&lt;/a&gt;'s comment, you could simplify it even more:</source>
          <target state="translated">&lt;a href=&quot;https://stackoverflow.com/users/49153/click-upvote&quot;&gt;Click Upvote&lt;/a&gt;のコメントに応じて、さらに簡単にすることができます。</target>
        </trans-unit>
        <trans-unit id="191216a7395aed5161e4fcfb09478317c8e872a8" translate="yes" xml:space="preserve">
          <source>In response to comment:</source>
          <target state="translated">コメントに反応して</target>
        </trans-unit>
        <trans-unit id="dbf9ba5ca6006381bcdff40469061e3b7616e9c3" translate="yes" xml:space="preserve">
          <source>It is almost &lt;strong&gt;twice&lt;/strong&gt; as fast as the split and join method.</source>
          <target state="translated">分割して結合する方法のほぼ&lt;strong&gt;2倍の&lt;/strong&gt;速度です。</target>
        </trans-unit>
        <trans-unit id="ee38f424d22647b54ca91efb42b2feb4dc705df1" translate="yes" xml:space="preserve">
          <source>It's somewhat late for an update, but since I just stumbled on this question, and noticed that my previous answer is not one I'm happy with. Since the question involved replaceing a single word, it's incredible nobody thought of using word boundaries (&lt;code&gt;\b&lt;/code&gt;)</source>
          <target state="translated">更新には少し遅れますが、この質問に出くわしただけで、以前の答えが満足できるものではないことに気づきました。 質問は単一の単語の置き換えを伴うため、単語の境界（ &lt;code&gt;\b&lt;/code&gt; ）を使用することを誰も考えなかったのは驚くべきことです</target>
        </trans-unit>
        <trans-unit id="e330ec23e20bc0e91f1bf5db33cb4dd1a0e02bd4" translate="yes" xml:space="preserve">
          <source>Just add &lt;code&gt;/g&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; を追加するだけです</target>
        </trans-unit>
        <trans-unit id="80e8772aa17b25f69c6e07312344c7020cbbfee3" translate="yes" xml:space="preserve">
          <source>Long string: 275 000 characters</source>
          <target state="translated">長い文字列:275 000文字</target>
        </trans-unit>
        <trans-unit id="2120bdbb22d21b0fe7265d9572081b7ed870ae9f" translate="yes" xml:space="preserve">
          <source>MDN also provides an implementation to escape our strings. It would be nice if this was also standardized as &lt;code&gt;RegExp.escape(str)&lt;/code&gt;, but alas, it does not exist:</source>
          <target state="translated">MDNは、文字列をエスケープするための実装も提供します。 これも &lt;code&gt;RegExp.escape(str)&lt;/code&gt; として標準化されていると便利ですが、 残念ながら存在しません。</target>
        </trans-unit>
        <trans-unit id="0225f5723fc9201da4e25ebcb7e68c6bad705b25" translate="yes" xml:space="preserve">
          <source>Match against a global regular expression:</source>
          <target state="translated">グローバル正規表現にマッチします。</target>
        </trans-unit>
        <trans-unit id="f76120c1db181b1c8e257b4637f8e39a2280009d" translate="yes" xml:space="preserve">
          <source>My guess is, this meets your needs. It's not fullproof, of course, but it should be enough to get you started. I'd recommend reading some more on these pages. This'll prove useful in perfecting this expression to meet your specific needs.</source>
          <target state="translated">私の推測では、これはあなたのニーズを満たしています。もちろん完全なものではありませんが、あなたが始めるのには十分なはずです。これらのページを読むことをお勧めします。これは、あなたの特定のニーズを満たすためにこの表現を完璧にするのに役立つことが証明されるでしょう。</target>
        </trans-unit>
        <trans-unit id="b8897d8922350c71545273bfce790fe7e2f72ff0" translate="yes" xml:space="preserve">
          <source>Not knowing too much about how regular expressions work behind the scenes in terms of efficiency, I tended to lean toward the split and join implementation in the past without thinking about performance. When I did wonder which was more efficient, and by what margin, I used it as an excuse to find out.</source>
          <target state="translated">効率性の面で正規表現が舞台裏でどのように機能しているのかをあまり知らないので、過去にはパフォーマンスのことは考えずに分割と結合の実装に傾く傾向がありました。どちらがより効率的で、どの程度のマージンで効率的なのか疑問に思ったときは、それを見つけるための口実にしました。</target>
        </trans-unit>
        <trans-unit id="139a05bf0f987bf64fbec5424cb7d5ebc55496a5" translate="yes" xml:space="preserve">
          <source>On my Chrome Windows&amp;nbsp;8 machine, &lt;strong&gt;the regular expression based implementation is the fastest&lt;/strong&gt;, with the &lt;strong&gt;split and join implementation being 53% slower&lt;/strong&gt;. Meaning the regular expressions are twice as fast for the lorem ipsum input I used.</source>
          <target state="translated">私のChrome Windows 8マシンで&lt;strong&gt;は、正規表現ベースの実装が最速&lt;/strong&gt;で、 &lt;strong&gt;分割と結合の実装は53％遅くなっています&lt;/strong&gt; 。 正規表現は、私が使用したlorem ipsum入力の2倍の速さです。</target>
        </trans-unit>
        <trans-unit id="4aeed3d41975990ec44e159a6fdeea976022e55f" translate="yes" xml:space="preserve">
          <source>Oops indeed, this probably isn't what you want. What is, then? IMHO, a regex that only replaces 'cat' conditionally. (ie not part of a word), like so:</source>
          <target state="translated">おっと、確かに、これはあなたが望むものではないかもしれません。では何なのでしょうか?IMHO では、条件付きで 'cat' を置き換えるだけの正規表現です。(つまり単語の一部ではなく)このような正規表現です。</target>
        </trans-unit>
        <trans-unit id="5bffa97d2b31528d43e65d8a25a71624db09d635" translate="yes" xml:space="preserve">
          <source>Or try the replaceAll function from here:</source>
          <target state="translated">もしくは、ここからreplaceAll関数を試してみてください。</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="958af61f062ee06d08e8952efd18380494a6a4d9" translate="yes" xml:space="preserve">
          <source>RangeError: Maximum call stack size exceeded</source>
          <target state="translated">RangeError.最大コールスタックサイズを超えました</target>
        </trans-unit>
        <trans-unit id="516ae82c40ff23ca1cf1e9b09339a27d789eeb76" translate="yes" xml:space="preserve">
          <source>Regular Expression Based Implementation</source>
          <target state="translated">正規表現に基づく実装</target>
        </trans-unit>
        <trans-unit id="1927e4338bf5ed5e34ce23c646604727fd370193" translate="yes" xml:space="preserve">
          <source>Replacing single quotes:</source>
          <target state="translated">シングルクォートの置き換え。</target>
        </trans-unit>
        <trans-unit id="8c27bd4109955934b131a097a08e8328d1b30751" translate="yes" xml:space="preserve">
          <source>Revised jsperf</source>
          <target state="translated">jsperfを修正しました。</target>
        </trans-unit>
        <trans-unit id="a3ae420dc94cd8628e9445b30f38b89f9b7e87c7" translate="yes" xml:space="preserve">
          <source>Say you want to replace all the 'abc' with 'x':</source>
          <target state="translated">すべての'abc'を'x'に置き換えたいとします。</target>
        </trans-unit>
        <trans-unit id="b3a0ed02924fa9756353d3b2962c9f868b0376eb" translate="yes" xml:space="preserve">
          <source>See here also</source>
          <target state="translated">こちらもご覧ください。</target>
        </trans-unit>
        <trans-unit id="238582b8899c43b60945a04bd423c0787fae81fc" translate="yes" xml:space="preserve">
          <source>Short string - 55 characters</source>
          <target state="translated">短い文字列-55文字</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">コードスニペットを表示</target>
        </trans-unit>
        <trans-unit id="afc3390a44e6d9658b7dbfc2d9192fef4d5122cc" translate="yes" xml:space="preserve">
          <source>So in order to make the &lt;code&gt;replaceAll()&lt;/code&gt; function above safer, it could be modified to the following if you also include &lt;code&gt;escapeRegExp&lt;/code&gt;:</source>
          <target state="translated">したがって、上記の &lt;code&gt;replaceAll()&lt;/code&gt; 関数をより安全にするために、 escapeRegExpも含める場合は、次のように変更できます。</target>
        </trans-unit>
        <trans-unit id="791f26db7f076b3fe806fedb1dfdd01bdfaabb50" translate="yes" xml:space="preserve">
          <source>Solutions based on &lt;code&gt;split-join&lt;/code&gt; (&lt;strong&gt;A,B&lt;/strong&gt;) or &lt;code&gt;replace&lt;/code&gt; (&lt;strong&gt;C,D&lt;/strong&gt;) are fast</source>
          <target state="translated">&lt;code&gt;split-join&lt;/code&gt; （ &lt;strong&gt;A、B&lt;/strong&gt; ）または &lt;code&gt;replace&lt;/code&gt; （ &lt;strong&gt;C、D&lt;/strong&gt; ）に基づくソリューションは高速です</target>
        </trans-unit>
        <trans-unit id="64a7df9d3528430f1d064d94dcd7ce12360a8b65" translate="yes" xml:space="preserve">
          <source>Solutions based on &lt;code&gt;while&lt;/code&gt; (&lt;strong&gt;E,F,G,H&lt;/strong&gt;) are slow - usually ~4 times slower for small strings and about ~3000 times (!) slower for long strings</source>
          <target state="translated">&lt;code&gt;while&lt;/code&gt; （ &lt;strong&gt;E、F、G、H&lt;/strong&gt; ）に基づくソリューションは遅い-小さな文字列では通常〜4倍遅く、長い​​文字列では約〜3000倍（！）遅い</target>
        </trans-unit>
        <trans-unit id="c5f617985382ce2f6b1ad5a88716ff377cafb216" translate="yes" xml:space="preserve">
          <source>Split and Join (Functional) Implementation</source>
          <target state="translated">分割と結合(機能)の実装</target>
        </trans-unit>
        <trans-unit id="3f262f9b42c014ce513b61f570042ee408a6ccbe" translate="yes" xml:space="preserve">
          <source>The 'replaceAll' method is added to String's prototype. This means it will be available for all string objects/literals.</source>
          <target state="translated">Stringのプロトタイプに'replaceAll'メソッドが追加されました。これは、すべての文字列オブジェクトリテラルに対して利用できるようになることを意味します。</target>
        </trans-unit>
        <trans-unit id="70a3c41c6145b1073780fd66e0a5961a9f9d085d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str.replace(/abc/g, '');&lt;/code&gt; (&lt;strong&gt;C&lt;/strong&gt;) is a good cross-browser fast solution for all strings.</source>
          <target state="translated">&lt;code&gt;str.replace(/abc/g, '');&lt;/code&gt; （ &lt;strong&gt;C&lt;/strong&gt; ）は、すべての文字列に対して適切なブラウザ間高速ソリューションです。</target>
        </trans-unit>
        <trans-unit id="6862722646db89bf527d4db5a4180543b94a8268" translate="yes" xml:space="preserve">
          <source>The general pattern is</source>
          <target state="translated">一般的なパターンは</target>
        </trans-unit>
        <trans-unit id="ad15bf1a90e5b964105fd6d24685320af721a361" translate="yes" xml:space="preserve">
          <source>The output is the same as the accepted answer, however, using the /cat/g expression on this string:</source>
          <target state="translated">ただし、この文字列にcatg式を使用することで、受理された回答と同じ出力になります。</target>
        </trans-unit>
        <trans-unit id="500d5673e29a623bf205aac14d021c9e4584c6d7" translate="yes" xml:space="preserve">
          <source>The previous answers are way too complicated. Just use the replace function like this:</source>
          <target state="translated">前の答えは複雑すぎます。こんな感じで置換機能を使えばいいんです。</target>
        </trans-unit>
        <trans-unit id="3edf210ac416af9397656481643d3200184bbd0a" translate="yes" xml:space="preserve">
          <source>The recurrence solutions (&lt;strong&gt;RA,RB&lt;/strong&gt;) are slow and do not work for long strings</source>
          <target state="translated">繰り返しソリューション（ &lt;strong&gt;RA、RB&lt;/strong&gt; ）は遅く、長い​​文字列では機能しません</target>
        </trans-unit>
        <trans-unit id="50bd0e425afb39661b9eb4e9f39fd4b4493a5609" translate="yes" xml:space="preserve">
          <source>The recursive solutions &lt;strong&gt;RA&lt;/strong&gt; and &lt;strong&gt;RB&lt;/strong&gt; gives</source>
          <target state="translated">&lt;strong&gt;RA&lt;/strong&gt;と&lt;strong&gt;RB&lt;/strong&gt;が与える再帰的解</target>
        </trans-unit>
        <trans-unit id="369989b3729604fa9987753462bbbf349899d07e" translate="yes" xml:space="preserve">
          <source>The simplest loop to solve this would be:</source>
          <target state="translated">これを解決するための最も単純なループは、次のようなものでしょう。</target>
        </trans-unit>
        <trans-unit id="03772ccff926aef82feb6ee59ca395521b306264" translate="yes" xml:space="preserve">
          <source>The simplest way to this without using any regex is split and join like the code here:</source>
          <target state="translated">正規表現を使わない最も簡単な方法は、ここのコードのように分割して結合することです。</target>
        </trans-unit>
        <trans-unit id="e03cd7383682fc6d72d2b9f15ccd635f4298117f" translate="yes" xml:space="preserve">
          <source>The tests were performed on Chrome 79.0, Safari 13.0.4 and Firefox 71.0 (64 bit). The tests &lt;code&gt;RA&lt;/code&gt; and &lt;code&gt;RB&lt;/code&gt; use recursion. Results</source>
          <target state="translated">テストはChrome 79.0、Safari 13.0.4およびFirefox 71.0（64ビット）で実行されました。 テスト &lt;code&gt;RA&lt;/code&gt; および &lt;code&gt;RB&lt;/code&gt; は再帰を使用します。 結果</target>
        </trans-unit>
        <trans-unit id="a9311a98961911f95ad2bd5e24444545ee47566a" translate="yes" xml:space="preserve">
          <source>There is another jsperf with variants on my recursive replace that go even faster (&lt;a href=&quot;http://jsperf.com/replace-all-vs-split-join/12&quot;&gt;http://jsperf.com/replace-all-vs-split-join/12&lt;/a&gt;)!</source>
          <target state="translated">私の再帰的置換のバリアントを持つ別のjsperfがあり、さらに速くなります（ &lt;a href=&quot;http://jsperf.com/replace-all-vs-split-join/12&quot;&gt;http://jsperf.com/replace-all-vs-split-join/12&lt;/a&gt; ）！</target>
        </trans-unit>
        <trans-unit id="16225ef62710b40df18181fe23a2e790ba51aaf9" translate="yes" xml:space="preserve">
          <source>These are the most common and readable methods.</source>
          <target state="translated">これらは、最も一般的で読みやすい方法です。</target>
        </trans-unit>
        <trans-unit id="df35a931ffe321873755cadd3104fa2c6ab5abc1" translate="yes" xml:space="preserve">
          <source>This can be particularly useful when looking for duplicate strings.</source>
          <target state="translated">重複した文字列を探すときに特に便利です。</target>
        </trans-unit>
        <trans-unit id="367dab6a1825fbf327c5342ee35812bde1eec73e" translate="yes" xml:space="preserve">
          <source>This is a simple regex that avoids replacing parts of words in most cases. However, a dash &lt;code&gt;-&lt;/code&gt; is still considered a word boundary. So conditionals can be used in this case to avoid replacing strings like &lt;code&gt;cool-cat&lt;/code&gt;:</source>
          <target state="translated">これは、ほとんどの場合、単語の一部の置き換えを回避する単純な正規表現です。 ただし、ダッシュ &lt;code&gt;-&lt;/code&gt; は依然として単語の境界と見なされます。 したがって、この場合は条件文を使用して、 &lt;code&gt;cool-cat&lt;/code&gt; のような文字列の置換を回避できます。</target>
        </trans-unit>
        <trans-unit id="c02562e1f6d4a5cbf736a7b0837cb984e69786fd" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;fastest&lt;/strong&gt; version that &lt;em&gt;doesn't use regular expressions&lt;/em&gt;.</source>
          <target state="translated">これは、 &lt;em&gt;正規表現を使用しない&lt;/em&gt; &lt;strong&gt;最速の&lt;/strong&gt;バージョンです。</target>
        </trans-unit>
        <trans-unit id="ba6f081fdf243a403bac2ba3cf8f0fdee154766a" translate="yes" xml:space="preserve">
          <source>This used to be faster in some cases than using &lt;code&gt;replaceAll&lt;/code&gt; and a regular expression, but that doesn't seem to be the case anymore in modern browsers.</source>
          <target state="translated">&lt;code&gt;replaceAll&lt;/code&gt; 、 replaceAllや正規表現を使用するよりも高速な場合がありましたが、最近のブラウザではそうではありません。</target>
        </trans-unit>
        <trans-unit id="c06e71ba6500c4e97fef51f00b081079208d8af6" translate="yes" xml:space="preserve">
          <source>Today 27.12.2019 I perform tests on &lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; (High Sierra) for the chosen solutions.</source>
          <target state="translated">今日27.12.2019選択したソリューションに対して&lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; （High Sierra）でテストを実行します。</target>
        </trans-unit>
        <trans-unit id="8f10ddde05bf54e0d639e76139d9d0182eb95a01" translate="yes" xml:space="preserve">
          <source>Update July 27th 2017: It looks like RegExp now has the fastest performance in the recently released Chrome 59.</source>
          <target state="translated">2017年7月27日更新。最近リリースされたChrome 59でRegExpが最速のパフォーマンスを発揮するようになったようです。</target>
        </trans-unit>
        <trans-unit id="4bcac541a8c7f79ba50a38a8988ad2f783681ee0" translate="yes" xml:space="preserve">
          <source>Use a regular expression:</source>
          <target state="translated">正規表現を使用します。</target>
        </trans-unit>
        <trans-unit id="c2aee7f5722611179e110f5e6d7da49f02ff7c59" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;RegExp&lt;/code&gt; in &lt;strong&gt;JavaScript&lt;/strong&gt; could do the job for you, just simply do something like below code, don't forget the &lt;code&gt;/g&lt;/code&gt; after which standout for &lt;strong&gt;global&lt;/strong&gt;:</source>
          <target state="translated">&lt;strong&gt;JavaScriptで&lt;/strong&gt; &lt;code&gt;RegExp&lt;/code&gt; を&lt;strong&gt;使用&lt;/strong&gt;すると、次のようなコードを実行できます。/gを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="9da6ee93a958af3f2a1cebcc0f2590371d8cb6b8" translate="yes" xml:space="preserve">
          <source>Using a regular expression with the &lt;code&gt;g&lt;/code&gt; flag set will replace all:</source>
          <target state="translated">&lt;code&gt;g&lt;/code&gt; フラグを設定した正規表現を使用すると、すべてが置き換えられます。</target>
        </trans-unit>
        <trans-unit id="09b3286eff56349c39d102a1b366232dba4e9210" translate="yes" xml:space="preserve">
          <source>We could call &lt;code&gt;escapeRegExp&lt;/code&gt; within our &lt;code&gt;String.prototype.replaceAll&lt;/code&gt; implementation, however, I'm not sure how much this will affect the performance (potentially even for strings for which the escape is not needed, like all alphanumeric strings).</source>
          <target state="translated">&lt;code&gt;String.prototype.replaceAll&lt;/code&gt; 実装内で &lt;code&gt;escapeRegExp&lt;/code&gt; を呼び出すこともできますが、これがパフォーマンスにどの程度影響するかはわかりません（すべての英数字文字列のように、エスケープが不要な文字列の場合でも）。</target>
        </trans-unit>
        <trans-unit id="00df80bf98961b338c936f71eb4491af5d4e6cd7" translate="yes" xml:space="preserve">
          <source>What are useful JavaScript methods that extends built-in objects?</source>
          <target state="translated">組み込みオブジェクトを拡張するJavaScriptの便利なメソッドとは?</target>
        </trans-unit>
        <trans-unit id="59826ff0dcdf2c8ff1dc7d8cb137e9a83b75e3ba" translate="yes" xml:space="preserve">
          <source>When complete, you will still have 'test abc'!</source>
          <target state="translated">完成しても、「test abc」が残っています!</target>
        </trans-unit>
        <trans-unit id="7413bc6dfd6712412a62d33b6ad98978fda494ef" translate="yes" xml:space="preserve">
          <source>You can refer the detailed example &lt;a href=&quot;http://www.cheezycode.com/2015/08/javascript-hacks-for-html-webpage.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">詳細な例は&lt;a href=&quot;http://www.cheezycode.com/2015/08/javascript-hacks-for-html-webpage.html&quot;&gt;ここで&lt;/a&gt;参照できます 。</target>
        </trans-unit>
        <trans-unit id="14612ebec52e07519f5df0000794a2c86ea5a2ed" translate="yes" xml:space="preserve">
          <source>You can run tests on your machine &lt;a href=&quot;https://jsperf.com/remove-substring-small/1&quot;&gt;HERE&lt;/a&gt;. Results for Chrome:</source>
          <target state="translated">&lt;a href=&quot;https://jsperf.com/remove-substring-small/1&quot;&gt;ここで&lt;/a&gt;マシン上でテストを実行できます。 Chromeの結果：</target>
        </trans-unit>
        <trans-unit id="d80d16d89e43a7516fb2dee5f412114891576996" translate="yes" xml:space="preserve">
          <source>You can simply use below method</source>
          <target state="translated">以下の方法を使用することができます。</target>
        </trans-unit>
        <trans-unit id="28905875c9209baab59de2b80e072d7fc36fde6e" translate="yes" xml:space="preserve">
          <source>[In that case, one could do .replace(/,+/g,','), but at some point the regex gets complex and slow enough to loop instead.]</source>
          <target state="translated">この場合、.replace(,+g,',')を実行することもできますが、ある時点で正規表現が複雑になり、ループするのに十分な速度が出なくなってしまいます。</target>
        </trans-unit>
        <trans-unit id="1aecada00183a6ff5ec2d92396d46a8c0ae9f7e9" translate="yes" xml:space="preserve">
          <source>and simply use it in your code over and over like below:</source>
          <target state="translated">と、以下のようにあなたのコードに使用するだけです。</target>
        </trans-unit>
        <trans-unit id="cc4acdb915a5e6e90d0ec0a00fa9a185d964911a" translate="yes" xml:space="preserve">
          <source>basically, this question is the same as the question here:
&lt;a href=&quot;https://stackoverflow.com/questions/9499075/javascript-replace-with/9499926&quot;&gt;Javascript replace &quot; ' &quot; with &quot; '' &quot;&lt;/a&gt;</source>
          <target state="translated">基本的に、この質問はここの質問と同じです： &lt;a href=&quot;https://stackoverflow.com/questions/9499075/javascript-replace-with/9499926&quot;&gt;Javascriptは「」を「」に置き換え&lt;/a&gt;ます</target>
        </trans-unit>
        <trans-unit id="a0d24cf1b244ef65eac88d415645e906ecf67ee0" translate="yes" xml:space="preserve">
          <source>seems to only remove the first occurrence of &lt;code&gt;abc&lt;/code&gt; in the string above.</source>
          <target state="translated">上記の文字列で最初に出現する &lt;code&gt;abc&lt;/code&gt; のみを削除するようです。</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="f57ca77c39afa4ad77c7b0cbdd76aaef04834b2b" translate="yes" xml:space="preserve">
          <source>worked better for me than the above answers. so &lt;code&gt;new RegExp(&quot;abc&quot;, 'g')&lt;/code&gt; creates a RegExp what matches all occurence (&lt;code&gt;'g'&lt;/code&gt; flag) of the text (&lt;code&gt;&quot;abc&quot;&lt;/code&gt;). The second part is what gets replaced to, in your case empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;).
&lt;code&gt;str&lt;/code&gt; is the string, and we have to override it, as &lt;code&gt;replace(...)&lt;/code&gt; just returns result, but not overrides. In some cases you might want to use that.</source>
          <target state="translated">上記の答えよりも私にとってはうまくいきました。 したがって、 &lt;code&gt;new RegExp(&quot;abc&quot;, 'g')&lt;/code&gt; ）は、テキスト（ &lt;code&gt;&quot;abc&quot;&lt;/code&gt; ）のすべての出現（ &lt;code&gt;'g'&lt;/code&gt; フラグ）に一致するRegExpを作成します。 2番目の部分は、空の文字列（ &lt;code&gt;&quot;&quot;&lt;/code&gt; ）に置き換えられます。 &lt;code&gt;str&lt;/code&gt; は文字列であり、 &lt;code&gt;replace(...)&lt;/code&gt; は結果を返すだけでオーバーライドはしないため、オーバーライドする必要があります。 場合によっては、それを使用することもできます。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
