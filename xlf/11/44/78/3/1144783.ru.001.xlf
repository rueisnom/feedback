<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/1144783">
    <body>
      <group id="1144783">
        <trans-unit id="d9952330ff36e4f4aeca5f93ac713b20da31fa77" translate="yes" xml:space="preserve">
          <source>//loop it until number occurrences comes to 0. OR simply copy/paste</source>
          <target state="translated">/закругляйтесь до тех пор,пока число происшествий не станет равным 0.Или просто скопипасти.</target>
        </trans-unit>
        <trans-unit id="c8857126cc10f9914e5f38613f237895ee5c6b21" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;/g&lt;/code&gt; means global</source>
          <target state="translated">&lt;code&gt;/g&lt;/code&gt; означает глобальный</target>
        </trans-unit>
        <trans-unit id="bb5c0451b917db9a91e43681457634a56c6655aa" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;&lt;strong&gt;Update:&lt;/strong&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&lt;strong&gt;Update:&lt;/strong&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="54d43c52441fb7bd3ed00affd5f9186806533d64" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Conclusions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Conclusions&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b7e2cd0e1a6f716d8fe13350e59d99500575639f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT:&lt;/strong&gt; Clarification about replaceAll availability</source>
          <target state="translated">&lt;strong&gt;РЕДАКТИРОВАТЬ:&lt;/strong&gt; разъяснения о заменеВсе наличие</target>
        </trans-unit>
        <trans-unit id="4f1f2d1ba0a7e969d5df6fdb8a7f2b397072df69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;EDIT&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;EDIT&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f29304ea9cd1982b93d7af334cf0f88bae973ea7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Final addition:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Заключительное дополнение:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d371a375635dead23e71c6018c06fc0b2d6bcf0a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 1:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Способ 1:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="39ba8b2d14f80c96148df898ae74111bfba336f0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 2:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Способ 2:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="72d457e583e8bca3f439a3a897e489de0b498c03" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 3:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Способ 3:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="529383dcc2e9606a5bb75847be52ba72603eb93a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Method 4:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Способ 4:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0737a49188ce80e8c141eb30d15abad1f570e32c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: Don't use this in performance critical code.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Примечание: не используйте это в коде, критичном к производительности.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="56781c4490d4641a69cef533a9621281a430d169" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; In general, extending the built-in prototypes in JavaScript is generally not recommended. I am providing as extensions on the String prototype simply for purposes of illustration, showing different implementations of a hypothetical standard method on the &lt;code&gt;String&lt;/code&gt; built-in prototype.</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Как правило, расширение встроенных прототипов в JavaScript обычно не рекомендуется. Я предоставляю в качестве расширений прототипа String просто в целях иллюстрации, демонстрируя различные реализации гипотетического стандартного метода на встроенном прототипе &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9ca3f2973d0dabdd79539f415055d2ed5b22768" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:&lt;/strong&gt; Regular expressions contain special (meta) characters, and as such it is dangerous to blindly pass an argument in the &lt;code&gt;find&lt;/code&gt; function above without pre-processing it to escape those characters.  This is covered in the &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;Mozilla Developer Network&lt;/a&gt;'s &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping&quot;&gt;JavaScript Guide on Regular Expressions&lt;/a&gt;, where they present the following utility function (which has changed at least twice since this answer was originally written, so make sure to check the MDN site for potential updates):</source>
          <target state="translated">&lt;strong&gt;Примечание.&lt;/strong&gt; Регулярные выражения содержат специальные (мета) символы, и поэтому опасно слепо передавать аргумент в функции &lt;code&gt;find&lt;/code&gt; выше без предварительной обработки для экранирования этих символов. Это описано в &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping&quot;&gt;Руководстве JavaScript по регулярным выражениям&lt;/a&gt; в &lt;a href=&quot;https://developer.mozilla.org/en-US/&quot;&gt;Mozilla Developer Network&lt;/a&gt; , в котором представлена ​​следующая служебная функция (которая изменилась не менее двух раз с момента первоначального написания этого ответа, поэтому обязательно проверяйте сайт MDN на наличие потенциальных обновлений):</target>
        </trans-unit>
        <trans-unit id="4cdcd3fdc8587add9d1885342dfb4ded08633670" translate="yes" xml:space="preserve">
          <source>@Mike, check the answer I gave there... regexp isn't the only way to replace multiple occurrences of a subsrting, far from it. Think flexible, think split!</source>
          <target state="translated">@Mike,проверь ответ,который я там дал...регэкспресс-не единственный способ заменить несколько случаев субартинга,далеко не единственный.Думай гибко,думай раздельно!</target>
        </trans-unit>
        <trans-unit id="9f7ff750c8d42bac2d5bf7ded2777806c7bbd646" translate="yes" xml:space="preserve">
          <source>Alternatively, to prevent replacing word parts -which the approved answer will do, too! You can get around this issue using regular expressions that are, I admit, somewhat more complex and as an upshot of that, a tad slower, too:</source>
          <target state="translated">В качестве альтернативы,чтобы предотвратить замену частей слова-что одобренный ответ тоже будет делать! Вы можете обойти эту проблему,используя регулярные выражения,которые,я признаю,несколько сложнее и,как результат,немного медленнее:</target>
        </trans-unit>
        <trans-unit id="9abf1f2f157ce45f651d436bf184af77b8adeb5e" translate="yes" xml:space="preserve">
          <source>Although people have mentioned the use of regex but there's a better approach if you want to replace the text irrespective of the case of the text. Like uppercase or lowercase. Use below syntax</source>
          <target state="translated">Хотя люди упоминали использование регекса,но есть лучший подход,если вы хотите заменить текст,независимо от случая текста.Например,заглавный или строчный.Используйте синтаксис ниже</target>
        </trans-unit>
        <trans-unit id="d9e6101a86eec306979f963e9857be885e7245e2" translate="yes" xml:space="preserve">
          <source>As an alternative to regular expressions for a simple literal string, you could use</source>
          <target state="translated">В качестве альтернативы регулярным выражениям для простой литературной строки,можно использовать следующие слова</target>
        </trans-unit>
        <trans-unit id="c152952996b6a5c283c92260257eb9c156c7669e" translate="yes" xml:space="preserve">
          <source>As noted in the comment below by @ThomasLeduc and others, there could be an issue with the regular expression-based implementation if &lt;code&gt;search&lt;/code&gt; contains certain characters which are reserved as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;special characters in regular expressions&lt;/a&gt;. The implementation assumes that the caller will escape the string beforehand or will only pass strings that are without the characters in the table in &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;Regular Expressions&lt;/a&gt;&lt;/em&gt; (MDN).</source>
          <target state="translated">Как отмечено в комментарии ниже @ThomasLeduc и других, может быть проблема с реализацией на основе регулярных выражений, если &lt;code&gt;search&lt;/code&gt; содержит определенные символы, которые зарезервированы как &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;специальные символы в регулярных выражениях&lt;/a&gt; . Реализация предполагает, что вызывающая сторона будет избегать строки заранее или будет передавать только те строки, которые не имеют символов в таблице в &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Using_special_characters&quot;&gt;регулярных выражениях&lt;/a&gt;&lt;/em&gt; (MDN).</target>
        </trans-unit>
        <trans-unit id="63b3d8e8f8a79cd8ec7c3c5683b3642dffed71ed" translate="yes" xml:space="preserve">
          <source>As pointed out in a comment here, this will not work if your &lt;code&gt;omit&lt;/code&gt; variable contains &lt;code&gt;place&lt;/code&gt;, as in: &lt;code&gt;replaceAll(&quot;string&quot;, &quot;s&quot;, &quot;ss&quot;)&lt;/code&gt;, because it will always be able to replace another occurrence of the word.</source>
          <target state="translated">Как указано в комментарии здесь, это не будет работать, если ваша переменная &lt;code&gt;replaceAll(&quot;string&quot;, &quot;s&quot;, &quot;ss&quot;)&lt;/code&gt; содержит &lt;code&gt;place&lt;/code&gt; , как в: replaceAll (&quot;string&quot;, &quot;s&quot;, &quot;ss&quot;) , потому что она всегда сможет заменить другое вхождение слова ,</target>
        </trans-unit>
        <trans-unit id="2efdbb9e7d89d63a3865b145be18d2985735f425" translate="yes" xml:space="preserve">
          <source>Benchmark: &lt;a href=&quot;https://jsperf.com/replace-all-vs-split-join&quot;&gt;https://jsperf.com/replace-all-vs-split-join&lt;/a&gt;</source>
          <target state="translated">Тест: &lt;a href=&quot;https://jsperf.com/replace-all-vs-split-join&quot;&gt;https://jsperf.com/replace-all-vs-split-join&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2f018edf766c43f923af62d936f6faa226aba148" translate="yes" xml:space="preserve">
          <source>But as I mention earlier, it won't make a huge difference in terms of lines to be written or performance, only caching the function may effect some faster performance on long strings and also a good practice of DRY code if you want to reuse.</source>
          <target state="translated">Но,как я упоминал ранее,это не будет иметь большого значения с точки зрения написания строк или производительности,только кэширование функции может повлиять на некоторую более быструю производительность на длинных строках,а также хорошую практику DRY кода,если вы хотите использовать его повторно.</target>
        </trans-unit>
        <trans-unit id="d0e0c00e52a63b53922a63942eb8ba57f073ff62" translate="yes" xml:space="preserve">
          <source>But that runs the replacement twice for each cycle. Perhaps (at risk of being voted down) that can be combined for a slightly more efficient but less readable form:</source>
          <target state="translated">Но при этом замена производится дважды за каждый цикл.Возможно (с риском быть проголосованным вниз),что может быть объединено для немного более эффективной,но менее читабельной формы:</target>
        </trans-unit>
        <trans-unit id="4781d0025fe7cca970eabbf656f7ad7b779e25ea" translate="yes" xml:space="preserve">
          <source>Check out this &lt;a href=&quot;http://jsben.ch/#/LFfWA&quot;&gt;&lt;strong&gt;benchmark&lt;/strong&gt;&lt;/a&gt; running these two implementations against each other.</source>
          <target state="translated">Проверьте этот &lt;a href=&quot;http://jsben.ch/#/LFfWA&quot;&gt;&lt;strong&gt;тест,&lt;/strong&gt;&lt;/a&gt; запустив эти две реализации друг против друга.</target>
        </trans-unit>
        <trans-unit id="c33ec0466fe646cd010b474e907704e44e7c4bfa" translate="yes" xml:space="preserve">
          <source>Code used in tests</source>
          <target state="translated">Код,используемый в тестах</target>
        </trans-unit>
        <trans-unit id="dfa777c69364feec4e5703f84e2ca7d360aff891" translate="yes" xml:space="preserve">
          <source>Conclusion: If you have a performance critical use case (e.g processing hundreds of strings), use the Regexp method. But for most typical use cases, this is well worth not having to worry about special characters.</source>
          <target state="translated">Вывод:Если у вас критический сценарий использования (например,обработка сотен строк),используйте метод Regexp.Но в большинстве типичных случаев использования этого метода не стоит беспокоиться о специальных символах.</target>
        </trans-unit>
        <trans-unit id="dc3decbb93847518f1a049dcf49d0d7c6560bcc6" translate="yes" xml:space="preserve">
          <source>Details</source>
          <target state="translated">Details</target>
        </trans-unit>
        <trans-unit id="ade2304f2a0ac295b0c79d7fe9ea6df6dc08d89f" translate="yes" xml:space="preserve">
          <source>Doing:</source>
          <target state="translated">Doing:</target>
        </trans-unit>
        <trans-unit id="fa4a7a170f7075560c98a976572cae386b13a240" translate="yes" xml:space="preserve">
          <source>E.g.</source>
          <target state="translated">E.g.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="dade7a599b73d04a874d2b0f676893876a891d64" translate="yes" xml:space="preserve">
          <source>Fiddle: &lt;a href=&quot;http://jsfiddle.net/cdbzL/&quot;&gt;http://jsfiddle.net/cdbzL/&lt;/a&gt;</source>
          <target state="translated">Скрипка: &lt;a href=&quot;http://jsfiddle.net/cdbzL/&quot;&gt;http://jsfiddle.net/cdbzL/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be49c2939db3ee7e866d3291921abff640df9c2e" translate="yes" xml:space="preserve">
          <source>For 1M characters they even break Chrome</source>
          <target state="translated">Для 1M символов они даже ломают Chrome</target>
        </trans-unit>
        <trans-unit id="b8c42f762938f25c778634ec4aa570773188eb6e" translate="yes" xml:space="preserve">
          <source>For example, if we have 'a,,,b' and we wish to remove all duplicate commas.</source>
          <target state="translated">Например,если у нас есть 'a,,,b' и мы хотим удалить все дубликаты запятых.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="11e735017335bc0a521dcf44d5eed735e118f9c6" translate="yes" xml:space="preserve">
          <source>For replacing a single time use:</source>
          <target state="translated">Для замены одноразового использования времени:</target>
        </trans-unit>
        <trans-unit id="149bb522c45db99a08d6a7b4983aa120a2224b39" translate="yes" xml:space="preserve">
          <source>For replacing multiple times use:</source>
          <target state="translated">Для многократной замены:</target>
        </trans-unit>
        <trans-unit id="36e472462a8bc791f2ba2aeae075e82051d294fc" translate="yes" xml:space="preserve">
          <source>For the sake of completeness, I got to thinking about which method I should use to do this. There are basically two ways to do this as suggested by the other answers on this page.</source>
          <target state="translated">Для полноты,я должен подумать о том,какой метод я должен использовать для этого.В принципе,есть два способа сделать это,как предлагают другие ответы на этой странице.</target>
        </trans-unit>
        <trans-unit id="c3edbcc75bd7b794628267175a04820e53edbdd3" translate="yes" xml:space="preserve">
          <source>Given that this question still gets a lot of views, I thought I might add an example of &lt;code&gt;.replace&lt;/code&gt; used with a callback function. In this case, it dramatically simplifies the expression &lt;em&gt;and&lt;/em&gt; provides even more flexibility, like replacing with correct capitalisation or replacing both &lt;code&gt;cat&lt;/code&gt; and &lt;code&gt;cats&lt;/code&gt; in one go:</source>
          <target state="translated">Учитывая, что этот вопрос по-прежнему получает много просмотров, я подумал, что мог бы добавить пример &lt;code&gt;.replace&lt;/code&gt; , используемого с функцией обратного вызова. В этом случае это значительно упрощает выражение &lt;em&gt;и&lt;/em&gt; обеспечивает еще большую гибкость, например, заменяет правильную заглавную букву или заменяет &lt;code&gt;cat&lt;/code&gt; и кошку за один раз:</target>
        </trans-unit>
        <trans-unit id="b7e3e4b0658ce61581539adf4188d7ebffea28ab" translate="yes" xml:space="preserve">
          <source>Here's a string prototype function based on the accepted answer:</source>
          <target state="translated">Вот прототип строковой функции,основанной на принятом ответе:</target>
        </trans-unit>
        <trans-unit id="24794182023bcc1030d2a1378b77bbf20705a2df" translate="yes" xml:space="preserve">
          <source>How can I replace &lt;strong&gt;all&lt;/strong&gt; occurrences of it?</source>
          <target state="translated">Как я могу заменить &lt;strong&gt;все&lt;/strong&gt; вхождения этого?</target>
        </trans-unit>
        <trans-unit id="617a8962b7e2e0f4b9d1343195a5c0af913dde36" translate="yes" xml:space="preserve">
          <source>How to replace all occurrences of a string</source>
          <target state="translated">Как заменить все вхождения строки</target>
        </trans-unit>
        <trans-unit id="271eda4d77d19f0c8b1efeb10240701ebf85921b" translate="yes" xml:space="preserve">
          <source>I also create my own solution. It looks like currently it is the shortest one which does the question job:</source>
          <target state="translated">Я также создаю свое собственное решение.Похоже,что на данный момент это самое короткое решение,которое делает работу с вопросами:</target>
        </trans-unit>
        <trans-unit id="27385f76de96154d8b2e18f8f81576c4eed4be96" translate="yes" xml:space="preserve">
          <source>I have this string:</source>
          <target state="translated">У меня есть эта веревка:</target>
        </trans-unit>
        <trans-unit id="92d7e77cec099283fa1ca888be9c7bb01adb1197" translate="yes" xml:space="preserve">
          <source>I like this method (it looks a little cleaner):</source>
          <target state="translated">Мне нравится этот метод (он выглядит немного чище):</target>
        </trans-unit>
        <trans-unit id="0d74abf0b650c9679eebf5f617351ed153d36de9" translate="yes" xml:space="preserve">
          <source>I try to perform tests for 1M characters for other solutions, but &lt;strong&gt;E,F,G,H&lt;/strong&gt; takes so much time that browser ask me to break script so I shrink test string to 275K characters. You can run tests on your machine &lt;a href=&quot;https://jsperf.com/remove-substring-big/1&quot;&gt;HERE&lt;/a&gt;. Results for Chrome</source>
          <target state="translated">Я пытаюсь выполнить тесты для 1M символов для других решений, но &lt;strong&gt;E, F, G, H&lt;/strong&gt; отнимает столько времени, что браузер просит меня разбить скрипт, поэтому я сокращаю тестовую строку до 275K символов. Вы можете запустить тесты на своем компьютере &lt;a href=&quot;https://jsperf.com/remove-substring-big/1&quot;&gt;ЗДЕСЬ&lt;/a&gt; . Результаты для Chrome</target>
        </trans-unit>
        <trans-unit id="571150b46c01207484df0493bc72e22e092ba6fb" translate="yes" xml:space="preserve">
          <source>I was trying to think about something more simple than modifying the string prototype.</source>
          <target state="translated">Я пытался подумать о чем-то более простом,чем модификация прототипа строки.</target>
        </trans-unit>
        <trans-unit id="f6f84f4228ff1dc85882fa840346aac31c421b25" translate="yes" xml:space="preserve">
          <source>If the string contain similar pattern like &lt;code&gt;abccc&lt;/code&gt;, you can use this:</source>
          <target state="translated">Если строка содержит аналогичный шаблон, как &lt;code&gt;abccc&lt;/code&gt; , вы можете использовать это:</target>
        </trans-unit>
        <trans-unit id="8889bb9f75193ae0d9d2462502aa8b541a30bf48" translate="yes" xml:space="preserve">
          <source>If what you want to find is already in a string, and you don't have a regex escaper handy, you can use join/split:</source>
          <target state="translated">Если то,что вы хотите найти,уже есть в строке,и у вас нет под рукой регекс-эскопера,вы можете использовать joinsplit:</target>
        </trans-unit>
        <trans-unit id="6426ffa6019405a00629f74abdadd40f6f1fa52f" translate="yes" xml:space="preserve">
          <source>If you are trying to ensure that the string you are looking for won't exist even after the replacement, you need to use a loop.</source>
          <target state="translated">Если вы пытаетесь гарантировать,что искомая строка не будет существовать даже после замены,вам нужно использовать цикл.</target>
        </trans-unit>
        <trans-unit id="8017ab8bc71676e6882e731d96181ecc21dfc1db" translate="yes" xml:space="preserve">
          <source>If you think of reuse, create a function to do that for you, but it's not recommended as it's only one line function, but again if you heavily use this, you can write something like this:</source>
          <target state="translated">Если вы думаете о повторном использовании,создайте функцию,чтобы сделать это за вас,но это не рекомендуется,так как это только одна строчная функция,но опять же,если вы сильно используете это,вы можете написать что-нибудь подобное:</target>
        </trans-unit>
        <trans-unit id="6a4b3b967221be750b157c4ee9fe1f50d77f67db" translate="yes" xml:space="preserve">
          <source>If your &lt;code&gt;find&lt;/code&gt; will contain special characters then you need to escape them:</source>
          <target state="translated">Если ваша &lt;code&gt;find&lt;/code&gt; будет содержать специальные символы, вам нужно их избежать:</target>
        </trans-unit>
        <trans-unit id="079c54dc97655e15c06ad5c00768b648932e30cd" translate="yes" xml:space="preserve">
          <source>In response to &lt;a href=&quot;https://stackoverflow.com/users/49153/click-upvote&quot;&gt;Click Upvote&lt;/a&gt;'s comment, you could simplify it even more:</source>
          <target state="translated">В ответ на комментарий &lt;a href=&quot;https://stackoverflow.com/users/49153/click-upvote&quot;&gt;Click Upvote&lt;/a&gt; вы можете упростить его еще больше:</target>
        </trans-unit>
        <trans-unit id="191216a7395aed5161e4fcfb09478317c8e872a8" translate="yes" xml:space="preserve">
          <source>In response to comment:</source>
          <target state="translated">В ответ на комментарий:</target>
        </trans-unit>
        <trans-unit id="dbf9ba5ca6006381bcdff40469061e3b7616e9c3" translate="yes" xml:space="preserve">
          <source>It is almost &lt;strong&gt;twice&lt;/strong&gt; as fast as the split and join method.</source>
          <target state="translated">Это почти в &lt;strong&gt;два раза&lt;/strong&gt; быстрее, чем метод split и join.</target>
        </trans-unit>
        <trans-unit id="ee38f424d22647b54ca91efb42b2feb4dc705df1" translate="yes" xml:space="preserve">
          <source>It's somewhat late for an update, but since I just stumbled on this question, and noticed that my previous answer is not one I'm happy with. Since the question involved replaceing a single word, it's incredible nobody thought of using word boundaries (&lt;code&gt;\b&lt;/code&gt;)</source>
          <target state="translated">Уже несколько поздно для обновления, но так как я просто наткнулся на этот вопрос и заметил, что мой предыдущий ответ не тот, которым я доволен. Поскольку вопрос касался замены одного слова, невероятно, что никто не думал об использовании границ слова ( &lt;code&gt;\b&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e330ec23e20bc0e91f1bf5db33cb4dd1a0e02bd4" translate="yes" xml:space="preserve">
          <source>Just add &lt;code&gt;/g&lt;/code&gt;</source>
          <target state="translated">Просто добавьте &lt;code&gt;/g&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="80e8772aa17b25f69c6e07312344c7020cbbfee3" translate="yes" xml:space="preserve">
          <source>Long string: 275 000 characters</source>
          <target state="translated">Длинная строка:275 000 символов</target>
        </trans-unit>
        <trans-unit id="2120bdbb22d21b0fe7265d9572081b7ed870ae9f" translate="yes" xml:space="preserve">
          <source>MDN also provides an implementation to escape our strings. It would be nice if this was also standardized as &lt;code&gt;RegExp.escape(str)&lt;/code&gt;, but alas, it does not exist:</source>
          <target state="translated">MDN также предоставляет реализацию, позволяющую избежать наших строк. Было бы хорошо, если бы это было также стандартизировано как &lt;code&gt;RegExp.escape(str)&lt;/code&gt; , но, увы, его не существует:</target>
        </trans-unit>
        <trans-unit id="0225f5723fc9201da4e25ebcb7e68c6bad705b25" translate="yes" xml:space="preserve">
          <source>Match against a global regular expression:</source>
          <target state="translated">Матч с глобальным регулярным выражением:</target>
        </trans-unit>
        <trans-unit id="f76120c1db181b1c8e257b4637f8e39a2280009d" translate="yes" xml:space="preserve">
          <source>My guess is, this meets your needs. It's not fullproof, of course, but it should be enough to get you started. I'd recommend reading some more on these pages. This'll prove useful in perfecting this expression to meet your specific needs.</source>
          <target state="translated">Думаю,это удовлетворяет твои потребности.Это,конечно,не полная защита,но этого должно быть достаточно,чтобы вы начали.Я бы порекомендовал почитать еще немного на этих страницах.Это окажется полезным в совершенствовании этого выражения для удовлетворения ваших конкретных потребностей.</target>
        </trans-unit>
        <trans-unit id="b8897d8922350c71545273bfce790fe7e2f72ff0" translate="yes" xml:space="preserve">
          <source>Not knowing too much about how regular expressions work behind the scenes in terms of efficiency, I tended to lean toward the split and join implementation in the past without thinking about performance. When I did wonder which was more efficient, and by what margin, I used it as an excuse to find out.</source>
          <target state="translated">Не зная слишком много о том,как регулярные выражения работают за кулисами с точки зрения эффективности,я склонялся к расколу и присоединялся к реализации в прошлом,не задумываясь о производительности.Когда я задавался вопросом,что более эффективно и с каким запасом,я использовал это как предлог,чтобы выяснить это.</target>
        </trans-unit>
        <trans-unit id="139a05bf0f987bf64fbec5424cb7d5ebc55496a5" translate="yes" xml:space="preserve">
          <source>On my Chrome Windows&amp;nbsp;8 machine, &lt;strong&gt;the regular expression based implementation is the fastest&lt;/strong&gt;, with the &lt;strong&gt;split and join implementation being 53% slower&lt;/strong&gt;. Meaning the regular expressions are twice as fast for the lorem ipsum input I used.</source>
          <target state="translated">На моем компьютере с Chrome Windows 8 &lt;strong&gt;реализация на основе регулярных выражений является самой быстрой&lt;/strong&gt; , &lt;strong&gt;а реализация разбиения и объединения выполняется на 53% медленнее&lt;/strong&gt; . Это означает, что регулярные выражения в два раза быстрее для ввода lorem ipsum, который я использовал.</target>
        </trans-unit>
        <trans-unit id="4aeed3d41975990ec44e159a6fdeea976022e55f" translate="yes" xml:space="preserve">
          <source>Oops indeed, this probably isn't what you want. What is, then? IMHO, a regex that only replaces 'cat' conditionally. (ie not part of a word), like so:</source>
          <target state="translated">Упс,действительно,это,наверное,не то,чего ты хочешь.А что же тогда? IMHO,регекс,который заменяет только &quot;кот&quot; условно.(т.е.не часть слова),вроде того:</target>
        </trans-unit>
        <trans-unit id="5bffa97d2b31528d43e65d8a25a71624db09d635" translate="yes" xml:space="preserve">
          <source>Or try the replaceAll function from here:</source>
          <target state="translated">Или попробуйте функцию replaceAll отсюда:</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="958af61f062ee06d08e8952efd18380494a6a4d9" translate="yes" xml:space="preserve">
          <source>RangeError: Maximum call stack size exceeded</source>
          <target state="translated">RangeError:Максимальный размер стека вызовов превышен</target>
        </trans-unit>
        <trans-unit id="516ae82c40ff23ca1cf1e9b09339a27d789eeb76" translate="yes" xml:space="preserve">
          <source>Regular Expression Based Implementation</source>
          <target state="translated">Регулярное осуществление на основе экспрессии</target>
        </trans-unit>
        <trans-unit id="1927e4338bf5ed5e34ce23c646604727fd370193" translate="yes" xml:space="preserve">
          <source>Replacing single quotes:</source>
          <target state="translated">Замена одиночных кавычек:</target>
        </trans-unit>
        <trans-unit id="8c27bd4109955934b131a097a08e8328d1b30751" translate="yes" xml:space="preserve">
          <source>Revised jsperf</source>
          <target state="translated">Пересмотренный шрифт</target>
        </trans-unit>
        <trans-unit id="a3ae420dc94cd8628e9445b30f38b89f9b7e87c7" translate="yes" xml:space="preserve">
          <source>Say you want to replace all the 'abc' with 'x':</source>
          <target state="translated">Скажи,что хочешь заменить все 'abc' на 'x':</target>
        </trans-unit>
        <trans-unit id="b3a0ed02924fa9756353d3b2962c9f868b0376eb" translate="yes" xml:space="preserve">
          <source>See here also</source>
          <target state="translated">См.также здесь</target>
        </trans-unit>
        <trans-unit id="238582b8899c43b60945a04bd423c0787fae81fc" translate="yes" xml:space="preserve">
          <source>Short string - 55 characters</source>
          <target state="translated">Короткая строка-55 символов</target>
        </trans-unit>
        <trans-unit id="4bcb4e163bf193fe874c35e7a1a754e4ed2bd51c" translate="yes" xml:space="preserve">
          <source>Show code snippet</source>
          <target state="translated">Показать фрагмент кода</target>
        </trans-unit>
        <trans-unit id="afc3390a44e6d9658b7dbfc2d9192fef4d5122cc" translate="yes" xml:space="preserve">
          <source>So in order to make the &lt;code&gt;replaceAll()&lt;/code&gt; function above safer, it could be modified to the following if you also include &lt;code&gt;escapeRegExp&lt;/code&gt;:</source>
          <target state="translated">Таким образом, чтобы сделать &lt;code&gt;replaceAll()&lt;/code&gt; приведенную выше, более безопасной, ее можно изменить следующим образом, если вы также &lt;code&gt;escapeRegExp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="791f26db7f076b3fe806fedb1dfdd01bdfaabb50" translate="yes" xml:space="preserve">
          <source>Solutions based on &lt;code&gt;split-join&lt;/code&gt; (&lt;strong&gt;A,B&lt;/strong&gt;) or &lt;code&gt;replace&lt;/code&gt; (&lt;strong&gt;C,D&lt;/strong&gt;) are fast</source>
          <target state="translated">Решения, основанные на &lt;code&gt;split-join&lt;/code&gt; ( &lt;strong&gt;A, B&lt;/strong&gt; ) или &lt;code&gt;replace&lt;/code&gt; ( &lt;strong&gt;C, D&lt;/strong&gt; ), являются быстрыми</target>
        </trans-unit>
        <trans-unit id="64a7df9d3528430f1d064d94dcd7ce12360a8b65" translate="yes" xml:space="preserve">
          <source>Solutions based on &lt;code&gt;while&lt;/code&gt; (&lt;strong&gt;E,F,G,H&lt;/strong&gt;) are slow - usually ~4 times slower for small strings and about ~3000 times (!) slower for long strings</source>
          <target state="translated">Решения, основанные на &lt;code&gt;while&lt;/code&gt; ( &lt;strong&gt;E, F, G, H&lt;/strong&gt; ), медленны - обычно в ~ 4 раза медленнее для маленьких строк и примерно в 3000 раз (!) Медленнее для длинных строк</target>
        </trans-unit>
        <trans-unit id="c5f617985382ce2f6b1ad5a88716ff377cafb216" translate="yes" xml:space="preserve">
          <source>Split and Join (Functional) Implementation</source>
          <target state="translated">Раздельное и совместное (функциональное)внедрение</target>
        </trans-unit>
        <trans-unit id="3f262f9b42c014ce513b61f570042ee408a6ccbe" translate="yes" xml:space="preserve">
          <source>The 'replaceAll' method is added to String's prototype. This means it will be available for all string objects/literals.</source>
          <target state="translated">Метод 'replaceAll' добавлен в прототип String.Это означает,что он будет доступен для всех строковых объектов-литералов.</target>
        </trans-unit>
        <trans-unit id="70a3c41c6145b1073780fd66e0a5961a9f9d085d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;str.replace(/abc/g, '');&lt;/code&gt; (&lt;strong&gt;C&lt;/strong&gt;) is a good cross-browser fast solution for all strings.</source>
          <target state="translated">&lt;code&gt;str.replace(/abc/g, '');&lt;/code&gt; ( &lt;strong&gt;C&lt;/strong&gt; ) - это хорошее кросс-браузерное быстрое решение для всех строк.</target>
        </trans-unit>
        <trans-unit id="6862722646db89bf527d4db5a4180543b94a8268" translate="yes" xml:space="preserve">
          <source>The general pattern is</source>
          <target state="translated">Общая закономерность заключается в том,что</target>
        </trans-unit>
        <trans-unit id="ad15bf1a90e5b964105fd6d24685320af721a361" translate="yes" xml:space="preserve">
          <source>The output is the same as the accepted answer, however, using the /cat/g expression on this string:</source>
          <target state="translated">Вывод такой же,как и принятый ответ,но с использованием выражения catg в этой строке:</target>
        </trans-unit>
        <trans-unit id="500d5673e29a623bf205aac14d021c9e4584c6d7" translate="yes" xml:space="preserve">
          <source>The previous answers are way too complicated. Just use the replace function like this:</source>
          <target state="translated">Предыдущие ответы слишком сложны.Просто используйте функцию замены вот так:</target>
        </trans-unit>
        <trans-unit id="3edf210ac416af9397656481643d3200184bbd0a" translate="yes" xml:space="preserve">
          <source>The recurrence solutions (&lt;strong&gt;RA,RB&lt;/strong&gt;) are slow and do not work for long strings</source>
          <target state="translated">Рекуррентные решения ( &lt;strong&gt;RA, RB&lt;/strong&gt; ) являются медленными и не работают для длинных строк</target>
        </trans-unit>
        <trans-unit id="50bd0e425afb39661b9eb4e9f39fd4b4493a5609" translate="yes" xml:space="preserve">
          <source>The recursive solutions &lt;strong&gt;RA&lt;/strong&gt; and &lt;strong&gt;RB&lt;/strong&gt; gives</source>
          <target state="translated">Рекурсивные решения &lt;strong&gt;РА&lt;/strong&gt; и &lt;strong&gt;РБ&lt;/strong&gt; дает</target>
        </trans-unit>
        <trans-unit id="369989b3729604fa9987753462bbbf349899d07e" translate="yes" xml:space="preserve">
          <source>The simplest loop to solve this would be:</source>
          <target state="translated">Самый простой цикл для решения этой проблемы:</target>
        </trans-unit>
        <trans-unit id="03772ccff926aef82feb6ee59ca395521b306264" translate="yes" xml:space="preserve">
          <source>The simplest way to this without using any regex is split and join like the code here:</source>
          <target state="translated">Самый простой способ сделать это без использования регекса-разделить и соединить как код здесь:</target>
        </trans-unit>
        <trans-unit id="e03cd7383682fc6d72d2b9f15ccd635f4298117f" translate="yes" xml:space="preserve">
          <source>The tests were performed on Chrome 79.0, Safari 13.0.4 and Firefox 71.0 (64 bit). The tests &lt;code&gt;RA&lt;/code&gt; and &lt;code&gt;RB&lt;/code&gt; use recursion. Results</source>
          <target state="translated">Тесты проводились на Chrome 79.0, Safari 13.0.4 и Firefox 71.0 (64 бит). Тесты &lt;code&gt;RA&lt;/code&gt; и &lt;code&gt;RB&lt;/code&gt; используют рекурсию. Результаты</target>
        </trans-unit>
        <trans-unit id="a9311a98961911f95ad2bd5e24444545ee47566a" translate="yes" xml:space="preserve">
          <source>There is another jsperf with variants on my recursive replace that go even faster (&lt;a href=&quot;http://jsperf.com/replace-all-vs-split-join/12&quot;&gt;http://jsperf.com/replace-all-vs-split-join/12&lt;/a&gt;)!</source>
          <target state="translated">На моей рекурсивной замене есть еще один jsperf с вариантами, которые идут еще быстрее ( &lt;a href=&quot;http://jsperf.com/replace-all-vs-split-join/12&quot;&gt;http://jsperf.com/replace-all-vs-split-join/12&lt;/a&gt; )!</target>
        </trans-unit>
        <trans-unit id="16225ef62710b40df18181fe23a2e790ba51aaf9" translate="yes" xml:space="preserve">
          <source>These are the most common and readable methods.</source>
          <target state="translated">Это наиболее распространенные и читаемые методы.</target>
        </trans-unit>
        <trans-unit id="df35a931ffe321873755cadd3104fa2c6ab5abc1" translate="yes" xml:space="preserve">
          <source>This can be particularly useful when looking for duplicate strings.</source>
          <target state="translated">Это может быть особенно полезно при поиске дубликатов строк.</target>
        </trans-unit>
        <trans-unit id="367dab6a1825fbf327c5342ee35812bde1eec73e" translate="yes" xml:space="preserve">
          <source>This is a simple regex that avoids replacing parts of words in most cases. However, a dash &lt;code&gt;-&lt;/code&gt; is still considered a word boundary. So conditionals can be used in this case to avoid replacing strings like &lt;code&gt;cool-cat&lt;/code&gt;:</source>
          <target state="translated">Это простое регулярное выражение, которое в большинстве случаев избегает замены частей слов. Тем не менее, тире &lt;code&gt;-&lt;/code&gt; все еще считается границей слова. Таким образом, в этом случае можно использовать условные выражения, чтобы избежать замены строк, таких как &lt;code&gt;cool-cat&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c02562e1f6d4a5cbf736a7b0837cb984e69786fd" translate="yes" xml:space="preserve">
          <source>This is the &lt;strong&gt;fastest&lt;/strong&gt; version that &lt;em&gt;doesn't use regular expressions&lt;/em&gt;.</source>
          <target state="translated">Это самая &lt;strong&gt;быстрая&lt;/strong&gt; версия, &lt;em&gt;которая не использует регулярные выражения&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="ba6f081fdf243a403bac2ba3cf8f0fdee154766a" translate="yes" xml:space="preserve">
          <source>This used to be faster in some cases than using &lt;code&gt;replaceAll&lt;/code&gt; and a regular expression, but that doesn't seem to be the case anymore in modern browsers.</source>
          <target state="translated">Раньше в некоторых случаях это было быстрее, чем с использованием &lt;code&gt;replaceAll&lt;/code&gt; и регулярного выражения, но в современных браузерах это больше не так.</target>
        </trans-unit>
        <trans-unit id="c06e71ba6500c4e97fef51f00b081079208d8af6" translate="yes" xml:space="preserve">
          <source>Today 27.12.2019 I perform tests on &lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; (High Sierra) for the chosen solutions.</source>
          <target state="translated">Сегодня 27.12.2019 я выполняю тесты на &lt;a href=&quot;https://en.wikipedia.org/wiki/MacOS_High_Sierra&quot;&gt;macOS v10.13.6&lt;/a&gt; (High Sierra) для выбранных решений.</target>
        </trans-unit>
        <trans-unit id="8f10ddde05bf54e0d639e76139d9d0182eb95a01" translate="yes" xml:space="preserve">
          <source>Update July 27th 2017: It looks like RegExp now has the fastest performance in the recently released Chrome 59.</source>
          <target state="translated">Обновление 27 июля 2017 года:Похоже,что у RegExp теперь самая быстрая производительность в недавно выпущенном Chrome 59.</target>
        </trans-unit>
        <trans-unit id="4bcac541a8c7f79ba50a38a8988ad2f783681ee0" translate="yes" xml:space="preserve">
          <source>Use a regular expression:</source>
          <target state="translated">Используйте регулярное выражение:</target>
        </trans-unit>
        <trans-unit id="c2aee7f5722611179e110f5e6d7da49f02ff7c59" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;RegExp&lt;/code&gt; in &lt;strong&gt;JavaScript&lt;/strong&gt; could do the job for you, just simply do something like below code, don't forget the &lt;code&gt;/g&lt;/code&gt; after which standout for &lt;strong&gt;global&lt;/strong&gt;:</source>
          <target state="translated">Использование &lt;code&gt;RegExp&lt;/code&gt; в &lt;strong&gt;JavaScript&lt;/strong&gt; может помочь вам, просто сделайте что-то наподобие приведенного ниже кода, не забывайте &lt;code&gt;/g&lt;/code&gt; , после которого выделяется &lt;strong&gt;глобальное&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="9da6ee93a958af3f2a1cebcc0f2590371d8cb6b8" translate="yes" xml:space="preserve">
          <source>Using a regular expression with the &lt;code&gt;g&lt;/code&gt; flag set will replace all:</source>
          <target state="translated">Использование регулярного выражения с установленным флагом &lt;code&gt;g&lt;/code&gt; заменит все:</target>
        </trans-unit>
        <trans-unit id="09b3286eff56349c39d102a1b366232dba4e9210" translate="yes" xml:space="preserve">
          <source>We could call &lt;code&gt;escapeRegExp&lt;/code&gt; within our &lt;code&gt;String.prototype.replaceAll&lt;/code&gt; implementation, however, I'm not sure how much this will affect the performance (potentially even for strings for which the escape is not needed, like all alphanumeric strings).</source>
          <target state="translated">Мы могли бы вызвать &lt;code&gt;escapeRegExp&lt;/code&gt; в нашей реализации &lt;code&gt;String.prototype.replaceAll&lt;/code&gt; , однако я не уверен, насколько это повлияет на производительность (потенциально даже для строк, для которых экранирование не требуется, как для всех буквенно-цифровых строк).</target>
        </trans-unit>
        <trans-unit id="00df80bf98961b338c936f71eb4491af5d4e6cd7" translate="yes" xml:space="preserve">
          <source>What are useful JavaScript methods that extends built-in objects?</source>
          <target state="translated">Какие полезные методы JavaScript расширяют встроенные объекты?</target>
        </trans-unit>
        <trans-unit id="59826ff0dcdf2c8ff1dc7d8cb137e9a83b75e3ba" translate="yes" xml:space="preserve">
          <source>When complete, you will still have 'test abc'!</source>
          <target state="translated">Когда все будет готово,у тебя все еще будет &quot;тест аббревиатуры&quot;!</target>
        </trans-unit>
        <trans-unit id="7413bc6dfd6712412a62d33b6ad98978fda494ef" translate="yes" xml:space="preserve">
          <source>You can refer the detailed example &lt;a href=&quot;http://www.cheezycode.com/2015/08/javascript-hacks-for-html-webpage.html&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Вы можете сослаться на подробный пример &lt;a href=&quot;http://www.cheezycode.com/2015/08/javascript-hacks-for-html-webpage.html&quot;&gt;здесь&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14612ebec52e07519f5df0000794a2c86ea5a2ed" translate="yes" xml:space="preserve">
          <source>You can run tests on your machine &lt;a href=&quot;https://jsperf.com/remove-substring-small/1&quot;&gt;HERE&lt;/a&gt;. Results for Chrome:</source>
          <target state="translated">Вы можете запустить тесты на своем компьютере &lt;a href=&quot;https://jsperf.com/remove-substring-small/1&quot;&gt;ЗДЕСЬ&lt;/a&gt; . Результаты для Chrome:</target>
        </trans-unit>
        <trans-unit id="d80d16d89e43a7516fb2dee5f412114891576996" translate="yes" xml:space="preserve">
          <source>You can simply use below method</source>
          <target state="translated">Вы можете просто использовать нижеприведенный метод</target>
        </trans-unit>
        <trans-unit id="28905875c9209baab59de2b80e072d7fc36fde6e" translate="yes" xml:space="preserve">
          <source>[In that case, one could do .replace(/,+/g,','), but at some point the regex gets complex and slow enough to loop instead.]</source>
          <target state="translated">[В этом случае можно было бы сделать .replace(,+g,','),но в какой-то момент регекс становится сложным и достаточно медленным,чтобы вместо этого зациклиться].</target>
        </trans-unit>
        <trans-unit id="1aecada00183a6ff5ec2d92396d46a8c0ae9f7e9" translate="yes" xml:space="preserve">
          <source>and simply use it in your code over and over like below:</source>
          <target state="translated">и просто используйте его в своем коде снова и снова,как показано ниже:</target>
        </trans-unit>
        <trans-unit id="cc4acdb915a5e6e90d0ec0a00fa9a185d964911a" translate="yes" xml:space="preserve">
          <source>basically, this question is the same as the question here:
&lt;a href=&quot;https://stackoverflow.com/questions/9499075/javascript-replace-with/9499926&quot;&gt;Javascript replace &quot; ' &quot; with &quot; '' &quot;&lt;/a&gt;</source>
          <target state="translated">в основном, этот вопрос такой же, как и здесь: &lt;a href=&quot;https://stackoverflow.com/questions/9499075/javascript-replace-with/9499926&quot;&gt;Javascript заменяет &amp;laquo;&amp;raquo; на &amp;laquo;&amp;raquo;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a0d24cf1b244ef65eac88d415645e906ecf67ee0" translate="yes" xml:space="preserve">
          <source>seems to only remove the first occurrence of &lt;code&gt;abc&lt;/code&gt; in the string above.</source>
          <target state="translated">кажется, только удалить первое вхождение &lt;code&gt;abc&lt;/code&gt; в строке выше.</target>
        </trans-unit>
        <trans-unit id="4374aaee247fb237ce6c97d5c8d64bbe474d16de" translate="yes" xml:space="preserve">
          <source>to</source>
          <target state="translated">to</target>
        </trans-unit>
        <trans-unit id="f57ca77c39afa4ad77c7b0cbdd76aaef04834b2b" translate="yes" xml:space="preserve">
          <source>worked better for me than the above answers. so &lt;code&gt;new RegExp(&quot;abc&quot;, 'g')&lt;/code&gt; creates a RegExp what matches all occurence (&lt;code&gt;'g'&lt;/code&gt; flag) of the text (&lt;code&gt;&quot;abc&quot;&lt;/code&gt;). The second part is what gets replaced to, in your case empty string (&lt;code&gt;&quot;&quot;&lt;/code&gt;).
&lt;code&gt;str&lt;/code&gt; is the string, and we have to override it, as &lt;code&gt;replace(...)&lt;/code&gt; just returns result, but not overrides. In some cases you might want to use that.</source>
          <target state="translated">работал лучше для меня, чем приведенные выше ответы. поэтому &lt;code&gt;new RegExp(&quot;abc&quot;, 'g')&lt;/code&gt; создает RegExp, который соответствует всему вхождению (флаг &lt;code&gt;'g'&lt;/code&gt; ) текста ( &lt;code&gt;&quot;abc&quot;&lt;/code&gt; ). Вторая часть - это то, что заменяется, в вашем случае пустой строкой ( &lt;code&gt;&quot;&quot;&lt;/code&gt; ). &lt;code&gt;str&lt;/code&gt; - строка, и мы должны переопределить ее, так как &lt;code&gt;replace(...)&lt;/code&gt; просто возвращает результат, но не переопределяет. В некоторых случаях вы можете использовать это.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
