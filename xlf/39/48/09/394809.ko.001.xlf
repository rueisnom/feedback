<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/394809">
    <body>
      <group id="394809">
        <trans-unit id="70ab045269befc703f5853d363741cd4809122f9" translate="yes" xml:space="preserve">
          <source>(execution delayed until the winner is known ;)), but it introduces inconsistency between callable and non-callable objects. In addition, it doesn't solve the case when using properties.</source>
          <target state="translated">(승자가 알려질 때까지 실행이 지연됩니다.)) 호출 가능 오브젝트와 호출 불가능 오브젝트 사이에 불일치가 발생합니다. 또한 속성을 사용할 때 경우를 해결하지 못합니다.</target>
        </trans-unit>
        <trans-unit id="8cb713133a6c1d41da9b697de8bb604304078011" translate="yes" xml:space="preserve">
          <source>, becomes:</source>
          <target state="translated">다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="40f40c03a1271b3952ed519b50c12fd149dc92e6" translate="yes" xml:space="preserve">
          <source>1- Simple Method to use ternary operator:</source>
          <target state="translated">1- 삼항 연산자를 사용하는 간단한 방법 :</target>
        </trans-unit>
        <trans-unit id="d848fcf366a8ef37a8ff9e843fba0d9be57b73fb" translate="yes" xml:space="preserve">
          <source>2- Direct Method of using tuples, Dictionary, and lambda:</source>
          <target state="translated">2- 튜플, 사전 및 람다를 사용하는 직접 방법 :</target>
        </trans-unit>
        <trans-unit id="1aae16e227a970760713cda0dda545cb5d3699fe" translate="yes" xml:space="preserve">
          <source>3- Ternary operator can be written as nested if-else:</source>
          <target state="translated">3- 삼항 연산자는 중첩 된 if-else로 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="044a950e94c378180ffa7793e1030478e33e33d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression1&lt;/code&gt; will have to be evaluated twice with the above usage. It can limit redundancy if it is simply a local variable. However, a common and performant Pythonic idiom for this use-case is to use &lt;code&gt;or&lt;/code&gt;'s shortcutting behavior:</source>
          <target state="translated">위의 사용법으로 &lt;code&gt;expression1&lt;/code&gt; 을 두 번 평가해야합니다. 단순히 로컬 변수 인 경우 중복성을 제한 할 수 있습니다. 그러나이 유스 케이스에 대해 일반적이고 성능이 뛰어난 파이썬 이디엄은 다음과 같은 단축키 동작을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="334c175549b49453b828bca8b2a67a5cca8af5cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression2&lt;/code&gt; works as a filter for the list comprehension, and is &lt;em&gt;not&lt;/em&gt; a ternary conditional operator.</source>
          <target state="translated">&lt;code&gt;expression2&lt;/code&gt; 는 목록 이해를위한 필터로 작동하며 삼항 조건 연산자가 &lt;em&gt;아닙니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5dab472beecae7e7e8dfecfe05a0c2d9f3e3ecd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression3&lt;/code&gt; will be lazily evaluated (that is, evaluated only if &lt;code&gt;expression2&lt;/code&gt; is false in a boolean context). And because of the recursive definition, you can chain them indefinitely (though it may considered bad style.)</source>
          <target state="translated">&lt;code&gt;expression3&lt;/code&gt; 은 느리게 평가됩니다 (즉, 부울 컨텍스트에서 &lt;code&gt;expression2&lt;/code&gt; 가 false 인 경우에만 평가됨). 그리고 재귀 적 정의 때문에, 그것들을 무기한으로 연결할 수 있습니다 (불량한 스타일로 간주 될 수 있습니다).</target>
        </trans-unit>
        <trans-unit id="29c4f62bef87062fb6570c3ab3b8996c0383d73f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test&lt;/code&gt; needs to return &lt;em&gt;True&lt;/em&gt; or &lt;em&gt;False&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 는 &lt;em&gt;True&lt;/em&gt; 또는 &lt;em&gt;False&lt;/em&gt; 를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="3fae46c5ec8c22f65a6e958eb8f75ef995296321" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A neat way to chain multiple operators:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;여러 연산자를 연결하는 깔끔한 방법 :&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a301bfe415904b8134c76d76fa61ec8147dc8ee2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary Operator in Javascript&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;자바 스크립트의 삼항 연산자&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa49ba0541262da7d41f0f4081422b0ba2554c7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary Operator in Ruby&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;루비의 삼항 연산자&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35cb1a58f55a6ac1ac6b936dfb825e64d5a5f996" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary operator in Python&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;파이썬의 삼항 연산자&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1a00fe97ba444ce4af43b0aa2eb087ce13ccd36" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary operator in R programming&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;R 프로그래밍의 3 진 연산자&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f11633b413a20a2ad39481a598a7473cdd7868d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary operator in Scala&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;스칼라의 3 차 연산자&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57ae2a1bc4b2cd461a9d0deedcd0dc94cde72aef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;[condition] and [expression_1] or [expression_2] ;&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;[condition] and [expression_1] or [expression_2] ;&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c135775097dd01254c74e73b8797ce9763f03653" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case you still want to make it work for all the cases regardless of what exp_1 and exp_2 truth values are, do this :-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;exp_1 및 exp_2 true 값이 무엇이든 관계없이 모든 경우에 여전히 작동하게하려면 다음을 수행하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f445f66b4684e3ca1e89dff63c6cf9c6b9a2085" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note :-&lt;/strong&gt; 0 , None , False , emptylist , emptyString evaluates as False.
And any data other than 0 evaluates to True.</source>
          <target state="translated">&lt;strong&gt;참고 :&lt;/strong&gt; -0, None, False, emptylist, emptyString은 False로 평가됩니다. 그리고 0 이외의 데이터는 True로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="8904df4a64a6f105d991168d30a94c94e66eb44d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:-&lt;/strong&gt; This kind of branching using &quot;or&quot; and &quot;and&quot; can only be used when the expression_1 doesn't have a Truth value of False (or 0 or None or emptylist [ ] or emptystring ' '.) since if expression_1 becomes False , then the expression_2 will be evaluated because of the presence &quot;or&quot; between exp_1 and exp_2.</source>
          <target state="translated">&lt;strong&gt;참고 :-&lt;/strong&gt; &quot;or&quot;및 &quot;and&quot;를 사용하는 이런 종류의 분기는 expression_1이 False (또는 0 또는 None 또는 emptylist [] 또는 emptystring '')가 아닌 경우 expression_1이되는 경우에만 사용할 수 있습니다. False이면 exp_1과 exp_2 사이의 &quot;또는&quot;존재로 인해 expression_2가 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="93c71edf58c5ab505268c88d73e083ab4ff69b1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ternary Operator in different programming Languages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;다른 프로그래밍 언어의 삼항 연산자&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0082dd6b907a273d541b44f98e346b6ffade9988" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result :-&lt;/strong&gt;  If condition is true exp_1 is executed else exp_2 is executed.</source>
          <target state="translated">&lt;strong&gt;결과 :-&lt;/strong&gt; 조건이 참이면 exp_1이 실행되고 그렇지 않으면 exp_2가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5d726f2ccbdf4ef2112e79b46394efd7a26bdb15" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;1. &lt;a href=&quot;http://docs.python.org/3.3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator&quot;&gt;Is there an equivalent of C&amp;rsquo;s &amp;rdquo;?:&amp;rdquo; ternary operator?&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;1. &lt;a href=&quot;http://docs.python.org/3.3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator&quot;&gt;C의 &quot;? :&quot;삼항 연산자에 해당하는 것이 있습니까?&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="0bdf2155f1318aca0a1e6ff9bab81d9a15d7e099" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Source: &lt;a href=&quot;https://en.wikipedia.org/wiki/%3F:#Python&quot;&gt;?: in Python at Wikipedia&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;출처 : &lt;a href=&quot;https://en.wikipedia.org/wiki/%3F:#Python&quot;&gt;? : Wikipedia의 Python&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="47137144ef43e236132e42d4c3cd332e4cc3ec7f" translate="yes" xml:space="preserve">
          <source>A note on usage:</source>
          <target state="translated">사용법에 대한 참고 사항 :</target>
        </trans-unit>
        <trans-unit id="9d0a430e9f1e437bba549167d60e32cd4b925015" translate="yes" xml:space="preserve">
          <source>A possible workaround is to make &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; lists or tuples as in the following:</source>
          <target state="translated">가능한 해결 방법은 다음과 같이 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 목록 또는 튜플을 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fe56c5e5a4d9f35e186ec5eb03b16ba91ecd7267" translate="yes" xml:space="preserve">
          <source>Above approach can be written as:</source>
          <target state="translated">위의 접근 방식은 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa5bb41606c2c5c53748e18b932c8d70cf7312ab" translate="yes" xml:space="preserve">
          <source>Additional information:</source>
          <target state="translated">추가 정보:</target>
        </trans-unit>
        <trans-unit id="f9cce9f391b0f087eec06d00b08402a5a533e1df" translate="yes" xml:space="preserve">
          <source>Alternative syntax for a more narrow case:</source>
          <target state="translated">더 좁은 경우에 대한 대체 구문 :</target>
        </trans-unit>
        <trans-unit id="4c7eaa8bf582781c438a6973636b946051d550a6" translate="yes" xml:space="preserve">
          <source>Although it does have the benefit of evaluating expressions left to right, which is clearer in my opinion.</source>
          <target state="translated">왼쪽에서 오른쪽으로 표현을 평가하는 이점이 있지만 내 의견으로는 더 명확합니다.</target>
        </trans-unit>
        <trans-unit id="4243fff9331bddbb87ee3995bde3a9f8c62ecdf0" translate="yes" xml:space="preserve">
          <source>An operator for a conditional expression in Python was added in 2006 as part of &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;Python Enhancement Proposal 308&lt;/a&gt;. Its form differ from common &lt;code&gt;?:&lt;/code&gt; operator and it's:</source>
          <target state="translated">Python의 조건부 표현식 연산자는 2006 년 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;Python Enhancement Proposal 308의&lt;/a&gt; 일부로 추가되었습니다. 형식은 일반적인 &lt;code&gt;?:&lt;/code&gt; 연산자와 다르며 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6d802d348de05c371872aaa136e43ae4790bb661" translate="yes" xml:space="preserve">
          <source>And so the story goes - choosing between 3 mentioned solutions is a trade-off between having the short-circuit feature, using at least Зython 2.5 (IMHO not a problem anymore) and not being prone to &quot;&lt;code&gt;trueValue&lt;/code&gt;-evaluates-to-false&quot; errors.</source>
          <target state="translated">그리고 이야기는 계속됩니다. 언급 된 3 가지 솔루션 중에서 선택하는 것은 최소한 Зython 2.5 (더 이상 문제가되지 않음)를 사용하고 &quot; &lt;code&gt;trueValue&lt;/code&gt; -false -to-false&quot;가 발생하지 않는 단락 기능을 갖는 것 사이의 절충입니다. 오류.</target>
        </trans-unit>
        <trans-unit id="9db147c5133a121c92efce9f531259e88a815251" translate="yes" xml:space="preserve">
          <source>Another (less reliable), but simpler method is to use &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators:</source>
          <target state="translated">신뢰성이 떨어지지 만 신뢰할 수있는 또 다른 방법은 &lt;code&gt;and&lt;/code&gt; 및 &lt;code&gt;or&lt;/code&gt; 연산자를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f29869a5fb045eacca16998a249d59fe4a1ef72e" translate="yes" xml:space="preserve">
          <source>Another syntax which can be used (compatible with versions before 2.5):</source>
          <target state="translated">사용할 수있는 다른 구문 (2.5 이전 버전과 호환 가능) :</target>
        </trans-unit>
        <trans-unit id="6ede496e52093534454faa827678b96dc14a0bde" translate="yes" xml:space="preserve">
          <source>Another way is by indexing a tuple (which isn't consistent with the conditional operator of most other languages):</source>
          <target state="translated">또 다른 방법은 튜플을 인덱싱하는 것입니다 (대부분의 다른 언어의 조건 연산자와 일치하지 않음).</target>
        </trans-unit>
        <trans-unit id="e5d8acdf91b2bad1764fb5d525bdb392c6e78228" translate="yes" xml:space="preserve">
          <source>As already answered, yes there is a ternary operator in python:</source>
          <target state="translated">이미 대답했듯이, 파이썬에는 삼항 연산자가 있습니다.</target>
        </trans-unit>
        <trans-unit id="10eeb6250c3d1364e2b4a11d28ce4b006bc96176" translate="yes" xml:space="preserve">
          <source>At first, the &lt;code&gt;Python&lt;/code&gt;&lt;strong&gt;B&lt;/strong&gt;enevolent &lt;strong&gt;D&lt;/strong&gt;ictator &lt;strong&gt;F&lt;/strong&gt;or &lt;strong&gt;L&lt;/strong&gt;ife (I mean Guido van Rossum, of course) rejected it (as non-Pythonic style), since it's quite hard to understand for people not used to &lt;code&gt;C&lt;/code&gt; language. Also, the colon sign &lt;strong&gt;&lt;code&gt;:&lt;/code&gt;&lt;/strong&gt; already has many uses in &lt;code&gt;Python&lt;/code&gt;. After &lt;strong&gt;PEP 308&lt;/strong&gt; was approved, &lt;code&gt;Python&lt;/code&gt; finally received its own shortcut conditional expression (what we use now):</source>
          <target state="translated">처음에 &lt;code&gt;Python&lt;/code&gt; &lt;strong&gt;B의&lt;/strong&gt; 독창적 인 독재자 &lt;strong&gt;F&lt;/strong&gt; 또는 &lt;strong&gt;L&lt;/strong&gt; ife (물론 Guido van Rossum을 의미합니다)는 &lt;code&gt;C&lt;/code&gt; 언어에 익숙하지 않은 사람들에게는 이해하기가 어렵 기 때문에 (Pyonic 스타일이 아닌) 거부했습니다. 또한 콜론 부호 &lt;strong&gt; &lt;code&gt;:&lt;/code&gt; &lt;/strong&gt; 이미 &lt;code&gt;Python&lt;/code&gt; 에서 많은 용도가 있습니다. &lt;strong&gt;PEP 308&lt;/strong&gt; 이 승인 된 후, &lt;code&gt;Python&lt;/code&gt; 마침내 자신 만의 단축키 조건식을 받았습니다 (현재 사용하는 것) :</target>
        </trans-unit>
        <trans-unit id="dd29e09af960c8454a520e8b4d704fdf79a455d7" translate="yes" xml:space="preserve">
          <source>Below is the ternary form. But this isn't most succinct way - see last example.</source>
          <target state="translated">아래는 삼항 형식입니다. 그러나 이것은 가장 간결한 방법은 아닙니다. 마지막 예를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="54ab93ad34df3c1e05aa8130fd92ecad93172607" translate="yes" xml:space="preserve">
          <source>But in case of</source>
          <target state="translated">그러나</target>
        </trans-unit>
        <trans-unit id="e428c12fd355944b5e6b7023bd80dd3c17b5aee5" translate="yes" xml:space="preserve">
          <source>Conditional expressions</source>
          <target state="translated">조건식</target>
        </trans-unit>
        <trans-unit id="53209a5d3bcb5ef6226a6a63af2411fb4329ea1a" translate="yes" xml:space="preserve">
          <source>Conditional expressions (sometimes called a &amp;ldquo;ternary operator&amp;rdquo;) have the lowest priority of all Python operations.</source>
          <target state="translated">조건식 (때때로 &quot;삼항 연산자&quot;라고도 함)은 모든 Python 작업의 우선 순위가 가장 낮습니다.</target>
        </trans-unit>
        <trans-unit id="43e7ce9b3100f9c4cee6083bc0c5c0ecc62fe1d3" translate="yes" xml:space="preserve">
          <source>Does Python have a ternary conditional operator</source>
          <target state="translated">파이썬에는 삼항 조건 연산자가 있습니까?</target>
        </trans-unit>
        <trans-unit id="1a6fd40c1dc466260f6a3434319de40a40079b42" translate="yes" xml:space="preserve">
          <source>Does Python have a ternary conditional operator?</source>
          <target state="translated">파이썬에는 삼항 조건 연산자가 있습니까?</target>
        </trans-unit>
        <trans-unit id="08ec689e9d96535ecd7d37b8542dacd3113a01d8" translate="yes" xml:space="preserve">
          <source>Example:-</source>
          <target state="translated">Example:-</target>
        </trans-unit>
        <trans-unit id="f67e732e29a09166934752e7537614b263f98276" translate="yes" xml:space="preserve">
          <source>First &lt;code&gt;condition&lt;/code&gt; is evaluated, then exactly one of either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is evaluated and returned based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;Boolean&lt;/a&gt; value of &lt;code&gt;condition&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; evaluates to &lt;code&gt;True&lt;/code&gt;, then &lt;code&gt;a&lt;/code&gt; is evaluated and returned but &lt;code&gt;b&lt;/code&gt; is ignored, or else when &lt;code&gt;b&lt;/code&gt; is evaluated and returned but &lt;code&gt;a&lt;/code&gt; is ignored.</source>
          <target state="translated">첫 번째 &lt;code&gt;condition&lt;/code&gt; 이 평가 된 다음 condition 의 &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;부울&lt;/a&gt; 값에 따라 &lt;code&gt;b&lt;/code&gt; 또는 b 중 하나가 정확하게 평가 및 반환 &lt;code&gt;condition&lt;/code&gt; . &lt;code&gt;condition&lt;/code&gt; 이 &lt;code&gt;True&lt;/code&gt; 로 평가되면 &lt;code&gt;a&lt;/code&gt; 가 평가되어 리턴되지만 &lt;code&gt;b&lt;/code&gt; 가 무시되거나 &lt;code&gt;b&lt;/code&gt; 가 평가되어 리턴되었지만 &lt;code&gt;a&lt;/code&gt; 가 무시 될 때 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="e65f8fce57a4328cfd936e7c997b733995619b23" translate="yes" xml:space="preserve">
          <source>For Python 2.5 and newer there is a specific syntax:</source>
          <target state="translated">Python 2.5 이상에는 구체적인 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">예를 들어</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="73ed66c8963b3d8dd7afa66295f9854e375e8607" translate="yes" xml:space="preserve">
          <source>For versions prior to 2.5, there's the trick:</source>
          <target state="translated">2.5 이전 버전의 경우 트릭이 있습니다.</target>
        </trans-unit>
        <trans-unit id="92945ac06e73038a2bde16da80172b032aba2bb3" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#conditional-expressions&quot;&gt;the documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#conditional-expressions&quot;&gt;설명서에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="05e2cc02796cc541f46aedf7a50bc4121d7e8342" translate="yes" xml:space="preserve">
          <source>Here I just try to show some important difference in &lt;code&gt;ternary operator&lt;/code&gt; between a couple of programming languages.</source>
          <target state="translated">여기서는 몇 가지 프로그래밍 언어 사이의 &lt;code&gt;ternary operator&lt;/code&gt; 에서 중요한 차이점을 보여 주려고합니다.</target>
        </trans-unit>
        <trans-unit id="77a6b125fd3cd1ac92bbf113c153321aee865a77" translate="yes" xml:space="preserve">
          <source>Here are some examples (conditions will be evaluated from left to right):</source>
          <target state="translated">다음은 몇 가지 예입니다 (조건은 왼쪽에서 오른쪽으로 평가됨).</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dcae16de665cdab304c88fb675786b95de0fc2e3" translate="yes" xml:space="preserve">
          <source>Here's how it works:</source>
          <target state="translated">작동 방식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">도움이 되었기를 바랍니다.</target>
        </trans-unit>
        <trans-unit id="37ead08d0a3de9126fb757db960eb29eba55180c" translate="yes" xml:space="preserve">
          <source>I always liked the C ternary syntax, but Python takes it a step further!</source>
          <target state="translated">나는 항상 C 삼항 구문을 좋아했지만 파이썬은 한 걸음 더 나아갑니다!</target>
        </trans-unit>
        <trans-unit id="2fc5c24905a2271acf5a9e03baac33ba14f9bc08" translate="yes" xml:space="preserve">
          <source>I find cumbersome the default python syntax &lt;code&gt;val = a if cond else b&lt;/code&gt;, so sometimes I do this:</source>
          <target state="translated">나는 기본 파이썬 구문 &lt;code&gt;val = a if cond else b&lt;/code&gt; 번거 롭다는 것을 알기 때문에 때로는 이렇게합니다.</target>
        </trans-unit>
        <trans-unit id="2e767bec6a36856af0721a196a27cd634af23fc7" translate="yes" xml:space="preserve">
          <source>I understand that some may say this isn't a good stylistic choice because it relies on mechanics that aren't immediately apparent to all developers. I personally disagree with that viewpoint. Python is a syntax rich language with lots of idiomatic tricks that aren't immediately apparent to the dabler. But the more you learn and understand the mechanics of the underlying system, the more you appreciate it.</source>
          <target state="translated">일부 개발자는 이것이 모든 개발자에게 즉시 드러나지 않는 역학에 의존하기 때문에 이것이 좋은 문체 선택이 아니라고 말할 수도 있습니다. 나는 개인적으로 그 견해에 동의하지 않습니다. 파이썬은 관용구에게 즉시 명백하지 않은 많은 관용적 트릭을 가진 구문이 풍부한 언어입니다. 그러나 기본 시스템의 메커니즘을 더 많이 배우고 이해할수록 더 감사합니다.</target>
        </trans-unit>
        <trans-unit id="4c43044d1cee7d9be8a45db13e7115d6ebb09ae0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;expression 1&amp;gt;&lt;/code&gt; is the condition you can use &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;Short-cirquit evaluation&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;expression 1&amp;gt;&lt;/code&gt; 이 조건 인 경우 &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;Short-cirquit 평가를&lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7b7a1b690cd2aa8c0d47a1a173633ac7de09ad9" translate="yes" xml:space="preserve">
          <source>If Python does not have a ternary conditional operator, is it possible to simulate one using other language constructs?</source>
          <target state="translated">파이썬에 삼항 조건 연산자가 없으면 다른 언어 구문을 사용하여 시뮬레이션 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="0e97f70a139ffcfa1a24114a4591be1fca3125fb" translate="yes" xml:space="preserve">
          <source>If you need to use statements, you have to use a normal &lt;code&gt;if&lt;/code&gt;&lt;strong&gt;statement&lt;/strong&gt; instead of a conditional &lt;strong&gt;expression&lt;/strong&gt;.</source>
          <target state="translated">명령문을 사용해야하는 &lt;code&gt;if&lt;/code&gt; &lt;strong&gt;조건식&lt;/strong&gt; 대신 일반 if &lt;strong&gt;문&lt;/strong&gt; 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0e07fb933f85a6a70d4007baf685896d04ea2e6" translate="yes" xml:space="preserve">
          <source>If you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, &lt;code&gt;x = 4 if b &amp;gt; 8 else 9&lt;/code&gt; is read aloud as &lt;code&gt;x will be 4 if b is greater than 8 otherwise 9&lt;/code&gt;.</source>
          <target state="translated">당신이 명령을 기억하는데 어려움이 있다면, 큰 소리로 읽을 때, 당신이 의미하는 바를 말하십시오. 예를 들어, &lt;code&gt;x will be 4 if b is greater than 8 otherwise 9&lt;/code&gt; &lt;code&gt;x = 4 if b &amp;gt; 8 else 9&lt;/code&gt; 를 큰 소리로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="cd86ff205ecdd4cb29b3e77564370ff6db70909b" translate="yes" xml:space="preserve">
          <source>If you're working with dictionaries, instead of using a ternary conditional, you can take advantage of &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.get&quot;&gt;&lt;code&gt;get(key, default)&lt;/code&gt;&lt;/a&gt;, for example:</source>
          <target state="translated">삼항 조건을 사용하는 대신 사전으로 작업하는 경우 &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.get&quot;&gt; &lt;code&gt;get(key, default)&lt;/code&gt; &lt;/a&gt; 을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="edd7170b76e39c053ddbe154bd719895bd4a908f" translate="yes" xml:space="preserve">
          <source>In older Pythons a ternary operator is not implemented but it's possible to simulate it.</source>
          <target state="translated">오래된 파이썬에서는 삼항 연산자가 구현되지 않았지만 시뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db9e5ecfa73258ca5cc22c532b88ad7d327d52f9" translate="yes" xml:space="preserve">
          <source>Is there an equivalent of C&amp;rsquo;s &amp;rdquo;?:&amp;rdquo; ternary operator?</source>
          <target state="translated">C의 &quot;? :&quot;삼항 연산자에 해당하는 것이 있습니까?</target>
        </trans-unit>
        <trans-unit id="24d3776bac90c9fd5d21c4b1f83deb0e1d687362" translate="yes" xml:space="preserve">
          <source>It can give wrong results when &lt;code&gt;on_true&lt;/code&gt; 
 has a false boolean value.&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;on_true&lt;/code&gt; 에 잘못된 부울 값이 있으면 잘못된 결과를 제공 할 수 있습니다. &lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32c5b1aa401cec0ed9411d5f0dd2d88c4ce21470" translate="yes" xml:space="preserve">
          <source>It is compatible with all Python versions.</source>
          <target state="translated">모든 Python 버전과 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="56172c01602d5c36c8f5eafe5e58f2bda8748700" translate="yes" xml:space="preserve">
          <source>It might be safer to always implement it as:</source>
          <target state="translated">항상 다음과 같이 구현하는 것이 더 안전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13ee33148a661d308d418e7ef1bba7aef5badefa" translate="yes" xml:space="preserve">
          <source>It's very common to need to assign to a variable one value or another depending on a condition.</source>
          <target state="translated">조건에 따라 변수에 하나 이상의 값을 할당해야하는 것이 매우 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="a48cc90e3c4b0a15108ca2d3e639a527ccbd8f3c" translate="yes" xml:space="preserve">
          <source>Just memorize this pyramid if you have trouble remembering:</source>
          <target state="translated">기억하기 어려운 경우이 피라미드를 외우십시오.</target>
        </trans-unit>
        <trans-unit id="b3cab6de298a55b417f1fd7ced11c4f193e7803d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it's frowned upon by some Pythonistas for several reasons:</source>
          <target state="translated">몇 가지 이유로 인해 일부 Pythonistas는 눈살을 찌푸리게됩니다.</target>
        </trans-unit>
        <trans-unit id="ed177662f0634eaaac95ed1a4f31f67c99f0d6e1" translate="yes" xml:space="preserve">
          <source>Knowing this, you can simply such assignments whenever you encounter them. This also works with strings and other iterables. You could assign &lt;code&gt;a&lt;/code&gt; whichever string isn't empty.</source>
          <target state="translated">이것을 알면 언제라도 그러한 과제를 할 수 있습니다. 이것은 문자열 및 기타 반복 가능 항목과도 ​​작동합니다. 비어 있지 않은 문자열을 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cabb6efdc2bfdd697f45c63b9b465ca38dfacae6" translate="yes" xml:space="preserve">
          <source>Many programming languages derived from &lt;code&gt;C&lt;/code&gt; usually have the following syntax of ternary conditional operator:</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 에서 파생 된 많은 프로그래밍 언어에는 일반적으로 다음과 같은 삼항 조건 연산자 구문이 있습니다.</target>
        </trans-unit>
        <trans-unit id="92d6e998ecbbd20e86ffa05b336aa618477dcb98" translate="yes" xml:space="preserve">
          <source>More a tip than an answer (don't need to repeat the obvious for the hundreth time), but I sometimes use it as a oneliner shortcut in such constructs:</source>
          <target state="translated">대답보다 팁이 더 많지만 (이런 시간에 명백한 것을 반복 할 필요는 없지만) 때로는 그러한 구성에서 oneliner 지름길로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4b569996756caea7c12ec127521d9424e8e1be8c" translate="yes" xml:space="preserve">
          <source>New since version 2.5.</source>
          <target state="translated">버전 2.5 이후 새로운 기능.</target>
        </trans-unit>
        <trans-unit id="3c6e31105fa73f62fb4e102f8668ff8f71e6244a" translate="yes" xml:space="preserve">
          <source>Note that conditionals are an &lt;em&gt;expression&lt;/em&gt;, not a &lt;em&gt;statement&lt;/em&gt;. This means you can't use assignment statements or &lt;code&gt;pass&lt;/code&gt; or other &lt;strong&gt;statements&lt;/strong&gt; within a conditional &lt;strong&gt;expression&lt;/strong&gt;:</source>
          <target state="translated">조건은 &lt;em&gt;명령문&lt;/em&gt; 이 아니라 &lt;em&gt;표현식&lt;/em&gt; 입니다. 즉, 조건식 내에서 대 입문이나 &lt;code&gt;pass&lt;/code&gt; 또는 기타 &lt;strong&gt;문을&lt;/strong&gt; 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="479d40d235c43adc3552914b59a66859cc395904" translate="yes" xml:space="preserve">
          <source>Note that every &lt;code&gt;if&lt;/code&gt; must be followed with an &lt;code&gt;else&lt;/code&gt;. People learning list comprehensions and generator expressions may find this to be a difficult lesson to learn - the following will not work, as Python expects a third expression for an else:</source>
          <target state="translated">모든 &lt;code&gt;if&lt;/code&gt; 는 &lt;code&gt;else&lt;/code&gt; 뒤에 와야합니다. 리스트 이해와 생성자 표현을 배우는 사람들은 이것이 배우기 어려운 교훈이라는 것을 알 수 있습니다. 파이썬은 다른 것에 대한 세 번째 표현을 기대하기 때문에 다음은 효과가 없습니다.</target>
        </trans-unit>
        <trans-unit id="5a744d56ca2c69c38476ac01a338fb242c1b6a64" translate="yes" xml:space="preserve">
          <source>Of course, it has the downside of always evaluating both sides (a and b), but the syntax it's way clearer to me</source>
          <target state="translated">물론, 그것은 항상 양쪽 (a와 b)을 평가한다는 단점이 있지만 구문은 나에게 더 명확합니다.</target>
        </trans-unit>
        <trans-unit id="1de3da6e82da1f06b4bf0d8c6161c81558b1aad4" translate="yes" xml:space="preserve">
          <source>Official documentation:</source>
          <target state="translated">공식 문서 :</target>
        </trans-unit>
        <trans-unit id="d0827d89564ba5e83ce93ed7166326488a92a205" translate="yes" xml:space="preserve">
          <source>One of the alternatives to Python's &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;conditional expression&lt;/a&gt;</source>
          <target state="translated">파이썬의 &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;조건식&lt;/a&gt; 에 대한 대안 중 하나</target>
        </trans-unit>
        <trans-unit id="9c4550b9ecd33c573988bea3fd0c8262d2e96e4e" translate="yes" xml:space="preserve">
          <source>One solution to this would be</source>
          <target state="translated">이것에 대한 한 가지 해결책은</target>
        </trans-unit>
        <trans-unit id="7b4b4244be13a3abd69c7140639a3d4f60891f6a" translate="yes" xml:space="preserve">
          <source>PS: Of course, a Short-cirquit evaluation is not a ternary operator but often the ternary is used in cases where the short circuit would be enough.</source>
          <target state="translated">추신 : 물론, 단기 간 평가는 삼항 연산자가 아니지만 단락이 충분할 경우 삼항이 사용되는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="58792d9668c4adc810f2ca241f219f68473b10b3" translate="yes" xml:space="preserve">
          <source>Python has a ternary form for assignments; however there may be even a shorter form that people should be aware of.</source>
          <target state="translated">파이썬은 과제에 대한 삼항 형식을 가지고 있습니다. 그러나 사람들이 알아야 할 짧은 형식이있을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="136139a7ae8963781743317576db7d500d885197" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;PEP 308&lt;/a&gt; for more details about conditional expressions.</source>
          <target state="translated">조건식에 대한 자세한 내용은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;PEP 308&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="036b7b152c8e2ad2d27d64b379952563535f109f" translate="yes" xml:space="preserve">
          <source>Similarly in</source>
          <target state="translated">마찬가지로</target>
        </trans-unit>
        <trans-unit id="c0aa83bbbe563bbcc34994245b02f09698d81bf9" translate="yes" xml:space="preserve">
          <source>Simulating the python ternary operator.</source>
          <target state="translated">파이썬 삼항 연산자 시뮬레이션.</target>
        </trans-unit>
        <trans-unit id="4509806cb94c2823fac491553c861100a38c9efc" translate="yes" xml:space="preserve">
          <source>So, a ternary conditional operation is of the form:</source>
          <target state="translated">따라서 삼항 조건부 연산의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1dee0139e43a4cbbca1778fe8b6f59248a65da5a" translate="yes" xml:space="preserve">
          <source>So, firstly it evaluates the condition. If it returns &lt;code&gt;True&lt;/code&gt;, &lt;strong&gt;expression1&lt;/strong&gt; will be evaluated to give the result, otherwise &lt;strong&gt;expression2&lt;/strong&gt; will be evaluated. Due to &lt;strong&gt;&lt;em&gt;Lazy Evaluation&lt;/em&gt;&lt;/strong&gt; mechanics &amp;ndash; only one expression will be executed.</source>
          <target state="translated">따라서 먼저 조건을 평가합니다. &lt;code&gt;True&lt;/code&gt; 를 반환하면 &lt;strong&gt;expression1&lt;/strong&gt; 이 평가되어 결과가 제공되고, 그렇지 않으면 &lt;strong&gt;expression2&lt;/strong&gt; 가 평가됩니다. &lt;strong&gt;&lt;em&gt;지연 평가&lt;/em&gt;&lt;/strong&gt; 메커니즘으로 인해 하나의 표현식 만 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="5eb20a0d0f308ab00cf66a44ffce1c909d193ed8" translate="yes" xml:space="preserve">
          <source>Some (many :) may frown upon it as unpythonic (even, ruby-ish :), but I personally find it more natural - i.e. how you'd express it normally, plus a bit more visually appealing in large blocks of code.</source>
          <target state="translated">일부 (많은 :)는 비 파이썬 적 인 것으로 찌를 수도 있지만 (루비 -ish :) 개인적으로 더 자연 스럽습니다. 즉, 정상적으로 표현하는 방법과 큰 코드 블록에서 시각적으로 호소력이 있습니다.</target>
        </trans-unit>
        <trans-unit id="10a2d2ce64f1e69ac87af7d7b375ce3f5f76b42e" translate="yes" xml:space="preserve">
          <source>Some find it &quot;unwieldy&quot;, since it goes contrary to the normal flow of thought (thinking of the condition first and then the effects).</source>
          <target state="translated">어떤 사람들은 그것이 생각의 정상적인 흐름 (조건을 먼저 생각한 다음 그 효과를 생각하는 것)과 상반되기 때문에 그것을 다루기 힘들다.</target>
        </trans-unit>
        <trans-unit id="83704dabdebcb46b80e236d14dd2c202687d3cc6" translate="yes" xml:space="preserve">
          <source>Stylistic reasons. (Although the 'inline &lt;code&gt;if&lt;/code&gt;' can be &lt;em&gt;really&lt;/em&gt; useful, and make your script more concise, it really does complicate your code)</source>
          <target state="translated">양식상의 이유. ( 'inline &lt;code&gt;if&lt;/code&gt; '가 &lt;em&gt;실제로&lt;/em&gt; 유용하고 스크립트를 더 간결하게 만들 수 있지만 실제로는 코드를 복잡하게 만듭니다)</target>
        </trans-unit>
        <trans-unit id="4837041f5c57f5efb96309599742e3c0ade4c6b7" translate="yes" xml:space="preserve">
          <source>Syntax :</source>
          <target state="translated">구문 :</target>
        </trans-unit>
        <trans-unit id="8f9eb933921eaddb08703549e034102f89a91d33" translate="yes" xml:space="preserve">
          <source>Ternary conditional operator simply allows testing a condition in a single line replacing the multiline if-else making the code compact.</source>
          <target state="translated">3 차 조건부 연산자를 사용하면 코드를 간결하게 만드는 여러 줄을 대신하여 한 줄로 조건을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1af072bcc6d3d1e5a9aa912cd54ed63e0cf1486d" translate="yes" xml:space="preserve">
          <source>Ternary operators can be chained in series:</source>
          <target state="translated">삼항 연산자는 직렬로 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5503cedf0d5ac8409f386d79e9175e2024368b00" translate="yes" xml:space="preserve">
          <source>The above works since &lt;code&gt;li1&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and the interp treats that as False in logic expressions. The interp then moves on and evaluates the second expression, which is not &lt;code&gt;None&lt;/code&gt; and it's not an empty list - so it gets assigned to a.</source>
          <target state="translated">위의 내용은 &lt;code&gt;li1&lt;/code&gt; 이 &lt;code&gt;None&lt;/code&gt; 이므로 interp은 논리 표현식에서이를 False로 취급합니다. interp는 다음으로 이동하여 두 번째 표현식을 평가합니다. &lt;code&gt;None&lt;/code&gt; 이 아니며 빈 목록이 아니므로 a에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="de0a4391febcb9cd8d58fd3e834ed43e1efb7a54" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;x if C else y&lt;/code&gt; first evaluates the condition, &lt;em&gt;C&lt;/em&gt; (&lt;em&gt;not x&lt;/em&gt;); if &lt;em&gt;C&lt;/em&gt; is true, &lt;em&gt;x&lt;/em&gt; is evaluated and its value is returned; otherwise, &lt;em&gt;y&lt;/em&gt; is evaluated and its value is returned.</source>
          <target state="translated">&lt;code&gt;x if C else y&lt;/code&gt; 먼저 조건을 평가하는 경우 표현식 x , &lt;em&gt;C&lt;/em&gt; ( &lt;em&gt;x&lt;/em&gt; 아님); &lt;em&gt;C&lt;/em&gt; 가 true이면 &lt;em&gt;x&lt;/em&gt; 가 평가되고 해당 값이 반환됩니다. 그렇지 않으면 &lt;em&gt;y&lt;/em&gt; 가 평가되고 해당 값이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="2af104f524b880b50f5f986ef733f30563ed3b2a" translate="yes" xml:space="preserve">
          <source>The expression exp won't be evaluated at all since &quot;and&quot; with 0 will always evaluate to zero and there is no need to evaluate the expression . This is how the compiler itself works , in all languages.</source>
          <target state="translated">0을 가진 &quot;and&quot;는 항상 0으로 평가되고 expression을 평가할 필요가 없으므로 표현식 exp는 전혀 평가되지 않습니다. 이것은 모든 언어에서 컴파일러 자체가 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="10dcb11ae3a76a8e15945f5d2d2d49ac3a28af82" translate="yes" xml:space="preserve">
          <source>The expression exp1 won't be evaluated since False is equivalent to writing 0 and doing &quot;and&quot; with 0 would be 0 itself but after exp1 since &quot;or&quot; is used, it will evaluate the expression exp2 after &quot;or&quot; .</source>
          <target state="translated">False가 0을 작성하는 것과 같고 0을 사용하여 &quot;and&quot;를 수행하는 것은 0 자체가되지만 exp1 이후에는 &quot;or&quot;가 사용되므로 exp1 표현식은 평가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0b0173a9bf087b41e367de32d4700aa1b3e7f88" translate="yes" xml:space="preserve">
          <source>The following one is the same as previous one:</source>
          <target state="translated">다음은 이전과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="067a165678ff801969ed32bb8ae60f3722d4866e" translate="yes" xml:space="preserve">
          <source>The order of the arguments is different from those of the classic &lt;code&gt;condition ? a : b&lt;/code&gt; ternary operator from many other languages (such as C, C++, Go, Perl, Ruby, Java, Javascript, etc.), which may lead to bugs when people unfamiliar with Python's &quot;surprising&quot; behaviour use it (they may reverse the argument order).</source>
          <target state="translated">논쟁의 순서는 고전적인 &lt;code&gt;condition ? a : b&lt;/code&gt; 의 순서와 다른가 ? a : 다른 많은 언어 (예 : C, C ++, Go, Perl, Ruby, Java, Javascript 등)의 3 진 연산자. 파이썬의 &quot;놀라운&quot;동작에 익숙하지 않은 사람들이이를 사용할 때 버그가 발생할 수 있습니다 (역전 될 수 있음) 인수 순서).</target>
        </trans-unit>
        <trans-unit id="7f7150ee78b704977771011e6cc40319ad111995" translate="yes" xml:space="preserve">
          <source>The part of interest is:</source>
          <target state="translated">관심있는 부분은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ecc502e972ed10fca2ccd9ef53adcd864cb4fc7b" translate="yes" xml:space="preserve">
          <source>The second expression exp2 won't be evaluated since &lt;code&gt;True and exp1&lt;/code&gt; would be True when exp1 isn't false .</source>
          <target state="translated">두 번째 표현식 exp2는 &lt;code&gt;True and exp1&lt;/code&gt; 이후 평가되지 않으며 exp1이 false가 아닌 경우 exp1은 True입니다.</target>
        </trans-unit>
        <trans-unit id="bdb2f1d61e753c9f06341fdd6911740881590e6a" translate="yes" xml:space="preserve">
          <source>The shortest alternative remains:</source>
          <target state="translated">가장 짧은 대안은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1dfd8c0a2483ad75105cf7ed865fe43abedbd49b" translate="yes" xml:space="preserve">
          <source>Think of the conditional expression as switching between two values. It is very useful when you're in a 'one value or another' situation, it but doesn't do much else.</source>
          <target state="translated">조건식을 두 값 사이를 전환하는 것으로 생각하십시오. '하나의 가치 또는 다른'상황에있을 때 매우 유용하지만 그다지 많은 일을하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="757bd11c077579d0812f85bcccc7725ef9ec81a5" translate="yes" xml:space="preserve">
          <source>This allows short-circuiting because when &lt;code&gt;condition&lt;/code&gt; is true only &lt;code&gt;a&lt;/code&gt; is evaluated and &lt;code&gt;b&lt;/code&gt; is not evaluated at all, but when &lt;code&gt;condition&lt;/code&gt; is false only &lt;code&gt;b&lt;/code&gt; is evaluated and &lt;code&gt;a&lt;/code&gt; is not evaluated at all.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 이 참이면 &lt;code&gt;a&lt;/code&gt; 만 평가되고 &lt;code&gt;b&lt;/code&gt; 는 전혀 평가되지 않지만 &lt;code&gt;condition&lt;/code&gt; 이 거짓이면 b 만 평가되고 a 는 전혀 평가되지 않기 때문에 단락이 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3aa85c1834379568a2dadd44872b30d05cc9785b" translate="yes" xml:space="preserve">
          <source>This also works with empty lists. For instance, if you want to assign &lt;code&gt;a&lt;/code&gt; whichever list has items.</source>
          <target state="translated">이것은 빈 목록에서도 작동합니다. 예를 들어, 항목이있는 목록을 지정하려는 경우.</target>
        </trans-unit>
        <trans-unit id="e427501a7bef42104eb698d56ff23ced6c553723" translate="yes" xml:space="preserve">
          <source>This would print &quot;odd&quot; if the number is odd or &quot;even&quot; if the number is even.</source>
          <target state="translated">숫자가 홀수이면 &quot;홀수&quot;로 표시되고 짝수이면 &quot;짝수&quot;로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="341d87306463ddc466b59261fedf82fb8984b255" translate="yes" xml:space="preserve">
          <source>Though, there is a potential problem, which if &lt;code&gt;cond&lt;/code&gt; evaluates to &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;on_true&lt;/code&gt; evaluates to &lt;code&gt;False&lt;/code&gt; then &lt;code&gt;on_false&lt;/code&gt; is returned instead of &lt;code&gt;on_true&lt;/code&gt;. If you want this behavior the method is OK, otherwise use this:</source>
          <target state="translated">그러나 &lt;code&gt;cond&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 로 평가되고 &lt;code&gt;on_false&lt;/code&gt; 가 &lt;code&gt;False&lt;/code&gt; 로 평가되면 on_true 대신 on_false 가 리턴되는 잠재적 문제점이 &lt;code&gt;on_true&lt;/code&gt; . 이 동작을 원하면 방법이 정상입니다. 그렇지 않으면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f7b558b3c21a3c98acd200b3647d45f05d3fca8c" translate="yes" xml:space="preserve">
          <source>Unfortunately, the</source>
          <target state="translated">불행히도</target>
        </trans-unit>
        <trans-unit id="b4258119ca3a4370d0ee540f727c401d66415a0e" translate="yes" xml:space="preserve">
          <source>With Python, you can simply use &lt;code&gt;or&lt;/code&gt; for alternative assignments.</source>
          <target state="translated">Python을 사용하면 간단히 &lt;code&gt;or&lt;/code&gt; 대체 할당에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="501c4df30742de5f56942e39e4e33cb5bd40bc10" translate="yes" xml:space="preserve">
          <source>YES, python have a ternary operator, here is the syntax and an example code to demonstrate the same :)</source>
          <target state="translated">예, 파이썬에는 삼항 연산자가 있습니다. 구문과 예제 코드는 동일합니다. :)</target>
        </trans-unit>
        <trans-unit id="4764fab14882c7824fd31afde1275c8ad9dfa5b5" translate="yes" xml:space="preserve">
          <source>Yes, it was &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;added&lt;/a&gt; in version 2.5. The expression syntax is:</source>
          <target state="translated">예, 버전 2.5에서 &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;추가&lt;/a&gt; 되었습니다. 표현식 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3837222375484f4dc46135b7a771581dbcab794a" translate="yes" xml:space="preserve">
          <source>Yes. From the &lt;a href=&quot;https://docs.python.org/reference/grammar.html&quot;&gt;grammar file&lt;/a&gt;:</source>
          <target state="translated">예. &lt;a href=&quot;https://docs.python.org/reference/grammar.html&quot;&gt;문법 파일에서&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="772c57f489560211e78cb2d11c2866b9b29aa5a6" translate="yes" xml:space="preserve">
          <source>You can index into a tuple:</source>
          <target state="translated">튜플로 색인을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d31bcb3f2a3c69063ab668827d032b8b24cb2929" translate="yes" xml:space="preserve">
          <source>You can, however, use conditional expressions to assign a variable like so:</source>
          <target state="translated">그러나 조건식을 사용하여 다음과 같이 변수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6ca419c1e37f1c6d062c1b86540910790e67eb6" translate="yes" xml:space="preserve">
          <source>You may find it somewhat painful to write the following:</source>
          <target state="translated">다음을 작성하는 것이 다소 고통 스러울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="379a81c9dfbf20958f52ab889b166808e4e8c8ed" translate="yes" xml:space="preserve">
          <source>You might often find</source>
          <target state="translated">당신은 종종 찾을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="31848eba55db40fa8ba451e1340bcdefedd1ab44" translate="yes" xml:space="preserve">
          <source>[on_true] if [expression] else [on_false]</source>
          <target state="translated">[on_true] if [expression] else [on_false]</target>
        </trans-unit>
        <trans-unit id="587c8f0406732dd61ae6136de1b47c30d311764c" translate="yes" xml:space="preserve">
          <source>^ This is the long form for doing such assignments.</source>
          <target state="translated">^ 이것은 그러한 과제를 수행하기위한 긴 형식입니다.</target>
        </trans-unit>
        <trans-unit id="1fb45c17c40a7ce16c17847d13d5985415280f02" translate="yes" xml:space="preserve">
          <source>and used this way:</source>
          <target state="translated">이 방법으로 사용 :</target>
        </trans-unit>
        <trans-unit id="1cd77732f70e749c449a2d2f10a245fdb56e9f44" translate="yes" xml:space="preserve">
          <source>both &lt;code&gt;no()&lt;/code&gt; and &lt;code&gt;yes()&lt;/code&gt; are evaluated.</source>
          <target state="translated">&lt;code&gt;no()&lt;/code&gt; 와 &lt;code&gt;yes()&lt;/code&gt; 가 모두 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="c41b42386b37a56e714bbb8ab4091873bf086bf5" translate="yes" xml:space="preserve">
          <source>but there is no alternative to</source>
          <target state="translated">그러나 대안이 없습니다</target>
        </trans-unit>
        <trans-unit id="c95d2327025d475ff8b7501febaf2cb7b1ddb92f" translate="yes" xml:space="preserve">
          <source>but this lead to problem when on_true == 0</source>
          <target state="translated">그러나 on_true == 0 일 때 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5a7924a284bb500fda5727b50dfc64f598dc9717" translate="yes" xml:space="preserve">
          <source>however this won't work if &lt;code&gt;x&lt;/code&gt; would be &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">그러나 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;False&lt;/code&gt; 인 경우에는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="73075949ea61dd74d8b1bfeb6d8bbf8696d9ea9e" translate="yes" xml:space="preserve">
          <source>if the condition [condition] becomes &quot;True&quot; then , expression_1 will be evaluated but not expression_2 .
If we &quot;and&quot; something with 0 (zero) , the result will always to be fasle .So in the below statement ,</source>
          <target state="translated">조건 [condition]이 &quot;True&quot;가되면 expression_1은 평가되지만 expression_2는 평가되지 않습니다. 우리가 0으로 무언가를 &quot;그리고&quot;한다면 결과는 항상 희미 해 질 것입니다.</target>
        </trans-unit>
        <trans-unit id="8347a9c362a17ba7f157573753c5e4693b113950" translate="yes" xml:space="preserve">
          <source>if variable is defined and you want to check if it has value you can just &lt;code&gt;a or b&lt;/code&gt;</source>
          <target state="translated">변수가 정의되어 있고 값이 있는지 확인하려는 경우 &lt;code&gt;a or b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30f50d1b7ad8a1d8edb08847855b435a18a6162f" translate="yes" xml:space="preserve">
          <source>if you want to avoid the evaluation of &lt;code&gt;yes()&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;no()&lt;/code&gt;, because in</source>
          <target state="translated">&lt;code&gt;yes()&lt;/code&gt; &lt;em&gt;및&lt;/em&gt; &lt;code&gt;no()&lt;/code&gt; 의 평가를 피하려면</target>
        </trans-unit>
        <trans-unit id="7dee470dedb23faec9c2b494d21fd11fc576b9cb" translate="yes" xml:space="preserve">
          <source>is the following:</source>
          <target state="translated">다음과 같습니다 :</target>
        </trans-unit>
        <trans-unit id="20a29395163e5b9709a368d657a06041695e75bc" translate="yes" xml:space="preserve">
          <source>it can be nested as your need. best of luck</source>
          <target state="translated">필요에 따라 중첩 될 수 있습니다. 행운을 빌어 요</target>
        </trans-unit>
        <trans-unit id="79dec008519b31cbf101741268f604a50168381a" translate="yes" xml:space="preserve">
          <source>or explicitly constructed dictionary:</source>
          <target state="translated">또는 명시 적으로 구성된 사전 :</target>
        </trans-unit>
        <trans-unit id="b7bbf3b6da6885a501de4362189e82f1cd57f4ec" translate="yes" xml:space="preserve">
          <source>or you can use the built-in &lt;a href=&quot;https://docs.python.org/3.3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool()&lt;/code&gt;&lt;/a&gt; to assure a &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;Boolean&lt;/a&gt; value:</source>
          <target state="translated">또는 내장 &lt;a href=&quot;https://docs.python.org/3.3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool()&lt;/code&gt; &lt;/a&gt; 을 사용하여 &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;부울&lt;/a&gt; 값을 보장 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="0f0e94c76317c1202fb0746ef1437c8fcdd487dd" translate="yes" xml:space="preserve">
          <source>solution doesn't have short-circuit behaviour; thus both &lt;code&gt;falseValue&lt;/code&gt; and &lt;code&gt;trueValue&lt;/code&gt; are evaluated regardless of the condition. This could be suboptimal or even buggy (i.e. both &lt;code&gt;trueValue&lt;/code&gt; and &lt;code&gt;falseValue&lt;/code&gt; could be methods and have side-effects).</source>
          <target state="translated">솔루션에는 단락 동작이 없습니다. 따라서 &lt;code&gt;trueValue&lt;/code&gt; 및 &lt;code&gt;falseValue&lt;/code&gt; 는 조건에 관계없이 평가됩니다. 이는 차선책이거나 버그가있을 수 있습니다 (즉, &lt;code&gt;falseValue&lt;/code&gt; 와 &lt;code&gt;trueValue&lt;/code&gt; 모두 메소드 일 수 있으며 부작용이있을 수 있음).</target>
        </trans-unit>
        <trans-unit id="a274a9708a98bc4fdb9472318da8f13c3bee8f70" translate="yes" xml:space="preserve">
          <source>the expression exp won't be evaluated at all since &quot;or&quot; with 1 will always be 1. So it won't bother to evaluate the expression exp since the result will be 1 anyway . (compiler optimization methods).</source>
          <target state="translated">표현식 exp는 1을 가진 &quot;or&quot;가 항상 1이기 때문에 전혀 평가되지 않습니다. 따라서 결과가 1이되기 때문에 표현식 exp를 평가하는 것은 귀찮지 않습니다. (컴파일러 최적화 방법).</target>
        </trans-unit>
        <trans-unit id="39d0c3ab7ef90c6d161469ec584ab022b15f4f10" translate="yes" xml:space="preserve">
          <source>where operands are &lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_evaluation&quot;&gt;lazily evaluated&lt;/a&gt;.</source>
          <target state="translated">피연산자가 &lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_evaluation&quot;&gt;느리게 평가&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="785b497ac41614c19f3ad8ef5a1360eddd4057ed" translate="yes" xml:space="preserve">
          <source>where you would expect for a  normal ternary operator this result</source>
          <target state="translated">일반적인 삼항 연산자가 예상되는 위치</target>
        </trans-unit>
        <trans-unit id="e43fb40cf7bf1d92d0566f4d8f907e807802db52" translate="yes" xml:space="preserve">
          <source>which can be wrapped by:</source>
          <target state="translated">다음과 같이 감쌀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a8a0f7868e57d2229b4d0eadf021b1a17426df8" translate="yes" xml:space="preserve">
          <source>which has the following nice extension:</source>
          <target state="translated">다음과 같은 멋진 확장 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7497cd967a22e5c73dd2351308b5e2ef28d3ca05" translate="yes" xml:space="preserve">
          <source>which is equivalent in semantics. Note that some style-guides may limit this usage on the grounds of clarity - it does pack a lot of meaning into very little syntax.</source>
          <target state="translated">의미론과 동일합니다. 일부 스타일 가이드는 명확성으로 인해이 사용법을 제한 할 수 있습니다.이 구문은 구문에 거의 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="cc81a06a417041080d93a2378641c20ac0ef4865" translate="yes" xml:space="preserve">
          <source>which is equivalent to:</source>
          <target state="translated">이는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2dc90da9b9944ad673e6b9050319bf49bdf7040" translate="yes" xml:space="preserve">
          <source>which raises a &lt;code&gt;SyntaxError: invalid syntax&lt;/code&gt;.
So the above is either an incomplete piece of logic (perhaps the user expects a no-op in the false condition) or what may be intended is to use expression2 as a filter - notes that the following is legal Python:</source>
          <target state="translated">&lt;code&gt;SyntaxError: invalid syntax&lt;/code&gt; 시킵니다. 따라서 위의 내용은 불완전한 논리 (아마도 사용자가 잘못된 조건에서 no-op를 기대할 것임)이거나 expression2를 필터로 사용하려는 것일 수 있습니다. 다음은 합법적 인 Python입니다.</target>
        </trans-unit>
        <trans-unit id="dee9317287e35bb56b2a38da732e9512ed8decb4" translate="yes" xml:space="preserve">
          <source>will output</source>
          <target state="translated">출력합니다</target>
        </trans-unit>
        <trans-unit id="36c7911bf17eb1c668d4ee0aa1aabedcd02fc3a1" translate="yes" xml:space="preserve">
          <source>you can do this :-</source>
          <target state="translated">당신은 이것을 할 수 있습니다 :-</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
