<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/394809">
    <body>
      <group id="394809">
        <trans-unit id="70ab045269befc703f5853d363741cd4809122f9" translate="yes" xml:space="preserve">
          <source>(execution delayed until the winner is known ;)), but it introduces inconsistency between callable and non-callable objects. In addition, it doesn't solve the case when using properties.</source>
          <target state="translated">(勝者がわかるまで実行が遅れる ;)が、呼び出し可能なオブジェクトと呼び出し不可能なオブジェクトの間に矛盾が生じます。また、プロパティを使用している場合は解決しません。</target>
        </trans-unit>
        <trans-unit id="8cb713133a6c1d41da9b697de8bb604304078011" translate="yes" xml:space="preserve">
          <source>, becomes:</source>
          <target state="translated">になります。</target>
        </trans-unit>
        <trans-unit id="40f40c03a1271b3952ed519b50c12fd149dc92e6" translate="yes" xml:space="preserve">
          <source>1- Simple Method to use ternary operator:</source>
          <target state="translated">1-三項演算子を使う簡単な方法。</target>
        </trans-unit>
        <trans-unit id="d848fcf366a8ef37a8ff9e843fba0d9be57b73fb" translate="yes" xml:space="preserve">
          <source>2- Direct Method of using tuples, Dictionary, and lambda:</source>
          <target state="translated">2-タプル、辞書、ラムダを直接使う方法</target>
        </trans-unit>
        <trans-unit id="1aae16e227a970760713cda0dda545cb5d3699fe" translate="yes" xml:space="preserve">
          <source>3- Ternary operator can be written as nested if-else:</source>
          <target state="translated">3-三項演算子は入れ子になったif-elseとして書くことができます。</target>
        </trans-unit>
        <trans-unit id="044a950e94c378180ffa7793e1030478e33e33d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression1&lt;/code&gt; will have to be evaluated twice with the above usage. It can limit redundancy if it is simply a local variable. However, a common and performant Pythonic idiom for this use-case is to use &lt;code&gt;or&lt;/code&gt;'s shortcutting behavior:</source>
          <target state="translated">上記の使用方法では、 &lt;code&gt;expression1&lt;/code&gt; を2回評価する必要があります。 単にローカル変数の場合、冗長性を制限できます。 ただし、このユースケースの一般的で高性能なPythonicイディオムは、 &lt;code&gt;or&lt;/code&gt; のショートカット動作です。</target>
        </trans-unit>
        <trans-unit id="334c175549b49453b828bca8b2a67a5cca8af5cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression2&lt;/code&gt; works as a filter for the list comprehension, and is &lt;em&gt;not&lt;/em&gt; a ternary conditional operator.</source>
          <target state="translated">&lt;code&gt;expression2&lt;/code&gt; はリスト内包のフィルターとして機能し、3項条件演算子ではあり&lt;em&gt;ません&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="5dab472beecae7e7e8dfecfe05a0c2d9f3e3ecd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression3&lt;/code&gt; will be lazily evaluated (that is, evaluated only if &lt;code&gt;expression2&lt;/code&gt; is false in a boolean context). And because of the recursive definition, you can chain them indefinitely (though it may considered bad style.)</source>
          <target state="translated">&lt;code&gt;expression3&lt;/code&gt; は遅延評価されます（つまり、booleanコンテキストで &lt;code&gt;expression2&lt;/code&gt; がfalseの場合にのみ評価されます）。 また、再帰的な定義のため、それらを無期限にチェーンすることができます（ただし、スタイルが悪いと見なされる場合があります）。</target>
        </trans-unit>
        <trans-unit id="29c4f62bef87062fb6570c3ab3b8996c0383d73f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test&lt;/code&gt; needs to return &lt;em&gt;True&lt;/em&gt; or &lt;em&gt;False&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; は&lt;em&gt;True&lt;/em&gt;または&lt;em&gt;False&lt;/em&gt;を返す必要があります。</target>
        </trans-unit>
        <trans-unit id="3fae46c5ec8c22f65a6e958eb8f75ef995296321" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A neat way to chain multiple operators:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;複数の演算子をチェーンするためのきちんとした方法：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a301bfe415904b8134c76d76fa61ec8147dc8ee2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary Operator in Javascript&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;JavaScriptの三項演算子&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa49ba0541262da7d41f0f4081422b0ba2554c7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary Operator in Ruby&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Rubyの三項演算子&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35cb1a58f55a6ac1ac6b936dfb825e64d5a5f996" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary operator in Python&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Pythonの三項演算子&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1a00fe97ba444ce4af43b0aa2eb087ce13ccd36" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary operator in R programming&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Rプログラミングの三項演算子&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f11633b413a20a2ad39481a598a7473cdd7868d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary operator in Scala&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Scalaの三項演算子&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57ae2a1bc4b2cd461a9d0deedcd0dc94cde72aef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;[condition] and [expression_1] or [expression_2] ;&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;[condition] and [expression_1] or [expression_2] ;&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c135775097dd01254c74e73b8797ce9763f03653" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case you still want to make it work for all the cases regardless of what exp_1 and exp_2 truth values are, do this :-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;exp_1およびexp_2の真理値が何であるかに関係なく、すべてのケースでそれを機能させたい場合は、次のようにします。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f445f66b4684e3ca1e89dff63c6cf9c6b9a2085" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note :-&lt;/strong&gt; 0 , None , False , emptylist , emptyString evaluates as False.
And any data other than 0 evaluates to True.</source>
          <target state="translated">&lt;strong&gt;注：&lt;/strong&gt; -0、なし、False、emptylist、emptyStringはFalseとして評価されます。 また、0以外のデータはすべてTrueと評価されます。</target>
        </trans-unit>
        <trans-unit id="8904df4a64a6f105d991168d30a94c94e66eb44d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:-&lt;/strong&gt; This kind of branching using &quot;or&quot; and &quot;and&quot; can only be used when the expression_1 doesn't have a Truth value of False (or 0 or None or emptylist [ ] or emptystring ' '.) since if expression_1 becomes False , then the expression_2 will be evaluated because of the presence &quot;or&quot; between exp_1 and exp_2.</source>
          <target state="translated">&lt;strong&gt;注：-&lt;/strong&gt; 「or」と「and」を使用したこの種の分岐は、expression_1がFalse（または0またはNoneまたはemptylist []またはemptystring ''。）の真理値を持たない場合にのみ使用できます。 Falseの場合、exp_1とexp_2の間に「または」が存在するため、expression_2が評価されます。</target>
        </trans-unit>
        <trans-unit id="93c71edf58c5ab505268c88d73e083ab4ff69b1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ternary Operator in different programming Languages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;異なるプログラミング言語の三項演算子&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0082dd6b907a273d541b44f98e346b6ffade9988" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result :-&lt;/strong&gt;  If condition is true exp_1 is executed else exp_2 is executed.</source>
          <target state="translated">&lt;strong&gt;結果：-&lt;/strong&gt;条件がtrueの場合はexp_1が実行され、そうでない場合はexp_2が実行されます。</target>
        </trans-unit>
        <trans-unit id="5d726f2ccbdf4ef2112e79b46394efd7a26bdb15" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;1. &lt;a href=&quot;http://docs.python.org/3.3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator&quot;&gt;Is there an equivalent of C&amp;rsquo;s &amp;rdquo;?:&amp;rdquo; ternary operator?&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;1. &lt;a href=&quot;http://docs.python.org/3.3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator&quot;&gt;Cの「？::」三項演算子に相当するものはありますか？&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="0bdf2155f1318aca0a1e6ff9bab81d9a15d7e099" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Source: &lt;a href=&quot;https://en.wikipedia.org/wiki/%3F:#Python&quot;&gt;?: in Python at Wikipedia&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;出典： &lt;a href=&quot;https://en.wikipedia.org/wiki/%3F:#Python&quot;&gt;？：WikipediaのPython&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="47137144ef43e236132e42d4c3cd332e4cc3ec7f" translate="yes" xml:space="preserve">
          <source>A note on usage:</source>
          <target state="translated">使い方の注意点。</target>
        </trans-unit>
        <trans-unit id="9d0a430e9f1e437bba549167d60e32cd4b925015" translate="yes" xml:space="preserve">
          <source>A possible workaround is to make &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; lists or tuples as in the following:</source>
          <target state="translated">可能な回避策は、次のように &lt;code&gt;x&lt;/code&gt; および &lt;code&gt;y&lt;/code&gt; リストまたはタプルを作成することです。</target>
        </trans-unit>
        <trans-unit id="fe56c5e5a4d9f35e186ec5eb03b16ba91ecd7267" translate="yes" xml:space="preserve">
          <source>Above approach can be written as:</source>
          <target state="translated">上記のアプローチは次のように書くことができます。</target>
        </trans-unit>
        <trans-unit id="aa5bb41606c2c5c53748e18b932c8d70cf7312ab" translate="yes" xml:space="preserve">
          <source>Additional information:</source>
          <target state="translated">追加情報です。</target>
        </trans-unit>
        <trans-unit id="f9cce9f391b0f087eec06d00b08402a5a533e1df" translate="yes" xml:space="preserve">
          <source>Alternative syntax for a more narrow case:</source>
          <target state="translated">より狭いケースの代替構文。</target>
        </trans-unit>
        <trans-unit id="4c7eaa8bf582781c438a6973636b946051d550a6" translate="yes" xml:space="preserve">
          <source>Although it does have the benefit of evaluating expressions left to right, which is clearer in my opinion.</source>
          <target state="translated">表現を左右に評価できるメリットはありますが、私の考えではどちらがわかりやすいでしょう。</target>
        </trans-unit>
        <trans-unit id="4243fff9331bddbb87ee3995bde3a9f8c62ecdf0" translate="yes" xml:space="preserve">
          <source>An operator for a conditional expression in Python was added in 2006 as part of &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;Python Enhancement Proposal 308&lt;/a&gt;. Its form differ from common &lt;code&gt;?:&lt;/code&gt; operator and it's:</source>
          <target state="translated">Pythonの条件式の演算子は、 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;Python拡張提案308の&lt;/a&gt;一部として2006年に追加されました。 その形式は一般的な &lt;code&gt;?:&lt;/code&gt; 演算子とは異なります。</target>
        </trans-unit>
        <trans-unit id="6d802d348de05c371872aaa136e43ae4790bb661" translate="yes" xml:space="preserve">
          <source>And so the story goes - choosing between 3 mentioned solutions is a trade-off between having the short-circuit feature, using at least Зython 2.5 (IMHO not a problem anymore) and not being prone to &quot;&lt;code&gt;trueValue&lt;/code&gt;-evaluates-to-false&quot; errors.</source>
          <target state="translated">そして、話は続きます-言及された3つのソリューションから選択することは、短絡機能を備えること、少なくともЗython2.5を使用すること（IMHOはもはや問題ではない）、「 &lt;code&gt;trueValue&lt;/code&gt; -evaluates-to-false」になりにくいことの間のトレードオフです。エラー。</target>
        </trans-unit>
        <trans-unit id="9db147c5133a121c92efce9f531259e88a815251" translate="yes" xml:space="preserve">
          <source>Another (less reliable), but simpler method is to use &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators:</source>
          <target state="translated">別の（信頼性は低い）が、より単純な方法は &lt;code&gt;and&lt;/code&gt; および &lt;code&gt;or&lt;/code&gt; 演算子を使用することです。</target>
        </trans-unit>
        <trans-unit id="f29869a5fb045eacca16998a249d59fe4a1ef72e" translate="yes" xml:space="preserve">
          <source>Another syntax which can be used (compatible with versions before 2.5):</source>
          <target state="translated">使用できる別の構文(2.5以前のバージョンと互換性があります)。</target>
        </trans-unit>
        <trans-unit id="6ede496e52093534454faa827678b96dc14a0bde" translate="yes" xml:space="preserve">
          <source>Another way is by indexing a tuple (which isn't consistent with the conditional operator of most other languages):</source>
          <target state="translated">もう一つの方法は、タプルをインデックス化することです(これは他のほとんどの言語の条件演算子とは一致しません)。</target>
        </trans-unit>
        <trans-unit id="e5d8acdf91b2bad1764fb5d525bdb392c6e78228" translate="yes" xml:space="preserve">
          <source>As already answered, yes there is a ternary operator in python:</source>
          <target state="translated">すでに答えられているように、パイソンには三項演算子があります。</target>
        </trans-unit>
        <trans-unit id="10eeb6250c3d1364e2b4a11d28ce4b006bc96176" translate="yes" xml:space="preserve">
          <source>At first, the &lt;code&gt;Python&lt;/code&gt;&lt;strong&gt;B&lt;/strong&gt;enevolent &lt;strong&gt;D&lt;/strong&gt;ictator &lt;strong&gt;F&lt;/strong&gt;or &lt;strong&gt;L&lt;/strong&gt;ife (I mean Guido van Rossum, of course) rejected it (as non-Pythonic style), since it's quite hard to understand for people not used to &lt;code&gt;C&lt;/code&gt; language. Also, the colon sign &lt;strong&gt;&lt;code&gt;:&lt;/code&gt;&lt;/strong&gt; already has many uses in &lt;code&gt;Python&lt;/code&gt;. After &lt;strong&gt;PEP 308&lt;/strong&gt; was approved, &lt;code&gt;Python&lt;/code&gt; finally received its own shortcut conditional expression (what we use now):</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 言語に慣れていない人にとっては理解するのが非常に難しいため、最初は、 &lt;code&gt;Python&lt;/code&gt; &lt;strong&gt;Bの&lt;/strong&gt;不快な発言者&lt;strong&gt;F&lt;/strong&gt;または&lt;strong&gt;L&lt;/strong&gt; ife（もちろん、Guido van Rossumを意味します）がそれを（非Pythonicスタイルとして）拒否しました。 また、コロン記号&lt;strong&gt; &lt;code&gt;:&lt;/code&gt; &lt;/strong&gt; &lt;code&gt;Python&lt;/code&gt; ではすでに多くの用途があります。 &lt;strong&gt;PEP 308&lt;/strong&gt;が承認された後、 &lt;code&gt;Python&lt;/code&gt; は最終的に独自のショートカット条件式（現在使用しているもの）を受け取りました。</target>
        </trans-unit>
        <trans-unit id="dd29e09af960c8454a520e8b4d704fdf79a455d7" translate="yes" xml:space="preserve">
          <source>Below is the ternary form. But this isn't most succinct way - see last example.</source>
          <target state="translated">以下は三項式です。しかし、これは最も簡潔な方法ではありません-最後の例を参照してください。</target>
        </trans-unit>
        <trans-unit id="54ab93ad34df3c1e05aa8130fd92ecad93172607" translate="yes" xml:space="preserve">
          <source>But in case of</source>
          <target state="translated">しかし、その場合には</target>
        </trans-unit>
        <trans-unit id="e428c12fd355944b5e6b7023bd80dd3c17b5aee5" translate="yes" xml:space="preserve">
          <source>Conditional expressions</source>
          <target state="translated">条件式</target>
        </trans-unit>
        <trans-unit id="53209a5d3bcb5ef6226a6a63af2411fb4329ea1a" translate="yes" xml:space="preserve">
          <source>Conditional expressions (sometimes called a &amp;ldquo;ternary operator&amp;rdquo;) have the lowest priority of all Python operations.</source>
          <target state="translated">条件式（「三項演算子」と呼ばれることもあります）は、すべてのPython操作の中で最も優先度が低くなります。</target>
        </trans-unit>
        <trans-unit id="43e7ce9b3100f9c4cee6083bc0c5c0ecc62fe1d3" translate="yes" xml:space="preserve">
          <source>Does Python have a ternary conditional operator</source>
          <target state="translated">Pythonには3項条件演算子がありますか?</target>
        </trans-unit>
        <trans-unit id="1a6fd40c1dc466260f6a3434319de40a40079b42" translate="yes" xml:space="preserve">
          <source>Does Python have a ternary conditional operator?</source>
          <target state="translated">Pythonには3項条件演算子がありますか?</target>
        </trans-unit>
        <trans-unit id="08ec689e9d96535ecd7d37b8542dacd3113a01d8" translate="yes" xml:space="preserve">
          <source>Example:-</source>
          <target state="translated">Example:-</target>
        </trans-unit>
        <trans-unit id="f67e732e29a09166934752e7537614b263f98276" translate="yes" xml:space="preserve">
          <source>First &lt;code&gt;condition&lt;/code&gt; is evaluated, then exactly one of either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is evaluated and returned based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;Boolean&lt;/a&gt; value of &lt;code&gt;condition&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; evaluates to &lt;code&gt;True&lt;/code&gt;, then &lt;code&gt;a&lt;/code&gt; is evaluated and returned but &lt;code&gt;b&lt;/code&gt; is ignored, or else when &lt;code&gt;b&lt;/code&gt; is evaluated and returned but &lt;code&gt;a&lt;/code&gt; is ignored.</source>
          <target state="translated">最初の &lt;code&gt;condition&lt;/code&gt; が評価され、次に &lt;code&gt;a&lt;/code&gt; または &lt;code&gt;b&lt;/code&gt; のいずれか1つが評価され、 conditionの&lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;ブール&lt;/a&gt;値に基づいて返され &lt;code&gt;condition&lt;/code&gt; 。 &lt;code&gt;condition&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; に評価される場合、 &lt;code&gt;a&lt;/code&gt; は評価されて返されますが、 &lt;code&gt;b&lt;/code&gt; は無視されます。それ以外の場合は、 &lt;code&gt;b&lt;/code&gt; が評価されて返されますが &lt;code&gt;a&lt;/code&gt; は無視されます。</target>
        </trans-unit>
        <trans-unit id="e65f8fce57a4328cfd936e7c997b733995619b23" translate="yes" xml:space="preserve">
          <source>For Python 2.5 and newer there is a specific syntax:</source>
          <target state="translated">Python 2.5以降では、特定の構文があります。</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="73ed66c8963b3d8dd7afa66295f9854e375e8607" translate="yes" xml:space="preserve">
          <source>For versions prior to 2.5, there's the trick:</source>
          <target state="translated">2.5以前のバージョンの場合はコツがあります。</target>
        </trans-unit>
        <trans-unit id="92945ac06e73038a2bde16da80172b032aba2bb3" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#conditional-expressions&quot;&gt;the documentation&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#conditional-expressions&quot;&gt;ドキュメント&lt;/a&gt;から：</target>
        </trans-unit>
        <trans-unit id="05e2cc02796cc541f46aedf7a50bc4121d7e8342" translate="yes" xml:space="preserve">
          <source>Here I just try to show some important difference in &lt;code&gt;ternary operator&lt;/code&gt; between a couple of programming languages.</source>
          <target state="translated">ここでは、いくつかのプログラミング言語間の &lt;code&gt;ternary operator&lt;/code&gt; いくつかの重要な違いを示します。</target>
        </trans-unit>
        <trans-unit id="77a6b125fd3cd1ac92bbf113c153321aee865a77" translate="yes" xml:space="preserve">
          <source>Here are some examples (conditions will be evaluated from left to right):</source>
          <target state="translated">ここでは、いくつかの例を紹介します(左から順に条件が評価されます)。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">ここでは一例を紹介します。</target>
        </trans-unit>
        <trans-unit id="dcae16de665cdab304c88fb675786b95de0fc2e3" translate="yes" xml:space="preserve">
          <source>Here's how it works:</source>
          <target state="translated">その仕組みをご紹介します。</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">これが助けになることを願っています。</target>
        </trans-unit>
        <trans-unit id="37ead08d0a3de9126fb757db960eb29eba55180c" translate="yes" xml:space="preserve">
          <source>I always liked the C ternary syntax, but Python takes it a step further!</source>
          <target state="translated">Cの三項構文はずっと好きだったのですが、Pythonはさらに一歩進んだものになっています。</target>
        </trans-unit>
        <trans-unit id="2fc5c24905a2271acf5a9e03baac33ba14f9bc08" translate="yes" xml:space="preserve">
          <source>I find cumbersome the default python syntax &lt;code&gt;val = a if cond else b&lt;/code&gt;, so sometimes I do this:</source>
          <target state="translated">デフォルトのpython構文 &lt;code&gt;val = a if cond else b&lt;/code&gt; が扱いにくいので、時々これを行います：</target>
        </trans-unit>
        <trans-unit id="2e767bec6a36856af0721a196a27cd634af23fc7" translate="yes" xml:space="preserve">
          <source>I understand that some may say this isn't a good stylistic choice because it relies on mechanics that aren't immediately apparent to all developers. I personally disagree with that viewpoint. Python is a syntax rich language with lots of idiomatic tricks that aren't immediately apparent to the dabler. But the more you learn and understand the mechanics of the underlying system, the more you appreciate it.</source>
          <target state="translated">すべての開発者がすぐにはわからないようなメカニックに頼っているので、これは良いスタイルの選択ではないと言う人もいるかもしれませんが、個人的にはそうは思いません。私は個人的にはその見解には反対です。Python は構文が豊富な言語で、開発者にはすぐにはわからないようなイディオムなトリックがたくさんあります。しかし、基礎となるシステムの仕組みを学び、理解すればするほど、その良さがわかるようになります。</target>
        </trans-unit>
        <trans-unit id="4c43044d1cee7d9be8a45db13e7115d6ebb09ae0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;expression 1&amp;gt;&lt;/code&gt; is the condition you can use &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;Short-cirquit evaluation&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;&amp;lt;expression 1&amp;gt;&lt;/code&gt; が条件である場合、 &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;短絡評価を&lt;/a&gt;使用できます。</target>
        </trans-unit>
        <trans-unit id="c7b7a1b690cd2aa8c0d47a1a173633ac7de09ad9" translate="yes" xml:space="preserve">
          <source>If Python does not have a ternary conditional operator, is it possible to simulate one using other language constructs?</source>
          <target state="translated">Pythonに3項条件演算子がない場合、他の言語の構文を使って3項条件演算子をシミュレートすることは可能ですか?</target>
        </trans-unit>
        <trans-unit id="0e97f70a139ffcfa1a24114a4591be1fca3125fb" translate="yes" xml:space="preserve">
          <source>If you need to use statements, you have to use a normal &lt;code&gt;if&lt;/code&gt;&lt;strong&gt;statement&lt;/strong&gt; instead of a conditional &lt;strong&gt;expression&lt;/strong&gt;.</source>
          <target state="translated">ステートメントを使用する必要がある場合は、条件&lt;strong&gt;式の&lt;/strong&gt;代わりに通常の &lt;code&gt;if&lt;/code&gt; &lt;strong&gt;ステートメント&lt;/strong&gt;を使用する必要があります。</target>
        </trans-unit>
        <trans-unit id="c0e07fb933f85a6a70d4007baf685896d04ea2e6" translate="yes" xml:space="preserve">
          <source>If you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, &lt;code&gt;x = 4 if b &amp;gt; 8 else 9&lt;/code&gt; is read aloud as &lt;code&gt;x will be 4 if b is greater than 8 otherwise 9&lt;/code&gt;.</source>
          <target state="translated">順序を思い出すのに問題がある場合は、声に出して読むとき、あなたが（ほとんど）意味を言うことを思い出してください。 たとえば、 &lt;code&gt;x = 4 if b &amp;gt; 8 else 9&lt;/code&gt; はx = 4で、それ以外の場合は9が読み上げられます。</target>
        </trans-unit>
        <trans-unit id="cd86ff205ecdd4cb29b3e77564370ff6db70909b" translate="yes" xml:space="preserve">
          <source>If you're working with dictionaries, instead of using a ternary conditional, you can take advantage of &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.get&quot;&gt;&lt;code&gt;get(key, default)&lt;/code&gt;&lt;/a&gt;, for example:</source>
          <target state="translated">辞書を使用している場合、3項条件を使用する代わりに、次のように&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.get&quot;&gt; &lt;code&gt;get(key, default)&lt;/code&gt; &lt;/a&gt;を利用できます 。</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="edd7170b76e39c053ddbe154bd719895bd4a908f" translate="yes" xml:space="preserve">
          <source>In older Pythons a ternary operator is not implemented but it's possible to simulate it.</source>
          <target state="translated">古いPythonsでは三項演算子は実装されていませんが、シミュレーションは可能です。</target>
        </trans-unit>
        <trans-unit id="db9e5ecfa73258ca5cc22c532b88ad7d327d52f9" translate="yes" xml:space="preserve">
          <source>Is there an equivalent of C&amp;rsquo;s &amp;rdquo;?:&amp;rdquo; ternary operator?</source>
          <target state="translated">Cの「？::」三項演算子に相当するものはありますか？</target>
        </trans-unit>
        <trans-unit id="24d3776bac90c9fd5d21c4b1f83deb0e1d687362" translate="yes" xml:space="preserve">
          <source>It can give wrong results when &lt;code&gt;on_true&lt;/code&gt; 
 has a false boolean value.&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">&lt;code&gt;on_true&lt;/code&gt; のブール値がfalseの場合、誤った結果が生じる可能性があります。 &lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32c5b1aa401cec0ed9411d5f0dd2d88c4ce21470" translate="yes" xml:space="preserve">
          <source>It is compatible with all Python versions.</source>
          <target state="translated">Pythonのすべてのバージョンと互換性があります。</target>
        </trans-unit>
        <trans-unit id="56172c01602d5c36c8f5eafe5e58f2bda8748700" translate="yes" xml:space="preserve">
          <source>It might be safer to always implement it as:</source>
          <target state="translated">いつものように実装しておいた方が無難かもしれません。</target>
        </trans-unit>
        <trans-unit id="13ee33148a661d308d418e7ef1bba7aef5badefa" translate="yes" xml:space="preserve">
          <source>It's very common to need to assign to a variable one value or another depending on a condition.</source>
          <target state="translated">条件に応じて変数に値を代入する必要があることはよくあることです。</target>
        </trans-unit>
        <trans-unit id="a48cc90e3c4b0a15108ca2d3e639a527ccbd8f3c" translate="yes" xml:space="preserve">
          <source>Just memorize this pyramid if you have trouble remembering:</source>
          <target state="translated">覚えるのが面倒な人は、このピラミッドを暗記するだけでいい。</target>
        </trans-unit>
        <trans-unit id="b3cab6de298a55b417f1fd7ced11c4f193e7803d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it's frowned upon by some Pythonistas for several reasons:</source>
          <target state="translated">いくつかの理由でPythonistasによって嫌われていることを覚えておいてください。</target>
        </trans-unit>
        <trans-unit id="ed177662f0634eaaac95ed1a4f31f67c99f0d6e1" translate="yes" xml:space="preserve">
          <source>Knowing this, you can simply such assignments whenever you encounter them. This also works with strings and other iterables. You could assign &lt;code&gt;a&lt;/code&gt; whichever string isn't empty.</source>
          <target state="translated">これを知っていれば、そのような割り当てに遭遇したときはいつでも簡単に行うことができます。 これは文字列や他のイテラブルでも機能します。 空でない文字列を割り当てることができます。</target>
        </trans-unit>
        <trans-unit id="cabb6efdc2bfdd697f45c63b9b465ca38dfacae6" translate="yes" xml:space="preserve">
          <source>Many programming languages derived from &lt;code&gt;C&lt;/code&gt; usually have the following syntax of ternary conditional operator:</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; から派生した多くのプログラミング言語には、通常、次の3項条件演算子の構文があります。</target>
        </trans-unit>
        <trans-unit id="92d6e998ecbbd20e86ffa05b336aa618477dcb98" translate="yes" xml:space="preserve">
          <source>More a tip than an answer (don't need to repeat the obvious for the hundreth time), but I sometimes use it as a oneliner shortcut in such constructs:</source>
          <target state="translated">答えというよりもヒントですが(何度も繰り返す必要はありません)、このような構文の中では、オネリのショートカットとして使うこともあります。</target>
        </trans-unit>
        <trans-unit id="4b569996756caea7c12ec127521d9424e8e1be8c" translate="yes" xml:space="preserve">
          <source>New since version 2.5.</source>
          <target state="translated">バージョン2.5から新しくなりました。</target>
        </trans-unit>
        <trans-unit id="3c6e31105fa73f62fb4e102f8668ff8f71e6244a" translate="yes" xml:space="preserve">
          <source>Note that conditionals are an &lt;em&gt;expression&lt;/em&gt;, not a &lt;em&gt;statement&lt;/em&gt;. This means you can't use assignment statements or &lt;code&gt;pass&lt;/code&gt; or other &lt;strong&gt;statements&lt;/strong&gt; within a conditional &lt;strong&gt;expression&lt;/strong&gt;:</source>
          <target state="translated">条件&lt;em&gt;文&lt;/em&gt;は&lt;em&gt;式&lt;/em&gt;ではなく、 &lt;em&gt;ステートメントで&lt;/em&gt;あることに注意して&lt;em&gt;ください&lt;/em&gt; 。 つまり、条件&lt;strong&gt;式&lt;/strong&gt;内では代入ステートメントや &lt;code&gt;pass&lt;/code&gt; &lt;strong&gt;ステートメント&lt;/strong&gt;やその他の&lt;strong&gt;ステートメントを&lt;/strong&gt;使用できません。</target>
        </trans-unit>
        <trans-unit id="479d40d235c43adc3552914b59a66859cc395904" translate="yes" xml:space="preserve">
          <source>Note that every &lt;code&gt;if&lt;/code&gt; must be followed with an &lt;code&gt;else&lt;/code&gt;. People learning list comprehensions and generator expressions may find this to be a difficult lesson to learn - the following will not work, as Python expects a third expression for an else:</source>
          <target state="translated">すべての &lt;code&gt;if&lt;/code&gt; の後には &lt;code&gt;else&lt;/code&gt; が続く必要があることに注意してください。 リスト内包表記とジェネレータ式を学習している人は、これを学ぶのは難しいレッスンであると感じるかもしれません-Pythonはelseの3番目の式を期待しているため、以下は機能しません。</target>
        </trans-unit>
        <trans-unit id="5a744d56ca2c69c38476ac01a338fb242c1b6a64" translate="yes" xml:space="preserve">
          <source>Of course, it has the downside of always evaluating both sides (a and b), but the syntax it's way clearer to me</source>
          <target state="translated">もちろん、それは常に両側(aとb)を評価するという欠点を持っていますが、構文は私にはそれがはるかに明確です。</target>
        </trans-unit>
        <trans-unit id="1de3da6e82da1f06b4bf0d8c6161c81558b1aad4" translate="yes" xml:space="preserve">
          <source>Official documentation:</source>
          <target state="translated">公式文書。</target>
        </trans-unit>
        <trans-unit id="d0827d89564ba5e83ce93ed7166326488a92a205" translate="yes" xml:space="preserve">
          <source>One of the alternatives to Python's &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;conditional expression&lt;/a&gt;</source>
          <target state="translated">Pythonの&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;条件式&lt;/a&gt;の代替手段の1つ</target>
        </trans-unit>
        <trans-unit id="9c4550b9ecd33c573988bea3fd0c8262d2e96e4e" translate="yes" xml:space="preserve">
          <source>One solution to this would be</source>
          <target state="translated">これに対する一つの解決策は</target>
        </trans-unit>
        <trans-unit id="7b4b4244be13a3abd69c7140639a3d4f60891f6a" translate="yes" xml:space="preserve">
          <source>PS: Of course, a Short-cirquit evaluation is not a ternary operator but often the ternary is used in cases where the short circuit would be enough.</source>
          <target state="translated">追記:もちろん短絡評価は三項演算子ではありませんが、短絡で十分な場合は三項演算子を使うことが多いです。</target>
        </trans-unit>
        <trans-unit id="58792d9668c4adc810f2ca241f219f68473b10b3" translate="yes" xml:space="preserve">
          <source>Python has a ternary form for assignments; however there may be even a shorter form that people should be aware of.</source>
          <target state="translated">Pythonには課題のための三項形式がありますが、もっと短い形式もあるかもしれません。</target>
        </trans-unit>
        <trans-unit id="136139a7ae8963781743317576db7d500d885197" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;PEP 308&lt;/a&gt; for more details about conditional expressions.</source>
          <target state="translated">条件式の詳細については、 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;PEP 308&lt;/a&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="036b7b152c8e2ad2d27d64b379952563535f109f" translate="yes" xml:space="preserve">
          <source>Similarly in</source>
          <target state="translated">同様に</target>
        </trans-unit>
        <trans-unit id="c0aa83bbbe563bbcc34994245b02f09698d81bf9" translate="yes" xml:space="preserve">
          <source>Simulating the python ternary operator.</source>
          <target state="translated">pythonの三項演算子のシミュレーション。</target>
        </trans-unit>
        <trans-unit id="4509806cb94c2823fac491553c861100a38c9efc" translate="yes" xml:space="preserve">
          <source>So, a ternary conditional operation is of the form:</source>
          <target state="translated">ですから、三項条件演算は、このような形になります。</target>
        </trans-unit>
        <trans-unit id="1dee0139e43a4cbbca1778fe8b6f59248a65da5a" translate="yes" xml:space="preserve">
          <source>So, firstly it evaluates the condition. If it returns &lt;code&gt;True&lt;/code&gt;, &lt;strong&gt;expression1&lt;/strong&gt; will be evaluated to give the result, otherwise &lt;strong&gt;expression2&lt;/strong&gt; will be evaluated. Due to &lt;strong&gt;&lt;em&gt;Lazy Evaluation&lt;/em&gt;&lt;/strong&gt; mechanics &amp;ndash; only one expression will be executed.</source>
          <target state="translated">したがって、最初に条件を評価します。 &lt;code&gt;True&lt;/code&gt; を返す場合、 &lt;strong&gt;expression1&lt;/strong&gt;が評価されて結果が返されます。それ以外の場合は、 &lt;strong&gt;expression2&lt;/strong&gt;が評価されます。 &lt;strong&gt;&lt;em&gt;遅延評価の&lt;/em&gt;&lt;/strong&gt;メカニズムにより、1つの式のみが実行されます。</target>
        </trans-unit>
        <trans-unit id="5eb20a0d0f308ab00cf66a44ffce1c909d193ed8" translate="yes" xml:space="preserve">
          <source>Some (many :) may frown upon it as unpythonic (even, ruby-ish :), but I personally find it more natural - i.e. how you'd express it normally, plus a bit more visually appealing in large blocks of code.</source>
          <target state="translated">一部の人(多くの人が)は、これをピソティックではない(ルビっぽい :)と嫌悪するかもしれませんが、私は個人的にはこの方が自然だと思っています-つまり、普通に表現する方法で、しかも大きなコードブロックの中ではもう少し視覚的に魅力的です。</target>
        </trans-unit>
        <trans-unit id="10a2d2ce64f1e69ac87af7d7b375ce3f5f76b42e" translate="yes" xml:space="preserve">
          <source>Some find it &quot;unwieldy&quot;, since it goes contrary to the normal flow of thought (thinking of the condition first and then the effects).</source>
          <target state="translated">通常の思考の流れ(状態を先に考えて、次に効果を考える)に反するので、「扱いにくい」と感じる人もいます。</target>
        </trans-unit>
        <trans-unit id="83704dabdebcb46b80e236d14dd2c202687d3cc6" translate="yes" xml:space="preserve">
          <source>Stylistic reasons. (Although the 'inline &lt;code&gt;if&lt;/code&gt;' can be &lt;em&gt;really&lt;/em&gt; useful, and make your script more concise, it really does complicate your code)</source>
          <target state="translated">文体上の理由。 （「インライン &lt;code&gt;if&lt;/code&gt; 」は&lt;em&gt;本当に&lt;/em&gt;便利で、スクリプトをより簡潔にすることができますが、実際にはコードが複雑になります）</target>
        </trans-unit>
        <trans-unit id="4837041f5c57f5efb96309599742e3c0ade4c6b7" translate="yes" xml:space="preserve">
          <source>Syntax :</source>
          <target state="translated">構文 .</target>
        </trans-unit>
        <trans-unit id="8f9eb933921eaddb08703549e034102f89a91d33" translate="yes" xml:space="preserve">
          <source>Ternary conditional operator simply allows testing a condition in a single line replacing the multiline if-else making the code compact.</source>
          <target state="translated">三項条件演算子は、複数行のif-elseの代わりに一行で条件をテストすることができ、コードをコンパクトにすることができます。</target>
        </trans-unit>
        <trans-unit id="1af072bcc6d3d1e5a9aa912cd54ed63e0cf1486d" translate="yes" xml:space="preserve">
          <source>Ternary operators can be chained in series:</source>
          <target state="translated">三項演算子は直列に連鎖させることができます。</target>
        </trans-unit>
        <trans-unit id="5503cedf0d5ac8409f386d79e9175e2024368b00" translate="yes" xml:space="preserve">
          <source>The above works since &lt;code&gt;li1&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and the interp treats that as False in logic expressions. The interp then moves on and evaluates the second expression, which is not &lt;code&gt;None&lt;/code&gt; and it's not an empty list - so it gets assigned to a.</source>
          <target state="translated">上記は &lt;code&gt;li1&lt;/code&gt; が &lt;code&gt;None&lt;/code&gt; であるため機能し、interpは論理式でそれをFalseとして扱います。 次に、interpは次に進み、2番目の式を評価します。これは &lt;code&gt;None&lt;/code&gt; ではなく、空のリストではないため、aに割り当てられます。</target>
        </trans-unit>
        <trans-unit id="de0a4391febcb9cd8d58fd3e834ed43e1efb7a54" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;x if C else y&lt;/code&gt; first evaluates the condition, &lt;em&gt;C&lt;/em&gt; (&lt;em&gt;not x&lt;/em&gt;); if &lt;em&gt;C&lt;/em&gt; is true, &lt;em&gt;x&lt;/em&gt; is evaluated and its value is returned; otherwise, &lt;em&gt;y&lt;/em&gt; is evaluated and its value is returned.</source>
          <target state="translated">式 &lt;code&gt;x if C else y&lt;/code&gt; 最初に条件&lt;em&gt;C&lt;/em&gt; （ &lt;em&gt;xではない&lt;/em&gt; ）を評価します。 &lt;em&gt;C&lt;/em&gt;がtrueの場合、 &lt;em&gt;x&lt;/em&gt;が評価され、その値が返されます。 それ以外の場合は&lt;em&gt;y&lt;/em&gt;が評価され、その値が返されます。</target>
        </trans-unit>
        <trans-unit id="2af104f524b880b50f5f986ef733f30563ed3b2a" translate="yes" xml:space="preserve">
          <source>The expression exp won't be evaluated at all since &quot;and&quot; with 0 will always evaluate to zero and there is no need to evaluate the expression . This is how the compiler itself works , in all languages.</source>
          <target state="translated">0を含む &quot;and &quot;は常に0に評価され、式を評価する必要がないので、expは全く評価されません。これはコンパイラがどの言語でもどのように動作するかを示しています。</target>
        </trans-unit>
        <trans-unit id="10dcb11ae3a76a8e15945f5d2d2d49ac3a28af82" translate="yes" xml:space="preserve">
          <source>The expression exp1 won't be evaluated since False is equivalent to writing 0 and doing &quot;and&quot; with 0 would be 0 itself but after exp1 since &quot;or&quot; is used, it will evaluate the expression exp2 after &quot;or&quot; .</source>
          <target state="translated">Falseは0を書くのと同じで、0と &quot;and &quot;をするとそれ自体が0になってしまうのでexp1は評価されませんが、exp1の後は &quot;or &quot;を使うので、&quot;or &quot;の後のexp2を評価します。</target>
        </trans-unit>
        <trans-unit id="b0b0173a9bf087b41e367de32d4700aa1b3e7f88" translate="yes" xml:space="preserve">
          <source>The following one is the same as previous one:</source>
          <target state="translated">次のものは前のものと同じです。</target>
        </trans-unit>
        <trans-unit id="067a165678ff801969ed32bb8ae60f3722d4866e" translate="yes" xml:space="preserve">
          <source>The order of the arguments is different from those of the classic &lt;code&gt;condition ? a : b&lt;/code&gt; ternary operator from many other languages (such as C, C++, Go, Perl, Ruby, Java, Javascript, etc.), which may lead to bugs when people unfamiliar with Python's &quot;surprising&quot; behaviour use it (they may reverse the argument order).</source>
          <target state="translated">引数の順序が古典的な &lt;code&gt;condition ? a : b&lt;/code&gt; の順序と異なりますか？ a：b他の多くの言語（C、C ++、Go、Perl、Ruby、Java、Javascriptなど）の3項演算子。Pythonの「意外な」動作に慣れていない人が使用すると、バグが発生する可能性があります（逆になる場合があります）引数の順序）。</target>
        </trans-unit>
        <trans-unit id="7f7150ee78b704977771011e6cc40319ad111995" translate="yes" xml:space="preserve">
          <source>The part of interest is:</source>
          <target state="translated">興味のある部分は</target>
        </trans-unit>
        <trans-unit id="ecc502e972ed10fca2ccd9ef53adcd864cb4fc7b" translate="yes" xml:space="preserve">
          <source>The second expression exp2 won't be evaluated since &lt;code&gt;True and exp1&lt;/code&gt; would be True when exp1 isn't false .</source>
          <target state="translated">2番目の式exp2は &lt;code&gt;True and exp1&lt;/code&gt; 評価されません。exp1がfalseでない場合、exp1はTrueになります。</target>
        </trans-unit>
        <trans-unit id="bdb2f1d61e753c9f06341fdd6911740881590e6a" translate="yes" xml:space="preserve">
          <source>The shortest alternative remains:</source>
          <target state="translated">最短の選択肢が残っています。</target>
        </trans-unit>
        <trans-unit id="1dfd8c0a2483ad75105cf7ed865fe43abedbd49b" translate="yes" xml:space="preserve">
          <source>Think of the conditional expression as switching between two values. It is very useful when you're in a 'one value or another' situation, it but doesn't do much else.</source>
          <target state="translated">条件式は2つの値を切り替えるものと考えてください。これは、「ある値か別の値か」という状況にあるときに非常に便利ですが、それ以外のことはあまりしません。</target>
        </trans-unit>
        <trans-unit id="757bd11c077579d0812f85bcccc7725ef9ec81a5" translate="yes" xml:space="preserve">
          <source>This allows short-circuiting because when &lt;code&gt;condition&lt;/code&gt; is true only &lt;code&gt;a&lt;/code&gt; is evaluated and &lt;code&gt;b&lt;/code&gt; is not evaluated at all, but when &lt;code&gt;condition&lt;/code&gt; is false only &lt;code&gt;b&lt;/code&gt; is evaluated and &lt;code&gt;a&lt;/code&gt; is not evaluated at all.</source>
          <target state="translated">これは、 &lt;code&gt;condition&lt;/code&gt; がtrueの場合、 &lt;code&gt;b&lt;/code&gt; のみが評価され、 bはまったく評価されないため、短絡を許可しますが、 &lt;code&gt;condition&lt;/code&gt; がfalseの場合、 &lt;code&gt;b&lt;/code&gt; のみが評価され、 &lt;code&gt;a&lt;/code&gt; はまったく評価されません。</target>
        </trans-unit>
        <trans-unit id="3aa85c1834379568a2dadd44872b30d05cc9785b" translate="yes" xml:space="preserve">
          <source>This also works with empty lists. For instance, if you want to assign &lt;code&gt;a&lt;/code&gt; whichever list has items.</source>
          <target state="translated">これは空のリストでも機能します。 たとえば、アイテムがあるリストを割り当てたい場合などです。</target>
        </trans-unit>
        <trans-unit id="e427501a7bef42104eb698d56ff23ced6c553723" translate="yes" xml:space="preserve">
          <source>This would print &quot;odd&quot; if the number is odd or &quot;even&quot; if the number is even.</source>
          <target state="translated">これは、数字が奇数の場合は「奇数」、偶数の場合は「偶数」と表示されます。</target>
        </trans-unit>
        <trans-unit id="341d87306463ddc466b59261fedf82fb8984b255" translate="yes" xml:space="preserve">
          <source>Though, there is a potential problem, which if &lt;code&gt;cond&lt;/code&gt; evaluates to &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;on_true&lt;/code&gt; evaluates to &lt;code&gt;False&lt;/code&gt; then &lt;code&gt;on_false&lt;/code&gt; is returned instead of &lt;code&gt;on_true&lt;/code&gt;. If you want this behavior the method is OK, otherwise use this:</source>
          <target state="translated">&lt;code&gt;on_true&lt;/code&gt; 、潜在的な問題があり、 &lt;code&gt;cond&lt;/code&gt; が &lt;code&gt;True&lt;/code&gt; に評価され、 &lt;code&gt;on_false&lt;/code&gt; が &lt;code&gt;False&lt;/code&gt; に評価された場合、 on_trueの代わりに &lt;code&gt;on_true&lt;/code&gt; が返されます。 この動作が必要な場合はメソッドに問題はありませんが、それ以外の場合はこれを使用します。</target>
        </trans-unit>
        <trans-unit id="f7b558b3c21a3c98acd200b3647d45f05d3fca8c" translate="yes" xml:space="preserve">
          <source>Unfortunately, the</source>
          <target state="translated">残念ながら</target>
        </trans-unit>
        <trans-unit id="b4258119ca3a4370d0ee540f727c401d66415a0e" translate="yes" xml:space="preserve">
          <source>With Python, you can simply use &lt;code&gt;or&lt;/code&gt; for alternative assignments.</source>
          <target state="translated">Pythonを使用すると、 &lt;code&gt;or&lt;/code&gt; を代わりの割り当てに使用できます。</target>
        </trans-unit>
        <trans-unit id="501c4df30742de5f56942e39e4e33cb5bd40bc10" translate="yes" xml:space="preserve">
          <source>YES, python have a ternary operator, here is the syntax and an example code to demonstrate the same :)</source>
          <target state="translated">はい、Pythonは3項演算子を持っています、ここでは、構文と同じことを実証するための例のコードです。)</target>
        </trans-unit>
        <trans-unit id="4764fab14882c7824fd31afde1275c8ad9dfa5b5" translate="yes" xml:space="preserve">
          <source>Yes, it was &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;added&lt;/a&gt; in version 2.5. The expression syntax is:</source>
          <target state="translated">はい、バージョン2.5で&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;追加さ&lt;/a&gt;れました。 式の構文は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="3837222375484f4dc46135b7a771581dbcab794a" translate="yes" xml:space="preserve">
          <source>Yes. From the &lt;a href=&quot;https://docs.python.org/reference/grammar.html&quot;&gt;grammar file&lt;/a&gt;:</source>
          <target state="translated">はい。 &lt;a href=&quot;https://docs.python.org/reference/grammar.html&quot;&gt;文法ファイル&lt;/a&gt;から：</target>
        </trans-unit>
        <trans-unit id="772c57f489560211e78cb2d11c2866b9b29aa5a6" translate="yes" xml:space="preserve">
          <source>You can index into a tuple:</source>
          <target state="translated">タプルにインデックスを付けることができます。</target>
        </trans-unit>
        <trans-unit id="d31bcb3f2a3c69063ab668827d032b8b24cb2929" translate="yes" xml:space="preserve">
          <source>You can, however, use conditional expressions to assign a variable like so:</source>
          <target state="translated">しかし、条件式を使って、このように変数を代入することができます。</target>
        </trans-unit>
        <trans-unit id="b6ca419c1e37f1c6d062c1b86540910790e67eb6" translate="yes" xml:space="preserve">
          <source>You may find it somewhat painful to write the following:</source>
          <target state="translated">以下のようなことを書くのは、少々苦しいかもしれません。</target>
        </trans-unit>
        <trans-unit id="379a81c9dfbf20958f52ab889b166808e4e8c8ed" translate="yes" xml:space="preserve">
          <source>You might often find</source>
          <target state="translated">よくあることかもしれませんが</target>
        </trans-unit>
        <trans-unit id="31848eba55db40fa8ba451e1340bcdefedd1ab44" translate="yes" xml:space="preserve">
          <source>[on_true] if [expression] else [on_false]</source>
          <target state="translated">もしも [式]であれば [on_true]else [on_false]となります。</target>
        </trans-unit>
        <trans-unit id="587c8f0406732dd61ae6136de1b47c30d311764c" translate="yes" xml:space="preserve">
          <source>^ This is the long form for doing such assignments.</source>
          <target state="translated">^ このような課題を行うための長いフォームです。</target>
        </trans-unit>
        <trans-unit id="1fb45c17c40a7ce16c17847d13d5985415280f02" translate="yes" xml:space="preserve">
          <source>and used this way:</source>
          <target state="translated">と、このように使用されています。</target>
        </trans-unit>
        <trans-unit id="1cd77732f70e749c449a2d2f10a245fdb56e9f44" translate="yes" xml:space="preserve">
          <source>both &lt;code&gt;no()&lt;/code&gt; and &lt;code&gt;yes()&lt;/code&gt; are evaluated.</source>
          <target state="translated">&lt;code&gt;no()&lt;/code&gt; と &lt;code&gt;yes()&lt;/code&gt; の両方が評価されます。</target>
        </trans-unit>
        <trans-unit id="c41b42386b37a56e714bbb8ab4091873bf086bf5" translate="yes" xml:space="preserve">
          <source>but there is no alternative to</source>
          <target state="translated">に代わるものはない</target>
        </trans-unit>
        <trans-unit id="c95d2327025d475ff8b7501febaf2cb7b1ddb92f" translate="yes" xml:space="preserve">
          <source>but this lead to problem when on_true == 0</source>
          <target state="translated">しかし、これは on_true ==0 の場合に問題が発生します。</target>
        </trans-unit>
        <trans-unit id="5a7924a284bb500fda5727b50dfc64f598dc9717" translate="yes" xml:space="preserve">
          <source>however this won't work if &lt;code&gt;x&lt;/code&gt; would be &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">ただし、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;False&lt;/code&gt; の場合、これは機能しません。</target>
        </trans-unit>
        <trans-unit id="73075949ea61dd74d8b1bfeb6d8bbf8696d9ea9e" translate="yes" xml:space="preserve">
          <source>if the condition [condition] becomes &quot;True&quot; then , expression_1 will be evaluated but not expression_2 .
If we &quot;and&quot; something with 0 (zero) , the result will always to be fasle .So in the below statement ,</source>
          <target state="translated">条件[条件]が &quot;True &quot;になった場合、式_1は評価されますが、式_2は評価されません。我々は0(ゼロ)で何かを &quot;and &quot;した場合、結果は常にfasleになります。</target>
        </trans-unit>
        <trans-unit id="8347a9c362a17ba7f157573753c5e4693b113950" translate="yes" xml:space="preserve">
          <source>if variable is defined and you want to check if it has value you can just &lt;code&gt;a or b&lt;/code&gt;</source>
          <target state="translated">変数が定義されていて、それが値を持っているかどうかを確認したい場合は、単に &lt;code&gt;a or b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30f50d1b7ad8a1d8edb08847855b435a18a6162f" translate="yes" xml:space="preserve">
          <source>if you want to avoid the evaluation of &lt;code&gt;yes()&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;no()&lt;/code&gt;, because in</source>
          <target state="translated">&lt;code&gt;yes()&lt;/code&gt; &lt;em&gt;および&lt;/em&gt; &lt;code&gt;no()&lt;/code&gt; の評価を避けたい場合は、</target>
        </trans-unit>
        <trans-unit id="7dee470dedb23faec9c2b494d21fd11fc576b9cb" translate="yes" xml:space="preserve">
          <source>is the following:</source>
          <target state="translated">は次のようになります。</target>
        </trans-unit>
        <trans-unit id="20a29395163e5b9709a368d657a06041695e75bc" translate="yes" xml:space="preserve">
          <source>it can be nested as your need. best of luck</source>
          <target state="translated">必要に応じて入れ子にすることができます。</target>
        </trans-unit>
        <trans-unit id="79dec008519b31cbf101741268f604a50168381a" translate="yes" xml:space="preserve">
          <source>or explicitly constructed dictionary:</source>
          <target state="translated">または明示的に構築された辞書。</target>
        </trans-unit>
        <trans-unit id="b7bbf3b6da6885a501de4362189e82f1cd57f4ec" translate="yes" xml:space="preserve">
          <source>or you can use the built-in &lt;a href=&quot;https://docs.python.org/3.3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool()&lt;/code&gt;&lt;/a&gt; to assure a &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;Boolean&lt;/a&gt; value:</source>
          <target state="translated">または、組み込みの&lt;a href=&quot;https://docs.python.org/3.3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool()&lt;/code&gt; &lt;/a&gt;を使用して&lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;ブール&lt;/a&gt;値を保証できます。</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="0f0e94c76317c1202fb0746ef1437c8fcdd487dd" translate="yes" xml:space="preserve">
          <source>solution doesn't have short-circuit behaviour; thus both &lt;code&gt;falseValue&lt;/code&gt; and &lt;code&gt;trueValue&lt;/code&gt; are evaluated regardless of the condition. This could be suboptimal or even buggy (i.e. both &lt;code&gt;trueValue&lt;/code&gt; and &lt;code&gt;falseValue&lt;/code&gt; could be methods and have side-effects).</source>
          <target state="translated">ソリューションには短絡動作がありません。 したがって、 &lt;code&gt;falseValue&lt;/code&gt; と &lt;code&gt;trueValue&lt;/code&gt; の両方が条件に関係なく評価されます。 これは最適とは &lt;code&gt;falseValue&lt;/code&gt; ない、またはバグがある場合もあります（つまり、 &lt;code&gt;trueValue&lt;/code&gt; とfalseValueの両方がメソッドであり、 副作用がある可能性があります）。</target>
        </trans-unit>
        <trans-unit id="a274a9708a98bc4fdb9472318da8f13c3bee8f70" translate="yes" xml:space="preserve">
          <source>the expression exp won't be evaluated at all since &quot;or&quot; with 1 will always be 1. So it won't bother to evaluate the expression exp since the result will be 1 anyway . (compiler optimization methods).</source>
          <target state="translated">の場合、1を含む &quot;or &quot;は常に1になるので、式expは全く評価されません。どうせ結果は1になるので、式 exp をわざわざ評価する必要はありません。(コンパイラの最適化方法)。</target>
        </trans-unit>
        <trans-unit id="39d0c3ab7ef90c6d161469ec584ab022b15f4f10" translate="yes" xml:space="preserve">
          <source>where operands are &lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_evaluation&quot;&gt;lazily evaluated&lt;/a&gt;.</source>
          <target state="translated">ここで、オペランドは&lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_evaluation&quot;&gt;遅延評価され&lt;/a&gt;ます。</target>
        </trans-unit>
        <trans-unit id="785b497ac41614c19f3ad8ef5a1360eddd4057ed" translate="yes" xml:space="preserve">
          <source>where you would expect for a  normal ternary operator this result</source>
          <target state="translated">ここで、通常の三項演算子ではこのような結果になります。</target>
        </trans-unit>
        <trans-unit id="e43fb40cf7bf1d92d0566f4d8f907e807802db52" translate="yes" xml:space="preserve">
          <source>which can be wrapped by:</source>
          <target state="translated">で包み込むことができます。</target>
        </trans-unit>
        <trans-unit id="2a8a0f7868e57d2229b4d0eadf021b1a17426df8" translate="yes" xml:space="preserve">
          <source>which has the following nice extension:</source>
          <target state="translated">には次のような素敵な拡張機能があります。</target>
        </trans-unit>
        <trans-unit id="7497cd967a22e5c73dd2351308b5e2ef28d3ca05" translate="yes" xml:space="preserve">
          <source>which is equivalent in semantics. Note that some style-guides may limit this usage on the grounds of clarity - it does pack a lot of meaning into very little syntax.</source>
          <target state="translated">は意味論的には同等です。スタイルガイドによっては、わかりやすさを理由にこの使用法を制限する場合があることに注意してください。</target>
        </trans-unit>
        <trans-unit id="cc81a06a417041080d93a2378641c20ac0ef4865" translate="yes" xml:space="preserve">
          <source>which is equivalent to:</source>
          <target state="translated">に相当する。</target>
        </trans-unit>
        <trans-unit id="f2dc90da9b9944ad673e6b9050319bf49bdf7040" translate="yes" xml:space="preserve">
          <source>which raises a &lt;code&gt;SyntaxError: invalid syntax&lt;/code&gt;.
So the above is either an incomplete piece of logic (perhaps the user expects a no-op in the false condition) or what may be intended is to use expression2 as a filter - notes that the following is legal Python:</source>
          <target state="translated">&lt;code&gt;SyntaxError: invalid syntax&lt;/code&gt; 。 したがって、上記は不完全なロジック（おそらく、ユーザーがfalse条件で何もしないことを期待する）か、式2をフィルターとして使用することを意図したものです-以下は正当なPythonであることに注意してください：</target>
        </trans-unit>
        <trans-unit id="dee9317287e35bb56b2a38da732e9512ed8decb4" translate="yes" xml:space="preserve">
          <source>will output</source>
          <target state="translated">を出力します。</target>
        </trans-unit>
        <trans-unit id="36c7911bf17eb1c668d4ee0aa1aabedcd02fc3a1" translate="yes" xml:space="preserve">
          <source>you can do this :-</source>
          <target state="translated">あなたはこれをすることができます :-。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
