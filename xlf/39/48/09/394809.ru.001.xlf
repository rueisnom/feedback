<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/394809">
    <body>
      <group id="394809">
        <trans-unit id="70ab045269befc703f5853d363741cd4809122f9" translate="yes" xml:space="preserve">
          <source>(execution delayed until the winner is known ;)), but it introduces inconsistency between callable and non-callable objects. In addition, it doesn't solve the case when using properties.</source>
          <target state="translated">(исполнение откладывается до тех пор,пока не будет известен победитель ;)),но при этом вводится несоответствие между вызываемыми и не вызываемыми объектами.Кроме того,это не решает проблему при использовании свойств.</target>
        </trans-unit>
        <trans-unit id="8cb713133a6c1d41da9b697de8bb604304078011" translate="yes" xml:space="preserve">
          <source>, becomes:</source>
          <target state="translated">становится:</target>
        </trans-unit>
        <trans-unit id="40f40c03a1271b3952ed519b50c12fd149dc92e6" translate="yes" xml:space="preserve">
          <source>1- Simple Method to use ternary operator:</source>
          <target state="translated">1-Простой метод использования тернарного оператора:</target>
        </trans-unit>
        <trans-unit id="d848fcf366a8ef37a8ff9e843fba0d9be57b73fb" translate="yes" xml:space="preserve">
          <source>2- Direct Method of using tuples, Dictionary, and lambda:</source>
          <target state="translated">2-Прямой метод использования кортежей,словаря и лямбды:</target>
        </trans-unit>
        <trans-unit id="1aae16e227a970760713cda0dda545cb5d3699fe" translate="yes" xml:space="preserve">
          <source>3- Ternary operator can be written as nested if-else:</source>
          <target state="translated">3-Тернарный оператор может быть записан как вложенный if-else:</target>
        </trans-unit>
        <trans-unit id="044a950e94c378180ffa7793e1030478e33e33d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression1&lt;/code&gt; will have to be evaluated twice with the above usage. It can limit redundancy if it is simply a local variable. However, a common and performant Pythonic idiom for this use-case is to use &lt;code&gt;or&lt;/code&gt;'s shortcutting behavior:</source>
          <target state="translated">&lt;code&gt;expression1&lt;/code&gt; должно быть оценено дважды с использованием вышеупомянутого. Это может ограничить избыточность, если это просто локальная переменная. Тем не менее, распространенным и эффективным Pythonic идиома для этого варианта использования является использование &lt;code&gt;or&lt;/code&gt; сокращенное поведение:</target>
        </trans-unit>
        <trans-unit id="334c175549b49453b828bca8b2a67a5cca8af5cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression2&lt;/code&gt; works as a filter for the list comprehension, and is &lt;em&gt;not&lt;/em&gt; a ternary conditional operator.</source>
          <target state="translated">&lt;code&gt;expression2&lt;/code&gt; работает как фильтр для понимания списка и &lt;em&gt;не&lt;/em&gt; является тройным условным оператором.</target>
        </trans-unit>
        <trans-unit id="5dab472beecae7e7e8dfecfe05a0c2d9f3e3ecd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression3&lt;/code&gt; will be lazily evaluated (that is, evaluated only if &lt;code&gt;expression2&lt;/code&gt; is false in a boolean context). And because of the recursive definition, you can chain them indefinitely (though it may considered bad style.)</source>
          <target state="translated">&lt;code&gt;expression3&lt;/code&gt; будет лениво оцениваться (то есть оцениваться только в том случае, если &lt;code&gt;expression2&lt;/code&gt; имеет значение false в логическом контексте). И из-за рекурсивного определения вы можете связывать их бесконечно (хотя это может считаться плохим стилем).</target>
        </trans-unit>
        <trans-unit id="29c4f62bef87062fb6570c3ab3b8996c0383d73f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test&lt;/code&gt; needs to return &lt;em&gt;True&lt;/em&gt; or &lt;em&gt;False&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; должен вернуть &lt;em&gt;True&lt;/em&gt; или &lt;em&gt;False&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="3fae46c5ec8c22f65a6e958eb8f75ef995296321" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A neat way to chain multiple operators:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Аккуратный способ связать несколько операторов:&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a301bfe415904b8134c76d76fa61ec8147dc8ee2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary Operator in Javascript&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Тернарный оператор в Javascript&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa49ba0541262da7d41f0f4081422b0ba2554c7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary Operator in Ruby&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Троичный оператор в рубине&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35cb1a58f55a6ac1ac6b936dfb825e64d5a5f996" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary operator in Python&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Тернарный оператор в Python&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1a00fe97ba444ce4af43b0aa2eb087ce13ccd36" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary operator in R programming&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Тернарный оператор в R-программировании&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f11633b413a20a2ad39481a598a7473cdd7868d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary operator in Scala&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Тернарный оператор в Скале&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57ae2a1bc4b2cd461a9d0deedcd0dc94cde72aef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;[condition] and [expression_1] or [expression_2] ;&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;[condition] and [expression_1] or [expression_2] ;&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c135775097dd01254c74e73b8797ce9763f03653" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case you still want to make it work for all the cases regardless of what exp_1 and exp_2 truth values are, do this :-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Если вы все еще хотите, чтобы он работал во всех случаях, независимо от того, какие значения истинности exp_1 и exp_2, сделайте следующее: -&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f445f66b4684e3ca1e89dff63c6cf9c6b9a2085" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note :-&lt;/strong&gt; 0 , None , False , emptylist , emptyString evaluates as False.
And any data other than 0 evaluates to True.</source>
          <target state="translated">&lt;strong&gt;Примечание: -&lt;/strong&gt; 0, None, False, emptylist, emptyString оценивается как False. И любые данные, кроме 0, оцениваются как True.</target>
        </trans-unit>
        <trans-unit id="8904df4a64a6f105d991168d30a94c94e66eb44d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:-&lt;/strong&gt; This kind of branching using &quot;or&quot; and &quot;and&quot; can only be used when the expression_1 doesn't have a Truth value of False (or 0 or None or emptylist [ ] or emptystring ' '.) since if expression_1 becomes False , then the expression_2 will be evaluated because of the presence &quot;or&quot; between exp_1 and exp_2.</source>
          <target state="translated">&lt;strong&gt;Примечание: -&lt;/strong&gt; Этот вид ветвления с использованием &amp;laquo;или&amp;raquo; и &amp;laquo;и&amp;raquo; можно использовать только тогда, когда выражение_1 не имеет значения Истина False (или 0, или Нет, или emptylist [], или emptystring ''.), Так как если выражение_1 становится Ложь, тогда выражение_2 будет оцениваться из-за наличия &amp;laquo;или&amp;raquo; между exp_1 и exp_2.</target>
        </trans-unit>
        <trans-unit id="93c71edf58c5ab505268c88d73e083ab4ff69b1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ternary Operator in different programming Languages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Тернарный оператор на разных языках программирования&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0082dd6b907a273d541b44f98e346b6ffade9988" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result :-&lt;/strong&gt;  If condition is true exp_1 is executed else exp_2 is executed.</source>
          <target state="translated">&lt;strong&gt;Результат: -&lt;/strong&gt; Если условие истинно, выполняется exp_1, иначе выполняется exp_2.</target>
        </trans-unit>
        <trans-unit id="5d726f2ccbdf4ef2112e79b46394efd7a26bdb15" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;1. &lt;a href=&quot;http://docs.python.org/3.3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator&quot;&gt;Is there an equivalent of C&amp;rsquo;s &amp;rdquo;?:&amp;rdquo; ternary operator?&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;1. &lt;a href=&quot;http://docs.python.org/3.3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator&quot;&gt;Существует ли эквивалент троичного оператора &amp;laquo;?:&amp;raquo;?&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="0bdf2155f1318aca0a1e6ff9bab81d9a15d7e099" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Source: &lt;a href=&quot;https://en.wikipedia.org/wiki/%3F:#Python&quot;&gt;?: in Python at Wikipedia&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;Источник: &lt;a href=&quot;https://en.wikipedia.org/wiki/%3F:#Python&quot;&gt;?: В Python в Википедии&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="47137144ef43e236132e42d4c3cd332e4cc3ec7f" translate="yes" xml:space="preserve">
          <source>A note on usage:</source>
          <target state="translated">Записка об использовании:</target>
        </trans-unit>
        <trans-unit id="9d0a430e9f1e437bba549167d60e32cd4b925015" translate="yes" xml:space="preserve">
          <source>A possible workaround is to make &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; lists or tuples as in the following:</source>
          <target state="translated">Возможный обходной путь - создать списки или кортежи &lt;code&gt;x&lt;/code&gt; и &lt;code&gt;y&lt;/code&gt; , как показано ниже:</target>
        </trans-unit>
        <trans-unit id="fe56c5e5a4d9f35e186ec5eb03b16ba91ecd7267" translate="yes" xml:space="preserve">
          <source>Above approach can be written as:</source>
          <target state="translated">Вышеуказанный подход может быть написан как:</target>
        </trans-unit>
        <trans-unit id="aa5bb41606c2c5c53748e18b932c8d70cf7312ab" translate="yes" xml:space="preserve">
          <source>Additional information:</source>
          <target state="translated">Дополнительная информация:</target>
        </trans-unit>
        <trans-unit id="f9cce9f391b0f087eec06d00b08402a5a533e1df" translate="yes" xml:space="preserve">
          <source>Alternative syntax for a more narrow case:</source>
          <target state="translated">Альтернативный синтаксис для более узкого случая:</target>
        </trans-unit>
        <trans-unit id="4c7eaa8bf582781c438a6973636b946051d550a6" translate="yes" xml:space="preserve">
          <source>Although it does have the benefit of evaluating expressions left to right, which is clearer in my opinion.</source>
          <target state="translated">Хотя,на мой взгляд,в этом есть преимущество оценки выражений слева направо.</target>
        </trans-unit>
        <trans-unit id="4243fff9331bddbb87ee3995bde3a9f8c62ecdf0" translate="yes" xml:space="preserve">
          <source>An operator for a conditional expression in Python was added in 2006 as part of &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;Python Enhancement Proposal 308&lt;/a&gt;. Its form differ from common &lt;code&gt;?:&lt;/code&gt; operator and it's:</source>
          <target state="translated">Оператор для условного выражения в Python был добавлен в 2006 году как часть &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;предложения 308 по улучшению Python&lt;/a&gt; . Его форма отличается от обычной &lt;code&gt;?:&lt;/code&gt; Оператор и это:</target>
        </trans-unit>
        <trans-unit id="6d802d348de05c371872aaa136e43ae4790bb661" translate="yes" xml:space="preserve">
          <source>And so the story goes - choosing between 3 mentioned solutions is a trade-off between having the short-circuit feature, using at least Зython 2.5 (IMHO not a problem anymore) and not being prone to &quot;&lt;code&gt;trueValue&lt;/code&gt;-evaluates-to-false&quot; errors.</source>
          <target state="translated">Итак, история такова: выбор между 3 упомянутыми решениями - это компромисс между наличием функции короткого замыкания, использованием не менее yython 2.5 (ИМХО больше не проблема) и отсутствием склонности к &amp;laquo; &lt;code&gt;trueValue&lt;/code&gt; -evaluates-to-false&amp;raquo; ошибки.</target>
        </trans-unit>
        <trans-unit id="9db147c5133a121c92efce9f531259e88a815251" translate="yes" xml:space="preserve">
          <source>Another (less reliable), but simpler method is to use &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators:</source>
          <target state="translated">Другим (менее надежным), но более простым способом является использование операторов &lt;code&gt;and&lt;/code&gt; и &lt;code&gt;or&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f29869a5fb045eacca16998a249d59fe4a1ef72e" translate="yes" xml:space="preserve">
          <source>Another syntax which can be used (compatible with versions before 2.5):</source>
          <target state="translated">Другой синтаксис,который может быть использован (совместимый с версиями до 2.5):</target>
        </trans-unit>
        <trans-unit id="6ede496e52093534454faa827678b96dc14a0bde" translate="yes" xml:space="preserve">
          <source>Another way is by indexing a tuple (which isn't consistent with the conditional operator of most other languages):</source>
          <target state="translated">Другой способ-индексирование кортежа (что не согласуется с условным оператором большинства других языков):</target>
        </trans-unit>
        <trans-unit id="e5d8acdf91b2bad1764fb5d525bdb392c6e78228" translate="yes" xml:space="preserve">
          <source>As already answered, yes there is a ternary operator in python:</source>
          <target state="translated">Как уже ответили,да,в питоне есть тернарный оператор:</target>
        </trans-unit>
        <trans-unit id="10eeb6250c3d1364e2b4a11d28ce4b006bc96176" translate="yes" xml:space="preserve">
          <source>At first, the &lt;code&gt;Python&lt;/code&gt;&lt;strong&gt;B&lt;/strong&gt;enevolent &lt;strong&gt;D&lt;/strong&gt;ictator &lt;strong&gt;F&lt;/strong&gt;or &lt;strong&gt;L&lt;/strong&gt;ife (I mean Guido van Rossum, of course) rejected it (as non-Pythonic style), since it's quite hard to understand for people not used to &lt;code&gt;C&lt;/code&gt; language. Also, the colon sign &lt;strong&gt;&lt;code&gt;:&lt;/code&gt;&lt;/strong&gt; already has many uses in &lt;code&gt;Python&lt;/code&gt;. After &lt;strong&gt;PEP 308&lt;/strong&gt; was approved, &lt;code&gt;Python&lt;/code&gt; finally received its own shortcut conditional expression (what we use now):</source>
          <target state="translated">Поначалу энтузиазм &lt;strong&gt;D&lt;/strong&gt; Dictator &lt;strong&gt;F&lt;/strong&gt; или Life в &lt;code&gt;Python&lt;/code&gt; (я имею в виду Гвидо ван Россума, конечно) отверг его (как непитоновский стиль), так как это довольно трудно понять людям, не привыкшим к языку &lt;code&gt;C&lt;/code&gt; . Кроме того, знак двоеточия &lt;strong&gt; &lt;code&gt;:&lt;/code&gt; &lt;/strong&gt; уже много используется в &lt;code&gt;Python&lt;/code&gt; . После утверждения &lt;strong&gt;PEP 308&lt;/strong&gt; &lt;code&gt;Python&lt;/code&gt; , наконец, получил собственное условное выражение (то, что мы используем сейчас):</target>
        </trans-unit>
        <trans-unit id="dd29e09af960c8454a520e8b4d704fdf79a455d7" translate="yes" xml:space="preserve">
          <source>Below is the ternary form. But this isn't most succinct way - see last example.</source>
          <target state="translated">Ниже-троичная форма.Но это не самый лаконичный способ-см.последний пример.</target>
        </trans-unit>
        <trans-unit id="54ab93ad34df3c1e05aa8130fd92ecad93172607" translate="yes" xml:space="preserve">
          <source>But in case of</source>
          <target state="translated">Но в случае,если</target>
        </trans-unit>
        <trans-unit id="e428c12fd355944b5e6b7023bd80dd3c17b5aee5" translate="yes" xml:space="preserve">
          <source>Conditional expressions</source>
          <target state="translated">Условные выражения</target>
        </trans-unit>
        <trans-unit id="53209a5d3bcb5ef6226a6a63af2411fb4329ea1a" translate="yes" xml:space="preserve">
          <source>Conditional expressions (sometimes called a &amp;ldquo;ternary operator&amp;rdquo;) have the lowest priority of all Python operations.</source>
          <target state="translated">Условные выражения (иногда называемые &amp;laquo;троичным оператором&amp;raquo;) имеют самый низкий приоритет среди всех операций Python.</target>
        </trans-unit>
        <trans-unit id="43e7ce9b3100f9c4cee6083bc0c5c0ecc62fe1d3" translate="yes" xml:space="preserve">
          <source>Does Python have a ternary conditional operator</source>
          <target state="translated">Есть ли у Python тернарный условный оператор</target>
        </trans-unit>
        <trans-unit id="1a6fd40c1dc466260f6a3434319de40a40079b42" translate="yes" xml:space="preserve">
          <source>Does Python have a ternary conditional operator?</source>
          <target state="translated">У Python есть троичный условный оператор?</target>
        </trans-unit>
        <trans-unit id="08ec689e9d96535ecd7d37b8542dacd3113a01d8" translate="yes" xml:space="preserve">
          <source>Example:-</source>
          <target state="translated">Example:-</target>
        </trans-unit>
        <trans-unit id="f67e732e29a09166934752e7537614b263f98276" translate="yes" xml:space="preserve">
          <source>First &lt;code&gt;condition&lt;/code&gt; is evaluated, then exactly one of either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is evaluated and returned based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;Boolean&lt;/a&gt; value of &lt;code&gt;condition&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; evaluates to &lt;code&gt;True&lt;/code&gt;, then &lt;code&gt;a&lt;/code&gt; is evaluated and returned but &lt;code&gt;b&lt;/code&gt; is ignored, or else when &lt;code&gt;b&lt;/code&gt; is evaluated and returned but &lt;code&gt;a&lt;/code&gt; is ignored.</source>
          <target state="translated">Сначала оценивается &lt;code&gt;condition&lt;/code&gt; , затем точно одно из значений &lt;code&gt;a&lt;/code&gt; или &lt;code&gt;b&lt;/code&gt; вычисляется и возвращается на основе &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;логического&lt;/a&gt; значения &lt;code&gt;condition&lt;/code&gt; . Если &lt;code&gt;condition&lt;/code&gt; оценивается как &lt;code&gt;True&lt;/code&gt; , то &lt;code&gt;a&lt;/code&gt; вычисляется и возвращается, но &lt;code&gt;b&lt;/code&gt; игнорируется, или же, когда &lt;code&gt;b&lt;/code&gt; вычисляется и возвращается, но &lt;code&gt;a&lt;/code&gt; игнорируется.</target>
        </trans-unit>
        <trans-unit id="e65f8fce57a4328cfd936e7c997b733995619b23" translate="yes" xml:space="preserve">
          <source>For Python 2.5 and newer there is a specific syntax:</source>
          <target state="translated">Для Python 2.5 и более новых версий существует специфический синтаксис:</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">Например</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Например:</target>
        </trans-unit>
        <trans-unit id="73ed66c8963b3d8dd7afa66295f9854e375e8607" translate="yes" xml:space="preserve">
          <source>For versions prior to 2.5, there's the trick:</source>
          <target state="translated">Для версий до 2.5,есть трюк:</target>
        </trans-unit>
        <trans-unit id="92945ac06e73038a2bde16da80172b032aba2bb3" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#conditional-expressions&quot;&gt;the documentation&lt;/a&gt;:</source>
          <target state="translated">Из &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#conditional-expressions&quot;&gt;документации&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="05e2cc02796cc541f46aedf7a50bc4121d7e8342" translate="yes" xml:space="preserve">
          <source>Here I just try to show some important difference in &lt;code&gt;ternary operator&lt;/code&gt; between a couple of programming languages.</source>
          <target state="translated">Здесь я просто пытаюсь показать некоторые важные различия в &lt;code&gt;ternary operator&lt;/code&gt; между несколькими языками программирования.</target>
        </trans-unit>
        <trans-unit id="77a6b125fd3cd1ac92bbf113c153321aee865a77" translate="yes" xml:space="preserve">
          <source>Here are some examples (conditions will be evaluated from left to right):</source>
          <target state="translated">Вот несколько примеров (условия будут оцениваться слева направо):</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">Вот пример:</target>
        </trans-unit>
        <trans-unit id="dcae16de665cdab304c88fb675786b95de0fc2e3" translate="yes" xml:space="preserve">
          <source>Here's how it works:</source>
          <target state="translated">Вот как это работает:</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">Надеюсь,это поможет.</target>
        </trans-unit>
        <trans-unit id="37ead08d0a3de9126fb757db960eb29eba55180c" translate="yes" xml:space="preserve">
          <source>I always liked the C ternary syntax, but Python takes it a step further!</source>
          <target state="translated">Мне всегда нравился синтаксис троичников на языке С,но Python делает шаг вперед!</target>
        </trans-unit>
        <trans-unit id="2fc5c24905a2271acf5a9e03baac33ba14f9bc08" translate="yes" xml:space="preserve">
          <source>I find cumbersome the default python syntax &lt;code&gt;val = a if cond else b&lt;/code&gt;, so sometimes I do this:</source>
          <target state="translated">Я нахожу громоздким синтаксис по умолчанию для Python &lt;code&gt;val = a if cond else b&lt;/code&gt; , поэтому иногда я делаю это:</target>
        </trans-unit>
        <trans-unit id="2e767bec6a36856af0721a196a27cd634af23fc7" translate="yes" xml:space="preserve">
          <source>I understand that some may say this isn't a good stylistic choice because it relies on mechanics that aren't immediately apparent to all developers. I personally disagree with that viewpoint. Python is a syntax rich language with lots of idiomatic tricks that aren't immediately apparent to the dabler. But the more you learn and understand the mechanics of the underlying system, the more you appreciate it.</source>
          <target state="translated">Я понимаю,что некоторые могут сказать,что это не очень хороший стилистический выбор,потому что он основан на механике,которая не сразу бросается в глаза всем разработчикам.Лично я не согласен с этой точкой зрения.Python-язык,богатый синтаксисом и множеством идиоматических хитростей,которые не сразу бросаются в глаза скатерти.Но чем больше вы изучаете и понимаете механику базовой системы,тем больше вы цените его.</target>
        </trans-unit>
        <trans-unit id="4c43044d1cee7d9be8a45db13e7115d6ebb09ae0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;expression 1&amp;gt;&lt;/code&gt; is the condition you can use &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;Short-cirquit evaluation&lt;/a&gt;:</source>
          <target state="translated">Если &lt;code&gt;&amp;lt;expression 1&amp;gt;&lt;/code&gt; является условием, вы можете использовать &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;оценку короткого замыкания&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c7b7a1b690cd2aa8c0d47a1a173633ac7de09ad9" translate="yes" xml:space="preserve">
          <source>If Python does not have a ternary conditional operator, is it possible to simulate one using other language constructs?</source>
          <target state="translated">Если на Python нет троичного условного оператора,можно ли симулировать один с помощью других языковых конструкций?</target>
        </trans-unit>
        <trans-unit id="0e97f70a139ffcfa1a24114a4591be1fca3125fb" translate="yes" xml:space="preserve">
          <source>If you need to use statements, you have to use a normal &lt;code&gt;if&lt;/code&gt;&lt;strong&gt;statement&lt;/strong&gt; instead of a conditional &lt;strong&gt;expression&lt;/strong&gt;.</source>
          <target state="translated">Если вам нужно использовать операторы, вы должны использовать обычный &lt;strong&gt;оператор&lt;/strong&gt; &lt;code&gt;if&lt;/code&gt; вместо условного &lt;strong&gt;выражения&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c0e07fb933f85a6a70d4007baf685896d04ea2e6" translate="yes" xml:space="preserve">
          <source>If you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, &lt;code&gt;x = 4 if b &amp;gt; 8 else 9&lt;/code&gt; is read aloud as &lt;code&gt;x will be 4 if b is greater than 8 otherwise 9&lt;/code&gt;.</source>
          <target state="translated">Если у вас возникают проблемы с запоминанием порядка, помните, что когда вы читаете вслух, вы (почти) говорите, что имеете в виду. Например, &lt;code&gt;x = 4 if b &amp;gt; 8 else 9&lt;/code&gt; читается вслух, поскольку &lt;code&gt;x will be 4 if b is greater than 8 otherwise 9&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd86ff205ecdd4cb29b3e77564370ff6db70909b" translate="yes" xml:space="preserve">
          <source>If you're working with dictionaries, instead of using a ternary conditional, you can take advantage of &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.get&quot;&gt;&lt;code&gt;get(key, default)&lt;/code&gt;&lt;/a&gt;, for example:</source>
          <target state="translated">Если вы работаете со словарями, вместо использования троичного условного выражения вы можете воспользоваться &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.get&quot;&gt; &lt;code&gt;get(key, default)&lt;/code&gt; &lt;/a&gt; , например:</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="edd7170b76e39c053ddbe154bd719895bd4a908f" translate="yes" xml:space="preserve">
          <source>In older Pythons a ternary operator is not implemented but it's possible to simulate it.</source>
          <target state="translated">В старых Pythons тернарный оператор не реализован,но его можно смоделировать.</target>
        </trans-unit>
        <trans-unit id="db9e5ecfa73258ca5cc22c532b88ad7d327d52f9" translate="yes" xml:space="preserve">
          <source>Is there an equivalent of C&amp;rsquo;s &amp;rdquo;?:&amp;rdquo; ternary operator?</source>
          <target state="translated">Существует ли эквивалент троичного оператора C?</target>
        </trans-unit>
        <trans-unit id="24d3776bac90c9fd5d21c4b1f83deb0e1d687362" translate="yes" xml:space="preserve">
          <source>It can give wrong results when &lt;code&gt;on_true&lt;/code&gt; 
 has a false boolean value.&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">Это может дать неправильные результаты, когда &lt;code&gt;on_true&lt;/code&gt; имеет ложное логическое значение. &lt;sup&gt;1&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32c5b1aa401cec0ed9411d5f0dd2d88c4ce21470" translate="yes" xml:space="preserve">
          <source>It is compatible with all Python versions.</source>
          <target state="translated">Он совместим со всеми версиями Python.</target>
        </trans-unit>
        <trans-unit id="56172c01602d5c36c8f5eafe5e58f2bda8748700" translate="yes" xml:space="preserve">
          <source>It might be safer to always implement it as:</source>
          <target state="translated">Может быть,безопаснее всегда выполнять его как:</target>
        </trans-unit>
        <trans-unit id="13ee33148a661d308d418e7ef1bba7aef5badefa" translate="yes" xml:space="preserve">
          <source>It's very common to need to assign to a variable one value or another depending on a condition.</source>
          <target state="translated">Очень часто возникает необходимость присвоения переменной того или иного значения в зависимости от условия.</target>
        </trans-unit>
        <trans-unit id="a48cc90e3c4b0a15108ca2d3e639a527ccbd8f3c" translate="yes" xml:space="preserve">
          <source>Just memorize this pyramid if you have trouble remembering:</source>
          <target state="translated">Просто запомни эту пирамиду,если у тебя проблемы с памятью:</target>
        </trans-unit>
        <trans-unit id="b3cab6de298a55b417f1fd7ced11c4f193e7803d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it's frowned upon by some Pythonistas for several reasons:</source>
          <target state="translated">Имейте в виду,что его хмурят некоторые питонисты по нескольким причинам:</target>
        </trans-unit>
        <trans-unit id="ed177662f0634eaaac95ed1a4f31f67c99f0d6e1" translate="yes" xml:space="preserve">
          <source>Knowing this, you can simply such assignments whenever you encounter them. This also works with strings and other iterables. You could assign &lt;code&gt;a&lt;/code&gt; whichever string isn't empty.</source>
          <target state="translated">Зная это, вы можете просто выполнять такие задания, когда сталкиваетесь с ними. Это также работает со строками и другими итерациями. Вы можете назначить любую пустую строку.</target>
        </trans-unit>
        <trans-unit id="cabb6efdc2bfdd697f45c63b9b465ca38dfacae6" translate="yes" xml:space="preserve">
          <source>Many programming languages derived from &lt;code&gt;C&lt;/code&gt; usually have the following syntax of ternary conditional operator:</source>
          <target state="translated">Многие языки программирования, производные от &lt;code&gt;C&lt;/code&gt; , обычно имеют следующий синтаксис троичного условного оператора:</target>
        </trans-unit>
        <trans-unit id="92d6e998ecbbd20e86ffa05b336aa618477dcb98" translate="yes" xml:space="preserve">
          <source>More a tip than an answer (don't need to repeat the obvious for the hundreth time), but I sometimes use it as a oneliner shortcut in such constructs:</source>
          <target state="translated">Больше чаевых,чем ответов (не нужно повторять очевидное в сотый раз),но я иногда использую его как одноразовый ярлык в таких конструкциях:</target>
        </trans-unit>
        <trans-unit id="4b569996756caea7c12ec127521d9424e8e1be8c" translate="yes" xml:space="preserve">
          <source>New since version 2.5.</source>
          <target state="translated">Новинка с версии 2.5.</target>
        </trans-unit>
        <trans-unit id="3c6e31105fa73f62fb4e102f8668ff8f71e6244a" translate="yes" xml:space="preserve">
          <source>Note that conditionals are an &lt;em&gt;expression&lt;/em&gt;, not a &lt;em&gt;statement&lt;/em&gt;. This means you can't use assignment statements or &lt;code&gt;pass&lt;/code&gt; or other &lt;strong&gt;statements&lt;/strong&gt; within a conditional &lt;strong&gt;expression&lt;/strong&gt;:</source>
          <target state="translated">Обратите внимание, что условные &lt;em&gt;выражения&lt;/em&gt; - это &lt;em&gt;выражение&lt;/em&gt; , а не &lt;em&gt;утверждение&lt;/em&gt; . Это означает, что вы не можете использовать операторы присваивания или &lt;code&gt;pass&lt;/code&gt; или другие &lt;strong&gt;операторы&lt;/strong&gt; в условном &lt;strong&gt;выражении&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="479d40d235c43adc3552914b59a66859cc395904" translate="yes" xml:space="preserve">
          <source>Note that every &lt;code&gt;if&lt;/code&gt; must be followed with an &lt;code&gt;else&lt;/code&gt;. People learning list comprehensions and generator expressions may find this to be a difficult lesson to learn - the following will not work, as Python expects a third expression for an else:</source>
          <target state="translated">Обратите внимание, что каждый &lt;code&gt;if&lt;/code&gt; должен сопровождаться &lt;code&gt;else&lt;/code&gt; . Люди, изучающие списки и выражения генераторов, могут найти этот урок трудным для изучения - следующее не сработает, так как Python ожидает третьего выражения для else:</target>
        </trans-unit>
        <trans-unit id="5a744d56ca2c69c38476ac01a338fb242c1b6a64" translate="yes" xml:space="preserve">
          <source>Of course, it has the downside of always evaluating both sides (a and b), but the syntax it's way clearer to me</source>
          <target state="translated">Конечно,у него есть обратная сторона-всегда оценивать обе стороны (a и b),но синтаксис для меня намного яснее.</target>
        </trans-unit>
        <trans-unit id="1de3da6e82da1f06b4bf0d8c6161c81558b1aad4" translate="yes" xml:space="preserve">
          <source>Official documentation:</source>
          <target state="translated">Официальная документация:</target>
        </trans-unit>
        <trans-unit id="d0827d89564ba5e83ce93ed7166326488a92a205" translate="yes" xml:space="preserve">
          <source>One of the alternatives to Python's &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;conditional expression&lt;/a&gt;</source>
          <target state="translated">Одна из альтернатив &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;условному выражению&lt;/a&gt; Python</target>
        </trans-unit>
        <trans-unit id="9c4550b9ecd33c573988bea3fd0c8262d2e96e4e" translate="yes" xml:space="preserve">
          <source>One solution to this would be</source>
          <target state="translated">Одно из решений этой проблемы могло бы заключаться в следующем</target>
        </trans-unit>
        <trans-unit id="7b4b4244be13a3abd69c7140639a3d4f60891f6a" translate="yes" xml:space="preserve">
          <source>PS: Of course, a Short-cirquit evaluation is not a ternary operator but often the ternary is used in cases where the short circuit would be enough.</source>
          <target state="translated">PS:Конечно,оценка короткого замыкания не является троичным оператором,но часто троичный оператор используется в тех случаях,когда короткого замыкания было бы достаточно.</target>
        </trans-unit>
        <trans-unit id="58792d9668c4adc810f2ca241f219f68473b10b3" translate="yes" xml:space="preserve">
          <source>Python has a ternary form for assignments; however there may be even a shorter form that people should be aware of.</source>
          <target state="translated">На Python есть троичная форма для заданий;однако может быть даже более короткая форма,о которой люди должны знать.</target>
        </trans-unit>
        <trans-unit id="136139a7ae8963781743317576db7d500d885197" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;PEP 308&lt;/a&gt; for more details about conditional expressions.</source>
          <target state="translated">См. &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;PEP 308&lt;/a&gt; для более подробной информации об условных выражениях.</target>
        </trans-unit>
        <trans-unit id="036b7b152c8e2ad2d27d64b379952563535f109f" translate="yes" xml:space="preserve">
          <source>Similarly in</source>
          <target state="translated">Аналогично этому в</target>
        </trans-unit>
        <trans-unit id="c0aa83bbbe563bbcc34994245b02f09698d81bf9" translate="yes" xml:space="preserve">
          <source>Simulating the python ternary operator.</source>
          <target state="translated">Моделирование питон-тернарного оператора.</target>
        </trans-unit>
        <trans-unit id="4509806cb94c2823fac491553c861100a38c9efc" translate="yes" xml:space="preserve">
          <source>So, a ternary conditional operation is of the form:</source>
          <target state="translated">Итак,тернарная условная операция имеет форму:</target>
        </trans-unit>
        <trans-unit id="1dee0139e43a4cbbca1778fe8b6f59248a65da5a" translate="yes" xml:space="preserve">
          <source>So, firstly it evaluates the condition. If it returns &lt;code&gt;True&lt;/code&gt;, &lt;strong&gt;expression1&lt;/strong&gt; will be evaluated to give the result, otherwise &lt;strong&gt;expression2&lt;/strong&gt; will be evaluated. Due to &lt;strong&gt;&lt;em&gt;Lazy Evaluation&lt;/em&gt;&lt;/strong&gt; mechanics &amp;ndash; only one expression will be executed.</source>
          <target state="translated">Итак, во-первых, он оценивает состояние. Если он возвращает &lt;code&gt;True&lt;/code&gt; , &lt;strong&gt;выражение1&lt;/strong&gt; будет оцениваться для получения результата, в противном случае &lt;strong&gt;выражение2&lt;/strong&gt; будет оцениваться. Из-за механики &lt;strong&gt;&lt;em&gt;Lazy Evaluation&lt;/em&gt;&lt;/strong&gt; - будет выполнено только одно выражение.</target>
        </trans-unit>
        <trans-unit id="5eb20a0d0f308ab00cf66a44ffce1c909d193ed8" translate="yes" xml:space="preserve">
          <source>Some (many :) may frown upon it as unpythonic (even, ruby-ish :), but I personally find it more natural - i.e. how you'd express it normally, plus a bit more visually appealing in large blocks of code.</source>
          <target state="translated">Некоторые (многие :)могут хмуриться на него как на непитонический (даже рубиновый :),но лично я нахожу его более естественным-т.е.то,как бы вы выражали его нормально,плюс немного более визуально привлекательным в больших блоках кода.</target>
        </trans-unit>
        <trans-unit id="10a2d2ce64f1e69ac87af7d7b375ce3f5f76b42e" translate="yes" xml:space="preserve">
          <source>Some find it &quot;unwieldy&quot;, since it goes contrary to the normal flow of thought (thinking of the condition first and then the effects).</source>
          <target state="translated">Некоторые находят его &quot;громоздким&quot;,так как он противоречит нормальному течению мысли (сначала думая о состоянии,а затем и об эффектах).</target>
        </trans-unit>
        <trans-unit id="83704dabdebcb46b80e236d14dd2c202687d3cc6" translate="yes" xml:space="preserve">
          <source>Stylistic reasons. (Although the 'inline &lt;code&gt;if&lt;/code&gt;' can be &lt;em&gt;really&lt;/em&gt; useful, and make your script more concise, it really does complicate your code)</source>
          <target state="translated">Стилистические причины. (Хотя &amp;laquo;встроенное &lt;code&gt;if&lt;/code&gt; &amp;raquo; может быть &lt;em&gt;очень&lt;/em&gt; полезным и сделать ваш сценарий более кратким, оно действительно усложнит ваш код)</target>
        </trans-unit>
        <trans-unit id="4837041f5c57f5efb96309599742e3c0ade4c6b7" translate="yes" xml:space="preserve">
          <source>Syntax :</source>
          <target state="translated">Синтаксис :</target>
        </trans-unit>
        <trans-unit id="8f9eb933921eaddb08703549e034102f89a91d33" translate="yes" xml:space="preserve">
          <source>Ternary conditional operator simply allows testing a condition in a single line replacing the multiline if-else making the code compact.</source>
          <target state="translated">Тернарный условный оператор просто позволяет тестировать условие в одной строке,заменяя многострочный if-else,что делает код компактным.</target>
        </trans-unit>
        <trans-unit id="1af072bcc6d3d1e5a9aa912cd54ed63e0cf1486d" translate="yes" xml:space="preserve">
          <source>Ternary operators can be chained in series:</source>
          <target state="translated">Тернарные операторы могут быть связаны последовательно:</target>
        </trans-unit>
        <trans-unit id="5503cedf0d5ac8409f386d79e9175e2024368b00" translate="yes" xml:space="preserve">
          <source>The above works since &lt;code&gt;li1&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and the interp treats that as False in logic expressions. The interp then moves on and evaluates the second expression, which is not &lt;code&gt;None&lt;/code&gt; and it's not an empty list - so it gets assigned to a.</source>
          <target state="translated">Вышеприведенное работает, поскольку &lt;code&gt;li1&lt;/code&gt; равен &lt;code&gt;None&lt;/code&gt; , а interp рассматривает это как False в логических выражениях. Затем interp переходит и оценивает второе выражение, которое не является &lt;code&gt;None&lt;/code&gt; и не является пустым списком - поэтому оно присваивается a.</target>
        </trans-unit>
        <trans-unit id="de0a4391febcb9cd8d58fd3e834ed43e1efb7a54" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;x if C else y&lt;/code&gt; first evaluates the condition, &lt;em&gt;C&lt;/em&gt; (&lt;em&gt;not x&lt;/em&gt;); if &lt;em&gt;C&lt;/em&gt; is true, &lt;em&gt;x&lt;/em&gt; is evaluated and its value is returned; otherwise, &lt;em&gt;y&lt;/em&gt; is evaluated and its value is returned.</source>
          <target state="translated">Выражение &lt;code&gt;x if C else y&lt;/code&gt; сначала вычисляет условие, &lt;em&gt;C&lt;/em&gt; ( &lt;em&gt;не x&lt;/em&gt; ); если &lt;em&gt;C&lt;/em&gt; истинно, &lt;em&gt;x&lt;/em&gt; вычисляется и возвращается его значение; в противном случае вычисляется &lt;em&gt;y&lt;/em&gt; и возвращается его значение.</target>
        </trans-unit>
        <trans-unit id="2af104f524b880b50f5f986ef733f30563ed3b2a" translate="yes" xml:space="preserve">
          <source>The expression exp won't be evaluated at all since &quot;and&quot; with 0 will always evaluate to zero and there is no need to evaluate the expression . This is how the compiler itself works , in all languages.</source>
          <target state="translated">Выражение exp вообще не будет вычисляться,так как &quot;и&quot; с 0 всегда будет вычисляться до нуля,и нет необходимости вычислять выражение.Так работает сам компилятор,на всех языках.</target>
        </trans-unit>
        <trans-unit id="10dcb11ae3a76a8e15945f5d2d2d49ac3a28af82" translate="yes" xml:space="preserve">
          <source>The expression exp1 won't be evaluated since False is equivalent to writing 0 and doing &quot;and&quot; with 0 would be 0 itself but after exp1 since &quot;or&quot; is used, it will evaluate the expression exp2 after &quot;or&quot; .</source>
          <target state="translated">Выражение exp1 не будет вычислено,так как False эквивалентно записи 0,и делать &quot;и&quot; с 0 будет само по себе 0,но после exp1,так как используется &quot;или&quot;,будет вычислено выражение exp2 после &quot;или&quot; .</target>
        </trans-unit>
        <trans-unit id="b0b0173a9bf087b41e367de32d4700aa1b3e7f88" translate="yes" xml:space="preserve">
          <source>The following one is the same as previous one:</source>
          <target state="translated">Следующий такой же,как и предыдущий:</target>
        </trans-unit>
        <trans-unit id="067a165678ff801969ed32bb8ae60f3722d4866e" translate="yes" xml:space="preserve">
          <source>The order of the arguments is different from those of the classic &lt;code&gt;condition ? a : b&lt;/code&gt; ternary operator from many other languages (such as C, C++, Go, Perl, Ruby, Java, Javascript, etc.), which may lead to bugs when people unfamiliar with Python's &quot;surprising&quot; behaviour use it (they may reverse the argument order).</source>
          <target state="translated">Порядок аргументов отличается от классического &lt;code&gt;condition ? a : b&lt;/code&gt; Тернарный оператор a: b из многих других языков (таких как C, C ++, Go, Perl, Ruby, Java, Javascript и т. д.), которые могут привести к ошибкам, когда его используют люди, незнакомые с &amp;laquo;удивительным&amp;raquo; поведением Python (они могут изменить порядок аргументов).</target>
        </trans-unit>
        <trans-unit id="7f7150ee78b704977771011e6cc40319ad111995" translate="yes" xml:space="preserve">
          <source>The part of interest is:</source>
          <target state="translated">Часть интереса:</target>
        </trans-unit>
        <trans-unit id="ecc502e972ed10fca2ccd9ef53adcd864cb4fc7b" translate="yes" xml:space="preserve">
          <source>The second expression exp2 won't be evaluated since &lt;code&gt;True and exp1&lt;/code&gt; would be True when exp1 isn't false .</source>
          <target state="translated">Второе выражение exp2 не будет оцениваться, поскольку &lt;code&gt;True and exp1&lt;/code&gt; будут True, если exp1 не ложно.</target>
        </trans-unit>
        <trans-unit id="bdb2f1d61e753c9f06341fdd6911740881590e6a" translate="yes" xml:space="preserve">
          <source>The shortest alternative remains:</source>
          <target state="translated">Остается кратчайшая альтернатива:</target>
        </trans-unit>
        <trans-unit id="1dfd8c0a2483ad75105cf7ed865fe43abedbd49b" translate="yes" xml:space="preserve">
          <source>Think of the conditional expression as switching between two values. It is very useful when you're in a 'one value or another' situation, it but doesn't do much else.</source>
          <target state="translated">Считайте условное выражение переключением между двумя значениями.Оно очень полезно,когда вы находитесь в ситуации &quot;то или иное значение&quot;,но больше ничего не делает.</target>
        </trans-unit>
        <trans-unit id="757bd11c077579d0812f85bcccc7725ef9ec81a5" translate="yes" xml:space="preserve">
          <source>This allows short-circuiting because when &lt;code&gt;condition&lt;/code&gt; is true only &lt;code&gt;a&lt;/code&gt; is evaluated and &lt;code&gt;b&lt;/code&gt; is not evaluated at all, but when &lt;code&gt;condition&lt;/code&gt; is false only &lt;code&gt;b&lt;/code&gt; is evaluated and &lt;code&gt;a&lt;/code&gt; is not evaluated at all.</source>
          <target state="translated">Это допускает короткое замыкание, потому что, когда &lt;code&gt;condition&lt;/code&gt; истинно, оценивается только &lt;code&gt;a&lt;/code&gt; , а &lt;code&gt;b&lt;/code&gt; вообще не оценивается, а если &lt;code&gt;condition&lt;/code&gt; ложно, только &lt;code&gt;b&lt;/code&gt; оценивается, а &lt;code&gt;a&lt;/code&gt; вообще не оценивается.</target>
        </trans-unit>
        <trans-unit id="3aa85c1834379568a2dadd44872b30d05cc9785b" translate="yes" xml:space="preserve">
          <source>This also works with empty lists. For instance, if you want to assign &lt;code&gt;a&lt;/code&gt; whichever list has items.</source>
          <target state="translated">Это также работает с пустыми списками. Например, если вы хотите назначить список, в котором есть элементы.</target>
        </trans-unit>
        <trans-unit id="e427501a7bef42104eb698d56ff23ced6c553723" translate="yes" xml:space="preserve">
          <source>This would print &quot;odd&quot; if the number is odd or &quot;even&quot; if the number is even.</source>
          <target state="translated">При этом будет выведено &quot;нечетное&quot;,если число нечетное,или &quot;четное&quot;,если число четное.</target>
        </trans-unit>
        <trans-unit id="341d87306463ddc466b59261fedf82fb8984b255" translate="yes" xml:space="preserve">
          <source>Though, there is a potential problem, which if &lt;code&gt;cond&lt;/code&gt; evaluates to &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;on_true&lt;/code&gt; evaluates to &lt;code&gt;False&lt;/code&gt; then &lt;code&gt;on_false&lt;/code&gt; is returned instead of &lt;code&gt;on_true&lt;/code&gt;. If you want this behavior the method is OK, otherwise use this:</source>
          <target state="translated">Тем не менее, существует потенциальная проблема, которая, если &lt;code&gt;cond&lt;/code&gt; оценивается как &lt;code&gt;True&lt;/code&gt; , а &lt;code&gt;on_true&lt;/code&gt; - &lt;code&gt;False&lt;/code&gt; , тогда &lt;code&gt;on_false&lt;/code&gt; возвращается вместо &lt;code&gt;on_true&lt;/code&gt; . Если вы хотите это поведение, метод в порядке, в противном случае используйте это:</target>
        </trans-unit>
        <trans-unit id="f7b558b3c21a3c98acd200b3647d45f05d3fca8c" translate="yes" xml:space="preserve">
          <source>Unfortunately, the</source>
          <target state="translated">К сожалению,</target>
        </trans-unit>
        <trans-unit id="b4258119ca3a4370d0ee540f727c401d66415a0e" translate="yes" xml:space="preserve">
          <source>With Python, you can simply use &lt;code&gt;or&lt;/code&gt; for alternative assignments.</source>
          <target state="translated">С Python вы можете просто использовать &lt;code&gt;or&lt;/code&gt; для альтернативных заданий.</target>
        </trans-unit>
        <trans-unit id="501c4df30742de5f56942e39e4e33cb5bd40bc10" translate="yes" xml:space="preserve">
          <source>YES, python have a ternary operator, here is the syntax and an example code to demonstrate the same :)</source>
          <target state="translated">ДА,у питона есть тернарный оператор,вот синтаксис и пример кода,чтобы продемонстрировать то же самое :)</target>
        </trans-unit>
        <trans-unit id="4764fab14882c7824fd31afde1275c8ad9dfa5b5" translate="yes" xml:space="preserve">
          <source>Yes, it was &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;added&lt;/a&gt; in version 2.5. The expression syntax is:</source>
          <target state="translated">Да, это было &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;добавлено&lt;/a&gt; в версии 2.5. Синтаксис выражения:</target>
        </trans-unit>
        <trans-unit id="3837222375484f4dc46135b7a771581dbcab794a" translate="yes" xml:space="preserve">
          <source>Yes. From the &lt;a href=&quot;https://docs.python.org/reference/grammar.html&quot;&gt;grammar file&lt;/a&gt;:</source>
          <target state="translated">Да. Из &lt;a href=&quot;https://docs.python.org/reference/grammar.html&quot;&gt;файла грамматики&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="772c57f489560211e78cb2d11c2866b9b29aa5a6" translate="yes" xml:space="preserve">
          <source>You can index into a tuple:</source>
          <target state="translated">Ты можешь проиндексировать в кортеж:</target>
        </trans-unit>
        <trans-unit id="d31bcb3f2a3c69063ab668827d032b8b24cb2929" translate="yes" xml:space="preserve">
          <source>You can, however, use conditional expressions to assign a variable like so:</source>
          <target state="translated">Однако для присвоения переменной можно использовать условные выражения:</target>
        </trans-unit>
        <trans-unit id="b6ca419c1e37f1c6d062c1b86540910790e67eb6" translate="yes" xml:space="preserve">
          <source>You may find it somewhat painful to write the following:</source>
          <target state="translated">Вам может показаться несколько болезненным написать следующее:</target>
        </trans-unit>
        <trans-unit id="379a81c9dfbf20958f52ab889b166808e4e8c8ed" translate="yes" xml:space="preserve">
          <source>You might often find</source>
          <target state="translated">Часто можно встретить</target>
        </trans-unit>
        <trans-unit id="31848eba55db40fa8ba451e1340bcdefedd1ab44" translate="yes" xml:space="preserve">
          <source>[on_true] if [expression] else [on_false]</source>
          <target state="translated">[on_true]if [expression]else [on_false]</target>
        </trans-unit>
        <trans-unit id="587c8f0406732dd61ae6136de1b47c30d311764c" translate="yes" xml:space="preserve">
          <source>^ This is the long form for doing such assignments.</source>
          <target state="translated">^ Это длинная форма для выполнения таких заданий.</target>
        </trans-unit>
        <trans-unit id="1fb45c17c40a7ce16c17847d13d5985415280f02" translate="yes" xml:space="preserve">
          <source>and used this way:</source>
          <target state="translated">и использовался таким образом:</target>
        </trans-unit>
        <trans-unit id="1cd77732f70e749c449a2d2f10a245fdb56e9f44" translate="yes" xml:space="preserve">
          <source>both &lt;code&gt;no()&lt;/code&gt; and &lt;code&gt;yes()&lt;/code&gt; are evaluated.</source>
          <target state="translated">оба &lt;code&gt;no()&lt;/code&gt; и &lt;code&gt;yes()&lt;/code&gt; оцениваются.</target>
        </trans-unit>
        <trans-unit id="c41b42386b37a56e714bbb8ab4091873bf086bf5" translate="yes" xml:space="preserve">
          <source>but there is no alternative to</source>
          <target state="translated">но нет альтернативы</target>
        </trans-unit>
        <trans-unit id="c95d2327025d475ff8b7501febaf2cb7b1ddb92f" translate="yes" xml:space="preserve">
          <source>but this lead to problem when on_true == 0</source>
          <target state="translated">но это приводит к проблеме,когда on_true ==0</target>
        </trans-unit>
        <trans-unit id="5a7924a284bb500fda5727b50dfc64f598dc9717" translate="yes" xml:space="preserve">
          <source>however this won't work if &lt;code&gt;x&lt;/code&gt; would be &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">однако это не сработает, если &lt;code&gt;x&lt;/code&gt; будет &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73075949ea61dd74d8b1bfeb6d8bbf8696d9ea9e" translate="yes" xml:space="preserve">
          <source>if the condition [condition] becomes &quot;True&quot; then , expression_1 will be evaluated but not expression_2 .
If we &quot;and&quot; something with 0 (zero) , the result will always to be fasle .So in the below statement ,</source>
          <target state="translated">если условие [условие]станет &quot;True&quot;,то будет вычислено выражение_1,а не выражение_2.Если мы &quot;и&quot; что-то &quot;и&quot; с 0 (нулем),то результатом всегда будет fasle .So в приведенном ниже выражении ,</target>
        </trans-unit>
        <trans-unit id="8347a9c362a17ba7f157573753c5e4693b113950" translate="yes" xml:space="preserve">
          <source>if variable is defined and you want to check if it has value you can just &lt;code&gt;a or b&lt;/code&gt;</source>
          <target state="translated">если переменная определена, и вы хотите проверить, имеет ли она значение, вы можете просто &lt;code&gt;a or b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30f50d1b7ad8a1d8edb08847855b435a18a6162f" translate="yes" xml:space="preserve">
          <source>if you want to avoid the evaluation of &lt;code&gt;yes()&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;no()&lt;/code&gt;, because in</source>
          <target state="translated">если вы хотите избежать оценки &lt;code&gt;yes()&lt;/code&gt; &lt;em&gt;и&lt;/em&gt; &lt;code&gt;no()&lt;/code&gt; , потому что в</target>
        </trans-unit>
        <trans-unit id="7dee470dedb23faec9c2b494d21fd11fc576b9cb" translate="yes" xml:space="preserve">
          <source>is the following:</source>
          <target state="translated">это следующее:</target>
        </trans-unit>
        <trans-unit id="20a29395163e5b9709a368d657a06041695e75bc" translate="yes" xml:space="preserve">
          <source>it can be nested as your need. best of luck</source>
          <target state="translated">он может быть вложен,как ваша потребность.Удачи вам.</target>
        </trans-unit>
        <trans-unit id="79dec008519b31cbf101741268f604a50168381a" translate="yes" xml:space="preserve">
          <source>or explicitly constructed dictionary:</source>
          <target state="translated">или специально составленный словарь:</target>
        </trans-unit>
        <trans-unit id="b7bbf3b6da6885a501de4362189e82f1cd57f4ec" translate="yes" xml:space="preserve">
          <source>or you can use the built-in &lt;a href=&quot;https://docs.python.org/3.3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool()&lt;/code&gt;&lt;/a&gt; to assure a &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;Boolean&lt;/a&gt; value:</source>
          <target state="translated">или вы можете использовать встроенную функцию &lt;a href=&quot;https://docs.python.org/3.3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool()&lt;/code&gt; &lt;/a&gt; для обеспечения &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;логического&lt;/a&gt; значения:</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="0f0e94c76317c1202fb0746ef1437c8fcdd487dd" translate="yes" xml:space="preserve">
          <source>solution doesn't have short-circuit behaviour; thus both &lt;code&gt;falseValue&lt;/code&gt; and &lt;code&gt;trueValue&lt;/code&gt; are evaluated regardless of the condition. This could be suboptimal or even buggy (i.e. both &lt;code&gt;trueValue&lt;/code&gt; and &lt;code&gt;falseValue&lt;/code&gt; could be methods and have side-effects).</source>
          <target state="translated">решение не имеет поведения короткого замыкания; таким образом, и &lt;code&gt;falseValue&lt;/code&gt; , и &lt;code&gt;trueValue&lt;/code&gt; оцениваются независимо от условия. Это может быть неоптимальным или даже &lt;code&gt;trueValue&lt;/code&gt; (то есть как trueValue, так и &lt;code&gt;falseValue&lt;/code&gt; могут быть методами и иметь побочные эффекты).</target>
        </trans-unit>
        <trans-unit id="a274a9708a98bc4fdb9472318da8f13c3bee8f70" translate="yes" xml:space="preserve">
          <source>the expression exp won't be evaluated at all since &quot;or&quot; with 1 will always be 1. So it won't bother to evaluate the expression exp since the result will be 1 anyway . (compiler optimization methods).</source>
          <target state="translated">выражение exp вообще не будет оцениваться,так как &quot;или&quot; с 1 всегда будет 1.Поэтому оценивать выражение exp не придется,так как результат в любом случае будет 1.(методы оптимизации компилятора).</target>
        </trans-unit>
        <trans-unit id="39d0c3ab7ef90c6d161469ec584ab022b15f4f10" translate="yes" xml:space="preserve">
          <source>where operands are &lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_evaluation&quot;&gt;lazily evaluated&lt;/a&gt;.</source>
          <target state="translated">где операнды &lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_evaluation&quot;&gt;лениво оцениваются&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="785b497ac41614c19f3ad8ef5a1360eddd4057ed" translate="yes" xml:space="preserve">
          <source>where you would expect for a  normal ternary operator this result</source>
          <target state="translated">где для обычного тернарного оператора можно ожидать такой результат.</target>
        </trans-unit>
        <trans-unit id="e43fb40cf7bf1d92d0566f4d8f907e807802db52" translate="yes" xml:space="preserve">
          <source>which can be wrapped by:</source>
          <target state="translated">которая может быть завернута:</target>
        </trans-unit>
        <trans-unit id="2a8a0f7868e57d2229b4d0eadf021b1a17426df8" translate="yes" xml:space="preserve">
          <source>which has the following nice extension:</source>
          <target state="translated">который имеет следующее приятное расширение:</target>
        </trans-unit>
        <trans-unit id="7497cd967a22e5c73dd2351308b5e2ef28d3ca05" translate="yes" xml:space="preserve">
          <source>which is equivalent in semantics. Note that some style-guides may limit this usage on the grounds of clarity - it does pack a lot of meaning into very little syntax.</source>
          <target state="translated">что эквивалентно в семантике.Обратите внимание,что некоторые руководства по стилю могут ограничивать это использование по соображениям ясности-они действительно упаковывают много смысла в очень маленький синтаксис.</target>
        </trans-unit>
        <trans-unit id="cc81a06a417041080d93a2378641c20ac0ef4865" translate="yes" xml:space="preserve">
          <source>which is equivalent to:</source>
          <target state="translated">что эквивалентно:</target>
        </trans-unit>
        <trans-unit id="f2dc90da9b9944ad673e6b9050319bf49bdf7040" translate="yes" xml:space="preserve">
          <source>which raises a &lt;code&gt;SyntaxError: invalid syntax&lt;/code&gt;.
So the above is either an incomplete piece of logic (perhaps the user expects a no-op in the false condition) or what may be intended is to use expression2 as a filter - notes that the following is legal Python:</source>
          <target state="translated">который вызывает &lt;code&gt;SyntaxError: invalid syntax&lt;/code&gt; . Таким образом, вышеприведенное является либо неполной частью логики (возможно, пользователь ожидает запрета в ложном состоянии), либо может быть предназначено для использования expression2 в качестве фильтра - отмечает, что следующее является допустимым Python:</target>
        </trans-unit>
        <trans-unit id="dee9317287e35bb56b2a38da732e9512ed8decb4" translate="yes" xml:space="preserve">
          <source>will output</source>
          <target state="translated">производительность</target>
        </trans-unit>
        <trans-unit id="36c7911bf17eb1c668d4ee0aa1aabedcd02fc3a1" translate="yes" xml:space="preserve">
          <source>you can do this :-</source>
          <target state="translated">вы можете это сделать :-</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
