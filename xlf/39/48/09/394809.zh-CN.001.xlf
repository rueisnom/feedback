<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/394809">
    <body>
      <group id="394809">
        <trans-unit id="70ab045269befc703f5853d363741cd4809122f9" translate="yes" xml:space="preserve">
          <source>(execution delayed until the winner is known ;)), but it introduces inconsistency between callable and non-callable objects. In addition, it doesn't solve the case when using properties.</source>
          <target state="translated">(执行延迟,直到知道胜利者为止;)),但它引入了可调用对象和不可调用对象之间的不一致。此外,它并不能解决使用属性时的情况。</target>
        </trans-unit>
        <trans-unit id="8cb713133a6c1d41da9b697de8bb604304078011" translate="yes" xml:space="preserve">
          <source>, becomes:</source>
          <target state="translated">,变成:</target>
        </trans-unit>
        <trans-unit id="40f40c03a1271b3952ed519b50c12fd149dc92e6" translate="yes" xml:space="preserve">
          <source>1- Simple Method to use ternary operator:</source>
          <target state="translated">1-使用三元运算器的简单方法。</target>
        </trans-unit>
        <trans-unit id="d848fcf366a8ef37a8ff9e843fba0d9be57b73fb" translate="yes" xml:space="preserve">
          <source>2- Direct Method of using tuples, Dictionary, and lambda:</source>
          <target state="translated">2-直接使用tuple、字典和lambda的方法。</target>
        </trans-unit>
        <trans-unit id="1aae16e227a970760713cda0dda545cb5d3699fe" translate="yes" xml:space="preserve">
          <source>3- Ternary operator can be written as nested if-else:</source>
          <target state="translated">3-三元运算符可以写成嵌套的if-else。</target>
        </trans-unit>
        <trans-unit id="044a950e94c378180ffa7793e1030478e33e33d8" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression1&lt;/code&gt; will have to be evaluated twice with the above usage. It can limit redundancy if it is simply a local variable. However, a common and performant Pythonic idiom for this use-case is to use &lt;code&gt;or&lt;/code&gt;'s shortcutting behavior:</source>
          <target state="translated">根据上述用法，必须对 &lt;code&gt;expression1&lt;/code&gt; 进行两次评估。 如果它只是局部变量，则可以限制冗余。 但是，此用例的常见且高性能的Python习惯用法是使用 &lt;code&gt;or&lt;/code&gt; 的快捷方式行为：</target>
        </trans-unit>
        <trans-unit id="334c175549b49453b828bca8b2a67a5cca8af5cd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression2&lt;/code&gt; works as a filter for the list comprehension, and is &lt;em&gt;not&lt;/em&gt; a ternary conditional operator.</source>
          <target state="translated">&lt;code&gt;expression2&lt;/code&gt; 用作列表理解的过滤器，而&lt;em&gt;不是&lt;/em&gt;三元条件运算符。</target>
        </trans-unit>
        <trans-unit id="5dab472beecae7e7e8dfecfe05a0c2d9f3e3ecd9" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;expression3&lt;/code&gt; will be lazily evaluated (that is, evaluated only if &lt;code&gt;expression2&lt;/code&gt; is false in a boolean context). And because of the recursive definition, you can chain them indefinitely (though it may considered bad style.)</source>
          <target state="translated">&lt;code&gt;expression3&lt;/code&gt; 将被懒惰地求值（即，仅当 &lt;code&gt;expression2&lt;/code&gt; 在布尔上下文中为false时才求值）。 而且由于递归定义，您可以无限地链接它们（尽管它可能被认为是不好的样式。）</target>
        </trans-unit>
        <trans-unit id="29c4f62bef87062fb6570c3ab3b8996c0383d73f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;test&lt;/code&gt; needs to return &lt;em&gt;True&lt;/em&gt; or &lt;em&gt;False&lt;/em&gt;.</source>
          <target state="translated">&lt;code&gt;test&lt;/code&gt; 需要返回&lt;em&gt;True&lt;/em&gt;或&lt;em&gt;False&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="3fae46c5ec8c22f65a6e958eb8f75ef995296321" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;A neat way to chain multiple operators:&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;链接多个运算符的一种巧妙方法：&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a301bfe415904b8134c76d76fa61ec8147dc8ee2" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary Operator in Javascript&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Javascript中的三元运算符&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aa49ba0541262da7d41f0f4081422b0ba2554c7d" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary Operator in Ruby&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Ruby中的三元运算符&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="35cb1a58f55a6ac1ac6b936dfb825e64d5a5f996" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary operator in Python&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Python中的三元运算符&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a1a00fe97ba444ce4af43b0aa2eb087ce13ccd36" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary operator in R programming&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;R编程中的三元运算符&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f11633b413a20a2ad39481a598a7473cdd7868d8" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Ternary operator in Scala&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Scala中的三元运算符&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="57ae2a1bc4b2cd461a9d0deedcd0dc94cde72aef" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;code&gt;[condition] and [expression_1] or [expression_2] ;&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;[condition] and [expression_1] or [expression_2] ;&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c135775097dd01254c74e73b8797ce9763f03653" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;In case you still want to make it work for all the cases regardless of what exp_1 and exp_2 truth values are, do this :-&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果您仍然想使它适用于所有情况，而不管exp_1和exp_2真值是多少，请执行以下操作：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f445f66b4684e3ca1e89dff63c6cf9c6b9a2085" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note :-&lt;/strong&gt; 0 , None , False , emptylist , emptyString evaluates as False.
And any data other than 0 evaluates to True.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt; -0，None，False，emptylist，emptyString计算为False。 除0以外的任何其他数据都将评估为True。</target>
        </trans-unit>
        <trans-unit id="8904df4a64a6f105d991168d30a94c94e66eb44d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note:-&lt;/strong&gt; This kind of branching using &quot;or&quot; and &quot;and&quot; can only be used when the expression_1 doesn't have a Truth value of False (or 0 or None or emptylist [ ] or emptystring ' '.) since if expression_1 becomes False , then the expression_2 will be evaluated because of the presence &quot;or&quot; between exp_1 and exp_2.</source>
          <target state="translated">&lt;strong&gt;注意：-&lt;/strong&gt;仅当expression_1的True值不为False（或0或None或emptylist []或emptystring''。）时，才可以使用这种使用&amp;ldquo; or&amp;rdquo;和&amp;ldquo; and&amp;rdquo;的分支，因为如果expression_1变为False，则由于exp_1和exp_2之间存在&amp;ldquo;或&amp;rdquo;，将对表达式_2进行求值。</target>
        </trans-unit>
        <trans-unit id="93c71edf58c5ab505268c88d73e083ab4ff69b1d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Ternary Operator in different programming Languages&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;不同编程语言的三元运算符&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0082dd6b907a273d541b44f98e346b6ffade9988" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;The result :-&lt;/strong&gt;  If condition is true exp_1 is executed else exp_2 is executed.</source>
          <target state="translated">&lt;strong&gt;结果：-&lt;/strong&gt;如果条件为true，则执行exp_1，否则执行exp_2。</target>
        </trans-unit>
        <trans-unit id="5d726f2ccbdf4ef2112e79b46394efd7a26bdb15" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;1. &lt;a href=&quot;http://docs.python.org/3.3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator&quot;&gt;Is there an equivalent of C&amp;rsquo;s &amp;rdquo;?:&amp;rdquo; ternary operator?&lt;/a&gt;&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;1. &lt;a href=&quot;http://docs.python.org/3.3/faq/programming.html#is-there-an-equivalent-of-c-s-ternary-operator&quot;&gt;是否有C的等价于&amp;ldquo;？：&amp;rdquo;三元运算符？&lt;/a&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="0bdf2155f1318aca0a1e6ff9bab81d9a15d7e099" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Source: &lt;a href=&quot;https://en.wikipedia.org/wiki/%3F:#Python&quot;&gt;?: in Python at Wikipedia&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;资料来源： &lt;a href=&quot;https://en.wikipedia.org/wiki/%3F:#Python&quot;&gt;？：维基百科中的Python&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="47137144ef43e236132e42d4c3cd332e4cc3ec7f" translate="yes" xml:space="preserve">
          <source>A note on usage:</source>
          <target state="translated">关于用途的说明。</target>
        </trans-unit>
        <trans-unit id="9d0a430e9f1e437bba549167d60e32cd4b925015" translate="yes" xml:space="preserve">
          <source>A possible workaround is to make &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; lists or tuples as in the following:</source>
          <target state="translated">可能的解决方法是按如下所示制作 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 列表或元组：</target>
        </trans-unit>
        <trans-unit id="fe56c5e5a4d9f35e186ec5eb03b16ba91ecd7267" translate="yes" xml:space="preserve">
          <source>Above approach can be written as:</source>
          <target state="translated">上述方法可以写成:</target>
        </trans-unit>
        <trans-unit id="aa5bb41606c2c5c53748e18b932c8d70cf7312ab" translate="yes" xml:space="preserve">
          <source>Additional information:</source>
          <target state="translated">补充资料:</target>
        </trans-unit>
        <trans-unit id="f9cce9f391b0f087eec06d00b08402a5a533e1df" translate="yes" xml:space="preserve">
          <source>Alternative syntax for a more narrow case:</source>
          <target state="translated">更为狭义的情况下的替代语法。</target>
        </trans-unit>
        <trans-unit id="4c7eaa8bf582781c438a6973636b946051d550a6" translate="yes" xml:space="preserve">
          <source>Although it does have the benefit of evaluating expressions left to right, which is clearer in my opinion.</source>
          <target state="translated">虽然它确实有从左到右评价表达的好处,在我看来,这一点比较清楚。</target>
        </trans-unit>
        <trans-unit id="4243fff9331bddbb87ee3995bde3a9f8c62ecdf0" translate="yes" xml:space="preserve">
          <source>An operator for a conditional expression in Python was added in 2006 as part of &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;Python Enhancement Proposal 308&lt;/a&gt;. Its form differ from common &lt;code&gt;?:&lt;/code&gt; operator and it's:</source>
          <target state="translated">作为&lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;Python增强建议308的&lt;/a&gt;一部分，2006年添加了Python条件表达式的运算符。 它的形式不同于常见的 &lt;code&gt;?:&lt;/code&gt; 运算符，它的形式是：</target>
        </trans-unit>
        <trans-unit id="6d802d348de05c371872aaa136e43ae4790bb661" translate="yes" xml:space="preserve">
          <source>And so the story goes - choosing between 3 mentioned solutions is a trade-off between having the short-circuit feature, using at least Зython 2.5 (IMHO not a problem anymore) and not being prone to &quot;&lt;code&gt;trueValue&lt;/code&gt;-evaluates-to-false&quot; errors.</source>
          <target state="translated">故事就这样了-在提到的3种解决方案之间进行选择是要在具有短路功能，至少使用Зython2.5（恕我直言，不再是问题）和不易于&amp;ldquo; &lt;code&gt;trueValue&lt;/code&gt; -evaluates -to-false&amp;rdquo;之间进行权衡错误。</target>
        </trans-unit>
        <trans-unit id="9db147c5133a121c92efce9f531259e88a815251" translate="yes" xml:space="preserve">
          <source>Another (less reliable), but simpler method is to use &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators:</source>
          <target state="translated">另一种（可靠性较低）但更简单的方法是使用 &lt;code&gt;and&lt;/code&gt; 和 &lt;code&gt;or&lt;/code&gt; 运算符：</target>
        </trans-unit>
        <trans-unit id="f29869a5fb045eacca16998a249d59fe4a1ef72e" translate="yes" xml:space="preserve">
          <source>Another syntax which can be used (compatible with versions before 2.5):</source>
          <target state="translated">另一个可以使用的语法(与2.5之前的版本兼容)。</target>
        </trans-unit>
        <trans-unit id="6ede496e52093534454faa827678b96dc14a0bde" translate="yes" xml:space="preserve">
          <source>Another way is by indexing a tuple (which isn't consistent with the conditional operator of most other languages):</source>
          <target state="translated">另一种方法是通过索引一个tuple(这与大多数其他语言的条件运算符不一致)。</target>
        </trans-unit>
        <trans-unit id="e5d8acdf91b2bad1764fb5d525bdb392c6e78228" translate="yes" xml:space="preserve">
          <source>As already answered, yes there is a ternary operator in python:</source>
          <target state="translated">正如已经回答的那样,是的,在python中存在一个三元运算符。</target>
        </trans-unit>
        <trans-unit id="10eeb6250c3d1364e2b4a11d28ce4b006bc96176" translate="yes" xml:space="preserve">
          <source>At first, the &lt;code&gt;Python&lt;/code&gt;&lt;strong&gt;B&lt;/strong&gt;enevolent &lt;strong&gt;D&lt;/strong&gt;ictator &lt;strong&gt;F&lt;/strong&gt;or &lt;strong&gt;L&lt;/strong&gt;ife (I mean Guido van Rossum, of course) rejected it (as non-Pythonic style), since it's quite hard to understand for people not used to &lt;code&gt;C&lt;/code&gt; language. Also, the colon sign &lt;strong&gt;&lt;code&gt;:&lt;/code&gt;&lt;/strong&gt; already has many uses in &lt;code&gt;Python&lt;/code&gt;. After &lt;strong&gt;PEP 308&lt;/strong&gt; was approved, &lt;code&gt;Python&lt;/code&gt; finally received its own shortcut conditional expression (what we use now):</source>
          <target state="translated">起初， &lt;code&gt;Python&lt;/code&gt; &lt;strong&gt;B&lt;/strong&gt;富裕的标识符&lt;strong&gt;F&lt;/strong&gt;或&lt;strong&gt;L&lt;/strong&gt; ife（我的意思是Guido van Rossum，当然）拒绝了它（因为它是非Pythonic风格的），因为对于不习惯 &lt;code&gt;C&lt;/code&gt; 语言的人们来说很难理解。 另外，冒号&lt;strong&gt; &lt;code&gt;:&lt;/code&gt; &lt;/strong&gt;在 &lt;code&gt;Python&lt;/code&gt; 中已经有很多用途。 在&lt;strong&gt;PEP 308&lt;/strong&gt;批准后， &lt;code&gt;Python&lt;/code&gt; 终于收到了自己的快捷方式条件表达式（我们现在使用的是）：</target>
        </trans-unit>
        <trans-unit id="dd29e09af960c8454a520e8b4d704fdf79a455d7" translate="yes" xml:space="preserve">
          <source>Below is the ternary form. But this isn't most succinct way - see last example.</source>
          <target state="translated">下面是三元的形式。但这并不是最简洁的方式--见最后一个例子。</target>
        </trans-unit>
        <trans-unit id="54ab93ad34df3c1e05aa8130fd92ecad93172607" translate="yes" xml:space="preserve">
          <source>But in case of</source>
          <target state="translated">但是,如果是</target>
        </trans-unit>
        <trans-unit id="e428c12fd355944b5e6b7023bd80dd3c17b5aee5" translate="yes" xml:space="preserve">
          <source>Conditional expressions</source>
          <target state="translated">条件表达式</target>
        </trans-unit>
        <trans-unit id="53209a5d3bcb5ef6226a6a63af2411fb4329ea1a" translate="yes" xml:space="preserve">
          <source>Conditional expressions (sometimes called a &amp;ldquo;ternary operator&amp;rdquo;) have the lowest priority of all Python operations.</source>
          <target state="translated">条件表达式（有时称为&amp;ldquo;三元运算符&amp;rdquo;）在所有Python操作中具有最低的优先级。</target>
        </trans-unit>
        <trans-unit id="43e7ce9b3100f9c4cee6083bc0c5c0ecc62fe1d3" translate="yes" xml:space="preserve">
          <source>Does Python have a ternary conditional operator</source>
          <target state="translated">Python有一个三元条件运算符吗?</target>
        </trans-unit>
        <trans-unit id="1a6fd40c1dc466260f6a3434319de40a40079b42" translate="yes" xml:space="preserve">
          <source>Does Python have a ternary conditional operator?</source>
          <target state="translated">Python有三元条件运算符吗?</target>
        </trans-unit>
        <trans-unit id="08ec689e9d96535ecd7d37b8542dacd3113a01d8" translate="yes" xml:space="preserve">
          <source>Example:-</source>
          <target state="translated">Example:-</target>
        </trans-unit>
        <trans-unit id="f67e732e29a09166934752e7537614b263f98276" translate="yes" xml:space="preserve">
          <source>First &lt;code&gt;condition&lt;/code&gt; is evaluated, then exactly one of either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is evaluated and returned based on the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;Boolean&lt;/a&gt; value of &lt;code&gt;condition&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; evaluates to &lt;code&gt;True&lt;/code&gt;, then &lt;code&gt;a&lt;/code&gt; is evaluated and returned but &lt;code&gt;b&lt;/code&gt; is ignored, or else when &lt;code&gt;b&lt;/code&gt; is evaluated and returned but &lt;code&gt;a&lt;/code&gt; is ignored.</source>
          <target state="translated">首先对 &lt;code&gt;condition&lt;/code&gt; 求值，然后根据 &lt;code&gt;condition&lt;/code&gt; 的&lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;布尔&lt;/a&gt;值对 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 中的任意一个求值并返回。 如果 &lt;code&gt;condition&lt;/code&gt; 评估为 &lt;code&gt;True&lt;/code&gt; ，则评估并返回 &lt;code&gt;b&lt;/code&gt; ，但b被忽略，否则，当评估并返回 &lt;code&gt;b&lt;/code&gt; 但 &lt;code&gt;a&lt;/code&gt; 被忽略时。</target>
        </trans-unit>
        <trans-unit id="e65f8fce57a4328cfd936e7c997b733995619b23" translate="yes" xml:space="preserve">
          <source>For Python 2.5 and newer there is a specific syntax:</source>
          <target state="translated">对于Python 2.5及更高版本的Python,有一个特定的语法。</target>
        </trans-unit>
        <trans-unit id="dc3c09a115b4ee611eb7505826a4fa0c2a8495d8" translate="yes" xml:space="preserve">
          <source>For example</source>
          <target state="translated">比如说</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="73ed66c8963b3d8dd7afa66295f9854e375e8607" translate="yes" xml:space="preserve">
          <source>For versions prior to 2.5, there's the trick:</source>
          <target state="translated">对于2.5之前的版本,有了窍门。</target>
        </trans-unit>
        <trans-unit id="92945ac06e73038a2bde16da80172b032aba2bb3" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#conditional-expressions&quot;&gt;the documentation&lt;/a&gt;:</source>
          <target state="translated">从&lt;a href=&quot;https://docs.python.org/3/reference/expressions.html#conditional-expressions&quot;&gt;文档中&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="05e2cc02796cc541f46aedf7a50bc4121d7e8342" translate="yes" xml:space="preserve">
          <source>Here I just try to show some important difference in &lt;code&gt;ternary operator&lt;/code&gt; between a couple of programming languages.</source>
          <target state="translated">在这里，我只是试图说明几种编程语言之间在 &lt;code&gt;ternary operator&lt;/code&gt; 一些重要区别。</target>
        </trans-unit>
        <trans-unit id="77a6b125fd3cd1ac92bbf113c153321aee865a77" translate="yes" xml:space="preserve">
          <source>Here are some examples (conditions will be evaluated from left to right):</source>
          <target state="translated">以下是一些例子(条件从左至右评价)。</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">这里有一个例子。</target>
        </trans-unit>
        <trans-unit id="dcae16de665cdab304c88fb675786b95de0fc2e3" translate="yes" xml:space="preserve">
          <source>Here's how it works:</source>
          <target state="translated">以下是它的工作原理。</target>
        </trans-unit>
        <trans-unit id="a6a0ce9031e0776d5fc6120b3023d51bccf114f1" translate="yes" xml:space="preserve">
          <source>Hope this helps.</source>
          <target state="translated">希望这对你有帮助。</target>
        </trans-unit>
        <trans-unit id="37ead08d0a3de9126fb757db960eb29eba55180c" translate="yes" xml:space="preserve">
          <source>I always liked the C ternary syntax, but Python takes it a step further!</source>
          <target state="translated">我一直很喜欢C语言的三元语法,但Python更进一步!</target>
        </trans-unit>
        <trans-unit id="2fc5c24905a2271acf5a9e03baac33ba14f9bc08" translate="yes" xml:space="preserve">
          <source>I find cumbersome the default python syntax &lt;code&gt;val = a if cond else b&lt;/code&gt;, so sometimes I do this:</source>
          <target state="translated">我发现笨拙的默认python语法 &lt;code&gt;val = a if cond else b&lt;/code&gt; ，那么有时我这样做：</target>
        </trans-unit>
        <trans-unit id="2e767bec6a36856af0721a196a27cd634af23fc7" translate="yes" xml:space="preserve">
          <source>I understand that some may say this isn't a good stylistic choice because it relies on mechanics that aren't immediately apparent to all developers. I personally disagree with that viewpoint. Python is a syntax rich language with lots of idiomatic tricks that aren't immediately apparent to the dabler. But the more you learn and understand the mechanics of the underlying system, the more you appreciate it.</source>
          <target state="translated">我理解,有人可能会说这不是一个好的风格选择,因为它依赖于不是所有的开发者都能立刻看出来的力学。我个人不同意这种观点。Python 是一门语法丰富的语言,它有很多成语技巧,对于开发者来说并不是立刻就能看出来的。但你越是学习和理解底层系统的机制,你就越是欣赏它。</target>
        </trans-unit>
        <trans-unit id="4c43044d1cee7d9be8a45db13e7115d6ebb09ae0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;expression 1&amp;gt;&lt;/code&gt; is the condition you can use &lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;Short-cirquit evaluation&lt;/a&gt;:</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;expression 1&amp;gt;&lt;/code&gt; 是条件，则可以使用&lt;a href=&quot;https://en.wikipedia.org/wiki/Short-circuit_evaluation&quot;&gt;Short-cirquit评估&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="c7b7a1b690cd2aa8c0d47a1a173633ac7de09ad9" translate="yes" xml:space="preserve">
          <source>If Python does not have a ternary conditional operator, is it possible to simulate one using other language constructs?</source>
          <target state="translated">如果Python没有三元条件运算器,是否可以用其他语言构造来模拟三元条件运算器?</target>
        </trans-unit>
        <trans-unit id="0e97f70a139ffcfa1a24114a4591be1fca3125fb" translate="yes" xml:space="preserve">
          <source>If you need to use statements, you have to use a normal &lt;code&gt;if&lt;/code&gt;&lt;strong&gt;statement&lt;/strong&gt; instead of a conditional &lt;strong&gt;expression&lt;/strong&gt;.</source>
          <target state="translated">如果需要使用语句，则必须使用常规的 &lt;code&gt;if&lt;/code&gt; &lt;strong&gt;语句&lt;/strong&gt;而不是条件&lt;strong&gt;表达式&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="c0e07fb933f85a6a70d4007baf685896d04ea2e6" translate="yes" xml:space="preserve">
          <source>If you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, &lt;code&gt;x = 4 if b &amp;gt; 8 else 9&lt;/code&gt; is read aloud as &lt;code&gt;x will be 4 if b is greater than 8 otherwise 9&lt;/code&gt;.</source>
          <target state="translated">如果您在记住顺序时遇到麻烦，请记住当大声朗读时，您（几乎）说出了您的意思。 例如， &lt;code&gt;x = 4 if b &amp;gt; 8 else 9&lt;/code&gt; ，则x = 4，否则大声读取9，因为 &lt;code&gt;x will be 4 if b is greater than 8 otherwise 9&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="cd86ff205ecdd4cb29b3e77564370ff6db70909b" translate="yes" xml:space="preserve">
          <source>If you're working with dictionaries, instead of using a ternary conditional, you can take advantage of &lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.get&quot;&gt;&lt;code&gt;get(key, default)&lt;/code&gt;&lt;/a&gt;, for example:</source>
          <target state="translated">如果使用的是字典，则可以使用&lt;a href=&quot;https://docs.python.org/3/library/stdtypes.html#dict.get&quot;&gt; &lt;code&gt;get(key, default)&lt;/code&gt; &lt;/a&gt;来代替使用三元条件，例如：</target>
        </trans-unit>
        <trans-unit id="aef36502d67b0520654deb764dd055a7e905cfdd" translate="yes" xml:space="preserve">
          <source>In</source>
          <target state="translated">In</target>
        </trans-unit>
        <trans-unit id="edd7170b76e39c053ddbe154bd719895bd4a908f" translate="yes" xml:space="preserve">
          <source>In older Pythons a ternary operator is not implemented but it's possible to simulate it.</source>
          <target state="translated">在旧版的Python中没有实现三元运算符,但可以模拟它。</target>
        </trans-unit>
        <trans-unit id="db9e5ecfa73258ca5cc22c532b88ad7d327d52f9" translate="yes" xml:space="preserve">
          <source>Is there an equivalent of C&amp;rsquo;s &amp;rdquo;?:&amp;rdquo; ternary operator?</source>
          <target state="translated">是否有C的等价于&amp;ldquo;？：&amp;rdquo;三元运算符？</target>
        </trans-unit>
        <trans-unit id="24d3776bac90c9fd5d21c4b1f83deb0e1d687362" translate="yes" xml:space="preserve">
          <source>It can give wrong results when &lt;code&gt;on_true&lt;/code&gt; 
 has a false boolean value.&lt;sup&gt;1&lt;/sup&gt;</source>
          <target state="translated">当 &lt;code&gt;on_true&lt;/code&gt; 具有错误的布尔值时，它可能会给出错误的结果。 &lt;sup&gt;1个&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32c5b1aa401cec0ed9411d5f0dd2d88c4ce21470" translate="yes" xml:space="preserve">
          <source>It is compatible with all Python versions.</source>
          <target state="translated">它兼容所有的Python版本。</target>
        </trans-unit>
        <trans-unit id="56172c01602d5c36c8f5eafe5e58f2bda8748700" translate="yes" xml:space="preserve">
          <source>It might be safer to always implement it as:</source>
          <target state="translated">始终如一地实施可能会更安全。</target>
        </trans-unit>
        <trans-unit id="13ee33148a661d308d418e7ef1bba7aef5badefa" translate="yes" xml:space="preserve">
          <source>It's very common to need to assign to a variable one value or another depending on a condition.</source>
          <target state="translated">根据条件的不同,需要给一个变量赋值是很常见的。</target>
        </trans-unit>
        <trans-unit id="a48cc90e3c4b0a15108ca2d3e639a527ccbd8f3c" translate="yes" xml:space="preserve">
          <source>Just memorize this pyramid if you have trouble remembering:</source>
          <target state="translated">如果你记不住,就把这个金字塔背下来吧。</target>
        </trans-unit>
        <trans-unit id="b3cab6de298a55b417f1fd7ced11c4f193e7803d" translate="yes" xml:space="preserve">
          <source>Keep in mind that it's frowned upon by some Pythonistas for several reasons:</source>
          <target state="translated">请记住,它被一些Python主义者所皱眉,原因有几个。</target>
        </trans-unit>
        <trans-unit id="ed177662f0634eaaac95ed1a4f31f67c99f0d6e1" translate="yes" xml:space="preserve">
          <source>Knowing this, you can simply such assignments whenever you encounter them. This also works with strings and other iterables. You could assign &lt;code&gt;a&lt;/code&gt; whichever string isn't empty.</source>
          <target state="translated">知道这一点，您可以在遇到任务时简单地进行此类分配。 这也适用于字符串和其他可迭代对象。 您可以分配 &lt;code&gt;a&lt;/code&gt; 不为空的字符串。</target>
        </trans-unit>
        <trans-unit id="cabb6efdc2bfdd697f45c63b9b465ca38dfacae6" translate="yes" xml:space="preserve">
          <source>Many programming languages derived from &lt;code&gt;C&lt;/code&gt; usually have the following syntax of ternary conditional operator:</source>
          <target state="translated">从 &lt;code&gt;C&lt;/code&gt; 派生的许多编程语言通常具有以下三元条件运算符的语法：</target>
        </trans-unit>
        <trans-unit id="92d6e998ecbbd20e86ffa05b336aa618477dcb98" translate="yes" xml:space="preserve">
          <source>More a tip than an answer (don't need to repeat the obvious for the hundreth time), but I sometimes use it as a oneliner shortcut in such constructs:</source>
          <target state="translated">更多的是一个提示而不是答案(不需要重复明显的一百次),但我有时会把它作为这类结构中的oneliner捷径。</target>
        </trans-unit>
        <trans-unit id="4b569996756caea7c12ec127521d9424e8e1be8c" translate="yes" xml:space="preserve">
          <source>New since version 2.5.</source>
          <target state="translated">自2.5版本以来,新的。</target>
        </trans-unit>
        <trans-unit id="3c6e31105fa73f62fb4e102f8668ff8f71e6244a" translate="yes" xml:space="preserve">
          <source>Note that conditionals are an &lt;em&gt;expression&lt;/em&gt;, not a &lt;em&gt;statement&lt;/em&gt;. This means you can't use assignment statements or &lt;code&gt;pass&lt;/code&gt; or other &lt;strong&gt;statements&lt;/strong&gt; within a conditional &lt;strong&gt;expression&lt;/strong&gt;:</source>
          <target state="translated">注意条件是&lt;em&gt;表达式&lt;/em&gt; ，而不是&lt;em&gt;语句&lt;/em&gt; 。 这意味着您不能在条件&lt;strong&gt;表达式中&lt;/strong&gt;使用赋值语句或 &lt;code&gt;pass&lt;/code&gt; 或其他&lt;strong&gt;语句&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="479d40d235c43adc3552914b59a66859cc395904" translate="yes" xml:space="preserve">
          <source>Note that every &lt;code&gt;if&lt;/code&gt; must be followed with an &lt;code&gt;else&lt;/code&gt;. People learning list comprehensions and generator expressions may find this to be a difficult lesson to learn - the following will not work, as Python expects a third expression for an else:</source>
          <target state="translated">请注意，每个 &lt;code&gt;if&lt;/code&gt; 后面都必须带有 &lt;code&gt;else&lt;/code&gt; 。 人们在学习列表理解和生成器表达式时可能会发现这是一个很难学习的课-以下内容将不起作用，因为Python期望将其他表达式用作第三个表达式：</target>
        </trans-unit>
        <trans-unit id="5a744d56ca2c69c38476ac01a338fb242c1b6a64" translate="yes" xml:space="preserve">
          <source>Of course, it has the downside of always evaluating both sides (a and b), but the syntax it's way clearer to me</source>
          <target state="translated">当然,它的缺点是总是对两边(a和b)进行评估,但语法上对我来说,它的作用更明显</target>
        </trans-unit>
        <trans-unit id="1de3da6e82da1f06b4bf0d8c6161c81558b1aad4" translate="yes" xml:space="preserve">
          <source>Official documentation:</source>
          <target state="translated">正式文件:</target>
        </trans-unit>
        <trans-unit id="d0827d89564ba5e83ce93ed7166326488a92a205" translate="yes" xml:space="preserve">
          <source>One of the alternatives to Python's &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;conditional expression&lt;/a&gt;</source>
          <target state="translated">Python &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;条件表达式&lt;/a&gt;的替代方法之一</target>
        </trans-unit>
        <trans-unit id="9c4550b9ecd33c573988bea3fd0c8262d2e96e4e" translate="yes" xml:space="preserve">
          <source>One solution to this would be</source>
          <target state="translated">这方面的一个解决办法是</target>
        </trans-unit>
        <trans-unit id="7b4b4244be13a3abd69c7140639a3d4f60891f6a" translate="yes" xml:space="preserve">
          <source>PS: Of course, a Short-cirquit evaluation is not a ternary operator but often the ternary is used in cases where the short circuit would be enough.</source>
          <target state="translated">PS:当然,短路评估不是三元算子,但往往在短路的情况下用三元算子就可以了。</target>
        </trans-unit>
        <trans-unit id="58792d9668c4adc810f2ca241f219f68473b10b3" translate="yes" xml:space="preserve">
          <source>Python has a ternary form for assignments; however there may be even a shorter form that people should be aware of.</source>
          <target state="translated">Python 有一个三元形式的任务;然而,可能还有一个更短的形式,人们应该知道。</target>
        </trans-unit>
        <trans-unit id="136139a7ae8963781743317576db7d500d885197" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;PEP 308&lt;/a&gt; for more details about conditional expressions.</source>
          <target state="translated">有关条件表达式的更多详细信息，请参见&lt;a href=&quot;https://www.python.org/dev/peps/pep-0308/&quot;&gt;PEP 308&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="036b7b152c8e2ad2d27d64b379952563535f109f" translate="yes" xml:space="preserve">
          <source>Similarly in</source>
          <target state="translated">同样,在</target>
        </trans-unit>
        <trans-unit id="c0aa83bbbe563bbcc34994245b02f09698d81bf9" translate="yes" xml:space="preserve">
          <source>Simulating the python ternary operator.</source>
          <target state="translated">模拟python的三元运算符。</target>
        </trans-unit>
        <trans-unit id="4509806cb94c2823fac491553c861100a38c9efc" translate="yes" xml:space="preserve">
          <source>So, a ternary conditional operation is of the form:</source>
          <target state="translated">所以,三元条件运算的形式是:。</target>
        </trans-unit>
        <trans-unit id="1dee0139e43a4cbbca1778fe8b6f59248a65da5a" translate="yes" xml:space="preserve">
          <source>So, firstly it evaluates the condition. If it returns &lt;code&gt;True&lt;/code&gt;, &lt;strong&gt;expression1&lt;/strong&gt; will be evaluated to give the result, otherwise &lt;strong&gt;expression2&lt;/strong&gt; will be evaluated. Due to &lt;strong&gt;&lt;em&gt;Lazy Evaluation&lt;/em&gt;&lt;/strong&gt; mechanics &amp;ndash; only one expression will be executed.</source>
          <target state="translated">因此，首先它评估条件。 如果返回 &lt;code&gt;True&lt;/code&gt; ，则将对&lt;strong&gt;expression1&lt;/strong&gt;求值以给出结果，否则将对&lt;strong&gt;expression2&lt;/strong&gt;求值。 由于&lt;strong&gt;&lt;em&gt;懒惰的评估&lt;/em&gt;&lt;/strong&gt;机制&amp;ndash;仅执行一个表达式。</target>
        </trans-unit>
        <trans-unit id="5eb20a0d0f308ab00cf66a44ffce1c909d193ed8" translate="yes" xml:space="preserve">
          <source>Some (many :) may frown upon it as unpythonic (even, ruby-ish :), but I personally find it more natural - i.e. how you'd express it normally, plus a bit more visually appealing in large blocks of code.</source>
          <target state="translated">有些人(很多人:)可能会嫌弃它不伦不类(甚至,红宝石色的:),但我个人觉得它更自然--也就是你通常的表达方式,再加上在大块的代码中更有视觉吸引力。</target>
        </trans-unit>
        <trans-unit id="10a2d2ce64f1e69ac87af7d7b375ce3f5f76b42e" translate="yes" xml:space="preserve">
          <source>Some find it &quot;unwieldy&quot;, since it goes contrary to the normal flow of thought (thinking of the condition first and then the effects).</source>
          <target state="translated">有的人觉得 &quot;不靠谱&quot;,因为它违背了正常的思维流程(先考虑条件再考虑效果)。</target>
        </trans-unit>
        <trans-unit id="83704dabdebcb46b80e236d14dd2c202687d3cc6" translate="yes" xml:space="preserve">
          <source>Stylistic reasons. (Although the 'inline &lt;code&gt;if&lt;/code&gt;' can be &lt;em&gt;really&lt;/em&gt; useful, and make your script more concise, it really does complicate your code)</source>
          <target state="translated">风格上的原因。 （尽管'inline &lt;code&gt;if&lt;/code&gt; '可能&lt;em&gt;确实&lt;/em&gt;有用，并且可以使脚本更简洁，但确实会使代码复杂化）</target>
        </trans-unit>
        <trans-unit id="4837041f5c57f5efb96309599742e3c0ade4c6b7" translate="yes" xml:space="preserve">
          <source>Syntax :</source>
          <target state="translated">句法 :</target>
        </trans-unit>
        <trans-unit id="8f9eb933921eaddb08703549e034102f89a91d33" translate="yes" xml:space="preserve">
          <source>Ternary conditional operator simply allows testing a condition in a single line replacing the multiline if-else making the code compact.</source>
          <target state="translated">三元条件运算符简单地允许在单行中测试一个条件,取代了多行if-else,使代码更加紧凑。</target>
        </trans-unit>
        <trans-unit id="1af072bcc6d3d1e5a9aa912cd54ed63e0cf1486d" translate="yes" xml:space="preserve">
          <source>Ternary operators can be chained in series:</source>
          <target state="translated">三元运算符可以串联起来。</target>
        </trans-unit>
        <trans-unit id="5503cedf0d5ac8409f386d79e9175e2024368b00" translate="yes" xml:space="preserve">
          <source>The above works since &lt;code&gt;li1&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt; and the interp treats that as False in logic expressions. The interp then moves on and evaluates the second expression, which is not &lt;code&gt;None&lt;/code&gt; and it's not an empty list - so it gets assigned to a.</source>
          <target state="translated">由于 &lt;code&gt;li1&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt; ，并且interp在逻辑表达式中将其视为False，因此上述方法有效。 然后，interp继续并计算第二个表达式，该表达式不是 &lt;code&gt;None&lt;/code&gt; ，而且也不是一个空列表-因此将其分配给a。</target>
        </trans-unit>
        <trans-unit id="de0a4391febcb9cd8d58fd3e834ed43e1efb7a54" translate="yes" xml:space="preserve">
          <source>The expression &lt;code&gt;x if C else y&lt;/code&gt; first evaluates the condition, &lt;em&gt;C&lt;/em&gt; (&lt;em&gt;not x&lt;/em&gt;); if &lt;em&gt;C&lt;/em&gt; is true, &lt;em&gt;x&lt;/em&gt; is evaluated and its value is returned; otherwise, &lt;em&gt;y&lt;/em&gt; is evaluated and its value is returned.</source>
          <target state="translated">&lt;code&gt;x if C else y&lt;/code&gt; 首先计算条件&lt;em&gt;C&lt;/em&gt; ， 则表达式x （ &lt;em&gt;不是x&lt;/em&gt; ）； 如果&lt;em&gt;C&lt;/em&gt;为true，则对&lt;em&gt;x&lt;/em&gt;求值并返回其值； 否则，将评估&lt;em&gt;y&lt;/em&gt;并返回其值。</target>
        </trans-unit>
        <trans-unit id="2af104f524b880b50f5f986ef733f30563ed3b2a" translate="yes" xml:space="preserve">
          <source>The expression exp won't be evaluated at all since &quot;and&quot; with 0 will always evaluate to zero and there is no need to evaluate the expression . This is how the compiler itself works , in all languages.</source>
          <target state="translated">表达式 exp 完全不会被执行,因为带 0 的 &quot;and &quot;永远都是 0,所以不需要对表达式进行评价。这就是编译器本身的工作原理,在所有语言中都是如此。</target>
        </trans-unit>
        <trans-unit id="10dcb11ae3a76a8e15945f5d2d2d49ac3a28af82" translate="yes" xml:space="preserve">
          <source>The expression exp1 won't be evaluated since False is equivalent to writing 0 and doing &quot;and&quot; with 0 would be 0 itself but after exp1 since &quot;or&quot; is used, it will evaluate the expression exp2 after &quot;or&quot; .</source>
          <target state="translated">表达式 exp1 不会被评价,因为 False 等同于写 0,而用 0 做 &quot;和&quot; 本身就是 0,但在 exp1 之后,因为使用了 &quot;或&quot; ,所以会在 &quot;或&quot; 之后评价 exp2。</target>
        </trans-unit>
        <trans-unit id="b0b0173a9bf087b41e367de32d4700aa1b3e7f88" translate="yes" xml:space="preserve">
          <source>The following one is the same as previous one:</source>
          <target state="translated">下面这个和前一个是一样的。</target>
        </trans-unit>
        <trans-unit id="067a165678ff801969ed32bb8ae60f3722d4866e" translate="yes" xml:space="preserve">
          <source>The order of the arguments is different from those of the classic &lt;code&gt;condition ? a : b&lt;/code&gt; ternary operator from many other languages (such as C, C++, Go, Perl, Ruby, Java, Javascript, etc.), which may lead to bugs when people unfamiliar with Python's &quot;surprising&quot; behaviour use it (they may reverse the argument order).</source>
          <target state="translated">论据的顺序与经典 &lt;code&gt;condition ? a : b&lt;/code&gt; 的顺序不同吗？ a：b来自许多其他语言（例如C，C ++，Go，Perl，Ruby，Java，Javascript等）的三元运算符，当不熟悉Python的&amp;ldquo;令人惊讶&amp;rdquo;行为的人使用它时，这可能会导致错误（它们可能会逆转）参数顺序）。</target>
        </trans-unit>
        <trans-unit id="7f7150ee78b704977771011e6cc40319ad111995" translate="yes" xml:space="preserve">
          <source>The part of interest is:</source>
          <target state="translated">感兴趣的部分是:</target>
        </trans-unit>
        <trans-unit id="ecc502e972ed10fca2ccd9ef53adcd864cb4fc7b" translate="yes" xml:space="preserve">
          <source>The second expression exp2 won't be evaluated since &lt;code&gt;True and exp1&lt;/code&gt; would be True when exp1 isn't false .</source>
          <target state="translated">第二个表达式exp2将不被评估，因为当exp1不为false时， &lt;code&gt;True and exp1&lt;/code&gt; 将为True。</target>
        </trans-unit>
        <trans-unit id="bdb2f1d61e753c9f06341fdd6911740881590e6a" translate="yes" xml:space="preserve">
          <source>The shortest alternative remains:</source>
          <target state="translated">最短的选择仍然是:</target>
        </trans-unit>
        <trans-unit id="1dfd8c0a2483ad75105cf7ed865fe43abedbd49b" translate="yes" xml:space="preserve">
          <source>Think of the conditional expression as switching between two values. It is very useful when you're in a 'one value or another' situation, it but doesn't do much else.</source>
          <target state="translated">把条件表达式看成是在两个值之间进行切换。当你在 &quot;一个值或另一个值 &quot;的情况下,它是非常有用的,但没有什么作用。</target>
        </trans-unit>
        <trans-unit id="757bd11c077579d0812f85bcccc7725ef9ec81a5" translate="yes" xml:space="preserve">
          <source>This allows short-circuiting because when &lt;code&gt;condition&lt;/code&gt; is true only &lt;code&gt;a&lt;/code&gt; is evaluated and &lt;code&gt;b&lt;/code&gt; is not evaluated at all, but when &lt;code&gt;condition&lt;/code&gt; is false only &lt;code&gt;b&lt;/code&gt; is evaluated and &lt;code&gt;a&lt;/code&gt; is not evaluated at all.</source>
          <target state="translated">这允许发生短路，因为当 &lt;code&gt;condition&lt;/code&gt; 为真时，仅评估 &lt;code&gt;b&lt;/code&gt; 而根本不评估b ，但是当 &lt;code&gt;condition&lt;/code&gt; 为假时，仅评估 &lt;code&gt;b&lt;/code&gt; 而根本不评估 &lt;code&gt;a&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="3aa85c1834379568a2dadd44872b30d05cc9785b" translate="yes" xml:space="preserve">
          <source>This also works with empty lists. For instance, if you want to assign &lt;code&gt;a&lt;/code&gt; whichever list has items.</source>
          <target state="translated">这也适用于空列表。 例如，如果您想分配 &lt;code&gt;a&lt;/code&gt; 包含项目的列表。</target>
        </trans-unit>
        <trans-unit id="e427501a7bef42104eb698d56ff23ced6c553723" translate="yes" xml:space="preserve">
          <source>This would print &quot;odd&quot; if the number is odd or &quot;even&quot; if the number is even.</source>
          <target state="translated">如果是奇数,则会打印 &quot;奇数&quot;;如果是偶数,则会打印 &quot;偶数&quot;。</target>
        </trans-unit>
        <trans-unit id="341d87306463ddc466b59261fedf82fb8984b255" translate="yes" xml:space="preserve">
          <source>Though, there is a potential problem, which if &lt;code&gt;cond&lt;/code&gt; evaluates to &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;on_true&lt;/code&gt; evaluates to &lt;code&gt;False&lt;/code&gt; then &lt;code&gt;on_false&lt;/code&gt; is returned instead of &lt;code&gt;on_true&lt;/code&gt;. If you want this behavior the method is OK, otherwise use this:</source>
          <target state="translated">但是，存在一个潜在的问题，如果 &lt;code&gt;cond&lt;/code&gt; 评估为 &lt;code&gt;True&lt;/code&gt; 且 &lt;code&gt;on_true&lt;/code&gt; 评估为 &lt;code&gt;False&lt;/code&gt; ,则返回 &lt;code&gt;on_true&lt;/code&gt; 而不是on_true 。 如果您想要这种行为，该方法可以，否则请使用以下方法：</target>
        </trans-unit>
        <trans-unit id="f7b558b3c21a3c98acd200b3647d45f05d3fca8c" translate="yes" xml:space="preserve">
          <source>Unfortunately, the</source>
          <target state="translated">遗憾的是</target>
        </trans-unit>
        <trans-unit id="b4258119ca3a4370d0ee540f727c401d66415a0e" translate="yes" xml:space="preserve">
          <source>With Python, you can simply use &lt;code&gt;or&lt;/code&gt; for alternative assignments.</source>
          <target state="translated">使用Python，您可以简单地使用 &lt;code&gt;or&lt;/code&gt; 进行其他分配。</target>
        </trans-unit>
        <trans-unit id="501c4df30742de5f56942e39e4e33cb5bd40bc10" translate="yes" xml:space="preserve">
          <source>YES, python have a ternary operator, here is the syntax and an example code to demonstrate the same :)</source>
          <target state="translated">是的,Python有一个三元运算符,这里有一个语法和一个例子代码来演示同样的代码:)</target>
        </trans-unit>
        <trans-unit id="4764fab14882c7824fd31afde1275c8ad9dfa5b5" translate="yes" xml:space="preserve">
          <source>Yes, it was &lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;added&lt;/a&gt; in version 2.5. The expression syntax is:</source>
          <target state="translated">是的，它是在2.5版中&lt;a href=&quot;https://mail.python.org/pipermail/python-dev/2005-September/056846.html&quot;&gt;添加的&lt;/a&gt; 。 表达式语法为：</target>
        </trans-unit>
        <trans-unit id="3837222375484f4dc46135b7a771581dbcab794a" translate="yes" xml:space="preserve">
          <source>Yes. From the &lt;a href=&quot;https://docs.python.org/reference/grammar.html&quot;&gt;grammar file&lt;/a&gt;:</source>
          <target state="translated">是。 从&lt;a href=&quot;https://docs.python.org/reference/grammar.html&quot;&gt;语法文件&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="772c57f489560211e78cb2d11c2866b9b29aa5a6" translate="yes" xml:space="preserve">
          <source>You can index into a tuple:</source>
          <target state="translated">你可以索引到一个tuple。</target>
        </trans-unit>
        <trans-unit id="d31bcb3f2a3c69063ab668827d032b8b24cb2929" translate="yes" xml:space="preserve">
          <source>You can, however, use conditional expressions to assign a variable like so:</source>
          <target state="translated">但是,你可以使用条件表达式来分配一个像这样的变量。</target>
        </trans-unit>
        <trans-unit id="b6ca419c1e37f1c6d062c1b86540910790e67eb6" translate="yes" xml:space="preserve">
          <source>You may find it somewhat painful to write the following:</source>
          <target state="translated">你可能会觉得写下面这段话有些痛苦。</target>
        </trans-unit>
        <trans-unit id="379a81c9dfbf20958f52ab889b166808e4e8c8ed" translate="yes" xml:space="preserve">
          <source>You might often find</source>
          <target state="translated">你可能经常会发现</target>
        </trans-unit>
        <trans-unit id="31848eba55db40fa8ba451e1340bcdefedd1ab44" translate="yes" xml:space="preserve">
          <source>[on_true] if [expression] else [on_false]</source>
          <target state="translated">[on_true]if [expression]else [on_false]</target>
        </trans-unit>
        <trans-unit id="587c8f0406732dd61ae6136de1b47c30d311764c" translate="yes" xml:space="preserve">
          <source>^ This is the long form for doing such assignments.</source>
          <target state="translated">^ 这就是做这种作业的长形式。</target>
        </trans-unit>
        <trans-unit id="1fb45c17c40a7ce16c17847d13d5985415280f02" translate="yes" xml:space="preserve">
          <source>and used this way:</source>
          <target state="translated">并以这种方式使用。</target>
        </trans-unit>
        <trans-unit id="1cd77732f70e749c449a2d2f10a245fdb56e9f44" translate="yes" xml:space="preserve">
          <source>both &lt;code&gt;no()&lt;/code&gt; and &lt;code&gt;yes()&lt;/code&gt; are evaluated.</source>
          <target state="translated">&lt;code&gt;no()&lt;/code&gt; 和 &lt;code&gt;yes()&lt;/code&gt; 均被评估。</target>
        </trans-unit>
        <trans-unit id="c41b42386b37a56e714bbb8ab4091873bf086bf5" translate="yes" xml:space="preserve">
          <source>but there is no alternative to</source>
          <target state="translated">但除此之外,别无他法</target>
        </trans-unit>
        <trans-unit id="c95d2327025d475ff8b7501febaf2cb7b1ddb92f" translate="yes" xml:space="preserve">
          <source>but this lead to problem when on_true == 0</source>
          <target state="translated">但当on_true ==0时,会出现问题。</target>
        </trans-unit>
        <trans-unit id="5a7924a284bb500fda5727b50dfc64f598dc9717" translate="yes" xml:space="preserve">
          <source>however this won't work if &lt;code&gt;x&lt;/code&gt; would be &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">但是，如果 &lt;code&gt;x&lt;/code&gt; 为 &lt;code&gt;False&lt;/code&gt; ,这将不起作用。</target>
        </trans-unit>
        <trans-unit id="73075949ea61dd74d8b1bfeb6d8bbf8696d9ea9e" translate="yes" xml:space="preserve">
          <source>if the condition [condition] becomes &quot;True&quot; then , expression_1 will be evaluated but not expression_2 .
If we &quot;and&quot; something with 0 (zero) , the result will always to be fasle .So in the below statement ,</source>
          <target state="translated">如果条件[条件]变成了 &quot;True&quot;,那么表达式_1将被执行,但表达式_2不会被执行。如果我们 &quot;和 &quot;的东西为0 (0),结果将永远是fasle ,</target>
        </trans-unit>
        <trans-unit id="8347a9c362a17ba7f157573753c5e4693b113950" translate="yes" xml:space="preserve">
          <source>if variable is defined and you want to check if it has value you can just &lt;code&gt;a or b&lt;/code&gt;</source>
          <target state="translated">如果定义了变量，并且您想检查它是否具有值，则可以只选择 &lt;code&gt;a or b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="30f50d1b7ad8a1d8edb08847855b435a18a6162f" translate="yes" xml:space="preserve">
          <source>if you want to avoid the evaluation of &lt;code&gt;yes()&lt;/code&gt;&lt;em&gt;and&lt;/em&gt;&lt;code&gt;no()&lt;/code&gt;, because in</source>
          <target state="translated">如果要避免对 &lt;code&gt;yes()&lt;/code&gt; &lt;em&gt;和&lt;/em&gt; &lt;code&gt;no()&lt;/code&gt; 求值，因为</target>
        </trans-unit>
        <trans-unit id="7dee470dedb23faec9c2b494d21fd11fc576b9cb" translate="yes" xml:space="preserve">
          <source>is the following:</source>
          <target state="translated">是:</target>
        </trans-unit>
        <trans-unit id="20a29395163e5b9709a368d657a06041695e75bc" translate="yes" xml:space="preserve">
          <source>it can be nested as your need. best of luck</source>
          <target state="translated">它可以根据你的需要进行嵌套。</target>
        </trans-unit>
        <trans-unit id="79dec008519b31cbf101741268f604a50168381a" translate="yes" xml:space="preserve">
          <source>or explicitly constructed dictionary:</source>
          <target state="translated">或明文规定的字典。</target>
        </trans-unit>
        <trans-unit id="b7bbf3b6da6885a501de4362189e82f1cd57f4ec" translate="yes" xml:space="preserve">
          <source>or you can use the built-in &lt;a href=&quot;https://docs.python.org/3.3/library/functions.html#bool&quot;&gt;&lt;code&gt;bool()&lt;/code&gt;&lt;/a&gt; to assure a &lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;Boolean&lt;/a&gt; value:</source>
          <target state="translated">或者您可以使用内置的&lt;a href=&quot;https://docs.python.org/3.3/library/functions.html#bool&quot;&gt; &lt;code&gt;bool()&lt;/code&gt; &lt;/a&gt;来确保&lt;a href=&quot;https://en.wikipedia.org/wiki/Boolean_data_type&quot;&gt;布尔&lt;/a&gt;值：</target>
        </trans-unit>
        <trans-unit id="1d9ad0addee82809659247e9008e6f9e82aa9000" translate="yes" xml:space="preserve">
          <source>or:</source>
          <target state="translated">or:</target>
        </trans-unit>
        <trans-unit id="27806062493e422e06f1adc0af3df9590689c118" translate="yes" xml:space="preserve">
          <source>output:</source>
          <target state="translated">output:</target>
        </trans-unit>
        <trans-unit id="0f0e94c76317c1202fb0746ef1437c8fcdd487dd" translate="yes" xml:space="preserve">
          <source>solution doesn't have short-circuit behaviour; thus both &lt;code&gt;falseValue&lt;/code&gt; and &lt;code&gt;trueValue&lt;/code&gt; are evaluated regardless of the condition. This could be suboptimal or even buggy (i.e. both &lt;code&gt;trueValue&lt;/code&gt; and &lt;code&gt;falseValue&lt;/code&gt; could be methods and have side-effects).</source>
          <target state="translated">解决方案没有短路行为； 因此，无论条件如何，都会对 &lt;code&gt;falseValue&lt;/code&gt; 和 &lt;code&gt;trueValue&lt;/code&gt; 进行评估。 这可能不是最理想的，甚至可能是错误的（即 &lt;code&gt;trueValue&lt;/code&gt; 和 &lt;code&gt;falseValue&lt;/code&gt; 都可能是方法，并且有副作用）。</target>
        </trans-unit>
        <trans-unit id="a274a9708a98bc4fdb9472318da8f13c3bee8f70" translate="yes" xml:space="preserve">
          <source>the expression exp won't be evaluated at all since &quot;or&quot; with 1 will always be 1. So it won't bother to evaluate the expression exp since the result will be 1 anyway . (compiler optimization methods).</source>
          <target state="translated">表达式 exp 根本不会被求值,因为带 1 的 &quot;or &quot;永远是 1。所以,它不会费心去评价exp这个表达式,因为结果会是1。编译器优化方法)。</target>
        </trans-unit>
        <trans-unit id="39d0c3ab7ef90c6d161469ec584ab022b15f4f10" translate="yes" xml:space="preserve">
          <source>where operands are &lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_evaluation&quot;&gt;lazily evaluated&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Lazy_evaluation&quot;&gt;延迟计算&lt;/a&gt;操作数的地方。</target>
        </trans-unit>
        <trans-unit id="785b497ac41614c19f3ad8ef5a1360eddd4057ed" translate="yes" xml:space="preserve">
          <source>where you would expect for a  normal ternary operator this result</source>
          <target state="translated">一般的三元运算符的结果为</target>
        </trans-unit>
        <trans-unit id="e43fb40cf7bf1d92d0566f4d8f907e807802db52" translate="yes" xml:space="preserve">
          <source>which can be wrapped by:</source>
          <target state="translated">可以通过以下方式进行包装:</target>
        </trans-unit>
        <trans-unit id="2a8a0f7868e57d2229b4d0eadf021b1a17426df8" translate="yes" xml:space="preserve">
          <source>which has the following nice extension:</source>
          <target state="translated">其中有以下几个不错的扩展。</target>
        </trans-unit>
        <trans-unit id="7497cd967a22e5c73dd2351308b5e2ef28d3ca05" translate="yes" xml:space="preserve">
          <source>which is equivalent in semantics. Note that some style-guides may limit this usage on the grounds of clarity - it does pack a lot of meaning into very little syntax.</source>
          <target state="translated">在语义上是等价的。请注意,一些风格指南可能会以清晰为由限制这种用法----它确实在很少的语法中包含了很多意义。</target>
        </trans-unit>
        <trans-unit id="cc81a06a417041080d93a2378641c20ac0ef4865" translate="yes" xml:space="preserve">
          <source>which is equivalent to:</source>
          <target state="translated">相当于:</target>
        </trans-unit>
        <trans-unit id="f2dc90da9b9944ad673e6b9050319bf49bdf7040" translate="yes" xml:space="preserve">
          <source>which raises a &lt;code&gt;SyntaxError: invalid syntax&lt;/code&gt;.
So the above is either an incomplete piece of logic (perhaps the user expects a no-op in the false condition) or what may be intended is to use expression2 as a filter - notes that the following is legal Python:</source>
          <target state="translated">引发 &lt;code&gt;SyntaxError: invalid syntax&lt;/code&gt; 。 因此，以上内容要么是一个不完整的逻辑（也许用户期望在错误条件下不执行操作），要么是要使用expression2作为过滤器-请注意，以下内容是合法的Python：</target>
        </trans-unit>
        <trans-unit id="dee9317287e35bb56b2a38da732e9512ed8decb4" translate="yes" xml:space="preserve">
          <source>will output</source>
          <target state="translated">将输出</target>
        </trans-unit>
        <trans-unit id="36c7911bf17eb1c668d4ee0aa1aabedcd02fc3a1" translate="yes" xml:space="preserve">
          <source>you can do this :-</source>
          <target state="translated">你可以这样做</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
