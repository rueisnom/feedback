<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/399078">
    <body>
      <group id="399078">
        <trans-unit id="7d67bb6716e56cca3eca8a9065af38ddcf97e9f6" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Anywhere: &lt;code&gt;. ^ $ * + - ? ( ) [ ] { } \ |&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Везде: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;. ^ $ * + - ? ( ) [ ] { } \ |&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a8c55057c2c0495b9bccfbec7b17e45412ea5d8" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;For literals, don't escape: &lt;code&gt;+ ? ( ) { } |&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Для литералов не убегайте: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;+ ? ( ) { } |&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a97d47555ec0720c1f70236663cc597967c70a60" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;For standard regex behavior, escape: &lt;code&gt;\+ \? \( \) \{ \} \|&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Для стандартного поведения регулярных выражений, escape: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;\+ \? \( \) \{ \} \|&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f12e6d0791605981ba059a406b6691a5f9790e5e" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Inside a character class: &lt;code&gt;^ - [ ]&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Внутри класса персонажа: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;^ - [ ]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="918002f5c663d22dba42a630d4b732416c76c2b3" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Outside a character class: &lt;code&gt;. ^ $ * + ? ( ) [ { } \ |&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Вне класса символов: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;. ^ $ * + ? ( ) [ { } \ |&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91540850fdd2484dc131620648016ffd98c1f7b1" translate="yes" xml:space="preserve">
          <source>&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Outside a character class: &lt;code&gt;. ^ $ * [ \&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;Вне класса символов: &lt;/font&gt;&lt;/font&gt; &lt;code&gt;. ^ $ * [ \&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f2da9c9d2e4568a1a403995617dc37f29af2dbfd" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://perldoc.perl.org/perlre.html#Quoting-metacharacters&quot;&gt;https://perldoc.perl.org/perlre.html#Quoting-metacharacters&lt;/a&gt; and &lt;a href=&quot;https://perldoc.perl.org/functions/quotemeta.html&quot;&gt;https://perldoc.perl.org/functions/quotemeta.html&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://perldoc.perl.org/perlre.html#Quoting-metacharacters&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://perldoc.perl.org/perlre.html#Quoting-metacharacters&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://perldoc.perl.org/functions/quotemeta.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://perldoc.perl.org/functions/quotemeta.html&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c393bf2f34a2d6c181e8a2227df5d4efeef0d62" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BRE/ed/grep/sed&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;BRE/ed/grep/sed&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f59e21f8afbeffd98079028ce6aeaf7d6a78fa84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ERE/awk/egrep/emacs&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ERE/awk/egrep/emacs&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e676b1e710b18dc41e56c23b6c72c2cc9e9870df" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Edit:&lt;/strong&gt; After the comment below, just thought I'd mention the fact that you also have to consider the difference between finite state automata and non-finite state automata when looking at the behaviour of regexp evaluation.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Изменить:&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; После комментария ниже, просто подумал, что я бы упомянул тот факт, что вы также должны учитывать разницу между автоматами с конечным состоянием и автоматами с конечным состоянием при рассмотрении поведения оценки регулярного выражения.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="45c05493036228b57a91a503e22683c5ed128082" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Includes C, C++, Delphi, EditPad, Java, JavaScript, Perl, PHP (preg), PostgreSQL, PowerGREP, PowerShell, Python, REALbasic, Real Studio, Ruby, TCL, VB.Net, VBScript, wxWidgets, XML Schema, Xojo, XRegExp.&lt;br/&gt;PCRE compatibility may vary&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Включает в себя C, C ++, Delphi, EditPad, Java, JavaScript, Perl, PHP (preg), PostgreSQL, PowerGREP, PowerShell, Python, REALbasic, Real Studio, Ruby, TCL, VB.Net, VBScript, wxWidgets, XML-схему, Xojo, XRegExp. &lt;/font&gt;&lt;/font&gt;&lt;br/&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;PCRE совместимость может отличаться&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="7267e98c4a2f05739245cf705a86774ca73aa3eb" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;Includes awk, ed, egrep, emacs, GNUlib, grep, PHP (ereg), MySQL, Oracle, R, sed.&lt;br/&gt;PCRE support may be enabled in later versions or by using extensions&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Включает в себя awk, ed, egrep, emacs, GNUlib, grep, PHP (ereg), MySQL, Oracle, R, sed. &lt;/font&gt;&lt;/font&gt;&lt;br/&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Поддержка PCRE может быть включена в более поздних версиях или с использованием расширений&lt;/font&gt;&lt;/font&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="53935ccb1d1bcc34d9efdfc75f0d546800f41839" translate="yes" xml:space="preserve">
          <source>Ah the joys of studying at UNSW in the late '70's! (-:</source>
          <target state="translated">Ах,радости обучения в UNSW в конце 70-х! (-:</target>
        </trans-unit>
        <trans-unit id="483f30ef22803526f1679fc7151333a7355f53c7" translate="yes" xml:space="preserve">
          <source>Alphanumeric characters cannot be escaped with a backslash</source>
          <target state="translated">Буквенно-цифровые символы не могут быть спасены обратным слешем.</target>
        </trans-unit>
        <trans-unit id="f7ebf500ba421b0bf9df4deedc3b6483601a07fa" translate="yes" xml:space="preserve">
          <source>Anyway, regexp's are so clunky compared to &lt;a href=&quot;http://en.wikipedia.org/wiki/SNOBOL&quot;&gt;SNOBOL&lt;/a&gt;!  Now &lt;strong&gt;that&lt;/strong&gt; was an interesting programming course! Along with the one on &lt;a href=&quot;http://en.wikipedia.org/wiki/Simula_67&quot;&gt;Simula&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В любом случае, регулярные выражения настолько неуклюжи по сравнению со &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/SNOBOL&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;СНОБОЛОМ&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Теперь , &lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;что&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; был интересный курс программирования! &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Вместе с тем на &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Simula_67&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Симуле&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="58c85a0276f22c46ce13b2389bc79add52b37f1c" translate="yes" xml:space="preserve">
          <source>Arbitrary symbols can be escaped with a backslash in PCRE, but not BRE/ERE (they must only be escaped when required). For PCRE &lt;code&gt;] -&lt;/code&gt; only need escaping within a character class, but I kept them in a single list for simplicity</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Произвольные символы могут быть экранированы с помощью обратной косой черты в PCRE, но не BRE / ERE (они должны экранироваться только при необходимости). &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для PCRE &lt;/font&gt;&lt;/font&gt; &lt;code&gt;] -&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; требуется только экранирование внутри класса персонажа, но я сохранил их в одном списке для простоты&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1a704c051e3f6fec7c0f0d461f093c5717764bc8" translate="yes" xml:space="preserve">
          <source>Aside from escapes, different regex implementations may support different modifiers, character classes, anchors, quantifiers, and other features. For more details, check out &lt;a href=&quot;http://www.regular-expressions.info&quot;&gt;regular-expressions.info&lt;/a&gt;, or use &lt;a href=&quot;https://regex101.com/&quot;&gt;regex101.com&lt;/a&gt; to test your expressions live</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Помимо выходов, различные реализации регулярных выражений могут поддерживать разные модификаторы, классы символов, якоря, квантификаторы и другие функции. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для получения более подробной информации, &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.regular-expressions.info&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;посетите регулярно-expressions.info&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , или используйте &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://regex101.com/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;regex101.com,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; чтобы проверить свои выражения вживую&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d89ca9e85b093f0601f26d305e30b91ef0aee25b" translate="yes" xml:space="preserve">
          <source>BTW Character classes are pretty vanilla regexp components so they tend to work in most situations where you need escaped characters in regexps.</source>
          <target state="translated">Кстати,классы BTW Character являются довольно ванильными регеxp компонентами,поэтому они,как правило,работают в большинстве ситуаций,когда вам нужны экранированные символы в регеxps.</target>
        </trans-unit>
        <trans-unit id="13174a9bc7f1c0d22d348a38e636143a4c31cda4" translate="yes" xml:space="preserve">
          <source>Be aware how the string in memory is processed: if can be a plain string inside the code, or a string entered to the command line, but a could be either an interactive command line or a command line stated inside a shell script file, or inside a variable in memory mentioned by the code, or an (string)argument through further evaluation, or a string containing code generated dynamically with any sort of encapsulation...</source>
          <target state="translated">Знайте,как обрабатывается строка в памяти:если это может быть простая строка внутри кода,или строка,введенная в командную строку,но это может быть либо интерактивная командная строка,либо командная строка,указанная внутри файла скрипта оболочки,либо внутри переменной в памяти,упомянутой кодом,или (строка)аргумент посредством дальнейшего анализа,либо строка,содержащая код,сгенерированный динамически с помощью любого рода инкапсуляции...</target>
        </trans-unit>
        <trans-unit id="dd01e7e261a6b1fe70b847c4b38dda03985adf94" translate="yes" xml:space="preserve">
          <source>Check out Jeff Friedl's &lt;a href=&quot;http://regex.info/&quot;&gt;Mastering Regular Expressions&lt;/a&gt; book.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Ознакомьтесь с &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;книгой &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Джеффа Фридла &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://regex.info/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Освоение регулярных выражений&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="8361115b121b188d914f90203e49011346e5c7e6" translate="yes" xml:space="preserve">
          <source>E.g. A regexp in the command line starting with &lt;code&gt;perl -npe&lt;/code&gt;, needs to be transferred to a set of &lt;em&gt;exec&lt;/em&gt; system calls connecting as pipe the file handles, each of this exec system calls just has a list of arguments that were separated by (non escaped)spaces, and possibly pipes(|) and redirection (&amp;gt; N&amp;gt; N&amp;gt;&amp;amp;M), parenthesis, interactive expansion of &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;$(())&lt;/code&gt; ... (all this are special characters used by the *sh which might appear to interfere with the character of the regular expression in the next context, but they are evaluated in order: before the command line. The command line is read by a program as bash/sh/csh/tcsh/zsh, essentially inside double quote or single quote the escape is simpler but it is not necessary to quote a string in the command line because mostly the space has to be prefixed with backslash and the quote are not necessary leaving available the expand functionality for characters * and ?, but this parse as different context as within quote. Then when the command line is evaluated the regexp obtained in memory (not as written in the command line) receives the same treatment as it would be in a source file.
For regexp there is character-set context within square brackets [ ], perl regular expression can be quoted by a large set of non alfa-numeric characters (E.g. m// or m:/better/for/path: ...).</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Например, регулярное выражение в командной строке, начинающееся с &lt;/font&gt;&lt;/font&gt; &lt;code&gt;perl -npe&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , должно быть перенесено в набор &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;системных вызовов &lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;exec,&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; соединяющихся как канал, который обрабатывает файл, каждый из этих системных вызовов exec просто имеет список аргументов, которые были разделены (не экранированы ) пробелы и, возможно, каналы (|) и перенаправление (&amp;gt; N&amp;gt; N&amp;gt; &amp;amp; M), скобки, интерактивное расширение &lt;/font&gt;&lt;/font&gt; &lt;code&gt;*&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; и &lt;/font&gt;&lt;/font&gt; &lt;code&gt;?&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , &lt;/font&gt;&lt;/font&gt; &lt;code&gt;$(())&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;... (все это специальные символы, используемые * sh, которые могут показаться мешающими символу регулярного выражения в следующем контексте, но они оцениваются по порядку: перед командной строкой. Командная строка читается запрограммируйте как bash / sh / csh / tcsh / zsh, по сути, внутри двойной кавычки или одинарной кавычки, экранирование проще, но нет необходимости заключать в кавычки строку в командной строке, потому что в большинстве случаев пробел должен начинаться с обратной косой черты, а кавычка необязательно оставлять доступными функциональные возможности раскрытия для символов * и?, но этот синтаксический анализ отличается от контекста, например, в кавычках. Затем при оценке командной строки регулярное выражение, полученное в памяти (а не записанное в командной строке), получает ту же обработку, что и будет в исходном файле. Для регулярного выражения есть контекст набора символов в квадратных скобках [],Регулярное выражение perl может быть заключено в большой набор не алфавитно-цифровых символов (например, m // или m: / better / for / path: ...).&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="adcff3eaaa4ead07debf3d94dc837f7ed21cec06" translate="yes" xml:space="preserve">
          <source>Each of this context assigned some characters with special functionality.</source>
          <target state="translated">Каждому из этих контекстов присвоены некоторые символы со специальной функциональностью.</target>
        </trans-unit>
        <trans-unit id="f08f9b14d233c90e12f3bfe6ffd77d280540b8a2" translate="yes" xml:space="preserve">
          <source>Escaping any other characters is an error with POSIX ERE.</source>
          <target state="translated">Исключение любых других символов является ошибкой в POSIX ERE.</target>
        </trans-unit>
        <trans-unit id="d175c420ed0e4eac7898cadf08c6b147e48609e3" translate="yes" xml:space="preserve">
          <source>Escaping parentheses and curly brackets in BREs gives them the special meaning their unescaped versions have in EREs.  Some implementations (e.g. GNU) also give special meaning to other characters when escaped, such as \? and +.  Escaping a character other than .^$*(){} is normally an error with BREs.</source>
          <target state="translated">Скрывающиеся круглые скобки и фигурные скобки в BRE придают им особое значение,которое их неосвещенные версии имеют в ERE.Некоторые реализации (например,GNU)также придают особое значение другим символам при экранировании,таким как \? и +.Экранирование символа,отличного от .^$*(){},обычно является ошибкой в BRE.</target>
        </trans-unit>
        <trans-unit id="f87278cc2c06764d8e04de06f830e733e448a3fd" translate="yes" xml:space="preserve">
          <source>Except if it's a &quot; or '.  :/</source>
          <target state="translated">Только если это не &quot;или&quot;..:</target>
        </trans-unit>
        <trans-unit id="407083df41efb846753191551f28dbb6de294319" translate="yes" xml:space="preserve">
          <source>For Ionic (Typescript) you have to double slash in order to scape the characters.
For example (this is to match some special characters):</source>
          <target state="translated">Для ионизирующего (Typescript)скрипта вы должны удвоить косую черту,чтобы пропустить символы.Например (чтобы соответствовать некоторым специальным символам):</target>
        </trans-unit>
        <trans-unit id="54f275ed7771dcb69cbc20ef9c202565ae878bcf" translate="yes" xml:space="preserve">
          <source>For PCRE, and most other so-called Perl-compatible flavors, escape these outside character classes:</source>
          <target state="translated">Для PCRE и большинства других так называемых Perl-совместимых вкусов,избегайте этих внешних классов персонажей:</target>
        </trans-unit>
        <trans-unit id="54c4e41693531e3ab7c7a314ea4e2eaa6d1cf7e1" translate="yes" xml:space="preserve">
          <source>For PHP, &quot;it is always safe to precede a non-alphanumeric with &quot;\&quot; to specify that it stands for itself.&quot; - &lt;a href=&quot;http://php.net/manual/en/regexp.reference.escape.php&quot;&gt;http://php.net/manual/en/regexp.reference.escape.php&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Для PHP &amp;laquo;всегда безопасно предшествовать не алфавитно-цифровому символу&amp;laquo; \ &amp;raquo;, чтобы указать, что оно обозначает себя&amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;- &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://php.net/manual/en/regexp.reference.escape.php&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;http://php.net/manual/en/regexp.reference.escape.php&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; .&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9380e5c8736cd4f19e0b9dd344946b2244877c31" translate="yes" xml:space="preserve">
          <source>For POSIX extended regexes (ERE), escape these outside character classes (same as PCRE):</source>
          <target state="translated">Для POSIX расширенных регексов (ERE),экранируйте эти внешние классы символов (так же,как PCRE):</target>
        </trans-unit>
        <trans-unit id="c2b64b544c190d00d427d2155b94a792b1b9db30" translate="yes" xml:space="preserve">
          <source>However, keeping a page like the &lt;a href=&quot;http://www.regular-expressions.info/tools.html&quot;&gt;Regular Expression Tools Page&lt;/a&gt; or this &lt;a href=&quot;http://www.addedbytes.com/cheat-sheets/regular-expressions-cheat-sheet/&quot;&gt;Regular Expression Cheatsheet&lt;/a&gt; can go a long way to help you quickly filter things out.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Однако сохранение такой страницы, как страница &amp;laquo; &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.regular-expressions.info/tools.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Инструменты регулярных выражений&amp;raquo;&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; или эта &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.addedbytes.com/cheat-sheets/regular-expressions-cheat-sheet/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;таблица регулярных выражений,&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; может помочь вам быстро отфильтровать вещи.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="a849b55daf78cf386fa658998ec37854ddff4799" translate="yes" xml:space="preserve">
          <source>I am tired of always trying to guess, if I should escape special characters like '&lt;code&gt;()[]{}|&lt;/code&gt;' etc. when using many implementations of regexps.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Я устал от попыток угадать, стоит ли мне избегать специальных символов, таких как ' &lt;/font&gt;&lt;/font&gt; &lt;code&gt;()[]{}|&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;и т. д. при использовании многих реализаций регулярных выражений.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e7ca436bca697c7810913b29993feabb023b8083" translate="yes" xml:space="preserve">
          <source>I tend to just use a simple character class definition instead, so the above expression becomes</source>
          <target state="translated">Вместо этого я склонен использовать простое определение класса символов,так что приведенное выше выражение становится</target>
        </trans-unit>
        <trans-unit id="54394c6bb51712440f21ae57bbe2313f22ce140e" translate="yes" xml:space="preserve">
          <source>If all this makes your head spin, grab a copy of &lt;a href=&quot;http://www.regexbuddy.com&quot;&gt;RegexBuddy&lt;/a&gt;.  On the Create tab, click Insert Token, and then Literal.  RegexBuddy will add escapes as needed.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если все это заставляет вашу голову &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.regexbuddy.com&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;кружиться&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; , возьмите копию &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;RegexBuddy&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; . &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На вкладке &amp;laquo;Создать&amp;raquo; нажмите &amp;laquo;Вставить маркер&amp;raquo;, а затем &amp;laquo;Литерал&amp;raquo;. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;RegexBuddy будет добавлять экранирование по мере необходимости.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e77fe7b95e12760b0659f5fe78377351558ca7ab" translate="yes" xml:space="preserve">
          <source>If unsure about a specific character, it can be escaped like &lt;code&gt;\xFF&lt;/code&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы не уверены в конкретном символе, его можно экранировать как &lt;/font&gt;&lt;/font&gt; &lt;code&gt;\xFF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06293a23dfd9a2808f8f5af94622a77f9985f0f4" translate="yes" xml:space="preserve">
          <source>In POSIX basic regular expressions (BRE), these are metacharacters that you need to escape to suppress their meaning:</source>
          <target state="translated">В POSIX основных регулярных выражениях (BRE)это метасимволы,от которых нужно уклониться,чтобы подавить их значение:</target>
        </trans-unit>
        <trans-unit id="11f83cfdeb5fd5da7a22a95360d91b3ad72833f6" translate="yes" xml:space="preserve">
          <source>In the official documentation, such characters are called metacharacters. Example of quoting:</source>
          <target state="translated">В официальной документации такие символы называются мета-символами.Пример цитирования:</target>
        </trans-unit>
        <trans-unit id="ab1a58228582b4b117b80856b4c70bcaadadd844" translate="yes" xml:space="preserve">
          <source>Inside character classes, BREs follow the same rule as EREs.</source>
          <target state="translated">Внутри классов символов BRE следуют тому же правилу,что и ERE.</target>
        </trans-unit>
        <trans-unit id="e2b30b848c1b94f3704299738525753a115907c3" translate="yes" xml:space="preserve">
          <source>Inside character classes, the backslash is a literal character in POSIX regular expressions.  You cannot use it to escape anything.  You have to use &quot;clever placement&quot; if you want to include character class metacharacters as literals.  Put the ^ anywhere except at the start, the ] at the start, and the - at the start or the end of the character class to match these literally, e.g.:</source>
          <target state="translated">Внутри классов символов обратный слеш является буквальным символом в регулярных выражениях POSIX.Вы не можете использовать его,чтобы избежать чего-либо.Вы должны использовать &quot;умное размещение&quot;,если вы хотите включить символы мета-класса символов в качестве литералов.Поставьте ^ в любом месте,кроме начала,]в начале и-в начале или в конце класса символов,чтобы они соответствовали этим буквам,например:</target>
        </trans-unit>
        <trans-unit id="894aa802f4d8b50284470b8d7af8d180642a0cbc" translate="yes" xml:space="preserve">
          <source>It is different with, for example, Python, sed, grep, awk, Perl, rename, Apache, find and so on.
Is there any rule set which tells when I should, and when I should not, escape special characters? Does it depend on the regexp type, like PCRE, POSIX or extended regexps?</source>
          <target state="translated">Он отличается,например,Python,sed,grep,awk,Perl,переименование,Apache,найти и так далее.Есть ли какой-либо набор правил,который говорит,когда я должен,а когда нет,избежать специальных символов? Зависит ли это от типа регеxp,как PCRE,POSIX или расширенные регеxps?</target>
        </trans-unit>
        <trans-unit id="f92cf4d271e5e508b9d65066ab31d73c4b3a60db" translate="yes" xml:space="preserve">
          <source>Legacy RegEx Flavors (BRE/ERE)</source>
          <target state="translated">Legacy RegEx Вкусы (BREERE)</target>
        </trans-unit>
        <trans-unit id="87ba021fd029962b2cfc3314e679c5178f8e8f91" translate="yes" xml:space="preserve">
          <source>Modern RegEx Flavors (PCRE)</source>
          <target state="translated">Современные ароматизаторы RegEx (PCRE)</target>
        </trans-unit>
        <trans-unit id="8dbd969ee97bd9bfab2f6fa3ae907ed08d524cab" translate="yes" xml:space="preserve">
          <source>Not all the world's a PCRE!</source>
          <target state="translated">Не весь мир-ПЦРЕ!</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="58712ad0108374c3dbf6f92a6b72b766dd6aebab" translate="yes" xml:space="preserve">
          <source>POSIX recognizes multiple variations on regular expressions - basic regular expressions (BRE) and extended regular expressions (ERE).  And even then, there are quirks because of the historical implementations of the utilities standardized by POSIX.</source>
          <target state="translated">POSIX распознает множественные вариации регулярных выражений-основные регулярные выражения (BRE)и расширенные регулярные выражения (ERE).И даже в этом случае есть причуды,связанные с историческими реализациями утилит,стандартизованных POSIX.</target>
        </trans-unit>
        <trans-unit id="42499e430e3ad3149c99af96ca10e885aaf46de4" translate="yes" xml:space="preserve">
          <source>Pay attention to this &lt;code&gt;] [ - _ . /&lt;/code&gt; characters. They have to be double slashed. If you don't do that, you are going to have a type error in your code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Обратите на это внимание &lt;/font&gt;&lt;/font&gt; &lt;code&gt;] [ - _ . /&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; персонажи. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Они должны быть дважды разрезаны. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Если вы этого не сделаете, в вашем коде будет ошибка типа.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="061d7c539b5b77283f5797bd9cad026318098133" translate="yes" xml:space="preserve">
          <source>Quoted expression strings must also have the surrounding quote characters escaped, and often with backslashes doubled-up (like &lt;code&gt;&quot;(\&quot;)(/)(\\.)&quot;&lt;/code&gt; versus &lt;code&gt;/(&quot;)(\/)(\.)/&lt;/code&gt; in JavaScript)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;В строках выражения в кавычках также должны быть экранированные символы кавычек, и часто с удвоенными &lt;/font&gt; &lt;code&gt;/(&quot;)(\/)(\.)/&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt; (например, &lt;/font&gt;&lt;/font&gt; &lt;code&gt;&quot;(\&quot;)(/)(\\.)&quot;&lt;/code&gt; По&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; сравнению с &lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;/(&quot;)(\/)(\.)/&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; в JavaScript)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6c4898925ca3b5988085856c93d5eb8db2bb8ad5" translate="yes" xml:space="preserve">
          <source>Really, there isn't.  there are about a half-zillion different regex syntaxes; they seem to come down to Perl, EMACS/GNU, and AT&amp;amp;T in general, but I'm always getting surprised too.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;На самом деле нет. &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;существует около полумиллиона различных синтаксисов регулярных выражений; &lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;похоже, они относятся к Perl, EMACS / GNU и AT &amp;amp; T в целом, но я всегда удивляюсь.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7bfebe3640cdb3426c48e83c532cc87ad6d71ffa" translate="yes" xml:space="preserve">
          <source>So you really have to know what style you are trying to quote.</source>
          <target state="translated">Так что тебе действительно нужно знать,какой стиль ты пытаешься процитировать.</target>
        </trans-unit>
        <trans-unit id="39b6f38bf2b3ef957f165d6856f072c9d6cb4abb" translate="yes" xml:space="preserve">
          <source>Sometimes simple escaping is not possible with the characters you've listed. For example, using a backslash to escape a bracket isn't going to work in the left hand side of a substitution string in sed, namely</source>
          <target state="translated">Иногда простой уход невозможен с перечисленными персонажами.Например,использование обратного слеша для экранирования скобки не сработает в левой части строки подстановки в sed,а именно</target>
        </trans-unit>
        <trans-unit id="3ffbf9108e1fb9f4f739a7c110dd8d9f4aaaeb20" translate="yes" xml:space="preserve">
          <source>There isn't a simple rule for when to use which notation, or even which notation a given command uses.</source>
          <target state="translated">Не существует простого правила для того,когда использовать какую нотацию,или даже какую нотацию использует данная команда.</target>
        </trans-unit>
        <trans-unit id="1eae24d3735cf6382bb598acd327833adead48fa" translate="yes" xml:space="preserve">
          <source>To escape regex pattern variables (or partial variables) in PHP use preg_quote()</source>
          <target state="translated">Для экранирования переменных регекс-шаблонов (или частичных переменных)в PHP используйте функцию preg_quote()</target>
        </trans-unit>
        <trans-unit id="547d9c5fe8cf140947c895b536944d926d9e0565" translate="yes" xml:space="preserve">
          <source>To know when and what to escape without attempts is necessary to understand precisely the chain of contexts the string pass through. You will specify the string from the farthest side to its final destination which is the memory handled by the regexp parsing code.</source>
          <target state="translated">Чтобы знать,когда и что можно избежать без попыток,необходимо точно понять цепочку контекстов,через которые проходит строка.Вы будете задавать строку от самой дальней стороны до ее конечного адресата-памяти,обрабатываемой кодом повторного разбора.</target>
        </trans-unit>
        <trans-unit id="495c0df080d56ef66956bee36ba63ba18fb51ee5" translate="yes" xml:space="preserve">
          <source>Unfortunately there really isn't a set set of escape codes since it varies based on the language you are using.</source>
          <target state="translated">К сожалению,на самом деле не существует набора экранирующих кодов,так как он варьируется в зависимости от используемого языка.</target>
        </trans-unit>
        <trans-unit id="e0c90f58ad09d2083cef1d05099012604eb5e2e4" translate="yes" xml:space="preserve">
          <source>Unfortunately, the meaning of things like ( and \( are swapped between Emacs style regular expressions and most other styles.  So if you try to escape these you may be doing the opposite of what you want.</source>
          <target state="translated">К сожалению,смысл таких вещей как(и \(поменялись местами между регулярными выражениями в стиле Emacs и большинством других стилей.Так что если вы попытаетесь избежать их,вы можете делать все наоборот.</target>
        </trans-unit>
        <trans-unit id="202929eaf3ff70c56f13ef4bebb902c161a24535" translate="yes" xml:space="preserve">
          <source>What special characters must be escaped in regular expressions</source>
          <target state="translated">Какие специальные символы в регулярных выражениях должны быть экранированы</target>
        </trans-unit>
        <trans-unit id="42311309ff2118567ad88fb48a34fbf0d59ff5ce" translate="yes" xml:space="preserve">
          <source>When you want to pass the character literally without using its special function (local to the context), than that's the case you have to escape it, for the next context... which might need some other escape characters which might additionally need to be escaped in the preceding context(s).
Furthermore there can be things like character encoding (the most insidious is utf-8 because it look like ASCII for common characters, but might be optionally interpreted even by the terminal depending on its settings so it might behave differently, then the encoding attribute of HTML/XML, it's necessary to understand the process precisely right.</source>
          <target state="translated">Когда вы хотите передать символ буквально без использования его специальной функции (локальной к контексту),то в этом случае вы должны экранировать его для следующего контекста...который может потребовать некоторых других экранирующих символов,которые дополнительно могут потребоваться для экранирования в предыдущем контексте (контекстах).Более того,могут быть такие вещи,как кодировка символов (самым коварным является utf-8,потому что он выглядит как ASCII для обычных символов,но может быть опционально интерпретирован даже терминалом в зависимости от его настроек,так что он может вести себя по-другому,тогда атрибут кодировки HTMLXML,необходимо понимать процесс точно так же,как и в предыдущем контексте.</target>
        </trans-unit>
        <trans-unit id="a0a70f58b2f56278f97d8e49ecc8b78c271bc6df" translate="yes" xml:space="preserve">
          <source>Which characters you must and which you mustn't escape indeed depends on the regex flavor you're working with.</source>
          <target state="translated">Какие персонажи вы должны и от каких вы не должны бежать,зависит от вкуса регекса,с которым вы работаете.</target>
        </trans-unit>
        <trans-unit id="65f33a96f4971b1a18dc55f52b610954b500eaef" translate="yes" xml:space="preserve">
          <source>You have more details about characters in other answer, which are very specific to the final regexp context. As I noted you mention that you find the regexp escape with attempts, that's probably because different context has different set of character that confused your memory of attempts (often backslash is the character used in those different context to escape a literal character instead of its function).</source>
          <target state="translated">У вас есть более подробная информация о символах в других ответах,которые очень специфичны для конечного контекста регенерации.Как я заметил,вы упоминаете,что регенерация выполняется с помощью попыток,вероятно,потому,что разный контекст имеет разный набор символов,которые путают вашу память с попытками (часто обратный слеш-это символ,используемый в этом разном контексте,чтобы избежать буквального символа,а не его функции).</target>
        </trans-unit>
        <trans-unit id="0b2b1ae2916b329bfb39c280bca9d2f0928411cc" translate="yes" xml:space="preserve">
          <source>You might like to look at &quot;the shiny ball book&quot; aka Effective Perl (&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201419750&quot;&gt;sanitised Amazon link&lt;/a&gt;), specifically the chapter on regular expressions, to get a feel for then difference in regexp engine evaluation types.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Возможно, вы захотите взглянуть на &amp;laquo;блестящую книгу&amp;raquo;, также называемую Effective Perl ( &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://rads.stackoverflow.com/amzn/click/com/0201419750&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;очищенная ссылка Amazon&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ), в частности главу о регулярных выражениях, чтобы почувствовать разницу в типах оценки движка регулярных выражений.&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="053134580733d1b999fe3b6e87c6cffd5823b4cb" translate="yes" xml:space="preserve">
          <source>and these inside character classes:</source>
          <target state="translated">и эти внутренние классы персонажей:</target>
        </trans-unit>
        <trans-unit id="29a0a78174e89d70570199cb327a0b8879d9165e" translate="yes" xml:space="preserve">
          <source>which I find works for most regexp implementations.</source>
          <target state="translated">которая,как я нахожу,работает для большинства регенерационных реализаций.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
