<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3988788">
    <body>
      <group id="3988788">
        <trans-unit id="9e17c4cb1696a52b482ad758b2ff26ed5d3b3913" translate="yes" xml:space="preserve">
          <source>-&amp;gt; &lt;strong&gt;Locate the root cause in the middle is your job.&lt;/strong&gt;</source>
          <target state="translated">-&amp;gt; &lt;strong&gt;중간에 근본 원인을 찾으십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7efdc3da3f50066fd34771714e2a5d58bba23bab" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;About this question - quite often I see a question come through where a novice programmer is &quot;getting an error&quot;, and they simply paste their stack trace and some random block of code without understanding what the stack trace is or how they can use it. This question is intended as a reference for novice programmers who might need help understanding the value of a stack trace.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;이 질문에 대해-초보자 프로그래머가 &quot;오류를 얻는&quot;곳에서 질문이 나오고 스택 추적이 무엇인지 또는 어떻게 사용할 수 있는지 이해하지 않고 스택 추적과 임의의 코드 블록을 붙여 넣습니다.&lt;/em&gt; &lt;em&gt;이 질문은 스택 트레이스의 가치를 이해하는 데 도움이 필요한 초보자 프로그래머를위한 참고 자료입니다.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e30b6c9a4a40d436e4c73aca3e343c2bb6300046" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example with a chain of exceptions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예외 체인이있는 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1aa697efe4c7ad2e19dd36e95353a7dbaf884e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How should I deal with Stacktraces/Exceptions?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Stacktrace / Exception을 어떻게 처리해야합니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c0c6819414fd35c2dd636ddb836570f5c6003f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key 1&lt;/strong&gt;:A tricky and important thing here need to be understand is : the deepest cause may not be the &quot;root cause&quot;, because if you write some &quot;bad code&quot;, it may cause some exception underneath which is deeper than its layer. For example, a bad sql query may cause SQLServerException connection reset in the bottem instead of syndax error, which may just in the middle of the stack.</source>
          <target state="translated">&lt;strong&gt;키 1&lt;/strong&gt; : 여기서 이해해야 할 까다 롭고 중요한 것은 가장 깊은 원인이 &quot;근본 원인&quot;이 아닐 수 있습니다. &quot;불량한 코드&quot;를 작성하면 그 아래 계층보다 더 깊은 예외가 발생할 수 있기 때문입니다. 예를 들어 잘못된 SQL 쿼리로 인해 스택 중간에 syndax 오류 대신 bottem에서 SQLServerException 연결이 재설정 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f9b27c0022bb53c8f1eda585728984a27b016e54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key 2&lt;/strong&gt;:Another tricky but important thing is inside each &quot;Cause by&quot; block, the first line was the deepest layer and happen first place for this block. For instance,</source>
          <target state="translated">&lt;strong&gt;키 2&lt;/strong&gt; : 또 하나의 까다 롭지 만 중요한 것은 각 &quot;원인&quot;블록 내에 있으며, 첫 번째 줄은 가장 깊은 레이어이며이 블록의 첫 번째 장소입니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="a6f80e689cac9f3d1c38029e6dc4646b88000beb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Manipulated stack trace:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;조작 된 스택 추적 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="efae31b0f686ad094d22681d2e39cca7f4838076" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More daunting example with library code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;라이브러리 코드로 더 어려운 예제&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30cc467eaf3b95a0739540a9156ebc43493b1920" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;간단한 예&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f01621c5ba99bb45938e4719e48e833d01071218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Standard behavior:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;표준 행동 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0def28abff50b5453af5effe03f21c319e75a393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54f43df9b5cad10843edbfcc5365f620a5f11c69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To understand the name&lt;/strong&gt;: A stack trace is a a list of Exceptions( or you can say a list of &quot;Cause by&quot;), from the most surface Exception(e.g. Service Layer Exception) to the deepest one (e.g. Database Exception). Just like the reason we call it 'stack' is because stack is First in Last out (FILO), the deepest exception was happened in the very beginning, then a chain of exception was generated a series of consequences, the surface Exception was the last one happened in time, but we see it in the first place.</source>
          <target state="translated">&lt;strong&gt;이름을 이해하려면&lt;/strong&gt; : 스택 추적은 가장 예외적 인 예외 (예 : 서비스 계층 예외)에서 가장 깊은 예외 (예 : 데이터베이스 예외)에 이르기까지 예외 목록 (또는 &quot;원인&quot;목록)이라고 할 수 있습니다. 우리가 그것을 '스택'이라고 부르는 이유와 마찬가지로 스택이 FILO (First in Last out)이기 때문에 처음부터 가장 깊은 예외가 발생한 다음 일련의 예외가 발생하여 표면 예외가 마지막이었습니다. 하나는 제 시간에 일어 났지만 우리는 처음에 그것을 봅니다.</target>
        </trans-unit>
        <trans-unit id="8c7c8060530d12e9c50d077a6c2083b8ced2d726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Stacktrace?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Stacktrace 란 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c07623d7483d1dbf34b9b1dfdb26de4239c6d4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is an Exception?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;예외 란 무엇입니까?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a965cc63ff98aa09a9add3204ed8471c665810a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why should I not use &lt;code&gt;catch (Exception e)&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt; &lt;code&gt;catch (Exception e)&lt;/code&gt; 사용하지 않아야하는 이유&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6226ce539868df18e25336c8aac8f012bdde715e" translate="yes" xml:space="preserve">
          <source>A stacktrace is a very helpful debugging tool. It shows the call stack (meaning, the stack of functions that were called up to that point) at the time an uncaught exception was thrown (or the time the stacktrace was generated manually). This is very useful because it doesn't only show you where the error happened, but also how the program ended up in that place of the code.
This leads over to the next question:</source>
          <target state="translated">stacktrace는 매우 유용한 디버깅 도구입니다. 포착되지 않은 예외가 발생했을 때 (또는 스택 추적이 수동으로 생성 된 시간) 호출 스택 (즉, 해당 지점까지 호출 된 함수의 스택)을 표시합니다. 이것은 오류가 발생한 위치뿐만 아니라 프로그램이 코드 위치에서 어떻게 종료되었는지를 보여주기 때문에 매우 유용합니다. 이것은 다음 질문으로 이어집니다.</target>
        </trans-unit>
        <trans-unit id="e2c723fd5136ff587ea2f2fd14ae158435d55ec6" translate="yes" xml:space="preserve">
          <source>Again, with this exception we'd want to look at line &lt;code&gt;22&lt;/code&gt; of &lt;code&gt;Book.java&lt;/code&gt; to see what might cause the &lt;code&gt;NullPointerException&lt;/code&gt; here.</source>
          <target state="translated">이 예외를 제외하고 우리는 &lt;code&gt;Book.java&lt;/code&gt; 의 &lt;code&gt;22&lt;/code&gt; 행을보고 &lt;code&gt;NullPointerException&lt;/code&gt; 을 일으키는 원인을 확인하고자합니다.</target>
        </trans-unit>
        <trans-unit id="0ded27539184c5108bce982dfb7dae5374889b46" translate="yes" xml:space="preserve">
          <source>An Exception is what the runtime environment uses to tell you that an error occurred. Popular examples are NullPointerException, IndexOutOfBoundsException or ArithmeticException. Each of these are caused when you try to do something that is not possible. For example, a NullPointerException will be thrown when you try to dereference a Null-object:</source>
          <target state="translated">예외는 런타임 환경에서 오류가 발생했음을 알리기 위해 사용하는 것입니다. 널리 사용되는 예는 NullPointerException, IndexOutOfBoundsException 또는 ArithmeticException입니다. 불가능한 일을하려고 할 때 발생합니다. 예를 들어 Null 객체를 역 참조하려고하면 NullPointerException이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1446b54943846ed8ede7eecb7acb580739cf75ea" translate="yes" xml:space="preserve">
          <source>At first, find out what is causing the Exception. Try googleing the name of the exception to find out, what is the cause of that exception. Most of the time it will be caused by incorrect code. In the given examples above, all of the exceptions are caused by incorrect code. So for the NullPointerException example you could make sure that &lt;code&gt;a&lt;/code&gt; is never null at that time. You could, for example, initialise &lt;code&gt;a&lt;/code&gt; or include a check like this one:</source>
          <target state="translated">처음에 예외의 원인을 찾으십시오. 예외 이름을 Google로 검색하여 예외의 원인을 찾으십시오. 대부분 잘못된 코드로 인해 발생합니다. 위의 예제에서 모든 예외는 잘못된 코드로 인해 발생합니다. 따라서 NullPointerException 예제의 경우 당시에 &lt;code&gt;a&lt;/code&gt; 가 null이 아닌지 확인할 수 있습니다. 예를 들어, &lt;code&gt;a&lt;/code&gt; 를 초기화하거나 다음과 같은 검사를 포함시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fec354ceddcbe7ea20bb5ca5289ffec7bb364462" translate="yes" xml:space="preserve">
          <source>Book.java:16 was called by Auther.java:25 which was called by Bootstrap.java:14, Book.java:16 was the root cause.
Here attach a diagram sort the trace stack in chronological order.</source>
          <target state="translated">Book.java:16은 Bootstrap.java:14에 의해 호출 된 Auther.java:25에 의해 호출되었으며 Book.java:16이 근본 원인이었습니다. 여기에 시간순으로 트레이스 스택을 정렬하는 다이어그램을 첨부하십시오.</target>
        </trans-unit>
        <trans-unit id="80bd8c5b2084abf7b62c1a6d5f7ab234ebfa537a" translate="yes" xml:space="preserve">
          <source>Figure out what is the cause of the exception and fix it, so that it doesn't throw the exception at all.</source>
          <target state="translated">예외의 원인을 파악하고 수정하여 예외가 전혀 발생하지 않도록하십시오.</target>
        </trans-unit>
        <trans-unit id="e438e6ab6e9a62b6589d45cb6ab68d42a04e71c6" translate="yes" xml:space="preserve">
          <source>First, ensure that you have all of your Java sources accessible in an Eclipse project.</source>
          <target state="translated">먼저 Eclipse 프로젝트에서 모든 Java 소스에 액세스 할 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="564a794ca9340e5bd5c39ffc26dcfd0ab1ac2acd" translate="yes" xml:space="preserve">
          <source>However, all the method calls under that are library code. So we'll move up to the &quot;Caused by&quot; above it, and look for the first method call originating from our code, which is:</source>
          <target state="translated">그러나 그 아래의 모든 메소드 호출은 라이브러리 코드입니다. 위의 &quot;Caused by&quot;로 넘어 가서 코드에서 시작된 첫 번째 메소드 호출을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="ea628175c8c7097d7fa1404e48c24d9e23055a01" translate="yes" xml:space="preserve">
          <source>I am posting this answer so the topmost answer (when sorted by activity) is not one that is just plain wrong.</source>
          <target state="translated">이 답변을 게시하므로 최상위 답변 (활동별로 정렬 할 때)이 단순한 잘못이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="5b77138d4162100bb0d1021e6370830c0d6aae0b" translate="yes" xml:space="preserve">
          <source>If 1. is not possible, catch the specific exception and handle it.</source>
          <target state="translated">1. 불가능한 경우 특정 예외를 잡아서 처리하십시오.</target>
        </trans-unit>
        <trans-unit id="15d8614888c88baa8e0dd1a6f06bbc31587cc34c" translate="yes" xml:space="preserve">
          <source>If you are using open-source software, you might need to download and attach to your project the sources if you want to examine. Download the source jars, in your project, open the &lt;em&gt;Referenced Libraries&lt;/em&gt; folder to find your jar for your open-source module (the one with the class files) then right click, select &lt;em&gt;Properties&lt;/em&gt; and attach the source jar.</source>
          <target state="translated">오픈 소스 소프트웨어를 사용하는 경우 검사하려는 경우 소스를 다운로드하여 프로젝트에 첨부해야합니다. 프로젝트에서 소스 jar을 다운로드하고 &lt;em&gt;참조 라이브러리&lt;/em&gt; 폴더를 열어서 오픈 소스 모듈 (클래스 파일이있는 모듈)의 jar을 찾은 다음 마우스 오른쪽 단추를 클릭하고 &lt;em&gt;특성을&lt;/em&gt; 선택하고 소스 jar을 첨부하십시오.</target>
        </trans-unit>
        <trans-unit id="487eb90890ff758ab851426d85fc6a7789a9eae0" translate="yes" xml:space="preserve">
          <source>If you get a stack trace and want to trace the cause of the exception, a good start point in understanding it is to use the &lt;em&gt;Java Stack Trace Console&lt;/em&gt; in &lt;strong&gt;Eclipse&lt;/strong&gt;. If you use another IDE there may be a similar feature, but this answer is about Eclipse.</source>
          <target state="translated">스택 추적을 받고 예외의 원인을 추적하려면 &lt;strong&gt;Eclipse&lt;/strong&gt; 에서 &lt;em&gt;Java 스택 추적 콘솔&lt;/em&gt; 을 사용하는 것이 좋습니다. 다른 IDE를 사용하는 경우 비슷한 기능이있을 수 있지만이 답변은 Eclipse에 관한 것입니다.</target>
        </trans-unit>
        <trans-unit id="613591bc550676714745432c75c4a608a01e1002" translate="yes" xml:space="preserve">
          <source>In our code we would want to evaluate that &lt;code&gt;firstName&lt;/code&gt; contains a value, we would do this like so: &lt;code&gt;if(firstName == null || firstName.equals(&quot;&quot;))  return;&lt;/code&gt;</source>
          <target state="translated">코드에서 &lt;code&gt;firstName&lt;/code&gt; 에 값이 포함되어 있는지 평가하려고합니다. &lt;code&gt;if(firstName == null || firstName.equals(&quot;&quot;)) return;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09a8a4114baff1ef1a66283b7e865492f7e51289" translate="yes" xml:space="preserve">
          <source>In simple terms, a &lt;strong&gt;stack trace&lt;/strong&gt; is a list of the method calls that the application was in the middle of when an Exception was thrown.</source>
          <target state="translated">간단히 말해서 &lt;strong&gt;스택 추적&lt;/strong&gt; 은 예외가 발생했을 때 응용 프로그램이 수행했던 메서드 호출 목록입니다.</target>
        </trans-unit>
        <trans-unit id="14b0ec51c80a071a2bd3488f704f780ec376c702" translate="yes" xml:space="preserve">
          <source>In this example, there's a lot more. What we're mostly concerned about is looking for methods that are from &lt;em&gt;our code&lt;/em&gt;, which would be anything in the &lt;code&gt;com.example.myproject&lt;/code&gt; package. From the second example (above), we'd first want to look down for the root cause, which is:</source>
          <target state="translated">이 예에는 더 많은 것이 있습니다. 우리가 주로 염려하는 것은 &lt;code&gt;com.example.myproject&lt;/code&gt; 패키지에있는 &lt;em&gt;코드의&lt;/em&gt; 메소드를 찾는 것입니다. 위의 두 번째 예에서 먼저 근본 원인을 찾아 보려고합니다.</target>
        </trans-unit>
        <trans-unit id="fd8f9a5ad29840838bb582c1d11aeb8597efa9b6" translate="yes" xml:space="preserve">
          <source>Just to add to the other examples, there are &lt;strong&gt;inner(nested) classes&lt;/strong&gt; that appear with the &lt;code&gt;$&lt;/code&gt; sign. For example:</source>
          <target state="translated">다른 예제에 추가하기 위해 &lt;code&gt;$&lt;/code&gt; 기호와 함께 나타나는 &lt;strong&gt;inner (nested) 클래스&lt;/strong&gt; 가 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ad5d1e6de22d3b3226789df2d8fbb5e80d49cf6" translate="yes" xml:space="preserve">
          <source>Let's use a small example to show why you should not just catch all exceptions:</source>
          <target state="translated">작은 예외를 사용하여 모든 예외를 잡아야하는 이유를 보여 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="23fb093c264a0e642af1b47a80f767b268b0a3c0" translate="yes" xml:space="preserve">
          <source>Like in previous examples, we should look at &lt;code&gt;MyEntityService.java&lt;/code&gt; on line &lt;code&gt;59&lt;/code&gt;, because that's where this error originated (this one's a bit obvious what went wrong, since the SQLException states the error, but the debugging procedure is what we're after).</source>
          <target state="translated">이전 예제에서와 같이 &lt;code&gt;59&lt;/code&gt; 행에서 &lt;code&gt;MyEntityService.java&lt;/code&gt; 를 살펴보아야합니다.이 오류가 발생한 위치이기 때문입니다 (SQLException에서 오류를 표시하기 때문에 오류가 발생한 것이 약간 분명하지만 디버깅 절차는 우리가 따르는 것입니다) .</target>
        </trans-unit>
        <trans-unit id="8fc9cf7ede540afe6a0e435663def251386adccc" translate="yes" xml:space="preserve">
          <source>Never just add a try/catch and then just ignore the exception! Don't do that!</source>
          <target state="translated">try / catch를 추가 한 다음 예외를 무시하지 마십시오. 하지마!</target>
        </trans-unit>
        <trans-unit id="39d9f60e1e2998c13e4e2032d71593c865205a1e" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;catch (Exception e)&lt;/code&gt;, always catch specific Exceptions. That will save you a lot of headaches.</source>
          <target state="translated">&lt;code&gt;catch (Exception e)&lt;/code&gt; 를 사용하지 말고 항상 특정 예외를 잡으십시오. 그것은 당신에게 많은 두통을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="495ca3360ccb4106b9d0e5dce9e4592ebbcbe3e7" translate="yes" xml:space="preserve">
          <source>Paste your stack trace into the console. It will then provide a list of links into your source code and any other source code available.</source>
          <target state="translated">스택 추적을 콘솔에 붙여 넣습니다. 그런 다음 소스 코드 및 사용 가능한 다른 소스 코드에 대한 링크 목록을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="93298efff7ecf9f3994b22176c9239a238b08680" translate="yes" xml:space="preserve">
          <source>People have referred to this as a &quot;stack trace&quot;. &lt;strong&gt;What is a stack trace?&lt;/strong&gt; What can it tell me about the error that's happening in my program?</source>
          <target state="translated">사람들은 이것을 &quot;스택 추적&quot;이라고합니다. &lt;strong&gt;스택 추적이란 무엇입니까?&lt;/strong&gt; 내 프로그램에서 발생하는 오류에 대해 무엇을 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="2d6cea83d2fa9c56b7e4f83d9acb2e8a9b781054" translate="yes" xml:space="preserve">
          <source>Since Rob has used the &lt;code&gt;NullPointerException&lt;/code&gt; (NPE) to illustrate something common, we can help to remove this issue in the following manner:</source>
          <target state="translated">Rob은 NPE ( &lt;code&gt;NullPointerException&lt;/code&gt; )를 사용하여 일반적인 것을 설명 했으므로 다음과 같은 방식으로이 문제를 해결하는 데 도움을 줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6e423de13a20e8485c4d2b1b23c4c523c61a38c" translate="yes" xml:space="preserve">
          <source>Sometimes applications will catch an Exception and re-throw it as the cause of another Exception.  This typically looks like:</source>
          <target state="translated">때때로 응용 프로그램은 예외를 잡아서 다른 예외의 원인으로 다시 발생시킵니다. 일반적으로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e466c8c050df7f99d7ed3eda1da2960c7c20347e" translate="yes" xml:space="preserve">
          <source>Sometimes when I run my application it gives me an error that looks like:</source>
          <target state="translated">때로는 응용 프로그램을 실행할 때 다음과 같은 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d22141c591cb9e0635bd1ecdf684ef89dcc76510" translate="yes" xml:space="preserve">
          <source>Sometimes you can't make sure that you don't get an exception. For example, if you are using a network connection in your program, you cannot stop the computer from loosing it's internet connection (e.g. you can't stop the user from disconnecting the computer's network connection). In this case the network library will probably throw an exception. Now you should catch the exception and &lt;strong&gt;handle&lt;/strong&gt; it. This means, in the example with the network connection, you should try to reopen the connection or notify the user or something like that. Also, whenever you use catch, always catch only the exception you want to catch, &lt;strong&gt;do not use broad catch statements like &lt;code&gt;catch (Exception e)&lt;/code&gt;&lt;/strong&gt; that would catch all exceptions. This is very important, because otherwise you might accidentally catch the wrong exception and react in the wrong way.</source>
          <target state="translated">때로는 예외가 발생하지 않았는지 확인할 수 없습니다. 예를 들어, 프로그램에서 네트워크 연결을 사용하는 경우 컴퓨터가 인터넷 연결을 잃는 것을 막을 수 없습니다 (예 : 사용자가 컴퓨터의 네트워크 연결을 끊는 것을 막을 수 없습니다). 이 경우 네트워크 라이브러리에서 예외가 발생합니다. 이제 예외를 잡아서 &lt;strong&gt;처리&lt;/strong&gt; 해야합니다. 즉, 네트워크 연결의 예에서 연결을 다시 열거 나 사용자에게 알리거나 이와 유사한 것을 알려야합니다. 또한 catch를 사용할 때마다 항상 포착하려는 예외 만 포착하고 모든 예외를 포착하는 &lt;strong&gt; &lt;code&gt;catch (Exception e)&lt;/code&gt; 와 같은 광범위한 catch 문을 사용하지 마십시오&lt;/strong&gt; . 그렇지 않으면 실수로 잘못된 예외를 포착하여 잘못된 방식으로 대응할 수 있기 때문에 이것은 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="cb9cb776c20bea056423449369d53ef52a9c4259" translate="yes" xml:space="preserve">
          <source>Stack trace:</source>
          <target state="translated">스택 추적 :</target>
        </trans-unit>
        <trans-unit id="bf69b603dad9a6fc4eb1f9b4f8ea6caf897877da" translate="yes" xml:space="preserve">
          <source>The above is the proper order to check for nulls, we start with the base object, dog in this case, and then begin walking down the tree of possibilities to make sure everything is valid before processing.  If the order were reversed a NPE could potentially be thrown and our program would crash.</source>
          <target state="translated">위의 방법은 null을 확인하는 적절한 순서이며,이 경우 기본 개체, dog로 시작한 다음 처리하기 전에 모든 것이 유효한지 확인하기 위해 가능성 트리를 걷기 시작합니다. 주문이 취소되면 NPE가 발생하여 프로그램이 중단 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5fb27293f5065e48d95aab824bc00124be221a18" translate="yes" xml:space="preserve">
          <source>The above prevents us from using &lt;code&gt;firstName&lt;/code&gt; as an unsafe parameter.  Therefore  by doing null checks before processing we can help to ensure that our code will run properly.  To expand on an example that utilizes an object with methods we can look here:</source>
          <target state="translated">위의 내용은 &lt;code&gt;firstName&lt;/code&gt; 을 안전하지 않은 매개 변수로 사용하지 못하게합니다. 따라서 처리하기 전에 null 검사를 수행하면 코드가 제대로 실행되도록 할 수 있습니다. 메소드를 사용하여 객체를 사용하는 예제를 확장하기 위해 다음을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7453ef913bb69c16a9f8a1f7b1324fb28f009efa" translate="yes" xml:space="preserve">
          <source>The most recent method call made will be the &lt;em&gt;top&lt;/em&gt; of the stack, which is the top line (excluding the message text). Going down the stack goes back in time. The second line is the method that calls the first line, etc.</source>
          <target state="translated">가장 최근에 호출 된 메소드 호출은 스택의 &lt;em&gt;맨 위&lt;/em&gt; 입니다 (메시지 텍스트 제외). 스택을 내려 가면 시간이지나갑니다. 두 번째 줄은 첫 번째 줄 등을 호출하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="11fbf33c63bd03732692540005c072cdd3ed1096" translate="yes" xml:space="preserve">
          <source>The other posts describe what a stack trace is, but it can still be hard to work with.</source>
          <target state="translated">다른 게시물은 스택 추적이 무엇인지 설명하지만 여전히 작업하기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c3ddf11fc25689b080b12527baea39641ae0db87" translate="yes" xml:space="preserve">
          <source>Then in the &lt;em&gt;Java&lt;/em&gt; perspective, click on the &lt;em&gt;Console&lt;/em&gt; tab (usually at the bottom). If the Console view is not visible, go to the menu option &lt;em&gt;Window -&amp;gt; Show View&lt;/em&gt; and select &lt;em&gt;Console&lt;/em&gt;.</source>
          <target state="translated">그런 다음 &lt;em&gt;Java&lt;/em&gt; Perspective에서 &lt;em&gt;콘솔&lt;/em&gt; 탭 (일반적으로 맨 아래)을 클릭하십시오. 콘솔보기가 표시되지 않으면 메뉴 옵션 &lt;em&gt;창-&amp;gt;보기 표시&lt;/em&gt; 로 이동하여 &lt;em&gt;콘솔을&lt;/em&gt; 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="575a7a948c6a156a106d55a90241bd4749fad5ca" translate="yes" xml:space="preserve">
          <source>Then in the console window, click on the following button (on the right)</source>
          <target state="translated">그런 다음 콘솔 창에서 다음 버튼을 클릭하십시오 (오른쪽)</target>
        </trans-unit>
        <trans-unit id="7b113dc376f62ec3b062c6c5782a7c23ce7ed13e" translate="yes" xml:space="preserve">
          <source>There is one more stacktrace feature offered by Throwable family - the possibility to &lt;strong&gt;manipulate&lt;/strong&gt; stack trace information.</source>
          <target state="translated">Throwable 제품군은 스택 추적 정보를 &lt;strong&gt;조작&lt;/strong&gt; 할 &lt;strong&gt;수있는 또 하나의&lt;/strong&gt; 스택 추적 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0839a810ec4da88cdf6083cb5086fe5cee3ee685" translate="yes" xml:space="preserve">
          <source>This is a very simple stack trace. If we start at the beginning of the list of &quot;at ...&quot;, we can tell where our error happened. What we're looking for is the &lt;strong&gt;topmost&lt;/strong&gt; method call that is part of our application. In this case, it's:</source>
          <target state="translated">이것은 매우 간단한 스택 추적입니다. &quot;at ...&quot;목록의 시작 부분에서 시작하면 오류가 발생한 위치를 알 수 있습니다. 우리가 찾고있는 것은 애플리케이션의 일부인 &lt;strong&gt;최상위&lt;/strong&gt; 메소드 호출입니다. 이 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5f628c41d41907e9337eb90dc7ec480a43bef487" translate="yes" xml:space="preserve">
          <source>This is what you might see (image from the Eclipse documentation):</source>
          <target state="translated">이것은 당신이 볼 수있는 것입니다 (Eclipse 문서의 이미지) :</target>
        </trans-unit>
        <trans-unit id="78507f11dd782b6c1af51bf682954e32ebc76066" translate="yes" xml:space="preserve">
          <source>This might give you a stack trace that looks like:</source>
          <target state="translated">이것은 다음과 같은 스택 추적을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ec60d92e12153a63d117ff1ab794bc3e4143c4b" translate="yes" xml:space="preserve">
          <source>This way, the offending line is not executed if &lt;code&gt;a==null&lt;/code&gt;. Same goes for the other examples.</source>
          <target state="translated">이런 식으로 &lt;code&gt;a==null&lt;/code&gt; 경우 문제를 일으키는 행이 실행되지 않습니다. 다른 예제도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="86a413041e25913218b0abb28f5e2dc38fc95d9c" translate="yes" xml:space="preserve">
          <source>This would indicate that something (probably &lt;code&gt;title&lt;/code&gt;) is &lt;code&gt;null&lt;/code&gt; in the above code.</source>
          <target state="translated">이것은 위의 코드에서 무언가 (아마도 &lt;code&gt;title&lt;/code&gt; )가 &lt;code&gt;null&lt;/code&gt; 임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b633c5cf2b51a5bd3a70b5d319f1c2ac9b9edcfd" translate="yes" xml:space="preserve">
          <source>To add on to what Rob has mentioned.  Setting break points in your application allows for the step-by-step processing of the stack.  This enables the developer to use the debugger to see at what exact point the method is doing something that was unanticipated.</source>
          <target state="translated">Rob이 언급 한 내용을 추가합니다. 응용 프로그램에서 중단 점을 설정하면 스택을 단계별로 처리 할 수 ​​있습니다. 이를 통해 개발자는 디버거를 사용하여 메서드가 예상치 못한 작업을 수행하는 정확한 지점을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f129ed2e3eafd696b404b089bdae450998145a1" translate="yes" xml:space="preserve">
          <source>To debug this, we can open up &lt;code&gt;Book.java&lt;/code&gt; and look at line &lt;code&gt;16&lt;/code&gt;, which is:</source>
          <target state="translated">이를 디버깅하기 위해 &lt;code&gt;Book.java&lt;/code&gt; 를 열고 &lt;code&gt;16&lt;/code&gt; 행을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52b747244a3584dd256e5f32c7d956aa076a29e9" translate="yes" xml:space="preserve">
          <source>Usually stack traces are much more complex than the two examples above. Here's an example (it's a long one, but demonstrates several levels of chained exceptions):</source>
          <target state="translated">일반적으로 스택 추적은 위의 두 예제보다 훨씬 더 복잡합니다. 다음은 예제입니다 (긴 예제이지만 여러 수준의 연결 예외를 보여줍니다).</target>
        </trans-unit>
        <trans-unit id="af1112769853e924619a8bd8e2ffe91ac135d2d0" translate="yes" xml:space="preserve">
          <source>What is a stack trace, and how can I use it to debug my application errors</source>
          <target state="translated">스택 추적이란 무엇이며이를 사용하여 응용 프로그램 오류를 디버깅하는 방법</target>
        </trans-unit>
        <trans-unit id="2b95441b3fc2100f60bfef05621335153b0f9dc6" translate="yes" xml:space="preserve">
          <source>What this code is trying to do is to catch the &lt;code&gt;ArithmeticException&lt;/code&gt; caused by a possible division by 0. But it also catches a possible &lt;code&gt;NullPointerException&lt;/code&gt; that is thrown if &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;null&lt;/code&gt;. This means, you might get a &lt;code&gt;NullPointerException&lt;/code&gt; but you'll treat it as an ArithmeticException and probably do the wrong thing. In the best case you still miss that there was a NullPointerException. Stuff like that makes debugging much harder, so don't do that.</source>
          <target state="translated">이 코드는 0으로 &lt;code&gt;ArithmeticException&lt;/code&gt; 수있는 ArithmeticException 을 포착하려고하지만 &lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;b&lt;/code&gt; 가 &lt;code&gt;null&lt;/code&gt; 인 경우 발생할 수있는 &lt;code&gt;NullPointerException&lt;/code&gt; 도 포착합니다. 즉, &lt;code&gt;NullPointerException&lt;/code&gt; 이 발생할 수 있지만이를 ArithmeticException으로 처리하고 잘못된 작업을 수행 할 수 있습니다. 가장 좋은 경우에는 여전히 NullPointerException이 있다는 것을 놓치게됩니다. 그런 것들로 인해 디버깅이 훨씬 어려워 지므로 그렇게하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="8693b761def5d0171d4bb9ab2c4d0391af84116a" translate="yes" xml:space="preserve">
          <source>What's different about this one is the &quot;Caused by&quot;. Sometimes exceptions will have multiple &quot;Caused by&quot; sections. For these, you typically want to find the &quot;root cause&quot;, which will be one of the lowest &quot;Caused by&quot; sections in the stack trace. In our case, it's:</source>
          <target state="translated">이것과 다른 점은 &quot;Caused by&quot;입니다. 때로는 예외에 여러 &quot;원인&quot;섹션이 있습니다. 이를 위해 일반적으로 스택 원인에서 가장 낮은 &quot;원인&quot;섹션 중 하나 인 &quot;근본 원인&quot;을 찾습니다. 우리의 경우 :</target>
        </trans-unit>
        <trans-unit id="a7a6bd69868c0f78cdebeb816648bd67743a6f14" translate="yes" xml:space="preserve">
          <source>Will result in this stack trace:</source>
          <target state="translated">이 스택 추적이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4b7552fe1f875853c01a7103f490b266ec4b133d" translate="yes" xml:space="preserve">
          <source>With the example given in the question, we can determine exactly where the exception was thrown in the application. Let's have a look at the stack trace:</source>
          <target state="translated">질문에 주어진 예를 통해 응용 프로그램에서 예외가 발생한 위치를 정확하게 결정할 수 있습니다. 스택 추적을 살펴 보자.</target>
        </trans-unit>
        <trans-unit id="173e07b2c48da36a70ece276f153fcc804be2dc1" translate="yes" xml:space="preserve">
          <source>and then select &lt;strong&gt;Java Stack Trace Console&lt;/strong&gt; from the drop-down list.</source>
          <target state="translated">드롭 다운 목록에서 &lt;strong&gt;Java Stack Trace Console&lt;/strong&gt; 을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="182d561f07be6784421367d9d0c622c6249e6740" translate="yes" xml:space="preserve">
          <source>if we have a method that takes parameters such as:  &lt;code&gt;void (String firstName)&lt;/code&gt;</source>
          <target state="translated">다음과 같은 매개 변수를 취하는 메소드가있는 경우 : &lt;code&gt;void (String firstName)&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
