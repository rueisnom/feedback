<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/3988788">
    <body>
      <group id="3988788">
        <trans-unit id="9e17c4cb1696a52b482ad758b2ff26ed5d3b3913" translate="yes" xml:space="preserve">
          <source>-&amp;gt; &lt;strong&gt;Locate the root cause in the middle is your job.&lt;/strong&gt;</source>
          <target state="translated">-&amp;gt; &lt;strong&gt;Найти основную причину в середине ваша работа.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7efdc3da3f50066fd34771714e2a5d58bba23bab" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;About this question - quite often I see a question come through where a novice programmer is &quot;getting an error&quot;, and they simply paste their stack trace and some random block of code without understanding what the stack trace is or how they can use it. This question is intended as a reference for novice programmers who might need help understanding the value of a stack trace.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;Об этом вопросе - довольно часто я вижу вопрос, когда начинающий программист &amp;laquo;получает ошибку&amp;raquo;, и они просто вставляют свою трассировку стека и некоторый случайный блок кода, не понимая, что такое трассировка стека или как они могут ее использовать.&lt;/em&gt; &lt;em&gt;Этот вопрос предназначен для начинающих программистов, которым может понадобиться помощь в понимании значения трассировки стека.&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e30b6c9a4a40d436e4c73aca3e343c2bb6300046" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example with a chain of exceptions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Пример с цепочкой исключений&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1aa697efe4c7ad2e19dd36e95353a7dbaf884e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How should I deal with Stacktraces/Exceptions?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Как я должен иметь дело со стеками / исключениями?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c0c6819414fd35c2dd636ddb836570f5c6003f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key 1&lt;/strong&gt;:A tricky and important thing here need to be understand is : the deepest cause may not be the &quot;root cause&quot;, because if you write some &quot;bad code&quot;, it may cause some exception underneath which is deeper than its layer. For example, a bad sql query may cause SQLServerException connection reset in the bottem instead of syndax error, which may just in the middle of the stack.</source>
          <target state="translated">&lt;strong&gt;Ключ 1&lt;/strong&gt; : хитрая и важная вещь, которую необходимо здесь понять: самая глубокая причина не может быть &amp;laquo;первопричиной&amp;raquo;, потому что, если вы пишете какой-то &amp;laquo;плохой код&amp;raquo;, это может вызвать некое исключение под ним, которое глубже, чем его слой. Например, неверный SQL-запрос может привести к сбросу соединения SQLServerException в нижней части окна, а не к ошибке sinax, которая может быть только в середине стека.</target>
        </trans-unit>
        <trans-unit id="f9b27c0022bb53c8f1eda585728984a27b016e54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key 2&lt;/strong&gt;:Another tricky but important thing is inside each &quot;Cause by&quot; block, the first line was the deepest layer and happen first place for this block. For instance,</source>
          <target state="translated">&lt;strong&gt;Ключ 2&lt;/strong&gt; : Еще одна хитрая, но важная вещь находится внутри каждого блока &amp;laquo;Причины&amp;raquo;, первая строка была самым глубоким слоем, и в этом блоке было первое место. Например,</target>
        </trans-unit>
        <trans-unit id="a6f80e689cac9f3d1c38029e6dc4646b88000beb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Manipulated stack trace:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Трассировка манипулируемого стека:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="efae31b0f686ad094d22681d2e39cca7f4838076" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More daunting example with library code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Более сложный пример с библиотечным кодом&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30cc467eaf3b95a0739540a9156ebc43493b1920" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Простой пример&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f01621c5ba99bb45938e4719e48e833d01071218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Standard behavior:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Стандартное поведение:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0def28abff50b5453af5effe03f21c319e75a393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54f43df9b5cad10843edbfcc5365f620a5f11c69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To understand the name&lt;/strong&gt;: A stack trace is a a list of Exceptions( or you can say a list of &quot;Cause by&quot;), from the most surface Exception(e.g. Service Layer Exception) to the deepest one (e.g. Database Exception). Just like the reason we call it 'stack' is because stack is First in Last out (FILO), the deepest exception was happened in the very beginning, then a chain of exception was generated a series of consequences, the surface Exception was the last one happened in time, but we see it in the first place.</source>
          <target state="translated">&lt;strong&gt;Чтобы понять имя&lt;/strong&gt; : трассировка стека - это список Исключений (или вы можете сказать список &amp;laquo;Причины&amp;raquo;), от самого поверхностного исключения (например, исключения уровня обслуживания) до самого глубокого (например, исключения базы данных). Точно так же, как причина, по которой мы называем это &amp;laquo;стек&amp;raquo;, заключается в том, что стек является первым в последнем выходе (FILO), самое глубокое исключение произошло в самом начале, а затем была создана цепочка исключений с серией последствий, исключение на поверхности было последним одно произошло вовремя, но мы видим это в первую очередь.</target>
        </trans-unit>
        <trans-unit id="8c7c8060530d12e9c50d077a6c2083b8ced2d726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Stacktrace?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что такое Stacktrace?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c07623d7483d1dbf34b9b1dfdb26de4239c6d4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is an Exception?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Что такое исключение?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a965cc63ff98aa09a9add3204ed8471c665810a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why should I not use &lt;code&gt;catch (Exception e)&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Почему я не должен использовать &lt;code&gt;catch (Exception e)&lt;/code&gt; ?&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6226ce539868df18e25336c8aac8f012bdde715e" translate="yes" xml:space="preserve">
          <source>A stacktrace is a very helpful debugging tool. It shows the call stack (meaning, the stack of functions that were called up to that point) at the time an uncaught exception was thrown (or the time the stacktrace was generated manually). This is very useful because it doesn't only show you where the error happened, but also how the program ended up in that place of the code.
This leads over to the next question:</source>
          <target state="translated">Стектрассировка-очень полезный инструмент отладки.Он показывает стек вызовов (то есть,стек функций,которые были вызваны до этого момента)в момент,когда было брошено непойманное исключение (или когда стековая трасса была сгенерирована вручную).Это очень полезно,так как показывает не только,где произошла ошибка,но и как программа оказалась в том месте кода.Это приводит к следующему вопросу:</target>
        </trans-unit>
        <trans-unit id="e2c723fd5136ff587ea2f2fd14ae158435d55ec6" translate="yes" xml:space="preserve">
          <source>Again, with this exception we'd want to look at line &lt;code&gt;22&lt;/code&gt; of &lt;code&gt;Book.java&lt;/code&gt; to see what might cause the &lt;code&gt;NullPointerException&lt;/code&gt; here.</source>
          <target state="translated">Опять же, за этим исключением, мы хотели бы взглянуть на строку &lt;code&gt;22&lt;/code&gt; &lt;code&gt;Book.java&lt;/code&gt; , чтобы увидеть, что может вызвать здесь исключение &lt;code&gt;NullPointerException&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ded27539184c5108bce982dfb7dae5374889b46" translate="yes" xml:space="preserve">
          <source>An Exception is what the runtime environment uses to tell you that an error occurred. Popular examples are NullPointerException, IndexOutOfBoundsException or ArithmeticException. Each of these are caused when you try to do something that is not possible. For example, a NullPointerException will be thrown when you try to dereference a Null-object:</source>
          <target state="translated">Исключением является то,что среда выполнения использует,чтобы сказать вам,что произошла ошибка.Популярными примерами являются NullPointerException,IndexOutOfBoundsException или ArithmeticException.Каждый из них вызывается,когда вы пытаетесь сделать что-то,что невозможно.Например,NullPointerException будет брошен,когда вы пытаетесь разыменовать Null-объект:</target>
        </trans-unit>
        <trans-unit id="1446b54943846ed8ede7eecb7acb580739cf75ea" translate="yes" xml:space="preserve">
          <source>At first, find out what is causing the Exception. Try googleing the name of the exception to find out, what is the cause of that exception. Most of the time it will be caused by incorrect code. In the given examples above, all of the exceptions are caused by incorrect code. So for the NullPointerException example you could make sure that &lt;code&gt;a&lt;/code&gt; is never null at that time. You could, for example, initialise &lt;code&gt;a&lt;/code&gt; or include a check like this one:</source>
          <target state="translated">Сначала выясните, что вызывает исключение. Попробуйте поискать название исключения, чтобы выяснить причину этого исключения. В большинстве случаев это будет вызвано неправильным кодом. В приведенных выше примерах все исключения вызваны неправильным кодом. Таким образом, для примера NullPointerException вы можете убедиться, что &lt;code&gt;a&lt;/code&gt; никогда не будет нулевым в это время. Вы можете, например, инициализировать или включить проверку, например, такую:</target>
        </trans-unit>
        <trans-unit id="fec354ceddcbe7ea20bb5ca5289ffec7bb364462" translate="yes" xml:space="preserve">
          <source>Book.java:16 was called by Auther.java:25 which was called by Bootstrap.java:14, Book.java:16 was the root cause.
Here attach a diagram sort the trace stack in chronological order.</source>
          <target state="translated">Book.java:16 был назван Auther.java:25,который был назван Bootstrap.java:14,Book.java:16 был первопричиной.Здесь прилагается диаграмма,сортирующая стек трасс в хронологическом порядке.</target>
        </trans-unit>
        <trans-unit id="80bd8c5b2084abf7b62c1a6d5f7ab234ebfa537a" translate="yes" xml:space="preserve">
          <source>Figure out what is the cause of the exception and fix it, so that it doesn't throw the exception at all.</source>
          <target state="translated">Выясните причину исключения и исправьте его,чтобы оно вообще не бросало исключение.</target>
        </trans-unit>
        <trans-unit id="e438e6ab6e9a62b6589d45cb6ab68d42a04e71c6" translate="yes" xml:space="preserve">
          <source>First, ensure that you have all of your Java sources accessible in an Eclipse project.</source>
          <target state="translated">Во-первых,убедитесь,что все ваши источники Java доступны в проекте Eclipse.</target>
        </trans-unit>
        <trans-unit id="564a794ca9340e5bd5c39ffc26dcfd0ab1ac2acd" translate="yes" xml:space="preserve">
          <source>However, all the method calls under that are library code. So we'll move up to the &quot;Caused by&quot; above it, and look for the first method call originating from our code, which is:</source>
          <target state="translated">Однако,все вызовы методов,под которыми они подразумеваются,являются библиотечным кодом.Поэтому мы перейдем к вышеприведенной строке &quot;Причина&quot; и поищем первый вызов метода,исходящий из нашего кода,а именно:</target>
        </trans-unit>
        <trans-unit id="ea628175c8c7097d7fa1404e48c24d9e23055a01" translate="yes" xml:space="preserve">
          <source>I am posting this answer so the topmost answer (when sorted by activity) is not one that is just plain wrong.</source>
          <target state="translated">Я размещаю этот ответ,так что самый верхний ответ (при сортировке по активности)не является просто неправильным.</target>
        </trans-unit>
        <trans-unit id="5b77138d4162100bb0d1021e6370830c0d6aae0b" translate="yes" xml:space="preserve">
          <source>If 1. is not possible, catch the specific exception and handle it.</source>
          <target state="translated">Если 1.невозможно,поймайте специфическое исключение и обратитесь с ним.</target>
        </trans-unit>
        <trans-unit id="15d8614888c88baa8e0dd1a6f06bbc31587cc34c" translate="yes" xml:space="preserve">
          <source>If you are using open-source software, you might need to download and attach to your project the sources if you want to examine. Download the source jars, in your project, open the &lt;em&gt;Referenced Libraries&lt;/em&gt; folder to find your jar for your open-source module (the one with the class files) then right click, select &lt;em&gt;Properties&lt;/em&gt; and attach the source jar.</source>
          <target state="translated">Если вы используете программное обеспечение с открытым исходным кодом, вам может потребоваться загрузить и прикрепить к своему проекту источники, если вы хотите проверить. Загрузите jar-файлы с исходным кодом, в своем проекте откройте папку &lt;em&gt;Referenced Libraries,&lt;/em&gt; чтобы найти jar-файл для вашего модуля с открытым исходным кодом (тот, который содержит файлы классов), затем щелкните правой кнопкой мыши, выберите &lt;em&gt;Properties&lt;/em&gt; и прикрепите jar-файл с исходным кодом.</target>
        </trans-unit>
        <trans-unit id="487eb90890ff758ab851426d85fc6a7789a9eae0" translate="yes" xml:space="preserve">
          <source>If you get a stack trace and want to trace the cause of the exception, a good start point in understanding it is to use the &lt;em&gt;Java Stack Trace Console&lt;/em&gt; in &lt;strong&gt;Eclipse&lt;/strong&gt;. If you use another IDE there may be a similar feature, but this answer is about Eclipse.</source>
          <target state="translated">Если вы получаете трассировку стека и хотите отследить причину исключения, хорошей отправной точкой для понимания этого является использование &lt;em&gt;консоли Java Stack Trace Console&lt;/em&gt; в &lt;strong&gt;Eclipse&lt;/strong&gt; . Если вы используете другую IDE, может быть похожая функция, но этот ответ касается Eclipse.</target>
        </trans-unit>
        <trans-unit id="613591bc550676714745432c75c4a608a01e1002" translate="yes" xml:space="preserve">
          <source>In our code we would want to evaluate that &lt;code&gt;firstName&lt;/code&gt; contains a value, we would do this like so: &lt;code&gt;if(firstName == null || firstName.equals(&quot;&quot;))  return;&lt;/code&gt;</source>
          <target state="translated">В нашем коде мы хотели бы оценить, что &lt;code&gt;firstName&lt;/code&gt; содержит значение, мы сделали бы это так: &lt;code&gt;if(firstName == null || firstName.equals(&quot;&quot;)) return;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09a8a4114baff1ef1a66283b7e865492f7e51289" translate="yes" xml:space="preserve">
          <source>In simple terms, a &lt;strong&gt;stack trace&lt;/strong&gt; is a list of the method calls that the application was in the middle of when an Exception was thrown.</source>
          <target state="translated">Проще говоря, &lt;strong&gt;трассировка стека&lt;/strong&gt; - это список вызовов методов, которые приложение находилось в середине, когда было сгенерировано исключение.</target>
        </trans-unit>
        <trans-unit id="14b0ec51c80a071a2bd3488f704f780ec376c702" translate="yes" xml:space="preserve">
          <source>In this example, there's a lot more. What we're mostly concerned about is looking for methods that are from &lt;em&gt;our code&lt;/em&gt;, which would be anything in the &lt;code&gt;com.example.myproject&lt;/code&gt; package. From the second example (above), we'd first want to look down for the root cause, which is:</source>
          <target state="translated">В этом примере намного больше. Что нас больше всего беспокоит, так это поиск методов из &lt;em&gt;нашего кода&lt;/em&gt; , которые могут быть в пакете &lt;code&gt;com.example.myproject&lt;/code&gt; . Из второго примера (выше), мы сначала хотели бы найти первопричину, а именно:</target>
        </trans-unit>
        <trans-unit id="fd8f9a5ad29840838bb582c1d11aeb8597efa9b6" translate="yes" xml:space="preserve">
          <source>Just to add to the other examples, there are &lt;strong&gt;inner(nested) classes&lt;/strong&gt; that appear with the &lt;code&gt;$&lt;/code&gt; sign. For example:</source>
          <target state="translated">Просто чтобы добавить к другим примерам, есть &lt;strong&gt;внутренние (вложенные) классы,&lt;/strong&gt; которые появляются со знаком &lt;code&gt;$&lt;/code&gt; . Например:</target>
        </trans-unit>
        <trans-unit id="8ad5d1e6de22d3b3226789df2d8fbb5e80d49cf6" translate="yes" xml:space="preserve">
          <source>Let's use a small example to show why you should not just catch all exceptions:</source>
          <target state="translated">Давайте на небольшом примере покажем,почему не стоит просто ловить все исключения:</target>
        </trans-unit>
        <trans-unit id="23fb093c264a0e642af1b47a80f767b268b0a3c0" translate="yes" xml:space="preserve">
          <source>Like in previous examples, we should look at &lt;code&gt;MyEntityService.java&lt;/code&gt; on line &lt;code&gt;59&lt;/code&gt;, because that's where this error originated (this one's a bit obvious what went wrong, since the SQLException states the error, but the debugging procedure is what we're after).</source>
          <target state="translated">Как и в предыдущих примерах, мы должны взглянуть на &lt;code&gt;MyEntityService.java&lt;/code&gt; в строке &lt;code&gt;59&lt;/code&gt; , потому что именно здесь возникла эта ошибка (эта ошибка немного очевидна, что пошло не так, поскольку SQLException сообщает об ошибке, но мы ищем процедуру отладки) ,</target>
        </trans-unit>
        <trans-unit id="8fc9cf7ede540afe6a0e435663def251386adccc" translate="yes" xml:space="preserve">
          <source>Never just add a try/catch and then just ignore the exception! Don't do that!</source>
          <target state="translated">Никогда не добавляйте просто trycatch,а затем просто игнорируйте исключение! Не делай этого!</target>
        </trans-unit>
        <trans-unit id="39d9f60e1e2998c13e4e2032d71593c865205a1e" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;catch (Exception e)&lt;/code&gt;, always catch specific Exceptions. That will save you a lot of headaches.</source>
          <target state="translated">Никогда не используйте &lt;code&gt;catch (Exception e)&lt;/code&gt; , всегда ловите определенные исключения. Это избавит вас от многих головных болей.</target>
        </trans-unit>
        <trans-unit id="495ca3360ccb4106b9d0e5dce9e4592ebbcbe3e7" translate="yes" xml:space="preserve">
          <source>Paste your stack trace into the console. It will then provide a list of links into your source code and any other source code available.</source>
          <target state="translated">Вставьте след от стека в консоль.Затем он предоставит список ссылок на ваш исходный код и любой другой доступный исходный код.</target>
        </trans-unit>
        <trans-unit id="93298efff7ecf9f3994b22176c9239a238b08680" translate="yes" xml:space="preserve">
          <source>People have referred to this as a &quot;stack trace&quot;. &lt;strong&gt;What is a stack trace?&lt;/strong&gt; What can it tell me about the error that's happening in my program?</source>
          <target state="translated">Люди называют это &amp;laquo;следом стека&amp;raquo;. &lt;strong&gt;Что такое трассировка стека?&lt;/strong&gt; Что он может сказать мне об ошибке, которая происходит в моей программе?</target>
        </trans-unit>
        <trans-unit id="2d6cea83d2fa9c56b7e4f83d9acb2e8a9b781054" translate="yes" xml:space="preserve">
          <source>Since Rob has used the &lt;code&gt;NullPointerException&lt;/code&gt; (NPE) to illustrate something common, we can help to remove this issue in the following manner:</source>
          <target state="translated">Поскольку Роб использовал &lt;code&gt;NullPointerException&lt;/code&gt; (NPE) для иллюстрации чего-то общего, мы можем помочь устранить эту проблему следующим образом:</target>
        </trans-unit>
        <trans-unit id="c6e423de13a20e8485c4d2b1b23c4c523c61a38c" translate="yes" xml:space="preserve">
          <source>Sometimes applications will catch an Exception and re-throw it as the cause of another Exception.  This typically looks like:</source>
          <target state="translated">Иногда приложения улавливают Исключение и повторно выбрасывают его как причину другого Исключения.Это обычно выглядит так:</target>
        </trans-unit>
        <trans-unit id="e466c8c050df7f99d7ed3eda1da2960c7c20347e" translate="yes" xml:space="preserve">
          <source>Sometimes when I run my application it gives me an error that looks like:</source>
          <target state="translated">Иногда,когда я запускаю свое приложение,это дает мне ошибку,которая выглядит так:</target>
        </trans-unit>
        <trans-unit id="d22141c591cb9e0635bd1ecdf684ef89dcc76510" translate="yes" xml:space="preserve">
          <source>Sometimes you can't make sure that you don't get an exception. For example, if you are using a network connection in your program, you cannot stop the computer from loosing it's internet connection (e.g. you can't stop the user from disconnecting the computer's network connection). In this case the network library will probably throw an exception. Now you should catch the exception and &lt;strong&gt;handle&lt;/strong&gt; it. This means, in the example with the network connection, you should try to reopen the connection or notify the user or something like that. Also, whenever you use catch, always catch only the exception you want to catch, &lt;strong&gt;do not use broad catch statements like &lt;code&gt;catch (Exception e)&lt;/code&gt;&lt;/strong&gt; that would catch all exceptions. This is very important, because otherwise you might accidentally catch the wrong exception and react in the wrong way.</source>
          <target state="translated">Иногда вы не можете быть уверены, что не получите исключения. Например, если вы используете сетевое соединение в своей программе, вы не можете остановить компьютер от потери его интернет-соединения (например, вы не можете запретить пользователю отключать сетевое соединение компьютера). В этом случае сетевая библиотека, вероятно, выдаст исключение. Теперь вы должны поймать исключение и &lt;strong&gt;обработать&lt;/strong&gt; его. Это означает, что в примере с сетевым подключением вы должны попытаться повторно открыть подключение или уведомить пользователя или что-то в этом роде. Кроме того, всякий раз, когда вы используете catch, всегда перехватываете только то исключение, которое вы хотите перехватить, &lt;strong&gt;не используйте широкие операторы &lt;code&gt;catch (Exception e)&lt;/code&gt; такие как catch (Exception e),&lt;/strong&gt; которые бы перехватывали все исключения. Это очень важно, потому что в противном случае вы можете случайно поймать не то исключение и отреагировать неправильно.</target>
        </trans-unit>
        <trans-unit id="cb9cb776c20bea056423449369d53ef52a9c4259" translate="yes" xml:space="preserve">
          <source>Stack trace:</source>
          <target state="translated">Следы стека:</target>
        </trans-unit>
        <trans-unit id="bf69b603dad9a6fc4eb1f9b4f8ea6caf897877da" translate="yes" xml:space="preserve">
          <source>The above is the proper order to check for nulls, we start with the base object, dog in this case, and then begin walking down the tree of possibilities to make sure everything is valid before processing.  If the order were reversed a NPE could potentially be thrown and our program would crash.</source>
          <target state="translated">Выше приведен правильный порядок проверки на наличие нулей,мы начинаем с базового объекта,в данном случае собаки,а затем начинаем ходить по дереву возможностей,чтобы удостовериться,что все в порядке перед обработкой.Если бы ордер был перевернут,то потенциально могло бы быть выброшено NPE,и наша программа аварийно завершалась бы.</target>
        </trans-unit>
        <trans-unit id="5fb27293f5065e48d95aab824bc00124be221a18" translate="yes" xml:space="preserve">
          <source>The above prevents us from using &lt;code&gt;firstName&lt;/code&gt; as an unsafe parameter.  Therefore  by doing null checks before processing we can help to ensure that our code will run properly.  To expand on an example that utilizes an object with methods we can look here:</source>
          <target state="translated">Вышесказанное не позволяет нам использовать &lt;code&gt;firstName&lt;/code&gt; в качестве небезопасного параметра. Поэтому, выполняя нулевые проверки перед обработкой, мы можем помочь гарантировать, что наш код будет работать правильно. Чтобы расширить пример, который использует объект с методами, мы можем посмотреть здесь:</target>
        </trans-unit>
        <trans-unit id="7453ef913bb69c16a9f8a1f7b1324fb28f009efa" translate="yes" xml:space="preserve">
          <source>The most recent method call made will be the &lt;em&gt;top&lt;/em&gt; of the stack, which is the top line (excluding the message text). Going down the stack goes back in time. The second line is the method that calls the first line, etc.</source>
          <target state="translated">Самый последний вызов метода будет &lt;em&gt;вершиной&lt;/em&gt; стека, которая является верхней строкой (исключая текст сообщения). Спуск по стеку уходит в прошлое. Вторая строка - это метод, который вызывает первую строку и т. Д.</target>
        </trans-unit>
        <trans-unit id="11fbf33c63bd03732692540005c072cdd3ed1096" translate="yes" xml:space="preserve">
          <source>The other posts describe what a stack trace is, but it can still be hard to work with.</source>
          <target state="translated">Другие сообщения описывают,что такое трассировка стека,но с ней все равно может быть сложно работать.</target>
        </trans-unit>
        <trans-unit id="c3ddf11fc25689b080b12527baea39641ae0db87" translate="yes" xml:space="preserve">
          <source>Then in the &lt;em&gt;Java&lt;/em&gt; perspective, click on the &lt;em&gt;Console&lt;/em&gt; tab (usually at the bottom). If the Console view is not visible, go to the menu option &lt;em&gt;Window -&amp;gt; Show View&lt;/em&gt; and select &lt;em&gt;Console&lt;/em&gt;.</source>
          <target state="translated">Затем в перспективе &lt;em&gt;Java&lt;/em&gt; нажмите на вкладку &lt;em&gt;Консоль&lt;/em&gt; (обычно внизу). Если вид консоли не отображается, перейдите к пункту меню &amp;laquo; &lt;em&gt;Окно&amp;raquo; -&amp;gt; &amp;laquo;Показать вид&amp;raquo;&lt;/em&gt; и выберите &amp;laquo; &lt;em&gt;Консоль&amp;raquo;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="575a7a948c6a156a106d55a90241bd4749fad5ca" translate="yes" xml:space="preserve">
          <source>Then in the console window, click on the following button (on the right)</source>
          <target state="translated">Затем в консольном окне нажмите на следующую кнопку (справа)</target>
        </trans-unit>
        <trans-unit id="7b113dc376f62ec3b062c6c5782a7c23ce7ed13e" translate="yes" xml:space="preserve">
          <source>There is one more stacktrace feature offered by Throwable family - the possibility to &lt;strong&gt;manipulate&lt;/strong&gt; stack trace information.</source>
          <target state="translated">Существует еще одна функция трассировки стека, предлагаемая семейством Throwable - возможность &lt;strong&gt;манипулировать&lt;/strong&gt; информацией трассировки стека.</target>
        </trans-unit>
        <trans-unit id="0839a810ec4da88cdf6083cb5086fe5cee3ee685" translate="yes" xml:space="preserve">
          <source>This is a very simple stack trace. If we start at the beginning of the list of &quot;at ...&quot;, we can tell where our error happened. What we're looking for is the &lt;strong&gt;topmost&lt;/strong&gt; method call that is part of our application. In this case, it's:</source>
          <target state="translated">Это очень простая трассировка стека. Если мы начнем с начала списка &amp;laquo;at ...&amp;raquo;, мы можем сказать, где произошла наша ошибка. Мы ищем самый &lt;strong&gt;верхний&lt;/strong&gt; вызов метода, который является частью нашего приложения. В данном случае это:</target>
        </trans-unit>
        <trans-unit id="5f628c41d41907e9337eb90dc7ec480a43bef487" translate="yes" xml:space="preserve">
          <source>This is what you might see (image from the Eclipse documentation):</source>
          <target state="translated">Это то,что вы можете увидеть (образ из документации Eclipse):</target>
        </trans-unit>
        <trans-unit id="78507f11dd782b6c1af51bf682954e32ebc76066" translate="yes" xml:space="preserve">
          <source>This might give you a stack trace that looks like:</source>
          <target state="translated">Это могло бы дать тебе след,который выглядел бы так:</target>
        </trans-unit>
        <trans-unit id="4ec60d92e12153a63d117ff1ab794bc3e4143c4b" translate="yes" xml:space="preserve">
          <source>This way, the offending line is not executed if &lt;code&gt;a==null&lt;/code&gt;. Same goes for the other examples.</source>
          <target state="translated">Таким образом, ошибочная строка не выполняется, если &lt;code&gt;a==null&lt;/code&gt; . То же самое касается других примеров.</target>
        </trans-unit>
        <trans-unit id="86a413041e25913218b0abb28f5e2dc38fc95d9c" translate="yes" xml:space="preserve">
          <source>This would indicate that something (probably &lt;code&gt;title&lt;/code&gt;) is &lt;code&gt;null&lt;/code&gt; in the above code.</source>
          <target state="translated">Это указывает на то, что что-то (возможно, &lt;code&gt;title&lt;/code&gt; ) является &lt;code&gt;null&lt;/code&gt; в приведенном выше коде</target>
        </trans-unit>
        <trans-unit id="b633c5cf2b51a5bd3a70b5d319f1c2ac9b9edcfd" translate="yes" xml:space="preserve">
          <source>To add on to what Rob has mentioned.  Setting break points in your application allows for the step-by-step processing of the stack.  This enables the developer to use the debugger to see at what exact point the method is doing something that was unanticipated.</source>
          <target state="translated">Чтобы добавить к тому,что упомянул Роб.Установка точек останова в вашем приложении позволяет поэтапно обрабатывать стек.Это позволяет разработчику использовать отладчик,чтобы увидеть,в какой именно точке метод делает то,что было непредвиденным.</target>
        </trans-unit>
        <trans-unit id="0f129ed2e3eafd696b404b089bdae450998145a1" translate="yes" xml:space="preserve">
          <source>To debug this, we can open up &lt;code&gt;Book.java&lt;/code&gt; and look at line &lt;code&gt;16&lt;/code&gt;, which is:</source>
          <target state="translated">Чтобы отладить это, мы можем открыть &lt;code&gt;Book.java&lt;/code&gt; и посмотреть на строку &lt;code&gt;16&lt;/code&gt; , которая:</target>
        </trans-unit>
        <trans-unit id="52b747244a3584dd256e5f32c7d956aa076a29e9" translate="yes" xml:space="preserve">
          <source>Usually stack traces are much more complex than the two examples above. Here's an example (it's a long one, but demonstrates several levels of chained exceptions):</source>
          <target state="translated">Обычно следы стека гораздо сложнее,чем два вышеприведенных примера.Вот пример (он длинный,но демонстрирует несколько уровней цепочечных исключений):</target>
        </trans-unit>
        <trans-unit id="af1112769853e924619a8bd8e2ffe91ac135d2d0" translate="yes" xml:space="preserve">
          <source>What is a stack trace, and how can I use it to debug my application errors</source>
          <target state="translated">Что такое стековая трассировка,и как я могу использовать ее для отладки моих ошибок приложения.</target>
        </trans-unit>
        <trans-unit id="2b95441b3fc2100f60bfef05621335153b0f9dc6" translate="yes" xml:space="preserve">
          <source>What this code is trying to do is to catch the &lt;code&gt;ArithmeticException&lt;/code&gt; caused by a possible division by 0. But it also catches a possible &lt;code&gt;NullPointerException&lt;/code&gt; that is thrown if &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;null&lt;/code&gt;. This means, you might get a &lt;code&gt;NullPointerException&lt;/code&gt; but you'll treat it as an ArithmeticException and probably do the wrong thing. In the best case you still miss that there was a NullPointerException. Stuff like that makes debugging much harder, so don't do that.</source>
          <target state="translated">Этот код пытается перехватить исключение &lt;code&gt;ArithmeticException&lt;/code&gt; , вызванное возможным делением на 0. Но он также перехватывает возможное исключение &lt;code&gt;NullPointerException&lt;/code&gt; , которое выдается , если &lt;code&gt;a&lt;/code&gt; или &lt;code&gt;b&lt;/code&gt; равны &lt;code&gt;null&lt;/code&gt; . Это означает, что вы можете получить &lt;code&gt;NullPointerException&lt;/code&gt; но вы будете рассматривать его как ArithmeticException и, вероятно, будете поступать неправильно. В лучшем случае вы все еще скучаете по тому, что было исключение NullPointerException. Такие вещи делают отладку намного сложнее, так что не делайте этого.</target>
        </trans-unit>
        <trans-unit id="8693b761def5d0171d4bb9ab2c4d0391af84116a" translate="yes" xml:space="preserve">
          <source>What's different about this one is the &quot;Caused by&quot;. Sometimes exceptions will have multiple &quot;Caused by&quot; sections. For these, you typically want to find the &quot;root cause&quot;, which will be one of the lowest &quot;Caused by&quot; sections in the stack trace. In our case, it's:</source>
          <target state="translated">А вот в этом есть разница-&quot;Причина&quot;.Иногда исключения будут иметь несколько секций &quot;Причины&quot;.Для них вы обычно хотите найти &quot;первопричину&quot;,которая будет одной из самых низких &quot;Причин&quot; секций в трассе стека.В нашем случае:</target>
        </trans-unit>
        <trans-unit id="a7a6bd69868c0f78cdebeb816648bd67743a6f14" translate="yes" xml:space="preserve">
          <source>Will result in this stack trace:</source>
          <target state="translated">В результате будет получен этот стековый след:</target>
        </trans-unit>
        <trans-unit id="4b7552fe1f875853c01a7103f490b266ec4b133d" translate="yes" xml:space="preserve">
          <source>With the example given in the question, we can determine exactly where the exception was thrown in the application. Let's have a look at the stack trace:</source>
          <target state="translated">На примере,приведенном в вопросе,мы можем точно определить,куда было брошено исключение в приложении.Давайте посмотрим на след стека:</target>
        </trans-unit>
        <trans-unit id="173e07b2c48da36a70ece276f153fcc804be2dc1" translate="yes" xml:space="preserve">
          <source>and then select &lt;strong&gt;Java Stack Trace Console&lt;/strong&gt; from the drop-down list.</source>
          <target state="translated">и затем выберите &lt;strong&gt;Java Stack Trace Console&lt;/strong&gt; из раскрывающегося списка.</target>
        </trans-unit>
        <trans-unit id="182d561f07be6784421367d9d0c622c6249e6740" translate="yes" xml:space="preserve">
          <source>if we have a method that takes parameters such as:  &lt;code&gt;void (String firstName)&lt;/code&gt;</source>
          <target state="translated">если у нас есть метод, который принимает параметры, такие как: &lt;code&gt;void (String firstName)&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
