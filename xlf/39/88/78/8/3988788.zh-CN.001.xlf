<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3988788">
    <body>
      <group id="3988788">
        <trans-unit id="9e17c4cb1696a52b482ad758b2ff26ed5d3b3913" translate="yes" xml:space="preserve">
          <source>-&amp;gt; &lt;strong&gt;Locate the root cause in the middle is your job.&lt;/strong&gt;</source>
          <target state="translated">-&amp;gt; &lt;strong&gt;在中间找到根本原因是您的工作。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7efdc3da3f50066fd34771714e2a5d58bba23bab" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;About this question - quite often I see a question come through where a novice programmer is &quot;getting an error&quot;, and they simply paste their stack trace and some random block of code without understanding what the stack trace is or how they can use it. This question is intended as a reference for novice programmers who might need help understanding the value of a stack trace.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;关于这个问题-我经常看到一个问题，这个问题是新手程序员在&amp;ldquo;遇到错误&amp;rdquo;时遇到的，他们只是粘贴了堆栈跟踪信息和一些随机的代码块，却不了解堆栈跟踪信息是什么或如何使用它。&lt;/em&gt; &lt;em&gt;该问题旨在为可能需要帮助来了解堆栈跟踪值的新手程序员提供参考。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e30b6c9a4a40d436e4c73aca3e343c2bb6300046" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example with a chain of exceptions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;带有一系列异常的示例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1aa697efe4c7ad2e19dd36e95353a7dbaf884e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How should I deal with Stacktraces/Exceptions?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;我应该如何处理Stacktraces / Exceptions？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c0c6819414fd35c2dd636ddb836570f5c6003f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key 1&lt;/strong&gt;:A tricky and important thing here need to be understand is : the deepest cause may not be the &quot;root cause&quot;, because if you write some &quot;bad code&quot;, it may cause some exception underneath which is deeper than its layer. For example, a bad sql query may cause SQLServerException connection reset in the bottem instead of syndax error, which may just in the middle of the stack.</source>
          <target state="translated">&lt;strong&gt;关键1&lt;/strong&gt; ：这里需要理解的一个棘手和重要的事情是：究其根本原因可能不是&amp;ldquo;根本原因&amp;rdquo;，因为如果您编写一些&amp;ldquo;不良代码&amp;rdquo;，则可能会在其底层深处引起某些异常。 例如，错误的sql查询可能会导致在bottem中重置SQLServerException连接而不是syndax错误，该错误可能恰好在堆栈的中间。</target>
        </trans-unit>
        <trans-unit id="f9b27c0022bb53c8f1eda585728984a27b016e54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key 2&lt;/strong&gt;:Another tricky but important thing is inside each &quot;Cause by&quot; block, the first line was the deepest layer and happen first place for this block. For instance,</source>
          <target state="translated">&lt;strong&gt;关键2&lt;/strong&gt; ：另一个棘手但重要的事情是在每个&amp;ldquo; Cause by&amp;rdquo;块中，第一行是最深的层，并且在该块中排在第一位。 例如，</target>
        </trans-unit>
        <trans-unit id="a6f80e689cac9f3d1c38029e6dc4646b88000beb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Manipulated stack trace:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;操纵堆栈跟踪：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="efae31b0f686ad094d22681d2e39cca7f4838076" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More daunting example with library code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;库代码更令人生畏的示例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30cc467eaf3b95a0739540a9156ebc43493b1920" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;简单的例子&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f01621c5ba99bb45938e4719e48e833d01071218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Standard behavior:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;标准行为：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0def28abff50b5453af5effe03f21c319e75a393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54f43df9b5cad10843edbfcc5365f620a5f11c69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To understand the name&lt;/strong&gt;: A stack trace is a a list of Exceptions( or you can say a list of &quot;Cause by&quot;), from the most surface Exception(e.g. Service Layer Exception) to the deepest one (e.g. Database Exception). Just like the reason we call it 'stack' is because stack is First in Last out (FILO), the deepest exception was happened in the very beginning, then a chain of exception was generated a series of consequences, the surface Exception was the last one happened in time, but we see it in the first place.</source>
          <target state="translated">&lt;strong&gt;要了解名称，请执行以下操作&lt;/strong&gt; ：堆栈跟踪是一系列异常的列表（或者您可以说是&amp;ldquo;原因&amp;rdquo;的列表），从最表面的异常（例如，服务层异常）到最深层的异常（例如，数据库异常）。 就像我们称其为&amp;ldquo;堆栈&amp;rdquo;的原因一样，因为堆栈是先进先出（FILO），最深层的异常发生在一开始，然后异常链产生了一系列后果，表面异常是最后一个事情及时发生了，但我们首先看到了它。</target>
        </trans-unit>
        <trans-unit id="8c7c8060530d12e9c50d077a6c2083b8ced2d726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Stacktrace?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;什么是Stacktrace？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c07623d7483d1dbf34b9b1dfdb26de4239c6d4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is an Exception?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;什么是例外？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a965cc63ff98aa09a9add3204ed8471c665810a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why should I not use &lt;code&gt;catch (Exception e)&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;为什么我不应该使用 &lt;code&gt;catch (Exception e)&lt;/code&gt; ？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6226ce539868df18e25336c8aac8f012bdde715e" translate="yes" xml:space="preserve">
          <source>A stacktrace is a very helpful debugging tool. It shows the call stack (meaning, the stack of functions that were called up to that point) at the time an uncaught exception was thrown (or the time the stacktrace was generated manually). This is very useful because it doesn't only show you where the error happened, but also how the program ended up in that place of the code.
This leads over to the next question:</source>
          <target state="translated">堆栈跟踪是一个非常有用的调试工具。它显示了未捕获的异常被抛出时的调用堆栈(意思是说,调用到该点的函数的堆栈),或者手动生成堆栈跟踪的时间。这一点非常有用,因为它不仅能告诉你错误发生在哪里,还能告诉你程序是如何在代码的那个地方结束的。这就引出了下一个问题。</target>
        </trans-unit>
        <trans-unit id="e2c723fd5136ff587ea2f2fd14ae158435d55ec6" translate="yes" xml:space="preserve">
          <source>Again, with this exception we'd want to look at line &lt;code&gt;22&lt;/code&gt; of &lt;code&gt;Book.java&lt;/code&gt; to see what might cause the &lt;code&gt;NullPointerException&lt;/code&gt; here.</source>
          <target state="translated">同样，除了这种例外情况，我们还要查看 &lt;code&gt;Book.java&lt;/code&gt; 的第 &lt;code&gt;22&lt;/code&gt; 行，以查看可能导致 &lt;code&gt;NullPointerException&lt;/code&gt; 的原因。</target>
        </trans-unit>
        <trans-unit id="0ded27539184c5108bce982dfb7dae5374889b46" translate="yes" xml:space="preserve">
          <source>An Exception is what the runtime environment uses to tell you that an error occurred. Popular examples are NullPointerException, IndexOutOfBoundsException or ArithmeticException. Each of these are caused when you try to do something that is not possible. For example, a NullPointerException will be thrown when you try to dereference a Null-object:</source>
          <target state="translated">异常是运行时环境用来告诉你发生了错误。常见的例子有NullPointerException、IndexOutOfBoundsException或ArithmeticException。每一个都是在你尝试做一些不可能的事情时引起的。例如,当你尝试对一个Null-object进行去解析时,会抛出NullPointerException。</target>
        </trans-unit>
        <trans-unit id="1446b54943846ed8ede7eecb7acb580739cf75ea" translate="yes" xml:space="preserve">
          <source>At first, find out what is causing the Exception. Try googleing the name of the exception to find out, what is the cause of that exception. Most of the time it will be caused by incorrect code. In the given examples above, all of the exceptions are caused by incorrect code. So for the NullPointerException example you could make sure that &lt;code&gt;a&lt;/code&gt; is never null at that time. You could, for example, initialise &lt;code&gt;a&lt;/code&gt; or include a check like this one:</source>
          <target state="translated">首先，找出导致异常的原因。 尝试在Google上搜索该异常的名称，以查明该异常的原因是什么。 大多数情况下，这是由错误的代码引起的。 在上面给出的示例中，所有异常都是由错误的代码引起的。 因此，对于NullPointerException示例，您可以确保此时 &lt;code&gt;a&lt;/code&gt; 永远不会为null。 例如，您可以初始化 &lt;code&gt;a&lt;/code&gt; 或包括这样的检查：</target>
        </trans-unit>
        <trans-unit id="fec354ceddcbe7ea20bb5ca5289ffec7bb364462" translate="yes" xml:space="preserve">
          <source>Book.java:16 was called by Auther.java:25 which was called by Bootstrap.java:14, Book.java:16 was the root cause.
Here attach a diagram sort the trace stack in chronological order.</source>
          <target state="translated">Book.java:16是被Bootstrap.java:14调用的Auther.java:25调用的,Book.java:16是根本原因。这里附上一张图,按时间顺序排序的跟踪栈。</target>
        </trans-unit>
        <trans-unit id="80bd8c5b2084abf7b62c1a6d5f7ab234ebfa537a" translate="yes" xml:space="preserve">
          <source>Figure out what is the cause of the exception and fix it, so that it doesn't throw the exception at all.</source>
          <target state="translated">弄清楚是什么原因造成的异常,并进行修复,这样就不会出现异常的情况。</target>
        </trans-unit>
        <trans-unit id="e438e6ab6e9a62b6589d45cb6ab68d42a04e71c6" translate="yes" xml:space="preserve">
          <source>First, ensure that you have all of your Java sources accessible in an Eclipse project.</source>
          <target state="translated">首先,确保你在Eclipse项目中拥有所有的Java源代码。</target>
        </trans-unit>
        <trans-unit id="564a794ca9340e5bd5c39ffc26dcfd0ab1ac2acd" translate="yes" xml:space="preserve">
          <source>However, all the method calls under that are library code. So we'll move up to the &quot;Caused by&quot; above it, and look for the first method call originating from our code, which is:</source>
          <target state="translated">但是,这下面的方法调用都是库代码。所以,我们将上移到它上面的 &quot;Caused by&quot;,寻找第一个源于我们的代码的方法调用,这就是。</target>
        </trans-unit>
        <trans-unit id="ea628175c8c7097d7fa1404e48c24d9e23055a01" translate="yes" xml:space="preserve">
          <source>I am posting this answer so the topmost answer (when sorted by activity) is not one that is just plain wrong.</source>
          <target state="translated">我把这个答案贴出来,所以最上面的答案(按活动排序时),并不是单纯的错题。</target>
        </trans-unit>
        <trans-unit id="5b77138d4162100bb0d1021e6370830c0d6aae0b" translate="yes" xml:space="preserve">
          <source>If 1. is not possible, catch the specific exception and handle it.</source>
          <target state="translated">如果1.不可能的话,抓住具体的异常情况进行处理。</target>
        </trans-unit>
        <trans-unit id="15d8614888c88baa8e0dd1a6f06bbc31587cc34c" translate="yes" xml:space="preserve">
          <source>If you are using open-source software, you might need to download and attach to your project the sources if you want to examine. Download the source jars, in your project, open the &lt;em&gt;Referenced Libraries&lt;/em&gt; folder to find your jar for your open-source module (the one with the class files) then right click, select &lt;em&gt;Properties&lt;/em&gt; and attach the source jar.</source>
          <target state="translated">如果使用的是开源软件，则可能需要下载源并将其附加到项目中。 下载源jar，在您的项目中，打开&lt;em&gt;Referenced Libraries&lt;/em&gt;文件夹以找到您的开源模块（带有类文件的jar），然后右键单击，选择&amp;ldquo; &lt;em&gt;属性&amp;rdquo;&lt;/em&gt;并附加源jar。</target>
        </trans-unit>
        <trans-unit id="487eb90890ff758ab851426d85fc6a7789a9eae0" translate="yes" xml:space="preserve">
          <source>If you get a stack trace and want to trace the cause of the exception, a good start point in understanding it is to use the &lt;em&gt;Java Stack Trace Console&lt;/em&gt; in &lt;strong&gt;Eclipse&lt;/strong&gt;. If you use another IDE there may be a similar feature, but this answer is about Eclipse.</source>
          <target state="translated">如果您获得了堆栈跟踪并希望跟踪异常原因，那么理解它的一个很好的起点就是使用&lt;strong&gt;Eclipse中&lt;/strong&gt;的&lt;em&gt;Java Stack Trace Console&lt;/em&gt; 。 如果您使用其他IDE，则可能会有类似的功能，但是此答案与Eclipse有关。</target>
        </trans-unit>
        <trans-unit id="613591bc550676714745432c75c4a608a01e1002" translate="yes" xml:space="preserve">
          <source>In our code we would want to evaluate that &lt;code&gt;firstName&lt;/code&gt; contains a value, we would do this like so: &lt;code&gt;if(firstName == null || firstName.equals(&quot;&quot;))  return;&lt;/code&gt;</source>
          <target state="translated">在我们的代码中，我们将希望评估 &lt;code&gt;firstName&lt;/code&gt; 包含一个值，我们将这样做： &lt;code&gt;if(firstName == null || firstName.equals(&quot;&quot;)) return;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09a8a4114baff1ef1a66283b7e865492f7e51289" translate="yes" xml:space="preserve">
          <source>In simple terms, a &lt;strong&gt;stack trace&lt;/strong&gt; is a list of the method calls that the application was in the middle of when an Exception was thrown.</source>
          <target state="translated">简而言之， &lt;strong&gt;堆栈跟踪&lt;/strong&gt;是应用程序在引发Exception时处于中间的方法调用的列表。</target>
        </trans-unit>
        <trans-unit id="14b0ec51c80a071a2bd3488f704f780ec376c702" translate="yes" xml:space="preserve">
          <source>In this example, there's a lot more. What we're mostly concerned about is looking for methods that are from &lt;em&gt;our code&lt;/em&gt;, which would be anything in the &lt;code&gt;com.example.myproject&lt;/code&gt; package. From the second example (above), we'd first want to look down for the root cause, which is:</source>
          <target state="translated">在这个例子中，还有更多。 我们最关心的是从&lt;em&gt;代码中&lt;/em&gt;寻找方法，这些方法可以是 &lt;code&gt;com.example.myproject&lt;/code&gt; 包中的任何方法。 在上面的第二个示例中，我们首先要查找根本原因，即：</target>
        </trans-unit>
        <trans-unit id="fd8f9a5ad29840838bb582c1d11aeb8597efa9b6" translate="yes" xml:space="preserve">
          <source>Just to add to the other examples, there are &lt;strong&gt;inner(nested) classes&lt;/strong&gt; that appear with the &lt;code&gt;$&lt;/code&gt; sign. For example:</source>
          <target state="translated">仅添加到其他示例中，就有带有 &lt;code&gt;$&lt;/code&gt; 符号出现的&lt;strong&gt;inner（nested）类&lt;/strong&gt; 。 例如：</target>
        </trans-unit>
        <trans-unit id="8ad5d1e6de22d3b3226789df2d8fbb5e80d49cf6" translate="yes" xml:space="preserve">
          <source>Let's use a small example to show why you should not just catch all exceptions:</source>
          <target state="translated">让我们用一个小例子来说明为什么不应该只抓住所有的异常情况。</target>
        </trans-unit>
        <trans-unit id="23fb093c264a0e642af1b47a80f767b268b0a3c0" translate="yes" xml:space="preserve">
          <source>Like in previous examples, we should look at &lt;code&gt;MyEntityService.java&lt;/code&gt; on line &lt;code&gt;59&lt;/code&gt;, because that's where this error originated (this one's a bit obvious what went wrong, since the SQLException states the error, but the debugging procedure is what we're after).</source>
          <target state="translated">像在前面的示例中一样，我们应该在第 &lt;code&gt;59&lt;/code&gt; 行上查看 &lt;code&gt;MyEntityService.java&lt;/code&gt; ，因为这是该错误的起源（这很明显出了问题，因为SQLException指出了该错误，但是调试过程就是我们要执行的操作） 。</target>
        </trans-unit>
        <trans-unit id="8fc9cf7ede540afe6a0e435663def251386adccc" translate="yes" xml:space="preserve">
          <source>Never just add a try/catch and then just ignore the exception! Don't do that!</source>
          <target state="translated">千万不要随便加一个trycatch,然后直接忽略异常! 千万不要这样做!</target>
        </trans-unit>
        <trans-unit id="39d9f60e1e2998c13e4e2032d71593c865205a1e" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;catch (Exception e)&lt;/code&gt;, always catch specific Exceptions. That will save you a lot of headaches.</source>
          <target state="translated">从不使用 &lt;code&gt;catch (Exception e)&lt;/code&gt; ，始终捕获特定的Exceptions。 这样可以省去很多麻烦。</target>
        </trans-unit>
        <trans-unit id="495ca3360ccb4106b9d0e5dce9e4592ebbcbe3e7" translate="yes" xml:space="preserve">
          <source>Paste your stack trace into the console. It will then provide a list of links into your source code and any other source code available.</source>
          <target state="translated">将你的栈跟踪粘贴到控制台中。然后它将提供一个链接到你的源代码和任何其他可用的源代码的列表。</target>
        </trans-unit>
        <trans-unit id="93298efff7ecf9f3994b22176c9239a238b08680" translate="yes" xml:space="preserve">
          <source>People have referred to this as a &quot;stack trace&quot;. &lt;strong&gt;What is a stack trace?&lt;/strong&gt; What can it tell me about the error that's happening in my program?</source>
          <target state="translated">人们将其称为&amp;ldquo;堆栈跟踪&amp;rdquo;。 &lt;strong&gt;什么是堆栈跟踪？&lt;/strong&gt; 关于程序中发生的错误，它能告诉我什么？</target>
        </trans-unit>
        <trans-unit id="2d6cea83d2fa9c56b7e4f83d9acb2e8a9b781054" translate="yes" xml:space="preserve">
          <source>Since Rob has used the &lt;code&gt;NullPointerException&lt;/code&gt; (NPE) to illustrate something common, we can help to remove this issue in the following manner:</source>
          <target state="translated">由于Rob使用 &lt;code&gt;NullPointerException&lt;/code&gt; （NPE）来说明一些常见问题，因此我们可以通过以下方式帮助解决此问题：</target>
        </trans-unit>
        <trans-unit id="c6e423de13a20e8485c4d2b1b23c4c523c61a38c" translate="yes" xml:space="preserve">
          <source>Sometimes applications will catch an Exception and re-throw it as the cause of another Exception.  This typically looks like:</source>
          <target state="translated">有时应用程序会捕捉到一个异常,并将其作为另一个异常的原因重新抛出。这通常看起来像这样。</target>
        </trans-unit>
        <trans-unit id="e466c8c050df7f99d7ed3eda1da2960c7c20347e" translate="yes" xml:space="preserve">
          <source>Sometimes when I run my application it gives me an error that looks like:</source>
          <target state="translated">有时,当我运行我的应用程序时,它会给我一个看起来像这样的错误。</target>
        </trans-unit>
        <trans-unit id="d22141c591cb9e0635bd1ecdf684ef89dcc76510" translate="yes" xml:space="preserve">
          <source>Sometimes you can't make sure that you don't get an exception. For example, if you are using a network connection in your program, you cannot stop the computer from loosing it's internet connection (e.g. you can't stop the user from disconnecting the computer's network connection). In this case the network library will probably throw an exception. Now you should catch the exception and &lt;strong&gt;handle&lt;/strong&gt; it. This means, in the example with the network connection, you should try to reopen the connection or notify the user or something like that. Also, whenever you use catch, always catch only the exception you want to catch, &lt;strong&gt;do not use broad catch statements like &lt;code&gt;catch (Exception e)&lt;/code&gt;&lt;/strong&gt; that would catch all exceptions. This is very important, because otherwise you might accidentally catch the wrong exception and react in the wrong way.</source>
          <target state="translated">有时，您无法确定自己没有例外。 例如，如果您在程序中使用网络连接，则无法阻止计算机失去其Internet连接（例如，您不能阻止用户断开计算机的网络连接）。 在这种情况下，网络库可能会引发异常。 现在，您应该捕获并&lt;strong&gt;处理&lt;/strong&gt;异常。 这意味着，在具有网络连接的示例中，您应尝试重新打开连接或通知用户或类似的信息。 另外，无论何时使用catch，都始终仅捕获要捕获的异常， &lt;strong&gt;请勿使用像 &lt;code&gt;catch (Exception e)&lt;/code&gt; &lt;/strong&gt;这样的&lt;strong&gt;广泛的catch语句&lt;/strong&gt;来捕获所有异常。 这非常重要，因为否则您可能会意外捕获错误的异常并以错误的方式做出反应。</target>
        </trans-unit>
        <trans-unit id="cb9cb776c20bea056423449369d53ef52a9c4259" translate="yes" xml:space="preserve">
          <source>Stack trace:</source>
          <target state="translated">堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="bf69b603dad9a6fc4eb1f9b4f8ea6caf897877da" translate="yes" xml:space="preserve">
          <source>The above is the proper order to check for nulls, we start with the base object, dog in this case, and then begin walking down the tree of possibilities to make sure everything is valid before processing.  If the order were reversed a NPE could potentially be thrown and our program would crash.</source>
          <target state="translated">以上是检查空值的正确顺序,我们从基本对象(本例中的狗)开始,然后开始沿着可能性树走下去,确保所有的东西都是有效的,然后再进行处理。如果这个订单被颠倒了一个NPE可能会被扔掉,我们的程序就会崩溃。</target>
        </trans-unit>
        <trans-unit id="5fb27293f5065e48d95aab824bc00124be221a18" translate="yes" xml:space="preserve">
          <source>The above prevents us from using &lt;code&gt;firstName&lt;/code&gt; as an unsafe parameter.  Therefore  by doing null checks before processing we can help to ensure that our code will run properly.  To expand on an example that utilizes an object with methods we can look here:</source>
          <target state="translated">以上内容阻止我们将 &lt;code&gt;firstName&lt;/code&gt; 用作不安全的参数。 因此，通过在处理之前进行空检查，我们可以帮助确保代码正常运行。 为了扩展一个使用对象和方法的示例，我们可以在这里看：</target>
        </trans-unit>
        <trans-unit id="7453ef913bb69c16a9f8a1f7b1324fb28f009efa" translate="yes" xml:space="preserve">
          <source>The most recent method call made will be the &lt;em&gt;top&lt;/em&gt; of the stack, which is the top line (excluding the message text). Going down the stack goes back in time. The second line is the method that calls the first line, etc.</source>
          <target state="translated">最近进行的方法调用将在堆栈的顶部，即最上面一行（不包括消息文本）。 往下走可以追溯到过去。 第二行是调用第一行的方法，依此类推。</target>
        </trans-unit>
        <trans-unit id="11fbf33c63bd03732692540005c072cdd3ed1096" translate="yes" xml:space="preserve">
          <source>The other posts describe what a stack trace is, but it can still be hard to work with.</source>
          <target state="translated">其他的帖子描述了什么是堆栈痕迹,但还是会让人很难受。</target>
        </trans-unit>
        <trans-unit id="c3ddf11fc25689b080b12527baea39641ae0db87" translate="yes" xml:space="preserve">
          <source>Then in the &lt;em&gt;Java&lt;/em&gt; perspective, click on the &lt;em&gt;Console&lt;/em&gt; tab (usually at the bottom). If the Console view is not visible, go to the menu option &lt;em&gt;Window -&amp;gt; Show View&lt;/em&gt; and select &lt;em&gt;Console&lt;/em&gt;.</source>
          <target state="translated">然后在&lt;em&gt;Java&lt;/em&gt;透视图中，单击&amp;ldquo; &lt;em&gt;控制台&amp;rdquo;&lt;/em&gt;选项卡（通常在底部）。 如果&amp;ldquo;控制台&amp;rdquo;视图不可见，请转到菜单选项&amp;ldquo; &lt;em&gt;窗口&amp;rdquo;-&amp;gt;&amp;ldquo;显示视图&amp;rdquo;，&lt;/em&gt;然后选择&amp;ldquo; &lt;em&gt;控制台&amp;rdquo;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="575a7a948c6a156a106d55a90241bd4749fad5ca" translate="yes" xml:space="preserve">
          <source>Then in the console window, click on the following button (on the right)</source>
          <target state="translated">然后在控制台窗口中,点击下面的按钮(右侧)。</target>
        </trans-unit>
        <trans-unit id="7b113dc376f62ec3b062c6c5782a7c23ce7ed13e" translate="yes" xml:space="preserve">
          <source>There is one more stacktrace feature offered by Throwable family - the possibility to &lt;strong&gt;manipulate&lt;/strong&gt; stack trace information.</source>
          <target state="translated">Throwable系列提供了另一个堆栈跟踪功能- &lt;strong&gt;操纵&lt;/strong&gt;堆栈跟踪信息的可能性。</target>
        </trans-unit>
        <trans-unit id="0839a810ec4da88cdf6083cb5086fe5cee3ee685" translate="yes" xml:space="preserve">
          <source>This is a very simple stack trace. If we start at the beginning of the list of &quot;at ...&quot;, we can tell where our error happened. What we're looking for is the &lt;strong&gt;topmost&lt;/strong&gt; method call that is part of our application. In this case, it's:</source>
          <target state="translated">这是一个非常简单的堆栈跟踪。 如果我们从&amp;ldquo; at ...&amp;rdquo;列表的开头开始，我们可以判断出错误发生在哪里。 我们正在寻找的是应用程序中&lt;strong&gt;最顶层的&lt;/strong&gt;方法调用。 在这种情况下，它是：</target>
        </trans-unit>
        <trans-unit id="5f628c41d41907e9337eb90dc7ec480a43bef487" translate="yes" xml:space="preserve">
          <source>This is what you might see (image from the Eclipse documentation):</source>
          <target state="translated">这就是你可能看到的(图片来自Eclipse文档)。</target>
        </trans-unit>
        <trans-unit id="78507f11dd782b6c1af51bf682954e32ebc76066" translate="yes" xml:space="preserve">
          <source>This might give you a stack trace that looks like:</source>
          <target state="translated">这可能会给你一个像这样的堆栈痕迹。</target>
        </trans-unit>
        <trans-unit id="4ec60d92e12153a63d117ff1ab794bc3e4143c4b" translate="yes" xml:space="preserve">
          <source>This way, the offending line is not executed if &lt;code&gt;a==null&lt;/code&gt;. Same goes for the other examples.</source>
          <target state="translated">这样，如果 &lt;code&gt;a==null&lt;/code&gt; 则不会执行违规行。 其他示例也是如此。</target>
        </trans-unit>
        <trans-unit id="86a413041e25913218b0abb28f5e2dc38fc95d9c" translate="yes" xml:space="preserve">
          <source>This would indicate that something (probably &lt;code&gt;title&lt;/code&gt;) is &lt;code&gt;null&lt;/code&gt; in the above code.</source>
          <target state="translated">这将表明上述代码中的某些内容（可能是 &lt;code&gt;title&lt;/code&gt; ）为 &lt;code&gt;null&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="b633c5cf2b51a5bd3a70b5d319f1c2ac9b9edcfd" translate="yes" xml:space="preserve">
          <source>To add on to what Rob has mentioned.  Setting break points in your application allows for the step-by-step processing of the stack.  This enables the developer to use the debugger to see at what exact point the method is doing something that was unanticipated.</source>
          <target state="translated">在Rob提到的基础上再补充一下。在你的应用程序中设置断点,可以对堆栈进行分步处理。这使得开发人员可以使用调试器来查看方法在哪个点上做了一些意料之外的事情。</target>
        </trans-unit>
        <trans-unit id="0f129ed2e3eafd696b404b089bdae450998145a1" translate="yes" xml:space="preserve">
          <source>To debug this, we can open up &lt;code&gt;Book.java&lt;/code&gt; and look at line &lt;code&gt;16&lt;/code&gt;, which is:</source>
          <target state="translated">为了调试它，我们可以打开 &lt;code&gt;Book.java&lt;/code&gt; 并查看第 &lt;code&gt;16&lt;/code&gt; 行，即：</target>
        </trans-unit>
        <trans-unit id="52b747244a3584dd256e5f32c7d956aa076a29e9" translate="yes" xml:space="preserve">
          <source>Usually stack traces are much more complex than the two examples above. Here's an example (it's a long one, but demonstrates several levels of chained exceptions):</source>
          <target state="translated">通常情况下,堆栈痕迹要比上面两个例子复杂得多。这里有一个例子(这个例子很长,但展示了几个层次的链式异常)。</target>
        </trans-unit>
        <trans-unit id="af1112769853e924619a8bd8e2ffe91ac135d2d0" translate="yes" xml:space="preserve">
          <source>What is a stack trace, and how can I use it to debug my application errors</source>
          <target state="translated">什么是栈跟踪,如何使用它来调试应用程序的错误?</target>
        </trans-unit>
        <trans-unit id="2b95441b3fc2100f60bfef05621335153b0f9dc6" translate="yes" xml:space="preserve">
          <source>What this code is trying to do is to catch the &lt;code&gt;ArithmeticException&lt;/code&gt; caused by a possible division by 0. But it also catches a possible &lt;code&gt;NullPointerException&lt;/code&gt; that is thrown if &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;null&lt;/code&gt;. This means, you might get a &lt;code&gt;NullPointerException&lt;/code&gt; but you'll treat it as an ArithmeticException and probably do the wrong thing. In the best case you still miss that there was a NullPointerException. Stuff like that makes debugging much harder, so don't do that.</source>
          <target state="translated">这段代码试图执行的操作是捕获由0除以可能引起的 &lt;code&gt;ArithmeticException&lt;/code&gt; 。但是，如果 &lt;code&gt;a&lt;/code&gt; 或 &lt;code&gt;b&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; ，则它还会捕获可能抛出的 &lt;code&gt;NullPointerException&lt;/code&gt; 。 这意味着，您可能会收到 &lt;code&gt;NullPointerException&lt;/code&gt; ,但会将其视为ArithmeticException并可能做错了事。 在最好的情况下，您仍然会错过NullPointerException。 这样的东西会使调试变得困难得多，所以不要这样做。</target>
        </trans-unit>
        <trans-unit id="8693b761def5d0171d4bb9ab2c4d0391af84116a" translate="yes" xml:space="preserve">
          <source>What's different about this one is the &quot;Caused by&quot;. Sometimes exceptions will have multiple &quot;Caused by&quot; sections. For these, you typically want to find the &quot;root cause&quot;, which will be one of the lowest &quot;Caused by&quot; sections in the stack trace. In our case, it's:</source>
          <target state="translated">这一条的不同之处在于 &quot;Causted by&quot;。有时异常会有多个 &quot;Caused by &quot;部分。对于这些,你通常要找到 &quot;根本原因&quot;,这将是栈跟踪中最低的 &quot;Caused by &quot;部分之一。在我们的例子中,它是。</target>
        </trans-unit>
        <trans-unit id="a7a6bd69868c0f78cdebeb816648bd67743a6f14" translate="yes" xml:space="preserve">
          <source>Will result in this stack trace:</source>
          <target state="translated">将导致这个堆栈跟踪。</target>
        </trans-unit>
        <trans-unit id="4b7552fe1f875853c01a7103f490b266ec4b133d" translate="yes" xml:space="preserve">
          <source>With the example given in the question, we can determine exactly where the exception was thrown in the application. Let's have a look at the stack trace:</source>
          <target state="translated">通过问题中给出的例子,我们可以准确判断出应用程序中的异常是在哪里抛出的。让我们来看看堆栈轨迹。</target>
        </trans-unit>
        <trans-unit id="173e07b2c48da36a70ece276f153fcc804be2dc1" translate="yes" xml:space="preserve">
          <source>and then select &lt;strong&gt;Java Stack Trace Console&lt;/strong&gt; from the drop-down list.</source>
          <target state="translated">然后从下拉列表中选择&lt;strong&gt;Java Stack Trace Console&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="182d561f07be6784421367d9d0c622c6249e6740" translate="yes" xml:space="preserve">
          <source>if we have a method that takes parameters such as:  &lt;code&gt;void (String firstName)&lt;/code&gt;</source>
          <target state="translated">如果我们有一个采用参数的方法，例如： &lt;code&gt;void (String firstName)&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
