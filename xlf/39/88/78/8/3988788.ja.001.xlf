<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/3988788">
    <body>
      <group id="3988788">
        <trans-unit id="9e17c4cb1696a52b482ad758b2ff26ed5d3b3913" translate="yes" xml:space="preserve">
          <source>-&amp;gt; &lt;strong&gt;Locate the root cause in the middle is your job.&lt;/strong&gt;</source>
          <target state="translated">-&amp;gt; &lt;strong&gt;真ん中の根本原因を突き止めるのはあなたの仕事です。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7efdc3da3f50066fd34771714e2a5d58bba23bab" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;About this question - quite often I see a question come through where a novice programmer is &quot;getting an error&quot;, and they simply paste their stack trace and some random block of code without understanding what the stack trace is or how they can use it. This question is intended as a reference for novice programmers who might need help understanding the value of a stack trace.&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;この質問について-初心者プログラマーが「エラーを取得している」という質問が頻繁に出てきます。スタックトレースとは何か、またはどのように使用できるかを理解せずに、スタックトレースとコードのランダムブロックを貼り付けるだけです。&lt;/em&gt; &lt;em&gt;この質問は、スタックトレースの値を理解するのに助けを必要とする可能性がある初心者プログラマのためのリファレンスとして意図されています。&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e30b6c9a4a40d436e4c73aca3e343c2bb6300046" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Example with a chain of exceptions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;一連の例外の例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1aa697efe4c7ad2e19dd36e95353a7dbaf884e2d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;How should I deal with Stacktraces/Exceptions?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;スタックトレース/例外をどのように処理する必要がありますか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c0c6819414fd35c2dd636ddb836570f5c6003f8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key 1&lt;/strong&gt;:A tricky and important thing here need to be understand is : the deepest cause may not be the &quot;root cause&quot;, because if you write some &quot;bad code&quot;, it may cause some exception underneath which is deeper than its layer. For example, a bad sql query may cause SQLServerException connection reset in the bottem instead of syndax error, which may just in the middle of the stack.</source>
          <target state="translated">&lt;strong&gt;キー1&lt;/strong&gt; ：ここで理解する必要があるトリッキーで重要なことは、次のとおりです。最も深い原因は「根本的な原因」ではない可能性があります。「不良コード」を記述すると、その層の下にある例外が発生する可能性があるためです。 たとえば、不正なSQLクエリにより、syndaxエラーの代わりにSQLServerException接続がボトルネックでリセットされる場合があり、これはスタックの真ん中にある場合があります。</target>
        </trans-unit>
        <trans-unit id="f9b27c0022bb53c8f1eda585728984a27b016e54" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Key 2&lt;/strong&gt;:Another tricky but important thing is inside each &quot;Cause by&quot; block, the first line was the deepest layer and happen first place for this block. For instance,</source>
          <target state="translated">&lt;strong&gt;キー2&lt;/strong&gt; ：別のトリッキーですが重要なことは、各「原因」ブロック内です。最初の行は最も深いレイヤーであり、このブロックの最初の場所で発生します。 例えば、</target>
        </trans-unit>
        <trans-unit id="a6f80e689cac9f3d1c38029e6dc4646b88000beb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Manipulated stack trace:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;操作されたスタックトレース：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="efae31b0f686ad094d22681d2e39cca7f4838076" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;More daunting example with library code&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ライブラリコードを使用したより困難な例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="30cc467eaf3b95a0739540a9156ebc43493b1920" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Simple Example&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;簡単な例&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f01621c5ba99bb45938e4719e48e833d01071218" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Standard behavior:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;標準的な動作：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0def28abff50b5453af5effe03f21c319e75a393" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;TLDR&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;TLDR&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54f43df9b5cad10843edbfcc5365f620a5f11c69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;To understand the name&lt;/strong&gt;: A stack trace is a a list of Exceptions( or you can say a list of &quot;Cause by&quot;), from the most surface Exception(e.g. Service Layer Exception) to the deepest one (e.g. Database Exception). Just like the reason we call it 'stack' is because stack is First in Last out (FILO), the deepest exception was happened in the very beginning, then a chain of exception was generated a series of consequences, the surface Exception was the last one happened in time, but we see it in the first place.</source>
          <target state="translated">&lt;strong&gt;名前を理解するには&lt;/strong&gt; ：スタックトレースは、最も表面的な例外（サービス層例外など）から最も深い例外（データベース例外など）までの例外のリスト（または「原因」のリストと言えます）です。 私たちが「スタック」と呼ぶ理由と同じように、スタックは先入れ先出し（FILO）であり、最も深い例外が最初に発生し、次に一連の例外が生成され、一連の結果が生成され、表面の例外が最後でした1つは時間内に発生しましたが、そもそもそれがわかります。</target>
        </trans-unit>
        <trans-unit id="8c7c8060530d12e9c50d077a6c2083b8ced2d726" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is a Stacktrace?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;スタックトレースとは何ですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5c07623d7483d1dbf34b9b1dfdb26de4239c6d4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What is an Exception?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;例外とは何ですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2a965cc63ff98aa09a9add3204ed8471c665810a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Why should I not use &lt;code&gt;catch (Exception e)&lt;/code&gt;?&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;なぜ &lt;code&gt;catch (Exception e)&lt;/code&gt; 使用すべきではないのですか？&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6226ce539868df18e25336c8aac8f012bdde715e" translate="yes" xml:space="preserve">
          <source>A stacktrace is a very helpful debugging tool. It shows the call stack (meaning, the stack of functions that were called up to that point) at the time an uncaught exception was thrown (or the time the stacktrace was generated manually). This is very useful because it doesn't only show you where the error happened, but also how the program ended up in that place of the code.
This leads over to the next question:</source>
          <target state="translated">スタックトレースは非常に便利なデバッグツールです。捕まえられなかった例外がスローされた時(またはスタックトレースが手動で生成された時)のコールスタック(つまり、その時点までに呼び出された関数のスタック)を表示します。これは、どこでエラーが発生したのかだけでなく、プログラムがどのようにしてコードのその場所で終わったのかを示してくれるので、非常に便利です。これが次の質問につながります。</target>
        </trans-unit>
        <trans-unit id="e2c723fd5136ff587ea2f2fd14ae158435d55ec6" translate="yes" xml:space="preserve">
          <source>Again, with this exception we'd want to look at line &lt;code&gt;22&lt;/code&gt; of &lt;code&gt;Book.java&lt;/code&gt; to see what might cause the &lt;code&gt;NullPointerException&lt;/code&gt; here.</source>
          <target state="translated">繰り返しになりますが、この例外を除いて、 &lt;code&gt;Book.java&lt;/code&gt; の &lt;code&gt;22&lt;/code&gt; 行目を見て、 &lt;code&gt;NullPointerException&lt;/code&gt; の原因を調べます。</target>
        </trans-unit>
        <trans-unit id="0ded27539184c5108bce982dfb7dae5374889b46" translate="yes" xml:space="preserve">
          <source>An Exception is what the runtime environment uses to tell you that an error occurred. Popular examples are NullPointerException, IndexOutOfBoundsException or ArithmeticException. Each of these are caused when you try to do something that is not possible. For example, a NullPointerException will be thrown when you try to dereference a Null-object:</source>
          <target state="translated">例外とは、ランタイム環境がエラーが発生したことを伝えるために使用するものです。よくある例としては、NullPointerException、IndexOutOfBoundsException、ArithmeticException などがあります。これらはいずれも、不可能なことをしようとしたときに発生します。たとえば、NullPointerException は、Null オブジェクトを参照しようとしたときにスローされます。</target>
        </trans-unit>
        <trans-unit id="1446b54943846ed8ede7eecb7acb580739cf75ea" translate="yes" xml:space="preserve">
          <source>At first, find out what is causing the Exception. Try googleing the name of the exception to find out, what is the cause of that exception. Most of the time it will be caused by incorrect code. In the given examples above, all of the exceptions are caused by incorrect code. So for the NullPointerException example you could make sure that &lt;code&gt;a&lt;/code&gt; is never null at that time. You could, for example, initialise &lt;code&gt;a&lt;/code&gt; or include a check like this one:</source>
          <target state="translated">最初に、例外の原因を調べます。 例外の名前をグーグルで調べて、その例外の原因を確認してください。 ほとんどの場合、不正なコードが原因です。 上記の例では、すべての例外は不正なコードが原因です。 したがって、NullPointerExceptionの例では、 &lt;code&gt;a&lt;/code&gt; が決してnullにならないようにすることができます。 たとえば、 &lt;code&gt;a&lt;/code&gt; を初期化するか、次のようなチェックを含めることができます。</target>
        </trans-unit>
        <trans-unit id="fec354ceddcbe7ea20bb5ca5289ffec7bb364462" translate="yes" xml:space="preserve">
          <source>Book.java:16 was called by Auther.java:25 which was called by Bootstrap.java:14, Book.java:16 was the root cause.
Here attach a diagram sort the trace stack in chronological order.</source>
          <target state="translated">Book.java:16がBootstrap.java:14で呼び出されたAuther.java:25で呼び出され、Book.java:16が根本原因でした。ここでは、トレーススタックを時系列に並べ替えた図を添付します。</target>
        </trans-unit>
        <trans-unit id="80bd8c5b2084abf7b62c1a6d5f7ab234ebfa537a" translate="yes" xml:space="preserve">
          <source>Figure out what is the cause of the exception and fix it, so that it doesn't throw the exception at all.</source>
          <target state="translated">例外が発生した原因を突き止めて修正し、例外が発生しないようにします。</target>
        </trans-unit>
        <trans-unit id="e438e6ab6e9a62b6589d45cb6ab68d42a04e71c6" translate="yes" xml:space="preserve">
          <source>First, ensure that you have all of your Java sources accessible in an Eclipse project.</source>
          <target state="translated">まず、EclipseプロジェクトですべてのJavaソースにアクセスできるようにします。</target>
        </trans-unit>
        <trans-unit id="564a794ca9340e5bd5c39ffc26dcfd0ab1ac2acd" translate="yes" xml:space="preserve">
          <source>However, all the method calls under that are library code. So we'll move up to the &quot;Caused by&quot; above it, and look for the first method call originating from our code, which is:</source>
          <target state="translated">しかし、その下のメソッド呼び出しはすべてライブラリコードです。そこで、その上の「Causeed by」に移動して、私たちのコードから発信されている最初のメソッド呼び出しを探してみましょう。</target>
        </trans-unit>
        <trans-unit id="ea628175c8c7097d7fa1404e48c24d9e23055a01" translate="yes" xml:space="preserve">
          <source>I am posting this answer so the topmost answer (when sorted by activity) is not one that is just plain wrong.</source>
          <target state="translated">私はこの回答を投稿しているので、一番上の回答(活動度でソートした場合)は、ただの間違った回答ではありません。</target>
        </trans-unit>
        <trans-unit id="5b77138d4162100bb0d1021e6370830c0d6aae0b" translate="yes" xml:space="preserve">
          <source>If 1. is not possible, catch the specific exception and handle it.</source>
          <target state="translated">1.ができない場合は、特定の例外をキャッチして処理する。</target>
        </trans-unit>
        <trans-unit id="15d8614888c88baa8e0dd1a6f06bbc31587cc34c" translate="yes" xml:space="preserve">
          <source>If you are using open-source software, you might need to download and attach to your project the sources if you want to examine. Download the source jars, in your project, open the &lt;em&gt;Referenced Libraries&lt;/em&gt; folder to find your jar for your open-source module (the one with the class files) then right click, select &lt;em&gt;Properties&lt;/em&gt; and attach the source jar.</source>
          <target state="translated">オープンソースソフトウェアを使用している場合、調べたい場合は、ソースをダウンロードしてプロジェクトに添付する必要があります。 ソースjarをダウンロードし、プロジェクトで&lt;em&gt;Referenced Libraries&lt;/em&gt;フォルダーを開いて、オープンソースモジュール（クラスファイルを含むモジュール）のjarを見つけ、右クリックして[ &lt;em&gt;プロパティ&lt;/em&gt; ]を選択し、ソースjarをアタッチし&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="487eb90890ff758ab851426d85fc6a7789a9eae0" translate="yes" xml:space="preserve">
          <source>If you get a stack trace and want to trace the cause of the exception, a good start point in understanding it is to use the &lt;em&gt;Java Stack Trace Console&lt;/em&gt; in &lt;strong&gt;Eclipse&lt;/strong&gt;. If you use another IDE there may be a similar feature, but this answer is about Eclipse.</source>
          <target state="translated">スタックトレースを取得して例外の原因をトレースしたい場合は、 &lt;strong&gt;Eclipseで&lt;/strong&gt; &lt;em&gt;Java Stack Trace Console&lt;/em&gt;を使用することを理解することから始めてください。 別のIDEを使用する場合、同様の機能があるかもしれませんが、この答えはEclipseに関するものです。</target>
        </trans-unit>
        <trans-unit id="613591bc550676714745432c75c4a608a01e1002" translate="yes" xml:space="preserve">
          <source>In our code we would want to evaluate that &lt;code&gt;firstName&lt;/code&gt; contains a value, we would do this like so: &lt;code&gt;if(firstName == null || firstName.equals(&quot;&quot;))  return;&lt;/code&gt;</source>
          <target state="translated">このコードでは、 &lt;code&gt;firstName&lt;/code&gt; に値が含まれていることを評価したいので、次の &lt;code&gt;if(firstName == null || firstName.equals(&quot;&quot;)) return;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="09a8a4114baff1ef1a66283b7e865492f7e51289" translate="yes" xml:space="preserve">
          <source>In simple terms, a &lt;strong&gt;stack trace&lt;/strong&gt; is a list of the method calls that the application was in the middle of when an Exception was thrown.</source>
          <target state="translated">簡単に言うと、 &lt;strong&gt;スタックトレース&lt;/strong&gt;は、例外がスローされたときにアプリケーションが途中だったメソッド呼び出しのリストです。</target>
        </trans-unit>
        <trans-unit id="14b0ec51c80a071a2bd3488f704f780ec376c702" translate="yes" xml:space="preserve">
          <source>In this example, there's a lot more. What we're mostly concerned about is looking for methods that are from &lt;em&gt;our code&lt;/em&gt;, which would be anything in the &lt;code&gt;com.example.myproject&lt;/code&gt; package. From the second example (above), we'd first want to look down for the root cause, which is:</source>
          <target state="translated">この例では、もっとたくさんあります。 私たちが最も心配しているのは&lt;em&gt;、コード&lt;/em&gt;からのメソッドを探すことです。これは、 &lt;code&gt;com.example.myproject&lt;/code&gt; パッケージ内のすべてのものになります。 2番目の例（上記）から、最初に根本原因を調べます。</target>
        </trans-unit>
        <trans-unit id="fd8f9a5ad29840838bb582c1d11aeb8597efa9b6" translate="yes" xml:space="preserve">
          <source>Just to add to the other examples, there are &lt;strong&gt;inner(nested) classes&lt;/strong&gt; that appear with the &lt;code&gt;$&lt;/code&gt; sign. For example:</source>
          <target state="translated">他の例に追加するために、 &lt;code&gt;$&lt;/code&gt; 記号で表示&lt;strong&gt;さ&lt;/strong&gt;れる&lt;strong&gt;内部（ネストされた）クラス&lt;/strong&gt;があります。 例えば：</target>
        </trans-unit>
        <trans-unit id="8ad5d1e6de22d3b3226789df2d8fbb5e80d49cf6" translate="yes" xml:space="preserve">
          <source>Let's use a small example to show why you should not just catch all exceptions:</source>
          <target state="translated">なぜすべての例外をキャッチするだけではいけないのか、小さな例を使って説明してみましょう。</target>
        </trans-unit>
        <trans-unit id="23fb093c264a0e642af1b47a80f767b268b0a3c0" translate="yes" xml:space="preserve">
          <source>Like in previous examples, we should look at &lt;code&gt;MyEntityService.java&lt;/code&gt; on line &lt;code&gt;59&lt;/code&gt;, because that's where this error originated (this one's a bit obvious what went wrong, since the SQLException states the error, but the debugging procedure is what we're after).</source>
          <target state="translated">前の例と同様に、 &lt;code&gt;59&lt;/code&gt; 行目の &lt;code&gt;MyEntityService.java&lt;/code&gt; を確認する必要があります。これは、このエラーが発生した場所です（SQLExceptionがエラーを示しているため、これはエラーの原因が少し明白ですが、デバッグ手順が後のエラーです）。 。</target>
        </trans-unit>
        <trans-unit id="8fc9cf7ede540afe6a0e435663def251386adccc" translate="yes" xml:space="preserve">
          <source>Never just add a try/catch and then just ignore the exception! Don't do that!</source>
          <target state="translated">絶対にトライキャッチを追加して例外を無視してはいけません! そんなことをしてはいけません!</target>
        </trans-unit>
        <trans-unit id="39d9f60e1e2998c13e4e2032d71593c865205a1e" translate="yes" xml:space="preserve">
          <source>Never use &lt;code&gt;catch (Exception e)&lt;/code&gt;, always catch specific Exceptions. That will save you a lot of headaches.</source>
          <target state="translated">&lt;code&gt;catch (Exception e)&lt;/code&gt; は使用せず、常に特定の例外をキャッチします。 それはあなたの頭痛の多くを救うでしょう。</target>
        </trans-unit>
        <trans-unit id="495ca3360ccb4106b9d0e5dce9e4592ebbcbe3e7" translate="yes" xml:space="preserve">
          <source>Paste your stack trace into the console. It will then provide a list of links into your source code and any other source code available.</source>
          <target state="translated">スタックトレースをコンソールに貼り付けます。そうすると、あなたのソースコードへのリンクのリストと、利用可能な他のソースコードが表示されます。</target>
        </trans-unit>
        <trans-unit id="93298efff7ecf9f3994b22176c9239a238b08680" translate="yes" xml:space="preserve">
          <source>People have referred to this as a &quot;stack trace&quot;. &lt;strong&gt;What is a stack trace?&lt;/strong&gt; What can it tell me about the error that's happening in my program?</source>
          <target state="translated">人々はこれを「スタックトレース」と呼んでいます。 &lt;strong&gt;スタックトレースとは何ですか？&lt;/strong&gt; プログラムで発生しているエラーについて何がわかりますか？</target>
        </trans-unit>
        <trans-unit id="2d6cea83d2fa9c56b7e4f83d9acb2e8a9b781054" translate="yes" xml:space="preserve">
          <source>Since Rob has used the &lt;code&gt;NullPointerException&lt;/code&gt; (NPE) to illustrate something common, we can help to remove this issue in the following manner:</source>
          <target state="translated">Robは一般的なものを説明するために &lt;code&gt;NullPointerException&lt;/code&gt; （NPE）を使用しているので、次の方法でこの問題を取り除くことができます。</target>
        </trans-unit>
        <trans-unit id="c6e423de13a20e8485c4d2b1b23c4c523c61a38c" translate="yes" xml:space="preserve">
          <source>Sometimes applications will catch an Exception and re-throw it as the cause of another Exception.  This typically looks like:</source>
          <target state="translated">アプリケーションが例外をキャッチして、それを別の例外の原因として再スローしてしまうことがあります。これは通常、次のようになります。</target>
        </trans-unit>
        <trans-unit id="e466c8c050df7f99d7ed3eda1da2960c7c20347e" translate="yes" xml:space="preserve">
          <source>Sometimes when I run my application it gives me an error that looks like:</source>
          <target state="translated">時々、アプリケーションを実行すると、次のようなエラーが出ます。</target>
        </trans-unit>
        <trans-unit id="d22141c591cb9e0635bd1ecdf684ef89dcc76510" translate="yes" xml:space="preserve">
          <source>Sometimes you can't make sure that you don't get an exception. For example, if you are using a network connection in your program, you cannot stop the computer from loosing it's internet connection (e.g. you can't stop the user from disconnecting the computer's network connection). In this case the network library will probably throw an exception. Now you should catch the exception and &lt;strong&gt;handle&lt;/strong&gt; it. This means, in the example with the network connection, you should try to reopen the connection or notify the user or something like that. Also, whenever you use catch, always catch only the exception you want to catch, &lt;strong&gt;do not use broad catch statements like &lt;code&gt;catch (Exception e)&lt;/code&gt;&lt;/strong&gt; that would catch all exceptions. This is very important, because otherwise you might accidentally catch the wrong exception and react in the wrong way.</source>
          <target state="translated">例外が発生しないことを確認できない場合があります。 たとえば、プログラムでネットワーク接続を使用している場合、コンピューターのインターネット接続が失われるのを防ぐことはできません（たとえば、ユーザーがコンピューターのネットワーク接続を切断するのを防ぐことはできません）。 この場合、ネットワークライブラリはおそらく例外をスローします。 ここで、例外をキャッチして&lt;strong&gt;処理&lt;/strong&gt;する必要があります。 つまり、ネットワーク接続の例では、接続を再度開くか、ユーザーまたはそのようなものに通知する必要があります。 また、catchを使用するときは常に、キャッチする例外のみをキャッチし、すべての例外をキャッチする&lt;strong&gt; &lt;code&gt;catch (Exception e)&lt;/code&gt; ような広範なcatchステートメントは使用しない&lt;/strong&gt;で&lt;strong&gt;ください&lt;/strong&gt; 。 これは非常に重要です。そうしないと、誤った例外を誤ってキャッチして、誤った方法で反応する可能性があります。</target>
        </trans-unit>
        <trans-unit id="cb9cb776c20bea056423449369d53ef52a9c4259" translate="yes" xml:space="preserve">
          <source>Stack trace:</source>
          <target state="translated">スタックトレース。</target>
        </trans-unit>
        <trans-unit id="bf69b603dad9a6fc4eb1f9b4f8ea6caf897877da" translate="yes" xml:space="preserve">
          <source>The above is the proper order to check for nulls, we start with the base object, dog in this case, and then begin walking down the tree of possibilities to make sure everything is valid before processing.  If the order were reversed a NPE could potentially be thrown and our program would crash.</source>
          <target state="translated">上記の順序は、ヌルをチェックするための適切な順序です。この順序を逆にすると、NPEが投げられる可能性があり、プログラムがクラッシュする可能性があります。</target>
        </trans-unit>
        <trans-unit id="5fb27293f5065e48d95aab824bc00124be221a18" translate="yes" xml:space="preserve">
          <source>The above prevents us from using &lt;code&gt;firstName&lt;/code&gt; as an unsafe parameter.  Therefore  by doing null checks before processing we can help to ensure that our code will run properly.  To expand on an example that utilizes an object with methods we can look here:</source>
          <target state="translated">上記は、 &lt;code&gt;firstName&lt;/code&gt; を安全でないパラメーターとして使用することを防ぎます。 したがって、処理前にnullチェックを行うことで、コードが適切に実行されることを確認できます。 メソッドを使用してオブジェクトを利用する例を展開するには、次のようにします。</target>
        </trans-unit>
        <trans-unit id="7453ef913bb69c16a9f8a1f7b1324fb28f009efa" translate="yes" xml:space="preserve">
          <source>The most recent method call made will be the &lt;em&gt;top&lt;/em&gt; of the stack, which is the top line (excluding the message text). Going down the stack goes back in time. The second line is the method that calls the first line, etc.</source>
          <target state="translated">最後に行われたメソッド呼び出しは、スタックの&lt;em&gt;一番上&lt;/em&gt;になります。これは一番上の行です（メッセージテキストを除く）。 スタックを下に行くと、時間に戻ります。 2行目は、1行目を呼び出すメソッドなどです。</target>
        </trans-unit>
        <trans-unit id="11fbf33c63bd03732692540005c072cdd3ed1096" translate="yes" xml:space="preserve">
          <source>The other posts describe what a stack trace is, but it can still be hard to work with.</source>
          <target state="translated">他の投稿ではスタックトレースとは何かを説明していますが、それでも作業が大変な場合があります。</target>
        </trans-unit>
        <trans-unit id="c3ddf11fc25689b080b12527baea39641ae0db87" translate="yes" xml:space="preserve">
          <source>Then in the &lt;em&gt;Java&lt;/em&gt; perspective, click on the &lt;em&gt;Console&lt;/em&gt; tab (usually at the bottom). If the Console view is not visible, go to the menu option &lt;em&gt;Window -&amp;gt; Show View&lt;/em&gt; and select &lt;em&gt;Console&lt;/em&gt;.</source>
          <target state="translated">次に、 &lt;em&gt;Java&lt;/em&gt;パースペクティブで、[ &lt;em&gt;コンソール&lt;/em&gt; ]タブ（通常は下部）をクリックします。 コンソールビューが表示されない場合は、メニューオプションの[ &lt;em&gt;ウィンドウ&lt;/em&gt; ] &lt;em&gt;-&amp;gt; [ビューの表示]に移動し&lt;/em&gt; 、[ &lt;em&gt;コンソール&lt;/em&gt; &lt;em&gt;]&lt;/em&gt;を選択します。</target>
        </trans-unit>
        <trans-unit id="575a7a948c6a156a106d55a90241bd4749fad5ca" translate="yes" xml:space="preserve">
          <source>Then in the console window, click on the following button (on the right)</source>
          <target state="translated">そして、コンソールウィンドウで、以下のボタン(右側)をクリックします。</target>
        </trans-unit>
        <trans-unit id="7b113dc376f62ec3b062c6c5782a7c23ce7ed13e" translate="yes" xml:space="preserve">
          <source>There is one more stacktrace feature offered by Throwable family - the possibility to &lt;strong&gt;manipulate&lt;/strong&gt; stack trace information.</source>
          <target state="translated">Throwableファミリーが提供&lt;strong&gt;する&lt;/strong&gt;スタックトレース機能がもう1つあります-スタックトレース情報を&lt;strong&gt;操作&lt;/strong&gt;する可能性。</target>
        </trans-unit>
        <trans-unit id="0839a810ec4da88cdf6083cb5086fe5cee3ee685" translate="yes" xml:space="preserve">
          <source>This is a very simple stack trace. If we start at the beginning of the list of &quot;at ...&quot;, we can tell where our error happened. What we're looking for is the &lt;strong&gt;topmost&lt;/strong&gt; method call that is part of our application. In this case, it's:</source>
          <target state="translated">これは非常に単純なスタックトレースです。 「...」のリストの先頭から開始すると、エラーが発生した場所がわかります。 探しているのは、アプリケーションの一部である&lt;strong&gt;最上位の&lt;/strong&gt;メソッド呼び出しです。 この場合、それは：</target>
        </trans-unit>
        <trans-unit id="5f628c41d41907e9337eb90dc7ec480a43bef487" translate="yes" xml:space="preserve">
          <source>This is what you might see (image from the Eclipse documentation):</source>
          <target state="translated">こんな感じになるかもしれません(画像はEclipseのドキュメントから)。</target>
        </trans-unit>
        <trans-unit id="78507f11dd782b6c1af51bf682954e32ebc76066" translate="yes" xml:space="preserve">
          <source>This might give you a stack trace that looks like:</source>
          <target state="translated">これでスタックトレースのようなものが得られるかもしれません。</target>
        </trans-unit>
        <trans-unit id="4ec60d92e12153a63d117ff1ab794bc3e4143c4b" translate="yes" xml:space="preserve">
          <source>This way, the offending line is not executed if &lt;code&gt;a==null&lt;/code&gt;. Same goes for the other examples.</source>
          <target state="translated">このように、 &lt;code&gt;a==null&lt;/code&gt; 場合、問題の行は実行されません。 他の例も同様です。</target>
        </trans-unit>
        <trans-unit id="86a413041e25913218b0abb28f5e2dc38fc95d9c" translate="yes" xml:space="preserve">
          <source>This would indicate that something (probably &lt;code&gt;title&lt;/code&gt;) is &lt;code&gt;null&lt;/code&gt; in the above code.</source>
          <target state="translated">これは、上記のコードで何か（おそらく &lt;code&gt;title&lt;/code&gt; ）が &lt;code&gt;null&lt;/code&gt; であることを示します。</target>
        </trans-unit>
        <trans-unit id="b633c5cf2b51a5bd3a70b5d319f1c2ac9b9edcfd" translate="yes" xml:space="preserve">
          <source>To add on to what Rob has mentioned.  Setting break points in your application allows for the step-by-step processing of the stack.  This enables the developer to use the debugger to see at what exact point the method is doing something that was unanticipated.</source>
          <target state="translated">Robが言及したことに付け加えると アプリケーションにブレークポイントを設定することで、スタックを段階的に処理することができます。これにより、開発者はデバッガを使用して、どの時点でメソッドが予期せぬことをしているのかを確認することができます。</target>
        </trans-unit>
        <trans-unit id="0f129ed2e3eafd696b404b089bdae450998145a1" translate="yes" xml:space="preserve">
          <source>To debug this, we can open up &lt;code&gt;Book.java&lt;/code&gt; and look at line &lt;code&gt;16&lt;/code&gt;, which is:</source>
          <target state="translated">これをデバッグするには、 &lt;code&gt;Book.java&lt;/code&gt; を開いて &lt;code&gt;16&lt;/code&gt; 行目を見てください。</target>
        </trans-unit>
        <trans-unit id="52b747244a3584dd256e5f32c7d956aa076a29e9" translate="yes" xml:space="preserve">
          <source>Usually stack traces are much more complex than the two examples above. Here's an example (it's a long one, but demonstrates several levels of chained exceptions):</source>
          <target state="translated">通常、スタックトレースは上の2つの例よりもはるかに複雑です。以下に例を示します(長いですが、いくつかのレベルの連鎖した例外を示しています)。</target>
        </trans-unit>
        <trans-unit id="af1112769853e924619a8bd8e2ffe91ac135d2d0" translate="yes" xml:space="preserve">
          <source>What is a stack trace, and how can I use it to debug my application errors</source>
          <target state="translated">スタックトレースとは何か、そしてアプリケーションのエラーをデバッグするためにどのように使うことができますか?</target>
        </trans-unit>
        <trans-unit id="2b95441b3fc2100f60bfef05621335153b0f9dc6" translate="yes" xml:space="preserve">
          <source>What this code is trying to do is to catch the &lt;code&gt;ArithmeticException&lt;/code&gt; caused by a possible division by 0. But it also catches a possible &lt;code&gt;NullPointerException&lt;/code&gt; that is thrown if &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; are &lt;code&gt;null&lt;/code&gt;. This means, you might get a &lt;code&gt;NullPointerException&lt;/code&gt; but you'll treat it as an ArithmeticException and probably do the wrong thing. In the best case you still miss that there was a NullPointerException. Stuff like that makes debugging much harder, so don't do that.</source>
          <target state="translated">このコードが実行しようとしていることは、0による除算の可能性によって引き起こされる &lt;code&gt;ArithmeticException&lt;/code&gt; をキャッチすることです。しかし、 &lt;code&gt;a&lt;/code&gt; または &lt;code&gt;b&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; の場合にスローされる可能性のある &lt;code&gt;NullPointerException&lt;/code&gt; もキャッチします 。 つまり、 &lt;code&gt;NullPointerException&lt;/code&gt; が発生する可能性がありますが、それをArithmeticExceptionとして扱い、おそらく間違った処理を行います。 最良のケースでは、NullPointerExceptionがあったことをまだ見逃しています。 そのようなものはデバッグを非常に難しくするので、それをしないでください。</target>
        </trans-unit>
        <trans-unit id="8693b761def5d0171d4bb9ab2c4d0391af84116a" translate="yes" xml:space="preserve">
          <source>What's different about this one is the &quot;Caused by&quot;. Sometimes exceptions will have multiple &quot;Caused by&quot; sections. For these, you typically want to find the &quot;root cause&quot;, which will be one of the lowest &quot;Caused by&quot; sections in the stack trace. In our case, it's:</source>
          <target state="translated">この中で違うのは、「Caused by」です。例外には複数の &quot;Caused by&quot; セクションがあることがあります。このような場合、通常はスタックトレースの中で最も低い &quot;Caused by&quot; セクションの一つである &quot;根本原因&quot; を見つけたいと思います。私たちの場合は、それが</target>
        </trans-unit>
        <trans-unit id="a7a6bd69868c0f78cdebeb816648bd67743a6f14" translate="yes" xml:space="preserve">
          <source>Will result in this stack trace:</source>
          <target state="translated">このスタックトレースになります。</target>
        </trans-unit>
        <trans-unit id="4b7552fe1f875853c01a7103f490b266ec4b133d" translate="yes" xml:space="preserve">
          <source>With the example given in the question, we can determine exactly where the exception was thrown in the application. Let's have a look at the stack trace:</source>
          <target state="translated">質問で与えられた例では、アプリケーションのどこで例外がスローされたかを正確に判断することができます。スタックトレースを見てみましょう。</target>
        </trans-unit>
        <trans-unit id="173e07b2c48da36a70ece276f153fcc804be2dc1" translate="yes" xml:space="preserve">
          <source>and then select &lt;strong&gt;Java Stack Trace Console&lt;/strong&gt; from the drop-down list.</source>
          <target state="translated">ドロップダウンリストから[ &lt;strong&gt;Java Stack Trace Console]を&lt;/strong&gt;選択します。</target>
        </trans-unit>
        <trans-unit id="182d561f07be6784421367d9d0c622c6249e6740" translate="yes" xml:space="preserve">
          <source>if we have a method that takes parameters such as:  &lt;code&gt;void (String firstName)&lt;/code&gt;</source>
          <target state="translated">次のようなパラメータを取るメソッドがある場合： &lt;code&gt;void (String firstName)&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
