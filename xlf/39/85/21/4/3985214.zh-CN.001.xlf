<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3985214">
    <body>
      <group id="3985214">
        <trans-unit id="d428b1875a05fa163eb5fd91f15c8fd34fdc902f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$redact&lt;/code&gt;&lt;em&gt;&quot;restricts the contents of the documents based on information stored in the documents themselves&quot;&lt;/em&gt;. So it will run only &lt;em&gt;inside of the document&lt;/em&gt;. It basically scans your document top to the bottom, and checks if it matches with your &lt;code&gt;if&lt;/code&gt; condition which is in &lt;code&gt;$cond&lt;/code&gt;, if there is match it will either keep the content(&lt;code&gt;$$DESCEND&lt;/code&gt;) or remove(&lt;code&gt;$$PRUNE&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;$redact&lt;/code&gt; &lt;em&gt;&amp;ldquo;根据存储在文档本身中的信息来限制文档的内容&amp;rdquo;&lt;/em&gt; 。 因此它将仅&lt;em&gt;在文档内部&lt;/em&gt;运行。 它基本上从上到下扫描您的文档，并检查它是否与 &lt;code&gt;$cond&lt;/code&gt; &lt;code&gt;if&lt;/code&gt; 条件匹配，如果匹配，则将保留内容（ &lt;code&gt;$$DESCEND&lt;/code&gt; ）或remove（ &lt;code&gt;$$PRUNE&lt;/code&gt; ）。</target>
        </trans-unit>
        <trans-unit id="ef99ea7a04b4c9b3e244dfeb3946adfceb2f6d00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$slice&lt;/code&gt; is helpful when you know the index of the element, but sometimes you want
whichever array element matched your criteria. You can return the matching element
with the &lt;code&gt;$&lt;/code&gt; operator.</source>
          <target state="translated">当您知道元素的索引时， &lt;code&gt;$slice&lt;/code&gt; 会很有帮助，但有时您希望任何符合条件的数组元素。 您可以使用 &lt;code&gt;$&lt;/code&gt; 运算符返回匹配的元素。</target>
        </trans-unit>
        <trans-unit id="79bc2ad7a703376e12e5c5c03cf3a0c069aaf862" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;OUTPUTS&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;OUTPUTS&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5b197e9aa89595d4b27f4692381efb8c101ab979" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution:&lt;/strong&gt; This answer provides a solution that was relevant &lt;em&gt;at that time&lt;/em&gt;, before the new features of MongoDB 2.2 and up were introduced. See the other answers if you are using a more recent version of MongoDB.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;在引入MongoDB 2.2及更高版本的新功能之前，此答案提供了当时相关的解决方案。 如果您使用的是MongoDB的最新版本，请参阅其他答案。</target>
        </trans-unit>
        <trans-unit id="8f0e825b58edfdcf9b64d4a991fc242fb7d10f5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MongoDB 3.2 Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MongoDB 3.2更新&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67d24ad9e4d9487e077b94d6348aa7c3dc4ff264" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;result:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;result:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6a46a51fb827f996af8598a376a31b72331d4db" translate="yes" xml:space="preserve">
          <source>Another interesing way is to use &lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/aggregation/redact/&quot;&gt;&lt;strong&gt;$redact&lt;/strong&gt;&lt;/a&gt;, which is one of the new aggregation features of &lt;strong&gt;MongoDB 2.6&lt;/strong&gt;. If you are using 2.6, you don't need an $unwind which might cause you performance problems if you have large arrays.</source>
          <target state="translated">另一种有趣的方式是使用&lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/aggregation/redact/&quot;&gt;&lt;strong&gt;$ redact&lt;/strong&gt;&lt;/a&gt; ，这是&lt;strong&gt;MongoDB 2.6&lt;/strong&gt;的新聚合功能之一。 如果您使用的是2.6，则不需要$ unwind，如果您有大阵列，则可能会导致性能问题。</target>
        </trans-unit>
        <trans-unit id="cd05150d858c1fdbba19d30c526a03a7db718397" translate="yes" xml:space="preserve">
          <source>Better you can query in matching array element using &lt;code&gt;$slice&lt;/code&gt; is it helpful to returning the significant object in an array.</source>
          <target state="translated">更好的是，您可以使用 &lt;code&gt;$slice&lt;/code&gt; 在匹配的数组元素中进行查询，这有助于返回数组中的有效对象。</target>
        </trans-unit>
        <trans-unit id="c007a566b746edfab934c80570ae620350040d75" translate="yes" xml:space="preserve">
          <source>Do query:</source>
          <target state="translated">做查询。</target>
        </trans-unit>
        <trans-unit id="cf0983c0a56e020e53f6da5088f2796645ae64fc" translate="yes" xml:space="preserve">
          <source>Here I just want to add some more complex usage.</source>
          <target state="translated">在这里,我只想再增加一些复杂的用法。</target>
        </trans-unit>
        <trans-unit id="4513ec74a04d72a529d8f21bdaced5b7ed31b0e9" translate="yes" xml:space="preserve">
          <source>How can I do this?</source>
          <target state="translated">如何才能做到这一点呢?</target>
        </trans-unit>
        <trans-unit id="c4ef81f23845407efe4fae673e7a631a0dfe1487" translate="yes" xml:space="preserve">
          <source>However, I'd like to get the document &lt;em&gt;(Document 1)&lt;/em&gt; only with the array that contains &lt;code&gt;color=red&lt;/code&gt;:</source>
          <target state="translated">但是，我只想使用包含 &lt;code&gt;color=red&lt;/code&gt; 的数组来获取文档&lt;em&gt;（文档1）&lt;/em&gt; ：</target>
        </trans-unit>
        <trans-unit id="e785cd00d89bb9ac86d456051a0ca74d9a1075e8" translate="yes" xml:space="preserve">
          <source>If you really &lt;em&gt;need&lt;/em&gt; the correct output directly from MongoDB, you can &lt;strong&gt;use a map-reduce&lt;/strong&gt; to filter the shapes.</source>
          <target state="translated">如果确实&lt;em&gt;需要&lt;/em&gt;直接从MongoDB输出正确的输出，则可以&lt;strong&gt;使用map-reduce&lt;/strong&gt;过滤形状。</target>
        </trans-unit>
        <trans-unit id="5d647fdb0cc21d467ad38022165467af31e807c5" translate="yes" xml:space="preserve">
          <source>In 2.2 you can also do this using the &lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/projection/positional/#proj._S_&quot;&gt;&lt;code&gt;$ projection operator&lt;/code&gt;&lt;/a&gt;, where the &lt;code&gt;$&lt;/code&gt; in a projection object field name represents the index of the field's first matching array element from the query.  The following returns the same results as above:</source>
          <target state="translated">在2.2中，您也可以使用&lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/projection/positional/#proj._S_&quot;&gt; &lt;code&gt;$ projection operator&lt;/code&gt; &lt;/a&gt;执行此操作 ，其中投影对象字段名称中的 &lt;code&gt;$&lt;/code&gt; 表示查询中该字段的第一个匹配数组元素的索引。 以下返回与上面相同的结果：</target>
        </trans-unit>
        <trans-unit id="25fb47033fed1e6f3bf21a6138edf6169b4106a6" translate="yes" xml:space="preserve">
          <source>In the example  above, first &lt;code&gt;$match&lt;/code&gt; returns the whole &lt;code&gt;shapes&lt;/code&gt; array, and $redact strips it down to the expected result.</source>
          <target state="translated">在上面的示例中，第一个 &lt;code&gt;$match&lt;/code&gt; 返回整个 &lt;code&gt;shapes&lt;/code&gt; 数组，然后$ redact将其剥离为预期结果。</target>
        </trans-unit>
        <trans-unit id="454f720bcd6ecd06330a312d145b2ab81c70ff3b" translate="yes" xml:space="preserve">
          <source>Likewise you can find for the multiple</source>
          <target state="translated">同样的,你也可以发现,对于多个</target>
        </trans-unit>
        <trans-unit id="b682bd767e48dba648b59d621a8e56e62f25b1c9" translate="yes" xml:space="preserve">
          <source>MongoDB 2.2's new &lt;a href=&quot;http://docs.mongodb.org/manual/reference/projection/elemMatch/&quot;&gt;&lt;code&gt;$elemMatch&lt;/code&gt;&lt;/a&gt; projection operator provides another way to alter the returned document to contain only the &lt;strong&gt;&lt;em&gt;first&lt;/em&gt;&lt;/strong&gt; matched &lt;code&gt;shapes&lt;/code&gt; element:</source>
          <target state="translated">MongoDB 2.2的新的&lt;a href=&quot;http://docs.mongodb.org/manual/reference/projection/elemMatch/&quot;&gt; &lt;code&gt;$elemMatch&lt;/code&gt; &lt;/a&gt;投影运算符提供了另一种方法来更改返回的文档，使其仅包含第&lt;strong&gt;&lt;em&gt;一个&lt;/em&gt;&lt;/strong&gt;匹配的 &lt;code&gt;shapes&lt;/code&gt; 元素：</target>
        </trans-unit>
        <trans-unit id="01f8801ae4d70eaa223d826b7ff0de3487d53ff5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;{$not:&quot;$color&quot;}&lt;/code&gt; is necessary, because it will scan the top document as well, and if &lt;code&gt;$redact&lt;/code&gt; does not find a &lt;code&gt;color&lt;/code&gt; field on the top level this will return &lt;code&gt;false&lt;/code&gt; that might strip the whole document which we don't want.</source>
          <target state="translated">请注意， &lt;code&gt;{$not:&quot;$color&quot;}&lt;/code&gt; 是必需的，因为它也会扫描顶层文档，并且如果 &lt;code&gt;$redact&lt;/code&gt; 在顶层没有找到 &lt;code&gt;color&lt;/code&gt; 字段，则将返回 &lt;code&gt;false&lt;/code&gt; ，这可能会剥离整个文档。不想要</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">结果是:</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="a6660f0c1d08dfce4b9177a7dbe3c877f3df8b8a" translate="yes" xml:space="preserve">
          <source>Retrieve only the queried element in an object array in MongoDB collection</source>
          <target state="translated">只检索MongoDB集合中的对象数组中的被查询元素。</target>
        </trans-unit>
        <trans-unit id="6b6a6b5bb61615362807d8d367bd7a8961f65043" translate="yes" xml:space="preserve">
          <source>Returns matched document &lt;em&gt;(Document 1)&lt;/em&gt;, but always with ALL array items in &lt;code&gt;shapes&lt;/code&gt;:</source>
          <target state="translated">返回匹配的文档&lt;em&gt;（文档1）&lt;/em&gt; ，但始终具有 &lt;code&gt;shapes&lt;/code&gt; 所有数组项：</target>
        </trans-unit>
        <trans-unit id="7749fcf802c472b6c2f5bd0556805e456ffd5674" translate="yes" xml:space="preserve">
          <source>Returns:</source>
          <target state="translated">Returns:</target>
        </trans-unit>
        <trans-unit id="94f5098c680abcd334b6931384be6781712c5125" translate="yes" xml:space="preserve">
          <source>Starting with the 3.2 release, you can use the new &lt;a href=&quot;https://docs.mongodb.org/master/reference/operator/aggregation/filter/#exp._S_filter&quot;&gt;&lt;code&gt;$filter&lt;/code&gt;&lt;/a&gt; aggregation operator to filter an array during projection, which has the benefit of including &lt;em&gt;all&lt;/em&gt; matches, instead of just the first one.</source>
          <target state="translated">从3.2版本开始，您可以使用新的&lt;a href=&quot;https://docs.mongodb.org/master/reference/operator/aggregation/filter/#exp._S_filter&quot;&gt; &lt;code&gt;$filter&lt;/code&gt; &lt;/a&gt;聚合运算符在投影过程中对数组进行过滤，其优点是包括&lt;em&gt;所有&lt;/em&gt;匹配项，而不仅仅是第一个匹配项。</target>
        </trans-unit>
        <trans-unit id="f5de345702bf7dc23d97be784f2e06df597b599e" translate="yes" xml:space="preserve">
          <source>Suppose you have the following documents in my collection:</source>
          <target state="translated">假设你在我的收藏里有以下文件:</target>
        </trans-unit>
        <trans-unit id="a61221aa5842fd7ce755e27accc559cb81bf6bf8" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/users/1259510/johnnyhk&quot;&gt;JohnnyHK&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">感谢&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/users/1259510/johnnyhk&quot;&gt;JohnnyHK&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="280ea20517945f059f3b0177b6d2791f40bd28dc" translate="yes" xml:space="preserve">
          <source>The easiest way is to just filter the shapes &lt;strong&gt;in the client&lt;/strong&gt;.</source>
          <target state="translated">最简单的方法是只过滤&lt;strong&gt;客户端中&lt;/strong&gt;的形状。</target>
        </trans-unit>
        <trans-unit id="011fcf568a7bf05cbc1d7df1771c112c22fa94b5" translate="yes" xml:space="preserve">
          <source>The field selector parameter is limited to complete properties. It cannot be used to select part of an array, only the entire array. I tried using the &lt;a href=&quot;http://www.mongodb.org/display/DOCS/Updating#Updating-The%24positionaloperator&quot;&gt;$ positional operator&lt;/a&gt;, but that didn't work.</source>
          <target state="translated">字段选择器参数仅限于完整属性。 它不能用于选择数组的一部分，只能选择整个数组。 我尝试使用&lt;a href=&quot;http://www.mongodb.org/display/DOCS/Updating#Updating-The%24positionaloperator&quot;&gt;$位置运算符&lt;/a&gt; ，但这没有用。</target>
        </trans-unit>
        <trans-unit id="5e57247870975708f3ad2a737501e04e8fa972bf" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;http://docs.mongodb.org/manual/applications/aggregation/&quot;&gt;Aggregation Framework&lt;/a&gt; in MongoDB 2.2+ provides an alternative to Map/Reduce.  The &lt;a href=&quot;http://docs.mongodb.org/manual/reference/aggregation/unwind/#_S_unwind&quot;&gt;&lt;code&gt;$unwind&lt;/code&gt;&lt;/a&gt; operator can be used to separate your &lt;code&gt;shapes&lt;/code&gt; array into a stream of documents that can be matched:</source>
          <target state="translated">MongoDB 2.2+中的新&lt;a href=&quot;http://docs.mongodb.org/manual/applications/aggregation/&quot;&gt;聚合框架&lt;/a&gt;提供了Map / Reduce的替代方法。 &lt;a href=&quot;http://docs.mongodb.org/manual/reference/aggregation/unwind/#_S_unwind&quot;&gt; &lt;code&gt;$unwind&lt;/code&gt; &lt;/a&gt;运算符可用于将您的 &lt;code&gt;shapes&lt;/code&gt; 数组分成可匹配的文档流：</target>
        </trans-unit>
        <trans-unit id="95b6f6200fe7942742a465176596cfd30b75c0a6" translate="yes" xml:space="preserve">
          <source>The syntax for find in mongodb is</source>
          <target state="translated">mongodb中查找的语法是</target>
        </trans-unit>
        <trans-unit id="a1db02d1876d875583532ee81fca79299840967e" translate="yes" xml:space="preserve">
          <source>This will give you the desired result.</source>
          <target state="translated">这样一来,就能达到理想的效果。</target>
        </trans-unit>
        <trans-unit id="166e86579d61879ce28269fc52125f329ec27dfe" translate="yes" xml:space="preserve">
          <source>Use aggregation function and &lt;code&gt;$project&lt;/code&gt; to get specific object field in document</source>
          <target state="translated">使用聚合函数和 &lt;code&gt;$project&lt;/code&gt; 获取文档中的特定对象字段</target>
        </trans-unit>
        <trans-unit id="9d61ae427838db230f311e356f832edddef5e1d1" translate="yes" xml:space="preserve">
          <source>You just need to run query</source>
          <target state="translated">你只需要运行查询</target>
        </trans-unit>
        <trans-unit id="0d47be58043b2f646bebb224b280fa7ec4cea37b" translate="yes" xml:space="preserve">
          <source>along with  $project it will be more appropriate  other wise matching elements will be clubbed together with other elements in document.</source>
          <target state="translated">随着$项目,它将更适合其他匹配的元素将与文件中的其他元素结合在一起。</target>
        </trans-unit>
        <trans-unit id="3e7966e60b8ead06f449a4c0808abd6e506e6252" translate="yes" xml:space="preserve">
          <source>and the second query that you have written, that is</source>
          <target state="translated">和你写的第二个疑问,那就是</target>
        </trans-unit>
        <trans-unit id="a9dd7c50d60471080ef847b20d425a7f8398a421" translate="yes" xml:space="preserve">
          <source>as you expected it'll gives the exact field from array that matches color:'red'.</source>
          <target state="translated">如你所料,它将从数组中给出与color:''red'相匹配的字段。</target>
        </trans-unit>
        <trans-unit id="37d90936ec1c52acd7cf334d0d540ecb29f70a0b" translate="yes" xml:space="preserve">
          <source>in this you have used the &lt;code&gt;$elemMatch&lt;/code&gt; operator in query part, whereas if you use this operator in the projection part then you will get the desired result. You can write down your query as</source>
          <target state="translated">在这种情况下，您在查询部分中使用了 &lt;code&gt;$elemMatch&lt;/code&gt; 运算符，而如果在投影部分中使用了此运算符，则将获得所需的结果。 您可以将查询记为</target>
        </trans-unit>
        <trans-unit id="0bf0abdf8924e8c2dbae4fbd00100472ff3a3c7b" translate="yes" xml:space="preserve">
          <source>output of this query is</source>
          <target state="translated">这个查询的输出是</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
