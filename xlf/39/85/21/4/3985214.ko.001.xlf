<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3985214">
    <body>
      <group id="3985214">
        <trans-unit id="d428b1875a05fa163eb5fd91f15c8fd34fdc902f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$redact&lt;/code&gt;&lt;em&gt;&quot;restricts the contents of the documents based on information stored in the documents themselves&quot;&lt;/em&gt;. So it will run only &lt;em&gt;inside of the document&lt;/em&gt;. It basically scans your document top to the bottom, and checks if it matches with your &lt;code&gt;if&lt;/code&gt; condition which is in &lt;code&gt;$cond&lt;/code&gt;, if there is match it will either keep the content(&lt;code&gt;$$DESCEND&lt;/code&gt;) or remove(&lt;code&gt;$$PRUNE&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;$redact&lt;/code&gt; &lt;em&gt;&quot;문서 자체에 저장된 정보를 기반으로 문서의 내용을 제한합니다&quot;&lt;/em&gt; . 따라서 &lt;em&gt;문서 내부&lt;/em&gt; 에서만 실행됩니다. 기본적으로 문서를 맨 아래까지 스캔하고 &lt;code&gt;$cond&lt;/code&gt; 있는 &lt;code&gt;if&lt;/code&gt; 조건과 일치하는지 확인합니다. 일치하는 경우 내용 ( &lt;code&gt;$$DESCEND&lt;/code&gt; ) 또는 remove ( &lt;code&gt;$$PRUNE&lt;/code&gt; )를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="ef99ea7a04b4c9b3e244dfeb3946adfceb2f6d00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$slice&lt;/code&gt; is helpful when you know the index of the element, but sometimes you want
whichever array element matched your criteria. You can return the matching element
with the &lt;code&gt;$&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;$slice&lt;/code&gt; 는 요소의 인덱스를 알고 있지만 때로는 어떤 기준 요소와 일치하는 배열 요소를 원할 때 유용합니다. &lt;code&gt;$&lt;/code&gt; 연산자를 사용하여 일치하는 요소를 반환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79bc2ad7a703376e12e5c5c03cf3a0c069aaf862" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;OUTPUTS&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;OUTPUTS&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5b197e9aa89595d4b27f4692381efb8c101ab979" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution:&lt;/strong&gt; This answer provides a solution that was relevant &lt;em&gt;at that time&lt;/em&gt;, before the new features of MongoDB 2.2 and up were introduced. See the other answers if you are using a more recent version of MongoDB.</source>
          <target state="translated">&lt;strong&gt;주의 :&lt;/strong&gt; 이 답변은 MongoDB 2.2 이상의 새로운 기능이 도입되기 전에 &lt;em&gt;당시&lt;/em&gt; 관련 솔루션을 제공합니다. 최신 버전의 MongoDB를 사용하는 경우 다른 답변을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8f0e825b58edfdcf9b64d4a991fc242fb7d10f5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MongoDB 3.2 Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MongoDB 3.2 업데이트&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67d24ad9e4d9487e077b94d6348aa7c3dc4ff264" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;result:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;result:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6a46a51fb827f996af8598a376a31b72331d4db" translate="yes" xml:space="preserve">
          <source>Another interesing way is to use &lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/aggregation/redact/&quot;&gt;&lt;strong&gt;$redact&lt;/strong&gt;&lt;/a&gt;, which is one of the new aggregation features of &lt;strong&gt;MongoDB 2.6&lt;/strong&gt;. If you are using 2.6, you don't need an $unwind which might cause you performance problems if you have large arrays.</source>
          <target state="translated">또 다른 중요한 방법은 &lt;strong&gt;MongoDB 2.6&lt;/strong&gt; 의 새로운 집계 기능 중 하나 인 &lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/aggregation/redact/&quot;&gt;&lt;strong&gt;$ redact&lt;/strong&gt;&lt;/a&gt; 를 사용하는 것입니다. 2.6을 사용하는 경우 큰 배열이있는 경우 성능 문제를 일으킬 수있는 $ unwind가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cd05150d858c1fdbba19d30c526a03a7db718397" translate="yes" xml:space="preserve">
          <source>Better you can query in matching array element using &lt;code&gt;$slice&lt;/code&gt; is it helpful to returning the significant object in an array.</source>
          <target state="translated">&lt;code&gt;$slice&lt;/code&gt; 사용하여 배열 요소를 일치시키는 쿼리를하는 것이 더 좋습니다. 배열에서 중요한 객체를 반환하는 것이 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c007a566b746edfab934c80570ae620350040d75" translate="yes" xml:space="preserve">
          <source>Do query:</source>
          <target state="translated">쿼리를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="cf0983c0a56e020e53f6da5088f2796645ae64fc" translate="yes" xml:space="preserve">
          <source>Here I just want to add some more complex usage.</source>
          <target state="translated">여기에 좀 더 복잡한 사용법을 추가하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="4513ec74a04d72a529d8f21bdaced5b7ed31b0e9" translate="yes" xml:space="preserve">
          <source>How can I do this?</source>
          <target state="translated">어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="c4ef81f23845407efe4fae673e7a631a0dfe1487" translate="yes" xml:space="preserve">
          <source>However, I'd like to get the document &lt;em&gt;(Document 1)&lt;/em&gt; only with the array that contains &lt;code&gt;color=red&lt;/code&gt;:</source>
          <target state="translated">그러나 &lt;code&gt;color=red&lt;/code&gt; 가 포함 된 배열로만 문서 &lt;em&gt;(문서 1)&lt;/em&gt; 를 얻고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="e785cd00d89bb9ac86d456051a0ca74d9a1075e8" translate="yes" xml:space="preserve">
          <source>If you really &lt;em&gt;need&lt;/em&gt; the correct output directly from MongoDB, you can &lt;strong&gt;use a map-reduce&lt;/strong&gt; to filter the shapes.</source>
          <target state="translated">실제로 MongoDB에서 직접 올바른 출력이 &lt;em&gt;필요한&lt;/em&gt; 경우 &lt;strong&gt;map-reduce&lt;/strong&gt; 를 &lt;strong&gt;사용&lt;/strong&gt; 하여 모양을 필터링 할 수 &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5d647fdb0cc21d467ad38022165467af31e807c5" translate="yes" xml:space="preserve">
          <source>In 2.2 you can also do this using the &lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/projection/positional/#proj._S_&quot;&gt;&lt;code&gt;$ projection operator&lt;/code&gt;&lt;/a&gt;, where the &lt;code&gt;$&lt;/code&gt; in a projection object field name represents the index of the field's first matching array element from the query.  The following returns the same results as above:</source>
          <target state="translated">2.2에서는 &lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/projection/positional/#proj._S_&quot;&gt; &lt;code&gt;$ projection operator&lt;/code&gt; &lt;/a&gt; 사용하여이 작업을 수행 할 수도 있습니다. 여기서 투영 객체 필드 이름의 &lt;code&gt;$&lt;/code&gt; 는 쿼리에서 필드의 첫 번째 일치하는 배열 요소의 인덱스를 나타냅니다. 다음은 위와 동일한 결과를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="25fb47033fed1e6f3bf21a6138edf6169b4106a6" translate="yes" xml:space="preserve">
          <source>In the example  above, first &lt;code&gt;$match&lt;/code&gt; returns the whole &lt;code&gt;shapes&lt;/code&gt; array, and $redact strips it down to the expected result.</source>
          <target state="translated">위의 예에서 첫 번째 &lt;code&gt;$match&lt;/code&gt; 는 전체 &lt;code&gt;shapes&lt;/code&gt; 배열을 반환하고 $ redact는이를 예상 결과로 줄입니다.</target>
        </trans-unit>
        <trans-unit id="454f720bcd6ecd06330a312d145b2ab81c70ff3b" translate="yes" xml:space="preserve">
          <source>Likewise you can find for the multiple</source>
          <target state="translated">마찬가지로 당신은 여러에 대한 찾을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="b682bd767e48dba648b59d621a8e56e62f25b1c9" translate="yes" xml:space="preserve">
          <source>MongoDB 2.2's new &lt;a href=&quot;http://docs.mongodb.org/manual/reference/projection/elemMatch/&quot;&gt;&lt;code&gt;$elemMatch&lt;/code&gt;&lt;/a&gt; projection operator provides another way to alter the returned document to contain only the &lt;strong&gt;&lt;em&gt;first&lt;/em&gt;&lt;/strong&gt; matched &lt;code&gt;shapes&lt;/code&gt; element:</source>
          <target state="translated">MongoDB 2.2의 새로운 &lt;a href=&quot;http://docs.mongodb.org/manual/reference/projection/elemMatch/&quot;&gt; &lt;code&gt;$elemMatch&lt;/code&gt; &lt;/a&gt; 프로젝션 연산자는 &lt;strong&gt;&lt;em&gt;첫 번째로&lt;/em&gt;&lt;/strong&gt; 일치하는 &lt;code&gt;shapes&lt;/code&gt; 요소 만 포함하도록 반환 된 문서를 변경하는 다른 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="01f8801ae4d70eaa223d826b7ff0de3487d53ff5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;{$not:&quot;$color&quot;}&lt;/code&gt; is necessary, because it will scan the top document as well, and if &lt;code&gt;$redact&lt;/code&gt; does not find a &lt;code&gt;color&lt;/code&gt; field on the top level this will return &lt;code&gt;false&lt;/code&gt; that might strip the whole document which we don't want.</source>
          <target state="translated">&lt;code&gt;{$not:&quot;$color&quot;}&lt;/code&gt; 는 최상위 문서도 스캔하기 때문에 필요하며 &lt;code&gt;$redact&lt;/code&gt; 가 최상위 레벨에서 &lt;code&gt;color&lt;/code&gt; 필드를 찾지 못하면 &lt;code&gt;false&lt;/code&gt; 를 반환하여 전체 문서를 제거 할 수 있습니다. 원하지 않아요</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">결과 :</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="a6660f0c1d08dfce4b9177a7dbe3c877f3df8b8a" translate="yes" xml:space="preserve">
          <source>Retrieve only the queried element in an object array in MongoDB collection</source>
          <target state="translated">MongoDB 컬렉션의 객체 배열에서 쿼리 된 요소 만 검색</target>
        </trans-unit>
        <trans-unit id="6b6a6b5bb61615362807d8d367bd7a8961f65043" translate="yes" xml:space="preserve">
          <source>Returns matched document &lt;em&gt;(Document 1)&lt;/em&gt;, but always with ALL array items in &lt;code&gt;shapes&lt;/code&gt;:</source>
          <target state="translated">일치하는 문서 &lt;em&gt;(문서 1)를&lt;/em&gt; 반환하지만 항상 &lt;code&gt;shapes&lt;/code&gt; 모든 배열 항목을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7749fcf802c472b6c2f5bd0556805e456ffd5674" translate="yes" xml:space="preserve">
          <source>Returns:</source>
          <target state="translated">Returns:</target>
        </trans-unit>
        <trans-unit id="94f5098c680abcd334b6931384be6781712c5125" translate="yes" xml:space="preserve">
          <source>Starting with the 3.2 release, you can use the new &lt;a href=&quot;https://docs.mongodb.org/master/reference/operator/aggregation/filter/#exp._S_filter&quot;&gt;&lt;code&gt;$filter&lt;/code&gt;&lt;/a&gt; aggregation operator to filter an array during projection, which has the benefit of including &lt;em&gt;all&lt;/em&gt; matches, instead of just the first one.</source>
          <target state="translated">3.2 릴리스부터는 새로운 &lt;a href=&quot;https://docs.mongodb.org/master/reference/operator/aggregation/filter/#exp._S_filter&quot;&gt; &lt;code&gt;$filter&lt;/code&gt; &lt;/a&gt; 집계 연산자를 사용하여 프로젝션 중에 배열을 필터링 할 수 있습니다. 첫 번째 배열 대신 &lt;em&gt;모든&lt;/em&gt; 일치 항목을 포함시키는 이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5de345702bf7dc23d97be784f2e06df597b599e" translate="yes" xml:space="preserve">
          <source>Suppose you have the following documents in my collection:</source>
          <target state="translated">내 컬렉션에 다음과 같은 문서가 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="a61221aa5842fd7ce755e27accc559cb81bf6bf8" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/users/1259510/johnnyhk&quot;&gt;JohnnyHK&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/users/1259510/johnnyhk&quot;&gt;JohnnyHK&lt;/a&gt;&lt;/em&gt; 에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="280ea20517945f059f3b0177b6d2791f40bd28dc" translate="yes" xml:space="preserve">
          <source>The easiest way is to just filter the shapes &lt;strong&gt;in the client&lt;/strong&gt;.</source>
          <target state="translated">가장 쉬운 방법은 &lt;strong&gt;클라이언트&lt;/strong&gt; 에서 도형 &lt;strong&gt;을&lt;/strong&gt; 필터링하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="011fcf568a7bf05cbc1d7df1771c112c22fa94b5" translate="yes" xml:space="preserve">
          <source>The field selector parameter is limited to complete properties. It cannot be used to select part of an array, only the entire array. I tried using the &lt;a href=&quot;http://www.mongodb.org/display/DOCS/Updating#Updating-The%24positionaloperator&quot;&gt;$ positional operator&lt;/a&gt;, but that didn't work.</source>
          <target state="translated">필드 선택기 매개 변수는 완전한 특성으로 제한됩니다. 배열의 일부를 선택하는 데 사용할 수 없으며 전체 배열 만 선택할 수 있습니다. &lt;a href=&quot;http://www.mongodb.org/display/DOCS/Updating#Updating-The%24positionaloperator&quot;&gt;$ positional operator&lt;/a&gt; 사용하려고 시도했지만 작동하지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="5e57247870975708f3ad2a737501e04e8fa972bf" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;http://docs.mongodb.org/manual/applications/aggregation/&quot;&gt;Aggregation Framework&lt;/a&gt; in MongoDB 2.2+ provides an alternative to Map/Reduce.  The &lt;a href=&quot;http://docs.mongodb.org/manual/reference/aggregation/unwind/#_S_unwind&quot;&gt;&lt;code&gt;$unwind&lt;/code&gt;&lt;/a&gt; operator can be used to separate your &lt;code&gt;shapes&lt;/code&gt; array into a stream of documents that can be matched:</source>
          <target state="translated">MongoDB 2.2+의 새로운 &lt;a href=&quot;http://docs.mongodb.org/manual/applications/aggregation/&quot;&gt;Aggregation Framework&lt;/a&gt; 는 Map / Reduce의 대안을 제공합니다. &lt;a href=&quot;http://docs.mongodb.org/manual/reference/aggregation/unwind/#_S_unwind&quot;&gt; &lt;code&gt;$unwind&lt;/code&gt; &lt;/a&gt; 연산자를 사용하여 &lt;code&gt;shapes&lt;/code&gt; 배열을 일치시킬 수있는 문서 스트림으로 분리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="95b6f6200fe7942742a465176596cfd30b75c0a6" translate="yes" xml:space="preserve">
          <source>The syntax for find in mongodb is</source>
          <target state="translated">mongodb에서 find의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a1db02d1876d875583532ee81fca79299840967e" translate="yes" xml:space="preserve">
          <source>This will give you the desired result.</source>
          <target state="translated">원하는 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="166e86579d61879ce28269fc52125f329ec27dfe" translate="yes" xml:space="preserve">
          <source>Use aggregation function and &lt;code&gt;$project&lt;/code&gt; to get specific object field in document</source>
          <target state="translated">집계 함수와 &lt;code&gt;$project&lt;/code&gt; 를 사용하여 문서의 특정 객체 필드를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9d61ae427838db230f311e356f832edddef5e1d1" translate="yes" xml:space="preserve">
          <source>You just need to run query</source>
          <target state="translated">당신은 단지 쿼리를 실행해야합니다</target>
        </trans-unit>
        <trans-unit id="0d47be58043b2f646bebb224b280fa7ec4cea37b" translate="yes" xml:space="preserve">
          <source>along with  $project it will be more appropriate  other wise matching elements will be clubbed together with other elements in document.</source>
          <target state="translated">$ project와 함께 다른 현명한 일치 요소가 문서의 다른 요소와 함께 클럽 화되는 것이 더 적합합니다.</target>
        </trans-unit>
        <trans-unit id="3e7966e60b8ead06f449a4c0808abd6e506e6252" translate="yes" xml:space="preserve">
          <source>and the second query that you have written, that is</source>
          <target state="translated">그리고 두 번째로 작성한 쿼리는</target>
        </trans-unit>
        <trans-unit id="a9dd7c50d60471080ef847b20d425a7f8398a421" translate="yes" xml:space="preserve">
          <source>as you expected it'll gives the exact field from array that matches color:'red'.</source>
          <target state="translated">예상대로 배열에서 색상 : '빨간색'과 일치하는 정확한 필드를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="37d90936ec1c52acd7cf334d0d540ecb29f70a0b" translate="yes" xml:space="preserve">
          <source>in this you have used the &lt;code&gt;$elemMatch&lt;/code&gt; operator in query part, whereas if you use this operator in the projection part then you will get the desired result. You can write down your query as</source>
          <target state="translated">여기에서는 쿼리 부분에서 &lt;code&gt;$elemMatch&lt;/code&gt; 연산자를 사용했지만 투영 부분에서이 연산자를 사용하면 원하는 결과를 얻을 수 있습니다. 검색어를 다음과 같이 작성할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0bf0abdf8924e8c2dbae4fbd00100472ff3a3c7b" translate="yes" xml:space="preserve">
          <source>output of this query is</source>
          <target state="translated">이 쿼리의 출력은</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
