<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/3985214">
    <body>
      <group id="3985214">
        <trans-unit id="d428b1875a05fa163eb5fd91f15c8fd34fdc902f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$redact&lt;/code&gt;&lt;em&gt;&quot;restricts the contents of the documents based on information stored in the documents themselves&quot;&lt;/em&gt;. So it will run only &lt;em&gt;inside of the document&lt;/em&gt;. It basically scans your document top to the bottom, and checks if it matches with your &lt;code&gt;if&lt;/code&gt; condition which is in &lt;code&gt;$cond&lt;/code&gt;, if there is match it will either keep the content(&lt;code&gt;$$DESCEND&lt;/code&gt;) or remove(&lt;code&gt;$$PRUNE&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;$redact&lt;/code&gt; &lt;em&gt;&quot;ドキュメント自体に格納されている情報に基づいてドキュメントの内容を制限します&quot;&lt;/em&gt; 。 したがって&lt;em&gt;、ドキュメントの内部で&lt;/em&gt;のみ実行さ&lt;em&gt;れます&lt;/em&gt; 。 基本的にドキュメントを上から下にスキャンし、 &lt;code&gt;$cond&lt;/code&gt; ある &lt;code&gt;if&lt;/code&gt; 条件と一致するかどうかを確認します。一致がある場合は、コンテンツを保持する（ &lt;code&gt;$$DESCEND&lt;/code&gt; ）または削除する（ &lt;code&gt;$$PRUNE&lt;/code&gt; ）かのいずれかです。</target>
        </trans-unit>
        <trans-unit id="ef99ea7a04b4c9b3e244dfeb3946adfceb2f6d00" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;$slice&lt;/code&gt; is helpful when you know the index of the element, but sometimes you want
whichever array element matched your criteria. You can return the matching element
with the &lt;code&gt;$&lt;/code&gt; operator.</source>
          <target state="translated">&lt;code&gt;$slice&lt;/code&gt; は、要素のインデックスがわかっている場合に役立ちますが、条件に一致する配列要素が必要になる場合があります。 &lt;code&gt;$&lt;/code&gt; 演算子を使用して、一致する要素を返すことができます。</target>
        </trans-unit>
        <trans-unit id="79bc2ad7a703376e12e5c5c03cf3a0c069aaf862" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;OUTPUTS&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;OUTPUTS&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5b197e9aa89595d4b27f4692381efb8c101ab979" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Caution:&lt;/strong&gt; This answer provides a solution that was relevant &lt;em&gt;at that time&lt;/em&gt;, before the new features of MongoDB 2.2 and up were introduced. See the other answers if you are using a more recent version of MongoDB.</source>
          <target state="translated">&lt;strong&gt;注意：&lt;/strong&gt;この回答は、MongoDB 2.2以降の新機能が導入される前の、 &lt;em&gt;当時&lt;/em&gt;関連&lt;em&gt;してい&lt;/em&gt;たソリューションを提供します。 より新しいバージョンのMongoDBを使用している場合は、他の回答を参照してください。</target>
        </trans-unit>
        <trans-unit id="8f0e825b58edfdcf9b64d4a991fc242fb7d10f5a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;MongoDB 3.2 Update&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;MongoDB 3.2アップデート&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67d24ad9e4d9487e077b94d6348aa7c3dc4ff264" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;result:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;result:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6a46a51fb827f996af8598a376a31b72331d4db" translate="yes" xml:space="preserve">
          <source>Another interesing way is to use &lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/aggregation/redact/&quot;&gt;&lt;strong&gt;$redact&lt;/strong&gt;&lt;/a&gt;, which is one of the new aggregation features of &lt;strong&gt;MongoDB 2.6&lt;/strong&gt;. If you are using 2.6, you don't need an $unwind which might cause you performance problems if you have large arrays.</source>
          <target state="translated">別の興味深い方法は、 &lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/aggregation/redact/&quot;&gt;&lt;strong&gt;$ redact&lt;/strong&gt;&lt;/a&gt;を使用すること&lt;strong&gt;です&lt;/strong&gt; 。これは、 &lt;strong&gt;MongoDB 2.6の&lt;/strong&gt;新しい集約機能の1つです。 2.6を使用している場合は、大きな配列がある場合にパフォーマンスの問題を引き起こす可能性がある$ unwindは必要ありません。</target>
        </trans-unit>
        <trans-unit id="cd05150d858c1fdbba19d30c526a03a7db718397" translate="yes" xml:space="preserve">
          <source>Better you can query in matching array element using &lt;code&gt;$slice&lt;/code&gt; is it helpful to returning the significant object in an array.</source>
          <target state="translated">&lt;code&gt;$slice&lt;/code&gt; を使用して一致する配列要素でクエリを実行できる方が、配列で重要なオブジェクトを返すのに役立ちます。</target>
        </trans-unit>
        <trans-unit id="c007a566b746edfab934c80570ae620350040d75" translate="yes" xml:space="preserve">
          <source>Do query:</source>
          <target state="translated">クエリをしてください。</target>
        </trans-unit>
        <trans-unit id="cf0983c0a56e020e53f6da5088f2796645ae64fc" translate="yes" xml:space="preserve">
          <source>Here I just want to add some more complex usage.</source>
          <target state="translated">ここでは、もう少し複雑な使い方を追加したいと思います。</target>
        </trans-unit>
        <trans-unit id="4513ec74a04d72a529d8f21bdaced5b7ed31b0e9" translate="yes" xml:space="preserve">
          <source>How can I do this?</source>
          <target state="translated">どうすればいいのでしょうか?</target>
        </trans-unit>
        <trans-unit id="c4ef81f23845407efe4fae673e7a631a0dfe1487" translate="yes" xml:space="preserve">
          <source>However, I'd like to get the document &lt;em&gt;(Document 1)&lt;/em&gt; only with the array that contains &lt;code&gt;color=red&lt;/code&gt;:</source>
          <target state="translated">ただし、 &lt;code&gt;color=red&lt;/code&gt; を含む配列のみを使用してドキュメント&lt;em&gt;（ドキュメント1）&lt;/em&gt;を取得したいと思います。</target>
        </trans-unit>
        <trans-unit id="e785cd00d89bb9ac86d456051a0ca74d9a1075e8" translate="yes" xml:space="preserve">
          <source>If you really &lt;em&gt;need&lt;/em&gt; the correct output directly from MongoDB, you can &lt;strong&gt;use a map-reduce&lt;/strong&gt; to filter the shapes.</source>
          <target state="translated">MongoDBから直接正しい出力が本当に&lt;em&gt;必要な&lt;/em&gt;場合&lt;strong&gt;は、map-reduce&lt;/strong&gt;を使用して形状をフィルタリングできます。</target>
        </trans-unit>
        <trans-unit id="5d647fdb0cc21d467ad38022165467af31e807c5" translate="yes" xml:space="preserve">
          <source>In 2.2 you can also do this using the &lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/projection/positional/#proj._S_&quot;&gt;&lt;code&gt;$ projection operator&lt;/code&gt;&lt;/a&gt;, where the &lt;code&gt;$&lt;/code&gt; in a projection object field name represents the index of the field's first matching array element from the query.  The following returns the same results as above:</source>
          <target state="translated">2.2では、 &lt;a href=&quot;http://docs.mongodb.org/manual/reference/operator/projection/positional/#proj._S_&quot;&gt; &lt;code&gt;$ projection operator&lt;/code&gt; &lt;/a&gt;を使用してこれを行うこともできます。プロジェクションオブジェクトフィールド名の &lt;code&gt;$&lt;/code&gt; は、クエリからのフィールドの最初に一致する配列要素のインデックスを表します。 以下は、上記と同じ結果を返します。</target>
        </trans-unit>
        <trans-unit id="25fb47033fed1e6f3bf21a6138edf6169b4106a6" translate="yes" xml:space="preserve">
          <source>In the example  above, first &lt;code&gt;$match&lt;/code&gt; returns the whole &lt;code&gt;shapes&lt;/code&gt; array, and $redact strips it down to the expected result.</source>
          <target state="translated">上記の例では、最初の &lt;code&gt;$match&lt;/code&gt; は &lt;code&gt;shapes&lt;/code&gt; 配列全体を返し、$ redactはそれを期待される結果まで削除します。</target>
        </trans-unit>
        <trans-unit id="454f720bcd6ecd06330a312d145b2ab81c70ff3b" translate="yes" xml:space="preserve">
          <source>Likewise you can find for the multiple</source>
          <target state="translated">同様に、複数の</target>
        </trans-unit>
        <trans-unit id="b682bd767e48dba648b59d621a8e56e62f25b1c9" translate="yes" xml:space="preserve">
          <source>MongoDB 2.2's new &lt;a href=&quot;http://docs.mongodb.org/manual/reference/projection/elemMatch/&quot;&gt;&lt;code&gt;$elemMatch&lt;/code&gt;&lt;/a&gt; projection operator provides another way to alter the returned document to contain only the &lt;strong&gt;&lt;em&gt;first&lt;/em&gt;&lt;/strong&gt; matched &lt;code&gt;shapes&lt;/code&gt; element:</source>
          <target state="translated">MongoDB 2.2の新しい&lt;a href=&quot;http://docs.mongodb.org/manual/reference/projection/elemMatch/&quot;&gt; &lt;code&gt;$elemMatch&lt;/code&gt; &lt;/a&gt;投影演算子は、 &lt;strong&gt;&lt;em&gt;最初に&lt;/em&gt;&lt;/strong&gt;一致した &lt;code&gt;shapes&lt;/code&gt; 要素のみを含むように返されたドキュメントを変更する別の方法を提供します。</target>
        </trans-unit>
        <trans-unit id="01f8801ae4d70eaa223d826b7ff0de3487d53ff5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;{$not:&quot;$color&quot;}&lt;/code&gt; is necessary, because it will scan the top document as well, and if &lt;code&gt;$redact&lt;/code&gt; does not find a &lt;code&gt;color&lt;/code&gt; field on the top level this will return &lt;code&gt;false&lt;/code&gt; that might strip the whole document which we don't want.</source>
          <target state="translated">&lt;code&gt;{$not:&quot;$color&quot;}&lt;/code&gt; も必要です。これは、最上位のドキュメントもスキャンするためです。 &lt;code&gt;$redact&lt;/code&gt; が最上位の &lt;code&gt;color&lt;/code&gt; フィールドを見つけられない場合は、 &lt;code&gt;false&lt;/code&gt; が返され、ドキュメント全体が削除される可能性があります。したくない。</target>
        </trans-unit>
        <trans-unit id="e72184f55cc026514b7160d78c3c5aef63c2a050" translate="yes" xml:space="preserve">
          <source>Or</source>
          <target state="translated">Or</target>
        </trans-unit>
        <trans-unit id="02d55b2baf2725bcbe0634735b4de01c005aa3e5" translate="yes" xml:space="preserve">
          <source>Results in:</source>
          <target state="translated">結果が出ています。</target>
        </trans-unit>
        <trans-unit id="fd19e6d6cb4b26b0ef86cb95d8b5872a311f4828" translate="yes" xml:space="preserve">
          <source>Results:</source>
          <target state="translated">Results:</target>
        </trans-unit>
        <trans-unit id="a6660f0c1d08dfce4b9177a7dbe3c877f3df8b8a" translate="yes" xml:space="preserve">
          <source>Retrieve only the queried element in an object array in MongoDB collection</source>
          <target state="translated">MongoDBコレクションのオブジェクト配列の中から、クエリの対象となる要素だけを取得する</target>
        </trans-unit>
        <trans-unit id="6b6a6b5bb61615362807d8d367bd7a8961f65043" translate="yes" xml:space="preserve">
          <source>Returns matched document &lt;em&gt;(Document 1)&lt;/em&gt;, but always with ALL array items in &lt;code&gt;shapes&lt;/code&gt;:</source>
          <target state="translated">一致したドキュメント&lt;em&gt;（ドキュメント1）を&lt;/em&gt;返しますが、常に &lt;code&gt;shapes&lt;/code&gt; すべての配列項目を使用します 。</target>
        </trans-unit>
        <trans-unit id="7749fcf802c472b6c2f5bd0556805e456ffd5674" translate="yes" xml:space="preserve">
          <source>Returns:</source>
          <target state="translated">Returns:</target>
        </trans-unit>
        <trans-unit id="94f5098c680abcd334b6931384be6781712c5125" translate="yes" xml:space="preserve">
          <source>Starting with the 3.2 release, you can use the new &lt;a href=&quot;https://docs.mongodb.org/master/reference/operator/aggregation/filter/#exp._S_filter&quot;&gt;&lt;code&gt;$filter&lt;/code&gt;&lt;/a&gt; aggregation operator to filter an array during projection, which has the benefit of including &lt;em&gt;all&lt;/em&gt; matches, instead of just the first one.</source>
          <target state="translated">3.2リリース以降では、新しい&lt;a href=&quot;https://docs.mongodb.org/master/reference/operator/aggregation/filter/#exp._S_filter&quot;&gt; &lt;code&gt;$filter&lt;/code&gt; &lt;/a&gt;集計演算子を使用して、射影中に配列をフィルター処理できます。これには、最初のものだけでなく、 &lt;em&gt;すべての&lt;/em&gt;一致を含めるという利点があります。</target>
        </trans-unit>
        <trans-unit id="f5de345702bf7dc23d97be784f2e06df597b599e" translate="yes" xml:space="preserve">
          <source>Suppose you have the following documents in my collection:</source>
          <target state="translated">私のコレクションの中に以下のような書類があるとします。</target>
        </trans-unit>
        <trans-unit id="a61221aa5842fd7ce755e27accc559cb81bf6bf8" translate="yes" xml:space="preserve">
          <source>Thanks to &lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/users/1259510/johnnyhk&quot;&gt;JohnnyHK&lt;/a&gt;&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;&lt;a href=&quot;https://stackoverflow.com/users/1259510/johnnyhk&quot;&gt;JohnnyHKに&lt;/a&gt;&lt;/em&gt;感謝し&lt;em&gt;ます&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="280ea20517945f059f3b0177b6d2791f40bd28dc" translate="yes" xml:space="preserve">
          <source>The easiest way is to just filter the shapes &lt;strong&gt;in the client&lt;/strong&gt;.</source>
          <target state="translated">最も簡単な方法は&lt;strong&gt;、クライアントの&lt;/strong&gt;形状&lt;strong&gt;を&lt;/strong&gt;フィルターするだけ&lt;strong&gt;です&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="011fcf568a7bf05cbc1d7df1771c112c22fa94b5" translate="yes" xml:space="preserve">
          <source>The field selector parameter is limited to complete properties. It cannot be used to select part of an array, only the entire array. I tried using the &lt;a href=&quot;http://www.mongodb.org/display/DOCS/Updating#Updating-The%24positionaloperator&quot;&gt;$ positional operator&lt;/a&gt;, but that didn't work.</source>
          <target state="translated">フィールドセレクタパラメータは、完全なプロパティに制限されています。 配列全体だけを選択して、配列の一部を選択することはできません。 &lt;a href=&quot;http://www.mongodb.org/display/DOCS/Updating#Updating-The%24positionaloperator&quot;&gt;$位置演算子&lt;/a&gt;を使ってみましたが、うまくいきませんでした。</target>
        </trans-unit>
        <trans-unit id="5e57247870975708f3ad2a737501e04e8fa972bf" translate="yes" xml:space="preserve">
          <source>The new &lt;a href=&quot;http://docs.mongodb.org/manual/applications/aggregation/&quot;&gt;Aggregation Framework&lt;/a&gt; in MongoDB 2.2+ provides an alternative to Map/Reduce.  The &lt;a href=&quot;http://docs.mongodb.org/manual/reference/aggregation/unwind/#_S_unwind&quot;&gt;&lt;code&gt;$unwind&lt;/code&gt;&lt;/a&gt; operator can be used to separate your &lt;code&gt;shapes&lt;/code&gt; array into a stream of documents that can be matched:</source>
          <target state="translated">MongoDB 2.2以降の新しい&lt;a href=&quot;http://docs.mongodb.org/manual/applications/aggregation/&quot;&gt;集約フレームワーク&lt;/a&gt;は、Map / Reduceの代替手段を提供します。 &lt;a href=&quot;http://docs.mongodb.org/manual/reference/aggregation/unwind/#_S_unwind&quot;&gt; &lt;code&gt;$unwind&lt;/code&gt; &lt;/a&gt;演算子を使用して、 &lt;code&gt;shapes&lt;/code&gt; 配列を、照合可能なドキュメントのストリームに分離できます。</target>
        </trans-unit>
        <trans-unit id="95b6f6200fe7942742a465176596cfd30b75c0a6" translate="yes" xml:space="preserve">
          <source>The syntax for find in mongodb is</source>
          <target state="translated">mongodbでのfindの構文は以下の通りです。</target>
        </trans-unit>
        <trans-unit id="a1db02d1876d875583532ee81fca79299840967e" translate="yes" xml:space="preserve">
          <source>This will give you the desired result.</source>
          <target state="translated">これで希望の結果が得られます。</target>
        </trans-unit>
        <trans-unit id="166e86579d61879ce28269fc52125f329ec27dfe" translate="yes" xml:space="preserve">
          <source>Use aggregation function and &lt;code&gt;$project&lt;/code&gt; to get specific object field in document</source>
          <target state="translated">集計関数と &lt;code&gt;$project&lt;/code&gt; を使用してドキュメント内の特定のオブジェクトフィールドを取得する</target>
        </trans-unit>
        <trans-unit id="9d61ae427838db230f311e356f832edddef5e1d1" translate="yes" xml:space="preserve">
          <source>You just need to run query</source>
          <target state="translated">クエリを実行する必要があります。</target>
        </trans-unit>
        <trans-unit id="0d47be58043b2f646bebb224b280fa7ec4cea37b" translate="yes" xml:space="preserve">
          <source>along with  $project it will be more appropriate  other wise matching elements will be clubbed together with other elements in document.</source>
          <target state="translated">projectと一緒に$projectと一緒にするのがより適切ですが、他にも一致する要素はドキュメント内の他の要素と一緒にクラブ化されます。</target>
        </trans-unit>
        <trans-unit id="3e7966e60b8ead06f449a4c0808abd6e506e6252" translate="yes" xml:space="preserve">
          <source>and the second query that you have written, that is</source>
          <target state="translated">と、2つ目のクエリを書いていますが、それは</target>
        </trans-unit>
        <trans-unit id="a9dd7c50d60471080ef847b20d425a7f8398a421" translate="yes" xml:space="preserve">
          <source>as you expected it'll gives the exact field from array that matches color:'red'.</source>
          <target state="translated">期待通り、配列の中の正確なフィールドを与えてくれます。</target>
        </trans-unit>
        <trans-unit id="37d90936ec1c52acd7cf334d0d540ecb29f70a0b" translate="yes" xml:space="preserve">
          <source>in this you have used the &lt;code&gt;$elemMatch&lt;/code&gt; operator in query part, whereas if you use this operator in the projection part then you will get the desired result. You can write down your query as</source>
          <target state="translated">この例では、クエリパーツで &lt;code&gt;$elemMatch&lt;/code&gt; 演算子を使用していますが、この演算子をプロジェクションパーツで使用すると、目的の結果が得られます。 次のようにクエリを書き留めることができます</target>
        </trans-unit>
        <trans-unit id="0bf0abdf8924e8c2dbae4fbd00100472ff3a3c7b" translate="yes" xml:space="preserve">
          <source>output of this query is</source>
          <target state="translated">このクエリの出力は</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
