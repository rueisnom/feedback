<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/348170">
    <body>
      <group id="348170">
        <trans-unit id="a605ebe1bbc70a2f5d68414542aedbb8267ea552" translate="yes" xml:space="preserve">
          <source>&quot;git reset&quot; (without options or parameters) used to error out when
     you do not have any commits in your history, but it now gives you
     an empty index (to match non-existent commit you are not even on).</source>
          <target state="translated">&quot;git reset&quot; (没有选项或参数)以前在你的历史记录中没有任何提交的时候会出错,但现在它给你一个空的索引(匹配你不存在的提交)。</target>
        </trans-unit>
        <trans-unit id="9d73d958a4a57f88de8c532a185785e528960fba" translate="yes" xml:space="preserve">
          <source>(Git version 1.7.5.4)</source>
          <target state="translated">(Git版本1.7.5.4)</target>
        </trans-unit>
        <trans-unit id="2ea3a7ae6a49dbe40036ba23b01afd89047ef957" translate="yes" xml:space="preserve">
          <source>(to undo my entire initial add), only to get this (not so) helpful message:</source>
          <target state="translated">撤消我的整个初始添加),只得到这个(不那么)有用的消息。</target>
        </trans-unit>
        <trans-unit id="d484bc11f9473ac3628a251e12abb3c9d00e2f4d" translate="yes" xml:space="preserve">
          <source>--cached
      Use this option to unstage and remove paths only from the index.
      Working tree files, whether modified or not, will be left.</source>
          <target state="translated">--cached 使用这个选项,只在索引中取消缓存并删除路径。工作树文件,无论是否修改,都将被留下。</target>
        </trans-unit>
        <trans-unit id="571355642f9e433222dd5df921a319db3ef42095" translate="yes" xml:space="preserve">
          <source>... lots of crap scrolls by ...</source>
          <target state="translated">..............大量的垃圾卷轴被......</target>
        </trans-unit>
        <trans-unit id="1acdc1609c5a5c5aee184b7b1480a7eff0ff9276" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git add myfile.txt&lt;/code&gt; # This will add your file into the to-be-committed list</source>
          <target state="translated">&lt;code&gt;git add myfile.txt&lt;/code&gt; ＃这会将您的文件添加到待提交列表中</target>
        </trans-unit>
        <trans-unit id="c54c6007493975e90a3ca44ab3e24e7d01a509e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git add&lt;/code&gt; is just an easier-to-type alias for &lt;code&gt;git stage&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; 只是 &lt;code&gt;git stage&lt;/code&gt; 易于使用的别名</target>
        </trans-unit>
        <trans-unit id="ab21b608095f7c251b86422efdad49ef7c2d81fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git add&lt;/code&gt;&lt;strong&gt;cannot be undone&lt;/strong&gt; - safely, in general.</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; &lt;strong&gt;无法撤消&lt;/strong&gt; -通常来说&lt;strong&gt;是&lt;/strong&gt;安全的。</target>
        </trans-unit>
        <trans-unit id="9438c745003ae0e762d6f7f77c8ecab60c1bba4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git remove&lt;/code&gt; or &lt;code&gt;git rm&lt;/code&gt; can be used for this, with the &lt;code&gt;--cached&lt;/code&gt; flag. Try:</source>
          <target state="translated">可以使用 &lt;code&gt;git remove&lt;/code&gt; 或 &lt;code&gt;git rm&lt;/code&gt; ，带有 &lt;code&gt;--cached&lt;/code&gt; 标志。 尝试：</target>
        </trans-unit>
        <trans-unit id="4c7a1ec8775aac840c46097e441f27c53f5610de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c51c03e368754a7b1f09d1c5f7bee49a92cbfa59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50ec6db7e773ae3709a13a5b14923d1b50b3e901" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git status&lt;/code&gt; will tell you if the file was a &lt;strong&gt;new file&lt;/strong&gt; or &lt;strong&gt;modified&lt;/strong&gt;:</source>
          <target state="translated">&lt;code&gt;git status&lt;/code&gt; 会告诉您该文件是&lt;strong&gt;新文件&lt;/strong&gt;还是已&lt;strong&gt;修改的&lt;/strong&gt; &lt;strong&gt;文件&lt;/strong&gt; ：</target>
        </trans-unit>
        <trans-unit id="00a0309cfbeba7e46054ffe7caa48b634485a5c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update&lt;/em&gt; (what follows is my attempt to clear some confusion that can arise from the most upvoted answers):</source>
          <target state="translated">&lt;em&gt;更新&lt;/em&gt; （以下是我尝试清除最受好评的答案可能引起的一些混淆）：</target>
        </trans-unit>
        <trans-unit id="ff16db05481cac0fedfa5919d2253aaf2f143851" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BUT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;BUT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9108ede24ec6135336892fdeecab45ae62e7a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explanation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Explanation:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2302eab0fcebad53f7fe95ba2101a333fa1d00b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For a specific file:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;对于特定文件：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="baae462ba9e06c8d31a4aa91cad37676af0c591e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For all added files:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;对于所有添加的文件：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1465ccbb0b4564f5097966ca2919193d1f830d88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If in doubt, use&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如有疑问，请使用&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa264aa22393c616b506a21fbd299dac1de43bae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: Recent Git versions (1.8.4.x) have changed this message:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;注意：最新的Git版本（1.8.4.x）更改了此消息：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0f1f00ebe5ebdad3a6aabf46d37f83fc812361e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Undo&lt;/strong&gt; a file which has already been added is quite easy using Git. For resetting &lt;code&gt;myfile.txt&lt;/code&gt;, which have already been added, use:</source>
          <target state="translated">使用Git &lt;strong&gt;撤消&lt;/strong&gt;已经添加的文件非常容易。 要重置已添加的 &lt;code&gt;myfile.txt&lt;/code&gt; ，请使用：</target>
        </trans-unit>
        <trans-unit id="1fb8ef0b5031857af5f15e998e196dc424e682aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you do &lt;code&gt;git rm --cached file&lt;/code&gt; on a file that was &lt;strong&gt;modified&lt;/strong&gt; (a file that existed before in the repository), then the file will be removed on &lt;code&gt;git commit&lt;/code&gt;! It will still exist in your file system, but if anybody else pulls your commit, the file will be deleted from their work tree.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt;如果对&lt;strong&gt;修改&lt;/strong&gt;过的文件（仓库中之前存在的文件）执行 &lt;code&gt;git rm --cached file&lt;/code&gt; ，则该文件将在 &lt;code&gt;git commit&lt;/code&gt; 时删除！ 它仍将存在于您的文件系统中，但是如果其他人拉您的提交，该文件将从他们的工作树中删除。</target>
        </trans-unit>
        <trans-unit id="08030a8ae7873170e8104d042b1f57d165779ad1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What you did before:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;您之前做了什么：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5eac4758bfc49c3a0acb49f313f4616a585cba86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What you want:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;你想要什么：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5a77de423f80cead68f5e43d1e4a0387a2d8d293" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;
* (Edit: the above is practically correct, but still there can be some slightly hackish/convoluted ways for recovering changes that were staged, but not committed and then overwritten - see the comments by Johannes Matokic and iolsmit)
&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;*（编辑：以上内容实际上是正确的，但仍可能有一些稍作修改/令人费解的方法来恢复已上演但未提交但随后被覆盖的更改-请参阅Johannes Matokic和iolsmit的评论）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9f25095b6a6bb4281266531ca63ba30aa599fc4b" translate="yes" xml:space="preserve">
          <source>=&amp;gt;    fatal: Failed to resolve 'HEAD' as a valid ref.</source>
          <target state="translated">=&amp;gt;致命：无法将&amp;ldquo; HEAD&amp;rdquo;解析为有效的引用。</target>
        </trans-unit>
        <trans-unit id="da4898c2f54ea719a176ff5921dd10aca02ce86a" translate="yes" xml:space="preserve">
          <source>=&amp;gt; Damn, I didn't want to add all of that.</source>
          <target state="translated">=&amp;gt;该死，我不想添加所有这些内容。</target>
        </trans-unit>
        <trans-unit id="6d6c3f2ad94a41f4041ea240c5260e20525c26b6" translate="yes" xml:space="preserve">
          <source>=&amp;gt; find Stack Overflow - yay</source>
          <target state="translated">=&amp;gt;查找堆栈溢出-是</target>
        </trans-unit>
        <trans-unit id="88fada2a66189147a4940e978181c511fbd9006b" translate="yes" xml:space="preserve">
          <source>Adding the file you didn't want:</source>
          <target state="translated">添加你不想要的文件。</target>
        </trans-unit>
        <trans-unit id="ac2fc40f817967b1c978a3c01c367cc9f47bb6bd" translate="yes" xml:space="preserve">
          <source>After you staged unwanted file(s), to undo, you can do &lt;code&gt;git reset&lt;/code&gt;. &lt;code&gt;Head&lt;/code&gt; is head of your file in the local and the last parameter is the name of your file.</source>
          <target state="translated">暂存不需要的文件后，要撤消，可以执行 &lt;code&gt;git reset&lt;/code&gt; 。 &lt;code&gt;Head&lt;/code&gt; 是本地文件的头，最后一个参数是文件名。</target>
        </trans-unit>
        <trans-unit id="7965e6566c2a6dfd8b1f483d94e6961ce4ada48b" translate="yes" xml:space="preserve">
          <source>An addition to the accepted answer, if your mistakenly-added file was huge, you'll probably notice that, even after removing it from the index with '&lt;code&gt;git reset&lt;/code&gt;', it still seems to occupy space in the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">除了已接受的答案之外，如果错误添加的文件很大，您可能会注意到，即使使用' &lt;code&gt;git reset&lt;/code&gt; '将其从索引中删除后，它似乎仍会占据 &lt;code&gt;.git&lt;/code&gt; 目录中的空间。</target>
        </trans-unit>
        <trans-unit id="6b6f0fea39bad88bec90965ca02b03874e4b0aa9" translate="yes" xml:space="preserve">
          <source>And finally, we have new commands:</source>
          <target state="translated">最后,我们还有新的命令。</target>
        </trans-unit>
        <trans-unit id="57a92191e7a1b366bd8881185dab6943347b9092" translate="yes" xml:space="preserve">
          <source>And that the correct solution was right there in the Git status output (which, yes, I glossed over as 'crap)</source>
          <target state="translated">而正确的解决方案就在Git状态输出中(是的,我把它当作 &quot;垃圾 &quot;掩盖了)。</target>
        </trans-unit>
        <trans-unit id="03eff60d200aefea67d7531d408233d1662e19be" translate="yes" xml:space="preserve">
          <source>And the solution indeed is to use &lt;code&gt;git rm --cached FILE&lt;/code&gt;.</source>
          <target state="translated">解决方案的确是使用 &lt;code&gt;git rm --cached FILE&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="268075f19321c5240e6d23fed51ce807fc626fbd" translate="yes" xml:space="preserve">
          <source>And we could also run &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt;. This is in general preferable, because it works in both scenarios: it also does the undo when we wrongly added a version of an already tracked item.</source>
          <target state="translated">我们还可以运行 &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; 。 通常，这是可取的，因为它在两种情况下都有效：当我们错误地添加已跟踪项目的版本时，它也可以撤消操作。</target>
        </trans-unit>
        <trans-unit id="6bf8d249e1267954bd4e230ac9242aecb362ac1b" translate="yes" xml:space="preserve">
          <source>Another advantage of this method is that if you run into line-ending troubles later and need to refresh all your files, it's easy:</source>
          <target state="translated">这种方法的另一个好处是,如果你在以后遇到行结束的问题,需要刷新所有的文件时,很容易。</target>
        </trans-unit>
        <trans-unit id="3b3a6f60a94e90679c108bb6eb50b25c24b38dd9" translate="yes" xml:space="preserve">
          <source>As per many of the other answers, you can use &lt;code&gt;git reset&lt;/code&gt;</source>
          <target state="translated">根据许多其他答案，您可以使用 &lt;code&gt;git reset&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf659d43d993f36f074044f6a12b23d4a2deeb33" translate="yes" xml:space="preserve">
          <source>Because it does the expected thing in both cases.</source>
          <target state="translated">因为它在这两种情况下都做了预期的事情。</target>
        </trans-unit>
        <trans-unit id="318826776dfef14ebad40e776c6f535a9cac2115" translate="yes" xml:space="preserve">
          <source>But there are two caveats.</source>
          <target state="translated">但有两点要注意。</target>
        </trans-unit>
        <trans-unit id="2228e2a8d5fef35b69908fd4ff6f0f1adc834753" translate="yes" xml:space="preserve">
          <source>Changed a file and used &lt;code&gt;git add .&lt;/code&gt;, or &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">更改文件并使用 &lt;code&gt;git add .&lt;/code&gt; 或 &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25f0e487b5c4252d75619b9d995b4ad8f5a9f18a" translate="yes" xml:space="preserve">
          <source>Check out that initial commit.  This will remove all your files.</source>
          <target state="translated">检查出初始提交。这将删除你所有的文件。</target>
        </trans-unit>
        <trans-unit id="0b7c6acc53e8b3b19e574cbc031b1a080a9327e6" translate="yes" xml:space="preserve">
          <source>Choose option 3 to un add files. In my case I often want to add more than one file, and with interactive mode you can use numbers like this to add files. This will take all but 4: 1, 2, 3, and 5</source>
          <target state="translated">选择选项3来取消添加文件。在我的情况下,我经常想添加多个文件,用交互模式可以用数字这样的方式来添加文件。这将需要除4之外的所有文件:1、2、3和5。</target>
        </trans-unit>
        <trans-unit id="73e4efc1cb5e56aaa583e6b26d3fa8e1ef793246" translate="yes" xml:space="preserve">
          <source>Commit your .gitignore file.</source>
          <target state="translated">提交你的.gitignore文件。</target>
        </trans-unit>
        <trans-unit id="48ac645e39b09e53f05e3fece1aa2de6c019d279" translate="yes" xml:space="preserve">
          <source>Create the main directory for your new project.</source>
          <target state="translated">为你的新项目创建主目录。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="4be867dc932c8893ff792e70234e09467c54700c" translate="yes" xml:space="preserve">
          <source>First: There is (as pointed out in the answer) only one scenario in which &lt;code&gt;git reset HEAD&lt;/code&gt; doesn't work, but &lt;code&gt;git rm --cached&lt;/code&gt; does: a new repository (no commits). But, really, this a practically irrelevant case.</source>
          <target state="translated">第一：（在答案中指出）只有一种情况，其中 &lt;code&gt;git reset HEAD&lt;/code&gt; 不起作用，但是 &lt;code&gt;git rm --cached&lt;/code&gt; 起作用：一个新的存储库（无提交）。 但是，实际上，这是一个无关紧要的案例。</target>
        </trans-unit>
        <trans-unit id="4a2468f3e16dd2cd246730cb5093e54e53053ba5" translate="yes" xml:space="preserve">
          <source>Git has commands for every action imaginable, but it needs extensive knowledge to get things right and because of that it is counter-intuitive at best...</source>
          <target state="translated">Git对每一个能想到的动作都有命令,但它需要大量的知识来完成,正因为如此,它最多只能说是反其道而行之。</target>
        </trans-unit>
        <trans-unit id="4c6a268d08e28eaee830639b0f6e459f3bfca324" translate="yes" xml:space="preserve">
          <source>Git makes it really hard to do &lt;code&gt;git reset&lt;/code&gt; if you don't have any commits.  If you create a tiny initial commit just for the sake of having one, after that you can &lt;code&gt;git add -A&lt;/code&gt; and &lt;code&gt;git reset&lt;/code&gt; as many times as you want in order to get everything right.</source>
          <target state="translated">如果您没有任何提交，Git使得进行 &lt;code&gt;git reset&lt;/code&gt; 真的很困难。 如果您只是为了拥有一个而创建一个微小的初始提交，那么您可以根据需要进行 &lt;code&gt;git add -A&lt;/code&gt; 和 &lt;code&gt;git reset&lt;/code&gt; 多次，以使所有操作正确。</target>
        </trans-unit>
        <trans-unit id="91a26e21098c90d8d4e43789b6f34caa5e8cdade" translate="yes" xml:space="preserve">
          <source>Git staging files</source>
          <target state="translated">Git分期文件</target>
        </trans-unit>
        <trans-unit id="dca35e5fe9deec8747cb15a6c2367d2391384044" translate="yes" xml:space="preserve">
          <source>Git will tell you what is staged, etc., including instructions on how to unstage:</source>
          <target state="translated">Git会告诉你什么是阶段性的等等,包括如何解除阶段性的指示。</target>
        </trans-unit>
        <trans-unit id="5cc928b51e1c3e6d782aa3d3b0519561e6eb9bf9" translate="yes" xml:space="preserve">
          <source>Going into interactive add to undo your add (the commands typed at git here are &quot;r&quot; (revert), &quot;1&quot; (first entry in the list revert shows), 'return' to drop out of revert mode, and &quot;q&quot; (quit):</source>
          <target state="translated">进入交互式添加来撤销你的添加(这里在git键入的命令是 &quot;r&quot;(还原),&quot;1&quot;(列表中的第一个条目还原显示),&quot;return &quot;退出还原模式,&quot;q&quot;(退出)。</target>
        </trans-unit>
        <trans-unit id="d2eba6f142b69842b44b13bd3542d53f601ab045" translate="yes" xml:space="preserve">
          <source>Here's a way to avoid this vexing problem when you start a new project:</source>
          <target state="translated">这里有一个方法,当你开始一个新项目时,可以避免这个烦人的问题。</target>
        </trans-unit>
        <trans-unit id="8d50c74608fd0e6cdc94bef7514a080111db98a2" translate="yes" xml:space="preserve">
          <source>How do I undo 'git add' before commit</source>
          <target state="translated">提交前如何撤销 &quot;git add&quot;?</target>
        </trans-unit>
        <trans-unit id="450c0e272806bac9274b3ed05e1b6bb52640bc2d" translate="yes" xml:space="preserve">
          <source>I created a new file and added it to Git. Then I unstaged it using the Sourcetree GUI.
This is the result:</source>
          <target state="translated">我创建了一个新文件并将其添加到Git中。然后,我使用Sourcetree GUI解压了它。结果是这样的。</target>
        </trans-unit>
        <trans-unit id="a180eb66607dd4df46b1ae9a6f29f86634826e1b" translate="yes" xml:space="preserve">
          <source>I find Git does a pretty good job of nudging me to do the right thing in situations like this.</source>
          <target state="translated">我发现在这种情况下,Git的工作做得相当不错,可以引导我做正确的事情。</target>
        </trans-unit>
        <trans-unit id="47ebb8632c5be8c1245f9fd247285152420b2a47" translate="yes" xml:space="preserve">
          <source>I found this great little post that actually adds the Git command (well, an alias) for &lt;code&gt;git unadd&lt;/code&gt;: see &lt;em&gt;&lt;a href=&quot;https://blog.pivotal.io/labs/labs/git-unadd&quot;&gt;git unadd&lt;/a&gt;&lt;/em&gt; for details or..</source>
          <target state="translated">我发现了这篇很棒的小文章，实际上为 &lt;code&gt;git unadd&lt;/code&gt; 添加了Git命令（还有一个别名）：有关详细信息，请参见&lt;em&gt;&lt;a href=&quot;https://blog.pivotal.io/labs/labs/git-unadd&quot;&gt;git unadd&lt;/a&gt;&lt;/em&gt; 。</target>
        </trans-unit>
        <trans-unit id="980f2d88ed5717679189772c4a5e6b43c72aa8f8" translate="yes" xml:space="preserve">
          <source>I have created the steps in the image below in more details for you, including all steps which may happen in these cases:</source>
          <target state="translated">我在下面的图片中为您详细介绍了创建步骤,包括这些情况下可能发生的所有步骤。</target>
        </trans-unit>
        <trans-unit id="26790ed531042f80782885ad57b1028053449307" translate="yes" xml:space="preserve">
          <source>I have not yet run &lt;code&gt;git commit&lt;/code&gt;. Is there a way to undo this, so these files won't be included in the commit?</source>
          <target state="translated">我还没有运行 &lt;code&gt;git commit&lt;/code&gt; 。 有一种方法可以撤消此操作，以便这些文件不会包含在提交中？</target>
        </trans-unit>
        <trans-unit id="f4d6416f59e901972dc68e4c2645f886d12e39d1" translate="yes" xml:space="preserve">
          <source>I mistakenly added files to Git using the command:</source>
          <target state="translated">我错误地使用命令将文件添加到Git中。</target>
        </trans-unit>
        <trans-unit id="59a1168cbdd90e679377d656fb08a05cfbc64983" translate="yes" xml:space="preserve">
          <source>I mistakenly added files using the command...</source>
          <target state="translated">我错误地使用命令添加文件.....</target>
        </trans-unit>
        <trans-unit id="2e8728d62406ec2c90bff4af6740b6ca2b39d201" translate="yes" xml:space="preserve">
          <source>I proceed to use</source>
          <target state="translated">我继续使用</target>
        </trans-unit>
        <trans-unit id="e9128e1ff3de03a54faec72eda56d381de0efeff" translate="yes" xml:space="preserve">
          <source>I zipped up everything to a safe place before trusting &lt;code&gt;git help rm&lt;/code&gt; about the &lt;code&gt;--cached&lt;/code&gt; not destroying anything (and what if I misspelled it).</source>
          <target state="translated">在信任 &lt;code&gt;git help rm&lt;/code&gt; 关于 &lt;code&gt;--cached&lt;/code&gt; 不会破坏任何内容（以及我拼错的内容该怎么办）之前，我将所有内容压缩到一个安全的地方。</target>
        </trans-unit>
        <trans-unit id="fcd7314f67163d84c2c9f40329f48cfdb2e19990" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; was &lt;strong&gt;already tracked&lt;/strong&gt;, &lt;code&gt;git add&lt;/code&gt;&lt;strong&gt;saves the current content&lt;/strong&gt; (snapshot, version) to the cache. In Git, this action is still called &lt;strong&gt;add&lt;/strong&gt;, (not mere &lt;em&gt;update&lt;/em&gt; it), because two different versions (snapshots) of a file are regarded as two different items: hence, we are indeed adding a new item to the cache, to be eventually committed later.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; &lt;strong&gt;已经&lt;/strong&gt;被&lt;strong&gt;跟踪&lt;/strong&gt; ， &lt;code&gt;git add&lt;/code&gt; &lt;strong&gt;会将当前内容&lt;/strong&gt; （快照，版本）保存到缓存中。 在Git中，此操作仍称为&lt;strong&gt;add&lt;/strong&gt; ，（不仅仅是&lt;em&gt;更新&lt;/em&gt;它），因为文件的两个不同版本（快照）被视为两个不同的项目：因此，我们的确在缓存中添加了一个新项目，最终以后提交。</target>
        </trans-unit>
        <trans-unit id="ce05ef547080bdd0c9b4b6d21f9a9cb1212fb4e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; was &lt;strong&gt;not previously tracked&lt;/strong&gt;, &lt;code&gt;git add&lt;/code&gt;&lt;strong&gt;adds it to the cache&lt;/strong&gt;, with its current content.</source>
          <target state="translated">如果 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; &lt;strong&gt;先前未被跟踪&lt;/strong&gt; ，则 &lt;code&gt;git add&lt;/code&gt; &lt;strong&gt;将其&lt;/strong&gt;及其当前内容&lt;strong&gt;添加到缓存中&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ff00e45e5ffaf135367a1313fb0084d4bdf27c8" translate="yes" xml:space="preserve">
          <source>If you type:</source>
          <target state="translated">如果你输入。</target>
        </trans-unit>
        <trans-unit id="2742bf9d716f8b835566210e331c47572dd4050b" translate="yes" xml:space="preserve">
          <source>If you're on your initial commit and you can't use &lt;code&gt;git reset&lt;/code&gt;, just declare &quot;Git bankruptcy&quot; and delete the &lt;code&gt;.git&lt;/code&gt; folder and start over</source>
          <target state="translated">如果您是首次提交，则不能使用 &lt;code&gt;git reset&lt;/code&gt; ，只需声明&amp;ldquo; Git破产&amp;rdquo;并删除 &lt;code&gt;.git&lt;/code&gt; 文件夹并重新开始</target>
        </trans-unit>
        <trans-unit id="cfa255a467797d7f7b136c29ef62aef20cf72142" translate="yes" xml:space="preserve">
          <source>In Sourcetree you can do this easily via the GUI.
You can check which command Sourcetree uses to unstage a file.</source>
          <target state="translated">在Sourcetree中,你可以通过GUI轻松完成这个操作。你可以检查Sourcetree使用哪条命令来解压一个文件。</target>
        </trans-unit>
        <trans-unit id="6371392980b92d1512f0ab12ff15fcc9824dcda5" translate="yes" xml:space="preserve">
          <source>In light of this, the question is slightly ambiguous:</source>
          <target state="translated">有鉴于此,这个问题略显含糊。</target>
        </trans-unit>
        <trans-unit id="26fded76dcbe21bec020034ef8ae2890f88f0a1e" translate="yes" xml:space="preserve">
          <source>In old versions of Git, the above commands are equivalent to &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; and &lt;code&gt;git reset HEAD&lt;/code&gt; respectively, and will fail if &lt;code&gt;HEAD&lt;/code&gt; is undefined (because you haven't yet made any commits in your repository) or ambiguous (because you created a branch called &lt;code&gt;HEAD&lt;/code&gt;, which is a stupid thing that you shouldn't do). This &lt;a href=&quot;https://git.kernel.org/cgit/git/git.git/tree/Documentation/RelNotes/1.8.2.txt#n179&quot;&gt;was changed in Git 1.8.2&lt;/a&gt;, though, so in modern versions of Git you can use the commands above even prior to making your first commit:</source>
          <target state="translated">在旧版本的Git中，上述命令分别等效于 &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; 和 &lt;code&gt;git reset HEAD&lt;/code&gt; ，如果 &lt;code&gt;HEAD&lt;/code&gt; 未定义（因为尚未在存储库中进行任何提交）或模棱两可（因为创建了一个名为 &lt;code&gt;HEAD&lt;/code&gt; 的分支，这是愚蠢的事情，您不应该这样做）。 不过， &lt;a href=&quot;https://git.kernel.org/cgit/git/git.git/tree/Documentation/RelNotes/1.8.2.txt#n179&quot;&gt;在Git 1.8.2中对此进行了更改&lt;/a&gt; ，因此在现代版本的Git中，甚至可以在进行首次提交之前使用上述命令：</target>
        </trans-unit>
        <trans-unit id="4051c13ecb202313b56c354bb279d138ec086db7" translate="yes" xml:space="preserve">
          <source>It further turns out that there's &lt;a href=&quot;http://kerneltrap.org/mailarchive/git/2008/2/13/846664/thread&quot;&gt;a bug logged&lt;/a&gt; against the unhelpfulness of this in the mailing list.</source>
          <target state="translated">事实证明，在邮件列表中有&lt;a href=&quot;http://kerneltrap.org/mailarchive/git/2008/2/13/846664/thread&quot;&gt;一个&lt;/a&gt;针对此问题的日志记录了一个错误 。</target>
        </trans-unit>
        <trans-unit id="155ff3b94a20cc6cfcbf96ffeaf7482107ecbbf9" translate="yes" xml:space="preserve">
          <source>It turns out that this is because the HEAD ref (branch?) doesn't exist until after the first commit. That is, you'll run into the same beginner's problem as me if your workflow, like mine, was something like:</source>
          <target state="translated">事实证明,这是因为head ref(分支?也就是说,如果你的工作流程和我一样,你会遇到和我一样的新手问题。</target>
        </trans-unit>
        <trans-unit id="adaaf6d802f465498479a38c637bf662a6522399" translate="yes" xml:space="preserve">
          <source>It will reset your head with that specified file. so, if your head doesn't have it means, it will simply reset it.</source>
          <target state="translated">它将重置你的头像与指定的文件,所以,如果你的头像没有它的意思,它将简单地重置它。</target>
        </trans-unit>
        <trans-unit id="68c9f4ed13403f924ccc247b10f282e693931120" translate="yes" xml:space="preserve">
          <source>Just type &lt;code&gt;git reset&lt;/code&gt; it will revert back and it is like you never typed &lt;code&gt;git add .&lt;/code&gt; since your last commit. Make sure you have committed before.</source>
          <target state="translated">只需输入 &lt;code&gt;git reset&lt;/code&gt; ,它就会还原，就像您从未输入 &lt;code&gt;git add .&lt;/code&gt; 自上次提交以来。 确保您之前已作出承诺。</target>
        </trans-unit>
        <trans-unit id="7e0db4ee366cdc01a3b955e69f4e20c110c2d411" translate="yes" xml:space="preserve">
          <source>Let's recall first what &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt; actually does:</source>
          <target state="translated">让我们首先回顾一下 &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt; 的实际作用：</target>
        </trans-unit>
        <trans-unit id="cb43fda806b60a9e08edb5a9c0bde80767b52dcb" translate="yes" xml:space="preserve">
          <source>Maybe Git has evolved since you posted your question.</source>
          <target state="translated">也许自从你发布问题后,Git已经进化了。</target>
        </trans-unit>
        <trans-unit id="1894d7e64791aafcdc008bf854895f11545e7eaa" translate="yes" xml:space="preserve">
          <source>Note that if you fail to specify a revision then you have to include a separator. Example from my console:</source>
          <target state="translated">注意,如果你没有指定一个版本,那么你必须包含一个分隔符。我的控制台中的例子。</target>
        </trans-unit>
        <trans-unit id="af8a3ad1fc0ec3393f35b0cf47135414c3907e84" translate="yes" xml:space="preserve">
          <source>Note the warnings elsewhere here - &lt;code&gt;git rm&lt;/code&gt; deletes your local working copy of the file, but &lt;em&gt;not&lt;/em&gt; if you use &lt;strong&gt;--cached&lt;/strong&gt;.  Here's the result of &lt;code&gt;git help rm&lt;/code&gt;:</source>
          <target state="translated">请注意此处其他地方的警告 &lt;code&gt;git rm&lt;/code&gt; 删除文件的本地工作副本，但如果使用&lt;strong&gt;--cached则&lt;/strong&gt; &lt;em&gt;不会&lt;/em&gt;删除。 这是 &lt;code&gt;git help rm&lt;/code&gt; 的结果：</target>
        </trans-unit>
        <trans-unit id="c72f4a37de00a8bbbe1dbd59f585874fa1e95893" translate="yes" xml:space="preserve">
          <source>Note: &lt;strong&gt;checkout&lt;/strong&gt; changes the code in the files and moves to the last updated (committed) state. &lt;strong&gt;reset&lt;/strong&gt; doesn't change the codes; it just resets the header.</source>
          <target state="translated">注意： &lt;strong&gt;检出会&lt;/strong&gt;更改文件中的代码，并移至上次更新（提交）状态。 &lt;strong&gt;重置&lt;/strong&gt;不会更改代码； 它只是重置标题。</target>
        </trans-unit>
        <trans-unit id="2cbbc1ff0f31adab3c452b40de6f1268e3911cdf" translate="yes" xml:space="preserve">
          <source>Now I want to undo this add, before commit, &lt;code&gt;git reset newFile.txt&lt;/code&gt;:</source>
          <target state="translated">现在我想撤消此添加，在提交之前， &lt;code&gt;git reset newFile.txt&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="05c7960282989a21ecc187ff2e0d765363c04167" translate="yes" xml:space="preserve">
          <source>Now create a .gitignore file (even if it's empty).</source>
          <target state="translated">现在创建一个.gitignore文件(即使它是空的)。</target>
        </trans-unit>
        <trans-unit id="d289da3aa7916cb38f48d3be42ec0125720bc36a" translate="yes" xml:space="preserve">
          <source>Now you can</source>
          <target state="translated">现在,你可以</target>
        </trans-unit>
        <trans-unit id="0e24b543e5ac084c629c30b256d5108f69b9af4c" translate="yes" xml:space="preserve">
          <source>Now, you can try:</source>
          <target state="translated">现在,你可以试试了。</target>
        </trans-unit>
        <trans-unit id="6bacde1e5ace7fedf82b742a45f533ea5dbbd8d5" translate="yes" xml:space="preserve">
          <source>Of course, this is not very critical if we just follow the usual lazy workflow of doing 'git add' only for adding new files (case 1), and we update new contents via the commit, &lt;code&gt;git commit -a&lt;/code&gt; command.</source>
          <target state="translated">当然，如果我们仅遵循通常的懒惰工作流程（仅用于添加新文件）进行&amp;ldquo; git add&amp;rdquo;（案例1），然后通过commit &lt;code&gt;git commit -a&lt;/code&gt; 命令更新新内容，这并不是很关键。</target>
        </trans-unit>
        <trans-unit id="ef179165bedaefa2e60e14c1f5b0a3fed59e2b9d" translate="yes" xml:space="preserve">
          <source>Okay, now I'm back to where I started. Next time I'm going to use &lt;code&gt;-n&lt;/code&gt; to do a dry run and see what will be added:</source>
          <target state="translated">好的，现在我回到了起点。 下次，我将使用 &lt;code&gt;-n&lt;/code&gt; 进行空运行并查看将添加的内容：</target>
        </trans-unit>
        <trans-unit id="0cb61707635fc5b2b85cc7e318bd0c2eff7bc6b4" translate="yes" xml:space="preserve">
          <source>Personally I use even shorter aliases:</source>
          <target state="translated">就我个人而言,我用的是更短的别名。</target>
        </trans-unit>
        <trans-unit id="4e01375f9a0c5e752c6c2ca322f69e1c751c7482" translate="yes" xml:space="preserve">
          <source>Pity there is no &lt;code&gt;git unstage&lt;/code&gt; nor &lt;code&gt;git unadd&lt;/code&gt; commands. The relevant one is harder to guess or remember, but it is pretty obvious:</source>
          <target state="translated">可惜没有 &lt;code&gt;git unadd&lt;/code&gt; 或git unadd命令。 相关的难以猜测或记住，但很明显：</target>
        </trans-unit>
        <trans-unit id="13a12243b9912816bf20ff21a06d8b8be5dc8068" translate="yes" xml:space="preserve">
          <source>Quite opposite to this command is,</source>
          <target state="translated">与此命令截然相反的是:</target>
        </trans-unit>
        <trans-unit id="dae6f4177d012c1139923735c568ddf03db59d60" translate="yes" xml:space="preserve">
          <source>Reasoning:</source>
          <target state="translated">Reasoning:</target>
        </trans-unit>
        <trans-unit id="e6c769e8631fe99bc7ceaf82b906459b7e02f9c3" translate="yes" xml:space="preserve">
          <source>Remove &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; from index and versioning, keeping the un-versioned file with changes in working copy:</source>
          <target state="translated">从索引和版本控制中删除 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; ，保留未版本化的文件以及工作副本中的更改：</target>
        </trans-unit>
        <trans-unit id="ae5dd6b49f5c3fbe00248e75277ab0bec4e291d2" translate="yes" xml:space="preserve">
          <source>Remove &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; from working copy and versioning completely:</source>
          <target state="translated">从工作副本和版本中完全删除 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="fed077be24eb8eaa204960095370114925bbcac1" translate="yes" xml:space="preserve">
          <source>Remove the file from the index, but keep it versioned and left with uncommitted changes in working copy:</source>
          <target state="translated">将该文件从索引中删除,但保持版本化,并在工作拷贝中留下未签署的修改。</target>
        </trans-unit>
        <trans-unit id="e74a1ace1491f586fe024a5c928549012bbdc769" translate="yes" xml:space="preserve">
          <source>Reset the file to the last state from HEAD, undoing changes and removing them from the index:</source>
          <target state="translated">将文件从HEAD重置为最后的状态,撤销更改并从索引中删除。</target>
        </trans-unit>
        <trans-unit id="b1b392607deaf29a7e81453e069b7c07a32a6b18" translate="yes" xml:space="preserve">
          <source>Run</source>
          <target state="translated">Run</target>
        </trans-unit>
        <trans-unit id="02dea6db5118caef938b800592b8a5b38b39b70c" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;git init&lt;/code&gt;.</source>
          <target state="translated">运行 &lt;code&gt;git init&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7e78630f4030bbb87b09bdc8ef8eb2b0effda1fd" translate="yes" xml:space="preserve">
          <source>Second: Be aware that &lt;code&gt;git reset HEAD&lt;/code&gt;  can't magically recover the previously cached file contents, it just resynchronises it from the HEAD. If our misguided &lt;code&gt;git add&lt;/code&gt; overwrote a previous staged uncommitted version, we can't recover it. That's why, strictly speaking, we cannot undo [*].</source>
          <target state="translated">其次：请注意 &lt;code&gt;git reset HEAD&lt;/code&gt; 不能神奇地恢复以前缓存的文件内容，它只是与HEAD重新同步。 如果我们误导的 &lt;code&gt;git add&lt;/code&gt; 覆盖了先前暂存的未提交版本，我们将无法恢复它。 因此，严格来说，这是我们不能撤消[*]的原因。</target>
        </trans-unit>
        <trans-unit id="6482098605bc3d53dec5b4352c070381b60cd196" translate="yes" xml:space="preserve">
          <source>Simply,</source>
          <target state="translated">Simply,</target>
        </trans-unit>
        <trans-unit id="66c23519edb800ce7f1ae7d41a7603aad229a1c7" translate="yes" xml:space="preserve">
          <source>So, which is the real &lt;strong&gt;undo&lt;/strong&gt; of &lt;code&gt;git add&lt;/code&gt;?</source>
          <target state="translated">那么，哪个是 &lt;code&gt;git add&lt;/code&gt; 的真正&lt;strong&gt;撤消&lt;/strong&gt; ？</target>
        </trans-unit>
        <trans-unit id="7a0a709ea65dccc7a4c51af95745b03c4f843454" translate="yes" xml:space="preserve">
          <source>Sourcetree uses &lt;code&gt;reset&lt;/code&gt; to unstage new files.</source>
          <target state="translated">Sourcetree使用 &lt;code&gt;reset&lt;/code&gt; 取消登台新文件。</target>
        </trans-unit>
        <trans-unit id="6c8f7d0c756781e3631fb4f4ea510b736c4722ab" translate="yes" xml:space="preserve">
          <source>Strictly speaking, and if I'm not mistaken: &lt;strong&gt;none&lt;/strong&gt;.</source>
          <target state="translated">严格来说，如果我没有记错的话： &lt;strong&gt;没有&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="552594479ca335a75b38e3d8e7bdd7faab39b95c" translate="yes" xml:space="preserve">
          <source>Suppose I add the file accidentally, &lt;code&gt;git add newFile.txt&lt;/code&gt;:</source>
          <target state="translated">假设我不小心添加了文件， &lt;code&gt;git add newFile.txt&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="9b8c3ebc30d10d6817fe9050f1cc51452b3d3228" translate="yes" xml:space="preserve">
          <source>Suppose I create a new file, &lt;code&gt;newFile.txt&lt;/code&gt;:</source>
          <target state="translated">假设我创建一个新文件 &lt;code&gt;newFile.txt&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="48ddf6e59a4b1f3b87a0c3bfe2a4dc11f44620d7" translate="yes" xml:space="preserve">
          <source>That's it!  Here's your proof, showing that &quot;foo&quot; is back on the untracked list:</source>
          <target state="translated">就是这样!这是你的证据,显示 &quot;Foo &quot;又回到了未追踪名单上。</target>
        </trans-unit>
        <trans-unit id="8958263708a605b83222c7193c08abd8eb1b5018" translate="yes" xml:space="preserve">
          <source>The OP's scenario seems to be the first one (untracked file),  we want the &quot;undo&quot; to remove the file (not just the current contents) from the tracked items. &lt;strong&gt;If&lt;/strong&gt; this is the case, then it's ok to run  &lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">OP的情况似乎是第一个（未跟踪的文件），我们希望&amp;ldquo;撤消&amp;rdquo;从跟踪的项目中删除文件（而不仅仅是当前内容）。 &lt;strong&gt;如果&lt;/strong&gt;是这种情况，那么可以运行 &lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="7b3077a7e23f22edb63b9582ee50b4547489abb5" translate="yes" xml:space="preserve">
          <source>The question is not clearly posed. The reason is that &lt;code&gt;git add&lt;/code&gt; has two meanings:</source>
          <target state="translated">这个问题没有明确提出。 原因是 &lt;code&gt;git add&lt;/code&gt; 具有两个含义：</target>
        </trans-unit>
        <trans-unit id="63cdf5c295405f082341c0ae56aecc932dd4667c" translate="yes" xml:space="preserve">
          <source>Then check out your most recent commit again.  This will retrieve fresh copies of your files, using your current line-ending settings.</source>
          <target state="translated">然后再次检查你最近的提交。这将检索到您的文件的新副本,使用您当前的行尾设置。</target>
        </trans-unit>
        <trans-unit id="45b5f9be123d9d86c58d9dec3dd125558e131647" translate="yes" xml:space="preserve">
          <source>There is also interactive mode:</source>
          <target state="translated">还有互动模式。</target>
        </trans-unit>
        <trans-unit id="3d8e9657b987817fb3c220308e1acc16025156bd" translate="yes" xml:space="preserve">
          <source>This command will unstash your changes:</source>
          <target state="translated">这个命令将解除你的更改。</target>
        </trans-unit>
        <trans-unit id="fbecbeb1a67335121e9c59db32b75a2ff73e40e7" translate="yes" xml:space="preserve">
          <source>This is needed since &lt;code&gt;git reset --hard HEAD&lt;/code&gt; won't work with single files.</source>
          <target state="translated">这是必需的，因为 &lt;code&gt;git reset --hard HEAD&lt;/code&gt; 不适用于单个文件。</target>
        </trans-unit>
        <trans-unit id="78be1b0da3b7e1ea2b2d12e12dd3d30469cfa022" translate="yes" xml:space="preserve">
          <source>This is nothing to be worried about; the file is indeed still in the repository, but only as a &quot;loose object&quot;. It will not be copied to other repositories (via clone, push), and the space will be eventually reclaimed - though perhaps not very soon. If you are anxious, you can run:</source>
          <target state="translated">这没什么好担心的,这个文件确实还在存储库中,但只是作为一个 &quot;松散的对象&quot;。它不会被复制到其他版本库中(通过克隆、推送),空间最终会被收回--尽管可能不会很快。如果你很着急,可以运行。</target>
        </trans-unit>
        <trans-unit id="5dcdedc4b69b304293ee4853c6d1a79b75fafbd7" translate="yes" xml:space="preserve">
          <source>This process is called &lt;em&gt;staging&lt;/em&gt;. So the most natural command to &lt;em&gt;stage&lt;/em&gt; the changes (changed files) is the obvious one:</source>
          <target state="translated">此过程称为&lt;em&gt;暂存&lt;/em&gt; 。 因此，进行更改（更改的文件）的最自然的命令是显而易见的命令：</target>
        </trans-unit>
        <trans-unit id="6bb9d50aae0e807f542249cc2247c59911ac39cd" translate="yes" xml:space="preserve">
          <source>This should be what you are looking for.</source>
          <target state="translated">这应该就是你要找的东西。</target>
        </trans-unit>
        <trans-unit id="16b0d869d782ecce087a08191cd6576c501a0143" translate="yes" xml:space="preserve">
          <source>To choose a sequence, just type 1-5 to take all from 1 to 5.</source>
          <target state="translated">要选择一个序列,只需输入1-5就可以从1到5中全部取数。</target>
        </trans-unit>
        <trans-unit id="9d60018f1a5334d24aeca0c7d89c5867b612205d" translate="yes" xml:space="preserve">
          <source>To clarify: &lt;code&gt;git add&lt;/code&gt; moves changes from the current working directory to the &lt;em&gt;staging area&lt;/em&gt; (index).</source>
          <target state="translated">需要说明的是： &lt;code&gt;git add&lt;/code&gt; 将更改从当前工作目录移动到&lt;em&gt;暂存区&lt;/em&gt; （索引）。</target>
        </trans-unit>
        <trans-unit id="515c85f04427e465b01ddaa8b4eed764826e3289" translate="yes" xml:space="preserve">
          <source>To remove new files from the staging area (and only in case of a new file), as suggested above:</source>
          <target state="translated">要将新文件从暂存区中删除(而且只在新文件的情况下),如上文建议。</target>
        </trans-unit>
        <trans-unit id="4c2db952152ad41554b645a8de14e0d96cee28e3" translate="yes" xml:space="preserve">
          <source>To reset every file in a particular folder (and its subfolders), you can use the following command:</source>
          <target state="translated">要重置特定文件夹中的每个文件(及其子文件夹),可以使用以下命令。</target>
        </trans-unit>
        <trans-unit id="7a6d02a83dd13f67c2c894d293c482fbefff8376" translate="yes" xml:space="preserve">
          <source>To undo &lt;code&gt;git add&lt;/code&gt;, use:</source>
          <target state="translated">要撤消 &lt;code&gt;git add&lt;/code&gt; ，请使用：</target>
        </trans-unit>
        <trans-unit id="fa1dcc9ecc36eb2fd6956b02179caec720b1c11b" translate="yes" xml:space="preserve">
          <source>Unstaging files [08/12/15 10:43]
  git -c diff.mnemonicprefix=false -c core.quotepath=false -c credential.helper=sourcetree reset -q -- path/to/file/filename.java</source>
          <target state="translated">Unstaging files [081215 10:43]git -c diff.mnemonicprefix=false -c core.quotepath=false -c credential.helper=sourcetree reset -q ---pathtofilefilename.java</target>
        </trans-unit>
        <trans-unit id="056701c16429c2b69fe63426e25dcd6aa3557661" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git add -i&lt;/code&gt; to remove just-added files from your upcoming commit.  Example:</source>
          <target state="translated">使用 &lt;code&gt;git add -i&lt;/code&gt; 从您即将提交的提交中删除刚添加的文件。 例：</target>
        </trans-unit>
        <trans-unit id="f877b9fe8d4d292f783a2224c88efb437d28d091" translate="yes" xml:space="preserve">
          <source>Use rm --cached only for new files accidentally added.</source>
          <target state="translated">只对意外添加的新文件使用 rm --cached。</target>
        </trans-unit>
        <trans-unit id="b3c520b0adfc4612c5f13f20487496d48ab36887" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;*&lt;/code&gt; command to handle multiple files at a time:</source>
          <target state="translated">使用 &lt;code&gt;*&lt;/code&gt; 命令一次处理多个文件：</target>
        </trans-unit>
        <trans-unit id="924703164da00b7444edd64fb60fcbb8c3162ce5" translate="yes" xml:space="preserve">
          <source>We can easily create an alias for this:</source>
          <target state="translated">对此,我们可以很容易地建立一个别名。</target>
        </trans-unit>
        <trans-unit id="bbed8dcb33376bb1d53e3675a03c7fa2ea7c9fe5" translate="yes" xml:space="preserve">
          <source>When I was new to this, I first tried</source>
          <target state="translated">当我刚开始做这个的时候,我第一次尝试过</target>
        </trans-unit>
        <trans-unit id="eedeb18aad137a7f9d3e048a4943d3e6769cc920" translate="yes" xml:space="preserve">
          <source>Will remove a file named filename.txt from the current index, the &quot;about to be committed&quot; area, without changing anything else.</source>
          <target state="translated">将从当前索引中删除一个名为 filename.txt 的文件,即 &quot;即将被提交 &quot;区域,而不改变其他任何东西。</target>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">你也可以使用</target>
        </trans-unit>
        <trans-unit id="80087849dfcee0e85f78d0320eb186d09742ee66" translate="yes" xml:space="preserve">
          <source>You can undo &lt;code&gt;git add&lt;/code&gt; before commit with</source>
          <target state="translated">您可以在提交之前撤消 &lt;code&gt;git add&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">你可以使用</target>
        </trans-unit>
        <trans-unit id="a0815200bea1a60432e0d4fb69db34bfd8e2c698" translate="yes" xml:space="preserve">
          <source>You want:</source>
          <target state="translated">你想要的。</target>
        </trans-unit>
        <trans-unit id="d8dcb8d55fececafb2c68ba7044ee1b772419651" translate="yes" xml:space="preserve">
          <source>adding a &lt;strong&gt;modified&lt;/strong&gt; file to the staging area, then undo with &lt;code&gt;git reset HEAD file&lt;/code&gt;.</source>
          <target state="translated">将一个&lt;strong&gt;修改过的&lt;/strong&gt;文件添加到暂存区，然后使用 &lt;code&gt;git reset HEAD file&lt;/code&gt; 撤消。</target>
        </trans-unit>
        <trans-unit id="6d473aa440edb561b8723fe71085cf8f567b0af0" translate="yes" xml:space="preserve">
          <source>adding a &lt;strong&gt;new file&lt;/strong&gt; to the staging area, then undo with &lt;code&gt;git rm --cached file&lt;/code&gt;.</source>
          <target state="translated">将一个&lt;strong&gt;新文件&lt;/strong&gt;添加到暂存区，然后使用 &lt;code&gt;git rm --cached file&lt;/code&gt; 撤消。</target>
        </trans-unit>
        <trans-unit id="4fb062fcfd7c48b01f50e3d39fe6e21fd78aec1b" translate="yes" xml:space="preserve">
          <source>and remove all the files manually or by selecting all of them and clicking on the &lt;em&gt;unstage from commit&lt;/em&gt; button.</source>
          <target state="translated">并手动删除所有文件，或选择所有文件并单击&amp;ldquo; &lt;em&gt;从提交&lt;/em&gt;取消&lt;em&gt;登台&amp;rdquo;&lt;/em&gt;按钮。</target>
        </trans-unit>
        <trans-unit id="4f3a7ccc2fff02e760b79353f269bbf29121de43" translate="yes" xml:space="preserve">
          <source>cd to my great new project directory to try out Git, the new hotness</source>
          <target state="translated">cd到我的新项目目录中去尝试一下Git,新的热门项目目录。</target>
        </trans-unit>
        <trans-unit id="fb7f7c94028fe09a6d2d9b3bf0b8501eb7095619" translate="yes" xml:space="preserve">
          <source>etc.</source>
          <target state="translated">etc.</target>
        </trans-unit>
        <trans-unit id="79986d4e639d0773bd127e19458b07f55b1bfc8c" translate="yes" xml:space="preserve">
          <source>git checkout .</source>
          <target state="translated">git checkout .</target>
        </trans-unit>
        <trans-unit id="15cba6d4879c1734e4422bdc03b13a6b93611534" translate="yes" xml:space="preserve">
          <source>git checkout my_file.txt</source>
          <target state="translated">git checkout my_file.txt</target>
        </trans-unit>
        <trans-unit id="801b883972ec8ef1236eb019443c886dcf6750a7" translate="yes" xml:space="preserve">
          <source>git reset .</source>
          <target state="translated">git重置。</target>
        </trans-unit>
        <trans-unit id="94f60eb54806996b7e1222363ba5dc870eddd539" translate="yes" xml:space="preserve">
          <source>git reset my_file.txt</source>
          <target state="translated">git reset my_file.txt</target>
        </trans-unit>
        <trans-unit id="25aab1fe6dec61e754487a291c40fdda95b4be44" translate="yes" xml:space="preserve">
          <source>google &quot;undo git add&quot;</source>
          <target state="translated">谷歌 &quot;撤消git添加&quot;</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="5712023340e6a2d05ce05ba84935a0ac55f18949" translate="yes" xml:space="preserve">
          <source>so, you will be in the previous state. Specified will be again in untracked list (previous state).</source>
          <target state="translated">所以,你将在之前的状态。指定将再次在未跟踪的列表中(以前的状态)。</target>
        </trans-unit>
        <trans-unit id="0d19f5a79e1fc6cc465c4d08247b4439056a1cad" translate="yes" xml:space="preserve">
          <source>to add parts of files.</source>
          <target state="translated">以添加部分文件。</target>
        </trans-unit>
        <trans-unit id="5f5d8b5a3e74af731dcc9b939e21d7235ca21741" translate="yes" xml:space="preserve">
          <source>to remove everything and start again. Didn't work though, because while &lt;code&gt;add .&lt;/code&gt; is recursive, turns out &lt;code&gt;rm&lt;/code&gt; needs &lt;code&gt;-r&lt;/code&gt; to recurse. Sigh.</source>
          <target state="translated">删除所有内容，然后重新开始。 不过没有用，因为在 &lt;code&gt;add .&lt;/code&gt; 是递归的，结果表明 &lt;code&gt;rm&lt;/code&gt; 需要 &lt;code&gt;-r&lt;/code&gt; 来递归。 叹。</target>
        </trans-unit>
        <trans-unit id="0e01177e2865564bc5a2bd0273597bbf76768708" translate="yes" xml:space="preserve">
          <source>which will remove it from the current index (the &quot;about to be committed&quot; list) without changing anything else.</source>
          <target state="translated">会将其从当前索引(&quot;即将提交 &quot;列表)中删除,而不会改变其他任何东西。</target>
        </trans-unit>
        <trans-unit id="22a56ae9ed58d1e164446e8aefe9c47c81c380ad" translate="yes" xml:space="preserve">
          <source>will &quot;un-add&quot; everything you've added from your current directory recursively</source>
          <target state="translated">将递归地 &quot;取消 &quot;你从当前目录中添加的所有内容。</target>
        </trans-unit>
        <trans-unit id="aaaa9d584e39a7eb22d6030fa5ce40df98b7224d" translate="yes" xml:space="preserve">
          <source>without any file name to unstage all due changes. This can come in handy when there are too many files to be listed one by one in a reasonable amount of time.</source>
          <target state="translated">没有任何文件名的情况下,取消了所有到期的更改。当文件太多,无法在合理的时间内逐一列出时,这个功能就会派上用场。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
