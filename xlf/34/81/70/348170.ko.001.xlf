<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/348170">
    <body>
      <group id="348170">
        <trans-unit id="a605ebe1bbc70a2f5d68414542aedbb8267ea552" translate="yes" xml:space="preserve">
          <source>&quot;git reset&quot; (without options or parameters) used to error out when
     you do not have any commits in your history, but it now gives you
     an empty index (to match non-existent commit you are not even on).</source>
          <target state="translated">히스토리에 커밋이 없을 때 오류를 발생시키는 데 사용되는 &quot;git reset&quot;(옵션 또는 매개 변수 없음)이 있지만 현재 존재하지 않는 커밋과 일치하지 않는 빈 인덱스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="9d73d958a4a57f88de8c532a185785e528960fba" translate="yes" xml:space="preserve">
          <source>(Git version 1.7.5.4)</source>
          <target state="translated">(Git 버전 1.7.5.4)</target>
        </trans-unit>
        <trans-unit id="2ea3a7ae6a49dbe40036ba23b01afd89047ef957" translate="yes" xml:space="preserve">
          <source>(to undo my entire initial add), only to get this (not so) helpful message:</source>
          <target state="translated">(전체 초기 추가를 실행 취소하려면) 유용한 메시지 만 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="d484bc11f9473ac3628a251e12abb3c9d00e2f4d" translate="yes" xml:space="preserve">
          <source>--cached
      Use this option to unstage and remove paths only from the index.
      Working tree files, whether modified or not, will be left.</source>
          <target state="translated">--cached이 옵션을 사용하면 인덱스에서만 경로를 준비 해제하고 제거 할 수 있습니다. 작업 트리 파일은 수정 여부에 관계없이 남아 있습니다.</target>
        </trans-unit>
        <trans-unit id="571355642f9e433222dd5df921a319db3ef42095" translate="yes" xml:space="preserve">
          <source>... lots of crap scrolls by ...</source>
          <target state="translated">... 많은 쓰레기 스크롤 ...</target>
        </trans-unit>
        <trans-unit id="1acdc1609c5a5c5aee184b7b1480a7eff0ff9276" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git add myfile.txt&lt;/code&gt; # This will add your file into the to-be-committed list</source>
          <target state="translated">&lt;code&gt;git add myfile.txt&lt;/code&gt; # 커밋 할 목록에 파일을 추가합니다</target>
        </trans-unit>
        <trans-unit id="c54c6007493975e90a3ca44ab3e24e7d01a509e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git add&lt;/code&gt; is just an easier-to-type alias for &lt;code&gt;git stage&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; 는 &lt;code&gt;git stage&lt;/code&gt; 에 대한 유형 지정이 쉬운 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="ab21b608095f7c251b86422efdad49ef7c2d81fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git add&lt;/code&gt;&lt;strong&gt;cannot be undone&lt;/strong&gt; - safely, in general.</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 일반적으로 안전하게 &lt;strong&gt;취소 할 수 없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9438c745003ae0e762d6f7f77c8ecab60c1bba4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git remove&lt;/code&gt; or &lt;code&gt;git rm&lt;/code&gt; can be used for this, with the &lt;code&gt;--cached&lt;/code&gt; flag. Try:</source>
          <target state="translated">이를 위해 &lt;code&gt;--cached&lt;/code&gt; 플래그와 함께 &lt;code&gt;git remove&lt;/code&gt; 또는 &lt;code&gt;git rm&lt;/code&gt; 을 사용할 수 있습니다. 시험:</target>
        </trans-unit>
        <trans-unit id="4c7a1ec8775aac840c46097e441f27c53f5610de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="c51c03e368754a7b1f09d1c5f7bee49a92cbfa59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="50ec6db7e773ae3709a13a5b14923d1b50b3e901" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git status&lt;/code&gt; will tell you if the file was a &lt;strong&gt;new file&lt;/strong&gt; or &lt;strong&gt;modified&lt;/strong&gt;:</source>
          <target state="translated">&lt;code&gt;git status&lt;/code&gt; 는 파일이 &lt;strong&gt;새 파일&lt;/strong&gt; 인지 또는 &lt;strong&gt;수정&lt;/strong&gt; 되었는지 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="00a0309cfbeba7e46054ffe7caa48b634485a5c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update&lt;/em&gt; (what follows is my attempt to clear some confusion that can arise from the most upvoted answers):</source>
          <target state="translated">&lt;em&gt;업데이트&lt;/em&gt; (다음은 가장 많이 답변 된 답변에서 발생할 수있는 혼란을 없애려는 나의 시도입니다) :</target>
        </trans-unit>
        <trans-unit id="ff16db05481cac0fedfa5919d2253aaf2f143851" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BUT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;BUT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9108ede24ec6135336892fdeecab45ae62e7a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explanation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Explanation:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2302eab0fcebad53f7fe95ba2101a333fa1d00b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For a specific file:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;특정 파일의 경우 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="baae462ba9e06c8d31a4aa91cad37676af0c591e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For all added files:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;추가 된 모든 파일 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1465ccbb0b4564f5097966ca2919193d1f830d88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If in doubt, use&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;확실하지 않은 경우&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa264aa22393c616b506a21fbd299dac1de43bae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: Recent Git versions (1.8.4.x) have changed this message:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;참고 : 최근 Git 버전 (1.8.4.x)에서이 메시지가 변경되었습니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0f1f00ebe5ebdad3a6aabf46d37f83fc812361e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Undo&lt;/strong&gt; a file which has already been added is quite easy using Git. For resetting &lt;code&gt;myfile.txt&lt;/code&gt;, which have already been added, use:</source>
          <target state="translated">Git을 사용하면 이미 추가 된 파일을 &lt;strong&gt;취소&lt;/strong&gt; 할 수 있습니다. 이미 추가 된 &lt;code&gt;myfile.txt&lt;/code&gt; 를 재설정하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1fb8ef0b5031857af5f15e998e196dc424e682aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you do &lt;code&gt;git rm --cached file&lt;/code&gt; on a file that was &lt;strong&gt;modified&lt;/strong&gt; (a file that existed before in the repository), then the file will be removed on &lt;code&gt;git commit&lt;/code&gt;! It will still exist in your file system, but if anybody else pulls your commit, the file will be deleted from their work tree.</source>
          <target state="translated">&lt;strong&gt;경고 :&lt;/strong&gt; &lt;strong&gt;수정 된&lt;/strong&gt; 파일 (리포지토리에 존재했던 &lt;code&gt;git rm --cached file&lt;/code&gt; 에서 git rm --cached 파일 을 수행하면 파일은 &lt;code&gt;git commit&lt;/code&gt; 에서 제거됩니다! 파일 시스템에는 여전히 존재하지만 다른 사람이 커밋을 가져 오면 파일이 작업 트리에서 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="08030a8ae7873170e8104d042b1f57d165779ad1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What you did before:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;당신이 전에 한 일 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5eac4758bfc49c3a0acb49f313f4616a585cba86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What you want:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;당신이 원하는 것 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5a77de423f80cead68f5e43d1e4a0387a2d8d293" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;
* (Edit: the above is practically correct, but still there can be some slightly hackish/convoluted ways for recovering changes that were staged, but not committed and then overwritten - see the comments by Johannes Matokic and iolsmit)
&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;* (편집 : 위의 내용은 실제로 정확하지만 단계적이지만 커밋되지 않은 다음 변경 사항을 복구하는 약간의 해킹 / 복잡한 방법이있을 수 있습니다-Johannes Matokic 및 iolsmit의 의견 참조)&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9f25095b6a6bb4281266531ca63ba30aa599fc4b" translate="yes" xml:space="preserve">
          <source>=&amp;gt;    fatal: Failed to resolve 'HEAD' as a valid ref.</source>
          <target state="translated">=&amp;gt; 치명적인 : 'HEAD'를 유효한 참조로 해결하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="da4898c2f54ea719a176ff5921dd10aca02ce86a" translate="yes" xml:space="preserve">
          <source>=&amp;gt; Damn, I didn't want to add all of that.</source>
          <target state="translated">=&amp;gt; 젠장, 나는 그 모든 것을 추가하고 싶지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6d6c3f2ad94a41f4041ea240c5260e20525c26b6" translate="yes" xml:space="preserve">
          <source>=&amp;gt; find Stack Overflow - yay</source>
          <target state="translated">=&amp;gt; 스택 오버플로 찾기-예</target>
        </trans-unit>
        <trans-unit id="88fada2a66189147a4940e978181c511fbd9006b" translate="yes" xml:space="preserve">
          <source>Adding the file you didn't want:</source>
          <target state="translated">원하지 않는 파일 추가 :</target>
        </trans-unit>
        <trans-unit id="ac2fc40f817967b1c978a3c01c367cc9f47bb6bd" translate="yes" xml:space="preserve">
          <source>After you staged unwanted file(s), to undo, you can do &lt;code&gt;git reset&lt;/code&gt;. &lt;code&gt;Head&lt;/code&gt; is head of your file in the local and the last parameter is the name of your file.</source>
          <target state="translated">원하지 않는 파일을 준비한 후 실행 취소하려면 &lt;code&gt;git reset&lt;/code&gt; 을 수행 할 수 있습니다. &lt;code&gt;Head&lt;/code&gt; 는 로컬의 파일 헤드이며 마지막 매개 변수는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="7965e6566c2a6dfd8b1f483d94e6961ce4ada48b" translate="yes" xml:space="preserve">
          <source>An addition to the accepted answer, if your mistakenly-added file was huge, you'll probably notice that, even after removing it from the index with '&lt;code&gt;git reset&lt;/code&gt;', it still seems to occupy space in the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">수락 된 답변 외에도 실수로 추가 된 파일이 &lt;code&gt;git reset&lt;/code&gt; ' git reset '을 사용하여 색인에서 파일을 제거한 후에도 여전히 &lt;code&gt;.git&lt;/code&gt; 디렉토리의 공간을 차지하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="6b6f0fea39bad88bec90965ca02b03874e4b0aa9" translate="yes" xml:space="preserve">
          <source>And finally, we have new commands:</source>
          <target state="translated">마지막으로 새로운 명령이 있습니다.</target>
        </trans-unit>
        <trans-unit id="57a92191e7a1b366bd8881185dab6943347b9092" translate="yes" xml:space="preserve">
          <source>And that the correct solution was right there in the Git status output (which, yes, I glossed over as 'crap)</source>
          <target state="translated">그리고 올바른 해결책은 Git 상태 출력에 있습니다 (예, 나는 '쓰레기'로 빛났습니다)</target>
        </trans-unit>
        <trans-unit id="03eff60d200aefea67d7531d408233d1662e19be" translate="yes" xml:space="preserve">
          <source>And the solution indeed is to use &lt;code&gt;git rm --cached FILE&lt;/code&gt;.</source>
          <target state="translated">그리고 해결책은 실제로 &lt;code&gt;git rm --cached FILE&lt;/code&gt; 을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="268075f19321c5240e6d23fed51ce807fc626fbd" translate="yes" xml:space="preserve">
          <source>And we could also run &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt;. This is in general preferable, because it works in both scenarios: it also does the undo when we wrongly added a version of an already tracked item.</source>
          <target state="translated">그리고 &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; 을 실행할 수도 있습니다. 이는 두 시나리오에서 모두 작동하기 때문에 일반적으로 바람직합니다. 이미 추적 된 항목의 버전을 잘못 추가 한 경우 실행 취소도 수행합니다.</target>
        </trans-unit>
        <trans-unit id="6bf8d249e1267954bd4e230ac9242aecb362ac1b" translate="yes" xml:space="preserve">
          <source>Another advantage of this method is that if you run into line-ending troubles later and need to refresh all your files, it's easy:</source>
          <target state="translated">이 방법의 또 다른 장점은 나중에 줄 끝 문제가 발생하여 모든 파일을 새로 고치면 쉽다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3b3a6f60a94e90679c108bb6eb50b25c24b38dd9" translate="yes" xml:space="preserve">
          <source>As per many of the other answers, you can use &lt;code&gt;git reset&lt;/code&gt;</source>
          <target state="translated">다른 많은 답변에 따라 &lt;code&gt;git reset&lt;/code&gt; 을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="bf659d43d993f36f074044f6a12b23d4a2deeb33" translate="yes" xml:space="preserve">
          <source>Because it does the expected thing in both cases.</source>
          <target state="translated">두 경우 모두 예상되는 작업을 수행하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="318826776dfef14ebad40e776c6f535a9cac2115" translate="yes" xml:space="preserve">
          <source>But there are two caveats.</source>
          <target state="translated">그러나 두 가지 경고가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2228e2a8d5fef35b69908fd4ff6f0f1adc834753" translate="yes" xml:space="preserve">
          <source>Changed a file and used &lt;code&gt;git add .&lt;/code&gt;, or &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">파일을 변경하고 &lt;code&gt;git add .&lt;/code&gt; 또는 &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25f0e487b5c4252d75619b9d995b4ad8f5a9f18a" translate="yes" xml:space="preserve">
          <source>Check out that initial commit.  This will remove all your files.</source>
          <target state="translated">초기 커밋을 확인하십시오. 모든 파일이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="0b7c6acc53e8b3b19e574cbc031b1a080a9327e6" translate="yes" xml:space="preserve">
          <source>Choose option 3 to un add files. In my case I often want to add more than one file, and with interactive mode you can use numbers like this to add files. This will take all but 4: 1, 2, 3, and 5</source>
          <target state="translated">옵션 3을 선택하여 파일을 추가 해제하십시오. 제 경우에는 종종 두 개 이상의 파일을 추가하고 싶습니다. 대화식 모드에서는 이와 같은 숫자를 사용하여 파일을 추가 할 수 있습니다. 4 : 1, 2, 3 및 5를 제외한 모든 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="73e4efc1cb5e56aaa583e6b26d3fa8e1ef793246" translate="yes" xml:space="preserve">
          <source>Commit your .gitignore file.</source>
          <target state="translated">.gitignore 파일을 커밋하십시오.</target>
        </trans-unit>
        <trans-unit id="48ac645e39b09e53f05e3fece1aa2de6c019d279" translate="yes" xml:space="preserve">
          <source>Create the main directory for your new project.</source>
          <target state="translated">새 프로젝트의 기본 디렉토리를 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="4be867dc932c8893ff792e70234e09467c54700c" translate="yes" xml:space="preserve">
          <source>First: There is (as pointed out in the answer) only one scenario in which &lt;code&gt;git reset HEAD&lt;/code&gt; doesn't work, but &lt;code&gt;git rm --cached&lt;/code&gt; does: a new repository (no commits). But, really, this a practically irrelevant case.</source>
          <target state="translated">첫 번째 : &lt;code&gt;git reset HEAD&lt;/code&gt; 가 작동하지 않지만 &lt;code&gt;git rm --cached&lt;/code&gt; 가 수행하는 시나리오는 하나뿐입니다 (커밋 없음). 그러나 실제로 이것은 실제로 관련이없는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="4a2468f3e16dd2cd246730cb5093e54e53053ba5" translate="yes" xml:space="preserve">
          <source>Git has commands for every action imaginable, but it needs extensive knowledge to get things right and because of that it is counter-intuitive at best...</source>
          <target state="translated">힘내 상상할 수있는 모든 행동에 대한 명령을 가지고 있지만, 물건을 올바르게 얻기 위해서는 광범위한 지식이 필요하며 그로 인해 반 직관적입니다 ...</target>
        </trans-unit>
        <trans-unit id="4c6a268d08e28eaee830639b0f6e459f3bfca324" translate="yes" xml:space="preserve">
          <source>Git makes it really hard to do &lt;code&gt;git reset&lt;/code&gt; if you don't have any commits.  If you create a tiny initial commit just for the sake of having one, after that you can &lt;code&gt;git add -A&lt;/code&gt; and &lt;code&gt;git reset&lt;/code&gt; as many times as you want in order to get everything right.</source>
          <target state="translated">Git은 커밋이 없으면 &lt;code&gt;git reset&lt;/code&gt; 을 실제로하기가 어렵습니다. 하나만 가지고 작은 초기 커밋을 만들면 모든 것을 올바르게 얻기 위해 원하는만큼 &lt;code&gt;git add -A&lt;/code&gt; 및 &lt;code&gt;git reset&lt;/code&gt; 을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="91a26e21098c90d8d4e43789b6f34caa5e8cdade" translate="yes" xml:space="preserve">
          <source>Git staging files</source>
          <target state="translated">힘내 준비 파일</target>
        </trans-unit>
        <trans-unit id="dca35e5fe9deec8747cb15a6c2367d2391384044" translate="yes" xml:space="preserve">
          <source>Git will tell you what is staged, etc., including instructions on how to unstage:</source>
          <target state="translated">Git은 스테이지를 해제하는 방법에 대한 지시 사항을 포함하여 스테이지 등을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="5cc928b51e1c3e6d782aa3d3b0519561e6eb9bf9" translate="yes" xml:space="preserve">
          <source>Going into interactive add to undo your add (the commands typed at git here are &quot;r&quot; (revert), &quot;1&quot; (first entry in the list revert shows), 'return' to drop out of revert mode, and &quot;q&quot; (quit):</source>
          <target state="translated">대화식 add로 들어가서 add 명령을 취소하려면 (git에 입력 한 명령은 &quot;r&quot;(revert), &quot;1&quot;(목록 revert가 표시되는 첫 번째 항목), 'return'을 눌러 되돌리기 모드에서 빠져 나오고, &quot;q&quot;) (떠나다):</target>
        </trans-unit>
        <trans-unit id="d2eba6f142b69842b44b13bd3542d53f601ab045" translate="yes" xml:space="preserve">
          <source>Here's a way to avoid this vexing problem when you start a new project:</source>
          <target state="translated">새 프로젝트를 시작할 때이 문제를 피하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8d50c74608fd0e6cdc94bef7514a080111db98a2" translate="yes" xml:space="preserve">
          <source>How do I undo 'git add' before commit</source>
          <target state="translated">커밋하기 전에 'git add'를 실행 취소하는 방법</target>
        </trans-unit>
        <trans-unit id="450c0e272806bac9274b3ed05e1b6bb52640bc2d" translate="yes" xml:space="preserve">
          <source>I created a new file and added it to Git. Then I unstaged it using the Sourcetree GUI.
This is the result:</source>
          <target state="translated">새 파일을 만들어 Git에 추가했습니다. 그런 다음 Sourcetree GUI를 사용하여 스테이지를 해제했습니다. 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a180eb66607dd4df46b1ae9a6f29f86634826e1b" translate="yes" xml:space="preserve">
          <source>I find Git does a pretty good job of nudging me to do the right thing in situations like this.</source>
          <target state="translated">나는 Git이 이런 상황에서 옳은 일을하도록 방해하는 꽤 좋은 일을한다는 것을 알았다.</target>
        </trans-unit>
        <trans-unit id="47ebb8632c5be8c1245f9fd247285152420b2a47" translate="yes" xml:space="preserve">
          <source>I found this great little post that actually adds the Git command (well, an alias) for &lt;code&gt;git unadd&lt;/code&gt;: see &lt;em&gt;&lt;a href=&quot;https://blog.pivotal.io/labs/labs/git-unadd&quot;&gt;git unadd&lt;/a&gt;&lt;/em&gt; for details or..</source>
          <target state="translated">실제로 &lt;code&gt;git unadd&lt;/code&gt; 에 대한 Git 명령 (별명)을 추가하는이 위대한 작은 게시물을 발견했습니다. 자세한 내용은 &lt;em&gt;&lt;a href=&quot;https://blog.pivotal.io/labs/labs/git-unadd&quot;&gt;git unadd&lt;/a&gt;&lt;/em&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="980f2d88ed5717679189772c4a5e6b43c72aa8f8" translate="yes" xml:space="preserve">
          <source>I have created the steps in the image below in more details for you, including all steps which may happen in these cases:</source>
          <target state="translated">아래 이미지에서 이러한 경우에 발생할 수있는 모든 단계를 포함하여 자세한 내용을 아래 단계에서 만들었습니다.</target>
        </trans-unit>
        <trans-unit id="26790ed531042f80782885ad57b1028053449307" translate="yes" xml:space="preserve">
          <source>I have not yet run &lt;code&gt;git commit&lt;/code&gt;. Is there a way to undo this, so these files won't be included in the commit?</source>
          <target state="translated">아직 &lt;code&gt;git commit&lt;/code&gt; 을 실행하지 않았습니다. 이것을 취소 할 수있는 방법이 있습니까? 그래서이 파일들은 커밋에 포함되지 않습니까?</target>
        </trans-unit>
        <trans-unit id="f4d6416f59e901972dc68e4c2645f886d12e39d1" translate="yes" xml:space="preserve">
          <source>I mistakenly added files to Git using the command:</source>
          <target state="translated">명령을 사용하여 실수로 Git에 파일을 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="59a1168cbdd90e679377d656fb08a05cfbc64983" translate="yes" xml:space="preserve">
          <source>I mistakenly added files using the command...</source>
          <target state="translated">명령을 사용하여 실수로 파일을 추가했습니다 ...</target>
        </trans-unit>
        <trans-unit id="2e8728d62406ec2c90bff4af6740b6ca2b39d201" translate="yes" xml:space="preserve">
          <source>I proceed to use</source>
          <target state="translated">사용을 진행합니다</target>
        </trans-unit>
        <trans-unit id="e9128e1ff3de03a54faec72eda56d381de0efeff" translate="yes" xml:space="preserve">
          <source>I zipped up everything to a safe place before trusting &lt;code&gt;git help rm&lt;/code&gt; about the &lt;code&gt;--cached&lt;/code&gt; not destroying anything (and what if I misspelled it).</source>
          <target state="translated">&lt;code&gt;git help rm&lt;/code&gt; 을 신뢰하기 전에 모든 것을 안전한 장소에 압축했습니다.</target>
        </trans-unit>
        <trans-unit id="fcd7314f67163d84c2c9f40329f48cfdb2e19990" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; was &lt;strong&gt;already tracked&lt;/strong&gt;, &lt;code&gt;git add&lt;/code&gt;&lt;strong&gt;saves the current content&lt;/strong&gt; (snapshot, version) to the cache. In Git, this action is still called &lt;strong&gt;add&lt;/strong&gt;, (not mere &lt;em&gt;update&lt;/em&gt; it), because two different versions (snapshots) of a file are regarded as two different items: hence, we are indeed adding a new item to the cache, to be eventually committed later.</source>
          <target state="translated">&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 이 &lt;strong&gt;이미 추적 된&lt;/strong&gt; 경우 &lt;code&gt;git add&lt;/code&gt; &lt;strong&gt;는 현재 컨텐츠&lt;/strong&gt; (스냅 샷, 버전)를 캐시에 저장합니다. Git에서는 파일의 두 가지 버전 (스냅 샷)이 두 개의 다른 항목으로 간주되므로이 작업을 여전히 &lt;strong&gt;add&lt;/strong&gt; 라고 &lt;strong&gt;합니다&lt;/strong&gt; (따라서 &lt;em&gt;업데이트&lt;/em&gt; 하지 않음). 따라서 실제로 캐시에 새 항목을 추가하여 결국에는 나중에 약속했다.</target>
        </trans-unit>
        <trans-unit id="ce05ef547080bdd0c9b4b6d21f9a9cb1212fb4e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; was &lt;strong&gt;not previously tracked&lt;/strong&gt;, &lt;code&gt;git add&lt;/code&gt;&lt;strong&gt;adds it to the cache&lt;/strong&gt;, with its current content.</source>
          <target state="translated">&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 이 &lt;strong&gt;이전에 추적되지 않은&lt;/strong&gt; 경우 &lt;code&gt;git add&lt;/code&gt; &lt;strong&gt;는&lt;/strong&gt; 현재 컨텐츠와 함께이를 &lt;strong&gt;캐시에&lt;/strong&gt; 추가 &lt;strong&gt;합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="9ff00e45e5ffaf135367a1313fb0084d4bdf27c8" translate="yes" xml:space="preserve">
          <source>If you type:</source>
          <target state="translated">입력하면 :</target>
        </trans-unit>
        <trans-unit id="2742bf9d716f8b835566210e331c47572dd4050b" translate="yes" xml:space="preserve">
          <source>If you're on your initial commit and you can't use &lt;code&gt;git reset&lt;/code&gt;, just declare &quot;Git bankruptcy&quot; and delete the &lt;code&gt;.git&lt;/code&gt; folder and start over</source>
          <target state="translated">초기 커밋에 있고 &lt;code&gt;git reset&lt;/code&gt; 을 사용할 수 없다면 &quot;Git 파산&quot;을 선언하고 &lt;code&gt;.git&lt;/code&gt; 폴더를 삭제하고 다시 시작하십시오.</target>
        </trans-unit>
        <trans-unit id="cfa255a467797d7f7b136c29ef62aef20cf72142" translate="yes" xml:space="preserve">
          <source>In Sourcetree you can do this easily via the GUI.
You can check which command Sourcetree uses to unstage a file.</source>
          <target state="translated">Sourcetree에서는 GUI를 통해이를 쉽게 수행 할 수 있습니다. 소스 트리에서 파일을 언 스테이지하는 데 사용하는 명령을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6371392980b92d1512f0ab12ff15fcc9824dcda5" translate="yes" xml:space="preserve">
          <source>In light of this, the question is slightly ambiguous:</source>
          <target state="translated">이것에 비추어, 질문은 약간 모호합니다.</target>
        </trans-unit>
        <trans-unit id="26fded76dcbe21bec020034ef8ae2890f88f0a1e" translate="yes" xml:space="preserve">
          <source>In old versions of Git, the above commands are equivalent to &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; and &lt;code&gt;git reset HEAD&lt;/code&gt; respectively, and will fail if &lt;code&gt;HEAD&lt;/code&gt; is undefined (because you haven't yet made any commits in your repository) or ambiguous (because you created a branch called &lt;code&gt;HEAD&lt;/code&gt;, which is a stupid thing that you shouldn't do). This &lt;a href=&quot;https://git.kernel.org/cgit/git/git.git/tree/Documentation/RelNotes/1.8.2.txt#n179&quot;&gt;was changed in Git 1.8.2&lt;/a&gt;, though, so in modern versions of Git you can use the commands above even prior to making your first commit:</source>
          <target state="translated">이전 버전의 Git에서 위의 명령은 &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; 및 &lt;code&gt;git reset HEAD&lt;/code&gt; 와 각각 동일하며 &lt;code&gt;HEAD&lt;/code&gt; 가 정의되지 않았거나 (저장소에서 커밋하지 않았기 때문에) HEAD 가 정의되지 않은 경우 (실제로 커밋하지 않았기 때문에) 실패합니다. &lt;code&gt;HEAD&lt;/code&gt; 라는 브랜치를 만들었습니다. 그러나 이것은 &lt;a href=&quot;https://git.kernel.org/cgit/git/git.git/tree/Documentation/RelNotes/1.8.2.txt#n179&quot;&gt;Git 1.8.2에서 변경&lt;/a&gt; 되었으므로 최신 버전의 Git에서는 처음 커밋하기 전에도 위 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4051c13ecb202313b56c354bb279d138ec086db7" translate="yes" xml:space="preserve">
          <source>It further turns out that there's &lt;a href=&quot;http://kerneltrap.org/mailarchive/git/2008/2/13/846664/thread&quot;&gt;a bug logged&lt;/a&gt; against the unhelpfulness of this in the mailing list.</source>
          <target state="translated">또한 메일 링리스트에 도움이되지 않는 &lt;a href=&quot;http://kerneltrap.org/mailarchive/git/2008/2/13/846664/thread&quot;&gt;버그가 기록&lt;/a&gt; 되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="155ff3b94a20cc6cfcbf96ffeaf7482107ecbbf9" translate="yes" xml:space="preserve">
          <source>It turns out that this is because the HEAD ref (branch?) doesn't exist until after the first commit. That is, you'll run into the same beginner's problem as me if your workflow, like mine, was something like:</source>
          <target state="translated">HEAD ref (branch?)는 첫 번째 커밋 이후까지 존재하지 않기 때문입니다. 즉, 내 워크 플로가 다음과 같은 경우 초보자와 같은 문제가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="adaaf6d802f465498479a38c637bf662a6522399" translate="yes" xml:space="preserve">
          <source>It will reset your head with that specified file. so, if your head doesn't have it means, it will simply reset it.</source>
          <target state="translated">지정된 파일로 머리를 재설정합니다. 따라서 머리에 의미가 없으면 간단히 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="68c9f4ed13403f924ccc247b10f282e693931120" translate="yes" xml:space="preserve">
          <source>Just type &lt;code&gt;git reset&lt;/code&gt; it will revert back and it is like you never typed &lt;code&gt;git add .&lt;/code&gt; since your last commit. Make sure you have committed before.</source>
          <target state="translated">그냥 &lt;code&gt;git reset&lt;/code&gt; 을 입력하면 되돌릴 것이고 &lt;code&gt;git add .&lt;/code&gt; 입력하지 않은 것과 같습니다 . 마지막 커밋 이후. 전에 커밋했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7e0db4ee366cdc01a3b955e69f4e20c110c2d411" translate="yes" xml:space="preserve">
          <source>Let's recall first what &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt; actually does:</source>
          <target state="translated">&lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt; 이 실제로 무엇을하는지 먼저 생각해 보자 :</target>
        </trans-unit>
        <trans-unit id="cb43fda806b60a9e08edb5a9c0bde80767b52dcb" translate="yes" xml:space="preserve">
          <source>Maybe Git has evolved since you posted your question.</source>
          <target state="translated">아마 Git은 질문을 게시 한 후 진화했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="1894d7e64791aafcdc008bf854895f11545e7eaa" translate="yes" xml:space="preserve">
          <source>Note that if you fail to specify a revision then you have to include a separator. Example from my console:</source>
          <target state="translated">개정을 지정하지 않으면 구분 기호를 포함해야합니다. 내 콘솔의 예 :</target>
        </trans-unit>
        <trans-unit id="af8a3ad1fc0ec3393f35b0cf47135414c3907e84" translate="yes" xml:space="preserve">
          <source>Note the warnings elsewhere here - &lt;code&gt;git rm&lt;/code&gt; deletes your local working copy of the file, but &lt;em&gt;not&lt;/em&gt; if you use &lt;strong&gt;--cached&lt;/strong&gt;.  Here's the result of &lt;code&gt;git help rm&lt;/code&gt;:</source>
          <target state="translated">다른 곳의 경고 &lt;code&gt;git rm&lt;/code&gt; 은 파일의 로컬 작업 복사본을 삭제하지만 &lt;strong&gt;--cached&lt;/strong&gt; 를 사용하는 경우는 삭제 &lt;em&gt;하지 않습니다&lt;/em&gt; . &lt;code&gt;git help rm&lt;/code&gt; 의 결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c72f4a37de00a8bbbe1dbd59f585874fa1e95893" translate="yes" xml:space="preserve">
          <source>Note: &lt;strong&gt;checkout&lt;/strong&gt; changes the code in the files and moves to the last updated (committed) state. &lt;strong&gt;reset&lt;/strong&gt; doesn't change the codes; it just resets the header.</source>
          <target state="translated">참고 : &lt;strong&gt;체크 아웃&lt;/strong&gt; 은 파일의 코드를 변경하고 마지막으로 업데이트 된 (커밋 된) 상태로 이동합니다. &lt;strong&gt;reset&lt;/strong&gt; 은 코드를 변경하지 않습니다. 그냥 헤더를 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="2cbbc1ff0f31adab3c452b40de6f1268e3911cdf" translate="yes" xml:space="preserve">
          <source>Now I want to undo this add, before commit, &lt;code&gt;git reset newFile.txt&lt;/code&gt;:</source>
          <target state="translated">이제 커밋 전에 &lt;code&gt;git reset newFile.txt&lt;/code&gt; 추가를 취소하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="05c7960282989a21ecc187ff2e0d765363c04167" translate="yes" xml:space="preserve">
          <source>Now create a .gitignore file (even if it's empty).</source>
          <target state="translated">이제 비어있는 경우에도 .gitignore 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d289da3aa7916cb38f48d3be42ec0125720bc36a" translate="yes" xml:space="preserve">
          <source>Now you can</source>
          <target state="translated">지금 당신은 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0e24b543e5ac084c629c30b256d5108f69b9af4c" translate="yes" xml:space="preserve">
          <source>Now, you can try:</source>
          <target state="translated">이제 시도해 볼 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6bacde1e5ace7fedf82b742a45f533ea5dbbd8d5" translate="yes" xml:space="preserve">
          <source>Of course, this is not very critical if we just follow the usual lazy workflow of doing 'git add' only for adding new files (case 1), and we update new contents via the commit, &lt;code&gt;git commit -a&lt;/code&gt; command.</source>
          <target state="translated">물론 새 파일을 추가하기 위해 'git add'를 수행하는 일반적인 게으른 워크 플로우를 따르고 (case 1) commit, &lt;code&gt;git commit -a&lt;/code&gt; 명령을 통해 새 내용을 업데이트하는 경우 이것은 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef179165bedaefa2e60e14c1f5b0a3fed59e2b9d" translate="yes" xml:space="preserve">
          <source>Okay, now I'm back to where I started. Next time I'm going to use &lt;code&gt;-n&lt;/code&gt; to do a dry run and see what will be added:</source>
          <target state="translated">이제 시작한 곳으로 돌아갑니다. 다음 번에는 &lt;code&gt;-n&lt;/code&gt; 을 사용하여 드라이 런을 수행하고 추가 할 내용을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="0cb61707635fc5b2b85cc7e318bd0c2eff7bc6b4" translate="yes" xml:space="preserve">
          <source>Personally I use even shorter aliases:</source>
          <target state="translated">개인적으로 나는 더 짧은 별칭을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4e01375f9a0c5e752c6c2ca322f69e1c751c7482" translate="yes" xml:space="preserve">
          <source>Pity there is no &lt;code&gt;git unstage&lt;/code&gt; nor &lt;code&gt;git unadd&lt;/code&gt; commands. The relevant one is harder to guess or remember, but it is pretty obvious:</source>
          <target state="translated">&lt;code&gt;git unstage&lt;/code&gt; 은 git unstage 또는 &lt;code&gt;git unadd&lt;/code&gt; 명령이 없습니다. 관련있는 것은 추측하거나 기억하기가 어렵지만 매우 분명합니다.</target>
        </trans-unit>
        <trans-unit id="13a12243b9912816bf20ff21a06d8b8be5dc8068" translate="yes" xml:space="preserve">
          <source>Quite opposite to this command is,</source>
          <target state="translated">이 명령과는 정반대입니다.</target>
        </trans-unit>
        <trans-unit id="dae6f4177d012c1139923735c568ddf03db59d60" translate="yes" xml:space="preserve">
          <source>Reasoning:</source>
          <target state="translated">Reasoning:</target>
        </trans-unit>
        <trans-unit id="e6c769e8631fe99bc7ceaf82b906459b7e02f9c3" translate="yes" xml:space="preserve">
          <source>Remove &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; from index and versioning, keeping the un-versioned file with changes in working copy:</source>
          <target state="translated">버전이없는 파일을 작업 사본의 변경 사항과 함께 유지하면서 색인 및 버전 관리에서 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="ae5dd6b49f5c3fbe00248e75277ab0bec4e291d2" translate="yes" xml:space="preserve">
          <source>Remove &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; from working copy and versioning completely:</source>
          <target state="translated">작업 사본 및 버전 관리에서 &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; 을 완전히 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="fed077be24eb8eaa204960095370114925bbcac1" translate="yes" xml:space="preserve">
          <source>Remove the file from the index, but keep it versioned and left with uncommitted changes in working copy:</source>
          <target state="translated">색인에서 파일을 제거하되 작업 사본에서 커밋되지 않은 변경 사항을 유지하고 버전을 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="e74a1ace1491f586fe024a5c928549012bbdc769" translate="yes" xml:space="preserve">
          <source>Reset the file to the last state from HEAD, undoing changes and removing them from the index:</source>
          <target state="translated">변경 사항을 취소하고 색인에서 제거하여 HEAD에서 파일을 마지막 상태로 재설정하십시오.</target>
        </trans-unit>
        <trans-unit id="b1b392607deaf29a7e81453e069b7c07a32a6b18" translate="yes" xml:space="preserve">
          <source>Run</source>
          <target state="translated">Run</target>
        </trans-unit>
        <trans-unit id="02dea6db5118caef938b800592b8a5b38b39b70c" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;git init&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git init&lt;/code&gt; 을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="7e78630f4030bbb87b09bdc8ef8eb2b0effda1fd" translate="yes" xml:space="preserve">
          <source>Second: Be aware that &lt;code&gt;git reset HEAD&lt;/code&gt;  can't magically recover the previously cached file contents, it just resynchronises it from the HEAD. If our misguided &lt;code&gt;git add&lt;/code&gt; overwrote a previous staged uncommitted version, we can't recover it. That's why, strictly speaking, we cannot undo [*].</source>
          <target state="translated">둘째 : &lt;code&gt;git reset HEAD&lt;/code&gt; 는 이전에 캐시 된 파일 내용을 마술처럼 복구 할 수 없으며 HEAD에서 다시 동기화합니다. 잘못 안내 된 &lt;code&gt;git add&lt;/code&gt; 가 이전의 단계적 커밋되지 않은 버전을 덮어 쓴 경우 복구 할 수 없습니다. 그렇기 때문에 엄밀히 말하면 [*]를 취소 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="6482098605bc3d53dec5b4352c070381b60cd196" translate="yes" xml:space="preserve">
          <source>Simply,</source>
          <target state="translated">Simply,</target>
        </trans-unit>
        <trans-unit id="66c23519edb800ce7f1ae7d41a7603aad229a1c7" translate="yes" xml:space="preserve">
          <source>So, which is the real &lt;strong&gt;undo&lt;/strong&gt; of &lt;code&gt;git add&lt;/code&gt;?</source>
          <target state="translated">그래서 &lt;code&gt;git add&lt;/code&gt; 의 실제 &lt;strong&gt;실행 취소&lt;/strong&gt; 는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="7a0a709ea65dccc7a4c51af95745b03c4f843454" translate="yes" xml:space="preserve">
          <source>Sourcetree uses &lt;code&gt;reset&lt;/code&gt; to unstage new files.</source>
          <target state="translated">소스 트리는 &lt;code&gt;reset&lt;/code&gt; 을 사용하여 새 파일을 스테이지 해제 합니다.</target>
        </trans-unit>
        <trans-unit id="6c8f7d0c756781e3631fb4f4ea510b736c4722ab" translate="yes" xml:space="preserve">
          <source>Strictly speaking, and if I'm not mistaken: &lt;strong&gt;none&lt;/strong&gt;.</source>
          <target state="translated">엄밀히 말하면, 내가 실수하지 않으면 : &lt;strong&gt;none&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="552594479ca335a75b38e3d8e7bdd7faab39b95c" translate="yes" xml:space="preserve">
          <source>Suppose I add the file accidentally, &lt;code&gt;git add newFile.txt&lt;/code&gt;:</source>
          <target state="translated">실수로 파일을 추가한다고 가정하고 &lt;code&gt;git add newFile.txt&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9b8c3ebc30d10d6817fe9050f1cc51452b3d3228" translate="yes" xml:space="preserve">
          <source>Suppose I create a new file, &lt;code&gt;newFile.txt&lt;/code&gt;:</source>
          <target state="translated">새 파일 &lt;code&gt;newFile.txt&lt;/code&gt; 를 작성한다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="48ddf6e59a4b1f3b87a0c3bfe2a4dc11f44620d7" translate="yes" xml:space="preserve">
          <source>That's it!  Here's your proof, showing that &quot;foo&quot; is back on the untracked list:</source>
          <target state="translated">그게 다야! 다음은 &quot;foo&quot;가 추적되지 않은 목록에 있음을 보여주는 증거입니다.</target>
        </trans-unit>
        <trans-unit id="8958263708a605b83222c7193c08abd8eb1b5018" translate="yes" xml:space="preserve">
          <source>The OP's scenario seems to be the first one (untracked file),  we want the &quot;undo&quot; to remove the file (not just the current contents) from the tracked items. &lt;strong&gt;If&lt;/strong&gt; this is the case, then it's ok to run  &lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">OP의 시나리오는 첫 번째 (추적되지 않은 파일) 것으로 보이며, &quot;실행 취소&quot;를 사용하여 추적 된 항목에서 파일 (현재 내용이 아닌)을 제거하려고합니다. &lt;strong&gt;이 경우&lt;/strong&gt; &lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt; 을 실행해도 됩니다 .</target>
        </trans-unit>
        <trans-unit id="7b3077a7e23f22edb63b9582ee50b4547489abb5" translate="yes" xml:space="preserve">
          <source>The question is not clearly posed. The reason is that &lt;code&gt;git add&lt;/code&gt; has two meanings:</source>
          <target state="translated">문제는 명확하게 제기되지 않습니다. 그 이유는 &lt;code&gt;git add&lt;/code&gt; 에는 두 가지 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="63cdf5c295405f082341c0ae56aecc932dd4667c" translate="yes" xml:space="preserve">
          <source>Then check out your most recent commit again.  This will retrieve fresh copies of your files, using your current line-ending settings.</source>
          <target state="translated">그런 다음 가장 최근 커밋을 다시 확인하십시오. 현재 줄 끝 설정을 사용하여 파일의 새로운 사본을 검색합니다.</target>
        </trans-unit>
        <trans-unit id="45b5f9be123d9d86c58d9dec3dd125558e131647" translate="yes" xml:space="preserve">
          <source>There is also interactive mode:</source>
          <target state="translated">대화식 모드도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3d8e9657b987817fb3c220308e1acc16025156bd" translate="yes" xml:space="preserve">
          <source>This command will unstash your changes:</source>
          <target state="translated">이 명령은 변경 사항을 해제합니다.</target>
        </trans-unit>
        <trans-unit id="fbecbeb1a67335121e9c59db32b75a2ff73e40e7" translate="yes" xml:space="preserve">
          <source>This is needed since &lt;code&gt;git reset --hard HEAD&lt;/code&gt; won't work with single files.</source>
          <target state="translated">이것은 &lt;code&gt;git reset --hard HEAD&lt;/code&gt; 가 단일 파일에서 작동하지 않기 때문에 필요합니다.</target>
        </trans-unit>
        <trans-unit id="78be1b0da3b7e1ea2b2d12e12dd3d30469cfa022" translate="yes" xml:space="preserve">
          <source>This is nothing to be worried about; the file is indeed still in the repository, but only as a &quot;loose object&quot;. It will not be copied to other repositories (via clone, push), and the space will be eventually reclaimed - though perhaps not very soon. If you are anxious, you can run:</source>
          <target state="translated">이것은 걱정할 것이 없습니다. 파일은 실제로 저장소에 있지만 &quot;느슨한 오브젝트&quot;로만 존재합니다. 복제, 푸시를 통해 다른 리포지토리에 복사되지 않으며 결국 공간은 곧 재생됩니다. 불안한 경우 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5dcdedc4b69b304293ee4853c6d1a79b75fafbd7" translate="yes" xml:space="preserve">
          <source>This process is called &lt;em&gt;staging&lt;/em&gt;. So the most natural command to &lt;em&gt;stage&lt;/em&gt; the changes (changed files) is the obvious one:</source>
          <target state="translated">이 프로세스를 &lt;em&gt;준비&lt;/em&gt; 라고합니다. 따라서 변경 사항을 변경하는 가장 자연스러운 명령 (변경된 파일)은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6bb9d50aae0e807f542249cc2247c59911ac39cd" translate="yes" xml:space="preserve">
          <source>This should be what you are looking for.</source>
          <target state="translated">이것은 당신이 찾고있는 것이어야합니다.</target>
        </trans-unit>
        <trans-unit id="16b0d869d782ecce087a08191cd6576c501a0143" translate="yes" xml:space="preserve">
          <source>To choose a sequence, just type 1-5 to take all from 1 to 5.</source>
          <target state="translated">순서를 선택하려면 1-5를 입력하여 1에서 5까지를 모두 취하십시오.</target>
        </trans-unit>
        <trans-unit id="9d60018f1a5334d24aeca0c7d89c5867b612205d" translate="yes" xml:space="preserve">
          <source>To clarify: &lt;code&gt;git add&lt;/code&gt; moves changes from the current working directory to the &lt;em&gt;staging area&lt;/em&gt; (index).</source>
          <target state="translated">명확히하기 위해 : &lt;code&gt;git add&lt;/code&gt; 는 현재 작업 디렉토리에서 &lt;em&gt;스테이징 영역&lt;/em&gt; (인덱스)으로 변경 사항을 이동합니다.</target>
        </trans-unit>
        <trans-unit id="515c85f04427e465b01ddaa8b4eed764826e3289" translate="yes" xml:space="preserve">
          <source>To remove new files from the staging area (and only in case of a new file), as suggested above:</source>
          <target state="translated">위에서 제안한대로 준비 영역에서 새 파일을 제거하려면 (새 파일의 경우에만) :</target>
        </trans-unit>
        <trans-unit id="4c2db952152ad41554b645a8de14e0d96cee28e3" translate="yes" xml:space="preserve">
          <source>To reset every file in a particular folder (and its subfolders), you can use the following command:</source>
          <target state="translated">특정 폴더 (및 해당 하위 폴더)의 모든 파일을 재설정하려면 다음 명령을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a6d02a83dd13f67c2c894d293c482fbefff8376" translate="yes" xml:space="preserve">
          <source>To undo &lt;code&gt;git add&lt;/code&gt;, use:</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; 를 실행 취소하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fa1dcc9ecc36eb2fd6956b02179caec720b1c11b" translate="yes" xml:space="preserve">
          <source>Unstaging files [08/12/15 10:43]
  git -c diff.mnemonicprefix=false -c core.quotepath=false -c credential.helper=sourcetree reset -q -- path/to/file/filename.java</source>
          <target state="translated">준비 파일 [08/12/15 10:43] git -c diff.mnemonicprefix = false -c core.quotepath = false -c credential.helper = sourcetree reset -q-경로 /to/file/filename.java</target>
        </trans-unit>
        <trans-unit id="056701c16429c2b69fe63426e25dcd6aa3557661" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git add -i&lt;/code&gt; to remove just-added files from your upcoming commit.  Example:</source>
          <target state="translated">다음 커밋에서 방금 추가 한 파일을 제거하려면 &lt;code&gt;git add -i&lt;/code&gt; 를 사용하십시오. 예:</target>
        </trans-unit>
        <trans-unit id="f877b9fe8d4d292f783a2224c88efb437d28d091" translate="yes" xml:space="preserve">
          <source>Use rm --cached only for new files accidentally added.</source>
          <target state="translated">실수로 추가 한 새 파일에 대해서만 rm --cached를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="b3c520b0adfc4612c5f13f20487496d48ab36887" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;*&lt;/code&gt; command to handle multiple files at a time:</source>
          <target state="translated">한 번에 여러 파일을 처리하려면 &lt;code&gt;*&lt;/code&gt; 명령을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="924703164da00b7444edd64fb60fcbb8c3162ce5" translate="yes" xml:space="preserve">
          <source>We can easily create an alias for this:</source>
          <target state="translated">이에 대한 별칭을 쉽게 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbed8dcb33376bb1d53e3675a03c7fa2ea7c9fe5" translate="yes" xml:space="preserve">
          <source>When I was new to this, I first tried</source>
          <target state="translated">내가 이것을 처음 접했을 때, 나는 처음 시도했다</target>
        </trans-unit>
        <trans-unit id="eedeb18aad137a7f9d3e048a4943d3e6769cc920" translate="yes" xml:space="preserve">
          <source>Will remove a file named filename.txt from the current index, the &quot;about to be committed&quot; area, without changing anything else.</source>
          <target state="translated">다른 것을 변경하지 않고 현재 색인에서 &quot;약속 예정&quot;영역의 filename.txt라는 파일을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">당신은 또한 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="80087849dfcee0e85f78d0320eb186d09742ee66" translate="yes" xml:space="preserve">
          <source>You can undo &lt;code&gt;git add&lt;/code&gt; before commit with</source>
          <target state="translated">커밋하기 전에 &lt;code&gt;git add&lt;/code&gt; 명령을 취소 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">당신이 사용할 수있는</target>
        </trans-unit>
        <trans-unit id="a0815200bea1a60432e0d4fb69db34bfd8e2c698" translate="yes" xml:space="preserve">
          <source>You want:</source>
          <target state="translated">당신이 원하는 :</target>
        </trans-unit>
        <trans-unit id="d8dcb8d55fececafb2c68ba7044ee1b772419651" translate="yes" xml:space="preserve">
          <source>adding a &lt;strong&gt;modified&lt;/strong&gt; file to the staging area, then undo with &lt;code&gt;git reset HEAD file&lt;/code&gt;.</source>
          <target state="translated">스테이징 영역에 &lt;strong&gt;수정 된&lt;/strong&gt; 파일을 추가 한 다음 &lt;code&gt;git reset HEAD file&lt;/code&gt; 을 사용 하여 실행 취소 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d473aa440edb561b8723fe71085cf8f567b0af0" translate="yes" xml:space="preserve">
          <source>adding a &lt;strong&gt;new file&lt;/strong&gt; to the staging area, then undo with &lt;code&gt;git rm --cached file&lt;/code&gt;.</source>
          <target state="translated">준비 영역에 &lt;strong&gt;새 파일&lt;/strong&gt; 을 추가 한 다음 &lt;code&gt;git rm --cached file&lt;/code&gt; 으로 실행 취소 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4fb062fcfd7c48b01f50e3d39fe6e21fd78aec1b" translate="yes" xml:space="preserve">
          <source>and remove all the files manually or by selecting all of them and clicking on the &lt;em&gt;unstage from commit&lt;/em&gt; button.</source>
          <target state="translated">수동으로 또는 모든 파일을 선택하고 &lt;em&gt;커밋&lt;/em&gt; 에서 &lt;em&gt;언 스테이지&lt;/em&gt; 버튼을 클릭하여 모든 파일을 제거하십시오.</target>
        </trans-unit>
        <trans-unit id="4f3a7ccc2fff02e760b79353f269bbf29121de43" translate="yes" xml:space="preserve">
          <source>cd to my great new project directory to try out Git, the new hotness</source>
          <target state="translated">내 새 프로젝트 디렉토리로 이동하여 Git을 시험해 보자.</target>
        </trans-unit>
        <trans-unit id="fb7f7c94028fe09a6d2d9b3bf0b8501eb7095619" translate="yes" xml:space="preserve">
          <source>etc.</source>
          <target state="translated">etc.</target>
        </trans-unit>
        <trans-unit id="79986d4e639d0773bd127e19458b07f55b1bfc8c" translate="yes" xml:space="preserve">
          <source>git checkout .</source>
          <target state="translated">git checkout.</target>
        </trans-unit>
        <trans-unit id="15cba6d4879c1734e4422bdc03b13a6b93611534" translate="yes" xml:space="preserve">
          <source>git checkout my_file.txt</source>
          <target state="translated">자식 체크 아웃 my_file.txt</target>
        </trans-unit>
        <trans-unit id="801b883972ec8ef1236eb019443c886dcf6750a7" translate="yes" xml:space="preserve">
          <source>git reset .</source>
          <target state="translated">git reset.</target>
        </trans-unit>
        <trans-unit id="94f60eb54806996b7e1222363ba5dc870eddd539" translate="yes" xml:space="preserve">
          <source>git reset my_file.txt</source>
          <target state="translated">자식 재설정 my_file.txt</target>
        </trans-unit>
        <trans-unit id="25aab1fe6dec61e754487a291c40fdda95b4be44" translate="yes" xml:space="preserve">
          <source>google &quot;undo git add&quot;</source>
          <target state="translated">구글 &quot;실행 취소 git add&quot;</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="5712023340e6a2d05ce05ba84935a0ac55f18949" translate="yes" xml:space="preserve">
          <source>so, you will be in the previous state. Specified will be again in untracked list (previous state).</source>
          <target state="translated">따라서 이전 상태에있게됩니다. 지정되지 않은 목록에 다시 지정됩니다 (이전 상태).</target>
        </trans-unit>
        <trans-unit id="0d19f5a79e1fc6cc465c4d08247b4439056a1cad" translate="yes" xml:space="preserve">
          <source>to add parts of files.</source>
          <target state="translated">파일의 일부를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5f5d8b5a3e74af731dcc9b939e21d7235ca21741" translate="yes" xml:space="preserve">
          <source>to remove everything and start again. Didn't work though, because while &lt;code&gt;add .&lt;/code&gt; is recursive, turns out &lt;code&gt;rm&lt;/code&gt; needs &lt;code&gt;-r&lt;/code&gt; to recurse. Sigh.</source>
          <target state="translated">모든 것을 제거하고 다시 시작하십시오. &lt;code&gt;add .&lt;/code&gt; 동안 때문에 작동하지 않았습니다 . 재귀 적이며, 재귀하기 위해 &lt;code&gt;rm&lt;/code&gt; 필요 &lt;code&gt;-r&lt;/code&gt; 을 나타냅니다. 한숨.</target>
        </trans-unit>
        <trans-unit id="0e01177e2865564bc5a2bd0273597bbf76768708" translate="yes" xml:space="preserve">
          <source>which will remove it from the current index (the &quot;about to be committed&quot; list) without changing anything else.</source>
          <target state="translated">다른 것을 변경하지 않고 현재 색인 ( &quot;커밋 예정&quot;목록)에서 제거합니다.</target>
        </trans-unit>
        <trans-unit id="22a56ae9ed58d1e164446e8aefe9c47c81c380ad" translate="yes" xml:space="preserve">
          <source>will &quot;un-add&quot; everything you've added from your current directory recursively</source>
          <target state="translated">현재 디렉토리에서 추가 한 모든 내용을 재귀 적으로 &quot;추가 취소&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="aaaa9d584e39a7eb22d6030fa5ce40df98b7224d" translate="yes" xml:space="preserve">
          <source>without any file name to unstage all due changes. This can come in handy when there are too many files to be listed one by one in a reasonable amount of time.</source>
          <target state="translated">파일 이름이 없어서 모든 변경 사항을 취소 할 수 있습니다. 합리적인 시간에 하나씩 나열 할 파일이 너무 많을 때 유용합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
