<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/348170">
    <body>
      <group id="348170">
        <trans-unit id="a605ebe1bbc70a2f5d68414542aedbb8267ea552" translate="yes" xml:space="preserve">
          <source>&quot;git reset&quot; (without options or parameters) used to error out when
     you do not have any commits in your history, but it now gives you
     an empty index (to match non-existent commit you are not even on).</source>
          <target state="translated">&quot;git reset&quot; (オプションやパラメータを指定せずに)は、履歴にコミットがない場合にエラーになっていましたが、今では空のインデックスを返してくれます (存在しないコミットにマッチするように)。</target>
        </trans-unit>
        <trans-unit id="9d73d958a4a57f88de8c532a185785e528960fba" translate="yes" xml:space="preserve">
          <source>(Git version 1.7.5.4)</source>
          <target state="translated">(Git バージョン 1.7.5.4)</target>
        </trans-unit>
        <trans-unit id="2ea3a7ae6a49dbe40036ba23b01afd89047ef957" translate="yes" xml:space="preserve">
          <source>(to undo my entire initial add), only to get this (not so) helpful message:</source>
          <target state="translated">(最初の追加をすべて元に戻すために)、この(それほどではありませんが)参考になるメッセージを得るためだけに。</target>
        </trans-unit>
        <trans-unit id="d484bc11f9473ac3628a251e12abb3c9d00e2f4d" translate="yes" xml:space="preserve">
          <source>--cached
      Use this option to unstage and remove paths only from the index.
      Working tree files, whether modified or not, will be left.</source>
          <target state="translated">--cached このオプションを使って、ステージを解除してインデックスからパスのみを削除します。作業木ファイルは、変更されているかどうかに関わらず、残されます。</target>
        </trans-unit>
        <trans-unit id="571355642f9e433222dd5df921a319db3ef42095" translate="yes" xml:space="preserve">
          <source>... lots of crap scrolls by ...</source>
          <target state="translated">くだらない巻物が多い</target>
        </trans-unit>
        <trans-unit id="1acdc1609c5a5c5aee184b7b1480a7eff0ff9276" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git add myfile.txt&lt;/code&gt; # This will add your file into the to-be-committed list</source>
          <target state="translated">&lt;code&gt;git add myfile.txt&lt;/code&gt; ＃これにより、ファイルがコミットされるリストに追加されます</target>
        </trans-unit>
        <trans-unit id="c54c6007493975e90a3ca44ab3e24e7d01a509e1" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git add&lt;/code&gt; is just an easier-to-type alias for &lt;code&gt;git stage&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; は &lt;code&gt;git stage&lt;/code&gt; タイプしやすいエイリアスです</target>
        </trans-unit>
        <trans-unit id="ab21b608095f7c251b86422efdad49ef7c2d81fd" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git add&lt;/code&gt;&lt;strong&gt;cannot be undone&lt;/strong&gt; - safely, in general.</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; &lt;strong&gt;は元に戻すことはできません&lt;/strong&gt; -一般的には安全です。</target>
        </trans-unit>
        <trans-unit id="9438c745003ae0e762d6f7f77c8ecab60c1bba4f" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git remove&lt;/code&gt; or &lt;code&gt;git rm&lt;/code&gt; can be used for this, with the &lt;code&gt;--cached&lt;/code&gt; flag. Try:</source>
          <target state="translated">&lt;code&gt;--cached&lt;/code&gt; フラグを指定すると、 &lt;code&gt;git remove&lt;/code&gt; または &lt;code&gt;git rm&lt;/code&gt; を使用できます。 試してください：</target>
        </trans-unit>
        <trans-unit id="4c7a1ec8775aac840c46097e441f27c53f5610de" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; ?</source>
          <target state="translated">&lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="c51c03e368754a7b1f09d1c5f7bee49a92cbfa59" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt;?</source>
          <target state="translated">&lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt; ？</target>
        </trans-unit>
        <trans-unit id="50ec6db7e773ae3709a13a5b14923d1b50b3e901" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;git status&lt;/code&gt; will tell you if the file was a &lt;strong&gt;new file&lt;/strong&gt; or &lt;strong&gt;modified&lt;/strong&gt;:</source>
          <target state="translated">&lt;code&gt;git status&lt;/code&gt; は、ファイルが&lt;strong&gt;新しいファイルである&lt;/strong&gt;か、 &lt;strong&gt;変更され&lt;/strong&gt;たかを通知します。</target>
        </trans-unit>
        <trans-unit id="00a0309cfbeba7e46054ffe7caa48b634485a5c3" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Update&lt;/em&gt; (what follows is my attempt to clear some confusion that can arise from the most upvoted answers):</source>
          <target state="translated">&lt;em&gt;更新&lt;/em&gt; （以下は、最も投票された回答から生じる可能性のある混乱を解消するための私の試みです）：</target>
        </trans-unit>
        <trans-unit id="ff16db05481cac0fedfa5919d2253aaf2f143851" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BUT:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;BUT:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a9108ede24ec6135336892fdeecab45ae62e7a84" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Explanation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Explanation:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2302eab0fcebad53f7fe95ba2101a333fa1d00b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For a specific file:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;特定のファイルの場合：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="baae462ba9e06c8d31a4aa91cad37676af0c591e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;For all added files:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;追加されたすべてのファイル：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1465ccbb0b4564f5097966ca2919193d1f830d88" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;If in doubt, use&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;疑わしい場合は、&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa264aa22393c616b506a21fbd299dac1de43bae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note: Recent Git versions (1.8.4.x) have changed this message:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;注：最近のGitバージョン（1.8.4.x）では、このメッセージが変更されています。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e0f1f00ebe5ebdad3a6aabf46d37f83fc812361e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Undo&lt;/strong&gt; a file which has already been added is quite easy using Git. For resetting &lt;code&gt;myfile.txt&lt;/code&gt;, which have already been added, use:</source>
          <target state="translated">すでに追加されているファイルを&lt;strong&gt;元に戻すのは&lt;/strong&gt; 、Gitを使用すると非常に簡単です。 追加済みの &lt;code&gt;myfile.txt&lt;/code&gt; をリセットするには、次を使用します。</target>
        </trans-unit>
        <trans-unit id="1fb8ef0b5031857af5f15e998e196dc424e682aa" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Warning:&lt;/strong&gt; if you do &lt;code&gt;git rm --cached file&lt;/code&gt; on a file that was &lt;strong&gt;modified&lt;/strong&gt; (a file that existed before in the repository), then the file will be removed on &lt;code&gt;git commit&lt;/code&gt;! It will still exist in your file system, but if anybody else pulls your commit, the file will be deleted from their work tree.</source>
          <target state="translated">&lt;strong&gt;警告：&lt;/strong&gt; &lt;strong&gt;変更され&lt;/strong&gt;たファイル（以前にリポジトリに存在していたファイル）に対して &lt;code&gt;git rm --cached file&lt;/code&gt; を実行すると、そのファイルは &lt;code&gt;git commit&lt;/code&gt; 時に削除されます！ それはまだファイルシステムに存在しますが、他の誰かがコミットをプルした場合、ファイルは作業ツリーから削除されます。</target>
        </trans-unit>
        <trans-unit id="08030a8ae7873170e8104d042b1f57d165779ad1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What you did before:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;以前に行ったこと：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5eac4758bfc49c3a0acb49f313f4616a585cba86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;What you want:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;あなたが欲しいもの：&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5a77de423f80cead68f5e43d1e4a0387a2d8d293" translate="yes" xml:space="preserve">
          <source>&lt;sup&gt;
* (Edit: the above is practically correct, but still there can be some slightly hackish/convoluted ways for recovering changes that were staged, but not committed and then overwritten - see the comments by Johannes Matokic and iolsmit)
&lt;/sup&gt;</source>
          <target state="translated">&lt;sup&gt;*（編集：上記は実質的に正しいですが、ステージングされたがコミットされずに上書きされた変更を回復するための少しハック/複雑な方法がまだある可能性があります-Johannes Matokicとiolsmitによるコメントを参照してください）&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="9f25095b6a6bb4281266531ca63ba30aa599fc4b" translate="yes" xml:space="preserve">
          <source>=&amp;gt;    fatal: Failed to resolve 'HEAD' as a valid ref.</source>
          <target state="translated">=&amp;gt; fatal： 'HEAD'を有効な参照として解決できませんでした。</target>
        </trans-unit>
        <trans-unit id="da4898c2f54ea719a176ff5921dd10aca02ce86a" translate="yes" xml:space="preserve">
          <source>=&amp;gt; Damn, I didn't want to add all of that.</source>
          <target state="translated">=&amp;gt;くそー、私はそれをすべて追加したくありませんでした。</target>
        </trans-unit>
        <trans-unit id="6d6c3f2ad94a41f4041ea240c5260e20525c26b6" translate="yes" xml:space="preserve">
          <source>=&amp;gt; find Stack Overflow - yay</source>
          <target state="translated">=&amp;gt;スタックオーバーフローを検索-はい</target>
        </trans-unit>
        <trans-unit id="88fada2a66189147a4940e978181c511fbd9006b" translate="yes" xml:space="preserve">
          <source>Adding the file you didn't want:</source>
          <target state="translated">欲しくなかったファイルを追加しました。</target>
        </trans-unit>
        <trans-unit id="ac2fc40f817967b1c978a3c01c367cc9f47bb6bd" translate="yes" xml:space="preserve">
          <source>After you staged unwanted file(s), to undo, you can do &lt;code&gt;git reset&lt;/code&gt;. &lt;code&gt;Head&lt;/code&gt; is head of your file in the local and the last parameter is the name of your file.</source>
          <target state="translated">不要なファイルをステージングした後、元に戻すには、 &lt;code&gt;git reset&lt;/code&gt; を実行できます。 &lt;code&gt;Head&lt;/code&gt; はローカルでのファイルのヘッドであり、最後のパラメーターはファイルの名前です。</target>
        </trans-unit>
        <trans-unit id="7965e6566c2a6dfd8b1f483d94e6961ce4ada48b" translate="yes" xml:space="preserve">
          <source>An addition to the accepted answer, if your mistakenly-added file was huge, you'll probably notice that, even after removing it from the index with '&lt;code&gt;git reset&lt;/code&gt;', it still seems to occupy space in the &lt;code&gt;.git&lt;/code&gt; directory.</source>
          <target state="translated">受け入れられた回答に加えて、誤って追加したファイルが大きい場合、 ' &lt;code&gt;git reset&lt;/code&gt; 'を使用してインデックスから削除した後でも、 &lt;code&gt;.git&lt;/code&gt; ディレクトリのスペースを占有しているように見えることにおそらく気付くでしょう。</target>
        </trans-unit>
        <trans-unit id="6b6f0fea39bad88bec90965ca02b03874e4b0aa9" translate="yes" xml:space="preserve">
          <source>And finally, we have new commands:</source>
          <target state="translated">そして、最後に新しいコマンドを用意しました。</target>
        </trans-unit>
        <trans-unit id="57a92191e7a1b366bd8881185dab6943347b9092" translate="yes" xml:space="preserve">
          <source>And that the correct solution was right there in the Git status output (which, yes, I glossed over as 'crap)</source>
          <target state="translated">そして、正しい解決策はGitのステータス出力の中にありました。</target>
        </trans-unit>
        <trans-unit id="03eff60d200aefea67d7531d408233d1662e19be" translate="yes" xml:space="preserve">
          <source>And the solution indeed is to use &lt;code&gt;git rm --cached FILE&lt;/code&gt;.</source>
          <target state="translated">そして実際の解決策は &lt;code&gt;git rm --cached FILE&lt;/code&gt; を使用することです。</target>
        </trans-unit>
        <trans-unit id="268075f19321c5240e6d23fed51ce807fc626fbd" translate="yes" xml:space="preserve">
          <source>And we could also run &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt;. This is in general preferable, because it works in both scenarios: it also does the undo when we wrongly added a version of an already tracked item.</source>
          <target state="translated">そして &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; を実行することもできます 。 これは、両方のシナリオで機能するため、一般的に望ましい方法です。既に追跡されているアイテムのバージョンを誤って追加した場合にも、元に戻すことができます。</target>
        </trans-unit>
        <trans-unit id="6bf8d249e1267954bd4e230ac9242aecb362ac1b" translate="yes" xml:space="preserve">
          <source>Another advantage of this method is that if you run into line-ending troubles later and need to refresh all your files, it's easy:</source>
          <target state="translated">この方法のもう一つの利点は、後になってラインエンディングのトラブルに遭遇して、すべてのファイルをリフレッシュする必要がある場合、それは簡単です。</target>
        </trans-unit>
        <trans-unit id="3b3a6f60a94e90679c108bb6eb50b25c24b38dd9" translate="yes" xml:space="preserve">
          <source>As per many of the other answers, you can use &lt;code&gt;git reset&lt;/code&gt;</source>
          <target state="translated">他の多くの回答と同様に、 &lt;code&gt;git reset&lt;/code&gt; を使用できます</target>
        </trans-unit>
        <trans-unit id="bf659d43d993f36f074044f6a12b23d4a2deeb33" translate="yes" xml:space="preserve">
          <source>Because it does the expected thing in both cases.</source>
          <target state="translated">どちらの場合も期待通りのことをするからです。</target>
        </trans-unit>
        <trans-unit id="318826776dfef14ebad40e776c6f535a9cac2115" translate="yes" xml:space="preserve">
          <source>But there are two caveats.</source>
          <target state="translated">しかし、2つの注意点があります。</target>
        </trans-unit>
        <trans-unit id="2228e2a8d5fef35b69908fd4ff6f0f1adc834753" translate="yes" xml:space="preserve">
          <source>Changed a file and used &lt;code&gt;git add .&lt;/code&gt;, or &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">ファイルを変更し、 &lt;code&gt;git add .&lt;/code&gt; を使用しました。 、または &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="25f0e487b5c4252d75619b9d995b4ad8f5a9f18a" translate="yes" xml:space="preserve">
          <source>Check out that initial commit.  This will remove all your files.</source>
          <target state="translated">最初のコミットを確認してください。これですべてのファイルが削除されます。</target>
        </trans-unit>
        <trans-unit id="0b7c6acc53e8b3b19e574cbc031b1a080a9327e6" translate="yes" xml:space="preserve">
          <source>Choose option 3 to un add files. In my case I often want to add more than one file, and with interactive mode you can use numbers like this to add files. This will take all but 4: 1, 2, 3, and 5</source>
          <target state="translated">オプション3を選択してファイルの追加を解除します。私の場合、複数のファイルを追加したいことが多いのですが、インタラクティブモードではこのように数字を使ってファイルを追加することができます。これは4以外のすべてのファイルを取ります:1,2,3,5</target>
        </trans-unit>
        <trans-unit id="73e4efc1cb5e56aaa583e6b26d3fa8e1ef793246" translate="yes" xml:space="preserve">
          <source>Commit your .gitignore file.</source>
          <target state="translated">.gitignore ファイルをコミットします。</target>
        </trans-unit>
        <trans-unit id="48ac645e39b09e53f05e3fece1aa2de6c019d279" translate="yes" xml:space="preserve">
          <source>Create the main directory for your new project.</source>
          <target state="translated">新しいプロジェクトのメインディレクトリを作成します。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="4be867dc932c8893ff792e70234e09467c54700c" translate="yes" xml:space="preserve">
          <source>First: There is (as pointed out in the answer) only one scenario in which &lt;code&gt;git reset HEAD&lt;/code&gt; doesn't work, but &lt;code&gt;git rm --cached&lt;/code&gt; does: a new repository (no commits). But, really, this a practically irrelevant case.</source>
          <target state="translated">最初：（回答で指摘されているように） &lt;code&gt;git reset HEAD&lt;/code&gt; が機能しないシナリオは1つだけですが、 &lt;code&gt;git rm --cached&lt;/code&gt; は機能します：新しいリポジトリ（コミットなし）。 しかし、実際には、これは実際には無関係なケースです。</target>
        </trans-unit>
        <trans-unit id="4a2468f3e16dd2cd246730cb5093e54e53053ba5" translate="yes" xml:space="preserve">
          <source>Git has commands for every action imaginable, but it needs extensive knowledge to get things right and because of that it is counter-intuitive at best...</source>
          <target state="translated">Git には想像できるすべてのアクションのためのコマンドがありますが、物事を正しく進めるためには広範な知識が必要で、せいぜい直観的ではありません...。</target>
        </trans-unit>
        <trans-unit id="4c6a268d08e28eaee830639b0f6e459f3bfca324" translate="yes" xml:space="preserve">
          <source>Git makes it really hard to do &lt;code&gt;git reset&lt;/code&gt; if you don't have any commits.  If you create a tiny initial commit just for the sake of having one, after that you can &lt;code&gt;git add -A&lt;/code&gt; and &lt;code&gt;git reset&lt;/code&gt; as many times as you want in order to get everything right.</source>
          <target state="translated">コミットがない場合、 &lt;code&gt;git reset&lt;/code&gt; はgit resetを実行することを本当に難しくします。 コミットするためだけに小さな初期コミットを作成した場合、その後、すべてを正しくするために &lt;code&gt;git add -A&lt;/code&gt; と &lt;code&gt;git reset&lt;/code&gt; を何度でも実行できます。</target>
        </trans-unit>
        <trans-unit id="91a26e21098c90d8d4e43789b6f34caa5e8cdade" translate="yes" xml:space="preserve">
          <source>Git staging files</source>
          <target state="translated">Git のステージングファイル</target>
        </trans-unit>
        <trans-unit id="dca35e5fe9deec8747cb15a6c2367d2391384044" translate="yes" xml:space="preserve">
          <source>Git will tell you what is staged, etc., including instructions on how to unstage:</source>
          <target state="translated">Gitでは、ステージの解除方法なども含めて、何がステージされているのかを教えてくれます。</target>
        </trans-unit>
        <trans-unit id="5cc928b51e1c3e6d782aa3d3b0519561e6eb9bf9" translate="yes" xml:space="preserve">
          <source>Going into interactive add to undo your add (the commands typed at git here are &quot;r&quot; (revert), &quot;1&quot; (first entry in the list revert shows), 'return' to drop out of revert mode, and &quot;q&quot; (quit):</source>
          <target state="translated">追加を元に戻すためにインタラクティブaddに入る(ここでgitで入力したコマンドは「r」(revert)、「1」(リストの最初のエントリがrevertで表示される)、revertモードからドロップアウトするための「return」、そして「q」(quit)です。</target>
        </trans-unit>
        <trans-unit id="d2eba6f142b69842b44b13bd3542d53f601ab045" translate="yes" xml:space="preserve">
          <source>Here's a way to avoid this vexing problem when you start a new project:</source>
          <target state="translated">新しいプロジェクトを始めるときに、このつらつらした問題を回避する方法をご紹介します。</target>
        </trans-unit>
        <trans-unit id="8d50c74608fd0e6cdc94bef7514a080111db98a2" translate="yes" xml:space="preserve">
          <source>How do I undo 'git add' before commit</source>
          <target state="translated">コミット前に 'git add' を元に戻すにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="450c0e272806bac9274b3ed05e1b6bb52640bc2d" translate="yes" xml:space="preserve">
          <source>I created a new file and added it to Git. Then I unstaged it using the Sourcetree GUI.
This is the result:</source>
          <target state="translated">新しいファイルを作成してGitに追加しました。それからSourcetree GUIを使ってアンステージしました。その結果がこれです。</target>
        </trans-unit>
        <trans-unit id="a180eb66607dd4df46b1ae9a6f29f86634826e1b" translate="yes" xml:space="preserve">
          <source>I find Git does a pretty good job of nudging me to do the right thing in situations like this.</source>
          <target state="translated">このような状況で正しいことをするように、Gitは私を後押ししてくれます。</target>
        </trans-unit>
        <trans-unit id="47ebb8632c5be8c1245f9fd247285152420b2a47" translate="yes" xml:space="preserve">
          <source>I found this great little post that actually adds the Git command (well, an alias) for &lt;code&gt;git unadd&lt;/code&gt;: see &lt;em&gt;&lt;a href=&quot;https://blog.pivotal.io/labs/labs/git-unadd&quot;&gt;git unadd&lt;/a&gt;&lt;/em&gt; for details or..</source>
          <target state="translated">私は実際に &lt;code&gt;git unadd&lt;/code&gt; のGitコマンド（まあ、エイリアス）を追加するこの素晴らしい小さな投稿を見つけました。詳細については&lt;em&gt;&lt;a href=&quot;https://blog.pivotal.io/labs/labs/git-unadd&quot;&gt;git unadd&lt;/a&gt;&lt;/em&gt;を参照してください。</target>
        </trans-unit>
        <trans-unit id="980f2d88ed5717679189772c4a5e6b43c72aa8f8" translate="yes" xml:space="preserve">
          <source>I have created the steps in the image below in more details for you, including all steps which may happen in these cases:</source>
          <target state="translated">このような場合に起こりうるすべてのステップを含めて、下の画像のステップをあなたのために詳細に作成しました。</target>
        </trans-unit>
        <trans-unit id="26790ed531042f80782885ad57b1028053449307" translate="yes" xml:space="preserve">
          <source>I have not yet run &lt;code&gt;git commit&lt;/code&gt;. Is there a way to undo this, so these files won't be included in the commit?</source>
          <target state="translated">まだ &lt;code&gt;git commit&lt;/code&gt; を実行していません。 これを元に戻す方法はあるので、これらのファイルはコミットに含まれませんか？</target>
        </trans-unit>
        <trans-unit id="f4d6416f59e901972dc68e4c2645f886d12e39d1" translate="yes" xml:space="preserve">
          <source>I mistakenly added files to Git using the command:</source>
          <target state="translated">コマンドを使って間違ってGitにファイルを追加してしまいました。</target>
        </trans-unit>
        <trans-unit id="59a1168cbdd90e679377d656fb08a05cfbc64983" translate="yes" xml:space="preserve">
          <source>I mistakenly added files using the command...</source>
          <target state="translated">間違ってコマンドを使ってファイルを追加してしまいました...。</target>
        </trans-unit>
        <trans-unit id="2e8728d62406ec2c90bff4af6740b6ca2b39d201" translate="yes" xml:space="preserve">
          <source>I proceed to use</source>
          <target state="translated">を使用するように進みます。</target>
        </trans-unit>
        <trans-unit id="e9128e1ff3de03a54faec72eda56d381de0efeff" translate="yes" xml:space="preserve">
          <source>I zipped up everything to a safe place before trusting &lt;code&gt;git help rm&lt;/code&gt; about the &lt;code&gt;--cached&lt;/code&gt; not destroying anything (and what if I misspelled it).</source>
          <target state="translated">&lt;code&gt;--cached&lt;/code&gt; が何も破壊しないことについて &lt;code&gt;git help rm&lt;/code&gt; を信頼する前に、すべてを安全な場所に圧縮しました（スペルを間違えた場合はどうなりますか）。</target>
        </trans-unit>
        <trans-unit id="fcd7314f67163d84c2c9f40329f48cfdb2e19990" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; was &lt;strong&gt;already tracked&lt;/strong&gt;, &lt;code&gt;git add&lt;/code&gt;&lt;strong&gt;saves the current content&lt;/strong&gt; (snapshot, version) to the cache. In Git, this action is still called &lt;strong&gt;add&lt;/strong&gt;, (not mere &lt;em&gt;update&lt;/em&gt; it), because two different versions (snapshots) of a file are regarded as two different items: hence, we are indeed adding a new item to the cache, to be eventually committed later.</source>
          <target state="translated">&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; が&lt;strong&gt;すでに追跡されている&lt;/strong&gt;場合、 &lt;code&gt;git add&lt;/code&gt; &lt;strong&gt;は現在のコンテンツ&lt;/strong&gt; （スナップショット、バージョン）をキャッシュに&lt;strong&gt;保存し&lt;/strong&gt;ます。 Gitでは、ファイルの2つの異なるバージョン（スナップショット）が2つの異なるアイテムと見なされるため、このアクションは引き続き&lt;strong&gt;add&lt;/strong&gt;と呼ばれます（単なる&lt;em&gt;更新&lt;/em&gt;ではありません）。したがって、最終的に、新しいアイテムをキャッシュに追加しています。後でコミット。</target>
        </trans-unit>
        <trans-unit id="ce05ef547080bdd0c9b4b6d21f9a9cb1212fb4e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; was &lt;strong&gt;not previously tracked&lt;/strong&gt;, &lt;code&gt;git add&lt;/code&gt;&lt;strong&gt;adds it to the cache&lt;/strong&gt;, with its current content.</source>
          <target state="translated">&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; が&lt;strong&gt;以前に追跡さ&lt;/strong&gt;れて&lt;strong&gt;いなかった&lt;/strong&gt;場合、 &lt;code&gt;git add&lt;/code&gt; &lt;strong&gt;はそれを&lt;/strong&gt;現在のコンテンツとともに&lt;strong&gt;キャッシュに&lt;/strong&gt; 追加し &lt;strong&gt;ます&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="9ff00e45e5ffaf135367a1313fb0084d4bdf27c8" translate="yes" xml:space="preserve">
          <source>If you type:</source>
          <target state="translated">タイプすれば</target>
        </trans-unit>
        <trans-unit id="2742bf9d716f8b835566210e331c47572dd4050b" translate="yes" xml:space="preserve">
          <source>If you're on your initial commit and you can't use &lt;code&gt;git reset&lt;/code&gt;, just declare &quot;Git bankruptcy&quot; and delete the &lt;code&gt;.git&lt;/code&gt; folder and start over</source>
          <target state="translated">最初のコミット時に &lt;code&gt;git reset&lt;/code&gt; を使用できない場合は、「Git破産」を宣言して &lt;code&gt;.git&lt;/code&gt; フォルダーを削除し、最初からやり直してください。</target>
        </trans-unit>
        <trans-unit id="cfa255a467797d7f7b136c29ef62aef20cf72142" translate="yes" xml:space="preserve">
          <source>In Sourcetree you can do this easily via the GUI.
You can check which command Sourcetree uses to unstage a file.</source>
          <target state="translated">Sourcetree では GUI から簡単に行うことができます。Sourcetree がどのコマンドを使ってファイルをアンステージするかを確認することができます。</target>
        </trans-unit>
        <trans-unit id="6371392980b92d1512f0ab12ff15fcc9824dcda5" translate="yes" xml:space="preserve">
          <source>In light of this, the question is slightly ambiguous:</source>
          <target state="translated">このことを考えると、やや曖昧な質問になってしまいます。</target>
        </trans-unit>
        <trans-unit id="26fded76dcbe21bec020034ef8ae2890f88f0a1e" translate="yes" xml:space="preserve">
          <source>In old versions of Git, the above commands are equivalent to &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; and &lt;code&gt;git reset HEAD&lt;/code&gt; respectively, and will fail if &lt;code&gt;HEAD&lt;/code&gt; is undefined (because you haven't yet made any commits in your repository) or ambiguous (because you created a branch called &lt;code&gt;HEAD&lt;/code&gt;, which is a stupid thing that you shouldn't do). This &lt;a href=&quot;https://git.kernel.org/cgit/git/git.git/tree/Documentation/RelNotes/1.8.2.txt#n179&quot;&gt;was changed in Git 1.8.2&lt;/a&gt;, though, so in modern versions of Git you can use the commands above even prior to making your first commit:</source>
          <target state="translated">Gitの古いバージョンでは、上記のコマンドはそれぞれ &lt;code&gt;git reset HEAD &amp;lt;file&amp;gt;&lt;/code&gt; および &lt;code&gt;git reset HEAD&lt;/code&gt; と同等であり、 &lt;code&gt;HEAD&lt;/code&gt; が未定義の場合（リポジトリでまだコミットを行っていないため）またはあいまいな場合（ため） &lt;code&gt;HEAD&lt;/code&gt; と呼ばれるブランチを作成しましたが、これはあなたがしてはいけない愚かなことです）。 ただし、これ&lt;a href=&quot;https://git.kernel.org/cgit/git/git.git/tree/Documentation/RelNotes/1.8.2.txt#n179&quot;&gt;はGit 1.8.2&lt;/a&gt;で変更されたため、最新バージョンのGitでは 、最初のコミットを行う前でも上記のコマンドを使用できます。</target>
        </trans-unit>
        <trans-unit id="4051c13ecb202313b56c354bb279d138ec086db7" translate="yes" xml:space="preserve">
          <source>It further turns out that there's &lt;a href=&quot;http://kerneltrap.org/mailarchive/git/2008/2/13/846664/thread&quot;&gt;a bug logged&lt;/a&gt; against the unhelpfulness of this in the mailing list.</source>
          <target state="translated">さらに、これの役に立たないことに対してメーリングリストに&lt;a href=&quot;http://kerneltrap.org/mailarchive/git/2008/2/13/846664/thread&quot;&gt;バグが記録さ&lt;/a&gt;れていることがわかりました。</target>
        </trans-unit>
        <trans-unit id="155ff3b94a20cc6cfcbf96ffeaf7482107ecbbf9" translate="yes" xml:space="preserve">
          <source>It turns out that this is because the HEAD ref (branch?) doesn't exist until after the first commit. That is, you'll run into the same beginner's problem as me if your workflow, like mine, was something like:</source>
          <target state="translated">これは、最初のコミットの後まで HEAD ref (ブランチ?)が存在しないからだとわかりました。つまり、もしあなたのワークフローが私のようなものであれば、私と同じような初心者の問題に遭遇することになるでしょう。</target>
        </trans-unit>
        <trans-unit id="adaaf6d802f465498479a38c637bf662a6522399" translate="yes" xml:space="preserve">
          <source>It will reset your head with that specified file. so, if your head doesn't have it means, it will simply reset it.</source>
          <target state="translated">指定したファイルで頭をリセットしてくれるので、頭にファイルがない場合は単純にリセットしてくれます。</target>
        </trans-unit>
        <trans-unit id="68c9f4ed13403f924ccc247b10f282e693931120" translate="yes" xml:space="preserve">
          <source>Just type &lt;code&gt;git reset&lt;/code&gt; it will revert back and it is like you never typed &lt;code&gt;git add .&lt;/code&gt; since your last commit. Make sure you have committed before.</source>
          <target state="translated">&lt;code&gt;git reset&lt;/code&gt; と入力するだけで元に戻り、 &lt;code&gt;git add .&lt;/code&gt; 入力したことはありません。 あなたの最後のコミット以来。 以前にコミットしたことを確認してください。</target>
        </trans-unit>
        <trans-unit id="7e0db4ee366cdc01a3b955e69f4e20c110c2d411" translate="yes" xml:space="preserve">
          <source>Let's recall first what &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt; actually does:</source>
          <target state="translated">最初に &lt;code&gt;git add &amp;lt;file&amp;gt;&lt;/code&gt; が実際に行うことを思い出してみましょう：</target>
        </trans-unit>
        <trans-unit id="cb43fda806b60a9e08edb5a9c0bde80767b52dcb" translate="yes" xml:space="preserve">
          <source>Maybe Git has evolved since you posted your question.</source>
          <target state="translated">もしかしたら、あなたが質問を投稿した時からGitは進化しているのかもしれません。</target>
        </trans-unit>
        <trans-unit id="1894d7e64791aafcdc008bf854895f11545e7eaa" translate="yes" xml:space="preserve">
          <source>Note that if you fail to specify a revision then you have to include a separator. Example from my console:</source>
          <target state="translated">リビジョンの指定に失敗した場合は、区切り文字を含めなければならないことに注意してください。私のコンソールからの例です。</target>
        </trans-unit>
        <trans-unit id="af8a3ad1fc0ec3393f35b0cf47135414c3907e84" translate="yes" xml:space="preserve">
          <source>Note the warnings elsewhere here - &lt;code&gt;git rm&lt;/code&gt; deletes your local working copy of the file, but &lt;em&gt;not&lt;/em&gt; if you use &lt;strong&gt;--cached&lt;/strong&gt;.  Here's the result of &lt;code&gt;git help rm&lt;/code&gt;:</source>
          <target state="translated">ここの他の場所の警告に注意してください &lt;code&gt;git rm&lt;/code&gt; はファイルのローカルの作業コピーを削除しますが、-- cachedを使用する場合は削除し&lt;em&gt;ません&lt;/em&gt; 。 &lt;code&gt;git help rm&lt;/code&gt; の結果は次のとおりです。</target>
        </trans-unit>
        <trans-unit id="c72f4a37de00a8bbbe1dbd59f585874fa1e95893" translate="yes" xml:space="preserve">
          <source>Note: &lt;strong&gt;checkout&lt;/strong&gt; changes the code in the files and moves to the last updated (committed) state. &lt;strong&gt;reset&lt;/strong&gt; doesn't change the codes; it just resets the header.</source>
          <target state="translated">注： &lt;strong&gt;チェックアウト&lt;/strong&gt;により、ファイル内のコードが変更され、最後に更新された（コミットされた）状態に移行します。 &lt;strong&gt;リセット&lt;/strong&gt;はコードを変更しません。 ヘッダーをリセットするだけです。</target>
        </trans-unit>
        <trans-unit id="2cbbc1ff0f31adab3c452b40de6f1268e3911cdf" translate="yes" xml:space="preserve">
          <source>Now I want to undo this add, before commit, &lt;code&gt;git reset newFile.txt&lt;/code&gt;:</source>
          <target state="translated">この追加を元に戻したいので、コミットする前に &lt;code&gt;git reset newFile.txt&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="05c7960282989a21ecc187ff2e0d765363c04167" translate="yes" xml:space="preserve">
          <source>Now create a .gitignore file (even if it's empty).</source>
          <target state="translated">ここで、.gitignoreファイルを作成します(空であっても構いません)。</target>
        </trans-unit>
        <trans-unit id="d289da3aa7916cb38f48d3be42ec0125720bc36a" translate="yes" xml:space="preserve">
          <source>Now you can</source>
          <target state="translated">今、あなたはすることができます。</target>
        </trans-unit>
        <trans-unit id="0e24b543e5ac084c629c30b256d5108f69b9af4c" translate="yes" xml:space="preserve">
          <source>Now, you can try:</source>
          <target state="translated">さあ、やってみてください。</target>
        </trans-unit>
        <trans-unit id="6bacde1e5ace7fedf82b742a45f533ea5dbbd8d5" translate="yes" xml:space="preserve">
          <source>Of course, this is not very critical if we just follow the usual lazy workflow of doing 'git add' only for adding new files (case 1), and we update new contents via the commit, &lt;code&gt;git commit -a&lt;/code&gt; command.</source>
          <target state="translated">もちろん、新しいファイルを追加するためだけに 'git add'を実行するという通常の遅延ワークフロー（ケース1）に従い、commit、 &lt;code&gt;git commit -a&lt;/code&gt; コマンドを使用して新しいコンテンツを更新する場合、これはそれほど重要ではありません。</target>
        </trans-unit>
        <trans-unit id="ef179165bedaefa2e60e14c1f5b0a3fed59e2b9d" translate="yes" xml:space="preserve">
          <source>Okay, now I'm back to where I started. Next time I'm going to use &lt;code&gt;-n&lt;/code&gt; to do a dry run and see what will be added:</source>
          <target state="translated">さて、今は始めたところに戻っています。 次回は &lt;code&gt;-n&lt;/code&gt; を使用して予行演習を行い、何が追加されるかを確認します。</target>
        </trans-unit>
        <trans-unit id="0cb61707635fc5b2b85cc7e318bd0c2eff7bc6b4" translate="yes" xml:space="preserve">
          <source>Personally I use even shorter aliases:</source>
          <target state="translated">個人的にはもっと短いエイリアスを使っています。</target>
        </trans-unit>
        <trans-unit id="4e01375f9a0c5e752c6c2ca322f69e1c751c7482" translate="yes" xml:space="preserve">
          <source>Pity there is no &lt;code&gt;git unstage&lt;/code&gt; nor &lt;code&gt;git unadd&lt;/code&gt; commands. The relevant one is harder to guess or remember, but it is pretty obvious:</source>
          <target state="translated">残念 &lt;code&gt;git unstage&lt;/code&gt; 、 &lt;code&gt;git unadd&lt;/code&gt; コマンドやgit unaddコマンドはありません。 関連するものを推測したり覚えたりするのは難しいですが、それはかなり明白です：</target>
        </trans-unit>
        <trans-unit id="13a12243b9912816bf20ff21a06d8b8be5dc8068" translate="yes" xml:space="preserve">
          <source>Quite opposite to this command is,</source>
          <target state="translated">このコマンドとは真逆です。</target>
        </trans-unit>
        <trans-unit id="dae6f4177d012c1139923735c568ddf03db59d60" translate="yes" xml:space="preserve">
          <source>Reasoning:</source>
          <target state="translated">Reasoning:</target>
        </trans-unit>
        <trans-unit id="e6c769e8631fe99bc7ceaf82b906459b7e02f9c3" translate="yes" xml:space="preserve">
          <source>Remove &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; from index and versioning, keeping the un-versioned file with changes in working copy:</source>
          <target state="translated">&lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; をインデックスとバージョン管理から削除し、バージョン管理されていないファイルを作業コピーの変更とともに保持します。</target>
        </trans-unit>
        <trans-unit id="ae5dd6b49f5c3fbe00248e75277ab0bec4e291d2" translate="yes" xml:space="preserve">
          <source>Remove &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; from working copy and versioning completely:</source>
          <target state="translated">作業コピーとバージョン管理から &lt;code&gt;&amp;lt;file&amp;gt;&lt;/code&gt; を完全に削除します 。</target>
        </trans-unit>
        <trans-unit id="fed077be24eb8eaa204960095370114925bbcac1" translate="yes" xml:space="preserve">
          <source>Remove the file from the index, but keep it versioned and left with uncommitted changes in working copy:</source>
          <target state="translated">インデックスからファイルを削除しますが、バージョンを保持し、作業コピーにコミットされていない変更を残しておきます。</target>
        </trans-unit>
        <trans-unit id="e74a1ace1491f586fe024a5c928549012bbdc769" translate="yes" xml:space="preserve">
          <source>Reset the file to the last state from HEAD, undoing changes and removing them from the index:</source>
          <target state="translated">ファイルをHEADから最後の状態にリセットし、変更を元に戻してインデックスから削除します。</target>
        </trans-unit>
        <trans-unit id="b1b392607deaf29a7e81453e069b7c07a32a6b18" translate="yes" xml:space="preserve">
          <source>Run</source>
          <target state="translated">Run</target>
        </trans-unit>
        <trans-unit id="02dea6db5118caef938b800592b8a5b38b39b70c" translate="yes" xml:space="preserve">
          <source>Run &lt;code&gt;git init&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;git init&lt;/code&gt; を実行します 。</target>
        </trans-unit>
        <trans-unit id="7e78630f4030bbb87b09bdc8ef8eb2b0effda1fd" translate="yes" xml:space="preserve">
          <source>Second: Be aware that &lt;code&gt;git reset HEAD&lt;/code&gt;  can't magically recover the previously cached file contents, it just resynchronises it from the HEAD. If our misguided &lt;code&gt;git add&lt;/code&gt; overwrote a previous staged uncommitted version, we can't recover it. That's why, strictly speaking, we cannot undo [*].</source>
          <target state="translated">2番目： &lt;code&gt;git reset HEAD&lt;/code&gt; は以前にキャッシュされたファイルの内容を魔法のように回復できないことに注意してください。HEADから再同期するだけです。 私たちの誤った &lt;code&gt;git add&lt;/code&gt; が以前のステージングされたコミットされていないバージョンを上書きした場合、それを回復することはできません。 そのため、厳密に言えば、元に戻すことはできません[*]。</target>
        </trans-unit>
        <trans-unit id="6482098605bc3d53dec5b4352c070381b60cd196" translate="yes" xml:space="preserve">
          <source>Simply,</source>
          <target state="translated">Simply,</target>
        </trans-unit>
        <trans-unit id="66c23519edb800ce7f1ae7d41a7603aad229a1c7" translate="yes" xml:space="preserve">
          <source>So, which is the real &lt;strong&gt;undo&lt;/strong&gt; of &lt;code&gt;git add&lt;/code&gt;?</source>
          <target state="translated">それで、どれが &lt;code&gt;git add&lt;/code&gt; の本当の&lt;strong&gt;取り消し&lt;/strong&gt;ですか？</target>
        </trans-unit>
        <trans-unit id="7a0a709ea65dccc7a4c51af95745b03c4f843454" translate="yes" xml:space="preserve">
          <source>Sourcetree uses &lt;code&gt;reset&lt;/code&gt; to unstage new files.</source>
          <target state="translated">Sourcetreeは、 &lt;code&gt;reset&lt;/code&gt; を使用して新しいファイルのステージングを解除します。</target>
        </trans-unit>
        <trans-unit id="6c8f7d0c756781e3631fb4f4ea510b736c4722ab" translate="yes" xml:space="preserve">
          <source>Strictly speaking, and if I'm not mistaken: &lt;strong&gt;none&lt;/strong&gt;.</source>
          <target state="translated">厳密に言えば、そして私が誤解していないのであれば： &lt;strong&gt;なし&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="552594479ca335a75b38e3d8e7bdd7faab39b95c" translate="yes" xml:space="preserve">
          <source>Suppose I add the file accidentally, &lt;code&gt;git add newFile.txt&lt;/code&gt;:</source>
          <target state="translated">誤ってファイルを追加したとし &lt;code&gt;git add newFile.txt&lt;/code&gt; 、 git add newFile.txt ：</target>
        </trans-unit>
        <trans-unit id="9b8c3ebc30d10d6817fe9050f1cc51452b3d3228" translate="yes" xml:space="preserve">
          <source>Suppose I create a new file, &lt;code&gt;newFile.txt&lt;/code&gt;:</source>
          <target state="translated">新しいファイル &lt;code&gt;newFile.txt&lt;/code&gt; を作成するとします。</target>
        </trans-unit>
        <trans-unit id="48ddf6e59a4b1f3b87a0c3bfe2a4dc11f44620d7" translate="yes" xml:space="preserve">
          <source>That's it!  Here's your proof, showing that &quot;foo&quot; is back on the untracked list:</source>
          <target state="translated">これだよ! これが証拠です。&quot;foo &quot;が追跡されていないリストに戻ってきたことを示しています。</target>
        </trans-unit>
        <trans-unit id="8958263708a605b83222c7193c08abd8eb1b5018" translate="yes" xml:space="preserve">
          <source>The OP's scenario seems to be the first one (untracked file),  we want the &quot;undo&quot; to remove the file (not just the current contents) from the tracked items. &lt;strong&gt;If&lt;/strong&gt; this is the case, then it's ok to run  &lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">OPのシナリオは最初のシナリオ（追跡されていないファイル）のようです。「元に戻す」で追跡されているアイテムからファイル（現在のコンテンツだけでなく）を削除します。 &lt;strong&gt;この場合&lt;/strong&gt;は、 &lt;code&gt;git rm --cached &amp;lt;file&amp;gt;&lt;/code&gt; を実行しても問題ありません 。</target>
        </trans-unit>
        <trans-unit id="7b3077a7e23f22edb63b9582ee50b4547489abb5" translate="yes" xml:space="preserve">
          <source>The question is not clearly posed. The reason is that &lt;code&gt;git add&lt;/code&gt; has two meanings:</source>
          <target state="translated">質問は明確に提起されていません。 その理由は、 &lt;code&gt;git add&lt;/code&gt; には2つの意味があるためです。</target>
        </trans-unit>
        <trans-unit id="63cdf5c295405f082341c0ae56aecc932dd4667c" translate="yes" xml:space="preserve">
          <source>Then check out your most recent commit again.  This will retrieve fresh copies of your files, using your current line-ending settings.</source>
          <target state="translated">そして、最新のコミットをもう一度確認してください。これにより、現在の改行設定を使用してファイルの新しいコピーを取得します。</target>
        </trans-unit>
        <trans-unit id="45b5f9be123d9d86c58d9dec3dd125558e131647" translate="yes" xml:space="preserve">
          <source>There is also interactive mode:</source>
          <target state="translated">インタラクティブモードもあります。</target>
        </trans-unit>
        <trans-unit id="3d8e9657b987817fb3c220308e1acc16025156bd" translate="yes" xml:space="preserve">
          <source>This command will unstash your changes:</source>
          <target state="translated">このコマンドを実行すると、変更した内容を公開しなくなります。</target>
        </trans-unit>
        <trans-unit id="fbecbeb1a67335121e9c59db32b75a2ff73e40e7" translate="yes" xml:space="preserve">
          <source>This is needed since &lt;code&gt;git reset --hard HEAD&lt;/code&gt; won't work with single files.</source>
          <target state="translated">&lt;code&gt;git reset --hard HEAD&lt;/code&gt; は単一ファイルでは機能しないため、これが必要です。</target>
        </trans-unit>
        <trans-unit id="78be1b0da3b7e1ea2b2d12e12dd3d30469cfa022" translate="yes" xml:space="preserve">
          <source>This is nothing to be worried about; the file is indeed still in the repository, but only as a &quot;loose object&quot;. It will not be copied to other repositories (via clone, push), and the space will be eventually reclaimed - though perhaps not very soon. If you are anxious, you can run:</source>
          <target state="translated">このファイルは確かにまだリポジトリに残っていますが、&quot;ルーズオブジェクト &quot;としてだけです。このファイルは他のリポジトリにコピーされることはなく (クローンやプッシュで)、最終的にはスペースは確保されます。不安な方は実行してみてください。</target>
        </trans-unit>
        <trans-unit id="5dcdedc4b69b304293ee4853c6d1a79b75fafbd7" translate="yes" xml:space="preserve">
          <source>This process is called &lt;em&gt;staging&lt;/em&gt;. So the most natural command to &lt;em&gt;stage&lt;/em&gt; the changes (changed files) is the obvious one:</source>
          <target state="translated">このプロセスは&lt;em&gt;ステージング&lt;/em&gt;と呼ばれます。 したがって、変更（変更されたファイル）を&lt;em&gt;ステージング&lt;/em&gt;するための最も自然なコマンドは明白なものです。</target>
        </trans-unit>
        <trans-unit id="6bb9d50aae0e807f542249cc2247c59911ac39cd" translate="yes" xml:space="preserve">
          <source>This should be what you are looking for.</source>
          <target state="translated">これはあなたが探しているもののはずです。</target>
        </trans-unit>
        <trans-unit id="16b0d869d782ecce087a08191cd6576c501a0143" translate="yes" xml:space="preserve">
          <source>To choose a sequence, just type 1-5 to take all from 1 to 5.</source>
          <target state="translated">シーケンスを選択するには、1から5までのすべてを取るために1-5と入力するだけです。</target>
        </trans-unit>
        <trans-unit id="9d60018f1a5334d24aeca0c7d89c5867b612205d" translate="yes" xml:space="preserve">
          <source>To clarify: &lt;code&gt;git add&lt;/code&gt; moves changes from the current working directory to the &lt;em&gt;staging area&lt;/em&gt; (index).</source>
          <target state="translated">明確にするために： &lt;code&gt;git add&lt;/code&gt; は、変更を現在の作業ディレクトリから&lt;em&gt;ステージング領域&lt;/em&gt; （インデックス）に移動します。</target>
        </trans-unit>
        <trans-unit id="515c85f04427e465b01ddaa8b4eed764826e3289" translate="yes" xml:space="preserve">
          <source>To remove new files from the staging area (and only in case of a new file), as suggested above:</source>
          <target state="translated">上で提案したように、ステージングエリアから新しいファイルを削除するには(新しいファイルがある場合のみ)。</target>
        </trans-unit>
        <trans-unit id="4c2db952152ad41554b645a8de14e0d96cee28e3" translate="yes" xml:space="preserve">
          <source>To reset every file in a particular folder (and its subfolders), you can use the following command:</source>
          <target state="translated">特定のフォルダ(およびそのサブフォルダ)内のすべてのファイルをリセットするには、次のコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="7a6d02a83dd13f67c2c894d293c482fbefff8376" translate="yes" xml:space="preserve">
          <source>To undo &lt;code&gt;git add&lt;/code&gt;, use:</source>
          <target state="translated">&lt;code&gt;git add&lt;/code&gt; を元に戻すには 、次のコマンドを使用します。</target>
        </trans-unit>
        <trans-unit id="fa1dcc9ecc36eb2fd6956b02179caec720b1c11b" translate="yes" xml:space="preserve">
          <source>Unstaging files [08/12/15 10:43]
  git -c diff.mnemonicprefix=false -c core.quotepath=false -c credential.helper=sourcetree reset -q -- path/to/file/filename.java</source>
          <target state="translated">ファイルのアンステージ [081215 10:43]git -c diff.mnemonicprefix=false -c core.quotepath=false -c credential.helper=sourcetree reset -q --pathtofilefilename.java</target>
        </trans-unit>
        <trans-unit id="056701c16429c2b69fe63426e25dcd6aa3557661" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;git add -i&lt;/code&gt; to remove just-added files from your upcoming commit.  Example:</source>
          <target state="translated">&lt;code&gt;git add -i&lt;/code&gt; ばかりのファイルを次のコミットから削除するには、 git add -iを使用します。 例：</target>
        </trans-unit>
        <trans-unit id="f877b9fe8d4d292f783a2224c88efb437d28d091" translate="yes" xml:space="preserve">
          <source>Use rm --cached only for new files accidentally added.</source>
          <target state="translated">rm --cached は誤って追加された新しいファイルのためだけに使用します。</target>
        </trans-unit>
        <trans-unit id="b3c520b0adfc4612c5f13f20487496d48ab36887" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;*&lt;/code&gt; command to handle multiple files at a time:</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; コマンドを使用して、一度に複数のファイルを処理します。</target>
        </trans-unit>
        <trans-unit id="924703164da00b7444edd64fb60fcbb8c3162ce5" translate="yes" xml:space="preserve">
          <source>We can easily create an alias for this:</source>
          <target state="translated">そのためのエイリアスを簡単に作ることができます。</target>
        </trans-unit>
        <trans-unit id="bbed8dcb33376bb1d53e3675a03c7fa2ea7c9fe5" translate="yes" xml:space="preserve">
          <source>When I was new to this, I first tried</source>
          <target state="translated">初めての時は、最初に試したのは</target>
        </trans-unit>
        <trans-unit id="eedeb18aad137a7f9d3e048a4943d3e6769cc920" translate="yes" xml:space="preserve">
          <source>Will remove a file named filename.txt from the current index, the &quot;about to be committed&quot; area, without changing anything else.</source>
          <target state="translated">現在のインデックス、&quot;about to be committed&quot; エリアから filename.txt という名前のファイルを、他に何も変更せずに削除します。</target>
        </trans-unit>
        <trans-unit id="22d0b06ab6697336780029eb518e6cdd2c05382e" translate="yes" xml:space="preserve">
          <source>You can also use</source>
          <target state="translated">また、以下のような使い方もできます。</target>
        </trans-unit>
        <trans-unit id="80087849dfcee0e85f78d0320eb186d09742ee66" translate="yes" xml:space="preserve">
          <source>You can undo &lt;code&gt;git add&lt;/code&gt; before commit with</source>
          <target state="translated">コミット &lt;code&gt;git add&lt;/code&gt; 前にgit addを取り消すことができます</target>
        </trans-unit>
        <trans-unit id="3c94090f45521fa505560d818d146d87684fe4b4" translate="yes" xml:space="preserve">
          <source>You can use</source>
          <target state="translated">を使用することができます。</target>
        </trans-unit>
        <trans-unit id="a0815200bea1a60432e0d4fb69db34bfd8e2c698" translate="yes" xml:space="preserve">
          <source>You want:</source>
          <target state="translated">欲しいんだろ?</target>
        </trans-unit>
        <trans-unit id="d8dcb8d55fececafb2c68ba7044ee1b772419651" translate="yes" xml:space="preserve">
          <source>adding a &lt;strong&gt;modified&lt;/strong&gt; file to the staging area, then undo with &lt;code&gt;git reset HEAD file&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;変更された&lt;/strong&gt;ファイルをステージング領域に追加し、 &lt;code&gt;git reset HEAD file&lt;/code&gt; で元に戻します 。</target>
        </trans-unit>
        <trans-unit id="6d473aa440edb561b8723fe71085cf8f567b0af0" translate="yes" xml:space="preserve">
          <source>adding a &lt;strong&gt;new file&lt;/strong&gt; to the staging area, then undo with &lt;code&gt;git rm --cached file&lt;/code&gt;.</source>
          <target state="translated">ステージング領域に&lt;strong&gt;新しいファイル&lt;/strong&gt;を追加してから、 &lt;code&gt;git rm --cached file&lt;/code&gt; で元に戻します 。</target>
        </trans-unit>
        <trans-unit id="4fb062fcfd7c48b01f50e3d39fe6e21fd78aec1b" translate="yes" xml:space="preserve">
          <source>and remove all the files manually or by selecting all of them and clicking on the &lt;em&gt;unstage from commit&lt;/em&gt; button.</source>
          <target state="translated">そして、すべてのファイルを手動で削除するか、それらのすべてを選択して、[ &lt;em&gt;コミット解除&lt;/em&gt; ]ボタン&lt;em&gt;を&lt;/em&gt;クリックします。</target>
        </trans-unit>
        <trans-unit id="4f3a7ccc2fff02e760b79353f269bbf29121de43" translate="yes" xml:space="preserve">
          <source>cd to my great new project directory to try out Git, the new hotness</source>
          <target state="translated">新しいプロジェクトディレクトリに cd して、新しいホットな Git を試してみました。</target>
        </trans-unit>
        <trans-unit id="fb7f7c94028fe09a6d2d9b3bf0b8501eb7095619" translate="yes" xml:space="preserve">
          <source>etc.</source>
          <target state="translated">etc.</target>
        </trans-unit>
        <trans-unit id="79986d4e639d0773bd127e19458b07f55b1bfc8c" translate="yes" xml:space="preserve">
          <source>git checkout .</source>
          <target state="translated">git checkout .</target>
        </trans-unit>
        <trans-unit id="15cba6d4879c1734e4422bdc03b13a6b93611534" translate="yes" xml:space="preserve">
          <source>git checkout my_file.txt</source>
          <target state="translated">git checkout my_file.txt</target>
        </trans-unit>
        <trans-unit id="801b883972ec8ef1236eb019443c886dcf6750a7" translate="yes" xml:space="preserve">
          <source>git reset .</source>
          <target state="translated">git reset .</target>
        </trans-unit>
        <trans-unit id="94f60eb54806996b7e1222363ba5dc870eddd539" translate="yes" xml:space="preserve">
          <source>git reset my_file.txt</source>
          <target state="translated">git reset my_file.txt</target>
        </trans-unit>
        <trans-unit id="25aab1fe6dec61e754487a291c40fdda95b4be44" translate="yes" xml:space="preserve">
          <source>google &quot;undo git add&quot;</source>
          <target state="translated">google &quot;undo git add&quot;</target>
        </trans-unit>
        <trans-unit id="1758356db21759f7c5a0da9b4dd1db8fd6feab3f" translate="yes" xml:space="preserve">
          <source>or</source>
          <target state="translated">or</target>
        </trans-unit>
        <trans-unit id="5712023340e6a2d05ce05ba84935a0ac55f18949" translate="yes" xml:space="preserve">
          <source>so, you will be in the previous state. Specified will be again in untracked list (previous state).</source>
          <target state="translated">で指定されているので、前の状態になります。指定した場合は、再び未追跡リスト(前の状態)になります。</target>
        </trans-unit>
        <trans-unit id="0d19f5a79e1fc6cc465c4d08247b4439056a1cad" translate="yes" xml:space="preserve">
          <source>to add parts of files.</source>
          <target state="translated">を使用して、ファイルのパーツを追加します。</target>
        </trans-unit>
        <trans-unit id="5f5d8b5a3e74af731dcc9b939e21d7235ca21741" translate="yes" xml:space="preserve">
          <source>to remove everything and start again. Didn't work though, because while &lt;code&gt;add .&lt;/code&gt; is recursive, turns out &lt;code&gt;rm&lt;/code&gt; needs &lt;code&gt;-r&lt;/code&gt; to recurse. Sigh.</source>
          <target state="translated">すべてを削除してやり直します。 しかし、動作しませんでした &lt;code&gt;add .&lt;/code&gt; 再帰的で、 &lt;code&gt;rm&lt;/code&gt; が &lt;code&gt;-r&lt;/code&gt; を再帰的に実行する必要があることが判明しました。 はぁ。</target>
        </trans-unit>
        <trans-unit id="0e01177e2865564bc5a2bd0273597bbf76768708" translate="yes" xml:space="preserve">
          <source>which will remove it from the current index (the &quot;about to be committed&quot; list) without changing anything else.</source>
          <target state="translated">これは、他に何も変更せずに現在のインデックス(&quot;about to be committed&quot; リスト)から削除します。</target>
        </trans-unit>
        <trans-unit id="22a56ae9ed58d1e164446e8aefe9c47c81c380ad" translate="yes" xml:space="preserve">
          <source>will &quot;un-add&quot; everything you've added from your current directory recursively</source>
          <target state="translated">は現在のディレクトリから再帰的に追加したものをすべて &quot;元に戻す &quot;ことができます。</target>
        </trans-unit>
        <trans-unit id="aaaa9d584e39a7eb22d6030fa5ce40df98b7224d" translate="yes" xml:space="preserve">
          <source>without any file name to unstage all due changes. This can come in handy when there are too many files to be listed one by one in a reasonable amount of time.</source>
          <target state="translated">を使用して、ファイル名を指定せずに、すべての変更をアンステージすることができます。これは、ファイルが多すぎて妥当な時間内に一つずつリストアップするのが難しい場合に便利です。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
