<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3481828">
    <body>
      <group id="3481828">
        <trans-unit id="634a0bdd960a66ce1185d269b6e09c19a16d7e59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;there&lt;/a&gt; are 12 characters with special meanings: the backslash &lt;code&gt;\&lt;/code&gt;, the caret &lt;code&gt;^&lt;/code&gt;, the dollar sign &lt;code&gt;$&lt;/code&gt;, the period or dot &lt;code&gt;.&lt;/code&gt;, the vertical bar or pipe symbol &lt;code&gt;|&lt;/code&gt;, the question mark &lt;code&gt;?&lt;/code&gt;, the asterisk or star &lt;code&gt;*&lt;/code&gt;, the plus sign &lt;code&gt;+&lt;/code&gt;, the opening parenthesis &lt;code&gt;(&lt;/code&gt;, the closing parenthesis &lt;code&gt;)&lt;/code&gt;, and the opening square bracket &lt;code&gt;[&lt;/code&gt;, the opening curly brace &lt;code&gt;{&lt;/code&gt;, These special characters are often called &quot;metacharacters&quot;.</source>
          <target state="translated">&lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;有&lt;/a&gt; 12个具有特殊含义的字符：反斜杠 &lt;code&gt;\&lt;/code&gt; ，脱字号 &lt;code&gt;^&lt;/code&gt; ，美元符号 &lt;code&gt;$&lt;/code&gt; ，句点或点 &lt;code&gt;.&lt;/code&gt; ，竖线或竖线符号 &lt;code&gt;|&lt;/code&gt; ，问号 &lt;code&gt;?&lt;/code&gt; ，星号或星号 &lt;code&gt;*&lt;/code&gt; ，加号 &lt;code&gt;+&lt;/code&gt; ，左括号 &lt;code&gt;(&lt;/code&gt; ，右括号 &lt;code&gt;)&lt;/code&gt; 和左方括号 &lt;code&gt;[&lt;/code&gt; ，大括号 &lt;code&gt;{&lt;/code&gt; ) ，这些特殊字符通常称为&amp;ldquo;元字符&amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="9eaaedfd4cc1e7d310987fa57faf8f0dadb38f16" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://explainjava.com/split-string-java/&quot;&gt;Here&lt;/a&gt; is a big overview of these methods and the most common examples (how to split by dot, slash, question mark, etc.)</source>
          <target state="translated">&lt;a href=&quot;https://explainjava.com/split-string-java/&quot;&gt;这&lt;/a&gt;是这些方法和最常见示例（如何按点，斜杠，问号等进行拆分）的概述。</target>
        </trans-unit>
        <trans-unit id="e1313d9d177aa767a2f19ce3fbfac579ced79591" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;String Split with multiple characters using Regex&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;使用正则表达式将字符串拆分为多个字符&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c16943696a740385ff52f52ff01f2c21d575844" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use Pattern.split and precompile the pattern if using a complex delimiter and you care about performance.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;如果使用复杂的定界符并且您关心性能，请使用Pattern.split并预编译模式。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54fbcdde970b3680f7855bf3eb18ae8469d7ce0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use String.split for a one-character delimiter or you don't care about performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;将String.split用于一个字符分隔符，或者您不关心性能&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7eeb6651db327271e5d1629a11d7fe0d16a7d8b" translate="yes" xml:space="preserve">
          <source>An alternative to processing the string directly would be to use a regular expression with capturing groups. This has the advantage that it makes it straightforward to imply more sophisticated constraints on the input. For example, the following splits the string into two parts, and ensures that both consist only of digits:</source>
          <target state="translated">直接处理字符串的另一种方法是使用带有捕获组的正则表达式。这样做的好处是可以直接对输入进行更复杂的约束。例如,下面的例子是将字符串分成两部分,并确保两部分都只由数字组成。</target>
        </trans-unit>
        <trans-unit id="19627da7883a0613ac58045d6ef1f0d8e6c29df6" translate="yes" xml:space="preserve">
          <source>And as expected it will print:</source>
          <target state="translated">果然不出所料,它会打印出来。</target>
        </trans-unit>
        <trans-unit id="281d300200893a33e3537d992266d3b91d6ad40f" translate="yes" xml:space="preserve">
          <source>Apache Commons StringUtils:</source>
          <target state="translated">Apache Commons StringUtils:</target>
        </trans-unit>
        <trans-unit id="0bd2c33eab401a57c01e405d1bbc1c234e7435b3" translate="yes" xml:space="preserve">
          <source>As mentioned by everyone, split() is the best option which may be used in your case. An alternative method can be using substring().</source>
          <target state="translated">正如大家所提到的,split()是最好的选择,在你的情况下可以使用。另一种方法是使用substring()。</target>
        </trans-unit>
        <trans-unit id="455bf4d4aefbaf76e95abcb994d64522e57f5a43" translate="yes" xml:space="preserve">
          <source>As the pattern is fixed in this instance, it can be compiled in advance and stored as a static member (initialised at class load time in the example). The regular expression is:</source>
          <target state="translated">由于这个实例中的模式是固定的,所以可以提前编译并作为静态成员存储(在示例中的类加载时初始化)。正则表达式为。</target>
        </trans-unit>
        <trans-unit id="acd8d9d3530feb7f220a993eb4bc93080beec114" translate="yes" xml:space="preserve">
          <source>Assume that if &lt;code&gt;-&lt;/code&gt; does not exists in your string, it returns the given string, and you will not get any exception.</source>
          <target state="translated">假设字符串中不存在 &lt;code&gt;-&lt;/code&gt; ，则返回给定的字符串，并且不会出现任何异常。</target>
        </trans-unit>
        <trans-unit id="b598f05f355293d3ba808a995629e736abdf52ac" translate="yes" xml:space="preserve">
          <source>Assuming, that</source>
          <target state="translated">假设:</target>
        </trans-unit>
        <trans-unit id="170679a43c9b6393ea32de0f697ab9d50e3a0a66" translate="yes" xml:space="preserve">
          <source>But do not expect the same output across all JDK versions. I have seen &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8043324&quot;&gt;one bug&lt;/a&gt; which exists in some JDK versions where the first null string has been ignored. This bug is not present in the latest JDK version, but it exists in some versions between JDK 1.7 late versions and 1.8 early versions.</source>
          <target state="translated">但是不要期望所有JDK版本都具有相同的输出。 我已经看到某些JDK版本中存在&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8043324&quot;&gt;一个错误&lt;/a&gt; ，其中第一个空字符串已被忽略。 此错误在最新的JDK版本中不存在，但在JDK 1.7后期版本和1.8早期版本之间的某些版本中存在。</target>
        </trans-unit>
        <trans-unit id="2e0832e81bd97677c3c3e45f933928a5b9fcf585" translate="yes" xml:space="preserve">
          <source>Check out the &lt;code&gt;split()&lt;/code&gt; method in the &lt;code&gt;String&lt;/code&gt; class on javadoc.</source>
          <target state="translated">在javadoc的 &lt;code&gt;String&lt;/code&gt; 类中签出 &lt;code&gt;split()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="9e823ab53cec95c3e300ab785e078436d9d366d4" translate="yes" xml:space="preserve">
          <source>Check out the &lt;code&gt;split()&lt;/code&gt; method in the &lt;code&gt;String&lt;/code&gt; class.</source>
          <target state="translated">在 &lt;code&gt;String&lt;/code&gt; 类中签出 &lt;code&gt;split()&lt;/code&gt; 方法。</target>
        </trans-unit>
        <trans-unit id="3172bac692f1e831e3ef1816e8723add91fa4296" translate="yes" xml:space="preserve">
          <source>Else, you can use StringTokenizer:</source>
          <target state="translated">Else,你可以使用StringTokenizer。</target>
        </trans-unit>
        <trans-unit id="26e0e8524f90a3c867fdd33bcd49bb6fa8f4e4d0" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;&quot;-333&quot;&lt;/code&gt; should return in &lt;code&gt;[,333]&lt;/code&gt; or if it is an error.
Can &lt;code&gt;&quot;333-333-33&quot;&lt;/code&gt; be separated in &lt;code&gt;[333,333-33] or [333-333,33]&lt;/code&gt; or is it an error? And so on.</source>
          <target state="translated">例如，如果 &lt;code&gt;&quot;-333&quot;&lt;/code&gt; 应返回 &lt;code&gt;[,333]&lt;/code&gt; 或是错误。 是否可以在 &lt;code&gt;[333,333-33] or [333-333,33]&lt;/code&gt; &lt;code&gt;&quot;333-333-33&quot;&lt;/code&gt; 分开，还是错误？ 等等。</target>
        </trans-unit>
        <trans-unit id="a959961f689dc6305eb84be8327b92d85950c3fd" translate="yes" xml:space="preserve">
          <source>For simple use cases &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;&lt;code&gt;String.split()&lt;/code&gt;&lt;/a&gt; should do the job. If you use guava, there is also a &lt;a href=&quot;https://github.com/google/guava/wiki/StringsExplained#splitter&quot;&gt;Splitter&lt;/a&gt; class which allows chaining of different string operations and supports &lt;a href=&quot;https://google.github.io/guava/releases/snapshot-jre/api/docs/com/google/common/base/CharMatcher.html&quot;&gt;CharMatcher&lt;/a&gt;:</source>
          <target state="translated">对于简单的用例， &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt; &lt;code&gt;String.split()&lt;/code&gt; &lt;/a&gt;应该可以完成工作。 如果使用番石榴，则还有一个&lt;a href=&quot;https://github.com/google/guava/wiki/StringsExplained#splitter&quot;&gt;Splitter&lt;/a&gt;类，该类允许链接不同的字符串操作并支持&lt;a href=&quot;https://google.github.io/guava/releases/snapshot-jre/api/docs/com/google/common/base/CharMatcher.html&quot;&gt;CharMatcher&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="41aa5e8cca232ef96ae8344d4180dbf6e0984c6c" translate="yes" xml:space="preserve">
          <source>Good test candidates should include:</source>
          <target state="translated">优秀的考生应包括:</target>
        </trans-unit>
        <trans-unit id="66c15e0f61dc4ba39ea4ecd546d9001621adbb7c" translate="yes" xml:space="preserve">
          <source>Google Guava Splitter:</source>
          <target state="translated">谷歌番石榴分裂器。</target>
        </trans-unit>
        <trans-unit id="1b570f545b2da28a044cb15d0d777d7bb12661f7" translate="yes" xml:space="preserve">
          <source>Here are two ways two achieve it.</source>
          <target state="translated">下面是两个实现的方法两个。</target>
        </trans-unit>
        <trans-unit id="d7702fb6307a48ed358e3bf97b7b58828135f99f" translate="yes" xml:space="preserve">
          <source>Here many examples for split string but I little code optimized.</source>
          <target state="translated">这里有很多拆分字符串的例子,但我对代码进行了少许优化。</target>
        </trans-unit>
        <trans-unit id="ecaeeb1e045a34e4ed62d11ef9b1606af81639f3" translate="yes" xml:space="preserve">
          <source>How to split a string in Java</source>
          <target state="translated">如何在Java中分割一个字符串</target>
        </trans-unit>
        <trans-unit id="9d00bd1b546789395f672ebe1d098d7b4670e821" translate="yes" xml:space="preserve">
          <source>I have a string, &lt;code&gt;&quot;004-034556&quot;&lt;/code&gt;, that I want to split into two strings:</source>
          <target state="translated">我有一个字符串 &lt;code&gt;&quot;004-034556&quot;&lt;/code&gt; ，我想分成两个字符串：</target>
        </trans-unit>
        <trans-unit id="597fca85260a03d531d03509982c894f6ec88d3a" translate="yes" xml:space="preserve">
          <source>I just wanted to write an algorithm instead of using Java built-in functions:</source>
          <target state="translated">我只是想写一个算法,而不是用Java内置的函数来代替。</target>
        </trans-unit>
        <trans-unit id="73640238f9039cdaa6a85588bf8ae148414cb776" translate="yes" xml:space="preserve">
          <source>I would recommend using commong-lang, since usually it contains a lot of stuff that's usable. However, if you don't need it for anything else than doing a split, then implementing yourself or escaping the regex is a better option.</source>
          <target state="translated">我建议使用commong-lang,因为通常它包含了很多可以使用的东西。但是,如果你除了做拆分之外不需要它,那么自己实现或者转义的regex是更好的选择。</target>
        </trans-unit>
        <trans-unit id="35f5eaeb8f626d3b81bb83d806e7bb128d180dfa" translate="yes" xml:space="preserve">
          <source>If performance is an issue, and your delimiter is not one of the above, you should pre-compile a regular expression pattern which you can then reuse.</source>
          <target state="translated">如果性能是一个问题,而你的分隔符不是上述的一种,你应该预先编译一个正则表达式模式,然后你可以重复使用。</target>
        </trans-unit>
        <trans-unit id="5711570bf541c6fabc965cce5a0f19929f00eb29" translate="yes" xml:space="preserve">
          <source>If performance is not an issue, or if the delimiter is a single character that is not a regular expression special character (i.e., not one of &lt;code&gt;.$|()[{^?*+\&lt;/code&gt;) then you can use &lt;code&gt;String.split&lt;/code&gt;.</source>
          <target state="translated">如果性能不是问题，或者分隔符是不是正则表达式特殊字符的单个字符（即，不是 &lt;code&gt;.$|()[{^?*+\&lt;/code&gt; ），那么可以使用 &lt;code&gt;String.split&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="abb4797fa4e7a9f330539336db1653a5f6b50e22" translate="yes" xml:space="preserve">
          <source>If the array length is not 2, then the string was not in the format: &lt;code&gt;string-string&lt;/code&gt;.</source>
          <target state="translated">如果数组长度不是2，则字符串的格式不为： &lt;code&gt;string-string&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="c9379386900a7ba181b578a891a6edd088cb32a8" translate="yes" xml:space="preserve">
          <source>If you'd like to limit the number of resulting parts, then you can supply the desired number as 2nd argument of &lt;code&gt;split()&lt;/code&gt; method.</source>
          <target state="translated">如果您想限制生成零件的数量，则可以提供所需的数量作为 &lt;code&gt;split()&lt;/code&gt; 方法的第二个参数。</target>
        </trans-unit>
        <trans-unit id="cf486efb110a169d1ec321ad391237aea75e64a5" translate="yes" xml:space="preserve">
          <source>If you'd like to retain the split character in the resulting parts, then make use of &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;positive lookaround&lt;/a&gt;. In case you want to have the split character to end up in left hand side, use positive lookbehind by prefixing &lt;code&gt;?&amp;lt;=&lt;/code&gt; group on the pattern.</source>
          <target state="translated">如果您想在结果部分中保留分割字符，请使用&lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;正向环视&lt;/a&gt; 。 如果要使分割字符以左结尾，请在模式前面加上 &lt;code&gt;?&amp;lt;=&lt;/code&gt; group，以使用正向后视。</target>
        </trans-unit>
        <trans-unit id="7d5bcf86d6aef4f63d20823de18fef46a3444d8b" translate="yes" xml:space="preserve">
          <source>In case you want to have the split character to end up in right hand side, use positive lookahead by prefixing &lt;code&gt;?=&lt;/code&gt; group on the pattern.</source>
          <target state="translated">如果您希望分割字符以右侧结尾，请在模式前面加上 &lt;code&gt;?=&lt;/code&gt; 组，以使用正向超前。</target>
        </trans-unit>
        <trans-unit id="d4d53e1a023a39b0d46c1060abcaf2ee36561cad" translate="yes" xml:space="preserve">
          <source>In this answer I also want to point out &lt;strong&gt;one change that has taken place for &lt;code&gt;split&lt;/code&gt; method in Java 8&lt;/strong&gt;. The &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;String#split()&lt;/a&gt; method makes use of &lt;code&gt;Pattern.split&lt;/code&gt;, and now it will remove empty strings at the start of the result array. Notice this &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-int-&quot;&gt;change&lt;/a&gt; in documentation for Java 8:</source>
          <target state="translated">在这个答案中，我还想指出&lt;strong&gt;Java 8中 &lt;code&gt;split&lt;/code&gt; 方法的一个变化&lt;/strong&gt; 。 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;String＃split（）&lt;/a&gt;方法利用了 &lt;code&gt;Pattern.split&lt;/code&gt; ，现在它将在结果数组的开头删除空字符串。 请注意Java 8文档中的这一&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-int-&quot;&gt;更改&lt;/a&gt; ：</target>
        </trans-unit>
        <trans-unit id="9d7ee1e0bfdc43c72fde2787f5595a8e3fe895b2" translate="yes" xml:space="preserve">
          <source>In your case, you want to split a string when there is a &quot;-&quot;.</source>
          <target state="translated">在你的情况下,当有&quot;-&quot;时,你想把一个字符串拆分。</target>
        </trans-unit>
        <trans-unit id="e1bab11672544eaa3fe560aec8ed33483038ee1c" translate="yes" xml:space="preserve">
          <source>It means for the following example:</source>
          <target state="translated">对于下面的例子,它的意思是:</target>
        </trans-unit>
        <trans-unit id="708293cbdedf6516d4e9d0f795068139869bebd2" translate="yes" xml:space="preserve">
          <source>Just use the appropriate method: &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;&lt;code&gt;String#split()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">只需使用适当的方法： &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt; &lt;code&gt;String#split()&lt;/code&gt; 即可&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1366efda6e348068340179972f16275440d6ada" translate="yes" xml:space="preserve">
          <source>Method signature:</source>
          <target state="translated">方法签名:</target>
        </trans-unit>
        <trans-unit id="f2689175bd2423f6686ae7bc6456bdb43ffb0fd2" translate="yes" xml:space="preserve">
          <source>Note that this takes a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#sum&quot;&gt;regular expression&lt;/a&gt;, so remember to escape &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;special characters&lt;/a&gt; if necessary.</source>
          <target state="translated">请注意，这需要一个&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#sum&quot;&gt;正则表达式&lt;/a&gt; ，因此请记住在必要时转义&lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;特殊字符&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2a53efac5096370ec7851ba3b6a71bc3e8c97d59" translate="yes" xml:space="preserve">
          <source>Note, this does not take a regular expression. For that, use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-&quot;&gt;&lt;code&gt;String#matches()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">注意，这不需要正则表达式。 为此，请使用&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-&quot;&gt; &lt;code&gt;String#matches()&lt;/code&gt; &lt;/a&gt;代替。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="513d0f10bf46562c61b583d103c88e43eb73c3f4" translate="yes" xml:space="preserve">
          <source>One way to do this is to run through the String in a for-each loop and use the required split character.</source>
          <target state="translated">一种方法是在for-each循环中运行String,并使用所需的分割字符。</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="5511135f9bda614cd85fc511dd6cc901ed9ac0c1" translate="yes" xml:space="preserve">
          <source>Pattern.compile(regexp).splitAsStream(input):</source>
          <target state="translated">Pattern.compile(regexp).splitAsStream(input):</target>
        </trans-unit>
        <trans-unit id="e668e302dd28bb529bbcea9393d214b1f72d72a5" translate="yes" xml:space="preserve">
          <source>Please don't use &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html&quot;&gt;StringTokenizer&lt;/a&gt; class as it is a legacy class that is retained for compatibility reasons, and its use is discouraged in new code. And we can make use of the split method as suggested by others as well.</source>
          <target state="translated">请不要使用&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html&quot;&gt;StringTokenizer&lt;/a&gt;类，因为它是出于兼容性原因而保留的旧类，并且在新代码中不鼓励使用它。 我们也可以使用其他人建议的split方法。</target>
        </trans-unit>
        <trans-unit id="bbfc20ca78fd6cf9b899cc707fe259878f888277" translate="yes" xml:space="preserve">
          <source>So you can choose the best option for you depending on what you need, e.g. return type (array, list, or iterable).</source>
          <target state="translated">所以你可以根据你的需求选择最适合你的选项,比如返回类型(数组、列表或迭代)。</target>
        </trans-unit>
        <trans-unit id="8be17a304e765e19a6319cd20c6fe0da067be66f" translate="yes" xml:space="preserve">
          <source>So, if you want to split on e.g. period/dot &lt;code&gt;.&lt;/code&gt; which means &quot;&lt;a href=&quot;http://www.regular-expressions.info/dot.html&quot;&gt;any character&lt;/a&gt;&quot; in regex, use either &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;backslash &lt;code&gt;\&lt;/code&gt;&lt;/a&gt; to escape the individual special character like so &lt;code&gt;split(&quot;\\.&quot;)&lt;/code&gt;, or use &lt;a href=&quot;http://www.regular-expressions.info/charclass.html&quot;&gt;character class &lt;code&gt;[]&lt;/code&gt;&lt;/a&gt; to represent literal character(s) like so &lt;code&gt;split(&quot;[.]&quot;)&lt;/code&gt;, or use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#quote-java.lang.String-&quot;&gt;&lt;code&gt;Pattern#quote()&lt;/code&gt;&lt;/a&gt; to escape the entire string like so &lt;code&gt;split(Pattern.quote(&quot;.&quot;))&lt;/code&gt;.</source>
          <target state="translated">因此，如果您想分割例如period / dot &lt;code&gt;.&lt;/code&gt; 这表示正则表达式中的&amp;ldquo; &lt;a href=&quot;http://www.regular-expressions.info/dot.html&quot;&gt;任何字符&lt;/a&gt; &amp;rdquo;，请使用&lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;反斜杠 &lt;code&gt;\&lt;/code&gt; &lt;/a&gt;来转义单个特殊字符，例如 &lt;code&gt;split(&quot;\\.&quot;)&lt;/code&gt; ，或使用&lt;a href=&quot;http://www.regular-expressions.info/charclass.html&quot;&gt;字符类 &lt;code&gt;[]&lt;/code&gt; &lt;/a&gt;来表示文字字符，例如 &lt;code&gt;split(&quot;[.]&quot;)&lt;/code&gt; ，或使用&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#quote-java.lang.String-&quot;&gt; &lt;code&gt;Pattern#quote()&lt;/code&gt; &lt;/a&gt;像 &lt;code&gt;split(Pattern.quote(&quot;.&quot;))&lt;/code&gt; 这样转义整个字符串。</target>
        </trans-unit>
        <trans-unit id="0a74d76701ae5ebf50bbbd415c4b559ff9f240db" translate="yes" xml:space="preserve">
          <source>String.split():</source>
          <target state="translated">String.split():</target>
        </trans-unit>
        <trans-unit id="21c6a5aab11d8d9baff2af00b73b27e61eb1bb70" translate="yes" xml:space="preserve">
          <source>StringTokenizer (legacy class):</source>
          <target state="translated">StringTokenizer(传统类)。</target>
        </trans-unit>
        <trans-unit id="d426fef84e8059c41d3b539263be4a0ac67f062c" translate="yes" xml:space="preserve">
          <source>That means the first string will contain the characters before &lt;code&gt;'-'&lt;/code&gt;, and the second string will contain the characters after &lt;code&gt;'-'&lt;/code&gt;. I also want to check if the string has &lt;code&gt;'-'&lt;/code&gt; in it. If not, I will throw an exception. How can I do this?</source>
          <target state="translated">这意味着第一个字符串将包含 &lt;code&gt;'-'&lt;/code&gt; 之前的字符，第二个字符串将包含 &lt;code&gt;'-'&lt;/code&gt; 之后的字符。 我还想检查字符串中是否包含 &lt;code&gt;'-'&lt;/code&gt; 。 如果没有，我将抛出异常。 我怎样才能做到这一点？</target>
        </trans-unit>
        <trans-unit id="03bb0d5c446aa1406a8c75e4f03caf43097a0e68" translate="yes" xml:space="preserve">
          <source>The easiest way is to use &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/StringUtils.html#split%28java.lang.String,%20char%29&quot;&gt;StringUtils#split(java.lang.String, char)&lt;/a&gt;. That's more convenient than the one provided by Java out of the box if you don't need regular expressions. Like its manual says, it works like this:</source>
          <target state="translated">最简单的方法是使用&lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/StringUtils.html#split%28java.lang.String,%20char%29&quot;&gt;StringUtils＃split（java.lang.String，char）&lt;/a&gt; 。 如果您不需要正则表达式，那比开箱即用的Java提供的便利。 如其手册所述，它的工作方式如下：</target>
        </trans-unit>
        <trans-unit id="8e7dd528a45dc621b7c1f129d523220331c90b22" translate="yes" xml:space="preserve">
          <source>The fastest way, which also consumes the least resource could be:</source>
          <target state="translated">最快的方式,也是消耗资源最少的方式,可能是。</target>
        </trans-unit>
        <trans-unit id="9f53375b26efb231c64a3a09d645c097bdb5794a" translate="yes" xml:space="preserve">
          <source>The parentheses denote the capturing groups; the string that matched that part of the regexp can be accessed by the Match.group() method, as shown. The \d matches and single decimal digit, and the + means &quot;match one or more of the previous expression). The - has no special meaning, so just matches that character in the input. Note that you need to double-escape the backslashes when writing this as a Java string. Some other examples:</source>
          <target state="translated">括号中的括号表示捕获组;与该部分regexp匹配的字符串可以通过Match.group()方法访问,如图所示。\d表示匹配和单位小数,+表示 &quot;匹配前面的一个或多个表达式&quot;。)而-没有特殊的含义,所以只是匹配输入中的那个字符。注意,当你把它写成Java字符串时,需要双倍地去掉反斜线。其他一些例子。</target>
        </trans-unit>
        <trans-unit id="2f1564091c8c399fe0cdae8db88204245585770c" translate="yes" xml:space="preserve">
          <source>The requirements left room for interpretation. I recommend writing a method,</source>
          <target state="translated">要求留下了解释的空间。我建议写一个方法。</target>
        </trans-unit>
        <trans-unit id="22ef733bbe3da925412acc480b7de8dc28db3462" translate="yes" xml:space="preserve">
          <source>The split method has an optimization to avoid using a regular expression if the delimeter is a single character and not in the above list. Otherwise, it has to compile a regular expression, and this is not ideal.</source>
          <target state="translated">分割方法有一个优化,如果delimeter是单个字符,且不在上面的列表中,则可以避免使用正则表达式。否则,它必须编译一个正则表达式,这并不理想。</target>
        </trans-unit>
        <trans-unit id="1039d4d97263436c7612e24c3014607be2955a3f" translate="yes" xml:space="preserve">
          <source>There are only two methods you really need to consider.</source>
          <target state="translated">真正需要考虑的方法只有两种,你真正需要考虑的只有两种。</target>
        </trans-unit>
        <trans-unit id="2ad5934937e5bc61b345d24f3e22d06c154410c1" translate="yes" xml:space="preserve">
          <source>This last option still creates a new &lt;code&gt;Matcher&lt;/code&gt; object. You can also cache this object and reset it for each input for maximum performance, but that is somewhat more complicated and not thread-safe.</source>
          <target state="translated">最后一个选项仍然创建一个新的 &lt;code&gt;Matcher&lt;/code&gt; 对象。 您也可以缓存该对象并为每个输入重置它，以实现最佳性能，但这会更加复杂并且不是线程安全的。</target>
        </trans-unit>
        <trans-unit id="43e999a4c1efce2357ea1d7e7bdbe6f82739b5f6" translate="yes" xml:space="preserve">
          <source>This split (regex) takes a regex as an argument. Remember to escape the regex special characters, like period/dot.</source>
          <target state="translated">这个 split (regex)以一个 regex 作为参数。记住要转义掉gex中的特殊字符,比如句号dot。</target>
        </trans-unit>
        <trans-unit id="6e02947cedc98e75e3a5b241b30474e9a29c52f5" translate="yes" xml:space="preserve">
          <source>This will split your string into 2 parts.  The first element in the array will be the part containing the stuff before the &lt;code&gt;-&lt;/code&gt;, and the 2nd element in the array will contain the part of your string after the &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">这会将您的字符串分成两部分。 数组中的第一个元素将是在 &lt;code&gt;-&lt;/code&gt; 之前包含内容的部分，而数组中的第二个元素将在 &lt;code&gt;-&lt;/code&gt; 之后包含字符串的一部分。</target>
        </trans-unit>
        <trans-unit id="c3ba0939a339061a816f3d87d8a1aee227e57443" translate="yes" xml:space="preserve">
          <source>To split a string, use &lt;code&gt;String.split(regex)&lt;/code&gt;:</source>
          <target state="translated">要拆分字符串，请使用 &lt;code&gt;String.split(regex)&lt;/code&gt; ：</target>
        </trans-unit>
        <trans-unit id="7f8658a552c8fddac1aee7a513aab32ff40548cf" translate="yes" xml:space="preserve">
          <source>To split a string, uses String.split(regex). Review the following examples:</source>
          <target state="translated">要分割一个字符串,使用String.split(regex)。请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="c44d828d0c1bacc16a8f1111f9c0c20fb6c9d9c3" translate="yes" xml:space="preserve">
          <source>To summarize: there are at least five ways to split a string in Java:</source>
          <target state="translated">总结一下:在Java中至少有5种方法可以拆分字符串。</target>
        </trans-unit>
        <trans-unit id="67f374ebe587596fe19b000771190ad3bf1d5ff3" translate="yes" xml:space="preserve">
          <source>To test beforehand if the string contains certain character(s), just use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contains-java.lang.CharSequence-&quot;&gt;&lt;code&gt;String#contains()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">要预先测试字符串是否包含某些字符，只需使用&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contains-java.lang.CharSequence-&quot;&gt; &lt;code&gt;String#contains()&lt;/code&gt; 即可&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="694f7e706eb39c40b04c5d4f24c5a1b3abd95ca5" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html#split(java.lang.String,%20char)&quot;&gt;org.apache.commons.lang.StringUtils'&lt;/a&gt; split method which can split strings based on the character or string you want to split.</source>
          <target state="translated">使用&lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html#split(java.lang.String,%20char)&quot;&gt;org.apache.commons.lang.StringUtils的&lt;/a&gt; split方法，该方法可以根据要拆分的字符或字符串拆分字符串。</target>
        </trans-unit>
        <trans-unit id="f48b143c73a3beedf263bb97736aed29d112cc45" translate="yes" xml:space="preserve">
          <source>WAY 1: As you have to split two numbers by a special character you can use regex</source>
          <target state="translated">方法1:因为你必须用一个特殊的字符来分割两个数字,你可以使用regex</target>
        </trans-unit>
        <trans-unit id="92a973bd215f622efe5ef3b4c633dbd595f59547" translate="yes" xml:space="preserve">
          <source>WAY 2: Using the string split method</source>
          <target state="translated">方法2:使用字符串分割法</target>
        </trans-unit>
        <trans-unit id="dd91b0658c6cf431015b14f6a00de46f9c97ac60" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of the input
  sequence then an empty leading substring is included at the beginning
  of the resulting array. A zero-width match at the beginning however
  never produces such empty leading substring.</source>
          <target state="translated">当输入序列的开头有一个正宽度的匹配,那么在生成的数组的开头就会包含一个空的前导子串。但是,在开始时的零宽度匹配不会产生这样的空前导数组。</target>
        </trans-unit>
        <trans-unit id="7b43177b490dfd01ed6e0438b89a88ed36b1419b" translate="yes" xml:space="preserve">
          <source>With Java 8:</source>
          <target state="translated">随着Java 8。</target>
        </trans-unit>
        <trans-unit id="d70aaa84bc798cb8b2c647782fe43a7cdc3b3869" translate="yes" xml:space="preserve">
          <source>With defining the according test results, you can specify the behaviour.</source>
          <target state="translated">有了根据测试结果的定义,你可以指定行为。</target>
        </trans-unit>
        <trans-unit id="76bb20eab98c1196b2934f9ecb1f186851f4c3a0" translate="yes" xml:space="preserve">
          <source>You can simply do as follows:</source>
          <target state="translated">你可以简单地做到以下几点。</target>
        </trans-unit>
        <trans-unit id="745adfbaebad4644181f103c3028a3163d9a0618" translate="yes" xml:space="preserve">
          <source>You can simply use StringTokenizer to split a string in two or more parts whether there are any type of delimiters:</source>
          <target state="translated">你可以简单地使用StringTokenizer将一个字符串分成两部分或更多部分,无论是否有任何类型的分隔符。</target>
        </trans-unit>
        <trans-unit id="19694d4c4ce9f54704ac6515420ed6e3759bcebb" translate="yes" xml:space="preserve">
          <source>You can split a string by a hyphen/character by using the following statement:</source>
          <target state="translated">你可以使用下面的语句,用连字符来分割一个字符串。</target>
        </trans-unit>
        <trans-unit id="f73c5ea266b5f4a2c5c45a763ef228fc21408fdc" translate="yes" xml:space="preserve">
          <source>You can split a string by a line break by using the following statement:</source>
          <target state="translated">你可以使用下面的语句来分割一个字符串。</target>
        </trans-unit>
        <trans-unit id="40de6a8dc52dcc8f5824e304163fb8987a745e82" translate="yes" xml:space="preserve">
          <source>You can try like this also</source>
          <target state="translated">你也可以尝试这样做</target>
        </trans-unit>
        <trans-unit id="54f18385d816c9a4bacc1a8fbc3b8590fbabb8e9" translate="yes" xml:space="preserve">
          <source>You can use Split():</source>
          <target state="translated">你可以使用Split()。</target>
        </trans-unit>
        <trans-unit id="aa9dfb7e3dece5be03c64f343a81607eca2aa807" translate="yes" xml:space="preserve">
          <source>You can use the method &lt;code&gt;split&lt;/code&gt;:</source>
          <target state="translated">您可以使用 &lt;code&gt;split&lt;/code&gt; 方法：</target>
        </trans-unit>
        <trans-unit id="9668d451d8c924278f7d7ecccc4e44a51b306de9" translate="yes" xml:space="preserve">
          <source>You should write some unit-tests for input strings and the desired results and behaviour.</source>
          <target state="translated">你应该写一些输入字符串的单元测试,以及期望的结果和行为。</target>
        </trans-unit>
        <trans-unit id="df28550c3b81f1b880a49ceb27fb76bcc7fa42ee" translate="yes" xml:space="preserve">
          <source>should do thing you want. String class has many method to operate with string.</source>
          <target state="translated">应该做你想要的事情。String类有很多方法来操作字符串。</target>
        </trans-unit>
        <trans-unit id="0b96290f91b9d7829c5e672bebedfa30ff377327" translate="yes" xml:space="preserve">
          <source>we will get three strings: &lt;code&gt;[0, 0, 4]&lt;/code&gt; and not four as was the case in Java 7 and before. Also check this similar &lt;a href=&quot;https://stackoverflow.com/questions/22718744/why-in-java-8-split-sometimes-removes-empty-strings-at-start-of-result-array&quot;&gt;question&lt;/a&gt;.</source>
          <target state="translated">我们将得到三个字符串： &lt;code&gt;[0, 0, 4]&lt;/code&gt; 而不是Java 7及以前版本中的四个。 还要检查类似的&lt;a href=&quot;https://stackoverflow.com/questions/22718744/why-in-java-8-split-sometimes-removes-empty-strings-at-start-of-result-array&quot;&gt;问题&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="2345d121bec649a607f505938c08c500e93234d7" translate="yes" xml:space="preserve">
          <source>which encapsulate this function. Of course you can use String.split(..) as mentioned in the other answers for the implementation.</source>
          <target state="translated">其中封装了这个函数。当然,你可以使用String.split(...),如其他答案中提到的实现。</target>
        </trans-unit>
        <trans-unit id="3fcd8bbf37ea44a0a387328f2a950f3728942e2c" translate="yes" xml:space="preserve">
          <source>you don't really need regular expressions for your split</source>
          <target state="translated">你其实不需要正则表达式来表达你的分词。</target>
        </trans-unit>
        <trans-unit id="bda5d696e27288e5ed234a4c1931bcf4af52f245" translate="yes" xml:space="preserve">
          <source>you happen to already use apache commons lang in your app</source>
          <target state="translated">你已经在你的应用程序中使用了apache commons语言</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
