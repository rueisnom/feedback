<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/3481828">
    <body>
      <group id="3481828">
        <trans-unit id="634a0bdd960a66ce1185d269b6e09c19a16d7e59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;there&lt;/a&gt; are 12 characters with special meanings: the backslash &lt;code&gt;\&lt;/code&gt;, the caret &lt;code&gt;^&lt;/code&gt;, the dollar sign &lt;code&gt;$&lt;/code&gt;, the period or dot &lt;code&gt;.&lt;/code&gt;, the vertical bar or pipe symbol &lt;code&gt;|&lt;/code&gt;, the question mark &lt;code&gt;?&lt;/code&gt;, the asterisk or star &lt;code&gt;*&lt;/code&gt;, the plus sign &lt;code&gt;+&lt;/code&gt;, the opening parenthesis &lt;code&gt;(&lt;/code&gt;, the closing parenthesis &lt;code&gt;)&lt;/code&gt;, and the opening square bracket &lt;code&gt;[&lt;/code&gt;, the opening curly brace &lt;code&gt;{&lt;/code&gt;, These special characters are often called &quot;metacharacters&quot;.</source>
          <target state="translated">特殊な意味を持つ12文字&lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;があり&lt;/a&gt;ます：バックスラッシュ &lt;code&gt;\&lt;/code&gt; 、キャレット &lt;code&gt;^&lt;/code&gt; 、ドル記号 &lt;code&gt;$&lt;/code&gt; 、ピリオドまたはドット &lt;code&gt;.&lt;/code&gt; 、縦棒またはパイプ記号 &lt;code&gt;|&lt;/code&gt; 、疑問符 &lt;code&gt;?&lt;/code&gt; 、アスタリスクまたはスター &lt;code&gt;*&lt;/code&gt; 、プラス記号 &lt;code&gt;+&lt;/code&gt; 、左括弧 &lt;code&gt;(&lt;/code&gt; 、右括弧 &lt;code&gt;)&lt;/code&gt; 、および左大括弧 &lt;code&gt;[&lt;/code&gt; 、左中括弧 &lt;code&gt;{&lt;/code&gt; 、これらの特殊文字は、しばしば「メタ文字」と呼ばれます。</target>
        </trans-unit>
        <trans-unit id="9eaaedfd4cc1e7d310987fa57faf8f0dadb38f16" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://explainjava.com/split-string-java/&quot;&gt;Here&lt;/a&gt; is a big overview of these methods and the most common examples (how to split by dot, slash, question mark, etc.)</source>
          <target state="translated">これらのメソッドと最も一般的な例の大まかな概要を&lt;a href=&quot;https://explainjava.com/split-string-java/&quot;&gt;以下に&lt;/a&gt;示します（ドット、スラッシュ、疑問符などで分割する方法）。</target>
        </trans-unit>
        <trans-unit id="e1313d9d177aa767a2f19ce3fbfac579ced79591" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;String Split with multiple characters using Regex&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;正規表現を使用した複数の文字による文字列分割&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c16943696a740385ff52f52ff01f2c21d575844" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use Pattern.split and precompile the pattern if using a complex delimiter and you care about performance.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;複雑な区切り文字を使用し、パフォーマンスを重視する場合は、Pattern.splitを使用してパターンをプリコンパイルします。&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54fbcdde970b3680f7855bf3eb18ae8469d7ce0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use String.split for a one-character delimiter or you don't care about performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1文字の区切り文字としてString.splitを使用するか、パフォーマンスを気にしない&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7eeb6651db327271e5d1629a11d7fe0d16a7d8b" translate="yes" xml:space="preserve">
          <source>An alternative to processing the string directly would be to use a regular expression with capturing groups. This has the advantage that it makes it straightforward to imply more sophisticated constraints on the input. For example, the following splits the string into two parts, and ensures that both consist only of digits:</source>
          <target state="translated">文字列を直接処理する代わりに、グループをキャプチャする正規表現を使用することができます。これには、入力に対してより洗練された制約を簡単に与えることができるという利点があります。例えば、以下の例では、文字列を2つの部分に分割し、両方とも数字のみで構成されることを保証しています。</target>
        </trans-unit>
        <trans-unit id="19627da7883a0613ac58045d6ef1f0d8e6c29df6" translate="yes" xml:space="preserve">
          <source>And as expected it will print:</source>
          <target state="translated">そして予想通り印刷されます。</target>
        </trans-unit>
        <trans-unit id="281d300200893a33e3537d992266d3b91d6ad40f" translate="yes" xml:space="preserve">
          <source>Apache Commons StringUtils:</source>
          <target state="translated">Apache Commons StringUtils.</target>
        </trans-unit>
        <trans-unit id="0bd2c33eab401a57c01e405d1bbc1c234e7435b3" translate="yes" xml:space="preserve">
          <source>As mentioned by everyone, split() is the best option which may be used in your case. An alternative method can be using substring().</source>
          <target state="translated">みんなが言っているように、split()はあなたの場合に使用できる最良のオプションです。別の方法として、 substring()を使うこともできます。</target>
        </trans-unit>
        <trans-unit id="455bf4d4aefbaf76e95abcb994d64522e57f5a43" translate="yes" xml:space="preserve">
          <source>As the pattern is fixed in this instance, it can be compiled in advance and stored as a static member (initialised at class load time in the example). The regular expression is:</source>
          <target state="translated">このインスタンスではパターンが固定されているので、あらかじめコンパイルして静的メンバとして格納しておくことができます(例ではクラスのロード時に初期化されています)。正規表現は</target>
        </trans-unit>
        <trans-unit id="acd8d9d3530feb7f220a993eb4bc93080beec114" translate="yes" xml:space="preserve">
          <source>Assume that if &lt;code&gt;-&lt;/code&gt; does not exists in your string, it returns the given string, and you will not get any exception.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; が文字列に存在しない場合は、指定された文字列を返し、例外は発生しないと想定します。</target>
        </trans-unit>
        <trans-unit id="b598f05f355293d3ba808a995629e736abdf52ac" translate="yes" xml:space="preserve">
          <source>Assuming, that</source>
          <target state="translated">仮に</target>
        </trans-unit>
        <trans-unit id="170679a43c9b6393ea32de0f697ab9d50e3a0a66" translate="yes" xml:space="preserve">
          <source>But do not expect the same output across all JDK versions. I have seen &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8043324&quot;&gt;one bug&lt;/a&gt; which exists in some JDK versions where the first null string has been ignored. This bug is not present in the latest JDK version, but it exists in some versions between JDK 1.7 late versions and 1.8 early versions.</source>
          <target state="translated">ただし、すべてのJDKバージョンで同じ出力を期待しないでください。 最初のnull文字列が無視された一部のJDKバージョンに存在する&lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8043324&quot;&gt;バグ&lt;/a&gt;を1つ見ました。 このバグは最新のJDKバージョンには存在しませんが、JDK 1.7の最新バージョンと1.8の初期バージョンの間の一部のバージョンに存在します。</target>
        </trans-unit>
        <trans-unit id="2e0832e81bd97677c3c3e45f933928a5b9fcf585" translate="yes" xml:space="preserve">
          <source>Check out the &lt;code&gt;split()&lt;/code&gt; method in the &lt;code&gt;String&lt;/code&gt; class on javadoc.</source>
          <target state="translated">javadocの &lt;code&gt;String&lt;/code&gt; クラスの &lt;code&gt;split()&lt;/code&gt; メソッドを確認してください。</target>
        </trans-unit>
        <trans-unit id="9e823ab53cec95c3e300ab785e078436d9d366d4" translate="yes" xml:space="preserve">
          <source>Check out the &lt;code&gt;split()&lt;/code&gt; method in the &lt;code&gt;String&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; クラスの &lt;code&gt;split()&lt;/code&gt; メソッドを確認してください。</target>
        </trans-unit>
        <trans-unit id="3172bac692f1e831e3ef1816e8723add91fa4296" translate="yes" xml:space="preserve">
          <source>Else, you can use StringTokenizer:</source>
          <target state="translated">それ以外の場合は、StringTokenizerを使用することができます。</target>
        </trans-unit>
        <trans-unit id="26e0e8524f90a3c867fdd33bcd49bb6fa8f4e4d0" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;&quot;-333&quot;&lt;/code&gt; should return in &lt;code&gt;[,333]&lt;/code&gt; or if it is an error.
Can &lt;code&gt;&quot;333-333-33&quot;&lt;/code&gt; be separated in &lt;code&gt;[333,333-33] or [333-333,33]&lt;/code&gt; or is it an error? And so on.</source>
          <target state="translated">たとえば、 &lt;code&gt;&quot;-333&quot;&lt;/code&gt; が &lt;code&gt;[,333]&lt;/code&gt; 返される場合、またはエラーの場合。 &lt;code&gt;&quot;333-333-33&quot;&lt;/code&gt; を &lt;code&gt;[333,333-33] or [333-333,33]&lt;/code&gt; ことはできますか、それともエラーですか？ 等々。</target>
        </trans-unit>
        <trans-unit id="a959961f689dc6305eb84be8327b92d85950c3fd" translate="yes" xml:space="preserve">
          <source>For simple use cases &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;&lt;code&gt;String.split()&lt;/code&gt;&lt;/a&gt; should do the job. If you use guava, there is also a &lt;a href=&quot;https://github.com/google/guava/wiki/StringsExplained#splitter&quot;&gt;Splitter&lt;/a&gt; class which allows chaining of different string operations and supports &lt;a href=&quot;https://google.github.io/guava/releases/snapshot-jre/api/docs/com/google/common/base/CharMatcher.html&quot;&gt;CharMatcher&lt;/a&gt;:</source>
          <target state="translated">単純な使用例では、 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt; &lt;code&gt;String.split()&lt;/code&gt; &lt;/a&gt;が適切に機能します。 &lt;a href=&quot;https://google.github.io/guava/releases/snapshot-jre/api/docs/com/google/common/base/CharMatcher.html&quot;&gt;guava&lt;/a&gt;を使用する場合、さまざまな文字列操作のチェーンを可能にし、 CharMatcherをサポートする&lt;a href=&quot;https://github.com/google/guava/wiki/StringsExplained#splitter&quot;&gt;Splitter&lt;/a&gt;クラスもあります。</target>
        </trans-unit>
        <trans-unit id="41aa5e8cca232ef96ae8344d4180dbf6e0984c6c" translate="yes" xml:space="preserve">
          <source>Good test candidates should include:</source>
          <target state="translated">良いテストの候補者は、次のようなものが含まれている必要があります。</target>
        </trans-unit>
        <trans-unit id="66c15e0f61dc4ba39ea4ecd546d9001621adbb7c" translate="yes" xml:space="preserve">
          <source>Google Guava Splitter:</source>
          <target state="translated">Googleグアバのスプリッター。</target>
        </trans-unit>
        <trans-unit id="1b570f545b2da28a044cb15d0d777d7bb12661f7" translate="yes" xml:space="preserve">
          <source>Here are two ways two achieve it.</source>
          <target state="translated">ここでは、2つの方法で実現しています。</target>
        </trans-unit>
        <trans-unit id="d7702fb6307a48ed358e3bf97b7b58828135f99f" translate="yes" xml:space="preserve">
          <source>Here many examples for split string but I little code optimized.</source>
          <target state="translated">ここでは、文字列を分割するための多くの例がありますが、私は少しコードが最適化されています。</target>
        </trans-unit>
        <trans-unit id="ecaeeb1e045a34e4ed62d11ef9b1606af81639f3" translate="yes" xml:space="preserve">
          <source>How to split a string in Java</source>
          <target state="translated">Javaで文字列を分割する方法</target>
        </trans-unit>
        <trans-unit id="9d00bd1b546789395f672ebe1d098d7b4670e821" translate="yes" xml:space="preserve">
          <source>I have a string, &lt;code&gt;&quot;004-034556&quot;&lt;/code&gt;, that I want to split into two strings:</source>
          <target state="translated">2つの文字列に分割したい文字列 &lt;code&gt;&quot;004-034556&quot;&lt;/code&gt; があります。</target>
        </trans-unit>
        <trans-unit id="597fca85260a03d531d03509982c894f6ec88d3a" translate="yes" xml:space="preserve">
          <source>I just wanted to write an algorithm instead of using Java built-in functions:</source>
          <target state="translated">Javaの組み込み関数を使うのではなく、アルゴリズムを書きたかっただけです。</target>
        </trans-unit>
        <trans-unit id="73640238f9039cdaa6a85588bf8ae148414cb776" translate="yes" xml:space="preserve">
          <source>I would recommend using commong-lang, since usually it contains a lot of stuff that's usable. However, if you don't need it for anything else than doing a split, then implementing yourself or escaping the regex is a better option.</source>
          <target state="translated">commong-lang を使うことをお勧めします。しかし、スプリット以外に必要ないのであれば、自分で実装するか正規表現をエスケープする方が良いでしょう。</target>
        </trans-unit>
        <trans-unit id="35f5eaeb8f626d3b81bb83d806e7bb128d180dfa" translate="yes" xml:space="preserve">
          <source>If performance is an issue, and your delimiter is not one of the above, you should pre-compile a regular expression pattern which you can then reuse.</source>
          <target state="translated">パフォーマンスに問題があり、デリミタが上記のいずれでもない場合は、正規表現パターンを事前にコンパイルして再利用する必要があります。</target>
        </trans-unit>
        <trans-unit id="5711570bf541c6fabc965cce5a0f19929f00eb29" translate="yes" xml:space="preserve">
          <source>If performance is not an issue, or if the delimiter is a single character that is not a regular expression special character (i.e., not one of &lt;code&gt;.$|()[{^?*+\&lt;/code&gt;) then you can use &lt;code&gt;String.split&lt;/code&gt;.</source>
          <target state="translated">パフォーマンスに問題がない場合、または区切り文字が正規表現の特殊文字ではない単一の文字（つまり、 &lt;code&gt;.$|()[{^?*+\&lt;/code&gt; ）である場合は、 &lt;code&gt;String.split&lt;/code&gt; を使用できます。</target>
        </trans-unit>
        <trans-unit id="abb4797fa4e7a9f330539336db1653a5f6b50e22" translate="yes" xml:space="preserve">
          <source>If the array length is not 2, then the string was not in the format: &lt;code&gt;string-string&lt;/code&gt;.</source>
          <target state="translated">配列の長さが2でない場合、文字列は &lt;code&gt;string-string&lt;/code&gt; の形式ではありませんでした。</target>
        </trans-unit>
        <trans-unit id="c9379386900a7ba181b578a891a6edd088cb32a8" translate="yes" xml:space="preserve">
          <source>If you'd like to limit the number of resulting parts, then you can supply the desired number as 2nd argument of &lt;code&gt;split()&lt;/code&gt; method.</source>
          <target state="translated">結果のパーツの数を制限したい場合は、 &lt;code&gt;split()&lt;/code&gt; メソッドの2番目の引数として必要な数を指定できます。</target>
        </trans-unit>
        <trans-unit id="cf486efb110a169d1ec321ad391237aea75e64a5" translate="yes" xml:space="preserve">
          <source>If you'd like to retain the split character in the resulting parts, then make use of &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;positive lookaround&lt;/a&gt;. In case you want to have the split character to end up in left hand side, use positive lookbehind by prefixing &lt;code&gt;?&amp;lt;=&lt;/code&gt; group on the pattern.</source>
          <target state="translated">結果のパーツの分割文字を保持したい場合は、 &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;ポジティブルックアラウンド&lt;/a&gt;を利用してください。 分割文字を左側に配置したい場合は、パターンの前に &lt;code&gt;?&amp;lt;=&lt;/code&gt; グループを付けて、肯定的な後読みを使用します。</target>
        </trans-unit>
        <trans-unit id="7d5bcf86d6aef4f63d20823de18fef46a3444d8b" translate="yes" xml:space="preserve">
          <source>In case you want to have the split character to end up in right hand side, use positive lookahead by prefixing &lt;code&gt;?=&lt;/code&gt; group on the pattern.</source>
          <target state="translated">分割文字を右端にしたい場合は、パターンの &lt;code&gt;?=&lt;/code&gt; グループを接頭辞として正の先読みを使用します。</target>
        </trans-unit>
        <trans-unit id="d4d53e1a023a39b0d46c1060abcaf2ee36561cad" translate="yes" xml:space="preserve">
          <source>In this answer I also want to point out &lt;strong&gt;one change that has taken place for &lt;code&gt;split&lt;/code&gt; method in Java 8&lt;/strong&gt;. The &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;String#split()&lt;/a&gt; method makes use of &lt;code&gt;Pattern.split&lt;/code&gt;, and now it will remove empty strings at the start of the result array. Notice this &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-int-&quot;&gt;change&lt;/a&gt; in documentation for Java 8:</source>
          <target state="translated">この回答&lt;strong&gt;では、Java 8の &lt;code&gt;split&lt;/code&gt; メソッドで行わ&lt;/strong&gt;れた&lt;strong&gt;1つの変更について&lt;/strong&gt;も指摘したいと思います。 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;String＃split（）&lt;/a&gt;メソッドは、 &lt;code&gt;Pattern.split&lt;/code&gt; を利用し、結果の配列の先頭にある空の文字列を削除します。 Java 8のドキュメントにおけるこの&lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-int-&quot;&gt;変更&lt;/a&gt;に注意してください 。</target>
        </trans-unit>
        <trans-unit id="9d7ee1e0bfdc43c72fde2787f5595a8e3fe895b2" translate="yes" xml:space="preserve">
          <source>In your case, you want to split a string when there is a &quot;-&quot;.</source>
          <target state="translated">あなたの場合は、&quot;-&quot;があるときに文字列を分割したいと思います。</target>
        </trans-unit>
        <trans-unit id="e1bab11672544eaa3fe560aec8ed33483038ee1c" translate="yes" xml:space="preserve">
          <source>It means for the following example:</source>
          <target state="translated">以下の例のための意味です。</target>
        </trans-unit>
        <trans-unit id="708293cbdedf6516d4e9d0f795068139869bebd2" translate="yes" xml:space="preserve">
          <source>Just use the appropriate method: &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;&lt;code&gt;String#split()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">適切なメソッドを使用してください： &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt; &lt;code&gt;String#split()&lt;/code&gt; &lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="a1366efda6e348068340179972f16275440d6ada" translate="yes" xml:space="preserve">
          <source>Method signature:</source>
          <target state="translated">メソッドの署名。</target>
        </trans-unit>
        <trans-unit id="f2689175bd2423f6686ae7bc6456bdb43ffb0fd2" translate="yes" xml:space="preserve">
          <source>Note that this takes a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#sum&quot;&gt;regular expression&lt;/a&gt;, so remember to escape &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;special characters&lt;/a&gt; if necessary.</source>
          <target state="translated">これは&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#sum&quot;&gt;正規表現を&lt;/a&gt;とるため、必要に応じて&lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;特殊文字&lt;/a&gt;をエスケープすることを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="2a53efac5096370ec7851ba3b6a71bc3e8c97d59" translate="yes" xml:space="preserve">
          <source>Note, this does not take a regular expression. For that, use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-&quot;&gt;&lt;code&gt;String#matches()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">これは正規表現を取りません。 そのためには、代わりに&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-&quot;&gt; &lt;code&gt;String#matches()&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="513d0f10bf46562c61b583d103c88e43eb73c3f4" translate="yes" xml:space="preserve">
          <source>One way to do this is to run through the String in a for-each loop and use the required split character.</source>
          <target state="translated">これを行う方法の1つは、Stringをfor-eachループで実行し、必要な分割文字を使用することです。</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="5511135f9bda614cd85fc511dd6cc901ed9ac0c1" translate="yes" xml:space="preserve">
          <source>Pattern.compile(regexp).splitAsStream(input):</source>
          <target state="translated">Pattern.compile(regexp).splitAsStream(input):</target>
        </trans-unit>
        <trans-unit id="e668e302dd28bb529bbcea9393d214b1f72d72a5" translate="yes" xml:space="preserve">
          <source>Please don't use &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html&quot;&gt;StringTokenizer&lt;/a&gt; class as it is a legacy class that is retained for compatibility reasons, and its use is discouraged in new code. And we can make use of the split method as suggested by others as well.</source>
          <target state="translated">&lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html&quot;&gt;StringTokenizer&lt;/a&gt;クラスは互換性のために保持されているレガシークラスであり、新しいコードでは使用しないようにしてください。 また、他の人から提案されているように、splitメソッドを使用することもできます。</target>
        </trans-unit>
        <trans-unit id="bbfc20ca78fd6cf9b899cc707fe259878f888277" translate="yes" xml:space="preserve">
          <source>So you can choose the best option for you depending on what you need, e.g. return type (array, list, or iterable).</source>
          <target state="translated">そのため、戻り値の型(配列、リスト、反復可能)など、必要なものに応じて最適なものを選ぶことができます。</target>
        </trans-unit>
        <trans-unit id="8be17a304e765e19a6319cd20c6fe0da067be66f" translate="yes" xml:space="preserve">
          <source>So, if you want to split on e.g. period/dot &lt;code&gt;.&lt;/code&gt; which means &quot;&lt;a href=&quot;http://www.regular-expressions.info/dot.html&quot;&gt;any character&lt;/a&gt;&quot; in regex, use either &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;backslash &lt;code&gt;\&lt;/code&gt;&lt;/a&gt; to escape the individual special character like so &lt;code&gt;split(&quot;\\.&quot;)&lt;/code&gt;, or use &lt;a href=&quot;http://www.regular-expressions.info/charclass.html&quot;&gt;character class &lt;code&gt;[]&lt;/code&gt;&lt;/a&gt; to represent literal character(s) like so &lt;code&gt;split(&quot;[.]&quot;)&lt;/code&gt;, or use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#quote-java.lang.String-&quot;&gt;&lt;code&gt;Pattern#quote()&lt;/code&gt;&lt;/a&gt; to escape the entire string like so &lt;code&gt;split(Pattern.quote(&quot;.&quot;))&lt;/code&gt;.</source>
          <target state="translated">したがって、たとえばピリオド/ドットで分割したい場合 &lt;code&gt;.&lt;/code&gt; つまり、正規表現では「 &lt;a href=&quot;http://www.regular-expressions.info/dot.html&quot;&gt;任意の文字&lt;/a&gt; 」を意味し、 &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;バックスラッシュ &lt;code&gt;\&lt;/code&gt; &lt;/a&gt;を使用してso &lt;code&gt;split(&quot;\\.&quot;)&lt;/code&gt; ような個々の特殊文字をエスケープするか、 &lt;a href=&quot;http://www.regular-expressions.info/charclass.html&quot;&gt;文字クラス &lt;code&gt;[]&lt;/code&gt; &lt;/a&gt;を使用してso &lt;code&gt;split(&quot;[.]&quot;)&lt;/code&gt; ようにリテラル文字を表します。 ] &quot;） 、または&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#quote-java.lang.String-&quot;&gt; &lt;code&gt;Pattern#quote()&lt;/code&gt; &lt;/a&gt;を使用して、文字列全体をそのようにエスケープします（ &lt;code&gt;split(Pattern.quote(&quot;.&quot;))&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="0a74d76701ae5ebf50bbbd415c4b559ff9f240db" translate="yes" xml:space="preserve">
          <source>String.split():</source>
          <target state="translated">String.split():</target>
        </trans-unit>
        <trans-unit id="21c6a5aab11d8d9baff2af00b73b27e61eb1bb70" translate="yes" xml:space="preserve">
          <source>StringTokenizer (legacy class):</source>
          <target state="translated">StringTokenizer(レガシークラス)。</target>
        </trans-unit>
        <trans-unit id="d426fef84e8059c41d3b539263be4a0ac67f062c" translate="yes" xml:space="preserve">
          <source>That means the first string will contain the characters before &lt;code&gt;'-'&lt;/code&gt;, and the second string will contain the characters after &lt;code&gt;'-'&lt;/code&gt;. I also want to check if the string has &lt;code&gt;'-'&lt;/code&gt; in it. If not, I will throw an exception. How can I do this?</source>
          <target state="translated">つまり、最初の文字列には &lt;code&gt;'-'&lt;/code&gt; の前の文字が含まれ、2番目の文字列には &lt;code&gt;'-'&lt;/code&gt; の後の文字が含まれます。 文字列に &lt;code&gt;'-'&lt;/code&gt; が含まれているかどうかも確認したいと思います。 そうでない場合は、例外をスローします。 これどうやってするの？</target>
        </trans-unit>
        <trans-unit id="03bb0d5c446aa1406a8c75e4f03caf43097a0e68" translate="yes" xml:space="preserve">
          <source>The easiest way is to use &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/StringUtils.html#split%28java.lang.String,%20char%29&quot;&gt;StringUtils#split(java.lang.String, char)&lt;/a&gt;. That's more convenient than the one provided by Java out of the box if you don't need regular expressions. Like its manual says, it works like this:</source>
          <target state="translated">最も簡単な方法は、 &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/StringUtils.html#split%28java.lang.String,%20char%29&quot;&gt;StringUtils＃split（java.lang.String、char）&lt;/a&gt;を使用することです。 正規表現が必要ない場合は、Javaが標準で提供しているものよりも便利です。 そのマニュアルが言うように、それはこのように機能します：</target>
        </trans-unit>
        <trans-unit id="8e7dd528a45dc621b7c1f129d523220331c90b22" translate="yes" xml:space="preserve">
          <source>The fastest way, which also consumes the least resource could be:</source>
          <target state="translated">最速の方法は、また、最小のリソースを消費する可能性があります。</target>
        </trans-unit>
        <trans-unit id="9f53375b26efb231c64a3a09d645c097bdb5794a" translate="yes" xml:space="preserve">
          <source>The parentheses denote the capturing groups; the string that matched that part of the regexp can be accessed by the Match.group() method, as shown. The \d matches and single decimal digit, and the + means &quot;match one or more of the previous expression). The - has no special meaning, so just matches that character in the input. Note that you need to double-escape the backslashes when writing this as a Java string. Some other examples:</source>
          <target state="translated">正規表現のその部分にマッチした文字列は、以下に示すように Match.group()メソッドでアクセスできます。\d はマッチする文字列と 10 進数の 1 桁、+は「前の式の 1 つ以上にマッチする」ことを意味します。)は特別な意味を持たないので、入力中のその文字にマッチします。これをJava文字列として書くときは、バックスラッシュをダブルエスケープする必要があることに注意してください。他にもいくつかの例があります。</target>
        </trans-unit>
        <trans-unit id="2f1564091c8c399fe0cdae8db88204245585770c" translate="yes" xml:space="preserve">
          <source>The requirements left room for interpretation. I recommend writing a method,</source>
          <target state="translated">要件は解釈の余地を残していました。方法を書くことをお勧めします。</target>
        </trans-unit>
        <trans-unit id="22ef733bbe3da925412acc480b7de8dc28db3462" translate="yes" xml:space="preserve">
          <source>The split method has an optimization to avoid using a regular expression if the delimeter is a single character and not in the above list. Otherwise, it has to compile a regular expression, and this is not ideal.</source>
          <target state="translated">分割メソッドは、デリメータが1文字で上記リストにない場合に正規表現を使用しないように最適化されています。そうでない場合は正規表現をコンパイルしなければならず、これは理想的ではありません。</target>
        </trans-unit>
        <trans-unit id="1039d4d97263436c7612e24c3014607be2955a3f" translate="yes" xml:space="preserve">
          <source>There are only two methods you really need to consider.</source>
          <target state="translated">本当に考えなければならない方法は2つしかありません。</target>
        </trans-unit>
        <trans-unit id="2ad5934937e5bc61b345d24f3e22d06c154410c1" translate="yes" xml:space="preserve">
          <source>This last option still creates a new &lt;code&gt;Matcher&lt;/code&gt; object. You can also cache this object and reset it for each input for maximum performance, but that is somewhat more complicated and not thread-safe.</source>
          <target state="translated">この最後のオプションでも、新しい &lt;code&gt;Matcher&lt;/code&gt; オブジェクトが作成されます。 このオブジェクトをキャッシュして、最大のパフォーマンスを得るために入力ごとにリセットすることもできますが、これはやや複雑でスレッドセーフではありません。</target>
        </trans-unit>
        <trans-unit id="43e999a4c1efce2357ea1d7e7bdbe6f82739b5f6" translate="yes" xml:space="preserve">
          <source>This split (regex) takes a regex as an argument. Remember to escape the regex special characters, like period/dot.</source>
          <target state="translated">このスプリット(正規表現)は正規表現を引数に取ります。ピリオドなどの正規表現の特殊文字をエスケープすることを忘れないでください。</target>
        </trans-unit>
        <trans-unit id="6e02947cedc98e75e3a5b241b30474e9a29c52f5" translate="yes" xml:space="preserve">
          <source>This will split your string into 2 parts.  The first element in the array will be the part containing the stuff before the &lt;code&gt;-&lt;/code&gt;, and the 2nd element in the array will contain the part of your string after the &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">これにより、文字列が2つの部分に分割されます。 配列の最初の要素は &lt;code&gt;-&lt;/code&gt; の前の要素を含む部分であり、配列の2番目の要素は &lt;code&gt;-&lt;/code&gt; の後の文字列の部分です。</target>
        </trans-unit>
        <trans-unit id="c3ba0939a339061a816f3d87d8a1aee227e57443" translate="yes" xml:space="preserve">
          <source>To split a string, use &lt;code&gt;String.split(regex)&lt;/code&gt;:</source>
          <target state="translated">文字列を分割するには、 &lt;code&gt;String.split(regex)&lt;/code&gt; を使用します。</target>
        </trans-unit>
        <trans-unit id="7f8658a552c8fddac1aee7a513aab32ff40548cf" translate="yes" xml:space="preserve">
          <source>To split a string, uses String.split(regex). Review the following examples:</source>
          <target state="translated">文字列を分割するには、String.split(regex)を使用します。以下の例を確認してください。</target>
        </trans-unit>
        <trans-unit id="c44d828d0c1bacc16a8f1111f9c0c20fb6c9d9c3" translate="yes" xml:space="preserve">
          <source>To summarize: there are at least five ways to split a string in Java:</source>
          <target state="translated">要約すると、Javaで文字列を分割する方法は少なくとも5つあります。</target>
        </trans-unit>
        <trans-unit id="67f374ebe587596fe19b000771190ad3bf1d5ff3" translate="yes" xml:space="preserve">
          <source>To test beforehand if the string contains certain character(s), just use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contains-java.lang.CharSequence-&quot;&gt;&lt;code&gt;String#contains()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">文字列に特定の文字が含まれているかどうかを事前にテストするには、 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contains-java.lang.CharSequence-&quot;&gt; &lt;code&gt;String#contains()&lt;/code&gt; を&lt;/a&gt;使用します。</target>
        </trans-unit>
        <trans-unit id="694f7e706eb39c40b04c5d4f24c5a1b3abd95ca5" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html#split(java.lang.String,%20char)&quot;&gt;org.apache.commons.lang.StringUtils'&lt;/a&gt; split method which can split strings based on the character or string you want to split.</source>
          <target state="translated">分割する文字または文字列に基づいて文字列を分割できる&lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html#split(java.lang.String,%20char)&quot;&gt;org.apache.commons.lang.StringUtilsの&lt;/a&gt;分割メソッドを使用します。</target>
        </trans-unit>
        <trans-unit id="f48b143c73a3beedf263bb97736aed29d112cc45" translate="yes" xml:space="preserve">
          <source>WAY 1: As you have to split two numbers by a special character you can use regex</source>
          <target state="translated">方法 1.2つの数値を特殊文字で分割する必要がある場合は、正規表現である</target>
        </trans-unit>
        <trans-unit id="92a973bd215f622efe5ef3b4c633dbd595f59547" translate="yes" xml:space="preserve">
          <source>WAY 2: Using the string split method</source>
          <target state="translated">WAY 2.文字列分割法を使う</target>
        </trans-unit>
        <trans-unit id="dd91b0658c6cf431015b14f6a00de46f9c97ac60" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of the input
  sequence then an empty leading substring is included at the beginning
  of the resulting array. A zero-width match at the beginning however
  never produces such empty leading substring.</source>
          <target state="translated">入力シーケンスの先頭に正の幅のマッチがあった場合、結果として得られる配列の先頭には空の部分文字列が含まれます。しかし、先頭にゼロ幅のマッチがあった場合、そのような空の先頭部分文字列は生成されません。</target>
        </trans-unit>
        <trans-unit id="7b43177b490dfd01ed6e0438b89a88ed36b1419b" translate="yes" xml:space="preserve">
          <source>With Java 8:</source>
          <target state="translated">Java 8で。</target>
        </trans-unit>
        <trans-unit id="d70aaa84bc798cb8b2c647782fe43a7cdc3b3869" translate="yes" xml:space="preserve">
          <source>With defining the according test results, you can specify the behaviour.</source>
          <target state="translated">テスト結果を定義することで、動作を指定することができます。</target>
        </trans-unit>
        <trans-unit id="76bb20eab98c1196b2934f9ecb1f186851f4c3a0" translate="yes" xml:space="preserve">
          <source>You can simply do as follows:</source>
          <target state="translated">単純に以下のようにすればいいのです。</target>
        </trans-unit>
        <trans-unit id="745adfbaebad4644181f103c3028a3163d9a0618" translate="yes" xml:space="preserve">
          <source>You can simply use StringTokenizer to split a string in two or more parts whether there are any type of delimiters:</source>
          <target state="translated">区切り文字の種類に関わらず、StringTokenizerを使って文字列を2つ以上の部分に分割することができます。</target>
        </trans-unit>
        <trans-unit id="19694d4c4ce9f54704ac6515420ed6e3759bcebb" translate="yes" xml:space="preserve">
          <source>You can split a string by a hyphen/character by using the following statement:</source>
          <target state="translated">文字列をハイフン文字で分割するには、以下のステートメントを使用します。</target>
        </trans-unit>
        <trans-unit id="f73c5ea266b5f4a2c5c45a763ef228fc21408fdc" translate="yes" xml:space="preserve">
          <source>You can split a string by a line break by using the following statement:</source>
          <target state="translated">文字列を改行で分割するには、以下のようなステートメントを使用します。</target>
        </trans-unit>
        <trans-unit id="40de6a8dc52dcc8f5824e304163fb8987a745e82" translate="yes" xml:space="preserve">
          <source>You can try like this also</source>
          <target state="translated">こんな風にしてみてもいいかもしれません。</target>
        </trans-unit>
        <trans-unit id="54f18385d816c9a4bacc1a8fbc3b8590fbabb8e9" translate="yes" xml:space="preserve">
          <source>You can use Split():</source>
          <target state="translated">Split()を使うことができます。</target>
        </trans-unit>
        <trans-unit id="aa9dfb7e3dece5be03c64f343a81607eca2aa807" translate="yes" xml:space="preserve">
          <source>You can use the method &lt;code&gt;split&lt;/code&gt;:</source>
          <target state="translated">あなたはメソッド &lt;code&gt;split&lt;/code&gt; を使うことができます：</target>
        </trans-unit>
        <trans-unit id="9668d451d8c924278f7d7ecccc4e44a51b306de9" translate="yes" xml:space="preserve">
          <source>You should write some unit-tests for input strings and the desired results and behaviour.</source>
          <target state="translated">入力文字列のユニットテストをいくつか書いて、望ましい結果と振る舞いを考えてみましょう。</target>
        </trans-unit>
        <trans-unit id="df28550c3b81f1b880a49ceb27fb76bcc7fa42ee" translate="yes" xml:space="preserve">
          <source>should do thing you want. String class has many method to operate with string.</source>
          <target state="translated">を使用して、文字列を操作する必要があります。文字列クラスには、文字列を操作するためのメソッドがたくさんあります。</target>
        </trans-unit>
        <trans-unit id="0b96290f91b9d7829c5e672bebedfa30ff377327" translate="yes" xml:space="preserve">
          <source>we will get three strings: &lt;code&gt;[0, 0, 4]&lt;/code&gt; and not four as was the case in Java 7 and before. Also check this similar &lt;a href=&quot;https://stackoverflow.com/questions/22718744/why-in-java-8-split-sometimes-removes-empty-strings-at-start-of-result-array&quot;&gt;question&lt;/a&gt;.</source>
          <target state="translated">3つの文字列 &lt;code&gt;[0, 0, 4]&lt;/code&gt; を取得し、Java 7以前の場合のように4つではありません。 この同様の&lt;a href=&quot;https://stackoverflow.com/questions/22718744/why-in-java-8-split-sometimes-removes-empty-strings-at-start-of-result-array&quot;&gt;質問&lt;/a&gt;も確認してください。</target>
        </trans-unit>
        <trans-unit id="2345d121bec649a607f505938c08c500e93234d7" translate="yes" xml:space="preserve">
          <source>which encapsulate this function. Of course you can use String.split(..) as mentioned in the other answers for the implementation.</source>
          <target state="translated">この関数をカプセル化した もちろん、実装のための他の回答で述べたようにString.split(...)を使用することができます。</target>
        </trans-unit>
        <trans-unit id="3fcd8bbf37ea44a0a387328f2a950f3728942e2c" translate="yes" xml:space="preserve">
          <source>you don't really need regular expressions for your split</source>
          <target state="translated">スプリットに正規表現は必要ありません。</target>
        </trans-unit>
        <trans-unit id="bda5d696e27288e5ed234a4c1931bcf4af52f245" translate="yes" xml:space="preserve">
          <source>you happen to already use apache commons lang in your app</source>
          <target state="translated">あなたのアプリで既に apache commons lang を使用している場合</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
