<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/3481828">
    <body>
      <group id="3481828">
        <trans-unit id="634a0bdd960a66ce1185d269b6e09c19a16d7e59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;there&lt;/a&gt; are 12 characters with special meanings: the backslash &lt;code&gt;\&lt;/code&gt;, the caret &lt;code&gt;^&lt;/code&gt;, the dollar sign &lt;code&gt;$&lt;/code&gt;, the period or dot &lt;code&gt;.&lt;/code&gt;, the vertical bar or pipe symbol &lt;code&gt;|&lt;/code&gt;, the question mark &lt;code&gt;?&lt;/code&gt;, the asterisk or star &lt;code&gt;*&lt;/code&gt;, the plus sign &lt;code&gt;+&lt;/code&gt;, the opening parenthesis &lt;code&gt;(&lt;/code&gt;, the closing parenthesis &lt;code&gt;)&lt;/code&gt;, and the opening square bracket &lt;code&gt;[&lt;/code&gt;, the opening curly brace &lt;code&gt;{&lt;/code&gt;, These special characters are often called &quot;metacharacters&quot;.</source>
          <target state="translated">특별한 의미를 가진 12 개의 문자가 있습니다 : 백 슬래시 &lt;code&gt;\&lt;/code&gt; , 캐럿 &lt;code&gt;^&lt;/code&gt; , 달러 기호 &lt;code&gt;$&lt;/code&gt; , 마침표 또는 점 &lt;code&gt;.&lt;/code&gt; , 수직 막대 또는 파이프 기호 &lt;code&gt;|&lt;/code&gt; , 물음표 &lt;code&gt;?&lt;/code&gt; , 별표 또는 별표 &lt;code&gt;*&lt;/code&gt; , 더하기 부호 &lt;code&gt;+&lt;/code&gt; , 여는 괄호 &lt;code&gt;(&lt;/code&gt; , 닫는 괄호 &lt;code&gt;)&lt;/code&gt; 및 여는 대괄호 &lt;code&gt;[&lt;/code&gt; , 여는 중괄호 &lt;code&gt;{&lt;/code&gt; , 이러한 특수 문자는 종종 &quot;메타 문자&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="9eaaedfd4cc1e7d310987fa57faf8f0dadb38f16" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://explainjava.com/split-string-java/&quot;&gt;Here&lt;/a&gt; is a big overview of these methods and the most common examples (how to split by dot, slash, question mark, etc.)</source>
          <target state="translated">&lt;a href=&quot;https://explainjava.com/split-string-java/&quot;&gt;다음&lt;/a&gt; 은 이러한 방법과 가장 일반적인 예 (점, 슬래시, 물음표 등으로 나누는 방법)에 대한 큰 개요입니다.</target>
        </trans-unit>
        <trans-unit id="e1313d9d177aa767a2f19ce3fbfac579ced79591" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;String Split with multiple characters using Regex&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;정규식을 사용하여 여러 문자로 문자열 분할&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c16943696a740385ff52f52ff01f2c21d575844" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use Pattern.split and precompile the pattern if using a complex delimiter and you care about performance.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;복잡한 구분 기호를 사용하고 성능에 관심이있는 경우 Pattern.split을 사용하고 패턴을 사전 컴파일하십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54fbcdde970b3680f7855bf3eb18ae8469d7ce0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use String.split for a one-character delimiter or you don't care about performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;한 문자 구분 기호로 String.split을 사용하거나 성능에 신경 쓰지 마십시오.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7eeb6651db327271e5d1629a11d7fe0d16a7d8b" translate="yes" xml:space="preserve">
          <source>An alternative to processing the string directly would be to use a regular expression with capturing groups. This has the advantage that it makes it straightforward to imply more sophisticated constraints on the input. For example, the following splits the string into two parts, and ensures that both consist only of digits:</source>
          <target state="translated">문자열을 직접 처리하는 대안은 캡처 그룹과 함께 정규식을 사용하는 것입니다. 이것은 입력에 대한보다 복잡한 제약을 암시하는 것이 간단하다는 장점이 있습니다. 예를 들어, 다음은 문자열을 두 부분으로 나누고 둘 다 숫자로만 구성되도록합니다.</target>
        </trans-unit>
        <trans-unit id="19627da7883a0613ac58045d6ef1f0d8e6c29df6" translate="yes" xml:space="preserve">
          <source>And as expected it will print:</source>
          <target state="translated">그리고 예상대로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="281d300200893a33e3537d992266d3b91d6ad40f" translate="yes" xml:space="preserve">
          <source>Apache Commons StringUtils:</source>
          <target state="translated">Apache Commons StringUtils :</target>
        </trans-unit>
        <trans-unit id="0bd2c33eab401a57c01e405d1bbc1c234e7435b3" translate="yes" xml:space="preserve">
          <source>As mentioned by everyone, split() is the best option which may be used in your case. An alternative method can be using substring().</source>
          <target state="translated">모두가 언급했듯이 split ()은 귀하의 경우에 사용될 수있는 최상의 옵션입니다. 대체 방법은 substring ()을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="455bf4d4aefbaf76e95abcb994d64522e57f5a43" translate="yes" xml:space="preserve">
          <source>As the pattern is fixed in this instance, it can be compiled in advance and stored as a static member (initialised at class load time in the example). The regular expression is:</source>
          <target state="translated">이 인스턴스에서 패턴이 고정되면 패턴을 미리 컴파일하여 정적 멤버 (예 : 클래스로드시 초기화 됨)로 저장할 수 있습니다. 정규식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="acd8d9d3530feb7f220a993eb4bc93080beec114" translate="yes" xml:space="preserve">
          <source>Assume that if &lt;code&gt;-&lt;/code&gt; does not exists in your string, it returns the given string, and you will not get any exception.</source>
          <target state="translated">&lt;code&gt;-&lt;/code&gt; 문자열에 - 가 없으면 주어진 문자열을 반환하고 예외가 발생하지 않는다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="b598f05f355293d3ba808a995629e736abdf52ac" translate="yes" xml:space="preserve">
          <source>Assuming, that</source>
          <target state="translated">가정하면</target>
        </trans-unit>
        <trans-unit id="170679a43c9b6393ea32de0f697ab9d50e3a0a66" translate="yes" xml:space="preserve">
          <source>But do not expect the same output across all JDK versions. I have seen &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8043324&quot;&gt;one bug&lt;/a&gt; which exists in some JDK versions where the first null string has been ignored. This bug is not present in the latest JDK version, but it exists in some versions between JDK 1.7 late versions and 1.8 early versions.</source>
          <target state="translated">그러나 모든 JDK 버전에서 동일한 출력을 기대하지는 마십시오. 첫 번째 null 문자열이 무시 된 일부 JDK 버전에 존재하는 &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8043324&quot;&gt;버그&lt;/a&gt; 가 하나 있습니다. 이 버그는 최신 JDK 버전에는 없지만 JDK 1.7 최신 버전과 1.8 초기 버전의 일부 버전에 존재합니다.</target>
        </trans-unit>
        <trans-unit id="2e0832e81bd97677c3c3e45f933928a5b9fcf585" translate="yes" xml:space="preserve">
          <source>Check out the &lt;code&gt;split()&lt;/code&gt; method in the &lt;code&gt;String&lt;/code&gt; class on javadoc.</source>
          <target state="translated">javadoc의 &lt;code&gt;String&lt;/code&gt; 클래스에서 &lt;code&gt;split()&lt;/code&gt; 메소드를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9e823ab53cec95c3e300ab785e078436d9d366d4" translate="yes" xml:space="preserve">
          <source>Check out the &lt;code&gt;split()&lt;/code&gt; method in the &lt;code&gt;String&lt;/code&gt; class.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 클래스에서 &lt;code&gt;split()&lt;/code&gt; 메소드를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="3172bac692f1e831e3ef1816e8723add91fa4296" translate="yes" xml:space="preserve">
          <source>Else, you can use StringTokenizer:</source>
          <target state="translated">그렇지 않으면 StringTokenizer를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="26e0e8524f90a3c867fdd33bcd49bb6fa8f4e4d0" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;&quot;-333&quot;&lt;/code&gt; should return in &lt;code&gt;[,333]&lt;/code&gt; or if it is an error.
Can &lt;code&gt;&quot;333-333-33&quot;&lt;/code&gt; be separated in &lt;code&gt;[333,333-33] or [333-333,33]&lt;/code&gt; or is it an error? And so on.</source>
          <target state="translated">예를 들어 &lt;code&gt;&quot;-333&quot;&lt;/code&gt; 이 &lt;code&gt;[,333]&lt;/code&gt; 으로 반환되거나 오류 인 경우입니다. &lt;code&gt;&quot;333-333-33&quot;&lt;/code&gt; 을 &lt;code&gt;[333,333-33] or [333-333,33]&lt;/code&gt; 에서 분리 할 수 ​​있습니까 , 아니면 오류입니까? 등등.</target>
        </trans-unit>
        <trans-unit id="a959961f689dc6305eb84be8327b92d85950c3fd" translate="yes" xml:space="preserve">
          <source>For simple use cases &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;&lt;code&gt;String.split()&lt;/code&gt;&lt;/a&gt; should do the job. If you use guava, there is also a &lt;a href=&quot;https://github.com/google/guava/wiki/StringsExplained#splitter&quot;&gt;Splitter&lt;/a&gt; class which allows chaining of different string operations and supports &lt;a href=&quot;https://google.github.io/guava/releases/snapshot-jre/api/docs/com/google/common/base/CharMatcher.html&quot;&gt;CharMatcher&lt;/a&gt;:</source>
          <target state="translated">간단한 사용 사례의 경우 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt; &lt;code&gt;String.split()&lt;/code&gt; &lt;/a&gt; 이 작업을 수행해야합니다. 구아바를 사용하는 경우 다른 문자열 작업을 연결하고 &lt;a href=&quot;https://google.github.io/guava/releases/snapshot-jre/api/docs/com/google/common/base/CharMatcher.html&quot;&gt;CharMatcher를&lt;/a&gt; 지원하는 &lt;a href=&quot;https://github.com/google/guava/wiki/StringsExplained#splitter&quot;&gt;Splitter&lt;/a&gt; 클래스도 있습니다.</target>
        </trans-unit>
        <trans-unit id="41aa5e8cca232ef96ae8344d4180dbf6e0984c6c" translate="yes" xml:space="preserve">
          <source>Good test candidates should include:</source>
          <target state="translated">좋은 시험 응시자는 다음을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="66c15e0f61dc4ba39ea4ecd546d9001621adbb7c" translate="yes" xml:space="preserve">
          <source>Google Guava Splitter:</source>
          <target state="translated">구글 구아바 스플리터 :</target>
        </trans-unit>
        <trans-unit id="1b570f545b2da28a044cb15d0d777d7bb12661f7" translate="yes" xml:space="preserve">
          <source>Here are two ways two achieve it.</source>
          <target state="translated">두 가지 방법으로 달성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7702fb6307a48ed358e3bf97b7b58828135f99f" translate="yes" xml:space="preserve">
          <source>Here many examples for split string but I little code optimized.</source>
          <target state="translated">분할 문자열에 대한 많은 예제가 있지만 코드 최적화가 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="ecaeeb1e045a34e4ed62d11ef9b1606af81639f3" translate="yes" xml:space="preserve">
          <source>How to split a string in Java</source>
          <target state="translated">Java에서 문자열을 분할하는 방법</target>
        </trans-unit>
        <trans-unit id="9d00bd1b546789395f672ebe1d098d7b4670e821" translate="yes" xml:space="preserve">
          <source>I have a string, &lt;code&gt;&quot;004-034556&quot;&lt;/code&gt;, that I want to split into two strings:</source>
          <target state="translated">문자열 &lt;code&gt;&quot;004-034556&quot;&lt;/code&gt; 이 있는데 두 문자열로 분할하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="597fca85260a03d531d03509982c894f6ec88d3a" translate="yes" xml:space="preserve">
          <source>I just wanted to write an algorithm instead of using Java built-in functions:</source>
          <target state="translated">Java 내장 함수를 사용하는 대신 알고리즘을 작성하고 싶었습니다.</target>
        </trans-unit>
        <trans-unit id="73640238f9039cdaa6a85588bf8ae148414cb776" translate="yes" xml:space="preserve">
          <source>I would recommend using commong-lang, since usually it contains a lot of stuff that's usable. However, if you don't need it for anything else than doing a split, then implementing yourself or escaping the regex is a better option.</source>
          <target state="translated">일반적으로 사용 가능한 많은 것들이 포함되어 있기 때문에 commong-lang을 사용하는 것이 좋습니다. 그러나 분할을 수행하는 것 외에 다른 작업이 필요하지 않으면 자신을 구현하거나 정규 표현식을 탈출하는 것이 더 나은 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="35f5eaeb8f626d3b81bb83d806e7bb128d180dfa" translate="yes" xml:space="preserve">
          <source>If performance is an issue, and your delimiter is not one of the above, you should pre-compile a regular expression pattern which you can then reuse.</source>
          <target state="translated">성능이 문제이고 분리 문자가 위의 것이 아닌 경우 정규 표현식 패턴을 사전 컴파일 한 후 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5711570bf541c6fabc965cce5a0f19929f00eb29" translate="yes" xml:space="preserve">
          <source>If performance is not an issue, or if the delimiter is a single character that is not a regular expression special character (i.e., not one of &lt;code&gt;.$|()[{^?*+\&lt;/code&gt;) then you can use &lt;code&gt;String.split&lt;/code&gt;.</source>
          <target state="translated">성능이 문제가 아니거나 분리 문자가 정규 표현식 특수 문자가 아닌 단일 문자 (예 : &lt;code&gt;.$|()[{^?*+\&lt;/code&gt; 중 하나가 아닌) 인 경우 &lt;code&gt;String.split&lt;/code&gt; 을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abb4797fa4e7a9f330539336db1653a5f6b50e22" translate="yes" xml:space="preserve">
          <source>If the array length is not 2, then the string was not in the format: &lt;code&gt;string-string&lt;/code&gt;.</source>
          <target state="translated">배열 길이가 2가 아닌 경우 문자열은 &lt;code&gt;string-string&lt;/code&gt; 형식이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c9379386900a7ba181b578a891a6edd088cb32a8" translate="yes" xml:space="preserve">
          <source>If you'd like to limit the number of resulting parts, then you can supply the desired number as 2nd argument of &lt;code&gt;split()&lt;/code&gt; method.</source>
          <target state="translated">결과 부분의 수를 제한하려면 &lt;code&gt;split()&lt;/code&gt; 메서드의 두 번째 인수로 원하는 숫자를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf486efb110a169d1ec321ad391237aea75e64a5" translate="yes" xml:space="preserve">
          <source>If you'd like to retain the split character in the resulting parts, then make use of &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;positive lookaround&lt;/a&gt;. In case you want to have the split character to end up in left hand side, use positive lookbehind by prefixing &lt;code&gt;?&amp;lt;=&lt;/code&gt; group on the pattern.</source>
          <target state="translated">결과 부분에 분할 문자를 유지하려면 &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;긍정적 인 둘러보기를&lt;/a&gt; 사용 하십시오 . 분할 문자를 왼쪽으로 끝내려면 패턴에 접두사 &lt;code&gt;?&amp;lt;=&lt;/code&gt; 그룹을 지정하여 긍정적 인 lookbehind를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7d5bcf86d6aef4f63d20823de18fef46a3444d8b" translate="yes" xml:space="preserve">
          <source>In case you want to have the split character to end up in right hand side, use positive lookahead by prefixing &lt;code&gt;?=&lt;/code&gt; group on the pattern.</source>
          <target state="translated">분할 문자를 오른쪽으로 끝내려면 패턴에서 접두사 &lt;code&gt;?=&lt;/code&gt; 그룹을 사용하여 긍정적 인 미리보기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d4d53e1a023a39b0d46c1060abcaf2ee36561cad" translate="yes" xml:space="preserve">
          <source>In this answer I also want to point out &lt;strong&gt;one change that has taken place for &lt;code&gt;split&lt;/code&gt; method in Java 8&lt;/strong&gt;. The &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;String#split()&lt;/a&gt; method makes use of &lt;code&gt;Pattern.split&lt;/code&gt;, and now it will remove empty strings at the start of the result array. Notice this &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-int-&quot;&gt;change&lt;/a&gt; in documentation for Java 8:</source>
          <target state="translated">이 답변 &lt;strong&gt;에서 Java 8의 &lt;code&gt;split&lt;/code&gt; 메소드에 대해 한 가지 변경 사항&lt;/strong&gt; 을 지적하고 싶습니다. &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;String # split ()&lt;/a&gt; 메서드는 &lt;code&gt;Pattern.split&lt;/code&gt; 을 사용하므로 결과 배열이 시작될 때 빈 문자열을 제거합니다. Java 8에 대한 설명서에서이 &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-int-&quot;&gt;변경&lt;/a&gt; 사항을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9d7ee1e0bfdc43c72fde2787f5595a8e3fe895b2" translate="yes" xml:space="preserve">
          <source>In your case, you want to split a string when there is a &quot;-&quot;.</source>
          <target state="translated">귀하의 경우 &quot;-&quot;가있을 때 문자열을 분할하려고합니다.</target>
        </trans-unit>
        <trans-unit id="e1bab11672544eaa3fe560aec8ed33483038ee1c" translate="yes" xml:space="preserve">
          <source>It means for the following example:</source>
          <target state="translated">다음 예제를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="708293cbdedf6516d4e9d0f795068139869bebd2" translate="yes" xml:space="preserve">
          <source>Just use the appropriate method: &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;&lt;code&gt;String#split()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">적절한 방법을 사용하십시오 : &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt; &lt;code&gt;String#split()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1366efda6e348068340179972f16275440d6ada" translate="yes" xml:space="preserve">
          <source>Method signature:</source>
          <target state="translated">메소드 서명 :</target>
        </trans-unit>
        <trans-unit id="f2689175bd2423f6686ae7bc6456bdb43ffb0fd2" translate="yes" xml:space="preserve">
          <source>Note that this takes a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#sum&quot;&gt;regular expression&lt;/a&gt;, so remember to escape &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;special characters&lt;/a&gt; if necessary.</source>
          <target state="translated">&lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#sum&quot;&gt;정규 표현식&lt;/a&gt; 이 필요하므로 필요한 경우 &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;특수 문자&lt;/a&gt; 를 이스케이프해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a53efac5096370ec7851ba3b6a71bc3e8c97d59" translate="yes" xml:space="preserve">
          <source>Note, this does not take a regular expression. For that, use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-&quot;&gt;&lt;code&gt;String#matches()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">정규 표현식은 사용하지 않습니다. 이를 위해 대신 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-&quot;&gt; &lt;code&gt;String#matches()&lt;/code&gt; &lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="513d0f10bf46562c61b583d103c88e43eb73c3f4" translate="yes" xml:space="preserve">
          <source>One way to do this is to run through the String in a for-each loop and use the required split character.</source>
          <target state="translated">이를 수행하는 한 가지 방법은 for-each 루프에서 문자열을 실행하고 필요한 분할 문자를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="5511135f9bda614cd85fc511dd6cc901ed9ac0c1" translate="yes" xml:space="preserve">
          <source>Pattern.compile(regexp).splitAsStream(input):</source>
          <target state="translated">Pattern.compile(regexp).splitAsStream(input):</target>
        </trans-unit>
        <trans-unit id="e668e302dd28bb529bbcea9393d214b1f72d72a5" translate="yes" xml:space="preserve">
          <source>Please don't use &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html&quot;&gt;StringTokenizer&lt;/a&gt; class as it is a legacy class that is retained for compatibility reasons, and its use is discouraged in new code. And we can make use of the split method as suggested by others as well.</source>
          <target state="translated">호환성을 위해 유지되는 레거시 클래스이므로 &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html&quot;&gt;StringTokenizer&lt;/a&gt; 클래스를 사용하지 마십시오. 새 코드에서는 사용하지 않는 것이 좋습니다. 그리고 우리는 다른 사람들이 제안한 split 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbfc20ca78fd6cf9b899cc707fe259878f888277" translate="yes" xml:space="preserve">
          <source>So you can choose the best option for you depending on what you need, e.g. return type (array, list, or iterable).</source>
          <target state="translated">따라서 반환 유형 (배열, 목록 또는 반복 가능)과 같이 필요한 항목에 따라 가장 적합한 옵션을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8be17a304e765e19a6319cd20c6fe0da067be66f" translate="yes" xml:space="preserve">
          <source>So, if you want to split on e.g. period/dot &lt;code&gt;.&lt;/code&gt; which means &quot;&lt;a href=&quot;http://www.regular-expressions.info/dot.html&quot;&gt;any character&lt;/a&gt;&quot; in regex, use either &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;backslash &lt;code&gt;\&lt;/code&gt;&lt;/a&gt; to escape the individual special character like so &lt;code&gt;split(&quot;\\.&quot;)&lt;/code&gt;, or use &lt;a href=&quot;http://www.regular-expressions.info/charclass.html&quot;&gt;character class &lt;code&gt;[]&lt;/code&gt;&lt;/a&gt; to represent literal character(s) like so &lt;code&gt;split(&quot;[.]&quot;)&lt;/code&gt;, or use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#quote-java.lang.String-&quot;&gt;&lt;code&gt;Pattern#quote()&lt;/code&gt;&lt;/a&gt; to escape the entire string like so &lt;code&gt;split(Pattern.quote(&quot;.&quot;))&lt;/code&gt;.</source>
          <target state="translated">따라서 예를 들어 period / dot로 분할하려면 이는 정규식에서 &quot; &lt;a href=&quot;http://www.regular-expressions.info/dot.html&quot;&gt;모든 문자&lt;/a&gt; &quot;를 의미합니다. &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;백 슬래시 &lt;code&gt;\&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;split(&quot;\\.&quot;)&lt;/code&gt; 과 같은 개별 특수 문자를 이스케이프하거나 &lt;a href=&quot;http://www.regular-expressions.info/charclass.html&quot;&gt;문자 클래스 &lt;code&gt;[]&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;split(&quot;[.]&quot;)&lt;/code&gt; 와 같은 리터럴 문자를 나타냅니다 . ] &quot;) 또는 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#quote-java.lang.String-&quot;&gt; &lt;code&gt;Pattern#quote()&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;code&gt;split(Pattern.quote(&quot;.&quot;))&lt;/code&gt; 같이 전체 문자열을 이스케이프하십시오.</target>
        </trans-unit>
        <trans-unit id="0a74d76701ae5ebf50bbbd415c4b559ff9f240db" translate="yes" xml:space="preserve">
          <source>String.split():</source>
          <target state="translated">String.split():</target>
        </trans-unit>
        <trans-unit id="21c6a5aab11d8d9baff2af00b73b27e61eb1bb70" translate="yes" xml:space="preserve">
          <source>StringTokenizer (legacy class):</source>
          <target state="translated">StringTokenizer (레거시 클래스) :</target>
        </trans-unit>
        <trans-unit id="d426fef84e8059c41d3b539263be4a0ac67f062c" translate="yes" xml:space="preserve">
          <source>That means the first string will contain the characters before &lt;code&gt;'-'&lt;/code&gt;, and the second string will contain the characters after &lt;code&gt;'-'&lt;/code&gt;. I also want to check if the string has &lt;code&gt;'-'&lt;/code&gt; in it. If not, I will throw an exception. How can I do this?</source>
          <target state="translated">즉, 첫 번째 문자열에는 &lt;code&gt;'-'&lt;/code&gt; 앞의 문자가 포함되고 두 번째 문자열에는 &lt;code&gt;'-'&lt;/code&gt; 다음의 문자가 포함됩니다. 또한 문자열에 &lt;code&gt;'-'&lt;/code&gt; 가 있는지 확인하고 싶습니다. 그렇지 않다면 예외를 던질 것입니다. 어떻게해야합니까?</target>
        </trans-unit>
        <trans-unit id="03bb0d5c446aa1406a8c75e4f03caf43097a0e68" translate="yes" xml:space="preserve">
          <source>The easiest way is to use &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/StringUtils.html#split%28java.lang.String,%20char%29&quot;&gt;StringUtils#split(java.lang.String, char)&lt;/a&gt;. That's more convenient than the one provided by Java out of the box if you don't need regular expressions. Like its manual says, it works like this:</source>
          <target state="translated">가장 쉬운 방법은 &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/StringUtils.html#split%28java.lang.String,%20char%29&quot;&gt;StringUtils # split (java.lang.String, char)를 사용하는 것&lt;/a&gt; 입니다. 정규 표현식이 필요없는 경우 Java에서 제공하는 것보다 편리합니다. 매뉴얼이 말했듯이 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="8e7dd528a45dc621b7c1f129d523220331c90b22" translate="yes" xml:space="preserve">
          <source>The fastest way, which also consumes the least resource could be:</source>
          <target state="translated">가장 적은 리소스를 소비하는 가장 빠른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9f53375b26efb231c64a3a09d645c097bdb5794a" translate="yes" xml:space="preserve">
          <source>The parentheses denote the capturing groups; the string that matched that part of the regexp can be accessed by the Match.group() method, as shown. The \d matches and single decimal digit, and the + means &quot;match one or more of the previous expression). The - has no special meaning, so just matches that character in the input. Note that you need to double-escape the backslashes when writing this as a Java string. Some other examples:</source>
          <target state="translated">괄호는 캡처 그룹을 나타냅니다. 정규 표현식의 해당 부분과 일치하는 문자열은 표시된대로 Match.group () 메서드로 액세스 할 수 있습니다. \ d는 10 진수와 일치하며, +는 &quot;이전 식의 하나 이상 일치&quot;를 의미합니다.-특별한 의미가 없으므로 입력에서 해당 문자와 ​​일치합니다. 백 슬래시를 두 번 이스케이프해야합니다. 이것을 Java 문자열로 쓸 때 다른 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="2f1564091c8c399fe0cdae8db88204245585770c" translate="yes" xml:space="preserve">
          <source>The requirements left room for interpretation. I recommend writing a method,</source>
          <target state="translated">요구 사항은 해석의 여지가되었습니다. 방법을 쓰는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="22ef733bbe3da925412acc480b7de8dc28db3462" translate="yes" xml:space="preserve">
          <source>The split method has an optimization to avoid using a regular expression if the delimeter is a single character and not in the above list. Otherwise, it has to compile a regular expression, and this is not ideal.</source>
          <target state="translated">분할 방법은 델리 미터가 단일 문자이고 위 목록에없는 경우 정규식을 사용하지 않도록 최적화되었습니다. 그렇지 않으면 정규 표현식을 컴파일해야하며 이는 이상적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1039d4d97263436c7612e24c3014607be2955a3f" translate="yes" xml:space="preserve">
          <source>There are only two methods you really need to consider.</source>
          <target state="translated">실제로 고려해야 할 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ad5934937e5bc61b345d24f3e22d06c154410c1" translate="yes" xml:space="preserve">
          <source>This last option still creates a new &lt;code&gt;Matcher&lt;/code&gt; object. You can also cache this object and reset it for each input for maximum performance, but that is somewhat more complicated and not thread-safe.</source>
          <target state="translated">이 마지막 옵션은 여전히 ​​새 &lt;code&gt;Matcher&lt;/code&gt; 객체를 만듭니다. 최대 성능을 위해이 객체를 캐시하고 각 입력에 대해 재설정 할 수도 있지만 다소 복잡하고 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="43e999a4c1efce2357ea1d7e7bdbe6f82739b5f6" translate="yes" xml:space="preserve">
          <source>This split (regex) takes a regex as an argument. Remember to escape the regex special characters, like period/dot.</source>
          <target state="translated">이 분할 (정규식)은 정규식을 인수로 사용합니다. 마침표 / 점과 같은 정규 표현식 특수 문자를 피하십시오.</target>
        </trans-unit>
        <trans-unit id="6e02947cedc98e75e3a5b241b30474e9a29c52f5" translate="yes" xml:space="preserve">
          <source>This will split your string into 2 parts.  The first element in the array will be the part containing the stuff before the &lt;code&gt;-&lt;/code&gt;, and the 2nd element in the array will contain the part of your string after the &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">이렇게하면 줄이 두 부분으로 나뉩니다. 배열의 첫 번째 요소는 &lt;code&gt;-&lt;/code&gt; 앞에 물건을 포함하는 부분이되고 배열의 두 번째 요소는 &lt;code&gt;-&lt;/code&gt; 뒤에 문자열 부분을 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c3ba0939a339061a816f3d87d8a1aee227e57443" translate="yes" xml:space="preserve">
          <source>To split a string, use &lt;code&gt;String.split(regex)&lt;/code&gt;:</source>
          <target state="translated">문자열을 분할하려면 &lt;code&gt;String.split(regex)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f8658a552c8fddac1aee7a513aab32ff40548cf" translate="yes" xml:space="preserve">
          <source>To split a string, uses String.split(regex). Review the following examples:</source>
          <target state="translated">문자열을 분할하려면 String.split (regex)를 사용하십시오. 다음 예를 검토하십시오.</target>
        </trans-unit>
        <trans-unit id="c44d828d0c1bacc16a8f1111f9c0c20fb6c9d9c3" translate="yes" xml:space="preserve">
          <source>To summarize: there are at least five ways to split a string in Java:</source>
          <target state="translated">요약 : Java에서 문자열을 분할하는 방법은 최소한 다섯 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="67f374ebe587596fe19b000771190ad3bf1d5ff3" translate="yes" xml:space="preserve">
          <source>To test beforehand if the string contains certain character(s), just use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contains-java.lang.CharSequence-&quot;&gt;&lt;code&gt;String#contains()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">문자열에 특정 문자가 포함되어 있는지 미리 테스트하려면 &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contains-java.lang.CharSequence-&quot;&gt; &lt;code&gt;String#contains()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="694f7e706eb39c40b04c5d4f24c5a1b3abd95ca5" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html#split(java.lang.String,%20char)&quot;&gt;org.apache.commons.lang.StringUtils'&lt;/a&gt; split method which can split strings based on the character or string you want to split.</source>
          <target state="translated">분할하려는 문자 또는 문자열을 기준으로 문자열을 분할 할 수있는 &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html#split(java.lang.String,%20char)&quot;&gt;org.apache.commons.lang.StringUtils의&lt;/a&gt; split 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f48b143c73a3beedf263bb97736aed29d112cc45" translate="yes" xml:space="preserve">
          <source>WAY 1: As you have to split two numbers by a special character you can use regex</source>
          <target state="translated">방법 1 : 특수 문자로 두 숫자를 나눌 때 정규식을 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="92a973bd215f622efe5ef3b4c633dbd595f59547" translate="yes" xml:space="preserve">
          <source>WAY 2: Using the string split method</source>
          <target state="translated">WAY 2 : 문자열 분리 방법 사용</target>
        </trans-unit>
        <trans-unit id="dd91b0658c6cf431015b14f6a00de46f9c97ac60" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of the input
  sequence then an empty leading substring is included at the beginning
  of the resulting array. A zero-width match at the beginning however
  never produces such empty leading substring.</source>
          <target state="translated">입력 시퀀스의 시작 부분에 양의 너비가 일치하면 결과 배열의 시작 부분에 빈 선행 부분 문자열이 포함됩니다. 그러나 처음에 너비가 0이면 일치하는 빈 선행 부분 문자열이 생성되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7b43177b490dfd01ed6e0438b89a88ed36b1419b" translate="yes" xml:space="preserve">
          <source>With Java 8:</source>
          <target state="translated">자바 8 :</target>
        </trans-unit>
        <trans-unit id="d70aaa84bc798cb8b2c647782fe43a7cdc3b3869" translate="yes" xml:space="preserve">
          <source>With defining the according test results, you can specify the behaviour.</source>
          <target state="translated">해당 테스트 결과를 정의하면 동작을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76bb20eab98c1196b2934f9ecb1f186851f4c3a0" translate="yes" xml:space="preserve">
          <source>You can simply do as follows:</source>
          <target state="translated">다음과 같이 간단하게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="745adfbaebad4644181f103c3028a3163d9a0618" translate="yes" xml:space="preserve">
          <source>You can simply use StringTokenizer to split a string in two or more parts whether there are any type of delimiters:</source>
          <target state="translated">StringTokenizer를 사용하여 구분 기호 유형이 있는지 여부에 관계없이 문자열을 둘 이상의 부분으로 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19694d4c4ce9f54704ac6515420ed6e3759bcebb" translate="yes" xml:space="preserve">
          <source>You can split a string by a hyphen/character by using the following statement:</source>
          <target state="translated">다음 명령문을 사용하여 문자열을 하이픈 / 문자로 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f73c5ea266b5f4a2c5c45a763ef228fc21408fdc" translate="yes" xml:space="preserve">
          <source>You can split a string by a line break by using the following statement:</source>
          <target state="translated">다음 명령문을 사용하여 줄 바꿈으로 문자열을 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40de6a8dc52dcc8f5824e304163fb8987a745e82" translate="yes" xml:space="preserve">
          <source>You can try like this also</source>
          <target state="translated">이것도 시도해 볼 수 있습니다</target>
        </trans-unit>
        <trans-unit id="54f18385d816c9a4bacc1a8fbc3b8590fbabb8e9" translate="yes" xml:space="preserve">
          <source>You can use Split():</source>
          <target state="translated">Split ()을 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="aa9dfb7e3dece5be03c64f343a81607eca2aa807" translate="yes" xml:space="preserve">
          <source>You can use the method &lt;code&gt;split&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;split&lt;/code&gt; 메소드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9668d451d8c924278f7d7ecccc4e44a51b306de9" translate="yes" xml:space="preserve">
          <source>You should write some unit-tests for input strings and the desired results and behaviour.</source>
          <target state="translated">입력 문자열과 원하는 결과 및 동작에 대한 단위 테스트를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="df28550c3b81f1b880a49ceb27fb76bcc7fa42ee" translate="yes" xml:space="preserve">
          <source>should do thing you want. String class has many method to operate with string.</source>
          <target state="translated">당신이 원하는 일을해야합니다. 문자열 클래스에는 문자열로 작동하는 많은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b96290f91b9d7829c5e672bebedfa30ff377327" translate="yes" xml:space="preserve">
          <source>we will get three strings: &lt;code&gt;[0, 0, 4]&lt;/code&gt; and not four as was the case in Java 7 and before. Also check this similar &lt;a href=&quot;https://stackoverflow.com/questions/22718744/why-in-java-8-split-sometimes-removes-empty-strings-at-start-of-result-array&quot;&gt;question&lt;/a&gt;.</source>
          <target state="translated">Java 7 이전과는 달리 &lt;code&gt;[0, 0, 4]&lt;/code&gt; 세 개의 문자열을 얻을 수 있습니다. 이 비슷한 &lt;a href=&quot;https://stackoverflow.com/questions/22718744/why-in-java-8-split-sometimes-removes-empty-strings-at-start-of-result-array&quot;&gt;질문&lt;/a&gt; 도 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2345d121bec649a607f505938c08c500e93234d7" translate="yes" xml:space="preserve">
          <source>which encapsulate this function. Of course you can use String.split(..) as mentioned in the other answers for the implementation.</source>
          <target state="translated">이 기능을 캡슐화합니다. 물론 구현에 대한 다른 답변에서 언급 한 것처럼 String.split (..)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fcd8bbf37ea44a0a387328f2a950f3728942e2c" translate="yes" xml:space="preserve">
          <source>you don't really need regular expressions for your split</source>
          <target state="translated">분할에 정규식이 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bda5d696e27288e5ed234a4c1931bcf4af52f245" translate="yes" xml:space="preserve">
          <source>you happen to already use apache commons lang in your app</source>
          <target state="translated">이미 앱에서 Apache Commons Lang을 사용하고 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
