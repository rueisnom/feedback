<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/3481828">
    <body>
      <group id="3481828">
        <trans-unit id="634a0bdd960a66ce1185d269b6e09c19a16d7e59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;there&lt;/a&gt; are 12 characters with special meanings: the backslash &lt;code&gt;\&lt;/code&gt;, the caret &lt;code&gt;^&lt;/code&gt;, the dollar sign &lt;code&gt;$&lt;/code&gt;, the period or dot &lt;code&gt;.&lt;/code&gt;, the vertical bar or pipe symbol &lt;code&gt;|&lt;/code&gt;, the question mark &lt;code&gt;?&lt;/code&gt;, the asterisk or star &lt;code&gt;*&lt;/code&gt;, the plus sign &lt;code&gt;+&lt;/code&gt;, the opening parenthesis &lt;code&gt;(&lt;/code&gt;, the closing parenthesis &lt;code&gt;)&lt;/code&gt;, and the opening square bracket &lt;code&gt;[&lt;/code&gt;, the opening curly brace &lt;code&gt;{&lt;/code&gt;, These special characters are often called &quot;metacharacters&quot;.</source>
          <target state="translated">&lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;Есть&lt;/a&gt; 12 символов с особым значением: обратная косая черта &lt;code&gt;\&lt;/code&gt; , символ каретки &lt;code&gt;^&lt;/code&gt; , знак доллара &lt;code&gt;$&lt;/code&gt; , точка или точка &lt;code&gt;.&lt;/code&gt; , вертикальная черта или символ трубы &lt;code&gt;|&lt;/code&gt; знак вопроса &lt;code&gt;?&lt;/code&gt; , звездочка или звездочка &lt;code&gt;*&lt;/code&gt; , знак плюс &lt;code&gt;+&lt;/code&gt; , открывающая скобка &lt;code&gt;(&lt;/code&gt; , закрывающая скобка &lt;code&gt;)&lt;/code&gt; и открывающая квадратная скобка &lt;code&gt;[&lt;/code&gt; , открывающая фигурная скобка &lt;code&gt;{&lt;/code&gt; , эти специальные символы часто называют &amp;laquo;метасимволами&amp;raquo;.</target>
        </trans-unit>
        <trans-unit id="9eaaedfd4cc1e7d310987fa57faf8f0dadb38f16" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://explainjava.com/split-string-java/&quot;&gt;Here&lt;/a&gt; is a big overview of these methods and the most common examples (how to split by dot, slash, question mark, etc.)</source>
          <target state="translated">&lt;a href=&quot;https://explainjava.com/split-string-java/&quot;&gt;Вот&lt;/a&gt; большой обзор этих методов и наиболее распространенных примеров (как разделить на точки, косая черта, знак вопроса и т. Д.)</target>
        </trans-unit>
        <trans-unit id="e1313d9d177aa767a2f19ce3fbfac579ced79591" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;String Split with multiple characters using Regex&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Разделение строк с несколькими символами с использованием регулярных выражений&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c16943696a740385ff52f52ff01f2c21d575844" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use Pattern.split and precompile the pattern if using a complex delimiter and you care about performance.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Используйте Pattern.split и прекомпилируйте шаблон, если используете сложный разделитель, и вы заботитесь о производительности.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54fbcdde970b3680f7855bf3eb18ae8469d7ce0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use String.split for a one-character delimiter or you don't care about performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Используйте String.split для односимвольного разделителя, или вы не заботитесь о производительности&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7eeb6651db327271e5d1629a11d7fe0d16a7d8b" translate="yes" xml:space="preserve">
          <source>An alternative to processing the string directly would be to use a regular expression with capturing groups. This has the advantage that it makes it straightforward to imply more sophisticated constraints on the input. For example, the following splits the string into two parts, and ensures that both consist only of digits:</source>
          <target state="translated">Альтернативой прямой обработке строки было бы использование регулярного выражения с группами захвата.Преимущество такого подхода заключается в том,что он подразумевает более сложные ограничения на входные данные.Например,следующее разбивает строку на две части и гарантирует,что обе части состоят только из цифр:</target>
        </trans-unit>
        <trans-unit id="19627da7883a0613ac58045d6ef1f0d8e6c29df6" translate="yes" xml:space="preserve">
          <source>And as expected it will print:</source>
          <target state="translated">И,как и ожидалось,он напечатает:</target>
        </trans-unit>
        <trans-unit id="281d300200893a33e3537d992266d3b91d6ad40f" translate="yes" xml:space="preserve">
          <source>Apache Commons StringUtils:</source>
          <target state="translated">Apache Commons StringUtils:</target>
        </trans-unit>
        <trans-unit id="0bd2c33eab401a57c01e405d1bbc1c234e7435b3" translate="yes" xml:space="preserve">
          <source>As mentioned by everyone, split() is the best option which may be used in your case. An alternative method can be using substring().</source>
          <target state="translated">Как все уже упоминали,функция split()является лучшим вариантом,который может быть использован в вашем случае.Альтернативным методом может быть использование подстроки().</target>
        </trans-unit>
        <trans-unit id="455bf4d4aefbaf76e95abcb994d64522e57f5a43" translate="yes" xml:space="preserve">
          <source>As the pattern is fixed in this instance, it can be compiled in advance and stored as a static member (initialised at class load time in the example). The regular expression is:</source>
          <target state="translated">Так как в данном примере шаблон фиксирован,его можно заранее скомпилировать и сохранить в виде статического члена (в примере инициализируется во время загрузки класса).Регулярное выражение:</target>
        </trans-unit>
        <trans-unit id="acd8d9d3530feb7f220a993eb4bc93080beec114" translate="yes" xml:space="preserve">
          <source>Assume that if &lt;code&gt;-&lt;/code&gt; does not exists in your string, it returns the given string, and you will not get any exception.</source>
          <target state="translated">Предположим, что если &lt;code&gt;-&lt;/code&gt; не существует в вашей строке, он возвращает данную строку, и вы не получите никакого исключения.</target>
        </trans-unit>
        <trans-unit id="b598f05f355293d3ba808a995629e736abdf52ac" translate="yes" xml:space="preserve">
          <source>Assuming, that</source>
          <target state="translated">Если предположить,что</target>
        </trans-unit>
        <trans-unit id="170679a43c9b6393ea32de0f697ab9d50e3a0a66" translate="yes" xml:space="preserve">
          <source>But do not expect the same output across all JDK versions. I have seen &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8043324&quot;&gt;one bug&lt;/a&gt; which exists in some JDK versions where the first null string has been ignored. This bug is not present in the latest JDK version, but it exists in some versions between JDK 1.7 late versions and 1.8 early versions.</source>
          <target state="translated">Но не ожидайте одинакового вывода во всех версиях JDK. Я видел &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8043324&quot;&gt;одну ошибку,&lt;/a&gt; которая существует в некоторых версиях JDK, где первая пустая строка была проигнорирована. Эта ошибка отсутствует в последней версии JDK, но существует в некоторых версиях между поздними версиями JDK 1.7 и ранними версиями 1.8.</target>
        </trans-unit>
        <trans-unit id="2e0832e81bd97677c3c3e45f933928a5b9fcf585" translate="yes" xml:space="preserve">
          <source>Check out the &lt;code&gt;split()&lt;/code&gt; method in the &lt;code&gt;String&lt;/code&gt; class on javadoc.</source>
          <target state="translated">Проверьте метод &lt;code&gt;split()&lt;/code&gt; в классе &lt;code&gt;String&lt;/code&gt; на javadoc.</target>
        </trans-unit>
        <trans-unit id="9e823ab53cec95c3e300ab785e078436d9d366d4" translate="yes" xml:space="preserve">
          <source>Check out the &lt;code&gt;split()&lt;/code&gt; method in the &lt;code&gt;String&lt;/code&gt; class.</source>
          <target state="translated">Проверьте метод &lt;code&gt;split()&lt;/code&gt; в классе &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3172bac692f1e831e3ef1816e8723add91fa4296" translate="yes" xml:space="preserve">
          <source>Else, you can use StringTokenizer:</source>
          <target state="translated">Иначе,ты можешь использовать StringTokenizer:</target>
        </trans-unit>
        <trans-unit id="26e0e8524f90a3c867fdd33bcd49bb6fa8f4e4d0" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;&quot;-333&quot;&lt;/code&gt; should return in &lt;code&gt;[,333]&lt;/code&gt; or if it is an error.
Can &lt;code&gt;&quot;333-333-33&quot;&lt;/code&gt; be separated in &lt;code&gt;[333,333-33] or [333-333,33]&lt;/code&gt; or is it an error? And so on.</source>
          <target state="translated">Например, если &lt;code&gt;&quot;-333&quot;&lt;/code&gt; должно возвращаться в &lt;code&gt;[,333]&lt;/code&gt; или если это ошибка. Можно ли &lt;code&gt;&quot;333-333-33&quot;&lt;/code&gt; в &lt;code&gt;[333,333-33] or [333-333,33]&lt;/code&gt; или это ошибка? И так далее.</target>
        </trans-unit>
        <trans-unit id="a959961f689dc6305eb84be8327b92d85950c3fd" translate="yes" xml:space="preserve">
          <source>For simple use cases &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;&lt;code&gt;String.split()&lt;/code&gt;&lt;/a&gt; should do the job. If you use guava, there is also a &lt;a href=&quot;https://github.com/google/guava/wiki/StringsExplained#splitter&quot;&gt;Splitter&lt;/a&gt; class which allows chaining of different string operations and supports &lt;a href=&quot;https://google.github.io/guava/releases/snapshot-jre/api/docs/com/google/common/base/CharMatcher.html&quot;&gt;CharMatcher&lt;/a&gt;:</source>
          <target state="translated">Для простых случаев использования &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt; &lt;code&gt;String.split()&lt;/code&gt; &lt;/a&gt; должен делать эту работу. Если вы используете guava, есть также класс &lt;a href=&quot;https://github.com/google/guava/wiki/StringsExplained#splitter&quot;&gt;Splitter,&lt;/a&gt; который позволяет связывать различные строковые операции и поддерживает &lt;a href=&quot;https://google.github.io/guava/releases/snapshot-jre/api/docs/com/google/common/base/CharMatcher.html&quot;&gt;CharMatcher&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="41aa5e8cca232ef96ae8344d4180dbf6e0984c6c" translate="yes" xml:space="preserve">
          <source>Good test candidates should include:</source>
          <target state="translated">Хорошие тестовые кандидаты должны включать в себя:</target>
        </trans-unit>
        <trans-unit id="66c15e0f61dc4ba39ea4ecd546d9001621adbb7c" translate="yes" xml:space="preserve">
          <source>Google Guava Splitter:</source>
          <target state="translated">Гугл Гуава Сплиттер:</target>
        </trans-unit>
        <trans-unit id="1b570f545b2da28a044cb15d0d777d7bb12661f7" translate="yes" xml:space="preserve">
          <source>Here are two ways two achieve it.</source>
          <target state="translated">Вот два способа достичь этого.</target>
        </trans-unit>
        <trans-unit id="d7702fb6307a48ed358e3bf97b7b58828135f99f" translate="yes" xml:space="preserve">
          <source>Here many examples for split string but I little code optimized.</source>
          <target state="translated">Здесь много примеров для сплит-строк,но я немного оптимизировал код.</target>
        </trans-unit>
        <trans-unit id="ecaeeb1e045a34e4ed62d11ef9b1606af81639f3" translate="yes" xml:space="preserve">
          <source>How to split a string in Java</source>
          <target state="translated">Как разделить строку на Java</target>
        </trans-unit>
        <trans-unit id="9d00bd1b546789395f672ebe1d098d7b4670e821" translate="yes" xml:space="preserve">
          <source>I have a string, &lt;code&gt;&quot;004-034556&quot;&lt;/code&gt;, that I want to split into two strings:</source>
          <target state="translated">У меня есть строка &lt;code&gt;&quot;004-034556&quot;&lt;/code&gt; , которую я хочу разделить на две строки:</target>
        </trans-unit>
        <trans-unit id="597fca85260a03d531d03509982c894f6ec88d3a" translate="yes" xml:space="preserve">
          <source>I just wanted to write an algorithm instead of using Java built-in functions:</source>
          <target state="translated">Я просто хотел написать алгоритм вместо использования встроенных функций Java:</target>
        </trans-unit>
        <trans-unit id="73640238f9039cdaa6a85588bf8ae148414cb776" translate="yes" xml:space="preserve">
          <source>I would recommend using commong-lang, since usually it contains a lot of stuff that's usable. However, if you don't need it for anything else than doing a split, then implementing yourself or escaping the regex is a better option.</source>
          <target state="translated">Я бы порекомендовал использовать обычный язык,так как обычно он содержит много полезного.Однако,если он вам не нужен ни для чего,кроме как для разделения,то лучшим вариантом будет реализация себя или уход от регекса.</target>
        </trans-unit>
        <trans-unit id="35f5eaeb8f626d3b81bb83d806e7bb128d180dfa" translate="yes" xml:space="preserve">
          <source>If performance is an issue, and your delimiter is not one of the above, you should pre-compile a regular expression pattern which you can then reuse.</source>
          <target state="translated">Если производительность является проблемой,и ваш разделитель не является одним из вышеперечисленных,то необходимо предварительно скомпилировать шаблон регулярного выражения,который затем можно будет использовать повторно.</target>
        </trans-unit>
        <trans-unit id="5711570bf541c6fabc965cce5a0f19929f00eb29" translate="yes" xml:space="preserve">
          <source>If performance is not an issue, or if the delimiter is a single character that is not a regular expression special character (i.e., not one of &lt;code&gt;.$|()[{^?*+\&lt;/code&gt;) then you can use &lt;code&gt;String.split&lt;/code&gt;.</source>
          <target state="translated">Если производительность не является проблемой или если разделитель представляет собой один символ, который не является специальным символом регулярного выражения (т. &lt;code&gt;String.split&lt;/code&gt; Не является одним из &lt;code&gt;.$|()[{^?*+\&lt;/code&gt; ), Тогда вы можете использовать String.split .</target>
        </trans-unit>
        <trans-unit id="abb4797fa4e7a9f330539336db1653a5f6b50e22" translate="yes" xml:space="preserve">
          <source>If the array length is not 2, then the string was not in the format: &lt;code&gt;string-string&lt;/code&gt;.</source>
          <target state="translated">Если длина массива не равна 2, тогда строка была не в формате: &lt;code&gt;string-string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9379386900a7ba181b578a891a6edd088cb32a8" translate="yes" xml:space="preserve">
          <source>If you'd like to limit the number of resulting parts, then you can supply the desired number as 2nd argument of &lt;code&gt;split()&lt;/code&gt; method.</source>
          <target state="translated">Если вы хотите ограничить количество получаемых деталей, вы можете указать нужное число в качестве второго аргумента метода &lt;code&gt;split()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf486efb110a169d1ec321ad391237aea75e64a5" translate="yes" xml:space="preserve">
          <source>If you'd like to retain the split character in the resulting parts, then make use of &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;positive lookaround&lt;/a&gt;. In case you want to have the split character to end up in left hand side, use positive lookbehind by prefixing &lt;code&gt;?&amp;lt;=&lt;/code&gt; group on the pattern.</source>
          <target state="translated">Если вы хотите сохранить символ разделения в результирующих частях, используйте &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;позитивный обзор&lt;/a&gt; . Если вы хотите, чтобы символ разделения находился в левой части, используйте положительный вид сзади с префиксом &lt;code&gt;?&amp;lt;=&lt;/code&gt; Group в шаблоне.</target>
        </trans-unit>
        <trans-unit id="7d5bcf86d6aef4f63d20823de18fef46a3444d8b" translate="yes" xml:space="preserve">
          <source>In case you want to have the split character to end up in right hand side, use positive lookahead by prefixing &lt;code&gt;?=&lt;/code&gt; group on the pattern.</source>
          <target state="translated">Если вы хотите, чтобы символ разделения находился справа, используйте положительный прогноз, добавив префикс &lt;code&gt;?=&lt;/code&gt; Group к шаблону.</target>
        </trans-unit>
        <trans-unit id="d4d53e1a023a39b0d46c1060abcaf2ee36561cad" translate="yes" xml:space="preserve">
          <source>In this answer I also want to point out &lt;strong&gt;one change that has taken place for &lt;code&gt;split&lt;/code&gt; method in Java 8&lt;/strong&gt;. The &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;String#split()&lt;/a&gt; method makes use of &lt;code&gt;Pattern.split&lt;/code&gt;, and now it will remove empty strings at the start of the result array. Notice this &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-int-&quot;&gt;change&lt;/a&gt; in documentation for Java 8:</source>
          <target state="translated">В этом ответе я также хочу указать на &lt;strong&gt;одно изменение, которое произошло в методе &lt;code&gt;split&lt;/code&gt; в Java 8&lt;/strong&gt; . Метод &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;String # split ()&lt;/a&gt; использует &lt;code&gt;Pattern.split&lt;/code&gt; , и теперь он удалит пустые строки в начале массива результатов. Обратите внимание на это &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-int-&quot;&gt;изменение&lt;/a&gt; в документации для Java 8:</target>
        </trans-unit>
        <trans-unit id="9d7ee1e0bfdc43c72fde2787f5595a8e3fe895b2" translate="yes" xml:space="preserve">
          <source>In your case, you want to split a string when there is a &quot;-&quot;.</source>
          <target state="translated">В вашем случае,вы хотите разделить строку,когда есть &quot;-&quot;.</target>
        </trans-unit>
        <trans-unit id="e1bab11672544eaa3fe560aec8ed33483038ee1c" translate="yes" xml:space="preserve">
          <source>It means for the following example:</source>
          <target state="translated">Это означает для следующего примера:</target>
        </trans-unit>
        <trans-unit id="708293cbdedf6516d4e9d0f795068139869bebd2" translate="yes" xml:space="preserve">
          <source>Just use the appropriate method: &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;&lt;code&gt;String#split()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Просто используйте соответствующий метод: &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt; &lt;code&gt;String#split()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1366efda6e348068340179972f16275440d6ada" translate="yes" xml:space="preserve">
          <source>Method signature:</source>
          <target state="translated">Подпись метода:</target>
        </trans-unit>
        <trans-unit id="f2689175bd2423f6686ae7bc6456bdb43ffb0fd2" translate="yes" xml:space="preserve">
          <source>Note that this takes a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#sum&quot;&gt;regular expression&lt;/a&gt;, so remember to escape &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;special characters&lt;/a&gt; if necessary.</source>
          <target state="translated">Обратите внимание, что для этого требуется &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#sum&quot;&gt;регулярное выражение&lt;/a&gt; , поэтому при необходимости не используйте &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;специальные символы&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2a53efac5096370ec7851ba3b6a71bc3e8c97d59" translate="yes" xml:space="preserve">
          <source>Note, this does not take a regular expression. For that, use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-&quot;&gt;&lt;code&gt;String#matches()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Обратите внимание, это не требует регулярного выражения. Для этого используйте вместо &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-&quot;&gt; &lt;code&gt;String#matches()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="513d0f10bf46562c61b583d103c88e43eb73c3f4" translate="yes" xml:space="preserve">
          <source>One way to do this is to run through the String in a for-each loop and use the required split character.</source>
          <target state="translated">Один из способов сделать это-пробегать через Строку в цикле for-each и использовать требуемый разделительный символ.</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="5511135f9bda614cd85fc511dd6cc901ed9ac0c1" translate="yes" xml:space="preserve">
          <source>Pattern.compile(regexp).splitAsStream(input):</source>
          <target state="translated">Pattern.compile(regexp).splitAsStream(input):</target>
        </trans-unit>
        <trans-unit id="e668e302dd28bb529bbcea9393d214b1f72d72a5" translate="yes" xml:space="preserve">
          <source>Please don't use &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html&quot;&gt;StringTokenizer&lt;/a&gt; class as it is a legacy class that is retained for compatibility reasons, and its use is discouraged in new code. And we can make use of the split method as suggested by others as well.</source>
          <target state="translated">Пожалуйста, не используйте класс &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html&quot;&gt;StringTokenizer, так&lt;/a&gt; как это унаследованный класс, который сохраняется из соображений совместимости, и его использование не рекомендуется в новом коде. И мы можем использовать метод разделения, как предложено другими.</target>
        </trans-unit>
        <trans-unit id="bbfc20ca78fd6cf9b899cc707fe259878f888277" translate="yes" xml:space="preserve">
          <source>So you can choose the best option for you depending on what you need, e.g. return type (array, list, or iterable).</source>
          <target state="translated">Таким образом,вы можете выбрать наилучший для вас вариант в зависимости от того,что вам нужно,например,тип возврата (массив,список или итерабельный).</target>
        </trans-unit>
        <trans-unit id="8be17a304e765e19a6319cd20c6fe0da067be66f" translate="yes" xml:space="preserve">
          <source>So, if you want to split on e.g. period/dot &lt;code&gt;.&lt;/code&gt; which means &quot;&lt;a href=&quot;http://www.regular-expressions.info/dot.html&quot;&gt;any character&lt;/a&gt;&quot; in regex, use either &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;backslash &lt;code&gt;\&lt;/code&gt;&lt;/a&gt; to escape the individual special character like so &lt;code&gt;split(&quot;\\.&quot;)&lt;/code&gt;, or use &lt;a href=&quot;http://www.regular-expressions.info/charclass.html&quot;&gt;character class &lt;code&gt;[]&lt;/code&gt;&lt;/a&gt; to represent literal character(s) like so &lt;code&gt;split(&quot;[.]&quot;)&lt;/code&gt;, or use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#quote-java.lang.String-&quot;&gt;&lt;code&gt;Pattern#quote()&lt;/code&gt;&lt;/a&gt; to escape the entire string like so &lt;code&gt;split(Pattern.quote(&quot;.&quot;))&lt;/code&gt;.</source>
          <target state="translated">Итак, если вы хотите разделить, например, точка / точка &lt;code&gt;.&lt;/code&gt; что означает &amp;laquo; &lt;a href=&quot;http://www.regular-expressions.info/dot.html&quot;&gt;любой символ&lt;/a&gt; &amp;raquo; в регулярном выражении, используйте либо &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;обратную косую черту &lt;code&gt;\&lt;/code&gt; &lt;/a&gt; для экранирования отдельного специального символа, такого как &lt;code&gt;split(&quot;\\.&quot;)&lt;/code&gt; , либо используйте &lt;a href=&quot;http://www.regular-expressions.info/charclass.html&quot;&gt;символьный класс &lt;code&gt;[]&lt;/code&gt; &lt;/a&gt; для представления литеральных символов, таких как &lt;code&gt;split(&quot;[.]&quot;)&lt;/code&gt; , или используйте &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#quote-java.lang.String-&quot;&gt; &lt;code&gt;Pattern#quote()&lt;/code&gt; &lt;/a&gt; для экранирования всей строки, например &lt;code&gt;split(Pattern.quote(&quot;.&quot;))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a74d76701ae5ebf50bbbd415c4b559ff9f240db" translate="yes" xml:space="preserve">
          <source>String.split():</source>
          <target state="translated">String.split():</target>
        </trans-unit>
        <trans-unit id="21c6a5aab11d8d9baff2af00b73b27e61eb1bb70" translate="yes" xml:space="preserve">
          <source>StringTokenizer (legacy class):</source>
          <target state="translated">StringTokenizer (класс наследия):</target>
        </trans-unit>
        <trans-unit id="d426fef84e8059c41d3b539263be4a0ac67f062c" translate="yes" xml:space="preserve">
          <source>That means the first string will contain the characters before &lt;code&gt;'-'&lt;/code&gt;, and the second string will contain the characters after &lt;code&gt;'-'&lt;/code&gt;. I also want to check if the string has &lt;code&gt;'-'&lt;/code&gt; in it. If not, I will throw an exception. How can I do this?</source>
          <target state="translated">Это означает, что первая строка будет содержать символы перед &lt;code&gt;'-'&lt;/code&gt; , а вторая строка будет содержать символы после &lt;code&gt;'-'&lt;/code&gt; . Я также хочу проверить, есть ли в строке &lt;code&gt;'-'&lt;/code&gt; . Если нет, я брошу исключение. Как я могу это сделать?</target>
        </trans-unit>
        <trans-unit id="03bb0d5c446aa1406a8c75e4f03caf43097a0e68" translate="yes" xml:space="preserve">
          <source>The easiest way is to use &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/StringUtils.html#split%28java.lang.String,%20char%29&quot;&gt;StringUtils#split(java.lang.String, char)&lt;/a&gt;. That's more convenient than the one provided by Java out of the box if you don't need regular expressions. Like its manual says, it works like this:</source>
          <target state="translated">Самый простой способ - использовать &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/StringUtils.html#split%28java.lang.String,%20char%29&quot;&gt;StringUtils # split (java.lang.String, char)&lt;/a&gt; . Это удобнее, чем тот, который предоставляется Java из коробки, если вам не нужны регулярные выражения. Как сказано в его руководстве, он работает так:</target>
        </trans-unit>
        <trans-unit id="8e7dd528a45dc621b7c1f129d523220331c90b22" translate="yes" xml:space="preserve">
          <source>The fastest way, which also consumes the least resource could be:</source>
          <target state="translated">Самым быстрым способом,который также потребляет меньше всего ресурсов,может быть:</target>
        </trans-unit>
        <trans-unit id="9f53375b26efb231c64a3a09d645c097bdb5794a" translate="yes" xml:space="preserve">
          <source>The parentheses denote the capturing groups; the string that matched that part of the regexp can be accessed by the Match.group() method, as shown. The \d matches and single decimal digit, and the + means &quot;match one or more of the previous expression). The - has no special meaning, so just matches that character in the input. Note that you need to double-escape the backslashes when writing this as a Java string. Some other examples:</source>
          <target state="translated">Круглые скобки обозначают группы захвата;строка,соответствующая этой части регеxp,может быть доступна методом Match.group(),как показано на рисунке.\d совпадает с одной десятичной цифрой,а+означает &quot;совпадает с одним или несколькими предыдущими выражениями&quot;.)The-не имеет особого значения,поэтому просто совпадает с этим символом во входных данных.Обратите внимание,что при написании этой строки в виде Java-строки вам нужно будет дважды записать обратные слеши.Некоторые другие примеры:</target>
        </trans-unit>
        <trans-unit id="2f1564091c8c399fe0cdae8db88204245585770c" translate="yes" xml:space="preserve">
          <source>The requirements left room for interpretation. I recommend writing a method,</source>
          <target state="translated">Требования оставили место для перевода.Я рекомендую написать метод,</target>
        </trans-unit>
        <trans-unit id="22ef733bbe3da925412acc480b7de8dc28db3462" translate="yes" xml:space="preserve">
          <source>The split method has an optimization to avoid using a regular expression if the delimeter is a single character and not in the above list. Otherwise, it has to compile a regular expression, and this is not ideal.</source>
          <target state="translated">Метод split имеет оптимизацию,чтобы избежать использования регулярного выражения,если разделитель является одним символом,а не в приведенном выше списке.В противном случае,он должен скомпилировать регулярное выражение,и это не идеально.</target>
        </trans-unit>
        <trans-unit id="1039d4d97263436c7612e24c3014607be2955a3f" translate="yes" xml:space="preserve">
          <source>There are only two methods you really need to consider.</source>
          <target state="translated">Есть только два метода,которые вам действительно нужно рассмотреть.</target>
        </trans-unit>
        <trans-unit id="2ad5934937e5bc61b345d24f3e22d06c154410c1" translate="yes" xml:space="preserve">
          <source>This last option still creates a new &lt;code&gt;Matcher&lt;/code&gt; object. You can also cache this object and reset it for each input for maximum performance, but that is somewhat more complicated and not thread-safe.</source>
          <target state="translated">Эта последняя опция все еще создает новый объект &lt;code&gt;Matcher&lt;/code&gt; . Вы также можете кэшировать этот объект и сбрасывать его для каждого входа для максимальной производительности, но это несколько сложнее и не поточно-ориентировано.</target>
        </trans-unit>
        <trans-unit id="43e999a4c1efce2357ea1d7e7bdbe6f82739b5f6" translate="yes" xml:space="preserve">
          <source>This split (regex) takes a regex as an argument. Remember to escape the regex special characters, like period/dot.</source>
          <target state="translated">Это разделение (регекс)принимает регекс в качестве аргумента.Не забывайте избегать специальных символов регекса,таких как точка пародонта.</target>
        </trans-unit>
        <trans-unit id="6e02947cedc98e75e3a5b241b30474e9a29c52f5" translate="yes" xml:space="preserve">
          <source>This will split your string into 2 parts.  The first element in the array will be the part containing the stuff before the &lt;code&gt;-&lt;/code&gt;, and the 2nd element in the array will contain the part of your string after the &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">Это разделит вашу строку на 2 части. Первым элементом в массиве будет часть, содержащая материал перед &lt;code&gt;-&lt;/code&gt; , а 2-й элемент в массиве будет содержать часть вашей строки после &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3ba0939a339061a816f3d87d8a1aee227e57443" translate="yes" xml:space="preserve">
          <source>To split a string, use &lt;code&gt;String.split(regex)&lt;/code&gt;:</source>
          <target state="translated">Чтобы разбить строку, используйте &lt;code&gt;String.split(regex)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7f8658a552c8fddac1aee7a513aab32ff40548cf" translate="yes" xml:space="preserve">
          <source>To split a string, uses String.split(regex). Review the following examples:</source>
          <target state="translated">Для разделения строки используется String.split(regex).Просмотрите следующие примеры:</target>
        </trans-unit>
        <trans-unit id="c44d828d0c1bacc16a8f1111f9c0c20fb6c9d9c3" translate="yes" xml:space="preserve">
          <source>To summarize: there are at least five ways to split a string in Java:</source>
          <target state="translated">Подводя итог:существует как минимум пять способов разделения строки на Java:</target>
        </trans-unit>
        <trans-unit id="67f374ebe587596fe19b000771190ad3bf1d5ff3" translate="yes" xml:space="preserve">
          <source>To test beforehand if the string contains certain character(s), just use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contains-java.lang.CharSequence-&quot;&gt;&lt;code&gt;String#contains()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Чтобы заранее проверить, содержит ли строка определенный символ (ы), просто используйте &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contains-java.lang.CharSequence-&quot;&gt; &lt;code&gt;String#contains()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="694f7e706eb39c40b04c5d4f24c5a1b3abd95ca5" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html#split(java.lang.String,%20char)&quot;&gt;org.apache.commons.lang.StringUtils'&lt;/a&gt; split method which can split strings based on the character or string you want to split.</source>
          <target state="translated">Используйте метод разделения &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html#split(java.lang.String,%20char)&quot;&gt;org.apache.commons.lang.StringUtils,&lt;/a&gt; который может разделять строки на основе символа или строки, которую вы хотите разделить.</target>
        </trans-unit>
        <trans-unit id="f48b143c73a3beedf263bb97736aed29d112cc45" translate="yes" xml:space="preserve">
          <source>WAY 1: As you have to split two numbers by a special character you can use regex</source>
          <target state="translated">WAY 1:Так как вы должны разделить две цифры специальным символом,вы можете использовать регекс</target>
        </trans-unit>
        <trans-unit id="92a973bd215f622efe5ef3b4c633dbd595f59547" translate="yes" xml:space="preserve">
          <source>WAY 2: Using the string split method</source>
          <target state="translated">WAY 2:Использование метода разделения строк</target>
        </trans-unit>
        <trans-unit id="dd91b0658c6cf431015b14f6a00de46f9c97ac60" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of the input
  sequence then an empty leading substring is included at the beginning
  of the resulting array. A zero-width match at the beginning however
  never produces such empty leading substring.</source>
          <target state="translated">При положительном совпадении по ширине в начале входной последовательности в начало результирующего массива включается пустая ведущая подстрока.Однако при нулевом значении ширины в начале массива такая пустая ведущая подстрока никогда не появится.</target>
        </trans-unit>
        <trans-unit id="7b43177b490dfd01ed6e0438b89a88ed36b1419b" translate="yes" xml:space="preserve">
          <source>With Java 8:</source>
          <target state="translated">С Java 8:</target>
        </trans-unit>
        <trans-unit id="d70aaa84bc798cb8b2c647782fe43a7cdc3b3869" translate="yes" xml:space="preserve">
          <source>With defining the according test results, you can specify the behaviour.</source>
          <target state="translated">Определив результаты теста,вы можете задать поведение.</target>
        </trans-unit>
        <trans-unit id="76bb20eab98c1196b2934f9ecb1f186851f4c3a0" translate="yes" xml:space="preserve">
          <source>You can simply do as follows:</source>
          <target state="translated">Вы можете просто сделать следующее:</target>
        </trans-unit>
        <trans-unit id="745adfbaebad4644181f103c3028a3163d9a0618" translate="yes" xml:space="preserve">
          <source>You can simply use StringTokenizer to split a string in two or more parts whether there are any type of delimiters:</source>
          <target state="translated">Вы можете просто использовать StringTokenizer,чтобы разделить строку на две или более частей,независимо от того,существует ли какой-либо тип разделителей:</target>
        </trans-unit>
        <trans-unit id="19694d4c4ce9f54704ac6515420ed6e3759bcebb" translate="yes" xml:space="preserve">
          <source>You can split a string by a hyphen/character by using the following statement:</source>
          <target state="translated">Вы можете разделить строку по дефисному символу,используя следующее утверждение:</target>
        </trans-unit>
        <trans-unit id="f73c5ea266b5f4a2c5c45a763ef228fc21408fdc" translate="yes" xml:space="preserve">
          <source>You can split a string by a line break by using the following statement:</source>
          <target state="translated">Вы можете разделить строку на разрыв,используя следующий оператор:</target>
        </trans-unit>
        <trans-unit id="40de6a8dc52dcc8f5824e304163fb8987a745e82" translate="yes" xml:space="preserve">
          <source>You can try like this also</source>
          <target state="translated">Вы можете попробовать так же</target>
        </trans-unit>
        <trans-unit id="54f18385d816c9a4bacc1a8fbc3b8590fbabb8e9" translate="yes" xml:space="preserve">
          <source>You can use Split():</source>
          <target state="translated">Вы можете использовать Split():</target>
        </trans-unit>
        <trans-unit id="aa9dfb7e3dece5be03c64f343a81607eca2aa807" translate="yes" xml:space="preserve">
          <source>You can use the method &lt;code&gt;split&lt;/code&gt;:</source>
          <target state="translated">Вы можете использовать метод &lt;code&gt;split&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9668d451d8c924278f7d7ecccc4e44a51b306de9" translate="yes" xml:space="preserve">
          <source>You should write some unit-tests for input strings and the desired results and behaviour.</source>
          <target state="translated">Вы должны написать несколько юнит-тестов для входных строк и желаемых результатов и поведения.</target>
        </trans-unit>
        <trans-unit id="df28550c3b81f1b880a49ceb27fb76bcc7fa42ee" translate="yes" xml:space="preserve">
          <source>should do thing you want. String class has many method to operate with string.</source>
          <target state="translated">должен делать то,что ты хочешь.В классе String есть много методов для работы со строкой.</target>
        </trans-unit>
        <trans-unit id="0b96290f91b9d7829c5e672bebedfa30ff377327" translate="yes" xml:space="preserve">
          <source>we will get three strings: &lt;code&gt;[0, 0, 4]&lt;/code&gt; and not four as was the case in Java 7 and before. Also check this similar &lt;a href=&quot;https://stackoverflow.com/questions/22718744/why-in-java-8-split-sometimes-removes-empty-strings-at-start-of-result-array&quot;&gt;question&lt;/a&gt;.</source>
          <target state="translated">мы получим три строки: &lt;code&gt;[0, 0, 4]&lt;/code&gt; а не четыре, как это было в Java 7 и ранее. Также проверьте этот похожий &lt;a href=&quot;https://stackoverflow.com/questions/22718744/why-in-java-8-split-sometimes-removes-empty-strings-at-start-of-result-array&quot;&gt;вопрос&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2345d121bec649a607f505938c08c500e93234d7" translate="yes" xml:space="preserve">
          <source>which encapsulate this function. Of course you can use String.split(..) as mentioned in the other answers for the implementation.</source>
          <target state="translated">которые инкапсулируют эту функцию.Конечно,для реализации можно использовать String.split(...),как указано в других ответах.</target>
        </trans-unit>
        <trans-unit id="3fcd8bbf37ea44a0a387328f2a950f3728942e2c" translate="yes" xml:space="preserve">
          <source>you don't really need regular expressions for your split</source>
          <target state="translated">тебе не нужны регулярные выражения для твоего раскола.</target>
        </trans-unit>
        <trans-unit id="bda5d696e27288e5ed234a4c1931bcf4af52f245" translate="yes" xml:space="preserve">
          <source>you happen to already use apache commons lang in your app</source>
          <target state="translated">вы уже используете apache Commons lang в вашем приложении.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
