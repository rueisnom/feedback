<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/3481828">
    <body>
      <group id="3481828">
        <trans-unit id="634a0bdd960a66ce1185d269b6e09c19a16d7e59" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;there&lt;/a&gt; are 12 characters with special meanings: the backslash &lt;code&gt;\&lt;/code&gt;, the caret &lt;code&gt;^&lt;/code&gt;, the dollar sign &lt;code&gt;$&lt;/code&gt;, the period or dot &lt;code&gt;.&lt;/code&gt;, the vertical bar or pipe symbol &lt;code&gt;|&lt;/code&gt;, the question mark &lt;code&gt;?&lt;/code&gt;, the asterisk or star &lt;code&gt;*&lt;/code&gt;, the plus sign &lt;code&gt;+&lt;/code&gt;, the opening parenthesis &lt;code&gt;(&lt;/code&gt;, the closing parenthesis &lt;code&gt;)&lt;/code&gt;, and the opening square bracket &lt;code&gt;[&lt;/code&gt;, the opening curly brace &lt;code&gt;{&lt;/code&gt;, These special characters are often called &quot;metacharacters&quot;.</source>
          <target state="translated">&lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;Hay&lt;/a&gt; 12 caracteres con significados especiales: la barra invertida &lt;code&gt;\&lt;/code&gt; , el s&amp;iacute;mbolo de intercalaci&amp;oacute;n &lt;code&gt;^&lt;/code&gt; , el signo de d&amp;oacute;lar &lt;code&gt;$&lt;/code&gt; , el punto o el punto &lt;code&gt;.&lt;/code&gt; , el s&amp;iacute;mbolo de barra vertical o tubo &lt;code&gt;|&lt;/code&gt; , el signo de interrogaci&amp;oacute;n &lt;code&gt;?&lt;/code&gt; , el asterisco o la estrella &lt;code&gt;*&lt;/code&gt; , el signo m&amp;aacute;s &lt;code&gt;+&lt;/code&gt; , el par&amp;eacute;ntesis de apertura &lt;code&gt;(&lt;/code&gt; el par&amp;eacute;ntesis de cierre &lt;code&gt;)&lt;/code&gt; y el corchete de apertura &lt;code&gt;[&lt;/code&gt; , la llave de apertura &lt;code&gt;{&lt;/code&gt; , estos caracteres especiales a menudo se denominan &quot;metacaracteres&quot;.</target>
        </trans-unit>
        <trans-unit id="9eaaedfd4cc1e7d310987fa57faf8f0dadb38f16" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://explainjava.com/split-string-java/&quot;&gt;Here&lt;/a&gt; is a big overview of these methods and the most common examples (how to split by dot, slash, question mark, etc.)</source>
          <target state="translated">&lt;a href=&quot;https://explainjava.com/split-string-java/&quot;&gt;Aqu&amp;iacute;&lt;/a&gt; hay una gran descripci&amp;oacute;n de estos m&amp;eacute;todos y los ejemplos m&amp;aacute;s comunes (c&amp;oacute;mo dividir por punto, barra, signo de interrogaci&amp;oacute;n, etc.)</target>
        </trans-unit>
        <trans-unit id="e1313d9d177aa767a2f19ce3fbfac579ced79591" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;&lt;em&gt;String Split with multiple characters using Regex&lt;/em&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;em&gt;Divisi&amp;oacute;n de cadenas con m&amp;uacute;ltiples caracteres usando Regex&lt;/em&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ccfff51da82250c6945871fe29c0806ff574c48" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Output:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Output:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9c16943696a740385ff52f52ff01f2c21d575844" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use Pattern.split and precompile the pattern if using a complex delimiter and you care about performance.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Use Pattern.split y precompile el patr&amp;oacute;n si usa un delimitador complejo y le preocupa el rendimiento.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="54fbcdde970b3680f7855bf3eb18ae8469d7ce0e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Use String.split for a one-character delimiter or you don't care about performance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Use String.split para un delimitador de un car&amp;aacute;cter o no le importa el rendimiento&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7eeb6651db327271e5d1629a11d7fe0d16a7d8b" translate="yes" xml:space="preserve">
          <source>An alternative to processing the string directly would be to use a regular expression with capturing groups. This has the advantage that it makes it straightforward to imply more sophisticated constraints on the input. For example, the following splits the string into two parts, and ensures that both consist only of digits:</source>
          <target state="translated">Una alternativa al procesamiento directo de la cadena sería utilizar una expresión regular con grupos de captura.Esto tiene la ventaja de que hace que sea sencillo implicar restricciones más sofisticadas en la entrada.Por ejemplo,a continuación se divide la cadena en dos partes,y se asegura que ambas consistan sólo en dígitos:</target>
        </trans-unit>
        <trans-unit id="19627da7883a0613ac58045d6ef1f0d8e6c29df6" translate="yes" xml:space="preserve">
          <source>And as expected it will print:</source>
          <target state="translated">Y como se esperaba,se imprimirá:</target>
        </trans-unit>
        <trans-unit id="281d300200893a33e3537d992266d3b91d6ad40f" translate="yes" xml:space="preserve">
          <source>Apache Commons StringUtils:</source>
          <target state="translated">Apache Commons StringUtils:</target>
        </trans-unit>
        <trans-unit id="0bd2c33eab401a57c01e405d1bbc1c234e7435b3" translate="yes" xml:space="preserve">
          <source>As mentioned by everyone, split() is the best option which may be used in your case. An alternative method can be using substring().</source>
          <target state="translated">Como todos han mencionado,split()es la mejor opción que se puede utilizar en su caso.Un método alternativo puede ser el uso de substring().</target>
        </trans-unit>
        <trans-unit id="455bf4d4aefbaf76e95abcb994d64522e57f5a43" translate="yes" xml:space="preserve">
          <source>As the pattern is fixed in this instance, it can be compiled in advance and stored as a static member (initialised at class load time in the example). The regular expression is:</source>
          <target state="translated">Como el patrón es fijo en este caso,puede ser compilado por adelantado y almacenado como un miembro estático (inicializado en el tiempo de carga de la clase en el ejemplo).La expresión regular es:</target>
        </trans-unit>
        <trans-unit id="acd8d9d3530feb7f220a993eb4bc93080beec114" translate="yes" xml:space="preserve">
          <source>Assume that if &lt;code&gt;-&lt;/code&gt; does not exists in your string, it returns the given string, and you will not get any exception.</source>
          <target state="translated">Suponga que si &lt;code&gt;-&lt;/code&gt; no existe en su cadena, devuelve la cadena dada y no obtendr&amp;aacute; ninguna excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b598f05f355293d3ba808a995629e736abdf52ac" translate="yes" xml:space="preserve">
          <source>Assuming, that</source>
          <target state="translated">Asumiendo,que</target>
        </trans-unit>
        <trans-unit id="170679a43c9b6393ea32de0f697ab9d50e3a0a66" translate="yes" xml:space="preserve">
          <source>But do not expect the same output across all JDK versions. I have seen &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8043324&quot;&gt;one bug&lt;/a&gt; which exists in some JDK versions where the first null string has been ignored. This bug is not present in the latest JDK version, but it exists in some versions between JDK 1.7 late versions and 1.8 early versions.</source>
          <target state="translated">Pero no espere el mismo resultado en todas las versiones de JDK. He visto &lt;a href=&quot;https://bugs.openjdk.java.net/browse/JDK-8043324&quot;&gt;un error&lt;/a&gt; que existe en algunas versiones de JDK donde la primera cadena nula ha sido ignorada. Este error no est&amp;aacute; presente en la &amp;uacute;ltima versi&amp;oacute;n de JDK, pero existe en algunas versiones entre las versiones finales JDK 1.7 y 1.8 versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="2e0832e81bd97677c3c3e45f933928a5b9fcf585" translate="yes" xml:space="preserve">
          <source>Check out the &lt;code&gt;split()&lt;/code&gt; method in the &lt;code&gt;String&lt;/code&gt; class on javadoc.</source>
          <target state="translated">Consulte el m&amp;eacute;todo &lt;code&gt;split()&lt;/code&gt; en la clase &lt;code&gt;String&lt;/code&gt; en javadoc.</target>
        </trans-unit>
        <trans-unit id="9e823ab53cec95c3e300ab785e078436d9d366d4" translate="yes" xml:space="preserve">
          <source>Check out the &lt;code&gt;split()&lt;/code&gt; method in the &lt;code&gt;String&lt;/code&gt; class.</source>
          <target state="translated">Echa un vistazo al m&amp;eacute;todo &lt;code&gt;split()&lt;/code&gt; en la clase &lt;code&gt;String&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3172bac692f1e831e3ef1816e8723add91fa4296" translate="yes" xml:space="preserve">
          <source>Else, you can use StringTokenizer:</source>
          <target state="translated">Si no,puedes usar StringTokenizer:</target>
        </trans-unit>
        <trans-unit id="26e0e8524f90a3c867fdd33bcd49bb6fa8f4e4d0" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;&quot;-333&quot;&lt;/code&gt; should return in &lt;code&gt;[,333]&lt;/code&gt; or if it is an error.
Can &lt;code&gt;&quot;333-333-33&quot;&lt;/code&gt; be separated in &lt;code&gt;[333,333-33] or [333-333,33]&lt;/code&gt; or is it an error? And so on.</source>
          <target state="translated">Por ejemplo, si &lt;code&gt;&quot;-333&quot;&lt;/code&gt; deber&amp;iacute;a regresar en &lt;code&gt;[,333]&lt;/code&gt; o si es un error. &amp;iquest;Puede &lt;code&gt;&quot;333-333-33&quot;&lt;/code&gt; separarse en &lt;code&gt;[333,333-33] or [333-333,33]&lt;/code&gt; o es un error? Y as&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="a959961f689dc6305eb84be8327b92d85950c3fd" translate="yes" xml:space="preserve">
          <source>For simple use cases &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;&lt;code&gt;String.split()&lt;/code&gt;&lt;/a&gt; should do the job. If you use guava, there is also a &lt;a href=&quot;https://github.com/google/guava/wiki/StringsExplained#splitter&quot;&gt;Splitter&lt;/a&gt; class which allows chaining of different string operations and supports &lt;a href=&quot;https://google.github.io/guava/releases/snapshot-jre/api/docs/com/google/common/base/CharMatcher.html&quot;&gt;CharMatcher&lt;/a&gt;:</source>
          <target state="translated">Para casos de uso simple, &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt; &lt;code&gt;String.split()&lt;/code&gt; &lt;/a&gt; deber&amp;iacute;a hacer el trabajo. Si usa guayaba, tambi&amp;eacute;n hay una clase &lt;a href=&quot;https://github.com/google/guava/wiki/StringsExplained#splitter&quot;&gt;Splitter&lt;/a&gt; que permite el encadenamiento de diferentes operaciones de cadena y admite &lt;a href=&quot;https://google.github.io/guava/releases/snapshot-jre/api/docs/com/google/common/base/CharMatcher.html&quot;&gt;CharMatcher&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="41aa5e8cca232ef96ae8344d4180dbf6e0984c6c" translate="yes" xml:space="preserve">
          <source>Good test candidates should include:</source>
          <target state="translated">Los buenos candidatos para el examen deben incluir:</target>
        </trans-unit>
        <trans-unit id="66c15e0f61dc4ba39ea4ecd546d9001621adbb7c" translate="yes" xml:space="preserve">
          <source>Google Guava Splitter:</source>
          <target state="translated">Google Guava Splitter:</target>
        </trans-unit>
        <trans-unit id="1b570f545b2da28a044cb15d0d777d7bb12661f7" translate="yes" xml:space="preserve">
          <source>Here are two ways two achieve it.</source>
          <target state="translated">Aquí hay dos formas de lograrlo.</target>
        </trans-unit>
        <trans-unit id="d7702fb6307a48ed358e3bf97b7b58828135f99f" translate="yes" xml:space="preserve">
          <source>Here many examples for split string but I little code optimized.</source>
          <target state="translated">Aquí hay muchos ejemplos de cadenas divididas pero poco código optimizado.</target>
        </trans-unit>
        <trans-unit id="ecaeeb1e045a34e4ed62d11ef9b1606af81639f3" translate="yes" xml:space="preserve">
          <source>How to split a string in Java</source>
          <target state="translated">Cómo dividir una cadena en Java</target>
        </trans-unit>
        <trans-unit id="9d00bd1b546789395f672ebe1d098d7b4670e821" translate="yes" xml:space="preserve">
          <source>I have a string, &lt;code&gt;&quot;004-034556&quot;&lt;/code&gt;, that I want to split into two strings:</source>
          <target state="translated">Tengo una cadena, &lt;code&gt;&quot;004-034556&quot;&lt;/code&gt; , que quiero dividir en dos cadenas:</target>
        </trans-unit>
        <trans-unit id="597fca85260a03d531d03509982c894f6ec88d3a" translate="yes" xml:space="preserve">
          <source>I just wanted to write an algorithm instead of using Java built-in functions:</source>
          <target state="translated">Sólo quería escribir un algoritmo en lugar de usar las funciones incorporadas de Java:</target>
        </trans-unit>
        <trans-unit id="73640238f9039cdaa6a85588bf8ae148414cb776" translate="yes" xml:space="preserve">
          <source>I would recommend using commong-lang, since usually it contains a lot of stuff that's usable. However, if you don't need it for anything else than doing a split, then implementing yourself or escaping the regex is a better option.</source>
          <target state="translated">Recomendaría usar el lenguaje común,ya que normalmente contiene un montón de cosas que son utilizables.Sin embargo,si no lo necesitas para nada más que para hacer un split,entonces implementarse o escapar del regex es una mejor opción.</target>
        </trans-unit>
        <trans-unit id="35f5eaeb8f626d3b81bb83d806e7bb128d180dfa" translate="yes" xml:space="preserve">
          <source>If performance is an issue, and your delimiter is not one of the above, you should pre-compile a regular expression pattern which you can then reuse.</source>
          <target state="translated">Si el rendimiento es un problema,y su delimitador no es uno de los anteriores,debe precompilar un patrón de expresión regular que luego puede reutilizar.</target>
        </trans-unit>
        <trans-unit id="5711570bf541c6fabc965cce5a0f19929f00eb29" translate="yes" xml:space="preserve">
          <source>If performance is not an issue, or if the delimiter is a single character that is not a regular expression special character (i.e., not one of &lt;code&gt;.$|()[{^?*+\&lt;/code&gt;) then you can use &lt;code&gt;String.split&lt;/code&gt;.</source>
          <target state="translated">Si el rendimiento no es un problema, o si el delimitador es un solo car&amp;aacute;cter que no es un car&amp;aacute;cter especial de expresi&amp;oacute;n regular (es decir, no es uno de &lt;code&gt;.$|()[{^?*+\&lt;/code&gt; ), Puede usar &lt;code&gt;String.split&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abb4797fa4e7a9f330539336db1653a5f6b50e22" translate="yes" xml:space="preserve">
          <source>If the array length is not 2, then the string was not in the format: &lt;code&gt;string-string&lt;/code&gt;.</source>
          <target state="translated">Si la longitud de la matriz no es 2, entonces la cadena no ten&amp;iacute;a el formato: &lt;code&gt;string-string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9379386900a7ba181b578a891a6edd088cb32a8" translate="yes" xml:space="preserve">
          <source>If you'd like to limit the number of resulting parts, then you can supply the desired number as 2nd argument of &lt;code&gt;split()&lt;/code&gt; method.</source>
          <target state="translated">Si desea limitar el n&amp;uacute;mero de partes resultantes, puede proporcionar el n&amp;uacute;mero deseado como segundo argumento del m&amp;eacute;todo &lt;code&gt;split()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf486efb110a169d1ec321ad391237aea75e64a5" translate="yes" xml:space="preserve">
          <source>If you'd like to retain the split character in the resulting parts, then make use of &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;positive lookaround&lt;/a&gt;. In case you want to have the split character to end up in left hand side, use positive lookbehind by prefixing &lt;code&gt;?&amp;lt;=&lt;/code&gt; group on the pattern.</source>
          <target state="translated">Si desea conservar el car&amp;aacute;cter dividido en las partes resultantes, utilice &lt;a href=&quot;http://www.regular-expressions.info/lookaround.html&quot;&gt;una apariencia positiva&lt;/a&gt; . En caso de que desee que el car&amp;aacute;cter dividido termine en el lado izquierdo, use una mirada hacia atr&amp;aacute;s positiva con el prefijo &lt;code&gt;?&amp;lt;=&lt;/code&gt; Group en el patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7d5bcf86d6aef4f63d20823de18fef46a3444d8b" translate="yes" xml:space="preserve">
          <source>In case you want to have the split character to end up in right hand side, use positive lookahead by prefixing &lt;code&gt;?=&lt;/code&gt; group on the pattern.</source>
          <target state="translated">En caso de que desee que el car&amp;aacute;cter dividido termine en el lado derecho, utilice una b&amp;uacute;squeda anticipada positiva con el prefijo &lt;code&gt;?=&lt;/code&gt; Group en el patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d4d53e1a023a39b0d46c1060abcaf2ee36561cad" translate="yes" xml:space="preserve">
          <source>In this answer I also want to point out &lt;strong&gt;one change that has taken place for &lt;code&gt;split&lt;/code&gt; method in Java 8&lt;/strong&gt;. The &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;String#split()&lt;/a&gt; method makes use of &lt;code&gt;Pattern.split&lt;/code&gt;, and now it will remove empty strings at the start of the result array. Notice this &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-int-&quot;&gt;change&lt;/a&gt; in documentation for Java 8:</source>
          <target state="translated">En esta respuesta tambi&amp;eacute;n quiero se&amp;ntilde;alar &lt;strong&gt;un cambio que ha tenido lugar para el m&amp;eacute;todo de &lt;code&gt;split&lt;/code&gt; en Java 8&lt;/strong&gt; . El m&amp;eacute;todo &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;String # split ()&lt;/a&gt; utiliza &lt;code&gt;Pattern.split&lt;/code&gt; y ahora eliminar&amp;aacute; cadenas vac&amp;iacute;as al comienzo de la matriz de resultados. Observe este &lt;a href=&quot;https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#split-java.lang.CharSequence-int-&quot;&gt;cambio&lt;/a&gt; en la documentaci&amp;oacute;n para Java 8:</target>
        </trans-unit>
        <trans-unit id="9d7ee1e0bfdc43c72fde2787f5595a8e3fe895b2" translate="yes" xml:space="preserve">
          <source>In your case, you want to split a string when there is a &quot;-&quot;.</source>
          <target state="translated">En tu caso,quieres dividir una cuerda cuando hay un &quot;-&quot;.</target>
        </trans-unit>
        <trans-unit id="e1bab11672544eaa3fe560aec8ed33483038ee1c" translate="yes" xml:space="preserve">
          <source>It means for the following example:</source>
          <target state="translated">Significa para el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="708293cbdedf6516d4e9d0f795068139869bebd2" translate="yes" xml:space="preserve">
          <source>Just use the appropriate method: &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt;&lt;code&gt;String#split()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Simplemente use el m&amp;eacute;todo apropiado: &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#split-java.lang.String-&quot;&gt; &lt;code&gt;String#split()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a1366efda6e348068340179972f16275440d6ada" translate="yes" xml:space="preserve">
          <source>Method signature:</source>
          <target state="translated">Firma del método:</target>
        </trans-unit>
        <trans-unit id="f2689175bd2423f6686ae7bc6456bdb43ffb0fd2" translate="yes" xml:space="preserve">
          <source>Note that this takes a &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#sum&quot;&gt;regular expression&lt;/a&gt;, so remember to escape &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;special characters&lt;/a&gt; if necessary.</source>
          <target state="translated">Tenga en cuenta que esto toma una &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#sum&quot;&gt;expresi&amp;oacute;n regular&lt;/a&gt; , as&amp;iacute; que recuerde escapar de &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;caracteres especiales&lt;/a&gt; si es necesario.</target>
        </trans-unit>
        <trans-unit id="2a53efac5096370ec7851ba3b6a71bc3e8c97d59" translate="yes" xml:space="preserve">
          <source>Note, this does not take a regular expression. For that, use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-&quot;&gt;&lt;code&gt;String#matches()&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">Tenga en cuenta que esto no toma una expresi&amp;oacute;n regular. Para eso, use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#matches-java.lang.String-&quot;&gt; &lt;code&gt;String#matches()&lt;/code&gt; &lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="83423c198b6099edba08f185f940042d5dba3b79" translate="yes" xml:space="preserve">
          <source>Note:</source>
          <target state="translated">Note:</target>
        </trans-unit>
        <trans-unit id="513d0f10bf46562c61b583d103c88e43eb73c3f4" translate="yes" xml:space="preserve">
          <source>One way to do this is to run through the String in a for-each loop and use the required split character.</source>
          <target state="translated">Una forma de hacerlo es correr a través de la cuerda en un bucle para cada uno y utilizar el carácter dividido requerido.</target>
        </trans-unit>
        <trans-unit id="4bed336194a9a5c86b6a734f03b3570d2aae1a68" translate="yes" xml:space="preserve">
          <source>Output</source>
          <target state="translated">Output</target>
        </trans-unit>
        <trans-unit id="f3c8c95c5e534bcd2ea0034a0d83177efa6923f4" translate="yes" xml:space="preserve">
          <source>Output:</source>
          <target state="translated">Output:</target>
        </trans-unit>
        <trans-unit id="5511135f9bda614cd85fc511dd6cc901ed9ac0c1" translate="yes" xml:space="preserve">
          <source>Pattern.compile(regexp).splitAsStream(input):</source>
          <target state="translated">Pattern.compile(regexp).splitAsStream(input):</target>
        </trans-unit>
        <trans-unit id="e668e302dd28bb529bbcea9393d214b1f72d72a5" translate="yes" xml:space="preserve">
          <source>Please don't use &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html&quot;&gt;StringTokenizer&lt;/a&gt; class as it is a legacy class that is retained for compatibility reasons, and its use is discouraged in new code. And we can make use of the split method as suggested by others as well.</source>
          <target state="translated">No use la clase &lt;a href=&quot;https://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html&quot;&gt;StringTokenizer&lt;/a&gt; ya que es una clase heredada que se retiene por razones de compatibilidad, y su uso no se recomienda en el nuevo c&amp;oacute;digo. Y tambi&amp;eacute;n podemos utilizar el m&amp;eacute;todo de divisi&amp;oacute;n seg&amp;uacute;n lo sugerido por otros.</target>
        </trans-unit>
        <trans-unit id="bbfc20ca78fd6cf9b899cc707fe259878f888277" translate="yes" xml:space="preserve">
          <source>So you can choose the best option for you depending on what you need, e.g. return type (array, list, or iterable).</source>
          <target state="translated">Así que puedes elegir la mejor opción para ti dependiendo de lo que necesites,por ejemplo,el tipo de retorno (matriz,lista o iterable).</target>
        </trans-unit>
        <trans-unit id="8be17a304e765e19a6319cd20c6fe0da067be66f" translate="yes" xml:space="preserve">
          <source>So, if you want to split on e.g. period/dot &lt;code&gt;.&lt;/code&gt; which means &quot;&lt;a href=&quot;http://www.regular-expressions.info/dot.html&quot;&gt;any character&lt;/a&gt;&quot; in regex, use either &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;backslash &lt;code&gt;\&lt;/code&gt;&lt;/a&gt; to escape the individual special character like so &lt;code&gt;split(&quot;\\.&quot;)&lt;/code&gt;, or use &lt;a href=&quot;http://www.regular-expressions.info/charclass.html&quot;&gt;character class &lt;code&gt;[]&lt;/code&gt;&lt;/a&gt; to represent literal character(s) like so &lt;code&gt;split(&quot;[.]&quot;)&lt;/code&gt;, or use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#quote-java.lang.String-&quot;&gt;&lt;code&gt;Pattern#quote()&lt;/code&gt;&lt;/a&gt; to escape the entire string like so &lt;code&gt;split(Pattern.quote(&quot;.&quot;))&lt;/code&gt;.</source>
          <target state="translated">Entonces, si desea dividir, por ejemplo, punto / punto &lt;code&gt;.&lt;/code&gt; lo que significa &quot; &lt;a href=&quot;http://www.regular-expressions.info/dot.html&quot;&gt;cualquier car&amp;aacute;cter&lt;/a&gt; &quot; en la expresi&amp;oacute;n regular, utilice la &lt;a href=&quot;http://www.regular-expressions.info/characters.html&quot;&gt;barra diagonal inversa &lt;code&gt;\&lt;/code&gt; &lt;/a&gt; para escapar del car&amp;aacute;cter especial individual como &lt;code&gt;split(&quot;\\.&quot;)&lt;/code&gt; , o utilice la &lt;a href=&quot;http://www.regular-expressions.info/charclass.html&quot;&gt;clase de caracteres &lt;code&gt;[]&lt;/code&gt; &lt;/a&gt; para representar los caracteres literales como &lt;code&gt;split(&quot;[.]&quot;)&lt;/code&gt; , o use el &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html#quote-java.lang.String-&quot;&gt; &lt;code&gt;Pattern#quote()&lt;/code&gt; &lt;/a&gt; para escapar de toda la cadena como &lt;code&gt;split(Pattern.quote(&quot;.&quot;))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a74d76701ae5ebf50bbbd415c4b559ff9f240db" translate="yes" xml:space="preserve">
          <source>String.split():</source>
          <target state="translated">String.split():</target>
        </trans-unit>
        <trans-unit id="21c6a5aab11d8d9baff2af00b73b27e61eb1bb70" translate="yes" xml:space="preserve">
          <source>StringTokenizer (legacy class):</source>
          <target state="translated">StringTokenizer (clase de legado):</target>
        </trans-unit>
        <trans-unit id="d426fef84e8059c41d3b539263be4a0ac67f062c" translate="yes" xml:space="preserve">
          <source>That means the first string will contain the characters before &lt;code&gt;'-'&lt;/code&gt;, and the second string will contain the characters after &lt;code&gt;'-'&lt;/code&gt;. I also want to check if the string has &lt;code&gt;'-'&lt;/code&gt; in it. If not, I will throw an exception. How can I do this?</source>
          <target state="translated">Eso significa que la primera cadena contendr&amp;aacute; los caracteres antes de &lt;code&gt;'-'&lt;/code&gt; , y la segunda cadena contendr&amp;aacute; los caracteres despu&amp;eacute;s de &lt;code&gt;'-'&lt;/code&gt; . Tambi&amp;eacute;n quiero verificar si la cadena tiene &lt;code&gt;'-'&lt;/code&gt; . Si no, lanzar&amp;eacute; una excepci&amp;oacute;n. &amp;iquest;C&amp;oacute;mo puedo hacer esto?</target>
        </trans-unit>
        <trans-unit id="03bb0d5c446aa1406a8c75e4f03caf43097a0e68" translate="yes" xml:space="preserve">
          <source>The easiest way is to use &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/StringUtils.html#split%28java.lang.String,%20char%29&quot;&gt;StringUtils#split(java.lang.String, char)&lt;/a&gt;. That's more convenient than the one provided by Java out of the box if you don't need regular expressions. Like its manual says, it works like this:</source>
          <target state="translated">La forma m&amp;aacute;s f&amp;aacute;cil es usar &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-3.1/org/apache/commons/lang3/StringUtils.html#split%28java.lang.String,%20char%29&quot;&gt;StringUtils # split (java.lang.String, char)&lt;/a&gt; . Eso es m&amp;aacute;s conveniente que el proporcionado por Java fuera de la caja si no necesita expresiones regulares. Como dice su manual, funciona as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="8e7dd528a45dc621b7c1f129d523220331c90b22" translate="yes" xml:space="preserve">
          <source>The fastest way, which also consumes the least resource could be:</source>
          <target state="translated">La forma más rápida,que también consume el menor recurso podría ser:</target>
        </trans-unit>
        <trans-unit id="9f53375b26efb231c64a3a09d645c097bdb5794a" translate="yes" xml:space="preserve">
          <source>The parentheses denote the capturing groups; the string that matched that part of the regexp can be accessed by the Match.group() method, as shown. The \d matches and single decimal digit, and the + means &quot;match one or more of the previous expression). The - has no special meaning, so just matches that character in the input. Note that you need to double-escape the backslashes when writing this as a Java string. Some other examples:</source>
          <target state="translated">Los paréntesis denotan los grupos de captura;la cadena que coincidió con esa parte del regexp puede ser accedida por el método Match.group(),como se muestra.La \d coincide con un solo dígito decimal,y el+significa &quot;coincide con una o más de la expresión anterior&quot;).El-no tiene un significado especial,así que sólo coincide con ese carácter en la entrada.Ten en cuenta que debes evitar las barras invertidas cuando escribas esto como una cadena de Java.Algunos otros ejemplos:</target>
        </trans-unit>
        <trans-unit id="2f1564091c8c399fe0cdae8db88204245585770c" translate="yes" xml:space="preserve">
          <source>The requirements left room for interpretation. I recommend writing a method,</source>
          <target state="translated">Los requisitos dejaron espacio para la interpretación.Recomiendo escribir un método,</target>
        </trans-unit>
        <trans-unit id="22ef733bbe3da925412acc480b7de8dc28db3462" translate="yes" xml:space="preserve">
          <source>The split method has an optimization to avoid using a regular expression if the delimeter is a single character and not in the above list. Otherwise, it has to compile a regular expression, and this is not ideal.</source>
          <target state="translated">El método de división tiene una optimización para evitar el uso de una expresión regular si el delimitador es un solo carácter y no está en la lista anterior.De lo contrario,tiene que compilar una expresión regular,y esto no es lo ideal.</target>
        </trans-unit>
        <trans-unit id="1039d4d97263436c7612e24c3014607be2955a3f" translate="yes" xml:space="preserve">
          <source>There are only two methods you really need to consider.</source>
          <target state="translated">Sólo hay dos métodos que debes considerar.</target>
        </trans-unit>
        <trans-unit id="2ad5934937e5bc61b345d24f3e22d06c154410c1" translate="yes" xml:space="preserve">
          <source>This last option still creates a new &lt;code&gt;Matcher&lt;/code&gt; object. You can also cache this object and reset it for each input for maximum performance, but that is somewhat more complicated and not thread-safe.</source>
          <target state="translated">Esta &amp;uacute;ltima opci&amp;oacute;n a&amp;uacute;n crea un nuevo objeto &lt;code&gt;Matcher&lt;/code&gt; . Tambi&amp;eacute;n puede almacenar en cach&amp;eacute; este objeto y restablecerlo para cada entrada para obtener el m&amp;aacute;ximo rendimiento, pero eso es algo m&amp;aacute;s complicado y no es seguro para subprocesos.</target>
        </trans-unit>
        <trans-unit id="43e999a4c1efce2357ea1d7e7bdbe6f82739b5f6" translate="yes" xml:space="preserve">
          <source>This split (regex) takes a regex as an argument. Remember to escape the regex special characters, like period/dot.</source>
          <target state="translated">Esta división (regex)toma un regex como argumento.Recuerde escapar de los caracteres especiales de la regex,como el punto y coma.</target>
        </trans-unit>
        <trans-unit id="6e02947cedc98e75e3a5b241b30474e9a29c52f5" translate="yes" xml:space="preserve">
          <source>This will split your string into 2 parts.  The first element in the array will be the part containing the stuff before the &lt;code&gt;-&lt;/code&gt;, and the 2nd element in the array will contain the part of your string after the &lt;code&gt;-&lt;/code&gt;.</source>
          <target state="translated">Esto dividir&amp;aacute; su cadena en 2 partes. El primer elemento en la matriz ser&amp;aacute; la parte que contiene las cosas antes de &lt;code&gt;-&lt;/code&gt; , y el segundo elemento en la matriz contendr&amp;aacute; la parte de su cadena despu&amp;eacute;s de &lt;code&gt;-&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3ba0939a339061a816f3d87d8a1aee227e57443" translate="yes" xml:space="preserve">
          <source>To split a string, use &lt;code&gt;String.split(regex)&lt;/code&gt;:</source>
          <target state="translated">Para dividir una cadena, use &lt;code&gt;String.split(regex)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7f8658a552c8fddac1aee7a513aab32ff40548cf" translate="yes" xml:space="preserve">
          <source>To split a string, uses String.split(regex). Review the following examples:</source>
          <target state="translated">Para dividir una cadena,usa String.split(regex).Revise los siguientes ejemplos:</target>
        </trans-unit>
        <trans-unit id="c44d828d0c1bacc16a8f1111f9c0c20fb6c9d9c3" translate="yes" xml:space="preserve">
          <source>To summarize: there are at least five ways to split a string in Java:</source>
          <target state="translated">Para resumir:hay al menos cinco maneras de dividir una cadena en Java:</target>
        </trans-unit>
        <trans-unit id="67f374ebe587596fe19b000771190ad3bf1d5ff3" translate="yes" xml:space="preserve">
          <source>To test beforehand if the string contains certain character(s), just use &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contains-java.lang.CharSequence-&quot;&gt;&lt;code&gt;String#contains()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Para probar de antemano si la cadena contiene ciertos caracteres, solo use la &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/String.html#contains-java.lang.CharSequence-&quot;&gt; &lt;code&gt;String#contains()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="694f7e706eb39c40b04c5d4f24c5a1b3abd95ca5" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html#split(java.lang.String,%20char)&quot;&gt;org.apache.commons.lang.StringUtils'&lt;/a&gt; split method which can split strings based on the character or string you want to split.</source>
          <target state="translated">Use &lt;a href=&quot;http://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html#split(java.lang.String,%20char)&quot;&gt;el&lt;/a&gt; m&amp;eacute;todo de divisi&amp;oacute;n org.apache.commons.lang.StringUtils que puede dividir cadenas en funci&amp;oacute;n del car&amp;aacute;cter o cadena que desea dividir.</target>
        </trans-unit>
        <trans-unit id="f48b143c73a3beedf263bb97736aed29d112cc45" translate="yes" xml:space="preserve">
          <source>WAY 1: As you have to split two numbers by a special character you can use regex</source>
          <target state="translated">VÍA 1:Como tienes que dividir dos números por un carácter especial puedes usar regex</target>
        </trans-unit>
        <trans-unit id="92a973bd215f622efe5ef3b4c633dbd595f59547" translate="yes" xml:space="preserve">
          <source>WAY 2: Using the string split method</source>
          <target state="translated">CAMINO 2:Usando el método de división de la cadena</target>
        </trans-unit>
        <trans-unit id="dd91b0658c6cf431015b14f6a00de46f9c97ac60" translate="yes" xml:space="preserve">
          <source>When there is a positive-width match at the beginning of the input
  sequence then an empty leading substring is included at the beginning
  of the resulting array. A zero-width match at the beginning however
  never produces such empty leading substring.</source>
          <target state="translated">Cuando hay una coincidencia de anchura positiva al principio de la secuencia de entrada,entonces se incluye una subcadena principal vacía al principio de la matriz resultante.Sin embargo,una coincidencia de ancho cero al principio nunca produce una subcadena principal tan vacía.</target>
        </trans-unit>
        <trans-unit id="7b43177b490dfd01ed6e0438b89a88ed36b1419b" translate="yes" xml:space="preserve">
          <source>With Java 8:</source>
          <target state="translated">Con Java 8:</target>
        </trans-unit>
        <trans-unit id="d70aaa84bc798cb8b2c647782fe43a7cdc3b3869" translate="yes" xml:space="preserve">
          <source>With defining the according test results, you can specify the behaviour.</source>
          <target state="translated">Con la definición de los resultados de las pruebas correspondientes,se puede especificar el comportamiento.</target>
        </trans-unit>
        <trans-unit id="76bb20eab98c1196b2934f9ecb1f186851f4c3a0" translate="yes" xml:space="preserve">
          <source>You can simply do as follows:</source>
          <target state="translated">Puedes hacer simplemente lo siguiente:</target>
        </trans-unit>
        <trans-unit id="745adfbaebad4644181f103c3028a3163d9a0618" translate="yes" xml:space="preserve">
          <source>You can simply use StringTokenizer to split a string in two or more parts whether there are any type of delimiters:</source>
          <target state="translated">Simplemente puede utilizar StringTokenizer para dividir una cadena en dos o más partes si hay algún tipo de delimitadores:</target>
        </trans-unit>
        <trans-unit id="19694d4c4ce9f54704ac6515420ed6e3759bcebb" translate="yes" xml:space="preserve">
          <source>You can split a string by a hyphen/character by using the following statement:</source>
          <target state="translated">Se puede dividir una cadena por un guión usando la siguiente declaración:</target>
        </trans-unit>
        <trans-unit id="f73c5ea266b5f4a2c5c45a763ef228fc21408fdc" translate="yes" xml:space="preserve">
          <source>You can split a string by a line break by using the following statement:</source>
          <target state="translated">Puedes dividir una cadena por un salto de línea usando la siguiente declaración:</target>
        </trans-unit>
        <trans-unit id="40de6a8dc52dcc8f5824e304163fb8987a745e82" translate="yes" xml:space="preserve">
          <source>You can try like this also</source>
          <target state="translated">Puedes intentarlo así también</target>
        </trans-unit>
        <trans-unit id="54f18385d816c9a4bacc1a8fbc3b8590fbabb8e9" translate="yes" xml:space="preserve">
          <source>You can use Split():</source>
          <target state="translated">Puedes usar Split():</target>
        </trans-unit>
        <trans-unit id="aa9dfb7e3dece5be03c64f343a81607eca2aa807" translate="yes" xml:space="preserve">
          <source>You can use the method &lt;code&gt;split&lt;/code&gt;:</source>
          <target state="translated">Puedes usar el m&amp;eacute;todo &lt;code&gt;split&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9668d451d8c924278f7d7ecccc4e44a51b306de9" translate="yes" xml:space="preserve">
          <source>You should write some unit-tests for input strings and the desired results and behaviour.</source>
          <target state="translated">Debería escribir algunas pruebas de unidad para las cadenas de entrada y los resultados y el comportamiento deseados.</target>
        </trans-unit>
        <trans-unit id="df28550c3b81f1b880a49ceb27fb76bcc7fa42ee" translate="yes" xml:space="preserve">
          <source>should do thing you want. String class has many method to operate with string.</source>
          <target state="translated">debería hacer lo que tú quieres.La clase de cuerda tiene muchos métodos para operar con cuerda.</target>
        </trans-unit>
        <trans-unit id="0b96290f91b9d7829c5e672bebedfa30ff377327" translate="yes" xml:space="preserve">
          <source>we will get three strings: &lt;code&gt;[0, 0, 4]&lt;/code&gt; and not four as was the case in Java 7 and before. Also check this similar &lt;a href=&quot;https://stackoverflow.com/questions/22718744/why-in-java-8-split-sometimes-removes-empty-strings-at-start-of-result-array&quot;&gt;question&lt;/a&gt;.</source>
          <target state="translated">obtendremos tres cadenas: &lt;code&gt;[0, 0, 4]&lt;/code&gt; y no cuatro como era el caso en Java 7 y antes. Tambi&amp;eacute;n revise esta &lt;a href=&quot;https://stackoverflow.com/questions/22718744/why-in-java-8-split-sometimes-removes-empty-strings-at-start-of-result-array&quot;&gt;pregunta&lt;/a&gt; similar.</target>
        </trans-unit>
        <trans-unit id="2345d121bec649a607f505938c08c500e93234d7" translate="yes" xml:space="preserve">
          <source>which encapsulate this function. Of course you can use String.split(..) as mentioned in the other answers for the implementation.</source>
          <target state="translated">que encapsulan esta función.Por supuesto que puede usar String.split(..)como se menciona en las otras respuestas para la implementación.</target>
        </trans-unit>
        <trans-unit id="3fcd8bbf37ea44a0a387328f2a950f3728942e2c" translate="yes" xml:space="preserve">
          <source>you don't really need regular expressions for your split</source>
          <target state="translated">no necesitas expresiones regulares para tu separación</target>
        </trans-unit>
        <trans-unit id="bda5d696e27288e5ed234a4c1931bcf4af52f245" translate="yes" xml:space="preserve">
          <source>you happen to already use apache commons lang in your app</source>
          <target state="translated">Resulta que ya usas Apache Commons Lang en tu aplicación...</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
