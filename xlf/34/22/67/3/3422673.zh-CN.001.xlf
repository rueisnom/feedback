<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/3422673">
    <body>
      <group id="3422673">
        <trans-unit id="b189493d0723abaf0a25aabd29c10044c9aa3c0f" translate="yes" xml:space="preserve">
          <source>1 - Simple furmula</source>
          <target state="translated">1-简单的毛皮草</target>
        </trans-unit>
        <trans-unit id="7b17ad8051a0cd08297c27ef47792e7a5aea6b8f" translate="yes" xml:space="preserve">
          <source>1.1 Get the next token.
1.2 If the token is:</source>
          <target state="translated">1.1 获取下一个令牌。1.2 如果该令牌是:</target>
        </trans-unit>
        <trans-unit id="70e5f660d27c4d6a729ee5eca4fc60ae93185e65" translate="yes" xml:space="preserve">
          <source>1.2.1 A number: push it onto the value stack.</source>
          <target state="translated">1.2.1 一个数字:将其推到值堆栈上。</target>
        </trans-unit>
        <trans-unit id="b54a111936c58ee5af526a780e97f447695a9829" translate="yes" xml:space="preserve">
          <source>1.2.2 A variable: get its value, and push onto the value stack.</source>
          <target state="translated">1.2.2 一个变量:得到它的值,并推送到值栈中。</target>
        </trans-unit>
        <trans-unit id="91e884a1365182e677736fc56ff9444bf690c751" translate="yes" xml:space="preserve">
          <source>1.2.3 A left parenthesis: push it onto the operator stack.</source>
          <target state="translated">1.2.3左括号:将其推到操作员堆栈上。</target>
        </trans-unit>
        <trans-unit id="87f2589084a9e2986f1c812f2dd76b001c34f226" translate="yes" xml:space="preserve">
          <source>1.2.4 A right parenthesis:</source>
          <target state="translated">1.2.4右括号。</target>
        </trans-unit>
        <trans-unit id="f0735c6d8c0d48bfee9f097e3b57bbcb2f691ff1" translate="yes" xml:space="preserve">
          <source>1.2.5 An operator (call it thisOp):</source>
          <target state="translated">1.2.5 一个操作员(称其为thisOp)。</target>
        </trans-unit>
        <trans-unit id="b70cb0631c94b280e75474fa969abb9710d178f2" translate="yes" xml:space="preserve">
          <source>2 - User defined arguments and constants</source>
          <target state="translated">2-用户定义的参数和常量</target>
        </trans-unit>
        <trans-unit id="15cd0cb27cccb8c62a2245c1bf5615624c873f23" translate="yes" xml:space="preserve">
          <source>3 - User defined functions</source>
          <target state="translated">3-用户定义的功能</target>
        </trans-unit>
        <trans-unit id="ccc6e9cea830b7494c74794e255cdb8b267b2fb4" translate="yes" xml:space="preserve">
          <source>4 - Iteration</source>
          <target state="translated">4-迭代</target>
        </trans-unit>
        <trans-unit id="2fe4e674579e140c3dcf8a1fe81a54e3cf17b70a" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;http://www.beyondlinux.com/2011/08/07/3-method-to-evaluate-expressions/&quot;&gt;This article&lt;/a&gt; discusses various approaches. Here are the 2 key approaches mentioned in the article:</source>
          <target state="translated">&lt;a href=&quot;http://www.beyondlinux.com/2011/08/07/3-method-to-evaluate-expressions/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;本文&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;讨论了各种方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是本文中提到的2种关键方法：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1740655f956511dc473f3c2abef5635fa5f3f604" translate="yes" xml:space="preserve">
          <source>&lt;a href=&quot;https://github.com/uklimaschewski/EvalEx&quot;&gt;HERE&lt;/a&gt; is another open source library on GitHub named EvalEx.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/uklimaschewski/EvalEx&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是GitHub上另一个名为EvalEx的开源库。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="66851ccaa5d4bff14d124ad631290650d91d3081" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;MVEL&lt;/code&gt; does runtime evaluation of expressions, we can write a java code in &lt;code&gt;String&lt;/code&gt; to get it evaluated in this.</source>
          <target state="translated">&lt;code&gt;MVEL&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对表达式进行运行时评估，我们可以在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;String&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编写一个Java代码&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以对此进行评估。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1da97c9df67bfe9403bc690b02dd407fa01987a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Different datatypes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不同的数据类型：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ea5c2c6b95749aa4e52965a30787c2b280bbfcac" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Separate compilation and evaluation:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;单独的编译和评估：&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4c51f75623c112c9098f9b294cb11df633411dc1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variables:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Variables:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a470a1c3c36ac43c6f08cff8179aac1bd3f98305" translate="yes" xml:space="preserve">
          <source>&lt;sub&gt;All code in this answer released &lt;a href=&quot;https://creativecommons.org/publicdomain/zero/1.0/&quot;&gt;to the public domain&lt;/a&gt;. Have fun!&lt;/sub&gt;</source>
          <target state="translated">&lt;sub&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;此答案中的所有代码均已发布&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://creativecommons.org/publicdomain/zero/1.0/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;到公共领域&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;玩得开心！&lt;/font&gt;&lt;/font&gt;&lt;/sub&gt;</target>
        </trans-unit>
        <trans-unit id="4071041dfbfbcfced9aef256cf6b920e7da9354f" translate="yes" xml:space="preserve">
          <source>A Java class that can evaluate mathematical expressions:</source>
          <target state="translated">一个可以评价数学表达式的Java类。</target>
        </trans-unit>
        <trans-unit id="11958cfc83000edc5cd619a8e7a09c04db89d839" translate="yes" xml:space="preserve">
          <source>Allows for scripts that include references to java objects.</source>
          <target state="translated">允许包含对java对象的引用的脚本。</target>
        </trans-unit>
        <trans-unit id="a821e43c3b969654c45585b8dd96b345c961af5d" translate="yes" xml:space="preserve">
          <source>And few examples</source>
          <target state="translated">而且例子很少</target>
        </trans-unit>
        <trans-unit id="b645420a182b55b4dad7f4c15d3ff4460c22c049" translate="yes" xml:space="preserve">
          <source>Another way is to use Spring Expression Language or SpEL which does a whole lot more along with evaluating mathematical expressions therefore maybe slightly overkill. You do not have to be using Spring framework to use this expression library as it is stand-alone. Copying examples from SpEL's documentation:</source>
          <target state="translated">另一种方法是使用Spring表达式语言或SpEL,它的功能更多,包括对数学表达式进行评估,因此可能略显矫枉过正。你不需要使用Spring框架来使用这个表达式库,因为它是独立的。复制SpEL的文档中的例子。</target>
        </trans-unit>
        <trans-unit id="f183c3165e8afe8b17298049840cd2837f05e235" translate="yes" xml:space="preserve">
          <source>At this point the operator stack should be empty, and the value
stack should have only one value in it, which is the final result.</source>
          <target state="translated">这时,操作员堆栈应该是空的,值堆栈中应该只有一个值,这就是最终的结果。</target>
        </trans-unit>
        <trans-unit id="fcd813eb5299875e79422935a8b3ca8932f15b90" translate="yes" xml:space="preserve">
          <source>Best regards</source>
          <target state="translated">祝贺你</target>
        </trans-unit>
        <trans-unit id="8cbf674db3a09bc0d1ffedc4e64c64fe1229a2bd" translate="yes" xml:space="preserve">
          <source>Building and processing a parse tree (&lt;a href=&quot;https://github.com/stefanhaustein/expressionparser/blob/master/src/main/java/org/kobjects/expressionparser/demo/cas/TreeBuilder.java&quot;&gt;TreeBuilder.java&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;构建和处理解析树（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/stefanhaustein/expressionparser/blob/master/src/main/java/org/kobjects/expressionparser/demo/cas/TreeBuilder.java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TreeBuilder.java&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3be0db3faa728a3164e2835916a109d2d95df639" translate="yes" xml:space="preserve">
          <source>Creating a recursive descent parser is a really good learning exercise.</source>
          <target state="translated">创建一个递归式血统解析器真的是一个很好的学习方法。</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="6baee3a552afa63e9da9d9fb45a6ad9ce55441a4" translate="yes" xml:space="preserve">
          <source>External library like RHINO or NASHORN can be used to run javascript. And javascript can evaluate simple formula without parcing the string. No performance impact as well if code is written well.
Below is an example with RHINO -</source>
          <target state="translated">外部库如RHINO或NASHORN可以用来运行javascript。而且javascript可以评估简单的公式,不需要解析字符串。如果代码写得好,也不会影响性能。下面是一个使用RHINO的例子</target>
        </trans-unit>
        <trans-unit id="b84959709066603663209b9212c3cbec6471419b" translate="yes" xml:space="preserve">
          <source>For example, in Sql Server or Sqlite</source>
          <target state="translated">例如,在Sql Server或Sqlite中</target>
        </trans-unit>
        <trans-unit id="7e2033bb95b31887135d46a7cf31bbffe1de185f" translate="yes" xml:space="preserve">
          <source>For my university project, I was looking for a parser / evaluator supporting both basic formulas and more complicated equations (especially iterated operators). I found very nice open source library for JAVA and .NET called mXparser. I will give a few examples to make some feeling on the syntax, for further instructions please visit project website (especially tutorial section).</source>
          <target state="translated">在我的大学项目中,我一直在寻找一个既支持基本公式又支持较复杂的方程(尤其是迭代运算符)的解析器评估器。我发现了一个非常好的JAVA和.NET的开源库,叫做mXparser。我将举几个例子来让大家对语法有一些感觉,更多的说明请访问项目网站(特别是教程部分)。</target>
        </trans-unit>
        <trans-unit id="b9b18f2943c9be49acd7bc2c77a19af47150bfaf" translate="yes" xml:space="preserve">
          <source>Found recently - in case you would like to try the syntax (and see the advanced use case) you can download the &lt;a href=&quot;https://scalarmath.org&quot;&gt;Scalar&lt;/a&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=org.mathparser.scalar.lite&quot;&gt;Calculator&lt;/a&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=org.mathparser.scalar.pro&quot;&gt;app&lt;/a&gt; that is powered by mXparser.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;最近找到的-如果您想尝试语法（并查看高级用例），则可以下载&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;由mXparser支持&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://scalarmath.org&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Scalar &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=org.mathparser.scalar.lite&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Calculator &lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;a href=&quot;https://play.google.com/store/apps/details?id=org.mathparser.scalar.pro&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应用程序&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="3411c974c0ef8392a0d6137440c8d5198424994d" translate="yes" xml:space="preserve">
          <source>Here's a full working example in Java</source>
          <target state="translated">下面是一个完整的Java工作示例</target>
        </trans-unit>
        <trans-unit id="6629b3a9b3a5e61946b4fe5db6db2d6f8b453cc7" translate="yes" xml:space="preserve">
          <source>How about something like this:</source>
          <target state="translated">这样的东西如何?</target>
        </trans-unit>
        <trans-unit id="6e2b7fc4783d971b7c62940ac33eb2e99955667f" translate="yes" xml:space="preserve">
          <source>How to evaluate a math expression given in string form</source>
          <target state="translated">如何评价一个以字符串形式给出的数学表达式?</target>
        </trans-unit>
        <trans-unit id="325fea76c774fe7b6356a69cb6244d8a3cbe14a7" translate="yes" xml:space="preserve">
          <source>However performance may suffer if many single expressions need to be evaluated individually, particularly when the DB is located on a network server.</source>
          <target state="translated">然而,如果需要对许多单个表达式进行单独评估,特别是当DB位于网络服务器上时,性能可能会受到影响。</target>
        </trans-unit>
        <trans-unit id="17e55fbea734c139b96c04e349f659a632f6759a" translate="yes" xml:space="preserve">
          <source>I have implemented this to have a simple but flexible option to permit both:</source>
          <target state="translated">我已经实现了这一点,以便有一个简单而灵活的选择,允许两者都有。</target>
        </trans-unit>
        <trans-unit id="623b29168ddac051ff09736a9aa511a71211e965" translate="yes" xml:space="preserve">
          <source>I think what ever way you do this it's going to involve a lot of conditional statements. But for single operations like in your examples you could limit it to 4 if statements with something like</source>
          <target state="translated">我认为无论你用什么方法来做,都会涉及到很多条件语句。但对于像你的例子中的单个操作,你可以把它限制在4个if语句中,例如</target>
        </trans-unit>
        <trans-unit id="bf168a32289f3a69ce3fd562b11028652acb4b8a" translate="yes" xml:space="preserve">
          <source>I want to avoid a lot of if-then-else statements.
How can I do this?</source>
          <target state="translated">我想避免大量的if-then-else语句。如何才能做到这一点呢?</target>
        </trans-unit>
        <trans-unit id="f52ac2cae128448688ae1e1b88616db5220a6562" translate="yes" xml:space="preserve">
          <source>I wrote an article about it &lt;a href=&quot;http://emmanueljohn.me/2015/07/05/shunting-yard-algorithm/&quot;&gt;here, with an implementation in java&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我&lt;/font&gt;&lt;a href=&quot;http://emmanueljohn.me/2015/07/05/shunting-yard-algorithm/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;写了一篇有关&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java的实现&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的文章&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="db6312e4fe13c314171c46d43eed64f5e65efc3a" translate="yes" xml:space="preserve">
          <source>I'm trying to write a Java routine to evaluate simple math expressions from &lt;code&gt;String&lt;/code&gt; values like:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我正在尝试编写Java例程，以从&lt;/font&gt;&lt;/font&gt; &lt;code&gt;String&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;值&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;评估简单的数学表达式，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="36f9c78b343cf9643dbbbdbc6f7278000062a536" translate="yes" xml:space="preserve">
          <source>I've written this &lt;code&gt;eval&lt;/code&gt; method for arithmetic expressions to answer this question. It does addition, subtraction, multiplication, division, exponentiation (using the &lt;code&gt;^&lt;/code&gt; symbol), and a few basic functions like &lt;code&gt;sqrt&lt;/code&gt;. It supports grouping using &lt;code&gt;(&lt;/code&gt;...&lt;code&gt;)&lt;/code&gt;, and it gets the operator &lt;a href=&quot;https://en.wikipedia.org/wiki/Order_of_operations&quot;&gt;precedence&lt;/a&gt; and &lt;a href=&quot;https://en.wikipedia.org/wiki/Operator_associativity&quot;&gt;associativity&lt;/a&gt; rules correct.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我已经&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为算术表达式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;编写了这个&lt;/font&gt;&lt;/font&gt; &lt;code&gt;eval&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法来回答这个问题。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它执行加，减，乘，除，求幂（使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;^&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;符号）以及一些基本功能（如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;sqrt&lt;/code&gt; )&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它支持使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;(&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; ... &lt;/font&gt;&lt;/font&gt; &lt;code&gt;)&lt;/code&gt; 进行&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;分组&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，并且可以&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;正确&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;确定运算符的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Order_of_operations&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;优先级&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Operator_associativity&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;关联性&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;规则。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d485794358ab6c11b2019cb8c6037fc4d6d8ef14" translate="yes" xml:space="preserve">
          <source>If you are trying to build a calculator then I'd surgest passing each section of the calculation separatly (each number or operator) rather than as a single string.</source>
          <target state="translated">如果你想建立一个计算器,那么我想把每一节的计算结果分开(每一个数字或运算器),而不是作为一个单独的字符串。</target>
        </trans-unit>
        <trans-unit id="74afb4bc9ddb21ecdc9d9e1cc4f78237ba415ef5" translate="yes" xml:space="preserve">
          <source>Immediate processing (&lt;a href=&quot;https://github.com/stefanhaustein/expressionparser/blob/master/src/main/java/org/kobjects/expressionparser/demo/calculator/Calculator.java&quot;&gt;Calculator.java&lt;/a&gt;, &lt;a href=&quot;https://github.com/stefanhaustein/expressionparser/blob/master/src/main/java/org/kobjects/expressionparser/demo/sets/SetDemo.java&quot;&gt;SetDemo.java&lt;/a&gt;)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;立即处理（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/stefanhaustein/expressionparser/blob/master/src/main/java/org/kobjects/expressionparser/demo/calculator/Calculator.java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Calculator.java&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/stefanhaustein/expressionparser/blob/master/src/main/java/org/kobjects/expressionparser/demo/sets/SetDemo.java&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;SetDemo.java&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="cd682725709d7c18e33d743d1899543f49415c27" translate="yes" xml:space="preserve">
          <source>Instead of &lt;code&gt;double&lt;/code&gt;, you could change the evaluator to use something more powerful like &lt;code&gt;BigDecimal&lt;/code&gt;, or a class that implements complex numbers, or rational numbers (fractions). You could even use &lt;code&gt;Object&lt;/code&gt;, allowing some mix of datatypes in expressions, just like a real programming language. :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;代替&lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您可以更改评估器以使用更强大的功能，例如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;BigDecimal&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;或实现复数或有理数（分数）的类。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您甚至可以使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Object&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，从而允许在表达式中混合一些数据类型，就像真正的编程语言一样。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7bcee2c0e8b42c9ac78ae27373922ae28e2af7e5" translate="yes" xml:space="preserve">
          <source>It gets a whole lot more complicated when you want to deal with multiple operations like &quot;4+5*6&quot;.</source>
          <target state="translated">当你想处理像 &quot;4+5*6 &quot;这样的多重操作时,就会变得复杂得多。</target>
        </trans-unit>
        <trans-unit id="90886e457b8b4f6e08199c1f3dda7af9a02cc8a0" translate="yes" xml:space="preserve">
          <source>It is possible to convert any expression string in infix notation to a postfix notation using &lt;a href=&quot;https://en.wikipedia.org/wiki/Shunting-yard_algorithm&quot;&gt;Djikstra's shunting-yard algorithm&lt;/a&gt;. The result of the algorithm can then serve as input to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;postfix algorithm&lt;/a&gt; with returns the result of the expression.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Shunting-yard_algorithm&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Djikstra的shunting-yard算法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;将中缀表示法的任何表达式字符串转换为后缀表示法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，该算法的结果可以用作&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Reverse_Polish_notation&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;后缀算法的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;输入，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;并返回表达式的结果。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5d99e7906eac1cb64e40d3c92b04a679282ed195" translate="yes" xml:space="preserve">
          <source>It seems like &lt;a href=&quot;http://sourceforge.net/projects/jep/&quot;&gt;JEP&lt;/a&gt; should do the job</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;看来&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://sourceforge.net/projects/jep/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JEP&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该胜任&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8b9b5fbb929d159cfd765eb6d2237e0dae020a7" translate="yes" xml:space="preserve">
          <source>It's too late to answer but I came across same situation to evaluate expression in java, it might help someone</source>
          <target state="translated">现在回答太晚了,但我遇到了同样的情况,在java中评估表达式,可能会有帮助。</target>
        </trans-unit>
        <trans-unit id="85b20cbf34900b61174cbfef5cba7a1f6821812a" translate="yes" xml:space="preserve">
          <source>JEXL from Apache</source>
          <target state="translated">来自Apache的JEXL</target>
        </trans-unit>
        <trans-unit id="2bba50be43e087d392fb4d92db31e568505a3a97" translate="yes" xml:space="preserve">
          <source>Now change all the methods that return &lt;code&gt;double&lt;/code&gt;s, so instead they return an instance of that interface. Java 8's lambda syntax works great for this. Example of one of the changed methods:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在更改所有返回&lt;/font&gt;&lt;/font&gt; &lt;code&gt;double&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此它们返回该接口的实例。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java 8的lambda语法对此非常有用。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更改的方法之一的示例：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="aa1aa70de67e04698badc45f571a75ae01d6e631" translate="yes" xml:space="preserve">
          <source>Of course you could extend the above code to handle multiple calculations at the same time.</source>
          <target state="translated">当然,你可以把上面的代码扩展到同时处理多个计算的情况。</target>
        </trans-unit>
        <trans-unit id="fc961aeb1f377ae5820c9c4cbefba9bd2eda1d82" translate="yes" xml:space="preserve">
          <source>Output: 7.5 &lt;a href=&quot;https://www.wolframalpha.com/input/?i=%28%284%20-%202%5E3%20%2B%201%29%20*%20-sqrt%283*3%2B4*4%29%29%20%2F%202&quot;&gt;(which is correct)&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;输出：7.5 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://www.wolframalpha.com/input/?i=%28%284%20-%202%5E3%20%2B%201%29%20*%20-sqrt%283*3%2B4*4%29%29%20%2F%202&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（正确）&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="cec43fae0cef8de67977d1383f4b49f91a935853" translate="yes" xml:space="preserve">
          <source>Read more concise SpEL examples &lt;a href=&quot;http://syntx.co/languages-frameworks/evaluating-expressions-using-spring-expression-language-spel/&quot;&gt;here&lt;/a&gt; and the complete docs &lt;a href=&quot;http://docs.spring.io/spring/docs/3.0.x/reference/expressions.html&quot;&gt;here&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;阅读更简洁的规划环境地政司的例子&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://syntx.co/languages-frameworks/evaluating-expressions-using-spring-expression-language-spel/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和完整的文档&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.spring.io/spring/docs/3.0.x/reference/expressions.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这里&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ba8d40f12cf4b5e5c2a99a97e877c80d6edae1ff" translate="yes" xml:space="preserve">
          <source>Some databases require you to use a dummy table (eg, Oracle's &quot;dual&quot; table) and others will allow you to evaluate expressions without &quot;selecting&quot; from any table.</source>
          <target state="translated">有些数据库要求你使用一个假表(例如,Oracle的 &quot;双表 &quot;表),而另一些数据库将允许你在不从任何表中 &quot;选择 &quot;的情况下评估表达式。</target>
        </trans-unit>
        <trans-unit id="b8092c56a98d9121844bfd753f149b6a39b3dfd8" translate="yes" xml:space="preserve">
          <source>Take note that definitively more complex expressions can be evaluated:</source>
          <target state="translated">要注意的是,可以对确定性较复杂的表达式进行评价。</target>
        </trans-unit>
        <trans-unit id="989811a1a1bfdb2953c7ad4dbb4583f10aa1b6b0" translate="yes" xml:space="preserve">
          <source>That builds a recursive tree of &lt;code&gt;Expression&lt;/code&gt; objects representing the compiled expression (an &lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;abstract syntax tree&lt;/a&gt;). Then you can compile it once and evaluate it repeatedly with different values:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这将构建一个&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;表示已编译表达式&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Expression&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对象&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的递归树&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Abstract_syntax_tree&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;抽象语法树&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;然后，您可以编译一次，然后使用不同的值反复评估它：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="81b296efc64d139159d578efadf8e2d5e87c5c78" translate="yes" xml:space="preserve">
          <source>The TreeBuilder linked above is part of a &lt;a href=&quot;https://github.com/stefanhaustein/expressionparser/tree/master/src/main/java/org/kobjects/expressionparser/demo/cas&quot;&gt;CAS demo package&lt;/a&gt; that does symbolic derivation. There is also a &lt;a href=&quot;https://github.com/stefanhaustein/expressionparser/tree/master/src/main/java/org/kobjects/expressionparser/demo/basic&quot;&gt;BASIC interpreter&lt;/a&gt; example and I have started to build a &lt;a href=&quot;https://github.com/stefanhaustein/typo&quot;&gt;TypeScript interpreter&lt;/a&gt; using it.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上面链接的TreeBuilder是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;执行符号推导&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/stefanhaustein/expressionparser/tree/master/src/main/java/org/kobjects/expressionparser/demo/cas&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;CAS演示包的&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一部分&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还有一个&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/stefanhaustein/expressionparser/tree/master/src/main/java/org/kobjects/expressionparser/demo/basic&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BASIC解释器&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;示例，我已经开始&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用它&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来构建&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/stefanhaustein/typo&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;TypeScript解释&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;器。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e0c5950787f087b30e58f48e90341a41a60db767" translate="yes" xml:space="preserve">
          <source>The advantage of using a DB is that you can evaluate many expressions at the same time. Also most DB's will allow you to use highly complex expressions and   will also have a number of extra functions that can be called as necessary.</source>
          <target state="translated">使用DB的好处是,你可以同时评估许多表达式。同时,大多数的DB都允许你使用高度复杂的表达式,并且有很多额外的函数可以根据需要调用。</target>
        </trans-unit>
        <trans-unit id="121608a35ff952255ffc4d2dcb8fe6c1156c1acc" translate="yes" xml:space="preserve">
          <source>The bit of the parser that reads the names for functions can easily be changed to handle custom variables too, by looking up names in a variable table passed to the &lt;code&gt;eval&lt;/code&gt; method, such as a &lt;code&gt;Map&amp;lt;String,Double&amp;gt; variables&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过在传递给&lt;/font&gt;&lt;/font&gt; &lt;code&gt;eval&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的变量表中查找名称&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，例如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Map&amp;lt;String,Double&amp;gt; variables&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以轻松地更改读取函数名称的解析器的位，以处理自定义&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fc76437fb404aa0973705a9b71bea5feffe95245" translate="yes" xml:space="preserve">
          <source>The correct way to solve this is with a &lt;a href=&quot;http://en.wikipedia.org/wiki/Lexical_analysis&quot;&gt;lexer&lt;/a&gt; and a &lt;a href=&quot;http://en.wikipedia.org/wiki/Parser&quot;&gt;parser&lt;/a&gt;. You can write simple versions of these yourself, or those pages also have links to Java lexers and parsers.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解决这个问题的正确方法是使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Lexical_analysis&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;词法分析器&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Parser&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解析器&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以自己编写这些的简单版本，或者这些页面还具有指向Java词法分析器和解析器的链接。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="4ef27834b8576cee4eb4589abe26cae562e3ae1b" translate="yes" xml:space="preserve">
          <source>The following addresses the performance problem to some extent, by using a Sqlite in-memory database.</source>
          <target state="translated">下面通过使用内存中的Sqlite数据库,在一定程度上解决了性能问题。</target>
        </trans-unit>
        <trans-unit id="7f0556635ea4b80d289b2326474aac31712e9e37" translate="yes" xml:space="preserve">
          <source>The parser is a &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursive_descent_parser&quot;&gt;recursive descent parser&lt;/a&gt;, so internally uses separate parse methods for each level of operator precedence in its grammar. I kept it &lt;strong&gt;short&lt;/strong&gt; so it's easy to modify, but here are some ideas you might want to expand it with:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;该解析器是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Recursive_descent_parser&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;递归下降解析器&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此在内部对其语法的每个级别的运算符优先级使用单独的解析方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我把它&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;简短了&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;一下&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所以很容易修改，但是下面是一些您可能想要扩展它的想法：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0e8a1bfb3a7ce7335feba6207a0a26567db135b4" translate="yes" xml:space="preserve">
          <source>The usage is very simple and gets the job done, for example:</source>
          <target state="translated">使用方法很简单,也能很好的完成任务,比如说。</target>
        </trans-unit>
        <trans-unit id="dedcd3977682849e3e0915c68cc93b738e9bdbe0" translate="yes" xml:space="preserve">
          <source>This is actually complementing the answer given by @Boann. It has a slight bug which causes &quot;-2 ^ 2&quot; to give an erroneous result of -4.0. The problem for that is the point at which the exponentiation is evaluated in his. Just move the exponentiation to the block of parseTerm(), and you'll be all fine. Have a look at the below, which is &lt;a href=&quot;https://stackoverflow.com/a/26227947/3126973&quot;&gt;@Boann's answer&lt;/a&gt; slightly modified. Modification is in the comments.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这实际上是对@Boann给出的答案的补充。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它有一个小错误，导致&amp;ldquo; -2 ^ 2&amp;rdquo;给出-4.0的错误结果。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样做的问题是在他的点求幂。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;只需将幂运算移动到parseTerm（）的块，就可以了。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;看看下面，这是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/a/26227947/3126973&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@Boann的答案&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;略有修改。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;注释中有修改。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="90e2a9471c2f709fc05848b873caa40e15fd1cbf" translate="yes" xml:space="preserve">
          <source>This is another interesting alternative 
&lt;a href=&quot;https://github.com/Shy-Ta/expression-evaluator-demo&quot;&gt;https://github.com/Shy-Ta/expression-evaluator-demo&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这是另一个有趣的替代方法 &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/Shy-Ta/expression-evaluator-demo&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https://github.com/Shy-Ta/expression-evaluator-demo&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="be5e94b4b48e4e011e9884468cd0c470cb061bde" translate="yes" xml:space="preserve">
          <source>Try the following sample code using JDK1.6's Javascript engine with code injection handling.</source>
          <target state="translated">尝试使用JDK1.6的Javascript引擎的代码注入处理示例代码。</target>
        </trans-unit>
        <trans-unit id="30915fa19fcda28878f14373f519a56dad5882c8" translate="yes" xml:space="preserve">
          <source>Unlike the JavaScript engine this library is focused in evaluating mathematical expressions only. Moreover, the library is extensible and supports use of boolean operators as well as parentheses.</source>
          <target state="translated">与JavaScript引擎不同,这个库只专注于评估数学表达式。此外,该库具有可扩展性,支持使用布尔运算符和括号。</target>
        </trans-unit>
        <trans-unit id="9cbfc13d7a82087f1e8cf577c42c09a7d0a82c8d" translate="yes" xml:space="preserve">
          <source>Use the javascript engine embedded in the JDK:</source>
          <target state="translated">使用JDK中嵌入的javascript引擎。</target>
        </trans-unit>
        <trans-unit id="6204cb7e170c3d221fd87e282b3a2b3873c65a6d" translate="yes" xml:space="preserve">
          <source>What if, having added support for variables, you wanted to evaluate the same expression millions of times with changed variables, without parsing it every time? It's possible. First define an interface to use to evaluate the precompiled expression:</source>
          <target state="translated">如果增加了对变量的支持后,你想用改变的变量来评价同一个表达式数百万次,而不需要每次都进行解析,那该怎么办?这是有可能的。首先定义一个接口,用于评估预编译的表达式。</target>
        </trans-unit>
        <trans-unit id="0166cedcc76e8442c40c96689443988315cbcb64" translate="yes" xml:space="preserve">
          <source>While the operator stack is not empty,
1 Pop the operator from the operator stack.
2 Pop the value stack twice, getting two operands.
3 Apply the operator to the operands, in the correct order.
4 Push the result onto the value stack.</source>
          <target state="translated">当操作符堆栈不是空的时候,1从操作符栈中弹出操作符。2 在值堆栈中弹出两次,得到两个操作符。3 按照正确的顺序将运算符应用到操作符上。4 将结果推到值堆栈上。</target>
        </trans-unit>
        <trans-unit id="d6e647ec522cf4392535ce381b93391ea8a426ab" translate="yes" xml:space="preserve">
          <source>While there are still tokens to be read in,</source>
          <target state="translated">虽然仍有令牌可以读进去。</target>
        </trans-unit>
        <trans-unit id="454b9e3af42a6c3673119746e53dc7307f0dc64c" translate="yes" xml:space="preserve">
          <source>With JDK1.6, you can use the built-in Javascript engine.</source>
          <target state="translated">使用JDK1.6,您可以使用内置的Javascript引擎。</target>
        </trans-unit>
        <trans-unit id="897d74cc15da0bb04ccacc416d65bcf6e84639c8" translate="yes" xml:space="preserve">
          <source>Yet another option: &lt;a href=&quot;https://github.com/stefanhaustein/expressionparser&quot;&gt;https://github.com/stefanhaustein/expressionparser&lt;/a&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另一个选择：&lt;/font&gt;&lt;a href=&quot;https://github.com/stefanhaustein/expressionparser&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;https&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;//github.com/stefanhaustein/expressionparser&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="65fc69e2020c789efb9a0acd35431dce809e40bb" translate="yes" xml:space="preserve">
          <source>You can also try the &lt;a href=&quot;http://www.beanshell.org&quot;&gt;BeanShell&lt;/a&gt; interpreter:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您也可以尝试&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.beanshell.org&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BeanShell&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解释器：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0b623f10fdcde6b68c56c2713f37bfe43b6c78c5" translate="yes" xml:space="preserve">
          <source>You can evaluate expressions easily if your Java application already accesses a database, without using any other JARs.</source>
          <target state="translated">如果你的Java应用程序已经访问了数据库,你可以轻松地评估表达式,而不需要使用任何其他的JAR。</target>
        </trans-unit>
        <trans-unit id="4b9d403cc607c5b71149db139f6b3d9c030f467f" translate="yes" xml:space="preserve">
          <source>You might have a look at the &lt;a href=&quot;https://bitbucket.org/axelclk/symja_android_library/wiki/Home&quot;&gt;Symja framework&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以看一下&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://bitbucket.org/axelclk/symja_android_library/wiki/Home&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Symja框架&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="69a3ac5cc2fdd16ba0d883dd36cdb3d9021373b3" translate="yes" xml:space="preserve">
          <source>and do the similar thing for every other mathematical operator accordingly ..</source>
          <target state="translated">并相应地对其他每一个数学运算符做类似的操作。</target>
        </trans-unit>
        <trans-unit id="0c54051c8ea84dc3cc644818d81f2b68f0685c3b" translate="yes" xml:space="preserve">
          <source>and in Oracle</source>
          <target state="translated">而在甲骨文中</target>
        </trans-unit>
        <trans-unit id="4fa697554e8a14e6d8fba6e8342c9232a0c25df0" translate="yes" xml:space="preserve">
          <source>if we are going to implement it then we can can use the below algorithm :--</source>
          <target state="translated">如果我们要实现它,那么我们可以使用下面的算法:----</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
