<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ru" datatype="htmlbody" original="https://stackoverflow.com/questions/34361379">
    <body>
      <group id="34361379">
        <trans-unit id="8a9305ffc2f2a21bc0e0cce734e74c2de0d90d5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let sum = (...args) =&amp;gt; args.reduce((x, y) =&amp;gt; x + y, 0)&lt;/code&gt;&lt;code&gt;sum(3, 3, 1) // output - 7&lt;/code&gt;
`</source>
          <target state="translated">&lt;code&gt;let sum = (...args) =&amp;gt; args.reduce((x, y) =&amp;gt; x + y, 0)&lt;/code&gt; &lt;code&gt;sum(3, 3, 1) // output - 7&lt;/code&gt; `</target>
        </trans-unit>
        <trans-unit id="d6b386be0e438dc899807a07cd58b7e487d922b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Not&lt;/em&gt; replaceable:</source>
          <target state="translated">&lt;em&gt;Не&lt;/em&gt; подлежит замене:</target>
        </trans-unit>
        <trans-unit id="488cc993c203373e105eb766d391b5e5b46cb0cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Lexical &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. Лексические &lt;code&gt;arguments&lt;/code&gt; и аргументы&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a7508586904c8705b34630d6f6d3c29302585ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Arrow functions cannot be called with &lt;code&gt;new&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. Функции стрелок нельзя вызывать с &lt;code&gt;new&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fea952fbdd01d7377771649c404b2d2eebe799d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But:&lt;/strong&gt; If the code which calls the callback explicitly sets &lt;code&gt;this&lt;/code&gt; to a specific value, as is often the case with event handlers, especially with jQuery, and the callback uses &lt;code&gt;this&lt;/code&gt; (or &lt;code&gt;arguments&lt;/code&gt;), you &lt;em&gt;cannot&lt;/em&gt; use an arrow function!</source>
          <target state="translated">&lt;strong&gt;Но:&lt;/strong&gt; если код, который вызывает обратный вызов, явно устанавливает &lt;code&gt;this&lt;/code&gt; конкретное значение, как это часто бывает в обработчиках событий, особенно в jQuery, и обратный вызов использует &lt;code&gt;this&lt;/code&gt; (или &lt;code&gt;arguments&lt;/code&gt; ), вы &lt;em&gt;не можете&lt;/em&gt; использовать функцию стрелки!</target>
        </trans-unit>
        <trans-unit id="7fdddf9c3bee50f48d61f290501ea4e7b84eca27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Callbacks&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Callbacks&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="157ce55d6ebcf86d356f903b9bf6c964f06e9444" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Функция конструктора&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="277d555f97f038c6632806bf7eef2dec6351e047" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that this also means that is &lt;em&gt;not&lt;/em&gt; possible to set an arrow function's &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;.bind&lt;/code&gt; or &lt;code&gt;.call&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Обратите внимание,&lt;/strong&gt; что это также означает, что невозможно установить функцию стрелки &lt;code&gt;this&lt;/code&gt; с помощью &lt;code&gt;.bind&lt;/code&gt; или &lt;code&gt;.call&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eddb8d389875d6c583f94dafb1d487acd6f23364" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Методы объекта&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7240b41b9e7e3d421b31b87e5dced476c42e69db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prototype methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Методы прототипа&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f93c5b443b5e0470526ac1a2270f433b36a7ba41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They cannot be used with&lt;/strong&gt;&lt;strong&gt;&lt;code&gt;new&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Они не могут быть использованы с&lt;/strong&gt; &lt;strong&gt; &lt;code&gt;new&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="44d0ea0505e9226c704f669fb8bc795ba50b4d5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They do not have &lt;code&gt;this&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;У них &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53b051204da25b8b824721699dd9120b211f117a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They do not have arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;У них нет аргументов&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b2ea255e5af4354b8c68a41f7d152fc208cdcdf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variadic functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Вариадические функции&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c563dcc474c861f5d23de9ea9d74cffa69cd0598" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr:&lt;/strong&gt;&lt;strong&gt;No!&lt;/strong&gt; Arrow functions and function declarations / expressions are not equivalent and cannot be replaced blindly.</source>
          <target state="translated">&lt;strong&gt;ДЛ:&lt;/strong&gt; &lt;strong&gt;Нет!&lt;/strong&gt; Функции стрелок и объявления / выражения функций не эквивалентны и не могут быть заменены вслепую.</target>
        </trans-unit>
        <trans-unit id="9e4f3b712458b764fee0ab7a77547075362a776d" translate="yes" xml:space="preserve">
          <source>Are 'Arrow Functions' and 'Functions' equivalent / exchangeable</source>
          <target state="translated">Эквивалентны ли &quot;Функции со стрелками&quot; и &quot;Функции&quot;.</target>
        </trans-unit>
        <trans-unit id="097cd6bcfb4e1fe38807711e39cf37e85c2bc5a1" translate="yes" xml:space="preserve">
          <source>Arrow functions (and methods) are only callable.
&lt;code&gt;class&lt;/code&gt; constructors are only constructable.</source>
          <target state="translated">Функции стрелок (и методы) доступны только для вызова. конструкторы &lt;code&gt;class&lt;/code&gt; являются только конструируемыми.</target>
        </trans-unit>
        <trans-unit id="81098c36bba344fc060ab84fa79bbfcf54aa2c3a" translate="yes" xml:space="preserve">
          <source>Arrow functions =&amp;gt; best ES6 feature so far. They are a tremendously
  powerful addition to ES6, that I use constantly.</source>
          <target state="translated">Стрелка функции =&amp;gt; лучшая функция ES6 до сих пор. Они являются чрезвычайно мощным дополнением к ES6, которое я постоянно использую.</target>
        </trans-unit>
        <trans-unit id="2ed8af4386bde5001c11d3a6063d953a276e2650" translate="yes" xml:space="preserve">
          <source>Arrow functions can't be construtors because they do not have a prototype property.</source>
          <target state="translated">Функции стрелок не могут быть конструкциями,потому что у них нет свойства прототипа.</target>
        </trans-unit>
        <trans-unit id="db9f796ceaa44d107dd215efb7264dff6cf8dc8c" translate="yes" xml:space="preserve">
          <source>Arrow functions don&amp;rsquo;t have an arguments object. But the same
functionality can be achieved using rest parameters.</source>
          <target state="translated">Функции стрелок не имеют объекта аргументов. Но та же функциональность может быть достигнута с помощью параметров отдыха.</target>
        </trans-unit>
        <trans-unit id="6ac7165f3dd26e2cdc228d4ea4202fc02f30e9e4" translate="yes" xml:space="preserve">
          <source>Arrow functions don't have their own &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;arguments&lt;/code&gt; binding. Instead, those identifiers are resolved in the lexical scope like any other variable. That means that inside an arrow function, &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; refer to the values of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; in the environment the arrow function is &lt;em&gt;defined&lt;/em&gt; in (i.e. &quot;outside&quot; the arrow function):</source>
          <target state="translated">Функции со стрелками не имеют своих привязок &lt;code&gt;this&lt;/code&gt; или &lt;code&gt;arguments&lt;/code&gt; . Вместо этого эти идентификаторы разрешаются в лексической области, как и любая другая переменная. Это означает, что внутри функции стрелки &lt;code&gt;arguments&lt;/code&gt; &lt;code&gt;this&lt;/code&gt; и arguments ссылаются на значения &lt;code&gt;this&lt;/code&gt; и &lt;code&gt;arguments&lt;/code&gt; в среде, в которой &lt;em&gt;определена&lt;/em&gt; функция стрелки (то есть &amp;laquo;вне&amp;raquo; функции стрелки):</target>
        </trans-unit>
        <trans-unit id="4c46e5830c1a4417ff77a66df443155bef9ddaba" translate="yes" xml:space="preserve">
          <source>Arrow functions in ES2015 provide a more concise syntax.</source>
          <target state="translated">Функции стрелок в ES2015 обеспечивают более лаконичный синтаксис.</target>
        </trans-unit>
        <trans-unit id="a349ca267127b5faf849c2f06a6f3ed14ab1572c" translate="yes" xml:space="preserve">
          <source>Arrow functions should NOT be used because:</source>
          <target state="translated">Функции стрелок НЕ должны использоваться,потому что:</target>
        </trans-unit>
        <trans-unit id="9b2bda921bc6b091d8d99377e4291396fbf26932" translate="yes" xml:space="preserve">
          <source>As so often: &lt;strong&gt;it depends&lt;/strong&gt;. Arrow functions have different behavior than function declarations / expressions, so let's have a look at the differences first:</source>
          <target state="translated">Как часто: &lt;strong&gt;это зависит&lt;/strong&gt; . Функции со стрелками ведут себя иначе, чем объявления / выражения функций, поэтому давайте сначала рассмотрим различия:</target>
        </trans-unit>
        <trans-unit id="807bece96fbabe4fd1884464fe2b6613508ddb00" translate="yes" xml:space="preserve">
          <source>But you can&amp;rsquo;t use an arrow function when a dynamic context is required: defining methods, create objects with constructors, get the target from this when handling events.</source>
          <target state="translated">Но вы не можете использовать функцию стрелки, когда требуется динамический контекст: определение методов, создание объектов с помощью конструкторов, получение цели из этого при обработке событий.</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="6f09b72943c02d70071365c301fbca77ddd1b8e1" translate="yes" xml:space="preserve">
          <source>Can I replace all my function declarations / expressions with arrow functions now?</source>
          <target state="translated">Могу ли я теперь заменить все выражения деклараций функций на функции со стрелками?</target>
        </trans-unit>
        <trans-unit id="b5c9417824a65aca8745057dafb4c034175cb1b9" translate="yes" xml:space="preserve">
          <source>Constructor function</source>
          <target state="translated">Функция конструктора</target>
        </trans-unit>
        <trans-unit id="d14be1865dab7ff31185f4ebfd1097f17695a8ad" translate="yes" xml:space="preserve">
          <source>Constructor functions</source>
          <target state="translated">Конструкторские функции</target>
        </trans-unit>
        <trans-unit id="ad5a6954f7216fa7344299b97657bf4b6231f0ec" translate="yes" xml:space="preserve">
          <source>Do ES6 arrow functions have their own arguments or not?</source>
          <target state="translated">Имеют ли функции стрелок ES6 свои собственные аргументы или нет?</target>
        </trans-unit>
        <trans-unit id="f05b8d2d73b2c0c0e233f2ee97f7accee054b0d7" translate="yes" xml:space="preserve">
          <source>Don't use to add function as a property in object literal because we
can not access this.</source>
          <target state="translated">Не используйте функцию добавления в качестве свойства в буквальном смысле объекта,потому что мы не можем получить доступ к этому.</target>
        </trans-unit>
        <trans-unit id="623f2a72fc475fa4b43aabb17036f57e8d86ea97" translate="yes" xml:space="preserve">
          <source>ES2015 distinguishes between functions that are &lt;em&gt;call&lt;/em&gt;able and functions that are &lt;em&gt;construct&lt;/em&gt;able. If a function is constructable, it can be called with  &lt;code&gt;new&lt;/code&gt;, i.e. &lt;code&gt;new User()&lt;/code&gt;. If a function is callable, it can be called without &lt;code&gt;new&lt;/code&gt; (i.e. normal function call).</source>
          <target state="translated">ES2015 различает функции, которые могут &lt;em&gt;вызываться,&lt;/em&gt; и функции, которые могут быть созданы. Если функция конструируема, ее можно вызвать с помощью &lt;code&gt;new&lt;/code&gt; , то есть &lt;code&gt;new User()&lt;/code&gt; . Если функция вызывается, ее можно вызывать без &lt;code&gt;new&lt;/code&gt; (т. Е. Обычного вызова функции).</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Расширить фрагмент</target>
        </trans-unit>
        <trans-unit id="b78884b7d6d3cd8b95d7b4912c7e6360c06df791" translate="yes" xml:space="preserve">
          <source>Function / methods added to a prototype (because they usually use &lt;code&gt;this&lt;/code&gt;)</source>
          <target state="translated">Функция / методы добавлены в прототип (потому что они обычно используют &lt;code&gt;this&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="393e528f5a84301cfcf4cbacaef7f7ff6975b56e" translate="yes" xml:space="preserve">
          <source>Function expressions are best for object methods. Arrow functions
are best for callbacks or methods like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, or &lt;code&gt;forEach&lt;/code&gt;.</source>
          <target state="translated">Выражения функций лучше всего подходят для объектных методов. Функции со стрелками лучше всего подходят для обратных вызовов или методов, таких как &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;forEach&lt;/code&gt; или forEach .</target>
        </trans-unit>
        <trans-unit id="6362bcada6b07a59ecb435d4048f398f1bc4f0b6" translate="yes" xml:space="preserve">
          <source>Functions created through function declarations / expressions are both constructable and callable.</source>
          <target state="translated">Функции,созданные с помощью выражений деклараций функций,являются как конструктивными,так и вызываемыми.</target>
        </trans-unit>
        <trans-unit id="f1f9e5119ab138f8bbc10a925f0aa5467120f80d" translate="yes" xml:space="preserve">
          <source>Functions that are used with &lt;code&gt;.bind(this)&lt;/code&gt;</source>
          <target state="translated">Функции, которые используются с &lt;code&gt;.bind(this)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="456d3987ca295af904df154e6369d508e294988a" translate="yes" xml:space="preserve">
          <source>Functions that don't use &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;arguments&lt;/code&gt;.</source>
          <target state="translated">Функции, которые не используют &lt;code&gt;this&lt;/code&gt; или &lt;code&gt;arguments&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="477bc37237dcccfb60e8212ecf58c8cfd4777700" translate="yes" xml:space="preserve">
          <source>Further resources:</source>
          <target state="translated">Дополнительные ресурсы:</target>
        </trans-unit>
        <trans-unit id="4e4c8f057232f689f7865d3560789790b7c4d3e2" translate="yes" xml:space="preserve">
          <source>How to use arrow functions (public class fields) as class methods?</source>
          <target state="translated">Как использовать функции стрелок (public class fields)в качестве методов класса?</target>
        </trans-unit>
        <trans-unit id="880597dc01da6cbbd55a0b71debfd54b7e7772d0" translate="yes" xml:space="preserve">
          <source>If the function you want to replace does &lt;em&gt;not&lt;/em&gt; use &lt;code&gt;this&lt;/code&gt;, &lt;code&gt;arguments&lt;/code&gt; and is not called with &lt;code&gt;new&lt;/code&gt;, then yes.</source>
          <target state="translated">Если функция, которую вы хотите заменить, &lt;em&gt;не&lt;/em&gt; использует &lt;code&gt;this&lt;/code&gt; , &lt;code&gt;arguments&lt;/code&gt; и не вызывается с &lt;code&gt;new&lt;/code&gt; , тогда да.</target>
        </trans-unit>
        <trans-unit id="350a68eb6569ce9ff1feb1188385b48380235995" translate="yes" xml:space="preserve">
          <source>If you are not very familiar with &lt;code&gt;this&lt;/code&gt;, consider reading</source>
          <target state="translated">Если вы не очень знакомы с &lt;code&gt;this&lt;/code&gt; , подумайте о прочтении</target>
        </trans-unit>
        <trans-unit id="635a17ff7cb2fe460b7e86b6255fd21f47b485f3" translate="yes" xml:space="preserve">
          <source>If you are trying to call a non-callable function or to construct a non-constructable function, you will get a runtime error.</source>
          <target state="translated">Если вы пытаетесь вызвать не вызываемую функцию или создать неконструктивную функцию,вы получите ошибку во время выполнения.</target>
        </trans-unit>
        <trans-unit id="2dff0492e38968e93907c861ade0d7967b3e7ebd" translate="yes" xml:space="preserve">
          <source>In the function expression case, &lt;code&gt;this&lt;/code&gt; refers to the object that was created inside the &lt;code&gt;createObject&lt;/code&gt;. In the arrow function case, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;this&lt;/code&gt; of &lt;code&gt;createObject&lt;/code&gt; itself.</source>
          <target state="translated">В случае выражения функции &lt;code&gt;this&lt;/code&gt; относится к объекту, который был создан внутри &lt;code&gt;createObject&lt;/code&gt; . В случае функции стрелки &lt;code&gt;this&lt;/code&gt; относится к самой функции &lt;code&gt;createObject&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd42fee9d4f1683e06ea78dc3a83833b50ad5a21" translate="yes" xml:space="preserve">
          <source>It depends. You should definitely replace it if you are aliasing the outer &lt;code&gt;this&lt;/code&gt; or are using &lt;code&gt;.bind(this)&lt;/code&gt;:</source>
          <target state="translated">По-разному. Вам определенно следует заменить его, если вы используете псевдоним внешний &lt;code&gt;this&lt;/code&gt; или используете &lt;code&gt;.bind(this)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="595fd6ec76457623f2c972ea259758fc3a7b743b" translate="yes" xml:space="preserve">
          <source>It uses &amp;ldquo;lexical scoping&amp;rdquo; to figure out what the value of &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo;
should be. In simple word lexical scoping it uses &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo; from the
inside the function&amp;rsquo;s body.</source>
          <target state="translated">Он использует &amp;laquo;лексическую область видимости&amp;raquo;, чтобы выяснить, каким должно быть значение &amp;laquo; &lt;code&gt;this&lt;/code&gt; &amp;raquo;. В простом слове лексическая область видимости использует &amp;laquo; &lt;code&gt;this&lt;/code&gt; &amp;raquo; изнутри тела функции.</target>
        </trans-unit>
        <trans-unit id="c476e80e1cdd58b7ace124f3c9a6375c30201c1a" translate="yes" xml:space="preserve">
          <source>Knowing this, we can state the following.</source>
          <target state="translated">Зная это,мы можем заявить следующее.</target>
        </trans-unit>
        <trans-unit id="77fa39a269b43e0605dcbafa7542c4f7d73394a1" translate="yes" xml:space="preserve">
          <source>Lets have a closer look at this using your examples:</source>
          <target state="translated">Давайте рассмотрим это подробнее на ваших примерах:</target>
        </trans-unit>
        <trans-unit id="3c28b8d22d5c20da1ebd35b6a29c6adfb785832b" translate="yes" xml:space="preserve">
          <source>MDN - Arrow functions</source>
          <target state="translated">MDN-функции стрелок</target>
        </trans-unit>
        <trans-unit id="645f17b142695c52e8daeb39d2e274b483222012" translate="yes" xml:space="preserve">
          <source>MDN - this</source>
          <target state="translated">MDN-это</target>
        </trans-unit>
        <trans-unit id="55f205dca19e0070e2a06a80e90943c1dc8cdf0d" translate="yes" xml:space="preserve">
          <source>Most likely not, because prototype methods usually use &lt;code&gt;this&lt;/code&gt; to access the instance. If they don't use &lt;code&gt;this&lt;/code&gt;, then you can replace it. However, if you primarily care for concise syntax, use &lt;code&gt;class&lt;/code&gt; with its concise method syntax:</source>
          <target state="translated">Скорее всего, нет, потому что методы-прототипы обычно используют &lt;code&gt;this&lt;/code&gt; для доступа к экземпляру. Если они не используют &lt;code&gt;this&lt;/code&gt; , то вы можете заменить его. Однако, если вам важен краткий синтаксис, используйте &lt;code&gt;class&lt;/code&gt; с его кратким синтаксисом метода:</target>
        </trans-unit>
        <trans-unit id="3cbdc79d3938eb210b07fab882dd77388e2e974d" translate="yes" xml:space="preserve">
          <source>Object (literal) methods</source>
          <target state="translated">Объектные (буквальные)методы</target>
        </trans-unit>
        <trans-unit id="b46ce0e46e0605a9b2dee716fba3840e125bed96" translate="yes" xml:space="preserve">
          <source>Prototype methods</source>
          <target state="translated">Методы прототипов</target>
        </trans-unit>
        <trans-unit id="d0dc8c8c213db6c4e484e26195b16c84bf3ee6b0" translate="yes" xml:space="preserve">
          <source>Related question:</source>
          <target state="translated">Похожий вопрос:</target>
        </trans-unit>
        <trans-unit id="cf9cf80c8a1eaa83b42cd0d57c602fa3492f586c" translate="yes" xml:space="preserve">
          <source>Replaceable:</source>
          <target state="translated">Replaceable:</target>
        </trans-unit>
        <trans-unit id="8200d713d5ab8264a2587d88340955d674688d00" translate="yes" xml:space="preserve">
          <source>Similarly for methods in an object literal. If the method wants to reference the object itself via &lt;code&gt;this&lt;/code&gt;, keep using function expressions,  or use the new method syntax:</source>
          <target state="translated">Аналогично для методов в литерале объекта. Если метод хочет ссылаться на сам объект через &lt;code&gt;this&lt;/code&gt; , продолжайте использовать выражения функции или используйте синтаксис нового метода:</target>
        </trans-unit>
        <trans-unit id="cf9ecaafb20e6f09950bf5223447af4392e5fc4a" translate="yes" xml:space="preserve">
          <source>Since arrow functions don't have their own &lt;code&gt;arguments&lt;/code&gt;, you cannot simply replace them with an arrow  function. However, ES2015 introduces an alternative to using &lt;code&gt;arguments&lt;/code&gt;: the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;rest parameter&lt;/a&gt;.</source>
          <target state="translated">Так как функции стрелок не имеют своих собственных &lt;code&gt;arguments&lt;/code&gt; , вы не можете просто заменить их функцией стрелок. Однако ES2015 представляет альтернативу использованию &lt;code&gt;arguments&lt;/code&gt; : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;параметр rest&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44aaadc5c82a80e98f3d0f7f3525ca8a69493dab" translate="yes" xml:space="preserve">
          <source>This makes arrow functions useful if you need to access the &lt;code&gt;this&lt;/code&gt; of the current environment:</source>
          <target state="translated">Это делает функции стрелок полезными, если вам нужен доступ к &lt;code&gt;this&lt;/code&gt; из текущей среды:</target>
        </trans-unit>
        <trans-unit id="bd3dc93f2d622ead47798f6b55203b5a4306478d" translate="yes" xml:space="preserve">
          <source>This won't work because arrow functions cannot be called with &lt;code&gt;new&lt;/code&gt;. Keep using a function declaration / expression or use &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">Это не будет работать, потому что функции стрелок не могут быть вызваны с &lt;code&gt;new&lt;/code&gt; . Продолжайте использовать объявление функции / выражение или использовать &lt;code&gt;class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72df882cfc7254f789055bbd609572ee19c64164" translate="yes" xml:space="preserve">
          <source>Use arrow functions for callbacks (because they tend to be terser).</source>
          <target state="translated">Используйте функции стрелок для обратных вызовов (потому что они,как правило,триггерные).</target>
        </trans-unit>
        <trans-unit id="fc9d2febd3cd1f00231d4d46be4a69bd3c08aa8b" translate="yes" xml:space="preserve">
          <source>Use function declarations for functions you&amp;rsquo;d call by name (because
they&amp;rsquo;re hoisted).</source>
          <target state="translated">Используйте объявления функций для функций, которые вы вызываете по имени (потому что они подняты).</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">вариадические функции</target>
        </trans-unit>
        <trans-unit id="30a2bf360c26bbff34c038deb577bf663a9c6b04" translate="yes" xml:space="preserve">
          <source>Variadic functions (if they use &lt;code&gt;arguments&lt;/code&gt; (see below))</source>
          <target state="translated">Функции Variadic (если они используют &lt;code&gt;arguments&lt;/code&gt; (см. Ниже))</target>
        </trans-unit>
        <trans-unit id="4bc73dceb4900b103dec4371d6b793953d0c286b" translate="yes" xml:space="preserve">
          <source>Wait, you can't use arrow function everywhere in your code, its not going to work in all cases like &lt;code&gt;this&lt;/code&gt; where arrow functions are not usable. Without a doubt, the arrow function is a great addition it brings code simplicity.</source>
          <target state="translated">Подождите, вы не можете использовать функцию стрелки везде в вашем коде, она не будет работать во всех случаях, таких как &lt;code&gt;this&lt;/code&gt; где функции стрелки не могут быть использованы. Без сомнения, функция стрелки является отличным дополнением и обеспечивает простоту кода.</target>
        </trans-unit>
        <trans-unit id="53efc89aa69b93c640109759ad72fe527704ada4" translate="yes" xml:space="preserve">
          <source>What are the differences (if any) between ES6 arrow functions and functions bound with Function.prototype.bind?</source>
          <target state="translated">Каковы различия (если таковые имеются)между функциями стрелок ES6 и функциями,связанными с Function.prototype.bind?</target>
        </trans-unit>
        <trans-unit id="6ecc2633f74ab15fa56773ce4d75cfd3a20a4109" translate="yes" xml:space="preserve">
          <source>What do I have to look out for?</source>
          <target state="translated">На что я должен обратить внимание?</target>
        </trans-unit>
        <trans-unit id="6efdd0660158859321165eadf5e588188a2b914c" translate="yes" xml:space="preserve">
          <source>When should I use Arrow functions in ECMAScript 6?</source>
          <target state="translated">Когда я должен использовать функции Arrow в ECMAScript 6?</target>
        </trans-unit>
        <trans-unit id="5b3c883bebe992d46fba10eba247117da34473e0" translate="yes" xml:space="preserve">
          <source>When to use arrow function and when not:</source>
          <target state="translated">Когда использовать функцию со стрелкой,а когда нет:</target>
        </trans-unit>
        <trans-unit id="251aebdb1baaab67aa66626abaec6dcd0ed17728" translate="yes" xml:space="preserve">
          <source>YDKJS - Arrow functions</source>
          <target state="translated">YDKJS-функции стрелок</target>
        </trans-unit>
        <trans-unit id="7ea5e2c1a61797ad69a9918d25ac545a4685999e" translate="yes" xml:space="preserve">
          <source>YDKJS - this &amp;amp; Object prototypes</source>
          <target state="translated">YDKJS - это &amp;amp; ​​Объектные прототипы</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
