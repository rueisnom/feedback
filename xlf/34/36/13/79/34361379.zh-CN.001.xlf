<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/34361379">
    <body>
      <group id="34361379">
        <trans-unit id="8a9305ffc2f2a21bc0e0cce734e74c2de0d90d5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let sum = (...args) =&amp;gt; args.reduce((x, y) =&amp;gt; x + y, 0)&lt;/code&gt;&lt;code&gt;sum(3, 3, 1) // output - 7&lt;/code&gt;
`</source>
          <target state="translated">&lt;code&gt;let sum = (...args) =&amp;gt; args.reduce((x, y) =&amp;gt; x + y, 0)&lt;/code&gt; &lt;code&gt;sum(3, 3, 1) // output - 7&lt;/code&gt; 3，3，1 ）//输出 -7`</target>
        </trans-unit>
        <trans-unit id="d6b386be0e438dc899807a07cd58b7e487d922b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Not&lt;/em&gt; replaceable:</source>
          <target state="translated">&lt;em&gt;不可&lt;/em&gt;更换：</target>
        </trans-unit>
        <trans-unit id="488cc993c203373e105eb766d391b5e5b46cb0cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Lexical &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1.词法和 &lt;code&gt;arguments&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a7508586904c8705b34630d6f6d3c29302585ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Arrow functions cannot be called with &lt;code&gt;new&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2.箭头函数不能用 &lt;code&gt;new&lt;/code&gt; 调用&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fea952fbdd01d7377771649c404b2d2eebe799d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But:&lt;/strong&gt; If the code which calls the callback explicitly sets &lt;code&gt;this&lt;/code&gt; to a specific value, as is often the case with event handlers, especially with jQuery, and the callback uses &lt;code&gt;this&lt;/code&gt; (or &lt;code&gt;arguments&lt;/code&gt;), you &lt;em&gt;cannot&lt;/em&gt; use an arrow function!</source>
          <target state="translated">&lt;strong&gt;但是：&lt;/strong&gt;如果调用回调的代码将事件处理程序（尤其是jQuery）通常显式地 &lt;code&gt;this&lt;/code&gt; 值设置为特定值，并且回调 &lt;code&gt;arguments&lt;/code&gt; 使用 &lt;code&gt;this&lt;/code&gt; （或arguments ）， &lt;em&gt;则不能&lt;/em&gt;使用箭头函数！</target>
        </trans-unit>
        <trans-unit id="7fdddf9c3bee50f48d61f290501ea4e7b84eca27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Callbacks&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Callbacks&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="157ce55d6ebcf86d356f903b9bf6c964f06e9444" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;构造函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="277d555f97f038c6632806bf7eef2dec6351e047" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that this also means that is &lt;em&gt;not&lt;/em&gt; possible to set an arrow function's &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;.bind&lt;/code&gt; or &lt;code&gt;.call&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;请注意&lt;/strong&gt; ，这也意味着&lt;em&gt;无法&lt;/em&gt;使用 &lt;code&gt;.bind&lt;/code&gt; 或 &lt;code&gt;.call&lt;/code&gt; 设置箭头功能。</target>
        </trans-unit>
        <trans-unit id="eddb8d389875d6c583f94dafb1d487acd6f23364" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;对象方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7240b41b9e7e3d421b31b87e5dced476c42e69db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prototype methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;原型方法&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f93c5b443b5e0470526ac1a2270f433b36a7ba41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They cannot be used with&lt;/strong&gt;&lt;strong&gt;&lt;code&gt;new&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;它们不能与&lt;/strong&gt; &lt;strong&gt; &lt;code&gt;new&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;一起使用&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="44d0ea0505e9226c704f669fb8bc795ba50b4d5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They do not have &lt;code&gt;this&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;他们没有 &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53b051204da25b8b824721699dd9120b211f117a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They do not have arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;他们没有争论&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b2ea255e5af4354b8c68a41f7d152fc208cdcdf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variadic functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;可变函数&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c563dcc474c861f5d23de9ea9d74cffa69cd0598" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr:&lt;/strong&gt;&lt;strong&gt;No!&lt;/strong&gt; Arrow functions and function declarations / expressions are not equivalent and cannot be replaced blindly.</source>
          <target state="translated">&lt;strong&gt;tl; dr：&lt;/strong&gt; &lt;strong&gt;不！&lt;/strong&gt; 箭头函数和函数声明/表达式不等效，不能盲目替换。</target>
        </trans-unit>
        <trans-unit id="9e4f3b712458b764fee0ab7a77547075362a776d" translate="yes" xml:space="preserve">
          <source>Are 'Arrow Functions' and 'Functions' equivalent / exchangeable</source>
          <target state="translated">'箭头函数'和'函数'是可以等价交换的吗?</target>
        </trans-unit>
        <trans-unit id="097cd6bcfb4e1fe38807711e39cf37e85c2bc5a1" translate="yes" xml:space="preserve">
          <source>Arrow functions (and methods) are only callable.
&lt;code&gt;class&lt;/code&gt; constructors are only constructable.</source>
          <target state="translated">箭头函数（和方法）仅可调用。 &lt;code&gt;class&lt;/code&gt; 构造函数只能构造。</target>
        </trans-unit>
        <trans-unit id="81098c36bba344fc060ab84fa79bbfcf54aa2c3a" translate="yes" xml:space="preserve">
          <source>Arrow functions =&amp;gt; best ES6 feature so far. They are a tremendously
  powerful addition to ES6, that I use constantly.</source>
          <target state="translated">箭头功能=&amp;gt;迄今为止最好的ES6功能。 它们是ES6的强大补充，我一直在使用。</target>
        </trans-unit>
        <trans-unit id="2ed8af4386bde5001c11d3a6063d953a276e2650" translate="yes" xml:space="preserve">
          <source>Arrow functions can't be construtors because they do not have a prototype property.</source>
          <target state="translated">箭头函数不能成为 construtors,因为它们没有原型属性。</target>
        </trans-unit>
        <trans-unit id="db9f796ceaa44d107dd215efb7264dff6cf8dc8c" translate="yes" xml:space="preserve">
          <source>Arrow functions don&amp;rsquo;t have an arguments object. But the same
functionality can be achieved using rest parameters.</source>
          <target state="translated">箭头函数没有参数对象。 但是使用rest参数可以实现相同的功能。</target>
        </trans-unit>
        <trans-unit id="6ac7165f3dd26e2cdc228d4ea4202fc02f30e9e4" translate="yes" xml:space="preserve">
          <source>Arrow functions don't have their own &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;arguments&lt;/code&gt; binding. Instead, those identifiers are resolved in the lexical scope like any other variable. That means that inside an arrow function, &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; refer to the values of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; in the environment the arrow function is &lt;em&gt;defined&lt;/em&gt; in (i.e. &quot;outside&quot; the arrow function):</source>
          <target state="translated">箭头函数没有自己的 &lt;code&gt;this&lt;/code&gt; 或 &lt;code&gt;arguments&lt;/code&gt; 绑定。 相反，这些标识符像任何其他变量一样在词法范围内解析。 这意味着在arrow函数内部， &lt;code&gt;this&lt;/code&gt; 和 &lt;code&gt;arguments&lt;/code&gt; 指的是&lt;em&gt;定义&lt;/em&gt;箭头函数的环境中的 &lt;code&gt;this&lt;/code&gt; 和 &lt;code&gt;arguments&lt;/code&gt; 的值（即arrow函数的&amp;ldquo;外部&amp;rdquo;）：</target>
        </trans-unit>
        <trans-unit id="4c46e5830c1a4417ff77a66df443155bef9ddaba" translate="yes" xml:space="preserve">
          <source>Arrow functions in ES2015 provide a more concise syntax.</source>
          <target state="translated">ES2015中的箭头函数提供了更简洁的语法。</target>
        </trans-unit>
        <trans-unit id="a349ca267127b5faf849c2f06a6f3ed14ab1572c" translate="yes" xml:space="preserve">
          <source>Arrow functions should NOT be used because:</source>
          <target state="translated">不应使用箭头函数,因为:</target>
        </trans-unit>
        <trans-unit id="9b2bda921bc6b091d8d99377e4291396fbf26932" translate="yes" xml:space="preserve">
          <source>As so often: &lt;strong&gt;it depends&lt;/strong&gt;. Arrow functions have different behavior than function declarations / expressions, so let's have a look at the differences first:</source>
          <target state="translated">如此频繁： &lt;strong&gt;这取决于&lt;/strong&gt; 。 箭头函数与函数声明/表达式的行为不同，因此让我们首先看一下它们的区别：</target>
        </trans-unit>
        <trans-unit id="807bece96fbabe4fd1884464fe2b6613508ddb00" translate="yes" xml:space="preserve">
          <source>But you can&amp;rsquo;t use an arrow function when a dynamic context is required: defining methods, create objects with constructors, get the target from this when handling events.</source>
          <target state="translated">但是，当需要动态上下文时，不能使用箭头功能：定义方法，使用构造函数创建对象，在处理事件时从中获取目标。</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="6f09b72943c02d70071365c301fbca77ddd1b8e1" translate="yes" xml:space="preserve">
          <source>Can I replace all my function declarations / expressions with arrow functions now?</source>
          <target state="translated">我现在可以用箭头函数代替所有的函数声明表达式了吗?</target>
        </trans-unit>
        <trans-unit id="b5c9417824a65aca8745057dafb4c034175cb1b9" translate="yes" xml:space="preserve">
          <source>Constructor function</source>
          <target state="translated">构造函数</target>
        </trans-unit>
        <trans-unit id="d14be1865dab7ff31185f4ebfd1097f17695a8ad" translate="yes" xml:space="preserve">
          <source>Constructor functions</source>
          <target state="translated">构造函数</target>
        </trans-unit>
        <trans-unit id="ad5a6954f7216fa7344299b97657bf4b6231f0ec" translate="yes" xml:space="preserve">
          <source>Do ES6 arrow functions have their own arguments or not?</source>
          <target state="translated">ES6箭头函数到底有没有自己的参数?</target>
        </trans-unit>
        <trans-unit id="f05b8d2d73b2c0c0e233f2ee97f7accee054b0d7" translate="yes" xml:space="preserve">
          <source>Don't use to add function as a property in object literal because we
can not access this.</source>
          <target state="translated">不要使用添加函数作为对象字面上的属性,因为我们不能访问这个。</target>
        </trans-unit>
        <trans-unit id="623f2a72fc475fa4b43aabb17036f57e8d86ea97" translate="yes" xml:space="preserve">
          <source>ES2015 distinguishes between functions that are &lt;em&gt;call&lt;/em&gt;able and functions that are &lt;em&gt;construct&lt;/em&gt;able. If a function is constructable, it can be called with  &lt;code&gt;new&lt;/code&gt;, i.e. &lt;code&gt;new User()&lt;/code&gt;. If a function is callable, it can be called without &lt;code&gt;new&lt;/code&gt; (i.e. normal function call).</source>
          <target state="translated">ES2015区分了可&lt;em&gt;调用的&lt;/em&gt;功能和可&lt;em&gt;构造的&lt;/em&gt;功能。 如果一个函数是可构造的，则可以使用 &lt;code&gt;new&lt;/code&gt; ，即 &lt;code&gt;new User()&lt;/code&gt; 来调用它。 如果一个函数是可调用的，则可以在不使用 &lt;code&gt;new&lt;/code&gt; 函数的情况下对其进行调用（即正常函数调用）。</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">扩展片段</target>
        </trans-unit>
        <trans-unit id="b78884b7d6d3cd8b95d7b4912c7e6360c06df791" translate="yes" xml:space="preserve">
          <source>Function / methods added to a prototype (because they usually use &lt;code&gt;this&lt;/code&gt;)</source>
          <target state="translated">添加到原型的函数/方法（因为他们通常使用 &lt;code&gt;this&lt;/code&gt; ）</target>
        </trans-unit>
        <trans-unit id="393e528f5a84301cfcf4cbacaef7f7ff6975b56e" translate="yes" xml:space="preserve">
          <source>Function expressions are best for object methods. Arrow functions
are best for callbacks or methods like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, or &lt;code&gt;forEach&lt;/code&gt;.</source>
          <target state="translated">函数表达式最适合对象方法。 箭头函数最适合于回调或方法，例如 &lt;code&gt;map&lt;/code&gt; ， &lt;code&gt;reduce&lt;/code&gt; 或 &lt;code&gt;forEach&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="6362bcada6b07a59ecb435d4048f398f1bc4f0b6" translate="yes" xml:space="preserve">
          <source>Functions created through function declarations / expressions are both constructable and callable.</source>
          <target state="translated">通过函数声明表达式创建的函数是可构造和可调用的。</target>
        </trans-unit>
        <trans-unit id="f1f9e5119ab138f8bbc10a925f0aa5467120f80d" translate="yes" xml:space="preserve">
          <source>Functions that are used with &lt;code&gt;.bind(this)&lt;/code&gt;</source>
          <target state="translated">与 &lt;code&gt;.bind(this)&lt;/code&gt; 一起使用的函数</target>
        </trans-unit>
        <trans-unit id="456d3987ca295af904df154e6369d508e294988a" translate="yes" xml:space="preserve">
          <source>Functions that don't use &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;arguments&lt;/code&gt;.</source>
          <target state="translated">不使用 &lt;code&gt;this&lt;/code&gt; 或 &lt;code&gt;arguments&lt;/code&gt; 的函数 。</target>
        </trans-unit>
        <trans-unit id="477bc37237dcccfb60e8212ecf58c8cfd4777700" translate="yes" xml:space="preserve">
          <source>Further resources:</source>
          <target state="translated">进一步的资源:</target>
        </trans-unit>
        <trans-unit id="4e4c8f057232f689f7865d3560789790b7c4d3e2" translate="yes" xml:space="preserve">
          <source>How to use arrow functions (public class fields) as class methods?</source>
          <target state="translated">如何将箭头函数(公共类字段)作为类方法使用?</target>
        </trans-unit>
        <trans-unit id="880597dc01da6cbbd55a0b71debfd54b7e7772d0" translate="yes" xml:space="preserve">
          <source>If the function you want to replace does &lt;em&gt;not&lt;/em&gt; use &lt;code&gt;this&lt;/code&gt;, &lt;code&gt;arguments&lt;/code&gt; and is not called with &lt;code&gt;new&lt;/code&gt;, then yes.</source>
          <target state="translated">如果您要替换的函数&lt;em&gt;未&lt;/em&gt;使用 &lt;code&gt;this&lt;/code&gt; ， &lt;code&gt;arguments&lt;/code&gt; 并且未使用 &lt;code&gt;new&lt;/code&gt; 调用 ，则为yes。</target>
        </trans-unit>
        <trans-unit id="350a68eb6569ce9ff1feb1188385b48380235995" translate="yes" xml:space="preserve">
          <source>If you are not very familiar with &lt;code&gt;this&lt;/code&gt;, consider reading</source>
          <target state="translated">如果您对此不太熟悉，请考虑阅读</target>
        </trans-unit>
        <trans-unit id="635a17ff7cb2fe460b7e86b6255fd21f47b485f3" translate="yes" xml:space="preserve">
          <source>If you are trying to call a non-callable function or to construct a non-constructable function, you will get a runtime error.</source>
          <target state="translated">如果你试图调用一个不可调用的函数或构造一个不可构造的函数,你会得到一个运行时错误。</target>
        </trans-unit>
        <trans-unit id="2dff0492e38968e93907c861ade0d7967b3e7ebd" translate="yes" xml:space="preserve">
          <source>In the function expression case, &lt;code&gt;this&lt;/code&gt; refers to the object that was created inside the &lt;code&gt;createObject&lt;/code&gt;. In the arrow function case, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;this&lt;/code&gt; of &lt;code&gt;createObject&lt;/code&gt; itself.</source>
          <target state="translated">在函数表达式的情况下， &lt;code&gt;this&lt;/code&gt; 是指在 &lt;code&gt;createObject&lt;/code&gt; 内部创建的对象。 在箭头函数的情况下， &lt;code&gt;this&lt;/code&gt; 是指 &lt;code&gt;createObject&lt;/code&gt; 本身。</target>
        </trans-unit>
        <trans-unit id="cd42fee9d4f1683e06ea78dc3a83833b50ad5a21" translate="yes" xml:space="preserve">
          <source>It depends. You should definitely replace it if you are aliasing the outer &lt;code&gt;this&lt;/code&gt; or are using &lt;code&gt;.bind(this)&lt;/code&gt;:</source>
          <target state="translated">这取决于。 如果要别名外部 &lt;code&gt;this&lt;/code&gt; 或使用 &lt;code&gt;.bind(this)&lt;/code&gt; ，则绝对应该替换它：</target>
        </trans-unit>
        <trans-unit id="595fd6ec76457623f2c972ea259758fc3a7b743b" translate="yes" xml:space="preserve">
          <source>It uses &amp;ldquo;lexical scoping&amp;rdquo; to figure out what the value of &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo;
should be. In simple word lexical scoping it uses &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo; from the
inside the function&amp;rsquo;s body.</source>
          <target state="translated">它使用&amp;ldquo;词法作用域&amp;rdquo;来确定&amp;ldquo; &lt;code&gt;this&lt;/code&gt; &amp;rdquo;的值。 用简单的词法作用域定义，它从函数体内使用&amp;ldquo; &lt;code&gt;this&lt;/code&gt; &amp;rdquo;。</target>
        </trans-unit>
        <trans-unit id="c476e80e1cdd58b7ace124f3c9a6375c30201c1a" translate="yes" xml:space="preserve">
          <source>Knowing this, we can state the following.</source>
          <target state="translated">知道了这一点,我们可以说明如下:</target>
        </trans-unit>
        <trans-unit id="77fa39a269b43e0605dcbafa7542c4f7d73394a1" translate="yes" xml:space="preserve">
          <source>Lets have a closer look at this using your examples:</source>
          <target state="translated">让我们用你的例子来仔细看一下。</target>
        </trans-unit>
        <trans-unit id="3c28b8d22d5c20da1ebd35b6a29c6adfb785832b" translate="yes" xml:space="preserve">
          <source>MDN - Arrow functions</source>
          <target state="translated">MDN-箭头功能</target>
        </trans-unit>
        <trans-unit id="645f17b142695c52e8daeb39d2e274b483222012" translate="yes" xml:space="preserve">
          <source>MDN - this</source>
          <target state="translated">MDN-这</target>
        </trans-unit>
        <trans-unit id="55f205dca19e0070e2a06a80e90943c1dc8cdf0d" translate="yes" xml:space="preserve">
          <source>Most likely not, because prototype methods usually use &lt;code&gt;this&lt;/code&gt; to access the instance. If they don't use &lt;code&gt;this&lt;/code&gt;, then you can replace it. However, if you primarily care for concise syntax, use &lt;code&gt;class&lt;/code&gt; with its concise method syntax:</source>
          <target state="translated">很有可能不是，因为原型方法通常使用 &lt;code&gt;this&lt;/code&gt; 来访问实例。 如果他们不使用 &lt;code&gt;this&lt;/code&gt; ，那么您可以替换它。 但是，如果您主要关心简洁的语法，请使用 &lt;code&gt;class&lt;/code&gt; 及其简洁的方法语法：</target>
        </trans-unit>
        <trans-unit id="3cbdc79d3938eb210b07fab882dd77388e2e974d" translate="yes" xml:space="preserve">
          <source>Object (literal) methods</source>
          <target state="translated">对象(字面)方法</target>
        </trans-unit>
        <trans-unit id="b46ce0e46e0605a9b2dee716fba3840e125bed96" translate="yes" xml:space="preserve">
          <source>Prototype methods</source>
          <target state="translated">原型方法</target>
        </trans-unit>
        <trans-unit id="d0dc8c8c213db6c4e484e26195b16c84bf3ee6b0" translate="yes" xml:space="preserve">
          <source>Related question:</source>
          <target state="translated">相关的问题。</target>
        </trans-unit>
        <trans-unit id="cf9cf80c8a1eaa83b42cd0d57c602fa3492f586c" translate="yes" xml:space="preserve">
          <source>Replaceable:</source>
          <target state="translated">Replaceable:</target>
        </trans-unit>
        <trans-unit id="8200d713d5ab8264a2587d88340955d674688d00" translate="yes" xml:space="preserve">
          <source>Similarly for methods in an object literal. If the method wants to reference the object itself via &lt;code&gt;this&lt;/code&gt;, keep using function expressions,  or use the new method syntax:</source>
          <target state="translated">与对象文字中的方法类似。 如果方法要通过 &lt;code&gt;this&lt;/code&gt; 引用对象本身，请继续使用函数表达式，或使用新的方法语法：</target>
        </trans-unit>
        <trans-unit id="cf9ecaafb20e6f09950bf5223447af4392e5fc4a" translate="yes" xml:space="preserve">
          <source>Since arrow functions don't have their own &lt;code&gt;arguments&lt;/code&gt;, you cannot simply replace them with an arrow  function. However, ES2015 introduces an alternative to using &lt;code&gt;arguments&lt;/code&gt;: the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;rest parameter&lt;/a&gt;.</source>
          <target state="translated">由于箭头函数没有自己的 &lt;code&gt;arguments&lt;/code&gt; ，因此不能简单地将它们替换为箭头函数。 但是，ES2015引入了使用 &lt;code&gt;arguments&lt;/code&gt; 的替代方法： &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;rest参数&lt;/a&gt; 。</target>
        </trans-unit>
        <trans-unit id="44aaadc5c82a80e98f3d0f7f3525ca8a69493dab" translate="yes" xml:space="preserve">
          <source>This makes arrow functions useful if you need to access the &lt;code&gt;this&lt;/code&gt; of the current environment:</source>
          <target state="translated">如果您需要访问当前环境的 &lt;code&gt;this&lt;/code&gt; ，这将使箭头功能有用：</target>
        </trans-unit>
        <trans-unit id="bd3dc93f2d622ead47798f6b55203b5a4306478d" translate="yes" xml:space="preserve">
          <source>This won't work because arrow functions cannot be called with &lt;code&gt;new&lt;/code&gt;. Keep using a function declaration / expression or use &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">这将无法正常工作，因为无法使用 &lt;code&gt;new&lt;/code&gt; 调用箭头函数。 继续使用函数声明/表达式或使用 &lt;code&gt;class&lt;/code&gt; 。</target>
        </trans-unit>
        <trans-unit id="72df882cfc7254f789055bbd609572ee19c64164" translate="yes" xml:space="preserve">
          <source>Use arrow functions for callbacks (because they tend to be terser).</source>
          <target state="translated">使用箭头函数进行回调(因为它们往往会比较麻烦)。</target>
        </trans-unit>
        <trans-unit id="fc9d2febd3cd1f00231d4d46be4a69bd3c08aa8b" translate="yes" xml:space="preserve">
          <source>Use function declarations for functions you&amp;rsquo;d call by name (because
they&amp;rsquo;re hoisted).</source>
          <target state="translated">对要通过名称调用的函数使用函数声明（因为它们已被吊起）。</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">变式函数</target>
        </trans-unit>
        <trans-unit id="30a2bf360c26bbff34c038deb577bf663a9c6b04" translate="yes" xml:space="preserve">
          <source>Variadic functions (if they use &lt;code&gt;arguments&lt;/code&gt; (see below))</source>
          <target state="translated">可变 &lt;code&gt;arguments&lt;/code&gt; 函数（如果它们使用参数 （请参见下文））</target>
        </trans-unit>
        <trans-unit id="4bc73dceb4900b103dec4371d6b793953d0c286b" translate="yes" xml:space="preserve">
          <source>Wait, you can't use arrow function everywhere in your code, its not going to work in all cases like &lt;code&gt;this&lt;/code&gt; where arrow functions are not usable. Without a doubt, the arrow function is a great addition it brings code simplicity.</source>
          <target state="translated">等等，您不能在代码中的任何地方使用箭头功能，在所有无法使用箭头功能的情况下，它都无法正常工作。 毫无疑问，箭头功能是一个很好的附加功能，它使代码更简单。</target>
        </trans-unit>
        <trans-unit id="53efc89aa69b93c640109759ad72fe527704ada4" translate="yes" xml:space="preserve">
          <source>What are the differences (if any) between ES6 arrow functions and functions bound with Function.prototype.bind?</source>
          <target state="translated">ES6箭头函数和用Function.prototype.bind绑定的函数有什么区别(如果有的话)?</target>
        </trans-unit>
        <trans-unit id="6ecc2633f74ab15fa56773ce4d75cfd3a20a4109" translate="yes" xml:space="preserve">
          <source>What do I have to look out for?</source>
          <target state="translated">我需要注意什么?</target>
        </trans-unit>
        <trans-unit id="6efdd0660158859321165eadf5e588188a2b914c" translate="yes" xml:space="preserve">
          <source>When should I use Arrow functions in ECMAScript 6?</source>
          <target state="translated">什么时候应该在ECMAScript 6中使用箭头函数?</target>
        </trans-unit>
        <trans-unit id="5b3c883bebe992d46fba10eba247117da34473e0" translate="yes" xml:space="preserve">
          <source>When to use arrow function and when not:</source>
          <target state="translated">什么时候使用箭头功能,什么时候不用。</target>
        </trans-unit>
        <trans-unit id="251aebdb1baaab67aa66626abaec6dcd0ed17728" translate="yes" xml:space="preserve">
          <source>YDKJS - Arrow functions</source>
          <target state="translated">YDKJS-箭头函数</target>
        </trans-unit>
        <trans-unit id="7ea5e2c1a61797ad69a9918d25ac545a4685999e" translate="yes" xml:space="preserve">
          <source>YDKJS - this &amp;amp; Object prototypes</source>
          <target state="translated">YDKJS-此和对象原型</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
