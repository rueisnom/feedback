<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="https://stackoverflow.com/questions/34361379">
    <body>
      <group id="34361379">
        <trans-unit id="8a9305ffc2f2a21bc0e0cce734e74c2de0d90d5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let sum = (...args) =&amp;gt; args.reduce((x, y) =&amp;gt; x + y, 0)&lt;/code&gt;&lt;code&gt;sum(3, 3, 1) // output - 7&lt;/code&gt;
`</source>
          <target state="translated">&lt;code&gt;let sum = (...args) =&amp;gt; args.reduce((x, y) =&amp;gt; x + y, 0)&lt;/code&gt; &lt;code&gt;sum(3, 3, 1) // output - 7&lt;/code&gt; -7`</target>
        </trans-unit>
        <trans-unit id="d6b386be0e438dc899807a07cd58b7e487d922b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Not&lt;/em&gt; replaceable:</source>
          <target state="translated">교체 &lt;em&gt;불가&lt;/em&gt; :</target>
        </trans-unit>
        <trans-unit id="488cc993c203373e105eb766d391b5e5b46cb0cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Lexical &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. 어휘와 &lt;code&gt;arguments&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a7508586904c8705b34630d6f6d3c29302585ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Arrow functions cannot be called with &lt;code&gt;new&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. &lt;code&gt;new&lt;/code&gt; 기능으로 화살표 기능을 호출 할 수 없습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fea952fbdd01d7377771649c404b2d2eebe799d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But:&lt;/strong&gt; If the code which calls the callback explicitly sets &lt;code&gt;this&lt;/code&gt; to a specific value, as is often the case with event handlers, especially with jQuery, and the callback uses &lt;code&gt;this&lt;/code&gt; (or &lt;code&gt;arguments&lt;/code&gt;), you &lt;em&gt;cannot&lt;/em&gt; use an arrow function!</source>
          <target state="translated">&lt;strong&gt;그러나&lt;/strong&gt; 콜백을 호출하는 코드가 명시 적으로 특정 값으로 설정 &lt;code&gt;this&lt;/code&gt; 이벤트 핸들러, 특히 jQuery의 경우와 마찬가지로 콜백 &lt;code&gt;this&lt;/code&gt; (또는 &lt;code&gt;arguments&lt;/code&gt; )를 사용하면 화살표 함수를 사용할 &lt;em&gt;수 없습니다&lt;/em&gt; !</target>
        </trans-unit>
        <trans-unit id="7fdddf9c3bee50f48d61f290501ea4e7b84eca27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Callbacks&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Callbacks&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="157ce55d6ebcf86d356f903b9bf6c964f06e9444" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;생성자 함수&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="277d555f97f038c6632806bf7eef2dec6351e047" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that this also means that is &lt;em&gt;not&lt;/em&gt; possible to set an arrow function's &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;.bind&lt;/code&gt; or &lt;code&gt;.call&lt;/code&gt;.</source>
          <target state="translated">이것은 또한 &lt;code&gt;.bind&lt;/code&gt; 또는 .call로 화살표 기능을 설정할 수 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="eddb8d389875d6c583f94dafb1d487acd6f23364" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;객체 메소드&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7240b41b9e7e3d421b31b87e5dced476c42e69db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prototype methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;프로토 타입 방법&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f93c5b443b5e0470526ac1a2270f433b36a7ba41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They cannot be used with&lt;/strong&gt;&lt;strong&gt;&lt;code&gt;new&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그들은&lt;/strong&gt; &lt;strong&gt; &lt;code&gt;new&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;것과 함께 사용할 수 없습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="44d0ea0505e9226c704f669fb8bc795ba50b4d5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They do not have &lt;code&gt;this&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그들은 &lt;code&gt;this&lt;/code&gt; 가지고 있지 않습니다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53b051204da25b8b824721699dd9120b211f117a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They do not have arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;그들은 논쟁이 없다&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b2ea255e5af4354b8c68a41f7d152fc208cdcdf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variadic functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;가변 기능&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c563dcc474c861f5d23de9ea9d74cffa69cd0598" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr:&lt;/strong&gt;&lt;strong&gt;No!&lt;/strong&gt; Arrow functions and function declarations / expressions are not equivalent and cannot be replaced blindly.</source>
          <target state="translated">&lt;strong&gt;tl; dr :&lt;/strong&gt; &lt;strong&gt;아니요!&lt;/strong&gt; 화살표 함수와 함수 선언 / 표현은 동일하지 않으며 맹목적으로 바꿀 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9e4f3b712458b764fee0ab7a77547075362a776d" translate="yes" xml:space="preserve">
          <source>Are 'Arrow Functions' and 'Functions' equivalent / exchangeable</source>
          <target state="translated">'화살표 함수'와 '함수'는 동일하거나 교환 가능</target>
        </trans-unit>
        <trans-unit id="097cd6bcfb4e1fe38807711e39cf37e85c2bc5a1" translate="yes" xml:space="preserve">
          <source>Arrow functions (and methods) are only callable.
&lt;code&gt;class&lt;/code&gt; constructors are only constructable.</source>
          <target state="translated">화살표 함수 (및 메소드)는 호출 만 가능합니다. &lt;code&gt;class&lt;/code&gt; 생성자는 구성 가능합니다.</target>
        </trans-unit>
        <trans-unit id="81098c36bba344fc060ab84fa79bbfcf54aa2c3a" translate="yes" xml:space="preserve">
          <source>Arrow functions =&amp;gt; best ES6 feature so far. They are a tremendously
  powerful addition to ES6, that I use constantly.</source>
          <target state="translated">화살표 기능 =&amp;gt; 지금까지 최고의 ES6 기능. ES6에 강력하게 추가되어 끊임없이 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2ed8af4386bde5001c11d3a6063d953a276e2650" translate="yes" xml:space="preserve">
          <source>Arrow functions can't be construtors because they do not have a prototype property.</source>
          <target state="translated">화살표 함수는 프로토 타입 속성이 없기 때문에 해석자가 될 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="db9f796ceaa44d107dd215efb7264dff6cf8dc8c" translate="yes" xml:space="preserve">
          <source>Arrow functions don&amp;rsquo;t have an arguments object. But the same
functionality can be achieved using rest parameters.</source>
          <target state="translated">화살표 함수에는 인수 객체가 없습니다. 그러나 나머지 매개 변수를 사용하여 동일한 기능을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ac7165f3dd26e2cdc228d4ea4202fc02f30e9e4" translate="yes" xml:space="preserve">
          <source>Arrow functions don't have their own &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;arguments&lt;/code&gt; binding. Instead, those identifiers are resolved in the lexical scope like any other variable. That means that inside an arrow function, &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; refer to the values of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; in the environment the arrow function is &lt;em&gt;defined&lt;/em&gt; in (i.e. &quot;outside&quot; the arrow function):</source>
          <target state="translated">화살표 함수에는 &lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;arguments&lt;/code&gt; 바인딩 이 없습니다. 대신, 이러한 식별자는 다른 변수와 같이 어휘 범위에서 분석됩니다. 즉, 화살표 함수 내에서 &lt;code&gt;this&lt;/code&gt; 및 &lt;code&gt;arguments&lt;/code&gt; 는 화살표 함수가 &lt;em&gt;정의 된&lt;/em&gt; 환경에서 &lt;code&gt;this&lt;/code&gt; 및 &lt;code&gt;arguments&lt;/code&gt; 의 값을 나타냅니다 (즉, 화살표 함수 &quot;외부&quot;).</target>
        </trans-unit>
        <trans-unit id="4c46e5830c1a4417ff77a66df443155bef9ddaba" translate="yes" xml:space="preserve">
          <source>Arrow functions in ES2015 provide a more concise syntax.</source>
          <target state="translated">ES2015의 화살표 함수는보다 간결한 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a349ca267127b5faf849c2f06a6f3ed14ab1572c" translate="yes" xml:space="preserve">
          <source>Arrow functions should NOT be used because:</source>
          <target state="translated">다음과 같은 이유로 화살표 기능을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9b2bda921bc6b091d8d99377e4291396fbf26932" translate="yes" xml:space="preserve">
          <source>As so often: &lt;strong&gt;it depends&lt;/strong&gt;. Arrow functions have different behavior than function declarations / expressions, so let's have a look at the differences first:</source>
          <target state="translated">자주 : &lt;strong&gt;그것은 따라 달라집니다&lt;/strong&gt; . 화살표 함수는 함수 선언 / 표현과 동작이 다르므로 차이점을 먼저 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="807bece96fbabe4fd1884464fe2b6613508ddb00" translate="yes" xml:space="preserve">
          <source>But you can&amp;rsquo;t use an arrow function when a dynamic context is required: defining methods, create objects with constructors, get the target from this when handling events.</source>
          <target state="translated">그러나 동적 컨텍스트가 필요한 경우 화살표 함수를 사용할 수 없습니다. 메소드를 정의하고 생성자를 사용하여 오브젝트를 작성하고 이벤트를 처리 할 때 대상을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="6f09b72943c02d70071365c301fbca77ddd1b8e1" translate="yes" xml:space="preserve">
          <source>Can I replace all my function declarations / expressions with arrow functions now?</source>
          <target state="translated">모든 함수 선언 / 표현을 화살표 함수로 바꿀 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="b5c9417824a65aca8745057dafb4c034175cb1b9" translate="yes" xml:space="preserve">
          <source>Constructor function</source>
          <target state="translated">생성자 함수</target>
        </trans-unit>
        <trans-unit id="d14be1865dab7ff31185f4ebfd1097f17695a8ad" translate="yes" xml:space="preserve">
          <source>Constructor functions</source>
          <target state="translated">생성자 함수</target>
        </trans-unit>
        <trans-unit id="ad5a6954f7216fa7344299b97657bf4b6231f0ec" translate="yes" xml:space="preserve">
          <source>Do ES6 arrow functions have their own arguments or not?</source>
          <target state="translated">ES6 화살표 함수에는 자체 인수가 있습니까?</target>
        </trans-unit>
        <trans-unit id="f05b8d2d73b2c0c0e233f2ee97f7accee054b0d7" translate="yes" xml:space="preserve">
          <source>Don't use to add function as a property in object literal because we
can not access this.</source>
          <target state="translated">우리는 이것을 접근 할 수 없기 때문에 객체 리터럴에서 속성으로 함수를 추가하는 데 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="623f2a72fc475fa4b43aabb17036f57e8d86ea97" translate="yes" xml:space="preserve">
          <source>ES2015 distinguishes between functions that are &lt;em&gt;call&lt;/em&gt;able and functions that are &lt;em&gt;construct&lt;/em&gt;able. If a function is constructable, it can be called with  &lt;code&gt;new&lt;/code&gt;, i.e. &lt;code&gt;new User()&lt;/code&gt;. If a function is callable, it can be called without &lt;code&gt;new&lt;/code&gt; (i.e. normal function call).</source>
          <target state="translated">ES2015는 &lt;em&gt;호출&lt;/em&gt; 가능한 기능과 &lt;em&gt;구성&lt;/em&gt; 가능한 기능을 구분합니다. 함수가 구성 가능한 경우 &lt;code&gt;new&lt;/code&gt; , 즉 &lt;code&gt;new User()&lt;/code&gt; 로 호출 할 수 있습니다. 함수를 호출 할 수 있으면 &lt;code&gt;new&lt;/code&gt; 함수없이 호출 할 수 있습니다 (예 : 일반 함수 호출).</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">스 니펫 확장</target>
        </trans-unit>
        <trans-unit id="b78884b7d6d3cd8b95d7b4912c7e6360c06df791" translate="yes" xml:space="preserve">
          <source>Function / methods added to a prototype (because they usually use &lt;code&gt;this&lt;/code&gt;)</source>
          <target state="translated">프로토 타입에 추가 된 함수 / 메소드 (보통 &lt;code&gt;this&lt;/code&gt; 사용하기 때문에)</target>
        </trans-unit>
        <trans-unit id="393e528f5a84301cfcf4cbacaef7f7ff6975b56e" translate="yes" xml:space="preserve">
          <source>Function expressions are best for object methods. Arrow functions
are best for callbacks or methods like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, or &lt;code&gt;forEach&lt;/code&gt;.</source>
          <target state="translated">함수 표현식은 객체 메소드에 가장 적합합니다. 화살표 함수는 &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;reduce&lt;/code&gt; 또는 &lt;code&gt;forEach&lt;/code&gt; 와 같은 콜백 또는 메소드에 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="6362bcada6b07a59ecb435d4048f398f1bc4f0b6" translate="yes" xml:space="preserve">
          <source>Functions created through function declarations / expressions are both constructable and callable.</source>
          <target state="translated">함수 선언 / 표현을 통해 생성 된 함수는 구성 가능하고 호출 가능합니다.</target>
        </trans-unit>
        <trans-unit id="f1f9e5119ab138f8bbc10a925f0aa5467120f80d" translate="yes" xml:space="preserve">
          <source>Functions that are used with &lt;code&gt;.bind(this)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.bind(this)&lt;/code&gt; 와 함께 사용되는 함수</target>
        </trans-unit>
        <trans-unit id="456d3987ca295af904df154e6369d508e294988a" translate="yes" xml:space="preserve">
          <source>Functions that don't use &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;arguments&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;this&lt;/code&gt; 또는 &lt;code&gt;arguments&lt;/code&gt; 를 사용하지 않는 함수</target>
        </trans-unit>
        <trans-unit id="477bc37237dcccfb60e8212ecf58c8cfd4777700" translate="yes" xml:space="preserve">
          <source>Further resources:</source>
          <target state="translated">추가 자료 :</target>
        </trans-unit>
        <trans-unit id="4e4c8f057232f689f7865d3560789790b7c4d3e2" translate="yes" xml:space="preserve">
          <source>How to use arrow functions (public class fields) as class methods?</source>
          <target state="translated">화살표 함수 (공개 클래스 필드)를 클래스 메서드로 사용하는 방법은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="880597dc01da6cbbd55a0b71debfd54b7e7772d0" translate="yes" xml:space="preserve">
          <source>If the function you want to replace does &lt;em&gt;not&lt;/em&gt; use &lt;code&gt;this&lt;/code&gt;, &lt;code&gt;arguments&lt;/code&gt; and is not called with &lt;code&gt;new&lt;/code&gt;, then yes.</source>
          <target state="translated">바꾸려는 함수가 &lt;code&gt;this&lt;/code&gt; , &lt;code&gt;arguments&lt;/code&gt; 를 사용하지 &lt;em&gt;않고&lt;/em&gt; &lt;code&gt;new&lt;/code&gt; 로 호출되지 않으면 yes입니다.</target>
        </trans-unit>
        <trans-unit id="350a68eb6569ce9ff1feb1188385b48380235995" translate="yes" xml:space="preserve">
          <source>If you are not very familiar with &lt;code&gt;this&lt;/code&gt;, consider reading</source>
          <target state="translated">당신이 &lt;code&gt;this&lt;/code&gt; 익숙하지 않다면, 독서를 고려하십시오</target>
        </trans-unit>
        <trans-unit id="635a17ff7cb2fe460b7e86b6255fd21f47b485f3" translate="yes" xml:space="preserve">
          <source>If you are trying to call a non-callable function or to construct a non-constructable function, you will get a runtime error.</source>
          <target state="translated">호출 할 수없는 함수를 호출하거나 구성 할 수없는 함수를 구성하려고하면 런타임 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2dff0492e38968e93907c861ade0d7967b3e7ebd" translate="yes" xml:space="preserve">
          <source>In the function expression case, &lt;code&gt;this&lt;/code&gt; refers to the object that was created inside the &lt;code&gt;createObject&lt;/code&gt;. In the arrow function case, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;this&lt;/code&gt; of &lt;code&gt;createObject&lt;/code&gt; itself.</source>
          <target state="translated">함수 표현식의 경우, &lt;code&gt;this&lt;/code&gt; &lt;code&gt;createObject&lt;/code&gt; 내부에서 작성된 오브젝트를 나타냅니다. 화살표 함수의 경우, &lt;code&gt;this&lt;/code&gt; &lt;code&gt;createObject&lt;/code&gt; 자체를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cd42fee9d4f1683e06ea78dc3a83833b50ad5a21" translate="yes" xml:space="preserve">
          <source>It depends. You should definitely replace it if you are aliasing the outer &lt;code&gt;this&lt;/code&gt; or are using &lt;code&gt;.bind(this)&lt;/code&gt;:</source>
          <target state="translated">때에 따라 다르지. 외부의 별칭을 지정하거나 &lt;code&gt;.bind(this)&lt;/code&gt; 사용하는 경우 반드시 교체해야합니다.</target>
        </trans-unit>
        <trans-unit id="595fd6ec76457623f2c972ea259758fc3a7b743b" translate="yes" xml:space="preserve">
          <source>It uses &amp;ldquo;lexical scoping&amp;rdquo; to figure out what the value of &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo;
should be. In simple word lexical scoping it uses &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo; from the
inside the function&amp;rsquo;s body.</source>
          <target state="translated">&amp;ldquo;lexical scoping&amp;rdquo;을 사용하여&amp;ldquo; &lt;code&gt;this&lt;/code&gt; &amp;rdquo;의 가치가 무엇인지 파악합니다. 간단한 단어 어휘 범위 지정에서는 함수 본문 내부에서 &quot; &lt;code&gt;this&lt;/code&gt; &quot;를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c476e80e1cdd58b7ace124f3c9a6375c30201c1a" translate="yes" xml:space="preserve">
          <source>Knowing this, we can state the following.</source>
          <target state="translated">이것을 알면 다음과 같이 말할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77fa39a269b43e0605dcbafa7542c4f7d73394a1" translate="yes" xml:space="preserve">
          <source>Lets have a closer look at this using your examples:</source>
          <target state="translated">예제를 사용하여이를 자세히 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3c28b8d22d5c20da1ebd35b6a29c6adfb785832b" translate="yes" xml:space="preserve">
          <source>MDN - Arrow functions</source>
          <target state="translated">MDN-화살표 기능</target>
        </trans-unit>
        <trans-unit id="645f17b142695c52e8daeb39d2e274b483222012" translate="yes" xml:space="preserve">
          <source>MDN - this</source>
          <target state="translated">MDN-이</target>
        </trans-unit>
        <trans-unit id="55f205dca19e0070e2a06a80e90943c1dc8cdf0d" translate="yes" xml:space="preserve">
          <source>Most likely not, because prototype methods usually use &lt;code&gt;this&lt;/code&gt; to access the instance. If they don't use &lt;code&gt;this&lt;/code&gt;, then you can replace it. However, if you primarily care for concise syntax, use &lt;code&gt;class&lt;/code&gt; with its concise method syntax:</source>
          <target state="translated">프로토 타입 메소드는 일반적 &lt;code&gt;this&lt;/code&gt; 메소드를 사용하여 인스턴스에 액세스하므로 대부분 그렇지 않습니다. 이들이이를 사용하지 않으면 교체 할 수 있습니다. 그러나 간결한 구문을 주로 관리하는 경우 간결한 메소드 구문과 함께 &lt;code&gt;class&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3cbdc79d3938eb210b07fab882dd77388e2e974d" translate="yes" xml:space="preserve">
          <source>Object (literal) methods</source>
          <target state="translated">객체 (리터럴) 방법</target>
        </trans-unit>
        <trans-unit id="b46ce0e46e0605a9b2dee716fba3840e125bed96" translate="yes" xml:space="preserve">
          <source>Prototype methods</source>
          <target state="translated">프로토 타입 방법</target>
        </trans-unit>
        <trans-unit id="d0dc8c8c213db6c4e484e26195b16c84bf3ee6b0" translate="yes" xml:space="preserve">
          <source>Related question:</source>
          <target state="translated">관련 질문 :</target>
        </trans-unit>
        <trans-unit id="cf9cf80c8a1eaa83b42cd0d57c602fa3492f586c" translate="yes" xml:space="preserve">
          <source>Replaceable:</source>
          <target state="translated">Replaceable:</target>
        </trans-unit>
        <trans-unit id="8200d713d5ab8264a2587d88340955d674688d00" translate="yes" xml:space="preserve">
          <source>Similarly for methods in an object literal. If the method wants to reference the object itself via &lt;code&gt;this&lt;/code&gt;, keep using function expressions,  or use the new method syntax:</source>
          <target state="translated">객체 리터럴의 메소드와 유사합니다. 메소드가 &lt;code&gt;this&lt;/code&gt; 를 통해 객체 자체를 참조하려면 함수 표현식을 계속 사용하거나 새 메소드 구문을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cf9ecaafb20e6f09950bf5223447af4392e5fc4a" translate="yes" xml:space="preserve">
          <source>Since arrow functions don't have their own &lt;code&gt;arguments&lt;/code&gt;, you cannot simply replace them with an arrow  function. However, ES2015 introduces an alternative to using &lt;code&gt;arguments&lt;/code&gt;: the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;rest parameter&lt;/a&gt;.</source>
          <target state="translated">화살표 함수에는 자체 &lt;code&gt;arguments&lt;/code&gt; 가 없으므로 화살표 함수로 간단히 바꿀 수 없습니다. 그러나 ES2015에는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;나머지 매개 변수 인&lt;/a&gt; &lt;code&gt;arguments&lt;/code&gt; 사용에 대한 대안이 도입되었습니다.</target>
        </trans-unit>
        <trans-unit id="44aaadc5c82a80e98f3d0f7f3525ca8a69493dab" translate="yes" xml:space="preserve">
          <source>This makes arrow functions useful if you need to access the &lt;code&gt;this&lt;/code&gt; of the current environment:</source>
          <target state="translated">현재 환경에 액세스해야 할 경우 화살표 기능이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="bd3dc93f2d622ead47798f6b55203b5a4306478d" translate="yes" xml:space="preserve">
          <source>This won't work because arrow functions cannot be called with &lt;code&gt;new&lt;/code&gt;. Keep using a function declaration / expression or use &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">화살표 함수를 &lt;code&gt;new&lt;/code&gt; 로 호출 할 수 없기 때문에 작동하지 않습니다. 함수 선언 / 표현식을 사용하거나 &lt;code&gt;class&lt;/code&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="72df882cfc7254f789055bbd609572ee19c64164" translate="yes" xml:space="preserve">
          <source>Use arrow functions for callbacks (because they tend to be terser).</source>
          <target state="translated">콜백에는 화살표 기능을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fc9d2febd3cd1f00231d4d46be4a69bd3c08aa8b" translate="yes" xml:space="preserve">
          <source>Use function declarations for functions you&amp;rsquo;d call by name (because
they&amp;rsquo;re hoisted).</source>
          <target state="translated">이름으로 호출 할 함수 (호이스트되기 때문에)에 함수 선언을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">가변 기능</target>
        </trans-unit>
        <trans-unit id="30a2bf360c26bbff34c038deb577bf663a9c6b04" translate="yes" xml:space="preserve">
          <source>Variadic functions (if they use &lt;code&gt;arguments&lt;/code&gt; (see below))</source>
          <target state="translated">가변 함수 ( &lt;code&gt;arguments&lt;/code&gt; 사용되는 경우 (아래 참조))</target>
        </trans-unit>
        <trans-unit id="4bc73dceb4900b103dec4371d6b793953d0c286b" translate="yes" xml:space="preserve">
          <source>Wait, you can't use arrow function everywhere in your code, its not going to work in all cases like &lt;code&gt;this&lt;/code&gt; where arrow functions are not usable. Without a doubt, the arrow function is a great addition it brings code simplicity.</source>
          <target state="translated">잠깐, 코드의 어느 곳에서나 화살표 기능을 사용할 수는 없으며 화살표 기능을 사용할 수없는 모든 경우에는 작동하지 않습니다. 의심의 여지없이 화살표 기능은 코드 단순성을 제공하는 큰 추가 기능입니다.</target>
        </trans-unit>
        <trans-unit id="53efc89aa69b93c640109759ad72fe527704ada4" translate="yes" xml:space="preserve">
          <source>What are the differences (if any) between ES6 arrow functions and functions bound with Function.prototype.bind?</source>
          <target state="translated">ES6 화살표 함수와 Function.prototype.bind에 바인딩 된 함수의 차이점 (있는 경우)은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="6ecc2633f74ab15fa56773ce4d75cfd3a20a4109" translate="yes" xml:space="preserve">
          <source>What do I have to look out for?</source>
          <target state="translated">무엇을 찾아야합니까?</target>
        </trans-unit>
        <trans-unit id="6efdd0660158859321165eadf5e588188a2b914c" translate="yes" xml:space="preserve">
          <source>When should I use Arrow functions in ECMAScript 6?</source>
          <target state="translated">ECMAScript 6에서 언제 화살표 기능을 사용해야합니까?</target>
        </trans-unit>
        <trans-unit id="5b3c883bebe992d46fba10eba247117da34473e0" translate="yes" xml:space="preserve">
          <source>When to use arrow function and when not:</source>
          <target state="translated">화살표 기능을 사용하는 경우와 사용하지 않는 경우 :</target>
        </trans-unit>
        <trans-unit id="251aebdb1baaab67aa66626abaec6dcd0ed17728" translate="yes" xml:space="preserve">
          <source>YDKJS - Arrow functions</source>
          <target state="translated">YDKJS-화살표 기능</target>
        </trans-unit>
        <trans-unit id="7ea5e2c1a61797ad69a9918d25ac545a4685999e" translate="yes" xml:space="preserve">
          <source>YDKJS - this &amp;amp; Object prototypes</source>
          <target state="translated">YDKJS-this &amp;amp; Object 프로토 타입</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
