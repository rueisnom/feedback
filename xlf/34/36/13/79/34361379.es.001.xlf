<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/34361379">
    <body>
      <group id="34361379">
        <trans-unit id="8a9305ffc2f2a21bc0e0cce734e74c2de0d90d5d" translate="yes" xml:space="preserve">
          <source>&lt;code&gt;let sum = (...args) =&amp;gt; args.reduce((x, y) =&amp;gt; x + y, 0)&lt;/code&gt;&lt;code&gt;sum(3, 3, 1) // output - 7&lt;/code&gt;
`</source>
          <target state="translated">&lt;code&gt;let sum = (...args) =&amp;gt; args.reduce((x, y) =&amp;gt; x + y, 0)&lt;/code&gt; &lt;code&gt;sum(3, 3, 1) // output - 7&lt;/code&gt; `</target>
        </trans-unit>
        <trans-unit id="d6b386be0e438dc899807a07cd58b7e487d922b7" translate="yes" xml:space="preserve">
          <source>&lt;em&gt;Not&lt;/em&gt; replaceable:</source>
          <target state="translated">&lt;em&gt;No&lt;/em&gt; reemplazable:</target>
        </trans-unit>
        <trans-unit id="488cc993c203373e105eb766d391b5e5b46cb0cc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;1. Lexical &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;1. L&amp;eacute;xico &lt;code&gt;this&lt;/code&gt; y &lt;code&gt;arguments&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1a7508586904c8705b34630d6f6d3c29302585ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;2. Arrow functions cannot be called with &lt;code&gt;new&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;2. Las funciones de flecha no se pueden llamar con &lt;code&gt;new&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fea952fbdd01d7377771649c404b2d2eebe799d2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;But:&lt;/strong&gt; If the code which calls the callback explicitly sets &lt;code&gt;this&lt;/code&gt; to a specific value, as is often the case with event handlers, especially with jQuery, and the callback uses &lt;code&gt;this&lt;/code&gt; (or &lt;code&gt;arguments&lt;/code&gt;), you &lt;em&gt;cannot&lt;/em&gt; use an arrow function!</source>
          <target state="translated">&lt;strong&gt;Pero:&lt;/strong&gt; si el c&amp;oacute;digo que llama a la devoluci&amp;oacute;n de llamada establece expl&amp;iacute;citamente &lt;code&gt;this&lt;/code&gt; en un valor espec&amp;iacute;fico, como suele ser el caso con los controladores de eventos, especialmente con jQuery, y la devoluci&amp;oacute;n de llamada usa &lt;code&gt;this&lt;/code&gt; (o &lt;code&gt;arguments&lt;/code&gt; ), &amp;iexcl; &lt;em&gt;no puede&lt;/em&gt; usar una funci&amp;oacute;n de flecha!</target>
        </trans-unit>
        <trans-unit id="7fdddf9c3bee50f48d61f290501ea4e7b84eca27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Callbacks&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Callbacks&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="157ce55d6ebcf86d356f903b9bf6c964f06e9444" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Constructor function&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Funci&amp;oacute;n constructora&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="277d555f97f038c6632806bf7eef2dec6351e047" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Note&lt;/strong&gt; that this also means that is &lt;em&gt;not&lt;/em&gt; possible to set an arrow function's &lt;code&gt;this&lt;/code&gt; with &lt;code&gt;.bind&lt;/code&gt; or &lt;code&gt;.call&lt;/code&gt;.</source>
          <target state="translated">&lt;strong&gt;Tenga en cuenta&lt;/strong&gt; que esto tambi&amp;eacute;n significa que &lt;em&gt;no&lt;/em&gt; es posible establecer una funci&amp;oacute;n de flecha con &lt;code&gt;.bind&lt;/code&gt; o &lt;code&gt;.call&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eddb8d389875d6c583f94dafb1d487acd6f23364" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Object methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todos de objeto&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7240b41b9e7e3d421b31b87e5dced476c42e69db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Prototype methods&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todos prototipo&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f93c5b443b5e0470526ac1a2270f433b36a7ba41" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They cannot be used with&lt;/strong&gt;&lt;strong&gt;&lt;code&gt;new&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;No se pueden usar con&lt;/strong&gt; &lt;strong&gt; &lt;code&gt;new&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="44d0ea0505e9226c704f669fb8bc795ba50b4d5f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They do not have &lt;code&gt;this&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Ellos no tienen &lt;code&gt;this&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="53b051204da25b8b824721699dd9120b211f117a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;They do not have arguments&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;No tienen argumentos&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8b2ea255e5af4354b8c68a41f7d152fc208cdcdf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Variadic functions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Funciones variadas&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c563dcc474c861f5d23de9ea9d74cffa69cd0598" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tl;dr:&lt;/strong&gt;&lt;strong&gt;No!&lt;/strong&gt; Arrow functions and function declarations / expressions are not equivalent and cannot be replaced blindly.</source>
          <target state="translated">&lt;strong&gt;tl; dr:&lt;/strong&gt; &lt;strong&gt;&amp;iexcl;No!&lt;/strong&gt; Las funciones de flecha y las declaraciones / expresiones de funci&amp;oacute;n no son equivalentes y no se pueden reemplazar a ciegas.</target>
        </trans-unit>
        <trans-unit id="9e4f3b712458b764fee0ab7a77547075362a776d" translate="yes" xml:space="preserve">
          <source>Are 'Arrow Functions' and 'Functions' equivalent / exchangeable</source>
          <target state="translated">Â¿Son las &quot;funciones de la flecha&quot; y las &quot;funciones&quot; equivalentes intercambiables</target>
        </trans-unit>
        <trans-unit id="097cd6bcfb4e1fe38807711e39cf37e85c2bc5a1" translate="yes" xml:space="preserve">
          <source>Arrow functions (and methods) are only callable.
&lt;code&gt;class&lt;/code&gt; constructors are only constructable.</source>
          <target state="translated">Las funciones de flecha (y m&amp;eacute;todos) solo son invocables. &lt;code&gt;class&lt;/code&gt; constructores de clase son solo construibles.</target>
        </trans-unit>
        <trans-unit id="81098c36bba344fc060ab84fa79bbfcf54aa2c3a" translate="yes" xml:space="preserve">
          <source>Arrow functions =&amp;gt; best ES6 feature so far. They are a tremendously
  powerful addition to ES6, that I use constantly.</source>
          <target state="translated">Funciones de flecha =&amp;gt; la mejor caracter&amp;iacute;stica de ES6 hasta ahora. Son una adici&amp;oacute;n tremendamente poderosa a ES6, que uso constantemente.</target>
        </trans-unit>
        <trans-unit id="2ed8af4386bde5001c11d3a6063d953a276e2650" translate="yes" xml:space="preserve">
          <source>Arrow functions can't be construtors because they do not have a prototype property.</source>
          <target state="translated">Las funciones de las flechas no pueden ser constructoras porque no tienen una propiedad de prototipo.</target>
        </trans-unit>
        <trans-unit id="db9f796ceaa44d107dd215efb7264dff6cf8dc8c" translate="yes" xml:space="preserve">
          <source>Arrow functions don&amp;rsquo;t have an arguments object. But the same
functionality can be achieved using rest parameters.</source>
          <target state="translated">Las funciones de flecha no tienen un objeto de argumentos. Pero se puede lograr la misma funcionalidad utilizando par&amp;aacute;metros de reposo.</target>
        </trans-unit>
        <trans-unit id="6ac7165f3dd26e2cdc228d4ea4202fc02f30e9e4" translate="yes" xml:space="preserve">
          <source>Arrow functions don't have their own &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;arguments&lt;/code&gt; binding. Instead, those identifiers are resolved in the lexical scope like any other variable. That means that inside an arrow function, &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; refer to the values of &lt;code&gt;this&lt;/code&gt; and &lt;code&gt;arguments&lt;/code&gt; in the environment the arrow function is &lt;em&gt;defined&lt;/em&gt; in (i.e. &quot;outside&quot; the arrow function):</source>
          <target state="translated">Las funciones de flecha no tienen su propio &lt;code&gt;this&lt;/code&gt; o &lt;code&gt;arguments&lt;/code&gt; vinculantes. En cambio, esos identificadores se resuelven en el &amp;aacute;mbito l&amp;eacute;xico como cualquier otra variable. Eso significa que dentro de una funci&amp;oacute;n de flecha, &lt;code&gt;this&lt;/code&gt; y los &lt;code&gt;arguments&lt;/code&gt; refieren a los valores de &lt;code&gt;this&lt;/code&gt; y los &lt;code&gt;arguments&lt;/code&gt; en el entorno en el que se &lt;em&gt;define la&lt;/em&gt; funci&amp;oacute;n de flecha (es decir, &quot;fuera&quot; de la funci&amp;oacute;n de flecha):</target>
        </trans-unit>
        <trans-unit id="4c46e5830c1a4417ff77a66df443155bef9ddaba" translate="yes" xml:space="preserve">
          <source>Arrow functions in ES2015 provide a more concise syntax.</source>
          <target state="translated">Las funciones de las flechas en ES2015 proporcionan una sintaxis mÃ¡s concisa.</target>
        </trans-unit>
        <trans-unit id="a349ca267127b5faf849c2f06a6f3ed14ab1572c" translate="yes" xml:space="preserve">
          <source>Arrow functions should NOT be used because:</source>
          <target state="translated">Las funciones de las flechas NO deben utilizarse porque:</target>
        </trans-unit>
        <trans-unit id="9b2bda921bc6b091d8d99377e4291396fbf26932" translate="yes" xml:space="preserve">
          <source>As so often: &lt;strong&gt;it depends&lt;/strong&gt;. Arrow functions have different behavior than function declarations / expressions, so let's have a look at the differences first:</source>
          <target state="translated">Como tan a menudo: &lt;strong&gt;depende&lt;/strong&gt; . Las funciones de flecha tienen un comportamiento diferente al de las declaraciones / expresiones de funci&amp;oacute;n, as&amp;iacute; que echemos un vistazo a las diferencias primero:</target>
        </trans-unit>
        <trans-unit id="807bece96fbabe4fd1884464fe2b6613508ddb00" translate="yes" xml:space="preserve">
          <source>But you can&amp;rsquo;t use an arrow function when a dynamic context is required: defining methods, create objects with constructors, get the target from this when handling events.</source>
          <target state="translated">Pero no puede usar una funci&amp;oacute;n de flecha cuando se requiere un contexto din&amp;aacute;mico: definir m&amp;eacute;todos, crear objetos con constructores, obtener el objetivo de esto cuando se manejan eventos.</target>
        </trans-unit>
        <trans-unit id="9fdc2cfe374fa5bde1e4e458854875e1709add1c" translate="yes" xml:space="preserve">
          <source>Callbacks</source>
          <target state="translated">Callbacks</target>
        </trans-unit>
        <trans-unit id="6f09b72943c02d70071365c301fbca77ddd1b8e1" translate="yes" xml:space="preserve">
          <source>Can I replace all my function declarations / expressions with arrow functions now?</source>
          <target state="translated">Â¿Puedo reemplazar ahora todas mis expresiones de declaraciones de funciones por funciones de flechas?</target>
        </trans-unit>
        <trans-unit id="b5c9417824a65aca8745057dafb4c034175cb1b9" translate="yes" xml:space="preserve">
          <source>Constructor function</source>
          <target state="translated">FunciÃ³n de constructor</target>
        </trans-unit>
        <trans-unit id="d14be1865dab7ff31185f4ebfd1097f17695a8ad" translate="yes" xml:space="preserve">
          <source>Constructor functions</source>
          <target state="translated">Funciones del constructor</target>
        </trans-unit>
        <trans-unit id="ad5a6954f7216fa7344299b97657bf4b6231f0ec" translate="yes" xml:space="preserve">
          <source>Do ES6 arrow functions have their own arguments or not?</source>
          <target state="translated">Â¿Las funciones de las flechas del ES6 tienen sus propios argumentos o no?</target>
        </trans-unit>
        <trans-unit id="f05b8d2d73b2c0c0e233f2ee97f7accee054b0d7" translate="yes" xml:space="preserve">
          <source>Don't use to add function as a property in object literal because we
can not access this.</source>
          <target state="translated">No utilice para aÃ±adir la funciÃ³n como una propiedad en el objeto literal porque no podemos acceder a esto.</target>
        </trans-unit>
        <trans-unit id="623f2a72fc475fa4b43aabb17036f57e8d86ea97" translate="yes" xml:space="preserve">
          <source>ES2015 distinguishes between functions that are &lt;em&gt;call&lt;/em&gt;able and functions that are &lt;em&gt;construct&lt;/em&gt;able. If a function is constructable, it can be called with  &lt;code&gt;new&lt;/code&gt;, i.e. &lt;code&gt;new User()&lt;/code&gt;. If a function is callable, it can be called without &lt;code&gt;new&lt;/code&gt; (i.e. normal function call).</source>
          <target state="translated">ES2015 distingue entre funciones que se pueden &lt;em&gt;llamar&lt;/em&gt; y funciones que se pueden &lt;em&gt;construir&lt;/em&gt; . Si una funci&amp;oacute;n es construible, se puede llamar con &lt;code&gt;new&lt;/code&gt; , es decir, &lt;code&gt;new User()&lt;/code&gt; . Si una funci&amp;oacute;n es invocable, se puede invocar sin &lt;code&gt;new&lt;/code&gt; (es decir, llamada a funci&amp;oacute;n normal).</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="49c2bd6aa6f23d62660e81e7508644de0747ce48" translate="yes" xml:space="preserve">
          <source>Expand snippet</source>
          <target state="translated">Ampliar fragmento</target>
        </trans-unit>
        <trans-unit id="b78884b7d6d3cd8b95d7b4912c7e6360c06df791" translate="yes" xml:space="preserve">
          <source>Function / methods added to a prototype (because they usually use &lt;code&gt;this&lt;/code&gt;)</source>
          <target state="translated">Funci&amp;oacute;n / m&amp;eacute;todos agregados a un prototipo (porque generalmente usan &lt;code&gt;this&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="393e528f5a84301cfcf4cbacaef7f7ff6975b56e" translate="yes" xml:space="preserve">
          <source>Function expressions are best for object methods. Arrow functions
are best for callbacks or methods like &lt;code&gt;map&lt;/code&gt;, &lt;code&gt;reduce&lt;/code&gt;, or &lt;code&gt;forEach&lt;/code&gt;.</source>
          <target state="translated">Las expresiones de funci&amp;oacute;n son mejores para los m&amp;eacute;todos de objeto. Las funciones de flecha son mejores para devoluciones de llamada o m&amp;eacute;todos como &lt;code&gt;map&lt;/code&gt; , &lt;code&gt;reduce&lt;/code&gt; o &lt;code&gt;forEach&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6362bcada6b07a59ecb435d4048f398f1bc4f0b6" translate="yes" xml:space="preserve">
          <source>Functions created through function declarations / expressions are both constructable and callable.</source>
          <target state="translated">Las funciones creadas a travÃ©s de las expresiones de declaraciÃ³n de funciones son tanto construibles como llamables.</target>
        </trans-unit>
        <trans-unit id="f1f9e5119ab138f8bbc10a925f0aa5467120f80d" translate="yes" xml:space="preserve">
          <source>Functions that are used with &lt;code&gt;.bind(this)&lt;/code&gt;</source>
          <target state="translated">Funciones que se usan con &lt;code&gt;.bind(this)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="456d3987ca295af904df154e6369d508e294988a" translate="yes" xml:space="preserve">
          <source>Functions that don't use &lt;code&gt;this&lt;/code&gt; or &lt;code&gt;arguments&lt;/code&gt;.</source>
          <target state="translated">Funciones que no usan &lt;code&gt;this&lt;/code&gt; o &lt;code&gt;arguments&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="477bc37237dcccfb60e8212ecf58c8cfd4777700" translate="yes" xml:space="preserve">
          <source>Further resources:</source>
          <target state="translated">MÃ¡s recursos:</target>
        </trans-unit>
        <trans-unit id="4e4c8f057232f689f7865d3560789790b7c4d3e2" translate="yes" xml:space="preserve">
          <source>How to use arrow functions (public class fields) as class methods?</source>
          <target state="translated">Â¿CÃ³mo utilizar las funciones de flecha (campos de clase pÃºblica)como mÃ©todos de clase?</target>
        </trans-unit>
        <trans-unit id="880597dc01da6cbbd55a0b71debfd54b7e7772d0" translate="yes" xml:space="preserve">
          <source>If the function you want to replace does &lt;em&gt;not&lt;/em&gt; use &lt;code&gt;this&lt;/code&gt;, &lt;code&gt;arguments&lt;/code&gt; and is not called with &lt;code&gt;new&lt;/code&gt;, then yes.</source>
          <target state="translated">Si la funci&amp;oacute;n que desea reemplazar &lt;em&gt;no&lt;/em&gt; usa &lt;code&gt;this&lt;/code&gt; , &lt;code&gt;arguments&lt;/code&gt; y no se llama con &lt;code&gt;new&lt;/code&gt; , entonces s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="350a68eb6569ce9ff1feb1188385b48380235995" translate="yes" xml:space="preserve">
          <source>If you are not very familiar with &lt;code&gt;this&lt;/code&gt;, consider reading</source>
          <target state="translated">Si no est&amp;aacute; muy familiarizado con &lt;code&gt;this&lt;/code&gt; , considere leer</target>
        </trans-unit>
        <trans-unit id="635a17ff7cb2fe460b7e86b6255fd21f47b485f3" translate="yes" xml:space="preserve">
          <source>If you are trying to call a non-callable function or to construct a non-constructable function, you will get a runtime error.</source>
          <target state="translated">Si intenta llamar una funciÃ³n no llamable o construir una funciÃ³n no construible,obtendrÃ¡ un error de tiempo de ejecuciÃ³n.</target>
        </trans-unit>
        <trans-unit id="2dff0492e38968e93907c861ade0d7967b3e7ebd" translate="yes" xml:space="preserve">
          <source>In the function expression case, &lt;code&gt;this&lt;/code&gt; refers to the object that was created inside the &lt;code&gt;createObject&lt;/code&gt;. In the arrow function case, &lt;code&gt;this&lt;/code&gt; refers to &lt;code&gt;this&lt;/code&gt; of &lt;code&gt;createObject&lt;/code&gt; itself.</source>
          <target state="translated">En el caso de la expresi&amp;oacute;n de funci&amp;oacute;n, &lt;code&gt;this&lt;/code&gt; refiere al objeto que se cre&amp;oacute; dentro del &lt;code&gt;createObject&lt;/code&gt; . En el caso de la funci&amp;oacute;n de flecha, &lt;code&gt;this&lt;/code&gt; refiere a &lt;code&gt;this&lt;/code&gt; de &lt;code&gt;createObject&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd42fee9d4f1683e06ea78dc3a83833b50ad5a21" translate="yes" xml:space="preserve">
          <source>It depends. You should definitely replace it if you are aliasing the outer &lt;code&gt;this&lt;/code&gt; or are using &lt;code&gt;.bind(this)&lt;/code&gt;:</source>
          <target state="translated">Depende. Definitivamente deber&amp;iacute;as reemplazarlo si est&amp;aacute;s aliasando el exterior &lt;code&gt;this&lt;/code&gt; o est&amp;aacute;s usando &lt;code&gt;.bind(this)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="595fd6ec76457623f2c972ea259758fc3a7b743b" translate="yes" xml:space="preserve">
          <source>It uses &amp;ldquo;lexical scoping&amp;rdquo; to figure out what the value of &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo;
should be. In simple word lexical scoping it uses &amp;ldquo;&lt;code&gt;this&lt;/code&gt;&amp;rdquo; from the
inside the function&amp;rsquo;s body.</source>
          <target state="translated">Utiliza el &quot;alcance l&amp;eacute;xico&quot; para determinar cu&amp;aacute;l deber&amp;iacute;a ser el valor de &quot; &lt;code&gt;this&lt;/code&gt; &quot;. En el &amp;aacute;mbito l&amp;eacute;xico simple de la palabra, utiliza &quot; &lt;code&gt;this&lt;/code&gt; &quot; desde el interior del cuerpo de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c476e80e1cdd58b7ace124f3c9a6375c30201c1a" translate="yes" xml:space="preserve">
          <source>Knowing this, we can state the following.</source>
          <target state="translated">Sabiendo esto,podemos afirmar lo siguiente.</target>
        </trans-unit>
        <trans-unit id="77fa39a269b43e0605dcbafa7542c4f7d73394a1" translate="yes" xml:space="preserve">
          <source>Lets have a closer look at this using your examples:</source>
          <target state="translated">Veamos esto mÃ¡s de cerca usando sus ejemplos:</target>
        </trans-unit>
        <trans-unit id="3c28b8d22d5c20da1ebd35b6a29c6adfb785832b" translate="yes" xml:space="preserve">
          <source>MDN - Arrow functions</source>
          <target state="translated">MDN-Funciones de la flecha</target>
        </trans-unit>
        <trans-unit id="645f17b142695c52e8daeb39d2e274b483222012" translate="yes" xml:space="preserve">
          <source>MDN - this</source>
          <target state="translated">MDN-esto</target>
        </trans-unit>
        <trans-unit id="55f205dca19e0070e2a06a80e90943c1dc8cdf0d" translate="yes" xml:space="preserve">
          <source>Most likely not, because prototype methods usually use &lt;code&gt;this&lt;/code&gt; to access the instance. If they don't use &lt;code&gt;this&lt;/code&gt;, then you can replace it. However, if you primarily care for concise syntax, use &lt;code&gt;class&lt;/code&gt; with its concise method syntax:</source>
          <target state="translated">Lo m&amp;aacute;s probable es que no, porque los m&amp;eacute;todos prototipo usualmente usan &lt;code&gt;this&lt;/code&gt; para acceder a la instancia. Si no usan &lt;code&gt;this&lt;/code&gt; , puede reemplazarlo. Sin embargo, si le interesa principalmente la sintaxis concisa, use &lt;code&gt;class&lt;/code&gt; con su sintaxis de m&amp;eacute;todo conciso:</target>
        </trans-unit>
        <trans-unit id="3cbdc79d3938eb210b07fab882dd77388e2e974d" translate="yes" xml:space="preserve">
          <source>Object (literal) methods</source>
          <target state="translated">MÃ©todos de objetos (literales)</target>
        </trans-unit>
        <trans-unit id="b46ce0e46e0605a9b2dee716fba3840e125bed96" translate="yes" xml:space="preserve">
          <source>Prototype methods</source>
          <target state="translated">MÃ©todos de prototipos</target>
        </trans-unit>
        <trans-unit id="d0dc8c8c213db6c4e484e26195b16c84bf3ee6b0" translate="yes" xml:space="preserve">
          <source>Related question:</source>
          <target state="translated">Pregunta relacionada:</target>
        </trans-unit>
        <trans-unit id="cf9cf80c8a1eaa83b42cd0d57c602fa3492f586c" translate="yes" xml:space="preserve">
          <source>Replaceable:</source>
          <target state="translated">Replaceable:</target>
        </trans-unit>
        <trans-unit id="8200d713d5ab8264a2587d88340955d674688d00" translate="yes" xml:space="preserve">
          <source>Similarly for methods in an object literal. If the method wants to reference the object itself via &lt;code&gt;this&lt;/code&gt;, keep using function expressions,  or use the new method syntax:</source>
          <target state="translated">Del mismo modo para los m&amp;eacute;todos en un objeto literal. Si el m&amp;eacute;todo quiere hacer referencia al objeto en s&amp;iacute; a trav&amp;eacute;s de &lt;code&gt;this&lt;/code&gt; , siga usando expresiones de funci&amp;oacute;n, o use la nueva sintaxis del m&amp;eacute;todo:</target>
        </trans-unit>
        <trans-unit id="cf9ecaafb20e6f09950bf5223447af4392e5fc4a" translate="yes" xml:space="preserve">
          <source>Since arrow functions don't have their own &lt;code&gt;arguments&lt;/code&gt;, you cannot simply replace them with an arrow  function. However, ES2015 introduces an alternative to using &lt;code&gt;arguments&lt;/code&gt;: the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;rest parameter&lt;/a&gt;.</source>
          <target state="translated">Dado que las funciones de flecha no tienen sus propios &lt;code&gt;arguments&lt;/code&gt; , no puede simplemente reemplazarlas con una funci&amp;oacute;n de flecha. Sin embargo, ES2015 introduce una alternativa al uso de &lt;code&gt;arguments&lt;/code&gt; : el &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters&quot;&gt;par&amp;aacute;metro rest&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="44aaadc5c82a80e98f3d0f7f3525ca8a69493dab" translate="yes" xml:space="preserve">
          <source>This makes arrow functions useful if you need to access the &lt;code&gt;this&lt;/code&gt; of the current environment:</source>
          <target state="translated">Esto hace que las funciones de flecha sean &amp;uacute;tiles si necesita acceder a &lt;code&gt;this&lt;/code&gt; del entorno actual:</target>
        </trans-unit>
        <trans-unit id="bd3dc93f2d622ead47798f6b55203b5a4306478d" translate="yes" xml:space="preserve">
          <source>This won't work because arrow functions cannot be called with &lt;code&gt;new&lt;/code&gt;. Keep using a function declaration / expression or use &lt;code&gt;class&lt;/code&gt;.</source>
          <target state="translated">Esto no funcionar&amp;aacute; porque las funciones de flecha no se pueden llamar con &lt;code&gt;new&lt;/code&gt; . Siga usando una declaraci&amp;oacute;n / expresi&amp;oacute;n de funci&amp;oacute;n o use &lt;code&gt;class&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72df882cfc7254f789055bbd609572ee19c64164" translate="yes" xml:space="preserve">
          <source>Use arrow functions for callbacks (because they tend to be terser).</source>
          <target state="translated">Usar las funciones de flecha para las llamadas de retorno (porque tienden a ser mÃ¡s largas).</target>
        </trans-unit>
        <trans-unit id="fc9d2febd3cd1f00231d4d46be4a69bd3c08aa8b" translate="yes" xml:space="preserve">
          <source>Use function declarations for functions you&amp;rsquo;d call by name (because
they&amp;rsquo;re hoisted).</source>
          <target state="translated">Use declaraciones de funciones para las funciones que llamar&amp;iacute;a por su nombre (porque est&amp;aacute;n izadas).</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">Funciones variadas</target>
        </trans-unit>
        <trans-unit id="30a2bf360c26bbff34c038deb577bf663a9c6b04" translate="yes" xml:space="preserve">
          <source>Variadic functions (if they use &lt;code&gt;arguments&lt;/code&gt; (see below))</source>
          <target state="translated">Funciones variables (si usan &lt;code&gt;arguments&lt;/code&gt; (ver m&amp;aacute;s abajo))</target>
        </trans-unit>
        <trans-unit id="4bc73dceb4900b103dec4371d6b793953d0c286b" translate="yes" xml:space="preserve">
          <source>Wait, you can't use arrow function everywhere in your code, its not going to work in all cases like &lt;code&gt;this&lt;/code&gt; where arrow functions are not usable. Without a doubt, the arrow function is a great addition it brings code simplicity.</source>
          <target state="translated">Espere, no puede usar la funci&amp;oacute;n de flecha en todas partes de su c&amp;oacute;digo, no funcionar&amp;aacute; en todos los casos como &lt;code&gt;this&lt;/code&gt; donde las funciones de flecha no son utilizables. Sin lugar a dudas, la funci&amp;oacute;n de flecha es una gran adici&amp;oacute;n que aporta simplicidad de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="53efc89aa69b93c640109759ad72fe527704ada4" translate="yes" xml:space="preserve">
          <source>What are the differences (if any) between ES6 arrow functions and functions bound with Function.prototype.bind?</source>
          <target state="translated">Â¿CuÃ¡les son las diferencias (si las hay)entre las funciones de las flechas del ES6 y las funciones vinculadas con Function.prototype.bind?</target>
        </trans-unit>
        <trans-unit id="6ecc2633f74ab15fa56773ce4d75cfd3a20a4109" translate="yes" xml:space="preserve">
          <source>What do I have to look out for?</source>
          <target state="translated">Â¿A quÃ© tengo que prestar atenciÃ³n?</target>
        </trans-unit>
        <trans-unit id="6efdd0660158859321165eadf5e588188a2b914c" translate="yes" xml:space="preserve">
          <source>When should I use Arrow functions in ECMAScript 6?</source>
          <target state="translated">Â¿CuÃ¡ndo debo usar las funciones de Flecha en ECMAScript 6?</target>
        </trans-unit>
        <trans-unit id="5b3c883bebe992d46fba10eba247117da34473e0" translate="yes" xml:space="preserve">
          <source>When to use arrow function and when not:</source>
          <target state="translated">CuÃ¡ndo usar la funciÃ³n de flecha y cuÃ¡ndo no:</target>
        </trans-unit>
        <trans-unit id="251aebdb1baaab67aa66626abaec6dcd0ed17728" translate="yes" xml:space="preserve">
          <source>YDKJS - Arrow functions</source>
          <target state="translated">YDKJS-Funciones de la flecha</target>
        </trans-unit>
        <trans-unit id="7ea5e2c1a61797ad69a9918d25ac545a4685999e" translate="yes" xml:space="preserve">
          <source>YDKJS - this &amp;amp; Object prototypes</source>
          <target state="translated">YDKJS - esto y prototipos de objetos</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
