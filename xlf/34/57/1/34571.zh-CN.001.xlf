<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="zh-CN" datatype="htmlbody" original="https://stackoverflow.com/questions/34571">
    <body>
      <group id="34571">
        <trans-unit id="f74e6e1dd54190d3d7fae8f5e96f21fb78828a1c" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;TargetClass.getDeclaredMethod(methodName, argClasses)&lt;/code&gt; lets you look into &lt;code&gt;private&lt;/code&gt; methods. The same thing applies for
  &lt;code&gt;getDeclaredField&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;1. &lt;/font&gt;&lt;/font&gt; &lt;code&gt;TargetClass.getDeclaredMethod(methodName, argClasses)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使您可以查看&lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同样的情况适用于 &lt;/font&gt;&lt;/font&gt; &lt;code&gt;getDeclaredField&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="f4cc2a945e6a4c9cbf53136a3c39c4f241d9f273" translate="yes" xml:space="preserve">
          <source>2. The &lt;code&gt;setAccessible(true)&lt;/code&gt; is required to play around with privates.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;2.必须使用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;setAccessible(true)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;才能与私人玩耍。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="80637c7eb7c5bf4678572b0409559fa57c032965" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BoundBox&lt;/strong&gt; makes it easy to test private/protected fields, methods and constructors. You can even access stuff that is hidden by inheritance. Indeed, BoundBox breaks encapsulation. It will give you access to all that through reflection, &lt;strong&gt;BUT&lt;/strong&gt; everything is checked at compile time.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用BoundBox&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;可以轻松测试私有/受保护的字段，方法和构造函数。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您甚至可以访问被继承隐藏的内容。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;实际上，BoundBox破坏了封装。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;通过反射，您可以访问所有内容，&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在编译时会检查所有内容。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="0c965907d2371e2e657952ec6ec3ce4cc3d0164e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling methods, e.g. &lt;code&gt;private void method(String s)&lt;/code&gt; - by Java reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;调用方法，例如 &lt;code&gt;private void method(String s)&lt;/code&gt; -通过Java反射&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aee3ea62516774cc4584c0e8794c9a0a9ff8a6b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling methods, e.g. &lt;code&gt;private void method(String s)&lt;/code&gt; - by Picklock&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;调用方法，例如 &lt;code&gt;private void method(String s)&lt;/code&gt; -通过Picklock&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="667a59955051009a0f32a003c2e1f6aeaf7043bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creating an SDK&lt;/strong&gt; for community
consumption. Here public takes on a
wholly different meaning, since this
is code that the whole world may see
(not just internal to my application). I put
code into private methods if I don't
want the SDK users to see it - I
don't see this as code smell, merely
as how SDK programming works. But of
course I still need to test my
private methods, and they are where
the functionality of my SDK actually
lives.</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建一个&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;供社区&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用的SDK&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这里的public具有完全不同的含义，因为这是全世界可能看到的代码（不仅仅是我的应用程序内部的代码）。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果我不希望SDK用户看到它，我会将代码放入私有方法中-我不认为这是代码的味道，仅是SDK编程的工作原理。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是当然我仍然需要测试我的私有方法，而这些正是我的SDK功能真正存在的地方。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="6b22ef7e1373ec5f2ed54ae4759f376b1b1ee360" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Decryption routines&lt;/strong&gt; - I would not
want to make them visible to anyone to see just for
the sake of testing, else anyone can
use them to decrypt. But they are
intrinsic to the code, complicated,
and need to always work (the obvious exception is reflection which can be used to view even private methods in most cases, when &lt;code&gt;SecurityManager&lt;/code&gt; is not configured to prevent this).</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解密例程&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -我不想让任何人看到它们只是为了进行测试，否则任何人都可以使用它们解密。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是它们是代码固有的，复杂的并且需要始终运行（明显的例外是反射，在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;没有配置&lt;/font&gt;&lt;/font&gt; &lt;code&gt;SecurityManager&lt;/code&gt; 的&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;情况下，反射在大多数情况下甚至可以用于查看私有方法&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ef937726101d6bbf1ea792d981c362dd127505c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00ccefff1cbb81b8564fd74ef5534ed942a1e40f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setting fields, e.g. &lt;code&gt;private BigInteger amount;&lt;/code&gt; - by Java reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;设置字段，例如， &lt;code&gt;private BigInteger amount;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;-通过Java反射&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4836ec35d6655b402cb0aeff0cc2d9be8bcd9902" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setting fields, e.g. &lt;code&gt;private BigInteger amount;&lt;/code&gt; - by Picklock&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;设置字段，例如， &lt;code&gt;private BigInteger amount;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;-通过Picklock&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a14ff6d0d2545a4fd033426dd9eb1bca74f4bd7" translate="yes" xml:space="preserve">
          <source>A private method is only to be accessed within the same class. So there is no way to test a &amp;ldquo;private&amp;rdquo; method of a target class from any test class. A way out is that you can perform unit testing manually or can change your method from &amp;ldquo;private&amp;rdquo; to &amp;ldquo;protected&amp;rdquo;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私有方法只能在同一类中访问。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，无法从任何测试类中测试目标类的&amp;ldquo;私有&amp;rdquo;方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;解决方法是您可以手动执行单元测试，也可以将方法从&amp;ldquo;专用&amp;rdquo;更改为&amp;ldquo;受保护&amp;rdquo;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c9f143cb14712f08a4e4970f0a574a82e563a424" translate="yes" xml:space="preserve">
          <source>Advantages:</source>
          <target state="translated">Advantages:</target>
        </trans-unit>
        <trans-unit id="2221efbf6965fac587b30d46e7724828ceb3edb5" translate="yes" xml:space="preserve">
          <source>And for fields:</source>
          <target state="translated">而对于田野来说。</target>
        </trans-unit>
        <trans-unit id="c8c30bf3f7e13ff579f2d44836856a1df45a19af" translate="yes" xml:space="preserve">
          <source>And then a protected method can only be accessed within the same package where the class is defined. So, testing a protected method of a target class means we need to define your test class in the same package as the target class.</source>
          <target state="translated">然后一个受保护的方法只能在定义类的同一个包内访问。所以,测试一个目标类的受保护方法意味着我们需要在目标类的同一个包中定义你的测试类。</target>
        </trans-unit>
        <trans-unit id="441792634ac4afd259f6c658a390705cde49193e" translate="yes" xml:space="preserve">
          <source>Another approach I have used is to change a private method to package private or protected then complement it with the &lt;strong&gt;@VisibleForTesting&lt;/strong&gt; annotation of the Google Guava library.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我使用的另一种方法是将私有方法更改为打包私有或受保护的程序，然后用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Google Guava库&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;@VisibleForTesting&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;批注&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;对其进行补充&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1301fc79049e7c65b4bbcf0ba6a61f5931687552" translate="yes" xml:space="preserve">
          <source>As many above have suggested, a good way is to test them via your public interfaces.</source>
          <target state="translated">正如上面很多人建议的,一个好的方法就是通过你的公共接口来测试。</target>
        </trans-unit>
        <trans-unit id="c13f7ca769cb85f3221127a40fbd5279f00e0fe7" translate="yes" xml:space="preserve">
          <source>As others have said... don't test private methods directly. Here are a few thoughts:</source>
          <target state="translated">就像别人说的那样...........不要直接测试私人的方法。这里有几个想法。</target>
        </trans-unit>
        <trans-unit id="00cf60dde25747bce8c2e44c6fa9ab92a1635c71" translate="yes" xml:space="preserve">
          <source>But if you must...</source>
          <target state="translated">但如果你一定要.....</target>
        </trans-unit>
        <trans-unit id="f0a8bb1ef2a081f480e91c8e34564927ff144af5" translate="yes" xml:space="preserve">
          <source>Can test to a finer granularity</source>
          <target state="translated">可以测试到更细的颗粒度</target>
        </trans-unit>
        <trans-unit id="0c069424ea8e8618c40b30af58a3b6dd3f06183b" translate="yes" xml:space="preserve">
          <source>Creating a test with access to private members and methods can test areas of code which are difficult to target specifically with access only to public methods. If a public method has several steps involved, it can consist of several private methods, which can then be tested individually.</source>
          <target state="translated">创建一个可以访问私有成员和方法的测试,可以测试只访问公共方法而难以具体针对的代码区域。如果一个公共方法涉及多个步骤,那么它可以由多个私有方法组成,然后可以对这些方法进行单独测试。</target>
        </trans-unit>
        <trans-unit id="c472a51872469dd7221cdb8ed81b476216096187" translate="yes" xml:space="preserve">
          <source>Disadvantages:</source>
          <target state="translated">Disadvantages:</target>
        </trans-unit>
        <trans-unit id="c9c9e5c85c1bd842957bfd2bf60f5c54670f8662" translate="yes" xml:space="preserve">
          <source>Don't test private methods.</source>
          <target state="translated">不要测试私人的方法。</target>
        </trans-unit>
        <trans-unit id="da1688d4291f35c06929635ff89a47756bee4936" translate="yes" xml:space="preserve">
          <source>First, I'll throw this question out: Why do your private members need isolated testing? Are they that complex, providing such complicated behaviors as to require testing apart from the public surface? It's unit testing, not 'line-of-code' testing. Don't sweat the small stuff.</source>
          <target state="translated">首先,我抛出这个问题。为什么你的私人会员需要隔离测试?它们有那么复杂吗,提供如此复杂的行为,需要在公共表面之外进行测试吗?这是单元测试,不是 &quot;代码行 &quot;测试。不要把小东西放在心上。</target>
        </trans-unit>
        <trans-unit id="488ba946d622fc383a6720a0de399a291c4a6365" translate="yes" xml:space="preserve">
          <source>For example, if a method to be tested is in &lt;code&gt;src/main/java/mypackage/MyClass.java&lt;/code&gt; then your test call should be placed in &lt;code&gt;src/test/java/mypackage/MyClassTest.java&lt;/code&gt;. That way, you got access to the test method in your test class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，如果要测试的方法在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;src/main/java/mypackage/MyClass.java&lt;/code&gt; 中,&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;则您的测试调用应放在&lt;/font&gt;&lt;/font&gt; &lt;code&gt;src/test/java/mypackage/MyClassTest.java&lt;/code&gt; 中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样，您就可以访问测试类中的测试方法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例如:</target>
        </trans-unit>
        <trans-unit id="c046b725299d827b1b1cfbff5b6ff9701d5b447f" translate="yes" xml:space="preserve">
          <source>From this article: &lt;a href=&quot;http://www.artima.com/suiterunner/private.html&quot;&gt;Testing Private Methods with JUnit and SuiteRunner&lt;/a&gt; (Bill Venners), you basically have 4 options:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;从本文开始：&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.artima.com/suiterunner/private.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用JUnit和SuiteRunner测试私有方法&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（Bill Venners），您基本上有4个选择：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="ae8c15b3105382053e62cc365916933eb7995b28" translate="yes" xml:space="preserve">
          <source>Generally a unit test is intended to exercise the public interface of a class or unit. Therefore, private methods are implementation detail that you would not expect to test explicitly.</source>
          <target state="translated">一般来说,单元测试的目的是锻炼类或单元的公共接口。因此,私有方法是实现细节,你不会想到要明文测试。</target>
        </trans-unit>
        <trans-unit id="21f944c5c0cd9b55951029e9c48346ad8ecaccfc" translate="yes" xml:space="preserve">
          <source>Give the methods package access.</source>
          <target state="translated">赋予方法包访问权限。</target>
        </trans-unit>
        <trans-unit id="3ea99547c530ccc60cd2d951a1059ecc58a082c9" translate="yes" xml:space="preserve">
          <source>Having tried Cem Catikkas' &lt;a href=&quot;https://stackoverflow.com/questions/34571/whats-the-best-way-of-unit-testing-private-methods#34658&quot;&gt;solution using reflection&lt;/a&gt; for Java, I'd have to say his was a more elegant solution than I have described here. However, if you're looking for an alternative to using reflection, and have access to the source you're testing, this will still be an option.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在尝试使用Cem Catikkas的&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java &lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/34571/whats-the-best-way-of-unit-testing-private-methods#34658&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反射解决方案后&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，我不得不说他的解决方案比我在此描述的更为优雅。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;但是，如果您正在寻找使用反射的替代方法，并且可以访问要测试的源，则仍然可以选择。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="738ac079cb2720eec3fc2ea83fa03d06c4e24357" translate="yes" xml:space="preserve">
          <source>Here is a convoluted example of how this would work:</source>
          <target state="translated">下面是一个迂回曲折的例子。</target>
        </trans-unit>
        <trans-unit id="bad99404aed0664a20ca51067abe49d23d05a388" translate="yes" xml:space="preserve">
          <source>Here is my generic function to test private fields:</source>
          <target state="translated">以下是我的通用函数,用于测试私有字段。</target>
        </trans-unit>
        <trans-unit id="cf1020a5e41eab9e99f445355aec8da27a8d8c7f" translate="yes" xml:space="preserve">
          <source>How do I test a private function or a class that has private methods, fields or inner classes</source>
          <target state="translated">如何测试一个私有函数或有私有方法、字段或内部类的类?</target>
        </trans-unit>
        <trans-unit id="0de14c706b029a054d6bb30db817984dba502ac6" translate="yes" xml:space="preserve">
          <source>How do I unit test (using xUnit) a class that has internal private methods, fields or nested classes? Or a function that is made private by having &lt;a href=&quot;https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage&quot;&gt;internal linkage&lt;/a&gt; (&lt;code&gt;static&lt;/code&gt; in C/C++) or is in a private (&lt;a href=&quot;https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions&quot;&gt;anonymous&lt;/a&gt;) namespace?</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如何对具有内部私有方法，字段或嵌套类的类进行单元测试（使用xUnit）？&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;还是通过&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内部链接&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在C / C ++中为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;static&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）或在私有（&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;匿名&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;）名称空间中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使其私有化的函数&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;？&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="bc255ea980bb0a2a256131036675cc23632ebedb" translate="yes" xml:space="preserve">
          <source>However, if continuous testing requires this method, it may be a signal that the private methods should be extracted, which could be tested in the traditional, public way.</source>
          <target state="translated">但是,如果连续测试需要这种方法的话,可能是一个信号,需要提取私有的方法,可以用传统的、公开的方式进行测试。</target>
        </trans-unit>
        <trans-unit id="e4ab4d98c5b0b5ae62722cd5daba84f9fc5d09e2" translate="yes" xml:space="preserve">
          <source>I have used &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt; to do this for Java in the past, and in my opinion it was a big mistake.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;过去，&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我曾使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反射&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来为Java做到这一点，我认为这是一个很大的错误。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b3f669f5a4850db8ae087533d316d74f7d18ef39" translate="yes" xml:space="preserve">
          <source>I personally believe it is better to create classes using TDD; creating the public method stubs, then generating unit tests with &lt;strong&gt;all&lt;/strong&gt; the assertions defined in advance, so the expected outcome of the method is determined before you code it. This way, you don't go down the wrong path of making the unit test assertions fit the results. Your class is then robust and meets requirements when all your unit tests pass.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我个人认为最好使用TDD创建类。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;创建公共方法存根，然后使用&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;预先定义的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;所有&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;断言&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;生成单元测试&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，因此在对代码进行编码之前，应确定该方法的预期结果。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样，您就不会沿着使单元测试断言适合结果的错误道路走下去。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这样，您的课程将变得很健壮，并在所有单元测试通过后都达到要求。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e36b52cb9fdfbb3e329d1441d178206837d71b2c" translate="yes" xml:space="preserve">
          <source>I recently had this problem and wrote a little tool, called &lt;a href=&quot;https://github.com/almondtools/picklock&quot;&gt;Picklock&lt;/a&gt;, that avoids the problems of explicitly using the Java reflection API, two examples:</source>
          <target state="translated">我最近遇到了这个问题，并编写了一个名为&lt;a href=&quot;https://github.com/almondtools/picklock&quot;&gt;Picklock&lt;/a&gt;的小工具，它避免了显式使用Java反射API的问题，这是两个示例：</target>
        </trans-unit>
        <trans-unit id="7d99726e2e6121e3f90a851753d372ae38b3621b" translate="yes" xml:space="preserve">
          <source>I tend not to test private methods.  There lies madness.  Personally, I believe you should only test your publicly exposed interfaces (and that includes protected and internal methods).</source>
          <target state="translated">我倾向于不测试私人的方法。这就是疯狂的地方。就我个人而言,我认为你应该只测试你公开暴露的接口(包括受保护的和内部方法)。</target>
        </trans-unit>
        <trans-unit id="5f07dd3769ec6c1f05bf2a35c0526f8b0b85e8f1" translate="yes" xml:space="preserve">
          <source>I understand the idea of only testing the &quot;contract&quot;. But I don't see one can advocate actually not testing code - your mileage may vary.</source>
          <target state="translated">我理解只测试 &quot;合同 &quot;的想法。但我不认为有人可以主张实际上不测试代码--你的里程可能会有差异。</target>
        </trans-unit>
        <trans-unit id="86ef42a47a405d6ea0d40445563542edd3714ab0" translate="yes" xml:space="preserve">
          <source>I use the &lt;strong&gt;junitx.util.PrivateAccessor&lt;/strong&gt;-package for Java . Lots of helpful one-liners for accessing private methods and private fields.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我将&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;junitx.util.PrivateAccessor -package&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;用于Java。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;访问私有方法和私有字段的大量有用的一线工具。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="42bb9d6ad7029d11852bf236c965500fd6aeb10a" translate="yes" xml:space="preserve">
          <source>I would suggest you refactoring your code a little bit. When you have to start thinking about using reflection or other kind of stuff, for just testing your code, something is going wrong with your code.</source>
          <target state="translated">我建议你重构一下你的代码。当你不得不开始考虑使用反射或其他类型的东西,只是为了测试你的代码时,你的代码就有问题了。</target>
        </trans-unit>
        <trans-unit id="e5c18c5a0c0257d22e6651f930fb4b67ab6d6430" translate="yes" xml:space="preserve">
          <source>I'd have used this:</source>
          <target state="translated">我本来是要用这个的。</target>
        </trans-unit>
        <trans-unit id="856f0a021ec6929f0585d3353794587bc738b479" translate="yes" xml:space="preserve">
          <source>If all the above does not suits your requirement, use &lt;a href=&quot;https://stackoverflow.com/questions/11483647/how-to-access-private-methods-and-private-data-members-via-reflection&quot;&gt;&lt;strong&gt;the  reflection way&lt;/strong&gt;&lt;/a&gt; to access the private method.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果以上都不符合您的要求，请使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/questions/11483647/how-to-access-private-methods-and-private-data-members-via-reflection&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;反射方式&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;访问私有方法。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2908c85ab8d5229462900d545e121dbae5bc5f33" translate="yes" xml:space="preserve">
          <source>If refactoring is inappropriate or infeasible, can you use the strategy pattern to replace access to these private member functions / member classes when under unit test? Under unit test, the strategy would provide added validation, but in release builds it would be simple passthrough.</source>
          <target state="translated">如果重构不合适或不可行,在单元测试时,是否可以使用策略模式来替换对这些私有成员函数成员类的访问?在单元测试下,策略将提供额外的验证,但在发布版本构建中,它将是简单的穿透。</target>
        </trans-unit>
        <trans-unit id="b50c21d867d9f45732d608b976f552d6b804fae5" translate="yes" xml:space="preserve">
          <source>If the class's design is still flexible, and you've got a complicated private method that you'd like to test separately, I suggest you pull it out into a separate class and test that class separately. This doesn't have to change the public interface of the original class; it can internally create an instance of the helper class and call the helper method.</source>
          <target state="translated">如果类的设计还算灵活,如果你有一个复杂的私有方法,想单独测试,我建议你把它拉到一个单独的类里,单独测试这个类。这不一定要改变原来类的公共接口,可以在内部创建一个帮助类的实例,然后调用帮助类的方法。</target>
        </trans-unit>
        <trans-unit id="f91aaf05eb0d0047f2110ff5981712e3f94e2098" translate="yes" xml:space="preserve">
          <source>If they are that big, big enough that these private members are each a 'unit' large in complexity -- consider refactoring such private members out of this class.</source>
          <target state="translated">如果它们有那么大,大到这些私有成员每个人都是一个复杂的 &quot;单位&quot;----考虑把这些私有成员从这个类中重新构思出来。</target>
        </trans-unit>
        <trans-unit id="afa066ad607390e7196812b766cdf27e86c8c154" translate="yes" xml:space="preserve">
          <source>If using Spring, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/util/ReflectionTestUtils.html&quot;&gt;ReflectionTestUtils&lt;/a&gt; provides some handy tools that help out here with minimal effort. For example, to set up a mock on a private member without being forced to add an undesirable public setter:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果使用Spring，&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/util/ReflectionTestUtils.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;ReflectionTestUtils&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;提供了一些方便的工具，可以在&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不费吹灰之力的情况下&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;为您提供帮助。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;例如，在不强制添加不受欢迎的公共二传手的情况下在私有成员上设置模拟：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="83193c16ef655f324fc282cd1969a12136199cf8" translate="yes" xml:space="preserve">
          <source>If you are using JDK 1.3 or higher, you can use reflection to subvert
  the access control mechanism with the aid of the &lt;a href=&quot;http://sourceforge.net/projects/privaccessor/&quot;&gt;PrivilegedAccessor&lt;/a&gt;.
  For details on how to use it, read &lt;a href=&quot;http://www.onjava.com/pub/a/onjava/2003/11/12/reflection.html&quot;&gt;this article&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您使用的是JDK 1.3或更高版本，则可以在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://sourceforge.net/projects/privaccessor/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;PrivilegedAccessor&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的帮助下使用反射来破坏访问控制机制&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关如何使用它的详细信息，请阅读&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://www.onjava.com/pub/a/onjava/2003/11/12/reflection.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;本文&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="82c0d1bf8945f5975a8f462f666b9a4e0e5e127d" translate="yes" xml:space="preserve">
          <source>If you are using JDK 1.6 or higher and you annotate your tests with
  @Test, you can use &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt; to inject reflection in your test methods. For
  details on how to use it, see &lt;a href=&quot;http://dp4j.com/testscript&quot;&gt;this test script&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果使用的是JDK 1.6或更高版本，并且使用@Test注释测试，则可以使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://dp4j.com&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dp4j&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在测试方法中注入反射。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;有关如何使用它的详细信息，请参见此&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://dp4j.com/testscript&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;测试脚本&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2b31f8facdbfd1bfa9d19d56f79ad1c75fa0d34e" translate="yes" xml:space="preserve">
          <source>If you do this, it's a good idea to use a code coverage tool (like Emma) to see if your private methods are in fact being executed from your tests.</source>
          <target state="translated">如果你这样做,最好用一个代码覆盖工具(比如Emma)来查看你的私有方法是否真的从你的测试中执行。</target>
        </trans-unit>
        <trans-unit id="231ced4c5a18aefc12b359da49c26b919a67fbb9" translate="yes" xml:space="preserve">
          <source>If you got some code with private methods or fields or constructors, you can use &lt;a href=&quot;https://github.com/stephanenicolas/boundbox&quot;&gt;&lt;strong&gt;BoundBox&lt;/strong&gt;&lt;/a&gt;. It does exactly what you are looking for.
Here below is an example of a test that accesses two private fields of an Android activity to test it:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您有一些带有私有方法，字段或构造函数的代码，则可以使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/stephanenicolas/boundbox&quot;&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;BoundBox&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它确实满足您的需求。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以下是一个测试示例，该示例访问一个Android活动的两个私有字段进行测试：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="c79881c26b4f45425fd6ff0dd1d27b095fb2240a" translate="yes" xml:space="preserve">
          <source>If you have somewhat of a legacy &lt;strong&gt;Java&lt;/strong&gt; application, and you're not allowed to change the visibility of your methods, the best way to test private methods is to use &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您使用的是旧版&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应用程序，并且不允许更改方法的可见性，那么测试私有方法的最佳方法是使用&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Reflection&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b48c353a1610aa6f526142112c3e4e924cf08d8d" translate="yes" xml:space="preserve">
          <source>If you want to test difficult error conditions coming from the helper method, you can go a step further. Extract an interface from the helper class, add a public getter and setter to the original class to inject the helper class (used through its interface), and then inject a mock version of the helper class into the original class to test how the original class responds to exceptions from the helper. This approach is also helpful if you want to test the original class without also testing the helper class.</source>
          <target state="translated">如果你想测试来自帮助类方法的困难错误条件,你可以再进一步。从辅助类中提取一个接口,在原类中添加一个公共getter和setter来注入辅助类(通过它的接口使用),然后在原类中注入一个模拟版的辅助类,测试原类如何响应来自辅助类的异常。如果你想测试原始类而不同时测试帮助器类,这种方法也很有帮助。</target>
        </trans-unit>
        <trans-unit id="fe75670323f07c2b037bcc439be60b5d49e84c28" translate="yes" xml:space="preserve">
          <source>If you want to test private methods of a legacy application where you can't change the code, one option for Java is &lt;a href=&quot;http://code.google.com/p/jmockit/&quot;&gt;jMockit&lt;/a&gt;, which will allow you to create mocks to an object even when they're private to the class.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果要在无法更改代码的情况下测试旧版应用程序的私有方法，则Java的一个选项是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://code.google.com/p/jmockit/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;jMockit&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，即使您是对象的私有类，也可以使用它来创建对象的对象。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="72e52fa6e1a9545b518febc8820865af20b96e14" translate="yes" xml:space="preserve">
          <source>If you're trying to test existing code that you're reluctant or unable to change, reflection is a good choice.</source>
          <target state="translated">如果你想测试现有的代码,而又不愿意或无法改变,那么反射是个不错的选择。</target>
        </trans-unit>
        <trans-unit id="d792406ad753323d672f9c3416735627210a6784" translate="yes" xml:space="preserve">
          <source>If you're using JUnit, have a look at &lt;a href=&quot;http://junit-addons.sourceforge.net/&quot;&gt;junit-addons&lt;/a&gt;. It has the ability to ignore the Java security model and access private methods and attributes.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您使用的是JUnit，请查看&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://junit-addons.sourceforge.net/&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;junit-addons&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;它具有忽略Java安全模型并访问私有方法和属性的能力。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="d28be3040a66843e9a8b31893a7a596588eb062b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://en.wikipedia.org/wiki/Spring_Framework&quot;&gt;Spring Framework&lt;/a&gt; you can test private methods using this method:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Spring_Framework&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Spring Framework中，&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您可以使用以下方法测试私有方法：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1fc74da23c19b1981c07b1448e7f5db47a487f28" translate="yes" xml:space="preserve">
          <source>Internally we're using helpers to get/set &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;private static&lt;/code&gt; variables as well as invoke &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;private static&lt;/code&gt; methods. The following patterns will let you do pretty much anything related to the private methods and fields. Of course, you can't change &lt;code&gt;private static final&lt;/code&gt; variables through reflection.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在内部，我们使用助手来获取/设置&lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量，以及调用&lt;/font&gt;&lt;/font&gt; &lt;code&gt;private&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;和&lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以下模式将使您几乎可以执行与私有方法和字段相关的所有操作。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;当然，您&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不能通过反射&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;更改&lt;/font&gt;&lt;/font&gt; &lt;code&gt;private static final&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;变量。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="9ced52e68cb80f32738bfe343adbf16629c4c90b" translate="yes" xml:space="preserve">
          <source>It is ideal for testing some legacy code. Use it carefully. ;)</source>
          <target state="translated">它是测试一些传统代码的理想选择。谨慎使用它。)</target>
        </trans-unit>
        <trans-unit id="2fa9f5af925c4287d94f324d2dd236645502165a" translate="yes" xml:space="preserve">
          <source>It seems bad to change the access modifier for a method or function just to be able to run a test.</source>
          <target state="translated">仅仅为了能够运行测试而改变方法或函数的访问修改器,似乎是不好的。</target>
        </trans-unit>
        <trans-unit id="e654ed1f3d726168497b0172d3d23035e3917b98" translate="yes" xml:space="preserve">
          <source>Just two examples of where I would want to test a private method:</source>
          <target state="translated">只是两个例子,我想在哪里测试一个私人的方法。</target>
        </trans-unit>
        <trans-unit id="d4e47f0274a3c52708f822a10e289c3e99775b5d" translate="yes" xml:space="preserve">
          <source>Keep all methods small and focused (easy to test, easy to find what is wrong)</source>
          <target state="translated">所有的方法要少而精(容易测试,容易发现问题的地方)。</target>
        </trans-unit>
        <trans-unit id="9adf46953726191943242b998a6a02cbbf4fca14" translate="yes" xml:space="preserve">
          <source>Mostly all that I wrote looks like it's a dependency injection pattern. In my personal experience it's really useful while testing, and I think that this kind of code is cleaner and will be easier to maintain. I'd say the same about nested classes. If a nested class contains heavy logic it would be better if you'd moved it as a package private class and have injected it into a class needing it.</source>
          <target state="translated">主要是我写的那些看起来都是依赖注入模式。就我个人的经验来说,在测试的时候真的很有用,我觉得这样的代码比较干净,也会更容易维护。关于嵌套类,我也是这么说的。如果一个嵌套类包含重逻辑的话,如果你把它作为包私有类移到需要它的类中,并将其注入到需要它的类中,效果会更好。</target>
        </trans-unit>
        <trans-unit id="30205722f087baf2291cb886209e83bbd9803fe4" translate="yes" xml:space="preserve">
          <source>My usual approach to addressing such issues is to tease out a new class that contains the interesting bits.  Often, this method and the fields it interacts with, and maybe another method or two can be extracted in to a new class.</source>
          <target state="translated">我通常采用的方法是,在处理这类问题的时候,我通常的方法是挑出一个新的类,其中包含有趣的部分。通常情况下,这个方法和它所交互的字段,也许还可以提取出另一两个方法到一个新的类中。</target>
        </trans-unit>
        <trans-unit id="2dc80e7fd583fd5394b42b7828b62bcf68608597" translate="yes" xml:space="preserve">
          <source>Note that I'm not suggesting that people create classes without using their brain! The point here is to use the forces of unit testing to help you find good new classes.</source>
          <target state="translated">注意,我并不是建议大家在创建类的时候不动脑筋就创建类! 这里的重点是利用单元测试的力量来帮助你找到好的新类。</target>
        </trans-unit>
        <trans-unit id="2fe26b2c16fe9cee75070a2fc030c171634bc7bf" translate="yes" xml:space="preserve">
          <source>Now about private methods. In my personal experience when you have to stub a private method for testing, then that method has nothing to do in that class. A common pattern, in that case, would be to &lt;em&gt;wrap&lt;/em&gt; it within an interface, like &lt;code&gt;Callable&lt;/code&gt; and then you pass in that interface also in the constructor (with that multiple constructor trick):</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在介绍私有方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;以我的个人经验，当您必须使用私有方法进行测试时，则该方法与该类无关。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在这种情况下，一种常见的模式是将其&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;包装&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;在接口（如&lt;/font&gt;&lt;/font&gt; &lt;code&gt;Callable&lt;/code&gt; )中&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，然后在构造函数中传递该接口（带有多个构造函数的技巧）：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="777cc4ad4d28cf7c02b892fe5111983c770aebf9" translate="yes" xml:space="preserve">
          <source>Now you can directly pass the object which has the private method, method name to be called, and additional parameters as below.</source>
          <target state="translated">现在你可以直接传递对象,该对象有私有方法、方法名称和附加参数,如下图所示。</target>
        </trans-unit>
        <trans-unit id="49a4661efd1819dad49a68ff125c5dfdef8c3ea9" translate="yes" xml:space="preserve">
          <source>P.S. I'm the main contributor to &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt;, ask &lt;a href=&quot;https://stackoverflow.com/users/300248&quot;&gt;me&lt;/a&gt; if you need help. :)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;附注：我是&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://dp4j.com&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Dp4j&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的主要贡献者&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，请问&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://stackoverflow.com/users/300248&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;是否需要帮助。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;:)&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="5f43d2331301eb02496c0c805bc3f87c3a2c7307" translate="yes" xml:space="preserve">
          <source>Please see below for an example;</source>
          <target state="translated">请看下面的例子。</target>
        </trans-unit>
        <trans-unit id="5fe8c532739285df240daf07b928efebea907d0a" translate="yes" xml:space="preserve">
          <source>PowerMockito is made for this.
Use maven dependency</source>
          <target state="translated">PowerMockito就是为此而生。使用maven依赖关系</target>
        </trans-unit>
        <trans-unit id="497baeb3b5ee74d2b4d986eb47ed0293a6ada2a0" translate="yes" xml:space="preserve">
          <source>Private methods are consumed by public ones. Otherwise, they're dead code. That's why you test the public method, asserting the expected results of the public method and thereby, the private methods it consumes.</source>
          <target state="translated">私有的方法被公有的方法所消耗。否则,它们就是死代码。这就是为什么要测试公有方法,断言公有方法的预期结果,从而断言它所消耗的私有方法。</target>
        </trans-unit>
        <trans-unit id="83d6d608b54d120b904dee27b0513327bd8a3adc" translate="yes" xml:space="preserve">
          <source>Run the code coverage on the unit tests. If you see that methods are not fully tested add to the tests to get the coverage up. Aim for 100% code coverage, but realize that you probably won't get it.</source>
          <target state="translated">在单元测试中运行代码覆盖率。如果你发现方法没有被完全测试过,那么就在测试中加入一些方法,以提高覆盖率。以100%的代码覆盖率为目标,但要意识到你可能无法达到。</target>
        </trans-unit>
        <trans-unit id="f33de1aa1bafbeb284338b42c053c4ecb4dbcf05" translate="yes" xml:space="preserve">
          <source>See also: &lt;em&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/javatips/jw-javatip106.html&quot;&gt;Java Tip 106: Static inner classes for fun and profit&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;另请参见：&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/javatips/jw-javatip106.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Java技巧106：获取乐趣和收益的静态内部类&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b710af9a932bb8b3407780d42ea95e9d3c2c9c68" translate="yes" xml:space="preserve">
          <source>Similarly with .class output files, they must remain within the same package as declared in source code</source>
          <target state="translated">同样,对于.class输出文件,它们必须保持在源代码中声明的同一个包中。</target>
        </trans-unit>
        <trans-unit id="40ef678cea4286c297bccc879a9c3c11a47c9b03" translate="yes" xml:space="preserve">
          <source>So don't test private methods.</source>
          <target state="translated">所以,不要测试私下的方法。</target>
        </trans-unit>
        <trans-unit id="204733d7cb2b813d677976ecf1b798415058621d" translate="yes" xml:space="preserve">
          <source>So my tradeoff involves complicating the JUnits with reflection, rather than compromising my security &amp;amp; SDK.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;因此，我的权衡包括通过反射使JUnit复杂化，而不是损害我的安全性和SDK。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="1dc726b4f0600a6162d0a5fec0ac442b107c4f85" translate="yes" xml:space="preserve">
          <source>Some 10 years later perhaps the best way to test a private method, or any inaccessible member, is via &lt;strong&gt;&lt;code&gt;@Jailbreak&lt;/code&gt;&lt;/strong&gt; from the &lt;a href=&quot;https://manifold.systems&quot;&gt;Manifold&lt;/a&gt; framework.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;大约十年后，测试私有方法或任何无法访问的成员的最佳方法可能是&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来自&lt;/font&gt;&lt;a href=&quot;https://manifold.systems&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Manifold&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;框架的&lt;/font&gt;&lt;/font&gt;&lt;strong&gt; &lt;code&gt;@Jailbreak&lt;/code&gt; &lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="93fcf1e45142f4bf2b769ec5b5d2448cc5a335d7" translate="yes" xml:space="preserve">
          <source>Strictly speaking, you should &lt;em&gt;not&lt;/em&gt; be writing unit tests that directly test private methods. What you &lt;em&gt;should&lt;/em&gt; be testing is the public contract that the class has with other objects; you should never directly test an object's internals. If another developer wants to make a small internal change to the class, which doesn't affect the classes public contract, he/she then has to modify your reflection based test to ensure that it works. If you do this repeatedly throughout a project, unit tests then stop being a useful measurement of code health, and start to become a hindrance to development, and an annoyance to the development team.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;严格地说，应该&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;不会&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;被编写单元测试直接测试私有方法。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;应该&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;测试的是该类与其他对象之间的公共合同；&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;您永远不要直接测试对象的内部。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果另一个开发人员想要对该类进行小的内部更改，而不影响该类的公共合同，则他/她必须修改您基于反射的测试以确保它可以工作。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;如果您在整个项目中重复执行此操作，则单元测试将不再是对代码运行状况的有用衡量，并开始成为开发的障碍和开发团队的烦恼。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="e60b23b6cc258fd2f3050f01d48f369e96d22536" translate="yes" xml:space="preserve">
          <source>Test code must reside in the same
file as source code, which can be
more difficult to maintain</source>
          <target state="translated">测试代码必须与源代码同在一个文件中,这可能更难维护</target>
        </trans-unit>
        <trans-unit id="e628bb4ef6d2f95c51a2e0fabdc7e6570882e841" translate="yes" xml:space="preserve">
          <source>Testing private methods breaks the encapsulation of your class because every time you change the internal implementation you break client code (in this case, the tests).</source>
          <target state="translated">测试私有化方法会破坏类的封装,因为每当你改变内部实现时,你就会破坏客户机代码(在本例中,测试)。</target>
        </trans-unit>
        <trans-unit id="b08d94828e924f3c44bdad7d49d7a9e8126f9b82" translate="yes" xml:space="preserve">
          <source>Testing private methods should be tested by debugging before running your unit tests on public methods.</source>
          <target state="translated">测试私有方法时,应该先通过调试来测试私有方法,然后再对公共方法进行单元测试。</target>
        </trans-unit>
        <trans-unit id="99ac885a2c04ce23f9e9dee57055ba4db55f0ba2" translate="yes" xml:space="preserve">
          <source>The answer from &lt;a href=&quot;http://junit.org/faq.html#atests_11&quot;&gt;JUnit.org FAQ page&lt;/a&gt;:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;来自&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://junit.org/faq.html#atests_11&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;JUnit.org常见问题页面&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;的答案&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;：&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="612f347cc8d13e68510dabfe438c3934b0e32ab6" translate="yes" xml:space="preserve">
          <source>The best way to test a private method is via another public method. If this cannot be done, then one of the following conditions is true:</source>
          <target state="translated">测试一个私有方法的最好方法是通过另一个公共方法。如果不能做到这一点,那么以下条件之一是真的。</target>
        </trans-unit>
        <trans-unit id="bd734d3c315faa6945e06b553d5414ada763a534" translate="yes" xml:space="preserve">
          <source>The following import statement should be added:</source>
          <target state="translated">应增加以下进口声明:</target>
        </trans-unit>
        <trans-unit id="85834fcc9380e9b0ac91e5af41b0a87baae505d9" translate="yes" xml:space="preserve">
          <source>The inner class would be compiled to &lt;code&gt;ClassToTest$StaticInnerTest&lt;/code&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;内部类将被编译为&lt;/font&gt;&lt;/font&gt; &lt;code&gt;ClassToTest$StaticInnerTest&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fe9916a66d8aaef8076e5a9c5eb90320bb058a1d" translate="yes" xml:space="preserve">
          <source>The method that you are trying to test should not be private</source>
          <target state="translated">你要测试的方法不应该是私有的。</target>
        </trans-unit>
        <trans-unit id="9660255e33ec7d540aff4829d9d77f76b4f97dd1" translate="yes" xml:space="preserve">
          <source>The new class exposes these methods as 'public', so they're accessible for unit testing.  The new and old classes are now both simpler than the original class, which is great for me (I need to keep things simple, or I get lost!).</source>
          <target state="translated">新类将这些方法公开为 &quot;公共&quot;,所以它们可以用于单元测试。现在新类和旧类都比原来的类简单,这对我来说很好(我需要保持简单,否则会迷路!)。</target>
        </trans-unit>
        <trans-unit id="e7a5f083811631d013af462cec5f70ee62d8c80c" translate="yes" xml:space="preserve">
          <source>The private method is dead code</source>
          <target state="translated">私人方法是死代码</target>
        </trans-unit>
        <trans-unit id="d4f0e9f95df601d6fc574b0d6b9281cadcdeb404" translate="yes" xml:space="preserve">
          <source>The private methods are called by a public method, so the inputs to your public methods should also test private methods that are called by those public methods. When a public method fails, then that could be a failure in the private method.</source>
          <target state="translated">私有方法被公有方法调用,所以你的公有方法的输入也应该测试被这些公有方法调用的私有方法。当一个公有方法失败,那么这可能是私有方法的失败。</target>
        </trans-unit>
        <trans-unit id="e801c066ad4c06126ee0faa678e75d5b639e6837" translate="yes" xml:space="preserve">
          <source>Then you can do</source>
          <target state="translated">那么你可以做</target>
        </trans-unit>
        <trans-unit id="6810d88f67449ede60291b3105c90bd696c31a2a" translate="yes" xml:space="preserve">
          <source>There are also several other design patterns which I have used while refactoring and maintaining legacy code, but it all depends on cases of your code to test. Using reflection mostly is not a problem, but when you have an enterprise application which is heavily tested and tests are run before every deployment everything gets really slow (it's just annoying and I don't like that kind of stuff).</source>
          <target state="translated">还有一些其他的设计模式,我在重构和维护遗留代码的时候也用过,但这一切都取决于你的代码测试的情况。大多数情况下使用反射是没有问题的,但是当你有一个企业级的应用,在每次部署之前都要进行大量的测试,而且每次部署之前都要进行测试,一切都会变得很慢(这很烦人,我不喜欢这种东西)。</target>
        </trans-unit>
        <trans-unit id="e294098a8dfea7a5c3635278eddc4336d7bbca52" translate="yes" xml:space="preserve">
          <source>There is a design smell near the class that you are testing</source>
          <target state="translated">在你所测试的班级附近,有一种设计的味道。</target>
        </trans-unit>
        <trans-unit id="1961b3194f3eceb534220dec7cfd0658a13c79d1" translate="yes" xml:space="preserve">
          <source>There is also setter injection, but I wouldn't recommended using it. I'd better stick with a constructor and initialize everything when it's really necessary, leaving the possibility for injecting necessary dependencies.</source>
          <target state="translated">还有setter注入,但我不建议使用它。我还是坚持用构造函数,在真正需要的时候再初始化一切,留下必要的依赖注入的可能性。</target>
        </trans-unit>
        <trans-unit id="a0630fa58840584312f8324a97af6d5961e771b5" translate="yes" xml:space="preserve">
          <source>There is possible merit in testing private methods of a class, particularly with &lt;a href=&quot;http://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;test-driven development&lt;/a&gt;, where you would like to design small tests before you write any code.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;测试类的私有方法可能有好处，尤其是在&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;测试驱动的开发中&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，您希望在编写任何代码之前先设计小型测试。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="086b75748a5099b73be65ec37188606e7a210e65" translate="yes" xml:space="preserve">
          <source>They may also be debugged using test-driven development, debugging your unit tests until all your assertions are met.</source>
          <target state="translated">它们也可以使用测试驱动的开发方式进行调试,调试你的单元测试,直到满足所有的断言为止。</target>
        </trans-unit>
        <trans-unit id="0d7e7626c0f234d5a4b1eefebb7e04bb6f95324f" translate="yes" xml:space="preserve">
          <source>This way your code remains type-safe and readable.  No design compromises, no overexposing methods and fields for the sake of tests.</source>
          <target state="translated">这样你的代码就可以保持类型安全和可读性。没有设计上的妥协,不会为了测试而过度暴露方法和字段。</target>
        </trans-unit>
        <trans-unit id="311f5e6a4e3dcb5323e8e594812c473e08551089" translate="yes" xml:space="preserve">
          <source>This will tell anybody using this method to take caution and not access it directly even in a package. Also a test class need not be in same package &lt;strong&gt;physically&lt;/strong&gt;, but in the same package under the &lt;strong&gt;test&lt;/strong&gt; folder.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;这将告诉使用此方法的任何人要当心，即使在包中也不要直接访问它。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;同样，测试类不必在&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;物理&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;上位于同一包中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;，而是在&lt;/font&gt;&lt;/font&gt;&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;test&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;文件夹&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;下的同一包中&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="b8bb20e26f0bfdeceed068608989a507c169de4d" translate="yes" xml:space="preserve">
          <source>This won't be a problem even with some legacy code. Old code will be using an empty constructor, and if you ask me, refactored code will look cleaner, and you'll be able to inject necessary values in test without reflection.</source>
          <target state="translated">即使是一些遗留的代码,这也不会是一个问题。旧代码将使用空的构造函数,如果你问我,重构后的代码看起来会更干净,而且你可以在测试中注入必要的值而不需要反射。</target>
        </trans-unit>
        <trans-unit id="f55b0f7d6249aa7de09959544b0f0feda938a90d" translate="yes" xml:space="preserve">
          <source>To test legacy code with large and quirky classes, it is often very helpful to be able to test the one private (or public) method I'm writing &lt;em&gt;right now&lt;/em&gt;.</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;与大型和古怪的类测试的遗留代码，它往往是能够测试一个私人（或公共）方法我正在写非常有帮助的&lt;/font&gt;&lt;/font&gt;&lt;em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;现在&lt;/font&gt;&lt;/font&gt;&lt;/em&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="2dd43ad23f4bf7d3a51fa427ec672d9bd6a01af6" translate="yes" xml:space="preserve">
          <source>Today, I pushed a Java library to help testing private methods and fields. It has been designed with Android in mind, but it can really be used for any Java project.</source>
          <target state="translated">今天,我推送了一个Java库来帮助测试私有方法和字段。它在设计的时候就考虑到了Android,但它真的可以用于任何Java项目。</target>
        </trans-unit>
        <trans-unit id="34159cd5d97b03db44c72acff5f46f6a24c21c8c" translate="yes" xml:space="preserve">
          <source>Use a nested test class.</source>
          <target state="translated">使用一个嵌套的测试类。</target>
        </trans-unit>
        <trans-unit id="f1e1383d50d27720fe116324eabd453138603022" translate="yes" xml:space="preserve">
          <source>Use code coverage tools. I like &lt;a href=&quot;http://cobertura.sourceforge.net/index.html&quot;&gt;Cobertura&lt;/a&gt; (oh happy day, looks like a new version is out!)</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;使用代码覆盖率工具。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;我喜欢&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;http://cobertura.sourceforge.net/index.html&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Cobertura&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;（开心的一天，看起来好像有新版本发布了！）&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="fa15115704d2ddf22825eb507327d9d92e328b27" translate="yes" xml:space="preserve">
          <source>Use reflection.</source>
          <target state="translated">利用反思。</target>
        </trans-unit>
        <trans-unit id="0736ff73d779714c30c887cd895cba51ef05c5d2" translate="yes" xml:space="preserve">
          <source>What I recommend doing instead is using a code coverage tool such as Cobertura, to ensure that the unit tests you write provide decent coverage of the code in private methods. That way, you indirectly test what the private methods are doing, and maintain a higher level of agility.</source>
          <target state="translated">我建议使用Cobertura这样的代码覆盖率工具,以确保你写的单元测试能够在私有化方法中提供合适的代码覆盖率。这样,你就可以间接地测试私有方法在做什么,并保持较高的敏捷性。</target>
        </trans-unit>
        <trans-unit id="ee409982c9dae5ad88c914fa57f08415903fa09c" translate="yes" xml:space="preserve">
          <source>When I have private methods in a class that are sufficiently complicated that I feel the need to test the private methods directly, that is a code smell: my class is too complicated.</source>
          <target state="translated">当我的类中的私有化方法足够复杂,以至于我觉得需要直接测试私有化方法时,那就是代码的味道:我的类太复杂了。</target>
        </trans-unit>
        <trans-unit id="263c36a6dc28d5740e02d9585bf8aa9bcba9f12d" translate="yes" xml:space="preserve">
          <source>You mentioned different types of problems. Let's start with private fields. In case of private fields I would have added a new constructor and injected fields into that. Instead of this:</source>
          <target state="translated">你提到了不同类型的问题。让我们从私有字段开始。如果是私有字段,我会添加一个新的构造函数,并将字段注入到其中。而不是这样。</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
