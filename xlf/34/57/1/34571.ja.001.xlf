<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ja" datatype="htmlbody" original="https://stackoverflow.com/questions/34571">
    <body>
      <group id="34571">
        <trans-unit id="f74e6e1dd54190d3d7fae8f5e96f21fb78828a1c" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;TargetClass.getDeclaredMethod(methodName, argClasses)&lt;/code&gt; lets you look into &lt;code&gt;private&lt;/code&gt; methods. The same thing applies for
  &lt;code&gt;getDeclaredField&lt;/code&gt;.</source>
          <target state="translated">1. &lt;code&gt;TargetClass.getDeclaredMethod(methodName, argClasses)&lt;/code&gt; 使用すると、 &lt;code&gt;private&lt;/code&gt; メソッドを調べることができます。 同じことが &lt;code&gt;getDeclaredField&lt;/code&gt; にも当てはまります 。</target>
        </trans-unit>
        <trans-unit id="f4cc2a945e6a4c9cbf53136a3c39c4f241d9f273" translate="yes" xml:space="preserve">
          <source>2. The &lt;code&gt;setAccessible(true)&lt;/code&gt; is required to play around with privates.</source>
          <target state="translated">2. &lt;code&gt;setAccessible(true)&lt;/code&gt; が必要です。</target>
        </trans-unit>
        <trans-unit id="80637c7eb7c5bf4678572b0409559fa57c032965" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BoundBox&lt;/strong&gt; makes it easy to test private/protected fields, methods and constructors. You can even access stuff that is hidden by inheritance. Indeed, BoundBox breaks encapsulation. It will give you access to all that through reflection, &lt;strong&gt;BUT&lt;/strong&gt; everything is checked at compile time.</source>
          <target state="translated">&lt;strong&gt;BoundBoxを使用&lt;/strong&gt;すると、プライベート/保護フィールド、メソッド、コンストラクターを簡単にテストできます。 継承によって隠されたものにアクセスすることもできます。 実際、BoundBoxはカプセル化を解除します。 リフレクションを通じてすべてにアクセスできますが、すべてがコンパイル時にチェックされます。</target>
        </trans-unit>
        <trans-unit id="0c965907d2371e2e657952ec6ec3ce4cc3d0164e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling methods, e.g. &lt;code&gt;private void method(String s)&lt;/code&gt; - by Java reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッドの呼び出し、たとえば&lt;/font&gt;&lt;/font&gt; &lt;code&gt;private void method(String s)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -Javaリフレクションによる&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aee3ea62516774cc4584c0e8794c9a0a9ff8a6b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling methods, e.g. &lt;code&gt;private void method(String s)&lt;/code&gt; - by Picklock&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;メソッドの呼び出し、例：&lt;/font&gt;&lt;/font&gt; &lt;code&gt;private void method(String s)&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt; -Picklockによる&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="667a59955051009a0f32a003c2e1f6aeaf7043bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creating an SDK&lt;/strong&gt; for community
consumption. Here public takes on a
wholly different meaning, since this
is code that the whole world may see
(not just internal to my application). I put
code into private methods if I don't
want the SDK users to see it - I
don't see this as code smell, merely
as how SDK programming works. But of
course I still need to test my
private methods, and they are where
the functionality of my SDK actually
lives.</source>
          <target state="translated">コミュニティで使用&lt;strong&gt;するためのSDK&lt;/strong&gt;を&lt;strong&gt;作成します&lt;/strong&gt; 。 これは、全世界が（私のアプリケーションの内部だけでなく）見ることができるコードであるため、パブリックはまったく異なる意味を持ちます。 SDKユーザーに見られたくない場合は、プライベートメソッドにコードを挿入します。これは、SDKプログラミングのしくみとしてのみ、コードのにおいとしては見えません。 ただし、もちろん、私はまだプライベートメソッドをテストする必要があります。これらのメソッドは、私のSDKの機能が実際に存在する場所です。</target>
        </trans-unit>
        <trans-unit id="6b22ef7e1373ec5f2ed54ae4759f376b1b1ee360" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Decryption routines&lt;/strong&gt; - I would not
want to make them visible to anyone to see just for
the sake of testing, else anyone can
use them to decrypt. But they are
intrinsic to the code, complicated,
and need to always work (the obvious exception is reflection which can be used to view even private methods in most cases, when &lt;code&gt;SecurityManager&lt;/code&gt; is not configured to prevent this).</source>
          <target state="translated">&lt;strong&gt;解読ルーチン&lt;/strong&gt; -私は、テストのためだけにそれらを誰にも見られるようにしたくありません。 しかし、これらはコードに固有で複雑であり、常に機能する必要があります（明らかな例外は、 &lt;code&gt;SecurityManager&lt;/code&gt; がこれを防止するように構成されていない場合、ほとんどの場合、プライベートメソッドでも表示するために使用できるリフレクションです）。</target>
        </trans-unit>
        <trans-unit id="ef937726101d6bbf1ea792d981c362dd127505c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00ccefff1cbb81b8564fd74ef5534ed942a1e40f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setting fields, e.g. &lt;code&gt;private BigInteger amount;&lt;/code&gt; - by Java reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;private BigInteger amount;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などのフィールドの設定&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-Javaリフレクションによる&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4836ec35d6655b402cb0aeff0cc2d9be8bcd9902" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setting fields, e.g. &lt;code&gt;private BigInteger amount;&lt;/code&gt; - by Picklock&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;/font&gt; &lt;code&gt;private BigInteger amount;&lt;/code&gt; &lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;などのフィールドの設定&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;。&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;-Picklockによる&lt;/font&gt;&lt;/font&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a14ff6d0d2545a4fd033426dd9eb1bca74f4bd7" translate="yes" xml:space="preserve">
          <source>A private method is only to be accessed within the same class. So there is no way to test a &amp;ldquo;private&amp;rdquo; method of a target class from any test class. A way out is that you can perform unit testing manually or can change your method from &amp;ldquo;private&amp;rdquo; to &amp;ldquo;protected&amp;rdquo;.</source>
          <target state="translated">プライベートメソッドは、同じクラス内でのみアクセスされます。 したがって、任意のテストクラスからターゲットクラスの「プライベート」メソッドをテストする方法はありません。 解決策は、ユニットテストを手動で実行したり、メソッドを「プライベート」から「保護」に変更したりできることです。</target>
        </trans-unit>
        <trans-unit id="c9f143cb14712f08a4e4970f0a574a82e563a424" translate="yes" xml:space="preserve">
          <source>Advantages:</source>
          <target state="translated">Advantages:</target>
        </trans-unit>
        <trans-unit id="2221efbf6965fac587b30d46e7724828ceb3edb5" translate="yes" xml:space="preserve">
          <source>And for fields:</source>
          <target state="translated">そして、フィールドのために。</target>
        </trans-unit>
        <trans-unit id="c8c30bf3f7e13ff579f2d44836856a1df45a19af" translate="yes" xml:space="preserve">
          <source>And then a protected method can only be accessed within the same package where the class is defined. So, testing a protected method of a target class means we need to define your test class in the same package as the target class.</source>
          <target state="translated">そして、保護されたメソッドは、そのクラスが定義されている同じパッケージ内でしかアクセスできません。つまり、ターゲットクラスの protected メソッドをテストするということは、ターゲットクラスと同じパッケージでテストクラスを定義する必要があるということです。</target>
        </trans-unit>
        <trans-unit id="441792634ac4afd259f6c658a390705cde49193e" translate="yes" xml:space="preserve">
          <source>Another approach I have used is to change a private method to package private or protected then complement it with the &lt;strong&gt;@VisibleForTesting&lt;/strong&gt; annotation of the Google Guava library.</source>
          <target state="translated">私が使用したもう1つのアプローチは、プライベートメソッドをプライベートまたは保護されたパッケージに変更し、それをGoogle Guavaライブラリの&lt;strong&gt;@VisibleForTesting&lt;/strong&gt;アノテーションで補完することです。</target>
        </trans-unit>
        <trans-unit id="1301fc79049e7c65b4bbcf0ba6a61f5931687552" translate="yes" xml:space="preserve">
          <source>As many above have suggested, a good way is to test them via your public interfaces.</source>
          <target state="translated">上記の多くの方が提案しているように、良い方法はパブリックインターフェイスを使ってテストすることです。</target>
        </trans-unit>
        <trans-unit id="c13f7ca769cb85f3221127a40fbd5279f00e0fe7" translate="yes" xml:space="preserve">
          <source>As others have said... don't test private methods directly. Here are a few thoughts:</source>
          <target state="translated">他の人が言っているように...プライベートメソッドを直接テストしないでください。ここにいくつかの考えがあります。</target>
        </trans-unit>
        <trans-unit id="00cf60dde25747bce8c2e44c6fa9ab92a1635c71" translate="yes" xml:space="preserve">
          <source>But if you must...</source>
          <target state="translated">でもどうしても...</target>
        </trans-unit>
        <trans-unit id="f0a8bb1ef2a081f480e91c8e34564927ff144af5" translate="yes" xml:space="preserve">
          <source>Can test to a finer granularity</source>
          <target state="translated">より細かい粒度までテストできる</target>
        </trans-unit>
        <trans-unit id="0c069424ea8e8618c40b30af58a3b6dd3f06183b" translate="yes" xml:space="preserve">
          <source>Creating a test with access to private members and methods can test areas of code which are difficult to target specifically with access only to public methods. If a public method has several steps involved, it can consist of several private methods, which can then be tested individually.</source>
          <target state="translated">プライベート・メンバーやメソッドにアクセスできるテストを作成することで、パブリック・メソッドのみへのアクセスでは特に対象とすることが難しいコードの領域をテストすることができます。公開メソッドにいくつかのステップがある場合、それはいくつかのプライベートメソッドで構成され、個別にテストすることができます。</target>
        </trans-unit>
        <trans-unit id="c472a51872469dd7221cdb8ed81b476216096187" translate="yes" xml:space="preserve">
          <source>Disadvantages:</source>
          <target state="translated">Disadvantages:</target>
        </trans-unit>
        <trans-unit id="c9c9e5c85c1bd842957bfd2bf60f5c54670f8662" translate="yes" xml:space="preserve">
          <source>Don't test private methods.</source>
          <target state="translated">プライベートメソッドをテストしてはいけません。</target>
        </trans-unit>
        <trans-unit id="da1688d4291f35c06929635ff89a47756bee4936" translate="yes" xml:space="preserve">
          <source>First, I'll throw this question out: Why do your private members need isolated testing? Are they that complex, providing such complicated behaviors as to require testing apart from the public surface? It's unit testing, not 'line-of-code' testing. Don't sweat the small stuff.</source>
          <target state="translated">まず、この質問を投げかけます。なぜプライベートなメンバーには隔離されたテストが必要なのでしょうか? 公開されている表面とは別にテストが必要なほど複雑な振る舞いを提供しているのでしょうか?それはユニットテストであって、'line-of-code' テストではありません。小さなことを気にする必要はありません。</target>
        </trans-unit>
        <trans-unit id="488ba946d622fc383a6720a0de399a291c4a6365" translate="yes" xml:space="preserve">
          <source>For example, if a method to be tested is in &lt;code&gt;src/main/java/mypackage/MyClass.java&lt;/code&gt; then your test call should be placed in &lt;code&gt;src/test/java/mypackage/MyClassTest.java&lt;/code&gt;. That way, you got access to the test method in your test class.</source>
          <target state="translated">たとえば、テストするメソッドが &lt;code&gt;src/main/java/mypackage/MyClass.java&lt;/code&gt; にある場合、テスト呼び出しは &lt;code&gt;src/test/java/mypackage/MyClassTest.java&lt;/code&gt; に配置する必要があります。 このようにして、テストクラスのテストメソッドにアクセスできます。</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">例えば</target>
        </trans-unit>
        <trans-unit id="c046b725299d827b1b1cfbff5b6ff9701d5b447f" translate="yes" xml:space="preserve">
          <source>From this article: &lt;a href=&quot;http://www.artima.com/suiterunner/private.html&quot;&gt;Testing Private Methods with JUnit and SuiteRunner&lt;/a&gt; (Bill Venners), you basically have 4 options:</source>
          <target state="translated">この記事から： &lt;a href=&quot;http://www.artima.com/suiterunner/private.html&quot;&gt;JUnitとSuiteRunner&lt;/a&gt; （Bill Venners） を使用したプライベートメソッドのテストには 、基本的に4つのオプションがあります。</target>
        </trans-unit>
        <trans-unit id="ae8c15b3105382053e62cc365916933eb7995b28" translate="yes" xml:space="preserve">
          <source>Generally a unit test is intended to exercise the public interface of a class or unit. Therefore, private methods are implementation detail that you would not expect to test explicitly.</source>
          <target state="translated">一般的に、ユニットテストはクラスやユニットのパブリックインターフェースを行使することを目的としています。したがって、プライベートメソッドは、明示的にテストすることを期待しない実装の詳細です。</target>
        </trans-unit>
        <trans-unit id="21f944c5c0cd9b55951029e9c48346ad8ecaccfc" translate="yes" xml:space="preserve">
          <source>Give the methods package access.</source>
          <target state="translated">メソッドパッケージにアクセス権を与えます。</target>
        </trans-unit>
        <trans-unit id="3ea99547c530ccc60cd2d951a1059ecc58a082c9" translate="yes" xml:space="preserve">
          <source>Having tried Cem Catikkas' &lt;a href=&quot;https://stackoverflow.com/questions/34571/whats-the-best-way-of-unit-testing-private-methods#34658&quot;&gt;solution using reflection&lt;/a&gt; for Java, I'd have to say his was a more elegant solution than I have described here. However, if you're looking for an alternative to using reflection, and have access to the source you're testing, this will still be an option.</source>
          <target state="translated">Javaの&lt;a href=&quot;https://stackoverflow.com/questions/34571/whats-the-best-way-of-unit-testing-private-methods#34658&quot;&gt;リフレクション&lt;/a&gt;を使用してCem Catikkasのソリューションを試してみたので、彼がここで説明したよりもエレガントなソリューションであると言えるでしょう。 ただし、リフレクションを使用する代わりの方法を探していて、テストしているソースにアクセスできる場合でも、これはオプションです。</target>
        </trans-unit>
        <trans-unit id="738ac079cb2720eec3fc2ea83fa03d06c4e24357" translate="yes" xml:space="preserve">
          <source>Here is a convoluted example of how this would work:</source>
          <target state="translated">これがどのように機能するのか、複雑な例を挙げてみましょう。</target>
        </trans-unit>
        <trans-unit id="bad99404aed0664a20ca51067abe49d23d05a388" translate="yes" xml:space="preserve">
          <source>Here is my generic function to test private fields:</source>
          <target state="translated">ここにプライベートフィールドをテストするための汎用関数があります。</target>
        </trans-unit>
        <trans-unit id="cf1020a5e41eab9e99f445355aec8da27a8d8c7f" translate="yes" xml:space="preserve">
          <source>How do I test a private function or a class that has private methods, fields or inner classes</source>
          <target state="translated">プライベート関数やプライベートメソッド、フィールド、内部クラスを持つクラスをテストするにはどうすればいいですか?</target>
        </trans-unit>
        <trans-unit id="0de14c706b029a054d6bb30db817984dba502ac6" translate="yes" xml:space="preserve">
          <source>How do I unit test (using xUnit) a class that has internal private methods, fields or nested classes? Or a function that is made private by having &lt;a href=&quot;https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage&quot;&gt;internal linkage&lt;/a&gt; (&lt;code&gt;static&lt;/code&gt; in C/C++) or is in a private (&lt;a href=&quot;https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions&quot;&gt;anonymous&lt;/a&gt;) namespace?</source>
          <target state="translated">内部プライベートメソッド、フィールド、またはネストされたクラスを持つクラスをユニットテスト（xUnitを使用）するにはどうすればよいですか？ または、 &lt;a href=&quot;https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage&quot;&gt;内部リンケージ&lt;/a&gt; （C / C ++では &lt;code&gt;static&lt;/code&gt; によってプライベートにされた関数、またはプライベート（ &lt;a href=&quot;https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions&quot;&gt;匿名&lt;/a&gt; ）ネームスペースにある関数？</target>
        </trans-unit>
        <trans-unit id="bc255ea980bb0a2a256131036675cc23632ebedb" translate="yes" xml:space="preserve">
          <source>However, if continuous testing requires this method, it may be a signal that the private methods should be extracted, which could be tested in the traditional, public way.</source>
          <target state="translated">しかし、継続的なテストがこの方法を必要とする場合は、伝統的な公的な方法でテストすることができるプライベートな方法を抽出すべきだという合図になるかもしれません。</target>
        </trans-unit>
        <trans-unit id="e4ab4d98c5b0b5ae62722cd5daba84f9fc5d09e2" translate="yes" xml:space="preserve">
          <source>I have used &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt; to do this for Java in the past, and in my opinion it was a big mistake.</source>
          <target state="translated">私はこれまでJavaでこれを行うために&lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;リフレクション&lt;/a&gt;を使用してきましたが、私の意見ではそれは大きな間違いでした。</target>
        </trans-unit>
        <trans-unit id="b3f669f5a4850db8ae087533d316d74f7d18ef39" translate="yes" xml:space="preserve">
          <source>I personally believe it is better to create classes using TDD; creating the public method stubs, then generating unit tests with &lt;strong&gt;all&lt;/strong&gt; the assertions defined in advance, so the expected outcome of the method is determined before you code it. This way, you don't go down the wrong path of making the unit test assertions fit the results. Your class is then robust and meets requirements when all your unit tests pass.</source>
          <target state="translated">私は個人的にはTDDを使用してクラスを作成する方が良いと信じています。 publicメソッドスタブを作成し、事前に定義された&lt;strong&gt;すべて&lt;/strong&gt;のアサーションを使用&lt;strong&gt;し&lt;/strong&gt;て単体テストを生成するため、メソッドの予想される結果は、コードを記述する前に決定されます。 このようにして、ユニットテストのアサーションを結果に合わせるという間違った道をたどることはありません。 その後、クラスは堅牢になり、すべての単体テストに合格したときに要件を満たします。</target>
        </trans-unit>
        <trans-unit id="e36b52cb9fdfbb3e329d1441d178206837d71b2c" translate="yes" xml:space="preserve">
          <source>I recently had this problem and wrote a little tool, called &lt;a href=&quot;https://github.com/almondtools/picklock&quot;&gt;Picklock&lt;/a&gt;, that avoids the problems of explicitly using the Java reflection API, two examples:</source>
          <target state="translated">&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;私は最近この問題を&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;抱えており、JavaリフレクションAPIを明示的に使用する問題を回避する&lt;/font&gt;&lt;/font&gt;&lt;a href=&quot;https://github.com/almondtools/picklock&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;Picklock&lt;/font&gt;&lt;/font&gt;&lt;/a&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;という小さなツールを&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;作成しました。2&lt;/font&gt;&lt;font style=&quot;vertical-align: inherit;&quot;&gt;つの例を示します。&lt;/font&gt;&lt;/font&gt;</target>
        </trans-unit>
        <trans-unit id="7d99726e2e6121e3f90a851753d372ae38b3621b" translate="yes" xml:space="preserve">
          <source>I tend not to test private methods.  There lies madness.  Personally, I believe you should only test your publicly exposed interfaces (and that includes protected and internal methods).</source>
          <target state="translated">私はプライベートな方法をテストしない傾向があります。そこに狂気があります。個人的には、公開されているインターフェイス(そしてそれには保護されたメソッドや内部メソッドも含まれます)だけをテストすべきだと考えています。</target>
        </trans-unit>
        <trans-unit id="5f07dd3769ec6c1f05bf2a35c0526f8b0b85e8f1" translate="yes" xml:space="preserve">
          <source>I understand the idea of only testing the &quot;contract&quot;. But I don't see one can advocate actually not testing code - your mileage may vary.</source>
          <target state="translated">私は唯一の &quot;契約 &quot;をテストするという考えを理解しています。しかし、私は1つが実際にコードをテストしていないことを提唱することができますが表示されません-あなたのマイルは異なる場合があります。</target>
        </trans-unit>
        <trans-unit id="86ef42a47a405d6ea0d40445563542edd3714ab0" translate="yes" xml:space="preserve">
          <source>I use the &lt;strong&gt;junitx.util.PrivateAccessor&lt;/strong&gt;-package for Java . Lots of helpful one-liners for accessing private methods and private fields.</source>
          <target state="translated">私は&lt;strong&gt;junitx.util.PrivateAccessor&lt;/strong&gt; -package for Javaを使用します。 プライベートメソッドとプライベートフィールドにアクセスするための便利な1行。</target>
        </trans-unit>
        <trans-unit id="42bb9d6ad7029d11852bf236c965500fd6aeb10a" translate="yes" xml:space="preserve">
          <source>I would suggest you refactoring your code a little bit. When you have to start thinking about using reflection or other kind of stuff, for just testing your code, something is going wrong with your code.</source>
          <target state="translated">コードを少しリファクタリングすることをお勧めします。コードをテストするためだけにリフレクションや他の種類のものを使用することを考え始めなければならないとき、あなたのコードで何かが間違っていることがあります。</target>
        </trans-unit>
        <trans-unit id="e5c18c5a0c0257d22e6651f930fb4b67ab6d6430" translate="yes" xml:space="preserve">
          <source>I'd have used this:</source>
          <target state="translated">これを使っていたら</target>
        </trans-unit>
        <trans-unit id="856f0a021ec6929f0585d3353794587bc738b479" translate="yes" xml:space="preserve">
          <source>If all the above does not suits your requirement, use &lt;a href=&quot;https://stackoverflow.com/questions/11483647/how-to-access-private-methods-and-private-data-members-via-reflection&quot;&gt;&lt;strong&gt;the  reflection way&lt;/strong&gt;&lt;/a&gt; to access the private method.</source>
          <target state="translated">上記のすべてが要件に合わない場合&lt;a href=&quot;https://stackoverflow.com/questions/11483647/how-to-access-private-methods-and-private-data-members-via-reflection&quot;&gt;&lt;strong&gt;は、リフレクション&lt;/strong&gt;&lt;/a&gt;を使用してプライベートメソッドにアクセスします。</target>
        </trans-unit>
        <trans-unit id="2908c85ab8d5229462900d545e121dbae5bc5f33" translate="yes" xml:space="preserve">
          <source>If refactoring is inappropriate or infeasible, can you use the strategy pattern to replace access to these private member functions / member classes when under unit test? Under unit test, the strategy would provide added validation, but in release builds it would be simple passthrough.</source>
          <target state="translated">リファクタリングが不適切であったり、実行不可能な場合、ユニットテスト中にストラテジーパターンを使用して、これらのプライベートメンバ関数メンバクラスへのアクセスを置き換えることができますか?ユニットテストでは、ストラテジーは追加の検証を提供しますが、リリースビルドでは単純なパススルーになります。</target>
        </trans-unit>
        <trans-unit id="b50c21d867d9f45732d608b976f552d6b804fae5" translate="yes" xml:space="preserve">
          <source>If the class's design is still flexible, and you've got a complicated private method that you'd like to test separately, I suggest you pull it out into a separate class and test that class separately. This doesn't have to change the public interface of the original class; it can internally create an instance of the helper class and call the helper method.</source>
          <target state="translated">クラスの設計がまだ柔軟で、複雑なプライベートメソッドを個別にテストしたい場合は、それを別のクラスに引っ張り出して、そのクラスを個別にテストすることをお勧めします。これは元のクラスのパブリックインターフェイスを変更する必要はありません。ヘルパークラスのインスタンスを内部的に作成してヘルパーメソッドを呼び出すことができます。</target>
        </trans-unit>
        <trans-unit id="f91aaf05eb0d0047f2110ff5981712e3f94e2098" translate="yes" xml:space="preserve">
          <source>If they are that big, big enough that these private members are each a 'unit' large in complexity -- consider refactoring such private members out of this class.</source>
          <target state="translated">もし、それらがそれほど大きく、これらのプライベート・メンバがそれぞれ複雑さの中で大きな「単位」になるような大きさであるならば、このクラスからそのようなプライベート・メンバをリファクタリングすることを検討してください。</target>
        </trans-unit>
        <trans-unit id="afa066ad607390e7196812b766cdf27e86c8c154" translate="yes" xml:space="preserve">
          <source>If using Spring, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/util/ReflectionTestUtils.html&quot;&gt;ReflectionTestUtils&lt;/a&gt; provides some handy tools that help out here with minimal effort. For example, to set up a mock on a private member without being forced to add an undesirable public setter:</source>
          <target state="translated">Springを使用する場合、 &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/util/ReflectionTestUtils.html&quot;&gt;ReflectionTestUtils&lt;/a&gt;は、最小限の労力でここで役立ついくつかの便利なツールを提供します。 たとえば、望ましくないパブリックセッターを追加せずにプライベートメンバーにモックを設定するには：</target>
        </trans-unit>
        <trans-unit id="83193c16ef655f324fc282cd1969a12136199cf8" translate="yes" xml:space="preserve">
          <source>If you are using JDK 1.3 or higher, you can use reflection to subvert
  the access control mechanism with the aid of the &lt;a href=&quot;http://sourceforge.net/projects/privaccessor/&quot;&gt;PrivilegedAccessor&lt;/a&gt;.
  For details on how to use it, read &lt;a href=&quot;http://www.onjava.com/pub/a/onjava/2003/11/12/reflection.html&quot;&gt;this article&lt;/a&gt;.</source>
          <target state="translated">JDK 1.3以降を使用している場合は、リフレクションを使用して、 &lt;a href=&quot;http://sourceforge.net/projects/privaccessor/&quot;&gt;PrivilegedAccessor&lt;/a&gt;を利用してアクセス制御メカニズムを破壊できます。 使い方の詳細は&lt;a href=&quot;http://www.onjava.com/pub/a/onjava/2003/11/12/reflection.html&quot;&gt;こちらの記事&lt;/a&gt;をご覧ください 。</target>
        </trans-unit>
        <trans-unit id="82c0d1bf8945f5975a8f462f666b9a4e0e5e127d" translate="yes" xml:space="preserve">
          <source>If you are using JDK 1.6 or higher and you annotate your tests with
  @Test, you can use &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt; to inject reflection in your test methods. For
  details on how to use it, see &lt;a href=&quot;http://dp4j.com/testscript&quot;&gt;this test script&lt;/a&gt;.</source>
          <target state="translated">JDK 1.6以降を使用していて、 &lt;a href=&quot;http://dp4j.com&quot;&gt;@ Test&lt;/a&gt;でテストに注釈を付ける場合、 Dp4jを使用して、テストメソッドにリフレクションを挿入できます。 使用方法の詳細については、 &lt;a href=&quot;http://dp4j.com/testscript&quot;&gt;このテストスクリプトを&lt;/a&gt;参照してください。</target>
        </trans-unit>
        <trans-unit id="2b31f8facdbfd1bfa9d19d56f79ad1c75fa0d34e" translate="yes" xml:space="preserve">
          <source>If you do this, it's a good idea to use a code coverage tool (like Emma) to see if your private methods are in fact being executed from your tests.</source>
          <target state="translated">その場合は、コードカバレッジツール(Emmaのようなもの)を使って、プライベートメソッドが実際にテストから実行されているかどうかを確認するのが良いでしょう。</target>
        </trans-unit>
        <trans-unit id="231ced4c5a18aefc12b359da49c26b919a67fbb9" translate="yes" xml:space="preserve">
          <source>If you got some code with private methods or fields or constructors, you can use &lt;a href=&quot;https://github.com/stephanenicolas/boundbox&quot;&gt;&lt;strong&gt;BoundBox&lt;/strong&gt;&lt;/a&gt;. It does exactly what you are looking for.
Here below is an example of a test that accesses two private fields of an Android activity to test it:</source>
          <target state="translated">プライベートメソッド、フィールド、またはコンストラクターを含むコードがある場合、 &lt;a href=&quot;https://github.com/stephanenicolas/boundbox&quot;&gt;&lt;strong&gt;BoundBox&lt;/strong&gt;&lt;/a&gt;を使用できます。 それはまさにあなたが探しているものを実行します。 以下は、Androidアクティビティの2つのプライベートフィールドにアクセスしてテストする例です。</target>
        </trans-unit>
        <trans-unit id="c79881c26b4f45425fd6ff0dd1d27b095fb2240a" translate="yes" xml:space="preserve">
          <source>If you have somewhat of a legacy &lt;strong&gt;Java&lt;/strong&gt; application, and you're not allowed to change the visibility of your methods, the best way to test private methods is to use &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt;.</source>
          <target state="translated">レガシー&lt;strong&gt;Java&lt;/strong&gt;アプリケーションがいくらかあり、メソッドの可視性を変更することが許可されていない場合、プライベートメソッドをテストする最良の方法は、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;リフレクション&lt;/a&gt;を使用することです。</target>
        </trans-unit>
        <trans-unit id="b48c353a1610aa6f526142112c3e4e924cf08d8d" translate="yes" xml:space="preserve">
          <source>If you want to test difficult error conditions coming from the helper method, you can go a step further. Extract an interface from the helper class, add a public getter and setter to the original class to inject the helper class (used through its interface), and then inject a mock version of the helper class into the original class to test how the original class responds to exceptions from the helper. This approach is also helpful if you want to test the original class without also testing the helper class.</source>
          <target state="translated">ヘルパーメソッドから来る難しいエラー条件をテストしたい場合は、さらに一歩進んでください。ヘルパークラスからインターフェイスを抽出し、元のクラスにパブリックゲッターとセッターを追加してヘルパークラス (インターフェイスを通して使用される)を注入し、ヘルパークラスのモックバージョンを元のクラスに注入して、元のクラスがヘルパーからの例外にどのように応答するかをテストします。このアプローチは、ヘルパークラスをテストせずに元のクラスをテストしたい場合にも役立ちます。</target>
        </trans-unit>
        <trans-unit id="fe75670323f07c2b037bcc439be60b5d49e84c28" translate="yes" xml:space="preserve">
          <source>If you want to test private methods of a legacy application where you can't change the code, one option for Java is &lt;a href=&quot;http://code.google.com/p/jmockit/&quot;&gt;jMockit&lt;/a&gt;, which will allow you to create mocks to an object even when they're private to the class.</source>
          <target state="translated">コードを変更できないレガシーアプリケーションのプライベートメソッドをテストする場合、Javaのオプションの1つは&lt;a href=&quot;http://code.google.com/p/jmockit/&quot;&gt;jMockitです&lt;/a&gt; 。これにより、クラスにプライベートでもモックをオブジェクトに作成できます。</target>
        </trans-unit>
        <trans-unit id="72e52fa6e1a9545b518febc8820865af20b96e14" translate="yes" xml:space="preserve">
          <source>If you're trying to test existing code that you're reluctant or unable to change, reflection is a good choice.</source>
          <target state="translated">既存のコードをテストしようとしていて、変更に消極的だったり、変更できなかったりする場合は、リフレクトを使うのが良いでしょう。</target>
        </trans-unit>
        <trans-unit id="d792406ad753323d672f9c3416735627210a6784" translate="yes" xml:space="preserve">
          <source>If you're using JUnit, have a look at &lt;a href=&quot;http://junit-addons.sourceforge.net/&quot;&gt;junit-addons&lt;/a&gt;. It has the ability to ignore the Java security model and access private methods and attributes.</source>
          <target state="translated">JUnitを使用している場合は、 &lt;a href=&quot;http://junit-addons.sourceforge.net/&quot;&gt;junit-addonsをご覧ください&lt;/a&gt; 。 Javaセキュリティモデルを無視し、プライベートメソッドと属性にアクセスする機能があります。</target>
        </trans-unit>
        <trans-unit id="d28be3040a66843e9a8b31893a7a596588eb062b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://en.wikipedia.org/wiki/Spring_Framework&quot;&gt;Spring Framework&lt;/a&gt; you can test private methods using this method:</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Spring_Framework&quot;&gt;Spring Framework&lt;/a&gt;では、このメソッドを使用してプライベートメソッドをテストできます。</target>
        </trans-unit>
        <trans-unit id="1fc74da23c19b1981c07b1448e7f5db47a487f28" translate="yes" xml:space="preserve">
          <source>Internally we're using helpers to get/set &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;private static&lt;/code&gt; variables as well as invoke &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;private static&lt;/code&gt; methods. The following patterns will let you do pretty much anything related to the private methods and fields. Of course, you can't change &lt;code&gt;private static final&lt;/code&gt; variables through reflection.</source>
          <target state="translated">内部的には、ヘルパーを使用して &lt;code&gt;private&lt;/code&gt; および &lt;code&gt;private static&lt;/code&gt; 変数を取得/設定し、 &lt;code&gt;private&lt;/code&gt; および &lt;code&gt;private static&lt;/code&gt; メソッドを呼び出しています。 次のパターンでは、プライベートメソッドとフィールドに関連するほとんどすべてのことを実行できます。 もちろん、リフレクションを介して &lt;code&gt;private static final&lt;/code&gt; 変数を変更することはできません。</target>
        </trans-unit>
        <trans-unit id="9ced52e68cb80f32738bfe343adbf16629c4c90b" translate="yes" xml:space="preserve">
          <source>It is ideal for testing some legacy code. Use it carefully. ;)</source>
          <target state="translated">レガシーコードのテストに最適です。慎重に使ってください。)</target>
        </trans-unit>
        <trans-unit id="2fa9f5af925c4287d94f324d2dd236645502165a" translate="yes" xml:space="preserve">
          <source>It seems bad to change the access modifier for a method or function just to be able to run a test.</source>
          <target state="translated">テストを実行できるようにするためだけに、メソッドや関数のアクセス修飾子を変更するのは良くないようです。</target>
        </trans-unit>
        <trans-unit id="e654ed1f3d726168497b0172d3d23035e3917b98" translate="yes" xml:space="preserve">
          <source>Just two examples of where I would want to test a private method:</source>
          <target state="translated">プライベートメソッドをテストしたい場所の例を2つ挙げてみました。</target>
        </trans-unit>
        <trans-unit id="d4e47f0274a3c52708f822a10e289c3e99775b5d" translate="yes" xml:space="preserve">
          <source>Keep all methods small and focused (easy to test, easy to find what is wrong)</source>
          <target state="translated">すべての方法を小さく、集中的に保つ(テストが容易で、何が間違っているかを見つけることが容易である</target>
        </trans-unit>
        <trans-unit id="9adf46953726191943242b998a6a02cbbf4fca14" translate="yes" xml:space="preserve">
          <source>Mostly all that I wrote looks like it's a dependency injection pattern. In my personal experience it's really useful while testing, and I think that this kind of code is cleaner and will be easier to maintain. I'd say the same about nested classes. If a nested class contains heavy logic it would be better if you'd moved it as a package private class and have injected it into a class needing it.</source>
          <target state="translated">書いていることのほとんどが依存性注入パターンのように見えます。個人的な経験では、テスト中は本当に便利ですし、こういうコードの方がすっきりしていてメンテナンスも楽になると思います。入れ子になったクラスについても同じことが言えると思います。入れ子になっているクラスに重いロジックが含まれている場合は、それをパッケージのプライベートクラスとして移動させて、それを必要とするクラスにインジェクションした方が良いと思います。</target>
        </trans-unit>
        <trans-unit id="30205722f087baf2291cb886209e83bbd9803fe4" translate="yes" xml:space="preserve">
          <source>My usual approach to addressing such issues is to tease out a new class that contains the interesting bits.  Often, this method and the fields it interacts with, and maybe another method or two can be extracted in to a new class.</source>
          <target state="translated">このような問題に対処するための私の通常のアプローチは、興味深い部分を含む新しいクラスを作成することです。多くの場合、このメソッドとそれが相互作用するフィールド、そしておそらく別のメソッドや2つのメソッドを新しいクラスに抽出することができます。</target>
        </trans-unit>
        <trans-unit id="2dc80e7fd583fd5394b42b7828b62bcf68608597" translate="yes" xml:space="preserve">
          <source>Note that I'm not suggesting that people create classes without using their brain! The point here is to use the forces of unit testing to help you find good new classes.</source>
          <target state="translated">私は、人々が頭を使わずにクラスを作れと言っているのではないことに注意してください! ここでのポイントは、ユニットテストの力を使って、良い新しいクラスを見つけるのを助けることです。</target>
        </trans-unit>
        <trans-unit id="2fe26b2c16fe9cee75070a2fc030c171634bc7bf" translate="yes" xml:space="preserve">
          <source>Now about private methods. In my personal experience when you have to stub a private method for testing, then that method has nothing to do in that class. A common pattern, in that case, would be to &lt;em&gt;wrap&lt;/em&gt; it within an interface, like &lt;code&gt;Callable&lt;/code&gt; and then you pass in that interface also in the constructor (with that multiple constructor trick):</source>
          <target state="translated">次に、プライベートメソッドについて説明します。 私の個人的な経験では、テストのためにプライベートメソッドをスタブする必要がある場合、そのメソッドはそのクラスでは何もしません。 その場合の一般的なパターンは、それを &lt;code&gt;Callable&lt;/code&gt; などのインターフェース内に&lt;em&gt;ラップ&lt;/em&gt;し、そのインターフェースをコンストラクターにも渡します（複数のコンストラクターのトリックを使用）。</target>
        </trans-unit>
        <trans-unit id="777cc4ad4d28cf7c02b892fe5111983c770aebf9" translate="yes" xml:space="preserve">
          <source>Now you can directly pass the object which has the private method, method name to be called, and additional parameters as below.</source>
          <target state="translated">これで、以下のようにプライベートメソッド、呼ばれるメソッド名、追加のパラメータを持つオブジェクトを直接渡すことができるようになりました。</target>
        </trans-unit>
        <trans-unit id="49a4661efd1819dad49a68ff125c5dfdef8c3ea9" translate="yes" xml:space="preserve">
          <source>P.S. I'm the main contributor to &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt;, ask &lt;a href=&quot;https://stackoverflow.com/users/300248&quot;&gt;me&lt;/a&gt; if you need help. :)</source>
          <target state="translated">PS私は&lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt;の主な貢献者です。サポートが必要かどうかを尋ね&lt;a href=&quot;https://stackoverflow.com/users/300248&quot;&gt;てください&lt;/a&gt; 。 :)</target>
        </trans-unit>
        <trans-unit id="5f43d2331301eb02496c0c805bc3f87c3a2c7307" translate="yes" xml:space="preserve">
          <source>Please see below for an example;</source>
          <target state="translated">一例として下記をご参照ください。</target>
        </trans-unit>
        <trans-unit id="5fe8c532739285df240daf07b928efebea907d0a" translate="yes" xml:space="preserve">
          <source>PowerMockito is made for this.
Use maven dependency</source>
          <target state="translated">PowerMockitoはこのために作られています。mavenの依存関係を使用します。</target>
        </trans-unit>
        <trans-unit id="497baeb3b5ee74d2b4d986eb47ed0293a6ada2a0" translate="yes" xml:space="preserve">
          <source>Private methods are consumed by public ones. Otherwise, they're dead code. That's why you test the public method, asserting the expected results of the public method and thereby, the private methods it consumes.</source>
          <target state="translated">プライベートなメソッドはパブリックなメソッドによって消費されます。そうでなければ、それらはデッドコードです。だからこそ、パブリックメソッドをテストして、パブリックメソッドの期待される結果をアサートし、それによってプライベートメソッドが消費することになります。</target>
        </trans-unit>
        <trans-unit id="83d6d608b54d120b904dee27b0513327bd8a3adc" translate="yes" xml:space="preserve">
          <source>Run the code coverage on the unit tests. If you see that methods are not fully tested add to the tests to get the coverage up. Aim for 100% code coverage, but realize that you probably won't get it.</source>
          <target state="translated">ユニットテストのコードカバレッジを実行します。メソッドが完全にテストされていないことがわかったら、カバレッジを上げるためにテストを追加してください。100%のコードカバレッジを目指してくださいが、おそらくあなたはそれを得ることができないことを認識しています。</target>
        </trans-unit>
        <trans-unit id="f33de1aa1bafbeb284338b42c053c4ecb4dbcf05" translate="yes" xml:space="preserve">
          <source>See also: &lt;em&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/javatips/jw-javatip106.html&quot;&gt;Java Tip 106: Static inner classes for fun and profit&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">参照： &lt;em&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/javatips/jw-javatip106.html&quot;&gt;Javaヒント106：楽しさと利益のための静的内部クラス&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b710af9a932bb8b3407780d42ea95e9d3c2c9c68" translate="yes" xml:space="preserve">
          <source>Similarly with .class output files, they must remain within the same package as declared in source code</source>
          <target state="translated">同様に、.class 出力ファイルも、ソースコードで宣言されている同じパッケージ内にとどまっていなければなりません。</target>
        </trans-unit>
        <trans-unit id="40ef678cea4286c297bccc879a9c3c11a47c9b03" translate="yes" xml:space="preserve">
          <source>So don't test private methods.</source>
          <target state="translated">だからプライベートメソッドをテストするな</target>
        </trans-unit>
        <trans-unit id="204733d7cb2b813d677976ecf1b798415058621d" translate="yes" xml:space="preserve">
          <source>So my tradeoff involves complicating the JUnits with reflection, rather than compromising my security &amp;amp; SDK.</source>
          <target state="translated">したがって、私のトレードオフには、セキュリティとSDKを妥協するのではなく、JUnitをリフレクションで複雑にすることが含まれます。</target>
        </trans-unit>
        <trans-unit id="1dc726b4f0600a6162d0a5fec0ac442b107c4f85" translate="yes" xml:space="preserve">
          <source>Some 10 years later perhaps the best way to test a private method, or any inaccessible member, is via &lt;strong&gt;&lt;code&gt;@Jailbreak&lt;/code&gt;&lt;/strong&gt; from the &lt;a href=&quot;https://manifold.systems&quot;&gt;Manifold&lt;/a&gt; framework.</source>
          <target state="translated">約10年後、おそらくプライベートメソッドまたはアクセスできないメンバーをテストする最良の方法は、 &lt;a href=&quot;https://manifold.systems&quot;&gt;マニホールド&lt;/a&gt;フレームワークから&lt;strong&gt; &lt;code&gt;@Jailbreak&lt;/code&gt; &lt;/strong&gt;を経由すること&lt;strong&gt;です&lt;/strong&gt; 。</target>
        </trans-unit>
        <trans-unit id="93fcf1e45142f4bf2b769ec5b5d2448cc5a335d7" translate="yes" xml:space="preserve">
          <source>Strictly speaking, you should &lt;em&gt;not&lt;/em&gt; be writing unit tests that directly test private methods. What you &lt;em&gt;should&lt;/em&gt; be testing is the public contract that the class has with other objects; you should never directly test an object's internals. If another developer wants to make a small internal change to the class, which doesn't affect the classes public contract, he/she then has to modify your reflection based test to ensure that it works. If you do this repeatedly throughout a project, unit tests then stop being a useful measurement of code health, and start to become a hindrance to development, and an annoyance to the development team.</source>
          <target state="translated">厳密に言えば、プライベートメソッドを直接テストする単体テストを作成するべきで&lt;em&gt;は&lt;/em&gt;ありませ&lt;em&gt;ん&lt;/em&gt; 。 テストする&lt;em&gt;必要&lt;/em&gt;があるのは、クラスが他のオブジェクトと持っているパブリックコントラクトです。 オブジェクトの内部を直接テストしないでください。 別の開発者が、クラスのパブリックコントラクトに影響を与えない、クラスに小さな内部変更を加えたい場合は、リフレクションベースのテストを変更して、機能することを確認する必要があります。 プロジェクト全体でこれを繰り返し行うと、ユニットテストはコードの正常性の有用な測定ではなくなり、開発の妨げになり始め、開発チームの迷惑になります。</target>
        </trans-unit>
        <trans-unit id="e60b23b6cc258fd2f3050f01d48f369e96d22536" translate="yes" xml:space="preserve">
          <source>Test code must reside in the same
file as source code, which can be
more difficult to maintain</source>
          <target state="translated">テストコードはソースコードと同じファイルに存在しなければならないので、メンテナンスが難しくなる可能性があります。</target>
        </trans-unit>
        <trans-unit id="e628bb4ef6d2f95c51a2e0fabdc7e6570882e841" translate="yes" xml:space="preserve">
          <source>Testing private methods breaks the encapsulation of your class because every time you change the internal implementation you break client code (in this case, the tests).</source>
          <target state="translated">プライベートメソッドをテストすることで、クラスのカプセル化が破られてしまいます。</target>
        </trans-unit>
        <trans-unit id="b08d94828e924f3c44bdad7d49d7a9e8126f9b82" translate="yes" xml:space="preserve">
          <source>Testing private methods should be tested by debugging before running your unit tests on public methods.</source>
          <target state="translated">プライベートメソッドのテストは、パブリックメソッドでユニットテストを実行する前に、デバッグでテストする必要があります。</target>
        </trans-unit>
        <trans-unit id="99ac885a2c04ce23f9e9dee57055ba4db55f0ba2" translate="yes" xml:space="preserve">
          <source>The answer from &lt;a href=&quot;http://junit.org/faq.html#atests_11&quot;&gt;JUnit.org FAQ page&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;http://junit.org/faq.html#atests_11&quot;&gt;JUnit.org FAQページ&lt;/a&gt;からの回答：</target>
        </trans-unit>
        <trans-unit id="612f347cc8d13e68510dabfe438c3934b0e32ab6" translate="yes" xml:space="preserve">
          <source>The best way to test a private method is via another public method. If this cannot be done, then one of the following conditions is true:</source>
          <target state="translated">プライベートメソッドをテストする最良の方法は、別のパブリックメソッドを経由することです。これができない場合は、次の条件のいずれかが真であることになります。</target>
        </trans-unit>
        <trans-unit id="bd734d3c315faa6945e06b553d5414ada763a534" translate="yes" xml:space="preserve">
          <source>The following import statement should be added:</source>
          <target state="translated">以下のインポート文を追加する必要があります。</target>
        </trans-unit>
        <trans-unit id="85834fcc9380e9b0ac91e5af41b0a87baae505d9" translate="yes" xml:space="preserve">
          <source>The inner class would be compiled to &lt;code&gt;ClassToTest$StaticInnerTest&lt;/code&gt;.</source>
          <target state="translated">内部クラスは &lt;code&gt;ClassToTest$StaticInnerTest&lt;/code&gt; コンパイルされます。</target>
        </trans-unit>
        <trans-unit id="fe9916a66d8aaef8076e5a9c5eb90320bb058a1d" translate="yes" xml:space="preserve">
          <source>The method that you are trying to test should not be private</source>
          <target state="translated">テストしようとしているメソッドはプライベートであるべきではありません。</target>
        </trans-unit>
        <trans-unit id="9660255e33ec7d540aff4829d9d77f76b4f97dd1" translate="yes" xml:space="preserve">
          <source>The new class exposes these methods as 'public', so they're accessible for unit testing.  The new and old classes are now both simpler than the original class, which is great for me (I need to keep things simple, or I get lost!).</source>
          <target state="translated">新しいクラスはこれらのメソッドを 'public' として公開しているので、ユニットテストのためにアクセスできるようになっています。新しいクラスと古いクラスの両方が元のクラスよりもシンプルになりました。</target>
        </trans-unit>
        <trans-unit id="e7a5f083811631d013af462cec5f70ee62d8c80c" translate="yes" xml:space="preserve">
          <source>The private method is dead code</source>
          <target state="translated">プライベートメソッドはデッドコード</target>
        </trans-unit>
        <trans-unit id="d4f0e9f95df601d6fc574b0d6b9281cadcdeb404" translate="yes" xml:space="preserve">
          <source>The private methods are called by a public method, so the inputs to your public methods should also test private methods that are called by those public methods. When a public method fails, then that could be a failure in the private method.</source>
          <target state="translated">プライベートメソッドはパブリックメソッドによって呼び出されますので、パブリックメソッドへの入力は、そのパブリックメソッドによって呼び出されるプライベートメソッドもテストしなければなりません。publicメソッドが失敗した場合、それはprivateメソッドの失敗である可能性があります。</target>
        </trans-unit>
        <trans-unit id="e801c066ad4c06126ee0faa678e75d5b639e6837" translate="yes" xml:space="preserve">
          <source>Then you can do</source>
          <target state="translated">それから、あなたは</target>
        </trans-unit>
        <trans-unit id="6810d88f67449ede60291b3105c90bd696c31a2a" translate="yes" xml:space="preserve">
          <source>There are also several other design patterns which I have used while refactoring and maintaining legacy code, but it all depends on cases of your code to test. Using reflection mostly is not a problem, but when you have an enterprise application which is heavily tested and tests are run before every deployment everything gets really slow (it's just annoying and I don't like that kind of stuff).</source>
          <target state="translated">私がレガシーコードのリファクタリングやメンテナンスをしている間に使ったデザインパターンは他にもいくつかありますが、すべてはテストするコードのケースに依存します。リフレクションを使うことは問題ありませんが、企業向けのアプリケーションでテストが重く、すべてのデプロイの前にテストが実行されている場合、すべてが本当に遅くなります(迷惑なだけで、私はそのようなことは好きではありません)。</target>
        </trans-unit>
        <trans-unit id="e294098a8dfea7a5c3635278eddc4336d7bbca52" translate="yes" xml:space="preserve">
          <source>There is a design smell near the class that you are testing</source>
          <target state="translated">テストしているクラスの近くにデザイン臭がある</target>
        </trans-unit>
        <trans-unit id="1961b3194f3eceb534220dec7cfd0658a13c79d1" translate="yes" xml:space="preserve">
          <source>There is also setter injection, but I wouldn't recommended using it. I'd better stick with a constructor and initialize everything when it's really necessary, leaving the possibility for injecting necessary dependencies.</source>
          <target state="translated">セッターインジェクションもありますが、それを使うのはお勧めできません。コンストラクタに固執して、本当に必要なときにすべてを初期化して、必要な依存性を注入する可能性を残しておく方がいいと思います。</target>
        </trans-unit>
        <trans-unit id="a0630fa58840584312f8324a97af6d5961e771b5" translate="yes" xml:space="preserve">
          <source>There is possible merit in testing private methods of a class, particularly with &lt;a href=&quot;http://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;test-driven development&lt;/a&gt;, where you would like to design small tests before you write any code.</source>
          <target state="translated">クラスのプライベートメソッドをテストすることにはメリットがあります。特に、 &lt;a href=&quot;http://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;テスト駆動開発&lt;/a&gt;では、コードを記述する前に小規模なテストを設計する必要があります。</target>
        </trans-unit>
        <trans-unit id="086b75748a5099b73be65ec37188606e7a210e65" translate="yes" xml:space="preserve">
          <source>They may also be debugged using test-driven development, debugging your unit tests until all your assertions are met.</source>
          <target state="translated">また、テスト駆動開発を使用して、すべてのアサーションが満たされるまでユニットテストをデバッグすることもできます。</target>
        </trans-unit>
        <trans-unit id="0d7e7626c0f234d5a4b1eefebb7e04bb6f95324f" translate="yes" xml:space="preserve">
          <source>This way your code remains type-safe and readable.  No design compromises, no overexposing methods and fields for the sake of tests.</source>
          <target state="translated">このようにして、コードはタイプセーフで読みやすくなります。設計上の妥協や、テストのためにメソッドやフィールドを過度に露出させることはありません。</target>
        </trans-unit>
        <trans-unit id="311f5e6a4e3dcb5323e8e594812c473e08551089" translate="yes" xml:space="preserve">
          <source>This will tell anybody using this method to take caution and not access it directly even in a package. Also a test class need not be in same package &lt;strong&gt;physically&lt;/strong&gt;, but in the same package under the &lt;strong&gt;test&lt;/strong&gt; folder.</source>
          <target state="translated">これは、このメソッドを使用しているすべての人に、パッケージ内でも直接アクセスしないように注意するように警告するものです。 また、テストクラスは&lt;strong&gt;物理的&lt;/strong&gt;に同じパッケージにある必要はありませんが、 &lt;strong&gt;テスト&lt;/strong&gt;フォルダの下の同じパッケージにあります。</target>
        </trans-unit>
        <trans-unit id="b8bb20e26f0bfdeceed068608989a507c169de4d" translate="yes" xml:space="preserve">
          <source>This won't be a problem even with some legacy code. Old code will be using an empty constructor, and if you ask me, refactored code will look cleaner, and you'll be able to inject necessary values in test without reflection.</source>
          <target state="translated">これはいくつかのレガシーコードでも問題にはならないでしょう。古いコードは空のコンストラクタを使うことになりますが、私に言わせれば、リファクタリングされたコードの方がすっきりとした見た目になりますし、テストで必要な値をリフレクトなしで注入できるようになります。</target>
        </trans-unit>
        <trans-unit id="f55b0f7d6249aa7de09959544b0f0feda938a90d" translate="yes" xml:space="preserve">
          <source>To test legacy code with large and quirky classes, it is often very helpful to be able to test the one private (or public) method I'm writing &lt;em&gt;right now&lt;/em&gt;.</source>
          <target state="translated">大きくて風変わりなクラスでレガシーコードをテストするには、 &lt;em&gt;今&lt;/em&gt;書いている1つのプライベート（またはパブリック）メソッドをテストできると非常に便利です。</target>
        </trans-unit>
        <trans-unit id="2dd43ad23f4bf7d3a51fa427ec672d9bd6a01af6" translate="yes" xml:space="preserve">
          <source>Today, I pushed a Java library to help testing private methods and fields. It has been designed with Android in mind, but it can really be used for any Java project.</source>
          <target state="translated">今日は、プライベートメソッドやフィールドのテストに役立つJavaライブラリをプッシュしました。Androidを念頭に置いて設計されていますが、本当にどんなJavaプロジェクトにも使えます。</target>
        </trans-unit>
        <trans-unit id="34159cd5d97b03db44c72acff5f46f6a24c21c8c" translate="yes" xml:space="preserve">
          <source>Use a nested test class.</source>
          <target state="translated">入れ子になったテストクラスを使用します。</target>
        </trans-unit>
        <trans-unit id="f1e1383d50d27720fe116324eabd453138603022" translate="yes" xml:space="preserve">
          <source>Use code coverage tools. I like &lt;a href=&quot;http://cobertura.sourceforge.net/index.html&quot;&gt;Cobertura&lt;/a&gt; (oh happy day, looks like a new version is out!)</source>
          <target state="translated">コードカバレッジツールを使用します。 私は&lt;a href=&quot;http://cobertura.sourceforge.net/index.html&quot;&gt;コベルトゥーラが&lt;/a&gt;好きです （ああ幸せな日、新しいバージョンが出ているようです！）</target>
        </trans-unit>
        <trans-unit id="fa15115704d2ddf22825eb507327d9d92e328b27" translate="yes" xml:space="preserve">
          <source>Use reflection.</source>
          <target state="translated">リフレクションを使用します。</target>
        </trans-unit>
        <trans-unit id="0736ff73d779714c30c887cd895cba51ef05c5d2" translate="yes" xml:space="preserve">
          <source>What I recommend doing instead is using a code coverage tool such as Cobertura, to ensure that the unit tests you write provide decent coverage of the code in private methods. That way, you indirectly test what the private methods are doing, and maintain a higher level of agility.</source>
          <target state="translated">代わりに私が推奨するのは、Cobertura のようなコードカバレッジツールを使用して、あなたが書くユニットテストがプライベートメソッドのコードをきちんとカバレッジしていることを確認することです。そうすることで、プライベートメソッドが何をしているかを間接的にテストし、より高いレベルの俊敏性を維持することができます。</target>
        </trans-unit>
        <trans-unit id="ee409982c9dae5ad88c914fa57f08415903fa09c" translate="yes" xml:space="preserve">
          <source>When I have private methods in a class that are sufficiently complicated that I feel the need to test the private methods directly, that is a code smell: my class is too complicated.</source>
          <target state="translated">私がプライベートメソッドを直接テストする必要性を感じるほど十分に複雑なクラスにプライベートメソッドがある場合、それはコードの臭いがします:私のクラスはあまりにも複雑です。</target>
        </trans-unit>
        <trans-unit id="263c36a6dc28d5740e02d9585bf8aa9bcba9f12d" translate="yes" xml:space="preserve">
          <source>You mentioned different types of problems. Let's start with private fields. In case of private fields I would have added a new constructor and injected fields into that. Instead of this:</source>
          <target state="translated">いろいろなタイプの問題が出てきましたね。まずはプライベートフィールドから始めてみましょう。プライベートフィールドの場合、私は新しいコンストラクタを追加し、その中にフィールドを注入していました。その代わりに</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
