<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="https://stackoverflow.com/questions/34571">
    <body>
      <group id="34571">
        <trans-unit id="f74e6e1dd54190d3d7fae8f5e96f21fb78828a1c" translate="yes" xml:space="preserve">
          <source>1. &lt;code&gt;TargetClass.getDeclaredMethod(methodName, argClasses)&lt;/code&gt; lets you look into &lt;code&gt;private&lt;/code&gt; methods. The same thing applies for
  &lt;code&gt;getDeclaredField&lt;/code&gt;.</source>
          <target state="translated">1. &lt;code&gt;TargetClass.getDeclaredMethod(methodName, argClasses)&lt;/code&gt; permite buscar m&amp;eacute;todos &lt;code&gt;private&lt;/code&gt; . Lo mismo se aplica para &lt;code&gt;getDeclaredField&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4cc2a945e6a4c9cbf53136a3c39c4f241d9f273" translate="yes" xml:space="preserve">
          <source>2. The &lt;code&gt;setAccessible(true)&lt;/code&gt; is required to play around with privates.</source>
          <target state="translated">2. Se &lt;code&gt;setAccessible(true)&lt;/code&gt; para jugar con elementos privados.</target>
        </trans-unit>
        <trans-unit id="80637c7eb7c5bf4678572b0409559fa57c032965" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;BoundBox&lt;/strong&gt; makes it easy to test private/protected fields, methods and constructors. You can even access stuff that is hidden by inheritance. Indeed, BoundBox breaks encapsulation. It will give you access to all that through reflection, &lt;strong&gt;BUT&lt;/strong&gt; everything is checked at compile time.</source>
          <target state="translated">&lt;strong&gt;BoundBox&lt;/strong&gt; facilita la prueba de campos, m&amp;eacute;todos y constructores privados / protegidos. Incluso puedes acceder a cosas que est&amp;aacute;n ocultas por herencia. De hecho, BoundBox rompe la encapsulaci&amp;oacute;n. Le dar&amp;aacute; acceso a todo eso a trav&amp;eacute;s de la reflexi&amp;oacute;n, &lt;strong&gt;PERO&lt;/strong&gt; todo se verifica en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0c965907d2371e2e657952ec6ec3ce4cc3d0164e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling methods, e.g. &lt;code&gt;private void method(String s)&lt;/code&gt; - by Java reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todos de llamada, por ejemplo, &lt;code&gt;private void method(String s)&lt;/code&gt; : por reflexi&amp;oacute;n de Java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aee3ea62516774cc4584c0e8794c9a0a9ff8a6b1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Calling methods, e.g. &lt;code&gt;private void method(String s)&lt;/code&gt; - by Picklock&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;M&amp;eacute;todos de llamada, por ejemplo, &lt;code&gt;private void method(String s)&lt;/code&gt; - por Picklock&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="667a59955051009a0f32a003c2e1f6aeaf7043bb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Creating an SDK&lt;/strong&gt; for community
consumption. Here public takes on a
wholly different meaning, since this
is code that the whole world may see
(not just internal to my application). I put
code into private methods if I don't
want the SDK users to see it - I
don't see this as code smell, merely
as how SDK programming works. But of
course I still need to test my
private methods, and they are where
the functionality of my SDK actually
lives.</source>
          <target state="translated">&lt;strong&gt;Creaci&amp;oacute;n de un SDK&lt;/strong&gt; para consumo comunitario. Aqu&amp;iacute;, el p&amp;uacute;blico adquiere un significado completamente diferente, ya que este es un c&amp;oacute;digo que todo el mundo puede ver (no solo interno a mi aplicaci&amp;oacute;n). Pongo c&amp;oacute;digo en m&amp;eacute;todos privados si no quiero que los usuarios del SDK lo vean. No veo esto como un olor a c&amp;oacute;digo, sino simplemente c&amp;oacute;mo funciona la programaci&amp;oacute;n del SDK. Pero, por supuesto, todav&amp;iacute;a necesito probar mis m&amp;eacute;todos privados, y es donde realmente vive la funcionalidad de mi SDK.</target>
        </trans-unit>
        <trans-unit id="6b22ef7e1373ec5f2ed54ae4759f376b1b1ee360" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Decryption routines&lt;/strong&gt; - I would not
want to make them visible to anyone to see just for
the sake of testing, else anyone can
use them to decrypt. But they are
intrinsic to the code, complicated,
and need to always work (the obvious exception is reflection which can be used to view even private methods in most cases, when &lt;code&gt;SecurityManager&lt;/code&gt; is not configured to prevent this).</source>
          <target state="translated">&lt;strong&gt;Rutinas de descifrado&lt;/strong&gt; : no quisiera hacerlas visibles para que cualquiera las vea solo por el simple hecho de probarlas, de lo contrario, cualquiera puede usarlas para descifrarlas. Pero son intr&amp;iacute;nsecos al c&amp;oacute;digo, complicados y deben funcionar siempre (la excepci&amp;oacute;n obvia es la reflexi&amp;oacute;n que puede usarse para ver incluso m&amp;eacute;todos privados en la mayor&amp;iacute;a de los casos, cuando &lt;code&gt;SecurityManager&lt;/code&gt; no est&amp;aacute; configurado para evitar esto).</target>
        </trans-unit>
        <trans-unit id="ef937726101d6bbf1ea792d981c362dd127505c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Notes:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Notes:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="00ccefff1cbb81b8564fd74ef5534ed942a1e40f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setting fields, e.g. &lt;code&gt;private BigInteger amount;&lt;/code&gt; - by Java reflection&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Establecer campos, por ejemplo, &lt;code&gt;private BigInteger amount;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;- por reflexi&amp;oacute;n de Java&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4836ec35d6655b402cb0aeff0cc2d9be8bcd9902" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Setting fields, e.g. &lt;code&gt;private BigInteger amount;&lt;/code&gt; - by Picklock&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Establecer campos, por ejemplo, &lt;code&gt;private BigInteger amount;&lt;/code&gt; &lt;/strong&gt; &lt;strong&gt;- por Picklock&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee947672ace063ceb0fbdd407b2cb329f46d107c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;Update:&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;Update:&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a14ff6d0d2545a4fd033426dd9eb1bca74f4bd7" translate="yes" xml:space="preserve">
          <source>A private method is only to be accessed within the same class. So there is no way to test a &amp;ldquo;private&amp;rdquo; method of a target class from any test class. A way out is that you can perform unit testing manually or can change your method from &amp;ldquo;private&amp;rdquo; to &amp;ldquo;protected&amp;rdquo;.</source>
          <target state="translated">Solo se puede acceder a un m&amp;eacute;todo privado dentro de la misma clase. Por lo tanto, no hay forma de probar un m&amp;eacute;todo &quot;privado&quot; de una clase objetivo desde ninguna clase de prueba. Una salida es que puede realizar pruebas unitarias manualmente o puede cambiar su m&amp;eacute;todo de &quot;privado&quot; a &quot;protegido&quot;.</target>
        </trans-unit>
        <trans-unit id="c9f143cb14712f08a4e4970f0a574a82e563a424" translate="yes" xml:space="preserve">
          <source>Advantages:</source>
          <target state="translated">Advantages:</target>
        </trans-unit>
        <trans-unit id="2221efbf6965fac587b30d46e7724828ceb3edb5" translate="yes" xml:space="preserve">
          <source>And for fields:</source>
          <target state="translated">Y para los campos:</target>
        </trans-unit>
        <trans-unit id="c8c30bf3f7e13ff579f2d44836856a1df45a19af" translate="yes" xml:space="preserve">
          <source>And then a protected method can only be accessed within the same package where the class is defined. So, testing a protected method of a target class means we need to define your test class in the same package as the target class.</source>
          <target state="translated">Y entonces un método protegido sólo puede ser accedido dentro del mismo paquete donde la clase está definida.Por lo tanto,probar un método protegido de una clase objetivo significa que necesitamos definir su clase de prueba en el mismo paquete que la clase objetivo.</target>
        </trans-unit>
        <trans-unit id="441792634ac4afd259f6c658a390705cde49193e" translate="yes" xml:space="preserve">
          <source>Another approach I have used is to change a private method to package private or protected then complement it with the &lt;strong&gt;@VisibleForTesting&lt;/strong&gt; annotation of the Google Guava library.</source>
          <target state="translated">Otro enfoque que he usado es cambiar un m&amp;eacute;todo privado para empaquetar privado o protegido y luego complementarlo con la anotaci&amp;oacute;n &lt;strong&gt;@VisibleForTesting&lt;/strong&gt; de la biblioteca Google Guava.</target>
        </trans-unit>
        <trans-unit id="1301fc79049e7c65b4bbcf0ba6a61f5931687552" translate="yes" xml:space="preserve">
          <source>As many above have suggested, a good way is to test them via your public interfaces.</source>
          <target state="translated">Como muchos de los anteriores han sugerido,una buena manera es probarlos a través de sus interfaces públicas.</target>
        </trans-unit>
        <trans-unit id="c13f7ca769cb85f3221127a40fbd5279f00e0fe7" translate="yes" xml:space="preserve">
          <source>As others have said... don't test private methods directly. Here are a few thoughts:</source>
          <target state="translated">Como otros han dicho...no pruebe los métodos privados directamente.Aquí hay algunas ideas:</target>
        </trans-unit>
        <trans-unit id="00cf60dde25747bce8c2e44c6fa9ab92a1635c71" translate="yes" xml:space="preserve">
          <source>But if you must...</source>
          <target state="translated">Pero si tienes que hacerlo...</target>
        </trans-unit>
        <trans-unit id="f0a8bb1ef2a081f480e91c8e34564927ff144af5" translate="yes" xml:space="preserve">
          <source>Can test to a finer granularity</source>
          <target state="translated">Puede probar a una granularidad más fina</target>
        </trans-unit>
        <trans-unit id="0c069424ea8e8618c40b30af58a3b6dd3f06183b" translate="yes" xml:space="preserve">
          <source>Creating a test with access to private members and methods can test areas of code which are difficult to target specifically with access only to public methods. If a public method has several steps involved, it can consist of several private methods, which can then be tested individually.</source>
          <target state="translated">La creación de una prueba con acceso a miembros y métodos privados puede poner a prueba áreas de código que son difíciles de abordar específicamente con acceso sólo a métodos públicos.Si un método público tiene varios pasos,puede consistir en varios métodos privados,que luego pueden probarse individualmente.</target>
        </trans-unit>
        <trans-unit id="c472a51872469dd7221cdb8ed81b476216096187" translate="yes" xml:space="preserve">
          <source>Disadvantages:</source>
          <target state="translated">Disadvantages:</target>
        </trans-unit>
        <trans-unit id="c9c9e5c85c1bd842957bfd2bf60f5c54670f8662" translate="yes" xml:space="preserve">
          <source>Don't test private methods.</source>
          <target state="translated">No pruebe los métodos privados.</target>
        </trans-unit>
        <trans-unit id="da1688d4291f35c06929635ff89a47756bee4936" translate="yes" xml:space="preserve">
          <source>First, I'll throw this question out: Why do your private members need isolated testing? Are they that complex, providing such complicated behaviors as to require testing apart from the public surface? It's unit testing, not 'line-of-code' testing. Don't sweat the small stuff.</source>
          <target state="translated">Primero,voy a tirar esta pregunta:¿Por qué sus miembros privados necesitan pruebas aisladas? ¿Son tan complejos,proporcionando comportamientos tan complicados como para requerir pruebas aparte de la superficie pública? Es una prueba de unidad,no una prueba de &quot;línea de código&quot;.No te preocupes por las cosas pequeñas.</target>
        </trans-unit>
        <trans-unit id="488ba946d622fc383a6720a0de399a291c4a6365" translate="yes" xml:space="preserve">
          <source>For example, if a method to be tested is in &lt;code&gt;src/main/java/mypackage/MyClass.java&lt;/code&gt; then your test call should be placed in &lt;code&gt;src/test/java/mypackage/MyClassTest.java&lt;/code&gt;. That way, you got access to the test method in your test class.</source>
          <target state="translated">Por ejemplo, si un m&amp;eacute;todo a probar est&amp;aacute; en &lt;code&gt;src/main/java/mypackage/MyClass.java&lt;/code&gt; , entonces su llamada de prueba debe colocarse en &lt;code&gt;src/test/java/mypackage/MyClassTest.java&lt;/code&gt; . De esa manera, tienes acceso al m&amp;eacute;todo de prueba en tu clase de prueba.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c046b725299d827b1b1cfbff5b6ff9701d5b447f" translate="yes" xml:space="preserve">
          <source>From this article: &lt;a href=&quot;http://www.artima.com/suiterunner/private.html&quot;&gt;Testing Private Methods with JUnit and SuiteRunner&lt;/a&gt; (Bill Venners), you basically have 4 options:</source>
          <target state="translated">De este art&amp;iacute;culo: &lt;a href=&quot;http://www.artima.com/suiterunner/private.html&quot;&gt;Prueba de m&amp;eacute;todos privados con JUnit y SuiteRunner&lt;/a&gt; (Bill Venners), b&amp;aacute;sicamente tiene 4 opciones:</target>
        </trans-unit>
        <trans-unit id="ae8c15b3105382053e62cc365916933eb7995b28" translate="yes" xml:space="preserve">
          <source>Generally a unit test is intended to exercise the public interface of a class or unit. Therefore, private methods are implementation detail that you would not expect to test explicitly.</source>
          <target state="translated">Por lo general,una prueba de unidad tiene por objeto ejercer la interfaz pública de una clase o unidad.Por lo tanto,los métodos privados son detalles de implementación que no se esperaría probar explícitamente.</target>
        </trans-unit>
        <trans-unit id="21f944c5c0cd9b55951029e9c48346ad8ecaccfc" translate="yes" xml:space="preserve">
          <source>Give the methods package access.</source>
          <target state="translated">Darle acceso al paquete de métodos.</target>
        </trans-unit>
        <trans-unit id="3ea99547c530ccc60cd2d951a1059ecc58a082c9" translate="yes" xml:space="preserve">
          <source>Having tried Cem Catikkas' &lt;a href=&quot;https://stackoverflow.com/questions/34571/whats-the-best-way-of-unit-testing-private-methods#34658&quot;&gt;solution using reflection&lt;/a&gt; for Java, I'd have to say his was a more elegant solution than I have described here. However, if you're looking for an alternative to using reflection, and have access to the source you're testing, this will still be an option.</source>
          <target state="translated">Despu&amp;eacute;s de probar la &lt;a href=&quot;https://stackoverflow.com/questions/34571/whats-the-best-way-of-unit-testing-private-methods#34658&quot;&gt;soluci&amp;oacute;n de&lt;/a&gt; Cem Catikkas usando la reflexi&amp;oacute;n para Java, debo decir que fue una soluci&amp;oacute;n m&amp;aacute;s elegante que la que he descrito aqu&amp;iacute;. Sin embargo, si est&amp;aacute; buscando una alternativa al uso de la reflexi&amp;oacute;n y tiene acceso a la fuente que est&amp;aacute; probando, esta seguir&amp;aacute; siendo una opci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="738ac079cb2720eec3fc2ea83fa03d06c4e24357" translate="yes" xml:space="preserve">
          <source>Here is a convoluted example of how this would work:</source>
          <target state="translated">Aquí hay un ejemplo enrevesado de cómo funcionaría esto:</target>
        </trans-unit>
        <trans-unit id="bad99404aed0664a20ca51067abe49d23d05a388" translate="yes" xml:space="preserve">
          <source>Here is my generic function to test private fields:</source>
          <target state="translated">Aquí está mi función genérica para probar los campos privados:</target>
        </trans-unit>
        <trans-unit id="cf1020a5e41eab9e99f445355aec8da27a8d8c7f" translate="yes" xml:space="preserve">
          <source>How do I test a private function or a class that has private methods, fields or inner classes</source>
          <target state="translated">¿Cómo puedo probar una función privada o una clase que tiene métodos privados,campos o clases internas</target>
        </trans-unit>
        <trans-unit id="0de14c706b029a054d6bb30db817984dba502ac6" translate="yes" xml:space="preserve">
          <source>How do I unit test (using xUnit) a class that has internal private methods, fields or nested classes? Or a function that is made private by having &lt;a href=&quot;https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage&quot;&gt;internal linkage&lt;/a&gt; (&lt;code&gt;static&lt;/code&gt; in C/C++) or is in a private (&lt;a href=&quot;https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions&quot;&gt;anonymous&lt;/a&gt;) namespace?</source>
          <target state="translated">&amp;iquest;C&amp;oacute;mo pruebo unitariamente (usando xUnit) una clase que tiene m&amp;eacute;todos privados internos, campos o clases anidadas? &amp;iquest;O una funci&amp;oacute;n que se hace privada al tener &lt;a href=&quot;https://stackoverflow.com/questions/1358400/what-is-external-linkage-and-internal-linkage&quot;&gt;un enlace interno&lt;/a&gt; ( &lt;code&gt;static&lt;/code&gt; en C / C ++) o est&amp;aacute; en un espacio de nombres privado ( &lt;a href=&quot;https://stackoverflow.com/questions/154469/unnamed-anonymous-namespaces-vs-static-functions&quot;&gt;an&amp;oacute;nimo&lt;/a&gt; )?</target>
        </trans-unit>
        <trans-unit id="bc255ea980bb0a2a256131036675cc23632ebedb" translate="yes" xml:space="preserve">
          <source>However, if continuous testing requires this method, it may be a signal that the private methods should be extracted, which could be tested in the traditional, public way.</source>
          <target state="translated">Sin embargo,si las pruebas continuas requieren este método,puede ser una señal de que deben extraerse los métodos privados,que podrían probarse en la forma tradicional,pública.</target>
        </trans-unit>
        <trans-unit id="e4ab4d98c5b0b5ae62722cd5daba84f9fc5d09e2" translate="yes" xml:space="preserve">
          <source>I have used &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt; to do this for Java in the past, and in my opinion it was a big mistake.</source>
          <target state="translated">He utilizado la &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflexi&amp;oacute;n&lt;/a&gt; para hacer esto para Java en el pasado, y en mi opini&amp;oacute;n fue un gran error.</target>
        </trans-unit>
        <trans-unit id="b3f669f5a4850db8ae087533d316d74f7d18ef39" translate="yes" xml:space="preserve">
          <source>I personally believe it is better to create classes using TDD; creating the public method stubs, then generating unit tests with &lt;strong&gt;all&lt;/strong&gt; the assertions defined in advance, so the expected outcome of the method is determined before you code it. This way, you don't go down the wrong path of making the unit test assertions fit the results. Your class is then robust and meets requirements when all your unit tests pass.</source>
          <target state="translated">Personalmente, creo que es mejor crear clases con TDD; crear los resguardos de m&amp;eacute;todos p&amp;uacute;blicos, luego generar pruebas unitarias con &lt;strong&gt;todas&lt;/strong&gt; las aserciones definidas de antemano, de modo que el resultado esperado del m&amp;eacute;todo se determine antes de codificarlo. De esta manera, no va por el camino equivocado al hacer que las afirmaciones de la prueba unitaria se ajusten a los resultados. Su clase es robusta y cumple con los requisitos cuando pasan todas las pruebas de su unidad.</target>
        </trans-unit>
        <trans-unit id="e36b52cb9fdfbb3e329d1441d178206837d71b2c" translate="yes" xml:space="preserve">
          <source>I recently had this problem and wrote a little tool, called &lt;a href=&quot;https://github.com/almondtools/picklock&quot;&gt;Picklock&lt;/a&gt;, that avoids the problems of explicitly using the Java reflection API, two examples:</source>
          <target state="translated">Recientemente tuve este problema y escrib&amp;iacute; una peque&amp;ntilde;a herramienta, llamada &lt;a href=&quot;https://github.com/almondtools/picklock&quot;&gt;Picklock&lt;/a&gt; , que evita los problemas de usar expl&amp;iacute;citamente la API de reflexi&amp;oacute;n de Java, dos ejemplos:</target>
        </trans-unit>
        <trans-unit id="7d99726e2e6121e3f90a851753d372ae38b3621b" translate="yes" xml:space="preserve">
          <source>I tend not to test private methods.  There lies madness.  Personally, I believe you should only test your publicly exposed interfaces (and that includes protected and internal methods).</source>
          <target state="translated">Tiendo a no probar métodos privados.Ahí está la locura.Personalmente,creo que sólo debería probar sus interfaces expuestas públicamente (y eso incluye los métodos protegidos e internos).</target>
        </trans-unit>
        <trans-unit id="5f07dd3769ec6c1f05bf2a35c0526f8b0b85e8f1" translate="yes" xml:space="preserve">
          <source>I understand the idea of only testing the &quot;contract&quot;. But I don't see one can advocate actually not testing code - your mileage may vary.</source>
          <target state="translated">Entiendo la idea de sólo probar el &quot;contrato&quot;.Pero no veo que se pueda abogar por no probar el código,su kilometraje puede variar.</target>
        </trans-unit>
        <trans-unit id="86ef42a47a405d6ea0d40445563542edd3714ab0" translate="yes" xml:space="preserve">
          <source>I use the &lt;strong&gt;junitx.util.PrivateAccessor&lt;/strong&gt;-package for Java . Lots of helpful one-liners for accessing private methods and private fields.</source>
          <target state="translated">Yo uso el &lt;strong&gt;paquete junitx.util.PrivateAccessor&lt;/strong&gt; para Java. Un mont&amp;oacute;n de frases &amp;uacute;tiles para acceder a m&amp;eacute;todos privados y campos privados.</target>
        </trans-unit>
        <trans-unit id="42bb9d6ad7029d11852bf236c965500fd6aeb10a" translate="yes" xml:space="preserve">
          <source>I would suggest you refactoring your code a little bit. When you have to start thinking about using reflection or other kind of stuff, for just testing your code, something is going wrong with your code.</source>
          <target state="translated">Le sugiero que refactorice un poco su código.Cuando tienes que empezar a pensar en usar el reflejo u otro tipo de cosas,sólo para probar tu código,algo va mal en tu código.</target>
        </trans-unit>
        <trans-unit id="e5c18c5a0c0257d22e6651f930fb4b67ab6d6430" translate="yes" xml:space="preserve">
          <source>I'd have used this:</source>
          <target state="translated">Yo habría usado esto:</target>
        </trans-unit>
        <trans-unit id="856f0a021ec6929f0585d3353794587bc738b479" translate="yes" xml:space="preserve">
          <source>If all the above does not suits your requirement, use &lt;a href=&quot;https://stackoverflow.com/questions/11483647/how-to-access-private-methods-and-private-data-members-via-reflection&quot;&gt;&lt;strong&gt;the  reflection way&lt;/strong&gt;&lt;/a&gt; to access the private method.</source>
          <target state="translated">Si todo lo anterior no cumple con sus requisitos, utilice &lt;a href=&quot;https://stackoverflow.com/questions/11483647/how-to-access-private-methods-and-private-data-members-via-reflection&quot;&gt;&lt;strong&gt;la forma de reflexi&amp;oacute;n&lt;/strong&gt;&lt;/a&gt; para acceder al m&amp;eacute;todo privado.</target>
        </trans-unit>
        <trans-unit id="2908c85ab8d5229462900d545e121dbae5bc5f33" translate="yes" xml:space="preserve">
          <source>If refactoring is inappropriate or infeasible, can you use the strategy pattern to replace access to these private member functions / member classes when under unit test? Under unit test, the strategy would provide added validation, but in release builds it would be simple passthrough.</source>
          <target state="translated">Si la refactorización es inapropiada o inviable,¿puede utilizar el patrón de estrategia para reemplazar el acceso a estas funciones privadas de los miembros de las clases cuando se está bajo la prueba de la unidad? En la prueba de unidad,la estrategia proporcionaría una validación adicional,pero en las construcciones de liberación sería un simple paso.</target>
        </trans-unit>
        <trans-unit id="b50c21d867d9f45732d608b976f552d6b804fae5" translate="yes" xml:space="preserve">
          <source>If the class's design is still flexible, and you've got a complicated private method that you'd like to test separately, I suggest you pull it out into a separate class and test that class separately. This doesn't have to change the public interface of the original class; it can internally create an instance of the helper class and call the helper method.</source>
          <target state="translated">Si el diseño de la clase sigue siendo flexible,y tienes un complicado método privado que te gustaría probar por separado,te sugiero que lo saques a una clase separada y pruebes esa clase por separado.Esto no tiene por qué cambiar la interfaz pública de la clase original,sino que puede crear internamente una instancia de la clase de ayuda y llamar al método de ayuda.</target>
        </trans-unit>
        <trans-unit id="f91aaf05eb0d0047f2110ff5981712e3f94e2098" translate="yes" xml:space="preserve">
          <source>If they are that big, big enough that these private members are each a 'unit' large in complexity -- consider refactoring such private members out of this class.</source>
          <target state="translated">Si son tan grandes,lo suficientemente grandes como para que estos miembros privados sean cada uno una &quot;unidad&quot; grande en complejidad-considere la posibilidad de refactorizar tales miembros privados fuera de esta clase.</target>
        </trans-unit>
        <trans-unit id="afa066ad607390e7196812b766cdf27e86c8c154" translate="yes" xml:space="preserve">
          <source>If using Spring, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/util/ReflectionTestUtils.html&quot;&gt;ReflectionTestUtils&lt;/a&gt; provides some handy tools that help out here with minimal effort. For example, to set up a mock on a private member without being forced to add an undesirable public setter:</source>
          <target state="translated">Si usa Spring, &lt;a href=&quot;http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/util/ReflectionTestUtils.html&quot;&gt;ReflectionTestUtils&lt;/a&gt; proporciona algunas herramientas &amp;uacute;tiles que ayudan aqu&amp;iacute; con un m&amp;iacute;nimo esfuerzo. Por ejemplo, para configurar un simulacro en un miembro privado sin verse obligado a agregar un setter p&amp;uacute;blico indeseable:</target>
        </trans-unit>
        <trans-unit id="83193c16ef655f324fc282cd1969a12136199cf8" translate="yes" xml:space="preserve">
          <source>If you are using JDK 1.3 or higher, you can use reflection to subvert
  the access control mechanism with the aid of the &lt;a href=&quot;http://sourceforge.net/projects/privaccessor/&quot;&gt;PrivilegedAccessor&lt;/a&gt;.
  For details on how to use it, read &lt;a href=&quot;http://www.onjava.com/pub/a/onjava/2003/11/12/reflection.html&quot;&gt;this article&lt;/a&gt;.</source>
          <target state="translated">Si est&amp;aacute; utilizando JDK 1.3 o superior, puede usar la reflexi&amp;oacute;n para subvertir el mecanismo de control de acceso con la ayuda del &lt;a href=&quot;http://sourceforge.net/projects/privaccessor/&quot;&gt;PrivilegedAccessor&lt;/a&gt; . Para obtener detalles sobre c&amp;oacute;mo usarlo, lea &lt;a href=&quot;http://www.onjava.com/pub/a/onjava/2003/11/12/reflection.html&quot;&gt;este art&amp;iacute;culo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82c0d1bf8945f5975a8f462f666b9a4e0e5e127d" translate="yes" xml:space="preserve">
          <source>If you are using JDK 1.6 or higher and you annotate your tests with
  @Test, you can use &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt; to inject reflection in your test methods. For
  details on how to use it, see &lt;a href=&quot;http://dp4j.com/testscript&quot;&gt;this test script&lt;/a&gt;.</source>
          <target state="translated">Si est&amp;aacute; utilizando JDK 1.6 o superior y anota sus pruebas con @Test, puede usar &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt; para inyectar reflejo en sus m&amp;eacute;todos de prueba. Para obtener detalles sobre c&amp;oacute;mo usarlo, consulte &lt;a href=&quot;http://dp4j.com/testscript&quot;&gt;este script de prueba&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2b31f8facdbfd1bfa9d19d56f79ad1c75fa0d34e" translate="yes" xml:space="preserve">
          <source>If you do this, it's a good idea to use a code coverage tool (like Emma) to see if your private methods are in fact being executed from your tests.</source>
          <target state="translated">Si haces esto,es una buena idea usar una herramienta de cobertura de código (como Emma)para ver si tus métodos privados se están ejecutando de hecho a partir de tus pruebas.</target>
        </trans-unit>
        <trans-unit id="231ced4c5a18aefc12b359da49c26b919a67fbb9" translate="yes" xml:space="preserve">
          <source>If you got some code with private methods or fields or constructors, you can use &lt;a href=&quot;https://github.com/stephanenicolas/boundbox&quot;&gt;&lt;strong&gt;BoundBox&lt;/strong&gt;&lt;/a&gt;. It does exactly what you are looking for.
Here below is an example of a test that accesses two private fields of an Android activity to test it:</source>
          <target state="translated">Si tiene alg&amp;uacute;n c&amp;oacute;digo con m&amp;eacute;todos privados o campos o constructores, puede usar &lt;a href=&quot;https://github.com/stephanenicolas/boundbox&quot;&gt;&lt;strong&gt;BoundBox&lt;/strong&gt;&lt;/a&gt; . Hace exactamente lo que est&amp;aacute;s buscando. A continuaci&amp;oacute;n se muestra un ejemplo de una prueba que accede a dos campos privados de una actividad de Android para probarla:</target>
        </trans-unit>
        <trans-unit id="c79881c26b4f45425fd6ff0dd1d27b095fb2240a" translate="yes" xml:space="preserve">
          <source>If you have somewhat of a legacy &lt;strong&gt;Java&lt;/strong&gt; application, and you're not allowed to change the visibility of your methods, the best way to test private methods is to use &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflection&lt;/a&gt;.</source>
          <target state="translated">Si tiene una aplicaci&amp;oacute;n &lt;strong&gt;Java&lt;/strong&gt; heredada y no se le permite cambiar la visibilidad de sus m&amp;eacute;todos, la mejor manera de probar m&amp;eacute;todos privados es usar la &lt;a href=&quot;http://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;reflexi&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b48c353a1610aa6f526142112c3e4e924cf08d8d" translate="yes" xml:space="preserve">
          <source>If you want to test difficult error conditions coming from the helper method, you can go a step further. Extract an interface from the helper class, add a public getter and setter to the original class to inject the helper class (used through its interface), and then inject a mock version of the helper class into the original class to test how the original class responds to exceptions from the helper. This approach is also helpful if you want to test the original class without also testing the helper class.</source>
          <target state="translated">Si quieres probar condiciones de error difíciles que provienen del método de ayuda,puedes ir un paso más allá.Extraer una interfaz de la clase ayudante,añadir un getter y setter públicos a la clase original para inyectar la clase ayudante (utilizada a través de su interfaz),y luego inyectar una versión simulada de la clase ayudante en la clase original para probar cómo responde la clase original a las excepciones de la ayudante.Este enfoque también es útil si quieres probar la clase original sin probar también la clase ayudante.</target>
        </trans-unit>
        <trans-unit id="fe75670323f07c2b037bcc439be60b5d49e84c28" translate="yes" xml:space="preserve">
          <source>If you want to test private methods of a legacy application where you can't change the code, one option for Java is &lt;a href=&quot;http://code.google.com/p/jmockit/&quot;&gt;jMockit&lt;/a&gt;, which will allow you to create mocks to an object even when they're private to the class.</source>
          <target state="translated">Si desea probar m&amp;eacute;todos privados de una aplicaci&amp;oacute;n heredada donde no puede cambiar el c&amp;oacute;digo, una opci&amp;oacute;n para Java es &lt;a href=&quot;http://code.google.com/p/jmockit/&quot;&gt;jMockit&lt;/a&gt; , que le permitir&amp;aacute; crear simulacros para un objeto incluso cuando son privados para la clase.</target>
        </trans-unit>
        <trans-unit id="72e52fa6e1a9545b518febc8820865af20b96e14" translate="yes" xml:space="preserve">
          <source>If you're trying to test existing code that you're reluctant or unable to change, reflection is a good choice.</source>
          <target state="translated">Si estás tratando de probar un código existente que eres reacio o incapaz de cambiar,la reflexión es una buena opción.</target>
        </trans-unit>
        <trans-unit id="d792406ad753323d672f9c3416735627210a6784" translate="yes" xml:space="preserve">
          <source>If you're using JUnit, have a look at &lt;a href=&quot;http://junit-addons.sourceforge.net/&quot;&gt;junit-addons&lt;/a&gt;. It has the ability to ignore the Java security model and access private methods and attributes.</source>
          <target state="translated">Si est&amp;aacute; usando JUnit, eche un vistazo a &lt;a href=&quot;http://junit-addons.sourceforge.net/&quot;&gt;junit-addons&lt;/a&gt; . Tiene la capacidad de ignorar el modelo de seguridad de Java y acceder a m&amp;eacute;todos y atributos privados.</target>
        </trans-unit>
        <trans-unit id="d28be3040a66843e9a8b31893a7a596588eb062b" translate="yes" xml:space="preserve">
          <source>In the &lt;a href=&quot;http://en.wikipedia.org/wiki/Spring_Framework&quot;&gt;Spring Framework&lt;/a&gt; you can test private methods using this method:</source>
          <target state="translated">En &lt;a href=&quot;http://en.wikipedia.org/wiki/Spring_Framework&quot;&gt;Spring Framework&lt;/a&gt; , puede probar m&amp;eacute;todos privados utilizando este m&amp;eacute;todo:</target>
        </trans-unit>
        <trans-unit id="1fc74da23c19b1981c07b1448e7f5db47a487f28" translate="yes" xml:space="preserve">
          <source>Internally we're using helpers to get/set &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;private static&lt;/code&gt; variables as well as invoke &lt;code&gt;private&lt;/code&gt; and &lt;code&gt;private static&lt;/code&gt; methods. The following patterns will let you do pretty much anything related to the private methods and fields. Of course, you can't change &lt;code&gt;private static final&lt;/code&gt; variables through reflection.</source>
          <target state="translated">Internamente estamos usando ayudantes para obtener / establecer variables &lt;code&gt;private static&lt;/code&gt; &lt;code&gt;private&lt;/code&gt; y privadas , as&amp;iacute; como invocar m&amp;eacute;todos &lt;code&gt;private static&lt;/code&gt; &lt;code&gt;private&lt;/code&gt; y privados . Los siguientes patrones le permitir&amp;aacute;n hacer casi cualquier cosa relacionada con los m&amp;eacute;todos y campos privados. Por supuesto, no puede cambiar &lt;code&gt;private static final&lt;/code&gt; variables finales est&amp;aacute;ticas privadas a trav&amp;eacute;s de la reflexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9ced52e68cb80f32738bfe343adbf16629c4c90b" translate="yes" xml:space="preserve">
          <source>It is ideal for testing some legacy code. Use it carefully. ;)</source>
          <target state="translated">Es ideal para probar algún código de legado.Úsalo con cuidado.;)</target>
        </trans-unit>
        <trans-unit id="2fa9f5af925c4287d94f324d2dd236645502165a" translate="yes" xml:space="preserve">
          <source>It seems bad to change the access modifier for a method or function just to be able to run a test.</source>
          <target state="translated">Parece malo cambiar el modificador de acceso para un método o función sólo para poder hacer una prueba.</target>
        </trans-unit>
        <trans-unit id="e654ed1f3d726168497b0172d3d23035e3917b98" translate="yes" xml:space="preserve">
          <source>Just two examples of where I would want to test a private method:</source>
          <target state="translated">Sólo dos ejemplos de dónde me gustaría probar un método privado:</target>
        </trans-unit>
        <trans-unit id="d4e47f0274a3c52708f822a10e289c3e99775b5d" translate="yes" xml:space="preserve">
          <source>Keep all methods small and focused (easy to test, easy to find what is wrong)</source>
          <target state="translated">Mantenga todos los métodos pequeños y enfocados (fácil de probar,fácil de encontrar lo que está mal)</target>
        </trans-unit>
        <trans-unit id="9adf46953726191943242b998a6a02cbbf4fca14" translate="yes" xml:space="preserve">
          <source>Mostly all that I wrote looks like it's a dependency injection pattern. In my personal experience it's really useful while testing, and I think that this kind of code is cleaner and will be easier to maintain. I'd say the same about nested classes. If a nested class contains heavy logic it would be better if you'd moved it as a package private class and have injected it into a class needing it.</source>
          <target state="translated">La mayoría de lo que escribí parece ser un patrón de inyección de dependencia.En mi experiencia personal es muy útil para las pruebas,y creo que este tipo de código es más limpio y será más fácil de mantener.Diría lo mismo sobre las clases anidadas.Si una clase anidada contiene lógica pesada,sería mejor si la movieras como una clase privada en paquete y la inyectaras en una clase que la necesite.</target>
        </trans-unit>
        <trans-unit id="30205722f087baf2291cb886209e83bbd9803fe4" translate="yes" xml:space="preserve">
          <source>My usual approach to addressing such issues is to tease out a new class that contains the interesting bits.  Often, this method and the fields it interacts with, and maybe another method or two can be extracted in to a new class.</source>
          <target state="translated">Mi enfoque habitual para abordar estos temas es sacar una nueva clase que contenga las partes interesantes.A menudo,este método y los campos con los que interactúa,y tal vez otro método o dos pueden ser extraídos en una nueva clase.</target>
        </trans-unit>
        <trans-unit id="2dc80e7fd583fd5394b42b7828b62bcf68608597" translate="yes" xml:space="preserve">
          <source>Note that I'm not suggesting that people create classes without using their brain! The point here is to use the forces of unit testing to help you find good new classes.</source>
          <target state="translated">¡Tengan en cuenta que no estoy sugiriendo que la gente cree clases sin usar su cerebro! El punto aquí es usar las fuerzas de las pruebas de la unidad para ayudarte a encontrar nuevas clases buenas.</target>
        </trans-unit>
        <trans-unit id="2fe26b2c16fe9cee75070a2fc030c171634bc7bf" translate="yes" xml:space="preserve">
          <source>Now about private methods. In my personal experience when you have to stub a private method for testing, then that method has nothing to do in that class. A common pattern, in that case, would be to &lt;em&gt;wrap&lt;/em&gt; it within an interface, like &lt;code&gt;Callable&lt;/code&gt; and then you pass in that interface also in the constructor (with that multiple constructor trick):</source>
          <target state="translated">Ahora sobre m&amp;eacute;todos privados. En mi experiencia personal, cuando tienes que tropezar con un m&amp;eacute;todo privado para la prueba, ese m&amp;eacute;todo no tiene nada que ver en esa clase. Un patr&amp;oacute;n com&amp;uacute;n, en ese caso, ser&amp;iacute;a &lt;em&gt;envolverlo&lt;/em&gt; dentro de una interfaz, como &lt;code&gt;Callable&lt;/code&gt; y luego pasar esa interfaz tambi&amp;eacute;n en el constructor (con ese truco de constructor m&amp;uacute;ltiple):</target>
        </trans-unit>
        <trans-unit id="777cc4ad4d28cf7c02b892fe5111983c770aebf9" translate="yes" xml:space="preserve">
          <source>Now you can directly pass the object which has the private method, method name to be called, and additional parameters as below.</source>
          <target state="translated">Ahora puede pasar directamente el objeto que tiene el método privado,el nombre del método a llamar y los parámetros adicionales como se indica a continuación.</target>
        </trans-unit>
        <trans-unit id="49a4661efd1819dad49a68ff125c5dfdef8c3ea9" translate="yes" xml:space="preserve">
          <source>P.S. I'm the main contributor to &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt;, ask &lt;a href=&quot;https://stackoverflow.com/users/300248&quot;&gt;me&lt;/a&gt; if you need help. :)</source>
          <target state="translated">PD: Soy el principal contribuyente a &lt;a href=&quot;http://dp4j.com&quot;&gt;Dp4j&lt;/a&gt; , preg&amp;uacute;ntame si necesitas ayuda. :)</target>
        </trans-unit>
        <trans-unit id="5f43d2331301eb02496c0c805bc3f87c3a2c7307" translate="yes" xml:space="preserve">
          <source>Please see below for an example;</source>
          <target state="translated">Por favor,vea abajo un ejemplo;</target>
        </trans-unit>
        <trans-unit id="5fe8c532739285df240daf07b928efebea907d0a" translate="yes" xml:space="preserve">
          <source>PowerMockito is made for this.
Use maven dependency</source>
          <target state="translated">PowerMockito está hecho para esto.Usa la dependencia de los hombres</target>
        </trans-unit>
        <trans-unit id="497baeb3b5ee74d2b4d986eb47ed0293a6ada2a0" translate="yes" xml:space="preserve">
          <source>Private methods are consumed by public ones. Otherwise, they're dead code. That's why you test the public method, asserting the expected results of the public method and thereby, the private methods it consumes.</source>
          <target state="translated">Los métodos privados son consumidos por los públicos.De lo contrario,son código muerto.Por eso se prueba el método público,afirmando los resultados esperados del método público y por lo tanto,los métodos privados que consume.</target>
        </trans-unit>
        <trans-unit id="83d6d608b54d120b904dee27b0513327bd8a3adc" translate="yes" xml:space="preserve">
          <source>Run the code coverage on the unit tests. If you see that methods are not fully tested add to the tests to get the coverage up. Aim for 100% code coverage, but realize that you probably won't get it.</source>
          <target state="translated">Ejecuta la cobertura del código en las pruebas de la unidad.Si ve que los métodos no están completamente probados,añada a las pruebas para aumentar la cobertura.Apunta a una cobertura de código del 100%,pero date cuenta de que probablemente no la obtendrás.</target>
        </trans-unit>
        <trans-unit id="f33de1aa1bafbeb284338b42c053c4ecb4dbcf05" translate="yes" xml:space="preserve">
          <source>See also: &lt;em&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/javatips/jw-javatip106.html&quot;&gt;Java Tip 106: Static inner classes for fun and profit&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">Ver tambi&amp;eacute;n: &lt;em&gt;&lt;a href=&quot;http://www.javaworld.com/javaworld/javatips/jw-javatip106.html&quot;&gt;Java Tip 106: Clases internas est&amp;aacute;ticas para diversi&amp;oacute;n y ganancias&lt;/a&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b710af9a932bb8b3407780d42ea95e9d3c2c9c68" translate="yes" xml:space="preserve">
          <source>Similarly with .class output files, they must remain within the same package as declared in source code</source>
          <target state="translated">De manera similar con los archivos de salida .class,deben permanecer dentro del mismo paquete declarado en el código fuente</target>
        </trans-unit>
        <trans-unit id="40ef678cea4286c297bccc879a9c3c11a47c9b03" translate="yes" xml:space="preserve">
          <source>So don't test private methods.</source>
          <target state="translated">Así que no pruebe los métodos privados.</target>
        </trans-unit>
        <trans-unit id="204733d7cb2b813d677976ecf1b798415058621d" translate="yes" xml:space="preserve">
          <source>So my tradeoff involves complicating the JUnits with reflection, rather than compromising my security &amp;amp; SDK.</source>
          <target state="translated">Entonces, mi compensaci&amp;oacute;n implica complicar los JUnits con la reflexi&amp;oacute;n, en lugar de comprometer mi seguridad y SDK.</target>
        </trans-unit>
        <trans-unit id="1dc726b4f0600a6162d0a5fec0ac442b107c4f85" translate="yes" xml:space="preserve">
          <source>Some 10 years later perhaps the best way to test a private method, or any inaccessible member, is via &lt;strong&gt;&lt;code&gt;@Jailbreak&lt;/code&gt;&lt;/strong&gt; from the &lt;a href=&quot;https://manifold.systems&quot;&gt;Manifold&lt;/a&gt; framework.</source>
          <target state="translated">Unos 10 a&amp;ntilde;os despu&amp;eacute;s, tal vez la mejor manera de probar un m&amp;eacute;todo privado, o cualquier miembro inaccesible, es a trav&amp;eacute;s de &lt;strong&gt; &lt;code&gt;@Jailbreak&lt;/code&gt; &lt;/strong&gt; desde el marco del &lt;a href=&quot;https://manifold.systems&quot;&gt;Manifold&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="93fcf1e45142f4bf2b769ec5b5d2448cc5a335d7" translate="yes" xml:space="preserve">
          <source>Strictly speaking, you should &lt;em&gt;not&lt;/em&gt; be writing unit tests that directly test private methods. What you &lt;em&gt;should&lt;/em&gt; be testing is the public contract that the class has with other objects; you should never directly test an object's internals. If another developer wants to make a small internal change to the class, which doesn't affect the classes public contract, he/she then has to modify your reflection based test to ensure that it works. If you do this repeatedly throughout a project, unit tests then stop being a useful measurement of code health, and start to become a hindrance to development, and an annoyance to the development team.</source>
          <target state="translated">Hablando estrictamente, &lt;em&gt;no&lt;/em&gt; debe escribir pruebas unitarias que prueben directamente m&amp;eacute;todos privados. Lo que &lt;em&gt;deber&amp;iacute;a&lt;/em&gt; probar es el contrato p&amp;uacute;blico que la clase tiene con otros objetos; nunca debe probar directamente las partes internas de un objeto. Si otro desarrollador quiere hacer un peque&amp;ntilde;o cambio interno en la clase, lo que no afecta el contrato p&amp;uacute;blico de las clases, entonces &amp;eacute;l / ella tiene que modificar su prueba basada en la reflexi&amp;oacute;n para asegurarse de que funcione. Si hace esto repetidamente durante un proyecto, las pruebas unitarias dejan de ser una medida &amp;uacute;til del estado del c&amp;oacute;digo y comienzan a convertirse en un obst&amp;aacute;culo para el desarrollo y una molestia para el equipo de desarrollo.</target>
        </trans-unit>
        <trans-unit id="e60b23b6cc258fd2f3050f01d48f369e96d22536" translate="yes" xml:space="preserve">
          <source>Test code must reside in the same
file as source code, which can be
more difficult to maintain</source>
          <target state="translated">El código de prueba debe residir en el mismo archivo que el código fuente,que puede ser más difícil de mantener</target>
        </trans-unit>
        <trans-unit id="e628bb4ef6d2f95c51a2e0fabdc7e6570882e841" translate="yes" xml:space="preserve">
          <source>Testing private methods breaks the encapsulation of your class because every time you change the internal implementation you break client code (in this case, the tests).</source>
          <target state="translated">Las pruebas de los métodos privados rompen el encapsulamiento de tu clase porque cada vez que cambias la implementación interna rompes el código del cliente (en este caso,las pruebas).</target>
        </trans-unit>
        <trans-unit id="b08d94828e924f3c44bdad7d49d7a9e8126f9b82" translate="yes" xml:space="preserve">
          <source>Testing private methods should be tested by debugging before running your unit tests on public methods.</source>
          <target state="translated">Los métodos privados deben probarse mediante la depuración antes de ejecutar las pruebas de la unidad en los métodos públicos.</target>
        </trans-unit>
        <trans-unit id="99ac885a2c04ce23f9e9dee57055ba4db55f0ba2" translate="yes" xml:space="preserve">
          <source>The answer from &lt;a href=&quot;http://junit.org/faq.html#atests_11&quot;&gt;JUnit.org FAQ page&lt;/a&gt;:</source>
          <target state="translated">La respuesta de la &lt;a href=&quot;http://junit.org/faq.html#atests_11&quot;&gt;p&amp;aacute;gina&lt;/a&gt; de preguntas frecuentes de JUnit.org :</target>
        </trans-unit>
        <trans-unit id="612f347cc8d13e68510dabfe438c3934b0e32ab6" translate="yes" xml:space="preserve">
          <source>The best way to test a private method is via another public method. If this cannot be done, then one of the following conditions is true:</source>
          <target state="translated">La mejor manera de probar un método privado es a través de otro método público.Si esto no se puede hacer,entonces una de las siguientes condiciones es cierta:</target>
        </trans-unit>
        <trans-unit id="bd734d3c315faa6945e06b553d5414ada763a534" translate="yes" xml:space="preserve">
          <source>The following import statement should be added:</source>
          <target state="translated">Debe añadirse la siguiente declaración de importación:</target>
        </trans-unit>
        <trans-unit id="85834fcc9380e9b0ac91e5af41b0a87baae505d9" translate="yes" xml:space="preserve">
          <source>The inner class would be compiled to &lt;code&gt;ClassToTest$StaticInnerTest&lt;/code&gt;.</source>
          <target state="translated">La clase interna se compilar&amp;iacute;a en &lt;code&gt;ClassToTest$StaticInnerTest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe9916a66d8aaef8076e5a9c5eb90320bb058a1d" translate="yes" xml:space="preserve">
          <source>The method that you are trying to test should not be private</source>
          <target state="translated">El método que está tratando de probar no debe ser privado</target>
        </trans-unit>
        <trans-unit id="9660255e33ec7d540aff4829d9d77f76b4f97dd1" translate="yes" xml:space="preserve">
          <source>The new class exposes these methods as 'public', so they're accessible for unit testing.  The new and old classes are now both simpler than the original class, which is great for me (I need to keep things simple, or I get lost!).</source>
          <target state="translated">La nueva clase expone estos métodos como &quot;públicos&quot;,por lo que son accesibles para las pruebas de la unidad.La nueva y la vieja clase son ahora más simples que la clase original,lo cual es genial para mí (necesito mantener las cosas simples,o me pierdo!).</target>
        </trans-unit>
        <trans-unit id="e7a5f083811631d013af462cec5f70ee62d8c80c" translate="yes" xml:space="preserve">
          <source>The private method is dead code</source>
          <target state="translated">El método privado es código muerto</target>
        </trans-unit>
        <trans-unit id="d4f0e9f95df601d6fc574b0d6b9281cadcdeb404" translate="yes" xml:space="preserve">
          <source>The private methods are called by a public method, so the inputs to your public methods should also test private methods that are called by those public methods. When a public method fails, then that could be a failure in the private method.</source>
          <target state="translated">Los métodos privados son llamados por un método público,por lo que las aportaciones a sus métodos públicos deben también probar los métodos privados que son llamados por esos métodos públicos.Cuando un método público falla,entonces eso podría ser un fallo en el método privado.</target>
        </trans-unit>
        <trans-unit id="e801c066ad4c06126ee0faa678e75d5b639e6837" translate="yes" xml:space="preserve">
          <source>Then you can do</source>
          <target state="translated">Entonces puedes hacer</target>
        </trans-unit>
        <trans-unit id="6810d88f67449ede60291b3105c90bd696c31a2a" translate="yes" xml:space="preserve">
          <source>There are also several other design patterns which I have used while refactoring and maintaining legacy code, but it all depends on cases of your code to test. Using reflection mostly is not a problem, but when you have an enterprise application which is heavily tested and tests are run before every deployment everything gets really slow (it's just annoying and I don't like that kind of stuff).</source>
          <target state="translated">También hay varios otros patrones de diseño que he utilizado al refactorizar y mantener el código heredado,pero todo depende de los casos de su código para probarlo.Usar la reflexión en su mayor parte no es un problema,pero cuando tienes una aplicación empresarial que está muy probada y se realizan pruebas antes de cada implementación todo se vuelve muy lento (es simplemente molesto y no me gusta ese tipo de cosas).</target>
        </trans-unit>
        <trans-unit id="e294098a8dfea7a5c3635278eddc4336d7bbca52" translate="yes" xml:space="preserve">
          <source>There is a design smell near the class that you are testing</source>
          <target state="translated">Hay un olor a diseño cerca de la clase que estás probando</target>
        </trans-unit>
        <trans-unit id="1961b3194f3eceb534220dec7cfd0658a13c79d1" translate="yes" xml:space="preserve">
          <source>There is also setter injection, but I wouldn't recommended using it. I'd better stick with a constructor and initialize everything when it's really necessary, leaving the possibility for injecting necessary dependencies.</source>
          <target state="translated">También hay una inyección de fijador,pero no recomendaría usarla.Mejor me quedo con un constructor e inicializo todo cuando es realmente necesario,dejando la posibilidad de inyectar las dependencias necesarias.</target>
        </trans-unit>
        <trans-unit id="a0630fa58840584312f8324a97af6d5961e771b5" translate="yes" xml:space="preserve">
          <source>There is possible merit in testing private methods of a class, particularly with &lt;a href=&quot;http://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;test-driven development&lt;/a&gt;, where you would like to design small tests before you write any code.</source>
          <target state="translated">Existe la posibilidad de probar m&amp;eacute;todos privados de una clase, particularmente con el &lt;a href=&quot;http://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;desarrollo basado en pruebas&lt;/a&gt; , en el que le gustar&amp;iacute;a dise&amp;ntilde;ar peque&amp;ntilde;as pruebas antes de escribir cualquier c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="086b75748a5099b73be65ec37188606e7a210e65" translate="yes" xml:space="preserve">
          <source>They may also be debugged using test-driven development, debugging your unit tests until all your assertions are met.</source>
          <target state="translated">También pueden ser depuradas mediante el desarrollo de pruebas,depurando sus pruebas de unidad hasta que se cumplan todas sus afirmaciones.</target>
        </trans-unit>
        <trans-unit id="0d7e7626c0f234d5a4b1eefebb7e04bb6f95324f" translate="yes" xml:space="preserve">
          <source>This way your code remains type-safe and readable.  No design compromises, no overexposing methods and fields for the sake of tests.</source>
          <target state="translated">De esta manera tu código permanece seguro y legible.Sin compromisos de diseño,sin sobreexponer los métodos y los campos por el bien de las pruebas.</target>
        </trans-unit>
        <trans-unit id="311f5e6a4e3dcb5323e8e594812c473e08551089" translate="yes" xml:space="preserve">
          <source>This will tell anybody using this method to take caution and not access it directly even in a package. Also a test class need not be in same package &lt;strong&gt;physically&lt;/strong&gt;, but in the same package under the &lt;strong&gt;test&lt;/strong&gt; folder.</source>
          <target state="translated">Esto le dir&amp;aacute; a cualquiera que use este m&amp;eacute;todo que tenga cuidado y no acceda directamente, incluso en un paquete. Adem&amp;aacute;s, una clase de prueba no necesita estar &lt;strong&gt;f&amp;iacute;sicamente&lt;/strong&gt; en el mismo paquete, sino en el mismo paquete bajo la carpeta de &lt;strong&gt;prueba&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="b8bb20e26f0bfdeceed068608989a507c169de4d" translate="yes" xml:space="preserve">
          <source>This won't be a problem even with some legacy code. Old code will be using an empty constructor, and if you ask me, refactored code will look cleaner, and you'll be able to inject necessary values in test without reflection.</source>
          <target state="translated">Esto no será un problema ni siquiera con algún código de legado.El código antiguo usará un constructor vacío,y si me preguntas,el código refactorizado se verá más limpio,y podrás inyectar los valores necesarios en la prueba sin reflejos.</target>
        </trans-unit>
        <trans-unit id="f55b0f7d6249aa7de09959544b0f0feda938a90d" translate="yes" xml:space="preserve">
          <source>To test legacy code with large and quirky classes, it is often very helpful to be able to test the one private (or public) method I'm writing &lt;em&gt;right now&lt;/em&gt;.</source>
          <target state="translated">Para probar el c&amp;oacute;digo heredado con clases grandes y extravagantes, a menudo es muy &amp;uacute;til poder probar el m&amp;eacute;todo privado (o p&amp;uacute;blico) que estoy escribiendo en &lt;em&gt;este momento&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="2dd43ad23f4bf7d3a51fa427ec672d9bd6a01af6" translate="yes" xml:space="preserve">
          <source>Today, I pushed a Java library to help testing private methods and fields. It has been designed with Android in mind, but it can really be used for any Java project.</source>
          <target state="translated">Hoy,impulsé una biblioteca de Java para ayudar a probar métodos y campos privados.Ha sido diseñada con Android en mente,pero realmente puede ser usada para cualquier proyecto de Java.</target>
        </trans-unit>
        <trans-unit id="34159cd5d97b03db44c72acff5f46f6a24c21c8c" translate="yes" xml:space="preserve">
          <source>Use a nested test class.</source>
          <target state="translated">Usa una clase de prueba anidada.</target>
        </trans-unit>
        <trans-unit id="f1e1383d50d27720fe116324eabd453138603022" translate="yes" xml:space="preserve">
          <source>Use code coverage tools. I like &lt;a href=&quot;http://cobertura.sourceforge.net/index.html&quot;&gt;Cobertura&lt;/a&gt; (oh happy day, looks like a new version is out!)</source>
          <target state="translated">Use herramientas de cobertura de c&amp;oacute;digo. Me gusta &lt;a href=&quot;http://cobertura.sourceforge.net/index.html&quot;&gt;Cobertura&lt;/a&gt; (&amp;iexcl;feliz d&amp;iacute;a, parece que ya sali&amp;oacute; una nueva versi&amp;oacute;n!)</target>
        </trans-unit>
        <trans-unit id="fa15115704d2ddf22825eb507327d9d92e328b27" translate="yes" xml:space="preserve">
          <source>Use reflection.</source>
          <target state="translated">Use la reflexión.</target>
        </trans-unit>
        <trans-unit id="0736ff73d779714c30c887cd895cba51ef05c5d2" translate="yes" xml:space="preserve">
          <source>What I recommend doing instead is using a code coverage tool such as Cobertura, to ensure that the unit tests you write provide decent coverage of the code in private methods. That way, you indirectly test what the private methods are doing, and maintain a higher level of agility.</source>
          <target state="translated">Lo que recomiendo hacer en su lugar es usar una herramienta de cobertura de código como Cobertura,para asegurar que las pruebas de la unidad que escribas proporcionen una cobertura decente del código en métodos privados.De esta manera,indirectamente se comprueba lo que los métodos privados están haciendo,y se mantiene un mayor nivel de agilidad.</target>
        </trans-unit>
        <trans-unit id="ee409982c9dae5ad88c914fa57f08415903fa09c" translate="yes" xml:space="preserve">
          <source>When I have private methods in a class that are sufficiently complicated that I feel the need to test the private methods directly, that is a code smell: my class is too complicated.</source>
          <target state="translated">Cuando tengo métodos privados en una clase que son lo suficientemente complicados como para sentir la necesidad de probar los métodos privados directamente,eso es un olor a código:mi clase es demasiado complicada.</target>
        </trans-unit>
        <trans-unit id="263c36a6dc28d5740e02d9585bf8aa9bcba9f12d" translate="yes" xml:space="preserve">
          <source>You mentioned different types of problems. Let's start with private fields. In case of private fields I would have added a new constructor and injected fields into that. Instead of this:</source>
          <target state="translated">Mencionó diferentes tipos de problemas.Empecemos con los campos privados.En el caso de los campos privados habría añadido un nuevo constructor e inyectado campos en él.En lugar de esto:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
